{"buggy_code": ["/*****************************************************************\n|\n|    AP4 - Atom Based Sample Tables\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This atom is part of AP4 (MP4 Audio Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the atom COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n ****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AtomSampleTable.h\"\n#include \"Ap4ByteStream.h\"\n#include \"Ap4StsdAtom.h\"\n#include \"Ap4StscAtom.h\"\n#include \"Ap4StcoAtom.h\"\n#include \"Ap4Co64Atom.h\"\n#include \"Ap4StszAtom.h\"\n#include \"Ap4Stz2Atom.h\"\n#include \"Ap4SttsAtom.h\"\n#include \"Ap4CttsAtom.h\"\n#include \"Ap4StssAtom.h\"\n#include \"Ap4Sample.h\"\n#include \"Ap4Atom.h\"\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable Dynamic Cast Anchor\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AtomSampleTable)\n\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::AP4_AtomSampleTable(AP4_ContainerAtom* stbl, \n                                         AP4_ByteStream&    sample_stream) :\n    m_SampleStream(sample_stream)\n{\n    m_StscAtom = AP4_DYNAMIC_CAST(AP4_StscAtom, stbl->GetChild(AP4_ATOM_TYPE_STSC));\n    m_StcoAtom = AP4_DYNAMIC_CAST(AP4_StcoAtom, stbl->GetChild(AP4_ATOM_TYPE_STCO));\n    m_StszAtom = AP4_DYNAMIC_CAST(AP4_StszAtom, stbl->GetChild(AP4_ATOM_TYPE_STSZ));\n    m_Stz2Atom = AP4_DYNAMIC_CAST(AP4_Stz2Atom, stbl->GetChild(AP4_ATOM_TYPE_STZ2));\n    m_CttsAtom = AP4_DYNAMIC_CAST(AP4_CttsAtom, stbl->GetChild(AP4_ATOM_TYPE_CTTS));\n    m_SttsAtom = AP4_DYNAMIC_CAST(AP4_SttsAtom, stbl->GetChild(AP4_ATOM_TYPE_STTS));\n    m_StssAtom = AP4_DYNAMIC_CAST(AP4_StssAtom, stbl->GetChild(AP4_ATOM_TYPE_STSS));\n    m_StsdAtom = AP4_DYNAMIC_CAST(AP4_StsdAtom, stbl->GetChild(AP4_ATOM_TYPE_STSD));\n    m_Co64Atom = AP4_DYNAMIC_CAST(AP4_Co64Atom, stbl->GetChild(AP4_ATOM_TYPE_CO64));\n\n    // keep a reference to the sample stream\n    m_SampleStream.AddReference();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::~AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::~AP4_AtomSampleTable()\n{\n    m_SampleStream.Release();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSample\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleCount()\n{\n    if (m_StszAtom) {\n        return m_StszAtom->GetSampleCount();\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->GetSampleCount();\n    } else {\n        return 0;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescription\n+---------------------------------------------------------------------*/\nAP4_SampleDescription*\nAP4_AtomSampleTable::GetSampleDescription(AP4_Ordinal index)\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescription(index) : NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescriptionCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleDescriptionCount()\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescriptionCount() : 0;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleChunkPosition\n+---------------------------------------------------------------------*/\nAP4_Result   \nAP4_AtomSampleTable::GetSampleChunkPosition(AP4_Ordinal  sample_index, \n                                            AP4_Ordinal& chunk_index,\n                                            AP4_Ordinal& position_in_chunk)\n{\n    // default values\n    chunk_index       = 0;\n    position_in_chunk = 0;\n    \n    AP4_Ordinal sample_description_index;\n    return GetChunkForSample(sample_index, \n                             chunk_index, \n                             position_in_chunk, \n                             sample_description_index);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkForSample\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkForSample(AP4_Ordinal  sample_index,\n                                       AP4_Ordinal& chunk_index,\n                                       AP4_Ordinal& position_in_chunk,\n                                       AP4_Ordinal& sample_description_index)\n{\n    // default values\n    chunk_index              = 0;\n    position_in_chunk        = 0;\n    sample_description_index = 0;\n\n    // check that we an stsc atom\n    if (m_StscAtom == NULL) return AP4_ERROR_INVALID_STATE;\n    \n    // get the chunk info from the stsc atom\n    AP4_Ordinal chunk = 0;\n    AP4_Result result = m_StscAtom->GetChunkForSample(sample_index+1, // the atom API is 1-based \n                                                      chunk, \n                                                      position_in_chunk, \n                                                      sample_description_index);\n    if (AP4_FAILED(result)) return result;\n    if (chunk == 0) return AP4_ERROR_INTERNAL;\n\n    // the atom sample and chunk indexes are 1-based, so we need to translate\n    chunk_index = chunk-1;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkOffset(AP4_Ordinal   chunk_index, \n                                    AP4_Position& offset)\n{\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        AP4_Result result = m_StcoAtom->GetChunkOffset(chunk_index+1, offset_32);\n        if (AP4_SUCCEEDED(result)) {\n            offset = offset_32;\n        } else {\n            offset = 0;\n        }\n        return result;\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->GetChunkOffset(chunk_index+1, offset);\n    } else {\n        offset = 0;\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetChunkOffset(AP4_Ordinal  chunk_index, \n                                    AP4_Position offset)\n{\n    if (m_StcoAtom) {\n        if ((offset >> 32) != 0) return AP4_ERROR_OUT_OF_RANGE;\n        return m_StcoAtom->SetChunkOffset(chunk_index+1, (AP4_UI32)offset);\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->SetChunkOffset(chunk_index+1, offset);\n    } else {\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetSampleSize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetSampleSize(AP4_Ordinal sample_index, AP4_Size size)\n{\n    if (m_StszAtom) {\n        return m_StszAtom->SetSampleSize(sample_index+1, size);\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->SetSampleSize(sample_index+1, size);\n    } else {    \n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleIndexForTimeStamp\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetSampleIndexForTimeStamp(AP4_UI64     ts, \n                                                AP4_Ordinal& sample_index)\n{\n    return m_SttsAtom ? m_SttsAtom->GetSampleIndexForTimeStamp(ts, sample_index) \n                      : AP4_FAILURE;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetNearestSyncSampleIndex\n+---------------------------------------------------------------------*/\nAP4_Ordinal  \nAP4_AtomSampleTable::GetNearestSyncSampleIndex(AP4_Ordinal sample_index, bool before)\n{\n    // if we don't have an stss table, all samples match\n    if (m_StssAtom == NULL) return sample_index;\n    \n    sample_index += 1; // the table is 1-based\n    AP4_Cardinal entry_count = m_StssAtom->GetEntries().ItemCount();\n    if (before) {\n        AP4_Ordinal cursor = 0;    \n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) return cursor;\n            if (m_StssAtom->GetEntries()[i]) cursor = m_StssAtom->GetEntries()[i]-1;\n        }\n\n        // not found?\n        return cursor;\n    } else {\n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) {\n                return m_StssAtom->GetEntries()[i]?m_StssAtom->GetEntries()[i]-1:sample_index-1;\n            }\n        }\n\n        // not found?\n        return GetSampleCount();\n    }\n}\n\n"], "fixing_code": ["/*****************************************************************\n|\n|    AP4 - Atom Based Sample Tables\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This atom is part of AP4 (MP4 Audio Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the atom COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n ****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AtomSampleTable.h\"\n#include \"Ap4ByteStream.h\"\n#include \"Ap4StsdAtom.h\"\n#include \"Ap4StscAtom.h\"\n#include \"Ap4StcoAtom.h\"\n#include \"Ap4Co64Atom.h\"\n#include \"Ap4StszAtom.h\"\n#include \"Ap4Stz2Atom.h\"\n#include \"Ap4SttsAtom.h\"\n#include \"Ap4CttsAtom.h\"\n#include \"Ap4StssAtom.h\"\n#include \"Ap4Sample.h\"\n#include \"Ap4Atom.h\"\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable Dynamic Cast Anchor\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AtomSampleTable)\n\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::AP4_AtomSampleTable(AP4_ContainerAtom* stbl, \n                                         AP4_ByteStream&    sample_stream) :\n    m_SampleStream(sample_stream)\n{\n    m_StscAtom = AP4_DYNAMIC_CAST(AP4_StscAtom, stbl->GetChild(AP4_ATOM_TYPE_STSC));\n    m_StcoAtom = AP4_DYNAMIC_CAST(AP4_StcoAtom, stbl->GetChild(AP4_ATOM_TYPE_STCO));\n    m_StszAtom = AP4_DYNAMIC_CAST(AP4_StszAtom, stbl->GetChild(AP4_ATOM_TYPE_STSZ));\n    m_Stz2Atom = AP4_DYNAMIC_CAST(AP4_Stz2Atom, stbl->GetChild(AP4_ATOM_TYPE_STZ2));\n    m_CttsAtom = AP4_DYNAMIC_CAST(AP4_CttsAtom, stbl->GetChild(AP4_ATOM_TYPE_CTTS));\n    m_SttsAtom = AP4_DYNAMIC_CAST(AP4_SttsAtom, stbl->GetChild(AP4_ATOM_TYPE_STTS));\n    m_StssAtom = AP4_DYNAMIC_CAST(AP4_StssAtom, stbl->GetChild(AP4_ATOM_TYPE_STSS));\n    m_StsdAtom = AP4_DYNAMIC_CAST(AP4_StsdAtom, stbl->GetChild(AP4_ATOM_TYPE_STSD));\n    m_Co64Atom = AP4_DYNAMIC_CAST(AP4_Co64Atom, stbl->GetChild(AP4_ATOM_TYPE_CO64));\n\n    // keep a reference to the sample stream\n    m_SampleStream.AddReference();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::~AP4_AtomSampleTable\n+---------------------------------------------------------------------*/\nAP4_AtomSampleTable::~AP4_AtomSampleTable()\n{\n    m_SampleStream.Release();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSample\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    if (m_SttsAtom) {\n        result = m_SttsAtom->GetDts(index, dts, &duration);\n        if (AP4_FAILED(result)) return result;\n    }\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleCount()\n{\n    if (m_StszAtom) {\n        return m_StszAtom->GetSampleCount();\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->GetSampleCount();\n    } else {\n        return 0;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescription\n+---------------------------------------------------------------------*/\nAP4_SampleDescription*\nAP4_AtomSampleTable::GetSampleDescription(AP4_Ordinal index)\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescription(index) : NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleDescriptionCount\n+---------------------------------------------------------------------*/\nAP4_Cardinal\nAP4_AtomSampleTable::GetSampleDescriptionCount()\n{\n    return m_StsdAtom ? m_StsdAtom->GetSampleDescriptionCount() : 0;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleChunkPosition\n+---------------------------------------------------------------------*/\nAP4_Result   \nAP4_AtomSampleTable::GetSampleChunkPosition(AP4_Ordinal  sample_index, \n                                            AP4_Ordinal& chunk_index,\n                                            AP4_Ordinal& position_in_chunk)\n{\n    // default values\n    chunk_index       = 0;\n    position_in_chunk = 0;\n    \n    AP4_Ordinal sample_description_index;\n    return GetChunkForSample(sample_index, \n                             chunk_index, \n                             position_in_chunk, \n                             sample_description_index);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkForSample\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkForSample(AP4_Ordinal  sample_index,\n                                       AP4_Ordinal& chunk_index,\n                                       AP4_Ordinal& position_in_chunk,\n                                       AP4_Ordinal& sample_description_index)\n{\n    // default values\n    chunk_index              = 0;\n    position_in_chunk        = 0;\n    sample_description_index = 0;\n\n    // check that we an stsc atom\n    if (m_StscAtom == NULL) return AP4_ERROR_INVALID_STATE;\n    \n    // get the chunk info from the stsc atom\n    AP4_Ordinal chunk = 0;\n    AP4_Result result = m_StscAtom->GetChunkForSample(sample_index+1, // the atom API is 1-based \n                                                      chunk, \n                                                      position_in_chunk, \n                                                      sample_description_index);\n    if (AP4_FAILED(result)) return result;\n    if (chunk == 0) return AP4_ERROR_INTERNAL;\n\n    // the atom sample and chunk indexes are 1-based, so we need to translate\n    chunk_index = chunk-1;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetChunkOffset(AP4_Ordinal   chunk_index, \n                                    AP4_Position& offset)\n{\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        AP4_Result result = m_StcoAtom->GetChunkOffset(chunk_index+1, offset_32);\n        if (AP4_SUCCEEDED(result)) {\n            offset = offset_32;\n        } else {\n            offset = 0;\n        }\n        return result;\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->GetChunkOffset(chunk_index+1, offset);\n    } else {\n        offset = 0;\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetChunkOffset\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetChunkOffset(AP4_Ordinal  chunk_index, \n                                    AP4_Position offset)\n{\n    if (m_StcoAtom) {\n        if ((offset >> 32) != 0) return AP4_ERROR_OUT_OF_RANGE;\n        return m_StcoAtom->SetChunkOffset(chunk_index+1, (AP4_UI32)offset);\n    } else if (m_Co64Atom) {\n        return m_Co64Atom->SetChunkOffset(chunk_index+1, offset);\n    } else {\n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::SetSampleSize\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::SetSampleSize(AP4_Ordinal sample_index, AP4_Size size)\n{\n    if (m_StszAtom) {\n        return m_StszAtom->SetSampleSize(sample_index+1, size);\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom->SetSampleSize(sample_index+1, size);\n    } else {    \n        return AP4_FAILURE;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetSampleIndexForTimeStamp\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_AtomSampleTable::GetSampleIndexForTimeStamp(AP4_UI64     ts, \n                                                AP4_Ordinal& sample_index)\n{\n    return m_SttsAtom ? m_SttsAtom->GetSampleIndexForTimeStamp(ts, sample_index) \n                      : AP4_FAILURE;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomSampleTable::GetNearestSyncSampleIndex\n+---------------------------------------------------------------------*/\nAP4_Ordinal  \nAP4_AtomSampleTable::GetNearestSyncSampleIndex(AP4_Ordinal sample_index, bool before)\n{\n    // if we don't have an stss table, all samples match\n    if (m_StssAtom == NULL) return sample_index;\n    \n    sample_index += 1; // the table is 1-based\n    AP4_Cardinal entry_count = m_StssAtom->GetEntries().ItemCount();\n    if (before) {\n        AP4_Ordinal cursor = 0;    \n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) return cursor;\n            if (m_StssAtom->GetEntries()[i]) cursor = m_StssAtom->GetEntries()[i]-1;\n        }\n\n        // not found?\n        return cursor;\n    } else {\n        for (unsigned int i=0; i<entry_count; i++) {\n            if (m_StssAtom->GetEntries()[i] >= sample_index) {\n                return m_StssAtom->GetEntries()[i]?m_StssAtom->GetEntries()[i]-1:sample_index-1;\n            }\n        }\n\n        // not found?\n        return GetSampleCount();\n    }\n}\n\n"], "filenames": ["Source/C++/Core/Ap4AtomSampleTable.cpp"], "buggy_code_start_loc": [143], "buggy_code_end_loc": [145], "fixing_code_start_loc": [143], "fixing_code_end_loc": [147], "type": "CWE-476", "message": "A NULL pointer dereference was discovered in AP4_AtomSampleTable::GetSample in Core/Ap4AtomSampleTable.cpp in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash, which leads to remote denial of service.", "other": {"cve": {"id": "CVE-2017-14640", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-21T17:29:00.230", "lastModified": "2017-09-28T16:16:15.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference was discovered in AP4_AtomSampleTable::GetSample in Core/Ap4AtomSampleTable.cpp in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash, which leads to remote denial of service."}, {"lang": "es", "value": "Existe una desreferencia de puntero NULL en AP4_AtomSampleTable::GetSample en Core/Ap4AtomSampleTable.cpp en Bento4 1.5.0-617. Esta vulnerabilidad causa un error de segmentaci\u00f3n y el cierre inesperado de la aplicaci\u00f3n, lo que da lugar a una denegaci\u00f3n de servicio remota."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bento4:bento4:1.5.0-617:*:*:*:*:*:*:*", "matchCriteriaId": "E91AC306-5354-4B0C-B481-CBA451648D90"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/09/14/bento4-null-pointer-dereference-in-ap4_atomsampletablegetsample-ap4atomsampletable-cpp/", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/axiomatic-systems/Bento4/commit/2f267f89f957088197f4b1fc254632d1645b415d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/axiomatic-systems/Bento4/issues/183", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/axiomatic-systems/Bento4/commit/2f267f89f957088197f4b1fc254632d1645b415d"}}