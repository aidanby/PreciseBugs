{"buggy_code": ["/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/record/PlaintextRecordLayer.h>\n\n#include <folly/String.h>\n\nnamespace fizz {\n\nusing ContentTypeType = typename std::underlying_type<ContentType>::type;\nusing ProtocolVersionType =\n    typename std::underlying_type<ProtocolVersion>::type;\n\nstatic constexpr uint16_t kMaxPlaintextRecordSize = 0x4000; // 16k\nstatic constexpr size_t kPlaintextHeaderSize =\n    sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n\nfolly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n\n    cursor.clone(msg.fragment, length);\n\n    buf.trimStart(cursor - buf.front());\n\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n\n    return std::move(msg);\n  }\n}\n\nEncryptionLevel PlaintextReadRecordLayer::getEncryptionLevel() const {\n  return EncryptionLevel::Plaintext;\n}\n\nTLSContent PlaintextWriteRecordLayer::write(TLSMessage&& msg) const {\n  return write(std::move(msg), ProtocolVersion::tls_1_2);\n}\n\nTLSContent PlaintextWriteRecordLayer::writeInitialClientHello(\n    Buf encodedClientHello) const {\n  return write(\n      TLSMessage{ContentType::handshake, std::move(encodedClientHello)},\n      ProtocolVersion::tls_1_0);\n}\n\nTLSContent PlaintextWriteRecordLayer::write(\n    TLSMessage msg,\n    ProtocolVersion recordVersion) const {\n  if (msg.type == ContentType::application_data) {\n    throw std::runtime_error(\"refusing to send plaintext application data\");\n  }\n\n  auto fragment = std::move(msg.fragment);\n  folly::io::Cursor cursor(fragment.get());\n  std::unique_ptr<folly::IOBuf> data;\n  while (!cursor.isAtEnd()) {\n    Buf thisFragment;\n    auto len = cursor.cloneAtMost(thisFragment, kMaxPlaintextRecordSize);\n\n    auto header = folly::IOBuf::create(kPlaintextHeaderSize);\n    folly::io::Appender appender(header.get(), kPlaintextHeaderSize);\n    appender.writeBE(static_cast<ContentTypeType>(msg.type));\n    appender.writeBE(static_cast<ProtocolVersionType>(recordVersion));\n    appender.writeBE<uint16_t>(len);\n\n    if (!data) {\n      data = std::move(header);\n    } else {\n      data->prependChain(std::move(header));\n    }\n    data->prependChain(std::move(thisFragment));\n  }\n  TLSContent content;\n  content.data = std::move(data);\n  content.contentType = msg.type;\n  content.encryptionLevel = EncryptionLevel::Plaintext;\n  return content;\n}\n\nEncryptionLevel PlaintextWriteRecordLayer::getEncryptionLevel() const {\n  return EncryptionLevel::Plaintext;\n}\n} // namespace fizz\n", "/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <folly/portability/GMock.h>\n#include <folly/portability/GTest.h>\n\n#include <fizz/record/PlaintextRecordLayer.h>\n\n#include <folly/String.h>\n\nusing namespace folly;\nusing namespace folly::io;\n\nusing testing::_;\nusing namespace testing;\n\nnamespace fizz {\nnamespace test {\n\nclass PlaintextRecordTest : public testing::Test {\n protected:\n  PlaintextReadRecordLayer read_;\n  PlaintextWriteRecordLayer write_;\n\n  IOBufQueue queue_{IOBufQueue::cacheChainLength()};\n\n  IOBufEqualTo eq_;\n\n  Buf getBuf(const std::string& hex) {\n    auto data = unhexlify(hex);\n    return IOBuf::copyBuffer(data.data(), data.size());\n  }\n\n  void addToQueue(const std::string& hex) {\n    queue_.append(getBuf(hex));\n  }\n\n  void expectSame(const Buf& buf, const std::string& hex) {\n    auto str = buf->moveToFbString().toStdString();\n    EXPECT_EQ(hexlify(str), hex);\n  }\n};\n\nTEST_F(PlaintextRecordTest, TestReadEmpty) {\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n}\n\nTEST_F(PlaintextRecordTest, TestReadHandshake) {\n  addToQueue(\"16030100050123456789\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::handshake);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestReadAlert) {\n  addToQueue(\"15030100050123456789\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::alert);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestReadAppData) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_ANY_THROW(read_.read(queue_));\n}\n\nTEST_F(PlaintextRecordTest, TestWaitForData) {\n  addToQueue(\"160301000512345678\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_EQ(queue_.chainLength(), 9);\n}\n\nTEST_F(PlaintextRecordTest, TestWaitForHeader) {\n  addToQueue(\"16030102\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_EQ(queue_.chainLength(), 4);\n}\n\nTEST_F(PlaintextRecordTest, TestMaxSize) {\n  addToQueue(\"1603014000\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_EQ(queue_.chainLength(), 5);\n}\n\nTEST_F(PlaintextRecordTest, TestOverSize) {\n  addToQueue(\"1603014001\");\n  EXPECT_ANY_THROW(read_.read(queue_));\n}\n\nTEST_F(PlaintextRecordTest, TestEmpty) {\n  addToQueue(\"1603010000aa\");\n  EXPECT_ANY_THROW(read_.read(queue_));\n}\n\nTEST_F(PlaintextRecordTest, TestDataRemaining) {\n  addToQueue(\"16030100050123456789160301\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::handshake);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_EQ(queue_.chainLength(), 3);\n  expectSame(queue_.move(), \"160301\");\n}\n\nTEST_F(PlaintextRecordTest, TestSkipAndWait) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"17030100050123456789\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestWaitBeforeSkip) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301000501234567\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  expectSame(queue_.move(), \"170301000501234567\");\n}\n\nTEST_F(PlaintextRecordTest, TestSkipAndRead) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301000501234567891703010005012345678916030100050123456789\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::handshake);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestWriteHandshake) {\n  TLSMessage msg{ContentType::handshake, getBuf(\"1234567890\")};\n  auto buf = write_.write(std::move(msg));\n  expectSame(buf.data, \"16030300051234567890\");\n}\n\nTEST_F(PlaintextRecordTest, TestWriteClientHello) {\n  auto buf = write_.writeInitialClientHello(getBuf(\"1234567890\"));\n  expectSame(buf.data, \"16030100051234567890\");\n}\n\nTEST_F(PlaintextRecordTest, TestWriteAppData) {\n  TLSMessage msg{ContentType::application_data};\n  EXPECT_ANY_THROW(write_.write(std::move(msg)));\n}\n\nTEST_F(PlaintextRecordTest, TestFragmentedWrite) {\n  TLSMessage msg{ContentType::handshake, IOBuf::create(0)};\n  auto buf = IOBuf::create(0x4010);\n  buf->append(0x4010);\n  memset(buf->writableData(), 0x1, buf->length());\n  msg.fragment->prependChain(std::move(buf));\n  auto write = write_.write(std::move(msg));\n\n  TLSMessage msg1{ContentType::handshake, IOBuf::create(0)};\n  buf = IOBuf::create(0x4000);\n  buf->append(0x4000);\n  memset(buf->writableData(), 0x1, buf->length());\n  msg1.fragment->prependChain(std::move(buf));\n  auto write1 = write_.write(std::move(msg1));\n\n  TLSMessage msg2{ContentType::handshake, IOBuf::create(0)};\n  buf = IOBuf::create(0x10);\n  buf->append(0x10);\n  memset(buf->writableData(), 0x1, buf->length());\n  msg2.fragment->prependChain(std::move(buf));\n  auto write2 = write_.write(std::move(msg2));\n\n  write1.data->prependChain(std::move(write2.data));\n  IOBufEqualTo eq;\n  EXPECT_TRUE(eq(write.data, write1.data));\n}\n} // namespace test\n} // namespace fizz\n"], "fixing_code": ["/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/record/PlaintextRecordLayer.h>\n\n#include <folly/String.h>\n\nnamespace fizz {\n\nusing ContentTypeType = typename std::underlying_type<ContentType>::type;\nusing ProtocolVersionType =\n    typename std::underlying_type<ProtocolVersion>::type;\n\nstatic constexpr uint16_t kMaxPlaintextRecordSize = 0x4000; // 16k\nstatic constexpr size_t kPlaintextHeaderSize =\n    sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n\nfolly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        buf.trimStart(static_cast<size_t>(kPlaintextHeaderSize) + length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n\n    cursor.clone(msg.fragment, length);\n\n    buf.trimStart(cursor - buf.front());\n\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n\n    return std::move(msg);\n  }\n}\n\nEncryptionLevel PlaintextReadRecordLayer::getEncryptionLevel() const {\n  return EncryptionLevel::Plaintext;\n}\n\nTLSContent PlaintextWriteRecordLayer::write(TLSMessage&& msg) const {\n  return write(std::move(msg), ProtocolVersion::tls_1_2);\n}\n\nTLSContent PlaintextWriteRecordLayer::writeInitialClientHello(\n    Buf encodedClientHello) const {\n  return write(\n      TLSMessage{ContentType::handshake, std::move(encodedClientHello)},\n      ProtocolVersion::tls_1_0);\n}\n\nTLSContent PlaintextWriteRecordLayer::write(\n    TLSMessage msg,\n    ProtocolVersion recordVersion) const {\n  if (msg.type == ContentType::application_data) {\n    throw std::runtime_error(\"refusing to send plaintext application data\");\n  }\n\n  auto fragment = std::move(msg.fragment);\n  folly::io::Cursor cursor(fragment.get());\n  std::unique_ptr<folly::IOBuf> data;\n  while (!cursor.isAtEnd()) {\n    Buf thisFragment;\n    auto len = cursor.cloneAtMost(thisFragment, kMaxPlaintextRecordSize);\n\n    auto header = folly::IOBuf::create(kPlaintextHeaderSize);\n    folly::io::Appender appender(header.get(), kPlaintextHeaderSize);\n    appender.writeBE(static_cast<ContentTypeType>(msg.type));\n    appender.writeBE(static_cast<ProtocolVersionType>(recordVersion));\n    appender.writeBE<uint16_t>(len);\n\n    if (!data) {\n      data = std::move(header);\n    } else {\n      data->prependChain(std::move(header));\n    }\n    data->prependChain(std::move(thisFragment));\n  }\n  TLSContent content;\n  content.data = std::move(data);\n  content.contentType = msg.type;\n  content.encryptionLevel = EncryptionLevel::Plaintext;\n  return content;\n}\n\nEncryptionLevel PlaintextWriteRecordLayer::getEncryptionLevel() const {\n  return EncryptionLevel::Plaintext;\n}\n} // namespace fizz\n", "/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <folly/portability/GMock.h>\n#include <folly/portability/GTest.h>\n\n#include <fizz/record/PlaintextRecordLayer.h>\n\n#include <folly/String.h>\n\nusing namespace folly;\nusing namespace folly::io;\n\nusing testing::_;\nusing namespace testing;\n\nnamespace fizz {\nnamespace test {\n\nclass PlaintextRecordTest : public testing::Test {\n protected:\n  PlaintextReadRecordLayer read_;\n  PlaintextWriteRecordLayer write_;\n\n  IOBufQueue queue_{IOBufQueue::cacheChainLength()};\n\n  IOBufEqualTo eq_;\n\n  Buf getBuf(const std::string& hex) {\n    auto data = unhexlify(hex);\n    return IOBuf::copyBuffer(data.data(), data.size());\n  }\n\n  void addToQueue(const std::string& hex) {\n    queue_.append(getBuf(hex));\n  }\n\n  void expectSame(const Buf& buf, const std::string& hex) {\n    auto str = buf->moveToFbString().toStdString();\n    EXPECT_EQ(hexlify(str), hex);\n  }\n};\n\nTEST_F(PlaintextRecordTest, TestReadEmpty) {\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n}\n\nTEST_F(PlaintextRecordTest, TestReadHandshake) {\n  addToQueue(\"16030100050123456789\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::handshake);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestReadAlert) {\n  addToQueue(\"15030100050123456789\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::alert);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestReadAppData) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_ANY_THROW(read_.read(queue_));\n}\n\nTEST_F(PlaintextRecordTest, TestWaitForData) {\n  addToQueue(\"160301000512345678\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_EQ(queue_.chainLength(), 9);\n}\n\nTEST_F(PlaintextRecordTest, TestWaitForHeader) {\n  addToQueue(\"16030102\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_EQ(queue_.chainLength(), 4);\n}\n\nTEST_F(PlaintextRecordTest, TestMaxSize) {\n  addToQueue(\"1603014000\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_EQ(queue_.chainLength(), 5);\n}\n\nTEST_F(PlaintextRecordTest, TestOverSize) {\n  addToQueue(\"1603014001\");\n  EXPECT_ANY_THROW(read_.read(queue_));\n}\n\nTEST_F(PlaintextRecordTest, TestEmpty) {\n  addToQueue(\"1603010000aa\");\n  EXPECT_ANY_THROW(read_.read(queue_));\n}\n\nTEST_F(PlaintextRecordTest, TestDataRemaining) {\n  addToQueue(\"16030100050123456789160301\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::handshake);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_EQ(queue_.chainLength(), 3);\n  expectSame(queue_.move(), \"160301\");\n}\n\nTEST_F(PlaintextRecordTest, TestSkipAndWait) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"17030100050123456789\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestSkipOversizedRecord) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301fffb\");\n  auto longBuf = IOBuf::create(0xfffb);\n  longBuf->append(0xfffb);\n  queue_.append(std::move(longBuf));\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestWaitBeforeSkip) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301000501234567\");\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  expectSame(queue_.move(), \"170301000501234567\");\n}\n\nTEST_F(PlaintextRecordTest, TestSkipAndRead) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301000501234567891703010005012345678916030100050123456789\");\n  auto msg = read_.read(queue_);\n  EXPECT_EQ(msg->type, ContentType::handshake);\n  expectSame(msg->fragment, \"0123456789\");\n  EXPECT_TRUE(queue_.empty());\n}\n\nTEST_F(PlaintextRecordTest, TestWriteHandshake) {\n  TLSMessage msg{ContentType::handshake, getBuf(\"1234567890\")};\n  auto buf = write_.write(std::move(msg));\n  expectSame(buf.data, \"16030300051234567890\");\n}\n\nTEST_F(PlaintextRecordTest, TestWriteClientHello) {\n  auto buf = write_.writeInitialClientHello(getBuf(\"1234567890\"));\n  expectSame(buf.data, \"16030100051234567890\");\n}\n\nTEST_F(PlaintextRecordTest, TestWriteAppData) {\n  TLSMessage msg{ContentType::application_data};\n  EXPECT_ANY_THROW(write_.write(std::move(msg)));\n}\n\nTEST_F(PlaintextRecordTest, TestFragmentedWrite) {\n  TLSMessage msg{ContentType::handshake, IOBuf::create(0)};\n  auto buf = IOBuf::create(0x4010);\n  buf->append(0x4010);\n  memset(buf->writableData(), 0x1, buf->length());\n  msg.fragment->prependChain(std::move(buf));\n  auto write = write_.write(std::move(msg));\n\n  TLSMessage msg1{ContentType::handshake, IOBuf::create(0)};\n  buf = IOBuf::create(0x4000);\n  buf->append(0x4000);\n  memset(buf->writableData(), 0x1, buf->length());\n  msg1.fragment->prependChain(std::move(buf));\n  auto write1 = write_.write(std::move(msg1));\n\n  TLSMessage msg2{ContentType::handshake, IOBuf::create(0)};\n  buf = IOBuf::create(0x10);\n  buf->append(0x10);\n  memset(buf->writableData(), 0x1, buf->length());\n  msg2.fragment->prependChain(std::move(buf));\n  auto write2 = write_.write(std::move(msg2));\n\n  write1.data->prependChain(std::move(write2.data));\n  IOBufEqualTo eq;\n  EXPECT_TRUE(eq(write.data, write1.data));\n}\n} // namespace test\n} // namespace fizz\n"], "filenames": ["fizz/record/PlaintextRecordLayer.cpp", "fizz/record/test/PlaintextRecordTest.cpp"], "buggy_code_start_loc": [42, 117], "buggy_code_end_loc": [45, 117], "fixing_code_start_loc": [42, 118], "fixing_code_end_loc": [43, 128], "type": "CWE-131", "message": "An improperly performed length calculation on a buffer in PlaintextRecordLayer could lead to an infinite loop and denial-of-service based on user input. This issue affected versions of fizz prior to v2019.03.04.00.", "other": {"cve": {"id": "CVE-2019-3560", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-04-29T16:29:00.813", "lastModified": "2023-06-12T07:15:12.343", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An improperly performed length calculation on a buffer in PlaintextRecordLayer could lead to an infinite loop and denial-of-service based on user input. This issue affected versions of fizz prior to v2019.03.04.00."}, {"lang": "es", "value": "Un c\u00e1lculo de longitud realizado incorrectamente en un b\u00fafer en PlaintextRecordLayer podr\u00eda conducir a un bucle infinito y a una denegaci\u00f3n de servicio basada en la entrada del usuario. Este problema afectaba a las versiones de fizz anteriores a la v2019.03.04.00."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-131"}, {"lang": "en", "value": "CWE-835"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:fizz:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.03.04.00", "matchCriteriaId": "E50495AD-BBBB-4821-BC00-150DC6980C2D"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/172836/polkit-Authentication-Bypass.html", "source": "cve-assign@fb.com"}, {"url": "https://github.com/facebookincubator/fizz/commit/40bbb161e72fb609608d53b9d64c56bb961a6ee2", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebookincubator/fizz/commit/40bbb161e72fb609608d53b9d64c56bb961a6ee2"}}