{"buggy_code": ["<?php\n\nnamespace BookStack\\Http\\Controllers\\Images;\n\nuse BookStack\\Exceptions\\ImageUploadException;\nuse BookStack\\Exceptions\\NotFoundException;\nuse BookStack\\Http\\Controllers\\Controller;\nuse BookStack\\Uploads\\Image;\nuse BookStack\\Uploads\\ImageRepo;\nuse Exception;\nuse Illuminate\\Filesystem\\Filesystem as File;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Validation\\ValidationException;\n\nclass ImageController extends Controller\n{\n    protected $image;\n    protected $file;\n    protected $imageRepo;\n\n    /**\n     * ImageController constructor.\n     */\n    public function __construct(Image $image, File $file, ImageRepo $imageRepo)\n    {\n        $this->image = $image;\n        $this->file = $file;\n        $this->imageRepo = $imageRepo;\n    }\n\n    /**\n     * Provide an image file from storage.\n     *\n     * @throws NotFoundException\n     */\n    public function showImage(string $path)\n    {\n        $path = storage_path('uploads/images/' . $path);\n        if (!file_exists($path)) {\n            throw (new NotFoundException(trans('errors.image_not_found')))\n                ->setSubtitle(trans('errors.image_not_found_subtitle'))\n                ->setDetails(trans('errors.image_not_found_details'));\n        }\n\n        return response()->file($path);\n    }\n\n    /**\n     * Update image details.\n     *\n     * @throws ImageUploadException\n     * @throws ValidationException\n     */\n    public function update(Request $request, string $id)\n    {\n        $this->validate($request, [\n            'name' => 'required|min:2|string',\n        ]);\n\n        $image = $this->imageRepo->getById($id);\n        $this->checkImagePermission($image);\n        $this->checkOwnablePermission('image-update', $image);\n\n        $image = $this->imageRepo->updateImageDetails($image, $request->all());\n\n        $this->imageRepo->loadThumbs($image);\n\n        return view('pages.parts.image-manager-form', [\n            'image'          => $image,\n            'dependantPages' => null,\n        ]);\n    }\n\n    /**\n     * Get the form for editing the given image.\n     *\n     * @throws Exception\n     */\n    public function edit(Request $request, string $id)\n    {\n        $image = $this->imageRepo->getById($id);\n        $this->checkImagePermission($image);\n\n        if ($request->has('delete')) {\n            $dependantPages = $this->imageRepo->getPagesUsingImage($image);\n        }\n\n        $this->imageRepo->loadThumbs($image);\n\n        return view('pages.parts.image-manager-form', [\n            'image'          => $image,\n            'dependantPages' => $dependantPages ?? null,\n        ]);\n    }\n\n    /**\n     * Deletes an image and all thumbnail/image files.\n     *\n     * @throws Exception\n     */\n    public function destroy(string $id)\n    {\n        $image = $this->imageRepo->getById($id);\n        $this->checkOwnablePermission('image-delete', $image);\n        $this->checkImagePermission($image);\n\n        $this->imageRepo->destroyImage($image);\n\n        return response('');\n    }\n\n    /**\n     * Check related page permission and ensure type is drawio or gallery.\n     */\n    protected function checkImagePermission(Image $image)\n    {\n        if ($image->type !== 'drawio' && $image->type !== 'gallery') {\n            $this->showPermissionError();\n        }\n\n        $relatedPage = $image->getPage();\n        if ($relatedPage) {\n            $this->checkOwnablePermission('page-view', $relatedPage);\n        }\n    }\n}\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\FileUploadException;\nuse Exception;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Str;\nuse League\\Flysystem\\Util;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass AttachmentService\n{\n    protected $fileSystem;\n\n    /**\n     * AttachmentService constructor.\n     */\n    public function __construct(FileSystem $fileSystem)\n    {\n        $this->fileSystem = $fileSystem;\n    }\n\n    /**\n     * Get the storage that will be used for storing files.\n     */\n    protected function getStorage(): FileSystemInstance\n    {\n        return $this->fileSystem->disk($this->getStorageDiskName());\n    }\n\n    /**\n     * Get the name of the storage disk to use.\n     */\n    protected function getStorageDiskName(): string\n    {\n        $storageType = config('filesystems.attachments');\n\n        // Change to our secure-attachment disk if any of the local options\n        // are used to prevent escaping that location.\n        if ($storageType === 'local' || $storageType === 'local_secure') {\n            $storageType = 'local_secure_attachments';\n        }\n\n        return $storageType;\n    }\n\n    /**\n     * Change the originally provided path to fit any disk-specific requirements.\n     * This also ensures the path is kept to the expected root folders.\n     */\n    protected function adjustPathForStorageDisk(string $path): string\n    {\n        $path = Util::normalizePath(str_replace('uploads/files/', '', $path));\n\n        if ($this->getStorageDiskName() === 'local_secure_attachments') {\n            return $path;\n        }\n\n        return 'uploads/files/' . $path;\n    }\n\n    /**\n     * Get an attachment from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getAttachmentFromStorage(Attachment $attachment): string\n    {\n        return $this->getStorage()->get($this->adjustPathForStorageDisk($attachment->path));\n    }\n\n    /**\n     * Store a new attachment upon user upload.\n     *\n     * @throws FileUploadException\n     */\n    public function saveNewUpload(UploadedFile $uploadedFile, int $pageId): Attachment\n    {\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n        $largestExistingOrder = Attachment::query()->where('uploaded_to', '=', $pageId)->max('order');\n\n        /** @var Attachment $attachment */\n        $attachment = Attachment::query()->forceCreate([\n            'name'        => $attachmentName,\n            'path'        => $attachmentPath,\n            'extension'   => $uploadedFile->getClientOriginalExtension(),\n            'uploaded_to' => $pageId,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n\n        return $attachment;\n    }\n\n    /**\n     * Store an upload, saving to a file and deleting any existing uploads\n     * attached to that file.\n     *\n     * @throws FileUploadException\n     */\n    public function saveUpdatedUpload(UploadedFile $uploadedFile, Attachment $attachment): Attachment\n    {\n        if (!$attachment->external) {\n            $this->deleteFileInStorage($attachment);\n        }\n\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n\n        $attachment->name = $attachmentName;\n        $attachment->path = $attachmentPath;\n        $attachment->external = false;\n        $attachment->extension = $uploadedFile->getClientOriginalExtension();\n        $attachment->save();\n\n        return $attachment;\n    }\n\n    /**\n     * Save a new File attachment from a given link and name.\n     */\n    public function saveNewFromLink(string $name, string $link, int $page_id): Attachment\n    {\n        $largestExistingOrder = Attachment::where('uploaded_to', '=', $page_id)->max('order');\n\n        return Attachment::forceCreate([\n            'name'        => $name,\n            'path'        => $link,\n            'external'    => true,\n            'extension'   => '',\n            'uploaded_to' => $page_id,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n    }\n\n    /**\n     * Updates the ordering for a listing of attached files.\n     */\n    public function updateFileOrderWithinPage(array $attachmentOrder, string $pageId)\n    {\n        foreach ($attachmentOrder as $index => $attachmentId) {\n            Attachment::query()->where('uploaded_to', '=', $pageId)\n                ->where('id', '=', $attachmentId)\n                ->update(['order' => $index]);\n        }\n    }\n\n    /**\n     * Update the details of a file.\n     */\n    public function updateFile(Attachment $attachment, array $requestData): Attachment\n    {\n        $attachment->name = $requestData['name'];\n        $link = trim($requestData['link'] ?? '');\n\n        if (!empty($link)) {\n            if (!$attachment->external) {\n                $this->deleteFileInStorage($attachment);\n                $attachment->external = true;\n                $attachment->extension = '';\n            }\n            $attachment->path = $requestData['link'];\n        }\n\n        $attachment->save();\n\n        return $attachment->refresh();\n    }\n\n    /**\n     * Delete a File from the database and storage.\n     *\n     * @throws Exception\n     */\n    public function deleteFile(Attachment $attachment)\n    {\n        if (!$attachment->external) {\n            $this->deleteFileInStorage($attachment);\n        }\n\n        $attachment->delete();\n    }\n\n    /**\n     * Delete a file from the filesystem it sits on.\n     * Cleans any empty leftover folders.\n     */\n    protected function deleteFileInStorage(Attachment $attachment)\n    {\n        $storage = $this->getStorage();\n        $dirPath = $this->adjustPathForStorageDisk(dirname($attachment->path));\n\n        $storage->delete($this->adjustPathForStorageDisk($attachment->path));\n        if (count($storage->allFiles($dirPath)) === 0) {\n            $storage->deleteDirectory($dirPath);\n        }\n    }\n\n    /**\n     * Store a file in storage with the given filename.\n     *\n     * @throws FileUploadException\n     */\n    protected function putFileInStorage(UploadedFile $uploadedFile): string\n    {\n        $attachmentData = file_get_contents($uploadedFile->getRealPath());\n\n        $storage = $this->getStorage();\n        $basePath = 'uploads/files/' . date('Y-m-M') . '/';\n\n        $uploadFileName = Str::random(16) . '.' . $uploadedFile->getClientOriginalExtension();\n        while ($storage->exists($this->adjustPathForStorageDisk($basePath . $uploadFileName))) {\n            $uploadFileName = Str::random(3) . $uploadFileName;\n        }\n\n        $attachmentPath = $basePath . $uploadFileName;\n\n        try {\n            $storage->put($this->adjustPathForStorageDisk($attachmentPath), $attachmentData);\n        } catch (Exception $e) {\n            Log::error('Error when attempting file upload:' . $e->getMessage());\n\n            throw new FileUploadException(trans('errors.path_not_writable', ['filePath' => $attachmentPath]));\n        }\n\n        return $attachmentPath;\n    }\n}\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\ImageUploadException;\nuse ErrorException;\nuse Exception;\nuse Illuminate\\Contracts\\Cache\\Repository as Cache;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as Storage;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Str;\nuse Intervention\\Image\\Exception\\NotSupportedException;\nuse Intervention\\Image\\ImageManager;\nuse League\\Flysystem\\Util;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass ImageService\n{\n    protected $imageTool;\n    protected $cache;\n    protected $storageUrl;\n    protected $image;\n    protected $fileSystem;\n\n    /**\n     * ImageService constructor.\n     */\n    public function __construct(Image $image, ImageManager $imageTool, FileSystem $fileSystem, Cache $cache)\n    {\n        $this->image = $image;\n        $this->imageTool = $imageTool;\n        $this->fileSystem = $fileSystem;\n        $this->cache = $cache;\n    }\n\n    /**\n     * Get the storage that will be used for storing images.\n     */\n    protected function getStorage(string $imageType = ''): FileSystemInstance\n    {\n        return $this->fileSystem->disk($this->getStorageDiskName($imageType));\n    }\n\n    /**\n     * Change the originally provided path to fit any disk-specific requirements.\n     * This also ensures the path is kept to the expected root folders.\n     */\n    protected function adjustPathForStorageDisk(string $path, string $imageType = ''): string\n    {\n        $path = Util::normalizePath(str_replace('uploads/images/', '', $path));\n\n        if ($this->getStorageDiskName($imageType) === 'local_secure_images') {\n            return $path;\n        }\n\n        return 'uploads/images/' . $path;\n    }\n\n    /**\n     * Get the name of the storage disk to use.\n     */\n    protected function getStorageDiskName(string $imageType): string\n    {\n        $storageType = config('filesystems.images');\n\n        // Ensure system images (App logo) are uploaded to a public space\n        if ($imageType === 'system' && $storageType === 'local_secure') {\n            $storageType = 'local';\n        }\n\n        if ($storageType === 'local_secure') {\n            $storageType = 'local_secure_images';\n        }\n\n        return $storageType;\n    }\n\n    /**\n     * Saves a new image from an upload.\n     *\n     * @throws ImageUploadException\n     *\n     * @return mixed\n     */\n    public function saveNewFromUpload(\n        UploadedFile $uploadedFile,\n        string $type,\n        int $uploadedTo = 0,\n        int $resizeWidth = null,\n        int $resizeHeight = null,\n        bool $keepRatio = true\n    ) {\n        $imageName = $uploadedFile->getClientOriginalName();\n        $imageData = file_get_contents($uploadedFile->getRealPath());\n\n        if ($resizeWidth !== null || $resizeHeight !== null) {\n            $imageData = $this->resizeImage($imageData, $resizeWidth, $resizeHeight, $keepRatio);\n        }\n\n        return $this->saveNew($imageName, $imageData, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image from a uri-encoded base64 string of data.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNewFromBase64Uri(string $base64Uri, string $name, string $type, int $uploadedTo = 0): Image\n    {\n        $splitData = explode(';base64,', $base64Uri);\n        if (count($splitData) < 2) {\n            throw new ImageUploadException('Invalid base64 image data provided');\n        }\n        $data = base64_decode($splitData[1]);\n\n        return $this->saveNew($name, $data, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image into storage.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNew(string $imageName, string $imageData, string $type, int $uploadedTo = 0): Image\n    {\n        $storage = $this->getStorage($type);\n        $secureUploads = setting('app-secure-images');\n        $fileName = $this->cleanImageFileName($imageName);\n\n        $imagePath = '/uploads/images/' . $type . '/' . date('Y-m') . '/';\n\n        while ($storage->exists($this->adjustPathForStorageDisk($imagePath . $fileName, $type))) {\n            $fileName = Str::random(3) . $fileName;\n        }\n\n        $fullPath = $imagePath . $fileName;\n        if ($secureUploads) {\n            $fullPath = $imagePath . Str::random(16) . '-' . $fileName;\n        }\n\n        try {\n            $this->saveImageDataInPublicSpace($storage, $this->adjustPathForStorageDisk($fullPath, $type), $imageData);\n        } catch (Exception $e) {\n            \\Log::error('Error when attempting image upload:' . $e->getMessage());\n\n            throw new ImageUploadException(trans('errors.path_not_writable', ['filePath' => $fullPath]));\n        }\n\n        $imageDetails = [\n            'name'        => $imageName,\n            'path'        => $fullPath,\n            'url'         => $this->getPublicUrl($fullPath),\n            'type'        => $type,\n            'uploaded_to' => $uploadedTo,\n        ];\n\n        if (user()->id !== 0) {\n            $userId = user()->id;\n            $imageDetails['created_by'] = $userId;\n            $imageDetails['updated_by'] = $userId;\n        }\n\n        $image = $this->image->newInstance();\n        $image->forceFill($imageDetails)->save();\n\n        return $image;\n    }\n\n    /**\n     * Save image data for the given path in the public space, if possible,\n     * for the provided storage mechanism.\n     */\n    protected function saveImageDataInPublicSpace(Storage $storage, string $path, string $data)\n    {\n        $storage->put($path, $data);\n\n        // Set visibility when a non-AWS-s3, s3-like storage option is in use.\n        // Done since this call can break s3-like services but desired for other image stores.\n        // Attempting to set ACL during above put request requires different permissions\n        // hence would technically be a breaking change for actual s3 usage.\n        $usingS3 = strtolower(config('filesystems.images')) === 's3';\n        $usingS3Like = $usingS3 && !is_null(config('filesystems.disks.s3.endpoint'));\n        if (!$usingS3Like) {\n            $storage->setVisibility($path, 'public');\n        }\n    }\n\n    /**\n     * Clean up an image file name to be both URL and storage safe.\n     */\n    protected function cleanImageFileName(string $name): string\n    {\n        $name = str_replace(' ', '-', $name);\n        $nameParts = explode('.', $name);\n        $extension = array_pop($nameParts);\n        $name = implode('-', $nameParts);\n        $name = Str::slug($name);\n\n        if (strlen($name) === 0) {\n            $name = Str::random(10);\n        }\n\n        return $name . '.' . $extension;\n    }\n\n    /**\n     * Checks if the image is a gif. Returns true if it is, else false.\n     */\n    protected function isGif(Image $image): bool\n    {\n        return strtolower(pathinfo($image->path, PATHINFO_EXTENSION)) === 'gif';\n    }\n\n    /**\n     * Get the thumbnail for an image.\n     * If $keepRatio is true only the width will be used.\n     * Checks the cache then storage to avoid creating / accessing the filesystem on every check.\n     *\n     * @param Image $image\n     * @param int   $width\n     * @param int   $height\n     * @param bool  $keepRatio\n     *\n     * @throws Exception\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    public function getThumbnail(Image $image, $width = 220, $height = 220, $keepRatio = false)\n    {\n        if ($keepRatio && $this->isGif($image)) {\n            return $this->getPublicUrl($image->path);\n        }\n\n        $thumbDirName = '/' . ($keepRatio ? 'scaled-' : 'thumbs-') . $width . '-' . $height . '/';\n        $imagePath = $image->path;\n        $thumbFilePath = dirname($imagePath) . $thumbDirName . basename($imagePath);\n\n        if ($this->cache->has('images-' . $image->id . '-' . $thumbFilePath) && $this->cache->get('images-' . $thumbFilePath)) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $storage = $this->getStorage($image->type);\n        if ($storage->exists($this->adjustPathForStorageDisk($thumbFilePath, $image->type))) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $thumbData = $this->resizeImage($storage->get($this->adjustPathForStorageDisk($imagePath, $image->type)), $width, $height, $keepRatio);\n\n        $this->saveImageDataInPublicSpace($storage, $this->adjustPathForStorageDisk($thumbFilePath, $image->type), $thumbData);\n        $this->cache->put('images-' . $image->id . '-' . $thumbFilePath, $thumbFilePath, 60 * 60 * 72);\n\n        return $this->getPublicUrl($thumbFilePath);\n    }\n\n    /**\n     * Resize image data.\n     *\n     * @param string $imageData\n     * @param int    $width\n     * @param int    $height\n     * @param bool   $keepRatio\n     *\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    protected function resizeImage(string $imageData, $width = 220, $height = null, bool $keepRatio = true)\n    {\n        try {\n            $thumb = $this->imageTool->make($imageData);\n        } catch (Exception $e) {\n            if ($e instanceof ErrorException || $e instanceof NotSupportedException) {\n                throw new ImageUploadException(trans('errors.cannot_create_thumbs'));\n            }\n\n            throw $e;\n        }\n\n        if ($keepRatio) {\n            $thumb->resize($width, $height, function ($constraint) {\n                $constraint->aspectRatio();\n                $constraint->upsize();\n            });\n        } else {\n            $thumb->fit($width, $height);\n        }\n\n        $thumbData = (string) $thumb->encode();\n\n        // Use original image data if we're keeping the ratio\n        // and the resizing does not save any space.\n        if ($keepRatio && strlen($thumbData) > strlen($imageData)) {\n            return $imageData;\n        }\n\n        return $thumbData;\n    }\n\n    /**\n     * Get the raw data content from an image.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getImageData(Image $image): string\n    {\n        $storage = $this->getStorage();\n\n        return $storage->get($this->adjustPathForStorageDisk($image->path, $image->type));\n    }\n\n    /**\n     * Destroy an image along with its revisions, thumbnails and remaining folders.\n     *\n     * @throws Exception\n     */\n    public function destroy(Image $image)\n    {\n        $this->destroyImagesFromPath($image->path, $image->type);\n        $image->delete();\n    }\n\n    /**\n     * Destroys an image at the given path.\n     * Searches for image thumbnails in addition to main provided path.\n     */\n    protected function destroyImagesFromPath(string $path, string $imageType): bool\n    {\n        $path = $this->adjustPathForStorageDisk($path, $imageType);\n        $storage = $this->getStorage($imageType);\n\n        $imageFolder = dirname($path);\n        $imageFileName = basename($path);\n        $allImages = collect($storage->allFiles($imageFolder));\n\n        // Delete image files\n        $imagesToDelete = $allImages->filter(function ($imagePath) use ($imageFileName) {\n            return basename($imagePath) === $imageFileName;\n        });\n        $storage->delete($imagesToDelete->all());\n\n        // Cleanup of empty folders\n        $foldersInvolved = array_merge([$imageFolder], $storage->directories($imageFolder));\n        foreach ($foldersInvolved as $directory) {\n            if ($this->isFolderEmpty($storage, $directory)) {\n                $storage->deleteDirectory($directory);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether a folder is empty.\n     */\n    protected function isFolderEmpty(FileSystemInstance $storage, string $path): bool\n    {\n        $files = $storage->files($path);\n        $folders = $storage->directories($path);\n\n        return count($files) === 0 && count($folders) === 0;\n    }\n\n    /**\n     * Delete gallery and drawings that are not within HTML content of pages or page revisions.\n     * Checks based off of only the image name.\n     * Could be much improved to be more specific but kept it generic for now to be safe.\n     *\n     * Returns the path of the images that would be/have been deleted.\n     */\n    public function deleteUnusedImages(bool $checkRevisions = true, bool $dryRun = true)\n    {\n        $types = ['gallery', 'drawio'];\n        $deletedPaths = [];\n\n        $this->image->newQuery()->whereIn('type', $types)\n            ->chunk(1000, function ($images) use ($checkRevisions, &$deletedPaths, $dryRun) {\n                foreach ($images as $image) {\n                    $searchQuery = '%' . basename($image->path) . '%';\n                    $inPage = DB::table('pages')\n                            ->where('html', 'like', $searchQuery)->count() > 0;\n\n                    $inRevision = false;\n                    if ($checkRevisions) {\n                        $inRevision = DB::table('page_revisions')\n                                ->where('html', 'like', $searchQuery)->count() > 0;\n                    }\n\n                    if (!$inPage && !$inRevision) {\n                        $deletedPaths[] = $image->path;\n                        if (!$dryRun) {\n                            $this->destroy($image);\n                        }\n                    }\n                }\n            });\n\n        return $deletedPaths;\n    }\n\n    /**\n     * Convert an image URI to a Base64 encoded string.\n     * Attempts to convert the URL to a system storage url then\n     * fetch the data from the disk or storage location.\n     * Returns null if the image data cannot be fetched from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function imageUriToBase64(string $uri): ?string\n    {\n        $storagePath = $this->imageUrlToStoragePath($uri);\n        if (empty($uri) || is_null($storagePath)) {\n            return null;\n        }\n\n        $storagePath = $this->adjustPathForStorageDisk($storagePath);\n        $storage = $this->getStorage();\n        $imageData = null;\n        if ($storage->exists($storagePath)) {\n            $imageData = $storage->get($storagePath);\n        }\n\n        if (is_null($imageData)) {\n            return null;\n        }\n\n        $extension = pathinfo($uri, PATHINFO_EXTENSION);\n        if ($extension === 'svg') {\n            $extension = 'svg+xml';\n        }\n\n        return 'data:image/' . $extension . ';base64,' . base64_encode($imageData);\n    }\n\n    /**\n     * Get a storage path for the given image URL.\n     * Ensures the path will start with \"uploads/images\".\n     * Returns null if the url cannot be resolved to a local URL.\n     */\n    private function imageUrlToStoragePath(string $url): ?string\n    {\n        $url = ltrim(trim($url), '/');\n\n        // Handle potential relative paths\n        $isRelative = strpos($url, 'http') !== 0;\n        if ($isRelative) {\n            if (strpos(strtolower($url), 'uploads/images') === 0) {\n                return trim($url, '/');\n            }\n\n            return null;\n        }\n\n        // Handle local images based on paths on the same domain\n        $potentialHostPaths = [\n            url('uploads/images/'),\n            $this->getPublicUrl('/uploads/images/'),\n        ];\n\n        foreach ($potentialHostPaths as $potentialBasePath) {\n            $potentialBasePath = strtolower($potentialBasePath);\n            if (strpos(strtolower($url), $potentialBasePath) === 0) {\n                return 'uploads/images/' . trim(substr($url, strlen($potentialBasePath)), '/');\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets a public facing url for an image by checking relevant environment variables.\n     * If s3-style store is in use it will default to guessing a public bucket URL.\n     */\n    private function getPublicUrl(string $filePath): string\n    {\n        if ($this->storageUrl === null) {\n            $storageUrl = config('filesystems.url');\n\n            // Get the standard public s3 url if s3 is set as storage type\n            // Uses the nice, short URL if bucket name has no periods in otherwise the longer\n            // region-based url will be used to prevent http issues.\n            if ($storageUrl == false && config('filesystems.images') === 's3') {\n                $storageDetails = config('filesystems.disks.s3');\n                if (strpos($storageDetails['bucket'], '.') === false) {\n                    $storageUrl = 'https://' . $storageDetails['bucket'] . '.s3.amazonaws.com';\n                } else {\n                    $storageUrl = 'https://s3-' . $storageDetails['region'] . '.amazonaws.com/' . $storageDetails['bucket'];\n                }\n            }\n            $this->storageUrl = $storageUrl;\n        }\n\n        $basePath = ($this->storageUrl == false) ? url('/') : $this->storageUrl;\n\n        return rtrim($basePath, '/') . $filePath;\n    }\n}\n", "<?php\n\nnamespace Tests\\Uploads;\n\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Entities\\Repos\\PageRepo;\nuse BookStack\\Uploads\\Image;\nuse BookStack\\Uploads\\ImageService;\nuse Illuminate\\Support\\Str;\nuse Tests\\TestCase;\n\nclass ImageTest extends TestCase\n{\n    use UsesImages;\n\n    public function test_image_upload()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $imgDetails = $this->uploadGalleryImage($page);\n        $relPath = $imgDetails['path'];\n\n        $this->assertTrue(file_exists(public_path($relPath)), 'Uploaded image found at path: ' . public_path($relPath));\n\n        $this->deleteImage($relPath);\n\n        $this->assertDatabaseHas('images', [\n            'url'         => $this->baseUrl . $relPath,\n            'type'        => 'gallery',\n            'uploaded_to' => $page->id,\n            'path'        => $relPath,\n            'created_by'  => $admin->id,\n            'updated_by'  => $admin->id,\n            'name'        => $imgDetails['name'],\n        ]);\n    }\n\n    public function test_image_display_thumbnail_generation_does_not_increase_image_size()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $originalFile = $this->getTestImageFilePath('compressed.png');\n        $originalFileSize = filesize($originalFile);\n        $imgDetails = $this->uploadGalleryImage($page, 'compressed.png');\n        $relPath = $imgDetails['path'];\n\n        $this->assertTrue(file_exists(public_path($relPath)), 'Uploaded image found at path: ' . public_path($relPath));\n        $displayImage = $imgDetails['response']->thumbs->display;\n\n        $displayImageRelPath = implode('/', array_slice(explode('/', $displayImage), 3));\n        $displayImagePath = public_path($displayImageRelPath);\n        $displayFileSize = filesize($displayImagePath);\n\n        $this->deleteImage($relPath);\n        $this->deleteImage($displayImageRelPath);\n\n        $this->assertEquals($originalFileSize, $displayFileSize, 'Display thumbnail generation should not increase image size');\n    }\n\n    public function test_image_edit()\n    {\n        $editor = $this->getEditor();\n        $this->actingAs($editor);\n\n        $imgDetails = $this->uploadGalleryImage();\n        $image = Image::query()->first();\n\n        $newName = Str::random();\n        $update = $this->put('/images/' . $image->id, ['name' => $newName]);\n        $update->assertSuccessful();\n        $update->assertSee($newName);\n\n        $this->deleteImage($imgDetails['path']);\n\n        $this->assertDatabaseHas('images', [\n            'type' => 'gallery',\n            'name' => $newName,\n        ]);\n    }\n\n    public function test_gallery_get_list_format()\n    {\n        $this->asEditor();\n\n        $imgDetails = $this->uploadGalleryImage();\n        $image = Image::query()->first();\n\n        $pageId = $imgDetails['page']->id;\n        $firstPageRequest = $this->get(\"/images/gallery?page=1&uploaded_to={$pageId}\");\n        $firstPageRequest->assertSuccessful()->assertElementExists('div');\n        $firstPageRequest->assertSuccessful()->assertSeeText($image->name);\n\n        $secondPageRequest = $this->get(\"/images/gallery?page=2&uploaded_to={$pageId}\");\n        $secondPageRequest->assertSuccessful()->assertElementNotExists('div');\n\n        $namePartial = substr($imgDetails['name'], 0, 3);\n        $searchHitRequest = $this->get(\"/images/gallery?page=1&uploaded_to={$pageId}&search={$namePartial}\");\n        $searchHitRequest->assertSuccessful()->assertSee($imgDetails['name']);\n\n        $namePartial = Str::random(16);\n        $searchFailRequest = $this->get(\"/images/gallery?page=1&uploaded_to={$pageId}&search={$namePartial}\");\n        $searchFailRequest->assertSuccessful()->assertDontSee($imgDetails['name']);\n        $searchFailRequest->assertSuccessful()->assertElementNotExists('div');\n    }\n\n    public function test_image_usage()\n    {\n        $page = Page::query()->first();\n        $editor = $this->getEditor();\n        $this->actingAs($editor);\n\n        $imgDetails = $this->uploadGalleryImage($page);\n\n        $image = Image::query()->first();\n        $page->html = '<img src=\"' . $image->url . '\">';\n        $page->save();\n\n        $usage = $this->get('/images/edit/' . $image->id . '?delete=true');\n        $usage->assertSuccessful();\n        $usage->assertSeeText($page->name);\n        $usage->assertSee($page->getUrl());\n\n        $this->deleteImage($imgDetails['path']);\n    }\n\n    public function test_php_files_cannot_be_uploaded()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $fileName = 'bad.php';\n        $relPath = $this->getTestImagePath('gallery', $fileName);\n        $this->deleteImage($relPath);\n\n        $file = $this->newTestImageFromBase64('bad-php.base64', $fileName);\n        $upload = $this->withHeader('Content-Type', 'image/jpeg')->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $file], []);\n        $upload->assertStatus(302);\n\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded php file was uploaded but should have been stopped');\n\n        $this->assertDatabaseMissing('images', [\n            'type' => 'gallery',\n            'name' => $fileName,\n        ]);\n    }\n\n    public function test_php_like_files_cannot_be_uploaded()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $fileName = 'bad.phtml';\n        $relPath = $this->getTestImagePath('gallery', $fileName);\n        $this->deleteImage($relPath);\n\n        $file = $this->newTestImageFromBase64('bad-phtml.base64', $fileName);\n        $upload = $this->withHeader('Content-Type', 'image/jpeg')->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $file], []);\n        $upload->assertStatus(302);\n\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded php file was uploaded but should have been stopped');\n    }\n\n    public function test_files_with_double_extensions_will_get_sanitized()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $fileName = 'bad.phtml.png';\n        $relPath = $this->getTestImagePath('gallery', $fileName);\n        $expectedRelPath = dirname($relPath) . '/bad-phtml.png';\n        $this->deleteImage($expectedRelPath);\n\n        $file = $this->newTestImageFromBase64('bad-phtml-png.base64', $fileName);\n        $upload = $this->withHeader('Content-Type', 'image/png')->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $file], []);\n        $upload->assertStatus(200);\n\n        $lastImage = Image::query()->latest('id')->first();\n\n        $this->assertEquals('bad.phtml.png', $lastImage->name);\n        $this->assertEquals('bad-phtml.png', basename($lastImage->path));\n        $this->assertFileDoesNotExist(public_path($relPath), 'Uploaded image file name was not stripped of dots');\n        $this->assertFileExists(public_path($expectedRelPath));\n\n        $this->deleteImage($lastImage->path);\n    }\n\n    public function test_url_entities_removed_from_filenames()\n    {\n        $this->asEditor();\n        $badNames = [\n            'bad-char-#-image.png',\n            'bad-char-?-image.png',\n            '?#.png',\n            '?.png',\n            '#.png',\n        ];\n        foreach ($badNames as $name) {\n            $galleryFile = $this->getTestImage($name);\n            $page = Page::query()->first();\n            $badPath = $this->getTestImagePath('gallery', $name);\n            $this->deleteImage($badPath);\n\n            $upload = $this->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $galleryFile], []);\n            $upload->assertStatus(200);\n\n            $lastImage = Image::query()->latest('id')->first();\n            $newFileName = explode('.', basename($lastImage->path))[0];\n\n            $this->assertEquals($lastImage->name, $name);\n            $this->assertFalse(strpos($lastImage->path, $name), 'Path contains original image name');\n            $this->assertFalse(file_exists(public_path($badPath)), 'Uploaded image file name was not stripped of url entities');\n\n            $this->assertTrue(strlen($newFileName) > 0, 'File name was reduced to nothing');\n\n            $this->deleteImage($lastImage->path);\n        }\n    }\n\n    public function test_secure_images_uploads_to_correct_place()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asEditor();\n        $galleryFile = $this->getTestImage('my-secure-test-upload.png');\n        $page = Page::query()->first();\n        $expectedPath = storage_path('uploads/images/gallery/' . date('Y-m') . '/my-secure-test-upload.png');\n\n        $upload = $this->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $galleryFile], []);\n        $upload->assertStatus(200);\n\n        $this->assertTrue(file_exists($expectedPath), 'Uploaded image not found at path: ' . $expectedPath);\n\n        if (file_exists($expectedPath)) {\n            unlink($expectedPath);\n        }\n    }\n\n    public function test_secure_images_included_in_exports()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asEditor();\n        $galleryFile = $this->getTestImage('my-secure-test-upload.png');\n        $page = Page::query()->first();\n        $expectedPath = storage_path('uploads/images/gallery/' . date('Y-m') . '/my-secure-test-upload.png');\n\n        $upload = $this->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $galleryFile], []);\n        $imageUrl = json_decode($upload->getContent(), true)['url'];\n        $page->html .= \"<img src=\\\"{$imageUrl}\\\">\";\n        $page->save();\n        $upload->assertStatus(200);\n\n        $encodedImageContent = base64_encode(file_get_contents($expectedPath));\n        $export = $this->get($page->getUrl('/export/html'));\n        $this->assertTrue(strpos($export->getContent(), $encodedImageContent) !== false, 'Uploaded image in export content');\n\n        if (file_exists($expectedPath)) {\n            unlink($expectedPath);\n        }\n    }\n\n    public function test_system_images_remain_public()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asAdmin();\n        $galleryFile = $this->getTestImage('my-system-test-upload.png');\n        $expectedPath = public_path('uploads/images/system/' . date('Y-m') . '/my-system-test-upload.png');\n\n        $upload = $this->call('POST', '/settings', [], [], ['app_logo' => $galleryFile], []);\n        $upload->assertRedirect('/settings');\n\n        $this->assertTrue(file_exists($expectedPath), 'Uploaded image not found at path: ' . $expectedPath);\n\n        if (file_exists($expectedPath)) {\n            unlink($expectedPath);\n        }\n    }\n\n    public function test_image_delete()\n    {\n        $page = Page::query()->first();\n        $this->asAdmin();\n        $imageName = 'first-image.png';\n        $relPath = $this->getTestImagePath('gallery', $imageName);\n        $this->deleteImage($relPath);\n\n        $this->uploadImage($imageName, $page->id);\n        $image = Image::first();\n\n        $delete = $this->delete('/images/' . $image->id);\n        $delete->assertStatus(200);\n\n        $this->assertDatabaseMissing('images', [\n            'url'  => $this->baseUrl . $relPath,\n            'type' => 'gallery',\n        ]);\n\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded image has not been deleted as expected');\n    }\n\n    public function test_image_delete_does_not_delete_similar_images()\n    {\n        $page = Page::query()->first();\n        $this->asAdmin();\n        $imageName = 'first-image.png';\n\n        $relPath = $this->getTestImagePath('gallery', $imageName);\n        $this->deleteImage($relPath);\n\n        $this->uploadImage($imageName, $page->id);\n        $this->uploadImage($imageName, $page->id);\n        $this->uploadImage($imageName, $page->id);\n\n        $image = Image::first();\n        $folder = public_path(dirname($relPath));\n        $imageCount = count(glob($folder . '/*'));\n\n        $delete = $this->delete('/images/' . $image->id);\n        $delete->assertStatus(200);\n\n        $newCount = count(glob($folder . '/*'));\n        $this->assertEquals($imageCount - 1, $newCount, 'More files than expected have been deleted');\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded image has not been deleted as expected');\n    }\n\n    protected function getTestProfileImage()\n    {\n        $imageName = 'profile.png';\n        $relPath = $this->getTestImagePath('user', $imageName);\n        $this->deleteImage($relPath);\n\n        return $this->getTestImage($imageName);\n    }\n\n    public function test_user_image_upload()\n    {\n        $editor = $this->getEditor();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $file = $this->getTestProfileImage();\n        $this->call('PUT', '/settings/users/' . $editor->id, [], [], ['profile_image' => $file], []);\n\n        $this->assertDatabaseHas('images', [\n            'type'        => 'user',\n            'uploaded_to' => $editor->id,\n            'created_by'  => $admin->id,\n        ]);\n    }\n\n    public function test_user_images_deleted_on_user_deletion()\n    {\n        $editor = $this->getEditor();\n        $this->actingAs($editor);\n\n        $file = $this->getTestProfileImage();\n        $this->call('PUT', '/settings/users/' . $editor->id, [], [], ['profile_image' => $file], []);\n\n        $profileImages = Image::where('type', '=', 'user')->where('created_by', '=', $editor->id)->get();\n        $this->assertTrue($profileImages->count() === 1, 'Found profile images does not match upload count');\n\n        $imagePath = public_path($profileImages->first()->path);\n        $this->assertTrue(file_exists($imagePath));\n\n        $userDelete = $this->asAdmin()->delete(\"/settings/users/{$editor->id}\");\n        $userDelete->assertStatus(302);\n\n        $this->assertDatabaseMissing('images', [\n            'type'       => 'user',\n            'created_by' => $editor->id,\n        ]);\n        $this->assertDatabaseMissing('images', [\n            'type'        => 'user',\n            'uploaded_to' => $editor->id,\n        ]);\n\n        $this->assertFalse(file_exists($imagePath));\n    }\n\n    public function test_deleted_unused_images()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $imageName = 'unused-image.png';\n        $relPath = $this->getTestImagePath('gallery', $imageName);\n        $this->deleteImage($relPath);\n\n        $upload = $this->uploadImage($imageName, $page->id);\n        $upload->assertStatus(200);\n        $image = Image::where('type', '=', 'gallery')->first();\n\n        $pageRepo = app(PageRepo::class);\n        $pageRepo->update($page, [\n            'name'    => $page->name,\n            'html'    => $page->html . \"<img src=\\\"{$image->url}\\\">\",\n            'summary' => '',\n        ]);\n\n        // Ensure no images are reported as deletable\n        $imageService = app(ImageService::class);\n        $toDelete = $imageService->deleteUnusedImages(true, true);\n        $this->assertCount(0, $toDelete);\n\n        // Save a revision of our page without the image;\n        $pageRepo->update($page, [\n            'name'    => $page->name,\n            'html'    => '<p>Hello</p>',\n            'summary' => '',\n        ]);\n\n        // Ensure revision images are picked up okay\n        $imageService = app(ImageService::class);\n        $toDelete = $imageService->deleteUnusedImages(true, true);\n        $this->assertCount(0, $toDelete);\n        $toDelete = $imageService->deleteUnusedImages(false, true);\n        $this->assertCount(1, $toDelete);\n\n        // Check image is found when revisions are destroyed\n        $page->revisions()->delete();\n        $toDelete = $imageService->deleteUnusedImages(true, true);\n        $this->assertCount(1, $toDelete);\n\n        // Check the image is deleted\n        $absPath = public_path($relPath);\n        $this->assertTrue(file_exists($absPath), \"Existing uploaded file at path {$absPath} exists\");\n        $toDelete = $imageService->deleteUnusedImages(true, false);\n        $this->assertCount(1, $toDelete);\n        $this->assertFalse(file_exists($absPath));\n\n        $this->deleteImage($relPath);\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace BookStack\\Http\\Controllers\\Images;\n\nuse BookStack\\Exceptions\\ImageUploadException;\nuse BookStack\\Exceptions\\NotFoundException;\nuse BookStack\\Http\\Controllers\\Controller;\nuse BookStack\\Uploads\\Image;\nuse BookStack\\Uploads\\ImageRepo;\nuse BookStack\\Uploads\\ImageService;\nuse Exception;\nuse Illuminate\\Filesystem\\Filesystem as File;\nuse Illuminate\\Filesystem\\FilesystemAdapter;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Illuminate\\Validation\\ValidationException;\nuse League\\Flysystem\\Util;\n\nclass ImageController extends Controller\n{\n    protected $image;\n    protected $file;\n    protected $imageRepo;\n    protected $imageService;\n\n    /**\n     * ImageController constructor.\n     */\n    public function __construct(Image $image, File $file, ImageRepo $imageRepo, ImageService $imageService)\n    {\n        $this->image = $image;\n        $this->file = $file;\n        $this->imageRepo = $imageRepo;\n        $this->imageService = $imageService;\n    }\n\n    /**\n     * Provide an image file from storage.\n     *\n     * @throws NotFoundException\n     */\n    public function showImage(string $path)\n    {\n        if (!$this->imageService->pathExistsInLocalSecure($path)) {\n            throw (new NotFoundException(trans('errors.image_not_found')))\n                ->setSubtitle(trans('errors.image_not_found_subtitle'))\n                ->setDetails(trans('errors.image_not_found_details'));\n        }\n\n        return $this->imageService->streamImageFromStorageResponse('gallery', $path);\n    }\n\n    /**\n     * Update image details.\n     *\n     * @throws ImageUploadException\n     * @throws ValidationException\n     */\n    public function update(Request $request, string $id)\n    {\n        $this->validate($request, [\n            'name' => 'required|min:2|string',\n        ]);\n\n        $image = $this->imageRepo->getById($id);\n        $this->checkImagePermission($image);\n        $this->checkOwnablePermission('image-update', $image);\n\n        $image = $this->imageRepo->updateImageDetails($image, $request->all());\n\n        $this->imageRepo->loadThumbs($image);\n\n        return view('pages.parts.image-manager-form', [\n            'image'          => $image,\n            'dependantPages' => null,\n        ]);\n    }\n\n    /**\n     * Get the form for editing the given image.\n     *\n     * @throws Exception\n     */\n    public function edit(Request $request, string $id)\n    {\n        $image = $this->imageRepo->getById($id);\n        $this->checkImagePermission($image);\n\n        if ($request->has('delete')) {\n            $dependantPages = $this->imageRepo->getPagesUsingImage($image);\n        }\n\n        $this->imageRepo->loadThumbs($image);\n\n        return view('pages.parts.image-manager-form', [\n            'image'          => $image,\n            'dependantPages' => $dependantPages ?? null,\n        ]);\n    }\n\n    /**\n     * Deletes an image and all thumbnail/image files.\n     *\n     * @throws Exception\n     */\n    public function destroy(string $id)\n    {\n        $image = $this->imageRepo->getById($id);\n        $this->checkOwnablePermission('image-delete', $image);\n        $this->checkImagePermission($image);\n\n        $this->imageRepo->destroyImage($image);\n\n        return response('');\n    }\n\n    /**\n     * Check related page permission and ensure type is drawio or gallery.\n     */\n    protected function checkImagePermission(Image $image)\n    {\n        if ($image->type !== 'drawio' && $image->type !== 'gallery') {\n            $this->showPermissionError();\n        }\n\n        $relatedPage = $image->getPage();\n        if ($relatedPage) {\n            $this->checkOwnablePermission('page-view', $relatedPage);\n        }\n    }\n}\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\FileUploadException;\nuse Exception;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Str;\nuse League\\Flysystem\\Util;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass AttachmentService\n{\n    protected $fileSystem;\n\n    /**\n     * AttachmentService constructor.\n     */\n    public function __construct(FileSystem $fileSystem)\n    {\n        $this->fileSystem = $fileSystem;\n    }\n\n    /**\n     * Get the storage that will be used for storing files.\n     */\n    protected function getStorageDisk(): FileSystemInstance\n    {\n        return $this->fileSystem->disk($this->getStorageDiskName());\n    }\n\n    /**\n     * Get the name of the storage disk to use.\n     */\n    protected function getStorageDiskName(): string\n    {\n        $storageType = config('filesystems.attachments');\n\n        // Change to our secure-attachment disk if any of the local options\n        // are used to prevent escaping that location.\n        if ($storageType === 'local' || $storageType === 'local_secure') {\n            $storageType = 'local_secure_attachments';\n        }\n\n        return $storageType;\n    }\n\n    /**\n     * Change the originally provided path to fit any disk-specific requirements.\n     * This also ensures the path is kept to the expected root folders.\n     */\n    protected function adjustPathForStorageDisk(string $path): string\n    {\n        $path = Util::normalizePath(str_replace('uploads/files/', '', $path));\n\n        if ($this->getStorageDiskName() === 'local_secure_attachments') {\n            return $path;\n        }\n\n        return 'uploads/files/' . $path;\n    }\n\n    /**\n     * Get an attachment from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getAttachmentFromStorage(Attachment $attachment): string\n    {\n        return $this->getStorageDisk()->get($this->adjustPathForStorageDisk($attachment->path));\n    }\n\n    /**\n     * Store a new attachment upon user upload.\n     *\n     * @throws FileUploadException\n     */\n    public function saveNewUpload(UploadedFile $uploadedFile, int $pageId): Attachment\n    {\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n        $largestExistingOrder = Attachment::query()->where('uploaded_to', '=', $pageId)->max('order');\n\n        /** @var Attachment $attachment */\n        $attachment = Attachment::query()->forceCreate([\n            'name'        => $attachmentName,\n            'path'        => $attachmentPath,\n            'extension'   => $uploadedFile->getClientOriginalExtension(),\n            'uploaded_to' => $pageId,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n\n        return $attachment;\n    }\n\n    /**\n     * Store an upload, saving to a file and deleting any existing uploads\n     * attached to that file.\n     *\n     * @throws FileUploadException\n     */\n    public function saveUpdatedUpload(UploadedFile $uploadedFile, Attachment $attachment): Attachment\n    {\n        if (!$attachment->external) {\n            $this->deleteFileInStorage($attachment);\n        }\n\n        $attachmentName = $uploadedFile->getClientOriginalName();\n        $attachmentPath = $this->putFileInStorage($uploadedFile);\n\n        $attachment->name = $attachmentName;\n        $attachment->path = $attachmentPath;\n        $attachment->external = false;\n        $attachment->extension = $uploadedFile->getClientOriginalExtension();\n        $attachment->save();\n\n        return $attachment;\n    }\n\n    /**\n     * Save a new File attachment from a given link and name.\n     */\n    public function saveNewFromLink(string $name, string $link, int $page_id): Attachment\n    {\n        $largestExistingOrder = Attachment::where('uploaded_to', '=', $page_id)->max('order');\n\n        return Attachment::forceCreate([\n            'name'        => $name,\n            'path'        => $link,\n            'external'    => true,\n            'extension'   => '',\n            'uploaded_to' => $page_id,\n            'created_by'  => user()->id,\n            'updated_by'  => user()->id,\n            'order'       => $largestExistingOrder + 1,\n        ]);\n    }\n\n    /**\n     * Updates the ordering for a listing of attached files.\n     */\n    public function updateFileOrderWithinPage(array $attachmentOrder, string $pageId)\n    {\n        foreach ($attachmentOrder as $index => $attachmentId) {\n            Attachment::query()->where('uploaded_to', '=', $pageId)\n                ->where('id', '=', $attachmentId)\n                ->update(['order' => $index]);\n        }\n    }\n\n    /**\n     * Update the details of a file.\n     */\n    public function updateFile(Attachment $attachment, array $requestData): Attachment\n    {\n        $attachment->name = $requestData['name'];\n        $link = trim($requestData['link'] ?? '');\n\n        if (!empty($link)) {\n            if (!$attachment->external) {\n                $this->deleteFileInStorage($attachment);\n                $attachment->external = true;\n                $attachment->extension = '';\n            }\n            $attachment->path = $requestData['link'];\n        }\n\n        $attachment->save();\n\n        return $attachment->refresh();\n    }\n\n    /**\n     * Delete a File from the database and storage.\n     *\n     * @throws Exception\n     */\n    public function deleteFile(Attachment $attachment)\n    {\n        if (!$attachment->external) {\n            $this->deleteFileInStorage($attachment);\n        }\n\n        $attachment->delete();\n    }\n\n    /**\n     * Delete a file from the filesystem it sits on.\n     * Cleans any empty leftover folders.\n     */\n    protected function deleteFileInStorage(Attachment $attachment)\n    {\n        $storage = $this->getStorageDisk();\n        $dirPath = $this->adjustPathForStorageDisk(dirname($attachment->path));\n\n        $storage->delete($this->adjustPathForStorageDisk($attachment->path));\n        if (count($storage->allFiles($dirPath)) === 0) {\n            $storage->deleteDirectory($dirPath);\n        }\n    }\n\n    /**\n     * Store a file in storage with the given filename.\n     *\n     * @throws FileUploadException\n     */\n    protected function putFileInStorage(UploadedFile $uploadedFile): string\n    {\n        $attachmentData = file_get_contents($uploadedFile->getRealPath());\n\n        $storage = $this->getStorageDisk();\n        $basePath = 'uploads/files/' . date('Y-m-M') . '/';\n\n        $uploadFileName = Str::random(16) . '.' . $uploadedFile->getClientOriginalExtension();\n        while ($storage->exists($this->adjustPathForStorageDisk($basePath . $uploadFileName))) {\n            $uploadFileName = Str::random(3) . $uploadFileName;\n        }\n\n        $attachmentPath = $basePath . $uploadFileName;\n\n        try {\n            $storage->put($this->adjustPathForStorageDisk($attachmentPath), $attachmentData);\n        } catch (Exception $e) {\n            Log::error('Error when attempting file upload:' . $e->getMessage());\n\n            throw new FileUploadException(trans('errors.path_not_writable', ['filePath' => $attachmentPath]));\n        }\n\n        return $attachmentPath;\n    }\n}\n", "<?php\n\nnamespace BookStack\\Uploads;\n\nuse BookStack\\Exceptions\\ImageUploadException;\nuse ErrorException;\nuse Exception;\nuse Illuminate\\Contracts\\Cache\\Repository as Cache;\nuse Illuminate\\Contracts\\Filesystem\\Factory as FileSystem;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as FileSystemInstance;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem as Storage;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Str;\nuse Intervention\\Image\\Exception\\NotSupportedException;\nuse Intervention\\Image\\ImageManager;\nuse League\\Flysystem\\Util;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Symfony\\Component\\HttpFoundation\\StreamedResponse;\n\nclass ImageService\n{\n    protected $imageTool;\n    protected $cache;\n    protected $storageUrl;\n    protected $image;\n    protected $fileSystem;\n\n    /**\n     * ImageService constructor.\n     */\n    public function __construct(Image $image, ImageManager $imageTool, FileSystem $fileSystem, Cache $cache)\n    {\n        $this->image = $image;\n        $this->imageTool = $imageTool;\n        $this->fileSystem = $fileSystem;\n        $this->cache = $cache;\n    }\n\n    /**\n     * Get the storage that will be used for storing images.\n     */\n    protected function getStorageDisk(string $imageType = ''): FileSystemInstance\n    {\n        return $this->fileSystem->disk($this->getStorageDiskName($imageType));\n    }\n\n    /**\n     * Check if local secure image storage (Fetched behind authentication)\n     * is currently active in the instance.\n     */\n    protected function usingSecureImages(): bool\n    {\n        return $this->getStorageDiskName('gallery') === 'local_secure_images';\n    }\n\n    /**\n     * Change the originally provided path to fit any disk-specific requirements.\n     * This also ensures the path is kept to the expected root folders.\n     */\n    protected function adjustPathForStorageDisk(string $path, string $imageType = ''): string\n    {\n        $path = Util::normalizePath(str_replace('uploads/images/', '', $path));\n\n        if ($this->getStorageDiskName($imageType) === 'local_secure_images') {\n            return $path;\n        }\n\n        return 'uploads/images/' . $path;\n    }\n\n    /**\n     * Get the name of the storage disk to use.\n     */\n    protected function getStorageDiskName(string $imageType): string\n    {\n        $storageType = config('filesystems.images');\n\n        // Ensure system images (App logo) are uploaded to a public space\n        if ($imageType === 'system' && $storageType === 'local_secure') {\n            $storageType = 'local';\n        }\n\n        if ($storageType === 'local_secure') {\n            $storageType = 'local_secure_images';\n        }\n\n        return $storageType;\n    }\n\n    /**\n     * Saves a new image from an upload.\n     *\n     * @throws ImageUploadException\n     *\n     * @return mixed\n     */\n    public function saveNewFromUpload(\n        UploadedFile $uploadedFile,\n        string $type,\n        int $uploadedTo = 0,\n        int $resizeWidth = null,\n        int $resizeHeight = null,\n        bool $keepRatio = true\n    ) {\n        $imageName = $uploadedFile->getClientOriginalName();\n        $imageData = file_get_contents($uploadedFile->getRealPath());\n\n        if ($resizeWidth !== null || $resizeHeight !== null) {\n            $imageData = $this->resizeImage($imageData, $resizeWidth, $resizeHeight, $keepRatio);\n        }\n\n        return $this->saveNew($imageName, $imageData, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image from a uri-encoded base64 string of data.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNewFromBase64Uri(string $base64Uri, string $name, string $type, int $uploadedTo = 0): Image\n    {\n        $splitData = explode(';base64,', $base64Uri);\n        if (count($splitData) < 2) {\n            throw new ImageUploadException('Invalid base64 image data provided');\n        }\n        $data = base64_decode($splitData[1]);\n\n        return $this->saveNew($name, $data, $type, $uploadedTo);\n    }\n\n    /**\n     * Save a new image into storage.\n     *\n     * @throws ImageUploadException\n     */\n    public function saveNew(string $imageName, string $imageData, string $type, int $uploadedTo = 0): Image\n    {\n        $storage = $this->getStorageDisk($type);\n        $secureUploads = setting('app-secure-images');\n        $fileName = $this->cleanImageFileName($imageName);\n\n        $imagePath = '/uploads/images/' . $type . '/' . date('Y-m') . '/';\n\n        while ($storage->exists($this->adjustPathForStorageDisk($imagePath . $fileName, $type))) {\n            $fileName = Str::random(3) . $fileName;\n        }\n\n        $fullPath = $imagePath . $fileName;\n        if ($secureUploads) {\n            $fullPath = $imagePath . Str::random(16) . '-' . $fileName;\n        }\n\n        try {\n            $this->saveImageDataInPublicSpace($storage, $this->adjustPathForStorageDisk($fullPath, $type), $imageData);\n        } catch (Exception $e) {\n            \\Log::error('Error when attempting image upload:' . $e->getMessage());\n\n            throw new ImageUploadException(trans('errors.path_not_writable', ['filePath' => $fullPath]));\n        }\n\n        $imageDetails = [\n            'name'        => $imageName,\n            'path'        => $fullPath,\n            'url'         => $this->getPublicUrl($fullPath),\n            'type'        => $type,\n            'uploaded_to' => $uploadedTo,\n        ];\n\n        if (user()->id !== 0) {\n            $userId = user()->id;\n            $imageDetails['created_by'] = $userId;\n            $imageDetails['updated_by'] = $userId;\n        }\n\n        $image = $this->image->newInstance();\n        $image->forceFill($imageDetails)->save();\n\n        return $image;\n    }\n\n    /**\n     * Save image data for the given path in the public space, if possible,\n     * for the provided storage mechanism.\n     */\n    protected function saveImageDataInPublicSpace(Storage $storage, string $path, string $data)\n    {\n        $storage->put($path, $data);\n\n        // Set visibility when a non-AWS-s3, s3-like storage option is in use.\n        // Done since this call can break s3-like services but desired for other image stores.\n        // Attempting to set ACL during above put request requires different permissions\n        // hence would technically be a breaking change for actual s3 usage.\n        $usingS3 = strtolower(config('filesystems.images')) === 's3';\n        $usingS3Like = $usingS3 && !is_null(config('filesystems.disks.s3.endpoint'));\n        if (!$usingS3Like) {\n            $storage->setVisibility($path, 'public');\n        }\n    }\n\n    /**\n     * Clean up an image file name to be both URL and storage safe.\n     */\n    protected function cleanImageFileName(string $name): string\n    {\n        $name = str_replace(' ', '-', $name);\n        $nameParts = explode('.', $name);\n        $extension = array_pop($nameParts);\n        $name = implode('-', $nameParts);\n        $name = Str::slug($name);\n\n        if (strlen($name) === 0) {\n            $name = Str::random(10);\n        }\n\n        return $name . '.' . $extension;\n    }\n\n    /**\n     * Checks if the image is a gif. Returns true if it is, else false.\n     */\n    protected function isGif(Image $image): bool\n    {\n        return strtolower(pathinfo($image->path, PATHINFO_EXTENSION)) === 'gif';\n    }\n\n    /**\n     * Get the thumbnail for an image.\n     * If $keepRatio is true only the width will be used.\n     * Checks the cache then storage to avoid creating / accessing the filesystem on every check.\n     *\n     * @param Image $image\n     * @param int   $width\n     * @param int   $height\n     * @param bool  $keepRatio\n     *\n     * @throws Exception\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    public function getThumbnail(Image $image, $width = 220, $height = 220, $keepRatio = false)\n    {\n        if ($keepRatio && $this->isGif($image)) {\n            return $this->getPublicUrl($image->path);\n        }\n\n        $thumbDirName = '/' . ($keepRatio ? 'scaled-' : 'thumbs-') . $width . '-' . $height . '/';\n        $imagePath = $image->path;\n        $thumbFilePath = dirname($imagePath) . $thumbDirName . basename($imagePath);\n\n        if ($this->cache->has('images-' . $image->id . '-' . $thumbFilePath) && $this->cache->get('images-' . $thumbFilePath)) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $storage = $this->getStorageDisk($image->type);\n        if ($storage->exists($this->adjustPathForStorageDisk($thumbFilePath, $image->type))) {\n            return $this->getPublicUrl($thumbFilePath);\n        }\n\n        $thumbData = $this->resizeImage($storage->get($this->adjustPathForStorageDisk($imagePath, $image->type)), $width, $height, $keepRatio);\n\n        $this->saveImageDataInPublicSpace($storage, $this->adjustPathForStorageDisk($thumbFilePath, $image->type), $thumbData);\n        $this->cache->put('images-' . $image->id . '-' . $thumbFilePath, $thumbFilePath, 60 * 60 * 72);\n\n        return $this->getPublicUrl($thumbFilePath);\n    }\n\n    /**\n     * Resize image data.\n     *\n     * @param string $imageData\n     * @param int    $width\n     * @param int    $height\n     * @param bool   $keepRatio\n     *\n     * @throws ImageUploadException\n     *\n     * @return string\n     */\n    protected function resizeImage(string $imageData, $width = 220, $height = null, bool $keepRatio = true)\n    {\n        try {\n            $thumb = $this->imageTool->make($imageData);\n        } catch (Exception $e) {\n            if ($e instanceof ErrorException || $e instanceof NotSupportedException) {\n                throw new ImageUploadException(trans('errors.cannot_create_thumbs'));\n            }\n\n            throw $e;\n        }\n\n        if ($keepRatio) {\n            $thumb->resize($width, $height, function ($constraint) {\n                $constraint->aspectRatio();\n                $constraint->upsize();\n            });\n        } else {\n            $thumb->fit($width, $height);\n        }\n\n        $thumbData = (string) $thumb->encode();\n\n        // Use original image data if we're keeping the ratio\n        // and the resizing does not save any space.\n        if ($keepRatio && strlen($thumbData) > strlen($imageData)) {\n            return $imageData;\n        }\n\n        return $thumbData;\n    }\n\n    /**\n     * Get the raw data content from an image.\n     *\n     * @throws FileNotFoundException\n     */\n    public function getImageData(Image $image): string\n    {\n        $storage = $this->getStorageDisk();\n\n        return $storage->get($this->adjustPathForStorageDisk($image->path, $image->type));\n    }\n\n    /**\n     * Destroy an image along with its revisions, thumbnails and remaining folders.\n     *\n     * @throws Exception\n     */\n    public function destroy(Image $image)\n    {\n        $this->destroyImagesFromPath($image->path, $image->type);\n        $image->delete();\n    }\n\n    /**\n     * Destroys an image at the given path.\n     * Searches for image thumbnails in addition to main provided path.\n     */\n    protected function destroyImagesFromPath(string $path, string $imageType): bool\n    {\n        $path = $this->adjustPathForStorageDisk($path, $imageType);\n        $storage = $this->getStorageDisk($imageType);\n\n        $imageFolder = dirname($path);\n        $imageFileName = basename($path);\n        $allImages = collect($storage->allFiles($imageFolder));\n\n        // Delete image files\n        $imagesToDelete = $allImages->filter(function ($imagePath) use ($imageFileName) {\n            return basename($imagePath) === $imageFileName;\n        });\n        $storage->delete($imagesToDelete->all());\n\n        // Cleanup of empty folders\n        $foldersInvolved = array_merge([$imageFolder], $storage->directories($imageFolder));\n        foreach ($foldersInvolved as $directory) {\n            if ($this->isFolderEmpty($storage, $directory)) {\n                $storage->deleteDirectory($directory);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether a folder is empty.\n     */\n    protected function isFolderEmpty(FileSystemInstance $storage, string $path): bool\n    {\n        $files = $storage->files($path);\n        $folders = $storage->directories($path);\n\n        return count($files) === 0 && count($folders) === 0;\n    }\n\n    /**\n     * Delete gallery and drawings that are not within HTML content of pages or page revisions.\n     * Checks based off of only the image name.\n     * Could be much improved to be more specific but kept it generic for now to be safe.\n     *\n     * Returns the path of the images that would be/have been deleted.\n     */\n    public function deleteUnusedImages(bool $checkRevisions = true, bool $dryRun = true)\n    {\n        $types = ['gallery', 'drawio'];\n        $deletedPaths = [];\n\n        $this->image->newQuery()->whereIn('type', $types)\n            ->chunk(1000, function ($images) use ($checkRevisions, &$deletedPaths, $dryRun) {\n                foreach ($images as $image) {\n                    $searchQuery = '%' . basename($image->path) . '%';\n                    $inPage = DB::table('pages')\n                            ->where('html', 'like', $searchQuery)->count() > 0;\n\n                    $inRevision = false;\n                    if ($checkRevisions) {\n                        $inRevision = DB::table('page_revisions')\n                                ->where('html', 'like', $searchQuery)->count() > 0;\n                    }\n\n                    if (!$inPage && !$inRevision) {\n                        $deletedPaths[] = $image->path;\n                        if (!$dryRun) {\n                            $this->destroy($image);\n                        }\n                    }\n                }\n            });\n\n        return $deletedPaths;\n    }\n\n    /**\n     * Convert an image URI to a Base64 encoded string.\n     * Attempts to convert the URL to a system storage url then\n     * fetch the data from the disk or storage location.\n     * Returns null if the image data cannot be fetched from storage.\n     *\n     * @throws FileNotFoundException\n     */\n    public function imageUriToBase64(string $uri): ?string\n    {\n        $storagePath = $this->imageUrlToStoragePath($uri);\n        if (empty($uri) || is_null($storagePath)) {\n            return null;\n        }\n\n        $storagePath = $this->adjustPathForStorageDisk($storagePath);\n        $storage = $this->getStorageDisk();\n        $imageData = null;\n        if ($storage->exists($storagePath)) {\n            $imageData = $storage->get($storagePath);\n        }\n\n        if (is_null($imageData)) {\n            return null;\n        }\n\n        $extension = pathinfo($uri, PATHINFO_EXTENSION);\n        if ($extension === 'svg') {\n            $extension = 'svg+xml';\n        }\n\n        return 'data:image/' . $extension . ';base64,' . base64_encode($imageData);\n    }\n\n    /**\n     * Check if the given path exists in the local secure image system.\n     * Returns false if local_secure is not in use.\n     */\n    public function pathExistsInLocalSecure(string $imagePath): bool\n    {\n        $disk = $this->getStorageDisk('gallery');\n\n        // Check local_secure is active\n        return $this->usingSecureImages()\n            // Check the image file exists\n            && $disk->exists($imagePath)\n            // Check the file is likely an image file\n            && strpos($disk->getMimetype($imagePath), 'image/') === 0;\n    }\n\n    /**\n     * For the given path, if existing, provide a response that will stream the image contents.\n     */\n    public function streamImageFromStorageResponse(string $imageType, string $path): StreamedResponse\n    {\n        $disk = $this->getStorageDisk($imageType);\n        return $disk->response($path);\n    }\n\n    /**\n     * Get a storage path for the given image URL.\n     * Ensures the path will start with \"uploads/images\".\n     * Returns null if the url cannot be resolved to a local URL.\n     */\n    private function imageUrlToStoragePath(string $url): ?string\n    {\n        $url = ltrim(trim($url), '/');\n\n        // Handle potential relative paths\n        $isRelative = strpos($url, 'http') !== 0;\n        if ($isRelative) {\n            if (strpos(strtolower($url), 'uploads/images') === 0) {\n                return trim($url, '/');\n            }\n\n            return null;\n        }\n\n        // Handle local images based on paths on the same domain\n        $potentialHostPaths = [\n            url('uploads/images/'),\n            $this->getPublicUrl('/uploads/images/'),\n        ];\n\n        foreach ($potentialHostPaths as $potentialBasePath) {\n            $potentialBasePath = strtolower($potentialBasePath);\n            if (strpos(strtolower($url), $potentialBasePath) === 0) {\n                return 'uploads/images/' . trim(substr($url, strlen($potentialBasePath)), '/');\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets a public facing url for an image by checking relevant environment variables.\n     * If s3-style store is in use it will default to guessing a public bucket URL.\n     */\n    private function getPublicUrl(string $filePath): string\n    {\n        if ($this->storageUrl === null) {\n            $storageUrl = config('filesystems.url');\n\n            // Get the standard public s3 url if s3 is set as storage type\n            // Uses the nice, short URL if bucket name has no periods in otherwise the longer\n            // region-based url will be used to prevent http issues.\n            if ($storageUrl == false && config('filesystems.images') === 's3') {\n                $storageDetails = config('filesystems.disks.s3');\n                if (strpos($storageDetails['bucket'], '.') === false) {\n                    $storageUrl = 'https://' . $storageDetails['bucket'] . '.s3.amazonaws.com';\n                } else {\n                    $storageUrl = 'https://s3-' . $storageDetails['region'] . '.amazonaws.com/' . $storageDetails['bucket'];\n                }\n            }\n            $this->storageUrl = $storageUrl;\n        }\n\n        $basePath = ($this->storageUrl == false) ? url('/') : $this->storageUrl;\n\n        return rtrim($basePath, '/') . $filePath;\n    }\n}\n", "<?php\n\nnamespace Tests\\Uploads;\n\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Entities\\Repos\\PageRepo;\nuse BookStack\\Uploads\\Image;\nuse BookStack\\Uploads\\ImageService;\nuse Illuminate\\Support\\Str;\nuse Tests\\TestCase;\n\nclass ImageTest extends TestCase\n{\n    use UsesImages;\n\n    public function test_image_upload()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $imgDetails = $this->uploadGalleryImage($page);\n        $relPath = $imgDetails['path'];\n\n        $this->assertTrue(file_exists(public_path($relPath)), 'Uploaded image found at path: ' . public_path($relPath));\n\n        $this->deleteImage($relPath);\n\n        $this->assertDatabaseHas('images', [\n            'url'         => $this->baseUrl . $relPath,\n            'type'        => 'gallery',\n            'uploaded_to' => $page->id,\n            'path'        => $relPath,\n            'created_by'  => $admin->id,\n            'updated_by'  => $admin->id,\n            'name'        => $imgDetails['name'],\n        ]);\n    }\n\n    public function test_image_display_thumbnail_generation_does_not_increase_image_size()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $originalFile = $this->getTestImageFilePath('compressed.png');\n        $originalFileSize = filesize($originalFile);\n        $imgDetails = $this->uploadGalleryImage($page, 'compressed.png');\n        $relPath = $imgDetails['path'];\n\n        $this->assertTrue(file_exists(public_path($relPath)), 'Uploaded image found at path: ' . public_path($relPath));\n        $displayImage = $imgDetails['response']->thumbs->display;\n\n        $displayImageRelPath = implode('/', array_slice(explode('/', $displayImage), 3));\n        $displayImagePath = public_path($displayImageRelPath);\n        $displayFileSize = filesize($displayImagePath);\n\n        $this->deleteImage($relPath);\n        $this->deleteImage($displayImageRelPath);\n\n        $this->assertEquals($originalFileSize, $displayFileSize, 'Display thumbnail generation should not increase image size');\n    }\n\n    public function test_image_edit()\n    {\n        $editor = $this->getEditor();\n        $this->actingAs($editor);\n\n        $imgDetails = $this->uploadGalleryImage();\n        $image = Image::query()->first();\n\n        $newName = Str::random();\n        $update = $this->put('/images/' . $image->id, ['name' => $newName]);\n        $update->assertSuccessful();\n        $update->assertSee($newName);\n\n        $this->deleteImage($imgDetails['path']);\n\n        $this->assertDatabaseHas('images', [\n            'type' => 'gallery',\n            'name' => $newName,\n        ]);\n    }\n\n    public function test_gallery_get_list_format()\n    {\n        $this->asEditor();\n\n        $imgDetails = $this->uploadGalleryImage();\n        $image = Image::query()->first();\n\n        $pageId = $imgDetails['page']->id;\n        $firstPageRequest = $this->get(\"/images/gallery?page=1&uploaded_to={$pageId}\");\n        $firstPageRequest->assertSuccessful()->assertElementExists('div');\n        $firstPageRequest->assertSuccessful()->assertSeeText($image->name);\n\n        $secondPageRequest = $this->get(\"/images/gallery?page=2&uploaded_to={$pageId}\");\n        $secondPageRequest->assertSuccessful()->assertElementNotExists('div');\n\n        $namePartial = substr($imgDetails['name'], 0, 3);\n        $searchHitRequest = $this->get(\"/images/gallery?page=1&uploaded_to={$pageId}&search={$namePartial}\");\n        $searchHitRequest->assertSuccessful()->assertSee($imgDetails['name']);\n\n        $namePartial = Str::random(16);\n        $searchFailRequest = $this->get(\"/images/gallery?page=1&uploaded_to={$pageId}&search={$namePartial}\");\n        $searchFailRequest->assertSuccessful()->assertDontSee($imgDetails['name']);\n        $searchFailRequest->assertSuccessful()->assertElementNotExists('div');\n    }\n\n    public function test_image_usage()\n    {\n        $page = Page::query()->first();\n        $editor = $this->getEditor();\n        $this->actingAs($editor);\n\n        $imgDetails = $this->uploadGalleryImage($page);\n\n        $image = Image::query()->first();\n        $page->html = '<img src=\"' . $image->url . '\">';\n        $page->save();\n\n        $usage = $this->get('/images/edit/' . $image->id . '?delete=true');\n        $usage->assertSuccessful();\n        $usage->assertSeeText($page->name);\n        $usage->assertSee($page->getUrl());\n\n        $this->deleteImage($imgDetails['path']);\n    }\n\n    public function test_php_files_cannot_be_uploaded()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $fileName = 'bad.php';\n        $relPath = $this->getTestImagePath('gallery', $fileName);\n        $this->deleteImage($relPath);\n\n        $file = $this->newTestImageFromBase64('bad-php.base64', $fileName);\n        $upload = $this->withHeader('Content-Type', 'image/jpeg')->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $file], []);\n        $upload->assertStatus(302);\n\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded php file was uploaded but should have been stopped');\n\n        $this->assertDatabaseMissing('images', [\n            'type' => 'gallery',\n            'name' => $fileName,\n        ]);\n    }\n\n    public function test_php_like_files_cannot_be_uploaded()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $fileName = 'bad.phtml';\n        $relPath = $this->getTestImagePath('gallery', $fileName);\n        $this->deleteImage($relPath);\n\n        $file = $this->newTestImageFromBase64('bad-phtml.base64', $fileName);\n        $upload = $this->withHeader('Content-Type', 'image/jpeg')->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $file], []);\n        $upload->assertStatus(302);\n\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded php file was uploaded but should have been stopped');\n    }\n\n    public function test_files_with_double_extensions_will_get_sanitized()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $fileName = 'bad.phtml.png';\n        $relPath = $this->getTestImagePath('gallery', $fileName);\n        $expectedRelPath = dirname($relPath) . '/bad-phtml.png';\n        $this->deleteImage($expectedRelPath);\n\n        $file = $this->newTestImageFromBase64('bad-phtml-png.base64', $fileName);\n        $upload = $this->withHeader('Content-Type', 'image/png')->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $file], []);\n        $upload->assertStatus(200);\n\n        $lastImage = Image::query()->latest('id')->first();\n\n        $this->assertEquals('bad.phtml.png', $lastImage->name);\n        $this->assertEquals('bad-phtml.png', basename($lastImage->path));\n        $this->assertFileDoesNotExist(public_path($relPath), 'Uploaded image file name was not stripped of dots');\n        $this->assertFileExists(public_path($expectedRelPath));\n\n        $this->deleteImage($lastImage->path);\n    }\n\n    public function test_url_entities_removed_from_filenames()\n    {\n        $this->asEditor();\n        $badNames = [\n            'bad-char-#-image.png',\n            'bad-char-?-image.png',\n            '?#.png',\n            '?.png',\n            '#.png',\n        ];\n        foreach ($badNames as $name) {\n            $galleryFile = $this->getTestImage($name);\n            $page = Page::query()->first();\n            $badPath = $this->getTestImagePath('gallery', $name);\n            $this->deleteImage($badPath);\n\n            $upload = $this->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $galleryFile], []);\n            $upload->assertStatus(200);\n\n            $lastImage = Image::query()->latest('id')->first();\n            $newFileName = explode('.', basename($lastImage->path))[0];\n\n            $this->assertEquals($lastImage->name, $name);\n            $this->assertFalse(strpos($lastImage->path, $name), 'Path contains original image name');\n            $this->assertFalse(file_exists(public_path($badPath)), 'Uploaded image file name was not stripped of url entities');\n\n            $this->assertTrue(strlen($newFileName) > 0, 'File name was reduced to nothing');\n\n            $this->deleteImage($lastImage->path);\n        }\n    }\n\n    public function test_secure_images_uploads_to_correct_place()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asEditor();\n        $galleryFile = $this->getTestImage('my-secure-test-upload.png');\n        $page = Page::query()->first();\n        $expectedPath = storage_path('uploads/images/gallery/' . date('Y-m') . '/my-secure-test-upload.png');\n\n        $upload = $this->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $galleryFile], []);\n        $upload->assertStatus(200);\n\n        $this->assertTrue(file_exists($expectedPath), 'Uploaded image not found at path: ' . $expectedPath);\n\n        if (file_exists($expectedPath)) {\n            unlink($expectedPath);\n        }\n    }\n\n    public function test_secure_image_paths_traversal_causes_500()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asEditor();\n\n        $resp = $this->get('/uploads/images/../../logs/laravel.log');\n        $resp->assertStatus(500);\n    }\n\n    public function test_secure_image_paths_traversal_on_non_secure_images_causes_404()\n    {\n        config()->set('filesystems.images', 'local');\n        $this->asEditor();\n\n        $resp = $this->get('/uploads/images/../../logs/laravel.log');\n        $resp->assertStatus(404);\n    }\n\n    public function test_secure_image_paths_dont_serve_non_images()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asEditor();\n\n        $testFilePath = storage_path('/uploads/images/testing.txt');\n        file_put_contents($testFilePath, 'hello from test_secure_image_paths_dont_serve_non_images');\n\n        $resp = $this->get('/uploads/images/testing.txt');\n        $resp->assertStatus(404);\n    }\n\n    public function test_secure_images_included_in_exports()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asEditor();\n        $galleryFile = $this->getTestImage('my-secure-test-upload.png');\n        $page = Page::query()->first();\n        $expectedPath = storage_path('uploads/images/gallery/' . date('Y-m') . '/my-secure-test-upload.png');\n\n        $upload = $this->call('POST', '/images/gallery', ['uploaded_to' => $page->id], [], ['file' => $galleryFile], []);\n        $imageUrl = json_decode($upload->getContent(), true)['url'];\n        $page->html .= \"<img src=\\\"{$imageUrl}\\\">\";\n        $page->save();\n        $upload->assertStatus(200);\n\n        $encodedImageContent = base64_encode(file_get_contents($expectedPath));\n        $export = $this->get($page->getUrl('/export/html'));\n        $this->assertTrue(strpos($export->getContent(), $encodedImageContent) !== false, 'Uploaded image in export content');\n\n        if (file_exists($expectedPath)) {\n            unlink($expectedPath);\n        }\n    }\n\n    public function test_system_images_remain_public()\n    {\n        config()->set('filesystems.images', 'local_secure');\n        $this->asAdmin();\n        $galleryFile = $this->getTestImage('my-system-test-upload.png');\n        $expectedPath = public_path('uploads/images/system/' . date('Y-m') . '/my-system-test-upload.png');\n\n        $upload = $this->call('POST', '/settings', [], [], ['app_logo' => $galleryFile], []);\n        $upload->assertRedirect('/settings');\n\n        $this->assertTrue(file_exists($expectedPath), 'Uploaded image not found at path: ' . $expectedPath);\n\n        if (file_exists($expectedPath)) {\n            unlink($expectedPath);\n        }\n    }\n\n    public function test_image_delete()\n    {\n        $page = Page::query()->first();\n        $this->asAdmin();\n        $imageName = 'first-image.png';\n        $relPath = $this->getTestImagePath('gallery', $imageName);\n        $this->deleteImage($relPath);\n\n        $this->uploadImage($imageName, $page->id);\n        $image = Image::first();\n\n        $delete = $this->delete('/images/' . $image->id);\n        $delete->assertStatus(200);\n\n        $this->assertDatabaseMissing('images', [\n            'url'  => $this->baseUrl . $relPath,\n            'type' => 'gallery',\n        ]);\n\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded image has not been deleted as expected');\n    }\n\n    public function test_image_delete_does_not_delete_similar_images()\n    {\n        $page = Page::query()->first();\n        $this->asAdmin();\n        $imageName = 'first-image.png';\n\n        $relPath = $this->getTestImagePath('gallery', $imageName);\n        $this->deleteImage($relPath);\n\n        $this->uploadImage($imageName, $page->id);\n        $this->uploadImage($imageName, $page->id);\n        $this->uploadImage($imageName, $page->id);\n\n        $image = Image::first();\n        $folder = public_path(dirname($relPath));\n        $imageCount = count(glob($folder . '/*'));\n\n        $delete = $this->delete('/images/' . $image->id);\n        $delete->assertStatus(200);\n\n        $newCount = count(glob($folder . '/*'));\n        $this->assertEquals($imageCount - 1, $newCount, 'More files than expected have been deleted');\n        $this->assertFalse(file_exists(public_path($relPath)), 'Uploaded image has not been deleted as expected');\n    }\n\n    protected function getTestProfileImage()\n    {\n        $imageName = 'profile.png';\n        $relPath = $this->getTestImagePath('user', $imageName);\n        $this->deleteImage($relPath);\n\n        return $this->getTestImage($imageName);\n    }\n\n    public function test_user_image_upload()\n    {\n        $editor = $this->getEditor();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $file = $this->getTestProfileImage();\n        $this->call('PUT', '/settings/users/' . $editor->id, [], [], ['profile_image' => $file], []);\n\n        $this->assertDatabaseHas('images', [\n            'type'        => 'user',\n            'uploaded_to' => $editor->id,\n            'created_by'  => $admin->id,\n        ]);\n    }\n\n    public function test_user_images_deleted_on_user_deletion()\n    {\n        $editor = $this->getEditor();\n        $this->actingAs($editor);\n\n        $file = $this->getTestProfileImage();\n        $this->call('PUT', '/settings/users/' . $editor->id, [], [], ['profile_image' => $file], []);\n\n        $profileImages = Image::where('type', '=', 'user')->where('created_by', '=', $editor->id)->get();\n        $this->assertTrue($profileImages->count() === 1, 'Found profile images does not match upload count');\n\n        $imagePath = public_path($profileImages->first()->path);\n        $this->assertTrue(file_exists($imagePath));\n\n        $userDelete = $this->asAdmin()->delete(\"/settings/users/{$editor->id}\");\n        $userDelete->assertStatus(302);\n\n        $this->assertDatabaseMissing('images', [\n            'type'       => 'user',\n            'created_by' => $editor->id,\n        ]);\n        $this->assertDatabaseMissing('images', [\n            'type'        => 'user',\n            'uploaded_to' => $editor->id,\n        ]);\n\n        $this->assertFalse(file_exists($imagePath));\n    }\n\n    public function test_deleted_unused_images()\n    {\n        $page = Page::query()->first();\n        $admin = $this->getAdmin();\n        $this->actingAs($admin);\n\n        $imageName = 'unused-image.png';\n        $relPath = $this->getTestImagePath('gallery', $imageName);\n        $this->deleteImage($relPath);\n\n        $upload = $this->uploadImage($imageName, $page->id);\n        $upload->assertStatus(200);\n        $image = Image::where('type', '=', 'gallery')->first();\n\n        $pageRepo = app(PageRepo::class);\n        $pageRepo->update($page, [\n            'name'    => $page->name,\n            'html'    => $page->html . \"<img src=\\\"{$image->url}\\\">\",\n            'summary' => '',\n        ]);\n\n        // Ensure no images are reported as deletable\n        $imageService = app(ImageService::class);\n        $toDelete = $imageService->deleteUnusedImages(true, true);\n        $this->assertCount(0, $toDelete);\n\n        // Save a revision of our page without the image;\n        $pageRepo->update($page, [\n            'name'    => $page->name,\n            'html'    => '<p>Hello</p>',\n            'summary' => '',\n        ]);\n\n        // Ensure revision images are picked up okay\n        $imageService = app(ImageService::class);\n        $toDelete = $imageService->deleteUnusedImages(true, true);\n        $this->assertCount(0, $toDelete);\n        $toDelete = $imageService->deleteUnusedImages(false, true);\n        $this->assertCount(1, $toDelete);\n\n        // Check image is found when revisions are destroyed\n        $page->revisions()->delete();\n        $toDelete = $imageService->deleteUnusedImages(true, true);\n        $this->assertCount(1, $toDelete);\n\n        // Check the image is deleted\n        $absPath = public_path($relPath);\n        $this->assertTrue(file_exists($absPath), \"Existing uploaded file at path {$absPath} exists\");\n        $toDelete = $imageService->deleteUnusedImages(true, false);\n        $this->assertCount(1, $toDelete);\n        $this->assertFalse(file_exists($absPath));\n\n        $this->deleteImage($relPath);\n    }\n}\n"], "filenames": ["app/Http/Controllers/Images/ImageController.php", "app/Uploads/AttachmentService.php", "app/Uploads/ImageService.php", "tests/Uploads/ImageTest.php"], "buggy_code_start_loc": [9, 30, 18, 243], "buggy_code_end_loc": [46, 217, 435, 243], "fixing_code_start_loc": [10, 30, 19, 244], "fixing_code_end_loc": [51, 217, 471, 274], "type": "CWE-22", "message": "bookstack is vulnerable to Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "other": {"cve": {"id": "CVE-2021-3916", "sourceIdentifier": "security@huntr.dev", "published": "2021-11-05T15:15:07.890", "lastModified": "2021-11-09T15:12:50.740", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "bookstack is vulnerable to Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"}, {"lang": "es", "value": "bookstack es vulnerable a una Limitaci\u00f3n Inapropiada de un Nombre de Ruta a un Directorio Restringido (\"Salto de Ruta\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bookstackapp:bookstack:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.10.3", "matchCriteriaId": "8A95589D-22C1-4F53-827C-5CB7BD5B1D1E"}]}]}], "references": [{"url": "https://github.com/bookstackapp/bookstack/commit/43830a372fc51a8793199d04a34c3f4ebdfccc7b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/0be32e6b-7c48-43f0-9cec-433000ad8f64", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bookstackapp/bookstack/commit/43830a372fc51a8793199d04a34c3f4ebdfccc7b"}}