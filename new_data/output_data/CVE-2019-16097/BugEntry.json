{"buggy_code": ["// Copyright 2018 Project Harbor Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage api\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/goharbor/harbor/src/common\"\n\t\"github.com/goharbor/harbor/src/common/dao\"\n\t\"github.com/goharbor/harbor/src/common/models\"\n\t\"github.com/goharbor/harbor/src/common/rbac\"\n\t\"github.com/goharbor/harbor/src/common/rbac/project\"\n\t\"github.com/goharbor/harbor/src/common/utils\"\n\t\"github.com/goharbor/harbor/src/common/utils/log\"\n\t\"github.com/goharbor/harbor/src/core/config\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strconv\"\n)\n\n// UserAPI handles request to /api/users/{}\ntype UserAPI struct {\n\tBaseController\n\tcurrentUserID    int\n\tuserID           int\n\tSelfRegistration bool\n\tIsAdmin          bool\n\tAuthMode         string\n\tsecretKey        string\n}\n\ntype passwordReq struct {\n\tOldPassword string `json:\"old_password\"`\n\tNewPassword string `json:\"new_password\"`\n}\n\ntype userSearch struct {\n\tUserID   int    `json:\"user_id\"`\n\tUsername string `json:\"username\"`\n}\n\ntype secretResp struct {\n\tSecret string `json:\"secret\"`\n}\n\n// Prepare validates the URL and parms\nfunc (ua *UserAPI) Prepare() {\n\tua.BaseController.Prepare()\n\tmode, err := config.AuthMode()\n\tif err != nil {\n\t\tlog.Errorf(\"failed to get auth mode: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tua.AuthMode = mode\n\tif mode == common.OIDCAuth {\n\t\tkey, err := config.SecretKey()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"failed to get secret key: %v\", err)\n\t\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get secret key: %v\", err))\n\t\t\treturn\n\t\t}\n\t\tua.secretKey = key\n\t}\n\n\tself, err := config.SelfRegistration()\n\tif err != nil {\n\t\tlog.Errorf(\"failed to get self registration: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tua.SelfRegistration = self\n\n\tif !ua.SecurityCtx.IsAuthenticated() {\n\t\tif ua.Ctx.Input.IsPost() {\n\t\t\treturn\n\t\t}\n\t\tua.SendUnAuthorizedError(errors.New(\"UnAuthorize\"))\n\t\treturn\n\t}\n\n\tuser, err := dao.GetUser(models.User{\n\t\tUsername: ua.SecurityCtx.GetUsername(),\n\t})\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get user %s: %v\",\n\t\t\tua.SecurityCtx.GetUsername(), err))\n\t\treturn\n\t}\n\n\tif user == nil {\n\t\tlog.Errorf(\"User with username %s does not exist in DB.\", ua.SecurityCtx.GetUsername())\n\t\tua.SendInternalServerError(fmt.Errorf(\"user %s does not exist in DB\", ua.SecurityCtx.GetUsername()))\n\t\treturn\n\t}\n\n\tua.currentUserID = user.UserID\n\tid := ua.Ctx.Input.Param(\":id\")\n\tif id == \"current\" {\n\t\tua.userID = ua.currentUserID\n\t} else if len(id) > 0 {\n\t\tvar err error\n\t\tua.userID, err = strconv.Atoi(id)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Invalid user id, error: %v\", err)\n\t\t\tua.SendBadRequestError(errors.New(\"invalid user Id\"))\n\t\t\treturn\n\t\t}\n\t\tuserQuery := models.User{UserID: ua.userID}\n\t\tu, err := dao.GetUser(userQuery)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error occurred in GetUser, error: %v\", err)\n\t\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\t\treturn\n\t\t}\n\t\tif u == nil {\n\t\t\tlog.Errorf(\"User with Id: %d does not exist\", ua.userID)\n\t\t\tua.SendNotFoundError(errors.New(\"\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\tua.IsAdmin = ua.SecurityCtx.IsSysAdmin()\n}\n\n// Get ...\nfunc (ua *UserAPI) Get() {\n\tif ua.userID == ua.currentUserID || ua.IsAdmin {\n\t\tuserQuery := models.User{UserID: ua.userID}\n\t\tu, err := dao.GetUser(userQuery)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error occurred in GetUser, error: %v\", err)\n\t\t\tua.SendInternalServerError(err)\n\t\t\treturn\n\t\t}\n\t\tu.Password = \"\"\n\t\tif ua.userID == ua.currentUserID {\n\t\t\tu.HasAdminRole = ua.SecurityCtx.IsSysAdmin()\n\t\t}\n\t\tif ua.AuthMode == common.OIDCAuth {\n\t\t\to, err := ua.getOIDCUserInfo()\n\t\t\tif err != nil {\n\t\t\t\tua.SendInternalServerError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tu.OIDCUserMeta = o\n\t\t}\n\t\tua.Data[\"json\"] = u\n\t\tua.ServeJSON()\n\t\treturn\n\t}\n\n\tlog.Errorf(\"Current user, id: %d does not have admin role, can not view other user's detail\", ua.currentUserID)\n\tua.SendForbiddenError(errors.New(\"user does not have admin role\"))\n\treturn\n}\n\n// List ...\nfunc (ua *UserAPI) List() {\n\tif !ua.IsAdmin {\n\t\tlog.Errorf(\"Current user, id: %d does not have admin role, can not list users\", ua.currentUserID)\n\t\tua.SendForbiddenError(errors.New(\"user does not have admin role\"))\n\t\treturn\n\t}\n\n\tpage, size, err := ua.GetPaginationParams()\n\tif err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\n\tquery := &models.UserQuery{\n\t\tUsername: ua.GetString(\"username\"),\n\t\tEmail:    ua.GetString(\"email\"),\n\t\tPagination: &models.Pagination{\n\t\t\tPage: page,\n\t\t\tSize: size,\n\t\t},\n\t}\n\n\ttotal, err := dao.GetTotalOfUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get total of users: %v\", err))\n\t\treturn\n\t}\n\n\tusers, err := dao.ListUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get users: %v\", err))\n\t\treturn\n\t}\n\tfor i := range users {\n\t\tuser := &users[i]\n\t\tuser.Password = \"\"\n\t}\n\tua.SetPaginationHeader(total, page, size)\n\tua.Data[\"json\"] = users\n\tua.ServeJSON()\n}\n\n// Search ...\nfunc (ua *UserAPI) Search() {\n\tpage, size, err := ua.GetPaginationParams()\n\tif err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\tquery := &models.UserQuery{\n\t\tUsername: ua.GetString(\"username\"),\n\t\tEmail:    ua.GetString(\"email\"),\n\t\tPagination: &models.Pagination{\n\t\t\tPage: page,\n\t\t\tSize: size,\n\t\t},\n\t}\n\n\ttotal, err := dao.GetTotalOfUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get total of users: %v\", err))\n\t\treturn\n\t}\n\n\tusers, err := dao.ListUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get users: %v\", err))\n\t\treturn\n\t}\n\n\tvar userSearches []userSearch\n\tfor _, user := range users {\n\t\tuserSearches = append(userSearches, userSearch{UserID: user.UserID, Username: user.Username})\n\t}\n\n\tua.SetPaginationHeader(total, page, size)\n\tua.Data[\"json\"] = userSearches\n\tua.ServeJSON()\n}\n\n// Put ...\nfunc (ua *UserAPI) Put() {\n\tif !ua.modifiable() {\n\t\tua.SendForbiddenError(fmt.Errorf(\"User with ID %d cannot be modified\", ua.userID))\n\t\treturn\n\t}\n\tuser := models.User{UserID: ua.userID}\n\tif err := ua.DecodeJSONReq(&user); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\terr := commonValidate(user)\n\tif err != nil {\n\t\tlog.Warningf(\"Bad request in change user profile: %v\", err)\n\t\tua.SendBadRequestError(fmt.Errorf(\"change user profile error:\" + err.Error()))\n\t\treturn\n\t}\n\tuserQuery := models.User{UserID: ua.userID}\n\tu, err := dao.GetUser(userQuery)\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in GetUser, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\tif u == nil {\n\t\tlog.Errorf(\"User with Id: %d does not exist\", ua.userID)\n\t\tua.SendNotFoundError(errors.New(\"\"))\n\t\treturn\n\t}\n\tif u.Email != user.Email {\n\t\temailExist, err := dao.UserExists(user, \"email\")\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error occurred in change user profile: %v\", err)\n\t\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\t\treturn\n\t\t}\n\t\tif emailExist {\n\t\t\tlog.Warning(\"email has already been used!\")\n\t\t\tua.SendConflictError(errors.New(\"email has already been used\"))\n\t\t\treturn\n\t\t}\n\t}\n\tif err := dao.ChangeUserProfile(user); err != nil {\n\t\tlog.Errorf(\"Failed to update user profile, error: %v\", err)\n\t\tua.SendInternalServerError(err)\n\t\treturn\n\t}\n}\n\n// Post ...\nfunc (ua *UserAPI) Post() {\n\n\tif !(ua.AuthMode == common.DBAuth) {\n\t\tua.SendForbiddenError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tif !(ua.SelfRegistration || ua.IsAdmin) {\n\t\tlog.Warning(\"Registration can only be used by admin role user when self-registration is off.\")\n\t\tua.SendForbiddenError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tuser := models.User{}\n\tif err := ua.DecodeJSONReq(&user); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\terr := validate(user)\n\tif err != nil {\n\t\tlog.Warningf(\"Bad request in Register: %v\", err)\n\t\tua.RenderError(http.StatusBadRequest, \"register error:\"+err.Error())\n\t\treturn\n\t}\n\tuserExist, err := dao.UserExists(user, \"username\")\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in Register: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\tif userExist {\n\t\tlog.Warning(\"username has already been used!\")\n\t\tua.SendConflictError(errors.New(\"username has already been used\"))\n\t\treturn\n\t}\n\temailExist, err := dao.UserExists(user, \"email\")\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in change user profile: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\tif emailExist {\n\t\tlog.Warning(\"email has already been used!\")\n\t\tua.SendConflictError(errors.New(\"email has already been used\"))\n\t\treturn\n\t}\n\tuserID, err := dao.Register(user)\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in Register: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\n\tua.Redirect(http.StatusCreated, strconv.FormatInt(userID, 10))\n}\n\n// Delete ...\nfunc (ua *UserAPI) Delete() {\n\tif !ua.IsAdmin || ua.AuthMode != common.DBAuth || ua.userID == 1 || ua.currentUserID == ua.userID {\n\t\tua.SendForbiddenError(fmt.Errorf(\"User with ID: %d cannot be removed, auth mode: %s, current user ID: %d\", ua.userID, ua.AuthMode, ua.currentUserID))\n\t\treturn\n\t}\n\n\tvar err error\n\terr = dao.DeleteUser(ua.userID)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to delete data from database, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"failed to delete User\"))\n\t\treturn\n\t}\n}\n\n// ChangePassword handles PUT to /api/users/{}/password\nfunc (ua *UserAPI) ChangePassword() {\n\tif !ua.modifiable() {\n\t\tua.SendForbiddenError(fmt.Errorf(\"User with ID: %d is not modifiable\", ua.userID))\n\t\treturn\n\t}\n\n\tchangePwdOfOwn := ua.userID == ua.currentUserID\n\n\tvar req passwordReq\n\tif err := ua.DecodeJSONReq(&req); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\n\tif changePwdOfOwn && len(req.OldPassword) == 0 {\n\t\tua.SendBadRequestError(errors.New(\"empty old_password\"))\n\t\treturn\n\t}\n\n\tif len(req.NewPassword) == 0 {\n\t\tua.SendBadRequestError(errors.New(\"empty new_password\"))\n\t\treturn\n\t}\n\n\tuser, err := dao.GetUser(models.User{UserID: ua.userID})\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get user %d: %v\", ua.userID, err))\n\t\treturn\n\t}\n\tif user == nil {\n\t\tua.SendNotFoundError(fmt.Errorf(\"user %d not found\", ua.userID))\n\t\treturn\n\t}\n\tif changePwdOfOwn {\n\t\tif user.Password != utils.Encrypt(req.OldPassword, user.Salt) {\n\t\t\tlog.Info(\"incorrect old_password\")\n\t\t\tua.SendForbiddenError(errors.New(\"incorrect old_password\"))\n\t\t\treturn\n\t\t}\n\t}\n\tif user.Password == utils.Encrypt(req.NewPassword, user.Salt) {\n\t\tua.SendBadRequestError(errors.New(\"the new password can not be same with the old one\"))\n\t\treturn\n\t}\n\n\tupdatedUser := models.User{\n\t\tUserID:   ua.userID,\n\t\tPassword: req.NewPassword,\n\t}\n\tif err = dao.ChangeUserPassword(updatedUser); err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to change password of user %d: %v\", ua.userID, err))\n\t\treturn\n\t}\n}\n\n// ToggleUserAdminRole handles PUT api/users/{}/sysadmin\nfunc (ua *UserAPI) ToggleUserAdminRole() {\n\tif !ua.IsAdmin {\n\t\tlog.Warningf(\"current user, id: %d does not have admin role, can not update other user's role\", ua.currentUserID)\n\t\tua.RenderError(http.StatusForbidden, \"User does not have admin role\")\n\t\treturn\n\t}\n\tuserQuery := models.User{UserID: ua.userID}\n\tif err := ua.DecodeJSONReq(&userQuery); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\tif err := dao.ToggleUserAdminRole(userQuery.UserID, userQuery.HasAdminRole); err != nil {\n\t\tlog.Errorf(\"Error occurred in ToggleUserAdminRole: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n}\n\n// ListUserPermissions handles GET to /api/users/{}/permissions\nfunc (ua *UserAPI) ListUserPermissions() {\n\tif ua.userID != ua.currentUserID {\n\t\tlog.Warningf(\"Current user, id: %d can not view other user's permissions\", ua.currentUserID)\n\t\tua.RenderError(http.StatusForbidden, \"User does not have permission\")\n\t\treturn\n\t}\n\n\trelative := ua.Ctx.Input.Query(\"relative\") == \"true\"\n\n\tscope := rbac.Resource(ua.Ctx.Input.Query(\"scope\"))\n\tpolicies := []*rbac.Policy{}\n\n\tnamespace, err := scope.GetNamespace()\n\tif err == nil {\n\t\tswitch namespace.Kind() {\n\t\tcase \"project\":\n\t\t\tfor _, policy := range project.GetAllPolicies(namespace) {\n\t\t\t\tif ua.SecurityCtx.Can(policy.Action, policy.Resource) {\n\t\t\t\t\tpolicies = append(policies, policy)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tresults := []map[string]string{}\n\tfor _, policy := range policies {\n\t\tvar resource rbac.Resource\n\n\t\t// for resource `/project/1/repository` if `relative` is `true` then the resource in response will be `repository`\n\t\tif relative {\n\t\t\trelativeResource, err := policy.Resource.RelativeTo(scope)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tresource = relativeResource\n\t\t} else {\n\t\t\tresource = policy.Resource\n\t\t}\n\n\t\tresults = append(results, map[string]string{\n\t\t\t\"resource\": resource.String(),\n\t\t\t\"action\":   policy.Action.String(),\n\t\t})\n\t}\n\n\tua.Data[\"json\"] = results\n\tua.ServeJSON()\n\treturn\n}\n\n// GenCLISecret generates a new CLI secret and replace the old one\nfunc (ua *UserAPI) GenCLISecret() {\n\tif ua.AuthMode != common.OIDCAuth {\n\t\tua.SendPreconditionFailedError(errors.New(\"the auth mode has to be oidc auth\"))\n\t\treturn\n\t}\n\tif ua.userID != ua.currentUserID && !ua.IsAdmin {\n\t\tua.SendForbiddenError(errors.New(\"\"))\n\t\treturn\n\t}\n\toidcData, err := dao.GetOIDCUserByUserID(ua.userID)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get OIDC User meta for user, id: %d, error: %v\", ua.userID, err)\n\t\tua.SendInternalServerError(errors.New(\"failed to get OIDC meta data for user\"))\n\t\treturn\n\t}\n\tif oidcData == nil {\n\t\tlog.Errorf(\"User is not onboarded via OIDC AuthN, user id: %d\", ua.userID)\n\t\tua.SendPreconditionFailedError(errors.New(\"user is not onboarded via OIDC AuthN\"))\n\t\treturn\n\t}\n\n\tsec := utils.GenerateRandomString()\n\tencSec, err := utils.ReversibleEncrypt(sec, ua.secretKey)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to encrypt secret, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"failed to encrypt secret\"))\n\t\treturn\n\t}\n\toidcData.Secret = encSec\n\terr = dao.UpdateOIDCUserSecret(oidcData)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to update secret in DB, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"failed to update secret in DB\"))\n\t\treturn\n\t}\n\tua.Data[\"json\"] = secretResp{sec}\n\tua.ServeJSON()\n}\n\nfunc (ua *UserAPI) getOIDCUserInfo() (*models.OIDCUser, error) {\n\to, err := dao.GetOIDCUserByUserID(ua.userID)\n\tif err != nil || o == nil {\n\t\treturn nil, err\n\t}\n\tif len(o.Secret) > 0 {\n\t\tp, err := utils.ReversibleDecrypt(o.Secret, ua.secretKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\to.PlainSecret = p\n\t}\n\treturn o, nil\n}\n\n// modifiable returns whether the modify is allowed based on current auth mode and context\nfunc (ua *UserAPI) modifiable() bool {\n\tif ua.AuthMode == common.DBAuth {\n\t\t// When the auth mode is local DB, admin can modify anyone, non-admin can modify himself.\n\t\treturn ua.IsAdmin || ua.userID == ua.currentUserID\n\t}\n\t// When the auth mode is external IDM backend, only the super user can modify himself,\n\t// because he's the only one whose information is stored in local DB.\n\treturn ua.userID == 1 && ua.userID == ua.currentUserID\n\n}\n\n// validate only validate when user register\nfunc validate(user models.User) error {\n\n\tif utils.IsIllegalLength(user.Username, 1, 255) {\n\t\treturn fmt.Errorf(\"username with illegal length\")\n\t}\n\tif utils.IsContainIllegalChar(user.Username, []string{\",\", \"~\", \"#\", \"$\", \"%\"}) {\n\t\treturn fmt.Errorf(\"username contains illegal characters\")\n\t}\n\tif utils.IsIllegalLength(user.Password, 8, 20) {\n\t\treturn fmt.Errorf(\"password with illegal length\")\n\t}\n\treturn commonValidate(user)\n}\n\n// commonValidate validates email, realname, comment information when user register or change their profile\nfunc commonValidate(user models.User) error {\n\n\tif len(user.Email) > 0 {\n\t\tif m, _ := regexp.MatchString(`^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$`, user.Email); !m {\n\t\t\treturn fmt.Errorf(\"email with illegal format\")\n\t\t}\n\t} else {\n\t\treturn fmt.Errorf(\"Email can't be empty\")\n\t}\n\n\tif utils.IsIllegalLength(user.Realname, 1, 255) {\n\t\treturn fmt.Errorf(\"realname with illegal length\")\n\t}\n\n\tif utils.IsContainIllegalChar(user.Realname, []string{\",\", \"~\", \"#\", \"$\", \"%\"}) {\n\t\treturn fmt.Errorf(\"realname contains illegal characters\")\n\t}\n\tif utils.IsIllegalLength(user.Comment, -1, 30) {\n\t\treturn fmt.Errorf(\"comment with illegal length\")\n\t}\n\treturn nil\n\n}\n", "// Copyright 2018 Project Harbor Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage api\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/goharbor/harbor/src/common/dao\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/goharbor/harbor/src/common/api\"\n\t\"github.com/goharbor/harbor/src/common/models\"\n\t\"github.com/goharbor/harbor/src/testing/apitests/apilib\"\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/astaxie/beego\"\n\t\"github.com/goharbor/harbor/src/common\"\n\t\"github.com/goharbor/harbor/src/core/config\"\n)\n\nvar testUser0002ID, testUser0003ID int\nvar testUser0002, testUser0003 apilib.User\nvar testUser0002Auth, testUser0003Auth *usrInfo\n\nfunc TestUsersPost(t *testing.T) {\n\n\tfmt.Println(\"Testing User Add\")\n\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\tconfig.Upload(map[string]interface{}{\n\t\tcommon.AUTHMode: \"db_auth\",\n\t})\n\t// case 1: register a new user without admin auth, expect 400, because self registration is on\n\tfmt.Println(\"Register user without admin auth\")\n\tcode, err := apiTest.UsersPost(testUser0002)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a test User\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 2: register a new user with admin auth, but username is empty, expect 400\n\tfmt.Println(\"Register user with admin auth, but username is empty\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 3: register a new user with admin auth, but bad username format, expect 400\n\ttestUser0002.Username = \"test@$\"\n\tfmt.Println(\"Register user with admin auth, but bad username format\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 4: register a new user with admin auth, but bad userpassword format, expect 400\n\ttestUser0002.Username = \"testUser0002\"\n\tfmt.Println(\"Register user with admin auth, but empty password.\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 5: register a new user with admin auth, but email is empty, expect 400\n\ttestUser0002.Password = \"testUser0002\"\n\tfmt.Println(\"Register user with admin auth, but email is empty\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 6: register a new user with admin auth, but bad email format, expect 400\n\ttestUser0002.Email = \"test...\"\n\tfmt.Println(\"Register user with admin auth, but bad email format\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 7: register a new user with admin auth, but userrealname is empty, expect 400\n\t/*\n\t\ttestUser0002.Email = \"testUser0002@mydomain.com\"\n\t\tfmt.Println(\"Register user with admin auth, but user realname is empty\")\n\t\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\t\tif err != nil {\n\t\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\t\tt.Log(err)\n\t\t} else {\n\t\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t\t}\n\t*/\n\t// case 8: register a new user with admin auth, but bad userrealname format, expect 400\n\ttestUser0002.Email = \"testUser0002@mydomain.com\"\n\ttestUser0002.Realname = \"test$com\"\n\tfmt.Println(\"Register user with admin auth, but bad user realname format\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 9: register a new user with admin auth, but bad user comment, expect 400\n\ttestUser0002.Realname = \"testUser0002\"\n\ttestUser0002.Comment = \"vmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\"\n\tfmt.Println(\"Register user with admin auth, but user comment length is illegal\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t}\n\n\t// case 10: register a new user with admin auth, expect 201\n\tfmt.Println(\"Register user with admin auth, right parameters\")\n\ttestUser0002.Comment = \"test user\"\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(201, code, \"Add user status should be 201\")\n\t}\n\n\t// case 11: register duplicate user with admin auth, expect 409\n\tfmt.Println(\"Register duplicate user with admin auth\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(409, code, \"Add user status should be 409\")\n\t}\n\n\t// case 12: register a new user with admin auth, but duplicate email, expect 409\n\tfmt.Println(\"Register user with admin auth, but duplicate email\")\n\ttestUser0002.Username = \"testUsertest\"\n\ttestUser0002.Email = \"testUser0002@mydomain.com\"\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(409, code, \"Add user status should be 409\")\n\t}\n}\n\nfunc TestUsersGet(t *testing.T) {\n\n\tfmt.Println(\"Testing User Get\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\ttestUser0002.Username = \"testUser0002\"\n\t// case 1: Get user2 with common auth, but no userid in path, expect 403\n\n\ttestUser0002Auth = &usrInfo{\"testUser0002\", \"testUser0002\"}\n\tcode, users, err := apiTest.UsersGet(testUser0002.Username, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Get users status should be 403\")\n\t}\n\t// case 2: Get user2 with admin auth, expect 200\n\tcode, users, err = apiTest.UsersGet(testUser0002.Username, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Get users status should be 200\")\n\t\tassert.Equal(1, len(users), \"Get users record should be 1 \")\n\t\ttestUser0002ID = users[0].UserId\n\t}\n}\n\nfunc TestUsersSearch(t *testing.T) {\n\n\tfmt.Println(\"Testing User Search\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\ttestUser0002.Username = \"testUser0002\"\n\t// case 1: Search user2 without auth, expect 401\n\n\ttestUser0002Auth = &usrInfo{\"testUser0002\", \"testUser0002\"}\n\tcode, users, err := apiTest.UsersSearch(testUser0002.Username)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while search users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(401, code, \"Search users status should be 401\")\n\t}\n\t// case 2: Search user2 with with common auth, expect 200\n\tcode, users, err = apiTest.UsersSearch(testUser0002.Username, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while search users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Search users status should be 200\")\n\t\tassert.Equal(1, len(users), \"Search users record should be 1 \")\n\t\ttestUser0002ID = users[0].UserID\n\t}\n}\n\nfunc TestUsersGetByID(t *testing.T) {\n\n\tfmt.Println(\"Testing User GetByID\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\t// case 1: Get user2 with userID and his own auth, expect 200\n\tcode, user, err := apiTest.UsersGetByID(testUser0002.Username, *testUser0002Auth, testUser0002ID)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Get users status should be 200\")\n\t\tassert.Equal(testUser0002.Username, user.Username, \"Get users username should be equal\")\n\t\tassert.Equal(testUser0002.Email, user.Email, \"Get users email should be equal\")\n\t}\n\t// case 2: Get user2 with user3 auth, expect 403\n\ttestUser0003.Username = \"testUser0003\"\n\ttestUser0003.Email = \"testUser0003@mydomain.com\"\n\ttestUser0003.Password = \"testUser0003\"\n\ttestUser0003.Realname = \"testUser0003\"\n\tcode, err = apiTest.UsersPost(testUser0003, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(201, code, \"Add user status should be 201\")\n\t}\n\n\ttestUser0003Auth = &usrInfo{\"testUser0003\", \"testUser0003\"}\n\tcode, user, err = apiTest.UsersGetByID(testUser0002.Username, *testUser0003Auth, testUser0002ID)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Get users status should be 403\")\n\t}\n\t// case 3: Get user that does not exist with user2 auth, expect 404 not found.\n\tcode, user, err = apiTest.UsersGetByID(testUser0002.Username, *testUser0002Auth, 1000)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(404, code, \"Get users status should be 404\")\n\t}\n\t// Get user3ID in order to delete at the last of the test\n\tcode, users, err := apiTest.UsersGet(testUser0003.Username, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Get users status should be 200\")\n\t\tassert.Equal(1, len(users), \"Get users record should be 1\")\n\t\ttestUser0003ID = users[0].UserId\n\t}\n}\n\nfunc TestUsersPut(t *testing.T) {\n\tfmt.Println(\"Testing User Put\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\tvar profile apilib.UserProfile\n\t// case 1: change user2 profile with user3 auth\n\tcode, err := apiTest.UsersPut(testUser0002ID, profile, *testUser0003Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Change user profile status should be 403\")\n\t}\n\t// case 2: change user2 profile with user2 auth, but bad parameters format.\n\tcode, err = apiTest.UsersPut(testUser0002ID, profile, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Change user profile status should be 400\")\n\t}\n\t// case 3: change user2 profile with user2 auth, but duplicate email.\n\tprofile.Realname = \"test user\"\n\tprofile.Email = \"testUser0003@mydomain.com\"\n\tprofile.Comment = \"change profile\"\n\tcode, err = apiTest.UsersPut(testUser0002ID, profile, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(409, code, \"Change user profile status should be 409\")\n\t}\n\t// case 4: change user2 profile with user2 auth, right parameters format.\n\tprofile.Realname = \"test user\"\n\tprofile.Email = \"testUser0002@vmware.com\"\n\tprofile.Comment = \"change profile\"\n\tcode, err = apiTest.UsersPut(testUser0002ID, profile, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Change user profile status should be 200\")\n\t\ttestUser0002.Email = profile.Email\n\t}\n}\n\nfunc TestUsersToggleAdminRole(t *testing.T) {\n\tfmt.Println(\"Testing Toggle User Admin Role\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\t// case 1: toggle user2 admin role without admin auth\n\tcode, err := apiTest.UsersToggleAdminRole(testUser0002ID, *testUser0002Auth, true)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while toggle user admin role\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Toggle user admin role status should be 403\")\n\t}\n\t// case 2: toggle user2 admin role with admin auth\n\tcode, err = apiTest.UsersToggleAdminRole(testUser0002ID, *admin, true)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while toggle user admin role\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Toggle user admin role status should be 200\")\n\t}\n}\n\nfunc buildChangeUserPasswordURL(id int) string {\n\treturn fmt.Sprintf(\"/api/users/%d/password\", id)\n}\n\nfunc TestUsersUpdatePassword(t *testing.T) {\n\tfmt.Println(\"Testing Update User Password\")\n\toldPassword := \"old_password\"\n\tnewPassword := \"new_password\"\n\n\tuser01 := models.User{\n\t\tUsername: \"user01_for_testing_change_password\",\n\t\tEmail:    \"user01_for_testing_change_password@test.com\",\n\t\tPassword: oldPassword,\n\t}\n\tid, err := dao.Register(user01)\n\trequire.Nil(t, err)\n\tuser01.UserID = int(id)\n\tdefer dao.DeleteUser(user01.UserID)\n\n\tuser02 := models.User{\n\t\tUsername: \"user02_for_testing_change_password\",\n\t\tEmail:    \"user02_for_testing_change_password@test.com\",\n\t\tPassword: oldPassword,\n\t}\n\tid, err = dao.Register(user02)\n\trequire.Nil(t, err)\n\tuser02.UserID = int(id)\n\tdefer dao.DeleteUser(user02.UserID)\n\n\tcases := []*codeCheckingCase{\n\t\t// unauthorized\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t},\n\t\t\tcode: http.StatusUnauthorized,\n\t\t},\n\t\t// 404\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(10000),\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusNotFound,\n\t\t},\n\t\t// 403, a normal user tries to change password of others\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user02.UserID),\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusForbidden,\n\t\t},\n\t\t// 400, empty old password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod:   http.MethodPut,\n\t\t\t\turl:      buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusBadRequest,\n\t\t},\n\t\t// 400, empty new password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tOldPassword: oldPassword,\n\t\t\t\t},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusBadRequest,\n\t\t},\n\t\t// 403, incorrect old password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tOldPassword: \"incorrect_old_password\",\n\t\t\t\t\tNewPassword: newPassword,\n\t\t\t\t},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusForbidden,\n\t\t},\n\t\t// 200, normal user change own password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tOldPassword: oldPassword,\n\t\t\t\t\tNewPassword: newPassword,\n\t\t\t\t},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusOK,\n\t\t},\n\t\t// 400, admin user change password of others.\n\t\t// the new password is same with the old one\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tNewPassword: newPassword,\n\t\t\t\t},\n\t\t\t\tcredential: admin,\n\t\t\t},\n\t\t\tcode: http.StatusBadRequest,\n\t\t},\n\t\t// 200, admin user change password of others\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tNewPassword: \"another_new_password\",\n\t\t\t\t},\n\t\t\t\tcredential: admin,\n\t\t\t},\n\t\t\tcode: http.StatusOK,\n\t\t},\n\t}\n\n\trunCodeCheckingCases(t, cases...)\n}\n\nfunc TestUsersDelete(t *testing.T) {\n\n\tfmt.Println(\"Testing User Delete\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\tt.Log(\"delete user-case 1\")\n\t// case 1:delete user without admin auth\n\tcode, err := apiTest.UsersDelete(testUser0002ID, *testUser0003Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Delete test user status should be 403\")\n\t}\n\t// case 2: delete user with admin auth, user2 has already been toggled to admin, but can not delete himself\n\tt.Log(\"delete user-case 2\")\n\tcode, err = apiTest.UsersDelete(testUser0002ID, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Delete test user status should be 403\")\n\t}\n\t// case 3: delete user with admin auth\n\tt.Log(\"delete user-case 3\")\n\tcode, err = apiTest.UsersDelete(testUser0002ID, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Delete test user status should be 200\")\n\t}\n\t// delete user3 with admin auth\n\tcode, err = apiTest.UsersDelete(testUser0003ID, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Delete test user status should be 200\")\n\t}\n}\n\nfunc TestModifiable(t *testing.T) {\n\tt.Log(\"Test modifiable.\")\n\tassert := assert.New(t)\n\tbase := BaseController{\n\t\tBaseAPI: api.BaseAPI{\n\t\t\tController: beego.Controller{},\n\t\t},\n\t\tSecurityCtx: nil,\n\t\tProjectMgr:  nil,\n\t}\n\n\tua1 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    3,\n\t\tuserID:           4,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          false,\n\t\tAuthMode:         \"db_auth\",\n\t}\n\tassert.False(ua1.modifiable())\n\tua2 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    3,\n\t\tuserID:           4,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          true,\n\t\tAuthMode:         \"db_auth\",\n\t}\n\tassert.True(ua2.modifiable())\n\tua3 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    3,\n\t\tuserID:           4,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          true,\n\t\tAuthMode:         \"ldap_auth\",\n\t}\n\tassert.False(ua3.modifiable())\n\tua4 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    1,\n\t\tuserID:           1,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          true,\n\t\tAuthMode:         \"ldap_auth\",\n\t}\n\tassert.True(ua4.modifiable())\n}\n\nfunc TestUsersCurrentPermissions(t *testing.T) {\n\tfmt.Println(\"Testing Get Users Current Permissions\")\n\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\thttpStatusCode, permissions, err := apiTest.UsersGetPermissions(\"current\", \"/project/1\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(200), httpStatusCode, \"httpStatusCode should be 200\")\n\tassert.NotEmpty(permissions, \"permissions should not be empty\")\n\n\thttpStatusCode, permissions, err = apiTest.UsersGetPermissions(\"current\", \"/unsupport-scope\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(200), httpStatusCode, \"httpStatusCode should be 200\")\n\tassert.Empty(permissions, \"permissions should be empty\")\n\n\thttpStatusCode, _, err = apiTest.UsersGetPermissions(projAdminID, \"/project/1\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(200), httpStatusCode, \"httpStatusCode should be 200\")\n\n\thttpStatusCode, _, err = apiTest.UsersGetPermissions(projDeveloperID, \"/project/1\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(403), httpStatusCode, \"httpStatusCode should be 403\")\n}\n"], "fixing_code": ["// Copyright 2018 Project Harbor Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage api\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/goharbor/harbor/src/common\"\n\t\"github.com/goharbor/harbor/src/common/dao\"\n\t\"github.com/goharbor/harbor/src/common/models\"\n\t\"github.com/goharbor/harbor/src/common/rbac\"\n\t\"github.com/goharbor/harbor/src/common/rbac/project\"\n\t\"github.com/goharbor/harbor/src/common/utils\"\n\t\"github.com/goharbor/harbor/src/common/utils/log\"\n\t\"github.com/goharbor/harbor/src/core/config\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strconv\"\n)\n\n// UserAPI handles request to /api/users/{}\ntype UserAPI struct {\n\tBaseController\n\tcurrentUserID    int\n\tuserID           int\n\tSelfRegistration bool\n\tIsAdmin          bool\n\tAuthMode         string\n\tsecretKey        string\n}\n\ntype passwordReq struct {\n\tOldPassword string `json:\"old_password\"`\n\tNewPassword string `json:\"new_password\"`\n}\n\ntype userSearch struct {\n\tUserID   int    `json:\"user_id\"`\n\tUsername string `json:\"username\"`\n}\n\ntype secretResp struct {\n\tSecret string `json:\"secret\"`\n}\n\n// Prepare validates the URL and parms\nfunc (ua *UserAPI) Prepare() {\n\tua.BaseController.Prepare()\n\tmode, err := config.AuthMode()\n\tif err != nil {\n\t\tlog.Errorf(\"failed to get auth mode: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tua.AuthMode = mode\n\tif mode == common.OIDCAuth {\n\t\tkey, err := config.SecretKey()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"failed to get secret key: %v\", err)\n\t\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get secret key: %v\", err))\n\t\t\treturn\n\t\t}\n\t\tua.secretKey = key\n\t}\n\n\tself, err := config.SelfRegistration()\n\tif err != nil {\n\t\tlog.Errorf(\"failed to get self registration: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tua.SelfRegistration = self\n\n\tif !ua.SecurityCtx.IsAuthenticated() {\n\t\tif ua.Ctx.Input.IsPost() {\n\t\t\treturn\n\t\t}\n\t\tua.SendUnAuthorizedError(errors.New(\"UnAuthorize\"))\n\t\treturn\n\t}\n\n\tuser, err := dao.GetUser(models.User{\n\t\tUsername: ua.SecurityCtx.GetUsername(),\n\t})\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get user %s: %v\",\n\t\t\tua.SecurityCtx.GetUsername(), err))\n\t\treturn\n\t}\n\n\tif user == nil {\n\t\tlog.Errorf(\"User with username %s does not exist in DB.\", ua.SecurityCtx.GetUsername())\n\t\tua.SendInternalServerError(fmt.Errorf(\"user %s does not exist in DB\", ua.SecurityCtx.GetUsername()))\n\t\treturn\n\t}\n\n\tua.currentUserID = user.UserID\n\tid := ua.Ctx.Input.Param(\":id\")\n\tif id == \"current\" {\n\t\tua.userID = ua.currentUserID\n\t} else if len(id) > 0 {\n\t\tvar err error\n\t\tua.userID, err = strconv.Atoi(id)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Invalid user id, error: %v\", err)\n\t\t\tua.SendBadRequestError(errors.New(\"invalid user Id\"))\n\t\t\treturn\n\t\t}\n\t\tuserQuery := models.User{UserID: ua.userID}\n\t\tu, err := dao.GetUser(userQuery)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error occurred in GetUser, error: %v\", err)\n\t\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\t\treturn\n\t\t}\n\t\tif u == nil {\n\t\t\tlog.Errorf(\"User with Id: %d does not exist\", ua.userID)\n\t\t\tua.SendNotFoundError(errors.New(\"\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\tua.IsAdmin = ua.SecurityCtx.IsSysAdmin()\n}\n\n// Get ...\nfunc (ua *UserAPI) Get() {\n\tif ua.userID == ua.currentUserID || ua.IsAdmin {\n\t\tuserQuery := models.User{UserID: ua.userID}\n\t\tu, err := dao.GetUser(userQuery)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error occurred in GetUser, error: %v\", err)\n\t\t\tua.SendInternalServerError(err)\n\t\t\treturn\n\t\t}\n\t\tu.Password = \"\"\n\t\tif ua.userID == ua.currentUserID {\n\t\t\tu.HasAdminRole = ua.SecurityCtx.IsSysAdmin()\n\t\t}\n\t\tif ua.AuthMode == common.OIDCAuth {\n\t\t\to, err := ua.getOIDCUserInfo()\n\t\t\tif err != nil {\n\t\t\t\tua.SendInternalServerError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tu.OIDCUserMeta = o\n\t\t}\n\t\tua.Data[\"json\"] = u\n\t\tua.ServeJSON()\n\t\treturn\n\t}\n\n\tlog.Errorf(\"Current user, id: %d does not have admin role, can not view other user's detail\", ua.currentUserID)\n\tua.SendForbiddenError(errors.New(\"user does not have admin role\"))\n\treturn\n}\n\n// List ...\nfunc (ua *UserAPI) List() {\n\tif !ua.IsAdmin {\n\t\tlog.Errorf(\"Current user, id: %d does not have admin role, can not list users\", ua.currentUserID)\n\t\tua.SendForbiddenError(errors.New(\"user does not have admin role\"))\n\t\treturn\n\t}\n\n\tpage, size, err := ua.GetPaginationParams()\n\tif err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\n\tquery := &models.UserQuery{\n\t\tUsername: ua.GetString(\"username\"),\n\t\tEmail:    ua.GetString(\"email\"),\n\t\tPagination: &models.Pagination{\n\t\t\tPage: page,\n\t\t\tSize: size,\n\t\t},\n\t}\n\n\ttotal, err := dao.GetTotalOfUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get total of users: %v\", err))\n\t\treturn\n\t}\n\n\tusers, err := dao.ListUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get users: %v\", err))\n\t\treturn\n\t}\n\tfor i := range users {\n\t\tuser := &users[i]\n\t\tuser.Password = \"\"\n\t}\n\tua.SetPaginationHeader(total, page, size)\n\tua.Data[\"json\"] = users\n\tua.ServeJSON()\n}\n\n// Search ...\nfunc (ua *UserAPI) Search() {\n\tpage, size, err := ua.GetPaginationParams()\n\tif err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\tquery := &models.UserQuery{\n\t\tUsername: ua.GetString(\"username\"),\n\t\tEmail:    ua.GetString(\"email\"),\n\t\tPagination: &models.Pagination{\n\t\t\tPage: page,\n\t\t\tSize: size,\n\t\t},\n\t}\n\n\ttotal, err := dao.GetTotalOfUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get total of users: %v\", err))\n\t\treturn\n\t}\n\n\tusers, err := dao.ListUsers(query)\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get users: %v\", err))\n\t\treturn\n\t}\n\n\tvar userSearches []userSearch\n\tfor _, user := range users {\n\t\tuserSearches = append(userSearches, userSearch{UserID: user.UserID, Username: user.Username})\n\t}\n\n\tua.SetPaginationHeader(total, page, size)\n\tua.Data[\"json\"] = userSearches\n\tua.ServeJSON()\n}\n\n// Put ...\nfunc (ua *UserAPI) Put() {\n\tif !ua.modifiable() {\n\t\tua.SendForbiddenError(fmt.Errorf(\"User with ID %d cannot be modified\", ua.userID))\n\t\treturn\n\t}\n\tuser := models.User{UserID: ua.userID}\n\tif err := ua.DecodeJSONReq(&user); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\terr := commonValidate(user)\n\tif err != nil {\n\t\tlog.Warningf(\"Bad request in change user profile: %v\", err)\n\t\tua.SendBadRequestError(fmt.Errorf(\"change user profile error:\" + err.Error()))\n\t\treturn\n\t}\n\tuserQuery := models.User{UserID: ua.userID}\n\tu, err := dao.GetUser(userQuery)\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in GetUser, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\tif u == nil {\n\t\tlog.Errorf(\"User with Id: %d does not exist\", ua.userID)\n\t\tua.SendNotFoundError(errors.New(\"\"))\n\t\treturn\n\t}\n\tif u.Email != user.Email {\n\t\temailExist, err := dao.UserExists(user, \"email\")\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error occurred in change user profile: %v\", err)\n\t\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\t\treturn\n\t\t}\n\t\tif emailExist {\n\t\t\tlog.Warning(\"email has already been used!\")\n\t\t\tua.SendConflictError(errors.New(\"email has already been used\"))\n\t\t\treturn\n\t\t}\n\t}\n\tif err := dao.ChangeUserProfile(user); err != nil {\n\t\tlog.Errorf(\"Failed to update user profile, error: %v\", err)\n\t\tua.SendInternalServerError(err)\n\t\treturn\n\t}\n}\n\n// Post ...\nfunc (ua *UserAPI) Post() {\n\n\tif !(ua.AuthMode == common.DBAuth) {\n\t\tua.SendForbiddenError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tif !(ua.SelfRegistration || ua.IsAdmin) {\n\t\tlog.Warning(\"Registration can only be used by admin role user when self-registration is off.\")\n\t\tua.SendForbiddenError(errors.New(\"\"))\n\t\treturn\n\t}\n\n\tuser := models.User{}\n\tif err := ua.DecodeJSONReq(&user); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\terr := validate(user)\n\tif err != nil {\n\t\tlog.Warningf(\"Bad request in Register: %v\", err)\n\t\tua.RenderError(http.StatusBadRequest, \"register error:\"+err.Error())\n\t\treturn\n\t}\n\n\tif !ua.IsAdmin && user.HasAdminRole {\n\t\tmsg := \"Non-admin cannot create an admin user.\"\n\t\tlog.Errorf(msg)\n\t\tua.SendForbiddenError(errors.New(msg))\n\t\treturn\n\t}\n\n\tuserExist, err := dao.UserExists(user, \"username\")\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in Register: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\tif userExist {\n\t\tlog.Warning(\"username has already been used!\")\n\t\tua.SendConflictError(errors.New(\"username has already been used\"))\n\t\treturn\n\t}\n\temailExist, err := dao.UserExists(user, \"email\")\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in change user profile: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\tif emailExist {\n\t\tlog.Warning(\"email has already been used!\")\n\t\tua.SendConflictError(errors.New(\"email has already been used\"))\n\t\treturn\n\t}\n\n\tuserID, err := dao.Register(user)\n\tif err != nil {\n\t\tlog.Errorf(\"Error occurred in Register: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n\n\tua.Redirect(http.StatusCreated, strconv.FormatInt(userID, 10))\n}\n\n// Delete ...\nfunc (ua *UserAPI) Delete() {\n\tif !ua.IsAdmin || ua.AuthMode != common.DBAuth || ua.userID == 1 || ua.currentUserID == ua.userID {\n\t\tua.SendForbiddenError(fmt.Errorf(\"User with ID: %d cannot be removed, auth mode: %s, current user ID: %d\", ua.userID, ua.AuthMode, ua.currentUserID))\n\t\treturn\n\t}\n\n\tvar err error\n\terr = dao.DeleteUser(ua.userID)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to delete data from database, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"failed to delete User\"))\n\t\treturn\n\t}\n}\n\n// ChangePassword handles PUT to /api/users/{}/password\nfunc (ua *UserAPI) ChangePassword() {\n\tif !ua.modifiable() {\n\t\tua.SendForbiddenError(fmt.Errorf(\"User with ID: %d is not modifiable\", ua.userID))\n\t\treturn\n\t}\n\n\tchangePwdOfOwn := ua.userID == ua.currentUserID\n\n\tvar req passwordReq\n\tif err := ua.DecodeJSONReq(&req); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\n\tif changePwdOfOwn && len(req.OldPassword) == 0 {\n\t\tua.SendBadRequestError(errors.New(\"empty old_password\"))\n\t\treturn\n\t}\n\n\tif len(req.NewPassword) == 0 {\n\t\tua.SendBadRequestError(errors.New(\"empty new_password\"))\n\t\treturn\n\t}\n\n\tuser, err := dao.GetUser(models.User{UserID: ua.userID})\n\tif err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to get user %d: %v\", ua.userID, err))\n\t\treturn\n\t}\n\tif user == nil {\n\t\tua.SendNotFoundError(fmt.Errorf(\"user %d not found\", ua.userID))\n\t\treturn\n\t}\n\tif changePwdOfOwn {\n\t\tif user.Password != utils.Encrypt(req.OldPassword, user.Salt) {\n\t\t\tlog.Info(\"incorrect old_password\")\n\t\t\tua.SendForbiddenError(errors.New(\"incorrect old_password\"))\n\t\t\treturn\n\t\t}\n\t}\n\tif user.Password == utils.Encrypt(req.NewPassword, user.Salt) {\n\t\tua.SendBadRequestError(errors.New(\"the new password can not be same with the old one\"))\n\t\treturn\n\t}\n\n\tupdatedUser := models.User{\n\t\tUserID:   ua.userID,\n\t\tPassword: req.NewPassword,\n\t}\n\tif err = dao.ChangeUserPassword(updatedUser); err != nil {\n\t\tua.SendInternalServerError(fmt.Errorf(\"failed to change password of user %d: %v\", ua.userID, err))\n\t\treturn\n\t}\n}\n\n// ToggleUserAdminRole handles PUT api/users/{}/sysadmin\nfunc (ua *UserAPI) ToggleUserAdminRole() {\n\tif !ua.IsAdmin {\n\t\tlog.Warningf(\"current user, id: %d does not have admin role, can not update other user's role\", ua.currentUserID)\n\t\tua.RenderError(http.StatusForbidden, \"User does not have admin role\")\n\t\treturn\n\t}\n\tuserQuery := models.User{UserID: ua.userID}\n\tif err := ua.DecodeJSONReq(&userQuery); err != nil {\n\t\tua.SendBadRequestError(err)\n\t\treturn\n\t}\n\tif err := dao.ToggleUserAdminRole(userQuery.UserID, userQuery.HasAdminRole); err != nil {\n\t\tlog.Errorf(\"Error occurred in ToggleUserAdminRole: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"internal error\"))\n\t\treturn\n\t}\n}\n\n// ListUserPermissions handles GET to /api/users/{}/permissions\nfunc (ua *UserAPI) ListUserPermissions() {\n\tif ua.userID != ua.currentUserID {\n\t\tlog.Warningf(\"Current user, id: %d can not view other user's permissions\", ua.currentUserID)\n\t\tua.RenderError(http.StatusForbidden, \"User does not have permission\")\n\t\treturn\n\t}\n\n\trelative := ua.Ctx.Input.Query(\"relative\") == \"true\"\n\n\tscope := rbac.Resource(ua.Ctx.Input.Query(\"scope\"))\n\tpolicies := []*rbac.Policy{}\n\n\tnamespace, err := scope.GetNamespace()\n\tif err == nil {\n\t\tswitch namespace.Kind() {\n\t\tcase \"project\":\n\t\t\tfor _, policy := range project.GetAllPolicies(namespace) {\n\t\t\t\tif ua.SecurityCtx.Can(policy.Action, policy.Resource) {\n\t\t\t\t\tpolicies = append(policies, policy)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tresults := []map[string]string{}\n\tfor _, policy := range policies {\n\t\tvar resource rbac.Resource\n\n\t\t// for resource `/project/1/repository` if `relative` is `true` then the resource in response will be `repository`\n\t\tif relative {\n\t\t\trelativeResource, err := policy.Resource.RelativeTo(scope)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tresource = relativeResource\n\t\t} else {\n\t\t\tresource = policy.Resource\n\t\t}\n\n\t\tresults = append(results, map[string]string{\n\t\t\t\"resource\": resource.String(),\n\t\t\t\"action\":   policy.Action.String(),\n\t\t})\n\t}\n\n\tua.Data[\"json\"] = results\n\tua.ServeJSON()\n\treturn\n}\n\n// GenCLISecret generates a new CLI secret and replace the old one\nfunc (ua *UserAPI) GenCLISecret() {\n\tif ua.AuthMode != common.OIDCAuth {\n\t\tua.SendPreconditionFailedError(errors.New(\"the auth mode has to be oidc auth\"))\n\t\treturn\n\t}\n\tif ua.userID != ua.currentUserID && !ua.IsAdmin {\n\t\tua.SendForbiddenError(errors.New(\"\"))\n\t\treturn\n\t}\n\toidcData, err := dao.GetOIDCUserByUserID(ua.userID)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get OIDC User meta for user, id: %d, error: %v\", ua.userID, err)\n\t\tua.SendInternalServerError(errors.New(\"failed to get OIDC meta data for user\"))\n\t\treturn\n\t}\n\tif oidcData == nil {\n\t\tlog.Errorf(\"User is not onboarded via OIDC AuthN, user id: %d\", ua.userID)\n\t\tua.SendPreconditionFailedError(errors.New(\"user is not onboarded via OIDC AuthN\"))\n\t\treturn\n\t}\n\n\tsec := utils.GenerateRandomString()\n\tencSec, err := utils.ReversibleEncrypt(sec, ua.secretKey)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to encrypt secret, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"failed to encrypt secret\"))\n\t\treturn\n\t}\n\toidcData.Secret = encSec\n\terr = dao.UpdateOIDCUserSecret(oidcData)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to update secret in DB, error: %v\", err)\n\t\tua.SendInternalServerError(errors.New(\"failed to update secret in DB\"))\n\t\treturn\n\t}\n\tua.Data[\"json\"] = secretResp{sec}\n\tua.ServeJSON()\n}\n\nfunc (ua *UserAPI) getOIDCUserInfo() (*models.OIDCUser, error) {\n\to, err := dao.GetOIDCUserByUserID(ua.userID)\n\tif err != nil || o == nil {\n\t\treturn nil, err\n\t}\n\tif len(o.Secret) > 0 {\n\t\tp, err := utils.ReversibleDecrypt(o.Secret, ua.secretKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\to.PlainSecret = p\n\t}\n\treturn o, nil\n}\n\n// modifiable returns whether the modify is allowed based on current auth mode and context\nfunc (ua *UserAPI) modifiable() bool {\n\tif ua.AuthMode == common.DBAuth {\n\t\t// When the auth mode is local DB, admin can modify anyone, non-admin can modify himself.\n\t\treturn ua.IsAdmin || ua.userID == ua.currentUserID\n\t}\n\t// When the auth mode is external IDM backend, only the super user can modify himself,\n\t// because he's the only one whose information is stored in local DB.\n\treturn ua.userID == 1 && ua.userID == ua.currentUserID\n\n}\n\n// validate only validate when user register\nfunc validate(user models.User) error {\n\n\tif utils.IsIllegalLength(user.Username, 1, 255) {\n\t\treturn fmt.Errorf(\"username with illegal length\")\n\t}\n\tif utils.IsContainIllegalChar(user.Username, []string{\",\", \"~\", \"#\", \"$\", \"%\"}) {\n\t\treturn fmt.Errorf(\"username contains illegal characters\")\n\t}\n\tif utils.IsIllegalLength(user.Password, 8, 20) {\n\t\treturn fmt.Errorf(\"password with illegal length\")\n\t}\n\treturn commonValidate(user)\n}\n\n// commonValidate validates email, realname, comment information when user register or change their profile\nfunc commonValidate(user models.User) error {\n\n\tif len(user.Email) > 0 {\n\t\tif m, _ := regexp.MatchString(`^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$`, user.Email); !m {\n\t\t\treturn fmt.Errorf(\"email with illegal format\")\n\t\t}\n\t} else {\n\t\treturn fmt.Errorf(\"Email can't be empty\")\n\t}\n\n\tif utils.IsIllegalLength(user.Realname, 1, 255) {\n\t\treturn fmt.Errorf(\"realname with illegal length\")\n\t}\n\n\tif utils.IsContainIllegalChar(user.Realname, []string{\",\", \"~\", \"#\", \"$\", \"%\"}) {\n\t\treturn fmt.Errorf(\"realname contains illegal characters\")\n\t}\n\tif utils.IsIllegalLength(user.Comment, -1, 30) {\n\t\treturn fmt.Errorf(\"comment with illegal length\")\n\t}\n\treturn nil\n\n}\n", "// Copyright 2018 Project Harbor Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage api\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/goharbor/harbor/src/common/dao\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/goharbor/harbor/src/common/api\"\n\t\"github.com/goharbor/harbor/src/common/models\"\n\t\"github.com/goharbor/harbor/src/testing/apitests/apilib\"\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/astaxie/beego\"\n\t\"github.com/goharbor/harbor/src/common\"\n\t\"github.com/goharbor/harbor/src/core/config\"\n)\n\nvar testUser0002ID, testUser0003ID int\nvar testUser0002, testUser0003 apilib.User\nvar testUser0002Auth, testUser0003Auth *usrInfo\n\nfunc TestUsersPost(t *testing.T) {\n\n\tfmt.Println(\"Testing User Add\")\n\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\tconfig.Upload(map[string]interface{}{\n\t\tcommon.AUTHMode: \"db_auth\",\n\t})\n\t// case 1: register a new user without admin auth, expect 400, because self registration is on\n\tt.Log(\"case 1: Register user without admin auth\")\n\tcode, err := apiTest.UsersPost(testUser0002)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a test User\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"case 1: Add user status should be 400\")\n\t}\n\n\t// case 2: register a new user with admin auth, but username is empty, expect 400\n\tt.Log(\"case 2: Register user with admin auth, but username is empty\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"case 2: Add user status should be 400\")\n\t}\n\n\t// case 3: register a new user with admin auth, but bad username format, expect 400\n\ttestUser0002.Username = \"test@$\"\n\tt.Log(\"case 3: Register user with admin auth, but bad username format\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"case 3: Add user status should be 400\")\n\t}\n\n\t// case 4: register a new user with admin auth, but bad userpassword format, expect 400\n\ttestUser0002.Username = \"testUser0002\"\n\tt.Log(\"case 4: Register user with admin auth, but empty password.\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"case 4: Add user status should be 400\")\n\t}\n\n\t// case 5: register a new user with admin auth, but email is empty, expect 400\n\ttestUser0002.Password = \"testUser0002\"\n\tt.Log(\"case 5: Register user with admin auth, but email is empty\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"case 5: Add user status should be 400\")\n\t}\n\n\t// case 6: register a new user with admin auth, but bad email format, expect 400\n\ttestUser0002.Email = \"test...\"\n\tt.Log(\"case 6: Register user with admin auth, but bad email format\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"case 6: Add user status should be 400\")\n\t}\n\n\t// case 7: register a new user with admin auth, but userrealname is empty, expect 400\n\t/*\n\t\ttestUser0002.Email = \"testUser0002@mydomain.com\"\n\t\tfmt.Println(\"Register user with admin auth, but user realname is empty\")\n\t\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\t\tif err != nil {\n\t\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\t\tt.Log(err)\n\t\t} else {\n\t\t\tassert.Equal(400, code, \"Add user status should be 400\")\n\t\t}\n\t*/\n\t// case 8: register a new user with admin auth, but bad userrealname format, expect 400\n\ttestUser0002.Email = \"testUser0002@mydomain.com\"\n\ttestUser0002.Realname = \"test$com\"\n\tt.Log(\"case 8: Register user with admin auth, but bad user realname format\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\n\t} else {\n\t\tassert.Equal(400, code, \"case 8: Add user status should be 400\")\n\t}\n\n\t// case 9: register a new user with admin auth, but bad user comment, expect 400\n\ttestUser0002.Realname = \"testUser0002\"\n\ttestUser0002.Comment = \"vmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\"\n\tt.Log(\"case 9: Register user with admin auth, but user comment length is illegal\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"case 9: Add user status should be 400\")\n\t}\n\ttestUser0002.Comment = \"test user\"\n\n\t// case 10: register an admin using non-admin user, expect 403\n\tt.Log(\"case 10: Register admin user with non admin auth\")\n\ttestUser0002.HasAdminRole = true\n\tcode, err = apiTest.UsersPost(testUser0002)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(http.StatusForbidden, code, \"case 10: Add user status should be 403\")\n\t}\n\ttestUser0002.HasAdminRole = false\n\n\t// case 11: register a new user with admin auth, expect 201\n\tt.Log(\"case 11: Register user with admin auth, right parameters\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(201, code, \"case 11: Add user status should be 201\")\n\t}\n\n\t// case 12: register duplicate user with admin auth, expect 409\n\tt.Log(\"case 12: Register duplicate user with admin auth\")\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(409, code, \"case 12: Add user status should be 409\")\n\t}\n\n\t// case 13: register a new user with admin auth, but duplicate email, expect 409\n\tt.Log(\"case 13: Register user with admin auth, but duplicate email\")\n\ttestUser0002.Username = \"testUsertest\"\n\ttestUser0002.Email = \"testUser0002@mydomain.com\"\n\tcode, err = apiTest.UsersPost(testUser0002, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(409, code, \"case 13: Add user status should be 409\")\n\t}\n}\n\nfunc TestUsersGet(t *testing.T) {\n\n\tfmt.Println(\"Testing User Get\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\ttestUser0002.Username = \"testUser0002\"\n\t// case 1: Get user2 with common auth, but no userid in path, expect 403\n\n\ttestUser0002Auth = &usrInfo{\"testUser0002\", \"testUser0002\"}\n\tcode, users, err := apiTest.UsersGet(testUser0002.Username, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Get users status should be 403\")\n\t}\n\t// case 2: Get user2 with admin auth, expect 200\n\tcode, users, err = apiTest.UsersGet(testUser0002.Username, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Get users status should be 200\")\n\t\tassert.Equal(1, len(users), \"Get users record should be 1 \")\n\t\ttestUser0002ID = users[0].UserId\n\t}\n}\n\nfunc TestUsersSearch(t *testing.T) {\n\n\tfmt.Println(\"Testing User Search\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\ttestUser0002.Username = \"testUser0002\"\n\t// case 1: Search user2 without auth, expect 401\n\n\ttestUser0002Auth = &usrInfo{\"testUser0002\", \"testUser0002\"}\n\tcode, users, err := apiTest.UsersSearch(testUser0002.Username)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while search users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(401, code, \"Search users status should be 401\")\n\t}\n\t// case 2: Search user2 with with common auth, expect 200\n\tcode, users, err = apiTest.UsersSearch(testUser0002.Username, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while search users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Search users status should be 200\")\n\t\tassert.Equal(1, len(users), \"Search users record should be 1 \")\n\t\ttestUser0002ID = users[0].UserID\n\t}\n}\n\nfunc TestUsersGetByID(t *testing.T) {\n\n\tfmt.Println(\"Testing User GetByID\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\t// case 1: Get user2 with userID and his own auth, expect 200\n\tcode, user, err := apiTest.UsersGetByID(testUser0002.Username, *testUser0002Auth, testUser0002ID)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Get users status should be 200\")\n\t\tassert.Equal(testUser0002.Username, user.Username, \"Get users username should be equal\")\n\t\tassert.Equal(testUser0002.Email, user.Email, \"Get users email should be equal\")\n\t}\n\t// case 2: Get user2 with user3 auth, expect 403\n\ttestUser0003.Username = \"testUser0003\"\n\ttestUser0003.Email = \"testUser0003@mydomain.com\"\n\ttestUser0003.Password = \"testUser0003\"\n\ttestUser0003.Realname = \"testUser0003\"\n\tcode, err = apiTest.UsersPost(testUser0003, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while add a user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(201, code, \"Add user status should be 201\")\n\t}\n\n\ttestUser0003Auth = &usrInfo{\"testUser0003\", \"testUser0003\"}\n\tcode, user, err = apiTest.UsersGetByID(testUser0002.Username, *testUser0003Auth, testUser0002ID)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Get users status should be 403\")\n\t}\n\t// case 3: Get user that does not exist with user2 auth, expect 404 not found.\n\tcode, user, err = apiTest.UsersGetByID(testUser0002.Username, *testUser0002Auth, 1000)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(404, code, \"Get users status should be 404\")\n\t}\n\t// Get user3ID in order to delete at the last of the test\n\tcode, users, err := apiTest.UsersGet(testUser0003.Username, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while get users\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Get users status should be 200\")\n\t\tassert.Equal(1, len(users), \"Get users record should be 1\")\n\t\ttestUser0003ID = users[0].UserId\n\t}\n}\n\nfunc TestUsersPut(t *testing.T) {\n\tfmt.Println(\"Testing User Put\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\tvar profile apilib.UserProfile\n\t// case 1: change user2 profile with user3 auth\n\tcode, err := apiTest.UsersPut(testUser0002ID, profile, *testUser0003Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Change user profile status should be 403\")\n\t}\n\t// case 2: change user2 profile with user2 auth, but bad parameters format.\n\tcode, err = apiTest.UsersPut(testUser0002ID, profile, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(400, code, \"Change user profile status should be 400\")\n\t}\n\t// case 3: change user2 profile with user2 auth, but duplicate email.\n\tprofile.Realname = \"test user\"\n\tprofile.Email = \"testUser0003@mydomain.com\"\n\tprofile.Comment = \"change profile\"\n\tcode, err = apiTest.UsersPut(testUser0002ID, profile, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(409, code, \"Change user profile status should be 409\")\n\t}\n\t// case 4: change user2 profile with user2 auth, right parameters format.\n\tprofile.Realname = \"test user\"\n\tprofile.Email = \"testUser0002@vmware.com\"\n\tprofile.Comment = \"change profile\"\n\tcode, err = apiTest.UsersPut(testUser0002ID, profile, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while change user profile\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Change user profile status should be 200\")\n\t\ttestUser0002.Email = profile.Email\n\t}\n}\n\nfunc TestUsersToggleAdminRole(t *testing.T) {\n\tfmt.Println(\"Testing Toggle User Admin Role\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\t// case 1: toggle user2 admin role without admin auth\n\tcode, err := apiTest.UsersToggleAdminRole(testUser0002ID, *testUser0002Auth, true)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while toggle user admin role\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Toggle user admin role status should be 403\")\n\t}\n\t// case 2: toggle user2 admin role with admin auth\n\tcode, err = apiTest.UsersToggleAdminRole(testUser0002ID, *admin, true)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while toggle user admin role\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Toggle user admin role status should be 200\")\n\t}\n}\n\nfunc buildChangeUserPasswordURL(id int) string {\n\treturn fmt.Sprintf(\"/api/users/%d/password\", id)\n}\n\nfunc TestUsersUpdatePassword(t *testing.T) {\n\tfmt.Println(\"Testing Update User Password\")\n\toldPassword := \"old_password\"\n\tnewPassword := \"new_password\"\n\n\tuser01 := models.User{\n\t\tUsername: \"user01_for_testing_change_password\",\n\t\tEmail:    \"user01_for_testing_change_password@test.com\",\n\t\tPassword: oldPassword,\n\t}\n\tid, err := dao.Register(user01)\n\trequire.Nil(t, err)\n\tuser01.UserID = int(id)\n\tdefer dao.DeleteUser(user01.UserID)\n\n\tuser02 := models.User{\n\t\tUsername: \"user02_for_testing_change_password\",\n\t\tEmail:    \"user02_for_testing_change_password@test.com\",\n\t\tPassword: oldPassword,\n\t}\n\tid, err = dao.Register(user02)\n\trequire.Nil(t, err)\n\tuser02.UserID = int(id)\n\tdefer dao.DeleteUser(user02.UserID)\n\n\tcases := []*codeCheckingCase{\n\t\t// unauthorized\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t},\n\t\t\tcode: http.StatusUnauthorized,\n\t\t},\n\t\t// 404\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(10000),\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusNotFound,\n\t\t},\n\t\t// 403, a normal user tries to change password of others\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user02.UserID),\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusForbidden,\n\t\t},\n\t\t// 400, empty old password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod:   http.MethodPut,\n\t\t\t\turl:      buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusBadRequest,\n\t\t},\n\t\t// 400, empty new password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tOldPassword: oldPassword,\n\t\t\t\t},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusBadRequest,\n\t\t},\n\t\t// 403, incorrect old password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tOldPassword: \"incorrect_old_password\",\n\t\t\t\t\tNewPassword: newPassword,\n\t\t\t\t},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusForbidden,\n\t\t},\n\t\t// 200, normal user change own password\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tOldPassword: oldPassword,\n\t\t\t\t\tNewPassword: newPassword,\n\t\t\t\t},\n\t\t\t\tcredential: &usrInfo{\n\t\t\t\t\tName:   user01.Username,\n\t\t\t\t\tPasswd: user01.Password,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcode: http.StatusOK,\n\t\t},\n\t\t// 400, admin user change password of others.\n\t\t// the new password is same with the old one\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tNewPassword: newPassword,\n\t\t\t\t},\n\t\t\t\tcredential: admin,\n\t\t\t},\n\t\t\tcode: http.StatusBadRequest,\n\t\t},\n\t\t// 200, admin user change password of others\n\t\t{\n\t\t\trequest: &testingRequest{\n\t\t\t\tmethod: http.MethodPut,\n\t\t\t\turl:    buildChangeUserPasswordURL(user01.UserID),\n\t\t\t\tbodyJSON: &passwordReq{\n\t\t\t\t\tNewPassword: \"another_new_password\",\n\t\t\t\t},\n\t\t\t\tcredential: admin,\n\t\t\t},\n\t\t\tcode: http.StatusOK,\n\t\t},\n\t}\n\n\trunCodeCheckingCases(t, cases...)\n}\n\nfunc TestUsersDelete(t *testing.T) {\n\n\tfmt.Println(\"Testing User Delete\")\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\tt.Log(\"delete user-case 1\")\n\t// case 1:delete user without admin auth\n\tcode, err := apiTest.UsersDelete(testUser0002ID, *testUser0003Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Delete test user status should be 403\")\n\t}\n\t// case 2: delete user with admin auth, user2 has already been toggled to admin, but can not delete himself\n\tt.Log(\"delete user-case 2\")\n\tcode, err = apiTest.UsersDelete(testUser0002ID, *testUser0002Auth)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(403, code, \"Delete test user status should be 403\")\n\t}\n\t// case 3: delete user with admin auth\n\tt.Log(\"delete user-case 3\")\n\tcode, err = apiTest.UsersDelete(testUser0002ID, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Delete test user status should be 200\")\n\t}\n\t// delete user3 with admin auth\n\tcode, err = apiTest.UsersDelete(testUser0003ID, *admin)\n\tif err != nil {\n\t\tt.Error(\"Error occurred while delete test user\", err.Error())\n\t\tt.Log(err)\n\t} else {\n\t\tassert.Equal(200, code, \"Delete test user status should be 200\")\n\t}\n}\n\nfunc TestModifiable(t *testing.T) {\n\tt.Log(\"Test modifiable.\")\n\tassert := assert.New(t)\n\tbase := BaseController{\n\t\tBaseAPI: api.BaseAPI{\n\t\t\tController: beego.Controller{},\n\t\t},\n\t\tSecurityCtx: nil,\n\t\tProjectMgr:  nil,\n\t}\n\n\tua1 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    3,\n\t\tuserID:           4,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          false,\n\t\tAuthMode:         \"db_auth\",\n\t}\n\tassert.False(ua1.modifiable())\n\tua2 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    3,\n\t\tuserID:           4,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          true,\n\t\tAuthMode:         \"db_auth\",\n\t}\n\tassert.True(ua2.modifiable())\n\tua3 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    3,\n\t\tuserID:           4,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          true,\n\t\tAuthMode:         \"ldap_auth\",\n\t}\n\tassert.False(ua3.modifiable())\n\tua4 := &UserAPI{\n\t\tBaseController:   base,\n\t\tcurrentUserID:    1,\n\t\tuserID:           1,\n\t\tSelfRegistration: false,\n\t\tIsAdmin:          true,\n\t\tAuthMode:         \"ldap_auth\",\n\t}\n\tassert.True(ua4.modifiable())\n}\n\nfunc TestUsersCurrentPermissions(t *testing.T) {\n\tfmt.Println(\"Testing Get Users Current Permissions\")\n\n\tassert := assert.New(t)\n\tapiTest := newHarborAPI()\n\n\thttpStatusCode, permissions, err := apiTest.UsersGetPermissions(\"current\", \"/project/1\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(200), httpStatusCode, \"httpStatusCode should be 200\")\n\tassert.NotEmpty(permissions, \"permissions should not be empty\")\n\n\thttpStatusCode, permissions, err = apiTest.UsersGetPermissions(\"current\", \"/unsupport-scope\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(200), httpStatusCode, \"httpStatusCode should be 200\")\n\tassert.Empty(permissions, \"permissions should be empty\")\n\n\thttpStatusCode, _, err = apiTest.UsersGetPermissions(projAdminID, \"/project/1\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(200), httpStatusCode, \"httpStatusCode should be 200\")\n\n\thttpStatusCode, _, err = apiTest.UsersGetPermissions(projDeveloperID, \"/project/1\", *projAdmin)\n\tassert.Nil(err)\n\tassert.Equal(int(403), httpStatusCode, \"httpStatusCode should be 403\")\n}\n"], "filenames": ["src/core/api/user.go", "src/core/api/user_test.go"], "buggy_code_start_loc": [326, 48], "buggy_code_end_loc": [348, 179], "fixing_code_start_loc": [327, 48], "fixing_code_end_loc": [358, 191], "type": "CWE-862", "message": "core/api/user.go in Harbor 1.7.0 through 1.8.2 allows non-admin users to create admin accounts via the POST /api/users API, when Harbor is setup with DB as authentication backend and allow user to do self-registration. Fixed version: v1.7.6 v1.8.3. v.1.9.0. Workaround without applying the fix: configure Harbor to use non-DB authentication backend such as LDAP.", "other": {"cve": {"id": "CVE-2019-16097", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-08T16:15:11.820", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "core/api/user.go in Harbor 1.7.0 through 1.8.2 allows non-admin users to create admin accounts via the POST /api/users API, when Harbor is setup with DB as authentication backend and allow user to do self-registration. Fixed version: v1.7.6 v1.8.3. v.1.9.0. Workaround without applying the fix: configure Harbor to use non-DB authentication backend such as LDAP."}, {"lang": "es", "value": "core/api/user.go en Harbor versi\u00f3n 1.7.0 hasta la versi\u00f3n 1.8.2 permite a los usuarios que no son administradores crear cuentas de administrador mediante el POST /api/users API, cuando Harbor se configura con DB como back-end de autenticaci\u00f3n y permite al usuario realizar el autorregistro. Esto se corrige en la versi\u00f3n 1.7.6, versi\u00f3n 1.8.3. versi\u00f3n 1.9.0. Soluci\u00f3n alternativa sin aplicar la correcci\u00f3n: configure Harbor para que utilice el backend de autenticaci\u00f3n que no sea de base de datos, como LDAP."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.0:-:*:*:*:*:*:*", "matchCriteriaId": "A821F059-11AC-4F49-A252-5DC473ED6F2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "6DAC0844-F418-457B-B97B-21B321BEC456"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "3B0D228F-2398-4727-B25D-9C191A6B5B45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "C751ACB0-551E-44E3-9BAF-9DD5F51FA873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "608DB219-F359-4056-8CE8-C360A57DDCE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "FF3210DE-A99E-458E-AF49-3E8CD284D6AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "12809349-0DC1-4F4F-BB29-958717FD7C39"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "5B45EDEE-EC64-474D-9959-6F1EAA1E6876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "53503E8E-84B4-4CD1-8DDC-3C15BF98CEF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "096D5DC7-5898-4765-8E71-A89A5CABA54B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.8.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "3726DEC5-21ED-4E3D-9C3E-82D6762669AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "C54E5105-221B-4911-A1DC-1736C20928B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.8.2:-:*:*:*:*:*:*", "matchCriteriaId": "08F17BB4-0E84-4C73-B36C-E71D88D34FC9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.8.2:rc1:*:*:*:*:*:*", "matchCriteriaId": "E228C4B2-24DE-4AEA-8485-35F2FFCF153D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.8.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "F734320C-329C-4E49-8516-62F5E4B0015F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:harbor:1.9.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "EB9B2E26-AD5F-4B79-A3E1-46355602B4ED"}]}]}], "references": [{"url": "http://www.vmware.com/security/advisories/VMSA-2019-0015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/goharbor/harbor/commit/b6db8a8a106259ec9a2c48be8a380cb3b37cf517", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/goharbor/harbor/compare/v1.8.2...v1.9.0-rc1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/goharbor/harbor/releases/tag/v1.7.6", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/goharbor/harbor/releases/tag/v1.8.3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://unit42.paloaltonetworks.com/critical-vulnerability-in-harbor-enables-privilege-escalation-from-zero-to-admin-cve-2019-16097/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/goharbor/harbor/commit/b6db8a8a106259ec9a2c48be8a380cb3b37cf517"}}