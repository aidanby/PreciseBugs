{"buggy_code": ["import base64\nimport gzip\nimport json\nimport re\nfrom gettext import gettext as _\nfrom io import BytesIO\n\nimport requests\nimport yaml\n\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.helper.recipe_html_import import get_recipe_from_source\nfrom cookbook.helper.recipe_url_import import iso_duration_to_minutes\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Keyword, Recipe, Step\n\n\nclass CookBookApp(Integration):\n\n    def import_file_name_filter(self, zip_info_object):\n        return zip_info_object.filename.endswith('.html')\n\n    def get_recipe_from_file(self, file):\n        recipe_html = file.getvalue().decode(\"utf-8\")\n\n        recipe_json, recipe_tree, html_data, images = get_recipe_from_source(recipe_html, 'CookBookApp', self.request)\n\n        recipe = Recipe.objects.create(\n            name=recipe_json['name'].strip(),\n            created_by=self.request.user, internal=True,\n            space=self.request.space)\n\n        try:\n            recipe.servings = re.findall('([0-9])+', recipe_json['recipeYield'])[0]\n        except Exception as e:\n            pass\n\n        try:\n            recipe.working_time = iso_duration_to_minutes(recipe_json['prepTime'])\n            recipe.waiting_time = iso_duration_to_minutes(recipe_json['cookTime'])\n        except Exception:\n            pass\n\n        step = Step.objects.create(instruction=recipe_json['recipeInstructions'], space=self.request.space, )\n\n        if 'nutrition' in recipe_json:\n            step.instruction = step.instruction + '\\n\\n' + recipe_json['nutrition']\n\n        step.save()\n        recipe.steps.add(step)\n\n        ingredient_parser = IngredientParser(self.request, True)\n        for ingredient in recipe_json['recipeIngredient']:\n            f = ingredient_parser.get_food(ingredient['ingredient']['text'])\n            u = ingredient_parser.get_unit(ingredient['unit']['text'])\n            step.ingredients.add(Ingredient.objects.create(\n                food=f, unit=u, amount=ingredient['amount'], note=ingredient['note'],  space=self.request.space,\n            ))\n\n        if len(images) > 0:\n            try:\n                response = requests.get(images[0])\n                self.import_recipe_image(recipe, BytesIO(response.content))\n            except Exception as e:\n                print('failed to import image ', str(e))\n\n        recipe.save()\n        return recipe\n", "import base64\nimport json\nfrom io import BytesIO\n\nfrom gettext import gettext as _\n\nimport requests\nfrom lxml import etree\n\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.helper.recipe_url_import import parse_servings, parse_time, parse_servings_text\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Keyword, Recipe, Step\n\n\nclass Cookmate(Integration):\n\n    def import_file_name_filter(self, zip_info_object):\n        return zip_info_object.filename.endswith('.xml')\n\n    def get_files_from_recipes(self, recipes, el, cookie):\n        raise NotImplementedError('Method not implemented in storage integration')\n\n    def get_recipe_from_file(self, file):\n        recipe_xml = file\n\n        recipe = Recipe.objects.create(\n            name=recipe_xml.find('title').text.strip(),\n            created_by=self.request.user, internal=True, space=self.request.space)\n\n        if recipe_xml.find('preptime') is not None and recipe_xml.find('preptime').text is not None:\n            recipe.working_time = parse_time(recipe_xml.find('preptime').text.strip())\n\n        if recipe_xml.find('cooktime') is not None and recipe_xml.find('cooktime').text is not None:\n            recipe.waiting_time = parse_time(recipe_xml.find('cooktime').text.strip())\n\n        if recipe_xml.find('quantity') is not None and recipe_xml.find('quantity').text is not None:\n            recipe.servings = parse_servings(recipe_xml.find('quantity').text.strip())\n            recipe.servings_text = parse_servings_text(recipe_xml.find('quantity').text.strip())\n\n        if recipe_xml.find('url') is not None and recipe_xml.find('url').text is not None:\n            recipe.source_url = recipe_xml.find('url').text.strip()\n\n        if recipe_xml.find('description') is not None:  # description is a list of <li>'s with text\n            if len(recipe_xml.find('description')) > 0:\n                recipe.description = recipe_xml.find('description')[0].text[:512]\n\n        for step in recipe_xml.find('recipetext').getchildren():\n            step = Step.objects.create(\n                instruction=step.text.strip(), space=self.request.space,\n            )\n            recipe.steps.add(step)\n\n        ingredient_parser = IngredientParser(self.request, True)\n\n        for ingredient in recipe_xml.find('ingredient').getchildren():\n            if ingredient.text.strip() != '':\n                amount, unit, food, note = ingredient_parser.parse(ingredient.text.strip())\n                f = ingredient_parser.get_food(food)\n                u = ingredient_parser.get_unit(unit)\n                recipe.steps.first().ingredients.add(Ingredient.objects.create(\n                    food=f, unit=u, amount=amount, note=note, original_text=ingredient.text.strip(), space=self.request.space,\n                ))\n\n        if recipe_xml.find('imageurl') is not None:\n            try:\n                response = requests.get(recipe_xml.find('imageurl').text.strip())\n                self.import_recipe_image(recipe, BytesIO(response.content))\n            except Exception as e:\n                print('failed to import image ', str(e))\n\n        recipe.save()\n\n        return recipe\n\n    def get_file_from_recipe(self, recipe):\n        raise NotImplementedError('Method not implemented in storage integration')\n", "import imghdr\nimport json\nimport re\nfrom io import BytesIO\nfrom zipfile import ZipFile\n\nimport requests\n\nfrom django.utils.translation import gettext as _\nfrom cookbook.helper.image_processing import get_filetype\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Keyword, Recipe, Step\n\n\nclass RecetteTek(Integration):\n\n    def import_file_name_filter(self, zip_info_object):\n        print(\"testing\", zip_info_object.filename)\n        return re.match(r'^recipes_0.json$', zip_info_object.filename) or re.match(r'^recipes.json$', zip_info_object.filename)\n\n    def split_recipe_file(self, file):\n\n        recipe_json = json.loads(file)\n\n        recipe_list = [r for r in recipe_json]\n\n        return recipe_list\n\n    def get_recipe_from_file(self, file):\n\n        # Create initial recipe with just a title and a description\n        recipe = Recipe.objects.create(name=file['title'], created_by=self.request.user, internal=True, space=self.request.space, )\n\n        # set the description as an empty string for later use for the source URL, in case there is no description text.\n        recipe.description = ''\n\n        try:\n            if file['description'] != '':\n                recipe.description = file['description'].strip()\n        except Exception as e:\n            print(recipe.name, ': failed to parse recipe description ', str(e))\n\n        instructions = file['instructions']\n        if not instructions:\n            instructions = ''\n\n        step = Step.objects.create(instruction=instructions, space=self.request.space,)\n\n        # Append the original import url to the step (if it exists)\n        try:\n            if file['url'] != '':\n                step.instruction += '\\n\\n' + _('Imported from') + ': ' + file['url']\n                step.save()\n        except Exception as e:\n            print(recipe.name, ': failed to import source url ', str(e))\n\n        try:\n            # Process the ingredients. Assumes 1 ingredient per line.\n            ingredient_parser = IngredientParser(self.request, True)\n            for ingredient in file['ingredients'].split('\\n'):\n                if len(ingredient.strip()) > 0:\n                    amount, unit, food, note = ingredient_parser.parse(food)\n                    f = ingredient_parser.get_food(ingredient)\n                    u = ingredient_parser.get_unit(unit)\n                    step.ingredients.add(Ingredient.objects.create(\n                        food=f, unit=u, amount=amount, note=note, original_text=ingredient, space=self.request.space,\n                    ))\n        except Exception as e:\n            print(recipe.name, ': failed to parse recipe ingredients ', str(e))\n        recipe.steps.add(step)\n\n        # Attempt to import prep/cooking times\n        # quick hack, this assumes only one number in the quantity field.\n        try:\n            if file['quantity'] != '':\n                for item in file['quantity'].split(' '):\n                    if item.isdigit():\n                        recipe.servings = int(item)\n                        break\n        except Exception as e:\n            print(recipe.name, ': failed to parse quantity ', str(e))\n\n        try:\n            if file['totalTime'] != '':\n                recipe.waiting_time = int(file['totalTime'])\n        except Exception as e:\n            print(recipe.name, ': failed to parse total times ', str(e))\n\n        try:\n            if file['preparationTime'] != '':\n                recipe.working_time = int(file['preparationTime'])\n        except Exception as e:\n            print(recipe.name, ': failed to parse prep time ', str(e))\n\n        try:\n            if file['cookingTime'] != '':\n                recipe.waiting_time = int(file['cookingTime'])\n        except Exception as e:\n            print(recipe.name, ': failed to parse cooking time ', str(e))\n\n        recipe.save()\n\n        # Import the recipe keywords\n        try:\n            if file['keywords'] != '':\n                for keyword in file['keywords'].split(';'):\n                    k, created = Keyword.objects.get_or_create(name=keyword.strip(), space=self.request.space)\n                    recipe.keywords.add(k)\n            recipe.save()\n        except Exception as e:\n            print(recipe.name, ': failed to parse keywords ', str(e))\n\n        # TODO: Parse Nutritional Information\n\n        # Import the original image from the zip file, if we cannot do that, attempt to download it again.\n        try:\n            if file['pictures'][0] != '':\n                image_file_name = file['pictures'][0].split('/')[-1]\n                for f in self.files:\n                    if '.rtk' in f['name']:\n                        import_zip = ZipFile(f['file'])\n                        self.import_recipe_image(recipe, BytesIO(import_zip.read(image_file_name)), filetype=get_filetype(image_file_name))\n            else:\n                if file['originalPicture'] != '':\n                    response = requests.get(file['originalPicture'])\n                    if imghdr.what(BytesIO(response.content)) is not None:\n                        self.import_recipe_image(recipe, BytesIO(response.content), filetype=get_filetype(file['originalPicture']))\n                    else:\n                        raise Exception(\"Original image failed to download.\")\n        except Exception as e:\n            print(recipe.name, ': failed to import image ', str(e))\n\n        return recipe\n\n    def get_file_from_recipe(self, recipe):\n        raise NotImplementedError('Method not implemented in storage integration')\n", "import json\nfrom io import BytesIO\n\nimport requests\n\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Recipe, Step\n\n\nclass RecipeSage(Integration):\n\n    def get_recipe_from_file(self, file):\n\n        recipe = Recipe.objects.create(\n            name=file['name'].strip(),\n            created_by=self.request.user, internal=True,\n            space=self.request.space)\n\n        try:\n            if file['recipeYield'] != '':\n                recipe.servings = int(file['recipeYield'])\n\n            if file['totalTime'] != '':\n                recipe.waiting_time = int(file['totalTime']) - int(file['timePrep'])\n\n            if file['prepTime'] != '':\n                recipe.working_time = int(file['timePrep'])\n\n            recipe.save()\n        except Exception as e:\n            print('failed to parse yield or time ', str(e))\n\n        ingredient_parser = IngredientParser(self.request, True)\n        ingredients_added = False\n        for s in file['recipeInstructions']:\n            step = Step.objects.create(\n                instruction=s['text'], space=self.request.space,\n            )\n            if not ingredients_added:\n                ingredients_added = True\n\n                for ingredient in file['recipeIngredient']:\n                    amount, unit, food, note = ingredient_parser.parse(ingredient)\n                    f = ingredient_parser.get_food(food)\n                    u = ingredient_parser.get_unit(unit)\n                    step.ingredients.add(Ingredient.objects.create(\n                        food=f, unit=u, amount=amount, note=note, original_text=ingredient, space=self.request.space,\n                    ))\n            recipe.steps.add(step)\n\n        if len(file['image']) > 0:\n            try:\n                response = requests.get(file['image'][0])\n                self.import_recipe_image(recipe, BytesIO(response.content))\n            except Exception as e:\n                print('failed to import image ', str(e))\n\n        return recipe\n\n    def get_file_from_recipe(self, recipe):\n        data = {\n            '@context': 'http://schema.org',\n            '@type': 'Recipe',\n            'creditText': '',\n            'isBasedOn': '',\n            'name': recipe.name,\n            'description': recipe.description,\n            'prepTime': str(recipe.working_time),\n            'totalTime': str(recipe.waiting_time + recipe.working_time),\n            'recipeYield': str(recipe.servings),\n            'image': [],\n            'recipeCategory': [],\n            'comment': [],\n            'recipeIngredient': [],\n            'recipeInstructions': [],\n        }\n\n        for s in recipe.steps.all():\n            data['recipeInstructions'].append({\n                '@type': 'HowToStep',\n                'text': s.instruction\n            })\n\n            for i in s.ingredients.all():\n                data['recipeIngredient'].append(f'{float(i.amount)} {i.unit} {i.food}')\n\n        return data\n\n    def get_files_from_recipes(self, recipes, el, cookie):\n        json_list = []\n        for r in recipes:\n            json_list.append(self.get_file_from_recipe(r))\n\n            el.exported_recipes += 1\n            el.msg += self.get_recipe_processed_msg(r)\n            el.save()\n\n        return [[self.get_export_file_name('json'), json.dumps(json_list)]]\n\n    def split_recipe_file(self, file):\n        return json.loads(file.read().decode(\"utf-8\"))\n", "import io\nimport json\nimport os\nfrom datetime import datetime\n\nimport requests\nfrom cookbook.models import Recipe, RecipeImport, SyncLog\nfrom cookbook.provider.provider import Provider\n\n\nclass Dropbox(Provider):\n\n    @staticmethod\n    def import_all(monitor):\n        url = \"https://api.dropboxapi.com/2/files/list_folder\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + monitor.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": monitor.path\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n        try:\n            recipes = r.json()\n        except ValueError:\n            log_entry = SyncLog(status='ERROR', msg=str(r), sync=monitor)\n            log_entry.save()\n            return r\n\n        import_count = 0\n        # TODO check if has_more is set and import that as well\n        for recipe in recipes['entries']:\n            path = recipe['path_lower']\n            if not Recipe.objects.filter(file_path__iexact=path, space=monitor.space).exists() and not RecipeImport.objects.filter(file_path=path, space=monitor.space).exists():\n                name = os.path.splitext(recipe['name'])[0]\n                new_recipe = RecipeImport(\n                    name=name,\n                    file_path=path,\n                    storage=monitor.storage,\n                    file_uid=recipe['id'],\n                    space=monitor.space,\n                )\n                new_recipe.save()\n                import_count += 1\n\n        log_entry = SyncLog(\n            status='SUCCESS',\n            msg='Imported ' + str(import_count) + ' recipes',\n            sync=monitor,\n        )\n        log_entry.save()\n\n        monitor.last_checked = datetime.now()\n        monitor.save()\n\n        return True\n\n    @staticmethod\n    def create_share_link(recipe):\n        url = \"https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings\"  # noqa: E501\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": recipe.file_uid\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n\n        return r.json()\n\n    @staticmethod\n    def get_share_link(recipe):\n        url = \"https://api.dropboxapi.com/2/sharing/list_shared_links\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": recipe.file_path,\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n        p = r.json()\n\n        for link in p['links']:\n            return link['url']\n\n        response = Dropbox.create_share_link(recipe)\n        return response['url']\n\n    @staticmethod\n    def get_file(recipe):\n        if not recipe.link:\n            recipe.link = Dropbox.get_share_link(recipe)\n            recipe.save()\n\n        response = requests.get(recipe.link.replace('www.dropbox.', 'dl.dropboxusercontent.'))\n\n        return io.BytesIO(response.content)\n\n    @staticmethod\n    def rename_file(recipe, new_name):\n        url = \"https://api.dropboxapi.com/2/files/move_v2\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"from_path\": recipe.file_path,\n            \"to_path\": \"%s/%s%s\" % (\n                os.path.dirname(recipe.file_path),\n                new_name,\n                os.path.splitext(recipe.file_path)[1]\n            )\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n\n        return r.json()\n\n    @staticmethod\n    def delete_file(recipe):\n        url = \"https://api.dropboxapi.com/2/files/delete_v2\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": recipe.file_path\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n\n        return r.json()\n", "import io\nimport os\nimport tempfile\nfrom datetime import datetime\n\nimport requests\nimport webdav3.client as wc\nfrom cookbook.models import Recipe, RecipeImport, SyncLog\nfrom cookbook.provider.provider import Provider\nfrom requests.auth import HTTPBasicAuth\n\nfrom recipes.settings import DEBUG\n\n\nclass Nextcloud(Provider):\n\n    @staticmethod\n    def get_client(storage):\n        options = {\n            'webdav_hostname': storage.url,\n            'webdav_login': storage.username,\n            'webdav_password': storage.password,\n            'webdav_root': '/remote.php/dav/files/' + storage.username\n        }\n        if storage.path != '':\n            options['webdav_root'] = storage.path\n        return wc.Client(options)\n\n    @staticmethod\n    def import_all(monitor):\n        client = Nextcloud.get_client(monitor.storage)\n\n        if DEBUG:\n            print(f'TANDOOR_PROVIDER_DEBUG checking path  {monitor.path} with client {client}')\n\n        files = client.list(monitor.path)\n\n        if DEBUG:\n            print(f'TANDOOR_PROVIDER_DEBUG file list  {files}')\n\n        import_count = 0\n        for file in files:\n            if DEBUG:\n                print(f'TANDOOR_PROVIDER_DEBUG importing file {file}')\n            path = monitor.path + '/' + file\n            if not Recipe.objects.filter(file_path__iexact=path, space=monitor.space).exists() and not RecipeImport.objects.filter(file_path=path, space=monitor.space).exists():\n                name = os.path.splitext(file)[0]\n                new_recipe = RecipeImport(\n                    name=name,\n                    file_path=path,\n                    storage=monitor.storage,\n                    space=monitor.space,\n                )\n                new_recipe.save()\n                import_count += 1\n\n        log_entry = SyncLog(\n            status='SUCCESS',\n            msg='Imported ' + str(import_count) + ' recipes',\n            sync=monitor,\n        )\n        log_entry.save()\n\n        monitor.last_checked = datetime.now()\n        monitor.save()\n\n        return True\n\n    @staticmethod\n    def create_share_link(recipe):\n        url = recipe.storage.url + '/ocs/v2.php/apps/files_sharing/api/v1/shares?format=json'  # noqa: E501\n\n        headers = {\n            \"OCS-APIRequest\": \"true\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n\n        data = {'path': recipe.file_path, 'shareType': 3}\n\n        r = requests.post(url, headers=headers, auth=HTTPBasicAuth(recipe.storage.username, recipe.storage.password), data=data)\n\n        response_json = r.json()\n\n        return response_json['ocs']['data']['url']\n\n    @staticmethod\n    def get_share_link(recipe):\n        url = recipe.storage.url + '/ocs/v2.php/apps/files_sharing/api/v1/shares?format=json&path=' + recipe.file_path  # noqa: E501\n\n        headers = {\n            \"OCS-APIRequest\": \"true\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        r = requests.get(\n            url,\n            headers=headers,\n            auth=HTTPBasicAuth(\n                recipe.storage.username, recipe.storage.password\n            )\n        )\n\n        response_json = r.json()\n        for element in response_json['ocs']['data']:\n            if element['share_type'] == '3':\n                return element['url']\n\n        return Nextcloud.create_share_link(recipe)\n\n    @staticmethod\n    def get_file(recipe):\n        client = Nextcloud.get_client(recipe.storage)\n\n        tmp_file_path = tempfile.gettempdir() + '/' + recipe.name + '.pdf'\n\n        client.download_file(\n            remote_path=recipe.file_path,\n            local_path=tmp_file_path\n        )\n\n        file = io.BytesIO(open(tmp_file_path, 'rb').read())\n        os.remove(tmp_file_path)\n\n        return file\n\n    @staticmethod\n    def rename_file(recipe, new_name):\n        client = Nextcloud.get_client(recipe.storage)\n\n        client.move(\n            recipe.file_path,\n            \"%s/%s%s\" % (\n                os.path.dirname(recipe.file_path),\n                new_name,\n                os.path.splitext(recipe.file_path)[1]\n            )\n        )\n\n        return True\n\n    @staticmethod\n    def delete_file(recipe):\n        client = Nextcloud.get_client(recipe.storage)\n\n        client.clean(recipe.file_path)\n\n        return True\n", "import io\nimport json\nimport mimetypes\nimport re\nimport uuid\nfrom collections import OrderedDict\n\nimport requests\nfrom PIL import UnidentifiedImageError\nfrom annoying.decorators import ajax_request\nfrom annoying.functions import get_object_or_None\nfrom django.contrib import messages\nfrom django.contrib.auth.models import User\nfrom django.contrib.postgres.search import TrigramSimilarity\nfrom django.core.exceptions import FieldError, ValidationError\nfrom django.core.files import File\nfrom django.db.models import (Case, Count, Exists, F, IntegerField, OuterRef, ProtectedError, Q,\n                              Subquery, Value, When)\nfrom django.db.models.fields.related import ForeignObjectRel\nfrom django.db.models.functions import Coalesce, Lower\nfrom django.http import FileResponse, HttpResponse, JsonResponse\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\nfrom django_scopes import scopes_disabled\nfrom icalendar import Calendar, Event\nfrom recipe_scrapers import NoSchemaFoundInWildMode, WebsiteNotImplementedError, scrape_me\nfrom requests.exceptions import MissingSchema\nfrom rest_framework import decorators, status, viewsets\nfrom rest_framework.exceptions import APIException, PermissionDenied\nfrom rest_framework.pagination import PageNumberPagination\nfrom rest_framework.parsers import MultiPartParser\nfrom rest_framework.renderers import JSONRenderer, TemplateHTMLRenderer\nfrom rest_framework.response import Response\nfrom rest_framework.viewsets import ViewSetMixin\nfrom treebeard.exceptions import InvalidMoveToDescendant, InvalidPosition, PathOverflow\n\nfrom cookbook.helper.HelperFunctions import str2bool\nfrom cookbook.helper.image_processing import handle_image\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.helper.permission_helper import (CustomIsAdmin, CustomIsGuest, CustomIsOwner,\n                                               CustomIsShare, CustomIsShared, CustomIsUser,\n                                               group_required)\nfrom cookbook.helper.recipe_html_import import get_recipe_from_source\nfrom cookbook.helper.recipe_search import RecipeFacet, RecipeSearch, old_search\nfrom cookbook.helper.recipe_url_import import get_from_scraper\nfrom cookbook.helper.shopping_helper import RecipeShoppingEditor, shopping_helper\nfrom cookbook.models import (Automation, BookmarkletImport, CookLog, CustomFilter, ExportLog, Food,\n                             FoodInheritField, ImportLog, Ingredient, Keyword, MealPlan, MealType,\n                             Recipe, RecipeBook, RecipeBookEntry, ShareLink, ShoppingList,\n                             ShoppingListEntry, ShoppingListRecipe, Step, Storage, Supermarket,\n                             SupermarketCategory, SupermarketCategoryRelation, Sync, SyncLog, Unit,\n                             UserFile, UserPreference, ViewLog)\nfrom cookbook.provider.dropbox import Dropbox\nfrom cookbook.provider.local import Local\nfrom cookbook.provider.nextcloud import Nextcloud\nfrom cookbook.schemas import FilterSchema, QueryParam, QueryParamAutoSchema, TreeSchema\nfrom cookbook.serializer import (AutomationSerializer, BookmarkletImportSerializer,\n                                 CookLogSerializer, CustomFilterSerializer, ExportLogSerializer,\n                                 FoodInheritFieldSerializer, FoodSerializer,\n                                 FoodShoppingUpdateSerializer, ImportLogSerializer,\n                                 IngredientSerializer, KeywordSerializer, MealPlanSerializer,\n                                 MealTypeSerializer, RecipeBookEntrySerializer,\n                                 RecipeBookSerializer, RecipeImageSerializer,\n                                 RecipeOverviewSerializer, RecipeSerializer,\n                                 RecipeShoppingUpdateSerializer, RecipeSimpleSerializer,\n                                 ShoppingListAutoSyncSerializer, ShoppingListEntrySerializer,\n                                 ShoppingListRecipeSerializer, ShoppingListSerializer,\n                                 StepSerializer, StorageSerializer,\n                                 SupermarketCategoryRelationSerializer,\n                                 SupermarketCategorySerializer, SupermarketSerializer,\n                                 SyncLogSerializer, SyncSerializer, UnitSerializer,\n                                 UserFileSerializer, UserNameSerializer, UserPreferenceSerializer,\n                                 ViewLogSerializer, IngredientSimpleSerializer, BookmarkletImportListSerializer)\nfrom recipes import settings\n\n\nclass StandardFilterMixin(ViewSetMixin):\n    def get_queryset(self):\n        queryset = self.queryset\n        query = self.request.query_params.get('query', None)\n        if query is not None:\n            queryset = queryset.filter(name__icontains=query)\n\n        updated_at = self.request.query_params.get('updated_at', None)\n        if updated_at is not None:\n            try:\n                queryset = queryset.filter(updated_at__gte=updated_at)\n            except FieldError:\n                pass\n            except ValidationError:\n                raise APIException(_('Parameter updated_at incorrectly formatted'))\n\n        limit = self.request.query_params.get('limit', None)\n        random = self.request.query_params.get('random', False)\n        if limit is not None:\n            if random:\n                queryset = queryset.order_by(\"?\")[:int(limit)]\n            else:\n                queryset = queryset[:int(limit)]\n        return queryset\n\n\nclass DefaultPagination(PageNumberPagination):\n    page_size = 50\n    page_size_query_param = 'page_size'\n    max_page_size = 200\n\n\nclass ExtendedRecipeMixin():\n    '''\n    ExtendedRecipe annotates a queryset with recipe_image and recipe_count values\n    '''\n\n    @classmethod\n    def annotate_recipe(self, queryset=None, request=None, serializer=None, tree=False):\n        extended = str2bool(request.query_params.get('extended', None))\n        if extended:\n            recipe_filter = serializer.recipe_filter\n            images = serializer.images\n            space = request.space\n\n            # add a recipe count annotation to the query\n            #  explanation on construction https://stackoverflow.com/a/43771738/15762829\n            recipe_count = Recipe.objects.filter(**{recipe_filter: OuterRef('id')}, space=space).values(\n                recipe_filter).annotate(count=Count('pk')).values('count')\n            queryset = queryset.annotate(recipe_count=Coalesce(Subquery(recipe_count), 0))\n\n            # add a recipe image annotation to the query\n            image_subquery = Recipe.objects.filter(**{recipe_filter: OuterRef('id')}, space=space).exclude(\n                image__isnull=True).exclude(image__exact='').order_by(\"?\").values('image')[:1]\n            if tree:\n                image_children_subquery = Recipe.objects.filter(\n                    **{f\"{recipe_filter}__path__startswith\": OuterRef('path')},\n                    space=space).exclude(image__isnull=True).exclude(image__exact='').order_by(\"?\").values('image')[:1]\n            else:\n                image_children_subquery = None\n            if images:\n                queryset = queryset.annotate(recipe_image=Coalesce(*images, image_subquery, image_children_subquery))\n            else:\n                queryset = queryset.annotate(recipe_image=Coalesce(image_subquery, image_children_subquery))\n        return queryset\n\n\nclass FuzzyFilterMixin(ViewSetMixin, ExtendedRecipeMixin):\n    schema = FilterSchema()\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).order_by(Lower('name').asc())\n        query = self.request.query_params.get('query', None)\n        fuzzy = self.request.user.searchpreference.lookup or any([self.model.__name__.lower() in x for x in\n                                                                  self.request.user.searchpreference.trigram.values_list(\n                                                                      'field', flat=True)])\n\n        if query is not None and query not in [\"''\", '']:\n            if fuzzy:\n                if any([self.model.__name__.lower() in x for x in\n                        self.request.user.searchpreference.unaccent.values_list('field', flat=True)]):\n                    self.queryset = self.queryset.annotate(trigram=TrigramSimilarity('name__unaccent', query))\n                else:\n                    self.queryset = self.queryset.annotate(trigram=TrigramSimilarity('name', query))\n                self.queryset = self.queryset.order_by('-trigram')\n            else:\n                # TODO have this check unaccent search settings or other search preferences?\n                filter = Q(name__icontains=query)\n                if any([self.model.__name__.lower() in x for x in\n                        self.request.user.searchpreference.unaccent.values_list('field', flat=True)]):\n                    filter |= Q(name__unaccent__icontains=query)\n\n                self.queryset = (\n                    self.queryset\n                        .annotate(starts=Case(When(name__istartswith=query, then=(Value(100))),\n                                              default=Value(0)))  # put exact matches at the top of the result set\n                        .filter(filter).order_by('-starts', Lower('name').asc())\n                )\n\n        updated_at = self.request.query_params.get('updated_at', None)\n        if updated_at is not None:\n            try:\n                self.queryset = self.queryset.filter(updated_at__gte=updated_at)\n            except FieldError:\n                pass\n            except ValidationError:\n                raise APIException(_('Parameter updated_at incorrectly formatted'))\n\n        limit = self.request.query_params.get('limit', None)\n        random = self.request.query_params.get('random', False)\n        if random:\n            self.queryset = self.queryset.order_by(\"?\")\n        if limit is not None:\n            self.queryset = self.queryset[:int(limit)]\n        return self.annotate_recipe(queryset=self.queryset, request=self.request, serializer=self.serializer_class)\n\n\nclass MergeMixin(ViewSetMixin):\n    @decorators.action(detail=True, url_path='merge/(?P<target>[^/.]+)', methods=['PUT'], )\n    @decorators.renderer_classes((TemplateHTMLRenderer, JSONRenderer))\n    def merge(self, request, pk, target):\n        self.description = f\"Merge {self.basename} onto target {self.basename} with ID of [int].\"\n\n        try:\n            source = self.model.objects.get(pk=pk, space=self.request.space)\n        except (self.model.DoesNotExist):\n            content = {'error': True, 'msg': _(f'No {self.basename} with id {pk} exists')}\n            return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n        if int(target) == source.id:\n            content = {'error': True, 'msg': _('Cannot merge with the same object!')}\n            return Response(content, status=status.HTTP_403_FORBIDDEN)\n\n        else:\n            try:\n                target = self.model.objects.get(pk=target, space=self.request.space)\n            except (self.model.DoesNotExist):\n                content = {'error': True, 'msg': _(f'No {self.basename} with id {target} exists')}\n                return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n            try:\n                if target in source.get_descendants_and_self():\n                    content = {'error': True, 'msg': _('Cannot merge with child object!')}\n                    return Response(content, status=status.HTTP_403_FORBIDDEN)\n                isTree = True\n            except AttributeError:\n                # AttributeError probably means its not a tree, so can safely ignore\n                isTree = False\n\n            try:\n                for link in [field for field in source._meta.get_fields() if issubclass(type(field), ForeignObjectRel)]:\n                    linkManager = getattr(source, link.get_accessor_name())\n                    related = linkManager.all()\n                    # link to foreign relationship could be OneToMany or ManyToMany\n                    if link.one_to_many:\n                        for r in related:\n                            setattr(r, link.field.name, target)\n                            r.save()\n                    elif link.many_to_many:\n                        for r in related:\n                            getattr(r, link.field.name).add(target)\n                            getattr(r, link.field.name).remove(source)\n                            r.save()\n                    else:\n                        # a new scenario exists and needs to be handled\n                        raise NotImplementedError\n                if isTree:\n                    if self.model.node_order_by:\n                        node_location = 'sorted-child'\n                    else:\n                        node_location = 'last-child'\n\n                    children = source.get_children().exclude(id=target.id)\n                    for c in children:\n                        c.move(target, node_location)\n                content = {'msg': _(f'{source.name} was merged successfully with {target.name}')}\n                source.delete()\n                return Response(content, status=status.HTTP_200_OK)\n            except Exception:\n                content = {'error': True,\n                           'msg': _(f'An error occurred attempting to merge {source.name} with {target.name}')}\n                return Response(content, status=status.HTTP_400_BAD_REQUEST)\n\n\nclass TreeMixin(MergeMixin, FuzzyFilterMixin, ExtendedRecipeMixin):\n    schema = TreeSchema()\n    model = None\n\n    def get_queryset(self):\n        root = self.request.query_params.get('root', None)\n        tree = self.request.query_params.get('tree', None)\n\n        if root:\n            if root.isnumeric():\n                try:\n                    root = int(root)\n                except ValueError:\n                    self.queryset = self.model.objects.none()\n\n                if root == 0:\n                    self.queryset = self.model.get_root_nodes()\n                else:\n                    self.queryset = self.model.objects.get(id=root).get_children()\n        elif tree:\n            if tree.isnumeric():\n                try:\n                    self.queryset = self.model.objects.get(id=int(tree)).get_descendants_and_self()\n                except self.model.DoesNotExist:\n                    self.queryset = self.model.objects.none()\n        else:\n            return self.annotate_recipe(queryset=super().get_queryset(), request=self.request,\n                                        serializer=self.serializer_class, tree=True)\n        self.queryset = self.queryset.filter(space=self.request.space).order_by(Lower('name').asc())\n\n        return self.annotate_recipe(queryset=self.queryset, request=self.request, serializer=self.serializer_class,\n                                    tree=True)\n\n    @decorators.action(detail=True, url_path='move/(?P<parent>[^/.]+)', methods=['PUT'], )\n    @decorators.renderer_classes((TemplateHTMLRenderer, JSONRenderer))\n    def move(self, request, pk, parent):\n        self.description = f\"Move {self.basename} to be a child of {self.basename} with ID of [int].  Use ID: 0 to move {self.basename} to the root.\"\n        if self.model.node_order_by:\n            node_location = 'sorted'\n        else:\n            node_location = 'last'\n\n        try:\n            child = self.model.objects.get(pk=pk, space=self.request.space)\n        except (self.model.DoesNotExist):\n            content = {'error': True, 'msg': _(f'No {self.basename} with id {pk} exists')}\n            return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n        parent = int(parent)\n        # parent 0 is root of the tree\n        if parent == 0:\n            try:\n                with scopes_disabled():\n                    child.move(self.model.get_first_root_node(), f'{node_location}-sibling')\n                content = {'msg': _(f'{child.name} was moved successfully to the root.')}\n                return Response(content, status=status.HTTP_200_OK)\n            except (PathOverflow, InvalidMoveToDescendant, InvalidPosition):\n                content = {'error': True, 'msg': _('An error occurred attempting to move ') + child.name}\n                return Response(content, status=status.HTTP_400_BAD_REQUEST)\n        elif parent == child.id:\n            content = {'error': True, 'msg': _('Cannot move an object to itself!')}\n            return Response(content, status=status.HTTP_403_FORBIDDEN)\n\n        try:\n            parent = self.model.objects.get(pk=parent, space=self.request.space)\n        except (self.model.DoesNotExist):\n            content = {'error': True, 'msg': _(f'No {self.basename} with id {parent} exists')}\n            return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n        try:\n            with scopes_disabled():\n                child.move(parent, f'{node_location}-child')\n            content = {'msg': _(f'{child.name} was moved successfully to parent {parent.name}')}\n            return Response(content, status=status.HTTP_200_OK)\n        except (PathOverflow, InvalidMoveToDescendant, InvalidPosition) as e:\n            content = {'error': True, 'msg': _('An error occurred attempting to move ') + child.name}\n            return Response(content, status=status.HTTP_400_BAD_REQUEST)\n\n\nclass UserNameViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    list:\n    optional parameters\n\n    - **filter_list**: array of user id's to get names for\n    \"\"\"\n    queryset = User.objects\n    serializer_class = UserNameSerializer\n    permission_classes = [CustomIsGuest]\n    http_method_names = ['get']\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(userpreference__space=self.request.space)\n        try:\n            filter_list = self.request.query_params.get('filter_list', None)\n            if filter_list is not None:\n                queryset = queryset.filter(pk__in=json.loads(filter_list))\n        except ValueError:\n            raise APIException('Parameter filter_list incorrectly formatted')\n\n        return queryset\n\n\nclass UserPreferenceViewSet(viewsets.ModelViewSet):\n    queryset = UserPreference.objects\n    serializer_class = UserPreferenceSerializer\n    permission_classes = [CustomIsOwner, ]\n\n    def get_queryset(self):\n        return self.queryset.filter(user=self.request.user)\n\n\nclass StorageViewSet(viewsets.ModelViewSet):\n    # TODO handle delete protect error and adjust test\n    queryset = Storage.objects\n    serializer_class = StorageSerializer\n    permission_classes = [CustomIsAdmin, ]\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass SyncViewSet(viewsets.ModelViewSet):\n    queryset = Sync.objects\n    serializer_class = SyncSerializer\n    permission_classes = [CustomIsAdmin, ]\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass SyncLogViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = SyncLog.objects\n    serializer_class = SyncLogSerializer\n    permission_classes = [CustomIsAdmin, ]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(sync__space=self.request.space)\n\n\nclass SupermarketViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = Supermarket.objects\n    serializer_class = SupermarketSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space)\n        return super().get_queryset()\n\n\nclass SupermarketCategoryViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = SupermarketCategory.objects\n    serializer_class = SupermarketCategorySerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).order_by(Lower('name').asc())\n        return super().get_queryset()\n\n\nclass SupermarketCategoryRelationViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = SupermarketCategoryRelation.objects\n    serializer_class = SupermarketCategoryRelationSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(supermarket__space=self.request.space).order_by('order')\n        return super().get_queryset()\n\n\nclass KeywordViewSet(viewsets.ModelViewSet, TreeMixin):\n    queryset = Keyword.objects\n    model = Keyword\n    serializer_class = KeywordSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n\nclass UnitViewSet(viewsets.ModelViewSet, MergeMixin, FuzzyFilterMixin):\n    queryset = Unit.objects\n    model = Unit\n    serializer_class = UnitSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n\nclass FoodInheritFieldViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = FoodInheritField.objects\n    serializer_class = FoodInheritFieldSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        # exclude fields not yet implemented\n        self.queryset = Food.inheritable_fields\n        return super().get_queryset()\n\n\nclass FoodViewSet(viewsets.ModelViewSet, TreeMixin):\n    queryset = Food.objects\n    model = Food\n    serializer_class = FoodSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        self.request._shared_users = [x.id for x in list(self.request.user.get_shopping_share())] + [\n            self.request.user.id]\n\n        self.queryset = super().get_queryset()\n        shopping_status = ShoppingListEntry.objects.filter(space=self.request.space, food=OuterRef('id'),\n                                                           checked=False).values('id')\n        # onhand_status = self.queryset.annotate(onhand_status=Exists(onhand_users_set__in=[shared_users]))\n        return self.queryset.annotate(shopping_status=Exists(shopping_status)).prefetch_related('onhand_users',\n                                                                                                'inherit_fields').select_related(\n            'recipe', 'supermarket_category')\n\n    @decorators.action(detail=True, methods=['PUT'], serializer_class=FoodShoppingUpdateSerializer, )\n    # TODO DRF only allows one action in a decorator action without overriding get_operation_id_base() this should be PUT and DELETE probably\n    def shopping(self, request, pk):\n        if self.request.space.demo:\n            raise PermissionDenied(detail='Not available in demo', code=None)\n        obj = self.get_object()\n        shared_users = list(self.request.user.get_shopping_share())\n        shared_users.append(request.user)\n        if request.data.get('_delete', False) == 'true':\n            ShoppingListEntry.objects.filter(food=obj, checked=False, space=request.space,\n                                             created_by__in=shared_users).delete()\n            content = {'msg': _(f'{obj.name} was removed from the shopping list.')}\n            return Response(content, status=status.HTTP_204_NO_CONTENT)\n\n        amount = request.data.get('amount', 1)\n        unit = request.data.get('unit', None)\n        content = {'msg': _(f'{obj.name} was added to the shopping list.')}\n\n        ShoppingListEntry.objects.create(food=obj, amount=amount, unit=unit, space=request.space,\n                                         created_by=request.user)\n        return Response(content, status=status.HTTP_204_NO_CONTENT)\n\n    def destroy(self, *args, **kwargs):\n        try:\n            return (super().destroy(self, *args, **kwargs))\n        except ProtectedError as e:\n            content = {'error': True, 'msg': e.args[0]}\n            return Response(content, status=status.HTTP_403_FORBIDDEN)\n\n\nclass RecipeBookViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = RecipeBook.objects\n    serializer_class = RecipeBookSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(Q(created_by=self.request.user) | Q(shared=self.request.user)).filter(\n            space=self.request.space).distinct()\n        return super().get_queryset()\n\n\nclass RecipeBookEntryViewSet(viewsets.ModelViewSet, viewsets.GenericViewSet):\n    \"\"\"\n        list:\n        optional parameters\n\n        - **recipe**: id of recipe - only return books for that recipe\n        - **book**: id of book - only return recipes in that book\n\n    \"\"\"\n    queryset = RecipeBookEntry.objects\n    serializer_class = RecipeBookEntrySerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(\n            Q(book__created_by=self.request.user) | Q(book__shared=self.request.user)).filter(\n            book__space=self.request.space).distinct()\n\n        recipe_id = self.request.query_params.get('recipe', None)\n        if recipe_id is not None:\n            queryset = queryset.filter(recipe__pk=recipe_id)\n\n        book_id = self.request.query_params.get('book', None)\n        if book_id is not None:\n            queryset = queryset.filter(book__pk=book_id)\n        return queryset\n\n\nclass MealPlanViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    list:\n    optional parameters\n\n    - **from_date**: filter from (inclusive) a certain date onward\n    - **to_date**: filter upward to (inclusive) certain date\n\n    \"\"\"\n    queryset = MealPlan.objects\n    serializer_class = MealPlanSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(\n            Q(created_by=self.request.user)\n            | Q(shared=self.request.user)\n        ).filter(space=self.request.space).distinct().all()\n\n        from_date = self.request.query_params.get('from_date', None)\n        if from_date is not None:\n            queryset = queryset.filter(date__gte=from_date)\n\n        to_date = self.request.query_params.get('to_date', None)\n        if to_date is not None:\n            queryset = queryset.filter(date__lte=to_date)\n        return queryset\n\n\nclass MealTypeViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    returns list of meal types created by the\n    requesting user ordered by the order field.\n    \"\"\"\n    queryset = MealType.objects\n    serializer_class = MealTypeSerializer\n    permission_classes = [CustomIsOwner]\n\n    def get_queryset(self):\n        queryset = self.queryset.order_by('order', 'id').filter(created_by=self.request.user).filter(\n            space=self.request.space).all()\n        return queryset\n\n\nclass IngredientViewSet(viewsets.ModelViewSet):\n    queryset = Ingredient.objects\n    serializer_class = IngredientSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_serializer_class(self):\n        if self.request and self.request.query_params.get('simple', False):\n            return IngredientSimpleSerializer\n        return IngredientSerializer\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(step__recipe__space=self.request.space)\n        food = self.request.query_params.get('food', None)\n        if food and re.match(r'^(\\d)+$', food):\n            queryset = queryset.filter(food_id=food)\n\n        unit = self.request.query_params.get('unit', None)\n        if unit and re.match(r'^(\\d)+$', unit):\n            queryset = queryset.filter(unit_id=unit)\n\n        return queryset\n\n\nclass StepViewSet(viewsets.ModelViewSet):\n    queryset = Step.objects\n    serializer_class = StepSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n    query_params = [\n        QueryParam(name='recipe', description=_('ID of recipe a step is part of. For multiple repeat parameter.'),\n                   qtype='int'),\n        QueryParam(name='query', description=_('Query string matched (fuzzy) against object name.'), qtype='string'),\n    ]\n    schema = QueryParamAutoSchema()\n\n    def get_queryset(self):\n        recipes = self.request.query_params.getlist('recipe', [])\n        query = self.request.query_params.get('query', None)\n        if len(recipes) > 0:\n            self.queryset = self.queryset.filter(recipe__in=recipes)\n        if query is not None:\n            self.queryset = self.queryset.filter(Q(name__icontains=query) | Q(recipe__name__icontains=query))\n        return self.queryset.filter(recipe__space=self.request.space)\n\n\nclass RecipePagination(PageNumberPagination):\n    page_size = 25\n    page_size_query_param = 'page_size'\n    max_page_size = 100\n\n    def paginate_queryset(self, queryset, request, view=None):\n        if queryset is None:\n            raise Exception\n        self.facets = RecipeFacet(request, queryset=queryset)\n        return super().paginate_queryset(queryset, request, view)\n\n    def get_paginated_response(self, data):\n        return Response(OrderedDict([\n            ('count', self.page.paginator.count),\n            ('next', self.get_next_link()),\n            ('previous', self.get_previous_link()),\n            ('results', data),\n            ('facets', self.facets.get_facets(from_cache=True))\n        ]))\n\n\nclass RecipeViewSet(viewsets.ModelViewSet):\n    queryset = Recipe.objects\n    serializer_class = RecipeSerializer\n    # TODO split read and write permission for meal plan guest\n    permission_classes = [CustomIsShare | CustomIsGuest]\n    pagination_class = RecipePagination\n\n    query_params = [\n        QueryParam(name='query', description=_(\n            'Query string matched (fuzzy) against recipe name. In the future also fulltext search.')),\n        QueryParam(name='keywords', description=_(\n            'ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or'),\n                   qtype='int'),\n        QueryParam(name='keywords_or',\n                   description=_('Keyword IDs, repeat for multiple. Return recipes with any of the keywords'),\n                   qtype='int'),\n        QueryParam(name='keywords_and',\n                   description=_('Keyword IDs, repeat for multiple. Return recipes with all of the keywords.'),\n                   qtype='int'),\n        QueryParam(name='keywords_or_not',\n                   description=_('Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.'),\n                   qtype='int'),\n        QueryParam(name='keywords_and_not',\n                   description=_('Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.'),\n                   qtype='int'),\n        QueryParam(name='foods', description=_('ID of food a recipe should have. For multiple repeat parameter.'),\n                   qtype='int'),\n        QueryParam(name='foods_or',\n                   description=_('Food IDs, repeat for multiple. Return recipes with any of the foods'), qtype='int'),\n        QueryParam(name='foods_and',\n                   description=_('Food IDs, repeat for multiple. Return recipes with all of the foods.'), qtype='int'),\n        QueryParam(name='foods_or_not',\n                   description=_('Food IDs, repeat for multiple. Exclude recipes with any of the foods.'), qtype='int'),\n        QueryParam(name='foods_and_not',\n                   description=_('Food IDs, repeat for multiple. Exclude recipes with all of the foods.'), qtype='int'),\n        QueryParam(name='units', description=_('ID of unit a recipe should have.'), qtype='int'),\n        QueryParam(name='rating', description=_(\n            'Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.'), qtype='int'),\n        QueryParam(name='books', description=_('ID of book a recipe should be in. For multiple repeat parameter.')),\n        QueryParam(name='books_or',\n                   description=_('Book IDs, repeat for multiple. Return recipes with any of the books'), qtype='int'),\n        QueryParam(name='books_and',\n                   description=_('Book IDs, repeat for multiple. Return recipes with all of the books.'), qtype='int'),\n        QueryParam(name='books_or_not',\n                   description=_('Book IDs, repeat for multiple. Exclude recipes with any of the books.'), qtype='int'),\n        QueryParam(name='books_and_not',\n                   description=_('Book IDs, repeat for multiple. Exclude recipes with all of the books.'), qtype='int'),\n        QueryParam(name='internal',\n                   description=_('If only internal recipes should be returned. [''true''/''<b>false</b>'']')),\n        QueryParam(name='random',\n                   description=_('Returns the results in randomized order. [''true''/''<b>false</b>'']')),\n        QueryParam(name='new',\n                   description=_('Returns new results first in search results. [''true''/''<b>false</b>'']')),\n        QueryParam(name='timescooked', description=_(\n            'Filter recipes cooked X times or more.  Negative values returns cooked less than X times'), qtype='int'),\n        QueryParam(name='cookedon', description=_(\n            'Filter recipes last cooked on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='createdon', description=_(\n            'Filter recipes created on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='updatedon', description=_(\n            'Filter recipes updated on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='viewedon', description=_(\n            'Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='makenow',\n                   description=_('Filter recipes that can be made with OnHand food. [''true''/''<b>false</b>'']')),\n    ]\n    schema = QueryParamAutoSchema()\n\n    def get_queryset(self):\n        share = self.request.query_params.get('share', None)\n\n        if self.detail:\n            if not share:\n                self.queryset = self.queryset.filter(space=self.request.space)\n            return super().get_queryset()\n\n        if not (share and self.detail):\n            self.queryset = self.queryset.filter(space=self.request.space)\n\n        params = {x: self.request.GET.get(x) if len({**self.request.GET}[x]) == 1 else self.request.GET.getlist(x) for x\n                  in list(self.request.GET)}\n        search = RecipeSearch(self.request, **params)\n        self.queryset = search.get_queryset(self.queryset).prefetch_related('cooklog_set')\n        return self.queryset\n\n    def list(self, request, *args, **kwargs):\n        if self.request.GET.get('debug', False):\n            return JsonResponse({\n                'new': str(self.get_queryset().query),\n                'old': str(old_search(request).query)\n            })\n        return super().list(request, *args, **kwargs)\n\n    # TODO write extensive tests for permissions\n\n    def get_serializer_class(self):\n        if self.action == 'list':\n            return RecipeOverviewSerializer\n        return self.serializer_class\n\n    @decorators.action(\n        detail=True,\n        methods=['PUT'],\n        serializer_class=RecipeImageSerializer,\n        parser_classes=[MultiPartParser],\n    )\n    def image(self, request, pk):\n        obj = self.get_object()\n\n        if obj.get_space() != request.space:\n            raise PermissionDenied(detail='You do not have the required permission to perform this action', code=403)\n\n        serializer = self.serializer_class(obj, data=request.data, partial=True)\n\n        if serializer.is_valid():\n            serializer.save()\n            image = None\n            filetype = \".jpeg\" # fall-back to .jpeg, even if wrong, at least users will know it's an image and most image viewers can open it correctly anyways\n\n            if 'image' in serializer.validated_data:\n                image = obj.image\n                filetype = mimetypes.guess_extension(serializer.validated_data['image'].content_type) or filetype\n            elif 'image_url' in serializer.validated_data:\n                try:\n                    response = requests.get(serializer.validated_data['image_url'])\n                    image = File(io.BytesIO(response.content))\n                    filetype = mimetypes.guess_extension(response.headers['content-type']) or filetype\n                except UnidentifiedImageError as e:\n                    print(e)\n                    pass\n                except MissingSchema as e:\n                    print(e)\n                    pass\n                except Exception as e:\n                    print(e)\n                    pass\n\n            if image is not None:\n                img = handle_image(request, image, filetype)\n                obj.image = File(img, name=f'{uuid.uuid4()}_{obj.pk}{filetype}')\n                obj.save()\n                return Response(serializer.data)\n\n        return Response(serializer.errors, 400)\n\n    # TODO: refactor API to use post/put/delete or leave as put and change VUE to use list_recipe after creating\n    # DRF only allows one action in a decorator action without overriding get_operation_id_base()\n    @decorators.action(\n        detail=True,\n        methods=['PUT'],\n        serializer_class=RecipeShoppingUpdateSerializer,\n    )\n    def shopping(self, request, pk):\n        if self.request.space.demo:\n            raise PermissionDenied(detail='Not available in demo', code=None)\n        obj = self.get_object()\n        ingredients = request.data.get('ingredients', None)\n        servings = request.data.get('servings', None)\n        list_recipe = request.data.get('list_recipe', None)\n        mealplan = request.data.get('mealplan', None)\n        SLR = RecipeShoppingEditor(request.user, request.space, id=list_recipe, recipe=obj, mealplan=mealplan)\n\n        content = {'msg': _(f'{obj.name} was added to the shopping list.')}\n        http_status = status.HTTP_204_NO_CONTENT\n        if servings and servings <= 0:\n            result = SLR.delete()\n        elif list_recipe:\n            result = SLR.edit(servings=servings, ingredients=ingredients)\n        else:\n            result = SLR.create(servings=servings, ingredients=ingredients)\n\n        if not result:\n            content = {'msg': ('An error occurred')}\n            http_status = status.HTTP_500_INTERNAL_SERVER_ERROR\n        else:\n            content = {'msg': _(f'{obj.name} was added to the shopping list.')}\n            http_status = status.HTTP_204_NO_CONTENT\n\n        return Response(content, status=http_status)\n\n    @decorators.action(\n        detail=True,\n        methods=['GET'],\n        serializer_class=RecipeSimpleSerializer\n    )\n    def related(self, request, pk):\n        obj = self.get_object()\n        if obj.get_space() != request.space:\n            raise PermissionDenied(detail='You do not have the required permission to perform this action', code=403)\n        try:\n            levels = int(request.query_params.get('levels', 1))\n        except (ValueError, TypeError):\n            levels = 1\n        qs = obj.get_related_recipes(\n            levels=levels)  # TODO: make levels a user setting, included in request data?, keep solely in the backend?\n        return Response(self.serializer_class(qs, many=True).data)\n\n\nclass ShoppingListRecipeViewSet(viewsets.ModelViewSet):\n    queryset = ShoppingListRecipe.objects\n    serializer_class = ShoppingListRecipeSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(\n            Q(shoppinglist__space=self.request.space) | Q(entries__space=self.request.space))\n        return self.queryset.filter(\n            Q(shoppinglist__created_by=self.request.user)\n            | Q(shoppinglist__shared=self.request.user)\n            | Q(entries__created_by=self.request.user)\n            | Q(entries__created_by__in=list(self.request.user.get_shopping_share()))\n        ).distinct().all()\n\n\nclass ShoppingListEntryViewSet(viewsets.ModelViewSet):\n    queryset = ShoppingListEntry.objects\n    serializer_class = ShoppingListEntrySerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n    query_params = [\n        QueryParam(name='id',\n                   description=_('Returns the shopping list entry with a primary key of id.  Multiple values allowed.'),\n                   qtype='int'),\n        QueryParam(\n            name='checked',\n            description=_(\n                'Filter shopping list entries on checked.  [''true'', ''false'', ''both'', ''<b>recent</b>'']<br>  - ''recent'' includes unchecked items and recently completed items.')\n        ),\n        QueryParam(name='supermarket',\n                   description=_('Returns the shopping list entries sorted by supermarket category order.'),\n                   qtype='int'),\n    ]\n    schema = QueryParamAutoSchema()\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space)\n\n        self.queryset = self.queryset.filter(\n            Q(created_by=self.request.user)\n            | Q(shoppinglist__shared=self.request.user)\n            | Q(created_by__in=list(self.request.user.get_shopping_share()))\n        ).distinct().all()\n\n        if pk := self.request.query_params.getlist('id', []):\n            self.queryset = self.queryset.filter(food__id__in=[int(i) for i in pk])\n\n        if 'checked' in self.request.query_params or 'recent' in self.request.query_params:\n            return shopping_helper(self.queryset, self.request)\n\n        # TODO once old shopping list is removed this needs updated to sharing users in preferences\n        return self.queryset\n\n\n# TODO deprecate\nclass ShoppingListViewSet(viewsets.ModelViewSet):\n    queryset = ShoppingList.objects\n    serializer_class = ShoppingListSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        return self.queryset.filter(\n            Q(created_by=self.request.user)\n            | Q(shared=self.request.user)\n            | Q(created_by__in=list(self.request.user.get_shopping_share()))\n        ).filter(space=self.request.space).distinct()\n\n    def get_serializer_class(self):\n        try:\n            autosync = self.request.query_params.get('autosync', False)\n            if autosync:\n                return ShoppingListAutoSyncSerializer\n        except AttributeError:  # Needed for the openapi schema to determine a serializer without a request\n            pass\n        return self.serializer_class\n\n\nclass ViewLogViewSet(viewsets.ModelViewSet):\n    queryset = ViewLog.objects\n    serializer_class = ViewLogSerializer\n    permission_classes = [CustomIsOwner]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        # working backwards from the test - this is supposed to be limited to user view logs only??\n        return self.queryset.filter(created_by=self.request.user).filter(space=self.request.space)\n\n\nclass CookLogViewSet(viewsets.ModelViewSet):\n    queryset = CookLog.objects\n    serializer_class = CookLogSerializer\n    permission_classes = [CustomIsOwner]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass ImportLogViewSet(viewsets.ModelViewSet):\n    queryset = ImportLog.objects\n    serializer_class = ImportLogSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass ExportLogViewSet(viewsets.ModelViewSet):\n    queryset = ExportLog.objects\n    serializer_class = ExportLogSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass BookmarkletImportViewSet(viewsets.ModelViewSet):\n    queryset = BookmarkletImport.objects\n    serializer_class = BookmarkletImportSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_serializer_class(self):\n        if self.action == 'list':\n            return BookmarkletImportListSerializer\n        return self.serializer_class\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space).all()\n\n\nclass UserFileViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = UserFile.objects\n    serializer_class = UserFileSerializer\n    permission_classes = [CustomIsUser]\n    parser_classes = [MultiPartParser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).all()\n        return super().get_queryset()\n\n\nclass AutomationViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = Automation.objects\n    serializer_class = AutomationSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).all()\n        return super().get_queryset()\n\n\nclass CustomFilterViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = CustomFilter.objects\n    serializer_class = CustomFilterSerializer\n    permission_classes = [CustomIsOwner]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(Q(created_by=self.request.user) | Q(shared=self.request.user)).filter(\n            space=self.request.space).distinct()\n        return super().get_queryset()\n\n\n# -------------- non django rest api views --------------------\n\n\ndef get_recipe_provider(recipe):\n    if recipe.storage.method == Storage.DROPBOX:\n        return Dropbox\n    elif recipe.storage.method == Storage.NEXTCLOUD:\n        return Nextcloud\n    elif recipe.storage.method == Storage.LOCAL:\n        return Local\n    else:\n        raise Exception('Provider not implemented')\n\n\ndef update_recipe_links(recipe):\n    if not recipe.link:\n        # TODO response validation in apis\n        recipe.link = get_recipe_provider(recipe).get_share_link(recipe)\n\n    recipe.save()\n\n\n@group_required('user')\ndef get_external_file_link(request, recipe_id):\n    recipe = get_object_or_404(Recipe, pk=recipe_id, space=request.space)\n    if not recipe.link:\n        update_recipe_links(recipe)\n\n    return HttpResponse(recipe.link)\n\n\n@group_required('guest')\ndef get_recipe_file(request, recipe_id):\n    recipe = get_object_or_404(Recipe, pk=recipe_id, space=request.space)\n    if recipe.storage:\n        return FileResponse(get_recipe_provider(recipe).get_file(recipe))\n    else:\n        return FileResponse()\n\n\n@group_required('user')\ndef sync_all(request):\n    if request.space.demo or settings.HOSTED:\n        messages.add_message(request, messages.ERROR,\n                             _('This feature is not yet available in the hosted version of tandoor!'))\n        return redirect('index')\n\n    monitors = Sync.objects.filter(active=True).filter(space=request.user.userpreference.space)\n\n    error = False\n    for monitor in monitors:\n        if monitor.storage.method == Storage.DROPBOX:\n            ret = Dropbox.import_all(monitor)\n            if not ret:\n                error = True\n        if monitor.storage.method == Storage.NEXTCLOUD:\n            ret = Nextcloud.import_all(monitor)\n            if not ret:\n                error = True\n        if monitor.storage.method == Storage.LOCAL:\n            ret = Local.import_all(monitor)\n            if not ret:\n                error = True\n\n    if not error:\n        messages.add_message(\n            request, messages.SUCCESS, _('Sync successful!')\n        )\n        return redirect('list_recipe_import')\n    else:\n        messages.add_message(\n            request, messages.ERROR, _('Error synchronizing with Storage')\n        )\n        return redirect('list_recipe_import')\n\n\n@group_required('user')\ndef share_link(request, pk):\n    if request.space.allow_sharing:\n        recipe = get_object_or_404(Recipe, pk=pk, space=request.space)\n        link = ShareLink.objects.create(recipe=recipe, created_by=request.user, space=request.space)\n        return JsonResponse({'pk': pk, 'share': link.uuid,\n                             'link': request.build_absolute_uri(reverse('view_recipe', args=[pk, link.uuid]))})\n    else:\n        return JsonResponse({'error': 'sharing_disabled'}, status=403)\n\n\n@group_required('user')\n@ajax_request\ndef log_cooking(request, recipe_id):\n    recipe = get_object_or_None(Recipe, id=recipe_id)\n    if recipe:\n        log = CookLog.objects.create(created_by=request.user, recipe=recipe, space=request.space)\n        servings = request.GET['s'] if 's' in request.GET else None\n        if servings and re.match(r'^([1-9])+$', servings):\n            log.servings = int(servings)\n\n        rating = request.GET['r'] if 'r' in request.GET else None\n        if rating and re.match(r'^([1-9])+$', rating):\n            log.rating = int(rating)\n        log.save()\n        return {'msg': 'updated successfully'}\n\n    return {'error': 'recipe does not exist'}\n\n\n@group_required('user')\ndef get_plan_ical(request, from_date, to_date):\n    queryset = MealPlan.objects.filter(\n        Q(created_by=request.user) | Q(shared=request.user)\n    ).filter(space=request.user.userpreference.space).distinct().all()\n\n    if from_date is not None:\n        queryset = queryset.filter(date__gte=from_date)\n\n    if to_date is not None:\n        queryset = queryset.filter(date__lte=to_date)\n\n    cal = Calendar()\n\n    for p in queryset:\n        event = Event()\n        event['uid'] = p.id\n        event.add('dtstart', p.date)\n        event.add('dtend', p.date)\n        event['summary'] = f'{p.meal_type.name}: {p.get_label()}'\n        event['description'] = p.note\n        cal.add_component(event)\n\n    response = FileResponse(io.BytesIO(cal.to_ical()))\n    response[\"Content-Disposition\"] = f'attachment; filename=meal_plan_{from_date}-{to_date}.ics'  # noqa: E501\n\n    return response\n\n\n@group_required('user')\ndef recipe_from_source(request):\n    \"\"\"\n    function to retrieve a recipe from a given url or source string\n    :param request: standard request with additional post parameters\n            - url: url to use for importing recipe\n            - data: if no url is given recipe is imported from provided source data\n            - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes\n    :return: JsonResponse containing the parsed json, original html,json and images\n    \"\"\"\n    if request.method == 'GET':\n        return HttpResponse(status=405)\n    request_payload = json.loads(request.body.decode('utf-8'))\n    url = request_payload.get('url', None)\n    data = request_payload.get('data', None)\n    bookmarklet = request_payload.get('bookmarklet', None)\n\n    if bookmarklet := BookmarkletImport.objects.filter(pk=bookmarklet).first():\n        url = bookmarklet.url\n        data = bookmarklet.html\n        bookmarklet.delete()\n\n    # headers to use for request to external sites\n    external_request_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.0.7) Gecko/2009021910 Firefox/3.0.7\"}\n\n    if not url and not data:\n        return JsonResponse({\n            'error': True,\n            'msg': _('Nothing to do.')\n        }, status=400)\n\n    # in manual mode request complete page to return it later\n    if url:\n        try:\n            data = requests.get(url, headers=external_request_headers).content\n        except requests.exceptions.ConnectionError:\n            return JsonResponse({\n                'error': True,\n                'msg': _('Connection Refused.')\n            }, status=400)\n        except requests.exceptions.MissingSchema:\n            return JsonResponse({\n                'error': True,\n                'msg': _('Bad URL Schema.')\n            }, status=400)\n    recipe_json, recipe_tree, recipe_html, recipe_images = get_recipe_from_source(data, url, request)\n    if len(recipe_tree) == 0 and len(recipe_json) == 0:\n        return JsonResponse({\n            'error': True,\n            'msg': _('No usable data could be found.')\n        }, status=400)\n    else:\n        return JsonResponse({\n            'recipe_json': recipe_json,\n            'recipe_tree': recipe_tree,\n            'recipe_html': recipe_html,\n            'recipe_images': list(dict.fromkeys(recipe_images)),\n        })\n\n\n@group_required('admin')\ndef get_backup(request):\n    if not request.user.is_superuser:\n        return HttpResponse('', status=403)\n\n\n@group_required('user')\ndef ingredient_from_string(request):\n    text = request.POST['text']\n\n    ingredient_parser = IngredientParser(request, False)\n    amount, unit, food, note = ingredient_parser.parse(text)\n\n    return JsonResponse(\n        {\n            'amount': amount,\n            'unit': unit,\n            'food': food,\n            'note': note\n        },\n        status=200\n    )\n\n\n@group_required('user')\ndef get_facets(request):\n    key = request.GET.get('hash', None)\n    food = request.GET.get('food', None)\n    keyword = request.GET.get('keyword', None)\n    facets = RecipeFacet(request, hash_key=key)\n\n    if food:\n        results = facets.add_food_children(food)\n    elif keyword:\n        results = facets.add_keyword_children(keyword)\n    else:\n        results = facets.get_facets()\n\n    return JsonResponse(\n        {\n            'facets': results,\n        },\n        status=200\n    )\n", "Django==3.2.13\ncryptography==37.0.1\ndjango-annoying==0.10.6\ndjango-autocomplete-light==3.9.4\ndjango-cleanup==6.0.0\ndjango-crispy-forms==1.14.0\ndjango-filter==21.1\ndjango-tables2==2.4.1\ndjangorestframework==3.13.1\ndrf-writable-nested==0.6.3\nbleach==4.1.0\nbleach-allowlist==1.0.3\ngunicorn==20.1.0\nlxml==4.8.0\nMarkdown==3.3.6\nPillow==9.0.1\npsycopg2-binary==2.9.3\npython-dotenv==0.20.0\nrequests==2.27.1\nsix==1.16.0\nwebdavclient3==3.14.6\nwhitenoise==6.0.0\nicalendar==4.0.9\npyyaml==6.0\nuritemplate==4.1.1\nbeautifulsoup4==4.10.0\nmicrodata==0.8.0\nJinja2==3.1.1\ndjango-webpack-loader==1.4.1\ndjango-js-reverse==0.9.1\ndjango-allauth==0.50.0\nrecipe-scrapers==13.32.1\ndjango-scopes==1.2.0\npytest==7.1.1\npytest-django==4.5.2\ndjango-treebeard==4.5.1\ndjango-cors-headers==3.11.0\ndjango-storages==1.12.3\nboto3==1.21.31\ndjango-prometheus==2.2.0\ndjango-hCaptcha==0.2.0\npython-ldap==3.4.0\ndjango-auth-ldap==4.0.0\npytest-factoryboy==2.1.0\npyppeteer==1.0.2\n"], "fixing_code": ["import base64\nimport gzip\nimport json\nimport re\nfrom gettext import gettext as _\nfrom io import BytesIO\n\nimport requests\nimport validators\nimport yaml\n\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.helper.recipe_html_import import get_recipe_from_source\nfrom cookbook.helper.recipe_url_import import iso_duration_to_minutes\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Keyword, Recipe, Step\n\n\nclass CookBookApp(Integration):\n\n    def import_file_name_filter(self, zip_info_object):\n        return zip_info_object.filename.endswith('.html')\n\n    def get_recipe_from_file(self, file):\n        recipe_html = file.getvalue().decode(\"utf-8\")\n\n        recipe_json, recipe_tree, html_data, images = get_recipe_from_source(recipe_html, 'CookBookApp', self.request)\n\n        recipe = Recipe.objects.create(\n            name=recipe_json['name'].strip(),\n            created_by=self.request.user, internal=True,\n            space=self.request.space)\n\n        try:\n            recipe.servings = re.findall('([0-9])+', recipe_json['recipeYield'])[0]\n        except Exception as e:\n            pass\n\n        try:\n            recipe.working_time = iso_duration_to_minutes(recipe_json['prepTime'])\n            recipe.waiting_time = iso_duration_to_minutes(recipe_json['cookTime'])\n        except Exception:\n            pass\n\n        step = Step.objects.create(instruction=recipe_json['recipeInstructions'], space=self.request.space, )\n\n        if 'nutrition' in recipe_json:\n            step.instruction = step.instruction + '\\n\\n' + recipe_json['nutrition']\n\n        step.save()\n        recipe.steps.add(step)\n\n        ingredient_parser = IngredientParser(self.request, True)\n        for ingredient in recipe_json['recipeIngredient']:\n            f = ingredient_parser.get_food(ingredient['ingredient']['text'])\n            u = ingredient_parser.get_unit(ingredient['unit']['text'])\n            step.ingredients.add(Ingredient.objects.create(\n                food=f, unit=u, amount=ingredient['amount'], note=ingredient['note'],  space=self.request.space,\n            ))\n\n        if len(images) > 0:\n            try:\n                url = images[0]\n                if validators.url(url, public=True):\n                    response = requests.get(url)\n                    self.import_recipe_image(recipe, BytesIO(response.content))\n            except Exception as e:\n                print('failed to import image ', str(e))\n\n        recipe.save()\n        return recipe\n", "import base64\nimport json\nfrom io import BytesIO\n\nfrom gettext import gettext as _\n\nimport requests\nimport validators\nfrom lxml import etree\n\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.helper.recipe_url_import import parse_servings, parse_time, parse_servings_text\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Keyword, Recipe, Step\n\n\nclass Cookmate(Integration):\n\n    def import_file_name_filter(self, zip_info_object):\n        return zip_info_object.filename.endswith('.xml')\n\n    def get_files_from_recipes(self, recipes, el, cookie):\n        raise NotImplementedError('Method not implemented in storage integration')\n\n    def get_recipe_from_file(self, file):\n        recipe_xml = file\n\n        recipe = Recipe.objects.create(\n            name=recipe_xml.find('title').text.strip(),\n            created_by=self.request.user, internal=True, space=self.request.space)\n\n        if recipe_xml.find('preptime') is not None and recipe_xml.find('preptime').text is not None:\n            recipe.working_time = parse_time(recipe_xml.find('preptime').text.strip())\n\n        if recipe_xml.find('cooktime') is not None and recipe_xml.find('cooktime').text is not None:\n            recipe.waiting_time = parse_time(recipe_xml.find('cooktime').text.strip())\n\n        if recipe_xml.find('quantity') is not None and recipe_xml.find('quantity').text is not None:\n            recipe.servings = parse_servings(recipe_xml.find('quantity').text.strip())\n            recipe.servings_text = parse_servings_text(recipe_xml.find('quantity').text.strip())\n\n        if recipe_xml.find('url') is not None and recipe_xml.find('url').text is not None:\n            recipe.source_url = recipe_xml.find('url').text.strip()\n\n        if recipe_xml.find('description') is not None:  # description is a list of <li>'s with text\n            if len(recipe_xml.find('description')) > 0:\n                recipe.description = recipe_xml.find('description')[0].text[:512]\n\n        for step in recipe_xml.find('recipetext').getchildren():\n            step = Step.objects.create(\n                instruction=step.text.strip(), space=self.request.space,\n            )\n            recipe.steps.add(step)\n\n        ingredient_parser = IngredientParser(self.request, True)\n\n        for ingredient in recipe_xml.find('ingredient').getchildren():\n            if ingredient.text.strip() != '':\n                amount, unit, food, note = ingredient_parser.parse(ingredient.text.strip())\n                f = ingredient_parser.get_food(food)\n                u = ingredient_parser.get_unit(unit)\n                recipe.steps.first().ingredients.add(Ingredient.objects.create(\n                    food=f, unit=u, amount=amount, note=note, original_text=ingredient.text.strip(), space=self.request.space,\n                ))\n\n        if recipe_xml.find('imageurl') is not None:\n            try:\n                url = recipe_xml.find('imageurl').text.strip()\n                if validators.url(url, public=True):\n                    response = requests.get(url)\n                self.import_recipe_image(recipe, BytesIO(response.content))\n            except Exception as e:\n                print('failed to import image ', str(e))\n\n        recipe.save()\n\n        return recipe\n\n    def get_file_from_recipe(self, recipe):\n        raise NotImplementedError('Method not implemented in storage integration')\n", "import imghdr\nimport json\nimport re\nfrom io import BytesIO\nfrom zipfile import ZipFile\n\nimport requests\nimport validators\n\nfrom django.utils.translation import gettext as _\nfrom cookbook.helper.image_processing import get_filetype\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Keyword, Recipe, Step\n\n\nclass RecetteTek(Integration):\n\n    def import_file_name_filter(self, zip_info_object):\n        print(\"testing\", zip_info_object.filename)\n        return re.match(r'^recipes_0.json$', zip_info_object.filename) or re.match(r'^recipes.json$', zip_info_object.filename)\n\n    def split_recipe_file(self, file):\n\n        recipe_json = json.loads(file)\n\n        recipe_list = [r for r in recipe_json]\n\n        return recipe_list\n\n    def get_recipe_from_file(self, file):\n\n        # Create initial recipe with just a title and a description\n        recipe = Recipe.objects.create(name=file['title'], created_by=self.request.user, internal=True, space=self.request.space, )\n\n        # set the description as an empty string for later use for the source URL, in case there is no description text.\n        recipe.description = ''\n\n        try:\n            if file['description'] != '':\n                recipe.description = file['description'].strip()\n        except Exception as e:\n            print(recipe.name, ': failed to parse recipe description ', str(e))\n\n        instructions = file['instructions']\n        if not instructions:\n            instructions = ''\n\n        step = Step.objects.create(instruction=instructions, space=self.request.space,)\n\n        # Append the original import url to the step (if it exists)\n        try:\n            if file['url'] != '':\n                step.instruction += '\\n\\n' + _('Imported from') + ': ' + file['url']\n                step.save()\n        except Exception as e:\n            print(recipe.name, ': failed to import source url ', str(e))\n\n        try:\n            # Process the ingredients. Assumes 1 ingredient per line.\n            ingredient_parser = IngredientParser(self.request, True)\n            for ingredient in file['ingredients'].split('\\n'):\n                if len(ingredient.strip()) > 0:\n                    amount, unit, food, note = ingredient_parser.parse(food)\n                    f = ingredient_parser.get_food(ingredient)\n                    u = ingredient_parser.get_unit(unit)\n                    step.ingredients.add(Ingredient.objects.create(\n                        food=f, unit=u, amount=amount, note=note, original_text=ingredient, space=self.request.space,\n                    ))\n        except Exception as e:\n            print(recipe.name, ': failed to parse recipe ingredients ', str(e))\n        recipe.steps.add(step)\n\n        # Attempt to import prep/cooking times\n        # quick hack, this assumes only one number in the quantity field.\n        try:\n            if file['quantity'] != '':\n                for item in file['quantity'].split(' '):\n                    if item.isdigit():\n                        recipe.servings = int(item)\n                        break\n        except Exception as e:\n            print(recipe.name, ': failed to parse quantity ', str(e))\n\n        try:\n            if file['totalTime'] != '':\n                recipe.waiting_time = int(file['totalTime'])\n        except Exception as e:\n            print(recipe.name, ': failed to parse total times ', str(e))\n\n        try:\n            if file['preparationTime'] != '':\n                recipe.working_time = int(file['preparationTime'])\n        except Exception as e:\n            print(recipe.name, ': failed to parse prep time ', str(e))\n\n        try:\n            if file['cookingTime'] != '':\n                recipe.waiting_time = int(file['cookingTime'])\n        except Exception as e:\n            print(recipe.name, ': failed to parse cooking time ', str(e))\n\n        recipe.save()\n\n        # Import the recipe keywords\n        try:\n            if file['keywords'] != '':\n                for keyword in file['keywords'].split(';'):\n                    k, created = Keyword.objects.get_or_create(name=keyword.strip(), space=self.request.space)\n                    recipe.keywords.add(k)\n            recipe.save()\n        except Exception as e:\n            print(recipe.name, ': failed to parse keywords ', str(e))\n\n        # TODO: Parse Nutritional Information\n\n        # Import the original image from the zip file, if we cannot do that, attempt to download it again.\n        try:\n            if file['pictures'][0] != '':\n                image_file_name = file['pictures'][0].split('/')[-1]\n                for f in self.files:\n                    if '.rtk' in f['name']:\n                        import_zip = ZipFile(f['file'])\n                        self.import_recipe_image(recipe, BytesIO(import_zip.read(image_file_name)), filetype=get_filetype(image_file_name))\n            else:\n                if file['originalPicture'] != '':\n                    url = file['originalPicture']\n                    if validators.url(url, public=True):\n                        response = requests.get(url)\n                        if imghdr.what(BytesIO(response.content)) is not None:\n                            self.import_recipe_image(recipe, BytesIO(response.content), filetype=get_filetype(file['originalPicture']))\n                        else:\n                            raise Exception(\"Original image failed to download.\")\n        except Exception as e:\n            print(recipe.name, ': failed to import image ', str(e))\n\n        return recipe\n\n    def get_file_from_recipe(self, recipe):\n        raise NotImplementedError('Method not implemented in storage integration')\n", "import json\nfrom io import BytesIO\n\nimport requests\nimport validators\n\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.integration.integration import Integration\nfrom cookbook.models import Ingredient, Recipe, Step\n\n\nclass RecipeSage(Integration):\n\n    def get_recipe_from_file(self, file):\n\n        recipe = Recipe.objects.create(\n            name=file['name'].strip(),\n            created_by=self.request.user, internal=True,\n            space=self.request.space)\n\n        try:\n            if file['recipeYield'] != '':\n                recipe.servings = int(file['recipeYield'])\n\n            if file['totalTime'] != '':\n                recipe.waiting_time = int(file['totalTime']) - int(file['timePrep'])\n\n            if file['prepTime'] != '':\n                recipe.working_time = int(file['timePrep'])\n\n            recipe.save()\n        except Exception as e:\n            print('failed to parse yield or time ', str(e))\n\n        ingredient_parser = IngredientParser(self.request, True)\n        ingredients_added = False\n        for s in file['recipeInstructions']:\n            step = Step.objects.create(\n                instruction=s['text'], space=self.request.space,\n            )\n            if not ingredients_added:\n                ingredients_added = True\n\n                for ingredient in file['recipeIngredient']:\n                    amount, unit, food, note = ingredient_parser.parse(ingredient)\n                    f = ingredient_parser.get_food(food)\n                    u = ingredient_parser.get_unit(unit)\n                    step.ingredients.add(Ingredient.objects.create(\n                        food=f, unit=u, amount=amount, note=note, original_text=ingredient, space=self.request.space,\n                    ))\n            recipe.steps.add(step)\n\n        if len(file['image']) > 0:\n            try:\n                url = file['image'][0]\n                if validators.url(url, public=True):\n                    response = requests.get(url)\n                    self.import_recipe_image(recipe, BytesIO(response.content))\n            except Exception as e:\n                print('failed to import image ', str(e))\n\n        return recipe\n\n    def get_file_from_recipe(self, recipe):\n        data = {\n            '@context': 'http://schema.org',\n            '@type': 'Recipe',\n            'creditText': '',\n            'isBasedOn': '',\n            'name': recipe.name,\n            'description': recipe.description,\n            'prepTime': str(recipe.working_time),\n            'totalTime': str(recipe.waiting_time + recipe.working_time),\n            'recipeYield': str(recipe.servings),\n            'image': [],\n            'recipeCategory': [],\n            'comment': [],\n            'recipeIngredient': [],\n            'recipeInstructions': [],\n        }\n\n        for s in recipe.steps.all():\n            data['recipeInstructions'].append({\n                '@type': 'HowToStep',\n                'text': s.instruction\n            })\n\n            for i in s.ingredients.all():\n                data['recipeIngredient'].append(f'{float(i.amount)} {i.unit} {i.food}')\n\n        return data\n\n    def get_files_from_recipes(self, recipes, el, cookie):\n        json_list = []\n        for r in recipes:\n            json_list.append(self.get_file_from_recipe(r))\n\n            el.exported_recipes += 1\n            el.msg += self.get_recipe_processed_msg(r)\n            el.save()\n\n        return [[self.get_export_file_name('json'), json.dumps(json_list)]]\n\n    def split_recipe_file(self, file):\n        return json.loads(file.read().decode(\"utf-8\"))\n", "import io\nimport json\nimport os\nfrom datetime import datetime\n\nimport requests\nimport validators\n\nfrom cookbook.models import Recipe, RecipeImport, SyncLog\nfrom cookbook.provider.provider import Provider\n\n\nclass Dropbox(Provider):\n\n    @staticmethod\n    def import_all(monitor):\n        url = \"https://api.dropboxapi.com/2/files/list_folder\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + monitor.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": monitor.path\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n        try:\n            recipes = r.json()\n        except ValueError:\n            log_entry = SyncLog(status='ERROR', msg=str(r), sync=monitor)\n            log_entry.save()\n            return r\n\n        import_count = 0\n        # TODO check if has_more is set and import that as well\n        for recipe in recipes['entries']:\n            path = recipe['path_lower']\n            if not Recipe.objects.filter(file_path__iexact=path, space=monitor.space).exists() and not RecipeImport.objects.filter(file_path=path, space=monitor.space).exists():\n                name = os.path.splitext(recipe['name'])[0]\n                new_recipe = RecipeImport(\n                    name=name,\n                    file_path=path,\n                    storage=monitor.storage,\n                    file_uid=recipe['id'],\n                    space=monitor.space,\n                )\n                new_recipe.save()\n                import_count += 1\n\n        log_entry = SyncLog(\n            status='SUCCESS',\n            msg='Imported ' + str(import_count) + ' recipes',\n            sync=monitor,\n        )\n        log_entry.save()\n\n        monitor.last_checked = datetime.now()\n        monitor.save()\n\n        return True\n\n    @staticmethod\n    def create_share_link(recipe):\n        url = \"https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings\"  # noqa: E501\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": recipe.file_uid\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n\n        return r.json()\n\n    @staticmethod\n    def get_share_link(recipe):\n        url = \"https://api.dropboxapi.com/2/sharing/list_shared_links\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": recipe.file_path,\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n        p = r.json()\n\n        for link in p['links']:\n            return link['url']\n\n        response = Dropbox.create_share_link(recipe)\n        return response['url']\n\n    @staticmethod\n    def get_file(recipe):\n        if not recipe.link:\n            recipe.link = Dropbox.get_share_link(recipe)\n            recipe.save()\n\n        url = recipe.link.replace('www.dropbox.', 'dl.dropboxusercontent.')\n        if validators.url(url, public=True):\n            response = requests.get(url)\n\n            return io.BytesIO(response.content)\n\n    @staticmethod\n    def rename_file(recipe, new_name):\n        url = \"https://api.dropboxapi.com/2/files/move_v2\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"from_path\": recipe.file_path,\n            \"to_path\": \"%s/%s%s\" % (\n                os.path.dirname(recipe.file_path),\n                new_name,\n                os.path.splitext(recipe.file_path)[1]\n            )\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n\n        return r.json()\n\n    @staticmethod\n    def delete_file(recipe):\n        url = \"https://api.dropboxapi.com/2/files/delete_v2\"\n\n        headers = {\n            \"Authorization\": \"Bearer \" + recipe.storage.token,\n            \"Content-Type\": \"application/json\"\n        }\n\n        data = {\n            \"path\": recipe.file_path\n        }\n\n        r = requests.post(url, headers=headers, data=json.dumps(data))\n\n        return r.json()\n", "import io\nimport os\nimport tempfile\nfrom datetime import datetime\n\nimport requests\nimport validators\nimport webdav3.client as wc\nfrom cookbook.models import Recipe, RecipeImport, SyncLog\nfrom cookbook.provider.provider import Provider\nfrom requests.auth import HTTPBasicAuth\n\nfrom recipes.settings import DEBUG\n\n\nclass Nextcloud(Provider):\n\n    @staticmethod\n    def get_client(storage):\n        options = {\n            'webdav_hostname': storage.url,\n            'webdav_login': storage.username,\n            'webdav_password': storage.password,\n            'webdav_root': '/remote.php/dav/files/' + storage.username\n        }\n        if storage.path != '':\n            options['webdav_root'] = storage.path\n        return wc.Client(options)\n\n    @staticmethod\n    def import_all(monitor):\n        client = Nextcloud.get_client(monitor.storage)\n\n        if DEBUG:\n            print(f'TANDOOR_PROVIDER_DEBUG checking path  {monitor.path} with client {client}')\n\n        files = client.list(monitor.path)\n\n        if DEBUG:\n            print(f'TANDOOR_PROVIDER_DEBUG file list  {files}')\n\n        import_count = 0\n        for file in files:\n            if DEBUG:\n                print(f'TANDOOR_PROVIDER_DEBUG importing file {file}')\n            path = monitor.path + '/' + file\n            if not Recipe.objects.filter(file_path__iexact=path, space=monitor.space).exists() and not RecipeImport.objects.filter(file_path=path, space=monitor.space).exists():\n                name = os.path.splitext(file)[0]\n                new_recipe = RecipeImport(\n                    name=name,\n                    file_path=path,\n                    storage=monitor.storage,\n                    space=monitor.space,\n                )\n                new_recipe.save()\n                import_count += 1\n\n        log_entry = SyncLog(\n            status='SUCCESS',\n            msg='Imported ' + str(import_count) + ' recipes',\n            sync=monitor,\n        )\n        log_entry.save()\n\n        monitor.last_checked = datetime.now()\n        monitor.save()\n\n        return True\n\n    @staticmethod\n    def create_share_link(recipe):\n        url = recipe.storage.url + '/ocs/v2.php/apps/files_sharing/api/v1/shares?format=json'  # noqa: E501\n\n        headers = {\n            \"OCS-APIRequest\": \"true\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n\n        data = {'path': recipe.file_path, 'shareType': 3}\n\n        r = requests.post(url, headers=headers, auth=HTTPBasicAuth(recipe.storage.username, recipe.storage.password), data=data)\n\n        response_json = r.json()\n\n        return response_json['ocs']['data']['url']\n\n    @staticmethod\n    def get_share_link(recipe):\n        url = recipe.storage.url + '/ocs/v2.php/apps/files_sharing/api/v1/shares?format=json&path=' + recipe.file_path  # noqa: E501\n\n        headers = {\n            \"OCS-APIRequest\": \"true\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        if validators.url(url, public=True):\n            r = requests.get(\n                url,\n                headers=headers,\n                auth=HTTPBasicAuth(\n                    recipe.storage.username, recipe.storage.password\n                )\n            )\n\n            response_json = r.json()\n            for element in response_json['ocs']['data']:\n                if element['share_type'] == '3':\n                    return element['url']\n\n            return Nextcloud.create_share_link(recipe)\n\n    @staticmethod\n    def get_file(recipe):\n        client = Nextcloud.get_client(recipe.storage)\n\n        tmp_file_path = tempfile.gettempdir() + '/' + recipe.name + '.pdf'\n\n        client.download_file(\n            remote_path=recipe.file_path,\n            local_path=tmp_file_path\n        )\n\n        file = io.BytesIO(open(tmp_file_path, 'rb').read())\n        os.remove(tmp_file_path)\n\n        return file\n\n    @staticmethod\n    def rename_file(recipe, new_name):\n        client = Nextcloud.get_client(recipe.storage)\n\n        client.move(\n            recipe.file_path,\n            \"%s/%s%s\" % (\n                os.path.dirname(recipe.file_path),\n                new_name,\n                os.path.splitext(recipe.file_path)[1]\n            )\n        )\n\n        return True\n\n    @staticmethod\n    def delete_file(recipe):\n        client = Nextcloud.get_client(recipe.storage)\n\n        client.clean(recipe.file_path)\n\n        return True\n", "import io\nimport json\nimport mimetypes\nimport re\nimport uuid\nfrom collections import OrderedDict\n\nimport requests\nimport validators\nfrom PIL import UnidentifiedImageError\nfrom annoying.decorators import ajax_request\nfrom annoying.functions import get_object_or_None\nfrom django.contrib import messages\nfrom django.contrib.auth.models import User\nfrom django.contrib.postgres.search import TrigramSimilarity\nfrom django.core.exceptions import FieldError, ValidationError\nfrom django.core.files import File\nfrom django.db.models import (Case, Count, Exists, OuterRef, ProtectedError, Q,\n                              Subquery, Value, When)\nfrom django.db.models.fields.related import ForeignObjectRel\nfrom django.db.models.functions import Coalesce, Lower\nfrom django.http import FileResponse, HttpResponse, JsonResponse\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\nfrom django_scopes import scopes_disabled\nfrom icalendar import Calendar, Event\nfrom requests.exceptions import MissingSchema\nfrom rest_framework import decorators, status, viewsets\nfrom rest_framework.exceptions import APIException, PermissionDenied\nfrom rest_framework.pagination import PageNumberPagination\nfrom rest_framework.parsers import MultiPartParser\nfrom rest_framework.renderers import JSONRenderer, TemplateHTMLRenderer\nfrom rest_framework.response import Response\nfrom rest_framework.viewsets import ViewSetMixin\nfrom treebeard.exceptions import InvalidMoveToDescendant, InvalidPosition, PathOverflow\nfrom validators import ValidationFailure\n\nfrom cookbook.helper.HelperFunctions import str2bool\nfrom cookbook.helper.image_processing import handle_image\nfrom cookbook.helper.ingredient_parser import IngredientParser\nfrom cookbook.helper.permission_helper import (CustomIsAdmin, CustomIsGuest, CustomIsOwner,\n                                               CustomIsShare, CustomIsShared, CustomIsUser,\n                                               group_required)\nfrom cookbook.helper.recipe_html_import import get_recipe_from_source\nfrom cookbook.helper.recipe_search import RecipeFacet, RecipeSearch, old_search\nfrom cookbook.helper.shopping_helper import RecipeShoppingEditor, shopping_helper\nfrom cookbook.models import (Automation, BookmarkletImport, CookLog, CustomFilter, ExportLog, Food,\n                             FoodInheritField, ImportLog, Ingredient, Keyword, MealPlan, MealType,\n                             Recipe, RecipeBook, RecipeBookEntry, ShareLink, ShoppingList,\n                             ShoppingListEntry, ShoppingListRecipe, Step, Storage, Supermarket,\n                             SupermarketCategory, SupermarketCategoryRelation, Sync, SyncLog, Unit,\n                             UserFile, UserPreference, ViewLog)\nfrom cookbook.provider.dropbox import Dropbox\nfrom cookbook.provider.local import Local\nfrom cookbook.provider.nextcloud import Nextcloud\nfrom cookbook.schemas import FilterSchema, QueryParam, QueryParamAutoSchema, TreeSchema\nfrom cookbook.serializer import (AutomationSerializer, BookmarkletImportSerializer,\n                                 CookLogSerializer, CustomFilterSerializer, ExportLogSerializer,\n                                 FoodInheritFieldSerializer, FoodSerializer,\n                                 FoodShoppingUpdateSerializer, ImportLogSerializer,\n                                 IngredientSerializer, KeywordSerializer, MealPlanSerializer,\n                                 MealTypeSerializer, RecipeBookEntrySerializer,\n                                 RecipeBookSerializer, RecipeImageSerializer,\n                                 RecipeOverviewSerializer, RecipeSerializer,\n                                 RecipeShoppingUpdateSerializer, RecipeSimpleSerializer,\n                                 ShoppingListAutoSyncSerializer, ShoppingListEntrySerializer,\n                                 ShoppingListRecipeSerializer, ShoppingListSerializer,\n                                 StepSerializer, StorageSerializer,\n                                 SupermarketCategoryRelationSerializer,\n                                 SupermarketCategorySerializer, SupermarketSerializer,\n                                 SyncLogSerializer, SyncSerializer, UnitSerializer,\n                                 UserFileSerializer, UserNameSerializer, UserPreferenceSerializer,\n                                 ViewLogSerializer, IngredientSimpleSerializer, BookmarkletImportListSerializer)\nfrom recipes import settings\n\n\nclass StandardFilterMixin(ViewSetMixin):\n    def get_queryset(self):\n        queryset = self.queryset\n        query = self.request.query_params.get('query', None)\n        if query is not None:\n            queryset = queryset.filter(name__icontains=query)\n\n        updated_at = self.request.query_params.get('updated_at', None)\n        if updated_at is not None:\n            try:\n                queryset = queryset.filter(updated_at__gte=updated_at)\n            except FieldError:\n                pass\n            except ValidationError:\n                raise APIException(_('Parameter updated_at incorrectly formatted'))\n\n        limit = self.request.query_params.get('limit', None)\n        random = self.request.query_params.get('random', False)\n        if limit is not None:\n            if random:\n                queryset = queryset.order_by(\"?\")[:int(limit)]\n            else:\n                queryset = queryset[:int(limit)]\n        return queryset\n\n\nclass DefaultPagination(PageNumberPagination):\n    page_size = 50\n    page_size_query_param = 'page_size'\n    max_page_size = 200\n\n\nclass ExtendedRecipeMixin():\n    '''\n    ExtendedRecipe annotates a queryset with recipe_image and recipe_count values\n    '''\n\n    @classmethod\n    def annotate_recipe(self, queryset=None, request=None, serializer=None, tree=False):\n        extended = str2bool(request.query_params.get('extended', None))\n        if extended:\n            recipe_filter = serializer.recipe_filter\n            images = serializer.images\n            space = request.space\n\n            # add a recipe count annotation to the query\n            #  explanation on construction https://stackoverflow.com/a/43771738/15762829\n            recipe_count = Recipe.objects.filter(**{recipe_filter: OuterRef('id')}, space=space).values(\n                recipe_filter).annotate(count=Count('pk')).values('count')\n            queryset = queryset.annotate(recipe_count=Coalesce(Subquery(recipe_count), 0))\n\n            # add a recipe image annotation to the query\n            image_subquery = Recipe.objects.filter(**{recipe_filter: OuterRef('id')}, space=space).exclude(\n                image__isnull=True).exclude(image__exact='').order_by(\"?\").values('image')[:1]\n            if tree:\n                image_children_subquery = Recipe.objects.filter(\n                    **{f\"{recipe_filter}__path__startswith\": OuterRef('path')},\n                    space=space).exclude(image__isnull=True).exclude(image__exact='').order_by(\"?\").values('image')[:1]\n            else:\n                image_children_subquery = None\n            if images:\n                queryset = queryset.annotate(recipe_image=Coalesce(*images, image_subquery, image_children_subquery))\n            else:\n                queryset = queryset.annotate(recipe_image=Coalesce(image_subquery, image_children_subquery))\n        return queryset\n\n\nclass FuzzyFilterMixin(ViewSetMixin, ExtendedRecipeMixin):\n    schema = FilterSchema()\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).order_by(Lower('name').asc())\n        query = self.request.query_params.get('query', None)\n        fuzzy = self.request.user.searchpreference.lookup or any([self.model.__name__.lower() in x for x in\n                                                                  self.request.user.searchpreference.trigram.values_list(\n                                                                      'field', flat=True)])\n\n        if query is not None and query not in [\"''\", '']:\n            if fuzzy:\n                if any([self.model.__name__.lower() in x for x in\n                        self.request.user.searchpreference.unaccent.values_list('field', flat=True)]):\n                    self.queryset = self.queryset.annotate(trigram=TrigramSimilarity('name__unaccent', query))\n                else:\n                    self.queryset = self.queryset.annotate(trigram=TrigramSimilarity('name', query))\n                self.queryset = self.queryset.order_by('-trigram')\n            else:\n                # TODO have this check unaccent search settings or other search preferences?\n                filter = Q(name__icontains=query)\n                if any([self.model.__name__.lower() in x for x in\n                        self.request.user.searchpreference.unaccent.values_list('field', flat=True)]):\n                    filter |= Q(name__unaccent__icontains=query)\n\n                self.queryset = (\n                    self.queryset\n                        .annotate(starts=Case(When(name__istartswith=query, then=(Value(100))),\n                                              default=Value(0)))  # put exact matches at the top of the result set\n                        .filter(filter).order_by('-starts', Lower('name').asc())\n                )\n\n        updated_at = self.request.query_params.get('updated_at', None)\n        if updated_at is not None:\n            try:\n                self.queryset = self.queryset.filter(updated_at__gte=updated_at)\n            except FieldError:\n                pass\n            except ValidationError:\n                raise APIException(_('Parameter updated_at incorrectly formatted'))\n\n        limit = self.request.query_params.get('limit', None)\n        random = self.request.query_params.get('random', False)\n        if random:\n            self.queryset = self.queryset.order_by(\"?\")\n        if limit is not None:\n            self.queryset = self.queryset[:int(limit)]\n        return self.annotate_recipe(queryset=self.queryset, request=self.request, serializer=self.serializer_class)\n\n\nclass MergeMixin(ViewSetMixin):\n    @decorators.action(detail=True, url_path='merge/(?P<target>[^/.]+)', methods=['PUT'], )\n    @decorators.renderer_classes((TemplateHTMLRenderer, JSONRenderer))\n    def merge(self, request, pk, target):\n        self.description = f\"Merge {self.basename} onto target {self.basename} with ID of [int].\"\n\n        try:\n            source = self.model.objects.get(pk=pk, space=self.request.space)\n        except (self.model.DoesNotExist):\n            content = {'error': True, 'msg': _(f'No {self.basename} with id {pk} exists')}\n            return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n        if int(target) == source.id:\n            content = {'error': True, 'msg': _('Cannot merge with the same object!')}\n            return Response(content, status=status.HTTP_403_FORBIDDEN)\n\n        else:\n            try:\n                target = self.model.objects.get(pk=target, space=self.request.space)\n            except (self.model.DoesNotExist):\n                content = {'error': True, 'msg': _(f'No {self.basename} with id {target} exists')}\n                return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n            try:\n                if target in source.get_descendants_and_self():\n                    content = {'error': True, 'msg': _('Cannot merge with child object!')}\n                    return Response(content, status=status.HTTP_403_FORBIDDEN)\n                isTree = True\n            except AttributeError:\n                # AttributeError probably means its not a tree, so can safely ignore\n                isTree = False\n\n            try:\n                for link in [field for field in source._meta.get_fields() if issubclass(type(field), ForeignObjectRel)]:\n                    linkManager = getattr(source, link.get_accessor_name())\n                    related = linkManager.all()\n                    # link to foreign relationship could be OneToMany or ManyToMany\n                    if link.one_to_many:\n                        for r in related:\n                            setattr(r, link.field.name, target)\n                            r.save()\n                    elif link.many_to_many:\n                        for r in related:\n                            getattr(r, link.field.name).add(target)\n                            getattr(r, link.field.name).remove(source)\n                            r.save()\n                    else:\n                        # a new scenario exists and needs to be handled\n                        raise NotImplementedError\n                if isTree:\n                    if self.model.node_order_by:\n                        node_location = 'sorted-child'\n                    else:\n                        node_location = 'last-child'\n\n                    children = source.get_children().exclude(id=target.id)\n                    for c in children:\n                        c.move(target, node_location)\n                content = {'msg': _(f'{source.name} was merged successfully with {target.name}')}\n                source.delete()\n                return Response(content, status=status.HTTP_200_OK)\n            except Exception:\n                content = {'error': True,\n                           'msg': _(f'An error occurred attempting to merge {source.name} with {target.name}')}\n                return Response(content, status=status.HTTP_400_BAD_REQUEST)\n\n\nclass TreeMixin(MergeMixin, FuzzyFilterMixin, ExtendedRecipeMixin):\n    schema = TreeSchema()\n    model = None\n\n    def get_queryset(self):\n        root = self.request.query_params.get('root', None)\n        tree = self.request.query_params.get('tree', None)\n\n        if root:\n            if root.isnumeric():\n                try:\n                    root = int(root)\n                except ValueError:\n                    self.queryset = self.model.objects.none()\n\n                if root == 0:\n                    self.queryset = self.model.get_root_nodes()\n                else:\n                    self.queryset = self.model.objects.get(id=root).get_children()\n        elif tree:\n            if tree.isnumeric():\n                try:\n                    self.queryset = self.model.objects.get(id=int(tree)).get_descendants_and_self()\n                except self.model.DoesNotExist:\n                    self.queryset = self.model.objects.none()\n        else:\n            return self.annotate_recipe(queryset=super().get_queryset(), request=self.request,\n                                        serializer=self.serializer_class, tree=True)\n        self.queryset = self.queryset.filter(space=self.request.space).order_by(Lower('name').asc())\n\n        return self.annotate_recipe(queryset=self.queryset, request=self.request, serializer=self.serializer_class,\n                                    tree=True)\n\n    @decorators.action(detail=True, url_path='move/(?P<parent>[^/.]+)', methods=['PUT'], )\n    @decorators.renderer_classes((TemplateHTMLRenderer, JSONRenderer))\n    def move(self, request, pk, parent):\n        self.description = f\"Move {self.basename} to be a child of {self.basename} with ID of [int].  Use ID: 0 to move {self.basename} to the root.\"\n        if self.model.node_order_by:\n            node_location = 'sorted'\n        else:\n            node_location = 'last'\n\n        try:\n            child = self.model.objects.get(pk=pk, space=self.request.space)\n        except (self.model.DoesNotExist):\n            content = {'error': True, 'msg': _(f'No {self.basename} with id {pk} exists')}\n            return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n        parent = int(parent)\n        # parent 0 is root of the tree\n        if parent == 0:\n            try:\n                with scopes_disabled():\n                    child.move(self.model.get_first_root_node(), f'{node_location}-sibling')\n                content = {'msg': _(f'{child.name} was moved successfully to the root.')}\n                return Response(content, status=status.HTTP_200_OK)\n            except (PathOverflow, InvalidMoveToDescendant, InvalidPosition):\n                content = {'error': True, 'msg': _('An error occurred attempting to move ') + child.name}\n                return Response(content, status=status.HTTP_400_BAD_REQUEST)\n        elif parent == child.id:\n            content = {'error': True, 'msg': _('Cannot move an object to itself!')}\n            return Response(content, status=status.HTTP_403_FORBIDDEN)\n\n        try:\n            parent = self.model.objects.get(pk=parent, space=self.request.space)\n        except (self.model.DoesNotExist):\n            content = {'error': True, 'msg': _(f'No {self.basename} with id {parent} exists')}\n            return Response(content, status=status.HTTP_404_NOT_FOUND)\n\n        try:\n            with scopes_disabled():\n                child.move(parent, f'{node_location}-child')\n            content = {'msg': _(f'{child.name} was moved successfully to parent {parent.name}')}\n            return Response(content, status=status.HTTP_200_OK)\n        except (PathOverflow, InvalidMoveToDescendant, InvalidPosition) as e:\n            content = {'error': True, 'msg': _('An error occurred attempting to move ') + child.name}\n            return Response(content, status=status.HTTP_400_BAD_REQUEST)\n\n\nclass UserNameViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    list:\n    optional parameters\n\n    - **filter_list**: array of user id's to get names for\n    \"\"\"\n    queryset = User.objects\n    serializer_class = UserNameSerializer\n    permission_classes = [CustomIsGuest]\n    http_method_names = ['get']\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(userpreference__space=self.request.space)\n        try:\n            filter_list = self.request.query_params.get('filter_list', None)\n            if filter_list is not None:\n                queryset = queryset.filter(pk__in=json.loads(filter_list))\n        except ValueError:\n            raise APIException('Parameter filter_list incorrectly formatted')\n\n        return queryset\n\n\nclass UserPreferenceViewSet(viewsets.ModelViewSet):\n    queryset = UserPreference.objects\n    serializer_class = UserPreferenceSerializer\n    permission_classes = [CustomIsOwner, ]\n\n    def get_queryset(self):\n        return self.queryset.filter(user=self.request.user)\n\n\nclass StorageViewSet(viewsets.ModelViewSet):\n    # TODO handle delete protect error and adjust test\n    queryset = Storage.objects\n    serializer_class = StorageSerializer\n    permission_classes = [CustomIsAdmin, ]\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass SyncViewSet(viewsets.ModelViewSet):\n    queryset = Sync.objects\n    serializer_class = SyncSerializer\n    permission_classes = [CustomIsAdmin, ]\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass SyncLogViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = SyncLog.objects\n    serializer_class = SyncLogSerializer\n    permission_classes = [CustomIsAdmin, ]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(sync__space=self.request.space)\n\n\nclass SupermarketViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = Supermarket.objects\n    serializer_class = SupermarketSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space)\n        return super().get_queryset()\n\n\nclass SupermarketCategoryViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = SupermarketCategory.objects\n    serializer_class = SupermarketCategorySerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).order_by(Lower('name').asc())\n        return super().get_queryset()\n\n\nclass SupermarketCategoryRelationViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = SupermarketCategoryRelation.objects\n    serializer_class = SupermarketCategoryRelationSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(supermarket__space=self.request.space).order_by('order')\n        return super().get_queryset()\n\n\nclass KeywordViewSet(viewsets.ModelViewSet, TreeMixin):\n    queryset = Keyword.objects\n    model = Keyword\n    serializer_class = KeywordSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n\nclass UnitViewSet(viewsets.ModelViewSet, MergeMixin, FuzzyFilterMixin):\n    queryset = Unit.objects\n    model = Unit\n    serializer_class = UnitSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n\nclass FoodInheritFieldViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = FoodInheritField.objects\n    serializer_class = FoodInheritFieldSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        # exclude fields not yet implemented\n        self.queryset = Food.inheritable_fields\n        return super().get_queryset()\n\n\nclass FoodViewSet(viewsets.ModelViewSet, TreeMixin):\n    queryset = Food.objects\n    model = Food\n    serializer_class = FoodSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        self.request._shared_users = [x.id for x in list(self.request.user.get_shopping_share())] + [\n            self.request.user.id]\n\n        self.queryset = super().get_queryset()\n        shopping_status = ShoppingListEntry.objects.filter(space=self.request.space, food=OuterRef('id'),\n                                                           checked=False).values('id')\n        # onhand_status = self.queryset.annotate(onhand_status=Exists(onhand_users_set__in=[shared_users]))\n        return self.queryset.annotate(shopping_status=Exists(shopping_status)).prefetch_related('onhand_users',\n                                                                                                'inherit_fields').select_related(\n            'recipe', 'supermarket_category')\n\n    @decorators.action(detail=True, methods=['PUT'], serializer_class=FoodShoppingUpdateSerializer, )\n    # TODO DRF only allows one action in a decorator action without overriding get_operation_id_base() this should be PUT and DELETE probably\n    def shopping(self, request, pk):\n        if self.request.space.demo:\n            raise PermissionDenied(detail='Not available in demo', code=None)\n        obj = self.get_object()\n        shared_users = list(self.request.user.get_shopping_share())\n        shared_users.append(request.user)\n        if request.data.get('_delete', False) == 'true':\n            ShoppingListEntry.objects.filter(food=obj, checked=False, space=request.space,\n                                             created_by__in=shared_users).delete()\n            content = {'msg': _(f'{obj.name} was removed from the shopping list.')}\n            return Response(content, status=status.HTTP_204_NO_CONTENT)\n\n        amount = request.data.get('amount', 1)\n        unit = request.data.get('unit', None)\n        content = {'msg': _(f'{obj.name} was added to the shopping list.')}\n\n        ShoppingListEntry.objects.create(food=obj, amount=amount, unit=unit, space=request.space,\n                                         created_by=request.user)\n        return Response(content, status=status.HTTP_204_NO_CONTENT)\n\n    def destroy(self, *args, **kwargs):\n        try:\n            return (super().destroy(self, *args, **kwargs))\n        except ProtectedError as e:\n            content = {'error': True, 'msg': e.args[0]}\n            return Response(content, status=status.HTTP_403_FORBIDDEN)\n\n\nclass RecipeBookViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = RecipeBook.objects\n    serializer_class = RecipeBookSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(Q(created_by=self.request.user) | Q(shared=self.request.user)).filter(\n            space=self.request.space).distinct()\n        return super().get_queryset()\n\n\nclass RecipeBookEntryViewSet(viewsets.ModelViewSet, viewsets.GenericViewSet):\n    \"\"\"\n        list:\n        optional parameters\n\n        - **recipe**: id of recipe - only return books for that recipe\n        - **book**: id of book - only return recipes in that book\n\n    \"\"\"\n    queryset = RecipeBookEntry.objects\n    serializer_class = RecipeBookEntrySerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(\n            Q(book__created_by=self.request.user) | Q(book__shared=self.request.user)).filter(\n            book__space=self.request.space).distinct()\n\n        recipe_id = self.request.query_params.get('recipe', None)\n        if recipe_id is not None:\n            queryset = queryset.filter(recipe__pk=recipe_id)\n\n        book_id = self.request.query_params.get('book', None)\n        if book_id is not None:\n            queryset = queryset.filter(book__pk=book_id)\n        return queryset\n\n\nclass MealPlanViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    list:\n    optional parameters\n\n    - **from_date**: filter from (inclusive) a certain date onward\n    - **to_date**: filter upward to (inclusive) certain date\n\n    \"\"\"\n    queryset = MealPlan.objects\n    serializer_class = MealPlanSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(\n            Q(created_by=self.request.user)\n            | Q(shared=self.request.user)\n        ).filter(space=self.request.space).distinct().all()\n\n        from_date = self.request.query_params.get('from_date', None)\n        if from_date is not None:\n            queryset = queryset.filter(date__gte=from_date)\n\n        to_date = self.request.query_params.get('to_date', None)\n        if to_date is not None:\n            queryset = queryset.filter(date__lte=to_date)\n        return queryset\n\n\nclass MealTypeViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    returns list of meal types created by the\n    requesting user ordered by the order field.\n    \"\"\"\n    queryset = MealType.objects\n    serializer_class = MealTypeSerializer\n    permission_classes = [CustomIsOwner]\n\n    def get_queryset(self):\n        queryset = self.queryset.order_by('order', 'id').filter(created_by=self.request.user).filter(\n            space=self.request.space).all()\n        return queryset\n\n\nclass IngredientViewSet(viewsets.ModelViewSet):\n    queryset = Ingredient.objects\n    serializer_class = IngredientSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_serializer_class(self):\n        if self.request and self.request.query_params.get('simple', False):\n            return IngredientSimpleSerializer\n        return IngredientSerializer\n\n    def get_queryset(self):\n        queryset = self.queryset.filter(step__recipe__space=self.request.space)\n        food = self.request.query_params.get('food', None)\n        if food and re.match(r'^(\\d)+$', food):\n            queryset = queryset.filter(food_id=food)\n\n        unit = self.request.query_params.get('unit', None)\n        if unit and re.match(r'^(\\d)+$', unit):\n            queryset = queryset.filter(unit_id=unit)\n\n        return queryset\n\n\nclass StepViewSet(viewsets.ModelViewSet):\n    queryset = Step.objects\n    serializer_class = StepSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n    query_params = [\n        QueryParam(name='recipe', description=_('ID of recipe a step is part of. For multiple repeat parameter.'),\n                   qtype='int'),\n        QueryParam(name='query', description=_('Query string matched (fuzzy) against object name.'), qtype='string'),\n    ]\n    schema = QueryParamAutoSchema()\n\n    def get_queryset(self):\n        recipes = self.request.query_params.getlist('recipe', [])\n        query = self.request.query_params.get('query', None)\n        if len(recipes) > 0:\n            self.queryset = self.queryset.filter(recipe__in=recipes)\n        if query is not None:\n            self.queryset = self.queryset.filter(Q(name__icontains=query) | Q(recipe__name__icontains=query))\n        return self.queryset.filter(recipe__space=self.request.space)\n\n\nclass RecipePagination(PageNumberPagination):\n    page_size = 25\n    page_size_query_param = 'page_size'\n    max_page_size = 100\n\n    def paginate_queryset(self, queryset, request, view=None):\n        if queryset is None:\n            raise Exception\n        self.facets = RecipeFacet(request, queryset=queryset)\n        return super().paginate_queryset(queryset, request, view)\n\n    def get_paginated_response(self, data):\n        return Response(OrderedDict([\n            ('count', self.page.paginator.count),\n            ('next', self.get_next_link()),\n            ('previous', self.get_previous_link()),\n            ('results', data),\n            ('facets', self.facets.get_facets(from_cache=True))\n        ]))\n\n\nclass RecipeViewSet(viewsets.ModelViewSet):\n    queryset = Recipe.objects\n    serializer_class = RecipeSerializer\n    # TODO split read and write permission for meal plan guest\n    permission_classes = [CustomIsShare | CustomIsGuest]\n    pagination_class = RecipePagination\n\n    query_params = [\n        QueryParam(name='query', description=_(\n            'Query string matched (fuzzy) against recipe name. In the future also fulltext search.')),\n        QueryParam(name='keywords', description=_(\n            'ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or'),\n                   qtype='int'),\n        QueryParam(name='keywords_or',\n                   description=_('Keyword IDs, repeat for multiple. Return recipes with any of the keywords'),\n                   qtype='int'),\n        QueryParam(name='keywords_and',\n                   description=_('Keyword IDs, repeat for multiple. Return recipes with all of the keywords.'),\n                   qtype='int'),\n        QueryParam(name='keywords_or_not',\n                   description=_('Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.'),\n                   qtype='int'),\n        QueryParam(name='keywords_and_not',\n                   description=_('Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.'),\n                   qtype='int'),\n        QueryParam(name='foods', description=_('ID of food a recipe should have. For multiple repeat parameter.'),\n                   qtype='int'),\n        QueryParam(name='foods_or',\n                   description=_('Food IDs, repeat for multiple. Return recipes with any of the foods'), qtype='int'),\n        QueryParam(name='foods_and',\n                   description=_('Food IDs, repeat for multiple. Return recipes with all of the foods.'), qtype='int'),\n        QueryParam(name='foods_or_not',\n                   description=_('Food IDs, repeat for multiple. Exclude recipes with any of the foods.'), qtype='int'),\n        QueryParam(name='foods_and_not',\n                   description=_('Food IDs, repeat for multiple. Exclude recipes with all of the foods.'), qtype='int'),\n        QueryParam(name='units', description=_('ID of unit a recipe should have.'), qtype='int'),\n        QueryParam(name='rating', description=_(\n            'Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.'), qtype='int'),\n        QueryParam(name='books', description=_('ID of book a recipe should be in. For multiple repeat parameter.')),\n        QueryParam(name='books_or',\n                   description=_('Book IDs, repeat for multiple. Return recipes with any of the books'), qtype='int'),\n        QueryParam(name='books_and',\n                   description=_('Book IDs, repeat for multiple. Return recipes with all of the books.'), qtype='int'),\n        QueryParam(name='books_or_not',\n                   description=_('Book IDs, repeat for multiple. Exclude recipes with any of the books.'), qtype='int'),\n        QueryParam(name='books_and_not',\n                   description=_('Book IDs, repeat for multiple. Exclude recipes with all of the books.'), qtype='int'),\n        QueryParam(name='internal',\n                   description=_('If only internal recipes should be returned. [''true''/''<b>false</b>'']')),\n        QueryParam(name='random',\n                   description=_('Returns the results in randomized order. [''true''/''<b>false</b>'']')),\n        QueryParam(name='new',\n                   description=_('Returns new results first in search results. [''true''/''<b>false</b>'']')),\n        QueryParam(name='timescooked', description=_(\n            'Filter recipes cooked X times or more.  Negative values returns cooked less than X times'), qtype='int'),\n        QueryParam(name='cookedon', description=_(\n            'Filter recipes last cooked on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='createdon', description=_(\n            'Filter recipes created on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='updatedon', description=_(\n            'Filter recipes updated on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='viewedon', description=_(\n            'Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending ''-'' filters on or before date.')),\n        QueryParam(name='makenow',\n                   description=_('Filter recipes that can be made with OnHand food. [''true''/''<b>false</b>'']')),\n    ]\n    schema = QueryParamAutoSchema()\n\n    def get_queryset(self):\n        share = self.request.query_params.get('share', None)\n\n        if self.detail:\n            if not share:\n                self.queryset = self.queryset.filter(space=self.request.space)\n            return super().get_queryset()\n\n        if not (share and self.detail):\n            self.queryset = self.queryset.filter(space=self.request.space)\n\n        params = {x: self.request.GET.get(x) if len({**self.request.GET}[x]) == 1 else self.request.GET.getlist(x) for x\n                  in list(self.request.GET)}\n        search = RecipeSearch(self.request, **params)\n        self.queryset = search.get_queryset(self.queryset).prefetch_related('cooklog_set')\n        return self.queryset\n\n    def list(self, request, *args, **kwargs):\n        if self.request.GET.get('debug', False):\n            return JsonResponse({\n                'new': str(self.get_queryset().query),\n                'old': str(old_search(request).query)\n            })\n        return super().list(request, *args, **kwargs)\n\n    # TODO write extensive tests for permissions\n\n    def get_serializer_class(self):\n        if self.action == 'list':\n            return RecipeOverviewSerializer\n        return self.serializer_class\n\n    @decorators.action(\n        detail=True,\n        methods=['PUT'],\n        serializer_class=RecipeImageSerializer,\n        parser_classes=[MultiPartParser],\n    )\n    def image(self, request, pk):\n        obj = self.get_object()\n\n        if obj.get_space() != request.space:\n            raise PermissionDenied(detail='You do not have the required permission to perform this action', code=403)\n\n        serializer = self.serializer_class(obj, data=request.data, partial=True)\n\n        if serializer.is_valid():\n            serializer.save()\n            image = None\n            filetype = \".jpeg\"  # fall-back to .jpeg, even if wrong, at least users will know it's an image and most image viewers can open it correctly anyways\n\n            if 'image' in serializer.validated_data:\n                image = obj.image\n                filetype = mimetypes.guess_extension(serializer.validated_data['image'].content_type) or filetype\n            elif 'image_url' in serializer.validated_data:\n                try:\n                    url = serializer.validated_data['image_url']\n                    if validators.url(url, public=True):\n                        response = requests.get(url)\n                        image = File(io.BytesIO(response.content))\n                        filetype = mimetypes.guess_extension(response.headers['content-type']) or filetype\n                except UnidentifiedImageError as e:\n                    print(e)\n                    pass\n                except MissingSchema as e:\n                    print(e)\n                    pass\n                except Exception as e:\n                    print(e)\n                    pass\n\n            if image is not None:\n                img = handle_image(request, image, filetype)\n                obj.image = File(img, name=f'{uuid.uuid4()}_{obj.pk}{filetype}')\n                obj.save()\n                return Response(serializer.data)\n\n        return Response(serializer.errors, 400)\n\n    # TODO: refactor API to use post/put/delete or leave as put and change VUE to use list_recipe after creating\n    # DRF only allows one action in a decorator action without overriding get_operation_id_base()\n    @decorators.action(\n        detail=True,\n        methods=['PUT'],\n        serializer_class=RecipeShoppingUpdateSerializer,\n    )\n    def shopping(self, request, pk):\n        if self.request.space.demo:\n            raise PermissionDenied(detail='Not available in demo', code=None)\n        obj = self.get_object()\n        ingredients = request.data.get('ingredients', None)\n        servings = request.data.get('servings', None)\n        list_recipe = request.data.get('list_recipe', None)\n        mealplan = request.data.get('mealplan', None)\n        SLR = RecipeShoppingEditor(request.user, request.space, id=list_recipe, recipe=obj, mealplan=mealplan)\n\n        content = {'msg': _(f'{obj.name} was added to the shopping list.')}\n        http_status = status.HTTP_204_NO_CONTENT\n        if servings and servings <= 0:\n            result = SLR.delete()\n        elif list_recipe:\n            result = SLR.edit(servings=servings, ingredients=ingredients)\n        else:\n            result = SLR.create(servings=servings, ingredients=ingredients)\n\n        if not result:\n            content = {'msg': ('An error occurred')}\n            http_status = status.HTTP_500_INTERNAL_SERVER_ERROR\n        else:\n            content = {'msg': _(f'{obj.name} was added to the shopping list.')}\n            http_status = status.HTTP_204_NO_CONTENT\n\n        return Response(content, status=http_status)\n\n    @decorators.action(\n        detail=True,\n        methods=['GET'],\n        serializer_class=RecipeSimpleSerializer\n    )\n    def related(self, request, pk):\n        obj = self.get_object()\n        if obj.get_space() != request.space:\n            raise PermissionDenied(detail='You do not have the required permission to perform this action', code=403)\n        try:\n            levels = int(request.query_params.get('levels', 1))\n        except (ValueError, TypeError):\n            levels = 1\n        qs = obj.get_related_recipes(\n            levels=levels)  # TODO: make levels a user setting, included in request data?, keep solely in the backend?\n        return Response(self.serializer_class(qs, many=True).data)\n\n\nclass ShoppingListRecipeViewSet(viewsets.ModelViewSet):\n    queryset = ShoppingListRecipe.objects\n    serializer_class = ShoppingListRecipeSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(\n            Q(shoppinglist__space=self.request.space) | Q(entries__space=self.request.space))\n        return self.queryset.filter(\n            Q(shoppinglist__created_by=self.request.user)\n            | Q(shoppinglist__shared=self.request.user)\n            | Q(entries__created_by=self.request.user)\n            | Q(entries__created_by__in=list(self.request.user.get_shopping_share()))\n        ).distinct().all()\n\n\nclass ShoppingListEntryViewSet(viewsets.ModelViewSet):\n    queryset = ShoppingListEntry.objects\n    serializer_class = ShoppingListEntrySerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n    query_params = [\n        QueryParam(name='id',\n                   description=_('Returns the shopping list entry with a primary key of id.  Multiple values allowed.'),\n                   qtype='int'),\n        QueryParam(\n            name='checked',\n            description=_(\n                'Filter shopping list entries on checked.  [''true'', ''false'', ''both'', ''<b>recent</b>'']<br>  - ''recent'' includes unchecked items and recently completed items.')\n        ),\n        QueryParam(name='supermarket',\n                   description=_('Returns the shopping list entries sorted by supermarket category order.'),\n                   qtype='int'),\n    ]\n    schema = QueryParamAutoSchema()\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space)\n\n        self.queryset = self.queryset.filter(\n            Q(created_by=self.request.user)\n            | Q(shoppinglist__shared=self.request.user)\n            | Q(created_by__in=list(self.request.user.get_shopping_share()))\n        ).distinct().all()\n\n        if pk := self.request.query_params.getlist('id', []):\n            self.queryset = self.queryset.filter(food__id__in=[int(i) for i in pk])\n\n        if 'checked' in self.request.query_params or 'recent' in self.request.query_params:\n            return shopping_helper(self.queryset, self.request)\n\n        # TODO once old shopping list is removed this needs updated to sharing users in preferences\n        return self.queryset\n\n\n# TODO deprecate\nclass ShoppingListViewSet(viewsets.ModelViewSet):\n    queryset = ShoppingList.objects\n    serializer_class = ShoppingListSerializer\n    permission_classes = [CustomIsOwner | CustomIsShared]\n\n    def get_queryset(self):\n        return self.queryset.filter(\n            Q(created_by=self.request.user)\n            | Q(shared=self.request.user)\n            | Q(created_by__in=list(self.request.user.get_shopping_share()))\n        ).filter(space=self.request.space).distinct()\n\n    def get_serializer_class(self):\n        try:\n            autosync = self.request.query_params.get('autosync', False)\n            if autosync:\n                return ShoppingListAutoSyncSerializer\n        except AttributeError:  # Needed for the openapi schema to determine a serializer without a request\n            pass\n        return self.serializer_class\n\n\nclass ViewLogViewSet(viewsets.ModelViewSet):\n    queryset = ViewLog.objects\n    serializer_class = ViewLogSerializer\n    permission_classes = [CustomIsOwner]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        # working backwards from the test - this is supposed to be limited to user view logs only??\n        return self.queryset.filter(created_by=self.request.user).filter(space=self.request.space)\n\n\nclass CookLogViewSet(viewsets.ModelViewSet):\n    queryset = CookLog.objects\n    serializer_class = CookLogSerializer\n    permission_classes = [CustomIsOwner]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass ImportLogViewSet(viewsets.ModelViewSet):\n    queryset = ImportLog.objects\n    serializer_class = ImportLogSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass ExportLogViewSet(viewsets.ModelViewSet):\n    queryset = ExportLog.objects\n    serializer_class = ExportLogSerializer\n    permission_classes = [CustomIsUser]\n    pagination_class = DefaultPagination\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space)\n\n\nclass BookmarkletImportViewSet(viewsets.ModelViewSet):\n    queryset = BookmarkletImport.objects\n    serializer_class = BookmarkletImportSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_serializer_class(self):\n        if self.action == 'list':\n            return BookmarkletImportListSerializer\n        return self.serializer_class\n\n    def get_queryset(self):\n        return self.queryset.filter(space=self.request.space).all()\n\n\nclass UserFileViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = UserFile.objects\n    serializer_class = UserFileSerializer\n    permission_classes = [CustomIsUser]\n    parser_classes = [MultiPartParser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).all()\n        return super().get_queryset()\n\n\nclass AutomationViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = Automation.objects\n    serializer_class = AutomationSerializer\n    permission_classes = [CustomIsUser]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(space=self.request.space).all()\n        return super().get_queryset()\n\n\nclass CustomFilterViewSet(viewsets.ModelViewSet, StandardFilterMixin):\n    queryset = CustomFilter.objects\n    serializer_class = CustomFilterSerializer\n    permission_classes = [CustomIsOwner]\n\n    def get_queryset(self):\n        self.queryset = self.queryset.filter(Q(created_by=self.request.user) | Q(shared=self.request.user)).filter(\n            space=self.request.space).distinct()\n        return super().get_queryset()\n\n\n# -------------- non django rest api views --------------------\n\n\ndef get_recipe_provider(recipe):\n    if recipe.storage.method == Storage.DROPBOX:\n        return Dropbox\n    elif recipe.storage.method == Storage.NEXTCLOUD:\n        return Nextcloud\n    elif recipe.storage.method == Storage.LOCAL:\n        return Local\n    else:\n        raise Exception('Provider not implemented')\n\n\ndef update_recipe_links(recipe):\n    if not recipe.link:\n        # TODO response validation in apis\n        recipe.link = get_recipe_provider(recipe).get_share_link(recipe)\n\n    recipe.save()\n\n\n@group_required('user')\ndef get_external_file_link(request, recipe_id):\n    recipe = get_object_or_404(Recipe, pk=recipe_id, space=request.space)\n    if not recipe.link:\n        update_recipe_links(recipe)\n\n    return HttpResponse(recipe.link)\n\n\n@group_required('guest')\ndef get_recipe_file(request, recipe_id):\n    recipe = get_object_or_404(Recipe, pk=recipe_id, space=request.space)\n    if recipe.storage:\n        return FileResponse(get_recipe_provider(recipe).get_file(recipe))\n    else:\n        return FileResponse()\n\n\n@group_required('user')\ndef sync_all(request):\n    if request.space.demo or settings.HOSTED:\n        messages.add_message(request, messages.ERROR,\n                             _('This feature is not yet available in the hosted version of tandoor!'))\n        return redirect('index')\n\n    monitors = Sync.objects.filter(active=True).filter(space=request.user.userpreference.space)\n\n    error = False\n    for monitor in monitors:\n        if monitor.storage.method == Storage.DROPBOX:\n            ret = Dropbox.import_all(monitor)\n            if not ret:\n                error = True\n        if monitor.storage.method == Storage.NEXTCLOUD:\n            ret = Nextcloud.import_all(monitor)\n            if not ret:\n                error = True\n        if monitor.storage.method == Storage.LOCAL:\n            ret = Local.import_all(monitor)\n            if not ret:\n                error = True\n\n    if not error:\n        messages.add_message(\n            request, messages.SUCCESS, _('Sync successful!')\n        )\n        return redirect('list_recipe_import')\n    else:\n        messages.add_message(\n            request, messages.ERROR, _('Error synchronizing with Storage')\n        )\n        return redirect('list_recipe_import')\n\n\n@group_required('user')\ndef share_link(request, pk):\n    if request.space.allow_sharing:\n        recipe = get_object_or_404(Recipe, pk=pk, space=request.space)\n        link = ShareLink.objects.create(recipe=recipe, created_by=request.user, space=request.space)\n        return JsonResponse({'pk': pk, 'share': link.uuid,\n                             'link': request.build_absolute_uri(reverse('view_recipe', args=[pk, link.uuid]))})\n    else:\n        return JsonResponse({'error': 'sharing_disabled'}, status=403)\n\n\n@group_required('user')\n@ajax_request\ndef log_cooking(request, recipe_id):\n    recipe = get_object_or_None(Recipe, id=recipe_id)\n    if recipe:\n        log = CookLog.objects.create(created_by=request.user, recipe=recipe, space=request.space)\n        servings = request.GET['s'] if 's' in request.GET else None\n        if servings and re.match(r'^([1-9])+$', servings):\n            log.servings = int(servings)\n\n        rating = request.GET['r'] if 'r' in request.GET else None\n        if rating and re.match(r'^([1-9])+$', rating):\n            log.rating = int(rating)\n        log.save()\n        return {'msg': 'updated successfully'}\n\n    return {'error': 'recipe does not exist'}\n\n\n@group_required('user')\ndef get_plan_ical(request, from_date, to_date):\n    queryset = MealPlan.objects.filter(\n        Q(created_by=request.user) | Q(shared=request.user)\n    ).filter(space=request.user.userpreference.space).distinct().all()\n\n    if from_date is not None:\n        queryset = queryset.filter(date__gte=from_date)\n\n    if to_date is not None:\n        queryset = queryset.filter(date__lte=to_date)\n\n    cal = Calendar()\n\n    for p in queryset:\n        event = Event()\n        event['uid'] = p.id\n        event.add('dtstart', p.date)\n        event.add('dtend', p.date)\n        event['summary'] = f'{p.meal_type.name}: {p.get_label()}'\n        event['description'] = p.note\n        cal.add_component(event)\n\n    response = FileResponse(io.BytesIO(cal.to_ical()))\n    response[\"Content-Disposition\"] = f'attachment; filename=meal_plan_{from_date}-{to_date}.ics'  # noqa: E501\n\n    return response\n\n\n@group_required('user')\ndef recipe_from_source(request):\n    \"\"\"\n    function to retrieve a recipe from a given url or source string\n    :param request: standard request with additional post parameters\n            - url: url to use for importing recipe\n            - data: if no url is given recipe is imported from provided source data\n            - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes\n    :return: JsonResponse containing the parsed json, original html,json and images\n    \"\"\"\n    if request.method == 'GET':\n        return HttpResponse(status=405)\n    request_payload = json.loads(request.body.decode('utf-8'))\n    url = request_payload.get('url', None)\n    data = request_payload.get('data', None)\n    bookmarklet = request_payload.get('bookmarklet', None)\n\n    if bookmarklet := BookmarkletImport.objects.filter(pk=bookmarklet).first():\n        url = bookmarklet.url\n        data = bookmarklet.html\n        bookmarklet.delete()\n\n    # headers to use for request to external sites\n    external_request_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.0.7) Gecko/2009021910 Firefox/3.0.7\"}\n\n    if not url and not data:\n        return JsonResponse({\n            'error': True,\n            'msg': _('Nothing to do.')\n        }, status=400)\n\n    # in manual mode request complete page to return it later\n    if url:\n        try:\n            if validators.url(url, public=True):\n                data = requests.get(url, headers=external_request_headers).content\n            else:\n                return JsonResponse({\n                    'error': True,\n                    'msg': _('Invalid Url')\n                }, status=400)\n        except requests.exceptions.ConnectionError:\n            return JsonResponse({\n                'error': True,\n                'msg': _('Connection Refused.')\n            }, status=400)\n        except requests.exceptions.MissingSchema:\n            return JsonResponse({\n                'error': True,\n                'msg': _('Bad URL Schema.')\n            }, status=400)\n\n    recipe_json, recipe_tree, recipe_html, recipe_images = get_recipe_from_source(data, url, request)\n    if len(recipe_tree) == 0 and len(recipe_json) == 0:\n        return JsonResponse({\n            'error': True,\n            'msg': _('No usable data could be found.')\n        }, status=400)\n    else:\n        return JsonResponse({\n            'recipe_json': recipe_json,\n            'recipe_tree': recipe_tree,\n            'recipe_html': recipe_html,\n            'recipe_images': list(dict.fromkeys(recipe_images)),\n        })\n\n\n@group_required('admin')\ndef get_backup(request):\n    if not request.user.is_superuser:\n        return HttpResponse('', status=403)\n\n\n@group_required('user')\ndef ingredient_from_string(request):\n    text = request.POST['text']\n\n    ingredient_parser = IngredientParser(request, False)\n    amount, unit, food, note = ingredient_parser.parse(text)\n\n    return JsonResponse(\n        {\n            'amount': amount,\n            'unit': unit,\n            'food': food,\n            'note': note\n        },\n        status=200\n    )\n\n\n@group_required('user')\ndef get_facets(request):\n    key = request.GET.get('hash', None)\n    food = request.GET.get('food', None)\n    keyword = request.GET.get('keyword', None)\n    facets = RecipeFacet(request, hash_key=key)\n\n    if food:\n        results = facets.add_food_children(food)\n    elif keyword:\n        results = facets.add_keyword_children(keyword)\n    else:\n        results = facets.get_facets()\n\n    return JsonResponse(\n        {\n            'facets': results,\n        },\n        status=200\n    )\n", "Django==3.2.13\ncryptography==37.0.1\ndjango-annoying==0.10.6\ndjango-autocomplete-light==3.9.4\ndjango-cleanup==6.0.0\ndjango-crispy-forms==1.14.0\ndjango-filter==21.1\ndjango-tables2==2.4.1\ndjangorestframework==3.13.1\ndrf-writable-nested==0.6.3\nbleach==4.1.0\nbleach-allowlist==1.0.3\ngunicorn==20.1.0\nlxml==4.8.0\nMarkdown==3.3.6\nPillow==9.0.1\npsycopg2-binary==2.9.3\npython-dotenv==0.20.0\nrequests==2.27.1\nsix==1.16.0\nwebdavclient3==3.14.6\nwhitenoise==6.0.0\nicalendar==4.0.9\npyyaml==6.0\nuritemplate==4.1.1\nbeautifulsoup4==4.10.0\nmicrodata==0.8.0\nJinja2==3.1.1\ndjango-webpack-loader==1.4.1\ndjango-js-reverse==0.9.1\ndjango-allauth==0.50.0\nrecipe-scrapers==13.32.1\ndjango-scopes==1.2.0\npytest==7.1.1\npytest-django==4.5.2\ndjango-treebeard==4.5.1\ndjango-cors-headers==3.11.0\ndjango-storages==1.12.3\nboto3==1.21.31\ndjango-prometheus==2.2.0\ndjango-hCaptcha==0.2.0\npython-ldap==3.4.0\ndjango-auth-ldap==4.0.0\npytest-factoryboy==2.1.0\npyppeteer==1.0.2\nvalidators==0.19.0"], "filenames": ["cookbook/integration/cookbookapp.py", "cookbook/integration/cookmate.py", "cookbook/integration/recettetek.py", "cookbook/integration/recipesage.py", "cookbook/provider/dropbox.py", "cookbook/provider/nextcloud.py", "cookbook/views/api.py", "requirements.txt"], "buggy_code_start_loc": [8, 7, 7, 4, 6, 6, 8, 45], "buggy_code_end_loc": [64, 68, 131, 56, 110, 109, 1201, 45], "fixing_code_start_loc": [9, 8, 8, 5, 7, 7, 9, 46], "fixing_code_end_loc": [67, 71, 134, 59, 114, 111, 1211, 47], "type": "CWE-918", "message": "In Recipes, versions 0.9.1 through 1.2.5 are vulnerable to Server Side Request Forgery (SSRF), in the \u201cImport Recipe\u201d functionality. When an attacker enters the localhost URL, a low privileged attacker can access/read the internal file system to access sensitive information.", "other": {"cve": {"id": "CVE-2022-23071", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2022-06-19T11:15:07.810", "lastModified": "2022-06-28T16:40:19.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Recipes, versions 0.9.1 through 1.2.5 are vulnerable to Server Side Request Forgery (SSRF), in the \u201cImport Recipe\u201d functionality. When an attacker enters the localhost URL, a low privileged attacker can access/read the internal file system to access sensitive information."}, {"lang": "es", "value": "En Recipes, versiones 0.9.1 hasta 1.2.5, son vulnerables a un ataque de tipo Server Side Request Forgery (SSRF), en la funcionalidad \u201cImport Recipe\u201d. Cuando un atacante entra en la URL de localhost, un atacante con pocos privilegios puede acceder/leer el sistema de archivos interno para acceder a informaci\u00f3n confidencial"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tandoor:recipes:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.1", "versionEndIncluding": "1.2.5", "matchCriteriaId": "B8A1ACAA-A43E-48E9-8406-A8F8F8EF6B45"}]}]}], "references": [{"url": "https://github.com/TandoorRecipes/recipes/commit/d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.mend.io/vulnerability-database/CVE-2022-23071", "source": "vulnerabilitylab@mend.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TandoorRecipes/recipes/commit/d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c"}}