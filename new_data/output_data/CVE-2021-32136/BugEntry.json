{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / mp4box application\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"mp4box.h\"\n\n#if defined(GPAC_DISABLE_ISOM) || defined(GPAC_DISABLE_ISOM_WRITE)\n\n#error \"Cannot compile MP4Box if GPAC is not built with ISO File Format support\"\n\n#else\n\n#ifndef GPAC_DISABLE_X3D\n#include <gpac/nodes_x3d.h>\n#endif\n#ifndef GPAC_DISABLE_BIFS\n#include <gpac/internal/bifs_dev.h>\n#endif\n#ifndef GPAC_DISABLE_VRML\n#include <gpac/nodes_mpeg4.h>\n#endif\n#include <gpac/constants.h>\n#include <gpac/avparse.h>\n#include <gpac/internal/media_dev.h>\n/*ISO 639 languages*/\n#include <gpac/iso639.h>\n#include <gpac/mpegts.h>\n\n#ifndef GPAC_DISABLE_SMGR\n#include <gpac/scene_manager.h>\n#endif\n#include <gpac/internal/media_dev.h>\n#include <gpac/media_tools.h>\n/*for built-in box printing*/\n#include <gpac/internal/isomedia_dev.h>\n\nextern u32 swf_flags;\nextern Float swf_flatten_angle;\nextern GF_FileType get_file_type_by_ext(char *inName);\nextern u32 fs_dump_flags;\n\nvoid scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist);\n\n\n#ifdef GPAC_DISABLE_LOG\nvoid mp4box_log(const char *fmt, ...)\n{\n\tva_list vl;\n\tva_start(vl, fmt);\n\tvfprintf(stderr, fmt, vlist);\n\tfflush(stderr);\n\tva_end(vl);\n}\n#endif\n\n\nu32 PrintLanguages(char *val, u32 opt)\n{\n\tu32 i=0, count = gf_lang_get_count();\n\tfprintf(stderr, \"Supported ISO 639 languages and codes:\\n\\n\");\n\tfor (i=0; i<count; i++) {\n\t\tif (gf_lang_get_2cc(i)) {\n\t\t\tfprintf(stderr, \"%s (%s - %s)\\n\", gf_lang_get_name(i), gf_lang_get_3cc(i), gf_lang_get_2cc(i));\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic const char *GetLanguage(char *lcode)\n{\n\ts32 idx = gf_lang_find(lcode);\n\tif (idx>=0) return gf_lang_get_name(idx);\n\treturn lcode;\n}\n\nGF_Err dump_isom_cover_art(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst u8 *tag;\n\tFILE *t;\n\tu32 tag_len;\n\tGF_Err e = gf_isom_apple_get_tag(file, GF_ISOM_ITUNE_COVER_ART, &tag, &tag_len);\n\tif (e!=GF_OK) {\n\t\tif (e==GF_URL_ERROR) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"No cover art found\\n\"));\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn e;\n\t}\n\n\tif (inName) {\n\t\tchar szName[1024];\n\t\tif (is_final_name) {\n\t\t\tstrcpy(szName, inName);\n\t\t} else {\n\t\t\tsprintf(szName, \"%s.%s\", inName, (tag_len>>31) ? \"png\" : \"jpg\");\n\t\t}\n\t\tt = gf_fopen(szName, \"wb\");\n\t\tif (!t) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szName));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t} else {\n\t\tt = stdout;\n\t}\n\tgf_fwrite(tag, tag_len & 0x7FFFFFFF, t);\n\n\tif (inName) gf_fclose(t);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\nGF_Err dump_isom_scene(char *file, char *inName, Bool is_final_name, GF_SceneDumpFormat dump_mode, Bool do_log, Bool no_odf_conv)\n{\n\tGF_Err e;\n\tGF_SceneManager *ctx;\n\tGF_SceneGraph *sg;\n\tGF_SceneLoader load;\n\tGF_FileType ftype;\n\tgf_log_cbk prev_logs = NULL;\n\tFILE *logs = NULL;\n\n\tsg = gf_sg_new();\n\tctx = gf_sm_new(sg);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = file;\n\tload.ctx = ctx;\n\tload.swf_import_flags = swf_flags;\n\tif (dump_mode == GF_SM_DUMP_SVG) {\n\t\tload.swf_import_flags |= GF_SM_SWF_USE_SVG;\n\t\tload.svgOutFile = inName;\n\t}\n\tload.swf_flatten_limit = swf_flatten_angle;\n\n\tftype = get_file_type_by_ext(file);\n\tif (ftype == GF_FILE_TYPE_ISO_MEDIA) {\n\t\tload.isom = gf_isom_open(file, GF_ISOM_OPEN_READ, NULL);\n\t\tif (!load.isom) {\n\t\t\te = gf_isom_last_error(NULL);\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error opening file: %s\\n\", gf_error_to_string(e)));\n\t\t\tgf_sm_del(ctx);\n\t\t\tgf_sg_del(sg);\n\t\t\treturn e;\n\t\t}\n\t\tif (no_odf_conv)\n\t\t\tgf_isom_disable_odf_conversion(load.isom, GF_TRUE);\n\n\t} else if (ftype==GF_FILE_TYPE_LSR_SAF) {\n\t\tload.isom = gf_isom_open(\"saf_conv\", GF_ISOM_WRITE_EDIT, NULL);\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tif (load.isom) {\n\t\t\tGF_Fraction _frac = {0,0};\n\t\t\te = import_file(load.isom, file, 0, _frac, 0, NULL, NULL, 0);\n\t\t} else\n#else\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: GPAC was compiled without Media Import support\\n\"));\n#endif\n\t\t\te = gf_isom_last_error(NULL);\n\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing file: %s\\n\", gf_error_to_string(e)));\n\t\t\tgf_sm_del(ctx);\n\t\t\tgf_sg_del(sg);\n\t\t\tif (load.isom) gf_isom_delete(load.isom);\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tif (do_log) {\n\t\tchar szLog[GF_MAX_PATH];\n\t\tsprintf(szLog, \"%s_dec.logs\", inName);\n\t\tlogs = gf_fopen(szLog, \"wt\");\n\n\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_DEBUG);\n\t\tprev_logs = gf_log_set_callback(logs, scene_coding_log);\n\t}\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (logs) {\n\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_ERROR);\n\t\tgf_log_set_callback(NULL, prev_logs);\n\t\tgf_fclose(logs);\n\t}\n\tif (!e && dump_mode != GF_SM_DUMP_SVG) {\n\t\tu32 count = gf_list_count(ctx->streams);\n\t\tif (count)\n\t\t\tfprintf(stderr, \"Scene loaded - dumping %d systems streams\\n\", count);\n\t\telse\n\t\t\tfprintf(stderr, \"Scene loaded - dumping root scene\\n\");\n\n\t\te = gf_sm_dump(ctx, inName, is_final_name, dump_mode);\n\t}\n\n\tgf_sm_del(ctx);\n\tgf_sg_del(sg);\n\tif (e) M4_LOG(GF_LOG_ERROR, (\"Error loading scene: %s\\n\", gf_error_to_string(e)));\n\tif (load.isom) gf_isom_delete(load.isom);\n\treturn e;\n}\n#endif\n\n#ifndef GPAC_DISABLE_SCENE_STATS\n\nstatic void dump_stats(FILE *dump, const GF_SceneStatistics *stats)\n{\n\tu32 i;\n\ts32 created, count, draw_created, draw_count, deleted, draw_deleted;\n\tcreated = count = draw_created = draw_count = deleted = draw_deleted = 0;\n\n\tfprintf(dump, \"<NodeStatistics>\\n\");\n\tfprintf(dump, \"<General NumberOfNodeTypes=\\\"%d\\\"/>\\n\", gf_list_count(stats->node_stats));\n\tfor (i=0; i<gf_list_count(stats->node_stats); i++) {\n\t\tGF_NodeStats *ptr = gf_list_get(stats->node_stats, i);\n\t\tfprintf(dump, \"<NodeStat NodeName=\\\"%s\\\">\\n\", ptr->name);\n\n\t\tswitch (ptr->tag) {\n#ifndef GPAC_DISABLE_VRML\n\t\tcase TAG_MPEG4_Bitmap:\n\t\tcase TAG_MPEG4_Background2D:\n\t\tcase TAG_MPEG4_Background:\n\t\tcase TAG_MPEG4_Box:\n\t\tcase TAG_MPEG4_Circle:\n\t\tcase TAG_MPEG4_CompositeTexture2D:\n\t\tcase TAG_MPEG4_CompositeTexture3D:\n\t\tcase TAG_MPEG4_Cylinder:\n\t\tcase TAG_MPEG4_Cone:\n\t\tcase TAG_MPEG4_Curve2D:\n\t\tcase TAG_MPEG4_Extrusion:\n\t\tcase TAG_MPEG4_ElevationGrid:\n\t\tcase TAG_MPEG4_IndexedFaceSet2D:\n\t\tcase TAG_MPEG4_IndexedFaceSet:\n\t\tcase TAG_MPEG4_IndexedLineSet2D:\n\t\tcase TAG_MPEG4_IndexedLineSet:\n\t\tcase TAG_MPEG4_PointSet2D:\n\t\tcase TAG_MPEG4_PointSet:\n\t\tcase TAG_MPEG4_Rectangle:\n\t\tcase TAG_MPEG4_Sphere:\n\t\tcase TAG_MPEG4_Text:\n\t\tcase TAG_MPEG4_Ellipse:\n\t\tcase TAG_MPEG4_XCurve2D:\n\t\t\tdraw_count += ptr->nb_created + ptr->nb_used - ptr->nb_del;\n\t\t\tdraw_deleted += ptr->nb_del;\n\t\t\tdraw_created += ptr->nb_created;\n\t\t\tbreak;\n#endif /*GPAC_DISABLE_VRML*/\n\t\t}\n\t\tfprintf(dump, \"<Instanciation NbObjects=\\\"%d\\\" NbUse=\\\"%d\\\" NbDestroy=\\\"%d\\\"/>\\n\", ptr->nb_created, ptr->nb_used, ptr->nb_del);\n\t\tcount += ptr->nb_created + ptr->nb_used;\n\t\tdeleted += ptr->nb_del;\n\t\tcreated += ptr->nb_created;\n\t\tfprintf(dump, \"</NodeStat>\\n\");\n\t}\n\tif (i) {\n\t\tfprintf(dump, \"<CumulatedStat TotalNumberOfNodes=\\\"%d\\\" ReallyAllocatedNodes=\\\"%d\\\" DeletedNodes=\\\"%d\\\" NumberOfAttributes=\\\"%d\\\"/>\\n\", count, created, deleted, stats->nb_svg_attributes);\n\t\tfprintf(dump, \"<DrawableNodesCumulatedStat TotalNumberOfNodes=\\\"%d\\\" ReallyAllocatedNodes=\\\"%d\\\" DeletedNodes=\\\"%d\\\"/>\\n\", draw_count, draw_created, draw_deleted);\n\t}\n\tfprintf(dump, \"</NodeStatistics>\\n\");\n\n\tcreated = count = deleted = 0;\n\tif (gf_list_count(stats->proto_stats)) {\n\t\tfprintf(dump, \"<ProtoStatistics NumberOfProtoUsed=\\\"%d\\\">\\n\", gf_list_count(stats->proto_stats));\n\t\tfor (i=0; i<gf_list_count(stats->proto_stats); i++) {\n\t\t\tGF_NodeStats *ptr = gf_list_get(stats->proto_stats, i);\n\t\t\tfprintf(dump, \"<ProtoStat ProtoName=\\\"%s\\\">\\n\", ptr->name);\n\t\t\tfprintf(dump, \"<Instanciation NbObjects=\\\"%d\\\" NbUse=\\\"%d\\\" NbDestroy=\\\"%d\\\"/>\\n\", ptr->nb_created, ptr->nb_used, ptr->nb_del);\n\t\t\tcount += ptr->nb_created + ptr->nb_used;\n\t\t\tdeleted += ptr->nb_del;\n\t\t\tcreated += ptr->nb_created;\n\t\t\tfprintf(dump, \"</ProtoStat>\\n\");\n\t\t}\n\t\tif (i) fprintf(dump, \"<CumulatedStat TotalNumberOfProtos=\\\"%d\\\" ReallyAllocatedProtos=\\\"%d\\\" DeletedProtos=\\\"%d\\\"/>\\n\", count, created, deleted);\n\t\tfprintf(dump, \"</ProtoStatistics>\\n\");\n\t}\n\tfprintf(dump, \"<FixedValues min=\\\"%f\\\" max=\\\"%f\\\">\\n\", FIX2FLT( stats->min_fixed) , FIX2FLT( stats->max_fixed ));\n\tfprintf(dump, \"<Resolutions scaleIntegerPart=\\\"%d\\\" scaleFracPart=\\\"%d\\\" coordIntegerPart=\\\"%d\\\" coordFracPart=\\\"%d\\\"/>\\n\", stats->scale_int_res_2d, stats->scale_frac_res_2d, stats->int_res_2d, stats->frac_res_2d);\n\tfprintf(dump, \"</FixedValues>\\n\");\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MFVec2f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\\n\", stats->count_2d, stats->rem_2d);\n\tif (stats->count_2d) {\n\t\tfprintf(dump, \"<ExtendInfo MinVec2f=\\\"%f %f\\\" MaxVec2f=\\\"%f %f\\\"/>\\n\", FIX2FLT( stats->min_2d.x) , FIX2FLT( stats->min_2d.y ), FIX2FLT( stats->max_2d.x ), FIX2FLT( stats->max_2d.y ) );\n\t}\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MFVec3f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\", stats->count_3d, stats->rem_3d);\n\tif (stats->count_3d) {\n\t\tfprintf(dump, \"<ExtendInfo MinVec3f=\\\"%f %f %f\\\" MaxVec3f=\\\"%f %f %f\\\"/>\\n\", FIX2FLT( stats->min_3d.x ), FIX2FLT( stats->min_3d.y ), FIX2FLT( stats->min_3d.z ), FIX2FLT( stats->max_3d.x ), FIX2FLT( stats->max_3d.y ), FIX2FLT( stats->max_3d.z ) );\n\t}\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MF/SFColor\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\", stats->count_color, stats->rem_color);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MF/SFFloat\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\", stats->count_float, stats->rem_float);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"SFVec2f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\"/>\", stats->count_2f);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"SFVec3f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\"/>\", stats->count_3f);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n}\n\n\nstatic void ReorderAU(GF_List *sample_list, GF_AUContext *au)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(sample_list); i++) {\n\t\tGF_AUContext *ptr = gf_list_get(sample_list, i);\n\t\tif (\n\t\t    /*time ordered*/\n\t\t    (ptr->timing_sec > au->timing_sec)\n\t\t    /*set bifs first*/\n\t\t    || ((ptr->timing_sec == au->timing_sec) && (ptr->owner->streamType < au->owner->streamType))\n\t\t) {\n\t\t\tgf_list_insert(sample_list, au, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_list_add(sample_list, au);\n}\n\nvoid dump_isom_scene_stats(char *file, char *inName, Bool is_final_name, u32 stat_level)\n{\n\tGF_Err e;\n\tFILE *dump;\n\tBool close;\n\tu32 i, j, count;\n\tchar szBuf[1024];\n\tGF_SceneManager *ctx;\n\tGF_SceneLoader load;\n\tGF_StatManager *sm;\n\tGF_List *sample_list;\n\tGF_SceneGraph *scene_graph;\n\n\tdump = NULL;\n\tsm = NULL;\n\tsample_list = NULL;\n\n\tclose = 0;\n\n\tscene_graph = gf_sg_new();\n\tctx = gf_sm_new(scene_graph);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = file;\n\tload.ctx = ctx;\n\n\tif (get_file_type_by_ext(file) == 1) {\n\t\tload.isom = gf_isom_open(file, GF_ISOM_OPEN_READ, NULL);\n\t\tif (!load.isom) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open file: %s\\n\", gf_error_to_string(gf_isom_last_error(NULL))));\n\t\t\tgf_sm_del(ctx);\n\t\t\tgf_sg_del(scene_graph);\n\t\t\treturn;\n\t\t}\n\t}\n\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (e<0) goto exit;\n\n\tif (inName) {\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_stat.xml\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t\tclose = 1;\n\t} else {\n\t\tdump = stdout;\n\t\tclose = 0;\n\t}\n\n\tfprintf(stderr, \"Analysing Scene\\n\");\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tfprintf(dump, \"<!-- Scene Graph Statistics Generated by MP4Box - GPAC \");\n\tif (! gf_sys_is_test_mode())\n\t\tfprintf(dump, \"%s \",  gf_gpac_version());\n\tfprintf(dump, \"-->\\n\");\n\n\tfprintf(dump, \"<SceneStatistics file=\\\"%s\\\" DumpType=\\\"%s\\\">\\n\", gf_file_basename(file), (stat_level==1) ? \"full scene\" : ((stat_level==2) ? \"AccessUnit based\" : \"SceneGraph after each AU\"));\n\n\tsm = gf_sm_stats_new();\n\n\t/*stat level 1: complete scene stat*/\n\tif (stat_level == 1) {\n\t\te = gf_sm_stats_for_scene(sm, ctx);\n\t\tif (!e) dump_stats(dump, gf_sm_stats_get(sm) );\n\t\tgoto exit;\n\t}\n\t/*re_order all BIFS-AUs*/\n\tsample_list = gf_list_new();\n\t/*configure all systems streams we're dumping*/\n\tfor (i=0; i<gf_list_count(ctx->streams); i++) {\n\t\tGF_StreamContext *sc = gf_list_get(ctx->streams, i);\n\t\tif (sc->streamType != GF_STREAM_SCENE) continue;\n\t\tfor (j=0; j<gf_list_count(sc->AUs); j++) {\n\t\t\tGF_AUContext *au = gf_list_get(sc->AUs, j);\n\t\t\tReorderAU(sample_list, au);\n\t\t}\n\t}\n\n\tcount = gf_list_count(sample_list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AUContext *au = gf_list_get(sample_list, i);\n\n\t\tfor (j=0; j<gf_list_count(au->commands); j++) {\n\t\t\tGF_Command *com = gf_list_get(au->commands, j);\n\t\t\t/*stat level 2 - get command stats*/\n\t\t\tif (stat_level==2) {\n\t\t\t\te = gf_sm_stats_for_command(sm, com);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\t/*stat level 3 - apply command*/\n\t\t\tif (stat_level==3) gf_sg_command_apply(scene_graph, com, 0);\n\t\t}\n\t\t/*stat level 3: get graph stat*/\n\t\tif (stat_level==3) {\n\t\t\te = gf_sm_stats_for_graph(sm, scene_graph);\n\t\t\tif (e) goto exit;\n\t\t}\n\t\tif (stat_level==2) {\n\t\t\tfprintf(dump, \"<AUStatistics StreamID=\\\"%d\\\" AUTime=\\\"\"LLD\"\\\">\\n\", au->owner->ESID, au->timing);\n\t\t} else {\n\t\t\tfprintf(dump, \"<GraphStatistics StreamID=\\\"%d\\\" AUTime=\\\"\"LLD\"\\\">\\n\", au->owner->ESID, au->timing);\n\t\t}\n\t\t/*dump stats*/\n\t\tdump_stats(dump, gf_sm_stats_get(sm) );\n\t\t/*reset stats*/\n\t\tgf_sm_stats_reset(sm);\n\t\tif (stat_level==2) {\n\t\t\tfprintf(dump, \"</AUStatistics>\\n\");\n\t\t} else {\n\t\t\tfprintf(dump, \"</GraphStatistics>\\n\");\n\t\t}\n\n\t\tgf_set_progress(\"Analysing AU\", i+1, count);\n\t}\n\n\nexit:\n\tif (sample_list) gf_list_del(sample_list);\n\tif (sm) gf_sm_stats_del(sm);\n\tgf_sm_del(ctx);\n\tgf_sg_del(scene_graph);\n\tif (load.isom) gf_isom_delete(load.isom);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Stats error: %s\\n\", gf_error_to_string(e)));\n\t} else {\n\t\tfprintf(dump, \"</SceneStatistics>\\n\");\n\t}\n\tif (dump && close) gf_fclose(dump);\n\tfprintf(stderr, \"done\\n\");\n}\n#endif /*GPAC_DISABLE_SCENE_STATS*/\n\n\n\n#ifndef GPAC_DISABLE_VRML\n\nstatic void PrintFixed(Fixed val, Bool add_space)\n{\n\tif (add_space) fprintf(stderr, \" \");\n\tif (val==FIX_MIN) fprintf(stderr, \"-I\");\n\telse if (val==FIX_MAX) fprintf(stderr, \"+I\");\n\telse fprintf(stderr, \"%g\", FIX2FLT(val));\n}\n\nstatic void PrintNodeSFField(u32 type, void *far_ptr)\n{\n\tif (!far_ptr) return;\n\tswitch (type) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\tfprintf(stderr, \"%s\", (*(SFBool *)far_ptr) ? \"TRUE\" : \"FALSE\");\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\tfprintf(stderr, \"%d\", (*(SFInt32 *)far_ptr));\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tPrintFixed((*(SFFloat *)far_ptr), 0);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tfprintf(stderr, \"%g\", (*(SFTime *)far_ptr));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tPrintFixed(((SFVec2f *)far_ptr)->x, 0);\n\t\tPrintFixed(((SFVec2f *)far_ptr)->y, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tPrintFixed(((SFVec3f *)far_ptr)->x, 0);\n\t\tPrintFixed(((SFVec3f *)far_ptr)->y, 1);\n\t\tPrintFixed(((SFVec3f *)far_ptr)->z, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tPrintFixed(((SFRotation *)far_ptr)->x, 0);\n\t\tPrintFixed(((SFRotation *)far_ptr)->y, 1);\n\t\tPrintFixed(((SFRotation *)far_ptr)->z, 1);\n\t\tPrintFixed(((SFRotation *)far_ptr)->q, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tPrintFixed(((SFColor *)far_ptr)->red, 0);\n\t\tPrintFixed(((SFColor *)far_ptr)->green, 1);\n\t\tPrintFixed(((SFColor *)far_ptr)->blue, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tif (((SFString*)far_ptr)->buffer)\n\t\t\tfprintf(stderr, \"\\\"%s\\\"\", ((SFString*)far_ptr)->buffer);\n\t\telse\n\t\t\tfprintf(stderr, \"NULL\");\n\t\tbreak;\n\t}\n}\n#endif\n\n#ifndef GPAC_DISABLE_VRML\nstatic void do_print_node(GF_Node *node, GF_SceneGraph *sg, const char *name, u32 graph_type, Bool is_nodefield, Bool do_cov)\n{\n\tu32 nbF, i;\n\tGF_FieldInfo f;\n#ifndef GPAC_DISABLE_BIFS\n\tu8 qt, at;\n\tFixed bmin, bmax;\n\tu32 nbBits;\n#endif /*GPAC_DISABLE_BIFS*/\n\n\tnbF = gf_node_get_field_count(node);\n\n\tif (is_nodefield) {\n\t\tchar szField[1024];\n\t\tu32 tfirst, tlast;\n\t\tif (gf_node_get_field_by_name(node, szField, &f) != GF_OK) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Field %s is not a member of node %s\\n\", szField, name));\n\t\t\treturn;\n\t\t}\n\t\tfprintf(stderr, \"Allowed nodes in %s.%s:\\n\", name, szField);\n\t\tif (graph_type==1) {\n\t\t\ttfirst = GF_NODE_RANGE_FIRST_X3D;\n\t\t\ttlast = GF_NODE_RANGE_LAST_X3D;\n\t\t} else {\n\t\t\ttfirst = GF_NODE_RANGE_FIRST_MPEG4;\n\t\t\ttlast = GF_NODE_RANGE_LAST_MPEG4;\n\t\t}\n\t\tfor (i=tfirst; i<tlast; i++) {\n\t\t\tGF_Node *tmp = gf_node_new(sg, i);\n\t\t\tgf_node_register(tmp, NULL);\n\t\t\tif (gf_node_in_table_by_tag(i, f.NDTtype)) {\n\t\t\t\tconst char *nname = gf_node_get_class_name(tmp);\n\t\t\t\tif (nname && strcmp(nname, \"Unknown Node\")) {\n\t\t\t\t\tfprintf(stderr, \"\\t%s\\n\", nname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_node_unregister(tmp, NULL);\n\t\t}\n\t\treturn;\n\t}\n\tif (do_cov) {\n\t\tu32 ndt;\n\t\tif (graph_type==0) {\n\t\t\tu32 all;\n\t\t\tgf_node_mpeg4_type_by_class_name(name);\n\t\t\tgf_bifs_get_child_table(node);\n\t\t\tall = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\t\tfor (i=0; i<all; i++) {\n\t\t\t\tu32 res;\n\t\t\t\tgf_sg_script_get_field_index(node, i, GF_SG_FIELD_CODING_ALL, &res);\n\t\t\t}\n\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF);\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN);\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_OUT);\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DYN);\n\t\t}\n\t\telse if (graph_type==1) gf_node_x3d_type_by_class_name(name);\n\t\tfor (ndt=NDT_SFWorldNode; ndt<NDT_LAST; ndt++) {\n\t\t\tgf_node_in_table_by_tag(gf_node_get_tag(node), ndt);\n\t\t}\n\t}\n\tfprintf(stderr, \"%s {\\n\", name);\n\n\tfor (i=0; i<nbF; i++) {\n\t\tgf_node_get_field(node, i, &f);\n\t\tif (graph_type==2) {\n\t\t\tfprintf(stderr, \"\\t%s=\\\"...\\\"\\n\", f.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfprintf(stderr, \"\\t%s %s %s\", gf_sg_vrml_get_event_type_name(f.eventType, 0), gf_sg_vrml_get_field_type_name(f.fieldType), f.name);\n\t\tif (f.fieldType==GF_SG_VRML_SFNODE) fprintf(stderr, \" NULL\");\n\t\telse if (f.fieldType==GF_SG_VRML_MFNODE) fprintf(stderr, \" []\");\n\t\telse if (gf_sg_vrml_is_sf_field(f.fieldType)) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tPrintNodeSFField(f.fieldType, f.far_ptr);\n\t\t} else {\n\t\t\tvoid *ptr;\n\t\t\tu32 j, sftype;\n\t\t\tGenMFField *mffield = (GenMFField *) f.far_ptr;\n\t\t\tfprintf(stderr, \" [\");\n\t\t\tsftype = gf_sg_vrml_get_sf_type(f.fieldType);\n\t\t\tfor (j=0; j<mffield->count; j++) {\n\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\tgf_sg_vrml_mf_get_item(f.far_ptr, f.fieldType, &ptr, j);\n\t\t\t\tPrintNodeSFField(sftype, ptr);\n\t\t\t}\n\t\t\tfprintf(stderr, \"]\");\n\t\t}\n#ifndef GPAC_DISABLE_BIFS\n\t\tif (gf_bifs_get_aq_info(node, i, &qt, &at, &bmin, &bmax, &nbBits)) {\n\t\t\tif (qt) {\n\t\t\t\tfprintf(stderr, \" #QP=%d\", qt);\n\t\t\t\tif (qt==13) fprintf(stderr, \" NbBits=%d\", nbBits);\n\t\t\t\tif (bmin && bmax) {\n\t\t\t\t\tfprintf(stderr, \" Bounds=[\");\n\t\t\t\t\tPrintFixed(bmin, 0);\n\t\t\t\t\tfprintf(stderr, \",\");\n\t\t\t\t\tPrintFixed(bmax, 0);\n\t\t\t\t\tfprintf(stderr, \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /*GPAC_DISABLE_BIFS*/\n\t\tfprintf(stderr, \"\\n\");\n\n\t\tif (do_cov) {\n\t\t\tgf_node_get_field_by_name(node, (char *) f.name, &f);\n\t\t}\n\t}\n\tfprintf(stderr, \"}\\n\\n\");\n\n}\n#endif\n\n\nu32 PrintNode(const char *name, u32 graph_type)\n{\n#ifdef GPAC_DISABLE_VRML\n\tM4_LOG(GF_LOG_ERROR, (\"VRML/MPEG-4/X3D scene graph is disabled in this build of GPAC\\n\"));\n\treturn 2;\n#else\n\tconst char *std_name;\n\tGF_Node *node;\n\tGF_SceneGraph *sg;\n\tu32 tag;\n#ifndef GPAC_DISABLE_BIFS\n#endif /*GPAC_DISABLE_BIFS*/\n\tBool is_nodefield = 0;\n\n\tchar *sep = strchr(name, '.');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tis_nodefield = 1;\n\t}\n\n\tif (graph_type==1) {\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(name);\n\t\tstd_name = \"X3D\";\n#else\n\t\tM4_LOG(GF_LOG_ERROR, (\"X3D node printing is not supported (X3D support disabled)\\n\"));\n\t\treturn 2;\n#endif\n\t} else {\n\t\ttag = gf_node_mpeg4_type_by_class_name(name);\n\t\tstd_name = \"MPEG4\";\n\t}\n\tif (!tag) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unknown %s node %s\\n\", std_name, name));\n\t\treturn 2;\n\t}\n\n\tsg = gf_sg_new();\n\tnode = gf_node_new(sg, tag);\n\tgf_node_register(node, NULL);\n\tname = gf_node_get_class_name(node);\n\tif (!node) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Node %s not supported in current built\\n\", name));\n\t\treturn 2;\n\t}\n\tdo_print_node(node, sg, name, graph_type, is_nodefield, GF_FALSE);\n\n\tgf_node_unregister(node, NULL);\n\tgf_sg_del(sg);\n#endif /*GPAC_DISABLE_VRML*/\n\treturn 1;\n}\n\nu32 PrintBuiltInNodes(char *arg_val, u32 dump_type)\n{\n#if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D) && !defined(GPAC_DISABLE_SVG)\n\tGF_SceneGraph *sg;\n\tu32 i, nb_in, nb_not_in, start_tag, end_tag;\n\tu32 graph_type;\n\tBool dump_nodes = ((dump_type==1) || (dump_type==3)) ? 1 : 0;\n\n\tif (dump_type==4) graph_type = 2;\n\telse if ((dump_type==2) || (dump_type==3)) graph_type = 1;\n\telse graph_type = 0;\n\n\tif (graph_type==1) {\n#if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D)\n\t\tstart_tag = GF_NODE_RANGE_FIRST_X3D;\n\t\tend_tag = TAG_LastImplementedX3D;\n#else\n\t\tM4_LOG(GF_LOG_ERROR, (\"X3D scene graph disabled in this build of GPAC\\n\"));\n\t\treturn 2;\n#endif\n\t} else if (graph_type==2) {\n#ifdef GPAC_DISABLE_SVG\n\t\tM4_LOG(GF_LOG_ERROR, (\"SVG scene graph disabled in this build of GPAC\\n\"));\n\t\treturn 2;\n#else\n\t\tstart_tag = GF_NODE_RANGE_FIRST_SVG;\n\t\tend_tag = GF_NODE_RANGE_LAST_SVG;\n#endif\n\t} else {\n#ifdef GPAC_DISABLE_VRML\n\t\tM4_LOG(GF_LOG_ERROR, (\"VRML/MPEG-4 scene graph disabled in this build of GPAC\\n\"));\n\t\treturn 2;\n#else\n\t\tstart_tag = GF_NODE_RANGE_FIRST_MPEG4;\n\t\tend_tag = TAG_LastImplementedMPEG4;\n#endif\n\t}\n\tnb_in = nb_not_in = 0;\n\tsg = gf_sg_new();\n\n\tif (graph_type==1) {\n\t\tfprintf(stderr, \"Available X3D nodes in this build (dumping):\\n\");\n\t} else if (graph_type==2) {\n\t\tfprintf(stderr, \"Available SVG nodes in this build (dumping and LASeR coding):\\n\");\n\t} else {\n\t\tfprintf(stderr, \"Available MPEG-4 nodes in this build (encoding/decoding/dumping):\\n\");\n\t}\n\tfor (i=start_tag; i<end_tag; i++) {\n\t\tGF_Node *node = gf_node_new(sg, i);\n\t\tif (node) {\n\t\t\tgf_node_register(node, NULL);\n\t\t\tif (dump_nodes) {\n\t\t\t\tdo_print_node(node, sg, gf_node_get_class_name(node), graph_type, GF_FALSE, GF_TRUE);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \" %s\\n\", gf_node_get_class_name(node));\n\t\t\t}\n\t\t\tgf_node_unregister(node, NULL);\n\t\t\tnb_in++;\n\t\t} else {\n\t\t\tif (graph_type==2)\n\t\t\t\tbreak;\n\t\t\tnb_not_in++;\n\t\t}\n\t}\n\tgf_sg_del(sg);\n\tif (graph_type==2) {\n\t\tfprintf(stderr, \"\\n%d nodes supported\\n\", nb_in);\n\t} else {\n\t\tfprintf(stderr, \"\\n%d nodes supported - %d nodes not supported\\n\", nb_in, nb_not_in);\n\t}\n\t//coverage\n\tif (dump_nodes) {\n\t\tfor (i=GF_SG_VRML_SFBOOL; i<GF_SG_VRML_SCRIPT_FUNCTION; i++) {\n\t\t\tvoid *fp = gf_sg_vrml_field_pointer_new(i);\n\t\t\tif (fp) {\n\t\t\t\tif (i==GF_SG_VRML_SFSCRIPT) gf_free(fp);\n\t\t\t\telse gf_sg_vrml_field_pointer_del(fp, i);\n\t\t\t}\n\t\t}\n\n\t}\n#else\n\tM4_LOG(GF_LOG_ERROR, (\"No scene graph enabled in this MP4Box build\\n\"));\n#endif\n\treturn 1;\n}\n\n\nu32 PrintBuiltInBoxes(char *argval, u32 do_cov)\n{\n\tu32 i, count=gf_isom_get_num_supported_boxes();\n\t\n\tfprintf(stdout, \"<Boxes>\\n\");\n\t//index 0 is our internal unknown box handler\n\tfor (i=1; i<count; i++) {\n\t\tgf_isom_dump_supported_box(i, stdout);\n        if (do_cov) {\n\t\t\tu32 btype = gf_isom_get_supported_box_type(i);\n            GF_Box *b=gf_isom_box_new(btype);\n            if (b) {\n                GF_Box *c=NULL;\n                gf_isom_clone_box(b, &c);\n                if (c) gf_isom_box_del(c);\n                gf_isom_box_del(b);\n            }\n        }\n\t}\n\tfprintf(stdout, \"</Boxes>\\n\");\n\treturn 1;\n}\n\n#if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_ISOM_DUMP)\n\nvoid dump_isom_rtp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tu32 i, j, size;\n\tFILE *dump;\n\tconst char *sdp;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_rtp.xml\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tfprintf(dump, \"<!-- MP4Box RTP trace -->\\n\");\n\tfprintf(dump, \"<RTPFile>\\n\");\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\n\t\tfprintf(dump, \"<RTPHintTrack trackID=\\\"%d\\\">\\n\", gf_isom_get_track_id(file, i+1));\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"<SDPInfo>%s</SDPInfo>\", sdp);\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\tfor (j=0; j<gf_isom_get_sample_count(file, i+1); j++) {\n\t\t\tgf_isom_dump_hint_sample(file, i+1, j+1, dump);\n\t\t}\n#endif\n\t\tfprintf(dump, \"</RTPHintTrack>\\n\");\n\t}\n\tfprintf(dump, \"</RTPFile>\\n\");\n\tif (inName) gf_fclose(dump);\n}\n#endif\n\n\nvoid dump_isom_timestamps(GF_ISOFile *file, char *inName, Bool is_final_name, u32 dump_mode)\n{\n\tu32 i, j, k, count;\n\tBool has_ctts_error, is_fragmented=GF_FALSE;\n\tFILE *dump;\n\tBool skip_offset = ((dump_mode==2) || (dump_mode==4)) ? GF_TRUE : GF_FALSE;\n\tBool check_ts = ((dump_mode==3) || (dump_mode==4)) ? GF_TRUE : GF_FALSE;\n\tstruct _ts_info {\n\t\tu64 dts;\n\t\ts64 cts;\n\t};\n\tstruct _ts_info *timings = NULL;\n\tu32 nb_timings=0, nb_timings_alloc = 0;\n\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_ts.txt\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\tif (gf_isom_is_fragmented(file))\n\t\tis_fragmented = GF_TRUE;\n\n\thas_ctts_error = GF_FALSE;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\ts64 cts_dts_shift = gf_isom_get_cts_to_dts_shift(file, i+1);\n\t\tu32 has_cts_offset = gf_isom_has_time_offset(file, i+1);\n\n\t\tfprintf(dump, \"#dumping track ID %d timing:\\n\", gf_isom_get_track_id(file, i + 1));\n\t\tfprintf(dump, \"Num\\tDTS\\tCTS\\tSize\\tRAP%s\\tisLeading\\tDependsOn\\tDependedOn\\tRedundant\\tRAP-SampleGroup\\tRoll-SampleGroup\\tRoll-Distance\", skip_offset ? \"\" : \"\\tOffset\");\n\t\tif (is_fragmented) {\n\t\t\tfprintf(dump, \"\\tfrag_start\");\n\t\t}\n\t\tfprintf(dump, \"\\n\");\n\n\n\t\tcount = gf_isom_get_sample_count(file, i+1);\n\t\tif (has_cts_offset && check_ts) {\n\t\t\tif (nb_timings_alloc<count) {\n\t\t\t\tnb_timings_alloc = count;\n\t\t\t\ttimings = gf_realloc(timings, sizeof (struct _ts_info) * count);\n\t\t\t}\n\t\t\tnb_timings = 0;\n\t\t}\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\ts64 cts;\n\t\t\tu64 dts, offset;\n\t\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\t\tBool is_rap;\n\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\ts32 roll_distance;\n\t\t\tu32 index;\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample_info(file, i+1, j+1, &index, &offset);\n\t\t\tif (!samp) {\n\t\t\t\tfprintf(dump, \" SAMPLE #%d IN TRACK #%d NOT THERE !!!\\n\", j+1, i+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_isom_get_sample_flags(file, i+1, j+1, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\t\tgf_isom_get_sample_rap_roll_info(file, i+1, j+1, &is_rap, &roll_type, &roll_distance);\n\t\t\tdts = samp->DTS;\n\t\t\tcts = dts + (s32) samp->CTS_Offset;\n\t\t\tfprintf(dump, \"Sample %d\\tDTS \"LLU\"\\tCTS \"LLD\"\\t%d\\t%d\", j+1, dts, cts, samp->dataLength, samp->IsRAP);\n\n\t\t\tif (!skip_offset)\n\t\t\t\tfprintf(dump, \"\\t\"LLU, offset);\n\n\t\t\tfprintf(dump, \"\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", isLeading, dependsOn, dependedOn, redundant, is_rap, roll_type, roll_distance);\n\n\t\t\tif (cts< (s64) dts) {\n\t\t\t\tif (has_cts_offset==2) {\n\t\t\t\t\tif (cts_dts_shift && (cts+cts_dts_shift < (s64) dts)) {\n\t\t\t\t\t\tfprintf(dump, \" #NEGATIVE CTS OFFSET!!!\");\n\t\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t\t} else if (!cts_dts_shift) {\n\t\t\t\t\t\tfprintf(dump, \" #possible negative CTS offset (no cslg in file)\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(dump, \" #NEGATIVE CTS OFFSET!!!\");\n\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_cts_offset && check_ts) {\n\t\t\t\tfor (k=0; k<nb_timings; k++) {\n\n\t\t\t\t\tif (timings[k].dts==dts) {\n\t\t\t\t\t\tfprintf(dump, \" #SAME DTS USED!!!\");\n\t\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (timings[k].cts==cts) {\n\t\t\t\t\t\tfprintf(dump, \" #SAME CTS USED!!! \");\n\t\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttimings[nb_timings].dts = dts;\n\t\t\t\ttimings[nb_timings].cts = cts;\n\t\t\t\tnb_timings++;\n\t\t\t}\n\n\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\tif (is_fragmented) {\n\t\t\t\tfprintf(dump, \"\\t%d\", gf_isom_sample_is_fragment_start(file, i+1, j+1, NULL) );\n\t\t\t}\n\t\t\tfprintf(dump, \"\\n\");\n\t\t\tgf_set_progress(\"Dumping track timing\", j+1, count);\n\t\t}\n\t\tfprintf(dump, \"\\n\\n\");\n\t\tgf_set_progress(\"Dumping track timing\", count, count);\n\t}\n\tif (timings) gf_free(timings);\n\n\tif (inName) gf_fclose(dump);\n\tif (has_ctts_error) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"\\tFile has CTTS table errors\\n\"));\n\t}\n}\n\n\n\nstatic u32 read_nal_size_hdr(u8 *ptr, u32 nalh_size)\n{\n\tu32 nal_size=0;\n\tu32 v = nalh_size;\n\twhile (v) {\n\t\tnal_size |= (u8) *ptr;\n\t\tptr++;\n\t\tv-=1;\n\t\tif (v) nal_size <<= 8;\n\t}\n\treturn nal_size;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nvoid gf_inspect_dump_nalu(FILE *dump, u8 *ptr, u32 ptr_size, Bool is_svc, HEVCState *hevc, AVCState *avc, VVCState *vvc, u32 nalh_size, Bool dump_crc, Bool is_encrypted);\n#endif\n\n\nstatic void dump_isom_nal_ex(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, u32 dump_flags)\n{\n\tu32 i, j, count, nb_descs, track, nalh_size, timescale, cur_extract_mode;\n\ts32 countRef;\n\tBool is_adobe_protected = GF_FALSE;\n\tBool is_cenc_protected = GF_FALSE;\n\tBool is_hevc = GF_FALSE;\n\tBool is_vvc = GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAVCState *avc_state = NULL;\n\tHEVCState *hevc_state = NULL;\n\tVVCState *vvc_state = NULL;\n#endif\n\tGF_AVCConfig *avccfg, *svccfg;\n\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\tGF_VVCConfig *vvccfg;\n\tGF_NALUFFParam *slc;\n\tBool has_svcc = GF_FALSE;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\n\tcount = gf_isom_get_sample_count(file, track);\n\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\n\tnb_descs = gf_isom_get_sample_description_count(file, track);\n\tif (!nb_descs) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error: Track #%d has no sample description so is likely not NALU-based!\\n\", trackID));\n\t\treturn;\n\t}\n\n\tfprintf(dump, \"<NALUTrack trackID=\\\"%d\\\" SampleCount=\\\"%d\\\" TimeScale=\\\"%d\\\">\\n\", trackID, count, timescale);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define DUMP_ARRAY(arr, name, loc, _is_svc)\\\n\tif (arr) {\\\n\t\tfprintf(dump, \"  <%sArray location=\\\"%s\\\">\\n\", name, loc);\\\n\t\tfor (i=0; i<gf_list_count(arr); i++) {\\\n\t\t\tslc = gf_list_get(arr, i);\\\n\t\t\tfprintf(dump, \"   <NALU size=\\\"%d\\\" \", slc->size);\\\n\t\t\tgf_inspect_dump_nalu(dump, (u8 *) slc->data, slc->size, _is_svc, is_hevc ? hevc_state : NULL, avc_state, is_vvc ? vvc_state : NULL, nalh_size, (dump_flags&1) ? GF_TRUE : GF_FALSE, GF_FALSE);\\\n\t\t}\\\n\t\tfprintf(dump, \"  </%sArray>\\n\", name);\\\n\t}\\\n\n#else\n\n#define DUMP_ARRAY(arr, name, loc, _is_svc)\\\n\tif (arr) {\\\n\t\tfprintf(dump, \"  <%sArray location=\\\"%s\\\">\\n\", name, loc);\\\n\t\tfor (i=0; i<gf_list_count(arr); i++) {\\\n\t\t\tslc = gf_list_get(arr, i);\\\n\t\t\tfprintf(dump, \"   <NALU size=\\\"%d\\\" \", slc->size);\\\n\t\t\tfprintf(dump, \"/>\\n\");\\\n\t\t}\\\n\t\tfprintf(dump, \"  </%sArray>\\n\", name);\\\n\t}\\\n\n#endif\n\n\tnalh_size = 0;\n\n\tfor (j=0; j<nb_descs; j++) {\n\t\tGF_AVCConfig *mvccfg;\n\t\tBool is_svc;\n\n\t\tavccfg = gf_isom_avc_config_get(file, track, j+1);\n\t\tsvccfg = gf_isom_svc_config_get(file, track, j+1);\n\t\tmvccfg = gf_isom_mvc_config_get(file, track, j+1);\n\t\thevccfg = gf_isom_hevc_config_get(file, track, j+1);\n\t\tlhvccfg = gf_isom_lhvc_config_get(file, track, j+1);\n\t\tvvccfg = gf_isom_vvc_config_get(file, track, j+1);\n\n\t\tis_svc = (svccfg!=NULL) ? 1:0;\n\n\t\tif (hevccfg || lhvccfg) {\n\t\t\tis_hevc = 1;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_SAFEALLOC(hevc_state, HEVCState)\n#endif\n\t\t} else if (vvccfg) {\n\t\t\tis_vvc = 1;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_SAFEALLOC(vvc_state, VVCState)\n#endif\n\t\t} else if (avccfg || svccfg || mvccfg) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_SAFEALLOC(avc_state, AVCState)\n#endif\n\t\t}\n\n\n\t\t//for tile tracks the hvcC is stored in the 'tbas' track\n\t\tif (!hevccfg && gf_isom_get_reference_count(file, track, GF_ISOM_REF_TBAS)) {\n\t\t\tu32 tk = 0;\n\t\t\tgf_isom_get_reference(file, track, GF_ISOM_REF_TBAS, 1, &tk);\n\t\t\thevccfg = gf_isom_hevc_config_get(file, tk, 1);\n\t\t}\n\n\t\tfprintf(dump, \" <NALUConfig>\\n\");\n\n\t\tif (!avccfg && !svccfg && !hevccfg && !lhvccfg && !vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error: Track #%d is not NALU or OBU based!\\n\", trackID));\n\t\t\treturn;\n\t\t}\n\n\t\tif (avccfg) {\n\t\t\tnalh_size = avccfg->nal_unit_size;\n\n\t\t\tDUMP_ARRAY(avccfg->sequenceParameterSets, \"AVCSPS\", \"avcC\", is_svc);\n\t\t\tDUMP_ARRAY(avccfg->pictureParameterSets, \"AVCPPS\", \"avcC\", is_svc)\n\t\t\tDUMP_ARRAY(avccfg->sequenceParameterSetExtensions, \"AVCSPSEx\", \"avcC\", is_svc)\n\t\t}\n\t\tif (is_svc) {\n\t\t\tif (!nalh_size) nalh_size = svccfg->nal_unit_size;\n\t\t\tDUMP_ARRAY(svccfg->sequenceParameterSets, \"SVCSPS\", \"svcC\", is_svc)\n\t\t\tDUMP_ARRAY(svccfg->pictureParameterSets, \"SVCPPS\", \"svcC\", is_svc)\n\t\t}\n\t\tif (mvccfg) {\n\t\t\tif (!nalh_size) nalh_size = mvccfg->nal_unit_size;\n\t\t\tDUMP_ARRAY(mvccfg->sequenceParameterSets, \"SVCSPS\", \"mvcC\", is_svc)\n\t\t\tDUMP_ARRAY(mvccfg->pictureParameterSets, \"SVCPPS\", \"mvcC\", is_svc)\n\t\t}\n\t\tif (hevccfg) {\n\t\t\tu32 idx;\n\t\t\tnalh_size = hevccfg->nal_unit_size;\n\t\t\tfor (idx=0; idx<gf_list_count(hevccfg->param_array); idx++) {\n\t\t\t\tGF_NALUFFParamArray *ar = gf_list_get(hevccfg->param_array, idx);\n\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCSPS\", \"hvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCPPS\", \"hvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCVPS\", \"hvcC\", 0)\n\t\t\t\t} else {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCUnknownPS\", \"hvcC\", 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (vvccfg) {\n\t\t\tu32 idx;\n\t\t\tnalh_size = vvccfg->nal_unit_size;\n\t\t\tfor (idx=0; idx<gf_list_count(vvccfg->param_array); idx++) {\n\t\t\t\tGF_NALUFFParamArray *ar = gf_list_get(vvccfg->param_array, idx);\n\t\t\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCSPS\", \"vvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_VVC_NALU_PIC_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCPPS\", \"vvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_VVC_NALU_VID_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCVPS\", \"vvcC\", 0)\n\t\t\t\t} else {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCUnknownPS\", \"vvcC\", 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lhvccfg) {\n\t\t\tu32 idx;\n\t\t\tnalh_size = lhvccfg->nal_unit_size;\n\t\t\tfor (idx=0; idx<gf_list_count(lhvccfg->param_array); idx++) {\n\t\t\t\tGF_NALUFFParamArray *ar = gf_list_get(lhvccfg->param_array, idx);\n\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCSPS\", \"lhcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCPPS\", \"lhcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCVPS\", \"lhcC\", 0)\n\t\t\t\t} else {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCUnknownPS\", \"lhcC\", 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(dump, \" </NALUConfig>\\n\");\n\n\t\tif (avccfg) gf_odf_avc_cfg_del(avccfg);\n\t\tif (svccfg) {\n\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\thas_svcc = GF_TRUE;\n\t\t}\n\t\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\t\tif (vvccfg) gf_odf_vvc_cfg_del(vvccfg);\n\t\tif (lhvccfg) gf_odf_hevc_cfg_del(lhvccfg);\n\t}\n\n\t/*fixme: for dumping encrypted track: we don't have neither avccfg nor svccfg*/\n\tif (!nalh_size) nalh_size = 4;\n\n\t/*for testing dependency*/\n\tcountRef = gf_isom_get_reference_count(file, track, GF_ISOM_REF_SCAL);\n\tif (countRef > 0)\n\t{\n\t\tGF_ISOTrackID refTrackID;\n\t\tfprintf(dump, \" <SCALReferences>\\n\");\n\t\tfor (i = 1; i <= (u32) countRef; i++)\n\t\t{\n\t\t\tgf_isom_get_reference_ID(file, track, GF_ISOM_REF_SCAL, i, &refTrackID);\n\t\t\tfprintf(dump, \"  <SCALReference number=\\\"%d\\\" refTrackID=\\\"%d\\\"/>\\n\", i, refTrackID);\n\t\t}\n\n\t\tfprintf(dump, \" </SCALReferences>\\n\");\n\t}\n\n\tfprintf(dump, \" <NALUSamples>\\n\");\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tis_adobe_protected = gf_isom_is_adobe_protection_media(file, track, 1);\n\tis_cenc_protected = gf_isom_is_cenc_media(file, track, 1);\n\tfor (i=0; i<count; i++) {\n\t\tu64 dts, cts;\n\t\tBool is_rap;\n\t\tu32 size, nal_size, idx, di;\n\t\tu8 *ptr;\n\t\tGF_ISOSample *samp = gf_isom_get_sample(file, track, i+1, &di);\n\t\tif (!samp) {\n\t\t\tfprintf(dump, \"<!-- Unable to fetch sample %d -->\\n\", i+1);\n\t\t\tcontinue;\n\t\t}\n\t\tdts = samp->DTS;\n\t\tcts = dts + (s32) samp->CTS_Offset;\n\t\tis_rap = samp->IsRAP;\n\t\tif (!is_rap) gf_isom_get_sample_rap_roll_info(file, track, i+1, &is_rap, NULL, NULL);\n\n\t\tif (dump_flags&2) {\n\t\t\tfprintf(dump, \"  <Sample size=\\\"%d\\\" RAP=\\\"%d\\\"\", samp->dataLength, is_rap);\n\t\t} else {\n\t\t\tfprintf(dump, \"  <Sample DTS=\\\"\"LLD\"\\\" CTS=\\\"\"LLD\"\\\" size=\\\"%d\\\" RAP=\\\"%d\\\"\", dts, cts, samp->dataLength, is_rap);\n\t\t}\n\t\tif (nb_descs>1)\n\t\t\tfprintf(dump, \" sample_description=\\\"%d\\\"\", di);\n\t\tfprintf(dump, \" >\\n\");\n\n\t\tif (cts<dts) fprintf(dump, \"<!-- NEGATIVE CTS OFFSET! -->\\n\");\n\n\t\tidx = 1;\n\t\tptr = samp->data;\n\t\tsize = samp->dataLength;\n\t\tif (is_adobe_protected) {\n\t\t\tu8 encrypted_au = ptr[0];\n\t\t\tif (encrypted_au) {\n\t\t\t\tfprintf(dump, \"   <!-- Sample number %d is an Adobe's protected sample: can not be dumped -->\\n\", i+1);\n\t\t\t\tfprintf(dump, \"  </Sample>\\n\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tptr++;\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\twhile (size) {\n\t\t\tnal_size = read_nal_size_hdr(ptr, nalh_size);\n\t\t\tptr += nalh_size;\n\n\t\t\tif (nal_size >= UINT_MAX-nalh_size || nalh_size + nal_size > size) {\n\t\t\t\tfprintf(dump, \"   <!-- NALU number %d is corrupted: size is %d but only %d remains -->\\n\", idx, nal_size, size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfprintf(dump, \"   <NALU size=\\\"%d\\\" \", nal_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tBool is_encrypted = 0;\n\t\t\t\tif (is_cenc_protected) {\n\t\t\t\t\tGF_Err e = gf_isom_get_sample_cenc_info(file, track, i + 1, &is_encrypted, NULL, NULL, NULL, NULL);\n\t\t\t\t\tif (e != GF_OK) {\n\t\t\t\t\t\tfprintf(dump, \"dump_msg=\\\"Error %s while fetching encryption info for sample, assuming sample is encrypted\\\" \", gf_error_to_string(e) );\n\t\t\t\t\t\tis_encrypted = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_inspect_dump_nalu(dump, ptr, nal_size, has_svcc ? 1 : 0, hevc_state, avc_state, vvc_state, nalh_size, dump_flags, is_encrypted);\n#else\n\t\t\t\tfprintf(dump, \"/>\\n\");\n#endif\n\t\t\t}\n\t\t\tidx++;\n\t\t\tptr+=nal_size;\n\t\t\tsize -= nal_size + nalh_size;\n\t\t}\n\t\tfprintf(dump, \"  </Sample>\\n\");\n\t\tgf_isom_sample_del(&samp);\n\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"Analysing Track NALUs\", i+1, count);\n\t}\n\tfprintf(dump, \" </NALUSamples>\\n\");\n\tfprintf(dump, \"</NALUTrack>\\n\");\n\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (hevc_state) gf_free(hevc_state);\n\tif (vvc_state) gf_free(vvc_state);\n\tif (avc_state) gf_free(avc_state);\n#endif\n}\n\nstatic void dump_isom_obu(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, Bool dump_crc);\nstatic void dump_qt_prores(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, Bool dump_crc);\n\nvoid dump_isom_nal(GF_ISOFile *file, GF_ISOTrackID trackID, char *inName, Bool is_final_name, u32 dump_flags)\n{\n\tBool is_av1 = GF_FALSE;\n\tBool is_prores = GF_FALSE;\n\n\tFILE *dump;\n\tif (inName) {\n\t\tGF_ESD* esd;\n\t\tchar szBuf[GF_MAX_PATH];\n\n\t\tstrcpy(szBuf, inName);\n\n\t\tu32 track = gf_isom_get_track_by_id(file, trackID);\n\t\tesd = gf_isom_get_esd(file, track, 1);\n\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tswitch (gf_isom_get_media_subtype(file, track, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_AV01:\n\t\t\t\tis_av1 = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_QT_SUBTYPE_APCH:\n\t\t\tcase GF_QT_SUBTYPE_APCO:\n\t\t\tcase GF_QT_SUBTYPE_APCN:\n\t\t\tcase GF_QT_SUBTYPE_APCS:\n\t\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\t\t\tis_prores = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (esd->decoderConfig->objectTypeIndication == GF_CODECID_AV1) {\n\t\t\tis_av1 = GF_TRUE;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\n\t\tif (!is_final_name) sprintf(szBuf, \"%s_%d_%s.xml\", inName, trackID, is_av1 ? \"obu\" : \"nalu\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tif (is_av1)\n\t\tdump_isom_obu(file, trackID, dump, dump_flags);\n\telse if (is_prores)\n\t\tdump_qt_prores(file, trackID, dump, dump_flags);\n\telse\n\t\tdump_isom_nal_ex(file, trackID, dump, dump_flags);\n\n\tif (inName) gf_fclose(dump);\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nvoid gf_inspect_dump_obu(FILE *dump, AV1State *av1, u8 *obu, u64 obu_length, ObuType obu_type, u64 obu_size, u32 hdr_size, Bool dump_crc);\n#endif\n\nstatic void dump_isom_obu(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, Bool dump_crc)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 i, count, track, timescale;\n\tAV1State av1;\n\tObuType obu_type;\n\tu64 obu_size;\n\tu32 hdr_size;\n\tGF_BitStream *bs;\n\tu32 idx;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\n\tgf_av1_init_state(&av1);\n\tav1.config = gf_isom_av1_config_get(file, track, 1);\n\tif (!av1.config) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error: Track #%d is not AV1!\\n\", trackID));\n\t\treturn;\n\t}\n\n\tcount = gf_isom_get_sample_count(file, track);\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\n\tfprintf(dump, \"<OBUTrack trackID=\\\"%d\\\" SampleCount=\\\"%d\\\" TimeScale=\\\"%d\\\">\\n\", trackID, count, timescale);\n\n\tfprintf(dump, \" <OBUConfig>\\n\");\n\n\tfor (i=0; i<gf_list_count(av1.config->obu_array); i++) {\n\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1.config->obu_array, i);\n\t\tbs = gf_bs_new(obu->obu, (u32) obu->obu_length, GF_BITSTREAM_READ);\n\t\tgf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\tgf_inspect_dump_obu(dump, &av1, obu->obu, obu->obu_length, obu_type, obu_size, hdr_size, dump_crc);\n\t\tgf_bs_del(bs);\n\t}\n\tfprintf(dump, \" </OBUConfig>\\n\");\n\n\tfprintf(dump, \" <OBUSamples>\\n\");\n\n\tfor (i=0; i<count; i++) {\n\t\tu64 dts, cts;\n\t\tu32 size;\n\t\tu8 *ptr;\n\t\tGF_ISOSample *samp = gf_isom_get_sample(file, track, i+1, NULL);\n\t\tif (!samp) {\n\t\t\tfprintf(dump, \"<!-- Unable to fetch sample %d -->\\n\", i+1);\n\t\t\tcontinue;\n\t\t}\n\t\tdts = samp->DTS;\n\t\tcts = dts + (s32) samp->CTS_Offset;\n\n\t\tfprintf(dump, \"  <Sample number=\\\"%d\\\" DTS=\\\"\"LLD\"\\\" CTS=\\\"\"LLD\"\\\" size=\\\"%d\\\" RAP=\\\"%d\\\" >\\n\", i+1, dts, cts, samp->dataLength, samp->IsRAP);\n\t\tif (cts<dts) fprintf(dump, \"<!-- NEGATIVE CTS OFFSET! -->\\n\");\n\n\t\tidx = 1;\n\t\tptr = samp->data;\n\t\tsize = samp->dataLength;\n\n\t\tbs = gf_bs_new(ptr, size, GF_BITSTREAM_READ);\n\t\twhile (size) {\n\t\t\tgf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\t\tif (obu_size > size) {\n\t\t\t\tfprintf(dump, \"   <!-- OBU number %d is corrupted: size is %d but only %d remains -->\\n\", idx, (u32) obu_size, size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_inspect_dump_obu(dump, &av1, ptr, obu_size, obu_type, obu_size, hdr_size, dump_crc);\n\t\t\tptr += obu_size;\n\t\t\tsize -= (u32)obu_size;\n\t\t\tidx++;\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tfprintf(dump, \"  </Sample>\\n\");\n\t\tgf_isom_sample_del(&samp);\n\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"Analysing Track OBUs\", i+1, count);\n\t}\n\tfprintf(dump, \" </OBUSamples>\\n\");\n\tfprintf(dump, \"</OBUTrack>\\n\");\n\n\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\tgf_av1_reset_state(&av1, GF_TRUE);\n#endif\n}\n\nstatic void dump_qt_prores(GF_ISOFile *file, u32 trackID, FILE *dump, Bool dump_crc)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 i, count, track, timescale;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\n\tcount = gf_isom_get_sample_count(file, track);\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\n\tfprintf(dump, \"<ProResTrack trackID=\\\"%d\\\" SampleCount=\\\"%d\\\" TimeScale=\\\"%d\\\">\\n\", trackID, count, timescale);\n\n\tfor (i=0; i<count; i++) {\n\t\tvoid gf_inspect_dump_prores(FILE *dump, u8 *ptr, u64 frame_size, Bool dump_crc);\n\t\tu64 dts, cts;\n\t\tGF_ISOSample *samp = gf_isom_get_sample(file, track, i+1, NULL);\n\t\tif (!samp) {\n\t\t\tfprintf(dump, \"<!-- Unable to fetch sample %d -->\\n\", i+1);\n\t\t\tcontinue;\n\t\t}\n\t\tdts = samp->DTS;\n\t\tcts = dts + (s32) samp->CTS_Offset;\n\n\t\tif (cts!=dts) fprintf(dump, \"<!-- Wrong timing info (CTS \"LLD\" vs DTS \"LLD\") ! -->\\n\", cts, dts);\n\t\tif (!samp->IsRAP) fprintf(dump, \"<!-- Wrong sync sample info, sample is not SAP1 ! -->\\n\");\n\n\t\tfprintf(dump, \"  <Sample number=\\\"%d\\\" CTS=\\\"\"LLD\"\\\" size=\\\"%d\\\">\\n\", i+1, cts, samp->dataLength);\n\n\t\tgf_inspect_dump_prores(dump, samp->data, samp->dataLength, dump_crc);\n\t\tfprintf(dump, \"  </Sample>\\n\");\n\n\t\tgf_isom_sample_del(&samp);\n\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"Analysing ProRes Track\", i+1, count);\n\t}\n\tfprintf(dump, \"</ProResTrack>\\n\");\n#endif\n}\n\nvoid dump_isom_saps(GF_ISOFile *file, GF_ISOTrackID trackID, u32 dump_saps_mode, char *inName, Bool is_final_name)\n{\n\tFILE *dump;\n\tu32 i, count;\n\ts64 media_offset=0;\n\tu32 track = gf_isom_get_track_by_id(file, trackID);\n\tif (inName) {\n\t\tchar szBuf[GF_MAX_PATH];\n\t\tstrcpy(szBuf, inName);\n\n\t\tif (!is_final_name) sprintf(szBuf, \"%s_%d_cues.xml\", inName, trackID);\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tfprintf(dump, \"<DASHCues xmlns=\\\"urn:gpac:dash:schema:cues:2018\\\">\\n\");\n\tfprintf(dump, \"<Stream id=\\\"%d\\\" timescale=\\\"%d\\\"\", trackID, gf_isom_get_media_timescale(file, track) );\n\tif (dump_saps_mode==4) {\n\t\tfprintf(dump, \" mode=\\\"edit\\\"\");\n\t\tgf_isom_get_edit_list_type(file, track, &media_offset);\n\t}\n\tfprintf(dump, \">\\n\");\n\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\ts64 cts, dts;\n\t\tu32 di;\n\t\tBool traf_start = 0;\n\t\tu32 sap_type = 0;\n\t\tu64 doffset;\n\t\t\n\t\tGF_ISOSample *samp = gf_isom_get_sample_info(file, track, i+1, &di, &doffset);\n\n\t\ttraf_start = gf_isom_sample_is_fragment_start(file, track, i+1, NULL);\n\n\t\tsap_type = samp->IsRAP;\n\t\tif (!sap_type) {\n\t\t\tBool is_rap;\n\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\ts32 roll_dist;\n\t\t\tgf_isom_get_sample_rap_roll_info(file, track, i+1, &is_rap, &roll_type, &roll_dist);\n\t\t\tif (roll_type) sap_type = SAP_TYPE_4;\n\t\t\telse if (is_rap)  sap_type = SAP_TYPE_3;\n\t\t}\n\n\t\tif (!sap_type) {\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdts = cts = samp->DTS;\n\t\tcts += samp->CTS_Offset;\n\t\tfprintf(dump, \"<Cue sap=\\\"%d\\\"\", sap_type);\n\t\tif (dump_saps_mode==4) {\n\t\t\tcts += media_offset;\n\t\t\tfprintf(dump, \" cts=\\\"\"LLD\"\\\"\", cts);\n\t\t} else {\n\t\t\tif (!dump_saps_mode || (dump_saps_mode==1)) fprintf(dump, \" sample=\\\"%d\\\"\", i+1);\n\t\t\tif (!dump_saps_mode || (dump_saps_mode==2)) fprintf(dump, \" cts=\\\"\"LLD\"\\\"\", cts);\n\t\t\tif (!dump_saps_mode || (dump_saps_mode==3)) fprintf(dump, \" dts=\\\"\"LLD\"\\\"\", dts);\n\t\t}\n\n\t\tif (traf_start)\n\t\t\tfprintf(dump, \" wasFragStart=\\\"yes\\\"\");\n\n\t\tfprintf(dump, \"/>\\n\");\n\n\t\tgf_isom_sample_del(&samp);\n\t}\n\tfprintf(dump, \"</Stream>\\n\");\n\tfprintf(dump, \"</DASHCues>\\n\");\n\tif (inName) gf_fclose(dump);\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nvoid dump_isom_ismacryp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tu32 i, j;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_ismacryp.xml\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tfprintf(dump, \"<!-- MP4Box ISMACryp trace -->\\n\");\n\tfprintf(dump, \"<ISMACrypFile>\\n\");\n\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_subtype(file, i+1, 1) != GF_ISOM_SUBTYPE_MPEG4_CRYP) continue;\n\n\t\tgf_isom_dump_ismacryp_protection(file, i+1, dump);\n\n\t\tfprintf(dump, \"<ISMACrypTrack trackID=\\\"%d\\\">\\n\", gf_isom_get_track_id(file, i+1));\n\t\tfor (j=0; j<gf_isom_get_sample_count(file, i+1); j++) {\n\t\t\tgf_isom_dump_ismacryp_sample(file, i+1, j+1, dump);\n\t\t}\n\t\tfprintf(dump, \"</ISMACrypTrack >\\n\");\n\t}\n\tfprintf(dump, \"</ISMACrypFile>\\n\");\n\tif (inName) gf_fclose(dump);\n}\n\n\nvoid dump_isom_timed_text(GF_ISOFile *file, GF_ISOTrackID trackID, char *inName, Bool is_final_name, Bool is_convert, GF_TextDumpType dump_type)\n{\n\tFILE *dump;\n\tGF_Err e;\n\tu32 track;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\tif (!track) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot find track ID %d\\n\", trackID));\n\t\treturn;\n\t}\n\n\tswitch (gf_isom_get_media_type(file, track)) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\tM4_LOG(GF_LOG_ERROR, (\"Track ID %d is not a 3GPP text track\\n\", trackID));\n\t\treturn;\n\t}\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tchar *ext;\n\t\text = ((dump_type==GF_TEXTDUMPTYPE_SVG) ? \"svg\" : ((dump_type==GF_TEXTDUMPTYPE_SRT) ? \"srt\" : \"ttxt\"));\n\t\tif (is_final_name) {\n\t\t\tstrcpy(szBuf, inName) ;\n\t\t} else if (is_convert)\n\t\t\tsprintf(szBuf, \"%s.%s\", inName, ext) ;\n\t\telse\n\t\t\tsprintf(szBuf, \"%s_%d_text.%s\", inName, trackID, ext);\n\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\te = gf_isom_text_dump(file, track, dump, dump_type);\n\tif (inName) gf_fclose(dump);\n\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Conversion failed (%s)\\n\", gf_error_to_string(e)));\n\t} else {\n\t\tfprintf(stderr, \"Conversion done\\n\");\n\t}\n}\n\n#endif /*GPAC_DISABLE_ISOM_DUMP*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"# File SDP content \\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tif (sdp && size)\n\t\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");\n\tif (inName) gf_fclose(dump);\n}\n\n#endif\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err dump_isom_xml(GF_ISOFile *file, char *inName, Bool is_final_name, Bool do_track_dump, Bool merge_vtt_cues, Bool skip_init, Bool skip_samples)\n{\n\tGF_Err e;\n\tFILE *dump = stdout;\n\tBool do_close=GF_FALSE;\n\tif (!file) return GF_ISOM_INVALID_FILE;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tstrcat(szBuf, do_track_dump ? \"_dump.xml\" : \"_info.xml\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tdo_close=GF_TRUE;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tif (do_track_dump) {\n\t\tfprintf(dump, \"<ISOBaseMediaFileTrace>\\n\");\n\t}\n\te = gf_isom_dump(file, dump, skip_init, skip_samples);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error dumping ISO structure\\n\"));\n\t}\n\n\tif (do_track_dump) {\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\t\tu32 i;\n\t\t//because of dump mode we need to reopen in regular read mode to avoid mem leaks\n\t\tGF_ISOFile *the_file = gf_isom_open(gf_isom_get_filename(file), GF_ISOM_OPEN_READ, NULL);\n\t\tu32 tcount = gf_isom_get_track_count(the_file);\n\t\tfprintf(dump, \"<Tracks>\\n\");\n\n\t\tfor (i=0; i<tcount; i++) {\n\t\t\tGF_MediaExporter dumper;\n\t\t\tGF_ISOTrackID trackID = gf_isom_get_track_id(the_file, i+1);\n\t\t\tu32 mtype = gf_isom_get_media_type(the_file, i+1);\n\t\t\tu32 msubtype = gf_isom_get_media_subtype(the_file, i+1, 1);\n\t\t\tBool fmt_handled = GF_FALSE;\n\t\t\tmemset(&dumper, 0, sizeof(GF_MediaExporter));\n\t\t\tdumper.file = the_file;\n\t\t\tdumper.trackID = trackID;\n\t\t\tdumper.dump_file = dump;\n\n\t\t\tif (mtype == GF_ISOM_MEDIA_HINT) {\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\t\t\tchar *name=NULL;\n\t\t\t\tif (msubtype==GF_ISOM_SUBTYPE_RTP) name = \"RTPHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_SRTP) name = \"SRTPHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_RRTP) name = \"RTPReceptionHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_RTCP) name = \"RTCPReceptionHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_FLUTE) name = \"FLUTEReceptionHintTrack\";\n\t\t\t\telse name = \"UnknownHintTrack\";\n\n\t\t\t\tfprintf(dump, \"<%s trackID=\\\"%d\\\">\\n\", name, trackID);\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\t\t\tu32 j, scount=gf_isom_get_sample_count(the_file, i+1);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tgf_isom_dump_hint_sample(the_file, i+1, j+1, dump);\n\t\t\t\t}\n#endif\n\t\t\t\tfprintf(dump, \"</%s>\\n\", name);\n\t\t\t\tfmt_handled = GF_TRUE;\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\t\t\t}\n\t\t\telse if (gf_isom_get_avc_svc_type(the_file, i+1, 1) || gf_isom_get_hevc_lhvc_type(the_file, i+1, 1)) {\n\t\t\t\tdump_isom_nal_ex(the_file, trackID, dump, GF_FALSE);\n\t\t\t\tfmt_handled = GF_TRUE;\n\t\t\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) ) {\n\n\t\t\t\tif (msubtype==GF_ISOM_SUBTYPE_WVTT) {\n\t\t\t\t\tgf_webvtt_dump_iso_track(&dumper, i+1, merge_vtt_cues, GF_TRUE);\n\t\t\t\t\tfmt_handled = GF_TRUE;\n\t\t\t\t} else if ((msubtype==GF_ISOM_SUBTYPE_TX3G) || (msubtype==GF_ISOM_SUBTYPE_TEXT)) {\n\t\t\t\t\tgf_isom_text_dump(the_file, i+1, dump, GF_TEXTDUMPTYPE_TTXT_BOXES);\n\t\t\t\t\tfmt_handled = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!fmt_handled) {\n\t\t\t\tdumper.flags = GF_EXPORT_NHML | GF_EXPORT_NHML_FULL;\n\t\t\t\tdumper.print_stats_graph = fs_dump_flags;\n\t\t\t\tgf_media_export(&dumper);\n\t\t\t}\n\t\t}\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif /*GPAC_DISABLE_MEDIA_EXPORT*/\n\t\tgf_isom_delete(the_file);\n\t\tfprintf(dump, \"</Tracks>\\n\");\n\t\tfprintf(dump, \"</ISOBaseMediaFileTrace>\\n\");\n\t}\n\tif (do_close) gf_fclose(dump);\n\treturn e;\n}\n#endif\n\n\nstatic char *format_duration(u64 dur, u32 timescale, char *szDur)\n{\n\tu32 h, m, s, ms;\n\tif ((dur==(u64) -1) || (dur==(u32) -1))  {\n\t\tstrcpy(szDur, \"Unknown\");\n\t\treturn szDur;\n\t}\n\tdur = (u64) (( ((Double) (s64) dur)/timescale)*1000);\n\th = (u32) (dur / 3600000);\n\tm = (u32) (dur/ 60000) - h*60;\n\ts = (u32) (dur/1000) - h*3600 - m*60;\n\tms = (u32) (dur) - h*3600000 - m*60000 - s*1000;\n\tif (h<=24) {\n\t\tsprintf(szDur, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\t} else {\n\t\tu32 d = (u32) (dur / 3600000 / 24);\n\t\th = (u32) (dur/3600000)-24*d;\n\t\tif (d<=365) {\n\t\t\tsprintf(szDur, \"%d Days, %02d:%02d:%02d.%03d\", d, h, m, s, ms);\n\t\t} else {\n\t\t\tu32 y=0;\n\t\t\twhile (d>365) {\n\t\t\t\ty++;\n\t\t\t\td-=365;\n\t\t\t\tif (y%4) d--;\n\t\t\t}\n\t\t\tsprintf(szDur, \"%d Years %d Days, %02d:%02d:%02d.%03d\", y, d, h, m, s, ms);\n\t\t}\n\n\t}\n\treturn szDur;\n}\n\nstatic char *format_date(u64 time, char *szTime)\n{\n\ttime_t now;\n\tif (!time) {\n\t\tstrcpy(szTime, \"UNKNOWN DATE\");\n\t} else {\n\t\ttime -= 2082844800;\n\t\tnow = (u32) time;\n\t\tsprintf(szTime, \"GMT %s\", asctime(gf_gmtime(&now)) );\n\t}\n\treturn szTime;\n}\n\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\nGF_Err dump_isom_udta(GF_ISOFile *file, char *inName, Bool is_final_name, u32 dump_udta_type, u32 dump_udta_track)\n{\n\tu8 *data;\n\tFILE *t;\n\tbin128 uuid;\n\tu32 count, res;\n\tGF_Err e;\n\n\tmemset(uuid, 0, 16);\n\tcount = gf_isom_get_user_data_count(file, dump_udta_track, dump_udta_type, uuid);\n\tif (!count) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No UDTA for type %s found\\n\", gf_4cc_to_str(dump_udta_type) ));\n\t\treturn GF_NOT_FOUND;\n\t}\n\n\tdata = NULL;\n\tcount = 0;\n\te = gf_isom_get_user_data(file, dump_udta_track, dump_udta_type, uuid, 0, &data, &count);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error dumping UDTA %s: %s\\n\", gf_4cc_to_str(dump_udta_type), gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tif (inName) {\n\t\tchar szName[1024];\n\t\tif (is_final_name)\n\t\t\tstrcpy(szName, inName);\n\t\telse\n\t\t\tsprintf(szName, \"%s_%s.udta\", inName, gf_4cc_to_str(dump_udta_type) );\n\n\t\tt = gf_fopen(szName, \"wb\");\n\t\tif (!t) {\n\t\t\tgf_free(data);\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open file %s\\n\", szName ));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t} else {\n\t\tt = stdout;\n\t}\n\tres = (u32) gf_fwrite(data+8, count-8, t);\n\tif (inName) gf_fclose(t);\n\tgf_free(data);\n\tif (count-8 != res) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error writing udta to file\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err dump_isom_chapters(GF_ISOFile *file, char *inName, Bool is_final_name, u32 dump_mode)\n{\n\tFILE *t;\n\tu32 i, count;\n\tu32 chap_tk = 0;\n\tcount = gf_isom_get_chapter_count(file, 0);\n\n\tif (dump_mode==2) dump_mode = GF_TEXTDUMPTYPE_OGG_CHAP;\n\telse if (dump_mode==3) dump_mode = GF_TEXTDUMPTYPE_ZOOM_CHAP;\n\telse dump_mode = GF_TEXTDUMPTYPE_TTXT_CHAP;\n\n\tif (!count) {\n\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_CHAP)) {\n\t\t\t\tGF_Err e = gf_isom_get_reference(file, i+1, GF_ISOM_REF_CHAP, 1, &chap_tk);\n\t\t\t\tif (!e) break;\n\t\t\t}\n\t\t}\n\t\tif (!chap_tk) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"No chapters or chapters track found in file\\n\"));\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tfprintf(stderr, \"Dumping chapter track %d\\n\", chap_tk);\n\t\tdump_isom_timed_text(file, gf_isom_get_track_id(file, chap_tk), inName, is_final_name, GF_FALSE, dump_mode);\n\t\treturn GF_OK;\n\n\t}\n\tif (inName) {\n\t\tchar szName[1024];\n\t\tstrcpy(szName, inName);\n\t\tif (!is_final_name) {\n\t\t\tif (dump_mode==GF_TEXTDUMPTYPE_OGG_CHAP) {\n\t\t\t\tstrcat(szName, \".txt\");\n\t\t\t} else if (dump_mode==GF_TEXTDUMPTYPE_ZOOM_CHAP) {\n\t\t\t\tstrcat(szName, \".txt\");\n\t\t\t} else {\n\t\t\t\tstrcat(szName, \".ttxt\");\n\t\t\t}\n\t\t}\n\t\tt = gf_fopen(szName, \"wt\");\n\t\tif (!t) return GF_IO_ERR;\n\t} else {\n\t\tt = stdout;\n\t}\n\n\tif (dump_mode==GF_TEXTDUMPTYPE_TTXT_CHAP) {\n\t\tfprintf(t, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tfprintf(t, \"<TextStream version=\\\"1.1\\\">\\n\");\n\t\tfprintf(t, \"<TextStreamHeader width=\\\"0\\\" height=\\\"0\\\" layer=\\\"0\\\" translation_x=\\\"0\\\" translation_y=\\\"0\\\">\\n\");\n\t\tfprintf(t, \"<TextSampleDescription horizontalJustification=\\\"left\\\" backColor=\\\"0 0 0\\\" scroll=\\\"None\\\"/>\\n\");\n\t\tfprintf(t, \"</TextStreamHeader>\\n\");\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tchar szDur[20];\n\t\tu64 chapter_time;\n\t\tconst char *name;\n\t\tgf_isom_get_chapter(file, 0, i+1, &chapter_time, &name);\n\t\tif (dump_mode==GF_TEXTDUMPTYPE_OGG_CHAP) {\n\t\t\tfprintf(t, \"CHAPTER%02d=%s\\n\", i+1, format_duration(chapter_time, 1000, szDur));\n\t\t\tfprintf(t, \"CHAPTER%02dNAME=%s\\n\", i+1, name);\n\t\t} else if (dump_mode==GF_TEXTDUMPTYPE_ZOOM_CHAP) {\n\t\t\tchapter_time /= 1000;\n\t\t\tfprintf(t, \"AddChapterBySecond(\"LLD\",%s)\\n\", chapter_time, name);\n\t\t} else {\n\t\t\tfprintf(t, \"<TextSample sampleTime=\\\"%s\\\" sampleDescriptionIndex=\\\"1\\\" xml:space=\\\"preserve\\\">%s</TextSample>\\n\"\n\t\t\t\t, format_duration(chapter_time, 1000, szDur), name);\n\t\t}\n\t}\n\tif (dump_mode==GF_TEXTDUMPTYPE_TTXT_CHAP) {\n\t\tfprintf(t, \"</TextStream>\\n\");\n\t}\n\tif (inName) gf_fclose(t);\n\treturn GF_OK;\n}\n\n\nstatic void dump_key_info(const u8 *key_info, u32 key_info_size, Bool is_protected)\n{\n\tif (!key_info) return;\n\tu32 j, k, kpos=3;\n\tu32 nb_keys = 1;\n\tif (key_info[0]) {\n\t\tnb_keys = key_info[1];\n\t\tnb_keys <<= 8;\n\t\tnb_keys |= key_info[2];\n\t}\n\tfor (k=0; k<nb_keys; k++) {\n\t\tu8 constant_iv_size=0;\n\t\tu8 iv_size=key_info[kpos+1];\n\t\tfprintf(stderr, \"\\t\\tKID\");\n\t\tif (nb_keys>1)\n\t\t\tfprintf(stderr, \"%d\", k+1);\n\t\tfprintf(stderr, \" \");\n\t\tfor (j=0; j<16; j++) fprintf(stderr, \"%02X\", key_info[kpos+1+j]);\n\t\tkpos+=17;\n\t\tif (!iv_size && is_protected) {\n\t\t\tconstant_iv_size = key_info[1];\n\t\t\tkpos += 1 + constant_iv_size;\n\t\t}\n\t\tfprintf(stderr, \" - %sIV size %d \\n\", constant_iv_size ? \"const \" : \"\", constant_iv_size ? constant_iv_size : iv_size);\n\t}\n}\n\nstatic void DumpMetaItem(GF_ISOFile *file, Bool root_meta, u32 tk_num, char *name)\n{\n\tchar szInd[2];\n\tu32 i, count, primary_id;\n\tu32 meta_type = gf_isom_get_meta_type(file, root_meta, tk_num);\n\tif (name[0]=='\\t') {\n\t\tszInd[0] = '\\t';\n\t\tszInd[1] = 0;\n\t} else {\n\t\tszInd[0] = 0;\n\t}\n\n\tcount = gf_isom_get_meta_item_count(file, root_meta, tk_num);\n\tprimary_id = gf_isom_get_meta_primary_item_id(file, root_meta, tk_num);\n\tfprintf(stderr, \"%s type: \\\"%s\\\" - %d resource item(s)\\n\", name, meta_type ? gf_4cc_to_str(meta_type) : \"undefined\", (count+(primary_id>0)));\n\tswitch (gf_isom_has_meta_xml(file, root_meta, tk_num)) {\n\tcase 1:\n\t\tfprintf(stderr, \"%sMeta has XML resource\\n\", szInd);\n\t\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"%sMeta has BinaryXML resource\\n\", szInd);\n\t\tbreak;\n\t}\n\tif (primary_id) {\n\t\tfprintf(stderr, \"%sPrimary Item - ID %d\\n\", szInd, primary_id);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tconst char *it_name, *mime, *enc, *url, *urn;\n\t\tBool self_ref;\n\t\tu32 ID;\n\t\tu32 it_type, cenc_scheme, cenc_version;\n\t\tGF_Err e = gf_isom_get_meta_item_info(file, root_meta, tk_num, i+1, &ID, &it_type, &cenc_scheme, &cenc_version, &self_ref, &it_name, &mime, &enc, &url, &urn);\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"%sItem #%d fetch info error: %s\\n\", szInd, i+1, gf_error_to_string(e) );\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stderr, \"%sItem #%d: ID %d type %s\", szInd, i+1, ID, gf_4cc_to_str(it_type));\n\t\tif (self_ref) fprintf(stderr, \" Self-Reference\");\n\t\telse if (it_name && it_name[0]) fprintf(stderr, \" Name \\\"%s\\\"\", it_name);\n\t\tif (mime) fprintf(stderr, \" MIME: \\\"%s\\\"\", mime);\n\t\tif (enc) fprintf(stderr, \" ContentEncoding: \\\"%s\\\"\", enc);\n\n\t\tif (meta_type == GF_META_ITEM_TYPE_PICT) {\n\t\t\tGF_ImageItemProperties img_props;\n\t\t\te = gf_isom_get_meta_image_props(file, root_meta, tk_num, ID, &img_props);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \" invalid image properties !\");\n\t\t\t} else {\n\t\t\t\tu32 j;\n\t\t\t\tBool chan_diff = 0;\n\t\t\t\tif (img_props.width && img_props.height) {\n\t\t\t\t\tfprintf(stderr, \" size %ux%u\", img_props.width, img_props.height);\n\t\t\t\t}\n\t\t\t\tif (img_props.hSpacing && img_props.vSpacing) {\n\t\t\t\t\tfprintf(stderr, \" SAR %u/%u\", img_props.hSpacing, img_props.vSpacing);\n\t\t\t\t}\n\t\t\t\tif (img_props.num_channels) {\n\t\t\t\t\tfprintf(stderr, \" %d channel%s (\", img_props.num_channels, (img_props.num_channels>1) ? \"s\" : \"\");\n\t\t\t\t\tfor (j=1; j<img_props.num_channels; j++) {\n\t\t\t\t\t\tif (img_props.bits_per_channel[0] != img_props.bits_per_channel[j])\n\t\t\t\t\t\t\tchan_diff = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (chan_diff) {\n\t\t\t\t\t\tfor (j=0; j<img_props.num_channels; j++) {\n\t\t\t\t\t\t\tif (j) fprintf(stderr, \",\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%d\", img_props.bits_per_channel[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"%d\", img_props.bits_per_channel[0]);\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \" bpc)\");\n\t\t\t\t}\n\t\t\t\tif (img_props.hOffset || img_props.vOffset)\n\t\t\t\t\tfprintf(stderr, \" Offset %ux%u\", img_props.hOffset, img_props.vOffset);\n\t\t\t\tif (img_props.alpha) fprintf(stderr, \" Alpha\");\n\t\t\t\tif (img_props.hidden) fprintf(stderr, \" Hidden\");\n\t\t\t\tif (img_props.angle) fprintf(stderr, \" Rotate %d\", img_props.angle);\n\t\t\t\tif (img_props.mirror) fprintf(stderr, \" Mirror %d\", img_props.mirror);\n\t\t\t\tif (img_props.clap_hden || img_props.clap_wden)\n\t\t\t\t\tfprintf(stderr, \" Clap %d/%d,%d/%d,%d/%d,%d/%d\", img_props.clap_wnum, img_props.clap_wden, img_props.clap_hnum, img_props.clap_hden, img_props.clap_honum, img_props.clap_hoden, img_props.clap_vonum, img_props.clap_voden);\n\t\t\t}\n\t\t}\n\n\t\tif (cenc_scheme) {\n\t\t\tBool is_protected;\n\t\t\tu8 skip_byte_block, crypt_byte_block;\n\t\t\tconst u8 *key_info;\n\t\t\tu32 key_info_size;\n\t\t\tfprintf(stderr, \" - Protection scheme: %s v0x%08X\", gf_4cc_to_str(cenc_scheme), cenc_version);\n\n\t\t\tgf_isom_extract_meta_item_get_cenc_info(file, root_meta, tk_num, ID, &is_protected, &skip_byte_block, &crypt_byte_block, &key_info, &key_info_size, NULL, NULL, NULL, NULL);\n\t\t\tif (skip_byte_block && crypt_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", skip_byte_block, crypt_byte_block);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(key_info, key_info_size, is_protected);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tif (url) fprintf(stderr, \"%sURL: %s\\n\", szInd, url);\n\t\tif (urn) fprintf(stderr, \"%sURN: %s\\n\", szInd, urn);\n\n\t}\n}\n\n\nstatic void print_config_hash(GF_List *xps_array, char *szName)\n{\n\tu32 i, j;\n\tu8 hash[20];\n\tfor (i=0; i<gf_list_count(xps_array); i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(xps_array, i);\n\t\tgf_sha1_csum((u8 *) slc->data, slc->size, hash);\n\t\tfprintf(stderr, \"\\t%s#%d hash: \", szName, i+1);\n\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid dump_hevc_track_info(GF_ISOFile *file, u32 trackNum, GF_HEVCConfig *hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t, HEVCState *hevc_state\n#endif /*GPAC_DISABLE_AV_PARSERS  && defined(GPAC_DISABLE_HEVC)*/\n\t)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\tu32 idx;\n#endif\n\tu32 k;\n\tBool non_hevc_base_layer=GF_FALSE;\n\tfprintf(stderr, \"\\t%s Info:\", hevccfg->is_lhvc ? \"LHVC\" : \"HEVC\");\n\tif (!hevccfg->is_lhvc)\n\t\tfprintf(stderr, \" Profile %s @ Level %g - Chroma Format %s\\n\", gf_hevc_get_profile_name(hevccfg->profile_idc), ((Double)hevccfg->level_idc) / 30.0, gf_avc_hevc_get_chroma_format_name(hevccfg->chromaFormat));\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tNAL Unit length bits: %d\", 8*hevccfg->nal_unit_size);\n\tif (!hevccfg->is_lhvc)\n\t\tfprintf(stderr, \" - general profile compatibility 0x%08X\\n\", hevccfg->general_profile_compatibility_flags);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tParameter Sets: \");\n\tfor (k=0; k<gf_list_count(hevccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(hevccfg->param_array, k);\n\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\tfprintf(stderr, \"%d SPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\tfprintf(stderr, \"%d PPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\tfprintf(stderr, \"%d VPS \", gf_list_count(ar->nalus));\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\t\tGF_NALUFFParam *vps = gf_list_get(ar->nalus, idx);\n\t\t\t\ts32 ps_idx=gf_hevc_read_vps(vps->data, vps->size, hevc_state);\n\t\t\t\tif (hevccfg->is_lhvc && (ps_idx>=0)) {\n\t\t\t\t\tnon_hevc_base_layer = ! hevc_state->vps[ps_idx].base_layer_internal_flag;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\n\tfprintf(stderr, \"\\n\");\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\tfor (k=0; k<gf_list_count(hevccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(hevccfg->param_array, k);\n\t\tu32 width, height;\n\t\ts32 par_n, par_d;\n\n\t\tif (ar->type !=GF_HEVC_NALU_SEQ_PARAM) continue;\n\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\tGF_Err e;\n\t\t\tGF_NALUFFParam *sps = gf_list_get(ar->nalus, idx);\n\t\t\tpar_n = par_d = -1;\n\t\t\te = gf_hevc_get_sps_info_with_state(hevc_state, sps->data, sps->size, NULL, &width, &height, &par_n, &par_d);\n\t\t\tif (e==GF_OK) {\n\t\t\t\tfprintf(stderr, \"\\tSPS resolution %dx%d\", width, height);\n\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\tu32 tw, th;\n\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\tfprintf(stderr, \" - Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\", par_n, par_d, tw, th);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to read SPS: %s\\n\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (!hevccfg->is_lhvc)\n\t\tfprintf(stderr, \"\\tBit Depth luma %d - Chroma %d - %d temporal layers\\n\", hevccfg->luma_bit_depth, hevccfg->chroma_bit_depth, hevccfg->numTemporalLayers);\n\telse\n\t\tfprintf(stderr, \"\\t%d temporal layers\\n\", hevccfg->numTemporalLayers);\n\tif (hevccfg->is_lhvc) {\n\t\tfprintf(stderr, \"\\t%sHEVC base layer - Complete representation %d\\n\", non_hevc_base_layer ? \"Non-\" : \"\", hevccfg->complete_representation);\n\t}\n\n\tfor (k=0; k<gf_list_count(hevccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(hevccfg->param_array, k);\n\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) print_config_hash(ar->nalus, \"SPS\");\n\t\telse if (ar->type==GF_HEVC_NALU_PIC_PARAM) print_config_hash(ar->nalus, \"PPS\");\n\t\telse if (ar->type==GF_HEVC_NALU_VID_PARAM) print_config_hash(ar->nalus, \"VPS\");\n\t}\n}\n\nvoid dump_vvc_track_info(GF_ISOFile *file, u32 trackNum, GF_VVCConfig *vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t, VVCState *vvc_state\n#endif /*GPAC_DISABLE_AV_PARSERS  && defined(GPAC_DISABLE_HEVC)*/\n\t)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\tu32 idx;\n#endif\n\tu32 k;\n\tfprintf(stderr, \"\\tVVC Info:\");\n\n\tfprintf(stderr, \" Profile %d @ Level %d - Chroma Format %s\\n\", vvccfg->general_profile_idc, vvccfg->general_level_idc, vvccfg->chromaformat_plus_one ? gf_avc_hevc_get_chroma_format_name(vvccfg->chromaformat_plus_one-1) : \"n/a\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tNAL Unit length bits: %d\", 8*vvccfg->nal_unit_size);\n\tif (vvccfg->general_constraint_info && vvccfg->num_constraint_info && vvccfg->general_constraint_info[0]) {\n\t\tfprintf(stderr, \" - general constraint info 0x\");\n\t\tfor (idx=0; idx<vvccfg->num_constraint_info; idx++) {\n\t\t\tfprintf(stderr, \"%02X\", vvccfg->general_constraint_info[idx]);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tParameter Sets: \");\n\tfor (k=0; k<gf_list_count(vvccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);\n\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) {\n\t\t\tfprintf(stderr, \"%d SPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_VVC_NALU_PIC_PARAM) {\n\t\t\tfprintf(stderr, \"%d PPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_VVC_NALU_VID_PARAM) {\n\t\t\tfprintf(stderr, \"%d VPS \", gf_list_count(ar->nalus));\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && 0 //TODO\n\t\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\t\tGF_NALUFFParam *vps = gf_list_get(ar->nalus, idx);\n\t\t\t\ts32 ps_idx=gf_hevc_read_vps(vps->data, vps->size, hevc_state);\n\t\t\t\tif (hevccfg->is_lhvc && (ps_idx>=0)) {\n\t\t\t\t\tnon_hevc_base_layer = ! hevc_state->vps[ps_idx].base_layer_internal_flag;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\n\tfprintf(stderr, \"\\n\");\n#if !defined(GPAC_DISABLE_AV_PARSERS) && 0 //TODO\n\tfor (k=0; k<gf_list_count(vvccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);\n\t\tu32 width, height;\n\t\ts32 par_n, par_d;\n\n\t\tif (ar->type !=GF_VVC_NALU_SEQ_PARAM) continue;\n\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\tGF_Err e;\n\t\t\tGF_NALUFFParam *sps = gf_list_get(ar->nalus, idx);\n\t\t\tpar_n = par_d = -1;\n\t\t\te = gf_vvc_get_sps_info_with_state(vvc_state, sps->data, sps->size, NULL, &width, &height, &par_n, &par_d);\n\t\t\tif (e==GF_OK) {\n\t\t\t\tfprintf(stderr, \"\\tSPS resolution %dx%d\", width, height);\n\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\tu32 tw, th;\n\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\tfprintf(stderr, \" - Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\", par_n, par_d, tw, th);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\nFailed to read SPS: %s\\n\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tfprintf(stderr, \"\\tBit Depth %d - %d temporal layers\\n\", vvccfg->bit_depth_plus_one-1, vvccfg->numTemporalLayers);\n\n\tfor (k=0; k<gf_list_count(vvccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);\n\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) print_config_hash(ar->nalus, \"SPS\");\n\t\telse if (ar->type==GF_VVC_NALU_PIC_PARAM) print_config_hash(ar->nalus, \"PPS\");\n\t\telse if (ar->type==GF_VVC_NALU_VID_PARAM) print_config_hash(ar->nalus, \"VPS\");\n\t}\n}\n\nvoid gf_inspect_format_timecode(const u8 *data, u32 size, u32 tmcd_flags, u32 tc_num, u32 tc_den, u32 tmcd_fpt, char szFmt[100]);\n\nvoid DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\tDouble scale, max_rate, rate;\n\tBool is_od_track = 0;\n\tu32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;\n\tu64 time_slice, dur, size;\n\ts32 cts_shift;\n\tGF_ESD *esd;\n\tchar szDur[50];\n\tchar *lang;\n\n\tif (!is_track_num) {\n\t\ttrackNum = gf_isom_get_track_by_id(file, trackID);\n\t} else {\n\t\ttrackNum = trackID;\n\t\ttrackID = gf_isom_get_track_id(file, trackNum);\n\t}\n\tif (!trackNum) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, trackNum);\n\tfprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);\n\n\tdur = gf_isom_get_media_original_duration(file, trackNum);\n\tsize = gf_isom_get_media_duration(file, trackNum);\n\tfprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));\n\tif (dur != size)\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tif (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));\n\t}\n\n\tnb_edits = gf_isom_get_edits_count(file, trackNum);\n\tif (nb_edits)\n\t\tfprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));\n\n\tcts_shift = gf_isom_get_composition_offset_shift(file, trackNum);\n\tif (cts_shift)\n\t\tfprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);\n\n\tif (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");\n\tif (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");\n\tgf_isom_get_media_language(file, trackNum, &lang);\n\tfprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );\n\tgf_free(lang);\n\tmtype = gf_isom_get_media_type(file, trackNum);\n\tfprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));\n\tmsub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);\n\tif (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tfprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));\n\n\tpfmt = gf_pixel_fmt_from_qt_type(msub_type);\n\tcodecid = gf_codec_id_from_isobmf(msub_type);\n\n\tcount = gf_isom_get_track_kind_count(file, trackNum);\n\tfor (i = 0; i < count; i++) {\n\t\tchar *kind_scheme, *kind_value;\n\t\tgf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);\n\t\tfprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");\n\t\tif (kind_scheme) gf_free(kind_scheme);\n\t\tif (kind_value) gf_free(kind_value);\n\t}\n\n\tif (gf_isom_is_track_fragmented(file, trackID) ) {\n\t\tu32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;\n\t\tu8 defaultPadding;\n\t\tu16 defaultDegradationPriority;\n\t\tu32 frag_samples;\n\t\tu64 frag_duration;\n\t\tgf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);\n\t\tfprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));\n\n\t\tgf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);\n\n\t\tfprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",\n\t\t\t\tdefaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,\n\t\t\t\t(u32) defaultPadding, (u32) defaultDegradationPriority\n\t\t);\n\t}\n\n\tif (!gf_isom_is_self_contained(file, trackNum, 1)) {\n\t\tconst char *url, *urn;\n\t\tgf_isom_get_data_reference(file, trackNum, 1, &url, &urn);\n\t\tfprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);\n\t}\n\n\tif (full_dump) {\n\t\tconst char *handler_name;\n\t\tgf_isom_get_handler_name(file, trackNum, &handler_name);\n\t\tfprintf(stderr, \"Handler name: %s\\n\", handler_name);\n\t}\n\n\tprint_udta(file, trackNum, GF_FALSE);\n\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\ts32 tx, ty;\n\t\tu32 w, h;\n\t\tu16 bit_depth;\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tgf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);\n\t\tfprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);\n\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);\n\t\tfprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);\n\t}\n\n\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);\n\tgf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmsub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tif (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)\n\t\tgf_isom_get_original_format_type(file, trackNum, 1, &msub_type);\n\n\tif ((msub_type==GF_ISOM_SUBTYPE_MPEG4)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_SVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_MVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LSR1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHE1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVT1)\n\t   )  {\n\t\tesd = gf_isom_get_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tconst char *st = gf_stream_type_name(esd->decoderConfig->streamType);\n\t\t\tif (dump_m4sys) {\n\t\t\t\tif (st) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_OD)\n\t\t\t\tis_od_track=1;\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\tu32 w, h;\n\t\t\t\tu16 rvc_predef;\n\t\t\t\tw = h = 0;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n#else\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);\n#endif\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));\n\t\t\t\t\t\tif (dsi.par_den && dsi.par_num) {\n\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\tfprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {\n\t\t\t\t\tGF_AVCConfig *avccfg, *svccfg, *mvccfg;\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);\n\n\t\t\t\t\tavccfg = gf_isom_avc_config_get(file, trackNum, 1);\n\t\t\t\t\tsvccfg = gf_isom_svc_config_get(file, trackNum, 1);\n\t\t\t\t\tmvccfg = gf_isom_mvc_config_get(file, trackNum, 1);\n\t\t\t\t\tif (!avccfg && !svccfg && !mvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));\n\t\t\t\t\t} else if (avccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );\n\t\t\t\t\t\tfprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);\n\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!full_dump) break;\n\t\t\t\t\t\t}\n#endif\n\n\t\t\t\t\t\tif (avccfg->chroma_bit_depth) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprint_config_hash(avccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(avccfg->pictureParameterSets, \"PPS\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t\t}\n\t\t\t\t\tif (svccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mvccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(mvccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(mvccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tgf_odf_avc_cfg_del(mvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)\n\t\t\t\t           || (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)\n\t\t\t\t          ) {\n\t\t\t\t\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\t\t\t\t\tGF_OperatingPointsInformation *oinf;\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\tHEVCState hevc_state;\n\t\t\t\t\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\t\t\t\t\thevc_state.sps_active_idx = -1;\n#endif\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);\n\t\t\t\t\thevccfg = gf_isom_hevc_config_get(file, trackNum, 1);\n\t\t\t\t\tlhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);\n\n\t\t\t\t\tif (msub_type==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\t\t\t\tconst u8 *data;\n\t\t\t\t\t\tu32 tsize;\n\t\t\t\t\t\tu32  is_default, tx,ty,tw,th, id, independent;\n\t\t\t\t\t\tBool full_frame;\n\t\t\t\t\t\tif (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);\n\t\t\t\t\t\t} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!hevccfg && !lhvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile base track\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (hevccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lhvccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, lhvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_oinf_info(file, trackNum, &oinf)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tOperating Points Information -\");\n\t\t\t\t\t\tfprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);\n\t\t\t\t\t\tswitch (oinf->scalability_mask) {\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfprintf(stderr, \"Multiview\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfprintf(stderr, \"Spatial scalability\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tfprintf(stderr, \"Auxilary\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//TODO: need to dump more info ?\n\t\t\t\t\t\tfprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );\n\t\t\t\t\t\tfprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OGG media*/\n\t\t\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tchar *szName;\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";\n\t\t\t\t\telse szName = \"Unknown\";\n\t\t\t\t\tfprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//check if we know this codec from its OTI\n\t\t\t\t\tu32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\t\tfprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"Visual Size %d x %d\\n\", w, h);\n\t\t\t\t}\n\t\t\t\tif (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);\n\t\t\t\t}\n\n\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 oti;\n#endif\n\t\t\t\tu32 codec_id;\n\t\t\t\tBool is_mp2 = GF_FALSE;\n\t\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tis_mp2 = GF_TRUE;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\telse\n\t\t\t\t\t\te = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *signaling = \"implicit\";\n\t\t\t\t\t\tchar *heaac = \"\";\n\t\t\t\t\t\tif (!is_mp2 && a_cfg.has_sbr) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";\n\t\t\t\t\t\t\telse heaac = \"(HE-AAC v1) \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a_cfg.base_object_type==2) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps || a_cfg.has_sbr)\n\t\t\t\t\t\t\t\tsignaling = \"backward compatible\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsignaling = \"hierarchical\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);\n\t\t\t\t\t\tif (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");\n\t\t\t\t\t\tif (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));\n\t\t\t\t\t\tif (a_cfg.has_ps) fprintf(stderr, \" - PS\");\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n#else\n\t\t\t\t\tfprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tif (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n\t\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);\n\t\t\t\t\t\tif (samp) {\n\t\t\t\t\t\t\tu32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",\n\t\t\t\t\t\t\t        gf_mp3_version_name(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_num_channels(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_sampling_rate(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_layer(mhdr)\n\t\t\t\t\t\t\t       );\n\t\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\tfprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tfprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\tfprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t/*packetVideo hack for EVRC...*/\n\t\t\t\tcase GF_CODECID_EVRC_PV:\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)\n\t\t\t\t\t        && !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tfprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcodec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=4) {\n\t\t\t\t\tGF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tfprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");\n\t\t\t\t\tif (full_dump && !b_cfg->elementaryMasks) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)b_cfg);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {\n\t\t\t\t\tu8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;\n\t\t\t\t\tconst char *afxtype = gf_stream_type_afx_name(tag);\n\t\t\t\t\tfprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {\n\t\t\t\t\tfprintf(stderr, \"Font Data stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {\n\t\t\t\t\tGF_LASERConfig l_cfg;\n\t\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);\n\t\t\t\t\tfprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {\n\t\t\t\t\tfprintf(stderr, \"Synthetized Texture stream stream\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*sync is only valid if we open all tracks to take care of default MP4 sync..*/\n\t\t\tif (!full_dump) {\n\t\t\t\tif (dump_m4sys) {\n\t\t\t\t\tif (!esd->OCRESID || (esd->OCRESID == esd->ESID))\n\t\t\t\t\t\tfprintf(stderr, \"Self-synchronized\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);\n\t\t\t\tif (esd->dependsOnESID)\n\t\t\t\t\tfprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");\n\n\t\t\t\tfprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);\n\t\t\t\tif (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_AV1Config *av1c;\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);\n\n\t\tav1c = gf_isom_av1_config_get(file, trackNum, 1);\n\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\tif (av1c->initial_presentation_delay_present)\n\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\tcount = gf_list_count(av1c->obu_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu8 hash[20];\n\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {\n\t\tfprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {\n\t\tfprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {\n\t\tfprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {\n\t\tfprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {\n\t\tu32 br = 0;\n\t\tconst char *lfe = \"\";\n\t\tBool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);\n\t\tif (ac3) {\n\t\t\tnb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);\n\t\t\tfor (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {\n\t\t\t\tassert(ac3->streams[0].nb_dep_sub == 1);\n\t\t\t\tnb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);\n\t\t\t}\n\t\t\tif (ac3->streams[0].lfon) lfe = \".1\";\n\t\t\tbr = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);\n\t\t\tis_ec3 = ac3->is_ec3;\n\t\t\tgf_free(ac3);\n\t\t}\n#endif\n\t\tfprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {\n\t\tfprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tu32 w, h;\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\n\t\tgf_isom_get_dims_description(file, trackNum, 1, &dims);\n\t\tfprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);\n\t\tfprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");\n\t\tfprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );\n\t\tif (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);\n\t\tif (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);\n\t\tif (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);\n\t} else if (mtype==GF_ISOM_MEDIA_HINT) {\n\t\tu32 refTrack;\n\t\ts32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);\n\t\tif (refCount>0) {\n\t\t\tfprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tgf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);\n\t\t\t\tif (i) fprintf(stderr, \" - \");\n\t\t\t\tfprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Streaming Hint Track (no refs)\\n\");\n\t\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\trefCount = gf_isom_get_payt_count(file, trackNum);\n\t\tif (refCount>0) {\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tconst char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);\n\t\t\t\tfprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);\n\t\t\t}\n\t\t}\n#endif\n\t} else if (mtype==GF_ISOM_MEDIA_FLASH) {\n\t\tfprintf(stderr, \"Macromedia Flash Movie\\n\");\n\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {\n\t\tu32 w, h;\n\t\ts16 l;\n\t\ts32 tx, ty;\n\t\tconst char *content_encoding = NULL;\n\t\tconst char *mime = NULL;\n\t\tconst char *config  = NULL;\n\t\tconst char *_namespace = NULL;\n\t\tconst char *schema_loc = NULL;\n\t\tconst char *auxiliary_mimes = NULL;\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);\n\t\tif (msub_type == GF_ISOM_SUBTYPE_SBTT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Simple Timed Text Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {\n\t\t\tgf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);\n\t\t\tfprintf(stderr, \"XML Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- namespace %s\", _namespace);\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tif (auxiliary_mimes != NULL) {\n\t\t\t\tfprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Text Stream\");\n\t\t}\n\t\tfprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);\n\t} else if (mtype == GF_ISOM_MEDIA_META) {\n\t\tconst char *content_encoding = NULL;\n\t\tif (msub_type == GF_ISOM_SUBTYPE_METT) {\n\t\t\tconst char *mime = NULL;\n\t\t\tconst char *config  = NULL;\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_METX) {\n\t\t\tconst char *_namespace = NULL;\n\t\t\tconst char *schema_loc = NULL;\n\t\t\tgf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);\n\t\t\tfprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Metadata Stream\\n\");\n\t\t}\n\t} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {\n\t\tGF_VVCConfig *vvccfg;\n\t\tu32 w, h;\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tVVCState *vvc_state;\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (vvc_state) vvc_state->sps_active_idx = -1;\n#endif\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\tfprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);\n\t\tvvccfg = gf_isom_vvc_config_get(file, trackNum, 1);\n\n\t\tif (!vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));\n\t\t} else {\n\t\t\tdump_vvc_track_info(file, trackNum, vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\t\t\t, vvc_state\n#endif\n\t\t\t);\n\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (vvc_state) gf_free(vvc_state);\n#endif\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)\n\t\t\t|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)\n\t) {\n\t\tconst u8 *compat_profiles;\n\t\tu32 nb_compat_profiles;\n\t\tBool valid = GF_FALSE;\n\t\tBool allow_inband = GF_FALSE;\n\t\tif ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tallow_inband = GF_TRUE;\n\n\t\tfprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);\n\n\t\tesd = gf_media_map_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\tif (allow_inband) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tu64 ch_layout=0;\n\t\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\t\tif (PL>=0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);\n\t\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\t\tfprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t\tvalid = GF_TRUE;\n\t\t\t}\n\t\t} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {\n\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]\n\t\t\t\t, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])\n\t\t\t);\n\t\t\tvalid = GF_TRUE;\n\t\t}\n\t\tif (!valid) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\tcompat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);\n\t\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\t\tif (!i)\n\t\t\t\tfprintf(stderr, \"\\tCompatible profiles:\");\n\t\t\tfprintf(stderr, \" 0x%02X\", compat_profiles[i]);\n\t\t}\n\t\tif (i) fprintf(stderr, \"\\n\");\n\t} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {\n\t\tu32 fmt, prate;\n\t\tif (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {\n\t\t\tfprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");\n\t\t}\n\t\tfprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);\n\t} else if (codecid) {\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\tfprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);\n\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);\n\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );\n\t\t}\n\t} else if (pfmt) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);\n\t} else if (msub_type==GF_QT_SUBTYPE_TMCD) {\n\t\tu32 stsd_idx;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);\n\t\tfprintf(stderr, \"Time Code stream\\n\");\n\t\tif (sample) {\n\t\t\tchar szTimecode[100];\n\t\t\tu32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;\n\n\t\t\tgf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);\n\n\t\t\tgf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);\n\n\t\t\tgf_isom_sample_del(&sample);\n\t\t\tfprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);\n\t\t}\n\t} else {\n\t\tGF_GenericSampleDescription *udesc;\n\n\t\tudesc = gf_isom_get_generic_sample_description(file, trackNum, 1);\n\t\tif (udesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n                fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",\n\t\t\t\t\t\t( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),\n                        udesc->compressor_name, udesc->width, udesc->height);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tfprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown media type\\n\");\n\t\t\t}\n\t\t\tif (udesc->vendor_code)\n\t\t\t\tfprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);\n\n\t\t\tif (udesc->extension_buf) {\n\t\t\t\tfprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);\n\t\t\t\tgf_free(udesc->extension_buf);\n\t\t\t}\n\t\t\tgf_free(udesc);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown track type\\n\");\n\t\t}\n\t}\n\n\n\t/*Crypto info*/\n\tif (gf_isom_is_track_encrypted(file, trackNum)) {\n\t\tconst char *scheme_URI, *KMS_URI;\n\t\tu32 scheme_type, version;\n\t\tu32 IV_size;\n\t\tBool use_sel_enc;\n\n\t\tif (gf_isom_is_ismacryp_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tif (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);\n\t\t\tif (KMS_URI) {\n\t\t\t\tif (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");\n\t\t\t\telse fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {\n\t\t\tconst char *textHdrs;\n\t\t\tu32 enc_type, hdr_len;\n\t\t\tu64 orig_len;\n\t\t\tgf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tfprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);\n\t\t\tfprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);\n\t\t\tif (textHdrs) {\n\t\t\t\tu32 offset;\n\t\t\t\tconst char *start = textHdrs;\n\t\t\t\tfprintf(stderr, \"\\tOMA Textual Headers:\\n\");\n\t\t\t\ti=0;\n\t\t\t\toffset=0;\n\t\t\t\twhile (i<hdr_len) {\n\t\t\t\t\tif (start[i]==0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\t\\t%s\\n\", start+offset);\n\t\t\t\t\t\toffset=i+1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\\\tt%s\\n\", start+offset);\n\t\t\t}\n\t\t\tif (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);\n\t\t\tfprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {\n\t\t\tconst u8 *def_key;\n\t\t\tu32 def_key_size;\n\t\t\tBool IsEncrypted;\n\t\t\tu8 crypt_byte_block, skip_byte_block;\n\t\t\tIV_size = 0;\n\t\t\tgf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);\n\n\t\t\tgf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);\n\n\t\t\tfprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);\n\n\t\t\tif (crypt_byte_block && skip_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);\n\t\t\tif (def_key && def_key[0])\n\t\t\t\tfprintf(stderr, \" - MultiKey\");\n\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(def_key, def_key_size, IsEncrypted);\n\n\t\t} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);\n\t\t\tfprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tif ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {\n\t\tfprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);\n\t}\n\n\n\tDumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");\n\n\tgf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);\n\tif (alt_group) {\n\t\tfprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);\n\t\tfor (i=0; i<nb_groups; i++) {\n\t\t\tu32 nb_crit, switchGroupID;\n\t\t\tconst u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);\n\t\t\tif (!nb_crit) {\n\t\t\t\tfprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");\n\t\t\t} else {\n\t\t\t\tif (switchGroupID) {\n\t\t\t\t\tfprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"\\tAlternate Group criterias: \");\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_crit; j++) {\n\t\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (gf_isom_has_sync_points(file, trackNum)) {\n\tcase 0:\n\t\tfprintf(stderr, \"\\tAll samples are sync\\n\");\n\t\tbreak;\n\tcase 1:\n\t{\n\t\tu32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;\n\t\tif (! nb_sync) {\n\t\t\tfprintf(stderr, \"\\tOnly one sync sample\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);\n\t\t}\n\t}\n\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"\\tNo sync sample found\\n\");\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);\n\n\tif (!full_dump) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\n\tdur = size = 0;\n\tmax_rate = rate = 0;\n\ttime_slice = 0;\n\tts = gf_isom_get_media_timescale(file, trackNum);\n\tcsize = gf_isom_get_constant_sample_size(file, trackNum);\n\tcdur = gf_isom_get_constant_sample_duration(file, trackNum);\n\tcount = gf_isom_get_sample_count(file, trackNum);\n\tif (csize && cdur) {\n\t\tsize = count * csize;\n\t\tdur = cdur * count;\n\t} else {\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (is_od_track) {\n\t\t\t\tsamp = gf_isom_get_sample(file, trackNum, j+1, NULL);\n\t\t\t} else {\n\t\t\t\tsamp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);\n\t\t\t}\n\t\t\tif (!samp) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdur = samp->DTS+samp->CTS_Offset;\n\t\t\tsize += samp->dataLength;\n\t\t\trate += samp->dataLength;\n\t\t\tif (samp->DTS - time_slice > ts) {\n\t\t\t\tDouble max_tmp = rate * ts / (samp->DTS - time_slice);\n\t\t\t\tif (max_rate < max_tmp )\n\t\t\t\t\tmax_rate = max_tmp;\n\n\t\t\t\trate = 0;\n\t\t\t\ttime_slice = samp->DTS;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\nComputed info from media:\\n\");\n\tif (csize && cdur) {\n\t\tfprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);\n\t}\n\tscale = 1000.0 / ts;\n\tdur = (u64) (scale * dur);\n\tfprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);\n\tif (!dur) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\t/*rate in byte, dur is in ms*/\n\trate = 8000.0 * size / dur;\n\n\tif (!max_rate)\n\t\tmax_rate = rate;\n\telse\n\t\tmax_rate *= 8.0;\n\n\tif (rate >= 1500) {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);\n\t} else {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);\n\t}\n\n\t{\n\t\tu32 dmin, dmax, davg, smin, smax, savg;\n\t\tgf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);\n\t\tfprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);\n\t\tfprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tcount = gf_isom_get_chapter_count(file, trackNum);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (j=0; j<count; j++) {\n\t\t\tgf_isom_get_chapter(file, trackNum, j+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);\n\t\t}\n\t}\n}\n\nvoid DumpMovieInfo(GF_ISOFile *file)\n{\n\tGF_InitialObjectDescriptor *iod;\n\tBool dump_m4sys = GF_FALSE;\n\tu32 i, brand, min, timescale, count, data_len;\n\tconst u8 *data;\n\tu64 create, modif;\n\tBool has_itags = GF_FALSE;\n\tchar szDur[50];\n\n\tDumpMetaItem(file, 1, 0, \"# File Meta\");\n\tif (!gf_isom_has_movie(file)) {\n\t\tif (gf_isom_has_segment(file, &brand, &min)) {\n\t\t\tcount = gf_isom_segment_get_fragment_count(file);\n\t\t\tfprintf(stderr, \"File is a segment - %d movie fragments - Brand %s (version %d):\\n\", count, gf_4cc_to_str(brand), min);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu32 j, traf_count = gf_isom_segment_get_track_fragment_count(file, i+1);\n\t\t\t\tfor (j=0; j<traf_count; j++) {\n\t\t\t\t\tu32 ID;\n\t\t\t\t\tu64 tfdt;\n\t\t\t\t\tID = gf_isom_segment_get_track_fragment_decode_time(file, i+1, j+1, &tfdt);\n\t\t\t\t\tfprintf(stderr, \"\\tFragment #%d Track ID %d - TFDT \"LLU\"\\n\", i+1, ID, tfdt);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"File has no movie (moov) - static data container\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_timescale(file);\n\ti=gf_isom_get_track_count(file);\n\tfprintf(stderr, \"# Movie Info - %d track%s - TimeScale %d\\n\", i, i>1 ? \"s\" : \"\", timescale);\n\n\tmodif = gf_isom_get_duration(file);\n\tcreate = gf_isom_get_original_duration(file);\n\tfprintf(stderr, \"Duration %s\", format_duration(create, timescale, szDur));\n\tif (create!=modif) {\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(modif, timescale, szDur));\n\t}\n\tfprintf(stderr, \"\\n\");\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (gf_isom_is_fragmented(file)) {\n\t\tfprintf(stderr, \"Fragmented: yes - duration %s\\n%d fragments - %d SegmentIndexes\\n\", format_duration(gf_isom_get_fragmented_duration(file), timescale, szDur), gf_isom_get_fragments_count(file, 0) , gf_isom_get_fragments_count(file, 1) );\n\t} else {\n\t\tfprintf(stderr, \"Fragmented: no\\n\");\n\t}\n#endif\n\n\tif (gf_isom_moov_first(file))\n\t\tfprintf(stderr, \"Progressive (moov before mdat)\\n\");\n\n\tif (gf_isom_get_brand_info(file, &brand, &min, &count) == GF_OK) {\n\t\tfprintf(stderr, \"Major Brand %s - version %d - compatible brands:\", gf_4cc_to_str(brand), min);\n\t\tfor (i=0; i<count;i++) {\n\t\t\tif (gf_isom_get_alternate_brand(file, i+1, &brand)==GF_OK)\n\t\t\t\tfprintf(stderr, \" %s\", gf_4cc_to_str(brand) );\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tgf_isom_get_creation_time(file, &create, &modif);\n\tfprintf(stderr, \"Created: %s\", format_date(create, szDur));\n\tif (create != modif)\n\t\tfprintf(stderr, \"Modified: %s\", format_date(modif, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tDumpMetaItem(file, 0, 0, \"# Movie Meta\");\n\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (iod) {\n\t\tu32 desc_size = gf_odf_desc_size((GF_Descriptor *)iod);\n\t\tif (iod->tag == GF_ODF_IOD_TAG) {\n\t\t\tfprintf(stderr, \"File has root IOD (%d bytes)\\n\", desc_size);\n\t\t\tfprintf(stderr, \"Scene PL 0x%02x - Graphics PL 0x%02x - OD PL 0x%02x\\n\", iod->scene_profileAndLevel, iod->graphics_profileAndLevel, iod->OD_profileAndLevel);\n\t\t\tfprintf(stderr, \"Visual PL: %s (0x%02x)\\n\", gf_m4v_get_profile_name(iod->visual_profileAndLevel), iod->visual_profileAndLevel);\n\t\t\tfprintf(stderr, \"Audio PL: %s (0x%02x)\\n\", gf_m4a_get_profile_name(iod->audio_profileAndLevel), iod->audio_profileAndLevel);\n\t\t\t//fprintf(stderr, \"inline profiles included %s\\n\", iod->inlineProfileFlag ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"File has root OD (%d bytes)\\n\", desc_size);\n\t\t}\n\t\tif (!gf_list_count(iod->ESDescriptors))\n\t\t\tfprintf(stderr, \"No streams included in root OD\\n\");\n\t\telse\n\t\t\tdump_m4sys = GF_TRUE;\n\n\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t}\n\tif (gf_isom_is_JPEG2000(file)) fprintf(stderr, \"File is JPEG 2000\\n\");\n\n\tcount = gf_isom_get_copyright_count(file);\n\tif (count) {\n\t\tconst char *lang, *note;\n\t\tfprintf(stderr, \"\\nCopyrights:\\n\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgf_isom_get_copyright(file, i+1, &lang, &note);\n\t\t\tfprintf(stderr, \"\\t(%s) %s\\n\", lang, note);\n\t\t}\n\t}\n\n\tcount = gf_isom_get_chapter_count(file, 0);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgf_isom_get_chapter(file, 0, i+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", i+1, format_duration(time, 1000, szDur), name);\n\t\t}\n\t}\n\n\tif (gf_isom_apple_get_tag(file, 0, &data, &data_len) == GF_OK) {\n\t\thas_itags = GF_TRUE;\n\t\tfprintf(stderr, \"\\niTunes Info:\\n\");\n\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tu32 int_val2, flags, itype;\n\t\t\tGF_ISOiTunesTag tag;\n\t\t\tu64 int_val;\n\t\t\ts32 tag_idx;\n\t\t\tGF_Err e = gf_isom_apple_enum_tag(file, i, &tag, &data, &data_len, &int_val, &int_val2, &flags);\n\t\t\tif (e) break;\n\t\t\ti++;\n\n\t\t\ttag_idx = gf_itags_find_by_itag(tag);\n\t\t\tif (tag_idx<0) {\n\t\t\t\tfprintf(stderr, \"\\t%s: %s\\n\", gf_4cc_to_str(tag), data);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\t%s: \", gf_itags_get_name(tag_idx) );\n\t\t\titype = gf_itags_get_type(tag_idx);\n\t\t\tswitch (itype) {\n\t\t\tcase GF_ITAG_BOOL: fprintf(stderr, int_val ? \"yes\" : \"no\"); break;\n\t\t\tcase GF_ITAG_INT8:\n\t\t\tcase GF_ITAG_INT16:\n\t\t\tcase GF_ITAG_INT32:\n\t\t\tcase GF_ITAG_INT64:\n\t\t\t\tfprintf(stderr, LLU, int_val);\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FRAC6:\n\t\t\tcase GF_ITAG_FRAC8:\n\t\t\t\tfprintf(stderr, LLU\" / %u\", int_val, int_val2);\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FILE:\n\t\t\t\tif (flags==14) fprintf(stderr, \"PNG File\");\n\t\t\t\telse if (flags==13) fprintf(stderr, \"JPEG File\");\n\t\t\t\telse fprintf(stderr, \"unknown (flags %d)\", flags);\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_ID3_GENRE:\n\t\t\t\tif (int_val) {\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_id3_get_genre((u32) int_val) );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//fallthrough\n\t\t\tdefault:\n\t\t\t\tif (data)\n\t\t\t\t\tfprintf(stderr, \"%s\", data);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, data_len ? \"none\" : \"unknown\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t}\n\ti=0;\n\twhile (1) {\n\t\tu32 type, version;\n\t\tchar *wmatag;\n\t\tGF_Err e = gf_isom_wma_enum_tag(file, i, &wmatag, &data, &data_len, &version, &type);\n\t\tif (e) break;\n\t\tif (!i) {\n\t\t\tfprintf(stderr, \"\\nWMA Info:\\n\");\n\t\t}\n\t\ti++;\n\t\tfprintf(stderr, \"\\t%s\", wmatag);\n\t\tif (version!=1)\n\t\t\tfprintf(stderr, \" (version %d)\", version);\n\t\tfprintf(stderr, \": \");\n\n\t\tif (type) {\n\t\t\tfprintf(stderr, \"unknown type %d\\n\", type);\n\t\t} else {\n\t\t\tu16 *src_str = (u16 *) data;\n\t\t\tu32 len = (u32) ( UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(src_str) );\n\t\t\tchar *utf8str = (char *)gf_malloc(len + 1);\n\t\t\tu32 res_len = (u32) gf_utf8_wcstombs(utf8str, len, (const unsigned short **) &src_str);\n\t\t\tutf8str[res_len] = 0;\n\t\t\tfprintf(stderr, \"%s\\n\", utf8str);\n\n\t\t\tgf_free(utf8str);\n\t\t}\n\t}\n\n\n\tprint_udta(file, 0, has_itags);\n\tfprintf(stderr, \"\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tDumpTrackInfo(file, i+1, 0, GF_TRUE, dump_m4sys);\n\t}\n}\n\n#endif /*defined(GPAC_DISABLE_ISOM) || defined(GPAC_DISABLE_ISOM_WRITE)*/\n\n\n#ifndef GPAC_DISABLE_MPEG2TS\n\n\ntypedef struct\n{\n\t/* when writing to file */\n\tFILE *pes_out;\n\tchar dump[100];\n#if 0\n\tFILE *pes_out_nhml;\n\tchar nhml[100];\n\tFILE *pes_out_info;\n\tchar info[100];\n#endif\n\tBool is_info_dumped;\n\n\tu32 prog_number;\n\t/* For logging timing information (PCR, PTS/DTS) */\n\tFILE *timestamps_info_file;\n\tchar timestamps_info_name[100];\n\n\t/* when dumping TS information */\n\tu32 dump_pid;\n\tBool has_seen_pat;\n\n} GF_M2TS_Dump;\n\n\n\nstatic void on_m2ts_dump_event(GF_M2TS_Demuxer *ts, u32 evt_type, void *par)\n{\n\tu32 i, count;\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_PES_PCK *pck;\n\tGF_M2TS_Dump *dumper = (GF_M2TS_Dump *)ts->user;\n\n\tswitch (evt_type) {\n\tcase GF_M2TS_EVT_PAT_FOUND:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PAT_UPDATE:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PAT_REPEAT:\n\t\t/* WARNING: We detect the pat on a repetition, probably to ensure that we also have seen all the PMT\n\t\t   To be checked */\n\t\tdumper->has_seen_pat = 1;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n//\t\tfprintf(stderr, \"Repeated PAT found - %d programs\\n\", gf_list_count(ts->programs) );\n\t\tbreak;\n\tcase GF_M2TS_EVT_CAT_FOUND:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_CAT_UPDATE:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_CAT_REPEAT:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_FOUND:\n\t\tprog = (GF_M2TS_Program*)par;\n\t\tif (gf_list_count(ts->programs)>1 && prog->number!=dumper->prog_number)\n\t\t\tbreak;\n\n\t\tcount = gf_list_count(prog->streams);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Program number %d found - %d streams:\\n\", prog->number, count));\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_ES *es = gf_list_get(prog->streams, i);\n\t\t\tif (es->pid == prog->pmt_pid) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tPID %d: Program Map Table\\n\", es->pid));\n\t\t\t} else {\n\t\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\t\t\t\tgf_m2ts_set_pes_framing(pes, dumper->pes_out ? GF_M2TS_PES_FRAMING_RAW : GF_M2TS_PES_FRAMING_DEFAULT);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tPID %d: %s \", pes->pid, gf_m2ts_get_stream_name(pes->stream_type) ));\n\t\t\t\tif (pes->mpeg4_es_id) GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\" - MPEG-4 ES ID %d\", pes->mpeg4_es_id));\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\n\"));\n\t\t\t}\n\t\t}\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, prog->pmt_pid);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_UPDATE:\n\t\tprog = (GF_M2TS_Program*)par;\n\t\tif (gf_list_count(ts->programs)>1 && prog->number!=dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, prog->pmt_pid);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_REPEAT:\n\t\tprog = (GF_M2TS_Program*)par;\n\t\tif (gf_list_count(ts->programs)>1 && prog->number!=dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, prog->pmt_pid);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_SDT_FOUND:\n#ifndef GPAC_DISABLE_LOG\n\t\tcount = gf_list_count(ts->SDTs) ;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Program Description found - %d desc:\\n\", count));\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_SDT *sdt = gf_list_get(ts->SDTs, i);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tServiceID %d - Provider %s - Name %s\\n\", sdt->service_id, sdt->provider, sdt->service));\n\t\t}\n#endif\n\t\tbreak;\n\tcase GF_M2TS_EVT_SDT_UPDATE:\n#ifndef GPAC_DISABLE_LOG\n\t\tcount = gf_list_count(ts->SDTs) ;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Program Description updated - %d desc\\n\", count));\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_SDT *sdt = gf_list_get(ts->SDTs, i);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tServiceID %d - Provider %s - Name %s\\n\", sdt->service_id, sdt->provider, sdt->service));\n\t\t}\n#endif\n\t\tbreak;\n\tcase GF_M2TS_EVT_SDT_REPEAT:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_TIMING:\n\t\tpck = par;\n\t\tif (gf_list_count(ts->programs)>1 && pck->stream->program->number != dumper->prog_number)\n\t\t\tbreak;\n\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCK:\n\t\tpck = par;\n\t\tif (gf_list_count(ts->programs)>1 && pck->stream->program->number != dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->has_seen_pat) {\n\n\t\t\t/*We need the interpolated PCR for the pcrb, hence moved this calculus out, and saving the calculated value in index_info to put it in the pcrb*/\n\t\t\tGF_M2TS_PES *pes = pck->stream;\n\t\t\t/*FIXME : not used GF_M2TS_Program *prog = pes->program; */\n\t\t\t/* Interpolated PCR value for the TS packet containing the PES header start */\n\t\t\tu64 interpolated_pcr_value = 0;\n\t\t\tif (pes->last_pcr_value && pes->before_last_pcr_value_pck_number && pes->last_pcr_value > pes->before_last_pcr_value) {\n\t\t\t\tu32 delta_pcr_pck_num = pes->last_pcr_value_pck_number - pes->before_last_pcr_value_pck_number;\n\t\t\t\tu32 delta_pts_pcr_pck_num = pes->pes_start_packet_number - pes->last_pcr_value_pck_number;\n\t\t\t\tu64 delta_pcr_value = pes->last_pcr_value - pes->before_last_pcr_value;\n\t\t\t\tif ((pes->pes_start_packet_number > pes->last_pcr_value_pck_number)\n\t\t\t\t        && (pes->last_pcr_value > pes->before_last_pcr_value)) {\n\n\t\t\t\t\tpes->last_pcr_value = pes->before_last_pcr_value;\n\t\t\t\t}\n\t\t\t\t/* we can compute the interpolated pcr value for the packet containing the PES header */\n\t\t\t\tinterpolated_pcr_value = pes->last_pcr_value + (u64)((delta_pcr_value*delta_pts_pcr_pck_num*1.0)/delta_pcr_pck_num);\n\t\t\t}\n\n\t\t\tif (dumper->timestamps_info_file) {\n\t\t\t\tDouble diff;\n\t\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\t\", pck->stream->pes_start_packet_number, pck->stream->pid);\n\t\t\t\tif (interpolated_pcr_value) fprintf(dumper->timestamps_info_file, \"%f\", interpolated_pcr_value/(300.0 * 90000));\n\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t\");\n\t\t\t\tif (pck->DTS) fprintf(dumper->timestamps_info_file, \"%f\", (pck->DTS / 90000.0));\n\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t%f\\t%d\\t%d\", pck->PTS / 90000.0, (pck->flags & GF_M2TS_PES_PCK_RAP) ? 1 : 0, (pck->flags & GF_M2TS_PES_PCK_DISCONTINUITY) ? 1 : 0);\n\t\t\t\tif (interpolated_pcr_value) {\n\t\t\t\t\tdiff = (pck->DTS ? pck->DTS : pck->PTS) / 90000.0;\n\t\t\t\t\tdiff -= pes->last_pcr_value / (300.0 * 90000);\n\t\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t%f\\n\", diff);\n\t\t\t\t\tif (diff<0) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: detected PTS/DTS value less than current PCR of %g sec\\n\", diff));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dumper->has_seen_pat && dumper->pes_out && (dumper->dump_pid == pck->stream->pid)) {\n\t\t\tgf_fwrite(pck->data, pck->data_len, dumper->pes_out);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCR:\n\t\tpck = par;\n\t\tif (gf_list_count(ts->programs)>1 && pck->stream->program->number != dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\t%f\\t\\t\\t\\t%d\\n\", pck->stream->program->last_pcr_value_pck_number, pck->stream->pid, pck->PTS / (300*90000.0), (pck->flags & GF_M2TS_PES_PCK_DISCONTINUITY) ? 1 : 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_SL_PCK:\n#if 0\n\t{\n\t\tGF_M2TS_SL_PCK *sl_pck = par;\n\t\tif (dumper->pes_out && (dumper->dump_pid == sl_pck->stream->pid)) {\n\t\t\tGF_SLHeader header;\n\t\t\tu32 header_len;\n\t\t\tif (sl_pck->stream->mpeg4_es_id) {\n\t\t\t\tGF_ESD *esd = ((GF_M2TS_PES*)sl_pck->stream)->esd;\n\t\t\t\tif (!dumper->is_info_dumped) {\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) gf_fwrite(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, dumper->pes_out_info);\n\t\t\t\t\tdumper->is_info_dumped = 1;\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"<NHNTStream version=\\\"1.0\\\" \");\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"timeScale=\\\"%d\\\" \", esd->slConfig->timestampResolution);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"streamType=\\\"%d\\\" \", esd->decoderConfig->streamType);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"objectTypeIndication=\\\"%d\\\" \", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) fprintf(dumper->pes_out_nhml, \"specificInfoFile=\\\"%s\\\" \", dumper->info);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"baseMediaFile=\\\"%s\\\" \", dumper->dump);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"inRootOD=\\\"yes\\\">\\n\");\n\t\t\t\t}\n\t\t\t\tgf_sl_depacketize(esd->slConfig, &header, sl_pck->data, sl_pck->data_len, &header_len);\n\t\t\t\tgf_fwrite(sl_pck->data+header_len, sl_pck->data_len-header_len, dumper->pes_out);\n\t\t\t\tfprintf(dumper->pes_out_nhml, \"<NHNTSample DTS=\\\"\"LLD\"\\\" dataLength=\\\"%d\\\" isRAP=\\\"%s\\\"/>\\n\", header.decodingTimeStamp, sl_pck->data_len-header_len, (header.randomAccessPointFlag?\"yes\":\"no\"));\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tbreak;\n\t}\n}\n\nvoid dump_mpeg2_ts(char *mpeg2ts_file, char *out_name, Bool prog_num)\n{\n\tu8 data[188];\n\tGF_M2TS_Dump dumper;\n\n\tu32 size;\n\tu64 fsize, fdone;\n\tGF_M2TS_Demuxer *ts;\n\tFILE *src;\n\n\tif (!prog_num && !out_name) {\n\t\tfprintf(stderr, \"No program number nor output filename specified. No timestamp file will be generated.\");\n\t}\n\n\tsrc = gf_fopen(mpeg2ts_file, \"rb\");\n\tif (!src) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open %s: no such file\\n\", mpeg2ts_file));\n\t\treturn;\n\t}\n\tts = gf_m2ts_demux_new();\n\tts->on_event = on_m2ts_dump_event;\n\tts->notify_pes_timing = 1;\n\tmemset(&dumper, 0, sizeof(GF_M2TS_Dump));\n\tts->user = &dumper;\n\tdumper.prog_number = prog_num;\n\n\t/*PES dumping*/\n\tif (out_name) {\n\t\tchar *pid = strrchr(out_name, '#');\n\t\tif (pid) {\n\t\t\tdumper.dump_pid = atoi(pid+1);\n\t\t\tpid[0] = 0;\n\t\t\tsprintf(dumper.dump, \"%s_%d.raw\", out_name, dumper.dump_pid);\n\t\t\tdumper.pes_out = gf_fopen(dumper.dump, \"wb\");\n#if 0\n\t\t\tsprintf(dumper.nhml, \"%s_%d.nhml\", pes_out_name, dumper.dump_pid);\n\t\t\tdumper.pes_out_nhml = gf_fopen(dumper.nhml, \"wt\");\n\t\t\tsprintf(dumper.info, \"%s_%d.info\", pes_out_name, dumper.dump_pid);\n\t\t\tdumper.pes_out_info = gf_fopen(dumper.info, \"wb\");\n#endif\n\t\t\tpid[0] = '#';\n\t\t}\n\t}\n\n\tgf_fseek(src, 0, SEEK_END);\n\tfsize = gf_ftell(src);\n\tgf_fseek(src, 0, SEEK_SET);\n\n\t/* first loop to process all packets between two PAT, and assume all signaling was found between these 2 PATs */\n\twhile (!feof(src)) {\n\t\tsize = (u32) gf_fread(data, 188, src);\n\t\tif (size<188) break;\n\n\t\tgf_m2ts_process_data(ts, data, size);\n\t\tif (dumper.has_seen_pat) break;\n\t}\n\tdumper.has_seen_pat = GF_TRUE;\n\n\tif (!prog_num) {\n\t\tGF_M2TS_Program *p = gf_list_get(ts->programs, 0);\n\t\tif (p) prog_num = p->number;\n\t\tfprintf(stderr, \"No program number specified, defaulting to first program\\n\");\n\t}\n\n\tif (!prog_num && !out_name) {\n\t\tfprintf(stderr, \"No program number nor output filename specified. No timestamp file will be generated\\n\");\n\t}\n\n\tif (prog_num) {\n\t\tsprintf(dumper.timestamps_info_name, \"%s_prog_%d_timestamps.txt\", mpeg2ts_file, prog_num/*, mpeg2ts_file*/);\n\t\tdumper.timestamps_info_file = gf_fopen(dumper.timestamps_info_name, \"wt\");\n\t\tif (!dumper.timestamps_info_file) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open file %s\\n\", dumper.timestamps_info_name));\n\t\t\treturn;\n\t\t}\n\t\tfprintf(dumper.timestamps_info_file, \"PCK#\\tPID\\tPCR\\tDTS\\tPTS\\tRAP\\tDiscontinuity\\tDTS-PCR Diff\\n\");\n\t}\n\n\tgf_m2ts_reset_parsers(ts);\n\tgf_fseek(src, 0, SEEK_SET);\n\tfdone = 0;\n\n\twhile (!feof(src)) {\n\t\tsize = (u32) gf_fread(data, 188, src);\n\t\tif (size<188) break;\n\n\t\tgf_m2ts_process_data(ts, data, size);\n\n\t\tfdone += size;\n\t\tgf_set_progress(\"MPEG-2 TS Parsing\", fdone, fsize);\n\t}\n\n\tgf_fclose(src);\n\tgf_m2ts_demux_del(ts);\n\tif (dumper.pes_out) gf_fclose(dumper.pes_out);\n#if 0\n\tif (dumper.pes_out_nhml) {\n\t\tif (dumper.is_info_dumped) fprintf(dumper.pes_out_nhml, \"</NHNTStream>\\n\");\n\t\tgf_fclose(dumper.pes_out_nhml);\n\t\tgf_fclose(dumper.pes_out_info);\n\t}\n#endif\n\tif (dumper.timestamps_info_file) gf_fclose(dumper.timestamps_info_file);\n}\n\n#endif /*GPAC_DISABLE_MPEG2TS*/\n\n\n#include <gpac/download.h>\n#include <gpac/mpd.h>\n\nvoid get_file_callback(void *usr_cbk, GF_NETIO_Parameter *parameter)\n{\n\tif (parameter->msg_type==GF_NETIO_DATA_EXCHANGE) {\n\t\tu64 tot_size, done, max;\n\t\tu32 bps;\n\t\tgf_dm_sess_get_stats(parameter->sess, NULL, NULL, &tot_size, &done, &bps, NULL);\n\t\tif (tot_size) {\n\t\t\tmax = done;\n\t\t\tmax *= 100;\n\t\t\tmax /= tot_size;\n\t\t\tfprintf(stderr, \"download %02d %% at %05d kpbs\\r\", (u32) max, bps*8/1000);\n\t\t}\n\t}\n}\n\nstatic GF_DownloadSession *get_file(const char *url, GF_DownloadManager *dm, GF_Err *e)\n{\n\tGF_DownloadSession *sess;\n\tsess = gf_dm_sess_new(dm, url, GF_NETIO_SESSION_NOT_THREADED, get_file_callback, NULL, e);\n\tif (!sess) return NULL;\n\t*e = gf_dm_sess_process(sess);\n\tif (*e) {\n\t\tgf_dm_sess_del(sess);\n\t\treturn NULL;\n\t}\n\treturn sess;\n}\n\nstatic void revert_cache_file(char *item_path)\n{\n\tchar szPATH[GF_MAX_PATH];\n\tconst char *url;\n\tGF_Config *cached;\n\n\tif (!strstr(item_path, \"gpac_cache_\")) {\n\t\tfprintf(stderr, \"%s is not a gpac cache file\\n\", item_path);\n\t\treturn;\n\t}\n\tif (!strncmp(item_path, \"./\", 2) || !strncmp(item_path, \".\\\\\", 2))\n\t\t\titem_path += 2;\n\n \tstrcpy(szPATH, item_path);\n\tstrcat(szPATH, \".txt\");\n\n\tcached = gf_cfg_new(NULL, szPATH);\n\turl = gf_cfg_get_key(cached, \"cache\", \"url\");\n\tif (url) url = strstr(url, \"://\");\n\tif (url) {\n\t\tu32 i, len, dir_len=0, k=0;\n\t\tchar *sep;\n\t\tchar *dst_name;\n\t\tsep = strstr(item_path, \"gpac_cache_\");\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tdir_len = (u32) strlen(item_path);\n\t\t\tsep[0] = 'g';\n\t\t}\n\t\turl+=3;\n\t\tlen = (u32) strlen(url);\n\t\tdst_name = gf_malloc(len+dir_len+1);\n\t\tmemset(dst_name, 0, len+dir_len+1);\n\n\t\tstrncpy(dst_name, item_path, dir_len);\n\t\tk=dir_len;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tdst_name[k] = url[i];\n\t\t\tif (dst_name[k]==':') dst_name[k]='_';\n\t\t\telse if (dst_name[k]=='/') {\n\t\t\t\tif (!gf_dir_exists(dst_name))\n\t\t\t\t\tgf_mkdir(dst_name);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tif (gf_file_exists(item_path)) {\n\t\t\tgf_file_move(item_path, dst_name);\n\t\t}\n\n\t\tgf_free(dst_name);\n\t} else {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to reverse %s cache file\\n\", item_path));\n\t}\n\tgf_cfg_del(cached);\n\tgf_file_delete(szPATH);\n}\n\nGF_Err rip_mpd(const char *mpd_src, const char *output_dir)\n{\n\tGF_DownloadSession *sess;\n\tu32 i, connect_time, reply_time, download_time, req_hdr_size, rsp_hdr_size;\n\tGF_Err e;\n\tGF_DOMParser *mpd_parser=NULL;\n\tGF_MPD *mpd=NULL;\n\tGF_MPD_Period *period;\n\tGF_MPD_AdaptationSet *as;\n\tGF_MPD_Representation *rep;\n\tchar szName[GF_MAX_PATH];\n\tGF_DownloadManager *dm;\n\n\tif (output_dir) {\n\t\tchar *sep;\n\t\tstrcpy(szName, output_dir);\n\t\tsep = gf_file_basename(szName);\n\t\tif (sep) sep[0] = 0;\n\t\tgf_opts_set_key(\"temp\", \"cache\", szName);\n\t} else {\n\t\tgf_opts_set_key(\"temp\", \"cache\", \".\");\n\t}\n\tgf_opts_set_key(\"temp\", \"clean-cache\", \"true\");\n\tdm = gf_dm_new(NULL);\n\n/*\n\tchar *name = strrchr(mpd_src, '/');\n\tif (!name) name = strrchr(mpd_src, '\\\\');\n\tif (!name) name = \"manifest.mpd\";\n\telse name ++;\n\n\tif (strchr(name, '?') || strchr(name, '&')) name = \"manifest.mpd\";\n*/\n\n\tfprintf(stderr, \"Downloading %s\\n\", mpd_src);\n\tsess = get_file(mpd_src, dm, &e);\n\tif (!sess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error downloading MPD file %s: %s\\n\", mpd_src, gf_error_to_string(e) ));\n\t\tgoto err_exit;\n\t}\n\tstrcpy(szName, gf_dm_sess_get_cache_name(sess) );\n\tgf_dm_sess_get_header_sizes_and_times(sess, &req_hdr_size, &rsp_hdr_size, &connect_time, &reply_time, &download_time);\n\tgf_dm_sess_del(sess);\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error fetching MPD file %s: %s\\n\", mpd_src, gf_error_to_string(e)));\n\t\tgoto err_exit;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Fetched file %s\\n\", mpd_src));\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_APP, (\"GET Header size %d - Reply header size %d\\n\", req_hdr_size, rsp_hdr_size));\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_APP, (\"GET time: Connect Time %d - Reply Time %d - Download Time %d\\n\", connect_time, reply_time, download_time));\n\n\tmpd_parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(mpd_parser, szName, NULL, NULL);\n\n\tif (e != GF_OK) {\n\t\tgf_xml_dom_del(mpd_parser);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error parsing MPD %s : %s\\n\", mpd_src, gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\tmpd = gf_mpd_new();\n\te = gf_mpd_init_from_dom(gf_xml_dom_get_root(mpd_parser), mpd, mpd_src);\n\tgf_xml_dom_del(mpd_parser);\n\tmpd_parser=NULL;\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error initializing MPD %s : %s\\n\", mpd_src, gf_error_to_string(e)));\n\t\tgoto err_exit;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_APP, (\"MPD %s initialized: %s\\n\", szName, gf_error_to_string(e)));\n\t}\n\n\trevert_cache_file(szName);\n\tif (mpd->type==GF_MPD_TYPE_DYNAMIC) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"MPD rip is not supported on live sources\\n\"));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto err_exit;\n\t}\n\n\ti=0;\n\twhile ((period = (GF_MPD_Period *) gf_list_enum(mpd->periods, &i))) {\n\t\tchar *initTemplate = NULL;\n\t\tBool segment_base = GF_FALSE;\n\t\tu32 j=0;\n\n\t\tif (period->segment_base) segment_base=GF_TRUE;\n\n\t\tif (period->segment_template && period->segment_template->initialization) {\n\t\t\tinitTemplate = period->segment_template->initialization;\n\t\t}\n\n\t\twhile ((as = gf_list_enum(period->adaptation_sets, &j))) {\n\t\t\tu32 k=0;\n\t\t\tif (!initTemplate && as->segment_template && as->segment_template->initialization) {\n\t\t\t\tinitTemplate = as->segment_template->initialization;\n\t\t\t}\n\t\t\tif (as->segment_base) segment_base=GF_TRUE;\n\n\t\t\twhile ((rep = gf_list_enum(as->representations, &k))) {\n\t\t\t\tu64 out_range_start, out_range_end, segment_duration;\n\t\t\t\tBool is_in_base_url;\n\t\t\t\tchar *seg_url;\n\t\t\t\tu32 seg_idx=0;\n\t\t\t\tif (rep->segment_template && rep->segment_template->initialization) {\n\t\t\t\t\tinitTemplate = rep->segment_template->initialization;\n\t\t\t\t} else if (k>1) {\n\t\t\t\t\tinitTemplate = NULL;\n\t\t\t\t}\n\t\t\t\tif (rep->segment_base) segment_base=GF_TRUE;\n\n\t\t\t\te = gf_mpd_resolve_url(mpd, rep, as, period, mpd_src, 0, GF_MPD_RESOLVE_URL_INIT, 0, 0, &seg_url, &out_range_start, &out_range_end, &segment_duration, &is_in_base_url, NULL, NULL, NULL);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error resolving init segment name : %s\\n\", gf_error_to_string(e)));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//not a byte range, replace URL\n\t\t\t\tif (segment_base) {\n\n\t\t\t\t} else if (out_range_start || out_range_end || !seg_url) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"byte range rip not yet implemented\\n\"));\n\t\t\t\t\tif (seg_url) gf_free(seg_url);\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\n\t\t\t\tfprintf(stderr, \"Downloading %s\\n\", seg_url);\n\t\t\t\tsess = get_file(seg_url, dm, &e);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error downloading init segment %s from MPD %s : %s\\n\", seg_url, mpd_src, gf_error_to_string(e)));\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\trevert_cache_file((char *) gf_dm_sess_get_cache_name(sess) );\n\t\t\t\tgf_free(seg_url);\n\t\t\t\tgf_dm_sess_del(sess);\n\n\t\t\t\tif (segment_base) continue;\n\n\t\t\t\twhile (1) {\n\t\t\t\t\te = gf_mpd_resolve_url(mpd, rep, as, period, mpd_src, 0, GF_MPD_RESOLVE_URL_MEDIA, seg_idx, 0, &seg_url, &out_range_start, &out_range_end, &segment_duration, NULL, NULL, NULL, NULL);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tif (e<0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error resolving segment name : %s\\n\", gf_error_to_string(e)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tseg_idx++;\n\n\t\t\t\t\tif (out_range_start || out_range_end || !seg_url) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"byte range rip not yet implemented\\n\"));\n\t\t\t\t\t\tif (seg_url) gf_free(seg_url);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"Downloading %s\\n\", seg_url);\n\t\t\t\t\tsess = get_file(seg_url, dm, &e);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_free(seg_url);\n\t\t\t\t\t\tif (e != GF_URL_ERROR) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error downloading segment %s: %s\\n\", seg_url, gf_error_to_string(e)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//todo, properly detect end of dash representation\n\t\t\t\t\t\t\te = GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trevert_cache_file((char *) gf_dm_sess_get_cache_name(sess) );\n\t\t\t\t\tgf_free(seg_url);\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nerr_exit:\n\tif (mpd) gf_mpd_del(mpd);\n\tgf_dm_del(dm);\n\treturn e;\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / mp4box application\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"mp4box.h\"\n\n#if defined(GPAC_DISABLE_ISOM) || defined(GPAC_DISABLE_ISOM_WRITE)\n\n#error \"Cannot compile MP4Box if GPAC is not built with ISO File Format support\"\n\n#else\n\n#ifndef GPAC_DISABLE_X3D\n#include <gpac/nodes_x3d.h>\n#endif\n#ifndef GPAC_DISABLE_BIFS\n#include <gpac/internal/bifs_dev.h>\n#endif\n#ifndef GPAC_DISABLE_VRML\n#include <gpac/nodes_mpeg4.h>\n#endif\n#include <gpac/constants.h>\n#include <gpac/avparse.h>\n#include <gpac/internal/media_dev.h>\n/*ISO 639 languages*/\n#include <gpac/iso639.h>\n#include <gpac/mpegts.h>\n\n#ifndef GPAC_DISABLE_SMGR\n#include <gpac/scene_manager.h>\n#endif\n#include <gpac/internal/media_dev.h>\n#include <gpac/media_tools.h>\n/*for built-in box printing*/\n#include <gpac/internal/isomedia_dev.h>\n\nextern u32 swf_flags;\nextern Float swf_flatten_angle;\nextern GF_FileType get_file_type_by_ext(char *inName);\nextern u32 fs_dump_flags;\n\nvoid scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist);\n\n\n#ifdef GPAC_DISABLE_LOG\nvoid mp4box_log(const char *fmt, ...)\n{\n\tva_list vl;\n\tva_start(vl, fmt);\n\tvfprintf(stderr, fmt, vlist);\n\tfflush(stderr);\n\tva_end(vl);\n}\n#endif\n\n\nu32 PrintLanguages(char *val, u32 opt)\n{\n\tu32 i=0, count = gf_lang_get_count();\n\tfprintf(stderr, \"Supported ISO 639 languages and codes:\\n\\n\");\n\tfor (i=0; i<count; i++) {\n\t\tif (gf_lang_get_2cc(i)) {\n\t\t\tfprintf(stderr, \"%s (%s - %s)\\n\", gf_lang_get_name(i), gf_lang_get_3cc(i), gf_lang_get_2cc(i));\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic const char *GetLanguage(char *lcode)\n{\n\ts32 idx = gf_lang_find(lcode);\n\tif (idx>=0) return gf_lang_get_name(idx);\n\treturn lcode;\n}\n\nGF_Err dump_isom_cover_art(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst u8 *tag;\n\tFILE *t;\n\tu32 tag_len;\n\tGF_Err e = gf_isom_apple_get_tag(file, GF_ISOM_ITUNE_COVER_ART, &tag, &tag_len);\n\tif (e!=GF_OK) {\n\t\tif (e==GF_URL_ERROR) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"No cover art found\\n\"));\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn e;\n\t}\n\n\tif (inName) {\n\t\tchar szName[1024];\n\t\tif (is_final_name) {\n\t\t\tstrcpy(szName, inName);\n\t\t} else {\n\t\t\tsprintf(szName, \"%s.%s\", inName, (tag_len>>31) ? \"png\" : \"jpg\");\n\t\t}\n\t\tt = gf_fopen(szName, \"wb\");\n\t\tif (!t) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szName));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t} else {\n\t\tt = stdout;\n\t}\n\tgf_fwrite(tag, tag_len & 0x7FFFFFFF, t);\n\n\tif (inName) gf_fclose(t);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\nGF_Err dump_isom_scene(char *file, char *inName, Bool is_final_name, GF_SceneDumpFormat dump_mode, Bool do_log, Bool no_odf_conv)\n{\n\tGF_Err e;\n\tGF_SceneManager *ctx;\n\tGF_SceneGraph *sg;\n\tGF_SceneLoader load;\n\tGF_FileType ftype;\n\tgf_log_cbk prev_logs = NULL;\n\tFILE *logs = NULL;\n\n\tsg = gf_sg_new();\n\tctx = gf_sm_new(sg);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = file;\n\tload.ctx = ctx;\n\tload.swf_import_flags = swf_flags;\n\tif (dump_mode == GF_SM_DUMP_SVG) {\n\t\tload.swf_import_flags |= GF_SM_SWF_USE_SVG;\n\t\tload.svgOutFile = inName;\n\t}\n\tload.swf_flatten_limit = swf_flatten_angle;\n\n\tftype = get_file_type_by_ext(file);\n\tif (ftype == GF_FILE_TYPE_ISO_MEDIA) {\n\t\tload.isom = gf_isom_open(file, GF_ISOM_OPEN_READ, NULL);\n\t\tif (!load.isom) {\n\t\t\te = gf_isom_last_error(NULL);\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error opening file: %s\\n\", gf_error_to_string(e)));\n\t\t\tgf_sm_del(ctx);\n\t\t\tgf_sg_del(sg);\n\t\t\treturn e;\n\t\t}\n\t\tif (no_odf_conv)\n\t\t\tgf_isom_disable_odf_conversion(load.isom, GF_TRUE);\n\n\t} else if (ftype==GF_FILE_TYPE_LSR_SAF) {\n\t\tload.isom = gf_isom_open(\"saf_conv\", GF_ISOM_WRITE_EDIT, NULL);\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tif (load.isom) {\n\t\t\tGF_Fraction _frac = {0,0};\n\t\t\te = import_file(load.isom, file, 0, _frac, 0, NULL, NULL, 0);\n\t\t} else\n#else\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: GPAC was compiled without Media Import support\\n\"));\n#endif\n\t\t\te = gf_isom_last_error(NULL);\n\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing file: %s\\n\", gf_error_to_string(e)));\n\t\t\tgf_sm_del(ctx);\n\t\t\tgf_sg_del(sg);\n\t\t\tif (load.isom) gf_isom_delete(load.isom);\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tif (do_log) {\n\t\tchar szLog[GF_MAX_PATH];\n\t\tsprintf(szLog, \"%s_dec.logs\", inName);\n\t\tlogs = gf_fopen(szLog, \"wt\");\n\n\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_DEBUG);\n\t\tprev_logs = gf_log_set_callback(logs, scene_coding_log);\n\t}\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (logs) {\n\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_ERROR);\n\t\tgf_log_set_callback(NULL, prev_logs);\n\t\tgf_fclose(logs);\n\t}\n\tif (!e && dump_mode != GF_SM_DUMP_SVG) {\n\t\tu32 count = gf_list_count(ctx->streams);\n\t\tif (count)\n\t\t\tfprintf(stderr, \"Scene loaded - dumping %d systems streams\\n\", count);\n\t\telse\n\t\t\tfprintf(stderr, \"Scene loaded - dumping root scene\\n\");\n\n\t\te = gf_sm_dump(ctx, inName, is_final_name, dump_mode);\n\t}\n\n\tgf_sm_del(ctx);\n\tgf_sg_del(sg);\n\tif (e) M4_LOG(GF_LOG_ERROR, (\"Error loading scene: %s\\n\", gf_error_to_string(e)));\n\tif (load.isom) gf_isom_delete(load.isom);\n\treturn e;\n}\n#endif\n\n#ifndef GPAC_DISABLE_SCENE_STATS\n\nstatic void dump_stats(FILE *dump, const GF_SceneStatistics *stats)\n{\n\tu32 i;\n\ts32 created, count, draw_created, draw_count, deleted, draw_deleted;\n\tcreated = count = draw_created = draw_count = deleted = draw_deleted = 0;\n\n\tfprintf(dump, \"<NodeStatistics>\\n\");\n\tfprintf(dump, \"<General NumberOfNodeTypes=\\\"%d\\\"/>\\n\", gf_list_count(stats->node_stats));\n\tfor (i=0; i<gf_list_count(stats->node_stats); i++) {\n\t\tGF_NodeStats *ptr = gf_list_get(stats->node_stats, i);\n\t\tfprintf(dump, \"<NodeStat NodeName=\\\"%s\\\">\\n\", ptr->name);\n\n\t\tswitch (ptr->tag) {\n#ifndef GPAC_DISABLE_VRML\n\t\tcase TAG_MPEG4_Bitmap:\n\t\tcase TAG_MPEG4_Background2D:\n\t\tcase TAG_MPEG4_Background:\n\t\tcase TAG_MPEG4_Box:\n\t\tcase TAG_MPEG4_Circle:\n\t\tcase TAG_MPEG4_CompositeTexture2D:\n\t\tcase TAG_MPEG4_CompositeTexture3D:\n\t\tcase TAG_MPEG4_Cylinder:\n\t\tcase TAG_MPEG4_Cone:\n\t\tcase TAG_MPEG4_Curve2D:\n\t\tcase TAG_MPEG4_Extrusion:\n\t\tcase TAG_MPEG4_ElevationGrid:\n\t\tcase TAG_MPEG4_IndexedFaceSet2D:\n\t\tcase TAG_MPEG4_IndexedFaceSet:\n\t\tcase TAG_MPEG4_IndexedLineSet2D:\n\t\tcase TAG_MPEG4_IndexedLineSet:\n\t\tcase TAG_MPEG4_PointSet2D:\n\t\tcase TAG_MPEG4_PointSet:\n\t\tcase TAG_MPEG4_Rectangle:\n\t\tcase TAG_MPEG4_Sphere:\n\t\tcase TAG_MPEG4_Text:\n\t\tcase TAG_MPEG4_Ellipse:\n\t\tcase TAG_MPEG4_XCurve2D:\n\t\t\tdraw_count += ptr->nb_created + ptr->nb_used - ptr->nb_del;\n\t\t\tdraw_deleted += ptr->nb_del;\n\t\t\tdraw_created += ptr->nb_created;\n\t\t\tbreak;\n#endif /*GPAC_DISABLE_VRML*/\n\t\t}\n\t\tfprintf(dump, \"<Instanciation NbObjects=\\\"%d\\\" NbUse=\\\"%d\\\" NbDestroy=\\\"%d\\\"/>\\n\", ptr->nb_created, ptr->nb_used, ptr->nb_del);\n\t\tcount += ptr->nb_created + ptr->nb_used;\n\t\tdeleted += ptr->nb_del;\n\t\tcreated += ptr->nb_created;\n\t\tfprintf(dump, \"</NodeStat>\\n\");\n\t}\n\tif (i) {\n\t\tfprintf(dump, \"<CumulatedStat TotalNumberOfNodes=\\\"%d\\\" ReallyAllocatedNodes=\\\"%d\\\" DeletedNodes=\\\"%d\\\" NumberOfAttributes=\\\"%d\\\"/>\\n\", count, created, deleted, stats->nb_svg_attributes);\n\t\tfprintf(dump, \"<DrawableNodesCumulatedStat TotalNumberOfNodes=\\\"%d\\\" ReallyAllocatedNodes=\\\"%d\\\" DeletedNodes=\\\"%d\\\"/>\\n\", draw_count, draw_created, draw_deleted);\n\t}\n\tfprintf(dump, \"</NodeStatistics>\\n\");\n\n\tcreated = count = deleted = 0;\n\tif (gf_list_count(stats->proto_stats)) {\n\t\tfprintf(dump, \"<ProtoStatistics NumberOfProtoUsed=\\\"%d\\\">\\n\", gf_list_count(stats->proto_stats));\n\t\tfor (i=0; i<gf_list_count(stats->proto_stats); i++) {\n\t\t\tGF_NodeStats *ptr = gf_list_get(stats->proto_stats, i);\n\t\t\tfprintf(dump, \"<ProtoStat ProtoName=\\\"%s\\\">\\n\", ptr->name);\n\t\t\tfprintf(dump, \"<Instanciation NbObjects=\\\"%d\\\" NbUse=\\\"%d\\\" NbDestroy=\\\"%d\\\"/>\\n\", ptr->nb_created, ptr->nb_used, ptr->nb_del);\n\t\t\tcount += ptr->nb_created + ptr->nb_used;\n\t\t\tdeleted += ptr->nb_del;\n\t\t\tcreated += ptr->nb_created;\n\t\t\tfprintf(dump, \"</ProtoStat>\\n\");\n\t\t}\n\t\tif (i) fprintf(dump, \"<CumulatedStat TotalNumberOfProtos=\\\"%d\\\" ReallyAllocatedProtos=\\\"%d\\\" DeletedProtos=\\\"%d\\\"/>\\n\", count, created, deleted);\n\t\tfprintf(dump, \"</ProtoStatistics>\\n\");\n\t}\n\tfprintf(dump, \"<FixedValues min=\\\"%f\\\" max=\\\"%f\\\">\\n\", FIX2FLT( stats->min_fixed) , FIX2FLT( stats->max_fixed ));\n\tfprintf(dump, \"<Resolutions scaleIntegerPart=\\\"%d\\\" scaleFracPart=\\\"%d\\\" coordIntegerPart=\\\"%d\\\" coordFracPart=\\\"%d\\\"/>\\n\", stats->scale_int_res_2d, stats->scale_frac_res_2d, stats->int_res_2d, stats->frac_res_2d);\n\tfprintf(dump, \"</FixedValues>\\n\");\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MFVec2f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\\n\", stats->count_2d, stats->rem_2d);\n\tif (stats->count_2d) {\n\t\tfprintf(dump, \"<ExtendInfo MinVec2f=\\\"%f %f\\\" MaxVec2f=\\\"%f %f\\\"/>\\n\", FIX2FLT( stats->min_2d.x) , FIX2FLT( stats->min_2d.y ), FIX2FLT( stats->max_2d.x ), FIX2FLT( stats->max_2d.y ) );\n\t}\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MFVec3f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\", stats->count_3d, stats->rem_3d);\n\tif (stats->count_3d) {\n\t\tfprintf(dump, \"<ExtendInfo MinVec3f=\\\"%f %f %f\\\" MaxVec3f=\\\"%f %f %f\\\"/>\\n\", FIX2FLT( stats->min_3d.x ), FIX2FLT( stats->min_3d.y ), FIX2FLT( stats->min_3d.z ), FIX2FLT( stats->max_3d.x ), FIX2FLT( stats->max_3d.y ), FIX2FLT( stats->max_3d.z ) );\n\t}\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MF/SFColor\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\", stats->count_color, stats->rem_color);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"MF/SFFloat\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\" NumRemoved=\\\"%d\\\"/>\", stats->count_float, stats->rem_float);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"SFVec2f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\"/>\", stats->count_2f);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n\tfprintf(dump, \"<FieldStatistic FieldType=\\\"SFVec3f\\\">\\n\");\n\tfprintf(dump, \"<ParsingInfo NumParsed=\\\"%d\\\"/>\", stats->count_3f);\n\tfprintf(dump, \"</FieldStatistic>\\n\");\n}\n\n\nstatic void ReorderAU(GF_List *sample_list, GF_AUContext *au)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(sample_list); i++) {\n\t\tGF_AUContext *ptr = gf_list_get(sample_list, i);\n\t\tif (\n\t\t    /*time ordered*/\n\t\t    (ptr->timing_sec > au->timing_sec)\n\t\t    /*set bifs first*/\n\t\t    || ((ptr->timing_sec == au->timing_sec) && (ptr->owner->streamType < au->owner->streamType))\n\t\t) {\n\t\t\tgf_list_insert(sample_list, au, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_list_add(sample_list, au);\n}\n\nvoid dump_isom_scene_stats(char *file, char *inName, Bool is_final_name, u32 stat_level)\n{\n\tGF_Err e;\n\tFILE *dump;\n\tBool close;\n\tu32 i, j, count;\n\tchar szBuf[1024];\n\tGF_SceneManager *ctx;\n\tGF_SceneLoader load;\n\tGF_StatManager *sm;\n\tGF_List *sample_list;\n\tGF_SceneGraph *scene_graph;\n\n\tdump = NULL;\n\tsm = NULL;\n\tsample_list = NULL;\n\n\tclose = 0;\n\n\tscene_graph = gf_sg_new();\n\tctx = gf_sm_new(scene_graph);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = file;\n\tload.ctx = ctx;\n\n\tif (get_file_type_by_ext(file) == 1) {\n\t\tload.isom = gf_isom_open(file, GF_ISOM_OPEN_READ, NULL);\n\t\tif (!load.isom) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open file: %s\\n\", gf_error_to_string(gf_isom_last_error(NULL))));\n\t\t\tgf_sm_del(ctx);\n\t\t\tgf_sg_del(scene_graph);\n\t\t\treturn;\n\t\t}\n\t}\n\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (e<0) goto exit;\n\n\tif (inName) {\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_stat.xml\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t\tclose = 1;\n\t} else {\n\t\tdump = stdout;\n\t\tclose = 0;\n\t}\n\n\tfprintf(stderr, \"Analysing Scene\\n\");\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tfprintf(dump, \"<!-- Scene Graph Statistics Generated by MP4Box - GPAC \");\n\tif (! gf_sys_is_test_mode())\n\t\tfprintf(dump, \"%s \",  gf_gpac_version());\n\tfprintf(dump, \"-->\\n\");\n\n\tfprintf(dump, \"<SceneStatistics file=\\\"%s\\\" DumpType=\\\"%s\\\">\\n\", gf_file_basename(file), (stat_level==1) ? \"full scene\" : ((stat_level==2) ? \"AccessUnit based\" : \"SceneGraph after each AU\"));\n\n\tsm = gf_sm_stats_new();\n\n\t/*stat level 1: complete scene stat*/\n\tif (stat_level == 1) {\n\t\te = gf_sm_stats_for_scene(sm, ctx);\n\t\tif (!e) dump_stats(dump, gf_sm_stats_get(sm) );\n\t\tgoto exit;\n\t}\n\t/*re_order all BIFS-AUs*/\n\tsample_list = gf_list_new();\n\t/*configure all systems streams we're dumping*/\n\tfor (i=0; i<gf_list_count(ctx->streams); i++) {\n\t\tGF_StreamContext *sc = gf_list_get(ctx->streams, i);\n\t\tif (sc->streamType != GF_STREAM_SCENE) continue;\n\t\tfor (j=0; j<gf_list_count(sc->AUs); j++) {\n\t\t\tGF_AUContext *au = gf_list_get(sc->AUs, j);\n\t\t\tReorderAU(sample_list, au);\n\t\t}\n\t}\n\n\tcount = gf_list_count(sample_list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AUContext *au = gf_list_get(sample_list, i);\n\n\t\tfor (j=0; j<gf_list_count(au->commands); j++) {\n\t\t\tGF_Command *com = gf_list_get(au->commands, j);\n\t\t\t/*stat level 2 - get command stats*/\n\t\t\tif (stat_level==2) {\n\t\t\t\te = gf_sm_stats_for_command(sm, com);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\t/*stat level 3 - apply command*/\n\t\t\tif (stat_level==3) gf_sg_command_apply(scene_graph, com, 0);\n\t\t}\n\t\t/*stat level 3: get graph stat*/\n\t\tif (stat_level==3) {\n\t\t\te = gf_sm_stats_for_graph(sm, scene_graph);\n\t\t\tif (e) goto exit;\n\t\t}\n\t\tif (stat_level==2) {\n\t\t\tfprintf(dump, \"<AUStatistics StreamID=\\\"%d\\\" AUTime=\\\"\"LLD\"\\\">\\n\", au->owner->ESID, au->timing);\n\t\t} else {\n\t\t\tfprintf(dump, \"<GraphStatistics StreamID=\\\"%d\\\" AUTime=\\\"\"LLD\"\\\">\\n\", au->owner->ESID, au->timing);\n\t\t}\n\t\t/*dump stats*/\n\t\tdump_stats(dump, gf_sm_stats_get(sm) );\n\t\t/*reset stats*/\n\t\tgf_sm_stats_reset(sm);\n\t\tif (stat_level==2) {\n\t\t\tfprintf(dump, \"</AUStatistics>\\n\");\n\t\t} else {\n\t\t\tfprintf(dump, \"</GraphStatistics>\\n\");\n\t\t}\n\n\t\tgf_set_progress(\"Analysing AU\", i+1, count);\n\t}\n\n\nexit:\n\tif (sample_list) gf_list_del(sample_list);\n\tif (sm) gf_sm_stats_del(sm);\n\tgf_sm_del(ctx);\n\tgf_sg_del(scene_graph);\n\tif (load.isom) gf_isom_delete(load.isom);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Stats error: %s\\n\", gf_error_to_string(e)));\n\t} else {\n\t\tfprintf(dump, \"</SceneStatistics>\\n\");\n\t}\n\tif (dump && close) gf_fclose(dump);\n\tfprintf(stderr, \"done\\n\");\n}\n#endif /*GPAC_DISABLE_SCENE_STATS*/\n\n\n\n#ifndef GPAC_DISABLE_VRML\n\nstatic void PrintFixed(Fixed val, Bool add_space)\n{\n\tif (add_space) fprintf(stderr, \" \");\n\tif (val==FIX_MIN) fprintf(stderr, \"-I\");\n\telse if (val==FIX_MAX) fprintf(stderr, \"+I\");\n\telse fprintf(stderr, \"%g\", FIX2FLT(val));\n}\n\nstatic void PrintNodeSFField(u32 type, void *far_ptr)\n{\n\tif (!far_ptr) return;\n\tswitch (type) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\tfprintf(stderr, \"%s\", (*(SFBool *)far_ptr) ? \"TRUE\" : \"FALSE\");\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\tfprintf(stderr, \"%d\", (*(SFInt32 *)far_ptr));\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tPrintFixed((*(SFFloat *)far_ptr), 0);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tfprintf(stderr, \"%g\", (*(SFTime *)far_ptr));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tPrintFixed(((SFVec2f *)far_ptr)->x, 0);\n\t\tPrintFixed(((SFVec2f *)far_ptr)->y, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tPrintFixed(((SFVec3f *)far_ptr)->x, 0);\n\t\tPrintFixed(((SFVec3f *)far_ptr)->y, 1);\n\t\tPrintFixed(((SFVec3f *)far_ptr)->z, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tPrintFixed(((SFRotation *)far_ptr)->x, 0);\n\t\tPrintFixed(((SFRotation *)far_ptr)->y, 1);\n\t\tPrintFixed(((SFRotation *)far_ptr)->z, 1);\n\t\tPrintFixed(((SFRotation *)far_ptr)->q, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tPrintFixed(((SFColor *)far_ptr)->red, 0);\n\t\tPrintFixed(((SFColor *)far_ptr)->green, 1);\n\t\tPrintFixed(((SFColor *)far_ptr)->blue, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tif (((SFString*)far_ptr)->buffer)\n\t\t\tfprintf(stderr, \"\\\"%s\\\"\", ((SFString*)far_ptr)->buffer);\n\t\telse\n\t\t\tfprintf(stderr, \"NULL\");\n\t\tbreak;\n\t}\n}\n#endif\n\n#ifndef GPAC_DISABLE_VRML\nstatic void do_print_node(GF_Node *node, GF_SceneGraph *sg, const char *name, u32 graph_type, Bool is_nodefield, Bool do_cov)\n{\n\tu32 nbF, i;\n\tGF_FieldInfo f;\n#ifndef GPAC_DISABLE_BIFS\n\tu8 qt, at;\n\tFixed bmin, bmax;\n\tu32 nbBits;\n#endif /*GPAC_DISABLE_BIFS*/\n\n\tnbF = gf_node_get_field_count(node);\n\n\tif (is_nodefield) {\n\t\tchar szField[1024];\n\t\tu32 tfirst, tlast;\n\t\tif (gf_node_get_field_by_name(node, szField, &f) != GF_OK) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Field %s is not a member of node %s\\n\", szField, name));\n\t\t\treturn;\n\t\t}\n\t\tfprintf(stderr, \"Allowed nodes in %s.%s:\\n\", name, szField);\n\t\tif (graph_type==1) {\n\t\t\ttfirst = GF_NODE_RANGE_FIRST_X3D;\n\t\t\ttlast = GF_NODE_RANGE_LAST_X3D;\n\t\t} else {\n\t\t\ttfirst = GF_NODE_RANGE_FIRST_MPEG4;\n\t\t\ttlast = GF_NODE_RANGE_LAST_MPEG4;\n\t\t}\n\t\tfor (i=tfirst; i<tlast; i++) {\n\t\t\tGF_Node *tmp = gf_node_new(sg, i);\n\t\t\tgf_node_register(tmp, NULL);\n\t\t\tif (gf_node_in_table_by_tag(i, f.NDTtype)) {\n\t\t\t\tconst char *nname = gf_node_get_class_name(tmp);\n\t\t\t\tif (nname && strcmp(nname, \"Unknown Node\")) {\n\t\t\t\t\tfprintf(stderr, \"\\t%s\\n\", nname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_node_unregister(tmp, NULL);\n\t\t}\n\t\treturn;\n\t}\n\tif (do_cov) {\n\t\tu32 ndt;\n\t\tif (graph_type==0) {\n\t\t\tu32 all;\n\t\t\tgf_node_mpeg4_type_by_class_name(name);\n\t\t\tgf_bifs_get_child_table(node);\n\t\t\tall = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\t\tfor (i=0; i<all; i++) {\n\t\t\t\tu32 res;\n\t\t\t\tgf_sg_script_get_field_index(node, i, GF_SG_FIELD_CODING_ALL, &res);\n\t\t\t}\n\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF);\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN);\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_OUT);\n\t\t\tgf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DYN);\n\t\t}\n\t\telse if (graph_type==1) gf_node_x3d_type_by_class_name(name);\n\t\tfor (ndt=NDT_SFWorldNode; ndt<NDT_LAST; ndt++) {\n\t\t\tgf_node_in_table_by_tag(gf_node_get_tag(node), ndt);\n\t\t}\n\t}\n\tfprintf(stderr, \"%s {\\n\", name);\n\n\tfor (i=0; i<nbF; i++) {\n\t\tgf_node_get_field(node, i, &f);\n\t\tif (graph_type==2) {\n\t\t\tfprintf(stderr, \"\\t%s=\\\"...\\\"\\n\", f.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfprintf(stderr, \"\\t%s %s %s\", gf_sg_vrml_get_event_type_name(f.eventType, 0), gf_sg_vrml_get_field_type_name(f.fieldType), f.name);\n\t\tif (f.fieldType==GF_SG_VRML_SFNODE) fprintf(stderr, \" NULL\");\n\t\telse if (f.fieldType==GF_SG_VRML_MFNODE) fprintf(stderr, \" []\");\n\t\telse if (gf_sg_vrml_is_sf_field(f.fieldType)) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tPrintNodeSFField(f.fieldType, f.far_ptr);\n\t\t} else {\n\t\t\tvoid *ptr;\n\t\t\tu32 j, sftype;\n\t\t\tGenMFField *mffield = (GenMFField *) f.far_ptr;\n\t\t\tfprintf(stderr, \" [\");\n\t\t\tsftype = gf_sg_vrml_get_sf_type(f.fieldType);\n\t\t\tfor (j=0; j<mffield->count; j++) {\n\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\tgf_sg_vrml_mf_get_item(f.far_ptr, f.fieldType, &ptr, j);\n\t\t\t\tPrintNodeSFField(sftype, ptr);\n\t\t\t}\n\t\t\tfprintf(stderr, \"]\");\n\t\t}\n#ifndef GPAC_DISABLE_BIFS\n\t\tif (gf_bifs_get_aq_info(node, i, &qt, &at, &bmin, &bmax, &nbBits)) {\n\t\t\tif (qt) {\n\t\t\t\tfprintf(stderr, \" #QP=%d\", qt);\n\t\t\t\tif (qt==13) fprintf(stderr, \" NbBits=%d\", nbBits);\n\t\t\t\tif (bmin && bmax) {\n\t\t\t\t\tfprintf(stderr, \" Bounds=[\");\n\t\t\t\t\tPrintFixed(bmin, 0);\n\t\t\t\t\tfprintf(stderr, \",\");\n\t\t\t\t\tPrintFixed(bmax, 0);\n\t\t\t\t\tfprintf(stderr, \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /*GPAC_DISABLE_BIFS*/\n\t\tfprintf(stderr, \"\\n\");\n\n\t\tif (do_cov) {\n\t\t\tgf_node_get_field_by_name(node, (char *) f.name, &f);\n\t\t}\n\t}\n\tfprintf(stderr, \"}\\n\\n\");\n\n}\n#endif\n\n\nu32 PrintNode(const char *name, u32 graph_type)\n{\n#ifdef GPAC_DISABLE_VRML\n\tM4_LOG(GF_LOG_ERROR, (\"VRML/MPEG-4/X3D scene graph is disabled in this build of GPAC\\n\"));\n\treturn 2;\n#else\n\tconst char *std_name;\n\tGF_Node *node;\n\tGF_SceneGraph *sg;\n\tu32 tag;\n#ifndef GPAC_DISABLE_BIFS\n#endif /*GPAC_DISABLE_BIFS*/\n\tBool is_nodefield = 0;\n\n\tchar *sep = strchr(name, '.');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tis_nodefield = 1;\n\t}\n\n\tif (graph_type==1) {\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(name);\n\t\tstd_name = \"X3D\";\n#else\n\t\tM4_LOG(GF_LOG_ERROR, (\"X3D node printing is not supported (X3D support disabled)\\n\"));\n\t\treturn 2;\n#endif\n\t} else {\n\t\ttag = gf_node_mpeg4_type_by_class_name(name);\n\t\tstd_name = \"MPEG4\";\n\t}\n\tif (!tag) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unknown %s node %s\\n\", std_name, name));\n\t\treturn 2;\n\t}\n\n\tsg = gf_sg_new();\n\tnode = gf_node_new(sg, tag);\n\tgf_node_register(node, NULL);\n\tname = gf_node_get_class_name(node);\n\tif (!node) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Node %s not supported in current built\\n\", name));\n\t\treturn 2;\n\t}\n\tdo_print_node(node, sg, name, graph_type, is_nodefield, GF_FALSE);\n\n\tgf_node_unregister(node, NULL);\n\tgf_sg_del(sg);\n#endif /*GPAC_DISABLE_VRML*/\n\treturn 1;\n}\n\nu32 PrintBuiltInNodes(char *arg_val, u32 dump_type)\n{\n#if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D) && !defined(GPAC_DISABLE_SVG)\n\tGF_SceneGraph *sg;\n\tu32 i, nb_in, nb_not_in, start_tag, end_tag;\n\tu32 graph_type;\n\tBool dump_nodes = ((dump_type==1) || (dump_type==3)) ? 1 : 0;\n\n\tif (dump_type==4) graph_type = 2;\n\telse if ((dump_type==2) || (dump_type==3)) graph_type = 1;\n\telse graph_type = 0;\n\n\tif (graph_type==1) {\n#if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D)\n\t\tstart_tag = GF_NODE_RANGE_FIRST_X3D;\n\t\tend_tag = TAG_LastImplementedX3D;\n#else\n\t\tM4_LOG(GF_LOG_ERROR, (\"X3D scene graph disabled in this build of GPAC\\n\"));\n\t\treturn 2;\n#endif\n\t} else if (graph_type==2) {\n#ifdef GPAC_DISABLE_SVG\n\t\tM4_LOG(GF_LOG_ERROR, (\"SVG scene graph disabled in this build of GPAC\\n\"));\n\t\treturn 2;\n#else\n\t\tstart_tag = GF_NODE_RANGE_FIRST_SVG;\n\t\tend_tag = GF_NODE_RANGE_LAST_SVG;\n#endif\n\t} else {\n#ifdef GPAC_DISABLE_VRML\n\t\tM4_LOG(GF_LOG_ERROR, (\"VRML/MPEG-4 scene graph disabled in this build of GPAC\\n\"));\n\t\treturn 2;\n#else\n\t\tstart_tag = GF_NODE_RANGE_FIRST_MPEG4;\n\t\tend_tag = TAG_LastImplementedMPEG4;\n#endif\n\t}\n\tnb_in = nb_not_in = 0;\n\tsg = gf_sg_new();\n\n\tif (graph_type==1) {\n\t\tfprintf(stderr, \"Available X3D nodes in this build (dumping):\\n\");\n\t} else if (graph_type==2) {\n\t\tfprintf(stderr, \"Available SVG nodes in this build (dumping and LASeR coding):\\n\");\n\t} else {\n\t\tfprintf(stderr, \"Available MPEG-4 nodes in this build (encoding/decoding/dumping):\\n\");\n\t}\n\tfor (i=start_tag; i<end_tag; i++) {\n\t\tGF_Node *node = gf_node_new(sg, i);\n\t\tif (node) {\n\t\t\tgf_node_register(node, NULL);\n\t\t\tif (dump_nodes) {\n\t\t\t\tdo_print_node(node, sg, gf_node_get_class_name(node), graph_type, GF_FALSE, GF_TRUE);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \" %s\\n\", gf_node_get_class_name(node));\n\t\t\t}\n\t\t\tgf_node_unregister(node, NULL);\n\t\t\tnb_in++;\n\t\t} else {\n\t\t\tif (graph_type==2)\n\t\t\t\tbreak;\n\t\t\tnb_not_in++;\n\t\t}\n\t}\n\tgf_sg_del(sg);\n\tif (graph_type==2) {\n\t\tfprintf(stderr, \"\\n%d nodes supported\\n\", nb_in);\n\t} else {\n\t\tfprintf(stderr, \"\\n%d nodes supported - %d nodes not supported\\n\", nb_in, nb_not_in);\n\t}\n\t//coverage\n\tif (dump_nodes) {\n\t\tfor (i=GF_SG_VRML_SFBOOL; i<GF_SG_VRML_SCRIPT_FUNCTION; i++) {\n\t\t\tvoid *fp = gf_sg_vrml_field_pointer_new(i);\n\t\t\tif (fp) {\n\t\t\t\tif (i==GF_SG_VRML_SFSCRIPT) gf_free(fp);\n\t\t\t\telse gf_sg_vrml_field_pointer_del(fp, i);\n\t\t\t}\n\t\t}\n\n\t}\n#else\n\tM4_LOG(GF_LOG_ERROR, (\"No scene graph enabled in this MP4Box build\\n\"));\n#endif\n\treturn 1;\n}\n\n\nu32 PrintBuiltInBoxes(char *argval, u32 do_cov)\n{\n\tu32 i, count=gf_isom_get_num_supported_boxes();\n\t\n\tfprintf(stdout, \"<Boxes>\\n\");\n\t//index 0 is our internal unknown box handler\n\tfor (i=1; i<count; i++) {\n\t\tgf_isom_dump_supported_box(i, stdout);\n        if (do_cov) {\n\t\t\tu32 btype = gf_isom_get_supported_box_type(i);\n            GF_Box *b=gf_isom_box_new(btype);\n            if (b) {\n                GF_Box *c=NULL;\n                gf_isom_clone_box(b, &c);\n                if (c) gf_isom_box_del(c);\n                gf_isom_box_del(b);\n            }\n        }\n\t}\n\tfprintf(stdout, \"</Boxes>\\n\");\n\treturn 1;\n}\n\n#if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_ISOM_DUMP)\n\nvoid dump_isom_rtp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tu32 i, j, size;\n\tFILE *dump;\n\tconst char *sdp;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_rtp.xml\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tfprintf(dump, \"<!-- MP4Box RTP trace -->\\n\");\n\tfprintf(dump, \"<RTPFile>\\n\");\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\n\t\tfprintf(dump, \"<RTPHintTrack trackID=\\\"%d\\\">\\n\", gf_isom_get_track_id(file, i+1));\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"<SDPInfo>%s</SDPInfo>\", sdp);\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\tfor (j=0; j<gf_isom_get_sample_count(file, i+1); j++) {\n\t\t\tgf_isom_dump_hint_sample(file, i+1, j+1, dump);\n\t\t}\n#endif\n\t\tfprintf(dump, \"</RTPHintTrack>\\n\");\n\t}\n\tfprintf(dump, \"</RTPFile>\\n\");\n\tif (inName) gf_fclose(dump);\n}\n#endif\n\n\nvoid dump_isom_timestamps(GF_ISOFile *file, char *inName, Bool is_final_name, u32 dump_mode)\n{\n\tu32 i, j, k, count;\n\tBool has_ctts_error, is_fragmented=GF_FALSE;\n\tFILE *dump;\n\tBool skip_offset = ((dump_mode==2) || (dump_mode==4)) ? GF_TRUE : GF_FALSE;\n\tBool check_ts = ((dump_mode==3) || (dump_mode==4)) ? GF_TRUE : GF_FALSE;\n\tstruct _ts_info {\n\t\tu64 dts;\n\t\ts64 cts;\n\t};\n\tstruct _ts_info *timings = NULL;\n\tu32 nb_timings=0, nb_timings_alloc = 0;\n\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_ts.txt\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\tif (gf_isom_is_fragmented(file))\n\t\tis_fragmented = GF_TRUE;\n\n\thas_ctts_error = GF_FALSE;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\ts64 cts_dts_shift = gf_isom_get_cts_to_dts_shift(file, i+1);\n\t\tu32 has_cts_offset = gf_isom_has_time_offset(file, i+1);\n\n\t\tfprintf(dump, \"#dumping track ID %d timing:\\n\", gf_isom_get_track_id(file, i + 1));\n\t\tfprintf(dump, \"Num\\tDTS\\tCTS\\tSize\\tRAP%s\\tisLeading\\tDependsOn\\tDependedOn\\tRedundant\\tRAP-SampleGroup\\tRoll-SampleGroup\\tRoll-Distance\", skip_offset ? \"\" : \"\\tOffset\");\n\t\tif (is_fragmented) {\n\t\t\tfprintf(dump, \"\\tfrag_start\");\n\t\t}\n\t\tfprintf(dump, \"\\n\");\n\n\n\t\tcount = gf_isom_get_sample_count(file, i+1);\n\t\tif (has_cts_offset && check_ts) {\n\t\t\tif (nb_timings_alloc<count) {\n\t\t\t\tnb_timings_alloc = count;\n\t\t\t\ttimings = gf_realloc(timings, sizeof (struct _ts_info) * count);\n\t\t\t}\n\t\t\tnb_timings = 0;\n\t\t}\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\ts64 cts;\n\t\t\tu64 dts, offset;\n\t\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\t\tBool is_rap;\n\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\ts32 roll_distance;\n\t\t\tu32 index;\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample_info(file, i+1, j+1, &index, &offset);\n\t\t\tif (!samp) {\n\t\t\t\tfprintf(dump, \" SAMPLE #%d IN TRACK #%d NOT THERE !!!\\n\", j+1, i+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_isom_get_sample_flags(file, i+1, j+1, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\t\tgf_isom_get_sample_rap_roll_info(file, i+1, j+1, &is_rap, &roll_type, &roll_distance);\n\t\t\tdts = samp->DTS;\n\t\t\tcts = dts + (s32) samp->CTS_Offset;\n\t\t\tfprintf(dump, \"Sample %d\\tDTS \"LLU\"\\tCTS \"LLD\"\\t%d\\t%d\", j+1, dts, cts, samp->dataLength, samp->IsRAP);\n\n\t\t\tif (!skip_offset)\n\t\t\t\tfprintf(dump, \"\\t\"LLU, offset);\n\n\t\t\tfprintf(dump, \"\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", isLeading, dependsOn, dependedOn, redundant, is_rap, roll_type, roll_distance);\n\n\t\t\tif (cts< (s64) dts) {\n\t\t\t\tif (has_cts_offset==2) {\n\t\t\t\t\tif (cts_dts_shift && (cts+cts_dts_shift < (s64) dts)) {\n\t\t\t\t\t\tfprintf(dump, \" #NEGATIVE CTS OFFSET!!!\");\n\t\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t\t} else if (!cts_dts_shift) {\n\t\t\t\t\t\tfprintf(dump, \" #possible negative CTS offset (no cslg in file)\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(dump, \" #NEGATIVE CTS OFFSET!!!\");\n\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_cts_offset && check_ts) {\n\t\t\t\tfor (k=0; k<nb_timings; k++) {\n\n\t\t\t\t\tif (timings[k].dts==dts) {\n\t\t\t\t\t\tfprintf(dump, \" #SAME DTS USED!!!\");\n\t\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (timings[k].cts==cts) {\n\t\t\t\t\t\tfprintf(dump, \" #SAME CTS USED!!! \");\n\t\t\t\t\t\thas_ctts_error = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttimings[nb_timings].dts = dts;\n\t\t\t\ttimings[nb_timings].cts = cts;\n\t\t\t\tnb_timings++;\n\t\t\t}\n\n\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\tif (is_fragmented) {\n\t\t\t\tfprintf(dump, \"\\t%d\", gf_isom_sample_is_fragment_start(file, i+1, j+1, NULL) );\n\t\t\t}\n\t\t\tfprintf(dump, \"\\n\");\n\t\t\tgf_set_progress(\"Dumping track timing\", j+1, count);\n\t\t}\n\t\tfprintf(dump, \"\\n\\n\");\n\t\tgf_set_progress(\"Dumping track timing\", count, count);\n\t}\n\tif (timings) gf_free(timings);\n\n\tif (inName) gf_fclose(dump);\n\tif (has_ctts_error) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"\\tFile has CTTS table errors\\n\"));\n\t}\n}\n\n\n\nstatic u32 read_nal_size_hdr(u8 *ptr, u32 nalh_size)\n{\n\tu32 nal_size=0;\n\tu32 v = nalh_size;\n\twhile (v) {\n\t\tnal_size |= (u8) *ptr;\n\t\tptr++;\n\t\tv-=1;\n\t\tif (v) nal_size <<= 8;\n\t}\n\treturn nal_size;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nvoid gf_inspect_dump_nalu(FILE *dump, u8 *ptr, u32 ptr_size, Bool is_svc, HEVCState *hevc, AVCState *avc, VVCState *vvc, u32 nalh_size, Bool dump_crc, Bool is_encrypted);\n#endif\n\n\nstatic void dump_isom_nal_ex(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, u32 dump_flags)\n{\n\tu32 i, j, count, nb_descs, track, nalh_size, timescale, cur_extract_mode;\n\ts32 countRef;\n\tBool is_adobe_protected = GF_FALSE;\n\tBool is_cenc_protected = GF_FALSE;\n\tBool is_hevc = GF_FALSE;\n\tBool is_vvc = GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAVCState *avc_state = NULL;\n\tHEVCState *hevc_state = NULL;\n\tVVCState *vvc_state = NULL;\n#endif\n\tGF_AVCConfig *avccfg, *svccfg;\n\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\tGF_VVCConfig *vvccfg;\n\tGF_NALUFFParam *slc;\n\tBool has_svcc = GF_FALSE;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\n\tcount = gf_isom_get_sample_count(file, track);\n\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\n\tnb_descs = gf_isom_get_sample_description_count(file, track);\n\tif (!nb_descs) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error: Track #%d has no sample description so is likely not NALU-based!\\n\", trackID));\n\t\treturn;\n\t}\n\n\tfprintf(dump, \"<NALUTrack trackID=\\\"%d\\\" SampleCount=\\\"%d\\\" TimeScale=\\\"%d\\\">\\n\", trackID, count, timescale);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define DUMP_ARRAY(arr, name, loc, _is_svc)\\\n\tif (arr) {\\\n\t\tfprintf(dump, \"  <%sArray location=\\\"%s\\\">\\n\", name, loc);\\\n\t\tfor (i=0; i<gf_list_count(arr); i++) {\\\n\t\t\tslc = gf_list_get(arr, i);\\\n\t\t\tfprintf(dump, \"   <NALU size=\\\"%d\\\" \", slc->size);\\\n\t\t\tgf_inspect_dump_nalu(dump, (u8 *) slc->data, slc->size, _is_svc, is_hevc ? hevc_state : NULL, avc_state, is_vvc ? vvc_state : NULL, nalh_size, (dump_flags&1) ? GF_TRUE : GF_FALSE, GF_FALSE);\\\n\t\t}\\\n\t\tfprintf(dump, \"  </%sArray>\\n\", name);\\\n\t}\\\n\n#else\n\n#define DUMP_ARRAY(arr, name, loc, _is_svc)\\\n\tif (arr) {\\\n\t\tfprintf(dump, \"  <%sArray location=\\\"%s\\\">\\n\", name, loc);\\\n\t\tfor (i=0; i<gf_list_count(arr); i++) {\\\n\t\t\tslc = gf_list_get(arr, i);\\\n\t\t\tfprintf(dump, \"   <NALU size=\\\"%d\\\" \", slc->size);\\\n\t\t\tfprintf(dump, \"/>\\n\");\\\n\t\t}\\\n\t\tfprintf(dump, \"  </%sArray>\\n\", name);\\\n\t}\\\n\n#endif\n\n\tnalh_size = 0;\n\n\tfor (j=0; j<nb_descs; j++) {\n\t\tGF_AVCConfig *mvccfg;\n\t\tBool is_svc;\n\n\t\tavccfg = gf_isom_avc_config_get(file, track, j+1);\n\t\tsvccfg = gf_isom_svc_config_get(file, track, j+1);\n\t\tmvccfg = gf_isom_mvc_config_get(file, track, j+1);\n\t\thevccfg = gf_isom_hevc_config_get(file, track, j+1);\n\t\tlhvccfg = gf_isom_lhvc_config_get(file, track, j+1);\n\t\tvvccfg = gf_isom_vvc_config_get(file, track, j+1);\n\n\t\tis_svc = (svccfg!=NULL) ? 1:0;\n\n\t\tif (hevccfg || lhvccfg) {\n\t\t\tis_hevc = 1;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_SAFEALLOC(hevc_state, HEVCState)\n#endif\n\t\t} else if (vvccfg) {\n\t\t\tis_vvc = 1;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_SAFEALLOC(vvc_state, VVCState)\n#endif\n\t\t} else if (avccfg || svccfg || mvccfg) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_SAFEALLOC(avc_state, AVCState)\n#endif\n\t\t}\n\n\n\t\t//for tile tracks the hvcC is stored in the 'tbas' track\n\t\tif (!hevccfg && gf_isom_get_reference_count(file, track, GF_ISOM_REF_TBAS)) {\n\t\t\tu32 tk = 0;\n\t\t\tgf_isom_get_reference(file, track, GF_ISOM_REF_TBAS, 1, &tk);\n\t\t\thevccfg = gf_isom_hevc_config_get(file, tk, 1);\n\t\t}\n\n\t\tfprintf(dump, \" <NALUConfig>\\n\");\n\n\t\tif (!avccfg && !svccfg && !hevccfg && !lhvccfg && !vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error: Track #%d is not NALU or OBU based!\\n\", trackID));\n\t\t\treturn;\n\t\t}\n\n\t\tif (avccfg) {\n\t\t\tnalh_size = avccfg->nal_unit_size;\n\n\t\t\tDUMP_ARRAY(avccfg->sequenceParameterSets, \"AVCSPS\", \"avcC\", is_svc);\n\t\t\tDUMP_ARRAY(avccfg->pictureParameterSets, \"AVCPPS\", \"avcC\", is_svc)\n\t\t\tDUMP_ARRAY(avccfg->sequenceParameterSetExtensions, \"AVCSPSEx\", \"avcC\", is_svc)\n\t\t}\n\t\tif (is_svc) {\n\t\t\tif (!nalh_size) nalh_size = svccfg->nal_unit_size;\n\t\t\tDUMP_ARRAY(svccfg->sequenceParameterSets, \"SVCSPS\", \"svcC\", is_svc)\n\t\t\tDUMP_ARRAY(svccfg->pictureParameterSets, \"SVCPPS\", \"svcC\", is_svc)\n\t\t}\n\t\tif (mvccfg) {\n\t\t\tif (!nalh_size) nalh_size = mvccfg->nal_unit_size;\n\t\t\tDUMP_ARRAY(mvccfg->sequenceParameterSets, \"SVCSPS\", \"mvcC\", is_svc)\n\t\t\tDUMP_ARRAY(mvccfg->pictureParameterSets, \"SVCPPS\", \"mvcC\", is_svc)\n\t\t}\n\t\tif (hevccfg) {\n\t\t\tu32 idx;\n\t\t\tnalh_size = hevccfg->nal_unit_size;\n\t\t\tfor (idx=0; idx<gf_list_count(hevccfg->param_array); idx++) {\n\t\t\t\tGF_NALUFFParamArray *ar = gf_list_get(hevccfg->param_array, idx);\n\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCSPS\", \"hvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCPPS\", \"hvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCVPS\", \"hvcC\", 0)\n\t\t\t\t} else {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCUnknownPS\", \"hvcC\", 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (vvccfg) {\n\t\t\tu32 idx;\n\t\t\tnalh_size = vvccfg->nal_unit_size;\n\t\t\tfor (idx=0; idx<gf_list_count(vvccfg->param_array); idx++) {\n\t\t\t\tGF_NALUFFParamArray *ar = gf_list_get(vvccfg->param_array, idx);\n\t\t\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCSPS\", \"vvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_VVC_NALU_PIC_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCPPS\", \"vvcC\", 0)\n\t\t\t\t} else if (ar->type==GF_VVC_NALU_VID_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCVPS\", \"vvcC\", 0)\n\t\t\t\t} else {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"VVCUnknownPS\", \"vvcC\", 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lhvccfg) {\n\t\t\tu32 idx;\n\t\t\tnalh_size = lhvccfg->nal_unit_size;\n\t\t\tfor (idx=0; idx<gf_list_count(lhvccfg->param_array); idx++) {\n\t\t\t\tGF_NALUFFParamArray *ar = gf_list_get(lhvccfg->param_array, idx);\n\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCSPS\", \"lhcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCPPS\", \"lhcC\", 0)\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCVPS\", \"lhcC\", 0)\n\t\t\t\t} else {\n\t\t\t\t\tDUMP_ARRAY(ar->nalus, \"HEVCUnknownPS\", \"lhcC\", 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(dump, \" </NALUConfig>\\n\");\n\n\t\tif (avccfg) gf_odf_avc_cfg_del(avccfg);\n\t\tif (svccfg) {\n\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\thas_svcc = GF_TRUE;\n\t\t}\n\t\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\t\tif (vvccfg) gf_odf_vvc_cfg_del(vvccfg);\n\t\tif (lhvccfg) gf_odf_hevc_cfg_del(lhvccfg);\n\t}\n\n\t/*fixme: for dumping encrypted track: we don't have neither avccfg nor svccfg*/\n\tif (!nalh_size) nalh_size = 4;\n\n\t/*for testing dependency*/\n\tcountRef = gf_isom_get_reference_count(file, track, GF_ISOM_REF_SCAL);\n\tif (countRef > 0)\n\t{\n\t\tGF_ISOTrackID refTrackID;\n\t\tfprintf(dump, \" <SCALReferences>\\n\");\n\t\tfor (i = 1; i <= (u32) countRef; i++)\n\t\t{\n\t\t\tgf_isom_get_reference_ID(file, track, GF_ISOM_REF_SCAL, i, &refTrackID);\n\t\t\tfprintf(dump, \"  <SCALReference number=\\\"%d\\\" refTrackID=\\\"%d\\\"/>\\n\", i, refTrackID);\n\t\t}\n\n\t\tfprintf(dump, \" </SCALReferences>\\n\");\n\t}\n\n\tfprintf(dump, \" <NALUSamples>\\n\");\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tis_adobe_protected = gf_isom_is_adobe_protection_media(file, track, 1);\n\tis_cenc_protected = gf_isom_is_cenc_media(file, track, 1);\n\tfor (i=0; i<count; i++) {\n\t\tu64 dts, cts;\n\t\tBool is_rap;\n\t\tu32 size, nal_size, idx, di;\n\t\tu8 *ptr;\n\t\tGF_ISOSample *samp = gf_isom_get_sample(file, track, i+1, &di);\n\t\tif (!samp) {\n\t\t\tfprintf(dump, \"<!-- Unable to fetch sample %d -->\\n\", i+1);\n\t\t\tcontinue;\n\t\t}\n\t\tdts = samp->DTS;\n\t\tcts = dts + (s32) samp->CTS_Offset;\n\t\tis_rap = samp->IsRAP;\n\t\tif (!is_rap) gf_isom_get_sample_rap_roll_info(file, track, i+1, &is_rap, NULL, NULL);\n\n\t\tif (dump_flags&2) {\n\t\t\tfprintf(dump, \"  <Sample size=\\\"%d\\\" RAP=\\\"%d\\\"\", samp->dataLength, is_rap);\n\t\t} else {\n\t\t\tfprintf(dump, \"  <Sample DTS=\\\"\"LLD\"\\\" CTS=\\\"\"LLD\"\\\" size=\\\"%d\\\" RAP=\\\"%d\\\"\", dts, cts, samp->dataLength, is_rap);\n\t\t}\n\t\tif (nb_descs>1)\n\t\t\tfprintf(dump, \" sample_description=\\\"%d\\\"\", di);\n\t\tfprintf(dump, \" >\\n\");\n\n\t\tif (cts<dts) fprintf(dump, \"<!-- NEGATIVE CTS OFFSET! -->\\n\");\n\n\t\tidx = 1;\n\t\tptr = samp->data;\n\t\tsize = samp->dataLength;\n\t\tif (is_adobe_protected) {\n\t\t\tu8 encrypted_au = ptr[0];\n\t\t\tif (encrypted_au) {\n\t\t\t\tfprintf(dump, \"   <!-- Sample number %d is an Adobe's protected sample: can not be dumped -->\\n\", i+1);\n\t\t\t\tfprintf(dump, \"  </Sample>\\n\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tptr++;\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\twhile (size) {\n\t\t\tnal_size = read_nal_size_hdr(ptr, nalh_size);\n\t\t\tptr += nalh_size;\n\n\t\t\tif (nal_size >= UINT_MAX-nalh_size || nalh_size + nal_size > size) {\n\t\t\t\tfprintf(dump, \"   <!-- NALU number %d is corrupted: size is %d but only %d remains -->\\n\", idx, nal_size, size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfprintf(dump, \"   <NALU size=\\\"%d\\\" \", nal_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tBool is_encrypted = 0;\n\t\t\t\tif (is_cenc_protected) {\n\t\t\t\t\tGF_Err e = gf_isom_get_sample_cenc_info(file, track, i + 1, &is_encrypted, NULL, NULL, NULL, NULL);\n\t\t\t\t\tif (e != GF_OK) {\n\t\t\t\t\t\tfprintf(dump, \"dump_msg=\\\"Error %s while fetching encryption info for sample, assuming sample is encrypted\\\" \", gf_error_to_string(e) );\n\t\t\t\t\t\tis_encrypted = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_inspect_dump_nalu(dump, ptr, nal_size, has_svcc ? 1 : 0, hevc_state, avc_state, vvc_state, nalh_size, dump_flags, is_encrypted);\n#else\n\t\t\t\tfprintf(dump, \"/>\\n\");\n#endif\n\t\t\t}\n\t\t\tidx++;\n\t\t\tptr+=nal_size;\n\t\t\tsize -= nal_size + nalh_size;\n\t\t}\n\t\tfprintf(dump, \"  </Sample>\\n\");\n\t\tgf_isom_sample_del(&samp);\n\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"Analysing Track NALUs\", i+1, count);\n\t}\n\tfprintf(dump, \" </NALUSamples>\\n\");\n\tfprintf(dump, \"</NALUTrack>\\n\");\n\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (hevc_state) gf_free(hevc_state);\n\tif (vvc_state) gf_free(vvc_state);\n\tif (avc_state) gf_free(avc_state);\n#endif\n}\n\nstatic void dump_isom_obu(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, Bool dump_crc);\nstatic void dump_qt_prores(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, Bool dump_crc);\n\nvoid dump_isom_nal(GF_ISOFile *file, GF_ISOTrackID trackID, char *inName, Bool is_final_name, u32 dump_flags)\n{\n\tBool is_av1 = GF_FALSE;\n\tBool is_prores = GF_FALSE;\n\n\tFILE *dump;\n\tif (inName) {\n\t\tGF_ESD* esd;\n\t\tchar szBuf[GF_MAX_PATH];\n\n\t\tstrcpy(szBuf, inName);\n\n\t\tu32 track = gf_isom_get_track_by_id(file, trackID);\n\t\tesd = gf_isom_get_esd(file, track, 1);\n\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tswitch (gf_isom_get_media_subtype(file, track, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_AV01:\n\t\t\t\tis_av1 = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_QT_SUBTYPE_APCH:\n\t\t\tcase GF_QT_SUBTYPE_APCO:\n\t\t\tcase GF_QT_SUBTYPE_APCN:\n\t\t\tcase GF_QT_SUBTYPE_APCS:\n\t\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\t\t\tis_prores = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (esd->decoderConfig->objectTypeIndication == GF_CODECID_AV1) {\n\t\t\tis_av1 = GF_TRUE;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\n\t\tif (!is_final_name) sprintf(szBuf, \"%s_%d_%s.xml\", inName, trackID, is_av1 ? \"obu\" : \"nalu\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tif (is_av1)\n\t\tdump_isom_obu(file, trackID, dump, dump_flags);\n\telse if (is_prores)\n\t\tdump_qt_prores(file, trackID, dump, dump_flags);\n\telse\n\t\tdump_isom_nal_ex(file, trackID, dump, dump_flags);\n\n\tif (inName) gf_fclose(dump);\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nvoid gf_inspect_dump_obu(FILE *dump, AV1State *av1, u8 *obu, u64 obu_length, ObuType obu_type, u64 obu_size, u32 hdr_size, Bool dump_crc);\n#endif\n\nstatic void dump_isom_obu(GF_ISOFile *file, GF_ISOTrackID trackID, FILE *dump, Bool dump_crc)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 i, count, track, timescale;\n\tAV1State av1;\n\tObuType obu_type;\n\tu64 obu_size;\n\tu32 hdr_size;\n\tGF_BitStream *bs;\n\tu32 idx;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\n\tgf_av1_init_state(&av1);\n\tav1.config = gf_isom_av1_config_get(file, track, 1);\n\tif (!av1.config) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error: Track #%d is not AV1!\\n\", trackID));\n\t\treturn;\n\t}\n\n\tcount = gf_isom_get_sample_count(file, track);\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\n\tfprintf(dump, \"<OBUTrack trackID=\\\"%d\\\" SampleCount=\\\"%d\\\" TimeScale=\\\"%d\\\">\\n\", trackID, count, timescale);\n\n\tfprintf(dump, \" <OBUConfig>\\n\");\n\n\tfor (i=0; i<gf_list_count(av1.config->obu_array); i++) {\n\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1.config->obu_array, i);\n\t\tbs = gf_bs_new(obu->obu, (u32) obu->obu_length, GF_BITSTREAM_READ);\n\t\tgf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\tgf_inspect_dump_obu(dump, &av1, obu->obu, obu->obu_length, obu_type, obu_size, hdr_size, dump_crc);\n\t\tgf_bs_del(bs);\n\t}\n\tfprintf(dump, \" </OBUConfig>\\n\");\n\n\tfprintf(dump, \" <OBUSamples>\\n\");\n\n\tfor (i=0; i<count; i++) {\n\t\tu64 dts, cts;\n\t\tu32 size;\n\t\tu8 *ptr;\n\t\tGF_ISOSample *samp = gf_isom_get_sample(file, track, i+1, NULL);\n\t\tif (!samp) {\n\t\t\tfprintf(dump, \"<!-- Unable to fetch sample %d -->\\n\", i+1);\n\t\t\tcontinue;\n\t\t}\n\t\tdts = samp->DTS;\n\t\tcts = dts + (s32) samp->CTS_Offset;\n\n\t\tfprintf(dump, \"  <Sample number=\\\"%d\\\" DTS=\\\"\"LLD\"\\\" CTS=\\\"\"LLD\"\\\" size=\\\"%d\\\" RAP=\\\"%d\\\" >\\n\", i+1, dts, cts, samp->dataLength, samp->IsRAP);\n\t\tif (cts<dts) fprintf(dump, \"<!-- NEGATIVE CTS OFFSET! -->\\n\");\n\n\t\tidx = 1;\n\t\tptr = samp->data;\n\t\tsize = samp->dataLength;\n\n\t\tbs = gf_bs_new(ptr, size, GF_BITSTREAM_READ);\n\t\twhile (size) {\n\t\t\tgf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\t\tif (obu_size > size) {\n\t\t\t\tfprintf(dump, \"   <!-- OBU number %d is corrupted: size is %d but only %d remains -->\\n\", idx, (u32) obu_size, size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_inspect_dump_obu(dump, &av1, ptr, obu_size, obu_type, obu_size, hdr_size, dump_crc);\n\t\t\tptr += obu_size;\n\t\t\tsize -= (u32)obu_size;\n\t\t\tidx++;\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tfprintf(dump, \"  </Sample>\\n\");\n\t\tgf_isom_sample_del(&samp);\n\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"Analysing Track OBUs\", i+1, count);\n\t}\n\tfprintf(dump, \" </OBUSamples>\\n\");\n\tfprintf(dump, \"</OBUTrack>\\n\");\n\n\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\tgf_av1_reset_state(&av1, GF_TRUE);\n#endif\n}\n\nstatic void dump_qt_prores(GF_ISOFile *file, u32 trackID, FILE *dump, Bool dump_crc)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 i, count, track, timescale;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\n\tcount = gf_isom_get_sample_count(file, track);\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\n\tfprintf(dump, \"<ProResTrack trackID=\\\"%d\\\" SampleCount=\\\"%d\\\" TimeScale=\\\"%d\\\">\\n\", trackID, count, timescale);\n\n\tfor (i=0; i<count; i++) {\n\t\tvoid gf_inspect_dump_prores(FILE *dump, u8 *ptr, u64 frame_size, Bool dump_crc);\n\t\tu64 dts, cts;\n\t\tGF_ISOSample *samp = gf_isom_get_sample(file, track, i+1, NULL);\n\t\tif (!samp) {\n\t\t\tfprintf(dump, \"<!-- Unable to fetch sample %d -->\\n\", i+1);\n\t\t\tcontinue;\n\t\t}\n\t\tdts = samp->DTS;\n\t\tcts = dts + (s32) samp->CTS_Offset;\n\n\t\tif (cts!=dts) fprintf(dump, \"<!-- Wrong timing info (CTS \"LLD\" vs DTS \"LLD\") ! -->\\n\", cts, dts);\n\t\tif (!samp->IsRAP) fprintf(dump, \"<!-- Wrong sync sample info, sample is not SAP1 ! -->\\n\");\n\n\t\tfprintf(dump, \"  <Sample number=\\\"%d\\\" CTS=\\\"\"LLD\"\\\" size=\\\"%d\\\">\\n\", i+1, cts, samp->dataLength);\n\n\t\tgf_inspect_dump_prores(dump, samp->data, samp->dataLength, dump_crc);\n\t\tfprintf(dump, \"  </Sample>\\n\");\n\n\t\tgf_isom_sample_del(&samp);\n\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"Analysing ProRes Track\", i+1, count);\n\t}\n\tfprintf(dump, \"</ProResTrack>\\n\");\n#endif\n}\n\nvoid dump_isom_saps(GF_ISOFile *file, GF_ISOTrackID trackID, u32 dump_saps_mode, char *inName, Bool is_final_name)\n{\n\tFILE *dump;\n\tu32 i, count;\n\ts64 media_offset=0;\n\tu32 track = gf_isom_get_track_by_id(file, trackID);\n\tif (inName) {\n\t\tchar szBuf[GF_MAX_PATH];\n\t\tstrcpy(szBuf, inName);\n\n\t\tif (!is_final_name) sprintf(szBuf, \"%s_%d_cues.xml\", inName, trackID);\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tfprintf(dump, \"<DASHCues xmlns=\\\"urn:gpac:dash:schema:cues:2018\\\">\\n\");\n\tfprintf(dump, \"<Stream id=\\\"%d\\\" timescale=\\\"%d\\\"\", trackID, gf_isom_get_media_timescale(file, track) );\n\tif (dump_saps_mode==4) {\n\t\tfprintf(dump, \" mode=\\\"edit\\\"\");\n\t\tgf_isom_get_edit_list_type(file, track, &media_offset);\n\t}\n\tfprintf(dump, \">\\n\");\n\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\ts64 cts, dts;\n\t\tu32 di;\n\t\tBool traf_start = 0;\n\t\tu32 sap_type = 0;\n\t\tu64 doffset;\n\t\t\n\t\tGF_ISOSample *samp = gf_isom_get_sample_info(file, track, i+1, &di, &doffset);\n\n\t\ttraf_start = gf_isom_sample_is_fragment_start(file, track, i+1, NULL);\n\n\t\tsap_type = samp->IsRAP;\n\t\tif (!sap_type) {\n\t\t\tBool is_rap;\n\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\ts32 roll_dist;\n\t\t\tgf_isom_get_sample_rap_roll_info(file, track, i+1, &is_rap, &roll_type, &roll_dist);\n\t\t\tif (roll_type) sap_type = SAP_TYPE_4;\n\t\t\telse if (is_rap)  sap_type = SAP_TYPE_3;\n\t\t}\n\n\t\tif (!sap_type) {\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdts = cts = samp->DTS;\n\t\tcts += samp->CTS_Offset;\n\t\tfprintf(dump, \"<Cue sap=\\\"%d\\\"\", sap_type);\n\t\tif (dump_saps_mode==4) {\n\t\t\tcts += media_offset;\n\t\t\tfprintf(dump, \" cts=\\\"\"LLD\"\\\"\", cts);\n\t\t} else {\n\t\t\tif (!dump_saps_mode || (dump_saps_mode==1)) fprintf(dump, \" sample=\\\"%d\\\"\", i+1);\n\t\t\tif (!dump_saps_mode || (dump_saps_mode==2)) fprintf(dump, \" cts=\\\"\"LLD\"\\\"\", cts);\n\t\t\tif (!dump_saps_mode || (dump_saps_mode==3)) fprintf(dump, \" dts=\\\"\"LLD\"\\\"\", dts);\n\t\t}\n\n\t\tif (traf_start)\n\t\t\tfprintf(dump, \" wasFragStart=\\\"yes\\\"\");\n\n\t\tfprintf(dump, \"/>\\n\");\n\n\t\tgf_isom_sample_del(&samp);\n\t}\n\tfprintf(dump, \"</Stream>\\n\");\n\tfprintf(dump, \"</DASHCues>\\n\");\n\tif (inName) gf_fclose(dump);\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nvoid dump_isom_ismacryp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tu32 i, j;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) strcat(szBuf, \"_ismacryp.xml\");\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tfprintf(dump, \"<!-- MP4Box ISMACryp trace -->\\n\");\n\tfprintf(dump, \"<ISMACrypFile>\\n\");\n\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_subtype(file, i+1, 1) != GF_ISOM_SUBTYPE_MPEG4_CRYP) continue;\n\n\t\tgf_isom_dump_ismacryp_protection(file, i+1, dump);\n\n\t\tfprintf(dump, \"<ISMACrypTrack trackID=\\\"%d\\\">\\n\", gf_isom_get_track_id(file, i+1));\n\t\tfor (j=0; j<gf_isom_get_sample_count(file, i+1); j++) {\n\t\t\tgf_isom_dump_ismacryp_sample(file, i+1, j+1, dump);\n\t\t}\n\t\tfprintf(dump, \"</ISMACrypTrack >\\n\");\n\t}\n\tfprintf(dump, \"</ISMACrypFile>\\n\");\n\tif (inName) gf_fclose(dump);\n}\n\n\nvoid dump_isom_timed_text(GF_ISOFile *file, GF_ISOTrackID trackID, char *inName, Bool is_final_name, Bool is_convert, GF_TextDumpType dump_type)\n{\n\tFILE *dump;\n\tGF_Err e;\n\tu32 track;\n\n\ttrack = gf_isom_get_track_by_id(file, trackID);\n\tif (!track) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot find track ID %d\\n\", trackID));\n\t\treturn;\n\t}\n\n\tswitch (gf_isom_get_media_type(file, track)) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\tM4_LOG(GF_LOG_ERROR, (\"Track ID %d is not a 3GPP text track\\n\", trackID));\n\t\treturn;\n\t}\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tchar *ext;\n\t\text = ((dump_type==GF_TEXTDUMPTYPE_SVG) ? \"svg\" : ((dump_type==GF_TEXTDUMPTYPE_SRT) ? \"srt\" : \"ttxt\"));\n\t\tif (is_final_name) {\n\t\t\tstrcpy(szBuf, inName) ;\n\t\t} else if (is_convert)\n\t\t\tsprintf(szBuf, \"%s.%s\", inName, ext) ;\n\t\telse\n\t\t\tsprintf(szBuf, \"%s_%d_text.%s\", inName, trackID, ext);\n\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t}\n\te = gf_isom_text_dump(file, track, dump, dump_type);\n\tif (inName) gf_fclose(dump);\n\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Conversion failed (%s)\\n\", gf_error_to_string(e)));\n\t} else {\n\t\tfprintf(stderr, \"Conversion done\\n\");\n\t}\n}\n\n#endif /*GPAC_DISABLE_ISOM_DUMP*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"# File SDP content \\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tif (sdp && size)\n\t\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");\n\tif (inName) gf_fclose(dump);\n}\n\n#endif\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err dump_isom_xml(GF_ISOFile *file, char *inName, Bool is_final_name, Bool do_track_dump, Bool merge_vtt_cues, Bool skip_init, Bool skip_samples)\n{\n\tGF_Err e;\n\tFILE *dump = stdout;\n\tBool do_close=GF_FALSE;\n\tif (!file) return GF_ISOM_INVALID_FILE;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tstrcat(szBuf, do_track_dump ? \"_dump.xml\" : \"_info.xml\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tdo_close=GF_TRUE;\n\t}\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tif (do_track_dump) {\n\t\tfprintf(dump, \"<ISOBaseMediaFileTrace>\\n\");\n\t}\n\te = gf_isom_dump(file, dump, skip_init, skip_samples);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error dumping ISO structure\\n\"));\n\t}\n\n\tif (do_track_dump) {\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\t\tu32 i;\n\t\t//because of dump mode we need to reopen in regular read mode to avoid mem leaks\n\t\tGF_ISOFile *the_file = gf_isom_open(gf_isom_get_filename(file), GF_ISOM_OPEN_READ, NULL);\n\t\tu32 tcount = gf_isom_get_track_count(the_file);\n\t\tfprintf(dump, \"<Tracks>\\n\");\n\n\t\tfor (i=0; i<tcount; i++) {\n\t\t\tGF_MediaExporter dumper;\n\t\t\tGF_ISOTrackID trackID = gf_isom_get_track_id(the_file, i+1);\n\t\t\tu32 mtype = gf_isom_get_media_type(the_file, i+1);\n\t\t\tu32 msubtype = gf_isom_get_media_subtype(the_file, i+1, 1);\n\t\t\tBool fmt_handled = GF_FALSE;\n\t\t\tmemset(&dumper, 0, sizeof(GF_MediaExporter));\n\t\t\tdumper.file = the_file;\n\t\t\tdumper.trackID = trackID;\n\t\t\tdumper.dump_file = dump;\n\n\t\t\tif (mtype == GF_ISOM_MEDIA_HINT) {\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\t\t\tchar *name=NULL;\n\t\t\t\tif (msubtype==GF_ISOM_SUBTYPE_RTP) name = \"RTPHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_SRTP) name = \"SRTPHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_RRTP) name = \"RTPReceptionHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_RTCP) name = \"RTCPReceptionHintTrack\";\n\t\t\t\telse if (msubtype==GF_ISOM_SUBTYPE_FLUTE) name = \"FLUTEReceptionHintTrack\";\n\t\t\t\telse name = \"UnknownHintTrack\";\n\n\t\t\t\tfprintf(dump, \"<%s trackID=\\\"%d\\\">\\n\", name, trackID);\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\t\t\tu32 j, scount=gf_isom_get_sample_count(the_file, i+1);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tgf_isom_dump_hint_sample(the_file, i+1, j+1, dump);\n\t\t\t\t}\n#endif\n\t\t\t\tfprintf(dump, \"</%s>\\n\", name);\n\t\t\t\tfmt_handled = GF_TRUE;\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\t\t\t}\n\t\t\telse if (gf_isom_get_avc_svc_type(the_file, i+1, 1) || gf_isom_get_hevc_lhvc_type(the_file, i+1, 1)) {\n\t\t\t\tdump_isom_nal_ex(the_file, trackID, dump, GF_FALSE);\n\t\t\t\tfmt_handled = GF_TRUE;\n\t\t\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) ) {\n\n\t\t\t\tif (msubtype==GF_ISOM_SUBTYPE_WVTT) {\n\t\t\t\t\tgf_webvtt_dump_iso_track(&dumper, i+1, merge_vtt_cues, GF_TRUE);\n\t\t\t\t\tfmt_handled = GF_TRUE;\n\t\t\t\t} else if ((msubtype==GF_ISOM_SUBTYPE_TX3G) || (msubtype==GF_ISOM_SUBTYPE_TEXT)) {\n\t\t\t\t\tgf_isom_text_dump(the_file, i+1, dump, GF_TEXTDUMPTYPE_TTXT_BOXES);\n\t\t\t\t\tfmt_handled = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!fmt_handled) {\n\t\t\t\tdumper.flags = GF_EXPORT_NHML | GF_EXPORT_NHML_FULL;\n\t\t\t\tdumper.print_stats_graph = fs_dump_flags;\n\t\t\t\tgf_media_export(&dumper);\n\t\t\t}\n\t\t}\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif /*GPAC_DISABLE_MEDIA_EXPORT*/\n\t\tgf_isom_delete(the_file);\n\t\tfprintf(dump, \"</Tracks>\\n\");\n\t\tfprintf(dump, \"</ISOBaseMediaFileTrace>\\n\");\n\t}\n\tif (do_close) gf_fclose(dump);\n\treturn e;\n}\n#endif\n\n\nstatic char *format_duration(u64 dur, u32 timescale, char *szDur)\n{\n\tu32 h, m, s, ms;\n\tif ((dur==(u64) -1) || (dur==(u32) -1))  {\n\t\tstrcpy(szDur, \"Unknown\");\n\t\treturn szDur;\n\t}\n\tdur = (u64) (( ((Double) (s64) dur)/timescale)*1000);\n\th = (u32) (dur / 3600000);\n\tm = (u32) (dur/ 60000) - h*60;\n\ts = (u32) (dur/1000) - h*3600 - m*60;\n\tms = (u32) (dur) - h*3600000 - m*60000 - s*1000;\n\tif (h<=24) {\n\t\tsprintf(szDur, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\t} else {\n\t\tu32 d = (u32) (dur / 3600000 / 24);\n\t\th = (u32) (dur/3600000)-24*d;\n\t\tif (d<=365) {\n\t\t\tsprintf(szDur, \"%d Days, %02d:%02d:%02d.%03d\", d, h, m, s, ms);\n\t\t} else {\n\t\t\tu32 y=0;\n\t\t\twhile (d>365) {\n\t\t\t\ty++;\n\t\t\t\td-=365;\n\t\t\t\tif (y%4) d--;\n\t\t\t}\n\t\t\tsprintf(szDur, \"%d Years %d Days, %02d:%02d:%02d.%03d\", y, d, h, m, s, ms);\n\t\t}\n\n\t}\n\treturn szDur;\n}\n\nstatic char *format_date(u64 time, char *szTime)\n{\n\ttime_t now;\n\tif (!time) {\n\t\tstrcpy(szTime, \"UNKNOWN DATE\");\n\t} else {\n\t\ttime -= 2082844800;\n\t\tnow = (u32) time;\n\t\tsprintf(szTime, \"GMT %s\", asctime(gf_gmtime(&now)) );\n\t}\n\treturn szTime;\n}\n\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (udta_size && gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tu32 idx;\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t\");\n\t\t\t\tfor (idx=0; idx<udta_size; idx++) {\n\t\t\t\t\tif (!udta[idx]) break;\n\t\t\t\t\tfprintf(stderr, \"%c\", udta[idx]);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\nGF_Err dump_isom_udta(GF_ISOFile *file, char *inName, Bool is_final_name, u32 dump_udta_type, u32 dump_udta_track)\n{\n\tu8 *data;\n\tFILE *t;\n\tbin128 uuid;\n\tu32 count, res;\n\tGF_Err e;\n\n\tmemset(uuid, 0, 16);\n\tcount = gf_isom_get_user_data_count(file, dump_udta_track, dump_udta_type, uuid);\n\tif (!count) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No UDTA for type %s found\\n\", gf_4cc_to_str(dump_udta_type) ));\n\t\treturn GF_NOT_FOUND;\n\t}\n\n\tdata = NULL;\n\tcount = 0;\n\te = gf_isom_get_user_data(file, dump_udta_track, dump_udta_type, uuid, 0, &data, &count);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error dumping UDTA %s: %s\\n\", gf_4cc_to_str(dump_udta_type), gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tif (inName) {\n\t\tchar szName[1024];\n\t\tif (is_final_name)\n\t\t\tstrcpy(szName, inName);\n\t\telse\n\t\t\tsprintf(szName, \"%s_%s.udta\", inName, gf_4cc_to_str(dump_udta_type) );\n\n\t\tt = gf_fopen(szName, \"wb\");\n\t\tif (!t) {\n\t\t\tgf_free(data);\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open file %s\\n\", szName ));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t} else {\n\t\tt = stdout;\n\t}\n\tres = (u32) gf_fwrite(data+8, count-8, t);\n\tif (inName) gf_fclose(t);\n\tgf_free(data);\n\tif (count-8 != res) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error writing udta to file\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err dump_isom_chapters(GF_ISOFile *file, char *inName, Bool is_final_name, u32 dump_mode)\n{\n\tFILE *t;\n\tu32 i, count;\n\tu32 chap_tk = 0;\n\tcount = gf_isom_get_chapter_count(file, 0);\n\n\tif (dump_mode==2) dump_mode = GF_TEXTDUMPTYPE_OGG_CHAP;\n\telse if (dump_mode==3) dump_mode = GF_TEXTDUMPTYPE_ZOOM_CHAP;\n\telse dump_mode = GF_TEXTDUMPTYPE_TTXT_CHAP;\n\n\tif (!count) {\n\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_CHAP)) {\n\t\t\t\tGF_Err e = gf_isom_get_reference(file, i+1, GF_ISOM_REF_CHAP, 1, &chap_tk);\n\t\t\t\tif (!e) break;\n\t\t\t}\n\t\t}\n\t\tif (!chap_tk) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"No chapters or chapters track found in file\\n\"));\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tfprintf(stderr, \"Dumping chapter track %d\\n\", chap_tk);\n\t\tdump_isom_timed_text(file, gf_isom_get_track_id(file, chap_tk), inName, is_final_name, GF_FALSE, dump_mode);\n\t\treturn GF_OK;\n\n\t}\n\tif (inName) {\n\t\tchar szName[1024];\n\t\tstrcpy(szName, inName);\n\t\tif (!is_final_name) {\n\t\t\tif (dump_mode==GF_TEXTDUMPTYPE_OGG_CHAP) {\n\t\t\t\tstrcat(szName, \".txt\");\n\t\t\t} else if (dump_mode==GF_TEXTDUMPTYPE_ZOOM_CHAP) {\n\t\t\t\tstrcat(szName, \".txt\");\n\t\t\t} else {\n\t\t\t\tstrcat(szName, \".ttxt\");\n\t\t\t}\n\t\t}\n\t\tt = gf_fopen(szName, \"wt\");\n\t\tif (!t) return GF_IO_ERR;\n\t} else {\n\t\tt = stdout;\n\t}\n\n\tif (dump_mode==GF_TEXTDUMPTYPE_TTXT_CHAP) {\n\t\tfprintf(t, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tfprintf(t, \"<TextStream version=\\\"1.1\\\">\\n\");\n\t\tfprintf(t, \"<TextStreamHeader width=\\\"0\\\" height=\\\"0\\\" layer=\\\"0\\\" translation_x=\\\"0\\\" translation_y=\\\"0\\\">\\n\");\n\t\tfprintf(t, \"<TextSampleDescription horizontalJustification=\\\"left\\\" backColor=\\\"0 0 0\\\" scroll=\\\"None\\\"/>\\n\");\n\t\tfprintf(t, \"</TextStreamHeader>\\n\");\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tchar szDur[20];\n\t\tu64 chapter_time;\n\t\tconst char *name;\n\t\tgf_isom_get_chapter(file, 0, i+1, &chapter_time, &name);\n\t\tif (dump_mode==GF_TEXTDUMPTYPE_OGG_CHAP) {\n\t\t\tfprintf(t, \"CHAPTER%02d=%s\\n\", i+1, format_duration(chapter_time, 1000, szDur));\n\t\t\tfprintf(t, \"CHAPTER%02dNAME=%s\\n\", i+1, name);\n\t\t} else if (dump_mode==GF_TEXTDUMPTYPE_ZOOM_CHAP) {\n\t\t\tchapter_time /= 1000;\n\t\t\tfprintf(t, \"AddChapterBySecond(\"LLD\",%s)\\n\", chapter_time, name);\n\t\t} else {\n\t\t\tfprintf(t, \"<TextSample sampleTime=\\\"%s\\\" sampleDescriptionIndex=\\\"1\\\" xml:space=\\\"preserve\\\">%s</TextSample>\\n\"\n\t\t\t\t, format_duration(chapter_time, 1000, szDur), name);\n\t\t}\n\t}\n\tif (dump_mode==GF_TEXTDUMPTYPE_TTXT_CHAP) {\n\t\tfprintf(t, \"</TextStream>\\n\");\n\t}\n\tif (inName) gf_fclose(t);\n\treturn GF_OK;\n}\n\n\nstatic void dump_key_info(const u8 *key_info, u32 key_info_size, Bool is_protected)\n{\n\tif (!key_info) return;\n\tu32 j, k, kpos=3;\n\tu32 nb_keys = 1;\n\tif (key_info[0]) {\n\t\tnb_keys = key_info[1];\n\t\tnb_keys <<= 8;\n\t\tnb_keys |= key_info[2];\n\t}\n\tfor (k=0; k<nb_keys; k++) {\n\t\tu8 constant_iv_size=0;\n\t\tu8 iv_size=key_info[kpos+1];\n\t\tfprintf(stderr, \"\\t\\tKID\");\n\t\tif (nb_keys>1)\n\t\t\tfprintf(stderr, \"%d\", k+1);\n\t\tfprintf(stderr, \" \");\n\t\tfor (j=0; j<16; j++) fprintf(stderr, \"%02X\", key_info[kpos+1+j]);\n\t\tkpos+=17;\n\t\tif (!iv_size && is_protected) {\n\t\t\tconstant_iv_size = key_info[1];\n\t\t\tkpos += 1 + constant_iv_size;\n\t\t}\n\t\tfprintf(stderr, \" - %sIV size %d \\n\", constant_iv_size ? \"const \" : \"\", constant_iv_size ? constant_iv_size : iv_size);\n\t}\n}\n\nstatic void DumpMetaItem(GF_ISOFile *file, Bool root_meta, u32 tk_num, char *name)\n{\n\tchar szInd[2];\n\tu32 i, count, primary_id;\n\tu32 meta_type = gf_isom_get_meta_type(file, root_meta, tk_num);\n\tif (name[0]=='\\t') {\n\t\tszInd[0] = '\\t';\n\t\tszInd[1] = 0;\n\t} else {\n\t\tszInd[0] = 0;\n\t}\n\n\tcount = gf_isom_get_meta_item_count(file, root_meta, tk_num);\n\tprimary_id = gf_isom_get_meta_primary_item_id(file, root_meta, tk_num);\n\tfprintf(stderr, \"%s type: \\\"%s\\\" - %d resource item(s)\\n\", name, meta_type ? gf_4cc_to_str(meta_type) : \"undefined\", (count+(primary_id>0)));\n\tswitch (gf_isom_has_meta_xml(file, root_meta, tk_num)) {\n\tcase 1:\n\t\tfprintf(stderr, \"%sMeta has XML resource\\n\", szInd);\n\t\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"%sMeta has BinaryXML resource\\n\", szInd);\n\t\tbreak;\n\t}\n\tif (primary_id) {\n\t\tfprintf(stderr, \"%sPrimary Item - ID %d\\n\", szInd, primary_id);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tconst char *it_name, *mime, *enc, *url, *urn;\n\t\tBool self_ref;\n\t\tu32 ID;\n\t\tu32 it_type, cenc_scheme, cenc_version;\n\t\tGF_Err e = gf_isom_get_meta_item_info(file, root_meta, tk_num, i+1, &ID, &it_type, &cenc_scheme, &cenc_version, &self_ref, &it_name, &mime, &enc, &url, &urn);\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"%sItem #%d fetch info error: %s\\n\", szInd, i+1, gf_error_to_string(e) );\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stderr, \"%sItem #%d: ID %d type %s\", szInd, i+1, ID, gf_4cc_to_str(it_type));\n\t\tif (self_ref) fprintf(stderr, \" Self-Reference\");\n\t\telse if (it_name && it_name[0]) fprintf(stderr, \" Name \\\"%s\\\"\", it_name);\n\t\tif (mime) fprintf(stderr, \" MIME: \\\"%s\\\"\", mime);\n\t\tif (enc) fprintf(stderr, \" ContentEncoding: \\\"%s\\\"\", enc);\n\n\t\tif (meta_type == GF_META_ITEM_TYPE_PICT) {\n\t\t\tGF_ImageItemProperties img_props;\n\t\t\te = gf_isom_get_meta_image_props(file, root_meta, tk_num, ID, &img_props);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \" invalid image properties !\");\n\t\t\t} else {\n\t\t\t\tu32 j;\n\t\t\t\tBool chan_diff = 0;\n\t\t\t\tif (img_props.width && img_props.height) {\n\t\t\t\t\tfprintf(stderr, \" size %ux%u\", img_props.width, img_props.height);\n\t\t\t\t}\n\t\t\t\tif (img_props.hSpacing && img_props.vSpacing) {\n\t\t\t\t\tfprintf(stderr, \" SAR %u/%u\", img_props.hSpacing, img_props.vSpacing);\n\t\t\t\t}\n\t\t\t\tif (img_props.num_channels) {\n\t\t\t\t\tfprintf(stderr, \" %d channel%s (\", img_props.num_channels, (img_props.num_channels>1) ? \"s\" : \"\");\n\t\t\t\t\tfor (j=1; j<img_props.num_channels; j++) {\n\t\t\t\t\t\tif (img_props.bits_per_channel[0] != img_props.bits_per_channel[j])\n\t\t\t\t\t\t\tchan_diff = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (chan_diff) {\n\t\t\t\t\t\tfor (j=0; j<img_props.num_channels; j++) {\n\t\t\t\t\t\t\tif (j) fprintf(stderr, \",\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%d\", img_props.bits_per_channel[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"%d\", img_props.bits_per_channel[0]);\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \" bpc)\");\n\t\t\t\t}\n\t\t\t\tif (img_props.hOffset || img_props.vOffset)\n\t\t\t\t\tfprintf(stderr, \" Offset %ux%u\", img_props.hOffset, img_props.vOffset);\n\t\t\t\tif (img_props.alpha) fprintf(stderr, \" Alpha\");\n\t\t\t\tif (img_props.hidden) fprintf(stderr, \" Hidden\");\n\t\t\t\tif (img_props.angle) fprintf(stderr, \" Rotate %d\", img_props.angle);\n\t\t\t\tif (img_props.mirror) fprintf(stderr, \" Mirror %d\", img_props.mirror);\n\t\t\t\tif (img_props.clap_hden || img_props.clap_wden)\n\t\t\t\t\tfprintf(stderr, \" Clap %d/%d,%d/%d,%d/%d,%d/%d\", img_props.clap_wnum, img_props.clap_wden, img_props.clap_hnum, img_props.clap_hden, img_props.clap_honum, img_props.clap_hoden, img_props.clap_vonum, img_props.clap_voden);\n\t\t\t}\n\t\t}\n\n\t\tif (cenc_scheme) {\n\t\t\tBool is_protected;\n\t\t\tu8 skip_byte_block, crypt_byte_block;\n\t\t\tconst u8 *key_info;\n\t\t\tu32 key_info_size;\n\t\t\tfprintf(stderr, \" - Protection scheme: %s v0x%08X\", gf_4cc_to_str(cenc_scheme), cenc_version);\n\n\t\t\tgf_isom_extract_meta_item_get_cenc_info(file, root_meta, tk_num, ID, &is_protected, &skip_byte_block, &crypt_byte_block, &key_info, &key_info_size, NULL, NULL, NULL, NULL);\n\t\t\tif (skip_byte_block && crypt_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", skip_byte_block, crypt_byte_block);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(key_info, key_info_size, is_protected);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tif (url) fprintf(stderr, \"%sURL: %s\\n\", szInd, url);\n\t\tif (urn) fprintf(stderr, \"%sURN: %s\\n\", szInd, urn);\n\n\t}\n}\n\n\nstatic void print_config_hash(GF_List *xps_array, char *szName)\n{\n\tu32 i, j;\n\tu8 hash[20];\n\tfor (i=0; i<gf_list_count(xps_array); i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(xps_array, i);\n\t\tgf_sha1_csum((u8 *) slc->data, slc->size, hash);\n\t\tfprintf(stderr, \"\\t%s#%d hash: \", szName, i+1);\n\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid dump_hevc_track_info(GF_ISOFile *file, u32 trackNum, GF_HEVCConfig *hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t, HEVCState *hevc_state\n#endif /*GPAC_DISABLE_AV_PARSERS  && defined(GPAC_DISABLE_HEVC)*/\n\t)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\tu32 idx;\n#endif\n\tu32 k;\n\tBool non_hevc_base_layer=GF_FALSE;\n\tfprintf(stderr, \"\\t%s Info:\", hevccfg->is_lhvc ? \"LHVC\" : \"HEVC\");\n\tif (!hevccfg->is_lhvc)\n\t\tfprintf(stderr, \" Profile %s @ Level %g - Chroma Format %s\\n\", gf_hevc_get_profile_name(hevccfg->profile_idc), ((Double)hevccfg->level_idc) / 30.0, gf_avc_hevc_get_chroma_format_name(hevccfg->chromaFormat));\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tNAL Unit length bits: %d\", 8*hevccfg->nal_unit_size);\n\tif (!hevccfg->is_lhvc)\n\t\tfprintf(stderr, \" - general profile compatibility 0x%08X\\n\", hevccfg->general_profile_compatibility_flags);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tParameter Sets: \");\n\tfor (k=0; k<gf_list_count(hevccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(hevccfg->param_array, k);\n\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\tfprintf(stderr, \"%d SPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\tfprintf(stderr, \"%d PPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\tfprintf(stderr, \"%d VPS \", gf_list_count(ar->nalus));\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\t\tGF_NALUFFParam *vps = gf_list_get(ar->nalus, idx);\n\t\t\t\ts32 ps_idx=gf_hevc_read_vps(vps->data, vps->size, hevc_state);\n\t\t\t\tif (hevccfg->is_lhvc && (ps_idx>=0)) {\n\t\t\t\t\tnon_hevc_base_layer = ! hevc_state->vps[ps_idx].base_layer_internal_flag;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\n\tfprintf(stderr, \"\\n\");\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\tfor (k=0; k<gf_list_count(hevccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(hevccfg->param_array, k);\n\t\tu32 width, height;\n\t\ts32 par_n, par_d;\n\n\t\tif (ar->type !=GF_HEVC_NALU_SEQ_PARAM) continue;\n\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\tGF_Err e;\n\t\t\tGF_NALUFFParam *sps = gf_list_get(ar->nalus, idx);\n\t\t\tpar_n = par_d = -1;\n\t\t\te = gf_hevc_get_sps_info_with_state(hevc_state, sps->data, sps->size, NULL, &width, &height, &par_n, &par_d);\n\t\t\tif (e==GF_OK) {\n\t\t\t\tfprintf(stderr, \"\\tSPS resolution %dx%d\", width, height);\n\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\tu32 tw, th;\n\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\tfprintf(stderr, \" - Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\", par_n, par_d, tw, th);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to read SPS: %s\\n\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (!hevccfg->is_lhvc)\n\t\tfprintf(stderr, \"\\tBit Depth luma %d - Chroma %d - %d temporal layers\\n\", hevccfg->luma_bit_depth, hevccfg->chroma_bit_depth, hevccfg->numTemporalLayers);\n\telse\n\t\tfprintf(stderr, \"\\t%d temporal layers\\n\", hevccfg->numTemporalLayers);\n\tif (hevccfg->is_lhvc) {\n\t\tfprintf(stderr, \"\\t%sHEVC base layer - Complete representation %d\\n\", non_hevc_base_layer ? \"Non-\" : \"\", hevccfg->complete_representation);\n\t}\n\n\tfor (k=0; k<gf_list_count(hevccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(hevccfg->param_array, k);\n\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) print_config_hash(ar->nalus, \"SPS\");\n\t\telse if (ar->type==GF_HEVC_NALU_PIC_PARAM) print_config_hash(ar->nalus, \"PPS\");\n\t\telse if (ar->type==GF_HEVC_NALU_VID_PARAM) print_config_hash(ar->nalus, \"VPS\");\n\t}\n}\n\nvoid dump_vvc_track_info(GF_ISOFile *file, u32 trackNum, GF_VVCConfig *vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t, VVCState *vvc_state\n#endif /*GPAC_DISABLE_AV_PARSERS  && defined(GPAC_DISABLE_HEVC)*/\n\t)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\tu32 idx;\n#endif\n\tu32 k;\n\tfprintf(stderr, \"\\tVVC Info:\");\n\n\tfprintf(stderr, \" Profile %d @ Level %d - Chroma Format %s\\n\", vvccfg->general_profile_idc, vvccfg->general_level_idc, vvccfg->chromaformat_plus_one ? gf_avc_hevc_get_chroma_format_name(vvccfg->chromaformat_plus_one-1) : \"n/a\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tNAL Unit length bits: %d\", 8*vvccfg->nal_unit_size);\n\tif (vvccfg->general_constraint_info && vvccfg->num_constraint_info && vvccfg->general_constraint_info[0]) {\n\t\tfprintf(stderr, \" - general constraint info 0x\");\n\t\tfor (idx=0; idx<vvccfg->num_constraint_info; idx++) {\n\t\t\tfprintf(stderr, \"%02X\", vvccfg->general_constraint_info[idx]);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"\\tParameter Sets: \");\n\tfor (k=0; k<gf_list_count(vvccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);\n\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) {\n\t\t\tfprintf(stderr, \"%d SPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_VVC_NALU_PIC_PARAM) {\n\t\t\tfprintf(stderr, \"%d PPS \", gf_list_count(ar->nalus));\n\t\t}\n\t\tif (ar->type==GF_VVC_NALU_VID_PARAM) {\n\t\t\tfprintf(stderr, \"%d VPS \", gf_list_count(ar->nalus));\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && 0 //TODO\n\t\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\t\tGF_NALUFFParam *vps = gf_list_get(ar->nalus, idx);\n\t\t\t\ts32 ps_idx=gf_hevc_read_vps(vps->data, vps->size, hevc_state);\n\t\t\t\tif (hevccfg->is_lhvc && (ps_idx>=0)) {\n\t\t\t\t\tnon_hevc_base_layer = ! hevc_state->vps[ps_idx].base_layer_internal_flag;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\n\tfprintf(stderr, \"\\n\");\n#if !defined(GPAC_DISABLE_AV_PARSERS) && 0 //TODO\n\tfor (k=0; k<gf_list_count(vvccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);\n\t\tu32 width, height;\n\t\ts32 par_n, par_d;\n\n\t\tif (ar->type !=GF_VVC_NALU_SEQ_PARAM) continue;\n\t\tfor (idx=0; idx<gf_list_count(ar->nalus); idx++) {\n\t\t\tGF_Err e;\n\t\t\tGF_NALUFFParam *sps = gf_list_get(ar->nalus, idx);\n\t\t\tpar_n = par_d = -1;\n\t\t\te = gf_vvc_get_sps_info_with_state(vvc_state, sps->data, sps->size, NULL, &width, &height, &par_n, &par_d);\n\t\t\tif (e==GF_OK) {\n\t\t\t\tfprintf(stderr, \"\\tSPS resolution %dx%d\", width, height);\n\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\tu32 tw, th;\n\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\tfprintf(stderr, \" - Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\", par_n, par_d, tw, th);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\nFailed to read SPS: %s\\n\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tfprintf(stderr, \"\\tBit Depth %d - %d temporal layers\\n\", vvccfg->bit_depth_plus_one-1, vvccfg->numTemporalLayers);\n\n\tfor (k=0; k<gf_list_count(vvccfg->param_array); k++) {\n\t\tGF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);\n\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) print_config_hash(ar->nalus, \"SPS\");\n\t\telse if (ar->type==GF_VVC_NALU_PIC_PARAM) print_config_hash(ar->nalus, \"PPS\");\n\t\telse if (ar->type==GF_VVC_NALU_VID_PARAM) print_config_hash(ar->nalus, \"VPS\");\n\t}\n}\n\nvoid gf_inspect_format_timecode(const u8 *data, u32 size, u32 tmcd_flags, u32 tc_num, u32 tc_den, u32 tmcd_fpt, char szFmt[100]);\n\nvoid DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\tDouble scale, max_rate, rate;\n\tBool is_od_track = 0;\n\tu32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;\n\tu64 time_slice, dur, size;\n\ts32 cts_shift;\n\tGF_ESD *esd;\n\tchar szDur[50];\n\tchar *lang;\n\n\tif (!is_track_num) {\n\t\ttrackNum = gf_isom_get_track_by_id(file, trackID);\n\t} else {\n\t\ttrackNum = trackID;\n\t\ttrackID = gf_isom_get_track_id(file, trackNum);\n\t}\n\tif (!trackNum) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, trackNum);\n\tfprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);\n\n\tdur = gf_isom_get_media_original_duration(file, trackNum);\n\tsize = gf_isom_get_media_duration(file, trackNum);\n\tfprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));\n\tif (dur != size)\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tif (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));\n\t}\n\n\tnb_edits = gf_isom_get_edits_count(file, trackNum);\n\tif (nb_edits)\n\t\tfprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));\n\n\tcts_shift = gf_isom_get_composition_offset_shift(file, trackNum);\n\tif (cts_shift)\n\t\tfprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);\n\n\tif (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");\n\tif (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");\n\tgf_isom_get_media_language(file, trackNum, &lang);\n\tfprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );\n\tgf_free(lang);\n\tmtype = gf_isom_get_media_type(file, trackNum);\n\tfprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));\n\tmsub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);\n\tif (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tfprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));\n\n\tpfmt = gf_pixel_fmt_from_qt_type(msub_type);\n\tcodecid = gf_codec_id_from_isobmf(msub_type);\n\n\tcount = gf_isom_get_track_kind_count(file, trackNum);\n\tfor (i = 0; i < count; i++) {\n\t\tchar *kind_scheme, *kind_value;\n\t\tgf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);\n\t\tfprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");\n\t\tif (kind_scheme) gf_free(kind_scheme);\n\t\tif (kind_value) gf_free(kind_value);\n\t}\n\n\tif (gf_isom_is_track_fragmented(file, trackID) ) {\n\t\tu32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;\n\t\tu8 defaultPadding;\n\t\tu16 defaultDegradationPriority;\n\t\tu32 frag_samples;\n\t\tu64 frag_duration;\n\t\tgf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);\n\t\tfprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));\n\n\t\tgf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);\n\n\t\tfprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",\n\t\t\t\tdefaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,\n\t\t\t\t(u32) defaultPadding, (u32) defaultDegradationPriority\n\t\t);\n\t}\n\n\tif (!gf_isom_is_self_contained(file, trackNum, 1)) {\n\t\tconst char *url, *urn;\n\t\tgf_isom_get_data_reference(file, trackNum, 1, &url, &urn);\n\t\tfprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);\n\t}\n\n\tif (full_dump) {\n\t\tconst char *handler_name;\n\t\tgf_isom_get_handler_name(file, trackNum, &handler_name);\n\t\tfprintf(stderr, \"Handler name: %s\\n\", handler_name);\n\t}\n\n\tprint_udta(file, trackNum, GF_FALSE);\n\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\ts32 tx, ty;\n\t\tu32 w, h;\n\t\tu16 bit_depth;\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tgf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);\n\t\tfprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);\n\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);\n\t\tfprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);\n\t}\n\n\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);\n\tgf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmsub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tif (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)\n\t\tgf_isom_get_original_format_type(file, trackNum, 1, &msub_type);\n\n\tif ((msub_type==GF_ISOM_SUBTYPE_MPEG4)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_SVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_MVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LSR1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHE1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVT1)\n\t   )  {\n\t\tesd = gf_isom_get_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tconst char *st = gf_stream_type_name(esd->decoderConfig->streamType);\n\t\t\tif (dump_m4sys) {\n\t\t\t\tif (st) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_OD)\n\t\t\t\tis_od_track=1;\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\tu32 w, h;\n\t\t\t\tu16 rvc_predef;\n\t\t\t\tw = h = 0;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n#else\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);\n#endif\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));\n\t\t\t\t\t\tif (dsi.par_den && dsi.par_num) {\n\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\tfprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {\n\t\t\t\t\tGF_AVCConfig *avccfg, *svccfg, *mvccfg;\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);\n\n\t\t\t\t\tavccfg = gf_isom_avc_config_get(file, trackNum, 1);\n\t\t\t\t\tsvccfg = gf_isom_svc_config_get(file, trackNum, 1);\n\t\t\t\t\tmvccfg = gf_isom_mvc_config_get(file, trackNum, 1);\n\t\t\t\t\tif (!avccfg && !svccfg && !mvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));\n\t\t\t\t\t} else if (avccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );\n\t\t\t\t\t\tfprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);\n\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!full_dump) break;\n\t\t\t\t\t\t}\n#endif\n\n\t\t\t\t\t\tif (avccfg->chroma_bit_depth) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprint_config_hash(avccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(avccfg->pictureParameterSets, \"PPS\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t\t}\n\t\t\t\t\tif (svccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mvccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(mvccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(mvccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tgf_odf_avc_cfg_del(mvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)\n\t\t\t\t           || (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)\n\t\t\t\t          ) {\n\t\t\t\t\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\t\t\t\t\tGF_OperatingPointsInformation *oinf;\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\tHEVCState hevc_state;\n\t\t\t\t\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\t\t\t\t\thevc_state.sps_active_idx = -1;\n#endif\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);\n\t\t\t\t\thevccfg = gf_isom_hevc_config_get(file, trackNum, 1);\n\t\t\t\t\tlhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);\n\n\t\t\t\t\tif (msub_type==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\t\t\t\tconst u8 *data;\n\t\t\t\t\t\tu32 tsize;\n\t\t\t\t\t\tu32  is_default, tx,ty,tw,th, id, independent;\n\t\t\t\t\t\tBool full_frame;\n\t\t\t\t\t\tif (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);\n\t\t\t\t\t\t} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!hevccfg && !lhvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile base track\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (hevccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lhvccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, lhvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_oinf_info(file, trackNum, &oinf)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tOperating Points Information -\");\n\t\t\t\t\t\tfprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);\n\t\t\t\t\t\tswitch (oinf->scalability_mask) {\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfprintf(stderr, \"Multiview\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfprintf(stderr, \"Spatial scalability\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tfprintf(stderr, \"Auxilary\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//TODO: need to dump more info ?\n\t\t\t\t\t\tfprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );\n\t\t\t\t\t\tfprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OGG media*/\n\t\t\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tchar *szName;\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";\n\t\t\t\t\telse szName = \"Unknown\";\n\t\t\t\t\tfprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//check if we know this codec from its OTI\n\t\t\t\t\tu32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\t\tfprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"Visual Size %d x %d\\n\", w, h);\n\t\t\t\t}\n\t\t\t\tif (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);\n\t\t\t\t}\n\n\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 oti;\n#endif\n\t\t\t\tu32 codec_id;\n\t\t\t\tBool is_mp2 = GF_FALSE;\n\t\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tis_mp2 = GF_TRUE;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\telse\n\t\t\t\t\t\te = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *signaling = \"implicit\";\n\t\t\t\t\t\tchar *heaac = \"\";\n\t\t\t\t\t\tif (!is_mp2 && a_cfg.has_sbr) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";\n\t\t\t\t\t\t\telse heaac = \"(HE-AAC v1) \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a_cfg.base_object_type==2) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps || a_cfg.has_sbr)\n\t\t\t\t\t\t\t\tsignaling = \"backward compatible\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsignaling = \"hierarchical\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);\n\t\t\t\t\t\tif (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");\n\t\t\t\t\t\tif (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));\n\t\t\t\t\t\tif (a_cfg.has_ps) fprintf(stderr, \" - PS\");\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n#else\n\t\t\t\t\tfprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tif (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n\t\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);\n\t\t\t\t\t\tif (samp) {\n\t\t\t\t\t\t\tu32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",\n\t\t\t\t\t\t\t        gf_mp3_version_name(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_num_channels(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_sampling_rate(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_layer(mhdr)\n\t\t\t\t\t\t\t       );\n\t\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\tfprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tfprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\tfprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t/*packetVideo hack for EVRC...*/\n\t\t\t\tcase GF_CODECID_EVRC_PV:\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)\n\t\t\t\t\t        && !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tfprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcodec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=4) {\n\t\t\t\t\tGF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tfprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");\n\t\t\t\t\tif (full_dump && !b_cfg->elementaryMasks) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)b_cfg);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {\n\t\t\t\t\tu8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;\n\t\t\t\t\tconst char *afxtype = gf_stream_type_afx_name(tag);\n\t\t\t\t\tfprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {\n\t\t\t\t\tfprintf(stderr, \"Font Data stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {\n\t\t\t\t\tGF_LASERConfig l_cfg;\n\t\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);\n\t\t\t\t\tfprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {\n\t\t\t\t\tfprintf(stderr, \"Synthetized Texture stream stream\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*sync is only valid if we open all tracks to take care of default MP4 sync..*/\n\t\t\tif (!full_dump) {\n\t\t\t\tif (dump_m4sys) {\n\t\t\t\t\tif (!esd->OCRESID || (esd->OCRESID == esd->ESID))\n\t\t\t\t\t\tfprintf(stderr, \"Self-synchronized\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);\n\t\t\t\tif (esd->dependsOnESID)\n\t\t\t\t\tfprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");\n\n\t\t\t\tfprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);\n\t\t\t\tif (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_AV1Config *av1c;\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);\n\n\t\tav1c = gf_isom_av1_config_get(file, trackNum, 1);\n\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\tif (av1c->initial_presentation_delay_present)\n\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\tcount = gf_list_count(av1c->obu_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu8 hash[20];\n\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {\n\t\tfprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {\n\t\tfprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {\n\t\tfprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {\n\t\tfprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {\n\t\tu32 br = 0;\n\t\tconst char *lfe = \"\";\n\t\tBool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);\n\t\tif (ac3) {\n\t\t\tnb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);\n\t\t\tfor (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {\n\t\t\t\tassert(ac3->streams[0].nb_dep_sub == 1);\n\t\t\t\tnb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);\n\t\t\t}\n\t\t\tif (ac3->streams[0].lfon) lfe = \".1\";\n\t\t\tbr = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);\n\t\t\tis_ec3 = ac3->is_ec3;\n\t\t\tgf_free(ac3);\n\t\t}\n#endif\n\t\tfprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {\n\t\tfprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tu32 w, h;\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\n\t\tgf_isom_get_dims_description(file, trackNum, 1, &dims);\n\t\tfprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);\n\t\tfprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");\n\t\tfprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );\n\t\tif (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);\n\t\tif (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);\n\t\tif (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);\n\t} else if (mtype==GF_ISOM_MEDIA_HINT) {\n\t\tu32 refTrack;\n\t\ts32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);\n\t\tif (refCount>0) {\n\t\t\tfprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tgf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);\n\t\t\t\tif (i) fprintf(stderr, \" - \");\n\t\t\t\tfprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Streaming Hint Track (no refs)\\n\");\n\t\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\trefCount = gf_isom_get_payt_count(file, trackNum);\n\t\tif (refCount>0) {\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tconst char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);\n\t\t\t\tfprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);\n\t\t\t}\n\t\t}\n#endif\n\t} else if (mtype==GF_ISOM_MEDIA_FLASH) {\n\t\tfprintf(stderr, \"Macromedia Flash Movie\\n\");\n\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {\n\t\tu32 w, h;\n\t\ts16 l;\n\t\ts32 tx, ty;\n\t\tconst char *content_encoding = NULL;\n\t\tconst char *mime = NULL;\n\t\tconst char *config  = NULL;\n\t\tconst char *_namespace = NULL;\n\t\tconst char *schema_loc = NULL;\n\t\tconst char *auxiliary_mimes = NULL;\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);\n\t\tif (msub_type == GF_ISOM_SUBTYPE_SBTT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Simple Timed Text Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {\n\t\t\tgf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);\n\t\t\tfprintf(stderr, \"XML Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- namespace %s\", _namespace);\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tif (auxiliary_mimes != NULL) {\n\t\t\t\tfprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Text Stream\");\n\t\t}\n\t\tfprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);\n\t} else if (mtype == GF_ISOM_MEDIA_META) {\n\t\tconst char *content_encoding = NULL;\n\t\tif (msub_type == GF_ISOM_SUBTYPE_METT) {\n\t\t\tconst char *mime = NULL;\n\t\t\tconst char *config  = NULL;\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_METX) {\n\t\t\tconst char *_namespace = NULL;\n\t\t\tconst char *schema_loc = NULL;\n\t\t\tgf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);\n\t\t\tfprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Metadata Stream\\n\");\n\t\t}\n\t} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {\n\t\tGF_VVCConfig *vvccfg;\n\t\tu32 w, h;\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tVVCState *vvc_state;\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (vvc_state) vvc_state->sps_active_idx = -1;\n#endif\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\tfprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);\n\t\tvvccfg = gf_isom_vvc_config_get(file, trackNum, 1);\n\n\t\tif (!vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));\n\t\t} else {\n\t\t\tdump_vvc_track_info(file, trackNum, vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\t\t\t, vvc_state\n#endif\n\t\t\t);\n\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (vvc_state) gf_free(vvc_state);\n#endif\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)\n\t\t\t|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)\n\t) {\n\t\tconst u8 *compat_profiles;\n\t\tu32 nb_compat_profiles;\n\t\tBool valid = GF_FALSE;\n\t\tBool allow_inband = GF_FALSE;\n\t\tif ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tallow_inband = GF_TRUE;\n\n\t\tfprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);\n\n\t\tesd = gf_media_map_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\tif (allow_inband) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tu64 ch_layout=0;\n\t\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\t\tif (PL>=0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);\n\t\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\t\tfprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t\tvalid = GF_TRUE;\n\t\t\t}\n\t\t} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {\n\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]\n\t\t\t\t, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])\n\t\t\t);\n\t\t\tvalid = GF_TRUE;\n\t\t}\n\t\tif (!valid) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\tcompat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);\n\t\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\t\tif (!i)\n\t\t\t\tfprintf(stderr, \"\\tCompatible profiles:\");\n\t\t\tfprintf(stderr, \" 0x%02X\", compat_profiles[i]);\n\t\t}\n\t\tif (i) fprintf(stderr, \"\\n\");\n\t} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {\n\t\tu32 fmt, prate;\n\t\tif (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {\n\t\t\tfprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");\n\t\t}\n\t\tfprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);\n\t} else if (codecid) {\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\tfprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);\n\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);\n\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );\n\t\t}\n\t} else if (pfmt) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);\n\t} else if (msub_type==GF_QT_SUBTYPE_TMCD) {\n\t\tu32 stsd_idx;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);\n\t\tfprintf(stderr, \"Time Code stream\\n\");\n\t\tif (sample) {\n\t\t\tchar szTimecode[100];\n\t\t\tu32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;\n\n\t\t\tgf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);\n\n\t\t\tgf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);\n\n\t\t\tgf_isom_sample_del(&sample);\n\t\t\tfprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);\n\t\t}\n\t} else {\n\t\tGF_GenericSampleDescription *udesc;\n\n\t\tudesc = gf_isom_get_generic_sample_description(file, trackNum, 1);\n\t\tif (udesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n                fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",\n\t\t\t\t\t\t( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),\n                        udesc->compressor_name, udesc->width, udesc->height);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tfprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown media type\\n\");\n\t\t\t}\n\t\t\tif (udesc->vendor_code)\n\t\t\t\tfprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);\n\n\t\t\tif (udesc->extension_buf) {\n\t\t\t\tfprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);\n\t\t\t\tgf_free(udesc->extension_buf);\n\t\t\t}\n\t\t\tgf_free(udesc);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown track type\\n\");\n\t\t}\n\t}\n\n\n\t/*Crypto info*/\n\tif (gf_isom_is_track_encrypted(file, trackNum)) {\n\t\tconst char *scheme_URI, *KMS_URI;\n\t\tu32 scheme_type, version;\n\t\tu32 IV_size;\n\t\tBool use_sel_enc;\n\n\t\tif (gf_isom_is_ismacryp_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tif (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);\n\t\t\tif (KMS_URI) {\n\t\t\t\tif (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");\n\t\t\t\telse fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {\n\t\t\tconst char *textHdrs;\n\t\t\tu32 enc_type, hdr_len;\n\t\t\tu64 orig_len;\n\t\t\tgf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tfprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);\n\t\t\tfprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);\n\t\t\tif (textHdrs) {\n\t\t\t\tu32 offset;\n\t\t\t\tconst char *start = textHdrs;\n\t\t\t\tfprintf(stderr, \"\\tOMA Textual Headers:\\n\");\n\t\t\t\ti=0;\n\t\t\t\toffset=0;\n\t\t\t\twhile (i<hdr_len) {\n\t\t\t\t\tif (start[i]==0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\t\\t%s\\n\", start+offset);\n\t\t\t\t\t\toffset=i+1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\\\tt%s\\n\", start+offset);\n\t\t\t}\n\t\t\tif (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);\n\t\t\tfprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {\n\t\t\tconst u8 *def_key;\n\t\t\tu32 def_key_size;\n\t\t\tBool IsEncrypted;\n\t\t\tu8 crypt_byte_block, skip_byte_block;\n\t\t\tIV_size = 0;\n\t\t\tgf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);\n\n\t\t\tgf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);\n\n\t\t\tfprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);\n\n\t\t\tif (crypt_byte_block && skip_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);\n\t\t\tif (def_key && def_key[0])\n\t\t\t\tfprintf(stderr, \" - MultiKey\");\n\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(def_key, def_key_size, IsEncrypted);\n\n\t\t} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);\n\t\t\tfprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tif ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {\n\t\tfprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);\n\t}\n\n\n\tDumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");\n\n\tgf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);\n\tif (alt_group) {\n\t\tfprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);\n\t\tfor (i=0; i<nb_groups; i++) {\n\t\t\tu32 nb_crit, switchGroupID;\n\t\t\tconst u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);\n\t\t\tif (!nb_crit) {\n\t\t\t\tfprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");\n\t\t\t} else {\n\t\t\t\tif (switchGroupID) {\n\t\t\t\t\tfprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"\\tAlternate Group criterias: \");\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_crit; j++) {\n\t\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (gf_isom_has_sync_points(file, trackNum)) {\n\tcase 0:\n\t\tfprintf(stderr, \"\\tAll samples are sync\\n\");\n\t\tbreak;\n\tcase 1:\n\t{\n\t\tu32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;\n\t\tif (! nb_sync) {\n\t\t\tfprintf(stderr, \"\\tOnly one sync sample\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);\n\t\t}\n\t}\n\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"\\tNo sync sample found\\n\");\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);\n\n\tif (!full_dump) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\n\tdur = size = 0;\n\tmax_rate = rate = 0;\n\ttime_slice = 0;\n\tts = gf_isom_get_media_timescale(file, trackNum);\n\tcsize = gf_isom_get_constant_sample_size(file, trackNum);\n\tcdur = gf_isom_get_constant_sample_duration(file, trackNum);\n\tcount = gf_isom_get_sample_count(file, trackNum);\n\tif (csize && cdur) {\n\t\tsize = count * csize;\n\t\tdur = cdur * count;\n\t} else {\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (is_od_track) {\n\t\t\t\tsamp = gf_isom_get_sample(file, trackNum, j+1, NULL);\n\t\t\t} else {\n\t\t\t\tsamp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);\n\t\t\t}\n\t\t\tif (!samp) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdur = samp->DTS+samp->CTS_Offset;\n\t\t\tsize += samp->dataLength;\n\t\t\trate += samp->dataLength;\n\t\t\tif (samp->DTS - time_slice > ts) {\n\t\t\t\tDouble max_tmp = rate * ts / (samp->DTS - time_slice);\n\t\t\t\tif (max_rate < max_tmp )\n\t\t\t\t\tmax_rate = max_tmp;\n\n\t\t\t\trate = 0;\n\t\t\t\ttime_slice = samp->DTS;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\nComputed info from media:\\n\");\n\tif (csize && cdur) {\n\t\tfprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);\n\t}\n\tscale = 1000.0 / ts;\n\tdur = (u64) (scale * dur);\n\tfprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);\n\tif (!dur) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\t/*rate in byte, dur is in ms*/\n\trate = 8000.0 * size / dur;\n\n\tif (!max_rate)\n\t\tmax_rate = rate;\n\telse\n\t\tmax_rate *= 8.0;\n\n\tif (rate >= 1500) {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);\n\t} else {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);\n\t}\n\n\t{\n\t\tu32 dmin, dmax, davg, smin, smax, savg;\n\t\tgf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);\n\t\tfprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);\n\t\tfprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tcount = gf_isom_get_chapter_count(file, trackNum);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (j=0; j<count; j++) {\n\t\t\tgf_isom_get_chapter(file, trackNum, j+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);\n\t\t}\n\t}\n}\n\nvoid DumpMovieInfo(GF_ISOFile *file)\n{\n\tGF_InitialObjectDescriptor *iod;\n\tBool dump_m4sys = GF_FALSE;\n\tu32 i, brand, min, timescale, count, data_len;\n\tconst u8 *data;\n\tu64 create, modif;\n\tBool has_itags = GF_FALSE;\n\tchar szDur[50];\n\n\tDumpMetaItem(file, 1, 0, \"# File Meta\");\n\tif (!gf_isom_has_movie(file)) {\n\t\tif (gf_isom_has_segment(file, &brand, &min)) {\n\t\t\tcount = gf_isom_segment_get_fragment_count(file);\n\t\t\tfprintf(stderr, \"File is a segment - %d movie fragments - Brand %s (version %d):\\n\", count, gf_4cc_to_str(brand), min);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu32 j, traf_count = gf_isom_segment_get_track_fragment_count(file, i+1);\n\t\t\t\tfor (j=0; j<traf_count; j++) {\n\t\t\t\t\tu32 ID;\n\t\t\t\t\tu64 tfdt;\n\t\t\t\t\tID = gf_isom_segment_get_track_fragment_decode_time(file, i+1, j+1, &tfdt);\n\t\t\t\t\tfprintf(stderr, \"\\tFragment #%d Track ID %d - TFDT \"LLU\"\\n\", i+1, ID, tfdt);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"File has no movie (moov) - static data container\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_timescale(file);\n\ti=gf_isom_get_track_count(file);\n\tfprintf(stderr, \"# Movie Info - %d track%s - TimeScale %d\\n\", i, i>1 ? \"s\" : \"\", timescale);\n\n\tmodif = gf_isom_get_duration(file);\n\tcreate = gf_isom_get_original_duration(file);\n\tfprintf(stderr, \"Duration %s\", format_duration(create, timescale, szDur));\n\tif (create!=modif) {\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(modif, timescale, szDur));\n\t}\n\tfprintf(stderr, \"\\n\");\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (gf_isom_is_fragmented(file)) {\n\t\tfprintf(stderr, \"Fragmented: yes - duration %s\\n%d fragments - %d SegmentIndexes\\n\", format_duration(gf_isom_get_fragmented_duration(file), timescale, szDur), gf_isom_get_fragments_count(file, 0) , gf_isom_get_fragments_count(file, 1) );\n\t} else {\n\t\tfprintf(stderr, \"Fragmented: no\\n\");\n\t}\n#endif\n\n\tif (gf_isom_moov_first(file))\n\t\tfprintf(stderr, \"Progressive (moov before mdat)\\n\");\n\n\tif (gf_isom_get_brand_info(file, &brand, &min, &count) == GF_OK) {\n\t\tfprintf(stderr, \"Major Brand %s - version %d - compatible brands:\", gf_4cc_to_str(brand), min);\n\t\tfor (i=0; i<count;i++) {\n\t\t\tif (gf_isom_get_alternate_brand(file, i+1, &brand)==GF_OK)\n\t\t\t\tfprintf(stderr, \" %s\", gf_4cc_to_str(brand) );\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tgf_isom_get_creation_time(file, &create, &modif);\n\tfprintf(stderr, \"Created: %s\", format_date(create, szDur));\n\tif (create != modif)\n\t\tfprintf(stderr, \"Modified: %s\", format_date(modif, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tDumpMetaItem(file, 0, 0, \"# Movie Meta\");\n\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (iod) {\n\t\tu32 desc_size = gf_odf_desc_size((GF_Descriptor *)iod);\n\t\tif (iod->tag == GF_ODF_IOD_TAG) {\n\t\t\tfprintf(stderr, \"File has root IOD (%d bytes)\\n\", desc_size);\n\t\t\tfprintf(stderr, \"Scene PL 0x%02x - Graphics PL 0x%02x - OD PL 0x%02x\\n\", iod->scene_profileAndLevel, iod->graphics_profileAndLevel, iod->OD_profileAndLevel);\n\t\t\tfprintf(stderr, \"Visual PL: %s (0x%02x)\\n\", gf_m4v_get_profile_name(iod->visual_profileAndLevel), iod->visual_profileAndLevel);\n\t\t\tfprintf(stderr, \"Audio PL: %s (0x%02x)\\n\", gf_m4a_get_profile_name(iod->audio_profileAndLevel), iod->audio_profileAndLevel);\n\t\t\t//fprintf(stderr, \"inline profiles included %s\\n\", iod->inlineProfileFlag ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"File has root OD (%d bytes)\\n\", desc_size);\n\t\t}\n\t\tif (!gf_list_count(iod->ESDescriptors))\n\t\t\tfprintf(stderr, \"No streams included in root OD\\n\");\n\t\telse\n\t\t\tdump_m4sys = GF_TRUE;\n\n\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t}\n\tif (gf_isom_is_JPEG2000(file)) fprintf(stderr, \"File is JPEG 2000\\n\");\n\n\tcount = gf_isom_get_copyright_count(file);\n\tif (count) {\n\t\tconst char *lang, *note;\n\t\tfprintf(stderr, \"\\nCopyrights:\\n\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgf_isom_get_copyright(file, i+1, &lang, &note);\n\t\t\tfprintf(stderr, \"\\t(%s) %s\\n\", lang, note);\n\t\t}\n\t}\n\n\tcount = gf_isom_get_chapter_count(file, 0);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgf_isom_get_chapter(file, 0, i+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", i+1, format_duration(time, 1000, szDur), name);\n\t\t}\n\t}\n\n\tif (gf_isom_apple_get_tag(file, 0, &data, &data_len) == GF_OK) {\n\t\thas_itags = GF_TRUE;\n\t\tfprintf(stderr, \"\\niTunes Info:\\n\");\n\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tu32 int_val2, flags, itype;\n\t\t\tGF_ISOiTunesTag tag;\n\t\t\tu64 int_val;\n\t\t\ts32 tag_idx;\n\t\t\tGF_Err e = gf_isom_apple_enum_tag(file, i, &tag, &data, &data_len, &int_val, &int_val2, &flags);\n\t\t\tif (e) break;\n\t\t\ti++;\n\n\t\t\ttag_idx = gf_itags_find_by_itag(tag);\n\t\t\tif (tag_idx<0) {\n\t\t\t\tfprintf(stderr, \"\\t%s: %s\\n\", gf_4cc_to_str(tag), data);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\t%s: \", gf_itags_get_name(tag_idx) );\n\t\t\titype = gf_itags_get_type(tag_idx);\n\t\t\tswitch (itype) {\n\t\t\tcase GF_ITAG_BOOL: fprintf(stderr, int_val ? \"yes\" : \"no\"); break;\n\t\t\tcase GF_ITAG_INT8:\n\t\t\tcase GF_ITAG_INT16:\n\t\t\tcase GF_ITAG_INT32:\n\t\t\tcase GF_ITAG_INT64:\n\t\t\t\tfprintf(stderr, LLU, int_val);\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FRAC6:\n\t\t\tcase GF_ITAG_FRAC8:\n\t\t\t\tfprintf(stderr, LLU\" / %u\", int_val, int_val2);\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FILE:\n\t\t\t\tif (flags==14) fprintf(stderr, \"PNG File\");\n\t\t\t\telse if (flags==13) fprintf(stderr, \"JPEG File\");\n\t\t\t\telse fprintf(stderr, \"unknown (flags %d)\", flags);\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_ID3_GENRE:\n\t\t\t\tif (int_val) {\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_id3_get_genre((u32) int_val) );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//fallthrough\n\t\t\tdefault:\n\t\t\t\tif (data)\n\t\t\t\t\tfprintf(stderr, \"%s\", data);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, data_len ? \"none\" : \"unknown\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t}\n\ti=0;\n\twhile (1) {\n\t\tu32 type, version;\n\t\tchar *wmatag;\n\t\tGF_Err e = gf_isom_wma_enum_tag(file, i, &wmatag, &data, &data_len, &version, &type);\n\t\tif (e) break;\n\t\tif (!i) {\n\t\t\tfprintf(stderr, \"\\nWMA Info:\\n\");\n\t\t}\n\t\ti++;\n\t\tfprintf(stderr, \"\\t%s\", wmatag);\n\t\tif (version!=1)\n\t\t\tfprintf(stderr, \" (version %d)\", version);\n\t\tfprintf(stderr, \": \");\n\n\t\tif (type) {\n\t\t\tfprintf(stderr, \"unknown type %d\\n\", type);\n\t\t} else {\n\t\t\tu16 *src_str = (u16 *) data;\n\t\t\tu32 len = (u32) ( UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(src_str) );\n\t\t\tchar *utf8str = (char *)gf_malloc(len + 1);\n\t\t\tu32 res_len = (u32) gf_utf8_wcstombs(utf8str, len, (const unsigned short **) &src_str);\n\t\t\tutf8str[res_len] = 0;\n\t\t\tfprintf(stderr, \"%s\\n\", utf8str);\n\n\t\t\tgf_free(utf8str);\n\t\t}\n\t}\n\n\n\tprint_udta(file, 0, has_itags);\n\tfprintf(stderr, \"\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tDumpTrackInfo(file, i+1, 0, GF_TRUE, dump_m4sys);\n\t}\n}\n\n#endif /*defined(GPAC_DISABLE_ISOM) || defined(GPAC_DISABLE_ISOM_WRITE)*/\n\n\n#ifndef GPAC_DISABLE_MPEG2TS\n\n\ntypedef struct\n{\n\t/* when writing to file */\n\tFILE *pes_out;\n\tchar dump[100];\n#if 0\n\tFILE *pes_out_nhml;\n\tchar nhml[100];\n\tFILE *pes_out_info;\n\tchar info[100];\n#endif\n\tBool is_info_dumped;\n\n\tu32 prog_number;\n\t/* For logging timing information (PCR, PTS/DTS) */\n\tFILE *timestamps_info_file;\n\tchar timestamps_info_name[100];\n\n\t/* when dumping TS information */\n\tu32 dump_pid;\n\tBool has_seen_pat;\n\n} GF_M2TS_Dump;\n\n\n\nstatic void on_m2ts_dump_event(GF_M2TS_Demuxer *ts, u32 evt_type, void *par)\n{\n\tu32 i, count;\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_PES_PCK *pck;\n\tGF_M2TS_Dump *dumper = (GF_M2TS_Dump *)ts->user;\n\n\tswitch (evt_type) {\n\tcase GF_M2TS_EVT_PAT_FOUND:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PAT_UPDATE:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PAT_REPEAT:\n\t\t/* WARNING: We detect the pat on a repetition, probably to ensure that we also have seen all the PMT\n\t\t   To be checked */\n\t\tdumper->has_seen_pat = 1;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n//\t\tfprintf(stderr, \"Repeated PAT found - %d programs\\n\", gf_list_count(ts->programs) );\n\t\tbreak;\n\tcase GF_M2TS_EVT_CAT_FOUND:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_CAT_UPDATE:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_CAT_REPEAT:\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_FOUND:\n\t\tprog = (GF_M2TS_Program*)par;\n\t\tif (gf_list_count(ts->programs)>1 && prog->number!=dumper->prog_number)\n\t\t\tbreak;\n\n\t\tcount = gf_list_count(prog->streams);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Program number %d found - %d streams:\\n\", prog->number, count));\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_ES *es = gf_list_get(prog->streams, i);\n\t\t\tif (es->pid == prog->pmt_pid) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tPID %d: Program Map Table\\n\", es->pid));\n\t\t\t} else {\n\t\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\t\t\t\tgf_m2ts_set_pes_framing(pes, dumper->pes_out ? GF_M2TS_PES_FRAMING_RAW : GF_M2TS_PES_FRAMING_DEFAULT);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tPID %d: %s \", pes->pid, gf_m2ts_get_stream_name(pes->stream_type) ));\n\t\t\t\tif (pes->mpeg4_es_id) GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\" - MPEG-4 ES ID %d\", pes->mpeg4_es_id));\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\n\"));\n\t\t\t}\n\t\t}\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, prog->pmt_pid);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_UPDATE:\n\t\tprog = (GF_M2TS_Program*)par;\n\t\tif (gf_list_count(ts->programs)>1 && prog->number!=dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, prog->pmt_pid);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_REPEAT:\n\t\tprog = (GF_M2TS_Program*)par;\n\t\tif (gf_list_count(ts->programs)>1 && prog->number!=dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\n\", ts->pck_number, prog->pmt_pid);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_SDT_FOUND:\n#ifndef GPAC_DISABLE_LOG\n\t\tcount = gf_list_count(ts->SDTs) ;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Program Description found - %d desc:\\n\", count));\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_SDT *sdt = gf_list_get(ts->SDTs, i);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tServiceID %d - Provider %s - Name %s\\n\", sdt->service_id, sdt->provider, sdt->service));\n\t\t}\n#endif\n\t\tbreak;\n\tcase GF_M2TS_EVT_SDT_UPDATE:\n#ifndef GPAC_DISABLE_LOG\n\t\tcount = gf_list_count(ts->SDTs) ;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Program Description updated - %d desc\\n\", count));\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_SDT *sdt = gf_list_get(ts->SDTs, i);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"\\tServiceID %d - Provider %s - Name %s\\n\", sdt->service_id, sdt->provider, sdt->service));\n\t\t}\n#endif\n\t\tbreak;\n\tcase GF_M2TS_EVT_SDT_REPEAT:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_TIMING:\n\t\tpck = par;\n\t\tif (gf_list_count(ts->programs)>1 && pck->stream->program->number != dumper->prog_number)\n\t\t\tbreak;\n\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCK:\n\t\tpck = par;\n\t\tif (gf_list_count(ts->programs)>1 && pck->stream->program->number != dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->has_seen_pat) {\n\n\t\t\t/*We need the interpolated PCR for the pcrb, hence moved this calculus out, and saving the calculated value in index_info to put it in the pcrb*/\n\t\t\tGF_M2TS_PES *pes = pck->stream;\n\t\t\t/*FIXME : not used GF_M2TS_Program *prog = pes->program; */\n\t\t\t/* Interpolated PCR value for the TS packet containing the PES header start */\n\t\t\tu64 interpolated_pcr_value = 0;\n\t\t\tif (pes->last_pcr_value && pes->before_last_pcr_value_pck_number && pes->last_pcr_value > pes->before_last_pcr_value) {\n\t\t\t\tu32 delta_pcr_pck_num = pes->last_pcr_value_pck_number - pes->before_last_pcr_value_pck_number;\n\t\t\t\tu32 delta_pts_pcr_pck_num = pes->pes_start_packet_number - pes->last_pcr_value_pck_number;\n\t\t\t\tu64 delta_pcr_value = pes->last_pcr_value - pes->before_last_pcr_value;\n\t\t\t\tif ((pes->pes_start_packet_number > pes->last_pcr_value_pck_number)\n\t\t\t\t        && (pes->last_pcr_value > pes->before_last_pcr_value)) {\n\n\t\t\t\t\tpes->last_pcr_value = pes->before_last_pcr_value;\n\t\t\t\t}\n\t\t\t\t/* we can compute the interpolated pcr value for the packet containing the PES header */\n\t\t\t\tinterpolated_pcr_value = pes->last_pcr_value + (u64)((delta_pcr_value*delta_pts_pcr_pck_num*1.0)/delta_pcr_pck_num);\n\t\t\t}\n\n\t\t\tif (dumper->timestamps_info_file) {\n\t\t\t\tDouble diff;\n\t\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\t\", pck->stream->pes_start_packet_number, pck->stream->pid);\n\t\t\t\tif (interpolated_pcr_value) fprintf(dumper->timestamps_info_file, \"%f\", interpolated_pcr_value/(300.0 * 90000));\n\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t\");\n\t\t\t\tif (pck->DTS) fprintf(dumper->timestamps_info_file, \"%f\", (pck->DTS / 90000.0));\n\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t%f\\t%d\\t%d\", pck->PTS / 90000.0, (pck->flags & GF_M2TS_PES_PCK_RAP) ? 1 : 0, (pck->flags & GF_M2TS_PES_PCK_DISCONTINUITY) ? 1 : 0);\n\t\t\t\tif (interpolated_pcr_value) {\n\t\t\t\t\tdiff = (pck->DTS ? pck->DTS : pck->PTS) / 90000.0;\n\t\t\t\t\tdiff -= pes->last_pcr_value / (300.0 * 90000);\n\t\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t%f\\n\", diff);\n\t\t\t\t\tif (diff<0) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: detected PTS/DTS value less than current PCR of %g sec\\n\", diff));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(dumper->timestamps_info_file, \"\\t\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dumper->has_seen_pat && dumper->pes_out && (dumper->dump_pid == pck->stream->pid)) {\n\t\t\tgf_fwrite(pck->data, pck->data_len, dumper->pes_out);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCR:\n\t\tpck = par;\n\t\tif (gf_list_count(ts->programs)>1 && pck->stream->program->number != dumper->prog_number)\n\t\t\tbreak;\n\t\tif (dumper->timestamps_info_file) {\n\t\t\tfprintf(dumper->timestamps_info_file, \"%u\\t%d\\t%f\\t\\t\\t\\t%d\\n\", pck->stream->program->last_pcr_value_pck_number, pck->stream->pid, pck->PTS / (300*90000.0), (pck->flags & GF_M2TS_PES_PCK_DISCONTINUITY) ? 1 : 0);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_SL_PCK:\n#if 0\n\t{\n\t\tGF_M2TS_SL_PCK *sl_pck = par;\n\t\tif (dumper->pes_out && (dumper->dump_pid == sl_pck->stream->pid)) {\n\t\t\tGF_SLHeader header;\n\t\t\tu32 header_len;\n\t\t\tif (sl_pck->stream->mpeg4_es_id) {\n\t\t\t\tGF_ESD *esd = ((GF_M2TS_PES*)sl_pck->stream)->esd;\n\t\t\t\tif (!dumper->is_info_dumped) {\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) gf_fwrite(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, dumper->pes_out_info);\n\t\t\t\t\tdumper->is_info_dumped = 1;\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"<NHNTStream version=\\\"1.0\\\" \");\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"timeScale=\\\"%d\\\" \", esd->slConfig->timestampResolution);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"streamType=\\\"%d\\\" \", esd->decoderConfig->streamType);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"objectTypeIndication=\\\"%d\\\" \", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) fprintf(dumper->pes_out_nhml, \"specificInfoFile=\\\"%s\\\" \", dumper->info);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"baseMediaFile=\\\"%s\\\" \", dumper->dump);\n\t\t\t\t\tfprintf(dumper->pes_out_nhml, \"inRootOD=\\\"yes\\\">\\n\");\n\t\t\t\t}\n\t\t\t\tgf_sl_depacketize(esd->slConfig, &header, sl_pck->data, sl_pck->data_len, &header_len);\n\t\t\t\tgf_fwrite(sl_pck->data+header_len, sl_pck->data_len-header_len, dumper->pes_out);\n\t\t\t\tfprintf(dumper->pes_out_nhml, \"<NHNTSample DTS=\\\"\"LLD\"\\\" dataLength=\\\"%d\\\" isRAP=\\\"%s\\\"/>\\n\", header.decodingTimeStamp, sl_pck->data_len-header_len, (header.randomAccessPointFlag?\"yes\":\"no\"));\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tbreak;\n\t}\n}\n\nvoid dump_mpeg2_ts(char *mpeg2ts_file, char *out_name, Bool prog_num)\n{\n\tu8 data[188];\n\tGF_M2TS_Dump dumper;\n\n\tu32 size;\n\tu64 fsize, fdone;\n\tGF_M2TS_Demuxer *ts;\n\tFILE *src;\n\n\tif (!prog_num && !out_name) {\n\t\tfprintf(stderr, \"No program number nor output filename specified. No timestamp file will be generated.\");\n\t}\n\n\tsrc = gf_fopen(mpeg2ts_file, \"rb\");\n\tif (!src) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open %s: no such file\\n\", mpeg2ts_file));\n\t\treturn;\n\t}\n\tts = gf_m2ts_demux_new();\n\tts->on_event = on_m2ts_dump_event;\n\tts->notify_pes_timing = 1;\n\tmemset(&dumper, 0, sizeof(GF_M2TS_Dump));\n\tts->user = &dumper;\n\tdumper.prog_number = prog_num;\n\n\t/*PES dumping*/\n\tif (out_name) {\n\t\tchar *pid = strrchr(out_name, '#');\n\t\tif (pid) {\n\t\t\tdumper.dump_pid = atoi(pid+1);\n\t\t\tpid[0] = 0;\n\t\t\tsprintf(dumper.dump, \"%s_%d.raw\", out_name, dumper.dump_pid);\n\t\t\tdumper.pes_out = gf_fopen(dumper.dump, \"wb\");\n#if 0\n\t\t\tsprintf(dumper.nhml, \"%s_%d.nhml\", pes_out_name, dumper.dump_pid);\n\t\t\tdumper.pes_out_nhml = gf_fopen(dumper.nhml, \"wt\");\n\t\t\tsprintf(dumper.info, \"%s_%d.info\", pes_out_name, dumper.dump_pid);\n\t\t\tdumper.pes_out_info = gf_fopen(dumper.info, \"wb\");\n#endif\n\t\t\tpid[0] = '#';\n\t\t}\n\t}\n\n\tgf_fseek(src, 0, SEEK_END);\n\tfsize = gf_ftell(src);\n\tgf_fseek(src, 0, SEEK_SET);\n\n\t/* first loop to process all packets between two PAT, and assume all signaling was found between these 2 PATs */\n\twhile (!feof(src)) {\n\t\tsize = (u32) gf_fread(data, 188, src);\n\t\tif (size<188) break;\n\n\t\tgf_m2ts_process_data(ts, data, size);\n\t\tif (dumper.has_seen_pat) break;\n\t}\n\tdumper.has_seen_pat = GF_TRUE;\n\n\tif (!prog_num) {\n\t\tGF_M2TS_Program *p = gf_list_get(ts->programs, 0);\n\t\tif (p) prog_num = p->number;\n\t\tfprintf(stderr, \"No program number specified, defaulting to first program\\n\");\n\t}\n\n\tif (!prog_num && !out_name) {\n\t\tfprintf(stderr, \"No program number nor output filename specified. No timestamp file will be generated\\n\");\n\t}\n\n\tif (prog_num) {\n\t\tsprintf(dumper.timestamps_info_name, \"%s_prog_%d_timestamps.txt\", mpeg2ts_file, prog_num/*, mpeg2ts_file*/);\n\t\tdumper.timestamps_info_file = gf_fopen(dumper.timestamps_info_name, \"wt\");\n\t\tif (!dumper.timestamps_info_file) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open file %s\\n\", dumper.timestamps_info_name));\n\t\t\treturn;\n\t\t}\n\t\tfprintf(dumper.timestamps_info_file, \"PCK#\\tPID\\tPCR\\tDTS\\tPTS\\tRAP\\tDiscontinuity\\tDTS-PCR Diff\\n\");\n\t}\n\n\tgf_m2ts_reset_parsers(ts);\n\tgf_fseek(src, 0, SEEK_SET);\n\tfdone = 0;\n\n\twhile (!feof(src)) {\n\t\tsize = (u32) gf_fread(data, 188, src);\n\t\tif (size<188) break;\n\n\t\tgf_m2ts_process_data(ts, data, size);\n\n\t\tfdone += size;\n\t\tgf_set_progress(\"MPEG-2 TS Parsing\", fdone, fsize);\n\t}\n\n\tgf_fclose(src);\n\tgf_m2ts_demux_del(ts);\n\tif (dumper.pes_out) gf_fclose(dumper.pes_out);\n#if 0\n\tif (dumper.pes_out_nhml) {\n\t\tif (dumper.is_info_dumped) fprintf(dumper.pes_out_nhml, \"</NHNTStream>\\n\");\n\t\tgf_fclose(dumper.pes_out_nhml);\n\t\tgf_fclose(dumper.pes_out_info);\n\t}\n#endif\n\tif (dumper.timestamps_info_file) gf_fclose(dumper.timestamps_info_file);\n}\n\n#endif /*GPAC_DISABLE_MPEG2TS*/\n\n\n#include <gpac/download.h>\n#include <gpac/mpd.h>\n\nvoid get_file_callback(void *usr_cbk, GF_NETIO_Parameter *parameter)\n{\n\tif (parameter->msg_type==GF_NETIO_DATA_EXCHANGE) {\n\t\tu64 tot_size, done, max;\n\t\tu32 bps;\n\t\tgf_dm_sess_get_stats(parameter->sess, NULL, NULL, &tot_size, &done, &bps, NULL);\n\t\tif (tot_size) {\n\t\t\tmax = done;\n\t\t\tmax *= 100;\n\t\t\tmax /= tot_size;\n\t\t\tfprintf(stderr, \"download %02d %% at %05d kpbs\\r\", (u32) max, bps*8/1000);\n\t\t}\n\t}\n}\n\nstatic GF_DownloadSession *get_file(const char *url, GF_DownloadManager *dm, GF_Err *e)\n{\n\tGF_DownloadSession *sess;\n\tsess = gf_dm_sess_new(dm, url, GF_NETIO_SESSION_NOT_THREADED, get_file_callback, NULL, e);\n\tif (!sess) return NULL;\n\t*e = gf_dm_sess_process(sess);\n\tif (*e) {\n\t\tgf_dm_sess_del(sess);\n\t\treturn NULL;\n\t}\n\treturn sess;\n}\n\nstatic void revert_cache_file(char *item_path)\n{\n\tchar szPATH[GF_MAX_PATH];\n\tconst char *url;\n\tGF_Config *cached;\n\n\tif (!strstr(item_path, \"gpac_cache_\")) {\n\t\tfprintf(stderr, \"%s is not a gpac cache file\\n\", item_path);\n\t\treturn;\n\t}\n\tif (!strncmp(item_path, \"./\", 2) || !strncmp(item_path, \".\\\\\", 2))\n\t\t\titem_path += 2;\n\n \tstrcpy(szPATH, item_path);\n\tstrcat(szPATH, \".txt\");\n\n\tcached = gf_cfg_new(NULL, szPATH);\n\turl = gf_cfg_get_key(cached, \"cache\", \"url\");\n\tif (url) url = strstr(url, \"://\");\n\tif (url) {\n\t\tu32 i, len, dir_len=0, k=0;\n\t\tchar *sep;\n\t\tchar *dst_name;\n\t\tsep = strstr(item_path, \"gpac_cache_\");\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tdir_len = (u32) strlen(item_path);\n\t\t\tsep[0] = 'g';\n\t\t}\n\t\turl+=3;\n\t\tlen = (u32) strlen(url);\n\t\tdst_name = gf_malloc(len+dir_len+1);\n\t\tmemset(dst_name, 0, len+dir_len+1);\n\n\t\tstrncpy(dst_name, item_path, dir_len);\n\t\tk=dir_len;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tdst_name[k] = url[i];\n\t\t\tif (dst_name[k]==':') dst_name[k]='_';\n\t\t\telse if (dst_name[k]=='/') {\n\t\t\t\tif (!gf_dir_exists(dst_name))\n\t\t\t\t\tgf_mkdir(dst_name);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tif (gf_file_exists(item_path)) {\n\t\t\tgf_file_move(item_path, dst_name);\n\t\t}\n\n\t\tgf_free(dst_name);\n\t} else {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to reverse %s cache file\\n\", item_path));\n\t}\n\tgf_cfg_del(cached);\n\tgf_file_delete(szPATH);\n}\n\nGF_Err rip_mpd(const char *mpd_src, const char *output_dir)\n{\n\tGF_DownloadSession *sess;\n\tu32 i, connect_time, reply_time, download_time, req_hdr_size, rsp_hdr_size;\n\tGF_Err e;\n\tGF_DOMParser *mpd_parser=NULL;\n\tGF_MPD *mpd=NULL;\n\tGF_MPD_Period *period;\n\tGF_MPD_AdaptationSet *as;\n\tGF_MPD_Representation *rep;\n\tchar szName[GF_MAX_PATH];\n\tGF_DownloadManager *dm;\n\n\tif (output_dir) {\n\t\tchar *sep;\n\t\tstrcpy(szName, output_dir);\n\t\tsep = gf_file_basename(szName);\n\t\tif (sep) sep[0] = 0;\n\t\tgf_opts_set_key(\"temp\", \"cache\", szName);\n\t} else {\n\t\tgf_opts_set_key(\"temp\", \"cache\", \".\");\n\t}\n\tgf_opts_set_key(\"temp\", \"clean-cache\", \"true\");\n\tdm = gf_dm_new(NULL);\n\n/*\n\tchar *name = strrchr(mpd_src, '/');\n\tif (!name) name = strrchr(mpd_src, '\\\\');\n\tif (!name) name = \"manifest.mpd\";\n\telse name ++;\n\n\tif (strchr(name, '?') || strchr(name, '&')) name = \"manifest.mpd\";\n*/\n\n\tfprintf(stderr, \"Downloading %s\\n\", mpd_src);\n\tsess = get_file(mpd_src, dm, &e);\n\tif (!sess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error downloading MPD file %s: %s\\n\", mpd_src, gf_error_to_string(e) ));\n\t\tgoto err_exit;\n\t}\n\tstrcpy(szName, gf_dm_sess_get_cache_name(sess) );\n\tgf_dm_sess_get_header_sizes_and_times(sess, &req_hdr_size, &rsp_hdr_size, &connect_time, &reply_time, &download_time);\n\tgf_dm_sess_del(sess);\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error fetching MPD file %s: %s\\n\", mpd_src, gf_error_to_string(e)));\n\t\tgoto err_exit;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Fetched file %s\\n\", mpd_src));\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_APP, (\"GET Header size %d - Reply header size %d\\n\", req_hdr_size, rsp_hdr_size));\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_APP, (\"GET time: Connect Time %d - Reply Time %d - Download Time %d\\n\", connect_time, reply_time, download_time));\n\n\tmpd_parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(mpd_parser, szName, NULL, NULL);\n\n\tif (e != GF_OK) {\n\t\tgf_xml_dom_del(mpd_parser);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error parsing MPD %s : %s\\n\", mpd_src, gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\tmpd = gf_mpd_new();\n\te = gf_mpd_init_from_dom(gf_xml_dom_get_root(mpd_parser), mpd, mpd_src);\n\tgf_xml_dom_del(mpd_parser);\n\tmpd_parser=NULL;\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error initializing MPD %s : %s\\n\", mpd_src, gf_error_to_string(e)));\n\t\tgoto err_exit;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_APP, (\"MPD %s initialized: %s\\n\", szName, gf_error_to_string(e)));\n\t}\n\n\trevert_cache_file(szName);\n\tif (mpd->type==GF_MPD_TYPE_DYNAMIC) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"MPD rip is not supported on live sources\\n\"));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto err_exit;\n\t}\n\n\ti=0;\n\twhile ((period = (GF_MPD_Period *) gf_list_enum(mpd->periods, &i))) {\n\t\tchar *initTemplate = NULL;\n\t\tBool segment_base = GF_FALSE;\n\t\tu32 j=0;\n\n\t\tif (period->segment_base) segment_base=GF_TRUE;\n\n\t\tif (period->segment_template && period->segment_template->initialization) {\n\t\t\tinitTemplate = period->segment_template->initialization;\n\t\t}\n\n\t\twhile ((as = gf_list_enum(period->adaptation_sets, &j))) {\n\t\t\tu32 k=0;\n\t\t\tif (!initTemplate && as->segment_template && as->segment_template->initialization) {\n\t\t\t\tinitTemplate = as->segment_template->initialization;\n\t\t\t}\n\t\t\tif (as->segment_base) segment_base=GF_TRUE;\n\n\t\t\twhile ((rep = gf_list_enum(as->representations, &k))) {\n\t\t\t\tu64 out_range_start, out_range_end, segment_duration;\n\t\t\t\tBool is_in_base_url;\n\t\t\t\tchar *seg_url;\n\t\t\t\tu32 seg_idx=0;\n\t\t\t\tif (rep->segment_template && rep->segment_template->initialization) {\n\t\t\t\t\tinitTemplate = rep->segment_template->initialization;\n\t\t\t\t} else if (k>1) {\n\t\t\t\t\tinitTemplate = NULL;\n\t\t\t\t}\n\t\t\t\tif (rep->segment_base) segment_base=GF_TRUE;\n\n\t\t\t\te = gf_mpd_resolve_url(mpd, rep, as, period, mpd_src, 0, GF_MPD_RESOLVE_URL_INIT, 0, 0, &seg_url, &out_range_start, &out_range_end, &segment_duration, &is_in_base_url, NULL, NULL, NULL);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error resolving init segment name : %s\\n\", gf_error_to_string(e)));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//not a byte range, replace URL\n\t\t\t\tif (segment_base) {\n\n\t\t\t\t} else if (out_range_start || out_range_end || !seg_url) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"byte range rip not yet implemented\\n\"));\n\t\t\t\t\tif (seg_url) gf_free(seg_url);\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\n\t\t\t\tfprintf(stderr, \"Downloading %s\\n\", seg_url);\n\t\t\t\tsess = get_file(seg_url, dm, &e);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error downloading init segment %s from MPD %s : %s\\n\", seg_url, mpd_src, gf_error_to_string(e)));\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\trevert_cache_file((char *) gf_dm_sess_get_cache_name(sess) );\n\t\t\t\tgf_free(seg_url);\n\t\t\t\tgf_dm_sess_del(sess);\n\n\t\t\t\tif (segment_base) continue;\n\n\t\t\t\twhile (1) {\n\t\t\t\t\te = gf_mpd_resolve_url(mpd, rep, as, period, mpd_src, 0, GF_MPD_RESOLVE_URL_MEDIA, seg_idx, 0, &seg_url, &out_range_start, &out_range_end, &segment_duration, NULL, NULL, NULL, NULL);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tif (e<0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error resolving segment name : %s\\n\", gf_error_to_string(e)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tseg_idx++;\n\n\t\t\t\t\tif (out_range_start || out_range_end || !seg_url) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"byte range rip not yet implemented\\n\"));\n\t\t\t\t\t\tif (seg_url) gf_free(seg_url);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"Downloading %s\\n\", seg_url);\n\t\t\t\t\tsess = get_file(seg_url, dm, &e);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_free(seg_url);\n\t\t\t\t\t\tif (e != GF_URL_ERROR) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Error downloading segment %s: %s\\n\", seg_url, gf_error_to_string(e)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//todo, properly detect end of dash representation\n\t\t\t\t\t\t\te = GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trevert_cache_file((char *) gf_dm_sess_get_cache_name(sess) );\n\t\t\t\t\tgf_free(seg_url);\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nerr_exit:\n\tif (mpd) gf_mpd_del(mpd);\n\tgf_dm_del(dm);\n\treturn e;\n}\n"], "filenames": ["applications/mp4box/filedump.c"], "buggy_code_start_loc": [1898], "buggy_code_end_loc": [1904], "fixing_code_start_loc": [1898], "fixing_code_end_loc": [1910], "type": "CWE-787", "message": "Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.", "other": {"cve": {"id": "CVE-2021-32136", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-13T13:15:07.360", "lastModified": "2021-09-22T19:05:58.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file."}, {"lang": "es", "value": "El desbordamiento de b\u00fafer en la funci\u00f3n print_udta de MP4Box en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio o ejecutar c\u00f3digo arbitrario por medio de un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/eb71812fcc10e9c5348a5d1c61bd25b6fa06eaed", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1765", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/eb71812fcc10e9c5348a5d1c61bd25b6fa06eaed"}}