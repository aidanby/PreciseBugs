{"buggy_code": ["package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"github.com/mrunalp/fileutils\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/fs2\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/userns\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype mountConfig struct {\n\troot            string\n\tlabel           string\n\tcgroup2Path     string\n\trootlessCgroups bool\n\tcgroupns        bool\n\tfd              *int\n}\n\n// needsSetupDev returns true if /dev needs to be set up.\nfunc needsSetupDev(config *configs.Config) bool {\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"bind\" && utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// prepareRootfs sets up the devices, mount points, and filesystems for use\n// inside a new mount namespace. It doesn't set anything as ro. You must call\n// finalizeRootfs after this function to finish setting up the rootfs.\nfunc prepareRootfs(pipe io.ReadWriter, iConfig *initConfig, mountFds []int) (err error) {\n\tconfig := iConfig.Config\n\tif err := prepareRoot(config); err != nil {\n\t\treturn fmt.Errorf(\"error preparing rootfs: %w\", err)\n\t}\n\n\tif mountFds != nil && len(mountFds) != len(config.Mounts) {\n\t\treturn fmt.Errorf(\"malformed mountFds slice. Expected size: %v, got: %v. Slice: %v\", len(config.Mounts), len(mountFds), mountFds)\n\t}\n\n\tmountConfig := &mountConfig{\n\t\troot:            config.Rootfs,\n\t\tlabel:           config.MountLabel,\n\t\tcgroup2Path:     iConfig.Cgroup2Path,\n\t\trootlessCgroups: iConfig.RootlessCgroups,\n\t\tcgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),\n\t}\n\tsetupDev := needsSetupDev(config)\n\tfor i, m := range config.Mounts {\n\t\t// Just before the loop we checked that if not empty, len(mountFds) == len(config.Mounts).\n\t\t// Therefore, we can access mountFds[i] without any concerns.\n\t\tif mountFds != nil && mountFds[i] != -1 {\n\t\t\tmountConfig.fd = &mountFds[i]\n\t\t} else {\n\t\t\tmountConfig.fd = nil\n\t\t}\n\n\t\tif err := mountToRootfs(m, mountConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)\n\t\t}\n\t}\n\n\tif setupDev {\n\t\tif err := createDevices(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error creating device nodes: %w\", err)\n\t\t}\n\t\tif err := setupPtmx(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up ptmx: %w\", err)\n\t\t}\n\t\tif err := setupDevSymlinks(config.Rootfs); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up /dev symlinks: %w\", err)\n\t\t}\n\t}\n\n\t// Signal the parent to run the pre-start hooks.\n\t// The hooks are run after the mounts are setup, but before we switch to the new\n\t// root, so that the old root is still available in the hooks for any mount\n\t// manipulations.\n\t// Note that iConfig.Cwd is not guaranteed to exist here.\n\tif err := syncParentHooks(pipe); err != nil {\n\t\treturn err\n\t}\n\n\t// The reason these operations are done here rather than in finalizeRootfs\n\t// is because the console-handling code gets quite sticky if we have to set\n\t// up the console before doing the pivot_root(2). This is because the\n\t// Console API has to also work with the ExecIn case, which means that the\n\t// API must be able to deal with being inside as well as outside the\n\t// container. It's just cleaner to do this here (at the expense of the\n\t// operation not being perfectly split).\n\n\tif err := unix.Chdir(config.Rootfs); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: config.Rootfs, Err: err}\n\t}\n\n\ts := iConfig.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreating\n\tif err := iConfig.Config.Hooks[configs.CreateContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif config.NoPivotRoot {\n\t\terr = msMoveRoot(config.Rootfs)\n\t} else if config.Namespaces.Contains(configs.NEWNS) {\n\t\terr = pivotRoot(config.Rootfs)\n\t} else {\n\t\terr = chroot()\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error jailing process inside rootfs: %w\", err)\n\t}\n\n\tif setupDev {\n\t\tif err := reOpenDevNull(); err != nil {\n\t\t\treturn fmt.Errorf(\"error reopening /dev/null inside container: %w\", err)\n\t\t}\n\t}\n\n\tif cwd := iConfig.Cwd; cwd != \"\" {\n\t\t// Note that spec.Process.Cwd can contain unclean value like  \"../../../../foo/bar...\".\n\t\t// However, we are safe to call MkDirAll directly because we are in the jail here.\n\t\tif err := os.MkdirAll(cwd, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// finalizeRootfs sets anything to ro if necessary. You must call\n// prepareRootfs first.\nfunc finalizeRootfs(config *configs.Config) (err error) {\n\t// All tmpfs mounts and /dev were previously mounted as rw\n\t// by mountPropagate. Remount them read-only as requested.\n\tfor _, m := range config.Mounts {\n\t\tif m.Flags&unix.MS_RDONLY != unix.MS_RDONLY {\n\t\t\tcontinue\n\t\t}\n\t\tif m.Device == \"tmpfs\" || utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\tif err := remountReadonly(m); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// set rootfs ( / ) as readonly\n\tif config.Readonlyfs {\n\t\tif err := setReadonly(); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rootfs as readonly: %w\", err)\n\t\t}\n\t}\n\n\tif config.Umask != nil {\n\t\tunix.Umask(int(*config.Umask))\n\t} else {\n\t\tunix.Umask(0o022)\n\t}\n\treturn nil\n}\n\n// /tmp has to be mounted as private to allow MS_MOVE to work in all situations\nfunc prepareTmp(topTmpDir string) (string, error) {\n\ttmpdir, err := os.MkdirTemp(topTmpDir, \"runctop\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(tmpdir, tmpdir, \"\", \"bind\", unix.MS_BIND, \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(\"\", tmpdir, \"\", \"\", uintptr(unix.MS_PRIVATE), \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tmpdir, nil\n}\n\nfunc cleanupTmp(tmpdir string) {\n\t_ = unix.Unmount(tmpdir, 0)\n\t_ = os.RemoveAll(tmpdir)\n}\n\nfunc prepareBindMount(m *configs.Mount, rootfs string, mountFd *int) error {\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\tstat, err := os.Stat(source)\n\tif err != nil {\n\t\t// error out if the source of a bind mount does not exist as we will be\n\t\t// unable to bind anything to it.\n\t\treturn err\n\t}\n\t// ensure that the destination of the bind mount is resolved of symlinks at mount time because\n\t// any previous mounts can invalidate the next mount's destination.\n\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n\t// evil stuff to try to escape the container's rootfs.\n\tvar dest string\n\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n\t\treturn err\n\t}\n\tif err := checkProcMount(rootfs, dest, source); err != nil {\n\t\treturn err\n\t}\n\tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n\tbinds, err := getCgroupMounts(m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar merged []string\n\tfor _, b := range binds {\n\t\tss := filepath.Base(b.Destination)\n\t\tif strings.Contains(ss, \",\") {\n\t\t\tmerged = append(merged, ss)\n\t\t}\n\t}\n\ttmpfs := &configs.Mount{\n\t\tSource:           \"tmpfs\",\n\t\tDevice:           \"tmpfs\",\n\t\tDestination:      m.Destination,\n\t\tFlags:            defaultMountFlags,\n\t\tData:             \"mode=755\",\n\t\tPropagationFlags: m.PropagationFlags,\n\t}\n\n\tif err := mountToRootfs(tmpfs, c); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, b := range binds {\n\t\tif c.cgroupns {\n\t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n\t\t\tif err := os.MkdirAll(subsystemPath, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := utils.WithProcfd(c.root, b.Destination, func(procfd string) error {\n\t\t\t\tflags := defaultMountFlags\n\t\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\t\t\tflags = flags | unix.MS_RDONLY\n\t\t\t\t}\n\t\t\t\tvar (\n\t\t\t\t\tsource = \"cgroup\"\n\t\t\t\t\tdata   = filepath.Base(subsystemPath)\n\t\t\t\t)\n\t\t\t\tif data == \"systemd\" {\n\t\t\t\t\tdata = cgroups.CgroupNamePrefix + data\n\t\t\t\t\tsource = \"systemd\"\n\t\t\t\t}\n\t\t\t\treturn mount(source, b.Destination, procfd, \"cgroup\", uintptr(flags), data)\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := mountToRootfs(b, c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor _, mc := range merged {\n\t\tfor _, ss := range strings.Split(mc, \",\") {\n\t\t\t// symlink(2) is very dumb, it will just shove the path into\n\t\t\t// the link and doesn't do any checks or relative path\n\t\t\t// conversion. Also, don't error out if the cgroup already exists.\n\t\t\tif err := os.Symlink(mc, filepath.Join(c.root, m.Destination, ss)); err != nil && !os.IsExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n\tdest, err := securejoin.SecureJoin(c.root, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\treturn err\n\t}\n\treturn utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n\t\tif err := mount(m.Source, m.Destination, procfd, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n\t\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n\t\t\tif errors.Is(err, unix.EPERM) || errors.Is(err, unix.EBUSY) {\n\t\t\t\tsrc := fs2.UnifiedMountpoint\n\t\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n\t\t\t\t\t// Emulate cgroupns by bind-mounting\n\t\t\t\t\t// the container cgroup path rather than\n\t\t\t\t\t// the whole /sys/fs/cgroup.\n\t\t\t\t\tsrc = c.cgroup2Path\n\t\t\t\t}\n\t\t\t\terr = mount(src, m.Destination, procfd, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n\t\t\t\tif c.rootlessCgroups && errors.Is(err, unix.ENOENT) {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n\t// Set up a scratch dir for the tmpfs on the host.\n\ttmpdir, err := prepareTmp(\"/tmp\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to setup tmpdir: %w\", err)\n\t}\n\tdefer cleanupTmp(tmpdir)\n\ttmpDir, err := os.MkdirTemp(tmpdir, \"runctmpdir\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to create tmpdir: %w\", err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\t// Configure the *host* tmpdir as if it's the container mount. We change\n\t// m.Destination since we are going to mount *on the host*.\n\toldDest := m.Destination\n\tm.Destination = tmpDir\n\terr = mountPropagate(m, \"/\", mountLabel, nil)\n\tm.Destination = oldDest\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif Err != nil {\n\t\t\tif err := unmount(tmpDir, unix.MNT_DETACH); err != nil {\n\t\t\t\tlogrus.Warnf(\"tmpcopyup: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) (Err error) {\n\t\t// Copy the container data to the host tmpdir. We append \"/\" to force\n\t\t// CopyDirectory to resolve the symlink rather than trying to copy the\n\t\t// symlink itself.\n\t\tif err := fileutils.CopyDirectory(procfd+\"/\", tmpDir); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to copy %s to %s (%s): %w\", m.Destination, procfd, tmpDir, err)\n\t\t}\n\t\t// Now move the mount into the container.\n\t\tif err := mount(tmpDir, m.Destination, procfd, \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to move mount: %w\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc mountToRootfs(m *configs.Mount, c *mountConfig) error {\n\trootfs := c.root\n\n\t// procfs and sysfs are special because we need to ensure they are actually\n\t// mounted on a specific path in a container without any funny business.\n\tswitch m.Device {\n\tcase \"proc\", \"sysfs\":\n\t\t// If the destination already exists and is not a directory, we bail\n\t\t// out. This is to avoid mounting through a symlink or similar -- which\n\t\t// has been a \"fun\" attack scenario in the past.\n\t\t// TODO: This won't be necessary once we switch to libpathrs and we can\n\t\t//       stop all of these symlink-exchange attacks.\n\t\tdest := filepath.Clean(m.Destination)\n\t\tif !strings.HasPrefix(dest, rootfs) {\n\t\t\t// Do not use securejoin as it resolves symlinks.\n\t\t\tdest = filepath.Join(rootfs, dest)\n\t\t}\n\t\tif fi, err := os.Lstat(dest); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if !fi.IsDir() {\n\t\t\treturn fmt.Errorf(\"filesystem %q must be mounted on ordinary directory\", m.Device)\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Selinux kernels do not support labeling of /proc or /sys.\n\t\treturn mountPropagate(m, rootfs, \"\", nil)\n\t}\n\n\tmountLabel := c.label\n\tmountFd := c.fd\n\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch m.Device {\n\tcase \"mqueue\":\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, \"\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn label.SetFileLabel(dest, mountLabel)\n\tcase \"tmpfs\":\n\t\tstat, err := os.Stat(dest)\n\t\tif err != nil {\n\t\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {\n\t\t\terr = doTmpfsCopyUp(m, rootfs, mountLabel)\n\t\t} else {\n\t\t\terr = mountPropagate(m, rootfs, mountLabel, nil)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif stat != nil {\n\t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\tcase \"bind\":\n\t\tif err := prepareBindMount(m, rootfs, mountFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, mountLabel, mountFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// bind mount won't change mount options, we need remount to make mount options effective.\n\t\t// first check that we have non-default options required before attempting a remount\n\t\tif m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {\n\t\t\t// only remount if unique mount options are set\n\t\t\tif err := remount(m, rootfs, mountFd); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Relabel != \"\" {\n\t\t\tif err := label.Validate(m.Relabel); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tshared := label.IsShared(m.Relabel)\n\t\t\tif err := label.Relabel(m.Source, mountLabel, shared); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn setRecAttr(m, rootfs)\n\tcase \"cgroup\":\n\t\tif cgroups.IsCgroup2UnifiedMode() {\n\t\t\treturn mountCgroupV2(m, c)\n\t\t}\n\t\treturn mountCgroupV1(m, c)\n\tdefault:\n\t\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn mountPropagate(m, rootfs, mountLabel, mountFd)\n\t}\n}\n\nfunc getCgroupMounts(m *configs.Mount) ([]*configs.Mount, error) {\n\tmounts, err := cgroups.GetCgroupMounts(false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcgroupPaths, err := cgroups.ParseCgroupFile(\"/proc/self/cgroup\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar binds []*configs.Mount\n\n\tfor _, mm := range mounts {\n\t\tdir, err := mm.GetOwnCgroup(cgroupPaths)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trelDir, err := filepath.Rel(mm.Root, dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbinds = append(binds, &configs.Mount{\n\t\t\tDevice:           \"bind\",\n\t\t\tSource:           filepath.Join(mm.Mountpoint, relDir),\n\t\t\tDestination:      filepath.Join(m.Destination, filepath.Base(mm.Mountpoint)),\n\t\t\tFlags:            unix.MS_BIND | unix.MS_REC | m.Flags,\n\t\t\tPropagationFlags: m.PropagationFlags,\n\t\t})\n\t}\n\n\treturn binds, nil\n}\n\n// checkProcMount checks to ensure that the mount destination is not over the top of /proc.\n// dest is required to be an abs path and have any symlinks resolved before calling this function.\n//\n// if source is nil, don't stat the filesystem.  This is used for restore of a checkpoint.\nfunc checkProcMount(rootfs, dest, source string) error {\n\tconst procPath = \"/proc\"\n\tpath, err := filepath.Rel(filepath.Join(rootfs, procPath), dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// pass if the mount path is located outside of /proc\n\tif strings.HasPrefix(path, \"..\") {\n\t\treturn nil\n\t}\n\tif path == \".\" {\n\t\t// an empty source is pasted on restore\n\t\tif source == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t// only allow a mount on-top of proc if it's source is \"proc\"\n\t\tisproc, err := isProc(source)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// pass if the mount is happening on top of /proc and the source of\n\t\t// the mount is a proc filesystem\n\t\tif isproc {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"%q cannot be mounted because it is not of type proc\", dest)\n\t}\n\n\t// Here dest is definitely under /proc. Do not allow those,\n\t// except for a few specific entries emulated by lxcfs.\n\tvalidProcMounts := []string{\n\t\t\"/proc/cpuinfo\",\n\t\t\"/proc/diskstats\",\n\t\t\"/proc/meminfo\",\n\t\t\"/proc/stat\",\n\t\t\"/proc/swaps\",\n\t\t\"/proc/uptime\",\n\t\t\"/proc/loadavg\",\n\t\t\"/proc/slabinfo\",\n\t\t\"/proc/net/dev\",\n\t\t\"/proc/sys/kernel/ns_last_pid\",\n\t}\n\tfor _, valid := range validProcMounts {\n\t\tpath, err := filepath.Rel(filepath.Join(rootfs, valid), dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path == \".\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%q cannot be mounted because it is inside /proc\", dest)\n}\n\nfunc isProc(path string) (bool, error) {\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn false, &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\treturn s.Type == unix.PROC_SUPER_MAGIC, nil\n}\n\nfunc setupDevSymlinks(rootfs string) error {\n\tlinks := [][2]string{\n\t\t{\"/proc/self/fd\", \"/dev/fd\"},\n\t\t{\"/proc/self/fd/0\", \"/dev/stdin\"},\n\t\t{\"/proc/self/fd/1\", \"/dev/stdout\"},\n\t\t{\"/proc/self/fd/2\", \"/dev/stderr\"},\n\t}\n\t// kcore support can be toggled with CONFIG_PROC_KCORE; only create a symlink\n\t// in /dev if it exists in /proc.\n\tif _, err := os.Stat(\"/proc/kcore\"); err == nil {\n\t\tlinks = append(links, [2]string{\"/proc/kcore\", \"/dev/core\"})\n\t}\n\tfor _, link := range links {\n\t\tvar (\n\t\t\tsrc = link[0]\n\t\t\tdst = filepath.Join(rootfs, link[1])\n\t\t)\n\t\tif err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// If stdin, stdout, and/or stderr are pointing to `/dev/null` in the parent's rootfs\n// this method will make them point to `/dev/null` in this container's rootfs.  This\n// needs to be called after we chroot/pivot into the container's rootfs so that any\n// symlinks are resolved locally.\nfunc reOpenDevNull() error {\n\tvar stat, devNullStat unix.Stat_t\n\tfile, err := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close() //nolint: errcheck\n\tif err := unix.Fstat(int(file.Fd()), &devNullStat); err != nil {\n\t\treturn &os.PathError{Op: \"fstat\", Path: file.Name(), Err: err}\n\t}\n\tfor fd := 0; fd < 3; fd++ {\n\t\tif err := unix.Fstat(fd, &stat); err != nil {\n\t\t\treturn &os.PathError{Op: \"fstat\", Path: \"fd \" + strconv.Itoa(fd), Err: err}\n\t\t}\n\t\tif stat.Rdev == devNullStat.Rdev {\n\t\t\t// Close and re-open the fd.\n\t\t\tif err := unix.Dup3(int(file.Fd()), fd, 0); err != nil {\n\t\t\t\treturn &os.PathError{\n\t\t\t\t\tOp:   \"dup3\",\n\t\t\t\t\tPath: \"fd \" + strconv.Itoa(int(file.Fd())),\n\t\t\t\t\tErr:  err,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Create the device nodes in the container.\nfunc createDevices(config *configs.Config) error {\n\tuseBindMount := userns.RunningInUserNS() || config.Namespaces.Contains(configs.NEWUSER)\n\toldMask := unix.Umask(0o000)\n\tfor _, node := range config.Devices {\n\n\t\t// The /dev/ptmx device is setup by setupPtmx()\n\t\tif utils.CleanPath(node.Path) == \"/dev/ptmx\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// containers running in a user namespace are not allowed to mknod\n\t\t// devices so we can just bind mount it from the host.\n\t\tif err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {\n\t\t\tunix.Umask(oldMask)\n\t\t\treturn err\n\t\t}\n\t}\n\tunix.Umask(oldMask)\n\treturn nil\n}\n\nfunc bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {\n\tf, err := os.Create(dest)\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\treturn utils.WithProcfd(rootfs, dest, func(procfd string) error {\n\t\treturn mount(node.Path, dest, procfd, \"bind\", unix.MS_BIND, \"\")\n\t})\n}\n\n// Creates the device node in the rootfs of the container.\nfunc createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n\tif node.Path == \"\" {\n\t\t// The node only exists for cgroup reasons, ignore it here.\n\t\treturn nil\n\t}\n\tdest, err := securejoin.SecureJoin(rootfs, node.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n\t\treturn err\n\t}\n\tif bind {\n\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t}\n\tif err := mknodDevice(dest, node); err != nil {\n\t\tif errors.Is(err, os.ErrExist) {\n\t\t\treturn nil\n\t\t} else if errors.Is(err, os.ErrPermission) {\n\t\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc mknodDevice(dest string, node *devices.Device) error {\n\tfileMode := node.FileMode\n\tswitch node.Type {\n\tcase devices.BlockDevice:\n\t\tfileMode |= unix.S_IFBLK\n\tcase devices.CharDevice:\n\t\tfileMode |= unix.S_IFCHR\n\tcase devices.FifoDevice:\n\t\tfileMode |= unix.S_IFIFO\n\tdefault:\n\t\treturn fmt.Errorf(\"%c is not a valid device type for device %s\", node.Type, node.Path)\n\t}\n\tdev, err := node.Mkdev()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Mknod(dest, uint32(fileMode), int(dev)); err != nil {\n\t\treturn &os.PathError{Op: \"mknod\", Path: dest, Err: err}\n\t}\n\treturn os.Chown(dest, int(node.Uid), int(node.Gid))\n}\n\n// Get the parent mount point of directory passed in as argument. Also return\n// optional fields.\nfunc getParentMount(rootfs string) (string, string, error) {\n\tmi, err := mountinfo.GetMounts(mountinfo.ParentsFilter(rootfs))\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tif len(mi) < 1 {\n\t\treturn \"\", \"\", fmt.Errorf(\"could not find parent mount of %s\", rootfs)\n\t}\n\n\t// find the longest mount point\n\tvar idx, maxlen int\n\tfor i := range mi {\n\t\tif len(mi[i].Mountpoint) > maxlen {\n\t\t\tmaxlen = len(mi[i].Mountpoint)\n\t\t\tidx = i\n\t\t}\n\t}\n\treturn mi[idx].Mountpoint, mi[idx].Optional, nil\n}\n\n// Make parent mount private if it was shared\nfunc rootfsParentMountPrivate(rootfs string) error {\n\tsharedMount := false\n\n\tparentMount, optionalOpts, err := getParentMount(rootfs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toptsSplit := strings.Split(optionalOpts, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\tsharedMount = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Make parent mount PRIVATE if it was shared. It is needed for two\n\t// reasons. First of all pivot_root() will fail if parent mount is\n\t// shared. Secondly when we bind mount rootfs it will propagate to\n\t// parent namespace and we don't want that to happen.\n\tif sharedMount {\n\t\treturn mount(\"\", parentMount, \"\", \"\", unix.MS_PRIVATE, \"\")\n\t}\n\n\treturn nil\n}\n\nfunc prepareRoot(config *configs.Config) error {\n\tflag := unix.MS_SLAVE | unix.MS_REC\n\tif config.RootPropagation != 0 {\n\t\tflag = config.RootPropagation\n\t}\n\tif err := mount(\"\", \"/\", \"\", \"\", uintptr(flag), \"\"); err != nil {\n\t\treturn err\n\t}\n\n\t// Make parent mount private to make sure following bind mount does\n\t// not propagate in other namespaces. Also it will help with kernel\n\t// check pass in pivot_root. (IS_SHARED(new_mnt->mnt_parent))\n\tif err := rootfsParentMountPrivate(config.Rootfs); err != nil {\n\t\treturn err\n\t}\n\n\treturn mount(config.Rootfs, config.Rootfs, \"\", \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n}\n\nfunc setReadonly() error {\n\tflags := uintptr(unix.MS_BIND | unix.MS_REMOUNT | unix.MS_RDONLY)\n\n\terr := mount(\"\", \"/\", \"\", \"\", flags, \"\")\n\tif err == nil {\n\t\treturn nil\n\t}\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(\"/\", &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: \"/\", Err: err}\n\t}\n\tflags |= uintptr(s.Flags)\n\treturn mount(\"\", \"/\", \"\", \"\", flags, \"\")\n}\n\nfunc setupPtmx(config *configs.Config) error {\n\tptmx := filepath.Join(config.Rootfs, \"dev/ptmx\")\n\tif err := os.Remove(ptmx); err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\tif err := os.Symlink(\"pts/ptmx\", ptmx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// pivotRoot will call pivot_root such that rootfs becomes the new root\n// filesystem, and everything else is cleaned up.\nfunc pivotRoot(rootfs string) error {\n\t// While the documentation may claim otherwise, pivot_root(\".\", \".\") is\n\t// actually valid. What this results in is / being the new root but\n\t// /proc/self/cwd being the old root. Since we can play around with the cwd\n\t// with pivot_root this allows us to pivot without creating directories in\n\t// the rootfs. Shout-outs to the LXC developers for giving us this idea.\n\n\toldroot, err := unix.Open(\"/\", unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: \"/\", Err: err}\n\t}\n\tdefer unix.Close(oldroot) //nolint: errcheck\n\n\tnewroot, err := unix.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: rootfs, Err: err}\n\t}\n\tdefer unix.Close(newroot) //nolint: errcheck\n\n\t// Change to the new root so that the pivot_root actually acts on it.\n\tif err := unix.Fchdir(newroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(newroot), Err: err}\n\t}\n\n\tif err := unix.PivotRoot(\".\", \".\"); err != nil {\n\t\treturn &os.PathError{Op: \"pivot_root\", Path: \".\", Err: err}\n\t}\n\n\t// Currently our \".\" is oldroot (according to the current kernel code).\n\t// However, purely for safety, we will fchdir(oldroot) since there isn't\n\t// really any guarantee from the kernel what /proc/self/cwd will be after a\n\t// pivot_root(2).\n\n\tif err := unix.Fchdir(oldroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(oldroot), Err: err}\n\t}\n\n\t// Make oldroot rslave to make sure our unmounts don't propagate to the\n\t// host (and thus bork the machine). We don't use rprivate because this is\n\t// known to cause issues due to races where we still have a reference to a\n\t// mount while a process in the host namespace are trying to operate on\n\t// something they think has no mounts (devicemapper in particular).\n\tif err := mount(\"\", \".\", \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\treturn err\n\t}\n\t// Perform the unmount. MNT_DETACH allows us to unmount /proc/self/cwd.\n\tif err := unmount(\".\", unix.MNT_DETACH); err != nil {\n\t\treturn err\n\t}\n\n\t// Switch back to our shiny new root.\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\nfunc msMoveRoot(rootfs string) error {\n\t// Before we move the root and chroot we have to mask all \"full\" sysfs and\n\t// procfs mounts which exist on the host. This is because while the kernel\n\t// has protections against mounting procfs if it has masks, when using\n\t// chroot(2) the *host* procfs mount is still reachable in the mount\n\t// namespace and the kernel permits procfs mounts inside --no-pivot\n\t// containers.\n\t//\n\t// Users shouldn't be using --no-pivot except in exceptional circumstances,\n\t// but to avoid such a trivial security flaw we apply a best-effort\n\t// protection here. The kernel only allows a mount of a pseudo-filesystem\n\t// like procfs or sysfs if there is a *full* mount (the root of the\n\t// filesystem is mounted) without any other locked mount points covering a\n\t// subtree of the mount.\n\t//\n\t// So we try to unmount (or mount tmpfs on top of) any mountpoint which is\n\t// a full mount of either sysfs or procfs (since those are the most\n\t// concerning filesystems to us).\n\tmountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {\n\t\t// Collect every sysfs and procfs filesystem, except for those which\n\t\t// are non-full mounts or are inside the rootfs of the container.\n\t\tif info.Root != \"/\" ||\n\t\t\t(info.FSType != \"proc\" && info.FSType != \"sysfs\") ||\n\t\t\tstrings.HasPrefix(info.Mountpoint, rootfs) {\n\t\t\tskip = true\n\t\t}\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, info := range mountinfos {\n\t\tp := info.Mountpoint\n\t\t// Be sure umount events are not propagated to the host.\n\t\tif err := mount(\"\", p, \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.ENOENT) {\n\t\t\t\t// If the mountpoint doesn't exist that means that we've\n\t\t\t\t// already blasted away some parent directory of the mountpoint\n\t\t\t\t// and so we don't care about this error.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif err := unmount(p, unix.MNT_DETACH); err != nil {\n\t\t\tif !errors.Is(err, unix.EINVAL) && !errors.Is(err, unix.EPERM) {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\t// If we have not privileges for umounting (e.g. rootless), then\n\t\t\t\t// cover the path.\n\t\t\t\tif err := mount(\"tmpfs\", p, \"\", \"tmpfs\", 0, \"\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move the rootfs on top of \"/\" in our mount namespace.\n\tif err := mount(rootfs, \"/\", \"\", \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn chroot()\n}\n\nfunc chroot() error {\n\tif err := unix.Chroot(\".\"); err != nil {\n\t\treturn &os.PathError{Op: \"chroot\", Path: \".\", Err: err}\n\t}\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\n// createIfNotExists creates a file or a directory only if it does not already exist.\nfunc createIfNotExists(path string, isDir bool) error {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif isDir {\n\t\t\t\treturn os.MkdirAll(path, 0o755)\n\t\t\t}\n\t\t\tif err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf, err := os.OpenFile(path, os.O_CREATE, 0o755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_ = f.Close()\n\t\t}\n\t}\n\treturn nil\n}\n\n// readonlyPath will make a path read only.\nfunc readonlyPath(path string) error {\n\tif err := mount(path, path, \"\", \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tflags := uintptr(s.Flags) & (unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC)\n\n\tif err := mount(path, path, \"\", \"\", flags|unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, \"\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// remountReadonly will remount an existing mount point and ensure that it is read-only.\nfunc remountReadonly(m *configs.Mount) error {\n\tvar (\n\t\tdest  = m.Destination\n\t\tflags = m.Flags\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\t// There is a special case in the kernel for\n\t\t// MS_REMOUNT | MS_BIND, which allows us to change only the\n\t\t// flags even as an unprivileged user (i.e. user namespace)\n\t\t// assuming we don't drop any security related flags (nodev,\n\t\t// nosuid, etc.). So, let's use that case so that we can do\n\t\t// this re-mount without failing in a userns.\n\t\tflags |= unix.MS_REMOUNT | unix.MS_BIND | unix.MS_RDONLY\n\t\tif err := mount(\"\", dest, \"\", \"\", uintptr(flags), \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.EBUSY) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unable to mount %s as readonly max retries reached\", dest)\n}\n\n// maskPath masks the top of the specified path inside a container to avoid\n// security issues from processes reading information from non-namespace aware\n// mounts ( proc/kcore ).\n// For files, maskPath bind mounts /dev/null over the top of the specified path.\n// For directories, maskPath mounts read-only tmpfs over the top of the specified path.\nfunc maskPath(path string, mountLabel string) error {\n\tif err := mount(\"/dev/null\", path, \"\", \"\", unix.MS_BIND, \"\"); err != nil && !errors.Is(err, os.ErrNotExist) {\n\t\tif errors.Is(err, unix.ENOTDIR) {\n\t\t\treturn mount(\"tmpfs\", path, \"\", \"tmpfs\", unix.MS_RDONLY, label.FormatMountLabel(\"\", mountLabel))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// writeSystemProperty writes the value to a path under /proc/sys as determined from the key.\n// For e.g. net.ipv4.ip_forward translated to /proc/sys/net/ipv4/ip_forward.\nfunc writeSystemProperty(key, value string) error {\n\tkeyPath := strings.Replace(key, \".\", \"/\", -1)\n\treturn os.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)\n}\n\nfunc remount(m *configs.Mount, rootfs string, mountFd *int) error {\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\tflags := uintptr(m.Flags | unix.MS_REMOUNT)\n\t\terr := mount(source, m.Destination, procfd, m.Device, flags, \"\")\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\t// Check if the source has ro flag...\n\t\tvar s unix.Statfs_t\n\t\tif err := unix.Statfs(source, &s); err != nil {\n\t\t\treturn &os.PathError{Op: \"statfs\", Path: source, Err: err}\n\t\t}\n\t\tif s.Flags&unix.MS_RDONLY != unix.MS_RDONLY {\n\t\t\treturn err\n\t\t}\n\t\t// ... and retry the mount with ro flag set.\n\t\tflags |= unix.MS_RDONLY\n\t\treturn mount(source, m.Destination, procfd, m.Device, flags, \"\")\n\t})\n}\n\n// Do the mount operation followed by additional mounts required to take care\n// of propagation flags. This will always be scoped inside the container rootfs.\nfunc mountPropagate(m *configs.Mount, rootfs string, mountLabel string, mountFd *int) error {\n\tvar (\n\t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n\t\tflags = m.Flags\n\t)\n\t// Delay mounting the filesystem read-only if we need to do further\n\t// operations on it. We need to set up files in \"/dev\", and other tmpfs\n\t// mounts may need to be chmod-ed after mounting. These mounts will be\n\t// remounted ro later in finalizeRootfs(), if necessary.\n\tif m.Device == \"tmpfs\" || utils.CleanPath(m.Destination) == \"/dev\" {\n\t\tflags &= ^unix.MS_RDONLY\n\t}\n\n\t// Because the destination is inside a container path which might be\n\t// mutating underneath us, we verify that we are actually going to mount\n\t// inside the container with WithProcfd() -- mounting through a procfd\n\t// mounts on the target.\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn mount(source, m.Destination, procfd, m.Device, uintptr(flags), data)\n\t}); err != nil {\n\t\treturn err\n\t}\n\t// We have to apply mount propagation flags in a separate WithProcfd() call\n\t// because the previous call invalidates the passed procfd -- the mount\n\t// target needs to be re-opened.\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\tfor _, pflag := range m.PropagationFlags {\n\t\t\tif err := mount(\"\", m.Destination, procfd, \"\", uintptr(pflag), \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"change mount propagation through procfd: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc setRecAttr(m *configs.Mount, rootfs string) error {\n\tif m.RecAttr == nil {\n\t\treturn nil\n\t}\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn unix.MountSetattr(-1, procfd, unix.AT_RECURSIVE, m.RecAttr)\n\t})\n}\n", "#!/usr/bin/env bats\n\nload helpers\n\nfunction setup() {\n\tsetup_busybox\n}\n\nfunction teardown() {\n\tteardown_bundle\n}\n\n@test \"runc run [bind mount]\" {\n\tupdate_config '\t  .mounts += [{\n\t\t\t\t\tsource: \".\",\n\t\t\t\t\tdestination: \"/tmp/bind\",\n\t\t\t\t\toptions: [\"bind\"]\n\t\t\t\t}]\n\t\t\t| .process.args |= [\"ls\", \"/tmp/bind/config.json\"]'\n\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[[ \"${lines[0]}\" == *'/tmp/bind/config.json'* ]]\n}\n\n# https://github.com/opencontainers/runc/issues/2246\n@test \"runc run [ro tmpfs mount]\" {\n\tupdate_config '\t  .mounts += [{\n\t\t\t\t\tsource: \"tmpfs\",\n\t\t\t\t\tdestination: \"/mnt\",\n\t\t\t\t\ttype: \"tmpfs\",\n\t\t\t\t\toptions: [\"ro\", \"nodev\", \"nosuid\", \"mode=755\"]\n\t\t\t\t}]\n\t\t\t| .process.args |= [\"grep\", \"^tmpfs /mnt\", \"/proc/mounts\"]'\n\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[[ \"${lines[0]}\" == *'ro,'* ]]\n}\n\n# https://github.com/opencontainers/runc/issues/3248\n@test \"runc run [ro /dev mount]\" {\n\tupdate_config '   .mounts |= map((select(.destination == \"/dev\") | .options += [\"ro\"]) // .)\n\t\t\t| .process.args |= [\"grep\", \"^tmpfs /dev\", \"/proc/mounts\"]'\n\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[[ \"${lines[0]}\" == *'ro,'* ]]\n}\n\n# https://github.com/opencontainers/runc/issues/2683\n@test \"runc run [tmpfs mount with absolute symlink]\" {\n\t# in container, /conf -> /real/conf\n\tmkdir -p rootfs/real/conf\n\tln -s /real/conf rootfs/conf\n\tupdate_config '\t  .mounts += [{\n\t\t\t\t\ttype: \"tmpfs\",\n\t\t\t\t\tsource: \"tmpfs\",\n\t\t\t\t\tdestination: \"/conf/stack\",\n\t\t\t\t\toptions: [\"ro\", \"nodev\", \"nosuid\"]\n\t\t\t\t}]\n\t\t\t| .process.args |= [\"true\"]'\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n}\n"], "fixing_code": ["package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"github.com/mrunalp/fileutils\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/fs2\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/userns\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype mountConfig struct {\n\troot            string\n\tlabel           string\n\tcgroup2Path     string\n\trootlessCgroups bool\n\tcgroupns        bool\n\tfd              *int\n}\n\n// needsSetupDev returns true if /dev needs to be set up.\nfunc needsSetupDev(config *configs.Config) bool {\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"bind\" && utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// prepareRootfs sets up the devices, mount points, and filesystems for use\n// inside a new mount namespace. It doesn't set anything as ro. You must call\n// finalizeRootfs after this function to finish setting up the rootfs.\nfunc prepareRootfs(pipe io.ReadWriter, iConfig *initConfig, mountFds []int) (err error) {\n\tconfig := iConfig.Config\n\tif err := prepareRoot(config); err != nil {\n\t\treturn fmt.Errorf(\"error preparing rootfs: %w\", err)\n\t}\n\n\tif mountFds != nil && len(mountFds) != len(config.Mounts) {\n\t\treturn fmt.Errorf(\"malformed mountFds slice. Expected size: %v, got: %v. Slice: %v\", len(config.Mounts), len(mountFds), mountFds)\n\t}\n\n\tmountConfig := &mountConfig{\n\t\troot:            config.Rootfs,\n\t\tlabel:           config.MountLabel,\n\t\tcgroup2Path:     iConfig.Cgroup2Path,\n\t\trootlessCgroups: iConfig.RootlessCgroups,\n\t\tcgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),\n\t}\n\tsetupDev := needsSetupDev(config)\n\tfor i, m := range config.Mounts {\n\t\t// Just before the loop we checked that if not empty, len(mountFds) == len(config.Mounts).\n\t\t// Therefore, we can access mountFds[i] without any concerns.\n\t\tif mountFds != nil && mountFds[i] != -1 {\n\t\t\tmountConfig.fd = &mountFds[i]\n\t\t} else {\n\t\t\tmountConfig.fd = nil\n\t\t}\n\n\t\tif err := mountToRootfs(m, mountConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)\n\t\t}\n\t}\n\n\tif setupDev {\n\t\tif err := createDevices(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error creating device nodes: %w\", err)\n\t\t}\n\t\tif err := setupPtmx(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up ptmx: %w\", err)\n\t\t}\n\t\tif err := setupDevSymlinks(config.Rootfs); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up /dev symlinks: %w\", err)\n\t\t}\n\t}\n\n\t// Signal the parent to run the pre-start hooks.\n\t// The hooks are run after the mounts are setup, but before we switch to the new\n\t// root, so that the old root is still available in the hooks for any mount\n\t// manipulations.\n\t// Note that iConfig.Cwd is not guaranteed to exist here.\n\tif err := syncParentHooks(pipe); err != nil {\n\t\treturn err\n\t}\n\n\t// The reason these operations are done here rather than in finalizeRootfs\n\t// is because the console-handling code gets quite sticky if we have to set\n\t// up the console before doing the pivot_root(2). This is because the\n\t// Console API has to also work with the ExecIn case, which means that the\n\t// API must be able to deal with being inside as well as outside the\n\t// container. It's just cleaner to do this here (at the expense of the\n\t// operation not being perfectly split).\n\n\tif err := unix.Chdir(config.Rootfs); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: config.Rootfs, Err: err}\n\t}\n\n\ts := iConfig.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreating\n\tif err := iConfig.Config.Hooks[configs.CreateContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif config.NoPivotRoot {\n\t\terr = msMoveRoot(config.Rootfs)\n\t} else if config.Namespaces.Contains(configs.NEWNS) {\n\t\terr = pivotRoot(config.Rootfs)\n\t} else {\n\t\terr = chroot()\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error jailing process inside rootfs: %w\", err)\n\t}\n\n\tif setupDev {\n\t\tif err := reOpenDevNull(); err != nil {\n\t\t\treturn fmt.Errorf(\"error reopening /dev/null inside container: %w\", err)\n\t\t}\n\t}\n\n\tif cwd := iConfig.Cwd; cwd != \"\" {\n\t\t// Note that spec.Process.Cwd can contain unclean value like  \"../../../../foo/bar...\".\n\t\t// However, we are safe to call MkDirAll directly because we are in the jail here.\n\t\tif err := os.MkdirAll(cwd, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// finalizeRootfs sets anything to ro if necessary. You must call\n// prepareRootfs first.\nfunc finalizeRootfs(config *configs.Config) (err error) {\n\t// All tmpfs mounts and /dev were previously mounted as rw\n\t// by mountPropagate. Remount them read-only as requested.\n\tfor _, m := range config.Mounts {\n\t\tif m.Flags&unix.MS_RDONLY != unix.MS_RDONLY {\n\t\t\tcontinue\n\t\t}\n\t\tif m.Device == \"tmpfs\" || utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\tif err := remountReadonly(m); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// set rootfs ( / ) as readonly\n\tif config.Readonlyfs {\n\t\tif err := setReadonly(); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rootfs as readonly: %w\", err)\n\t\t}\n\t}\n\n\tif config.Umask != nil {\n\t\tunix.Umask(int(*config.Umask))\n\t} else {\n\t\tunix.Umask(0o022)\n\t}\n\treturn nil\n}\n\n// /tmp has to be mounted as private to allow MS_MOVE to work in all situations\nfunc prepareTmp(topTmpDir string) (string, error) {\n\ttmpdir, err := os.MkdirTemp(topTmpDir, \"runctop\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(tmpdir, tmpdir, \"\", \"bind\", unix.MS_BIND, \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(\"\", tmpdir, \"\", \"\", uintptr(unix.MS_PRIVATE), \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tmpdir, nil\n}\n\nfunc cleanupTmp(tmpdir string) {\n\t_ = unix.Unmount(tmpdir, 0)\n\t_ = os.RemoveAll(tmpdir)\n}\n\nfunc prepareBindMount(m *configs.Mount, rootfs string, mountFd *int) error {\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\tstat, err := os.Stat(source)\n\tif err != nil {\n\t\t// error out if the source of a bind mount does not exist as we will be\n\t\t// unable to bind anything to it.\n\t\treturn err\n\t}\n\t// ensure that the destination of the bind mount is resolved of symlinks at mount time because\n\t// any previous mounts can invalidate the next mount's destination.\n\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n\t// evil stuff to try to escape the container's rootfs.\n\tvar dest string\n\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n\t\treturn err\n\t}\n\tif err := checkProcMount(rootfs, dest, source); err != nil {\n\t\treturn err\n\t}\n\tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n\tbinds, err := getCgroupMounts(m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar merged []string\n\tfor _, b := range binds {\n\t\tss := filepath.Base(b.Destination)\n\t\tif strings.Contains(ss, \",\") {\n\t\t\tmerged = append(merged, ss)\n\t\t}\n\t}\n\ttmpfs := &configs.Mount{\n\t\tSource:           \"tmpfs\",\n\t\tDevice:           \"tmpfs\",\n\t\tDestination:      m.Destination,\n\t\tFlags:            defaultMountFlags,\n\t\tData:             \"mode=755\",\n\t\tPropagationFlags: m.PropagationFlags,\n\t}\n\n\tif err := mountToRootfs(tmpfs, c); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, b := range binds {\n\t\tif c.cgroupns {\n\t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n\t\t\tif err := os.MkdirAll(subsystemPath, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := utils.WithProcfd(c.root, b.Destination, func(procfd string) error {\n\t\t\t\tflags := defaultMountFlags\n\t\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\t\t\tflags = flags | unix.MS_RDONLY\n\t\t\t\t}\n\t\t\t\tvar (\n\t\t\t\t\tsource = \"cgroup\"\n\t\t\t\t\tdata   = filepath.Base(subsystemPath)\n\t\t\t\t)\n\t\t\t\tif data == \"systemd\" {\n\t\t\t\t\tdata = cgroups.CgroupNamePrefix + data\n\t\t\t\t\tsource = \"systemd\"\n\t\t\t\t}\n\t\t\t\treturn mount(source, b.Destination, procfd, \"cgroup\", uintptr(flags), data)\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := mountToRootfs(b, c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor _, mc := range merged {\n\t\tfor _, ss := range strings.Split(mc, \",\") {\n\t\t\t// symlink(2) is very dumb, it will just shove the path into\n\t\t\t// the link and doesn't do any checks or relative path\n\t\t\t// conversion. Also, don't error out if the cgroup already exists.\n\t\t\tif err := os.Symlink(mc, filepath.Join(c.root, m.Destination, ss)); err != nil && !os.IsExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n\tdest, err := securejoin.SecureJoin(c.root, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\treturn err\n\t}\n\terr = utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n\t\treturn mount(m.Source, m.Destination, procfd, \"cgroup2\", uintptr(m.Flags), m.Data)\n\t})\n\tif err == nil || !(errors.Is(err, unix.EPERM) || errors.Is(err, unix.EBUSY)) {\n\t\treturn err\n\t}\n\n\t// When we are in UserNS but CgroupNS is not unshared, we cannot mount\n\t// cgroup2 (#2158), so fall back to bind mount.\n\tbindM := &configs.Mount{\n\t\tDevice:           \"bind\",\n\t\tSource:           fs2.UnifiedMountpoint,\n\t\tDestination:      m.Destination,\n\t\tFlags:            unix.MS_BIND | m.Flags,\n\t\tPropagationFlags: m.PropagationFlags,\n\t}\n\tif c.cgroupns && c.cgroup2Path != \"\" {\n\t\t// Emulate cgroupns by bind-mounting the container cgroup path\n\t\t// rather than the whole /sys/fs/cgroup.\n\t\tbindM.Source = c.cgroup2Path\n\t}\n\t// mountToRootfs() handles remounting for MS_RDONLY.\n\t// No need to set c.fd here, because mountToRootfs() calls utils.WithProcfd() by itself in mountPropagate().\n\terr = mountToRootfs(bindM, c)\n\tif c.rootlessCgroups && errors.Is(err, unix.ENOENT) {\n\t\t// ENOENT (for `src = c.cgroup2Path`) happens when rootless runc is being executed\n\t\t// outside the userns+mountns.\n\t\t//\n\t\t// Mask `/sys/fs/cgroup` to ensure it is read-only, even when `/sys` is mounted\n\t\t// with `rbind,ro` (`runc spec --rootless` produces `rbind,ro` for `/sys`).\n\t\terr = utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n\t\t\treturn maskPath(procfd, c.label)\n\t\t})\n\t}\n\treturn err\n}\n\nfunc doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n\t// Set up a scratch dir for the tmpfs on the host.\n\ttmpdir, err := prepareTmp(\"/tmp\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to setup tmpdir: %w\", err)\n\t}\n\tdefer cleanupTmp(tmpdir)\n\ttmpDir, err := os.MkdirTemp(tmpdir, \"runctmpdir\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to create tmpdir: %w\", err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\t// Configure the *host* tmpdir as if it's the container mount. We change\n\t// m.Destination since we are going to mount *on the host*.\n\toldDest := m.Destination\n\tm.Destination = tmpDir\n\terr = mountPropagate(m, \"/\", mountLabel, nil)\n\tm.Destination = oldDest\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif Err != nil {\n\t\t\tif err := unmount(tmpDir, unix.MNT_DETACH); err != nil {\n\t\t\t\tlogrus.Warnf(\"tmpcopyup: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) (Err error) {\n\t\t// Copy the container data to the host tmpdir. We append \"/\" to force\n\t\t// CopyDirectory to resolve the symlink rather than trying to copy the\n\t\t// symlink itself.\n\t\tif err := fileutils.CopyDirectory(procfd+\"/\", tmpDir); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to copy %s to %s (%s): %w\", m.Destination, procfd, tmpDir, err)\n\t\t}\n\t\t// Now move the mount into the container.\n\t\tif err := mount(tmpDir, m.Destination, procfd, \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to move mount: %w\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc mountToRootfs(m *configs.Mount, c *mountConfig) error {\n\trootfs := c.root\n\n\t// procfs and sysfs are special because we need to ensure they are actually\n\t// mounted on a specific path in a container without any funny business.\n\tswitch m.Device {\n\tcase \"proc\", \"sysfs\":\n\t\t// If the destination already exists and is not a directory, we bail\n\t\t// out. This is to avoid mounting through a symlink or similar -- which\n\t\t// has been a \"fun\" attack scenario in the past.\n\t\t// TODO: This won't be necessary once we switch to libpathrs and we can\n\t\t//       stop all of these symlink-exchange attacks.\n\t\tdest := filepath.Clean(m.Destination)\n\t\tif !strings.HasPrefix(dest, rootfs) {\n\t\t\t// Do not use securejoin as it resolves symlinks.\n\t\t\tdest = filepath.Join(rootfs, dest)\n\t\t}\n\t\tif fi, err := os.Lstat(dest); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if !fi.IsDir() {\n\t\t\treturn fmt.Errorf(\"filesystem %q must be mounted on ordinary directory\", m.Device)\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Selinux kernels do not support labeling of /proc or /sys.\n\t\treturn mountPropagate(m, rootfs, \"\", nil)\n\t}\n\n\tmountLabel := c.label\n\tmountFd := c.fd\n\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch m.Device {\n\tcase \"mqueue\":\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, \"\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn label.SetFileLabel(dest, mountLabel)\n\tcase \"tmpfs\":\n\t\tstat, err := os.Stat(dest)\n\t\tif err != nil {\n\t\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {\n\t\t\terr = doTmpfsCopyUp(m, rootfs, mountLabel)\n\t\t} else {\n\t\t\terr = mountPropagate(m, rootfs, mountLabel, nil)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif stat != nil {\n\t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\tcase \"bind\":\n\t\tif err := prepareBindMount(m, rootfs, mountFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, mountLabel, mountFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// bind mount won't change mount options, we need remount to make mount options effective.\n\t\t// first check that we have non-default options required before attempting a remount\n\t\tif m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {\n\t\t\t// only remount if unique mount options are set\n\t\t\tif err := remount(m, rootfs, mountFd); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Relabel != \"\" {\n\t\t\tif err := label.Validate(m.Relabel); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tshared := label.IsShared(m.Relabel)\n\t\t\tif err := label.Relabel(m.Source, mountLabel, shared); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn setRecAttr(m, rootfs)\n\tcase \"cgroup\":\n\t\tif cgroups.IsCgroup2UnifiedMode() {\n\t\t\treturn mountCgroupV2(m, c)\n\t\t}\n\t\treturn mountCgroupV1(m, c)\n\tdefault:\n\t\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn mountPropagate(m, rootfs, mountLabel, mountFd)\n\t}\n}\n\nfunc getCgroupMounts(m *configs.Mount) ([]*configs.Mount, error) {\n\tmounts, err := cgroups.GetCgroupMounts(false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcgroupPaths, err := cgroups.ParseCgroupFile(\"/proc/self/cgroup\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar binds []*configs.Mount\n\n\tfor _, mm := range mounts {\n\t\tdir, err := mm.GetOwnCgroup(cgroupPaths)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trelDir, err := filepath.Rel(mm.Root, dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbinds = append(binds, &configs.Mount{\n\t\t\tDevice:           \"bind\",\n\t\t\tSource:           filepath.Join(mm.Mountpoint, relDir),\n\t\t\tDestination:      filepath.Join(m.Destination, filepath.Base(mm.Mountpoint)),\n\t\t\tFlags:            unix.MS_BIND | unix.MS_REC | m.Flags,\n\t\t\tPropagationFlags: m.PropagationFlags,\n\t\t})\n\t}\n\n\treturn binds, nil\n}\n\n// checkProcMount checks to ensure that the mount destination is not over the top of /proc.\n// dest is required to be an abs path and have any symlinks resolved before calling this function.\n//\n// if source is nil, don't stat the filesystem.  This is used for restore of a checkpoint.\nfunc checkProcMount(rootfs, dest, source string) error {\n\tconst procPath = \"/proc\"\n\tpath, err := filepath.Rel(filepath.Join(rootfs, procPath), dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// pass if the mount path is located outside of /proc\n\tif strings.HasPrefix(path, \"..\") {\n\t\treturn nil\n\t}\n\tif path == \".\" {\n\t\t// an empty source is pasted on restore\n\t\tif source == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t// only allow a mount on-top of proc if it's source is \"proc\"\n\t\tisproc, err := isProc(source)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// pass if the mount is happening on top of /proc and the source of\n\t\t// the mount is a proc filesystem\n\t\tif isproc {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"%q cannot be mounted because it is not of type proc\", dest)\n\t}\n\n\t// Here dest is definitely under /proc. Do not allow those,\n\t// except for a few specific entries emulated by lxcfs.\n\tvalidProcMounts := []string{\n\t\t\"/proc/cpuinfo\",\n\t\t\"/proc/diskstats\",\n\t\t\"/proc/meminfo\",\n\t\t\"/proc/stat\",\n\t\t\"/proc/swaps\",\n\t\t\"/proc/uptime\",\n\t\t\"/proc/loadavg\",\n\t\t\"/proc/slabinfo\",\n\t\t\"/proc/net/dev\",\n\t\t\"/proc/sys/kernel/ns_last_pid\",\n\t}\n\tfor _, valid := range validProcMounts {\n\t\tpath, err := filepath.Rel(filepath.Join(rootfs, valid), dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path == \".\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%q cannot be mounted because it is inside /proc\", dest)\n}\n\nfunc isProc(path string) (bool, error) {\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn false, &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\treturn s.Type == unix.PROC_SUPER_MAGIC, nil\n}\n\nfunc setupDevSymlinks(rootfs string) error {\n\tlinks := [][2]string{\n\t\t{\"/proc/self/fd\", \"/dev/fd\"},\n\t\t{\"/proc/self/fd/0\", \"/dev/stdin\"},\n\t\t{\"/proc/self/fd/1\", \"/dev/stdout\"},\n\t\t{\"/proc/self/fd/2\", \"/dev/stderr\"},\n\t}\n\t// kcore support can be toggled with CONFIG_PROC_KCORE; only create a symlink\n\t// in /dev if it exists in /proc.\n\tif _, err := os.Stat(\"/proc/kcore\"); err == nil {\n\t\tlinks = append(links, [2]string{\"/proc/kcore\", \"/dev/core\"})\n\t}\n\tfor _, link := range links {\n\t\tvar (\n\t\t\tsrc = link[0]\n\t\t\tdst = filepath.Join(rootfs, link[1])\n\t\t)\n\t\tif err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// If stdin, stdout, and/or stderr are pointing to `/dev/null` in the parent's rootfs\n// this method will make them point to `/dev/null` in this container's rootfs.  This\n// needs to be called after we chroot/pivot into the container's rootfs so that any\n// symlinks are resolved locally.\nfunc reOpenDevNull() error {\n\tvar stat, devNullStat unix.Stat_t\n\tfile, err := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close() //nolint: errcheck\n\tif err := unix.Fstat(int(file.Fd()), &devNullStat); err != nil {\n\t\treturn &os.PathError{Op: \"fstat\", Path: file.Name(), Err: err}\n\t}\n\tfor fd := 0; fd < 3; fd++ {\n\t\tif err := unix.Fstat(fd, &stat); err != nil {\n\t\t\treturn &os.PathError{Op: \"fstat\", Path: \"fd \" + strconv.Itoa(fd), Err: err}\n\t\t}\n\t\tif stat.Rdev == devNullStat.Rdev {\n\t\t\t// Close and re-open the fd.\n\t\t\tif err := unix.Dup3(int(file.Fd()), fd, 0); err != nil {\n\t\t\t\treturn &os.PathError{\n\t\t\t\t\tOp:   \"dup3\",\n\t\t\t\t\tPath: \"fd \" + strconv.Itoa(int(file.Fd())),\n\t\t\t\t\tErr:  err,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Create the device nodes in the container.\nfunc createDevices(config *configs.Config) error {\n\tuseBindMount := userns.RunningInUserNS() || config.Namespaces.Contains(configs.NEWUSER)\n\toldMask := unix.Umask(0o000)\n\tfor _, node := range config.Devices {\n\n\t\t// The /dev/ptmx device is setup by setupPtmx()\n\t\tif utils.CleanPath(node.Path) == \"/dev/ptmx\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// containers running in a user namespace are not allowed to mknod\n\t\t// devices so we can just bind mount it from the host.\n\t\tif err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {\n\t\t\tunix.Umask(oldMask)\n\t\t\treturn err\n\t\t}\n\t}\n\tunix.Umask(oldMask)\n\treturn nil\n}\n\nfunc bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {\n\tf, err := os.Create(dest)\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\treturn utils.WithProcfd(rootfs, dest, func(procfd string) error {\n\t\treturn mount(node.Path, dest, procfd, \"bind\", unix.MS_BIND, \"\")\n\t})\n}\n\n// Creates the device node in the rootfs of the container.\nfunc createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n\tif node.Path == \"\" {\n\t\t// The node only exists for cgroup reasons, ignore it here.\n\t\treturn nil\n\t}\n\tdest, err := securejoin.SecureJoin(rootfs, node.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n\t\treturn err\n\t}\n\tif bind {\n\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t}\n\tif err := mknodDevice(dest, node); err != nil {\n\t\tif errors.Is(err, os.ErrExist) {\n\t\t\treturn nil\n\t\t} else if errors.Is(err, os.ErrPermission) {\n\t\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc mknodDevice(dest string, node *devices.Device) error {\n\tfileMode := node.FileMode\n\tswitch node.Type {\n\tcase devices.BlockDevice:\n\t\tfileMode |= unix.S_IFBLK\n\tcase devices.CharDevice:\n\t\tfileMode |= unix.S_IFCHR\n\tcase devices.FifoDevice:\n\t\tfileMode |= unix.S_IFIFO\n\tdefault:\n\t\treturn fmt.Errorf(\"%c is not a valid device type for device %s\", node.Type, node.Path)\n\t}\n\tdev, err := node.Mkdev()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Mknod(dest, uint32(fileMode), int(dev)); err != nil {\n\t\treturn &os.PathError{Op: \"mknod\", Path: dest, Err: err}\n\t}\n\treturn os.Chown(dest, int(node.Uid), int(node.Gid))\n}\n\n// Get the parent mount point of directory passed in as argument. Also return\n// optional fields.\nfunc getParentMount(rootfs string) (string, string, error) {\n\tmi, err := mountinfo.GetMounts(mountinfo.ParentsFilter(rootfs))\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tif len(mi) < 1 {\n\t\treturn \"\", \"\", fmt.Errorf(\"could not find parent mount of %s\", rootfs)\n\t}\n\n\t// find the longest mount point\n\tvar idx, maxlen int\n\tfor i := range mi {\n\t\tif len(mi[i].Mountpoint) > maxlen {\n\t\t\tmaxlen = len(mi[i].Mountpoint)\n\t\t\tidx = i\n\t\t}\n\t}\n\treturn mi[idx].Mountpoint, mi[idx].Optional, nil\n}\n\n// Make parent mount private if it was shared\nfunc rootfsParentMountPrivate(rootfs string) error {\n\tsharedMount := false\n\n\tparentMount, optionalOpts, err := getParentMount(rootfs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toptsSplit := strings.Split(optionalOpts, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\tsharedMount = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Make parent mount PRIVATE if it was shared. It is needed for two\n\t// reasons. First of all pivot_root() will fail if parent mount is\n\t// shared. Secondly when we bind mount rootfs it will propagate to\n\t// parent namespace and we don't want that to happen.\n\tif sharedMount {\n\t\treturn mount(\"\", parentMount, \"\", \"\", unix.MS_PRIVATE, \"\")\n\t}\n\n\treturn nil\n}\n\nfunc prepareRoot(config *configs.Config) error {\n\tflag := unix.MS_SLAVE | unix.MS_REC\n\tif config.RootPropagation != 0 {\n\t\tflag = config.RootPropagation\n\t}\n\tif err := mount(\"\", \"/\", \"\", \"\", uintptr(flag), \"\"); err != nil {\n\t\treturn err\n\t}\n\n\t// Make parent mount private to make sure following bind mount does\n\t// not propagate in other namespaces. Also it will help with kernel\n\t// check pass in pivot_root. (IS_SHARED(new_mnt->mnt_parent))\n\tif err := rootfsParentMountPrivate(config.Rootfs); err != nil {\n\t\treturn err\n\t}\n\n\treturn mount(config.Rootfs, config.Rootfs, \"\", \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n}\n\nfunc setReadonly() error {\n\tflags := uintptr(unix.MS_BIND | unix.MS_REMOUNT | unix.MS_RDONLY)\n\n\terr := mount(\"\", \"/\", \"\", \"\", flags, \"\")\n\tif err == nil {\n\t\treturn nil\n\t}\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(\"/\", &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: \"/\", Err: err}\n\t}\n\tflags |= uintptr(s.Flags)\n\treturn mount(\"\", \"/\", \"\", \"\", flags, \"\")\n}\n\nfunc setupPtmx(config *configs.Config) error {\n\tptmx := filepath.Join(config.Rootfs, \"dev/ptmx\")\n\tif err := os.Remove(ptmx); err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\tif err := os.Symlink(\"pts/ptmx\", ptmx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// pivotRoot will call pivot_root such that rootfs becomes the new root\n// filesystem, and everything else is cleaned up.\nfunc pivotRoot(rootfs string) error {\n\t// While the documentation may claim otherwise, pivot_root(\".\", \".\") is\n\t// actually valid. What this results in is / being the new root but\n\t// /proc/self/cwd being the old root. Since we can play around with the cwd\n\t// with pivot_root this allows us to pivot without creating directories in\n\t// the rootfs. Shout-outs to the LXC developers for giving us this idea.\n\n\toldroot, err := unix.Open(\"/\", unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: \"/\", Err: err}\n\t}\n\tdefer unix.Close(oldroot) //nolint: errcheck\n\n\tnewroot, err := unix.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: rootfs, Err: err}\n\t}\n\tdefer unix.Close(newroot) //nolint: errcheck\n\n\t// Change to the new root so that the pivot_root actually acts on it.\n\tif err := unix.Fchdir(newroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(newroot), Err: err}\n\t}\n\n\tif err := unix.PivotRoot(\".\", \".\"); err != nil {\n\t\treturn &os.PathError{Op: \"pivot_root\", Path: \".\", Err: err}\n\t}\n\n\t// Currently our \".\" is oldroot (according to the current kernel code).\n\t// However, purely for safety, we will fchdir(oldroot) since there isn't\n\t// really any guarantee from the kernel what /proc/self/cwd will be after a\n\t// pivot_root(2).\n\n\tif err := unix.Fchdir(oldroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(oldroot), Err: err}\n\t}\n\n\t// Make oldroot rslave to make sure our unmounts don't propagate to the\n\t// host (and thus bork the machine). We don't use rprivate because this is\n\t// known to cause issues due to races where we still have a reference to a\n\t// mount while a process in the host namespace are trying to operate on\n\t// something they think has no mounts (devicemapper in particular).\n\tif err := mount(\"\", \".\", \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\treturn err\n\t}\n\t// Perform the unmount. MNT_DETACH allows us to unmount /proc/self/cwd.\n\tif err := unmount(\".\", unix.MNT_DETACH); err != nil {\n\t\treturn err\n\t}\n\n\t// Switch back to our shiny new root.\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\nfunc msMoveRoot(rootfs string) error {\n\t// Before we move the root and chroot we have to mask all \"full\" sysfs and\n\t// procfs mounts which exist on the host. This is because while the kernel\n\t// has protections against mounting procfs if it has masks, when using\n\t// chroot(2) the *host* procfs mount is still reachable in the mount\n\t// namespace and the kernel permits procfs mounts inside --no-pivot\n\t// containers.\n\t//\n\t// Users shouldn't be using --no-pivot except in exceptional circumstances,\n\t// but to avoid such a trivial security flaw we apply a best-effort\n\t// protection here. The kernel only allows a mount of a pseudo-filesystem\n\t// like procfs or sysfs if there is a *full* mount (the root of the\n\t// filesystem is mounted) without any other locked mount points covering a\n\t// subtree of the mount.\n\t//\n\t// So we try to unmount (or mount tmpfs on top of) any mountpoint which is\n\t// a full mount of either sysfs or procfs (since those are the most\n\t// concerning filesystems to us).\n\tmountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {\n\t\t// Collect every sysfs and procfs filesystem, except for those which\n\t\t// are non-full mounts or are inside the rootfs of the container.\n\t\tif info.Root != \"/\" ||\n\t\t\t(info.FSType != \"proc\" && info.FSType != \"sysfs\") ||\n\t\t\tstrings.HasPrefix(info.Mountpoint, rootfs) {\n\t\t\tskip = true\n\t\t}\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, info := range mountinfos {\n\t\tp := info.Mountpoint\n\t\t// Be sure umount events are not propagated to the host.\n\t\tif err := mount(\"\", p, \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.ENOENT) {\n\t\t\t\t// If the mountpoint doesn't exist that means that we've\n\t\t\t\t// already blasted away some parent directory of the mountpoint\n\t\t\t\t// and so we don't care about this error.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif err := unmount(p, unix.MNT_DETACH); err != nil {\n\t\t\tif !errors.Is(err, unix.EINVAL) && !errors.Is(err, unix.EPERM) {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\t// If we have not privileges for umounting (e.g. rootless), then\n\t\t\t\t// cover the path.\n\t\t\t\tif err := mount(\"tmpfs\", p, \"\", \"tmpfs\", 0, \"\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move the rootfs on top of \"/\" in our mount namespace.\n\tif err := mount(rootfs, \"/\", \"\", \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn chroot()\n}\n\nfunc chroot() error {\n\tif err := unix.Chroot(\".\"); err != nil {\n\t\treturn &os.PathError{Op: \"chroot\", Path: \".\", Err: err}\n\t}\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\n// createIfNotExists creates a file or a directory only if it does not already exist.\nfunc createIfNotExists(path string, isDir bool) error {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif isDir {\n\t\t\t\treturn os.MkdirAll(path, 0o755)\n\t\t\t}\n\t\t\tif err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf, err := os.OpenFile(path, os.O_CREATE, 0o755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_ = f.Close()\n\t\t}\n\t}\n\treturn nil\n}\n\n// readonlyPath will make a path read only.\nfunc readonlyPath(path string) error {\n\tif err := mount(path, path, \"\", \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tflags := uintptr(s.Flags) & (unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC)\n\n\tif err := mount(path, path, \"\", \"\", flags|unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, \"\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// remountReadonly will remount an existing mount point and ensure that it is read-only.\nfunc remountReadonly(m *configs.Mount) error {\n\tvar (\n\t\tdest  = m.Destination\n\t\tflags = m.Flags\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\t// There is a special case in the kernel for\n\t\t// MS_REMOUNT | MS_BIND, which allows us to change only the\n\t\t// flags even as an unprivileged user (i.e. user namespace)\n\t\t// assuming we don't drop any security related flags (nodev,\n\t\t// nosuid, etc.). So, let's use that case so that we can do\n\t\t// this re-mount without failing in a userns.\n\t\tflags |= unix.MS_REMOUNT | unix.MS_BIND | unix.MS_RDONLY\n\t\tif err := mount(\"\", dest, \"\", \"\", uintptr(flags), \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.EBUSY) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unable to mount %s as readonly max retries reached\", dest)\n}\n\n// maskPath masks the top of the specified path inside a container to avoid\n// security issues from processes reading information from non-namespace aware\n// mounts ( proc/kcore ).\n// For files, maskPath bind mounts /dev/null over the top of the specified path.\n// For directories, maskPath mounts read-only tmpfs over the top of the specified path.\nfunc maskPath(path string, mountLabel string) error {\n\tif err := mount(\"/dev/null\", path, \"\", \"\", unix.MS_BIND, \"\"); err != nil && !errors.Is(err, os.ErrNotExist) {\n\t\tif errors.Is(err, unix.ENOTDIR) {\n\t\t\treturn mount(\"tmpfs\", path, \"\", \"tmpfs\", unix.MS_RDONLY, label.FormatMountLabel(\"\", mountLabel))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// writeSystemProperty writes the value to a path under /proc/sys as determined from the key.\n// For e.g. net.ipv4.ip_forward translated to /proc/sys/net/ipv4/ip_forward.\nfunc writeSystemProperty(key, value string) error {\n\tkeyPath := strings.Replace(key, \".\", \"/\", -1)\n\treturn os.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)\n}\n\nfunc remount(m *configs.Mount, rootfs string, mountFd *int) error {\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\tflags := uintptr(m.Flags | unix.MS_REMOUNT)\n\t\terr := mount(source, m.Destination, procfd, m.Device, flags, \"\")\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\t// Check if the source has ro flag...\n\t\tvar s unix.Statfs_t\n\t\tif err := unix.Statfs(source, &s); err != nil {\n\t\t\treturn &os.PathError{Op: \"statfs\", Path: source, Err: err}\n\t\t}\n\t\tif s.Flags&unix.MS_RDONLY != unix.MS_RDONLY {\n\t\t\treturn err\n\t\t}\n\t\t// ... and retry the mount with ro flag set.\n\t\tflags |= unix.MS_RDONLY\n\t\treturn mount(source, m.Destination, procfd, m.Device, flags, \"\")\n\t})\n}\n\n// Do the mount operation followed by additional mounts required to take care\n// of propagation flags. This will always be scoped inside the container rootfs.\nfunc mountPropagate(m *configs.Mount, rootfs string, mountLabel string, mountFd *int) error {\n\tvar (\n\t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n\t\tflags = m.Flags\n\t)\n\t// Delay mounting the filesystem read-only if we need to do further\n\t// operations on it. We need to set up files in \"/dev\", and other tmpfs\n\t// mounts may need to be chmod-ed after mounting. These mounts will be\n\t// remounted ro later in finalizeRootfs(), if necessary.\n\tif m.Device == \"tmpfs\" || utils.CleanPath(m.Destination) == \"/dev\" {\n\t\tflags &= ^unix.MS_RDONLY\n\t}\n\n\t// Because the destination is inside a container path which might be\n\t// mutating underneath us, we verify that we are actually going to mount\n\t// inside the container with WithProcfd() -- mounting through a procfd\n\t// mounts on the target.\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn mount(source, m.Destination, procfd, m.Device, uintptr(flags), data)\n\t}); err != nil {\n\t\treturn err\n\t}\n\t// We have to apply mount propagation flags in a separate WithProcfd() call\n\t// because the previous call invalidates the passed procfd -- the mount\n\t// target needs to be re-opened.\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\tfor _, pflag := range m.PropagationFlags {\n\t\t\tif err := mount(\"\", m.Destination, procfd, \"\", uintptr(pflag), \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"change mount propagation through procfd: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc setRecAttr(m *configs.Mount, rootfs string) error {\n\tif m.RecAttr == nil {\n\t\treturn nil\n\t}\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn unix.MountSetattr(-1, procfd, unix.AT_RECURSIVE, m.RecAttr)\n\t})\n}\n", "#!/usr/bin/env bats\n\nload helpers\n\nfunction setup() {\n\tsetup_busybox\n}\n\nfunction teardown() {\n\tteardown_bundle\n}\n\n@test \"runc run [bind mount]\" {\n\tupdate_config '\t  .mounts += [{\n\t\t\t\t\tsource: \".\",\n\t\t\t\t\tdestination: \"/tmp/bind\",\n\t\t\t\t\toptions: [\"bind\"]\n\t\t\t\t}]\n\t\t\t| .process.args |= [\"ls\", \"/tmp/bind/config.json\"]'\n\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[[ \"${lines[0]}\" == *'/tmp/bind/config.json'* ]]\n}\n\n# https://github.com/opencontainers/runc/issues/2246\n@test \"runc run [ro tmpfs mount]\" {\n\tupdate_config '\t  .mounts += [{\n\t\t\t\t\tsource: \"tmpfs\",\n\t\t\t\t\tdestination: \"/mnt\",\n\t\t\t\t\ttype: \"tmpfs\",\n\t\t\t\t\toptions: [\"ro\", \"nodev\", \"nosuid\", \"mode=755\"]\n\t\t\t\t}]\n\t\t\t| .process.args |= [\"grep\", \"^tmpfs /mnt\", \"/proc/mounts\"]'\n\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[[ \"${lines[0]}\" == *'ro,'* ]]\n}\n\n# https://github.com/opencontainers/runc/issues/3248\n@test \"runc run [ro /dev mount]\" {\n\tupdate_config '   .mounts |= map((select(.destination == \"/dev\") | .options += [\"ro\"]) // .)\n\t\t\t| .process.args |= [\"grep\", \"^tmpfs /dev\", \"/proc/mounts\"]'\n\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[[ \"${lines[0]}\" == *'ro,'* ]]\n}\n\n# https://github.com/opencontainers/runc/issues/2683\n@test \"runc run [tmpfs mount with absolute symlink]\" {\n\t# in container, /conf -> /real/conf\n\tmkdir -p rootfs/real/conf\n\tln -s /real/conf rootfs/conf\n\tupdate_config '\t  .mounts += [{\n\t\t\t\t\ttype: \"tmpfs\",\n\t\t\t\t\tsource: \"tmpfs\",\n\t\t\t\t\tdestination: \"/conf/stack\",\n\t\t\t\t\toptions: [\"ro\", \"nodev\", \"nosuid\"]\n\t\t\t\t}]\n\t\t\t| .process.args |= [\"true\"]'\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n}\n\n# https://github.com/opencontainers/runc/security/advisories/GHSA-m8cg-xc2p-r3fc\n@test \"runc run [ro /sys/fs/cgroup mount]\" {\n\t# With cgroup namespace\n\tupdate_config '.process.args |= [\"sh\", \"-euc\", \"for f in `grep /sys/fs/cgroup /proc/mounts | awk \\\"{print \\\\\\\\$2}\\\"| uniq`; do grep -w $f /proc/mounts | tail -n1; done\"]'\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[ \"${#lines[@]}\" -ne 0 ]\n\tfor line in \"${lines[@]}\"; do [[ \"${line}\" == *'ro,'* ]]; done\n\n\t# Without cgroup namespace\n\tupdate_config '.linux.namespaces -= [{\"type\": \"cgroup\"}]'\n\trunc run test_busybox\n\t[ \"$status\" -eq 0 ]\n\t[ \"${#lines[@]}\" -ne 0 ]\n\tfor line in \"${lines[@]}\"; do [[ \"${line}\" == *'ro,'* ]]; done\n}\n"], "filenames": ["libcontainer/rootfs_linux.go", "tests/integration/mounts.bats"], "buggy_code_start_loc": [309, 65], "buggy_code_end_loc": [328, 65], "fixing_code_start_loc": [309, 66], "fixing_code_end_loc": [344, 83], "type": "CWE-281", "message": "runc is a CLI tool for spawning and running containers according to the OCI specification. In affected versions it was found that rootless runc makes `/sys/fs/cgroup` writable in following conditons: 1. when runc is executed inside the user namespace, and the `config.json` does not specify the cgroup namespace to be unshared (e.g.., `(docker|podman|nerdctl) run --cgroupns=host`, with Rootless Docker/Podman/nerdctl) or 2. when runc is executed outside the user namespace, and `/sys` is mounted with `rbind, ro` (e.g., `runc spec --rootless`; this condition is very rare). A container may gain the write access to user-owned cgroup hierarchy `/sys/fs/cgroup/user.slice/...` on the host . Other users's cgroup hierarchies are not affected. Users are advised to upgrade to version 1.1.5. Users unable to upgrade may unshare the cgroup namespace (`(docker|podman|nerdctl) run --cgroupns=private)`. This is the default behavior of Docker/Podman/nerdctl on cgroup v2 hosts. or add `/sys/fs/cgroup` to `maskedPaths`.", "other": {"cve": {"id": "CVE-2023-25809", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-29T19:15:22.170", "lastModified": "2023-04-06T17:41:26.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "runc is a CLI tool for spawning and running containers according to the OCI specification. In affected versions it was found that rootless runc makes `/sys/fs/cgroup` writable in following conditons: 1. when runc is executed inside the user namespace, and the `config.json` does not specify the cgroup namespace to be unshared (e.g.., `(docker|podman|nerdctl) run --cgroupns=host`, with Rootless Docker/Podman/nerdctl) or 2. when runc is executed outside the user namespace, and `/sys` is mounted with `rbind, ro` (e.g., `runc spec --rootless`; this condition is very rare). A container may gain the write access to user-owned cgroup hierarchy `/sys/fs/cgroup/user.slice/...` on the host . Other users's cgroup hierarchies are not affected. Users are advised to upgrade to version 1.1.5. Users unable to upgrade may unshare the cgroup namespace (`(docker|podman|nerdctl) run --cgroupns=private)`. This is the default behavior of Docker/Podman/nerdctl on cgroup v2 hosts. or add `/sys/fs/cgroup` to `maskedPaths`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.0, "impactScore": 3.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:C/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-281"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.5", "matchCriteriaId": "AE0C5D34-F78A-4993-AC70-25A6606FC82B"}]}]}], "references": [{"url": "https://github.com/opencontainers/runc/commit/0d62b950e60f6980b54fe3bafd9a9c608dc1df17", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/opencontainers/runc/security/advisories/GHSA-m8cg-xc2p-r3fc", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/opencontainers/runc/commit/0d62b950e60f6980b54fe3bafd9a9c608dc1df17"}}