{"buggy_code": ["# frozen_string_literal: true\n\n# external dependencies\nrequire 'rack'\nrequire 'tilt'\nrequire 'rack/protection'\nrequire 'mustermann'\nrequire 'mustermann/sinatra'\nrequire 'mustermann/regular'\n\n# stdlib dependencies\nrequire 'time'\nrequire 'uri'\n\n# other files we need\nrequire 'sinatra/indifferent_hash'\nrequire 'sinatra/show_exceptions'\nrequire 'sinatra/version'\n\nmodule Sinatra\n  # The request object. See Rack::Request for more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Request\n  class Request < Rack::Request\n    HEADER_PARAM = /\\s*[\\w.]+=(?:[\\w.]+|\"(?:[^\"\\\\]|\\\\.)*\")?\\s*/.freeze\n    HEADER_VALUE_WITH_PARAMS = %r{(?:(?:\\w+|\\*)/(?:\\w+(?:\\.|-|\\+)?|\\*)*)\\s*(?:;#{HEADER_PARAM})*}.freeze\n\n    # Returns an array of acceptable media types for the response\n    def accept\n      @env['sinatra.accept'] ||= if @env.include?('HTTP_ACCEPT') && (@env['HTTP_ACCEPT'].to_s != '')\n                                   @env['HTTP_ACCEPT']\n                                     .to_s\n                                     .scan(HEADER_VALUE_WITH_PARAMS)\n                                     .map! { |e| AcceptEntry.new(e) }\n                                     .sort\n                                 else\n                                   [AcceptEntry.new('*/*')]\n                                 end\n    end\n\n    def accept?(type)\n      preferred_type(type).to_s.include?(type)\n    end\n\n    def preferred_type(*types)\n      return accept.first if types.empty?\n\n      types.flatten!\n      return types.first if accept.empty?\n\n      accept.detect do |accept_header|\n        type = types.detect { |t| MimeTypeEntry.new(t).accepts?(accept_header) }\n        return type if type\n      end\n    end\n\n    alias secure? ssl?\n\n    def forwarded?\n      @env.include? 'HTTP_X_FORWARDED_HOST'\n    end\n\n    def safe?\n      get? || head? || options? || trace?\n    end\n\n    def idempotent?\n      safe? || put? || delete? || link? || unlink?\n    end\n\n    def link?\n      request_method == 'LINK'\n    end\n\n    def unlink?\n      request_method == 'UNLINK'\n    end\n\n    def params\n      super\n    rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e\n      raise BadRequest, \"Invalid query parameters: #{Rack::Utils.escape_html(e.message)}\"\n    rescue EOFError => e\n      raise BadRequest, \"Invalid multipart/form-data: #{Rack::Utils.escape_html(e.message)}\"\n    end\n\n    class AcceptEntry\n      attr_accessor :params\n      attr_reader :entry\n\n      def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @entry  = entry\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n        @q      = @params.delete('q') { 1.0 }.to_f\n      end\n\n      def <=>(other)\n        other.priority <=> priority\n      end\n\n      def priority\n        # We sort in descending order; better matches should be higher.\n        [@q, -@type.count('*'), @params.size]\n      end\n\n      def to_str\n        @type\n      end\n\n      def to_s(full = false)\n        full ? entry : to_str\n      end\n\n      def respond_to?(*args)\n        super || to_str.respond_to?(*args)\n      end\n\n      def method_missing(*args, &block)\n        to_str.send(*args, &block)\n      end\n    end\n\n    class MimeTypeEntry\n      attr_reader :params\n\n      def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n      end\n\n      def accepts?(entry)\n        File.fnmatch(entry, self) && matches_params?(entry.params)\n      end\n\n      def to_str\n        @type\n      end\n\n      def matches_params?(params)\n        return true if @params.empty?\n\n        params.all? { |k, v| !@params.key?(k) || @params[k] == v }\n      end\n    end\n  end\n\n  # The response object. See Rack::Response and Rack::Response::Helpers for\n  # more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response/Helpers\n  class Response < Rack::Response\n    DROP_BODY_RESPONSES = [204, 304].freeze\n\n    def body=(value)\n      value = value.body while Rack::Response === value\n      @body = String === value ? [value.to_str] : value\n    end\n\n    def each\n      block_given? ? super : enum_for(:each)\n    end\n\n    def finish\n      result = body\n\n      if drop_content_info?\n        headers.delete 'Content-Length'\n        headers.delete 'Content-Type'\n      end\n\n      if drop_body?\n        close\n        result = []\n      end\n\n      if calculate_content_length?\n        # if some other code has already set Content-Length, don't muck with it\n        # currently, this would be the static file-handler\n        headers['Content-Length'] = body.map(&:bytesize).reduce(0, :+).to_s\n      end\n\n      [status, headers, result]\n    end\n\n    private\n\n    def calculate_content_length?\n      headers['Content-Type'] && !headers['Content-Length'] && (Array === body)\n    end\n\n    def drop_content_info?\n      informational? || drop_body?\n    end\n\n    def drop_body?\n      DROP_BODY_RESPONSES.include?(status)\n    end\n  end\n\n  # Some Rack handlers (Rainbows!) implement an extended body object protocol, however,\n  # some middleware (namely Rack::Lint) will break it by not mirroring the methods in question.\n  # This middleware will detect an extended body object and will make sure it reaches the\n  # handler directly. We do this here, so our middleware and middleware set up by the app will\n  # still be able to run.\n  class ExtendedRack < Struct.new(:app)\n    def call(env)\n      result = app.call(env)\n      callback = env['async.callback']\n      return result unless callback && async?(*result)\n\n      after_response { callback.call result }\n      setup_close(env, *result)\n      throw :async\n    end\n\n    private\n\n    def setup_close(env, _status, _headers, body)\n      return unless body.respond_to?(:close) && env.include?('async.close')\n\n      env['async.close'].callback { body.close }\n      env['async.close'].errback { body.close }\n    end\n\n    def after_response(&block)\n      raise NotImplementedError, 'only supports EventMachine at the moment' unless defined? EventMachine\n\n      EventMachine.next_tick(&block)\n    end\n\n    def async?(status, _headers, body)\n      return true if status == -1\n\n      body.respond_to?(:callback) && body.respond_to?(:errback)\n    end\n  end\n\n  # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing,\n  # if another CommonLogger is already in the middleware chain.\n  class CommonLogger < Rack::CommonLogger\n    def call(env)\n      env['sinatra.commonlogger'] ? @app.call(env) : super\n    end\n\n    superclass.class_eval do\n      alias_method :call_without_check, :call unless method_defined? :call_without_check\n      def call(env)\n        env['sinatra.commonlogger'] = true\n        call_without_check(env)\n      end\n    end\n  end\n\n  class Error < StandardError # :nodoc:\n  end\n\n  class BadRequest < Error # :nodoc:\n    def http_status; 400 end\n  end\n\n  class NotFound < Error # :nodoc:\n    def http_status; 404 end\n  end\n\n  # Methods available to routes, before/after filters, and views.\n  module Helpers\n    # Set or retrieve the response status code.\n    def status(value = nil)\n      response.status = Rack::Utils.status_code(value) if value\n      response.status\n    end\n\n    # Set or retrieve the response body. When a block is given,\n    # evaluation is deferred until the body is read with #each.\n    def body(value = nil, &block)\n      if block_given?\n        def block.each; yield(call) end\n        response.body = block\n      elsif value\n        # Rack 2.0 returns a Rack::File::Iterator here instead of\n        # Rack::File as it was in the previous API.\n        unless request.head? || value.is_a?(Rack::File::Iterator) || value.is_a?(Stream)\n          headers.delete 'Content-Length'\n        end\n        response.body = value\n      else\n        response.body\n      end\n    end\n\n    # Halt processing and redirect to the URI provided.\n    def redirect(uri, *args)\n      if (env['HTTP_VERSION'] == 'HTTP/1.1') && (env['REQUEST_METHOD'] != 'GET')\n        status 303\n      else\n        status 302\n      end\n\n      # According to RFC 2616 section 14.30, \"the field value consists of a\n      # single absolute URI\"\n      response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?)\n      halt(*args)\n    end\n\n    # Generates the absolute URI for a given path in the app.\n    # Takes Rack routers and reverse proxies into account.\n    def uri(addr = nil, absolute = true, add_script_name = true)\n      return addr if addr =~ /\\A[a-z][a-z0-9+.\\-]*:/i\n\n      uri = [host = String.new]\n      if absolute\n        host << \"http#{'s' if request.secure?}://\"\n        host << if request.forwarded? || (request.port != (request.secure? ? 443 : 80))\n                  request.host_with_port\n                else\n                  request.host\n                end\n      end\n      uri << request.script_name.to_s if add_script_name\n      uri << (addr || request.path_info).to_s\n      File.join uri\n    end\n\n    alias url uri\n    alias to uri\n\n    # Halt processing and return the error status provided.\n    def error(code, body = nil)\n      if code.respond_to? :to_str\n        body = code.to_str\n        code = 500\n      end\n      response.body = body unless body.nil?\n      halt code\n    end\n\n    # Halt processing and return a 404 Not Found.\n    def not_found(body = nil)\n      error 404, body\n    end\n\n    # Set multiple response headers with Hash.\n    def headers(hash = nil)\n      response.headers.merge! hash if hash\n      response.headers\n    end\n\n    # Access the underlying Rack session.\n    def session\n      request.session\n    end\n\n    # Access shared logger object.\n    def logger\n      request.logger\n    end\n\n    # Look up a media type by file extension in Rack's mime registry.\n    def mime_type(type)\n      Base.mime_type(type)\n    end\n\n    # Set the Content-Type of the response body given a media type or file\n    # extension.\n    def content_type(type = nil, params = {})\n      return response['Content-Type'] unless type\n\n      default = params.delete :default\n      mime_type = mime_type(type) || default\n      raise format('Unknown media type: %p', type) if mime_type.nil?\n\n      mime_type = mime_type.dup\n      unless params.include?(:charset) || settings.add_charset.all? { |p| !(p === mime_type) }\n        params[:charset] = params.delete('charset') || settings.default_encoding\n      end\n      params.delete :charset if mime_type.include? 'charset'\n      unless params.empty?\n        mime_type << (mime_type.include?(';') ? ', ' : ';')\n        mime_type << params.map do |key, val|\n          val = val.inspect if val =~ /[\";,]/\n          \"#{key}=#{val}\"\n        end.join(', ')\n      end\n      response['Content-Type'] = mime_type\n    end\n\n    # Set the Content-Disposition to \"attachment\" with the specified filename,\n    # instructing the user agents to prompt to save.\n    def attachment(filename = nil, disposition = :attachment)\n      response['Content-Disposition'] = disposition.to_s.dup\n      return unless filename\n\n      params = format('; filename=\"%s\"', File.basename(filename))\n      response['Content-Disposition'] << params\n      ext = File.extname(filename)\n      content_type(ext) unless response['Content-Type'] || ext.empty?\n    end\n\n    # Use the contents of the file at +path+ as the response body.\n    def send_file(path, opts = {})\n      if opts[:type] || !response['Content-Type']\n        content_type opts[:type] || File.extname(path), default: 'application/octet-stream'\n      end\n\n      disposition = opts[:disposition]\n      filename    = opts[:filename]\n      disposition = :attachment if disposition.nil? && filename\n      filename    = path        if filename.nil?\n      attachment(filename, disposition) if disposition\n\n      last_modified opts[:last_modified] if opts[:last_modified]\n\n      file   = Rack::File.new(File.dirname(settings.app_file))\n      result = file.serving(request, path)\n\n      result[1].each { |k, v| headers[k] ||= v }\n      headers['Content-Length'] = result[1]['Content-Length']\n      opts[:status] &&= Integer(opts[:status])\n      halt (opts[:status] || result[0]), result[2]\n    rescue Errno::ENOENT\n      not_found\n    end\n\n    # Class of the response body in case you use #stream.\n    #\n    # Three things really matter: The front and back block (back being the\n    # block generating content, front the one sending it to the client) and\n    # the scheduler, integrating with whatever concurrency feature the Rack\n    # handler is using.\n    #\n    # Scheduler has to respond to defer and schedule.\n    class Stream\n      def self.schedule(*) yield end\n      def self.defer(*)    yield end\n\n      def initialize(scheduler = self.class, keep_open = false, &back)\n        @back = back.to_proc\n        @scheduler = scheduler\n        @keep_open = keep_open\n        @callbacks = []\n        @closed = false\n      end\n\n      def close\n        return if closed?\n\n        @closed = true\n        @scheduler.schedule { @callbacks.each { |c| c.call } }\n      end\n\n      def each(&front)\n        @front = front\n        @scheduler.defer do\n          begin\n            @back.call(self)\n          rescue Exception => e\n            @scheduler.schedule { raise e }\n          end\n          close unless @keep_open\n        end\n      end\n\n      def <<(data)\n        @scheduler.schedule { @front.call(data.to_s) }\n        self\n      end\n\n      def callback(&block)\n        return yield if closed?\n\n        @callbacks << block\n      end\n\n      alias errback callback\n\n      def closed?\n        @closed\n      end\n    end\n\n    # Allows to start sending data to the client even though later parts of\n    # the response body have not yet been generated.\n    #\n    # The close parameter specifies whether Stream#close should be called\n    # after the block has been executed. This is only relevant for evented\n    # servers like Rainbows.\n    def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } }\n    end\n\n    # Specify response freshness policy for HTTP caches (Cache-Control header).\n    # Any number of non-value directives (:public, :private, :no_cache,\n    # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with\n    # a Hash of value directives (:max_age, :s_maxage).\n    #\n    #   cache_control :public, :must_revalidate, :max_age => 60\n    #   => Cache-Control: public, must-revalidate, max-age=60\n    #\n    # See RFC 2616 / 14.9 for more on standard cache control directives:\n    # http://tools.ietf.org/html/rfc2616#section-14.9.1\n    def cache_control(*values)\n      if values.last.is_a?(Hash)\n        hash = values.pop\n        hash.reject! { |_k, v| v == false }\n        hash.reject! { |k, v| values << k if v == true }\n      else\n        hash = {}\n      end\n\n      values.map! { |value| value.to_s.tr('_', '-') }\n      hash.each do |key, value|\n        key = key.to_s.tr('_', '-')\n        value = value.to_i if %w[max-age s-maxage].include? key\n        values << \"#{key}=#{value}\"\n      end\n\n      response['Cache-Control'] = values.join(', ') if values.any?\n    end\n\n    # Set the Expires header and Cache-Control/max-age directive. Amount\n    # can be an integer number of seconds in the future or a Time object\n    # indicating when the response should be considered \"stale\". The remaining\n    # \"values\" arguments are passed to the #cache_control helper:\n    #\n    #   expires 500, :public, :must_revalidate\n    #   => Cache-Control: public, must-revalidate, max-age=500\n    #   => Expires: Mon, 08 Jun 2009 08:50:17 GMT\n    #\n    def expires(amount, *values)\n      values << {} unless values.last.is_a?(Hash)\n\n      if amount.is_a? Integer\n        time    = Time.now + amount.to_i\n        max_age = amount\n      else\n        time    = time_for amount\n        max_age = time - Time.now\n      end\n\n      values.last.merge!(max_age: max_age) { |_key, v1, v2| v1 || v2 }\n      cache_control(*values)\n\n      response['Expires'] = time.httpdate\n    end\n\n    # Set the last modified time of the resource (HTTP 'Last-Modified' header)\n    # and halt if conditional GET matches. The +time+ argument is a Time,\n    # DateTime, or other object that responds to +to_time+.\n    #\n    # When the current request includes an 'If-Modified-Since' header that is\n    # equal or later than the time specified, execution is immediately halted\n    # with a '304 Not Modified' response.\n    def last_modified(time)\n      return unless time\n\n      time = time_for time\n      response['Last-Modified'] = time.httpdate\n      return if env['HTTP_IF_NONE_MATCH']\n\n      if (status == 200) && env['HTTP_IF_MODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i\n        halt 304 if since >= time.to_i\n      end\n\n      if (success? || (status == 412)) && env['HTTP_IF_UNMODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i\n        halt 412 if since < time.to_i\n      end\n    rescue ArgumentError\n    end\n\n    ETAG_KINDS = %i[strong weak].freeze\n    # Set the response entity tag (HTTP 'ETag' header) and halt if conditional\n    # GET matches. The +value+ argument is an identifier that uniquely\n    # identifies the current version of the resource. The +kind+ argument\n    # indicates whether the etag should be used as a :strong (default) or :weak\n    # cache validator.\n    #\n    # When the current request includes an 'If-None-Match' header with a\n    # matching etag, execution is immediately halted. If the request method is\n    # GET or HEAD, a '304 Not Modified' response is sent.\n    def etag(value, options = {})\n      # Before touching this code, please double check RFC 2616 14.24 and 14.26.\n      options      = { kind: options } unless Hash === options\n      kind         = options[:kind] || :strong\n      new_resource = options.fetch(:new_resource) { request.post? }\n\n      unless ETAG_KINDS.include?(kind)\n        raise ArgumentError, ':strong or :weak expected'\n      end\n\n      value = format('\"%s\"', value)\n      value = \"W/#{value}\" if kind == :weak\n      response['ETag'] = value\n\n      return unless success? || status == 304\n\n      if etag_matches?(env['HTTP_IF_NONE_MATCH'], new_resource)\n        halt(request.safe? ? 304 : 412)\n      end\n\n      if env['HTTP_IF_MATCH']\n        return if etag_matches?(env['HTTP_IF_MATCH'], new_resource)\n\n        halt 412\n      end\n\n      nil\n    end\n\n    # Sugar for redirect (example:  redirect back)\n    def back\n      request.referer\n    end\n\n    # whether or not the status is set to 1xx\n    def informational?\n      status.between? 100, 199\n    end\n\n    # whether or not the status is set to 2xx\n    def success?\n      status.between? 200, 299\n    end\n\n    # whether or not the status is set to 3xx\n    def redirect?\n      status.between? 300, 399\n    end\n\n    # whether or not the status is set to 4xx\n    def client_error?\n      status.between? 400, 499\n    end\n\n    # whether or not the status is set to 5xx\n    def server_error?\n      status.between? 500, 599\n    end\n\n    # whether or not the status is set to 404\n    def not_found?\n      status == 404\n    end\n\n    # whether or not the status is set to 400\n    def bad_request?\n      status == 400\n    end\n\n    # Generates a Time object from the given value.\n    # Used by #expires and #last_modified.\n    def time_for(value)\n      if value.is_a? Numeric\n        Time.at value\n      elsif value.respond_to? :to_s\n        Time.parse value.to_s\n      else\n        value.to_time\n      end\n    rescue ArgumentError => e\n      raise e\n    rescue Exception\n      raise ArgumentError, \"unable to convert #{value.inspect} to a Time object\"\n    end\n\n    private\n\n    # Helper method checking if a ETag value list includes the current ETag.\n    def etag_matches?(list, new_resource = request.post?)\n      return !new_resource if list == '*'\n\n      list.to_s.split(/\\s*,\\s*/).include? response['ETag']\n    end\n\n    def with_params(temp_params)\n      original = @params\n      @params = temp_params\n      yield\n    ensure\n      @params = original if original\n    end\n  end\n\n  # Template rendering methods. Each method takes the name of a template\n  # to render as a Symbol and returns a String with the rendered output,\n  # as well as an optional hash with additional options.\n  #\n  # `template` is either the name or path of the template as symbol\n  # (Use `:'subdir/myview'` for views in subdirectories), or a string\n  # that will be rendered.\n  #\n  # Possible options are:\n  #   :content_type   The content type to use, same arguments as content_type.\n  #   :layout         If set to something falsy, no layout is rendered, otherwise\n  #                   the specified layout is used\n  #   :layout_engine  Engine to use for rendering the layout.\n  #   :locals         A hash with local variables that should be available\n  #                   in the template\n  #   :scope          If set, template is evaluate with the binding of the given\n  #                   object rather than the application instance.\n  #   :views          Views directory to use.\n  module Templates\n    module ContentTyped\n      attr_accessor :content_type\n    end\n\n    def initialize\n      super\n      @default_layout = :layout\n      @preferred_extension = nil\n    end\n\n    def erb(template, options = {}, locals = {}, &block)\n      render(:erb, template, options, locals, &block)\n    end\n\n    def haml(template, options = {}, locals = {}, &block)\n      render(:haml, template, options, locals, &block)\n    end\n\n    def builder(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:builder, template, options, locals, &block)\n    end\n\n    def liquid(template, options = {}, locals = {}, &block)\n      render(:liquid, template, options, locals, &block)\n    end\n\n    def markdown(template, options = {}, locals = {})\n      options[:exclude_outvar] = true\n      render :markdown, template, options, locals\n    end\n\n    def rdoc(template, options = {}, locals = {})\n      render :rdoc, template, options, locals\n    end\n\n    def asciidoc(template, options = {}, locals = {})\n      render :asciidoc, template, options, locals\n    end\n\n    def markaby(template = nil, options = {}, locals = {}, &block)\n      render_ruby(:mab, template, options, locals, &block)\n    end\n\n    def nokogiri(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:nokogiri, template, options, locals, &block)\n    end\n\n    def slim(template, options = {}, locals = {}, &block)\n      render(:slim, template, options, locals, &block)\n    end\n\n    def yajl(template, options = {}, locals = {})\n      options[:default_content_type] = :json\n      render :yajl, template, options, locals\n    end\n\n    def rabl(template, options = {}, locals = {})\n      Rabl.register!\n      render :rabl, template, options, locals\n    end\n\n    # Calls the given block for every possible template file in views,\n    # named name.ext, where ext is registered on engine.\n    def find_template(views, name, engine)\n      yield ::File.join(views, \"#{name}.#{@preferred_extension}\")\n\n      Tilt.default_mapping.extensions_for(engine).each do |ext|\n        yield ::File.join(views, \"#{name}.#{ext}\") unless ext == @preferred_extension\n      end\n    end\n\n    private\n\n    # logic shared between builder and nokogiri\n    def render_ruby(engine, template, options = {}, locals = {}, &block)\n      if template.is_a?(Hash)\n        options = template\n        template = nil\n      end\n      template = proc { block } if template.nil?\n      render engine, template, options, locals\n    end\n\n    def render(engine, data, options = {}, locals = {}, &block)\n      # merge app-level options\n      engine_options = settings.respond_to?(engine) ? settings.send(engine) : {}\n      options.merge!(engine_options) { |_key, v1, _v2| v1 }\n\n      # extract generic options\n      locals          = options.delete(:locals) || locals         || {}\n      views           = options.delete(:views)  || settings.views || './views'\n      layout          = options[:layout]\n      layout          = false if layout.nil? && options.include?(:layout)\n      eat_errors      = layout.nil?\n      layout          = engine_options[:layout] if layout.nil? || (layout == true && engine_options[:layout] != false)\n      layout          = @default_layout         if layout.nil? || (layout == true)\n      layout_options  = options.delete(:layout_options) || {}\n      content_type    = options.delete(:default_content_type)\n      content_type    = options.delete(:content_type)   || content_type\n      layout_engine   = options.delete(:layout_engine)  || engine\n      scope           = options.delete(:scope)          || self\n      exclude_outvar  = options.delete(:exclude_outvar)\n      options.delete(:layout)\n\n      # set some defaults\n      options[:outvar] ||= '@_out_buf' unless exclude_outvar\n      options[:default_encoding] ||= settings.default_encoding\n\n      # compile and render template\n      begin\n        layout_was      = @default_layout\n        @default_layout = false\n        template        = compile_template(engine, data, options, views)\n        output          = template.render(scope, locals, &block)\n      ensure\n        @default_layout = layout_was\n      end\n\n      # render layout\n      if layout\n        extra_options = { views: views, layout: false, eat_errors: eat_errors, scope: scope }\n        options = options.merge(extra_options).merge!(layout_options)\n\n        catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } }\n      end\n\n      output.extend(ContentTyped).content_type = content_type if content_type\n      output\n    end\n\n    def compile_template(engine, data, options, views)\n      eat_errors = options.delete :eat_errors\n      template = Tilt[engine]\n      raise \"Template engine not found: #{engine}\" if template.nil?\n\n      case data\n      when Symbol\n        template_cache.fetch engine, data, options, views do\n          body, path, line = settings.templates[data]\n          if body\n            body = body.call if body.respond_to?(:call)\n            template.new(path, line.to_i, options) { body }\n          else\n            found = false\n            @preferred_extension = engine.to_s\n            find_template(views, data, template) do |file|\n              path ||= file # keep the initial path rather than the last one\n              found = File.exist?(file)\n              if found\n                path = file\n                break\n              end\n            end\n            throw :layout_missing if eat_errors && !found\n            template.new(path, 1, options)\n          end\n        end\n      when Proc\n        compile_block_template(template, options, &data)\n      when String\n        template_cache.fetch engine, data, options, views do\n          compile_block_template(template, options) { data }\n        end\n      else\n        raise ArgumentError, \"Sorry, don't know how to render #{data.inspect}.\"\n      end\n    end\n\n    def compile_block_template(template, options, &body)\n      first_location = caller_locations.first\n      path = first_location.path\n      line = first_location.lineno\n      path = options[:path] || path\n      line = options[:line] || line\n      template.new(path, line.to_i, options, &body)\n    end\n  end\n\n  # Base class for all Sinatra applications and middleware.\n  class Base\n    include Rack::Utils\n    include Helpers\n    include Templates\n\n    URI_INSTANCE = URI::Parser.new\n\n    attr_accessor :app, :env, :request, :response, :params\n    attr_reader   :template_cache\n\n    def initialize(app = nil, **_kwargs)\n      super()\n      @app = app\n      @template_cache = Tilt::Cache.new\n      @pinned_response = nil # whether a before! filter pinned the content-type\n      yield self if block_given?\n    end\n\n    # Rack call interface.\n    def call(env)\n      dup.call!(env)\n    end\n\n    def call!(env) # :nodoc:\n      @env      = env\n      @params   = IndifferentHash.new\n      @request  = Request.new(env)\n      @response = Response.new\n      @pinned_response = nil\n      template_cache.clear if settings.reload_templates\n\n      invoke { dispatch! }\n      invoke { error_block!(response.status) } unless @env['sinatra.error']\n\n      unless @response['Content-Type']\n        if Array === body && body[0].respond_to?(:content_type)\n          content_type body[0].content_type\n        elsif (default = settings.default_content_type)\n          content_type default\n        end\n      end\n\n      @response.finish\n    end\n\n    # Access settings defined with Base.set.\n    def self.settings\n      self\n    end\n\n    # Access settings defined with Base.set.\n    def settings\n      self.class.settings\n    end\n\n    # Exit the current block, halts any further processing\n    # of the request, and returns the specified response.\n    def halt(*response)\n      response = response.first if response.length == 1\n      throw :halt, response\n    end\n\n    # Pass control to the next matching route.\n    # If there are no more matching routes, Sinatra will\n    # return a 404 response.\n    def pass(&block)\n      throw :pass, block\n    end\n\n    # Forward the request to the downstream app -- middleware only.\n    def forward\n      raise 'downstream app not set' unless @app.respond_to? :call\n\n      status, headers, body = @app.call env\n      @response.status = status\n      @response.body = body\n      @response.headers.merge! headers\n      nil\n    end\n\n    private\n\n    # Run filters defined on the class and all superclasses.\n    # Accepts an optional block to call after each filter is applied.\n    def filter!(type, base = settings, &block)\n      filter!(type, base.superclass, &block) if base.superclass.respond_to?(:filters)\n      base.filters[type].each do |args|\n        result = process_route(*args)\n        block.call(result) if block_given?\n      end\n    end\n\n    # Run routes defined on the class and all superclasses.\n    def route!(base = settings, pass_block = nil)\n      routes = base.routes[@request.request_method]\n\n      routes&.each do |pattern, conditions, block|\n        response.delete_header('Content-Type') unless @pinned_response\n\n        returned_pass_block = process_route(pattern, conditions) do |*args|\n          env['sinatra.route'] = \"#{@request.request_method} #{pattern}\"\n          route_eval { block[*args] }\n        end\n\n        # don't wipe out pass_block in superclass\n        pass_block = returned_pass_block if returned_pass_block\n      end\n\n      # Run routes defined in superclass.\n      if base.superclass.respond_to?(:routes)\n        return route!(base.superclass, pass_block)\n      end\n\n      route_eval(&pass_block) if pass_block\n      route_missing\n    end\n\n    # Run a route block and throw :halt with the result.\n    def route_eval\n      throw :halt, yield\n    end\n\n    # If the current request matches pattern and conditions, fill params\n    # with keys and call the given block.\n    # Revert params afterwards.\n    #\n    # Returns pass block.\n    def process_route(pattern, conditions, block = nil, values = [])\n      route = @request.path_info\n      route = '/' if route.empty? && !settings.empty_path_info?\n      route = route[0..-2] if !settings.strict_paths? && route != '/' && route.end_with?('/')\n\n      params = pattern.params(route)\n      return unless params\n\n      params.delete('ignore') # TODO: better params handling, maybe turn it into \"smart\" object or detect changes\n      force_encoding(params)\n      @params = @params.merge(params) { |_k, v1, v2| v2 || v1 } if params.any?\n\n      regexp_exists = pattern.is_a?(Mustermann::Regular) || (pattern.respond_to?(:patterns) && pattern.patterns.any? { |subpattern| subpattern.is_a?(Mustermann::Regular) })\n      if regexp_exists\n        captures           = pattern.match(route).captures.map { |c| URI_INSTANCE.unescape(c) if c }\n        values            += captures\n        @params[:captures] = force_encoding(captures) unless captures.nil? || captures.empty?\n      else\n        values += params.values.flatten\n      end\n\n      catch(:pass) do\n        conditions.each { |c| throw :pass if c.bind(self).call == false }\n        block ? block[self, values] : yield(self, values)\n      end\n    rescue StandardError\n      @env['sinatra.error.params'] = @params\n      raise\n    ensure\n      params ||= {}\n      params.each { |k, _| @params.delete(k) } unless @env['sinatra.error.params']\n    end\n\n    # No matching route was found or all routes passed. The default\n    # implementation is to forward the request downstream when running\n    # as middleware (@app is non-nil); when no downstream app is set, raise\n    # a NotFound exception. Subclasses can override this method to perform\n    # custom route miss logic.\n    def route_missing\n      raise NotFound unless @app\n\n      forward\n    end\n\n    # Attempt to serve static files from public directory. Throws :halt when\n    # a matching file is found, returns nil otherwise.\n    def static!(options = {})\n      return if (public_dir = settings.public_folder).nil?\n\n      path = \"#{public_dir}#{URI_INSTANCE.unescape(request.path_info)}\"\n      return unless valid_path?(path)\n\n      path = File.expand_path(path)\n      return unless path.start_with?(\"#{File.expand_path(public_dir)}/\")\n\n      return unless File.file?(path)\n\n      env['sinatra.static_file'] = path\n      cache_control(*settings.static_cache_control) if settings.static_cache_control?\n      send_file path, options.merge(disposition: nil)\n    end\n\n    # Run the block with 'throw :halt' support and apply result to the response.\n    def invoke(&block)\n      res = catch(:halt, &block)\n\n      res = [res] if (Integer === res) || (String === res)\n      if (Array === res) && (Integer === res.first)\n        res = res.dup\n        status(res.shift)\n        body(res.pop)\n        headers(*res)\n      elsif res.respond_to? :each\n        body res\n      end\n      nil # avoid double setting the same response tuple twice\n    end\n\n    # Dispatch a request with error handling.\n    def dispatch!\n      # Avoid passing frozen string in force_encoding\n      @params.merge!(@request.params).each do |key, val|\n        next unless val.respond_to?(:force_encoding)\n\n        val = val.dup if val.frozen?\n        @params[key] = force_encoding(val)\n      end\n\n      invoke do\n        static! if settings.static? && (request.get? || request.head?)\n        filter! :before do\n          @pinned_response = !response['Content-Type'].nil?\n        end\n        route!\n      end\n    rescue ::Exception => e\n      invoke { handle_exception!(e) }\n    ensure\n      begin\n        filter! :after unless env['sinatra.static_file']\n      rescue ::Exception => e\n        invoke { handle_exception!(e) } unless @env['sinatra.error']\n      end\n    end\n\n    # Error handling during requests.\n    def handle_exception!(boom)\n      error_params = @env['sinatra.error.params']\n\n      @params = @params.merge(error_params) if error_params\n\n      @env['sinatra.error'] = boom\n\n      http_status = if boom.is_a? Sinatra::Error\n                      if boom.respond_to? :http_status\n                        boom.http_status\n                      elsif settings.use_code? && boom.respond_to?(:code)\n                        boom.code\n                      end\n                    end\n\n      http_status = 500 unless http_status&.between?(400, 599)\n      status(http_status)\n\n      if server_error?\n        dump_errors! boom if settings.dump_errors?\n        raise boom if settings.show_exceptions? && (settings.show_exceptions != :after_handler)\n      elsif not_found?\n        headers['X-Cascade'] = 'pass' if settings.x_cascade?\n      end\n\n      if (res = error_block!(boom.class, boom) || error_block!(status, boom))\n        return res\n      end\n\n      if not_found? || bad_request?\n        if boom.message && boom.message != boom.class.name\n          body Rack::Utils.escape_html(boom.message)\n        else\n          content_type 'text/html'\n          body \"<h1>#{not_found? ? 'Not Found' : 'Bad Request'}</h1>\"\n        end\n      end\n\n      return unless server_error?\n\n      raise boom if settings.raise_errors? || settings.show_exceptions?\n\n      error_block! Exception, boom\n    end\n\n    # Find an custom error block for the key(s) specified.\n    def error_block!(key, *block_params)\n      base = settings\n      while base.respond_to?(:errors)\n        args_array = base.errors[key]\n\n        next base = base.superclass unless args_array\n\n        args_array.reverse_each do |args|\n          first = args == args_array.first\n          args += [block_params]\n          resp = process_route(*args)\n          return resp unless resp.nil? && !first\n        end\n      end\n      return false unless key.respond_to?(:superclass) && (key.superclass < Exception)\n\n      error_block!(key.superclass, *block_params)\n    end\n\n    def dump_errors!(boom)\n      msg = [\"#{Time.now.strftime('%Y-%m-%d %H:%M:%S')} - #{boom.class} - #{boom.message}:\", *boom.backtrace].join(\"\\n\\t\")\n      @env['rack.errors'].puts(msg)\n    end\n\n    class << self\n      CALLERS_TO_IGNORE = [ # :nodoc:\n        %r{/sinatra(/(base|main|show_exceptions))?\\.rb$},   # all sinatra code\n        %r{lib/tilt.*\\.rb$},                                # all tilt code\n        /^\\(.*\\)$/,                                         # generated code\n        %r{rubygems/(custom|core_ext/kernel)_require\\.rb$}, # rubygems require hacks\n        /active_support/,                                   # active_support require hacks\n        %r{bundler(/(?:runtime|inline))?\\.rb},              # bundler require hacks\n        /<internal:/                                        # internal in ruby >= 1.9.2\n      ].freeze\n\n      attr_reader :routes, :filters, :templates, :errors\n\n      # Removes all routes, filters, middleware and extension hooks from the\n      # current class (not routes/filters/... defined by its superclass).\n      def reset!\n        @conditions     = []\n        @routes         = {}\n        @filters        = { before: [], after: [] }\n        @errors         = {}\n        @middleware     = []\n        @prototype      = nil\n        @extensions     = []\n\n        @templates = if superclass.respond_to?(:templates)\n                       Hash.new { |_hash, key| superclass.templates[key] }\n                     else\n                       {}\n                     end\n      end\n\n      # Extension modules registered on this class and all superclasses.\n      def extensions\n        if superclass.respond_to?(:extensions)\n          (@extensions + superclass.extensions).uniq\n        else\n          @extensions\n        end\n      end\n\n      # Middleware used in this class and all superclasses.\n      def middleware\n        if superclass.respond_to?(:middleware)\n          superclass.middleware + @middleware\n        else\n          @middleware\n        end\n      end\n\n      # Sets an option to the given value.  If the value is a proc,\n      # the proc will be called every time the option is accessed.\n      def set(option, value = (not_set = true), ignore_setter = false, &block)\n        raise ArgumentError if block && !not_set\n\n        if block\n          value = block\n          not_set = false\n        end\n\n        if not_set\n          raise ArgumentError unless option.respond_to?(:each)\n\n          option.each { |k, v| set(k, v) }\n          return self\n        end\n\n        if respond_to?(\"#{option}=\") && !ignore_setter\n          return __send__(\"#{option}=\", value)\n        end\n\n        setter = proc { |val| set option, val, true }\n        getter = proc { value }\n\n        case value\n        when Proc\n          getter = value\n        when Symbol, Integer, FalseClass, TrueClass, NilClass\n          getter = value.inspect\n        when Hash\n          setter = proc do |val|\n            val = value.merge val if Hash === val\n            set option, val, true\n          end\n        end\n\n        define_singleton(\"#{option}=\", setter)\n        define_singleton(option, getter)\n        define_singleton(\"#{option}?\", \"!!#{option}\") unless method_defined? \"#{option}?\"\n        self\n      end\n\n      # Same as calling `set :option, true` for each of the given options.\n      def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end\n\n      # Same as calling `set :option, false` for each of the given options.\n      def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end\n\n      # Define a custom error handler. Optionally takes either an Exception\n      # class, or an HTTP status code to specify which errors should be\n      # handled.\n      def error(*codes, &block)\n        args  = compile! 'ERROR', /.*/, block\n        codes = codes.flat_map(&method(:Array))\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n        codes.each { |c| (@errors[c] ||= []) << args }\n      end\n\n      # Sugar for `error(404) { ... }`\n      def not_found(&block)\n        error(404, &block)\n      end\n\n      # Define a named template. The block must return the template source.\n      def template(name, &block)\n        filename, line = caller_locations.first\n        templates[name] = [block, filename, line.to_i]\n      end\n\n      # Define the layout template. The block must return the template source.\n      def layout(name = :layout, &block)\n        template name, &block\n      end\n\n      # Load embedded templates from the file; uses the caller's __FILE__\n      # when no file is specified.\n      def inline_templates=(file = nil)\n        file = (caller_files.first || File.expand_path($0)) if file.nil? || file == true\n\n        begin\n          io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file)\n          app, data = io.gsub(\"\\r\\n\", \"\\n\").split(/^__END__$/, 2)\n        rescue Errno::ENOENT\n          app, data = nil\n        end\n\n        return unless data\n\n        encoding = if app && app =~ /([^\\n]*\\n)?#[^\\n]*coding: *(\\S+)/m\n                     $2\n                   else\n                     settings.default_encoding\n                   end\n\n        lines = app.count(\"\\n\") + 1\n        template = nil\n        force_encoding data, encoding\n        data.each_line do |line|\n          lines += 1\n          if line =~ /^@@\\s*(.*\\S)\\s*$/\n            template = force_encoding(String.new, encoding)\n            templates[$1.to_sym] = [template, file, lines]\n          elsif template\n            template << line\n          end\n        end\n      end\n\n      # Lookup or register a mime type in Rack's mime registry.\n      def mime_type(type, value = nil)\n        return type      if type.nil?\n        return type.to_s if type.to_s.include?('/')\n\n        type = \".#{type}\" unless type.to_s[0] == '.'\n        return Rack::Mime.mime_type(type, nil) unless value\n\n        Rack::Mime::MIME_TYPES[type] = value\n      end\n\n      # provides all mime types matching type, including deprecated types:\n      #   mime_types :html # => ['text/html']\n      #   mime_types :js   # => ['application/javascript', 'text/javascript']\n      def mime_types(type)\n        type = mime_type type\n        type =~ %r{^application/(xml|javascript)$} ? [type, \"text/#{$1}\"] : [type]\n      end\n\n      # Define a before filter; runs before all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def before(path = /.*/, **options, &block)\n        add_filter(:before, path, **options, &block)\n      end\n\n      # Define an after filter; runs after all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def after(path = /.*/, **options, &block)\n        add_filter(:after, path, **options, &block)\n      end\n\n      # add a filter\n      def add_filter(type, path = /.*/, **options, &block)\n        filters[type] << compile!(type, path, block, **options)\n      end\n\n      # Add a route condition. The route is considered non-matching when the\n      # block returns false.\n      def condition(name = \"#{caller.first[/`.*'/]} condition\", &block)\n        @conditions << generate_method(name, &block)\n      end\n\n      def public=(value)\n        warn_for_deprecation ':public is no longer used to avoid overloading Module#public, use :public_folder or :public_dir instead'\n        set(:public_folder, value)\n      end\n\n      def public_dir=(value)\n        self.public_folder = value\n      end\n\n      def public_dir\n        public_folder\n      end\n\n      # Defining a `GET` handler also automatically defines\n      # a `HEAD` handler.\n      def get(path, opts = {}, &block)\n        conditions = @conditions.dup\n        route('GET', path, opts, &block)\n\n        @conditions = conditions\n        route('HEAD', path, opts, &block)\n      end\n\n      def put(path, opts = {}, &block)     route 'PUT',     path, opts, &block end\n\n      def post(path, opts = {}, &block)    route 'POST',    path, opts, &block end\n\n      def delete(path, opts = {}, &block)  route 'DELETE',  path, opts, &block end\n\n      def head(path, opts = {}, &block)    route 'HEAD',    path, opts, &block end\n\n      def options(path, opts = {}, &block) route 'OPTIONS', path, opts, &block end\n\n      def patch(path, opts = {}, &block)   route 'PATCH',   path, opts, &block end\n\n      def link(path, opts = {}, &block)    route 'LINK',    path, opts, &block end\n\n      def unlink(path, opts = {}, &block)  route 'UNLINK',  path, opts, &block end\n\n      # Makes the methods defined in the block and in the Modules given\n      # in `extensions` available to the handlers and templates\n      def helpers(*extensions, &block)\n        class_eval(&block)   if block_given?\n        include(*extensions) if extensions.any?\n      end\n\n      # Register an extension. Alternatively take a block from which an\n      # extension will be created and registered on the fly.\n      def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end\n\n      def development?; environment == :development end\n      def production?;  environment == :production  end\n      def test?;        environment == :test        end\n\n      # Set configuration options for Sinatra and/or the app.\n      # Allows scoping of settings for certain environments.\n      def configure(*envs)\n        yield self if envs.empty? || envs.include?(environment.to_sym)\n      end\n\n      # Use the specified Rack middleware\n      def use(middleware, *args, &block)\n        @prototype = nil\n        @middleware << [middleware, args, block]\n      end\n      ruby2_keywords(:use) if respond_to?(:ruby2_keywords, true)\n\n      # Stop the self-hosted server if running.\n      def quit!\n        return unless running?\n\n        # Use Thin's hard #stop! if available, otherwise just #stop.\n        running_server.respond_to?(:stop!) ? running_server.stop! : running_server.stop\n        warn '== Sinatra has ended his set (crowd applauds)' unless suppress_messages?\n        set :running_server, nil\n        set :handler_name, nil\n      end\n\n      alias stop! quit!\n\n      # Run the Sinatra app as a self-hosted server using\n      # Puma, Falcon, Mongrel, or WEBrick (in that order). If given a block, will call\n      # with the constructed handler once we have taken the stage.\n      def run!(options = {}, &block)\n        return if running?\n\n        set options\n        handler         = Rack::Handler.pick(server)\n        handler_name    = handler.name.gsub(/.*::/, '')\n        server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {}\n        server_settings.merge!(Port: port, Host: bind)\n\n        begin\n          start_server(handler, server_settings, handler_name, &block)\n        rescue Errno::EADDRINUSE\n          warn \"== Someone is already performing on port #{port}!\"\n          raise\n        ensure\n          quit!\n        end\n      end\n\n      alias start! run!\n\n      # Check whether the self-hosted server is running or not.\n      def running?\n        running_server?\n      end\n\n      # The prototype instance used to process requests.\n      def prototype\n        @prototype ||= new\n      end\n\n      # Create a new instance without middleware in front of it.\n      alias new! new unless method_defined? :new!\n\n      # Create a new instance of the class fronted by its middleware\n      # pipeline. The object is guaranteed to respond to #call but may not be\n      # an instance of the class new was called on.\n      def new(*args, &block)\n        instance = new!(*args, &block)\n        Wrapper.new(build(instance).to_app, instance)\n      end\n      ruby2_keywords :new if respond_to?(:ruby2_keywords, true)\n\n      # Creates a Rack::Builder instance with all the middleware set up and\n      # the given +app+ as end point.\n      def build(app)\n        builder = Rack::Builder.new\n        setup_default_middleware builder\n        setup_middleware builder\n        builder.run app\n        builder\n      end\n\n      def call(env)\n        synchronize { prototype.call(env) }\n      end\n\n      # Like Kernel#caller but excluding certain magic entries and without\n      # line / method information; the resulting array contains filenames only.\n      def caller_files\n        cleaned_caller(1).flatten\n      end\n\n      private\n\n      # Starts the server by running the Rack Handler.\n      def start_server(handler, server_settings, handler_name)\n        # Ensure we initialize middleware before startup, to match standard Rack\n        # behavior, by ensuring an instance exists:\n        prototype\n        # Run the instance we created:\n        handler.run(self, **server_settings) do |server|\n          unless suppress_messages?\n            warn \"== Sinatra (v#{Sinatra::VERSION}) has taken the stage on #{port} for #{environment} with backup from #{handler_name}\"\n          end\n\n          setup_traps\n          set :running_server, server\n          set :handler_name,   handler_name\n          server.threaded = settings.threaded if server.respond_to? :threaded=\n\n          yield server if block_given?\n        end\n      end\n\n      def suppress_messages?\n        handler_name =~ /cgi/i || quiet\n      end\n\n      def setup_traps\n        return unless traps?\n\n        at_exit { quit! }\n\n        %i[INT TERM].each do |signal|\n          old_handler = trap(signal) do\n            quit!\n            old_handler.call if old_handler.respond_to?(:call)\n          end\n        end\n\n        set :traps, false\n      end\n\n      # Dynamically defines a method on settings.\n      def define_singleton(name, content = Proc.new)\n        singleton_class.class_eval do\n          undef_method(name) if method_defined? name\n          String === content ? class_eval(\"def #{name}() #{content}; end\") : define_method(name, &content)\n        end\n      end\n\n      # Condition for matching host name. Parameter might be String or Regexp.\n      def host_name(pattern)\n        condition { pattern === request.host }\n      end\n\n      # Condition for matching user agent. Parameter should be Regexp.\n      # Will set params[:agent].\n      def user_agent(pattern)\n        condition do\n          if request.user_agent.to_s =~ pattern\n            @params[:agent] = $~[1..-1]\n            true\n          else\n            false\n          end\n        end\n      end\n      alias agent user_agent\n\n      # Condition for matching mimetypes. Accepts file extensions.\n      def provides(*types)\n        types.map! { |t| mime_types(t) }\n        types.flatten!\n        condition do\n          response_content_type = response['Content-Type']\n          preferred_type = request.preferred_type(types)\n\n          if response_content_type\n            types.include?(response_content_type) || types.include?(response_content_type[/^[^;]+/])\n          elsif preferred_type\n            params = (preferred_type.respond_to?(:params) ? preferred_type.params : {})\n            content_type(preferred_type, params)\n            true\n          else\n            false\n          end\n        end\n      end\n\n      def route(verb, path, options = {}, &block)\n        enable :empty_path_info if path == '' && empty_path_info.nil?\n        signature = compile!(verb, path, block, **options)\n        (@routes[verb] ||= []) << signature\n        invoke_hook(:route_added, verb, path, block)\n        signature\n      end\n\n      def invoke_hook(name, *args)\n        extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end\n\n      def generate_method(method_name, &block)\n        define_method(method_name, &block)\n        method = instance_method method_name\n        remove_method method_name\n        method\n      end\n\n      def compile!(verb, path, block, **options)\n        # Because of self.options.host\n        host_name(options.delete(:host)) if options.key?(:host)\n        # Pass Mustermann opts to compile()\n        route_mustermann_opts = options.key?(:mustermann_opts) ? options.delete(:mustermann_opts) : {}.freeze\n\n        options.each_pair { |option, args| send(option, *args) }\n\n        pattern                 = compile(path, route_mustermann_opts)\n        method_name             = \"#{verb} #{path}\"\n        unbound_method          = generate_method(method_name, &block)\n        conditions = @conditions\n        @conditions = []\n        wrapper = block.arity.zero? ?\n          proc { |a, _p| unbound_method.bind(a).call } :\n          proc { |a, p| unbound_method.bind(a).call(*p) }\n\n        [pattern, conditions, wrapper]\n      end\n\n      def compile(path, route_mustermann_opts = {})\n        Mustermann.new(path, **mustermann_opts.merge(route_mustermann_opts))\n      end\n\n      def setup_default_middleware(builder)\n        builder.use ExtendedRack\n        builder.use ShowExceptions       if show_exceptions?\n        builder.use Rack::MethodOverride if method_override?\n        builder.use Rack::Head\n        setup_logging    builder\n        setup_sessions   builder\n        setup_protection builder\n      end\n\n      def setup_middleware(builder)\n        middleware.each { |c, a, b| builder.use(c, *a, &b) }\n      end\n\n      def setup_logging(builder)\n        if logging?\n          setup_common_logger(builder)\n          setup_custom_logger(builder)\n        elsif logging == false\n          setup_null_logger(builder)\n        end\n      end\n\n      def setup_null_logger(builder)\n        builder.use Rack::NullLogger\n      end\n\n      def setup_common_logger(builder)\n        builder.use Sinatra::CommonLogger\n      end\n\n      def setup_custom_logger(builder)\n        if logging.respond_to? :to_int\n          builder.use Rack::Logger, logging\n        else\n          builder.use Rack::Logger\n        end\n      end\n\n      def setup_protection(builder)\n        return unless protection?\n\n        options = Hash === protection ? protection.dup : {}\n        options = {\n          img_src: \"'self' data:\",\n          font_src: \"'self'\"\n        }.merge options\n\n        protect_session = options.fetch(:session) { sessions? }\n        options[:without_session] = !protect_session\n\n        options[:reaction] ||= :drop_session\n\n        builder.use Rack::Protection, options\n      end\n\n      def setup_sessions(builder)\n        return unless sessions?\n\n        options = {}\n        options[:secret] = session_secret if session_secret?\n        options.merge! sessions.to_hash if sessions.respond_to? :to_hash\n        builder.use session_store, options\n      end\n\n      def inherited(subclass)\n        subclass.reset!\n        subclass.set :app_file, caller_files.first unless subclass.app_file?\n        super\n      end\n\n      @@mutex = Mutex.new\n      def synchronize(&block)\n        if lock?\n          @@mutex.synchronize(&block)\n        else\n          yield\n        end\n      end\n\n      # used for deprecation warnings\n      def warn_for_deprecation(message)\n        warn message + \"\\n\\tfrom #{cleaned_caller.first.join(':')}\"\n      end\n\n      # Like Kernel#caller but excluding certain magic entries\n      def cleaned_caller(keep = 3)\n        caller(1)\n          .map! { |line| line.split(/:(?=\\d|in )/, 3)[0, keep] }\n          .reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } }\n      end\n    end\n\n    # Force data to specified encoding. It defaults to settings.default_encoding\n    # which is UTF-8 by default\n    def self.force_encoding(data, encoding = default_encoding)\n      return if data == settings || data.is_a?(Tempfile)\n\n      if data.respond_to? :force_encoding\n        data.force_encoding(encoding).encode!\n      elsif data.respond_to? :each_value\n        data.each_value { |v| force_encoding(v, encoding) }\n      elsif data.respond_to? :each\n        data.each { |v| force_encoding(v, encoding) }\n      end\n      data\n    end\n\n    def force_encoding(*args)\n      settings.force_encoding(*args)\n    end\n\n    reset!\n\n    set :environment, (ENV['APP_ENV'] || ENV['RACK_ENV'] || :development).to_sym\n    set :raise_errors, proc { test? }\n    set :dump_errors, proc { !test? }\n    set :show_exceptions, proc { development? }\n    set :sessions, false\n    set :session_store, Rack::Protection::EncryptedCookie\n    set :logging, false\n    set :protection, true\n    set :method_override, false\n    set :use_code, false\n    set :default_encoding, 'utf-8'\n    set :x_cascade, true\n    set :add_charset, %w[javascript xml xhtml+xml].map { |t| \"application/#{t}\" }\n    settings.add_charset << %r{^text/}\n    set :mustermann_opts, {}\n    set :default_content_type, 'text/html'\n\n    # explicitly generating a session secret eagerly to play nice with preforking\n    begin\n      require 'securerandom'\n      set :session_secret, SecureRandom.hex(64)\n    rescue LoadError, NotImplementedError\n      # SecureRandom raises a NotImplementedError if no random device is available\n      set :session_secret, format('%064x', Kernel.rand((2**256) - 1))\n    end\n\n    class << self\n      alias methodoverride? method_override?\n      alias methodoverride= method_override=\n    end\n\n    set :run, false                       # start server via at-exit hook?\n    set :running_server, nil\n    set :handler_name, nil\n    set :traps, true\n    set :server, %w[HTTP webrick]\n    set :bind, proc { development? ? 'localhost' : '0.0.0.0' }\n    set :port, Integer(ENV['PORT'] && !ENV['PORT'].empty? ? ENV['PORT'] : 4567)\n    set :quiet, false\n\n    ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE\n\n    server.unshift 'puma'\n    server.unshift 'falcon'   if ruby_engine != 'jruby'\n    server.unshift 'mongrel'  if ruby_engine.nil?\n    server.unshift 'thin'     if ruby_engine != 'jruby'\n    server.unshift 'trinidad' if ruby_engine == 'jruby'\n\n    set :absolute_redirects, true\n    set :prefixed_redirects, false\n    set :empty_path_info, nil\n    set :strict_paths, true\n\n    set :app_file, nil\n    set :root, proc { app_file && File.expand_path(File.dirname(app_file)) }\n    set :views, proc { root && File.join(root, 'views') }\n    set :reload_templates, proc { development? }\n    set :lock, false\n    set :threaded, true\n\n    set :public_folder, proc { root && File.join(root, 'public') }\n    set :static, proc { public_folder && File.exist?(public_folder) }\n    set :static_cache_control, false\n\n    error ::Exception do\n      response.status = 500\n      content_type 'text/html'\n      '<h1>Internal Server Error</h1>'\n    end\n\n    configure :development do\n      get '/__sinatra__/:image.png' do\n        filename = __dir__ + \"/images/#{params[:image].to_i}.png\"\n        content_type :png\n        send_file filename\n      end\n\n      error NotFound do\n        content_type 'text/html'\n\n        if instance_of?(Sinatra::Application)\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            #{request.request_method.downcase} '#{request.path_info}' do\n              \"Hello World\"\n            end\n          RUBY\n        else\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            class #{self.class}\n              #{request.request_method.downcase} '#{request.path_info}' do\n                \"Hello World\"\n              end\n            end\n          RUBY\n\n          file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(%r{^/}, '')\n          code = \"# in #{file}\\n#{code}\" unless file.empty?\n        end\n\n        <<-HTML.gsub(/^ {10}/, '')\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <style type=\"text/css\">\n            body { text-align:center;font-family:helvetica,arial;font-size:22px;\n              color:#888;margin:20px}\n            #c {margin:0 auto;width:500px;text-align:left}\n            </style>\n          </head>\n          <body>\n            <h2>Sinatra doesn\u2019t know this ditty.</h2>\n            <img src='#{uri '/__sinatra__/404.png'}'>\n            <div id=\"c\">\n              Try this:\n              <pre>#{Rack::Utils.escape_html(code)}</pre>\n            </div>\n          </body>\n          </html>\n        HTML\n      end\n    end\n  end\n\n  # Execution context for classic style (top-level) applications. All\n  # DSL methods executed on main are delegated to this class.\n  #\n  # The Application class should not be subclassed, unless you want to\n  # inherit all settings, routes, handlers, and error pages from the\n  # top-level. Subclassing Sinatra::Base is highly recommended for\n  # modular applications.\n  class Application < Base\n    set :logging, proc { !test? }\n    set :method_override, true\n    set :run, proc { !test? }\n    set :app_file, nil\n\n    def self.register(*extensions, &block) # :nodoc:\n      added_methods = extensions.flat_map(&:public_instance_methods)\n      Delegator.delegate(*added_methods)\n      super(*extensions, &block)\n    end\n  end\n\n  # Sinatra delegation mixin. Mixing this module into an object causes all\n  # methods to be delegated to the Sinatra::Application class. Used primarily\n  # at the top-level.\n  module Delegator # :nodoc:\n    def self.delegate(*methods)\n      methods.each do |method_name|\n        define_method(method_name) do |*args, &block|\n          return super(*args, &block) if respond_to? method_name\n\n          Delegator.target.send(method_name, *args, &block)\n        end\n        # ensure keyword argument passing is compatible with ruby >= 2.7\n        ruby2_keywords(method_name) if respond_to?(:ruby2_keywords, true)\n        private method_name\n      end\n    end\n\n    delegate :get, :patch, :put, :post, :delete, :head, :options, :link, :unlink,\n             :template, :layout, :before, :after, :error, :not_found, :configure,\n             :set, :mime_type, :enable, :disable, :use, :development?, :test?,\n             :production?, :helpers, :settings, :register\n\n    class << self\n      attr_accessor :target\n    end\n\n    self.target = Application\n  end\n\n  class Wrapper\n    def initialize(stack, instance)\n      @stack = stack\n      @instance = instance\n    end\n\n    def settings\n      @instance.settings\n    end\n\n    def helpers\n      @instance\n    end\n\n    def call(env)\n      @stack.call(env)\n    end\n\n    def inspect\n      \"#<#{@instance.class} app_file=#{settings.app_file.inspect}>\"\n    end\n  end\n\n  # Create a new Sinatra application; the block is evaluated in the class scope.\n  def self.new(base = Base, &block)\n    base = Class.new(base)\n    base.class_eval(&block) if block_given?\n    base\n  end\n\n  # Extend the top-level DSL with the modules provided.\n  def self.register(*extensions, &block)\n    Delegator.target.register(*extensions, &block)\n  end\n\n  # Include the helper modules provided in Sinatra's request context.\n  def self.helpers(*extensions, &block)\n    Delegator.target.helpers(*extensions, &block)\n  end\n\n  # Use the middleware for classic applications.\n  def self.use(*args, &block)\n    Delegator.target.use(*args, &block)\n  end\nend\n", "require File.expand_path('helper', __dir__)\nrequire 'date'\nrequire 'json'\n\nclass HelpersTest < Minitest::Test\n  def test_default\n    assert true\n  end\n\n  def status_app(code, &block)\n    code += 2 if [204, 304].include? code\n    block ||= proc { }\n    mock_app do\n      get('/') do\n        status code\n        instance_eval(&block).inspect\n      end\n    end\n    get '/'\n  end\n\n  describe 'status' do\n    it 'sets the response status code' do\n      status_app 207\n      assert_equal 207, response.status\n    end\n  end\n\n  describe 'bad_request?' do\n    it 'is true for status == 400' do\n      status_app(400) { bad_request? }\n      assert_body 'true'\n    end\n\n    it 'is false for status gt 400' do\n      status_app(401) { bad_request? }\n      assert_body 'false'\n    end\n\n    it 'is false for status lt 400' do\n      status_app(399) { bad_request? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'not_found?' do\n    it 'is true for status == 404' do\n      status_app(404) { not_found? }\n      assert_body 'true'\n    end\n\n    it 'is false for status gt 404' do\n      status_app(405) { not_found? }\n      assert_body 'false'\n    end\n\n    it 'is false for status lt 404' do\n      status_app(403) { not_found? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'informational?' do\n    it 'is true for 1xx status' do\n      status_app(100 + rand(100)) { informational? }\n      assert_body 'true'\n    end\n\n    it 'is false for status > 199' do\n      status_app(200 + rand(400)) { informational? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'success?' do\n    it 'is true for 2xx status' do\n      status_app(200 + rand(100)) { success? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 200' do\n      status_app(100 + rand(100)) { success? }\n      assert_body 'false'\n    end\n\n    it 'is false for status > 299' do\n      status_app(300 + rand(300)) { success? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'redirect?' do\n    it 'is true for 3xx status' do\n      status_app(300 + rand(100)) { redirect? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 300' do\n      status_app(200 + rand(100)) { redirect? }\n      assert_body 'false'\n    end\n\n    it 'is false for status > 399' do\n      status_app(400 + rand(200)) { redirect? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'client_error?' do\n    it 'is true for 4xx status' do\n      status_app(400 + rand(100)) { client_error? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 400' do\n      status_app(200 + rand(200)) { client_error? }\n      assert_body 'false'\n    end\n\n    it 'is false for status > 499' do\n      status_app(500 + rand(100)) { client_error? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'server_error?' do\n    it 'is true for 5xx status' do\n      status_app(500 + rand(100)) { server_error? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 500' do\n      status_app(200 + rand(300)) { server_error? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'body' do\n    it 'takes a block for deferred body generation' do\n      mock_app do\n        get('/') { body { 'Hello World' } }\n      end\n\n      get '/'\n      assert_equal 'Hello World', body\n    end\n\n    it 'takes a String, Array, or other object responding to #each' do\n      mock_app { get('/') { body 'Hello World' } }\n\n      get '/'\n      assert_equal 'Hello World', body\n    end\n\n    it 'can be used with other objects' do\n      mock_app do\n        get '/' do\n          body :hello => 'from json'\n        end\n\n        after do\n          if Hash === response.body\n            body response.body[:hello]\n          end\n        end\n      end\n\n      get '/'\n      assert_body 'from json'\n    end\n\n    it 'can be set in after filter' do\n      mock_app do\n        get('/') { body 'route'  }\n        after    { body 'filter' }\n      end\n\n      get '/'\n      assert_body 'filter'\n    end\n  end\n\n  describe 'redirect' do\n    it 'uses a 302 when only a path is given' do\n      mock_app do\n        get('/') do\n          redirect '/foo'\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://example.org/foo', response['Location']\n    end\n\n    it 'uses the code given when specified' do\n      mock_app do\n        get('/') do\n          redirect '/foo', 301\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 301, status\n      assert_equal '', body\n      assert_equal 'http://example.org/foo', response['Location']\n    end\n\n    it 'redirects back to request.referer when passed back' do\n      mock_app { get('/try_redirect') { redirect back } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/try_redirect', 'HTTP_REFERER' => '/foo')\n      assert_equal 302, response.status\n      assert_equal 'http://example.org/foo', response['Location']\n    end\n\n    it 'redirects using a non-standard HTTP port' do\n      mock_app { get('/') { redirect '/foo' } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/', 'SERVER_PORT' => '81')\n      assert_equal 'http://example.org:81/foo', response['Location']\n    end\n\n    it 'redirects using a non-standard HTTPS port' do\n      mock_app { get('/') { redirect '/foo' } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/', 'SERVER_PORT' => '444')\n      assert_equal 'http://example.org:444/foo', response['Location']\n    end\n\n    it 'uses 303 for post requests if request is HTTP 1.1' do\n      mock_app { post('/') { redirect '/'} }\n      post('/', {}, 'HTTP_VERSION' => 'HTTP/1.1')\n      assert_equal 303, status\n      assert_equal '', body\n      assert_equal 'http://example.org/', response['Location']\n    end\n\n    it 'uses 302 for post requests if request is HTTP 1.0' do\n      mock_app { post('/') { redirect '/'} }\n      post('/', {}, 'HTTP_VERSION' => 'HTTP/1.0')\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://example.org/', response['Location']\n    end\n\n    it 'works behind a reverse proxy' do\n      mock_app { get('/') { redirect '/foo' } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/', 'HTTP_X_FORWARDED_HOST' => 'example.com', 'SERVER_PORT' => '8080')\n      assert_equal 'http://example.com/foo', response['Location']\n    end\n\n    it 'accepts absolute URIs' do\n      mock_app do\n        get('/') do\n          redirect 'http://google.com'\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://google.com', response['Location']\n    end\n\n    it 'accepts absolute URIs with a different schema' do\n      mock_app do\n        get('/') do\n          redirect 'mailto:jsmith@example.com'\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'mailto:jsmith@example.com', response['Location']\n    end\n\n    it 'accepts a URI object instead of a String' do\n      mock_app do\n        get('/') { redirect URI.parse('http://sinatrarb.com') }\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://sinatrarb.com', response['Location']\n    end\n  end\n\n  describe 'error' do\n    it 'sets a status code and halts' do\n      mock_app do\n        get('/') do\n          error 501\n          fail 'error should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 501, status\n      assert_equal '', body\n    end\n\n    it 'takes an optional body' do\n      mock_app do\n        get('/') do\n          error 501, 'FAIL'\n          fail 'error should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 501, status\n      assert_equal 'FAIL', body\n    end\n\n    it 'should not invoke error handler when setting status inside an error handler' do\n      mock_app do\n        disable :raise_errors\n        not_found do\n          body \"not_found handler\"\n          status 404\n        end\n\n        error do\n          body \"error handler\"\n          status 404\n        end\n\n        get '/' do\n          raise\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal 'error handler', body\n    end\n\n    it 'should not reset the content-type to html for error handlers' do\n      mock_app do\n        disable :raise_errors\n        before    { content_type \"application/json\" }\n        not_found { JSON.dump(\"error\" => \"Not Found\") }\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal 'application/json', response.content_type\n    end\n\n    it 'should not invoke error handler when halting with 500 inside an error handler' do\n      mock_app do\n        disable :raise_errors\n        not_found do\n          body \"not_found handler\"\n          halt 404\n        end\n\n        error do\n          body \"error handler\"\n          halt 404\n        end\n\n        get '/' do\n          raise\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal 'error handler', body\n    end\n\n    it 'should not invoke not_found handler when halting with 404 inside a not found handler' do\n      mock_app do\n        disable :raise_errors\n\n        not_found do\n          body \"not_found handler\"\n          halt 500\n        end\n\n        error do\n          body \"error handler\"\n          halt 500\n        end\n      end\n\n      get '/'\n      assert_equal 500, status\n      assert_equal 'not_found handler', body\n    end\n\n    it 'uses a 500 status code when first argument is a body' do\n      mock_app do\n        get('/') do\n          error 'FAIL'\n          fail 'error should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 500, status\n      assert_equal 'FAIL', body\n    end\n  end\n\n  describe 'not_found' do\n    it 'halts with a 404 status' do\n      mock_app do\n        get('/') do\n          not_found\n          fail 'not_found should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal '', body\n    end\n\n    it 'does not set a X-Cascade header' do\n      mock_app do\n        get('/') do\n          not_found\n          fail 'not_found should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_nil response.headers['X-Cascade']\n    end\n  end\n\n  describe 'headers' do\n    it 'sets headers on the response object when given a Hash' do\n      mock_app do\n        get('/') do\n          headers 'X-Foo' => 'bar', 'X-Baz' => 'bling'\n          'kthx'\n        end\n      end\n\n      get '/'\n      assert ok?\n      assert_equal 'bar', response['X-Foo']\n      assert_equal 'bling', response['X-Baz']\n      assert_equal 'kthx', body\n    end\n\n    it 'returns the response headers hash when no hash provided' do\n      mock_app do\n        get('/') do\n          headers['X-Foo'] = 'bar'\n          'kthx'\n        end\n      end\n\n      get '/'\n      assert ok?\n      assert_equal 'bar', response['X-Foo']\n    end\n  end\n\n  describe 'session' do\n    it 'uses the existing rack.session' do\n      mock_app do\n        get('/') do\n          session[:foo]\n        end\n      end\n\n      get('/', {}, { 'rack.session' => { :foo => 'bar' } })\n      assert_equal 'bar', body\n    end\n\n    it 'creates a new session when none provided' do\n      mock_app do\n        enable :sessions\n\n        get('/') do\n          assert session[:foo].nil?\n          session[:foo] = 'bar'\n          redirect '/hi'\n        end\n\n        get('/hi') do\n          \"hi #{session[:foo]}\"\n        end\n      end\n\n      get '/'\n      follow_redirect!\n      assert_equal 'hi bar', body\n    end\n\n    it 'inserts session middleware' do\n      mock_app do\n        enable :sessions\n\n        get('/') do\n          assert env['rack.session']\n          assert env['rack.session.options']\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_body 'ok'\n    end\n\n    it 'sets a default session secret' do\n      mock_app do\n        enable :sessions\n\n        get('/') do\n          secret = env['rack.session.options'][:secret]\n          assert secret\n          assert_equal secret, settings.session_secret\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_body 'ok'\n    end\n\n    it 'allows disabling session secret' do\n      mock_app do\n        enable :sessions\n        disable :session_secret\n\n        get('/') do\n          assert !env['rack.session.options'].include?(:session_secret)\n          'ok'\n        end\n      end\n\n      # Silence warnings since Rack::Session::Cookie complains about the non-present session secret\n      silence_warnings do\n        get '/'\n      end\n      assert_body 'ok'\n    end\n\n    it 'accepts an options hash' do\n      mock_app do\n        set :sessions, :foo => :bar\n\n        get('/') do\n          assert_equal env['rack.session.options'][:foo], :bar\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_body 'ok'\n    end\n  end\n\n  describe 'mime_type' do\n    include Sinatra::Helpers\n\n    it \"looks up mime types in Rack's MIME registry\" do\n      Rack::Mime::MIME_TYPES['.foo'] = 'application/foo'\n      assert_equal 'application/foo', mime_type('foo')\n      assert_equal 'application/foo', mime_type('.foo')\n      assert_equal 'application/foo', mime_type(:foo)\n    end\n\n    it 'returns nil when given nil' do\n      assert mime_type(nil).nil?\n    end\n\n    it 'returns nil when media type not registered' do\n      assert mime_type(:bizzle).nil?\n    end\n\n    it 'returns the argument when given a media type string' do\n      assert_equal 'text/plain', mime_type('text/plain')\n    end\n\n    it 'turns AcceptEntry into String' do\n      type = mime_type(Sinatra::Request::AcceptEntry.new('text/plain'))\n      assert_equal String, type.class\n      assert_equal 'text/plain', type\n    end\n  end\n\n  test 'Base.mime_type registers mime type' do\n    mock_app do\n      mime_type :foo, 'application/foo'\n\n      get('/') do\n        \"foo is #{mime_type(:foo)}\"\n      end\n    end\n\n    get '/'\n    assert_equal 'foo is application/foo', body\n  end\n\n  describe 'content_type' do\n    it 'sets the Content-Type header' do\n      mock_app do\n        get('/') do\n          content_type 'text/plain'\n          'Hello World'\n        end\n      end\n\n      get '/'\n      assert_equal 'text/plain;charset=utf-8', response['Content-Type']\n      assert_equal 'Hello World', body\n    end\n\n    it 'takes media type parameters (like charset=)' do\n      mock_app do\n        get('/') do\n          content_type 'text/html', :charset => 'latin1'\n          \"<h1>Hello, World</h1>\"\n        end\n      end\n\n      get '/'\n      assert ok?\n      assert_equal 'text/html;charset=latin1', response['Content-Type']\n      assert_equal \"<h1>Hello, World</h1>\", body\n    end\n\n    it \"looks up symbols in Rack's mime types dictionary\" do\n      Rack::Mime::MIME_TYPES['.foo'] = 'application/foo'\n      mock_app do\n        get('/foo.xml') do\n          content_type :foo\n          \"I AM FOO\"\n        end\n      end\n\n      get '/foo.xml'\n      assert ok?\n      assert_equal 'application/foo', response['Content-Type']\n      assert_equal 'I AM FOO', body\n    end\n\n    it 'fails when no mime type is registered for the argument provided' do\n      mock_app do\n        get('/foo.xml') do\n          content_type :bizzle\n          \"I AM FOO\"\n        end\n      end\n\n      assert_raises(RuntimeError) { get '/foo.xml' }\n    end\n\n    it 'only sets default charset for specific mime types' do\n      tests_ran = false\n      mock_app do\n        mime_type :foo, 'text/foo'\n        mime_type :bar, 'application/bar'\n        mime_type :baz, 'application/baz'\n        add_charset << mime_type(:baz)\n        get('/') do\n          assert_equal content_type(:txt),    'text/plain;charset=utf-8'\n          assert_equal content_type(:css),    'text/css;charset=utf-8'\n          assert_equal content_type(:html),   'text/html;charset=utf-8'\n          assert_equal content_type(:foo),    'text/foo;charset=utf-8'\n          assert_equal content_type(:xml),    'application/xml;charset=utf-8'\n          assert_equal content_type(:xhtml),  'application/xhtml+xml;charset=utf-8'\n          assert_equal content_type(:js),     'application/javascript;charset=utf-8'\n          assert_equal content_type(:json),   'application/json'\n          assert_equal content_type(:bar),    'application/bar'\n          assert_equal content_type(:png),    'image/png'\n          assert_equal content_type(:baz),    'application/baz;charset=utf-8'\n          tests_ran = true\n          \"done\"\n        end\n      end\n\n      get '/'\n      assert tests_ran\n    end\n\n    it 'handles already present params' do\n      mock_app do\n        get('/') do\n          content_type 'foo/bar;level=1', :charset => 'utf-8'\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_equal 'foo/bar;level=1, charset=utf-8', response['Content-Type']\n    end\n\n    it 'does not add charset if present' do\n      mock_app do\n        get('/') do\n          content_type 'text/plain;charset=utf-16'\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_equal 'text/plain;charset=utf-16', response['Content-Type']\n    end\n\n    it 'properly encodes parameters with delimiter characters' do\n      mock_app do\n        before '/comma' do\n          content_type 'image/png', :comment => 'Hello, world!'\n        end\n        before '/semicolon' do\n          content_type 'image/png', :comment => 'semi;colon'\n        end\n        before '/quote' do\n          content_type 'image/png', :comment => '\"Whatever.\"'\n        end\n\n        get('*') { 'ok' }\n      end\n\n      get '/comma'\n      assert_equal 'image/png;comment=\"Hello, world!\"', response['Content-Type']\n      get '/semicolon'\n      assert_equal 'image/png;comment=\"semi;colon\"', response['Content-Type']\n      get '/quote'\n      assert_equal 'image/png;comment=\"\\\"Whatever.\\\"\"', response['Content-Type']\n    end\n  end\n\n  describe 'attachment' do\n    def attachment_app(filename=nil)\n      mock_app do\n        get('/attachment') do\n          attachment filename\n          response.write(\"<sinatra></sinatra>\")\n        end\n      end\n    end\n\n    it 'sets the Content-Type response header' do\n      attachment_app('test.xml')\n      get '/attachment'\n      assert_equal 'application/xml;charset=utf-8', response['Content-Type']\n      assert_equal '<sinatra></sinatra>', body\n    end\n\n    it 'sets the Content-Type response header without extname' do\n      attachment_app('test')\n      get '/attachment'\n      assert_equal 'text/html;charset=utf-8', response['Content-Type']\n      assert_equal '<sinatra></sinatra>', body\n    end\n\n    it 'sets the Content-Type response header with extname' do\n      mock_app do\n        get('/attachment') do\n          content_type :atom\n          attachment 'test.xml'\n          response.write(\"<sinatra></sinatra>\")\n        end\n      end\n\n      get '/attachment'\n      assert_equal 'application/atom+xml', response['Content-Type']\n      assert_equal '<sinatra></sinatra>', body\n    end\n\n  end\n\n  describe 'send_file' do\n    setup do\n      @file = __dir__ + '/file.txt'\n      File.open(@file, 'wb') { |io| io.write('Hello World') }\n    end\n\n    def teardown\n      File.unlink @file\n      @file = nil\n    end\n\n    def send_file_app(opts={})\n      path = @file\n      mock_app {\n        get '/file.txt' do\n          send_file path, opts\n        end\n      }\n    end\n\n    it \"sends the contents of the file\" do\n      send_file_app\n      get '/file.txt'\n      assert ok?\n      assert_equal 'Hello World', body\n    end\n\n    it 'sets the Content-Type response header if a mime-type can be located' do\n      send_file_app\n      get '/file.txt'\n      assert_equal 'text/plain;charset=utf-8', response['Content-Type']\n    end\n\n    it 'sets the Content-Type response header if type option is set to a file extension' do\n      send_file_app :type => 'html'\n      get '/file.txt'\n      assert_equal 'text/html;charset=utf-8', response['Content-Type']\n    end\n\n    it 'sets the Content-Type response header if type option is set to a mime type' do\n      send_file_app :type => 'application/octet-stream'\n      get '/file.txt'\n      assert_equal 'application/octet-stream', response['Content-Type']\n    end\n\n    it 'sets the Content-Length response header' do\n      send_file_app\n      get '/file.txt'\n      assert_equal 'Hello World'.length.to_s, response['Content-Length']\n    end\n\n    it 'sets the Last-Modified response header' do\n      send_file_app\n      get '/file.txt'\n      assert_equal File.mtime(@file).httpdate, response['Last-Modified']\n    end\n\n    it 'allows passing in a different Last-Modified response header with :last_modified' do\n      time = Time.now\n      send_file_app :last_modified => time\n      get '/file.txt'\n      assert_equal time.httpdate, response['Last-Modified']\n    end\n\n    it \"returns a 404 when not found\" do\n      mock_app {\n        get('/') { send_file 'this-file-does-not-exist.txt' }\n      }\n      get '/'\n      assert not_found?\n    end\n\n    it \"does not set the Content-Disposition header by default\" do\n      send_file_app\n      get '/file.txt'\n      assert_nil response['Content-Disposition']\n    end\n\n    it \"sets the Content-Disposition header when :disposition set to 'attachment'\" do\n      send_file_app :disposition => 'attachment'\n      get '/file.txt'\n      assert_equal 'attachment; filename=\"file.txt\"', response['Content-Disposition']\n    end\n\n    it \"does not set add a file name if filename is false\" do\n      send_file_app :disposition => 'inline', :filename => false\n      get '/file.txt'\n      assert_equal 'inline', response['Content-Disposition']\n    end\n\n    it \"sets the Content-Disposition header when :disposition set to 'inline'\" do\n      send_file_app :disposition => 'inline'\n      get '/file.txt'\n      assert_equal 'inline; filename=\"file.txt\"', response['Content-Disposition']\n    end\n\n    it \"does not raise an error when :disposition set to a frozen string\" do\n      send_file_app :disposition => 'inline'.freeze\n      get '/file.txt'\n      assert_equal 'inline; filename=\"file.txt\"', response['Content-Disposition']\n    end \n    \n    it \"sets the Content-Disposition header when :filename provided\" do\n      send_file_app :filename => 'foo.txt'\n      get '/file.txt'\n      assert_equal 'attachment; filename=\"foo.txt\"', response['Content-Disposition']\n    end\n\n    it 'allows setting a custom status code' do\n      send_file_app :status => 201\n      get '/file.txt'\n      assert_status 201\n    end\n\n    it \"is able to send files with unknown mime type\" do\n      @file = __dir__ + '/file.foobar'\n      File.open(@file, 'wb') { |io| io.write('Hello World') }\n      send_file_app\n      get '/file.txt'\n      assert_equal 'application/octet-stream', response['Content-Type']\n    end\n\n    it \"does not override Content-Type if already set and no explicit type is given\" do\n      path = @file\n      mock_app do\n        get('/') do\n          content_type :png\n          send_file path\n        end\n      end\n      get '/'\n      assert_equal 'image/png', response['Content-Type']\n    end\n\n    it \"does override Content-Type even if already set, if explicit type is given\" do\n      path = @file\n      mock_app do\n        get('/') do\n          content_type :png\n          send_file path, :type => :gif\n        end\n      end\n      get '/'\n      assert_equal 'image/gif', response['Content-Type']\n    end\n\n    it 'can have :status option as a string' do\n      path = @file\n      mock_app do\n        post '/' do\n          send_file path, :status => '422'\n        end\n      end\n      post '/'\n      assert_equal response.status, 422\n    end\n  end\n\n  describe 'cache_control' do\n    setup do\n      mock_app do\n        get('/foo') do\n          cache_control :public, :no_cache, :max_age => 60.0\n          'Hello World'\n        end\n\n        get('/bar') do\n          cache_control :public, :no_cache\n          'Hello World'\n        end\n      end\n    end\n\n    it 'sets the Cache-Control header' do\n      get '/foo'\n      assert_equal ['public', 'no-cache', 'max-age=60'], response['Cache-Control'].split(', ')\n    end\n\n    it 'last argument does not have to be a hash' do\n      get '/bar'\n      assert_equal ['public', 'no-cache'], response['Cache-Control'].split(', ')\n    end\n  end\n\n  describe 'expires' do\n    setup do\n      mock_app do\n        get('/foo') do\n          expires 60, :public, :no_cache\n          'Hello World'\n        end\n\n        get('/bar') { expires Time.now }\n\n        get('/baz') { expires Time.at(0) }\n\n        get('/bah') { expires Time.at(0), :max_age => 20 }\n\n        get('/blah') do\n          obj = Object.new\n          def obj.method_missing(*a, &b) 60.send(*a, &b) end\n          def obj.is_a?(thing) 60.is_a?(thing) end\n          expires obj, :public, :no_cache\n          'Hello World'\n        end\n\n        get('/boom') { expires '9999' }\n      end\n    end\n\n    it 'sets the Cache-Control header' do\n      get '/foo'\n      assert_equal ['public', 'no-cache', 'max-age=60'], response['Cache-Control'].split(', ')\n    end\n\n    it 'sets the Expires header' do\n      get '/foo'\n      refute_nil response['Expires']\n    end\n\n    it 'allows passing Time.now objects' do\n      get '/bar'\n      refute_nil response['Expires']\n    end\n\n    it 'allows passing Time.at objects' do\n      get '/baz'\n      assert_equal 'Thu, 01 Jan 1970 00:00:00 GMT', response['Expires']\n    end\n\n    it 'allows max_age to be specified separately' do\n      get '/bah'\n      assert_equal 'Thu, 01 Jan 1970 00:00:00 GMT', response['Expires']\n      assert_equal ['max-age=20'], response['Cache-Control'].split(', ')\n    end\n\n    it 'accepts values pretending to be a Numeric (like ActiveSupport::Duration)' do\n      get '/blah'\n      assert_equal ['public', 'no-cache', 'max-age=60'], response['Cache-Control'].split(', ')\n    end\n\n    it 'fails when Time.parse raises an ArgumentError' do\n      assert_raises(ArgumentError) { get '/boom' }\n    end\n  end\n\n  describe 'last_modified' do\n    it 'ignores nil' do\n      mock_app { get('/') { last_modified nil; 200; } }\n\n      get '/'\n      assert ! response['Last-Modified']\n    end\n\n    it 'does not change a status other than 200' do\n      mock_app do\n        get('/') do\n          status 299\n          last_modified Time.at(0)\n          'ok'\n        end\n      end\n\n      get('/', {}, 'HTTP_IF_MODIFIED_SINCE' => 'Sun, 26 Sep 2030 23:43:52 GMT')\n      assert_status 299\n      assert_body 'ok'\n    end\n\n    [Time.now, DateTime.now, Date.today, Time.now.to_i,\n      Struct.new(:to_time).new(Time.now) ].each do |last_modified_time|\n      describe \"with #{last_modified_time.class.name}\" do\n        setup do\n          mock_app do\n            get('/') do\n              last_modified last_modified_time\n              'Boo!'\n            end\n          end\n          wrapper = Object.new.extend Sinatra::Helpers\n          @last_modified_time = wrapper.time_for last_modified_time\n        end\n\n        # fixes strange missing test error when running complete test suite.\n        it(\"does not complain about missing tests\") { }\n\n        context \"when there's no If-Modified-Since header\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get '/'\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET misses and returns a body' do\n            get '/'\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n        end\n\n        context \"when there's an invalid If-Modified-Since header\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'a really weird date' })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET misses and returns a body' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'a really weird date' })\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n        end\n\n        context \"when the resource has been modified since the If-Modified-Since header date\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time - 1).httpdate })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET misses and returns a body' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time - 1).httpdate })\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n\n          it 'does not rely on string comparison' do\n            mock_app do\n              get('/compare') do\n                last_modified \"Mon, 18 Oct 2010 20:57:11 GMT\"\n                \"foo\"\n              end\n            end\n\n            get('/compare', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'Sun, 26 Sep 2010 23:43:52 GMT' })\n            assert_equal 200, status\n            assert_equal 'foo', body\n            get('/compare', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'Sun, 26 Sep 2030 23:43:52 GMT' })\n            assert_equal 304, status\n            assert_equal '', body\n          end\n        end\n\n        context \"when the resource has been modified on the exact If-Modified-Since header date\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => @last_modified_time.httpdate })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET matches and halts' do\n            get( '/', {}, { 'HTTP_IF_MODIFIED_SINCE' => @last_modified_time.httpdate })\n            assert_equal 304, status\n            assert_equal '', body\n          end\n        end\n\n        context \"when the resource hasn't been modified since the If-Modified-Since header date\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time + 1).httpdate })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET matches and halts' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time + 1).httpdate })\n            assert_equal 304, status\n            assert_equal '', body\n          end\n        end\n\n        context \"If-Unmodified-Since\" do\n          it 'results in 200 if resource has not been modified' do\n            get('/', {}, { 'HTTP_IF_UNMODIFIED_SINCE' => 'Sun, 26 Sep 2030 23:43:52 GMT' })\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n\n          it 'results in 412 if resource has been modified' do\n            get('/', {}, { 'HTTP_IF_UNMODIFIED_SINCE' => Time.at(0).httpdate })\n            assert_equal 412, status\n            assert_equal '', body\n          end\n        end\n      end\n    end\n  end\n\n  describe 'etag' do\n    context \"safe requests\" do\n      it 'returns 200 for normal requests' do\n        mock_app do\n          get('/') do\n            etag 'foo'\n            'ok'\n          end\n        end\n\n        get '/'\n        assert_status 200\n        assert_body 'ok'\n      end\n\n      context \"If-None-Match\" do\n        it 'returns 304 when If-None-Match is *' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match is * for new resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 304 when If-None-Match is * for existing resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 304 when If-None-Match is the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 304 when If-None-Match includes the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\", \"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match does not include the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'ignores If-Modified-Since if If-None-Match does not match' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              last_modified Time.at(0)\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'does not change a status code other than 2xx or 304' do\n          mock_app do\n            get('/') do\n              status 499\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 499\n          assert_body 'ok'\n        end\n\n        it 'does change 2xx status codes' do\n          mock_app do\n            get('/') do\n              status 299\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'does not send a body on 304 status codes' do\n          mock_app do\n            get('/') do\n              status 304\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n      end\n\n      context \"If-Match\" do\n        it 'returns 200 when If-Match is the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '\"foo\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match includes the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '\"foo\", \"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match is *' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match is * for new resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-Match is * for existing resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match does not include the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '\"bar\"')\n          assert_status 412\n          assert_body ''\n        end\n      end\n    end\n\n    context \"idempotent requests\" do\n      it 'returns 200 for normal requests' do\n        mock_app do\n          put('/') do\n            etag 'foo'\n            'ok'\n          end\n        end\n\n        put '/'\n        assert_status 200\n        assert_body 'ok'\n      end\n\n      context \"If-None-Match\" do\n        it 'returns 412 when If-None-Match is *' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match is * for new resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-None-Match is * for existing resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match is the etag' do\n          mock_app do\n            put '/' do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match includes the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\", \"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match does not include the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'ignores If-Modified-Since if If-None-Match does not match' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              last_modified Time.at(0)\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n      end\n\n      context \"If-Match\" do\n        it 'returns 200 when If-Match is the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '\"foo\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match includes the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '\"foo\", \"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match is *' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match is * for new resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-Match is * for existing resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match does not include the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '\"bar\"')\n          assert_status 412\n          assert_body ''\n        end\n      end\n    end\n\n    context \"post requests\" do\n      it 'returns 200 for normal requests' do\n        mock_app do\n          post('/') do\n            etag 'foo'\n            'ok'\n          end\n        end\n\n        post('/')\n        assert_status 200\n        assert_body 'ok'\n      end\n\n      context \"If-None-Match\" do\n        it 'returns 200 when If-None-Match is *' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-None-Match is * for new resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-None-Match is * for existing resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match is the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match includes the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\", \"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match does not include the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'ignores If-Modified-Since if If-None-Match does not match' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              last_modified Time.at(0)\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n      end\n\n      context \"If-Match\" do\n        it 'returns 200 when If-Match is the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '\"foo\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match includes the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '\"foo\", \"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match is *' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-Match is * for new resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-Match is * for existing resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match does not include the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '\"bar\"')\n          assert_status 412\n          assert_body ''\n        end\n      end\n    end\n\n    it 'uses a weak etag with the :weak option' do\n      mock_app do\n        get('/') do\n          etag 'FOO', :weak\n          \"that's weak, dude.\"\n        end\n      end\n      get '/'\n      assert_equal 'W/\"FOO\"', response['ETag']\n    end\n\n    it 'raises an ArgumentError for an invalid strength' do\n      mock_app do\n        get('/') do\n          etag 'FOO', :w00t\n          \"that's weak, dude.\"\n        end\n      end\n      assert_raises(ArgumentError) { get('/') }\n    end\n  end\n\n  describe 'back' do\n    it \"makes redirecting back pretty\" do\n      mock_app { get('/foo') { redirect back } }\n\n      get('/foo', {}, 'HTTP_REFERER' => 'http://github.com')\n      assert redirect?\n      assert_equal \"http://github.com\", response.location\n    end\n  end\n\n  describe 'uri' do\n    it 'generates absolute urls' do\n      mock_app { get('/') { uri }}\n      get '/'\n      assert_equal 'http://example.org/', body\n    end\n\n    it 'includes path_info' do\n      mock_app { get('/:name') { uri }}\n      get '/foo'\n      assert_equal 'http://example.org/foo', body\n    end\n\n    it 'allows passing an alternative to path_info' do\n      mock_app { get('/:name') { uri '/bar' }}\n      get '/foo'\n      assert_equal 'http://example.org/bar', body\n    end\n\n    it 'includes script_name' do\n      mock_app { get('/:name') { uri '/bar' }}\n      get '/foo', {}, { \"SCRIPT_NAME\" => '/foo' }\n      assert_equal 'http://example.org/foo/bar', body\n    end\n\n    it 'handles absolute URIs' do\n      mock_app { get('/') { uri 'http://google.com' }}\n      get '/'\n      assert_equal 'http://google.com', body\n    end\n\n    it 'handles different protocols' do\n      mock_app { get('/') { uri 'mailto:jsmith@example.com' }}\n      get '/'\n      assert_equal 'mailto:jsmith@example.com', body\n    end\n\n    it 'is aliased to #url' do\n      mock_app { get('/') { url }}\n      get '/'\n      assert_equal 'http://example.org/', body\n    end\n\n    it 'is aliased to #to' do\n      mock_app { get('/') { to }}\n      get '/'\n      assert_equal 'http://example.org/', body\n    end\n\n    it 'is case-insensitive' do\n      mock_app { get('/:foo') { uri params[:foo] }}\n      assert_equal get('HtTP://google.com').body, get('http://google.com').body\n    end\n\n    it 'generates relative link for invalid path' do\n      mock_app { get('/') { uri 'htt^p://google.com' }}\n      get '/'\n      assert_equal 'http://example.org/htt^p://google.com', body\n    end\n  end\n\n  describe 'logger' do\n    it 'logging works when logging is enabled' do\n      mock_app do\n        enable :logging\n        get('/') do\n          logger.info \"Program started\"\n          logger.warn \"Nothing to do!\"\n        end\n      end\n      io = StringIO.new\n      get '/', {}, 'rack.errors' => io\n      assert io.string.include?(\"INFO -- : Program started\")\n      assert io.string.include?(\"WARN -- : Nothing to do\")\n    end\n\n    it 'logging works when logging is disable, but no output is produced' do\n      mock_app do\n        disable :logging\n        get('/') do\n          logger.info \"Program started\"\n          logger.warn \"Nothing to do!\"\n        end\n      end\n      io = StringIO.new\n      get '/', {}, 'rack.errors' => io\n      assert !io.string.include?(\"INFO -- : Program started\")\n      assert !io.string.include?(\"WARN -- : Nothing to do\")\n    end\n\n    it 'does not create a logger when logging is set to nil' do\n      mock_app do\n        set :logging, nil\n        get('/') { logger.inspect }\n      end\n\n      get '/'\n      assert_body 'nil'\n    end\n  end\n\n  module ::HelperOne; def one; '1'; end; end\n  module ::HelperTwo; def two; '2'; end; end\n\n  describe 'Adding new helpers' do\n    it 'takes a list of modules to mix into the app' do\n      mock_app do\n        helpers ::HelperOne, ::HelperTwo\n\n        get('/one') { one }\n\n        get('/two') { two }\n      end\n\n      get '/one'\n      assert_equal '1', body\n\n      get '/two'\n      assert_equal '2', body\n    end\n\n    it 'takes a block to mix into the app' do\n      mock_app do\n        helpers do\n          def foo\n            'foo'\n          end\n        end\n\n        get('/') { foo }\n      end\n\n      get '/'\n      assert_equal 'foo', body\n    end\n\n    it 'evaluates the block in class context so that methods can be aliased' do\n      mock_app do\n        helpers { alias_method :h, :escape_html }\n\n        get('/') { h('42 < 43') }\n      end\n\n      get '/'\n      assert ok?\n      assert_equal '42 &lt; 43', body\n    end\n\n    it 'prepends modules so previously-defined methods can be overridden consistently' do\n      skip <<-EOS\n        This test will be helpful after switching #helpers's code from Module#include to Module#prepend\n        See more details: https://github.com/sinatra/sinatra/pull/1214\n      EOS\n      mock_app do\n        helpers do\n          def one; nil end\n          def two; nil end\n        end\n\n        helpers ::HelperOne do\n          def two; '2' end\n        end\n\n        get('/one') { one }\n        get('/two') { two }\n      end\n\n      get '/one'\n      assert_equal '1', body\n\n      get '/two'\n      assert_equal '2', body\n    end\n\n    module HelpersOverloadingBaseHelper\n      def my_test\n        'BaseHelper#test'\n      end\n    end\n\n    class HelpersOverloadingIncludeAndOverride < Sinatra::Base\n      helpers HelpersOverloadingBaseHelper\n\n      get '/' do\n        my_test\n      end\n\n      helpers do\n        def my_test\n          'InlineHelper#test'\n        end\n      end\n    end\n\n    it 'uses overloaded inline helper' do\n      mock_app(HelpersOverloadingIncludeAndOverride)\n      get '/'\n      assert ok?\n      assert_equal 'InlineHelper#test', body\n    end\n\n    module HelperWithIncluded\n      def self.included(base)\n        base.extend(ClassMethods)\n      end\n\n      module ClassMethods\n        def nickname(name)\n          # do something.\n        end\n      end\n    end\n\n    class ServerApp < Sinatra::Base\n      helpers HelperWithIncluded\n      # `nickname` method should be available.\n    end\n\n    it 'calls included method of helpers' do\n      assert ServerApp.respond_to?(:nickname)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# external dependencies\nrequire 'rack'\nrequire 'tilt'\nrequire 'rack/protection'\nrequire 'mustermann'\nrequire 'mustermann/sinatra'\nrequire 'mustermann/regular'\n\n# stdlib dependencies\nrequire 'time'\nrequire 'uri'\n\n# other files we need\nrequire 'sinatra/indifferent_hash'\nrequire 'sinatra/show_exceptions'\nrequire 'sinatra/version'\n\nmodule Sinatra\n  # The request object. See Rack::Request for more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Request\n  class Request < Rack::Request\n    HEADER_PARAM = /\\s*[\\w.]+=(?:[\\w.]+|\"(?:[^\"\\\\]|\\\\.)*\")?\\s*/.freeze\n    HEADER_VALUE_WITH_PARAMS = %r{(?:(?:\\w+|\\*)/(?:\\w+(?:\\.|-|\\+)?|\\*)*)\\s*(?:;#{HEADER_PARAM})*}.freeze\n\n    # Returns an array of acceptable media types for the response\n    def accept\n      @env['sinatra.accept'] ||= if @env.include?('HTTP_ACCEPT') && (@env['HTTP_ACCEPT'].to_s != '')\n                                   @env['HTTP_ACCEPT']\n                                     .to_s\n                                     .scan(HEADER_VALUE_WITH_PARAMS)\n                                     .map! { |e| AcceptEntry.new(e) }\n                                     .sort\n                                 else\n                                   [AcceptEntry.new('*/*')]\n                                 end\n    end\n\n    def accept?(type)\n      preferred_type(type).to_s.include?(type)\n    end\n\n    def preferred_type(*types)\n      return accept.first if types.empty?\n\n      types.flatten!\n      return types.first if accept.empty?\n\n      accept.detect do |accept_header|\n        type = types.detect { |t| MimeTypeEntry.new(t).accepts?(accept_header) }\n        return type if type\n      end\n    end\n\n    alias secure? ssl?\n\n    def forwarded?\n      @env.include? 'HTTP_X_FORWARDED_HOST'\n    end\n\n    def safe?\n      get? || head? || options? || trace?\n    end\n\n    def idempotent?\n      safe? || put? || delete? || link? || unlink?\n    end\n\n    def link?\n      request_method == 'LINK'\n    end\n\n    def unlink?\n      request_method == 'UNLINK'\n    end\n\n    def params\n      super\n    rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e\n      raise BadRequest, \"Invalid query parameters: #{Rack::Utils.escape_html(e.message)}\"\n    rescue EOFError => e\n      raise BadRequest, \"Invalid multipart/form-data: #{Rack::Utils.escape_html(e.message)}\"\n    end\n\n    class AcceptEntry\n      attr_accessor :params\n      attr_reader :entry\n\n      def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @entry  = entry\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n        @q      = @params.delete('q') { 1.0 }.to_f\n      end\n\n      def <=>(other)\n        other.priority <=> priority\n      end\n\n      def priority\n        # We sort in descending order; better matches should be higher.\n        [@q, -@type.count('*'), @params.size]\n      end\n\n      def to_str\n        @type\n      end\n\n      def to_s(full = false)\n        full ? entry : to_str\n      end\n\n      def respond_to?(*args)\n        super || to_str.respond_to?(*args)\n      end\n\n      def method_missing(*args, &block)\n        to_str.send(*args, &block)\n      end\n    end\n\n    class MimeTypeEntry\n      attr_reader :params\n\n      def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n      end\n\n      def accepts?(entry)\n        File.fnmatch(entry, self) && matches_params?(entry.params)\n      end\n\n      def to_str\n        @type\n      end\n\n      def matches_params?(params)\n        return true if @params.empty?\n\n        params.all? { |k, v| !@params.key?(k) || @params[k] == v }\n      end\n    end\n  end\n\n  # The response object. See Rack::Response and Rack::Response::Helpers for\n  # more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response/Helpers\n  class Response < Rack::Response\n    DROP_BODY_RESPONSES = [204, 304].freeze\n\n    def body=(value)\n      value = value.body while Rack::Response === value\n      @body = String === value ? [value.to_str] : value\n    end\n\n    def each\n      block_given? ? super : enum_for(:each)\n    end\n\n    def finish\n      result = body\n\n      if drop_content_info?\n        headers.delete 'Content-Length'\n        headers.delete 'Content-Type'\n      end\n\n      if drop_body?\n        close\n        result = []\n      end\n\n      if calculate_content_length?\n        # if some other code has already set Content-Length, don't muck with it\n        # currently, this would be the static file-handler\n        headers['Content-Length'] = body.map(&:bytesize).reduce(0, :+).to_s\n      end\n\n      [status, headers, result]\n    end\n\n    private\n\n    def calculate_content_length?\n      headers['Content-Type'] && !headers['Content-Length'] && (Array === body)\n    end\n\n    def drop_content_info?\n      informational? || drop_body?\n    end\n\n    def drop_body?\n      DROP_BODY_RESPONSES.include?(status)\n    end\n  end\n\n  # Some Rack handlers (Rainbows!) implement an extended body object protocol, however,\n  # some middleware (namely Rack::Lint) will break it by not mirroring the methods in question.\n  # This middleware will detect an extended body object and will make sure it reaches the\n  # handler directly. We do this here, so our middleware and middleware set up by the app will\n  # still be able to run.\n  class ExtendedRack < Struct.new(:app)\n    def call(env)\n      result = app.call(env)\n      callback = env['async.callback']\n      return result unless callback && async?(*result)\n\n      after_response { callback.call result }\n      setup_close(env, *result)\n      throw :async\n    end\n\n    private\n\n    def setup_close(env, _status, _headers, body)\n      return unless body.respond_to?(:close) && env.include?('async.close')\n\n      env['async.close'].callback { body.close }\n      env['async.close'].errback { body.close }\n    end\n\n    def after_response(&block)\n      raise NotImplementedError, 'only supports EventMachine at the moment' unless defined? EventMachine\n\n      EventMachine.next_tick(&block)\n    end\n\n    def async?(status, _headers, body)\n      return true if status == -1\n\n      body.respond_to?(:callback) && body.respond_to?(:errback)\n    end\n  end\n\n  # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing,\n  # if another CommonLogger is already in the middleware chain.\n  class CommonLogger < Rack::CommonLogger\n    def call(env)\n      env['sinatra.commonlogger'] ? @app.call(env) : super\n    end\n\n    superclass.class_eval do\n      alias_method :call_without_check, :call unless method_defined? :call_without_check\n      def call(env)\n        env['sinatra.commonlogger'] = true\n        call_without_check(env)\n      end\n    end\n  end\n\n  class Error < StandardError # :nodoc:\n  end\n\n  class BadRequest < Error # :nodoc:\n    def http_status; 400 end\n  end\n\n  class NotFound < Error # :nodoc:\n    def http_status; 404 end\n  end\n\n  # Methods available to routes, before/after filters, and views.\n  module Helpers\n    # Set or retrieve the response status code.\n    def status(value = nil)\n      response.status = Rack::Utils.status_code(value) if value\n      response.status\n    end\n\n    # Set or retrieve the response body. When a block is given,\n    # evaluation is deferred until the body is read with #each.\n    def body(value = nil, &block)\n      if block_given?\n        def block.each; yield(call) end\n        response.body = block\n      elsif value\n        # Rack 2.0 returns a Rack::File::Iterator here instead of\n        # Rack::File as it was in the previous API.\n        unless request.head? || value.is_a?(Rack::File::Iterator) || value.is_a?(Stream)\n          headers.delete 'Content-Length'\n        end\n        response.body = value\n      else\n        response.body\n      end\n    end\n\n    # Halt processing and redirect to the URI provided.\n    def redirect(uri, *args)\n      if (env['HTTP_VERSION'] == 'HTTP/1.1') && (env['REQUEST_METHOD'] != 'GET')\n        status 303\n      else\n        status 302\n      end\n\n      # According to RFC 2616 section 14.30, \"the field value consists of a\n      # single absolute URI\"\n      response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?)\n      halt(*args)\n    end\n\n    # Generates the absolute URI for a given path in the app.\n    # Takes Rack routers and reverse proxies into account.\n    def uri(addr = nil, absolute = true, add_script_name = true)\n      return addr if addr =~ /\\A[a-z][a-z0-9+.\\-]*:/i\n\n      uri = [host = String.new]\n      if absolute\n        host << \"http#{'s' if request.secure?}://\"\n        host << if request.forwarded? || (request.port != (request.secure? ? 443 : 80))\n                  request.host_with_port\n                else\n                  request.host\n                end\n      end\n      uri << request.script_name.to_s if add_script_name\n      uri << (addr || request.path_info).to_s\n      File.join uri\n    end\n\n    alias url uri\n    alias to uri\n\n    # Halt processing and return the error status provided.\n    def error(code, body = nil)\n      if code.respond_to? :to_str\n        body = code.to_str\n        code = 500\n      end\n      response.body = body unless body.nil?\n      halt code\n    end\n\n    # Halt processing and return a 404 Not Found.\n    def not_found(body = nil)\n      error 404, body\n    end\n\n    # Set multiple response headers with Hash.\n    def headers(hash = nil)\n      response.headers.merge! hash if hash\n      response.headers\n    end\n\n    # Access the underlying Rack session.\n    def session\n      request.session\n    end\n\n    # Access shared logger object.\n    def logger\n      request.logger\n    end\n\n    # Look up a media type by file extension in Rack's mime registry.\n    def mime_type(type)\n      Base.mime_type(type)\n    end\n\n    # Set the Content-Type of the response body given a media type or file\n    # extension.\n    def content_type(type = nil, params = {})\n      return response['Content-Type'] unless type\n\n      default = params.delete :default\n      mime_type = mime_type(type) || default\n      raise format('Unknown media type: %p', type) if mime_type.nil?\n\n      mime_type = mime_type.dup\n      unless params.include?(:charset) || settings.add_charset.all? { |p| !(p === mime_type) }\n        params[:charset] = params.delete('charset') || settings.default_encoding\n      end\n      params.delete :charset if mime_type.include? 'charset'\n      unless params.empty?\n        mime_type << (mime_type.include?(';') ? ', ' : ';')\n        mime_type << params.map do |key, val|\n          val = val.inspect if val =~ /[\";,]/\n          \"#{key}=#{val}\"\n        end.join(', ')\n      end\n      response['Content-Type'] = mime_type\n    end\n\n    # https://html.spec.whatwg.org/#multipart-form-data\n    MULTIPART_FORM_DATA_REPLACEMENT_TABLE = {\n      '\"'  => '%22',\n      \"\\r\" => '%0D',\n      \"\\n\" => '%0A'\n    }.freeze\n\n    # Set the Content-Disposition to \"attachment\" with the specified filename,\n    # instructing the user agents to prompt to save.\n    def attachment(filename = nil, disposition = :attachment)\n      response['Content-Disposition'] = disposition.to_s.dup\n      return unless filename\n\n      params = format('; filename=\"%s\"', File.basename(filename).gsub(/[\"\\r\\n]/, MULTIPART_FORM_DATA_REPLACEMENT_TABLE))\n      response['Content-Disposition'] << params\n      ext = File.extname(filename)\n      content_type(ext) unless response['Content-Type'] || ext.empty?\n    end\n\n    # Use the contents of the file at +path+ as the response body.\n    def send_file(path, opts = {})\n      if opts[:type] || !response['Content-Type']\n        content_type opts[:type] || File.extname(path), default: 'application/octet-stream'\n      end\n\n      disposition = opts[:disposition]\n      filename    = opts[:filename]\n      disposition = :attachment if disposition.nil? && filename\n      filename    = path        if filename.nil?\n      attachment(filename, disposition) if disposition\n\n      last_modified opts[:last_modified] if opts[:last_modified]\n\n      file   = Rack::File.new(File.dirname(settings.app_file))\n      result = file.serving(request, path)\n\n      result[1].each { |k, v| headers[k] ||= v }\n      headers['Content-Length'] = result[1]['Content-Length']\n      opts[:status] &&= Integer(opts[:status])\n      halt (opts[:status] || result[0]), result[2]\n    rescue Errno::ENOENT\n      not_found\n    end\n\n    # Class of the response body in case you use #stream.\n    #\n    # Three things really matter: The front and back block (back being the\n    # block generating content, front the one sending it to the client) and\n    # the scheduler, integrating with whatever concurrency feature the Rack\n    # handler is using.\n    #\n    # Scheduler has to respond to defer and schedule.\n    class Stream\n      def self.schedule(*) yield end\n      def self.defer(*)    yield end\n\n      def initialize(scheduler = self.class, keep_open = false, &back)\n        @back = back.to_proc\n        @scheduler = scheduler\n        @keep_open = keep_open\n        @callbacks = []\n        @closed = false\n      end\n\n      def close\n        return if closed?\n\n        @closed = true\n        @scheduler.schedule { @callbacks.each { |c| c.call } }\n      end\n\n      def each(&front)\n        @front = front\n        @scheduler.defer do\n          begin\n            @back.call(self)\n          rescue Exception => e\n            @scheduler.schedule { raise e }\n          end\n          close unless @keep_open\n        end\n      end\n\n      def <<(data)\n        @scheduler.schedule { @front.call(data.to_s) }\n        self\n      end\n\n      def callback(&block)\n        return yield if closed?\n\n        @callbacks << block\n      end\n\n      alias errback callback\n\n      def closed?\n        @closed\n      end\n    end\n\n    # Allows to start sending data to the client even though later parts of\n    # the response body have not yet been generated.\n    #\n    # The close parameter specifies whether Stream#close should be called\n    # after the block has been executed. This is only relevant for evented\n    # servers like Rainbows.\n    def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } }\n    end\n\n    # Specify response freshness policy for HTTP caches (Cache-Control header).\n    # Any number of non-value directives (:public, :private, :no_cache,\n    # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with\n    # a Hash of value directives (:max_age, :s_maxage).\n    #\n    #   cache_control :public, :must_revalidate, :max_age => 60\n    #   => Cache-Control: public, must-revalidate, max-age=60\n    #\n    # See RFC 2616 / 14.9 for more on standard cache control directives:\n    # http://tools.ietf.org/html/rfc2616#section-14.9.1\n    def cache_control(*values)\n      if values.last.is_a?(Hash)\n        hash = values.pop\n        hash.reject! { |_k, v| v == false }\n        hash.reject! { |k, v| values << k if v == true }\n      else\n        hash = {}\n      end\n\n      values.map! { |value| value.to_s.tr('_', '-') }\n      hash.each do |key, value|\n        key = key.to_s.tr('_', '-')\n        value = value.to_i if %w[max-age s-maxage].include? key\n        values << \"#{key}=#{value}\"\n      end\n\n      response['Cache-Control'] = values.join(', ') if values.any?\n    end\n\n    # Set the Expires header and Cache-Control/max-age directive. Amount\n    # can be an integer number of seconds in the future or a Time object\n    # indicating when the response should be considered \"stale\". The remaining\n    # \"values\" arguments are passed to the #cache_control helper:\n    #\n    #   expires 500, :public, :must_revalidate\n    #   => Cache-Control: public, must-revalidate, max-age=500\n    #   => Expires: Mon, 08 Jun 2009 08:50:17 GMT\n    #\n    def expires(amount, *values)\n      values << {} unless values.last.is_a?(Hash)\n\n      if amount.is_a? Integer\n        time    = Time.now + amount.to_i\n        max_age = amount\n      else\n        time    = time_for amount\n        max_age = time - Time.now\n      end\n\n      values.last.merge!(max_age: max_age) { |_key, v1, v2| v1 || v2 }\n      cache_control(*values)\n\n      response['Expires'] = time.httpdate\n    end\n\n    # Set the last modified time of the resource (HTTP 'Last-Modified' header)\n    # and halt if conditional GET matches. The +time+ argument is a Time,\n    # DateTime, or other object that responds to +to_time+.\n    #\n    # When the current request includes an 'If-Modified-Since' header that is\n    # equal or later than the time specified, execution is immediately halted\n    # with a '304 Not Modified' response.\n    def last_modified(time)\n      return unless time\n\n      time = time_for time\n      response['Last-Modified'] = time.httpdate\n      return if env['HTTP_IF_NONE_MATCH']\n\n      if (status == 200) && env['HTTP_IF_MODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i\n        halt 304 if since >= time.to_i\n      end\n\n      if (success? || (status == 412)) && env['HTTP_IF_UNMODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i\n        halt 412 if since < time.to_i\n      end\n    rescue ArgumentError\n    end\n\n    ETAG_KINDS = %i[strong weak].freeze\n    # Set the response entity tag (HTTP 'ETag' header) and halt if conditional\n    # GET matches. The +value+ argument is an identifier that uniquely\n    # identifies the current version of the resource. The +kind+ argument\n    # indicates whether the etag should be used as a :strong (default) or :weak\n    # cache validator.\n    #\n    # When the current request includes an 'If-None-Match' header with a\n    # matching etag, execution is immediately halted. If the request method is\n    # GET or HEAD, a '304 Not Modified' response is sent.\n    def etag(value, options = {})\n      # Before touching this code, please double check RFC 2616 14.24 and 14.26.\n      options      = { kind: options } unless Hash === options\n      kind         = options[:kind] || :strong\n      new_resource = options.fetch(:new_resource) { request.post? }\n\n      unless ETAG_KINDS.include?(kind)\n        raise ArgumentError, ':strong or :weak expected'\n      end\n\n      value = format('\"%s\"', value)\n      value = \"W/#{value}\" if kind == :weak\n      response['ETag'] = value\n\n      return unless success? || status == 304\n\n      if etag_matches?(env['HTTP_IF_NONE_MATCH'], new_resource)\n        halt(request.safe? ? 304 : 412)\n      end\n\n      if env['HTTP_IF_MATCH']\n        return if etag_matches?(env['HTTP_IF_MATCH'], new_resource)\n\n        halt 412\n      end\n\n      nil\n    end\n\n    # Sugar for redirect (example:  redirect back)\n    def back\n      request.referer\n    end\n\n    # whether or not the status is set to 1xx\n    def informational?\n      status.between? 100, 199\n    end\n\n    # whether or not the status is set to 2xx\n    def success?\n      status.between? 200, 299\n    end\n\n    # whether or not the status is set to 3xx\n    def redirect?\n      status.between? 300, 399\n    end\n\n    # whether or not the status is set to 4xx\n    def client_error?\n      status.between? 400, 499\n    end\n\n    # whether or not the status is set to 5xx\n    def server_error?\n      status.between? 500, 599\n    end\n\n    # whether or not the status is set to 404\n    def not_found?\n      status == 404\n    end\n\n    # whether or not the status is set to 400\n    def bad_request?\n      status == 400\n    end\n\n    # Generates a Time object from the given value.\n    # Used by #expires and #last_modified.\n    def time_for(value)\n      if value.is_a? Numeric\n        Time.at value\n      elsif value.respond_to? :to_s\n        Time.parse value.to_s\n      else\n        value.to_time\n      end\n    rescue ArgumentError => e\n      raise e\n    rescue Exception\n      raise ArgumentError, \"unable to convert #{value.inspect} to a Time object\"\n    end\n\n    private\n\n    # Helper method checking if a ETag value list includes the current ETag.\n    def etag_matches?(list, new_resource = request.post?)\n      return !new_resource if list == '*'\n\n      list.to_s.split(/\\s*,\\s*/).include? response['ETag']\n    end\n\n    def with_params(temp_params)\n      original = @params\n      @params = temp_params\n      yield\n    ensure\n      @params = original if original\n    end\n  end\n\n  # Template rendering methods. Each method takes the name of a template\n  # to render as a Symbol and returns a String with the rendered output,\n  # as well as an optional hash with additional options.\n  #\n  # `template` is either the name or path of the template as symbol\n  # (Use `:'subdir/myview'` for views in subdirectories), or a string\n  # that will be rendered.\n  #\n  # Possible options are:\n  #   :content_type   The content type to use, same arguments as content_type.\n  #   :layout         If set to something falsy, no layout is rendered, otherwise\n  #                   the specified layout is used\n  #   :layout_engine  Engine to use for rendering the layout.\n  #   :locals         A hash with local variables that should be available\n  #                   in the template\n  #   :scope          If set, template is evaluate with the binding of the given\n  #                   object rather than the application instance.\n  #   :views          Views directory to use.\n  module Templates\n    module ContentTyped\n      attr_accessor :content_type\n    end\n\n    def initialize\n      super\n      @default_layout = :layout\n      @preferred_extension = nil\n    end\n\n    def erb(template, options = {}, locals = {}, &block)\n      render(:erb, template, options, locals, &block)\n    end\n\n    def haml(template, options = {}, locals = {}, &block)\n      render(:haml, template, options, locals, &block)\n    end\n\n    def builder(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:builder, template, options, locals, &block)\n    end\n\n    def liquid(template, options = {}, locals = {}, &block)\n      render(:liquid, template, options, locals, &block)\n    end\n\n    def markdown(template, options = {}, locals = {})\n      options[:exclude_outvar] = true\n      render :markdown, template, options, locals\n    end\n\n    def rdoc(template, options = {}, locals = {})\n      render :rdoc, template, options, locals\n    end\n\n    def asciidoc(template, options = {}, locals = {})\n      render :asciidoc, template, options, locals\n    end\n\n    def markaby(template = nil, options = {}, locals = {}, &block)\n      render_ruby(:mab, template, options, locals, &block)\n    end\n\n    def nokogiri(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:nokogiri, template, options, locals, &block)\n    end\n\n    def slim(template, options = {}, locals = {}, &block)\n      render(:slim, template, options, locals, &block)\n    end\n\n    def yajl(template, options = {}, locals = {})\n      options[:default_content_type] = :json\n      render :yajl, template, options, locals\n    end\n\n    def rabl(template, options = {}, locals = {})\n      Rabl.register!\n      render :rabl, template, options, locals\n    end\n\n    # Calls the given block for every possible template file in views,\n    # named name.ext, where ext is registered on engine.\n    def find_template(views, name, engine)\n      yield ::File.join(views, \"#{name}.#{@preferred_extension}\")\n\n      Tilt.default_mapping.extensions_for(engine).each do |ext|\n        yield ::File.join(views, \"#{name}.#{ext}\") unless ext == @preferred_extension\n      end\n    end\n\n    private\n\n    # logic shared between builder and nokogiri\n    def render_ruby(engine, template, options = {}, locals = {}, &block)\n      if template.is_a?(Hash)\n        options = template\n        template = nil\n      end\n      template = proc { block } if template.nil?\n      render engine, template, options, locals\n    end\n\n    def render(engine, data, options = {}, locals = {}, &block)\n      # merge app-level options\n      engine_options = settings.respond_to?(engine) ? settings.send(engine) : {}\n      options.merge!(engine_options) { |_key, v1, _v2| v1 }\n\n      # extract generic options\n      locals          = options.delete(:locals) || locals         || {}\n      views           = options.delete(:views)  || settings.views || './views'\n      layout          = options[:layout]\n      layout          = false if layout.nil? && options.include?(:layout)\n      eat_errors      = layout.nil?\n      layout          = engine_options[:layout] if layout.nil? || (layout == true && engine_options[:layout] != false)\n      layout          = @default_layout         if layout.nil? || (layout == true)\n      layout_options  = options.delete(:layout_options) || {}\n      content_type    = options.delete(:default_content_type)\n      content_type    = options.delete(:content_type)   || content_type\n      layout_engine   = options.delete(:layout_engine)  || engine\n      scope           = options.delete(:scope)          || self\n      exclude_outvar  = options.delete(:exclude_outvar)\n      options.delete(:layout)\n\n      # set some defaults\n      options[:outvar] ||= '@_out_buf' unless exclude_outvar\n      options[:default_encoding] ||= settings.default_encoding\n\n      # compile and render template\n      begin\n        layout_was      = @default_layout\n        @default_layout = false\n        template        = compile_template(engine, data, options, views)\n        output          = template.render(scope, locals, &block)\n      ensure\n        @default_layout = layout_was\n      end\n\n      # render layout\n      if layout\n        extra_options = { views: views, layout: false, eat_errors: eat_errors, scope: scope }\n        options = options.merge(extra_options).merge!(layout_options)\n\n        catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } }\n      end\n\n      output.extend(ContentTyped).content_type = content_type if content_type\n      output\n    end\n\n    def compile_template(engine, data, options, views)\n      eat_errors = options.delete :eat_errors\n      template = Tilt[engine]\n      raise \"Template engine not found: #{engine}\" if template.nil?\n\n      case data\n      when Symbol\n        template_cache.fetch engine, data, options, views do\n          body, path, line = settings.templates[data]\n          if body\n            body = body.call if body.respond_to?(:call)\n            template.new(path, line.to_i, options) { body }\n          else\n            found = false\n            @preferred_extension = engine.to_s\n            find_template(views, data, template) do |file|\n              path ||= file # keep the initial path rather than the last one\n              found = File.exist?(file)\n              if found\n                path = file\n                break\n              end\n            end\n            throw :layout_missing if eat_errors && !found\n            template.new(path, 1, options)\n          end\n        end\n      when Proc\n        compile_block_template(template, options, &data)\n      when String\n        template_cache.fetch engine, data, options, views do\n          compile_block_template(template, options) { data }\n        end\n      else\n        raise ArgumentError, \"Sorry, don't know how to render #{data.inspect}.\"\n      end\n    end\n\n    def compile_block_template(template, options, &body)\n      first_location = caller_locations.first\n      path = first_location.path\n      line = first_location.lineno\n      path = options[:path] || path\n      line = options[:line] || line\n      template.new(path, line.to_i, options, &body)\n    end\n  end\n\n  # Base class for all Sinatra applications and middleware.\n  class Base\n    include Rack::Utils\n    include Helpers\n    include Templates\n\n    URI_INSTANCE = URI::Parser.new\n\n    attr_accessor :app, :env, :request, :response, :params\n    attr_reader   :template_cache\n\n    def initialize(app = nil, **_kwargs)\n      super()\n      @app = app\n      @template_cache = Tilt::Cache.new\n      @pinned_response = nil # whether a before! filter pinned the content-type\n      yield self if block_given?\n    end\n\n    # Rack call interface.\n    def call(env)\n      dup.call!(env)\n    end\n\n    def call!(env) # :nodoc:\n      @env      = env\n      @params   = IndifferentHash.new\n      @request  = Request.new(env)\n      @response = Response.new\n      @pinned_response = nil\n      template_cache.clear if settings.reload_templates\n\n      invoke { dispatch! }\n      invoke { error_block!(response.status) } unless @env['sinatra.error']\n\n      unless @response['Content-Type']\n        if Array === body && body[0].respond_to?(:content_type)\n          content_type body[0].content_type\n        elsif (default = settings.default_content_type)\n          content_type default\n        end\n      end\n\n      @response.finish\n    end\n\n    # Access settings defined with Base.set.\n    def self.settings\n      self\n    end\n\n    # Access settings defined with Base.set.\n    def settings\n      self.class.settings\n    end\n\n    # Exit the current block, halts any further processing\n    # of the request, and returns the specified response.\n    def halt(*response)\n      response = response.first if response.length == 1\n      throw :halt, response\n    end\n\n    # Pass control to the next matching route.\n    # If there are no more matching routes, Sinatra will\n    # return a 404 response.\n    def pass(&block)\n      throw :pass, block\n    end\n\n    # Forward the request to the downstream app -- middleware only.\n    def forward\n      raise 'downstream app not set' unless @app.respond_to? :call\n\n      status, headers, body = @app.call env\n      @response.status = status\n      @response.body = body\n      @response.headers.merge! headers\n      nil\n    end\n\n    private\n\n    # Run filters defined on the class and all superclasses.\n    # Accepts an optional block to call after each filter is applied.\n    def filter!(type, base = settings, &block)\n      filter!(type, base.superclass, &block) if base.superclass.respond_to?(:filters)\n      base.filters[type].each do |args|\n        result = process_route(*args)\n        block.call(result) if block_given?\n      end\n    end\n\n    # Run routes defined on the class and all superclasses.\n    def route!(base = settings, pass_block = nil)\n      routes = base.routes[@request.request_method]\n\n      routes&.each do |pattern, conditions, block|\n        response.delete_header('Content-Type') unless @pinned_response\n\n        returned_pass_block = process_route(pattern, conditions) do |*args|\n          env['sinatra.route'] = \"#{@request.request_method} #{pattern}\"\n          route_eval { block[*args] }\n        end\n\n        # don't wipe out pass_block in superclass\n        pass_block = returned_pass_block if returned_pass_block\n      end\n\n      # Run routes defined in superclass.\n      if base.superclass.respond_to?(:routes)\n        return route!(base.superclass, pass_block)\n      end\n\n      route_eval(&pass_block) if pass_block\n      route_missing\n    end\n\n    # Run a route block and throw :halt with the result.\n    def route_eval\n      throw :halt, yield\n    end\n\n    # If the current request matches pattern and conditions, fill params\n    # with keys and call the given block.\n    # Revert params afterwards.\n    #\n    # Returns pass block.\n    def process_route(pattern, conditions, block = nil, values = [])\n      route = @request.path_info\n      route = '/' if route.empty? && !settings.empty_path_info?\n      route = route[0..-2] if !settings.strict_paths? && route != '/' && route.end_with?('/')\n\n      params = pattern.params(route)\n      return unless params\n\n      params.delete('ignore') # TODO: better params handling, maybe turn it into \"smart\" object or detect changes\n      force_encoding(params)\n      @params = @params.merge(params) { |_k, v1, v2| v2 || v1 } if params.any?\n\n      regexp_exists = pattern.is_a?(Mustermann::Regular) || (pattern.respond_to?(:patterns) && pattern.patterns.any? { |subpattern| subpattern.is_a?(Mustermann::Regular) })\n      if regexp_exists\n        captures           = pattern.match(route).captures.map { |c| URI_INSTANCE.unescape(c) if c }\n        values            += captures\n        @params[:captures] = force_encoding(captures) unless captures.nil? || captures.empty?\n      else\n        values += params.values.flatten\n      end\n\n      catch(:pass) do\n        conditions.each { |c| throw :pass if c.bind(self).call == false }\n        block ? block[self, values] : yield(self, values)\n      end\n    rescue StandardError\n      @env['sinatra.error.params'] = @params\n      raise\n    ensure\n      params ||= {}\n      params.each { |k, _| @params.delete(k) } unless @env['sinatra.error.params']\n    end\n\n    # No matching route was found or all routes passed. The default\n    # implementation is to forward the request downstream when running\n    # as middleware (@app is non-nil); when no downstream app is set, raise\n    # a NotFound exception. Subclasses can override this method to perform\n    # custom route miss logic.\n    def route_missing\n      raise NotFound unless @app\n\n      forward\n    end\n\n    # Attempt to serve static files from public directory. Throws :halt when\n    # a matching file is found, returns nil otherwise.\n    def static!(options = {})\n      return if (public_dir = settings.public_folder).nil?\n\n      path = \"#{public_dir}#{URI_INSTANCE.unescape(request.path_info)}\"\n      return unless valid_path?(path)\n\n      path = File.expand_path(path)\n      return unless path.start_with?(\"#{File.expand_path(public_dir)}/\")\n\n      return unless File.file?(path)\n\n      env['sinatra.static_file'] = path\n      cache_control(*settings.static_cache_control) if settings.static_cache_control?\n      send_file path, options.merge(disposition: nil)\n    end\n\n    # Run the block with 'throw :halt' support and apply result to the response.\n    def invoke(&block)\n      res = catch(:halt, &block)\n\n      res = [res] if (Integer === res) || (String === res)\n      if (Array === res) && (Integer === res.first)\n        res = res.dup\n        status(res.shift)\n        body(res.pop)\n        headers(*res)\n      elsif res.respond_to? :each\n        body res\n      end\n      nil # avoid double setting the same response tuple twice\n    end\n\n    # Dispatch a request with error handling.\n    def dispatch!\n      # Avoid passing frozen string in force_encoding\n      @params.merge!(@request.params).each do |key, val|\n        next unless val.respond_to?(:force_encoding)\n\n        val = val.dup if val.frozen?\n        @params[key] = force_encoding(val)\n      end\n\n      invoke do\n        static! if settings.static? && (request.get? || request.head?)\n        filter! :before do\n          @pinned_response = !response['Content-Type'].nil?\n        end\n        route!\n      end\n    rescue ::Exception => e\n      invoke { handle_exception!(e) }\n    ensure\n      begin\n        filter! :after unless env['sinatra.static_file']\n      rescue ::Exception => e\n        invoke { handle_exception!(e) } unless @env['sinatra.error']\n      end\n    end\n\n    # Error handling during requests.\n    def handle_exception!(boom)\n      error_params = @env['sinatra.error.params']\n\n      @params = @params.merge(error_params) if error_params\n\n      @env['sinatra.error'] = boom\n\n      http_status = if boom.is_a? Sinatra::Error\n                      if boom.respond_to? :http_status\n                        boom.http_status\n                      elsif settings.use_code? && boom.respond_to?(:code)\n                        boom.code\n                      end\n                    end\n\n      http_status = 500 unless http_status&.between?(400, 599)\n      status(http_status)\n\n      if server_error?\n        dump_errors! boom if settings.dump_errors?\n        raise boom if settings.show_exceptions? && (settings.show_exceptions != :after_handler)\n      elsif not_found?\n        headers['X-Cascade'] = 'pass' if settings.x_cascade?\n      end\n\n      if (res = error_block!(boom.class, boom) || error_block!(status, boom))\n        return res\n      end\n\n      if not_found? || bad_request?\n        if boom.message && boom.message != boom.class.name\n          body Rack::Utils.escape_html(boom.message)\n        else\n          content_type 'text/html'\n          body \"<h1>#{not_found? ? 'Not Found' : 'Bad Request'}</h1>\"\n        end\n      end\n\n      return unless server_error?\n\n      raise boom if settings.raise_errors? || settings.show_exceptions?\n\n      error_block! Exception, boom\n    end\n\n    # Find an custom error block for the key(s) specified.\n    def error_block!(key, *block_params)\n      base = settings\n      while base.respond_to?(:errors)\n        args_array = base.errors[key]\n\n        next base = base.superclass unless args_array\n\n        args_array.reverse_each do |args|\n          first = args == args_array.first\n          args += [block_params]\n          resp = process_route(*args)\n          return resp unless resp.nil? && !first\n        end\n      end\n      return false unless key.respond_to?(:superclass) && (key.superclass < Exception)\n\n      error_block!(key.superclass, *block_params)\n    end\n\n    def dump_errors!(boom)\n      msg = [\"#{Time.now.strftime('%Y-%m-%d %H:%M:%S')} - #{boom.class} - #{boom.message}:\", *boom.backtrace].join(\"\\n\\t\")\n      @env['rack.errors'].puts(msg)\n    end\n\n    class << self\n      CALLERS_TO_IGNORE = [ # :nodoc:\n        %r{/sinatra(/(base|main|show_exceptions))?\\.rb$},   # all sinatra code\n        %r{lib/tilt.*\\.rb$},                                # all tilt code\n        /^\\(.*\\)$/,                                         # generated code\n        %r{rubygems/(custom|core_ext/kernel)_require\\.rb$}, # rubygems require hacks\n        /active_support/,                                   # active_support require hacks\n        %r{bundler(/(?:runtime|inline))?\\.rb},              # bundler require hacks\n        /<internal:/                                        # internal in ruby >= 1.9.2\n      ].freeze\n\n      attr_reader :routes, :filters, :templates, :errors\n\n      # Removes all routes, filters, middleware and extension hooks from the\n      # current class (not routes/filters/... defined by its superclass).\n      def reset!\n        @conditions     = []\n        @routes         = {}\n        @filters        = { before: [], after: [] }\n        @errors         = {}\n        @middleware     = []\n        @prototype      = nil\n        @extensions     = []\n\n        @templates = if superclass.respond_to?(:templates)\n                       Hash.new { |_hash, key| superclass.templates[key] }\n                     else\n                       {}\n                     end\n      end\n\n      # Extension modules registered on this class and all superclasses.\n      def extensions\n        if superclass.respond_to?(:extensions)\n          (@extensions + superclass.extensions).uniq\n        else\n          @extensions\n        end\n      end\n\n      # Middleware used in this class and all superclasses.\n      def middleware\n        if superclass.respond_to?(:middleware)\n          superclass.middleware + @middleware\n        else\n          @middleware\n        end\n      end\n\n      # Sets an option to the given value.  If the value is a proc,\n      # the proc will be called every time the option is accessed.\n      def set(option, value = (not_set = true), ignore_setter = false, &block)\n        raise ArgumentError if block && !not_set\n\n        if block\n          value = block\n          not_set = false\n        end\n\n        if not_set\n          raise ArgumentError unless option.respond_to?(:each)\n\n          option.each { |k, v| set(k, v) }\n          return self\n        end\n\n        if respond_to?(\"#{option}=\") && !ignore_setter\n          return __send__(\"#{option}=\", value)\n        end\n\n        setter = proc { |val| set option, val, true }\n        getter = proc { value }\n\n        case value\n        when Proc\n          getter = value\n        when Symbol, Integer, FalseClass, TrueClass, NilClass\n          getter = value.inspect\n        when Hash\n          setter = proc do |val|\n            val = value.merge val if Hash === val\n            set option, val, true\n          end\n        end\n\n        define_singleton(\"#{option}=\", setter)\n        define_singleton(option, getter)\n        define_singleton(\"#{option}?\", \"!!#{option}\") unless method_defined? \"#{option}?\"\n        self\n      end\n\n      # Same as calling `set :option, true` for each of the given options.\n      def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end\n\n      # Same as calling `set :option, false` for each of the given options.\n      def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end\n\n      # Define a custom error handler. Optionally takes either an Exception\n      # class, or an HTTP status code to specify which errors should be\n      # handled.\n      def error(*codes, &block)\n        args  = compile! 'ERROR', /.*/, block\n        codes = codes.flat_map(&method(:Array))\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n        codes.each { |c| (@errors[c] ||= []) << args }\n      end\n\n      # Sugar for `error(404) { ... }`\n      def not_found(&block)\n        error(404, &block)\n      end\n\n      # Define a named template. The block must return the template source.\n      def template(name, &block)\n        filename, line = caller_locations.first\n        templates[name] = [block, filename, line.to_i]\n      end\n\n      # Define the layout template. The block must return the template source.\n      def layout(name = :layout, &block)\n        template name, &block\n      end\n\n      # Load embedded templates from the file; uses the caller's __FILE__\n      # when no file is specified.\n      def inline_templates=(file = nil)\n        file = (caller_files.first || File.expand_path($0)) if file.nil? || file == true\n\n        begin\n          io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file)\n          app, data = io.gsub(\"\\r\\n\", \"\\n\").split(/^__END__$/, 2)\n        rescue Errno::ENOENT\n          app, data = nil\n        end\n\n        return unless data\n\n        encoding = if app && app =~ /([^\\n]*\\n)?#[^\\n]*coding: *(\\S+)/m\n                     $2\n                   else\n                     settings.default_encoding\n                   end\n\n        lines = app.count(\"\\n\") + 1\n        template = nil\n        force_encoding data, encoding\n        data.each_line do |line|\n          lines += 1\n          if line =~ /^@@\\s*(.*\\S)\\s*$/\n            template = force_encoding(String.new, encoding)\n            templates[$1.to_sym] = [template, file, lines]\n          elsif template\n            template << line\n          end\n        end\n      end\n\n      # Lookup or register a mime type in Rack's mime registry.\n      def mime_type(type, value = nil)\n        return type      if type.nil?\n        return type.to_s if type.to_s.include?('/')\n\n        type = \".#{type}\" unless type.to_s[0] == '.'\n        return Rack::Mime.mime_type(type, nil) unless value\n\n        Rack::Mime::MIME_TYPES[type] = value\n      end\n\n      # provides all mime types matching type, including deprecated types:\n      #   mime_types :html # => ['text/html']\n      #   mime_types :js   # => ['application/javascript', 'text/javascript']\n      def mime_types(type)\n        type = mime_type type\n        type =~ %r{^application/(xml|javascript)$} ? [type, \"text/#{$1}\"] : [type]\n      end\n\n      # Define a before filter; runs before all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def before(path = /.*/, **options, &block)\n        add_filter(:before, path, **options, &block)\n      end\n\n      # Define an after filter; runs after all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def after(path = /.*/, **options, &block)\n        add_filter(:after, path, **options, &block)\n      end\n\n      # add a filter\n      def add_filter(type, path = /.*/, **options, &block)\n        filters[type] << compile!(type, path, block, **options)\n      end\n\n      # Add a route condition. The route is considered non-matching when the\n      # block returns false.\n      def condition(name = \"#{caller.first[/`.*'/]} condition\", &block)\n        @conditions << generate_method(name, &block)\n      end\n\n      def public=(value)\n        warn_for_deprecation ':public is no longer used to avoid overloading Module#public, use :public_folder or :public_dir instead'\n        set(:public_folder, value)\n      end\n\n      def public_dir=(value)\n        self.public_folder = value\n      end\n\n      def public_dir\n        public_folder\n      end\n\n      # Defining a `GET` handler also automatically defines\n      # a `HEAD` handler.\n      def get(path, opts = {}, &block)\n        conditions = @conditions.dup\n        route('GET', path, opts, &block)\n\n        @conditions = conditions\n        route('HEAD', path, opts, &block)\n      end\n\n      def put(path, opts = {}, &block)     route 'PUT',     path, opts, &block end\n\n      def post(path, opts = {}, &block)    route 'POST',    path, opts, &block end\n\n      def delete(path, opts = {}, &block)  route 'DELETE',  path, opts, &block end\n\n      def head(path, opts = {}, &block)    route 'HEAD',    path, opts, &block end\n\n      def options(path, opts = {}, &block) route 'OPTIONS', path, opts, &block end\n\n      def patch(path, opts = {}, &block)   route 'PATCH',   path, opts, &block end\n\n      def link(path, opts = {}, &block)    route 'LINK',    path, opts, &block end\n\n      def unlink(path, opts = {}, &block)  route 'UNLINK',  path, opts, &block end\n\n      # Makes the methods defined in the block and in the Modules given\n      # in `extensions` available to the handlers and templates\n      def helpers(*extensions, &block)\n        class_eval(&block)   if block_given?\n        include(*extensions) if extensions.any?\n      end\n\n      # Register an extension. Alternatively take a block from which an\n      # extension will be created and registered on the fly.\n      def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end\n\n      def development?; environment == :development end\n      def production?;  environment == :production  end\n      def test?;        environment == :test        end\n\n      # Set configuration options for Sinatra and/or the app.\n      # Allows scoping of settings for certain environments.\n      def configure(*envs)\n        yield self if envs.empty? || envs.include?(environment.to_sym)\n      end\n\n      # Use the specified Rack middleware\n      def use(middleware, *args, &block)\n        @prototype = nil\n        @middleware << [middleware, args, block]\n      end\n      ruby2_keywords(:use) if respond_to?(:ruby2_keywords, true)\n\n      # Stop the self-hosted server if running.\n      def quit!\n        return unless running?\n\n        # Use Thin's hard #stop! if available, otherwise just #stop.\n        running_server.respond_to?(:stop!) ? running_server.stop! : running_server.stop\n        warn '== Sinatra has ended his set (crowd applauds)' unless suppress_messages?\n        set :running_server, nil\n        set :handler_name, nil\n      end\n\n      alias stop! quit!\n\n      # Run the Sinatra app as a self-hosted server using\n      # Puma, Falcon, Mongrel, or WEBrick (in that order). If given a block, will call\n      # with the constructed handler once we have taken the stage.\n      def run!(options = {}, &block)\n        return if running?\n\n        set options\n        handler         = Rack::Handler.pick(server)\n        handler_name    = handler.name.gsub(/.*::/, '')\n        server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {}\n        server_settings.merge!(Port: port, Host: bind)\n\n        begin\n          start_server(handler, server_settings, handler_name, &block)\n        rescue Errno::EADDRINUSE\n          warn \"== Someone is already performing on port #{port}!\"\n          raise\n        ensure\n          quit!\n        end\n      end\n\n      alias start! run!\n\n      # Check whether the self-hosted server is running or not.\n      def running?\n        running_server?\n      end\n\n      # The prototype instance used to process requests.\n      def prototype\n        @prototype ||= new\n      end\n\n      # Create a new instance without middleware in front of it.\n      alias new! new unless method_defined? :new!\n\n      # Create a new instance of the class fronted by its middleware\n      # pipeline. The object is guaranteed to respond to #call but may not be\n      # an instance of the class new was called on.\n      def new(*args, &block)\n        instance = new!(*args, &block)\n        Wrapper.new(build(instance).to_app, instance)\n      end\n      ruby2_keywords :new if respond_to?(:ruby2_keywords, true)\n\n      # Creates a Rack::Builder instance with all the middleware set up and\n      # the given +app+ as end point.\n      def build(app)\n        builder = Rack::Builder.new\n        setup_default_middleware builder\n        setup_middleware builder\n        builder.run app\n        builder\n      end\n\n      def call(env)\n        synchronize { prototype.call(env) }\n      end\n\n      # Like Kernel#caller but excluding certain magic entries and without\n      # line / method information; the resulting array contains filenames only.\n      def caller_files\n        cleaned_caller(1).flatten\n      end\n\n      private\n\n      # Starts the server by running the Rack Handler.\n      def start_server(handler, server_settings, handler_name)\n        # Ensure we initialize middleware before startup, to match standard Rack\n        # behavior, by ensuring an instance exists:\n        prototype\n        # Run the instance we created:\n        handler.run(self, **server_settings) do |server|\n          unless suppress_messages?\n            warn \"== Sinatra (v#{Sinatra::VERSION}) has taken the stage on #{port} for #{environment} with backup from #{handler_name}\"\n          end\n\n          setup_traps\n          set :running_server, server\n          set :handler_name,   handler_name\n          server.threaded = settings.threaded if server.respond_to? :threaded=\n\n          yield server if block_given?\n        end\n      end\n\n      def suppress_messages?\n        handler_name =~ /cgi/i || quiet\n      end\n\n      def setup_traps\n        return unless traps?\n\n        at_exit { quit! }\n\n        %i[INT TERM].each do |signal|\n          old_handler = trap(signal) do\n            quit!\n            old_handler.call if old_handler.respond_to?(:call)\n          end\n        end\n\n        set :traps, false\n      end\n\n      # Dynamically defines a method on settings.\n      def define_singleton(name, content = Proc.new)\n        singleton_class.class_eval do\n          undef_method(name) if method_defined? name\n          String === content ? class_eval(\"def #{name}() #{content}; end\") : define_method(name, &content)\n        end\n      end\n\n      # Condition for matching host name. Parameter might be String or Regexp.\n      def host_name(pattern)\n        condition { pattern === request.host }\n      end\n\n      # Condition for matching user agent. Parameter should be Regexp.\n      # Will set params[:agent].\n      def user_agent(pattern)\n        condition do\n          if request.user_agent.to_s =~ pattern\n            @params[:agent] = $~[1..-1]\n            true\n          else\n            false\n          end\n        end\n      end\n      alias agent user_agent\n\n      # Condition for matching mimetypes. Accepts file extensions.\n      def provides(*types)\n        types.map! { |t| mime_types(t) }\n        types.flatten!\n        condition do\n          response_content_type = response['Content-Type']\n          preferred_type = request.preferred_type(types)\n\n          if response_content_type\n            types.include?(response_content_type) || types.include?(response_content_type[/^[^;]+/])\n          elsif preferred_type\n            params = (preferred_type.respond_to?(:params) ? preferred_type.params : {})\n            content_type(preferred_type, params)\n            true\n          else\n            false\n          end\n        end\n      end\n\n      def route(verb, path, options = {}, &block)\n        enable :empty_path_info if path == '' && empty_path_info.nil?\n        signature = compile!(verb, path, block, **options)\n        (@routes[verb] ||= []) << signature\n        invoke_hook(:route_added, verb, path, block)\n        signature\n      end\n\n      def invoke_hook(name, *args)\n        extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end\n\n      def generate_method(method_name, &block)\n        define_method(method_name, &block)\n        method = instance_method method_name\n        remove_method method_name\n        method\n      end\n\n      def compile!(verb, path, block, **options)\n        # Because of self.options.host\n        host_name(options.delete(:host)) if options.key?(:host)\n        # Pass Mustermann opts to compile()\n        route_mustermann_opts = options.key?(:mustermann_opts) ? options.delete(:mustermann_opts) : {}.freeze\n\n        options.each_pair { |option, args| send(option, *args) }\n\n        pattern                 = compile(path, route_mustermann_opts)\n        method_name             = \"#{verb} #{path}\"\n        unbound_method          = generate_method(method_name, &block)\n        conditions = @conditions\n        @conditions = []\n        wrapper = block.arity.zero? ?\n          proc { |a, _p| unbound_method.bind(a).call } :\n          proc { |a, p| unbound_method.bind(a).call(*p) }\n\n        [pattern, conditions, wrapper]\n      end\n\n      def compile(path, route_mustermann_opts = {})\n        Mustermann.new(path, **mustermann_opts.merge(route_mustermann_opts))\n      end\n\n      def setup_default_middleware(builder)\n        builder.use ExtendedRack\n        builder.use ShowExceptions       if show_exceptions?\n        builder.use Rack::MethodOverride if method_override?\n        builder.use Rack::Head\n        setup_logging    builder\n        setup_sessions   builder\n        setup_protection builder\n      end\n\n      def setup_middleware(builder)\n        middleware.each { |c, a, b| builder.use(c, *a, &b) }\n      end\n\n      def setup_logging(builder)\n        if logging?\n          setup_common_logger(builder)\n          setup_custom_logger(builder)\n        elsif logging == false\n          setup_null_logger(builder)\n        end\n      end\n\n      def setup_null_logger(builder)\n        builder.use Rack::NullLogger\n      end\n\n      def setup_common_logger(builder)\n        builder.use Sinatra::CommonLogger\n      end\n\n      def setup_custom_logger(builder)\n        if logging.respond_to? :to_int\n          builder.use Rack::Logger, logging\n        else\n          builder.use Rack::Logger\n        end\n      end\n\n      def setup_protection(builder)\n        return unless protection?\n\n        options = Hash === protection ? protection.dup : {}\n        options = {\n          img_src: \"'self' data:\",\n          font_src: \"'self'\"\n        }.merge options\n\n        protect_session = options.fetch(:session) { sessions? }\n        options[:without_session] = !protect_session\n\n        options[:reaction] ||= :drop_session\n\n        builder.use Rack::Protection, options\n      end\n\n      def setup_sessions(builder)\n        return unless sessions?\n\n        options = {}\n        options[:secret] = session_secret if session_secret?\n        options.merge! sessions.to_hash if sessions.respond_to? :to_hash\n        builder.use session_store, options\n      end\n\n      def inherited(subclass)\n        subclass.reset!\n        subclass.set :app_file, caller_files.first unless subclass.app_file?\n        super\n      end\n\n      @@mutex = Mutex.new\n      def synchronize(&block)\n        if lock?\n          @@mutex.synchronize(&block)\n        else\n          yield\n        end\n      end\n\n      # used for deprecation warnings\n      def warn_for_deprecation(message)\n        warn message + \"\\n\\tfrom #{cleaned_caller.first.join(':')}\"\n      end\n\n      # Like Kernel#caller but excluding certain magic entries\n      def cleaned_caller(keep = 3)\n        caller(1)\n          .map! { |line| line.split(/:(?=\\d|in )/, 3)[0, keep] }\n          .reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } }\n      end\n    end\n\n    # Force data to specified encoding. It defaults to settings.default_encoding\n    # which is UTF-8 by default\n    def self.force_encoding(data, encoding = default_encoding)\n      return if data == settings || data.is_a?(Tempfile)\n\n      if data.respond_to? :force_encoding\n        data.force_encoding(encoding).encode!\n      elsif data.respond_to? :each_value\n        data.each_value { |v| force_encoding(v, encoding) }\n      elsif data.respond_to? :each\n        data.each { |v| force_encoding(v, encoding) }\n      end\n      data\n    end\n\n    def force_encoding(*args)\n      settings.force_encoding(*args)\n    end\n\n    reset!\n\n    set :environment, (ENV['APP_ENV'] || ENV['RACK_ENV'] || :development).to_sym\n    set :raise_errors, proc { test? }\n    set :dump_errors, proc { !test? }\n    set :show_exceptions, proc { development? }\n    set :sessions, false\n    set :session_store, Rack::Protection::EncryptedCookie\n    set :logging, false\n    set :protection, true\n    set :method_override, false\n    set :use_code, false\n    set :default_encoding, 'utf-8'\n    set :x_cascade, true\n    set :add_charset, %w[javascript xml xhtml+xml].map { |t| \"application/#{t}\" }\n    settings.add_charset << %r{^text/}\n    set :mustermann_opts, {}\n    set :default_content_type, 'text/html'\n\n    # explicitly generating a session secret eagerly to play nice with preforking\n    begin\n      require 'securerandom'\n      set :session_secret, SecureRandom.hex(64)\n    rescue LoadError, NotImplementedError\n      # SecureRandom raises a NotImplementedError if no random device is available\n      set :session_secret, format('%064x', Kernel.rand((2**256) - 1))\n    end\n\n    class << self\n      alias methodoverride? method_override?\n      alias methodoverride= method_override=\n    end\n\n    set :run, false                       # start server via at-exit hook?\n    set :running_server, nil\n    set :handler_name, nil\n    set :traps, true\n    set :server, %w[HTTP webrick]\n    set :bind, proc { development? ? 'localhost' : '0.0.0.0' }\n    set :port, Integer(ENV['PORT'] && !ENV['PORT'].empty? ? ENV['PORT'] : 4567)\n    set :quiet, false\n\n    ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE\n\n    server.unshift 'puma'\n    server.unshift 'falcon'   if ruby_engine != 'jruby'\n    server.unshift 'mongrel'  if ruby_engine.nil?\n    server.unshift 'thin'     if ruby_engine != 'jruby'\n    server.unshift 'trinidad' if ruby_engine == 'jruby'\n\n    set :absolute_redirects, true\n    set :prefixed_redirects, false\n    set :empty_path_info, nil\n    set :strict_paths, true\n\n    set :app_file, nil\n    set :root, proc { app_file && File.expand_path(File.dirname(app_file)) }\n    set :views, proc { root && File.join(root, 'views') }\n    set :reload_templates, proc { development? }\n    set :lock, false\n    set :threaded, true\n\n    set :public_folder, proc { root && File.join(root, 'public') }\n    set :static, proc { public_folder && File.exist?(public_folder) }\n    set :static_cache_control, false\n\n    error ::Exception do\n      response.status = 500\n      content_type 'text/html'\n      '<h1>Internal Server Error</h1>'\n    end\n\n    configure :development do\n      get '/__sinatra__/:image.png' do\n        filename = __dir__ + \"/images/#{params[:image].to_i}.png\"\n        content_type :png\n        send_file filename\n      end\n\n      error NotFound do\n        content_type 'text/html'\n\n        if instance_of?(Sinatra::Application)\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            #{request.request_method.downcase} '#{request.path_info}' do\n              \"Hello World\"\n            end\n          RUBY\n        else\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            class #{self.class}\n              #{request.request_method.downcase} '#{request.path_info}' do\n                \"Hello World\"\n              end\n            end\n          RUBY\n\n          file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(%r{^/}, '')\n          code = \"# in #{file}\\n#{code}\" unless file.empty?\n        end\n\n        <<-HTML.gsub(/^ {10}/, '')\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <style type=\"text/css\">\n            body { text-align:center;font-family:helvetica,arial;font-size:22px;\n              color:#888;margin:20px}\n            #c {margin:0 auto;width:500px;text-align:left}\n            </style>\n          </head>\n          <body>\n            <h2>Sinatra doesn\u2019t know this ditty.</h2>\n            <img src='#{uri '/__sinatra__/404.png'}'>\n            <div id=\"c\">\n              Try this:\n              <pre>#{Rack::Utils.escape_html(code)}</pre>\n            </div>\n          </body>\n          </html>\n        HTML\n      end\n    end\n  end\n\n  # Execution context for classic style (top-level) applications. All\n  # DSL methods executed on main are delegated to this class.\n  #\n  # The Application class should not be subclassed, unless you want to\n  # inherit all settings, routes, handlers, and error pages from the\n  # top-level. Subclassing Sinatra::Base is highly recommended for\n  # modular applications.\n  class Application < Base\n    set :logging, proc { !test? }\n    set :method_override, true\n    set :run, proc { !test? }\n    set :app_file, nil\n\n    def self.register(*extensions, &block) # :nodoc:\n      added_methods = extensions.flat_map(&:public_instance_methods)\n      Delegator.delegate(*added_methods)\n      super(*extensions, &block)\n    end\n  end\n\n  # Sinatra delegation mixin. Mixing this module into an object causes all\n  # methods to be delegated to the Sinatra::Application class. Used primarily\n  # at the top-level.\n  module Delegator # :nodoc:\n    def self.delegate(*methods)\n      methods.each do |method_name|\n        define_method(method_name) do |*args, &block|\n          return super(*args, &block) if respond_to? method_name\n\n          Delegator.target.send(method_name, *args, &block)\n        end\n        # ensure keyword argument passing is compatible with ruby >= 2.7\n        ruby2_keywords(method_name) if respond_to?(:ruby2_keywords, true)\n        private method_name\n      end\n    end\n\n    delegate :get, :patch, :put, :post, :delete, :head, :options, :link, :unlink,\n             :template, :layout, :before, :after, :error, :not_found, :configure,\n             :set, :mime_type, :enable, :disable, :use, :development?, :test?,\n             :production?, :helpers, :settings, :register\n\n    class << self\n      attr_accessor :target\n    end\n\n    self.target = Application\n  end\n\n  class Wrapper\n    def initialize(stack, instance)\n      @stack = stack\n      @instance = instance\n    end\n\n    def settings\n      @instance.settings\n    end\n\n    def helpers\n      @instance\n    end\n\n    def call(env)\n      @stack.call(env)\n    end\n\n    def inspect\n      \"#<#{@instance.class} app_file=#{settings.app_file.inspect}>\"\n    end\n  end\n\n  # Create a new Sinatra application; the block is evaluated in the class scope.\n  def self.new(base = Base, &block)\n    base = Class.new(base)\n    base.class_eval(&block) if block_given?\n    base\n  end\n\n  # Extend the top-level DSL with the modules provided.\n  def self.register(*extensions, &block)\n    Delegator.target.register(*extensions, &block)\n  end\n\n  # Include the helper modules provided in Sinatra's request context.\n  def self.helpers(*extensions, &block)\n    Delegator.target.helpers(*extensions, &block)\n  end\n\n  # Use the middleware for classic applications.\n  def self.use(*args, &block)\n    Delegator.target.use(*args, &block)\n  end\nend\n", "require File.expand_path('helper', __dir__)\nrequire 'date'\nrequire 'json'\n\nclass HelpersTest < Minitest::Test\n  def test_default\n    assert true\n  end\n\n  def status_app(code, &block)\n    code += 2 if [204, 304].include? code\n    block ||= proc { }\n    mock_app do\n      get('/') do\n        status code\n        instance_eval(&block).inspect\n      end\n    end\n    get '/'\n  end\n\n  describe 'status' do\n    it 'sets the response status code' do\n      status_app 207\n      assert_equal 207, response.status\n    end\n  end\n\n  describe 'bad_request?' do\n    it 'is true for status == 400' do\n      status_app(400) { bad_request? }\n      assert_body 'true'\n    end\n\n    it 'is false for status gt 400' do\n      status_app(401) { bad_request? }\n      assert_body 'false'\n    end\n\n    it 'is false for status lt 400' do\n      status_app(399) { bad_request? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'not_found?' do\n    it 'is true for status == 404' do\n      status_app(404) { not_found? }\n      assert_body 'true'\n    end\n\n    it 'is false for status gt 404' do\n      status_app(405) { not_found? }\n      assert_body 'false'\n    end\n\n    it 'is false for status lt 404' do\n      status_app(403) { not_found? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'informational?' do\n    it 'is true for 1xx status' do\n      status_app(100 + rand(100)) { informational? }\n      assert_body 'true'\n    end\n\n    it 'is false for status > 199' do\n      status_app(200 + rand(400)) { informational? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'success?' do\n    it 'is true for 2xx status' do\n      status_app(200 + rand(100)) { success? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 200' do\n      status_app(100 + rand(100)) { success? }\n      assert_body 'false'\n    end\n\n    it 'is false for status > 299' do\n      status_app(300 + rand(300)) { success? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'redirect?' do\n    it 'is true for 3xx status' do\n      status_app(300 + rand(100)) { redirect? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 300' do\n      status_app(200 + rand(100)) { redirect? }\n      assert_body 'false'\n    end\n\n    it 'is false for status > 399' do\n      status_app(400 + rand(200)) { redirect? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'client_error?' do\n    it 'is true for 4xx status' do\n      status_app(400 + rand(100)) { client_error? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 400' do\n      status_app(200 + rand(200)) { client_error? }\n      assert_body 'false'\n    end\n\n    it 'is false for status > 499' do\n      status_app(500 + rand(100)) { client_error? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'server_error?' do\n    it 'is true for 5xx status' do\n      status_app(500 + rand(100)) { server_error? }\n      assert_body 'true'\n    end\n\n    it 'is false for status < 500' do\n      status_app(200 + rand(300)) { server_error? }\n      assert_body 'false'\n    end\n  end\n\n  describe 'body' do\n    it 'takes a block for deferred body generation' do\n      mock_app do\n        get('/') { body { 'Hello World' } }\n      end\n\n      get '/'\n      assert_equal 'Hello World', body\n    end\n\n    it 'takes a String, Array, or other object responding to #each' do\n      mock_app { get('/') { body 'Hello World' } }\n\n      get '/'\n      assert_equal 'Hello World', body\n    end\n\n    it 'can be used with other objects' do\n      mock_app do\n        get '/' do\n          body :hello => 'from json'\n        end\n\n        after do\n          if Hash === response.body\n            body response.body[:hello]\n          end\n        end\n      end\n\n      get '/'\n      assert_body 'from json'\n    end\n\n    it 'can be set in after filter' do\n      mock_app do\n        get('/') { body 'route'  }\n        after    { body 'filter' }\n      end\n\n      get '/'\n      assert_body 'filter'\n    end\n  end\n\n  describe 'redirect' do\n    it 'uses a 302 when only a path is given' do\n      mock_app do\n        get('/') do\n          redirect '/foo'\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://example.org/foo', response['Location']\n    end\n\n    it 'uses the code given when specified' do\n      mock_app do\n        get('/') do\n          redirect '/foo', 301\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 301, status\n      assert_equal '', body\n      assert_equal 'http://example.org/foo', response['Location']\n    end\n\n    it 'redirects back to request.referer when passed back' do\n      mock_app { get('/try_redirect') { redirect back } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/try_redirect', 'HTTP_REFERER' => '/foo')\n      assert_equal 302, response.status\n      assert_equal 'http://example.org/foo', response['Location']\n    end\n\n    it 'redirects using a non-standard HTTP port' do\n      mock_app { get('/') { redirect '/foo' } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/', 'SERVER_PORT' => '81')\n      assert_equal 'http://example.org:81/foo', response['Location']\n    end\n\n    it 'redirects using a non-standard HTTPS port' do\n      mock_app { get('/') { redirect '/foo' } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/', 'SERVER_PORT' => '444')\n      assert_equal 'http://example.org:444/foo', response['Location']\n    end\n\n    it 'uses 303 for post requests if request is HTTP 1.1' do\n      mock_app { post('/') { redirect '/'} }\n      post('/', {}, 'HTTP_VERSION' => 'HTTP/1.1')\n      assert_equal 303, status\n      assert_equal '', body\n      assert_equal 'http://example.org/', response['Location']\n    end\n\n    it 'uses 302 for post requests if request is HTTP 1.0' do\n      mock_app { post('/') { redirect '/'} }\n      post('/', {}, 'HTTP_VERSION' => 'HTTP/1.0')\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://example.org/', response['Location']\n    end\n\n    it 'works behind a reverse proxy' do\n      mock_app { get('/') { redirect '/foo' } }\n\n      request = Rack::MockRequest.new(@app)\n      response = request.get('/', 'HTTP_X_FORWARDED_HOST' => 'example.com', 'SERVER_PORT' => '8080')\n      assert_equal 'http://example.com/foo', response['Location']\n    end\n\n    it 'accepts absolute URIs' do\n      mock_app do\n        get('/') do\n          redirect 'http://google.com'\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://google.com', response['Location']\n    end\n\n    it 'accepts absolute URIs with a different schema' do\n      mock_app do\n        get('/') do\n          redirect 'mailto:jsmith@example.com'\n          fail 'redirect should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'mailto:jsmith@example.com', response['Location']\n    end\n\n    it 'accepts a URI object instead of a String' do\n      mock_app do\n        get('/') { redirect URI.parse('http://sinatrarb.com') }\n      end\n\n      get '/'\n      assert_equal 302, status\n      assert_equal '', body\n      assert_equal 'http://sinatrarb.com', response['Location']\n    end\n  end\n\n  describe 'error' do\n    it 'sets a status code and halts' do\n      mock_app do\n        get('/') do\n          error 501\n          fail 'error should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 501, status\n      assert_equal '', body\n    end\n\n    it 'takes an optional body' do\n      mock_app do\n        get('/') do\n          error 501, 'FAIL'\n          fail 'error should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 501, status\n      assert_equal 'FAIL', body\n    end\n\n    it 'should not invoke error handler when setting status inside an error handler' do\n      mock_app do\n        disable :raise_errors\n        not_found do\n          body \"not_found handler\"\n          status 404\n        end\n\n        error do\n          body \"error handler\"\n          status 404\n        end\n\n        get '/' do\n          raise\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal 'error handler', body\n    end\n\n    it 'should not reset the content-type to html for error handlers' do\n      mock_app do\n        disable :raise_errors\n        before    { content_type \"application/json\" }\n        not_found { JSON.dump(\"error\" => \"Not Found\") }\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal 'application/json', response.content_type\n    end\n\n    it 'should not invoke error handler when halting with 500 inside an error handler' do\n      mock_app do\n        disable :raise_errors\n        not_found do\n          body \"not_found handler\"\n          halt 404\n        end\n\n        error do\n          body \"error handler\"\n          halt 404\n        end\n\n        get '/' do\n          raise\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal 'error handler', body\n    end\n\n    it 'should not invoke not_found handler when halting with 404 inside a not found handler' do\n      mock_app do\n        disable :raise_errors\n\n        not_found do\n          body \"not_found handler\"\n          halt 500\n        end\n\n        error do\n          body \"error handler\"\n          halt 500\n        end\n      end\n\n      get '/'\n      assert_equal 500, status\n      assert_equal 'not_found handler', body\n    end\n\n    it 'uses a 500 status code when first argument is a body' do\n      mock_app do\n        get('/') do\n          error 'FAIL'\n          fail 'error should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 500, status\n      assert_equal 'FAIL', body\n    end\n  end\n\n  describe 'not_found' do\n    it 'halts with a 404 status' do\n      mock_app do\n        get('/') do\n          not_found\n          fail 'not_found should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_equal '', body\n    end\n\n    it 'does not set a X-Cascade header' do\n      mock_app do\n        get('/') do\n          not_found\n          fail 'not_found should halt'\n        end\n      end\n\n      get '/'\n      assert_equal 404, status\n      assert_nil response.headers['X-Cascade']\n    end\n  end\n\n  describe 'headers' do\n    it 'sets headers on the response object when given a Hash' do\n      mock_app do\n        get('/') do\n          headers 'X-Foo' => 'bar', 'X-Baz' => 'bling'\n          'kthx'\n        end\n      end\n\n      get '/'\n      assert ok?\n      assert_equal 'bar', response['X-Foo']\n      assert_equal 'bling', response['X-Baz']\n      assert_equal 'kthx', body\n    end\n\n    it 'returns the response headers hash when no hash provided' do\n      mock_app do\n        get('/') do\n          headers['X-Foo'] = 'bar'\n          'kthx'\n        end\n      end\n\n      get '/'\n      assert ok?\n      assert_equal 'bar', response['X-Foo']\n    end\n  end\n\n  describe 'session' do\n    it 'uses the existing rack.session' do\n      mock_app do\n        get('/') do\n          session[:foo]\n        end\n      end\n\n      get('/', {}, { 'rack.session' => { :foo => 'bar' } })\n      assert_equal 'bar', body\n    end\n\n    it 'creates a new session when none provided' do\n      mock_app do\n        enable :sessions\n\n        get('/') do\n          assert session[:foo].nil?\n          session[:foo] = 'bar'\n          redirect '/hi'\n        end\n\n        get('/hi') do\n          \"hi #{session[:foo]}\"\n        end\n      end\n\n      get '/'\n      follow_redirect!\n      assert_equal 'hi bar', body\n    end\n\n    it 'inserts session middleware' do\n      mock_app do\n        enable :sessions\n\n        get('/') do\n          assert env['rack.session']\n          assert env['rack.session.options']\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_body 'ok'\n    end\n\n    it 'sets a default session secret' do\n      mock_app do\n        enable :sessions\n\n        get('/') do\n          secret = env['rack.session.options'][:secret]\n          assert secret\n          assert_equal secret, settings.session_secret\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_body 'ok'\n    end\n\n    it 'allows disabling session secret' do\n      mock_app do\n        enable :sessions\n        disable :session_secret\n\n        get('/') do\n          assert !env['rack.session.options'].include?(:session_secret)\n          'ok'\n        end\n      end\n\n      # Silence warnings since Rack::Session::Cookie complains about the non-present session secret\n      silence_warnings do\n        get '/'\n      end\n      assert_body 'ok'\n    end\n\n    it 'accepts an options hash' do\n      mock_app do\n        set :sessions, :foo => :bar\n\n        get('/') do\n          assert_equal env['rack.session.options'][:foo], :bar\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_body 'ok'\n    end\n  end\n\n  describe 'mime_type' do\n    include Sinatra::Helpers\n\n    it \"looks up mime types in Rack's MIME registry\" do\n      Rack::Mime::MIME_TYPES['.foo'] = 'application/foo'\n      assert_equal 'application/foo', mime_type('foo')\n      assert_equal 'application/foo', mime_type('.foo')\n      assert_equal 'application/foo', mime_type(:foo)\n    end\n\n    it 'returns nil when given nil' do\n      assert mime_type(nil).nil?\n    end\n\n    it 'returns nil when media type not registered' do\n      assert mime_type(:bizzle).nil?\n    end\n\n    it 'returns the argument when given a media type string' do\n      assert_equal 'text/plain', mime_type('text/plain')\n    end\n\n    it 'turns AcceptEntry into String' do\n      type = mime_type(Sinatra::Request::AcceptEntry.new('text/plain'))\n      assert_equal String, type.class\n      assert_equal 'text/plain', type\n    end\n  end\n\n  test 'Base.mime_type registers mime type' do\n    mock_app do\n      mime_type :foo, 'application/foo'\n\n      get('/') do\n        \"foo is #{mime_type(:foo)}\"\n      end\n    end\n\n    get '/'\n    assert_equal 'foo is application/foo', body\n  end\n\n  describe 'content_type' do\n    it 'sets the Content-Type header' do\n      mock_app do\n        get('/') do\n          content_type 'text/plain'\n          'Hello World'\n        end\n      end\n\n      get '/'\n      assert_equal 'text/plain;charset=utf-8', response['Content-Type']\n      assert_equal 'Hello World', body\n    end\n\n    it 'takes media type parameters (like charset=)' do\n      mock_app do\n        get('/') do\n          content_type 'text/html', :charset => 'latin1'\n          \"<h1>Hello, World</h1>\"\n        end\n      end\n\n      get '/'\n      assert ok?\n      assert_equal 'text/html;charset=latin1', response['Content-Type']\n      assert_equal \"<h1>Hello, World</h1>\", body\n    end\n\n    it \"looks up symbols in Rack's mime types dictionary\" do\n      Rack::Mime::MIME_TYPES['.foo'] = 'application/foo'\n      mock_app do\n        get('/foo.xml') do\n          content_type :foo\n          \"I AM FOO\"\n        end\n      end\n\n      get '/foo.xml'\n      assert ok?\n      assert_equal 'application/foo', response['Content-Type']\n      assert_equal 'I AM FOO', body\n    end\n\n    it 'fails when no mime type is registered for the argument provided' do\n      mock_app do\n        get('/foo.xml') do\n          content_type :bizzle\n          \"I AM FOO\"\n        end\n      end\n\n      assert_raises(RuntimeError) { get '/foo.xml' }\n    end\n\n    it 'only sets default charset for specific mime types' do\n      tests_ran = false\n      mock_app do\n        mime_type :foo, 'text/foo'\n        mime_type :bar, 'application/bar'\n        mime_type :baz, 'application/baz'\n        add_charset << mime_type(:baz)\n        get('/') do\n          assert_equal content_type(:txt),    'text/plain;charset=utf-8'\n          assert_equal content_type(:css),    'text/css;charset=utf-8'\n          assert_equal content_type(:html),   'text/html;charset=utf-8'\n          assert_equal content_type(:foo),    'text/foo;charset=utf-8'\n          assert_equal content_type(:xml),    'application/xml;charset=utf-8'\n          assert_equal content_type(:xhtml),  'application/xhtml+xml;charset=utf-8'\n          assert_equal content_type(:js),     'application/javascript;charset=utf-8'\n          assert_equal content_type(:json),   'application/json'\n          assert_equal content_type(:bar),    'application/bar'\n          assert_equal content_type(:png),    'image/png'\n          assert_equal content_type(:baz),    'application/baz;charset=utf-8'\n          tests_ran = true\n          \"done\"\n        end\n      end\n\n      get '/'\n      assert tests_ran\n    end\n\n    it 'handles already present params' do\n      mock_app do\n        get('/') do\n          content_type 'foo/bar;level=1', :charset => 'utf-8'\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_equal 'foo/bar;level=1, charset=utf-8', response['Content-Type']\n    end\n\n    it 'does not add charset if present' do\n      mock_app do\n        get('/') do\n          content_type 'text/plain;charset=utf-16'\n          'ok'\n        end\n      end\n\n      get '/'\n      assert_equal 'text/plain;charset=utf-16', response['Content-Type']\n    end\n\n    it 'properly encodes parameters with delimiter characters' do\n      mock_app do\n        before '/comma' do\n          content_type 'image/png', :comment => 'Hello, world!'\n        end\n        before '/semicolon' do\n          content_type 'image/png', :comment => 'semi;colon'\n        end\n        before '/quote' do\n          content_type 'image/png', :comment => '\"Whatever.\"'\n        end\n\n        get('*') { 'ok' }\n      end\n\n      get '/comma'\n      assert_equal 'image/png;comment=\"Hello, world!\"', response['Content-Type']\n      get '/semicolon'\n      assert_equal 'image/png;comment=\"semi;colon\"', response['Content-Type']\n      get '/quote'\n      assert_equal 'image/png;comment=\"\\\"Whatever.\\\"\"', response['Content-Type']\n    end\n  end\n\n  describe 'attachment' do\n    def attachment_app(filename=nil)\n      mock_app do\n        get('/attachment') do\n          attachment filename\n          response.write(\"<sinatra></sinatra>\")\n        end\n      end\n    end\n\n    it 'sets the Content-Type response header' do\n      attachment_app('test.xml')\n      get '/attachment'\n      assert_equal 'application/xml;charset=utf-8', response['Content-Type']\n      assert_equal '<sinatra></sinatra>', body\n    end\n\n    it 'sets the Content-Type response header without extname' do\n      attachment_app('test')\n      get '/attachment'\n      assert_equal 'text/html;charset=utf-8', response['Content-Type']\n      assert_equal '<sinatra></sinatra>', body\n    end\n\n    it 'sets the Content-Type response header with extname' do\n      mock_app do\n        get('/attachment') do\n          content_type :atom\n          attachment 'test.xml'\n          response.write(\"<sinatra></sinatra>\")\n        end\n      end\n\n      get '/attachment'\n      assert_equal 'application/atom+xml', response['Content-Type']\n      assert_equal '<sinatra></sinatra>', body\n    end\n\n    it 'escapes filename in the Content-Disposition header according to the multipart form data spec in WHATWG living standard' do\n      mock_app do\n        get('/attachment') do\n          attachment \"test.xml\\\";\\r\\next=.txt\"\n          response.write(\"<sinatra></sinatra>\")\n        end\n      end\n\n      get '/attachment'\n      assert_equal 'attachment; filename=\"test.xml%22;%0D%0Aext=.txt\"', response['Content-Disposition']\n      assert_equal '<sinatra></sinatra>', body\n    end\n  end\n\n  describe 'send_file' do\n    setup do\n      @file = __dir__ + '/file.txt'\n      File.open(@file, 'wb') { |io| io.write('Hello World') }\n    end\n\n    def teardown\n      File.unlink @file\n      @file = nil\n    end\n\n    def send_file_app(opts={})\n      path = @file\n      mock_app {\n        get '/file.txt' do\n          send_file path, opts\n        end\n      }\n    end\n\n    it \"sends the contents of the file\" do\n      send_file_app\n      get '/file.txt'\n      assert ok?\n      assert_equal 'Hello World', body\n    end\n\n    it 'sets the Content-Type response header if a mime-type can be located' do\n      send_file_app\n      get '/file.txt'\n      assert_equal 'text/plain;charset=utf-8', response['Content-Type']\n    end\n\n    it 'sets the Content-Type response header if type option is set to a file extension' do\n      send_file_app :type => 'html'\n      get '/file.txt'\n      assert_equal 'text/html;charset=utf-8', response['Content-Type']\n    end\n\n    it 'sets the Content-Type response header if type option is set to a mime type' do\n      send_file_app :type => 'application/octet-stream'\n      get '/file.txt'\n      assert_equal 'application/octet-stream', response['Content-Type']\n    end\n\n    it 'sets the Content-Length response header' do\n      send_file_app\n      get '/file.txt'\n      assert_equal 'Hello World'.length.to_s, response['Content-Length']\n    end\n\n    it 'sets the Last-Modified response header' do\n      send_file_app\n      get '/file.txt'\n      assert_equal File.mtime(@file).httpdate, response['Last-Modified']\n    end\n\n    it 'allows passing in a different Last-Modified response header with :last_modified' do\n      time = Time.now\n      send_file_app :last_modified => time\n      get '/file.txt'\n      assert_equal time.httpdate, response['Last-Modified']\n    end\n\n    it \"returns a 404 when not found\" do\n      mock_app {\n        get('/') { send_file 'this-file-does-not-exist.txt' }\n      }\n      get '/'\n      assert not_found?\n    end\n\n    it \"does not set the Content-Disposition header by default\" do\n      send_file_app\n      get '/file.txt'\n      assert_nil response['Content-Disposition']\n    end\n\n    it \"sets the Content-Disposition header when :disposition set to 'attachment'\" do\n      send_file_app :disposition => 'attachment'\n      get '/file.txt'\n      assert_equal 'attachment; filename=\"file.txt\"', response['Content-Disposition']\n    end\n\n    it \"does not set add a file name if filename is false\" do\n      send_file_app :disposition => 'inline', :filename => false\n      get '/file.txt'\n      assert_equal 'inline', response['Content-Disposition']\n    end\n\n    it \"sets the Content-Disposition header when :disposition set to 'inline'\" do\n      send_file_app :disposition => 'inline'\n      get '/file.txt'\n      assert_equal 'inline; filename=\"file.txt\"', response['Content-Disposition']\n    end\n\n    it \"does not raise an error when :disposition set to a frozen string\" do\n      send_file_app :disposition => 'inline'.freeze\n      get '/file.txt'\n      assert_equal 'inline; filename=\"file.txt\"', response['Content-Disposition']\n    end \n    \n    it \"sets the Content-Disposition header when :filename provided\" do\n      send_file_app :filename => 'foo.txt'\n      get '/file.txt'\n      assert_equal 'attachment; filename=\"foo.txt\"', response['Content-Disposition']\n    end\n\n    it 'allows setting a custom status code' do\n      send_file_app :status => 201\n      get '/file.txt'\n      assert_status 201\n    end\n\n    it \"is able to send files with unknown mime type\" do\n      @file = __dir__ + '/file.foobar'\n      File.open(@file, 'wb') { |io| io.write('Hello World') }\n      send_file_app\n      get '/file.txt'\n      assert_equal 'application/octet-stream', response['Content-Type']\n    end\n\n    it \"does not override Content-Type if already set and no explicit type is given\" do\n      path = @file\n      mock_app do\n        get('/') do\n          content_type :png\n          send_file path\n        end\n      end\n      get '/'\n      assert_equal 'image/png', response['Content-Type']\n    end\n\n    it \"does override Content-Type even if already set, if explicit type is given\" do\n      path = @file\n      mock_app do\n        get('/') do\n          content_type :png\n          send_file path, :type => :gif\n        end\n      end\n      get '/'\n      assert_equal 'image/gif', response['Content-Type']\n    end\n\n    it 'can have :status option as a string' do\n      path = @file\n      mock_app do\n        post '/' do\n          send_file path, :status => '422'\n        end\n      end\n      post '/'\n      assert_equal response.status, 422\n    end\n  end\n\n  describe 'cache_control' do\n    setup do\n      mock_app do\n        get('/foo') do\n          cache_control :public, :no_cache, :max_age => 60.0\n          'Hello World'\n        end\n\n        get('/bar') do\n          cache_control :public, :no_cache\n          'Hello World'\n        end\n      end\n    end\n\n    it 'sets the Cache-Control header' do\n      get '/foo'\n      assert_equal ['public', 'no-cache', 'max-age=60'], response['Cache-Control'].split(', ')\n    end\n\n    it 'last argument does not have to be a hash' do\n      get '/bar'\n      assert_equal ['public', 'no-cache'], response['Cache-Control'].split(', ')\n    end\n  end\n\n  describe 'expires' do\n    setup do\n      mock_app do\n        get('/foo') do\n          expires 60, :public, :no_cache\n          'Hello World'\n        end\n\n        get('/bar') { expires Time.now }\n\n        get('/baz') { expires Time.at(0) }\n\n        get('/bah') { expires Time.at(0), :max_age => 20 }\n\n        get('/blah') do\n          obj = Object.new\n          def obj.method_missing(*a, &b) 60.send(*a, &b) end\n          def obj.is_a?(thing) 60.is_a?(thing) end\n          expires obj, :public, :no_cache\n          'Hello World'\n        end\n\n        get('/boom') { expires '9999' }\n      end\n    end\n\n    it 'sets the Cache-Control header' do\n      get '/foo'\n      assert_equal ['public', 'no-cache', 'max-age=60'], response['Cache-Control'].split(', ')\n    end\n\n    it 'sets the Expires header' do\n      get '/foo'\n      refute_nil response['Expires']\n    end\n\n    it 'allows passing Time.now objects' do\n      get '/bar'\n      refute_nil response['Expires']\n    end\n\n    it 'allows passing Time.at objects' do\n      get '/baz'\n      assert_equal 'Thu, 01 Jan 1970 00:00:00 GMT', response['Expires']\n    end\n\n    it 'allows max_age to be specified separately' do\n      get '/bah'\n      assert_equal 'Thu, 01 Jan 1970 00:00:00 GMT', response['Expires']\n      assert_equal ['max-age=20'], response['Cache-Control'].split(', ')\n    end\n\n    it 'accepts values pretending to be a Numeric (like ActiveSupport::Duration)' do\n      get '/blah'\n      assert_equal ['public', 'no-cache', 'max-age=60'], response['Cache-Control'].split(', ')\n    end\n\n    it 'fails when Time.parse raises an ArgumentError' do\n      assert_raises(ArgumentError) { get '/boom' }\n    end\n  end\n\n  describe 'last_modified' do\n    it 'ignores nil' do\n      mock_app { get('/') { last_modified nil; 200; } }\n\n      get '/'\n      assert ! response['Last-Modified']\n    end\n\n    it 'does not change a status other than 200' do\n      mock_app do\n        get('/') do\n          status 299\n          last_modified Time.at(0)\n          'ok'\n        end\n      end\n\n      get('/', {}, 'HTTP_IF_MODIFIED_SINCE' => 'Sun, 26 Sep 2030 23:43:52 GMT')\n      assert_status 299\n      assert_body 'ok'\n    end\n\n    [Time.now, DateTime.now, Date.today, Time.now.to_i,\n      Struct.new(:to_time).new(Time.now) ].each do |last_modified_time|\n      describe \"with #{last_modified_time.class.name}\" do\n        setup do\n          mock_app do\n            get('/') do\n              last_modified last_modified_time\n              'Boo!'\n            end\n          end\n          wrapper = Object.new.extend Sinatra::Helpers\n          @last_modified_time = wrapper.time_for last_modified_time\n        end\n\n        # fixes strange missing test error when running complete test suite.\n        it(\"does not complain about missing tests\") { }\n\n        context \"when there's no If-Modified-Since header\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get '/'\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET misses and returns a body' do\n            get '/'\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n        end\n\n        context \"when there's an invalid If-Modified-Since header\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'a really weird date' })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET misses and returns a body' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'a really weird date' })\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n        end\n\n        context \"when the resource has been modified since the If-Modified-Since header date\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time - 1).httpdate })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET misses and returns a body' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time - 1).httpdate })\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n\n          it 'does not rely on string comparison' do\n            mock_app do\n              get('/compare') do\n                last_modified \"Mon, 18 Oct 2010 20:57:11 GMT\"\n                \"foo\"\n              end\n            end\n\n            get('/compare', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'Sun, 26 Sep 2010 23:43:52 GMT' })\n            assert_equal 200, status\n            assert_equal 'foo', body\n            get('/compare', {}, { 'HTTP_IF_MODIFIED_SINCE' => 'Sun, 26 Sep 2030 23:43:52 GMT' })\n            assert_equal 304, status\n            assert_equal '', body\n          end\n        end\n\n        context \"when the resource has been modified on the exact If-Modified-Since header date\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => @last_modified_time.httpdate })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET matches and halts' do\n            get( '/', {}, { 'HTTP_IF_MODIFIED_SINCE' => @last_modified_time.httpdate })\n            assert_equal 304, status\n            assert_equal '', body\n          end\n        end\n\n        context \"when the resource hasn't been modified since the If-Modified-Since header date\" do\n          it 'sets the Last-Modified header to a valid RFC 2616 date value' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time + 1).httpdate })\n            assert_equal @last_modified_time.httpdate, response['Last-Modified']\n          end\n\n          it 'conditional GET matches and halts' do\n            get('/', {}, { 'HTTP_IF_MODIFIED_SINCE' => (@last_modified_time + 1).httpdate })\n            assert_equal 304, status\n            assert_equal '', body\n          end\n        end\n\n        context \"If-Unmodified-Since\" do\n          it 'results in 200 if resource has not been modified' do\n            get('/', {}, { 'HTTP_IF_UNMODIFIED_SINCE' => 'Sun, 26 Sep 2030 23:43:52 GMT' })\n            assert_equal 200, status\n            assert_equal 'Boo!', body\n          end\n\n          it 'results in 412 if resource has been modified' do\n            get('/', {}, { 'HTTP_IF_UNMODIFIED_SINCE' => Time.at(0).httpdate })\n            assert_equal 412, status\n            assert_equal '', body\n          end\n        end\n      end\n    end\n  end\n\n  describe 'etag' do\n    context \"safe requests\" do\n      it 'returns 200 for normal requests' do\n        mock_app do\n          get('/') do\n            etag 'foo'\n            'ok'\n          end\n        end\n\n        get '/'\n        assert_status 200\n        assert_body 'ok'\n      end\n\n      context \"If-None-Match\" do\n        it 'returns 304 when If-None-Match is *' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match is * for new resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 304 when If-None-Match is * for existing resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 304 when If-None-Match is the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 304 when If-None-Match includes the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\", \"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match does not include the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'ignores If-Modified-Since if If-None-Match does not match' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              last_modified Time.at(0)\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'does not change a status code other than 2xx or 304' do\n          mock_app do\n            get('/') do\n              status 499\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 499\n          assert_body 'ok'\n        end\n\n        it 'does change 2xx status codes' do\n          mock_app do\n            get('/') do\n              status 299\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n\n        it 'does not send a body on 304 status codes' do\n          mock_app do\n            get('/') do\n              status 304\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 304\n          assert_body ''\n        end\n      end\n\n      context \"If-Match\" do\n        it 'returns 200 when If-Match is the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '\"foo\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match includes the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '\"foo\", \"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match is *' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match is * for new resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-Match is * for existing resources' do\n          mock_app do\n            get('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match does not include the etag' do\n          mock_app do\n            get('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          get('/', {}, 'HTTP_IF_MATCH' => '\"bar\"')\n          assert_status 412\n          assert_body ''\n        end\n      end\n    end\n\n    context \"idempotent requests\" do\n      it 'returns 200 for normal requests' do\n        mock_app do\n          put('/') do\n            etag 'foo'\n            'ok'\n          end\n        end\n\n        put '/'\n        assert_status 200\n        assert_body 'ok'\n      end\n\n      context \"If-None-Match\" do\n        it 'returns 412 when If-None-Match is *' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match is * for new resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-None-Match is * for existing resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match is the etag' do\n          mock_app do\n            put '/' do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match includes the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\", \"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match does not include the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'ignores If-Modified-Since if If-None-Match does not match' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              last_modified Time.at(0)\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n      end\n\n      context \"If-Match\" do\n        it 'returns 200 when If-Match is the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '\"foo\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match includes the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '\"foo\", \"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match is *' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match is * for new resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-Match is * for existing resources' do\n          mock_app do\n            put('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match does not include the etag' do\n          mock_app do\n            put('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          put('/', {}, 'HTTP_IF_MATCH' => '\"bar\"')\n          assert_status 412\n          assert_body ''\n        end\n      end\n    end\n\n    context \"post requests\" do\n      it 'returns 200 for normal requests' do\n        mock_app do\n          post('/') do\n            etag 'foo'\n            'ok'\n          end\n        end\n\n        post('/')\n        assert_status 200\n        assert_body 'ok'\n      end\n\n      context \"If-None-Match\" do\n        it 'returns 200 when If-None-Match is *' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-None-Match is * for new resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-None-Match is * for existing resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match is the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-None-Match includes the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\", \"foo\"')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-None-Match does not include the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'ignores If-Modified-Since if If-None-Match does not match' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              last_modified Time.at(0)\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_NONE_MATCH' => '\"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n      end\n\n      context \"If-Match\" do\n        it 'returns 200 when If-Match is the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '\"foo\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 200 when If-Match includes the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '\"foo\", \"bar\"')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match is *' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 412 when If-Match is * for new resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => true\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 412\n          assert_body ''\n        end\n\n        it 'returns 200 when If-Match is * for existing resources' do\n          mock_app do\n            post('/') do\n              etag 'foo', :new_resource => false\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '*')\n          assert_status 200\n          assert_body 'ok'\n        end\n\n        it 'returns 412 when If-Match does not include the etag' do\n          mock_app do\n            post('/') do\n              etag 'foo'\n              'ok'\n            end\n          end\n\n          post('/', {}, 'HTTP_IF_MATCH' => '\"bar\"')\n          assert_status 412\n          assert_body ''\n        end\n      end\n    end\n\n    it 'uses a weak etag with the :weak option' do\n      mock_app do\n        get('/') do\n          etag 'FOO', :weak\n          \"that's weak, dude.\"\n        end\n      end\n      get '/'\n      assert_equal 'W/\"FOO\"', response['ETag']\n    end\n\n    it 'raises an ArgumentError for an invalid strength' do\n      mock_app do\n        get('/') do\n          etag 'FOO', :w00t\n          \"that's weak, dude.\"\n        end\n      end\n      assert_raises(ArgumentError) { get('/') }\n    end\n  end\n\n  describe 'back' do\n    it \"makes redirecting back pretty\" do\n      mock_app { get('/foo') { redirect back } }\n\n      get('/foo', {}, 'HTTP_REFERER' => 'http://github.com')\n      assert redirect?\n      assert_equal \"http://github.com\", response.location\n    end\n  end\n\n  describe 'uri' do\n    it 'generates absolute urls' do\n      mock_app { get('/') { uri }}\n      get '/'\n      assert_equal 'http://example.org/', body\n    end\n\n    it 'includes path_info' do\n      mock_app { get('/:name') { uri }}\n      get '/foo'\n      assert_equal 'http://example.org/foo', body\n    end\n\n    it 'allows passing an alternative to path_info' do\n      mock_app { get('/:name') { uri '/bar' }}\n      get '/foo'\n      assert_equal 'http://example.org/bar', body\n    end\n\n    it 'includes script_name' do\n      mock_app { get('/:name') { uri '/bar' }}\n      get '/foo', {}, { \"SCRIPT_NAME\" => '/foo' }\n      assert_equal 'http://example.org/foo/bar', body\n    end\n\n    it 'handles absolute URIs' do\n      mock_app { get('/') { uri 'http://google.com' }}\n      get '/'\n      assert_equal 'http://google.com', body\n    end\n\n    it 'handles different protocols' do\n      mock_app { get('/') { uri 'mailto:jsmith@example.com' }}\n      get '/'\n      assert_equal 'mailto:jsmith@example.com', body\n    end\n\n    it 'is aliased to #url' do\n      mock_app { get('/') { url }}\n      get '/'\n      assert_equal 'http://example.org/', body\n    end\n\n    it 'is aliased to #to' do\n      mock_app { get('/') { to }}\n      get '/'\n      assert_equal 'http://example.org/', body\n    end\n\n    it 'is case-insensitive' do\n      mock_app { get('/:foo') { uri params[:foo] }}\n      assert_equal get('HtTP://google.com').body, get('http://google.com').body\n    end\n\n    it 'generates relative link for invalid path' do\n      mock_app { get('/') { uri 'htt^p://google.com' }}\n      get '/'\n      assert_equal 'http://example.org/htt^p://google.com', body\n    end\n  end\n\n  describe 'logger' do\n    it 'logging works when logging is enabled' do\n      mock_app do\n        enable :logging\n        get('/') do\n          logger.info \"Program started\"\n          logger.warn \"Nothing to do!\"\n        end\n      end\n      io = StringIO.new\n      get '/', {}, 'rack.errors' => io\n      assert io.string.include?(\"INFO -- : Program started\")\n      assert io.string.include?(\"WARN -- : Nothing to do\")\n    end\n\n    it 'logging works when logging is disable, but no output is produced' do\n      mock_app do\n        disable :logging\n        get('/') do\n          logger.info \"Program started\"\n          logger.warn \"Nothing to do!\"\n        end\n      end\n      io = StringIO.new\n      get '/', {}, 'rack.errors' => io\n      assert !io.string.include?(\"INFO -- : Program started\")\n      assert !io.string.include?(\"WARN -- : Nothing to do\")\n    end\n\n    it 'does not create a logger when logging is set to nil' do\n      mock_app do\n        set :logging, nil\n        get('/') { logger.inspect }\n      end\n\n      get '/'\n      assert_body 'nil'\n    end\n  end\n\n  module ::HelperOne; def one; '1'; end; end\n  module ::HelperTwo; def two; '2'; end; end\n\n  describe 'Adding new helpers' do\n    it 'takes a list of modules to mix into the app' do\n      mock_app do\n        helpers ::HelperOne, ::HelperTwo\n\n        get('/one') { one }\n\n        get('/two') { two }\n      end\n\n      get '/one'\n      assert_equal '1', body\n\n      get '/two'\n      assert_equal '2', body\n    end\n\n    it 'takes a block to mix into the app' do\n      mock_app do\n        helpers do\n          def foo\n            'foo'\n          end\n        end\n\n        get('/') { foo }\n      end\n\n      get '/'\n      assert_equal 'foo', body\n    end\n\n    it 'evaluates the block in class context so that methods can be aliased' do\n      mock_app do\n        helpers { alias_method :h, :escape_html }\n\n        get('/') { h('42 < 43') }\n      end\n\n      get '/'\n      assert ok?\n      assert_equal '42 &lt; 43', body\n    end\n\n    it 'prepends modules so previously-defined methods can be overridden consistently' do\n      skip <<-EOS\n        This test will be helpful after switching #helpers's code from Module#include to Module#prepend\n        See more details: https://github.com/sinatra/sinatra/pull/1214\n      EOS\n      mock_app do\n        helpers do\n          def one; nil end\n          def two; nil end\n        end\n\n        helpers ::HelperOne do\n          def two; '2' end\n        end\n\n        get('/one') { one }\n        get('/two') { two }\n      end\n\n      get '/one'\n      assert_equal '1', body\n\n      get '/two'\n      assert_equal '2', body\n    end\n\n    module HelpersOverloadingBaseHelper\n      def my_test\n        'BaseHelper#test'\n      end\n    end\n\n    class HelpersOverloadingIncludeAndOverride < Sinatra::Base\n      helpers HelpersOverloadingBaseHelper\n\n      get '/' do\n        my_test\n      end\n\n      helpers do\n        def my_test\n          'InlineHelper#test'\n        end\n      end\n    end\n\n    it 'uses overloaded inline helper' do\n      mock_app(HelpersOverloadingIncludeAndOverride)\n      get '/'\n      assert ok?\n      assert_equal 'InlineHelper#test', body\n    end\n\n    module HelperWithIncluded\n      def self.included(base)\n        base.extend(ClassMethods)\n      end\n\n      module ClassMethods\n        def nickname(name)\n          # do something.\n        end\n      end\n    end\n\n    class ServerApp < Sinatra::Base\n      helpers HelperWithIncluded\n      # `nickname` method should be available.\n    end\n\n    it 'calls included method of helpers' do\n      assert ServerApp.respond_to?(:nickname)\n    end\n  end\nend\n"], "filenames": ["lib/sinatra/base.rb", "test/helpers_test.rb"], "buggy_code_start_loc": [398, 783], "buggy_code_end_loc": [406, 783], "fixing_code_start_loc": [399, 784], "fixing_code_end_loc": [413, 796], "type": "CWE-494", "message": "Sinatra is a domain-specific language for creating web applications in Ruby. An issue was discovered in Sinatra 2.0 before 2.2.3 and 3.0 before 3.0.4. An application is vulnerable to a reflected file download (RFD) attack that sets the Content-Disposition header of a response when the filename is derived from user-supplied input. Version 2.2.3 and 3.0.4 contain patches for this issue.", "other": {"cve": {"id": "CVE-2022-45442", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-28T21:15:10.670", "lastModified": "2023-02-01T15:47:27.760", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sinatra is a domain-specific language for creating web applications in Ruby. An issue was discovered in Sinatra 2.0 before 2.2.3 and 3.0 before 3.0.4. An application is vulnerable to a reflected file download (RFD) attack that sets the Content-Disposition header of a response when the filename is derived from user-supplied input. Version 2.2.3 and 3.0.4 contain patches for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-494"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sinatrarb:sinatra:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "47A016CE-44CB-455F-B208-1669CAA801DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sinatrarb:sinatra:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.4", "matchCriteriaId": "2141BB80-5B38-4DA7-9B84-5C56E7919A3F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-8x94-hmjh-97hq", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/sinatra/sinatra/commit/ea8fc9495a350f7551b39e3025bfcd06f49f363b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sinatra/sinatra/security/advisories/GHSA-2x8x-jmrp-phxw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00005.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sinatra/sinatra/commit/ea8fc9495a350f7551b39e3025bfcd06f49f363b"}}