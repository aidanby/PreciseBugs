{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\SecurityBundle\\DependencyInjection\\Security\\Factory;\n\nuse Symfony\\Bridge\\Doctrine\\Security\\RememberMe\\DoctrineTokenProvider;\nuse Symfony\\Bundle\\SecurityBundle\\RememberMe\\DecoratedRememberMeHandler;\nuse Symfony\\Component\\Config\\Definition\\Builder\\NodeDefinition;\nuse Symfony\\Component\\Config\\Definition\\Exception\\InvalidConfigurationException;\nuse Symfony\\Component\\Config\\FileLocator;\nuse Symfony\\Component\\DependencyInjection\\Argument\\IteratorArgument;\nuse Symfony\\Component\\DependencyInjection\\ChildDefinition;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\DependencyInjection\\Definition;\nuse Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader;\nuse Symfony\\Component\\DependencyInjection\\Reference;\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse Symfony\\Component\\Security\\Core\\Authentication\\RememberMe\\CacheTokenVerifier;\nuse Symfony\\Component\\Security\\Http\\EventListener\\RememberMeLogoutListener;\n\n/**\n * @internal\n */\nclass RememberMeFactory implements SecurityFactoryInterface, AuthenticatorFactoryInterface\n{\n    protected $options = [\n        'name' => 'REMEMBERME',\n        'lifetime' => 31536000,\n        'path' => '/',\n        'domain' => null,\n        'secure' => false,\n        'httponly' => true,\n        'samesite' => null,\n        'always_remember_me' => false,\n        'remember_me_parameter' => '_remember_me',\n    ];\n\n    public function create(ContainerBuilder $container, string $id, array $config, ?string $userProvider, ?string $defaultEntryPoint)\n    {\n        // authentication provider\n        $authProviderId = 'security.authentication.provider.rememberme.'.$id;\n        $container\n            ->setDefinition($authProviderId, new ChildDefinition('security.authentication.provider.rememberme'))\n            ->replaceArgument(0, new Reference('security.user_checker.'.$id))\n            ->addArgument($config['secret'])\n            ->addArgument($id)\n        ;\n\n        // remember me services\n        $templateId = $this->generateRememberMeServicesTemplateId($config, $id);\n        $rememberMeServicesId = $templateId.'.'.$id;\n\n        // attach to remember-me aware listeners\n        $userProviders = [];\n        foreach ($container->findTaggedServiceIds('security.remember_me_aware') as $serviceId => $attributes) {\n            foreach ($attributes as $attribute) {\n                if (!isset($attribute['id']) || $attribute['id'] !== $id) {\n                    continue;\n                }\n\n                if (!isset($attribute['provider'])) {\n                    throw new \\RuntimeException('Each \"security.remember_me_aware\" tag must have a provider attribute.');\n                }\n\n                // context listeners don't need a provider\n                if ('none' !== $attribute['provider']) {\n                    $userProviders[] = new Reference($attribute['provider']);\n                }\n\n                $container\n                    ->getDefinition($serviceId)\n                    ->addMethodCall('setRememberMeServices', [new Reference($rememberMeServicesId)])\n                ;\n            }\n        }\n\n        $this->createRememberMeServices($container, $id, $templateId, $userProviders, $config);\n\n        // remember-me listener\n        $listenerId = 'security.authentication.listener.rememberme.'.$id;\n        $listener = $container->setDefinition($listenerId, new ChildDefinition('security.authentication.listener.rememberme'));\n        $listener->replaceArgument(1, new Reference($rememberMeServicesId));\n        $listener->replaceArgument(5, $config['catch_exceptions']);\n\n        // remember-me logout listener\n        $container->setDefinition('security.logout.listener.remember_me.'.$id, new Definition(RememberMeLogoutListener::class))\n            ->addArgument(new Reference($rememberMeServicesId))\n            ->addTag('kernel.event_subscriber', ['dispatcher' => 'security.event_dispatcher.'.$id]);\n\n        return [$authProviderId, $listenerId, $defaultEntryPoint];\n    }\n\n    public function createAuthenticator(ContainerBuilder $container, string $firewallName, array $config, string $userProviderId): string\n    {\n        if (!$container->hasDefinition('security.authenticator.remember_me')) {\n            $loader = new PhpFileLoader($container, new FileLocator(\\dirname(__DIR__).'/../../Resources/config'));\n            $loader->load('security_authenticator_remember_me.php');\n        }\n\n        if ('auto' === $config['secure']) {\n            $config['secure'] = null;\n        }\n\n        // create remember me handler (which manage the remember-me cookies)\n        $rememberMeHandlerId = 'security.authenticator.remember_me_handler.'.$firewallName;\n        if (isset($config['service']) && isset($config['token_provider'])) {\n            throw new InvalidConfigurationException(sprintf('You cannot use both \"service\" and \"token_provider\" in \"security.firewalls.%s.remember_me\".', $firewallName));\n        }\n\n        if (isset($config['service'])) {\n            $container->register($rememberMeHandlerId, DecoratedRememberMeHandler::class)\n                ->addArgument(new Reference($config['service']))\n                ->addTag('security.remember_me_handler', ['firewall' => $firewallName]);\n        } elseif (isset($config['token_provider'])) {\n            $tokenProviderId = $this->createTokenProvider($container, $firewallName, $config['token_provider']);\n            $tokenVerifier = $this->createTokenVerifier($container, $firewallName, $config['token_verifier'] ?? null);\n            $container->setDefinition($rememberMeHandlerId, new ChildDefinition('security.authenticator.persistent_remember_me_handler'))\n                ->replaceArgument(0, new Reference($tokenProviderId))\n                ->replaceArgument(2, new Reference($userProviderId))\n                ->replaceArgument(4, $config)\n                ->replaceArgument(6, $tokenVerifier)\n                ->addTag('security.remember_me_handler', ['firewall' => $firewallName]);\n        } else {\n            $signatureHasherId = 'security.authenticator.remember_me_signature_hasher.'.$firewallName;\n            $container->setDefinition($signatureHasherId, new ChildDefinition('security.authenticator.remember_me_signature_hasher'))\n                ->replaceArgument(1, $config['signature_properties'])\n            ;\n\n            $container->setDefinition($rememberMeHandlerId, new ChildDefinition('security.authenticator.signature_remember_me_handler'))\n                ->replaceArgument(0, new Reference($signatureHasherId))\n                ->replaceArgument(1, new Reference($userProviderId))\n                ->replaceArgument(3, $config)\n                ->addTag('security.remember_me_handler', ['firewall' => $firewallName]);\n        }\n\n        // create check remember me conditions listener (which checks if a remember-me cookie is supported and requested)\n        $rememberMeConditionsListenerId = 'security.listener.check_remember_me_conditions.'.$firewallName;\n        $container->setDefinition($rememberMeConditionsListenerId, new ChildDefinition('security.listener.check_remember_me_conditions'))\n            ->replaceArgument(0, array_intersect_key($config, ['always_remember_me' => true, 'remember_me_parameter' => true]))\n            ->addTag('kernel.event_subscriber', ['dispatcher' => 'security.event_dispatcher.'.$firewallName])\n        ;\n\n        // create remember me listener (which executes the remember me services for other authenticators and logout)\n        $rememberMeListenerId = 'security.listener.remember_me.'.$firewallName;\n        $container->setDefinition($rememberMeListenerId, new ChildDefinition('security.listener.remember_me'))\n            ->replaceArgument(0, new Reference($rememberMeHandlerId))\n            ->addTag('kernel.event_subscriber', ['dispatcher' => 'security.event_dispatcher.'.$firewallName])\n        ;\n\n        // create remember me authenticator (which re-authenticates the user based on the remember-me cookie)\n        $authenticatorId = 'security.authenticator.remember_me.'.$firewallName;\n        $container\n            ->setDefinition($authenticatorId, new ChildDefinition('security.authenticator.remember_me'))\n            ->replaceArgument(0, new Reference($rememberMeHandlerId))\n            ->replaceArgument(3, $config['name'] ?? $this->options['name'])\n        ;\n\n        foreach ($container->findTaggedServiceIds('security.remember_me_aware') as $serviceId => $attributes) {\n            // register ContextListener\n            if ('security.context_listener' === substr($serviceId, 0, 25)) {\n                continue;\n            }\n\n            throw new \\LogicException(sprintf('Symfony Authenticator Security dropped support for the \"security.remember_me_aware\" tag, service \"%s\" will no longer work as expected.', $serviceId));\n        }\n\n        return $authenticatorId;\n    }\n\n    public function getPosition()\n    {\n        return 'remember_me';\n    }\n\n    public function getKey()\n    {\n        return 'remember-me';\n    }\n\n    public function addConfiguration(NodeDefinition $node)\n    {\n        $builder = $node\n            ->fixXmlConfig('user_provider')\n            ->children()\n        ;\n\n        $builder\n            ->scalarNode('secret')->isRequired()->cannotBeEmpty()->end()\n            ->scalarNode('service')->end()\n            ->arrayNode('user_providers')\n                ->beforeNormalization()\n                    ->ifString()->then(function ($v) { return [$v]; })\n                ->end()\n                ->prototype('scalar')->end()\n            ->end()\n            ->booleanNode('catch_exceptions')->defaultTrue()->end()\n            ->arrayNode('signature_properties')\n                ->prototype('scalar')->end()\n                ->requiresAtLeastOneElement()\n                ->info('An array of properties on your User that are used to sign the remember-me cookie. If any of these change, all existing cookies will become invalid.')\n                ->example(['email', 'password'])\n            ->end()\n            ->arrayNode('token_provider')\n                ->beforeNormalization()\n                    ->ifString()->then(function ($v) { return ['service' => $v]; })\n                ->end()\n                ->children()\n                    ->scalarNode('service')->info('The service ID of a custom rememberme token provider.')->end()\n                    ->arrayNode('doctrine')\n                        ->canBeEnabled()\n                        ->children()\n                            ->scalarNode('connection')->defaultNull()->end()\n                        ->end()\n                    ->end()\n                ->end()\n            ->end()\n            ->scalarNode('token_verifier')\n                ->info('The service ID of a custom rememberme token verifier.')\n            ->end();\n\n        foreach ($this->options as $name => $value) {\n            if ('secure' === $name) {\n                $builder->enumNode($name)->values([true, false, 'auto'])->defaultValue('auto' === $value ? null : $value);\n            } elseif ('samesite' === $name) {\n                $builder->enumNode($name)->values([null, Cookie::SAMESITE_LAX, Cookie::SAMESITE_STRICT, Cookie::SAMESITE_NONE])->defaultValue($value);\n            } elseif (\\is_bool($value)) {\n                $builder->booleanNode($name)->defaultValue($value);\n            } elseif (\\is_int($value)) {\n                $builder->integerNode($name)->defaultValue($value);\n            } else {\n                $builder->scalarNode($name)->defaultValue($value);\n            }\n        }\n    }\n\n    private function generateRememberMeServicesTemplateId(array $config, string $id): string\n    {\n        if (isset($config['service'])) {\n            return $config['service'];\n        }\n\n        if (isset($config['token_provider'])) {\n            return 'security.authentication.rememberme.services.persistent';\n        }\n\n        return 'security.authentication.rememberme.services.simplehash';\n    }\n\n    private function createRememberMeServices(ContainerBuilder $container, string $id, string $templateId, array $userProviders, array $config): void\n    {\n        $rememberMeServicesId = $templateId.'.'.$id;\n\n        $rememberMeServices = $container->setDefinition($rememberMeServicesId, new ChildDefinition($templateId));\n        $rememberMeServices->replaceArgument(1, $config['secret']);\n        $rememberMeServices->replaceArgument(2, $id);\n\n        if (isset($config['token_provider'])) {\n            $tokenProviderId = $this->createTokenProvider($container, $id, $config['token_provider']);\n            $rememberMeServices->addMethodCall('setTokenProvider', [new Reference($tokenProviderId)]);\n        }\n\n        // remember-me options\n        $mergedOptions = array_intersect_key($config, $this->options);\n        if ('auto' === $mergedOptions['secure']) {\n            $mergedOptions['secure'] = null;\n        }\n\n        $rememberMeServices->replaceArgument(3, $mergedOptions);\n\n        if ($config['user_providers']) {\n            $userProviders = [];\n            foreach ($config['user_providers'] as $providerName) {\n                $userProviders[] = new Reference('security.user.provider.concrete.'.$providerName);\n            }\n        }\n\n        if (0 === \\count($userProviders)) {\n            throw new \\RuntimeException('You must configure at least one remember-me aware listener (such as form-login) for each firewall that has remember-me enabled.');\n        }\n\n        $rememberMeServices->replaceArgument(0, new IteratorArgument(array_unique($userProviders)));\n    }\n\n    private function createTokenProvider(ContainerBuilder $container, string $firewallName, array $config): string\n    {\n        $tokenProviderId = $config['service'] ?? false;\n        if ($config['doctrine']['enabled'] ?? false) {\n            if (!class_exists(DoctrineTokenProvider::class)) {\n                throw new InvalidConfigurationException('Cannot use the \"doctrine\" token provider for \"remember_me\" because the Doctrine Bridge is not installed. Try running \"composer require symfony/doctrine-bridge\".');\n            }\n\n            if (null === $config['doctrine']['connection']) {\n                $connectionId = 'database_connection';\n            } else {\n                $connectionId = 'doctrine.dbal.'.$config['doctrine']['connection'].'_connection';\n            }\n\n            $tokenProviderId = 'security.remember_me.doctrine_token_provider.'.$firewallName;\n            $container->register($tokenProviderId, DoctrineTokenProvider::class)\n                ->addArgument(new Reference($connectionId));\n        }\n\n        if (!$tokenProviderId) {\n            throw new InvalidConfigurationException(sprintf('No token provider was set for firewall \"%s\". Either configure a service ID or set \"remember_me.token_provider.doctrine\" to true.', $firewallName));\n        }\n\n        return $tokenProviderId;\n    }\n\n    private function createTokenVerifier(ContainerBuilder $container, string $firewallName, ?string $serviceId): Reference\n    {\n        if ($serviceId) {\n            return new Reference($serviceId);\n        }\n\n        $tokenVerifierId = 'security.remember_me.token_verifier.'.$firewallName;\n\n        $container->register($tokenVerifierId, CacheTokenVerifier::class)\n            ->addArgument(new Reference('cache.security_token_verifier', ContainerInterface::NULL_ON_INVALID_REFERENCE))\n            ->addArgument(60)\n            ->addArgument('rememberme-'.$firewallName.'-stale-');\n\n        return new Reference($tokenVerifierId, ContainerInterface::NULL_ON_INVALID_REFERENCE);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\SecurityBundle\\Tests\\Functional\\Bundle\\RememberMeBundle\\Security;\n\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUser;\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUserProvider;\nuse Symfony\\Component\\Security\\Core\\User\\User;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserProviderInterface;\n\nclass UserChangingUserProvider implements UserProviderInterface\n{\n    private $inner;\n\n    public function __construct(InMemoryUserProvider $inner)\n    {\n        $this->inner = $inner;\n    }\n\n    public function loadUserByUsername($username)\n    {\n        return $this->inner->loadUserByUsername($username);\n    }\n\n    public function loadUserByIdentifier(string $userIdentifier): UserInterface\n    {\n        return $this->inner->loadUserByIdentifier($userIdentifier);\n    }\n\n    public function refreshUser(UserInterface $user)\n    {\n        $user = $this->inner->refreshUser($user);\n\n        $alterUser = \\Closure::bind(function (InMemoryUser $user) { $user->password = 'foo'; }, null, class_exists(User::class) ? User::class : InMemoryUser::class);\n        $alterUser($user);\n\n        return $user;\n    }\n\n    public function supportsClass($class)\n    {\n        return $this->inner->supportsClass($class);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\SecurityBundle\\Tests\\Functional;\n\nclass RememberMeTest extends AbstractWebTestCase\n{\n    /**\n     * @dataProvider provideConfigs\n     */\n    public function testRememberMe(array $options)\n    {\n        $client = $this->createClient(array_merge_recursive(['root_config' => 'config.yml', 'test_case' => 'RememberMe'], $options));\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent());\n\n        // clear session, this should trigger remember me on the next request\n        $client->getCookieJar()->expire('MOCKSESSID');\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent(), 'Not logged in after resetting session.');\n\n        // logout, this should clear the remember-me cookie\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($client->getCookieJar()->get('REMEMBERME'));\n    }\n\n    public function testUserChangeClearsCookie()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'clear_on_change_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n        $cookieJar = $client->getCookieJar();\n        $this->assertNotNull($cookieJar->get('REMEMBERME'));\n\n        $client->request('GET', '/profile');\n        $this->assertRedirect($client->getResponse(), '/login');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n    }\n\n    public function testSessionLessRememberMeLogout()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'stateless_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $cookieJar = $client->getCookieJar();\n        $cookieJar->expire(session_name());\n\n        $this->assertNotNull($cookieJar->get('REMEMBERME'));\n        $this->assertSame('lax', $cookieJar->get('REMEMBERME')->getSameSite());\n\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n    }\n\n    /**\n     * @dataProvider provideLegacyConfigs\n     * @group legacy\n     */\n    public function testLegacyRememberMe(array $options)\n    {\n        $client = $this->createClient(array_merge_recursive(['root_config' => 'config.yml', 'test_case' => 'RememberMe'], $options));\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent());\n\n        // clear session, this should trigger remember me on the next request\n        $client->getCookieJar()->expire('MOCKSESSID');\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent(), 'Not logged in after resetting session.');\n\n        // logout, this should clear the remember-me cookie\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($client->getCookieJar()->get('REMEMBERME'));\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyUserChangeClearsCookie()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'clear_on_change_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n        $cookieJar = $client->getCookieJar();\n        $this->assertNotNull($cookieJar->get('REMEMBERME'));\n\n        $client->request('GET', '/profile');\n        $this->assertRedirect($client->getResponse(), '/login');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacySessionLessRememberMeLogout()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'stateless_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $cookieJar = $client->getCookieJar();\n        $cookieJar->expire(session_name());\n\n        $this->assertNotNull($cookieJar->get('REMEMBERME'));\n        $this->assertSame('lax', $cookieJar->get('REMEMBERME')->getSameSite());\n\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n    }\n\n    public function provideConfigs()\n    {\n        yield [['root_config' => 'config_session.yml']];\n        yield [['root_config' => 'config_persistent.yml']];\n    }\n\n    public function provideLegacyConfigs()\n    {\n        yield [['root_config' => 'legacy_config_session.yml']];\n        yield [['root_config' => 'legacy_config_persistent.yml']];\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\SecurityBundle\\DependencyInjection\\Security\\Factory;\n\nuse Symfony\\Bridge\\Doctrine\\Security\\RememberMe\\DoctrineTokenProvider;\nuse Symfony\\Bundle\\SecurityBundle\\RememberMe\\DecoratedRememberMeHandler;\nuse Symfony\\Component\\Config\\Definition\\Builder\\NodeDefinition;\nuse Symfony\\Component\\Config\\Definition\\Exception\\InvalidConfigurationException;\nuse Symfony\\Component\\Config\\FileLocator;\nuse Symfony\\Component\\DependencyInjection\\Argument\\IteratorArgument;\nuse Symfony\\Component\\DependencyInjection\\ChildDefinition;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\DependencyInjection\\Definition;\nuse Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader;\nuse Symfony\\Component\\DependencyInjection\\Reference;\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse Symfony\\Component\\Security\\Core\\Authentication\\RememberMe\\CacheTokenVerifier;\nuse Symfony\\Component\\Security\\Http\\EventListener\\RememberMeLogoutListener;\n\n/**\n * @internal\n */\nclass RememberMeFactory implements SecurityFactoryInterface, AuthenticatorFactoryInterface\n{\n    protected $options = [\n        'name' => 'REMEMBERME',\n        'lifetime' => 31536000,\n        'path' => '/',\n        'domain' => null,\n        'secure' => false,\n        'httponly' => true,\n        'samesite' => null,\n        'always_remember_me' => false,\n        'remember_me_parameter' => '_remember_me',\n    ];\n\n    public function create(ContainerBuilder $container, string $id, array $config, ?string $userProvider, ?string $defaultEntryPoint)\n    {\n        // authentication provider\n        $authProviderId = 'security.authentication.provider.rememberme.'.$id;\n        $container\n            ->setDefinition($authProviderId, new ChildDefinition('security.authentication.provider.rememberme'))\n            ->replaceArgument(0, new Reference('security.user_checker.'.$id))\n            ->addArgument($config['secret'])\n            ->addArgument($id)\n        ;\n\n        // remember me services\n        $templateId = $this->generateRememberMeServicesTemplateId($config, $id);\n        $rememberMeServicesId = $templateId.'.'.$id;\n\n        // attach to remember-me aware listeners\n        $userProviders = [];\n        foreach ($container->findTaggedServiceIds('security.remember_me_aware') as $serviceId => $attributes) {\n            foreach ($attributes as $attribute) {\n                if (!isset($attribute['id']) || $attribute['id'] !== $id) {\n                    continue;\n                }\n\n                if (!isset($attribute['provider'])) {\n                    throw new \\RuntimeException('Each \"security.remember_me_aware\" tag must have a provider attribute.');\n                }\n\n                // context listeners don't need a provider\n                if ('none' !== $attribute['provider']) {\n                    $userProviders[] = new Reference($attribute['provider']);\n                }\n\n                $container\n                    ->getDefinition($serviceId)\n                    ->addMethodCall('setRememberMeServices', [new Reference($rememberMeServicesId)])\n                ;\n            }\n        }\n\n        $this->createRememberMeServices($container, $id, $templateId, $userProviders, $config);\n\n        // remember-me listener\n        $listenerId = 'security.authentication.listener.rememberme.'.$id;\n        $listener = $container->setDefinition($listenerId, new ChildDefinition('security.authentication.listener.rememberme'));\n        $listener->replaceArgument(1, new Reference($rememberMeServicesId));\n        $listener->replaceArgument(5, $config['catch_exceptions']);\n\n        // remember-me logout listener\n        $container->setDefinition('security.logout.listener.remember_me.'.$id, new Definition(RememberMeLogoutListener::class))\n            ->addArgument(new Reference($rememberMeServicesId))\n            ->addTag('kernel.event_subscriber', ['dispatcher' => 'security.event_dispatcher.'.$id]);\n\n        return [$authProviderId, $listenerId, $defaultEntryPoint];\n    }\n\n    public function createAuthenticator(ContainerBuilder $container, string $firewallName, array $config, string $userProviderId): string\n    {\n        if (!$container->hasDefinition('security.authenticator.remember_me')) {\n            $loader = new PhpFileLoader($container, new FileLocator(\\dirname(__DIR__).'/../../Resources/config'));\n            $loader->load('security_authenticator_remember_me.php');\n        }\n\n        if ('auto' === $config['secure']) {\n            $config['secure'] = null;\n        }\n\n        // create remember me handler (which manage the remember-me cookies)\n        $rememberMeHandlerId = 'security.authenticator.remember_me_handler.'.$firewallName;\n        if (isset($config['service']) && isset($config['token_provider'])) {\n            throw new InvalidConfigurationException(sprintf('You cannot use both \"service\" and \"token_provider\" in \"security.firewalls.%s.remember_me\".', $firewallName));\n        }\n\n        if (isset($config['service'])) {\n            $container->register($rememberMeHandlerId, DecoratedRememberMeHandler::class)\n                ->addArgument(new Reference($config['service']))\n                ->addTag('security.remember_me_handler', ['firewall' => $firewallName]);\n        } elseif (isset($config['token_provider'])) {\n            $tokenProviderId = $this->createTokenProvider($container, $firewallName, $config['token_provider']);\n            $tokenVerifier = $this->createTokenVerifier($container, $firewallName, $config['token_verifier'] ?? null);\n            $container->setDefinition($rememberMeHandlerId, new ChildDefinition('security.authenticator.persistent_remember_me_handler'))\n                ->replaceArgument(0, new Reference($tokenProviderId))\n                ->replaceArgument(2, new Reference($userProviderId))\n                ->replaceArgument(4, $config)\n                ->replaceArgument(6, $tokenVerifier)\n                ->addTag('security.remember_me_handler', ['firewall' => $firewallName]);\n        } else {\n            $signatureHasherId = 'security.authenticator.remember_me_signature_hasher.'.$firewallName;\n            $container->setDefinition($signatureHasherId, new ChildDefinition('security.authenticator.remember_me_signature_hasher'))\n                ->replaceArgument(1, $config['signature_properties'])\n            ;\n\n            $container->setDefinition($rememberMeHandlerId, new ChildDefinition('security.authenticator.signature_remember_me_handler'))\n                ->replaceArgument(0, new Reference($signatureHasherId))\n                ->replaceArgument(1, new Reference($userProviderId))\n                ->replaceArgument(3, $config)\n                ->addTag('security.remember_me_handler', ['firewall' => $firewallName]);\n        }\n\n        // create check remember me conditions listener (which checks if a remember-me cookie is supported and requested)\n        $rememberMeConditionsListenerId = 'security.listener.check_remember_me_conditions.'.$firewallName;\n        $container->setDefinition($rememberMeConditionsListenerId, new ChildDefinition('security.listener.check_remember_me_conditions'))\n            ->replaceArgument(0, array_intersect_key($config, ['always_remember_me' => true, 'remember_me_parameter' => true]))\n            ->addTag('kernel.event_subscriber', ['dispatcher' => 'security.event_dispatcher.'.$firewallName])\n        ;\n\n        // create remember me listener (which executes the remember me services for other authenticators and logout)\n        $rememberMeListenerId = 'security.listener.remember_me.'.$firewallName;\n        $container->setDefinition($rememberMeListenerId, new ChildDefinition('security.listener.remember_me'))\n            ->replaceArgument(0, new Reference($rememberMeHandlerId))\n            ->addTag('kernel.event_subscriber', ['dispatcher' => 'security.event_dispatcher.'.$firewallName])\n        ;\n\n        // create remember me authenticator (which re-authenticates the user based on the remember-me cookie)\n        $authenticatorId = 'security.authenticator.remember_me.'.$firewallName;\n        $container\n            ->setDefinition($authenticatorId, new ChildDefinition('security.authenticator.remember_me'))\n            ->replaceArgument(0, new Reference($rememberMeHandlerId))\n            ->replaceArgument(3, $config['name'] ?? $this->options['name'])\n        ;\n\n        foreach ($container->findTaggedServiceIds('security.remember_me_aware') as $serviceId => $attributes) {\n            // register ContextListener\n            if ('security.context_listener' === substr($serviceId, 0, 25)) {\n                continue;\n            }\n\n            throw new \\LogicException(sprintf('Symfony Authenticator Security dropped support for the \"security.remember_me_aware\" tag, service \"%s\" will no longer work as expected.', $serviceId));\n        }\n\n        return $authenticatorId;\n    }\n\n    public function getPosition()\n    {\n        return 'remember_me';\n    }\n\n    public function getKey()\n    {\n        return 'remember-me';\n    }\n\n    public function addConfiguration(NodeDefinition $node)\n    {\n        $builder = $node\n            ->fixXmlConfig('user_provider')\n            ->children()\n        ;\n\n        $builder\n            ->scalarNode('secret')->isRequired()->cannotBeEmpty()->end()\n            ->scalarNode('service')->end()\n            ->arrayNode('user_providers')\n                ->beforeNormalization()\n                    ->ifString()->then(function ($v) { return [$v]; })\n                ->end()\n                ->prototype('scalar')->end()\n            ->end()\n            ->booleanNode('catch_exceptions')->defaultTrue()->end()\n            ->arrayNode('signature_properties')\n                ->prototype('scalar')->end()\n                ->requiresAtLeastOneElement()\n                ->info('An array of properties on your User that are used to sign the remember-me cookie. If any of these change, all existing cookies will become invalid.')\n                ->example(['email', 'password'])\n                ->defaultValue(['password'])\n            ->end()\n            ->arrayNode('token_provider')\n                ->beforeNormalization()\n                    ->ifString()->then(function ($v) { return ['service' => $v]; })\n                ->end()\n                ->children()\n                    ->scalarNode('service')->info('The service ID of a custom rememberme token provider.')->end()\n                    ->arrayNode('doctrine')\n                        ->canBeEnabled()\n                        ->children()\n                            ->scalarNode('connection')->defaultNull()->end()\n                        ->end()\n                    ->end()\n                ->end()\n            ->end()\n            ->scalarNode('token_verifier')\n                ->info('The service ID of a custom rememberme token verifier.')\n            ->end();\n\n        foreach ($this->options as $name => $value) {\n            if ('secure' === $name) {\n                $builder->enumNode($name)->values([true, false, 'auto'])->defaultValue('auto' === $value ? null : $value);\n            } elseif ('samesite' === $name) {\n                $builder->enumNode($name)->values([null, Cookie::SAMESITE_LAX, Cookie::SAMESITE_STRICT, Cookie::SAMESITE_NONE])->defaultValue($value);\n            } elseif (\\is_bool($value)) {\n                $builder->booleanNode($name)->defaultValue($value);\n            } elseif (\\is_int($value)) {\n                $builder->integerNode($name)->defaultValue($value);\n            } else {\n                $builder->scalarNode($name)->defaultValue($value);\n            }\n        }\n    }\n\n    private function generateRememberMeServicesTemplateId(array $config, string $id): string\n    {\n        if (isset($config['service'])) {\n            return $config['service'];\n        }\n\n        if (isset($config['token_provider'])) {\n            return 'security.authentication.rememberme.services.persistent';\n        }\n\n        return 'security.authentication.rememberme.services.simplehash';\n    }\n\n    private function createRememberMeServices(ContainerBuilder $container, string $id, string $templateId, array $userProviders, array $config): void\n    {\n        $rememberMeServicesId = $templateId.'.'.$id;\n\n        $rememberMeServices = $container->setDefinition($rememberMeServicesId, new ChildDefinition($templateId));\n        $rememberMeServices->replaceArgument(1, $config['secret']);\n        $rememberMeServices->replaceArgument(2, $id);\n\n        if (isset($config['token_provider'])) {\n            $tokenProviderId = $this->createTokenProvider($container, $id, $config['token_provider']);\n            $rememberMeServices->addMethodCall('setTokenProvider', [new Reference($tokenProviderId)]);\n        }\n\n        // remember-me options\n        $mergedOptions = array_intersect_key($config, $this->options);\n        if ('auto' === $mergedOptions['secure']) {\n            $mergedOptions['secure'] = null;\n        }\n\n        $rememberMeServices->replaceArgument(3, $mergedOptions);\n\n        if ($config['user_providers']) {\n            $userProviders = [];\n            foreach ($config['user_providers'] as $providerName) {\n                $userProviders[] = new Reference('security.user.provider.concrete.'.$providerName);\n            }\n        }\n\n        if (0 === \\count($userProviders)) {\n            throw new \\RuntimeException('You must configure at least one remember-me aware listener (such as form-login) for each firewall that has remember-me enabled.');\n        }\n\n        $rememberMeServices->replaceArgument(0, new IteratorArgument(array_unique($userProviders)));\n    }\n\n    private function createTokenProvider(ContainerBuilder $container, string $firewallName, array $config): string\n    {\n        $tokenProviderId = $config['service'] ?? false;\n        if ($config['doctrine']['enabled'] ?? false) {\n            if (!class_exists(DoctrineTokenProvider::class)) {\n                throw new InvalidConfigurationException('Cannot use the \"doctrine\" token provider for \"remember_me\" because the Doctrine Bridge is not installed. Try running \"composer require symfony/doctrine-bridge\".');\n            }\n\n            if (null === $config['doctrine']['connection']) {\n                $connectionId = 'database_connection';\n            } else {\n                $connectionId = 'doctrine.dbal.'.$config['doctrine']['connection'].'_connection';\n            }\n\n            $tokenProviderId = 'security.remember_me.doctrine_token_provider.'.$firewallName;\n            $container->register($tokenProviderId, DoctrineTokenProvider::class)\n                ->addArgument(new Reference($connectionId));\n        }\n\n        if (!$tokenProviderId) {\n            throw new InvalidConfigurationException(sprintf('No token provider was set for firewall \"%s\". Either configure a service ID or set \"remember_me.token_provider.doctrine\" to true.', $firewallName));\n        }\n\n        return $tokenProviderId;\n    }\n\n    private function createTokenVerifier(ContainerBuilder $container, string $firewallName, ?string $serviceId): Reference\n    {\n        if ($serviceId) {\n            return new Reference($serviceId);\n        }\n\n        $tokenVerifierId = 'security.remember_me.token_verifier.'.$firewallName;\n\n        $container->register($tokenVerifierId, CacheTokenVerifier::class)\n            ->addArgument(new Reference('cache.security_token_verifier', ContainerInterface::NULL_ON_INVALID_REFERENCE))\n            ->addArgument(60)\n            ->addArgument('rememberme-'.$firewallName.'-stale-');\n\n        return new Reference($tokenVerifierId, ContainerInterface::NULL_ON_INVALID_REFERENCE);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\SecurityBundle\\Tests\\Functional\\Bundle\\RememberMeBundle\\Security;\n\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUser;\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUserProvider;\nuse Symfony\\Component\\Security\\Core\\User\\User;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserProviderInterface;\n\nclass UserChangingUserProvider implements UserProviderInterface\n{\n    private $inner;\n\n    public static $changePassword = false;\n\n    public function __construct(InMemoryUserProvider $inner)\n    {\n        $this->inner = $inner;\n    }\n\n    public function loadUserByUsername($username)\n    {\n        return $this->changeUser($this->inner->loadUserByUsername($username));\n    }\n\n    public function loadUserByIdentifier(string $userIdentifier): UserInterface\n    {\n        return $this->changeUser($this->inner->loadUserByIdentifier($userIdentifier));\n    }\n\n    public function refreshUser(UserInterface $user)\n    {\n        return $this->changeUser($this->inner->refreshUser($user));\n    }\n\n    public function supportsClass($class)\n    {\n        return $this->inner->supportsClass($class);\n    }\n\n    private function changeUser(UserInterface $user): UserInterface\n    {\n        if (self::$changePassword) {\n            $alterUser = \\Closure::bind(function (InMemoryUser $user) { $user->password = 'changed!'; }, null, class_exists(User::class) ? User::class : InMemoryUser::class);\n            $alterUser($user);\n        }\n\n        return $user;\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\SecurityBundle\\Tests\\Functional;\n\nuse Symfony\\Bundle\\SecurityBundle\\Tests\\Functional\\Bundle\\RememberMeBundle\\Security\\UserChangingUserProvider;\n\nclass RememberMeTest extends AbstractWebTestCase\n{\n    protected function setUp(): void\n    {\n        UserChangingUserProvider::$changePassword = false;\n    }\n\n    /**\n     * @dataProvider provideConfigs\n     */\n    public function testRememberMe(array $options)\n    {\n        $client = $this->createClient(array_merge_recursive(['root_config' => 'config.yml', 'test_case' => 'RememberMe'], $options));\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent());\n\n        // clear session, this should trigger remember me on the next request\n        $client->getCookieJar()->expire('MOCKSESSID');\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent(), 'Not logged in after resetting session.');\n\n        // logout, this should clear the remember-me cookie\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($client->getCookieJar()->get('REMEMBERME'));\n    }\n\n    public function testUserChangeClearsCookie()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'clear_on_change_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n        $cookieJar = $client->getCookieJar();\n        $this->assertNotNull($cookie = $cookieJar->get('REMEMBERME'));\n\n        UserChangingUserProvider::$changePassword = true;\n\n        // change password (through user provider), this deauthenticates the session\n        $client->request('GET', '/profile');\n        $this->assertRedirect($client->getResponse(), '/login');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n\n        // restore the old remember me cookie, it should no longer be valid\n        $cookieJar->set($cookie);\n        $client->request('GET', '/profile');\n        $this->assertRedirect($client->getResponse(), '/login');\n    }\n\n    public function testSessionLessRememberMeLogout()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'stateless_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $cookieJar = $client->getCookieJar();\n        $cookieJar->expire(session_name());\n\n        $this->assertNotNull($cookieJar->get('REMEMBERME'));\n        $this->assertSame('lax', $cookieJar->get('REMEMBERME')->getSameSite());\n\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n    }\n\n    /**\n     * @dataProvider provideLegacyConfigs\n     * @group legacy\n     */\n    public function testLegacyRememberMe(array $options)\n    {\n        $client = $this->createClient(array_merge_recursive(['root_config' => 'config.yml', 'test_case' => 'RememberMe'], $options));\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent());\n\n        // clear session, this should trigger remember me on the next request\n        $client->getCookieJar()->expire('MOCKSESSID');\n\n        $client->request('GET', '/profile');\n        $this->assertSame('johannes', $client->getResponse()->getContent(), 'Not logged in after resetting session.');\n\n        // logout, this should clear the remember-me cookie\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($client->getCookieJar()->get('REMEMBERME'));\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyUserChangeClearsCookie()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'clear_on_change_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $this->assertSame(302, $client->getResponse()->getStatusCode());\n        $cookieJar = $client->getCookieJar();\n        $this->assertNotNull($cookie = $cookieJar->get('REMEMBERME'));\n\n        UserChangingUserProvider::$changePassword = true;\n\n        // change password (through user provider), this deauthenticates the session\n        $client->request('GET', '/profile');\n        $this->assertRedirect($client->getResponse(), '/login');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n\n        // restore the old remember me cookie, it should no longer be valid\n        $cookieJar->set($cookie);\n        $client->request('GET', '/profile');\n        $this->assertRedirect($client->getResponse(), '/login');\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacySessionLessRememberMeLogout()\n    {\n        $client = $this->createClient(['test_case' => 'RememberMe', 'root_config' => 'stateless_config.yml']);\n\n        $client->request('POST', '/login', [\n            '_username' => 'johannes',\n            '_password' => 'test',\n        ]);\n\n        $cookieJar = $client->getCookieJar();\n        $cookieJar->expire(session_name());\n\n        $this->assertNotNull($cookieJar->get('REMEMBERME'));\n        $this->assertSame('lax', $cookieJar->get('REMEMBERME')->getSameSite());\n\n        $client->request('GET', '/logout');\n        $this->assertSame(302, $client->getResponse()->getStatusCode(), 'Logout unsuccessful.');\n        $this->assertNull($cookieJar->get('REMEMBERME'));\n    }\n\n    public function provideConfigs()\n    {\n        yield [['root_config' => 'config_session.yml']];\n        yield [['root_config' => 'config_persistent.yml']];\n    }\n\n    public function provideLegacyConfigs()\n    {\n        yield [['root_config' => 'legacy_config_session.yml']];\n        yield [['root_config' => 'legacy_config_persistent.yml']];\n    }\n}\n"], "filenames": ["src/Symfony/Bundle/SecurityBundle/DependencyInjection/Security/Factory/RememberMeFactory.php", "src/Symfony/Bundle/SecurityBundle/Tests/Functional/Bundle/RememberMeBundle/Security/UserChangingUserProvider.php", "src/Symfony/Bundle/SecurityBundle/Tests/Functional/RememberMeTest.php"], "buggy_code_start_loc": [210, 23, 13], "buggy_code_end_loc": [210, 52, 128], "fixing_code_start_loc": [211, 24, 14], "fixing_code_end_loc": [212, 60, 152], "type": "CWE-384", "message": "Symfony/SecurityBundle is the security system for Symfony, a PHP framework for web and console applications and a set of reusable PHP components. Since the rework of the Remember me cookie in version 5.3.0, the cookie is not invalidated when the user changes their password. Attackers can therefore maintain their access to the account even if the password is changed as long as they have had the chance to login once and get a valid remember me cookie. Starting with version 5.3.12, Symfony makes the password part of the signature by default. In that way, when the password changes, then the cookie is not valid anymore.", "other": {"cve": {"id": "CVE-2021-41268", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-24T19:15:07.817", "lastModified": "2021-11-30T20:04:56.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Symfony/SecurityBundle is the security system for Symfony, a PHP framework for web and console applications and a set of reusable PHP components. Since the rework of the Remember me cookie in version 5.3.0, the cookie is not invalidated when the user changes their password. Attackers can therefore maintain their access to the account even if the password is changed as long as they have had the chance to login once and get a valid remember me cookie. Starting with version 5.3.12, Symfony makes the password part of the signature by default. In that way, when the password changes, then the cookie is not valid anymore."}, {"lang": "es", "value": "Symfony/SecurityBundle es el sistema de seguridad de Symfony, un framework PHP para aplicaciones web y de consola y un conjunto de componentes PHP reusables. Desde la revisi\u00f3n de la cookie Remember me en la versi\u00f3n 5.3.0, la cookie no es invalidada cuando el usuario cambia su contrase\u00f1a. Por lo tanto, los atacantes pueden mantener su acceso a la cuenta aunque se cambie la contrase\u00f1a, siempre y cuando hayan tenido la oportunidad de iniciar sesi\u00f3n una vez y conseguir una cookie remember me v\u00e1lida. A partir de la versi\u00f3n 5.3.12, Symfony hace que la contrase\u00f1a sea parte de la firma por defecto. De esta forma, cuando la contrase\u00f1a cambia, la cookie deja de ser v\u00e1lida"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.3.0", "versionEndExcluding": "5.3.12", "matchCriteriaId": "13AF17F8-5CAF-4AB6-9A17-131D76C8D57B"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/36a808b857cd3240244f4b224452fb1e70dc6dfc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/pull/44243", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/releases/tag/v5.3.12", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-qw36-p97w-vcqr", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/36a808b857cd3240244f4b224452fb1e70dc6dfc"}}