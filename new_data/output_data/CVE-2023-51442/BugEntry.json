{"buggy_code": ["package auth\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-chi/jwtauth/v5\"\n\t\"github.com/lestrrat-go/jwx/v2/jwt\"\n\t\"github.com/navidrome/navidrome/conf\"\n\t\"github.com/navidrome/navidrome/consts\"\n\t\"github.com/navidrome/navidrome/log\"\n\t\"github.com/navidrome/navidrome/model\"\n\t\"github.com/navidrome/navidrome/model/request\"\n)\n\nvar (\n\tonce      sync.Once\n\tSecret    []byte\n\tTokenAuth *jwtauth.JWTAuth\n)\n\nfunc Init(ds model.DataStore) {\n\tonce.Do(func() {\n\t\tlog.Info(\"Setting Session Timeout\", \"value\", conf.Server.SessionTimeout)\n\t\tsecret, err := ds.Property(context.TODO()).DefaultGet(consts.JWTSecretKey, \"not so secret\")\n\t\tif err != nil {\n\t\t\tlog.Error(\"No JWT secret found in DB. Setting a temp one, but please report this error\", err)\n\t\t}\n\t\tSecret = []byte(secret)\n\t\tTokenAuth = jwtauth.New(\"HS256\", Secret, nil)\n\t})\n}\n\nfunc createBaseClaims() map[string]any {\n\ttokenClaims := map[string]any{}\n\ttokenClaims[jwt.IssuerKey] = consts.JWTIssuer\n\treturn tokenClaims\n}\n\nfunc CreatePublicToken(claims map[string]any) (string, error) {\n\ttokenClaims := createBaseClaims()\n\tfor k, v := range claims {\n\t\ttokenClaims[k] = v\n\t}\n\t_, token, err := TokenAuth.Encode(tokenClaims)\n\n\treturn token, err\n}\n\nfunc CreateExpiringPublicToken(exp time.Time, claims map[string]any) (string, error) {\n\ttokenClaims := createBaseClaims()\n\tif !exp.IsZero() {\n\t\ttokenClaims[jwt.ExpirationKey] = exp.UTC().Unix()\n\t}\n\tfor k, v := range claims {\n\t\ttokenClaims[k] = v\n\t}\n\t_, token, err := TokenAuth.Encode(tokenClaims)\n\n\treturn token, err\n}\n\nfunc CreateToken(u *model.User) (string, error) {\n\tclaims := createBaseClaims()\n\tclaims[jwt.SubjectKey] = u.UserName\n\tclaims[jwt.IssuedAtKey] = time.Now().UTC().Unix()\n\tclaims[\"uid\"] = u.ID\n\tclaims[\"adm\"] = u.IsAdmin\n\ttoken, _, err := TokenAuth.Encode(claims)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn TouchToken(token)\n}\n\nfunc TouchToken(token jwt.Token) (string, error) {\n\tclaims, err := token.AsMap(context.Background())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tclaims[jwt.ExpirationKey] = time.Now().UTC().Add(conf.Server.SessionTimeout).Unix()\n\t_, newToken, err := TokenAuth.Encode(claims)\n\n\treturn newToken, err\n}\n\nfunc Validate(tokenStr string) (map[string]interface{}, error) {\n\ttoken, err := jwtauth.VerifyToken(TokenAuth, tokenStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn token.AsMap(context.Background())\n}\n\nfunc WithAdminUser(ctx context.Context, ds model.DataStore) context.Context {\n\tu, err := ds.User(ctx).FindFirstAdmin()\n\tif err != nil {\n\t\tc, err := ds.User(ctx).CountAll()\n\t\tif c == 0 && err == nil {\n\t\t\tlog.Debug(ctx, \"Scanner: No admin user yet!\", err)\n\t\t} else {\n\t\t\tlog.Error(ctx, \"Scanner: No admin user found!\", err)\n\t\t}\n\t\tu = &model.User{}\n\t}\n\n\tctx = request.WithUsername(ctx, u.UserName)\n\treturn request.WithUser(ctx, *u)\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/go-chi/httprate\"\n\t\"github.com/navidrome/navidrome/conf\"\n\t\"github.com/navidrome/navidrome/consts\"\n\t\"github.com/navidrome/navidrome/core/auth\"\n\t\"github.com/navidrome/navidrome/log\"\n\t\"github.com/navidrome/navidrome/model\"\n\t\"github.com/navidrome/navidrome/server/events\"\n\t\"github.com/navidrome/navidrome/ui\"\n\t. \"github.com/navidrome/navidrome/utils/gg\"\n)\n\ntype Server struct {\n\trouter  chi.Router\n\tds      model.DataStore\n\tappRoot string\n\tbroker  events.Broker\n}\n\nfunc New(ds model.DataStore, broker events.Broker) *Server {\n\ts := &Server{ds: ds, broker: broker}\n\tauth.Init(s.ds)\n\tinitialSetup(ds)\n\ts.initRoutes()\n\ts.mountAuthenticationRoutes()\n\ts.mountRootRedirector()\n\tcheckFfmpegInstallation()\n\tcheckExternalCredentials()\n\treturn s\n}\n\nfunc (s *Server) MountRouter(description, urlPath string, subRouter http.Handler) {\n\turlPath = path.Join(conf.Server.BasePath, urlPath)\n\tlog.Info(fmt.Sprintf(\"Mounting %s routes\", description), \"path\", urlPath)\n\ts.router.Group(func(r chi.Router) {\n\t\tr.Mount(urlPath, subRouter)\n\t})\n}\n\n// Run starts the server with the given address, and if specified, with TLS enabled.\nfunc (s *Server) Run(ctx context.Context, addr string, port int, tlsCert string, tlsKey string) error {\n\t// Mount the router for the frontend assets\n\ts.MountRouter(\"WebUI\", consts.URLPathUI, s.frontendAssetsHandler())\n\n\t// Create a new http.Server with the specified read header timeout and handler\n\tserver := &http.Server{\n\t\tReadHeaderTimeout: consts.ServerReadHeaderTimeout,\n\t\tHandler:           s.router,\n\t}\n\n\t// Determine if TLS is enabled\n\ttlsEnabled := tlsCert != \"\" && tlsKey != \"\"\n\n\t// Create a listener based on the address type (either Unix socket or TCP)\n\tvar listener net.Listener\n\tvar err error\n\tif strings.HasPrefix(addr, \"unix:\") {\n\t\tsocketPath := strings.TrimPrefix(addr, \"unix:\")\n\t\t// Remove the socket file if it already exists\n\t\tif err := os.Remove(socketPath); err != nil && !os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"error removing previous unix socket file: %w\", err)\n\t\t}\n\t\tlistener, err = net.Listen(\"unix\", socketPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error creating unix socket listener: %w\", err)\n\t\t}\n\t} else {\n\t\taddr = fmt.Sprintf(\"%s:%d\", addr, port)\n\t\tlistener, err = net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error creating tcp listener: %w\", err)\n\t\t}\n\t}\n\n\t// Start the server in a new goroutine and send an error signal to errC if there's an error\n\terrC := make(chan error)\n\tgo func() {\n\t\tif tlsEnabled {\n\t\t\t// Start the HTTPS server\n\t\t\tlog.Info(\"Starting server with TLS (HTTPS) enabled\", \"tlsCert\", tlsCert, \"tlsKey\", tlsKey)\n\t\t\tif err := server.ServeTLS(listener, tlsCert, tlsKey); !errors.Is(err, http.ErrServerClosed) {\n\t\t\t\terrC <- err\n\t\t\t}\n\t\t} else {\n\t\t\t// Start the HTTP server\n\t\t\tif err := server.Serve(listener); !errors.Is(err, http.ErrServerClosed) {\n\t\t\t\terrC <- err\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Measure server startup time\n\tstartupTime := time.Since(consts.ServerStart)\n\n\t// Wait a short time before checking if the server has started successfully\n\ttime.Sleep(50 * time.Millisecond)\n\tselect {\n\tcase err := <-errC:\n\t\tlog.Error(ctx, \"Could not start server. Aborting\", err)\n\t\treturn fmt.Errorf(\"error starting server: %w\", err)\n\tdefault:\n\t\tlog.Info(ctx, \"----> Navidrome server is ready!\", \"address\", addr, \"startupTime\", startupTime, \"tlsEnabled\", tlsEnabled)\n\t}\n\n\t// Wait for a signal to terminate\n\tselect {\n\tcase err := <-errC:\n\t\treturn fmt.Errorf(\"error running server: %w\", err)\n\tcase <-ctx.Done():\n\t\t// If the context is done (i.e. the server should stop), proceed to shutting down the server\n\t}\n\n\t// Try to stop the HTTP server gracefully\n\tlog.Info(ctx, \"Stopping HTTP server\")\n\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel()\n\tserver.SetKeepAlivesEnabled(false)\n\tif err := server.Shutdown(ctx); err != nil && !errors.Is(err, context.DeadlineExceeded) {\n\t\tlog.Error(ctx, \"Unexpected error in http.Shutdown()\", err)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) initRoutes() {\n\ts.appRoot = path.Join(conf.Server.BasePath, consts.URLPathUI)\n\n\tr := chi.NewRouter()\n\n\tmiddlewares := chi.Middlewares{\n\t\tsecureMiddleware(),\n\t\tcorsHandler(),\n\t\tmiddleware.RequestID,\n\t}\n\tif conf.Server.ReverseProxyWhitelist == \"\" {\n\t\tmiddlewares = append(middlewares, middleware.RealIP)\n\t}\n\n\tmiddlewares = append(middlewares,\n\t\tmiddleware.Recoverer,\n\t\tmiddleware.Heartbeat(\"/ping\"),\n\t\trobotsTXT(ui.BuildAssets()),\n\t\tserverAddressMiddleware,\n\t\tclientUniqueIDMiddleware,\n\t)\n\n\t// Mount the Native API /events endpoint with all middlewares, except the compress and request logger,\n\t// adding the authentication middlewares\n\tif conf.Server.DevActivityPanel {\n\t\tr.Group(func(r chi.Router) {\n\t\t\tr.Use(middlewares...)\n\t\t\tr.Use(loggerInjector)\n\t\t\tr.Use(authHeaderMapper)\n\t\t\tr.Use(jwtVerifier)\n\t\t\tr.Use(Authenticator(s.ds))\n\t\t\tr.Use(JWTRefresher)\n\t\t\tr.Handle(path.Join(conf.Server.BasePath, consts.URLPathNativeAPI, \"events\"), s.broker)\n\t\t})\n\t}\n\n\t// Configure the router with the default middlewares\n\tr.Group(func(r chi.Router) {\n\t\tr.Use(middlewares...)\n\t\tr.Use(compressMiddleware())\n\t\tr.Use(loggerInjector)\n\t\tr.Use(requestLogger)\n\t\tr.Use(authHeaderMapper)\n\t\tr.Use(jwtVerifier)\n\t\ts.router = r\n\t})\n}\n\nfunc (s *Server) mountAuthenticationRoutes() chi.Router {\n\tr := s.router\n\treturn r.Route(path.Join(conf.Server.BasePath, \"/auth\"), func(r chi.Router) {\n\t\tif conf.Server.AuthRequestLimit > 0 {\n\t\t\tlog.Info(\"Login rate limit set\", \"requestLimit\", conf.Server.AuthRequestLimit,\n\t\t\t\t\"windowLength\", conf.Server.AuthWindowLength)\n\n\t\t\trateLimiter := httprate.LimitByIP(conf.Server.AuthRequestLimit, conf.Server.AuthWindowLength)\n\t\t\tr.With(rateLimiter).Post(\"/login\", login(s.ds))\n\t\t} else {\n\t\t\tlog.Warn(\"Login rate limit is disabled! Consider enabling it to be protected against brute-force attacks\")\n\n\t\t\tr.Post(\"/login\", login(s.ds))\n\t\t}\n\t\tr.Post(\"/createAdmin\", createAdmin(s.ds))\n\t})\n}\n\n// Serve UI app assets\nfunc (s *Server) mountRootRedirector() {\n\tr := s.router\n\t// Redirect root to UI URL\n\tr.Get(\"/*\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, s.appRoot+\"/\", http.StatusFound)\n\t})\n\tr.Get(s.appRoot, func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, s.appRoot+\"/\", http.StatusFound)\n\t})\n}\n\nfunc (s *Server) frontendAssetsHandler() http.Handler {\n\tr := chi.NewRouter()\n\n\tr.Handle(\"/\", Index(s.ds, ui.BuildAssets()))\n\tr.Handle(\"/*\", http.StripPrefix(s.appRoot, http.FileServer(http.FS(ui.BuildAssets()))))\n\treturn r\n}\n\nfunc AbsoluteURL(r *http.Request, u string, params url.Values) string {\n\tbuildUrl, _ := url.Parse(u)\n\tif strings.HasPrefix(u, \"/\") {\n\t\tbuildUrl.Path = path.Join(conf.Server.BasePath, buildUrl.Path)\n\t\tif conf.Server.BaseHost != \"\" {\n\t\t\tbuildUrl.Scheme = If(conf.Server.BaseScheme, \"http\")\n\t\t\tbuildUrl.Host = conf.Server.BaseHost\n\t\t} else {\n\t\t\tbuildUrl.Scheme = r.URL.Scheme\n\t\t\tbuildUrl.Host = r.Host\n\t\t}\n\t}\n\tif len(params) > 0 {\n\t\tbuildUrl.RawQuery = params.Encode()\n\t}\n\treturn buildUrl.String()\n}\n"], "fixing_code": ["package auth\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-chi/jwtauth/v5\"\n\t\"github.com/google/uuid\"\n\t\"github.com/lestrrat-go/jwx/v2/jwt\"\n\t\"github.com/navidrome/navidrome/conf\"\n\t\"github.com/navidrome/navidrome/consts\"\n\t\"github.com/navidrome/navidrome/log\"\n\t\"github.com/navidrome/navidrome/model\"\n\t\"github.com/navidrome/navidrome/model/request\"\n)\n\nvar (\n\tonce      sync.Once\n\tSecret    []byte\n\tTokenAuth *jwtauth.JWTAuth\n)\n\nfunc Init(ds model.DataStore) {\n\tonce.Do(func() {\n\t\tlog.Info(\"Setting Session Timeout\", \"value\", conf.Server.SessionTimeout)\n\t\tsecret, err := ds.Property(context.TODO()).Get(consts.JWTSecretKey)\n\t\tif err != nil || secret == \"\" {\n\t\t\tlog.Error(\"No JWT secret found in DB. Setting a temp one, but please report this error\", err)\n\t\t\tsecret = uuid.NewString()\n\t\t}\n\t\tSecret = []byte(secret)\n\t\tTokenAuth = jwtauth.New(\"HS256\", Secret, nil)\n\t})\n}\n\nfunc createBaseClaims() map[string]any {\n\ttokenClaims := map[string]any{}\n\ttokenClaims[jwt.IssuerKey] = consts.JWTIssuer\n\treturn tokenClaims\n}\n\nfunc CreatePublicToken(claims map[string]any) (string, error) {\n\ttokenClaims := createBaseClaims()\n\tfor k, v := range claims {\n\t\ttokenClaims[k] = v\n\t}\n\t_, token, err := TokenAuth.Encode(tokenClaims)\n\n\treturn token, err\n}\n\nfunc CreateExpiringPublicToken(exp time.Time, claims map[string]any) (string, error) {\n\ttokenClaims := createBaseClaims()\n\tif !exp.IsZero() {\n\t\ttokenClaims[jwt.ExpirationKey] = exp.UTC().Unix()\n\t}\n\tfor k, v := range claims {\n\t\ttokenClaims[k] = v\n\t}\n\t_, token, err := TokenAuth.Encode(tokenClaims)\n\n\treturn token, err\n}\n\nfunc CreateToken(u *model.User) (string, error) {\n\tclaims := createBaseClaims()\n\tclaims[jwt.SubjectKey] = u.UserName\n\tclaims[jwt.IssuedAtKey] = time.Now().UTC().Unix()\n\tclaims[\"uid\"] = u.ID\n\tclaims[\"adm\"] = u.IsAdmin\n\ttoken, _, err := TokenAuth.Encode(claims)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn TouchToken(token)\n}\n\nfunc TouchToken(token jwt.Token) (string, error) {\n\tclaims, err := token.AsMap(context.Background())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tclaims[jwt.ExpirationKey] = time.Now().UTC().Add(conf.Server.SessionTimeout).Unix()\n\t_, newToken, err := TokenAuth.Encode(claims)\n\n\treturn newToken, err\n}\n\nfunc Validate(tokenStr string) (map[string]interface{}, error) {\n\ttoken, err := jwtauth.VerifyToken(TokenAuth, tokenStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn token.AsMap(context.Background())\n}\n\nfunc WithAdminUser(ctx context.Context, ds model.DataStore) context.Context {\n\tu, err := ds.User(ctx).FindFirstAdmin()\n\tif err != nil {\n\t\tc, err := ds.User(ctx).CountAll()\n\t\tif c == 0 && err == nil {\n\t\t\tlog.Debug(ctx, \"Scanner: No admin user yet!\", err)\n\t\t} else {\n\t\t\tlog.Error(ctx, \"Scanner: No admin user found!\", err)\n\t\t}\n\t\tu = &model.User{}\n\t}\n\n\tctx = request.WithUsername(ctx, u.UserName)\n\treturn request.WithUser(ctx, *u)\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/go-chi/httprate\"\n\t\"github.com/navidrome/navidrome/conf\"\n\t\"github.com/navidrome/navidrome/consts\"\n\t\"github.com/navidrome/navidrome/core/auth\"\n\t\"github.com/navidrome/navidrome/log\"\n\t\"github.com/navidrome/navidrome/model\"\n\t\"github.com/navidrome/navidrome/server/events\"\n\t\"github.com/navidrome/navidrome/ui\"\n\t. \"github.com/navidrome/navidrome/utils/gg\"\n)\n\ntype Server struct {\n\trouter  chi.Router\n\tds      model.DataStore\n\tappRoot string\n\tbroker  events.Broker\n}\n\nfunc New(ds model.DataStore, broker events.Broker) *Server {\n\ts := &Server{ds: ds, broker: broker}\n\tinitialSetup(ds)\n\tauth.Init(s.ds)\n\ts.initRoutes()\n\ts.mountAuthenticationRoutes()\n\ts.mountRootRedirector()\n\tcheckFfmpegInstallation()\n\tcheckExternalCredentials()\n\treturn s\n}\n\nfunc (s *Server) MountRouter(description, urlPath string, subRouter http.Handler) {\n\turlPath = path.Join(conf.Server.BasePath, urlPath)\n\tlog.Info(fmt.Sprintf(\"Mounting %s routes\", description), \"path\", urlPath)\n\ts.router.Group(func(r chi.Router) {\n\t\tr.Mount(urlPath, subRouter)\n\t})\n}\n\n// Run starts the server with the given address, and if specified, with TLS enabled.\nfunc (s *Server) Run(ctx context.Context, addr string, port int, tlsCert string, tlsKey string) error {\n\t// Mount the router for the frontend assets\n\ts.MountRouter(\"WebUI\", consts.URLPathUI, s.frontendAssetsHandler())\n\n\t// Create a new http.Server with the specified read header timeout and handler\n\tserver := &http.Server{\n\t\tReadHeaderTimeout: consts.ServerReadHeaderTimeout,\n\t\tHandler:           s.router,\n\t}\n\n\t// Determine if TLS is enabled\n\ttlsEnabled := tlsCert != \"\" && tlsKey != \"\"\n\n\t// Create a listener based on the address type (either Unix socket or TCP)\n\tvar listener net.Listener\n\tvar err error\n\tif strings.HasPrefix(addr, \"unix:\") {\n\t\tsocketPath := strings.TrimPrefix(addr, \"unix:\")\n\t\t// Remove the socket file if it already exists\n\t\tif err := os.Remove(socketPath); err != nil && !os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"error removing previous unix socket file: %w\", err)\n\t\t}\n\t\tlistener, err = net.Listen(\"unix\", socketPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error creating unix socket listener: %w\", err)\n\t\t}\n\t} else {\n\t\taddr = fmt.Sprintf(\"%s:%d\", addr, port)\n\t\tlistener, err = net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error creating tcp listener: %w\", err)\n\t\t}\n\t}\n\n\t// Start the server in a new goroutine and send an error signal to errC if there's an error\n\terrC := make(chan error)\n\tgo func() {\n\t\tif tlsEnabled {\n\t\t\t// Start the HTTPS server\n\t\t\tlog.Info(\"Starting server with TLS (HTTPS) enabled\", \"tlsCert\", tlsCert, \"tlsKey\", tlsKey)\n\t\t\tif err := server.ServeTLS(listener, tlsCert, tlsKey); !errors.Is(err, http.ErrServerClosed) {\n\t\t\t\terrC <- err\n\t\t\t}\n\t\t} else {\n\t\t\t// Start the HTTP server\n\t\t\tif err := server.Serve(listener); !errors.Is(err, http.ErrServerClosed) {\n\t\t\t\terrC <- err\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Measure server startup time\n\tstartupTime := time.Since(consts.ServerStart)\n\n\t// Wait a short time before checking if the server has started successfully\n\ttime.Sleep(50 * time.Millisecond)\n\tselect {\n\tcase err := <-errC:\n\t\tlog.Error(ctx, \"Could not start server. Aborting\", err)\n\t\treturn fmt.Errorf(\"error starting server: %w\", err)\n\tdefault:\n\t\tlog.Info(ctx, \"----> Navidrome server is ready!\", \"address\", addr, \"startupTime\", startupTime, \"tlsEnabled\", tlsEnabled)\n\t}\n\n\t// Wait for a signal to terminate\n\tselect {\n\tcase err := <-errC:\n\t\treturn fmt.Errorf(\"error running server: %w\", err)\n\tcase <-ctx.Done():\n\t\t// If the context is done (i.e. the server should stop), proceed to shutting down the server\n\t}\n\n\t// Try to stop the HTTP server gracefully\n\tlog.Info(ctx, \"Stopping HTTP server\")\n\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel()\n\tserver.SetKeepAlivesEnabled(false)\n\tif err := server.Shutdown(ctx); err != nil && !errors.Is(err, context.DeadlineExceeded) {\n\t\tlog.Error(ctx, \"Unexpected error in http.Shutdown()\", err)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) initRoutes() {\n\ts.appRoot = path.Join(conf.Server.BasePath, consts.URLPathUI)\n\n\tr := chi.NewRouter()\n\n\tmiddlewares := chi.Middlewares{\n\t\tsecureMiddleware(),\n\t\tcorsHandler(),\n\t\tmiddleware.RequestID,\n\t}\n\tif conf.Server.ReverseProxyWhitelist == \"\" {\n\t\tmiddlewares = append(middlewares, middleware.RealIP)\n\t}\n\n\tmiddlewares = append(middlewares,\n\t\tmiddleware.Recoverer,\n\t\tmiddleware.Heartbeat(\"/ping\"),\n\t\trobotsTXT(ui.BuildAssets()),\n\t\tserverAddressMiddleware,\n\t\tclientUniqueIDMiddleware,\n\t)\n\n\t// Mount the Native API /events endpoint with all middlewares, except the compress and request logger,\n\t// adding the authentication middlewares\n\tif conf.Server.DevActivityPanel {\n\t\tr.Group(func(r chi.Router) {\n\t\t\tr.Use(middlewares...)\n\t\t\tr.Use(loggerInjector)\n\t\t\tr.Use(authHeaderMapper)\n\t\t\tr.Use(jwtVerifier)\n\t\t\tr.Use(Authenticator(s.ds))\n\t\t\tr.Use(JWTRefresher)\n\t\t\tr.Handle(path.Join(conf.Server.BasePath, consts.URLPathNativeAPI, \"events\"), s.broker)\n\t\t})\n\t}\n\n\t// Configure the router with the default middlewares\n\tr.Group(func(r chi.Router) {\n\t\tr.Use(middlewares...)\n\t\tr.Use(compressMiddleware())\n\t\tr.Use(loggerInjector)\n\t\tr.Use(requestLogger)\n\t\tr.Use(authHeaderMapper)\n\t\tr.Use(jwtVerifier)\n\t\ts.router = r\n\t})\n}\n\nfunc (s *Server) mountAuthenticationRoutes() chi.Router {\n\tr := s.router\n\treturn r.Route(path.Join(conf.Server.BasePath, \"/auth\"), func(r chi.Router) {\n\t\tif conf.Server.AuthRequestLimit > 0 {\n\t\t\tlog.Info(\"Login rate limit set\", \"requestLimit\", conf.Server.AuthRequestLimit,\n\t\t\t\t\"windowLength\", conf.Server.AuthWindowLength)\n\n\t\t\trateLimiter := httprate.LimitByIP(conf.Server.AuthRequestLimit, conf.Server.AuthWindowLength)\n\t\t\tr.With(rateLimiter).Post(\"/login\", login(s.ds))\n\t\t} else {\n\t\t\tlog.Warn(\"Login rate limit is disabled! Consider enabling it to be protected against brute-force attacks\")\n\n\t\t\tr.Post(\"/login\", login(s.ds))\n\t\t}\n\t\tr.Post(\"/createAdmin\", createAdmin(s.ds))\n\t})\n}\n\n// Serve UI app assets\nfunc (s *Server) mountRootRedirector() {\n\tr := s.router\n\t// Redirect root to UI URL\n\tr.Get(\"/*\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, s.appRoot+\"/\", http.StatusFound)\n\t})\n\tr.Get(s.appRoot, func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, s.appRoot+\"/\", http.StatusFound)\n\t})\n}\n\nfunc (s *Server) frontendAssetsHandler() http.Handler {\n\tr := chi.NewRouter()\n\n\tr.Handle(\"/\", Index(s.ds, ui.BuildAssets()))\n\tr.Handle(\"/*\", http.StripPrefix(s.appRoot, http.FileServer(http.FS(ui.BuildAssets()))))\n\treturn r\n}\n\nfunc AbsoluteURL(r *http.Request, u string, params url.Values) string {\n\tbuildUrl, _ := url.Parse(u)\n\tif strings.HasPrefix(u, \"/\") {\n\t\tbuildUrl.Path = path.Join(conf.Server.BasePath, buildUrl.Path)\n\t\tif conf.Server.BaseHost != \"\" {\n\t\t\tbuildUrl.Scheme = If(conf.Server.BaseScheme, \"http\")\n\t\t\tbuildUrl.Host = conf.Server.BaseHost\n\t\t} else {\n\t\t\tbuildUrl.Scheme = r.URL.Scheme\n\t\t\tbuildUrl.Host = r.Host\n\t\t}\n\t}\n\tif len(params) > 0 {\n\t\tbuildUrl.RawQuery = params.Encode()\n\t}\n\treturn buildUrl.String()\n}\n"], "filenames": ["core/auth/auth.go", "server/server.go"], "buggy_code_start_loc": [8, 36], "buggy_code_end_loc": [28, 39], "fixing_code_start_loc": [9, 37], "fixing_code_end_loc": [31, 38], "type": "CWE-287", "message": "Navidrome is an open source web-based music collection server and streamer. A security vulnerability has been identified in navidrome's subsonic endpoint, allowing for authentication bypass. This exploit enables unauthorized access to any known account by utilizing a JSON Web Token (JWT) signed with the key \"not so secret\". The vulnerability can only be exploited on instances that have never been restarted. Navidrome supports an extension to the subsonic authentication scheme, where a JWT can be provided using a `jwt` query parameter instead of the traditional password or token and salt (corresponding to resp. the `p` or `t` and `s` query parameters). This authentication bypass vulnerability potentially affects all instances that don't protect the subsonic endpoint `/rest/`, which is expected to be most instances in a standard deployment, and most instances in the reverse proxy setup too (as the documentation mentions to leave that endpoint unprotected). This issue has been patched in version 0.50.2.\n", "other": {"cve": {"id": "CVE-2023-51442", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-21T15:15:13.397", "lastModified": "2024-01-04T14:12:46.563", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Navidrome is an open source web-based music collection server and streamer. A security vulnerability has been identified in navidrome's subsonic endpoint, allowing for authentication bypass. This exploit enables unauthorized access to any known account by utilizing a JSON Web Token (JWT) signed with the key \"not so secret\". The vulnerability can only be exploited on instances that have never been restarted. Navidrome supports an extension to the subsonic authentication scheme, where a JWT can be provided using a `jwt` query parameter instead of the traditional password or token and salt (corresponding to resp. the `p` or `t` and `s` query parameters). This authentication bypass vulnerability potentially affects all instances that don't protect the subsonic endpoint `/rest/`, which is expected to be most instances in a standard deployment, and most instances in the reverse proxy setup too (as the documentation mentions to leave that endpoint unprotected). This issue has been patched in version 0.50.2.\n"}, {"lang": "es", "value": "Navidrome es un servidor y transmisor de colecci\u00f3n de m\u00fasica basado en web de c\u00f3digo abierto. Se ha identificado una vulnerabilidad de seguridad en el endpoint subs\u00f3nico de Navidrome, lo que permite omitir la autenticaci\u00f3n. Esta explotaci\u00f3n permite el acceso no autorizado a cualquier cuenta conocida mediante la utilizaci\u00f3n de un token web JSON (JWT) firmado con la clave \"not so secret\". La vulnerabilidad s\u00f3lo se puede explotar en instancias que nunca se han reiniciado. Navidrome admite una extensi\u00f3n del esquema de autenticaci\u00f3n subs\u00f3nica, donde se puede proporcionar un JWT usando un par\u00e1metro de consulta `jwt` en lugar de la contrase\u00f1a tradicional o token y salt (correspondiente a, respectivamente, la consulta `p` o `t` y `s` par\u00e1metros). Esta vulnerabilidad de omisi\u00f3n de autenticaci\u00f3n afecta potencialmente a todas las instancias que no protegen el endpoint subs\u00f3nico `/rest/`, que se espera que sea la mayor\u00eda de las instancias en una implementaci\u00f3n est\u00e1ndar, y tambi\u00e9n la mayor\u00eda de las instancias en la configuraci\u00f3n de proxy inverso (como menciona la documentaci\u00f3n para dejar ese punto final desprotegido). Este problema se solucion\u00f3 en la versi\u00f3n 0.50.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:navidrome:navidrome:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.50.2", "matchCriteriaId": "230BD176-20CA-4E61-BD08-AB11F8ACBF0B"}]}]}], "references": [{"url": "https://github.com/navidrome/navidrome/commit/1132abb0135d1ecaebc41ed97a1e908a4ae02f7c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/navidrome/navidrome/security/advisories/GHSA-wq59-4q6r-635r", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/navidrome/navidrome/commit/1132abb0135d1ecaebc41ed97a1e908a4ae02f7c"}}