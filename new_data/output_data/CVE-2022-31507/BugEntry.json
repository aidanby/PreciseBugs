{"buggy_code": ["import os\nimport jwt\nimport json\nimport requests\nimport time\nimport select\nimport termios\nimport struct\nimport fcntl\nimport subprocess\nimport pty\nimport sys\nimport datetime\nfrom functools import wraps\nfrom werkzeug.utils import secure_filename\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom flask import Flask, request, jsonify, render_template, flash, redirect, url_for, session, send_file, make_response\nfrom flask_login import login_user, login_required, logout_user, current_user, UserMixin\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\nfrom flask_socketio import SocketIO\nfrom GangaGUI.gui.config import Config\n\n# ******************** Initialisation of Flask App for GUI ******************** #\n\n\n# GUI Flask App and set configuration from ./config.py file\ngui = Flask(__name__)\ngui.config.from_object(Config)\n\n# Database object which is used to interact with the \"gui.sqlite\" in gangadir/gui folder\n# NOTE: IT HAS NO RELATION WITH THE GANGA PERSISTENT DATABASE\ndb = SQLAlchemy(gui)\n\n# Login manage for the view routes\nlogin = LoginManager(gui)\nlogin.login_view = \"login\"\nlogin.login_message = \"Please Login to Access this Page.\"\nlogin.login_message_category = \"warning\"\n\n# For websocket, for communication between frontend and backend\nsocketio = SocketIO(gui)\n\n\n# ******************** The user class for database and authentication ******************** #\n\n# ORM Class to represent Users - used to access the GUI & API resources\nclass User(UserMixin, db.Model):\n    __tablename__ = \"users\"\n    id = db.Column(db.Integer, primary_key=True)\n    public_id = db.Column(db.String(64), unique=True)\n    user = db.Column(db.String(32), unique=True)\n    password_hash = db.Column(db.String(64))\n    role = db.Column(db.String(32))\n    pinned_jobs = db.Column(db.Text)\n\n    def store_password_hash(self, password: str):\n        self.password_hash = generate_password_hash(password)\n\n    def verify_password(self, password: str) -> bool:\n        return check_password_hash(self.password_hash, password)\n\n    def generate_auth_token(self, expires_in_days: int = 5) -> str:\n        return jwt.encode(\n            {\"public_id\": self.public_id, \"exp\": datetime.datetime.utcnow() + datetime.timedelta(days=expires_in_days)},\n            gui.config[\"SECRET_KEY\"], algorithm=\"HS256\")\n\n    def __repr__(self):\n        return \"User {}: {} (Public ID: {}, Role: {})\".format(self.id, self.user, self.public_id, self.role)\n\n\n# User Loader Function for Flask Login\n@login.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))\n\n\n# ******************** Global Variables ******************** #\n\n\n# Colors showed for different job statuses in the GUI based on Bootstrap CSS\nstatus_color = {\n    \"new\": \"info\",\n    \"completed\": \"success\",\n    \"completed_frozen\" : \"success\",\n    \"failed\": \"danger\",\n    \"failed_frozen\" : \"danger\",\n    \"running\": \"primary\",\n    \"submitted\": \"secondary\",\n    \"killed\": \"warning\"\n}\n\n# Allowed extensions when uploading any files to GUI\nALLOWED_EXTENSIONS = {\"txt\", \"py\"}\n\n# Variables to globally store plugins and actions\nactions = {}\nplugins = {}\n\n\n# ******************** Run Before First Request ******************** #\n\n\n# Execute before first request\n@gui.before_first_request\ndef initial_run():\n    \"\"\"\n    This function runs before first request. It stores actions and plugins information from the ganga. It create default session cookies. If WEB_CLI is also started then it also starts a Ganga session.\n    \"\"\"\n\n    global actions, plugins\n\n    # Start ganga if WEB_CLI mode is True\n    if gui.config['WEB_CLI'] is True:\n        start_ganga(gui.config['INTERNAL_PORT'], args=gui.config[\"GANGA_ARGS\"])\n        session[\"WEB_CLI\"] = True\n    elif gui.config['INTERNAL_PORT'] is None:\n        gui.config['INTERNAL_PORT'] = os.environ['INTERNAL_PORT']\n\n    # If user is authenticated, log them out. This happens after a fresh start of the GUI server.\n    if current_user.is_authenticated:\n        logout_user()\n\n    # Create user session defaults\n    create_session_defaults()\n\n    # Check if internal server is online, exit after 20s of retrying\n    if not ping_internal():\n        print(\"INTERNAL SERVER UNAVAILABLE, TERMINATING...\")\n        sys.exit(1)\n\n    # Get job actions and plugins information from ganga\n    try:\n        # Get actions and plugins data once\n        actions = query_internal_api(\"/internal/jobs/actions\", \"get\")\n        plugins = query_internal_api(\"/internal/plugins\", \"get\")\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n\n# ******************** View Routes ******************** #\n\n\n# Login View\n@gui.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    \"\"\"\n    Handles login route of the GUI.\n    \"\"\"\n\n    # If already authenticated, logout\n    if current_user.is_authenticated:\n        return redirect(url_for(\"dashboard\"))\n\n    # Login user\n    if request.method == \"POST\":\n\n        # Form data\n        username = request.form.get(\"username\")\n        password = request.form.get(\"password\")\n\n        # Database query\n        user = User.query.filter_by(user=username).first()\n\n        # If valid user, login\n        if user and user.verify_password(password):\n            login_user(user, True)\n            flash(\"Login successful\", \"success\")\n            return redirect(url_for(\"dashboard\"))\n\n        flash(\"Error identifying the user\", \"danger\")\n\n    # Get users from the database\n    users = User.query.all()\n\n    return render_template(\"login.html\", title=\"Login\", users=users)\n\n\n# Logout View\n@gui.route(\"/logout\", methods=[\"GET\"])\ndef logout():\n    \"\"\"\n    Logout user from GUI\n    \"\"\"\n\n    # Logout\n    if current_user.is_authenticated:\n        logout_user()\n\n    return redirect(url_for(\"login\"))\n\n\n# Dashboard view\n@gui.route(\"/\")\n@login_required\ndef dashboard():\n    \"\"\"\n    Handles the dashboard route of the GUI.\n    \"\"\"\n\n    quick_statistics = {}\n    recent_jobs_info = []\n    pinned_jobs_info = []\n\n    try:\n        # Query overall statistics\n        quick_statistics = query_internal_api(\"/internal/jobs/statistics\", \"get\")\n\n        # Query recent 10 jobs\n        recent_jobs_info = query_internal_api(\"/internal/jobs/recent\", \"get\")\n\n        # Query pinned jobs\n        u = current_user\n        pinned_jobs_info = query_internal_api(\"/internal/jobs\", \"get\", params={\n            \"ids\": u.pinned_jobs if u.pinned_jobs is not None else json.dumps([]),\n            \"auto-validate-ids\": True})\n\n    except Exception as err:\n        # Flash the error in the GUI\n        flash(str(err), \"danger\")\n\n    return render_template(\"dashboard.html\",\n                           title=\"Dashboard\",\n                           quick_statistics=quick_statistics,\n                           recent_jobs_info=recent_jobs_info,\n                           pinned_jobs_info=pinned_jobs_info,\n                           status_color=status_color)\n\n\n# Config view\n@gui.route(\"/config\", methods=[\"GET\", \"POST\"])\n@login_required\ndef config_page():\n    \"\"\"\n    Handles the config route of the GUI.\n    \"\"\"\n\n    full_config_info = []\n    config_info = []\n    section = None\n\n    # When GUI request for specific section\n    if request.method == \"POST\":\n        # Get section name for request form data\n        section = request.form.get(\"section\")\n        section = None if section in [\"\", None] else section\n\n    try:\n        # Query full config\n        full_config_info = query_internal_api(\"/internal/config\", \"get\")\n\n        # If asked for specific section, add only that for displaying\n        config_info = full_config_info if section is None else [s for s in full_config_info if s[\"name\"] == section]\n\n    except Exception as err:\n        # Flash the error in the GUI\n        flash(str(err), \"danger\")\n\n    return render_template(\"config.html\", title=\"Config\", full_config_info=full_config_info, config_info=config_info)\n\n#Edit gangarc\n@gui.route(\"/config_edit\",methods=[\"GET\", \"POST\"])\n@login_required\ndef edit_config_page():\n    \"\"\"\n    Edit gangarc file from the GUI\n    \"\"\"\n    gui_rc = gui.config[\"GANGA_RC\"]\n    with open(gui_rc, \"rt\") as f:\n        ganga_config = f.read()\n    if request.method == 'POST':\n        config_ganga = request.form['config-data']\n        with open(gui_rc, 'w') as f1:\n            f1.write(str(config_ganga))\n        flash(\".gangarc Edited\", \"success\")\n        with open(gui_rc, \"rt\") as f2:\n            ganga_config = f2.read()\n    return render_template(\"config_edit.html\", title=\"Edit gangarc\", ganga_config=ganga_config)\n    \n@login_required\n# Create view\n@gui.route(\"/create\", methods=[\"GET\", \"POST\"])\ndef create_page():\n    \"\"\"\n    Handles create route of the GUI.\n    \"\"\"\n\n    # Handle file uploads\n    if request.method == \"POST\":\n\n        # Load from the uploaded file\n        if \"loadfile\" in request.files:\n            loadfile = request.files[\"loadfile\"]\n            if loadfile.filename == \"\":\n                flash(\"No file selected\", \"warning\")\n                return redirect(request.url)\n\n            # If valid file, the save the file\n            if loadfile and allowed_file(loadfile.filename):\n                save_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"loadfile.txt\")\n                loadfile.save(save_path)\n\n                # Load the file\n                try:\n                    # Query to load the file\n                    response_info = query_internal_api(\"/internal/load\", \"get\", params={\"path\": save_path})\n\n                except Exception as err:\n                    # Display error in the GUI\n                    flash(str(err), \"danger\")\n                    return redirect(request.url)\n\n                # Success message\n                flash(response_info.get(\"message\"), \"success\")\n                return redirect(request.url)\n\n        # Run file using the runfile GPI function\n        if \"runfile\" in request.files:\n            runfile = request.files[\"runfile\"]\n            if runfile.filename == \"\":\n                flash(\"No file selected\", \"warning\")\n                return redirect(request.url)\n\n            # If valid file, save the file\n            if runfile and allowed_file(runfile.filename):\n                save_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"runfile.py\")\n                runfile.save(save_path)\n\n                # Run the file\n                try:\n                    # Query ganga to run the file\n                    response_info = query_internal_api(\"/internal/runfile\", \"get\", params={\"path\": save_path})\n\n                except Exception as err:\n                    # Display error back to GUI\n                    flash(str(err), \"danger\")\n                    return redirect(request.url)\n\n                # Success message\n                flash(response_info.get(\"message\"), \"success\")\n                return redirect(request.url)\n\n        # No file case\n        flash(\"No file, retry!\", \"warning\")\n        return redirect(request.url)\n\n    try:\n        # Query templates info\n        templates_info = query_internal_api(\"/internal/templates\", \"get\",\n                                            params={\"recent\": True, \"length\": \"6\"})\n\n    except Exception as err:\n        # Display error to GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template(\"create.html\", title=\"Create\", templates_info=templates_info)\n\n\n# Runfile view\n@gui.route(\"/create/runfile\", methods=[\"GET\", \"POST\"])\n@login_required\ndef runfile_page():\n    \"\"\"\n    Quick create a runfile to be run using the runfile GPI function.\n    \"\"\"\n\n    # Runfile path\n    runfile_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"runfile.py\")\n\n    # Save runfile data from frontend\n    if request.method == \"POST\":\n        runfile_data = request.form.get(\"runfile-data\")\n        with open(runfile_path, \"w+\") as f:\n            f.write(runfile_data)\n\n        # Run the file\n        try:\n            # Query ganga to run the file\n            response_info = query_internal_api(\"/internal/runfile\", \"get\", params={\"path\": runfile_path})\n            flash(response_info[\"message\"], \"success\")\n\n        except Exception as err:\n            # Display error back in the GUI\n            flash(str(err), \"danger\")\n            return redirect(request.url)\n\n    return render_template(\"runfile.html\", title=\"Runfile\")\n\n\n# Templates view\n@gui.route(\"/templates\", methods=[\"GET\", \"POST\"])\n@login_required\ndef templates_page():\n    \"\"\"\n    Handles the templates route of the GUI. Displays templates in a tabular form.\n    \"\"\"\n\n    # Update filter values\n    if request.method == \"POST\":\n        # Add filter data to user session\n        session[\"templates_per_page\"] = int(request.form.get(\"templates-per-page\"))\n        session[\"templates_filter\"] = {key: request.form.get(form_name) for key, form_name in\n                                       zip([\"application\", \"backend\"], [\"template-application\", \"template-backend\"])}\n\n    # Current page\n    current_page = int(request.args.get(\"page\")) if request.args.get(\"page\") is not None else 0\n\n    # Get user defined value from session\n    templates_per_page = session[\"templates_per_page\"]\n\n    try:\n\n        # Query total number of templates\n        templates_length = query_internal_api(\"/internal/templates/length\", \"get\", params=session[\"templates_filter\"])\n\n        # Calculate number of max pages\n        number_of_pages = (int(templates_length) // int(templates_per_page)) + 1\n\n        # if current page exceeds last possible page, redirect to last page\n        if current_page >= number_of_pages:\n            return redirect(url_for(\"templates_page\", page=number_of_pages - 1))\n\n        # Add templates filters and range options for query params\n        params = session[\"templates_filter\"].copy()\n        params.update({\n            \"recent\": True,\n            \"length\": templates_per_page,\n            \"offset\": current_page\n        })\n\n        # Query templates information\n        templates_info = query_internal_api(\"/internal/templates\", \"get\", params=params)\n\n    except Exception as err:\n        # Flash error if any\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"create_page\"))\n\n    return render_template(\"templates.html\",\n                           title=\"Templates\",\n                           number_of_pages=number_of_pages,\n                           current_page=current_page,\n                           backends=plugins[\"backends\"],\n                           applications=plugins[\"applications\"],\n                           templates_info=templates_info)\n\n\n# Jobs view\n@gui.route(\"/jobs\", methods=[\"GET\", \"POST\"])\n@login_required\ndef jobs_page():\n    \"\"\"\n    Handles jobs route of the GUI. Displays jobs in a tabular view.\n    \"\"\"\n\n    # Update filter values\n    if request.method == \"POST\":\n        # Add form data to user session\n        session[\"jobs_per_page\"] = int(request.form.get(\"jobs-per-page\"))\n        session[\"jobs_filter\"] = {key: request.form.get(form_name) for key, form_name in\n                                  zip([\"status\", \"application\", \"backend\"],\n                                      [\"job-status\", \"job-application\", \"job-backend\"])}\n\n    # Current page\n    current_page = int(request.args.get(\"page\")) if request.args.get(\"page\") is not None else 0\n\n    # Get user defined value from user session\n    jobs_per_page = session[\"jobs_per_page\"]\n\n    try:\n\n        # Query total number of jobs\n        jobs_length = query_internal_api(\"/internal/jobs/length\", \"get\", params=session[\"jobs_filter\"])\n\n        # Calculate number of max pages\n        number_of_pages = (int(jobs_length) // int(jobs_per_page)) + 1\n\n        # if current page exceeds last possible page, redirect to last page\n        if current_page >= number_of_pages:\n            return redirect(url_for(\"jobs_page\", page=number_of_pages - 1))\n\n        # Add jobs filters and range options for query params\n        params = session[\"jobs_filter\"].copy()\n        params.update({\n            \"recent\": True,\n            \"length\": jobs_per_page,\n            \"offset\": current_page\n        })\n\n        # Query jobs information\n        jobs_info = query_internal_api(\"/internal/jobs\", \"get\", params=params)\n\n    except Exception as err:\n        # Display error back to GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template(\"jobs.html\",\n                           title=\"Jobs\",\n                           jobs_info=jobs_info,\n                           backends=plugins[\"backends\"],\n                           applications=plugins[\"applications\"],\n                           number_of_pages=number_of_pages,\n                           current_page=current_page,\n                           status_color=status_color)\n\n\n# Job view\n@gui.route('/jobs/<int:job_id>')\n@login_required\ndef job_page(job_id: int):\n    \"\"\"\n    Handles job route of the GUI. Displays all the information about the job.\n    :param job_id: int\n    \"\"\"\n\n    stdout = None\n    stderr = None\n\n    try:\n\n        # Query job information\n        job_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"get\")\n\n        # Query full print of the job\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/full-print\", \"get\")\n\n        # stdout and stderr path\n        stdout_path = os.path.join(job_info[\"outputdir\"], \"stdout\")\n        stderr_path = os.path.join(job_info[\"outputdir\"], \"stderr\")\n\n        # Get stdout\n        if os.path.exists(stdout_path):\n            with open(stdout_path) as f:\n                stdout = f.read()\n\n        # Get stderr\n        if os.path.exists(stderr_path):\n            with open(stderr_path) as f:\n                stderr = f.read()\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"jobs_page\"))\n\n    return render_template(\"job.html\",\n                           title=f\"Job {job_id}\",\n                           job_info=job_info,\n                           status_color=status_color,\n                           attribute_actions=actions.get(\"attributes\"),\n                           method_actions=actions.get(\"methods\"),\n                           stdout=stdout,\n                           stderr=stderr,\n                           full_print_info=full_print_info)\n\n\n# Export job\n@gui.route(\"/jobs/<int:job_id>/export\")\n@login_required\ndef job_export(job_id: int):\n    \"\"\"\n    Sends the job file which is generated using export function of GPI.\n    :param job_id: int\n    \"\"\"\n\n    # Path to save file using export GPI function\n    export_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], f\"export.txt\")\n\n    try:\n\n        # Query to export the job at export path\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/export\", \"get\", params={\"path\": export_path})\n\n        # Send file\n        return send_file(export_path, as_attachment=True, cache_timeout=0, attachment_filename=f\"Job_{job_id}.txt\")\n\n    except Exception as err:\n        # Display error back to GUI\n        flash(str(err), \"danger\")\n\n    return redirect(url_for(\"job_page\", job_id=job_id))\n\n\n# Edit job\n@gui.route(\"/jobs/<int:job_id>/edit\", methods=[\"GET\", \"POST\"])\n@login_required\ndef job_edit(job_id: int):\n    \"\"\"\n    Show the exported job text on the GUI for it to be edited and submit. Will create a new job after submission.\n    :param job_id: int\n    \"\"\"\n\n    # Save paths\n    loadfile_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"loadfile.txt\")\n    export_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"export.txt\")\n\n    # Create a new job with the submitted information\n    if request.method == \"POST\":\n\n        # Save the edited job info\n        edited_job_info = request.form.get(\"edited-job-info\")\n        with open(loadfile_path, \"w+\") as f:\n            f.write(edited_job_info)\n\n        # Load the file\n        try:\n            # Query to load the job\n            response_info = query_internal_api(\"/internal/load\", \"get\", params={\"path\": loadfile_path})\n            flash(response_info[\"message\"], \"success\")\n\n        except Exception as err:\n            # Display error on the GUI\n            flash(str(err), \"danger\")\n            return redirect(request.url)\n\n    try:\n        # Query to export the job text\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/export\", \"get\", params={\"path\": export_path})\n\n        # Read exported job file to display\n        with open(export_path) as f:\n            exported_data = f.read()\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    return render_template(\"edit_job.html\", title=f\"Edit Job {job_id}\", job_id=job_id, exported_data=exported_data)\n\n\n# Browse job directory\n@gui.route(\"/job/<int:job_id>/browse\", defaults={\"path\": \"\"})\n@gui.route(\"/job/<int:job_id>/browse/<path:path>\")\n@login_required\ndef job_browse(job_id: int, path):\n    \"\"\"\n    Browse directory of the job.\n    :param job_id: int\n    :param path: str\n    \"\"\"\n\n    try:\n        # Query job information\n        job_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"get\")\n\n        # Base directory of the job\n        job_base_dir = os.path.dirname(os.path.dirname(job_info[\"outputdir\"]))\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    # Join the base and the requested path\n    abs_path = os.path.join(job_base_dir, path)\n\n    # URL path variable for going back\n    back_path = os.path.dirname(abs_path).replace(job_base_dir, \"\")\n\n    # If path doesn't exist\n    if not os.path.exists(abs_path):\n        flash(\"Directory for this job does not exist.\", \"warning\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    # Check if path is a file and send\n    if os.path.isfile(abs_path):\n        return send_file(abs_path)\n\n    files_info = []\n\n    # Show directory contents\n    files = os.listdir(abs_path)\n\n    # Store directory information\n    for file in files:\n        files_info.append({\n            \"file\": file,\n            \"directory\": os.path.isdir(os.path.join(abs_path, file))\n        })\n\n    return render_template('job_dir.html', title=f\"Job {job_id} Directory\",\n                           job_id=job_id,\n                           abs_path=abs_path,\n                           files_info=files_info,\n                           back_path=back_path)\n\n\n# Subjobs view\n@gui.route(\"/jobs/<int:job_id>/subjobs\", methods=[\"GET\", \"POST\"])\n@login_required\ndef subjobs_page(job_id: int):\n    \"\"\"\n    Handles subjobs view of the GUI. Displays subjobs of a job in a tabular form.\n    :param job_id: int\n    \"\"\"\n\n    # Change filter values\n    if request.method == \"POST\":\n        # Add form data to client session\n        session[\"subjobs_per_page\"] = int(request.form.get(\"subjobs-per-page\"))\n        session[\"subjobs_filter\"] = {key: request.form.get(form_name) for key, form_name in\n                                     zip([\"status\", \"application\", \"backend\"],\n                                         [\"subjob-status\", \"subjob-application\", \"subjob-backend\"])}\n\n    # Current page\n    current_page = int(request.args.get(\"page\")) if request.args.get(\"page\") is not None else 0\n\n    # Get user defined value from session\n    subjobs_per_page = session[\"subjobs_per_page\"]\n\n    try:\n        # Query total number of subjobs\n        subjobs_length = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/length\", \"get\",\n                                            params=session[\"subjobs_filter\"])\n\n        # Calculate number of max pages\n        number_of_pages = (int(subjobs_length) // int(subjobs_per_page)) + 1\n\n        # if current page exceeds last possible page, redirect to last page\n        if current_page >= number_of_pages:\n            return redirect(url_for(\"subjobs_page\", page=number_of_pages - 1, job_id=job_id))\n\n        # Add subjobs filters and range options for query params\n        params = session[\"subjobs_filter\"].copy()\n        params.update({\n            \"recent\": True,\n            \"length\": subjobs_per_page,\n            \"offset\": current_page\n        })\n\n        # Query subjobs information\n        subjobs_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs\", \"get\", params=params)\n\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    return render_template(\"subjobs.html\",\n                           title=f\"Subjobs - Job {job_id}\",\n                           status_color=status_color,\n                           number_of_pages=number_of_pages,\n                           current_page=current_page,\n                           backends=plugins[\"backends\"],\n                           applications=plugins[\"applications\"],\n                           subjobs_info=subjobs_info,\n                           job_id=job_id)\n\n\n# Subjob view\n@gui.route(\"/jobs/<int:job_id>/subjobs/<int:subjob_id>\", methods=[\"GET\"])\n@login_required\ndef subjob_page(job_id: int, subjob_id: int):\n    \"\"\"\n    Handles subjob route of the GUI. Displays extensive details of a subjob.\n    :param job_id: int\n    :param subjob_id: int\n    \"\"\"\n\n    stdout = None\n    stderr = None\n\n    try:\n\n        # Query job information\n        job_outputdir = query_internal_api(f\"/internal/jobs/{job_id}/outputdir\", \"get\")\n\n        # Query subjob information\n        subjob_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}\", \"get\")\n\n        # Query full print of the job\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/full-print\", \"get\")\n\n        # Extract browse path that can be used by job_browse route\n        job_dir_basepath = os.path.dirname(os.path.dirname(job_outputdir[\"outputdir\"]))\n        subjob_dir_basepath = os.path.dirname(os.path.dirname(subjob_info[\"outputdir\"]))\n        browse_path = subjob_dir_basepath.replace(job_dir_basepath, \"\")\n\n        # stdout and stderr path\n        stdout_path = os.path.join(subjob_info[\"outputdir\"], \"stdout\")\n        stderr_path = os.path.join(subjob_info[\"outputdir\"], \"stderr\")\n\n        # Get stdout\n        if os.path.exists(stdout_path):\n            with open(stdout_path) as f:\n                stdout = f.read()\n\n        # Get stderr\n        if os.path.exists(stderr_path):\n            with open(stderr_path) as f:\n                stderr = f.read()\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"subjobs_page\", job_id=job_id))\n\n    return render_template(\"subjob.html\",\n                           title=f\"Subjob {subjob_id} - Job {job_id}\",\n                           subjob_info=subjob_info,\n                           status_color=status_color,\n                           attribute_actions=actions[\"attributes\"],\n                           method_actions=actions[\"methods\"],\n                           stdout=stdout,\n                           stderr=stderr,\n                           full_print_info=full_print_info,\n                           job_id=job_id,\n                           browse_path=browse_path)\n\n\n# Credential view\n@gui.route(\"/credentials\")\n@login_required\ndef credentials_page():\n    \"\"\"\n    Handles credential store view of the GUI. Displays credentials in a tabular form.\n    \"\"\"\n\n    try:\n        # Query credential store information\n        credentials_info = query_internal_api(\"/internal/credentials\", \"get\")\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template('credentials.html', credential_info_list=credentials_info)\n\n@gui.route(\"/queue\", methods=[\"GET\"])\n@login_required\ndef queue_page():\n    \"\"\"\n    Displays queues information\n    \"\"\"\n    try:\n        queue_info = query_internal_api(\"/internal/queue\", \"get\")\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template('queue.html', queue_info_list=queue_info)\n\n# Plugins view\n@gui.route('/plugins')\n@login_required\ndef plugins_page():\n    \"\"\"\n    Handles plugins route of the GUI. Displays the list of plugins.\n    \"\"\"\n\n    try:\n        # Store plugins information\n        plugins_info = plugins\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template('plugins.html', plugins_info=plugins_info)\n\n\n# Plugin view\n@gui.route(\"/plugin/<plugin_name>\")\n@login_required\ndef plugin_page(plugin_name: str):\n    \"\"\"\n    Displays information about the plugin like it's docstring.\n    :param plugin_name: str\n    \"\"\"\n\n    try:\n        # Query plugin information\n        plugin_info = query_internal_api(f\"/internal/plugins/{plugin_name}\", \"get\")\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"plugins_page\"))\n\n    return render_template(\"plugin.html\", title=f\"{plugin_name}\", plugin_info=plugin_info)\n\n\n# Ganga logs view\n@gui.route(\"/logs\")\n@login_required\ndef logs_page():\n    \"\"\"\n    Diplay ganga log file.\n    :return:\n    \"\"\"\n\n    ganga_log_path = gui.config[\"GANGA_LOG\"]\n    gui_accesslog_path = gui.config[\"ACCESS_LOG\"]\n    gui_errorlog_path = gui.config[\"ERROR_LOG\"]\n\n    try:\n        # Get ganga log\n        with open(ganga_log_path, \"rt\") as f:\n            ganga_log_data = f.read()\n\n        # Get GUI access log\n        with open(gui_accesslog_path, \"rt\") as f:\n            gui_accesslog_data = f.read()\n\n        # Get GUI error log\n        with open(gui_errorlog_path, \"rt\") as f:\n            gui_errorlog_data = f.read()\n\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template(\"logs.html\", title=\"Logs\", ganga_log_data=ganga_log_data,\n                           gui_accesslog_data=gui_accesslog_data, gui_errorlog_data=gui_errorlog_data)\n\n\n@gui.route(\"/storage\", defaults={\"path\": \"\"}, methods=[\"GET\", \"POST\"])\n@gui.route(\"/storage/<path:path>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef storage_page(path):\n    \"\"\"\n    A convenience feature to store some file remotely in gangadir/storage\n    \"\"\"\n\n    # Storage folder path\n    storage_folder = gui.config[\"STORAGE_FOLDER\"]\n\n    # Join the storage path and the requested path\n    abs_path = os.path.join(storage_folder, path)\n\n    # Handle file uploads\n    if request.method == \"POST\":\n\n        # Uploaded file\n        if \"storagefile\" in request.files:\n            storagefile = request.files[\"storagefile\"]\n            if storagefile.filename == \"\":\n                flash(\"No file selected\", \"warning\")\n                return redirect(request.url)\n\n            # If valid file, the save the file\n            if storagefile:\n                # Directory check\n                if not os.path.isdir(abs_path):\n                    flash(\"Error while uploading the file\", \"danger\")\n                    return redirect(request.url)\n\n                filename = secure_filename(storagefile.filename)\n                save_path = os.path.join(abs_path, filename)\n                storagefile.save(save_path)\n\n                # Success message\n                flash(\"Successfully uploaded the file.\", \"success\")\n                return redirect(request.url)\n\n        # No file case\n        flash(\"No file, retry!\", \"warning\")\n        return redirect(request.url)\n\n    # URL path variable for going back\n    back_path = os.path.dirname(abs_path).replace(storage_folder, \"\")\n\n    # If path doesn't exist\n    if not os.path.exists(abs_path):\n        flash(\"Directory does not exist.\", \"warning\")\n        return redirect(url_for(\"dashboard\"))\n\n    # Check if path is a file and send\n    if os.path.isfile(abs_path):\n        return send_file(abs_path)\n\n    files_info = []\n\n    # Show directory contents\n    files = os.listdir(abs_path)\n\n    # Store directory information\n    for file in files:\n        files_info.append({\n            \"file\": file,\n            \"directory\": os.path.isdir(os.path.join(abs_path, file))\n        })\n\n    return render_template(\"storage.html\", title=\"Storage\",\n                           abs_path=abs_path,\n                           files_info=files_info,\n                           back_path=back_path)\n\n\n# Serve CLI\n@gui.route(\"/cli\")\n@login_required\ndef serve_cli():\n    return render_template(\"cli.html\")\n\n\n# Establish a websocket connection from the frontend to the server\n@socketio.on(\"connect\", namespace=\"/pty\")\ndef connect():\n    \"\"\"\n    New client connected, start reading and writing from the pseudo terminal.\n    \"\"\"\n\n    if gui.config[\"CHILD_PID\"] and current_user.is_authenticated:\n        # Start background reading and emitting the output of the pseudo terminal\n        socketio.start_background_task(target=read_and_forward_pty_output)\n        return\n\n\n# Input from the frontend\n@socketio.on(\"pty-input\", namespace=\"/pty\")\ndef pty_input(data):\n    \"\"\"\n    Write to the child pty. The pty sees this as if you are typing in a real terminal.\n    \"\"\"\n\n    if gui.config[\"FD\"] and current_user.is_authenticated:\n        os.write(gui.config[\"FD\"], data[\"input\"].encode())\n\n\n# Resize the pseudo terminal when the frontend is resized\n@socketio.on(\"resize\", namespace=\"/pty\")\ndef resize(data):\n    \"\"\"\n    Resize the pseudo terminal according to the dimension at the frontend.\n    :param data: contains information about rows and cols of the frontend terminal.\n    \"\"\"\n\n    if gui.config[\"FD\"] and current_user.is_authenticated:\n        set_windowsize(gui.config[\"FD\"], data[\"rows\"], data[\"cols\"])\n\n\n# ******************** Token Based Authentication ******************** #\n\n# Generate token for API authentication - token validity 5 days\n@gui.route(\"/token\", methods=[\"POST\"])\ndef generate_token():\n    \"\"\"\n    Using the 'user' and 'password' data from the form body, validates the user and returns a JSON Web Token (JWT).\n    \"\"\"\n\n    # Request form data\n    request_json = request.json if request.json else {}\n    request_user = request_json.get(\"username\")\n    request_password = request_json.get(\"password\")\n\n    # Handle no user or no password case\n    if not request_user or not request_password:\n        response_data = {\"success\": False, \"message\": \"Could not verify user.\"}\n        return jsonify(response_data), 401\n\n    # Verify user and accordingly return the token\n    user = User.query.filter_by(user=request_user).first()\n    if user and user.verify_password(request_password):\n        token = user.generate_auth_token().decode(\"UTF-8\")\n        response_data = {\"token\": token}\n        return jsonify(response_data)\n\n    # If authentication fails, return 401 HTTP code\n    response_data = {\"success\": False, \"message\": \"Could not verify user.\"}\n    return jsonify(response_data), 401\n\n\n# ******************** Token Authentication Decorator ******************** #\n\n# Decorator for token protected routes\ndef token_required(f):\n    \"\"\"\n    Decorator which validates the request header token in 'X-Acess-Token' field, and returns the user.\n    \"\"\"\n\n    @wraps(f)\n    def decorated(*args, **kwargs):\n\n        token = None\n\n        # Extract token from headers\n        if \"X-Access-Token\" in request.headers:\n            token = request.headers[\"X-Access-Token\"]\n\n        if not token:\n            return jsonify({\"success\": False, \"message\": \"Token is missing\"}), 401\n\n        # Decode the token and subsequently identify the user\n        try:\n            data = jwt.decode(token, gui.config[\"SECRET_KEY\"], algorithms=[\"HS256\"])\n            current_api_user = User.query.filter_by(public_id=data[\"public_id\"]).first()\n            if current_api_user is None:\n                return jsonify({\"success\": False, \"message\": \"Token is old. Please renew\"}), 401\n        except jwt.ExpiredSignatureError:\n            return jsonify({\"success\": False, \"message\": \"Token is expired\"}), 401\n        except jwt.InvalidTokenError:\n            return jsonify({\"success\": False, \"message\": \"Token is invalid\"}), 401\n        except:\n            return jsonify({\"success\": False, \"message\": \"Could not verify token\"}), 401\n\n        return f(current_api_user, *args, **kwargs)\n\n    return decorated\n\n\n# ******************** Job API ******************** #\n\n\n# Single job information API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>\", methods=[\"GET\"])\n@token_required\ndef job_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Given the job_id, returns the general information related to the job in JSON format.\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query job information to the GPI\n        job_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(job_info)\n\n\n# Single job attribute information API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/<attribute>\", methods=[\"GET\"])\n@token_required\ndef job_attribute_endpoint(current_api_user, job_id: int, attribute: str):\n    \"\"\"\n    Given the job_id and attribute, returns the attribute information in the JSON format.\n\n    :param job_id: int\n    :param attribute: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query job attribute information from ganga\n        job_attribute_info = query_internal_api(f\"/internal/jobs/{job_id}/{attribute}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(job_attribute_info)\n\n\n# Single job full print API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/full-print\", methods=[\"GET\"])\n@token_required\ndef job_full_print_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Return full print of the job.\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query job full print from ganga\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/full-print\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(full_print_info)\n\n\n# Create job using template API - POST Method\n@gui.route(\"/api/jobs/create\", methods=[\"POST\"])\n@token_required\ndef job_create_endpoint(current_api_user):\n    \"\"\"\n    Create a new job using the existing template.\n\n    IMPORTANT: template_id NEEDS to be provided in the request body. job_name can optionally be provided in the request body.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Request data\n    data = {\n        \"template_id\": request.json.get(\"template_id\"),\n        \"job_name\": request.json.get(\"job_name\")\n    }\n\n    try:\n        # Query ganga to create a job using the template id\n        response_info = query_internal_api(\"/internal/jobs/create\", \"post\", json=data)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Copy job API - PUT Method\n@gui.route(\"/api/jobs/<int:job_id>/copy\", methods=[\"PUT\"])\n@token_required\ndef job_copy_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Create a copy of the job.\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    :param job_id: int\n    \"\"\"\n\n    try:\n        # Query ganga to copy the job\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/copy\", \"put\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Job action API - PUT Method\n@gui.route(\"/api/jobs/<int:job_id>/<action>\", methods=[\"PUT\"])\n@token_required\ndef job_action_endpoint(current_api_user, job_id: int, action: str):\n    \"\"\"\n    Given the job_id and action in the endpoint, perform the action on the job.\n\n    The action can be any method or attribute change that can be called on the Job object.\n\n    Example:\n    1)\n        PUT http://localhost:5000/job/13/resubmit\n\n        The above request will resubmit the job with ID 13.\n\n    2)\n        PUT http://localhost:5000/job/13/force_status\n        {\"force_status\":\"failed\"}\n\n        The above request will force status of the job with ID 13 to killed. If unsuccessful will return back the error.\n\n    3)\n        PUT http://localhost:5000/job/13/name\n        {\"name\"=\"New Name\"}\n\n        The above request will change the name of the job with ID 13 to \"New Name\". Notice how the required values\n        are passed in the request body with the same name as action.\n\n    NOTE: It is NECESSARY to send body in JSON format for the request to be parsed in JSON.\n\n    :param job_id: int\n    :param action: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Request data\n    request_data = request.json\n\n    try:\n        # Query ganga to perform the action\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/{action}\", \"put\", json=request_data)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Job delete API - DELETE Method\n@gui.route(\"/api/jobs/<int:job_id>\", methods=[\"DELETE\"])\n@token_required\ndef job_delete_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Given the job id, removes the job from the job repository.\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to delete the job\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"delete\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Pin the Job\n@gui.route(\"/api/jobs/<int:job_id>/pin\", methods=[\"PUT\"])\n@token_required\ndef job_pin_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Pin the given job, which is then shown in the dashboard.\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Get current user\n    u = current_user\n\n    # Load pinned jobs of the user from the database\n    pinned_jobs = json.loads(u.pinned_jobs) if u.pinned_jobs is not None else []\n\n    # Pin job\n    if job_id not in pinned_jobs:\n        pinned_jobs.append(job_id)\n\n    # Add new pinned jobs to the database\n    u.pinned_jobs = json.dumps(pinned_jobs)\n    db.session.add(u)\n    db.session.commit()\n\n    return jsonify({\"success\": True, \"message\": f\"Successfully pinned Job (ID={job_id}).\"})\n\n\n# Unpin the job\n@gui.route(\"/api/jobs/<int:job_id>/unpin\", methods=[\"PUT\"])\n@token_required\ndef job_unpin_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Unpin the job, and make the required change to the GUI database.\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Get the user from the database\n    u = current_user\n\n    # Load user's pinned job from the database\n    pinned_jobs = json.loads(u.pinned_jobs) if u.pinned_jobs is not None else []\n\n    # Unpin the job\n    if job_id in pinned_jobs:\n        pinned_jobs.remove(job_id)\n\n    # Commit changes to the database\n    u.pinned_jobs = json.dumps(pinned_jobs)\n    db.session.add(u)\n    db.session.commit()\n\n    return jsonify({\"success\": True, \"message\": f\"Successfully unpinned Job (ID={job_id}).\"})\n\n\n# ******************** Subjobs API ******************** #\n\n# Subjobs API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs\", methods=[\"GET\"])\n@token_required\ndef subjobs_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Returns a list subjobs of a particular job in a similar way as Jobs API.\n\n    The parameter accepted are:\n    * ids: provide a JSON string of list of IDs\n    * status: provide subjob status as a string for filter\n    * application: provide subjob application as a string for filter\n    * backend: provide backend application as a string for filter\n    * recent: if provided, starts a list from recent subjobs to old\n    * length: number of subjobs to be returned, provide as a int\n    * offset: how many subjobs to skip before returning the specified length of subjobs. Provide as int.\n        offset works as: number of subjobs skipped = offset * length\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    params = {\n        \"ids\": request.args.get(\"ids\"),\n        \"status\": request.args.get(\"status\"),\n        \"application\": request.args.get(\"application\"),\n        \"backend\": request.args.get(\"backend\"),\n        \"recent\": request.args.get(\"recent\"),\n        \"length\": request.args.get(\"length\"),\n        \"offset\": request.args.get(\"offset\")\n    }\n\n    try:\n        # Query ganga for subjobs information\n        subjobs_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs\", \"get\", params=params)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(subjobs_info)\n\n\n# Single subjob info API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>\", methods=[\"GET\"])\n@token_required\ndef subjob_endpoint(current_api_user, job_id: int, subjob_id: int):\n    \"\"\"\n    Returns information of a single subjob related to a particular job\n\n    :param job_id: int\n    :param subjob_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query subjob information to ganga\n        subjob_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(subjob_info)\n\n\n# Single Subjob Attribute Info API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>/<attribute>\", methods=[\"GET\"])\n@token_required\ndef subjob_attribute_endpoint(current_api_user, job_id: int, subjob_id: int, attribute: str):\n    \"\"\"\n    Given the job id, subjob id and attribute; return the attribute information in the string format via JSON.\n\n    :param job_id: int\n    :param subjob_id: int\n    :param attribute: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query attribute information from ganga\n        subjob_attribute_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/{attribute}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(subjob_attribute_info)\n\n\n# Single subjob full print API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>/full-print\", methods=[\"GET\"])\n@token_required\ndef subjob_full_print_endpoint(current_api_user, job_id: int, subjob_id: int):\n    \"\"\"\n    Return full print of the subjob.\n\n    :param subjob_id: int\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query subjob full print from ganga\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/full-print\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(full_print_info)\n\n\n# Copy subjob API - PUT Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>/copy\", methods=[\"PUT\"])\n@token_required\ndef subjob_copy_endpoint(current_api_user, job_id: int, subjob_id: int):\n    \"\"\"\n    Create a copy of the subjob into a new job.\n    :param job_id:\n    :param subjob_id:\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to copy subjob\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/copy\", \"put\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# ******************** Jobs API ******************** #\n\n# Jobs API - GET Method\n@gui.route(\"/api/jobs\", methods=[\"GET\"])\n@token_required\ndef jobs_endpoint(current_api_user):\n    \"\"\"\n    Returns a list of jobs with general information in JSON format.\n\n    The parameter accepted are:\n    * ids: provide a JSON string of list of IDs\n    * status: provide job status as a string for filter\n    * application: provide job application as a string for filter\n    * backend: provide backend application as a string for filter\n    * recent: if provided, starts a list from recent job to old\n    * length: number of job to be returned, provide as a int\n    * offset: how many job to skip before returning the specified length of job. Provide as int.\n        offset works like: number of job skipped = offset * length\n    * auto-validate-ids: If ids provided in ids parameters does not exist in job repository, then skip those ids.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    params = {\n        \"ids\": request.args.get(\"ids\"),\n        \"status\": request.args.get(\"status\"),\n        \"application\": request.args.get(\"application\"),\n        \"backend\": request.args.get(\"backend\"),\n        \"recent\": request.args.get(\"recent\"),\n        \"length\": request.args.get(\"length\"),\n        \"offset\": request.args.get(\"offset\"),\n        \"auto-validate-ids\": request.args.get(\"auto-validate-ids\")\n    }\n\n    try:\n        # Get jobs information according to select filter and range filter\n        jobs_info = query_internal_api(f\"/internal/jobs\", \"get\", params=params)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(jobs_info)\n\n\n# Jobs statistics API - GET Method\n@gui.route(\"/api/jobs/statistics\", methods=[\"GET\"])\n@token_required\ndef jobs_statistics_endpoint(current_api_user):\n    \"\"\"\n    Returns the number of jobs in new, running, completed, killed, failed status.\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get statistics information\n        statistics = query_internal_api(\"/internal/jobs/statistics\", \"get\")\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(statistics)\n\n@gui.route(\"/api/queue\", methods=[\"GET\"])\n@token_required\ndef queue_endpoint(current_api_user):\n\n    try:\n        queue_info = query_internal_api(\"/internal/queue\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(queue_info)\n\n@gui.route(\"/api/queue/chart\", methods=[\"GET\",\"POST\"])\ndef queue_chart_endpoint():\n\n    \n    chart_info = query_internal_api(\"/internal/queue/data\", \"get\")\n    response = make_response(json.dumps(chart_info))\n    response.content_type = 'application/json'\n    return response\n\n# Job incomplete ids API - GET Method\n@gui.route(\"/api/jobs/incomplete_ids\", methods=[\"GET\"])\n@token_required\ndef jobs_incomplete_ids_endpoint(current_api_user):\n    \"\"\"\n    Returns a list of incomplete job ids in JSON format.\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get incomplete ids list\n        incomplete_ids_list = query_internal_api(\"/internal/jobs/incomplete-ids\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(incomplete_ids_list)\n\n\n# ******************** Config API ******************** #\n\n# Config API - GET Method\n@gui.route(\"/api/config\", methods=[\"GET\"], defaults={\"section\": \"\"})\n@gui.route(\"/api/config/<section>\", methods=[\"GET\"])\n@token_required\ndef config_endpoint(current_api_user, section: str):\n    \"\"\"\n    Returns a list of all the section of the configuration and their options as well as the values in JSON format.\n\n    If section is provide, returns information about the section in JSON format.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get config information\n        if section != \"\":\n            config_info = query_internal_api(f\"/internal/config/{section}\", \"get\")\n        else:\n            config_info = query_internal_api(\"/internal/config\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(config_info)\n\n\n# ******************** Templates API ******************** #\n\n# Templates API - GET Method\n@gui.route(\"/api/templates\", methods=[\"GET\"])\n@token_required\ndef templates_endpoint(current_api_user):\n    \"\"\"\n    Returns a list of objects containing template info in JSON format.\n\n    * ids: provide a JSON string of list of IDs\n    * status: provide template status as a string for filter\n    * application: provide template application as a string for filter\n    * backend: provide backend application as a string for filter\n    * recent: if provided, starts a list from recent template to old\n    * length: number of template to be returned, provide as a int\n    * offset: how many template to skip before returning the specified length of template. Provide as int.\n        offset works like: number of template skipped = offset * length\n\n    :param current_api_user: Information of the current_user based on the request's JWT token\n    \"\"\"\n\n    params = {\n        \"application\": request.args.get(\"application\"),\n        \"backend\": request.args.get(\"backend\"),\n        \"recent\": request.args.get(\"recent\"),\n        \"length\": request.args.get(\"length\"),\n        \"offset\": request.args.get(\"offset\"),\n    }\n\n    try:\n        # Query ganga for templates information\n        templates_info = query_internal_api(\"/internal/templates\", \"get\", params=params)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(templates_info)\n\n\n# Single template full print API - GET Method\n@gui.route(\"/api/templates/<int:template_id>/full-print\", methods=[\"GET\"])\n@token_required\ndef template_full_print_endpoint(current_api_user, template_id: int):\n    \"\"\"\n    Return full print of the template.\n\n    :param template_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query template full print from ganga\n        full_print_info = query_internal_api(f\"/internal/templates/{template_id}/full-print\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(full_print_info)\n\n\n# Template API - DELETE Method\n@gui.route(\"/api/templates/<int:template_id>\", methods=[\"DELETE\"])\n@token_required\ndef delete_template_endpoint(current_api_user, template_id: int):\n    \"\"\"\n\n    Given the templates id, delete it from the template repository.\n\n    :param template_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to remove the template\n        response_info = query_internal_api(f\"/internal/templates/{template_id}\", \"delete\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# ******************** Credentials API ******************** #\n\n# Credential store API - GET Method\n@gui.route(\"/api/credentials\", methods=[\"GET\"])\n@token_required\ndef credentials_endpoint(current_api_user):\n    \"\"\"\n    Return a list of credentials and their information in JSON format.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga for credentials information\n        credentials_info = query_internal_api(\"/internal/credentials\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(credentials_info)\n\n\n# Credential Store API - PUT Method - Renew all credentials\n@gui.route(\"/api/credentials/renew\", methods=[\"PUT\"])\n@token_required\ndef credentials_renew_endpoint(current_api_user):\n    \"\"\"\n    Renew all the credentials in the credential store.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to renew credentials\n        response_info = query_internal_api(\"/internal/credentials/renew\", \"put\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# ******************** Job Tree API ******************** #\n\n# Job tree API - GET Method\n@gui.route(\"/api/jobtree\", methods=[\"GET\"])\n@token_required\ndef jobtree_endpoint(current_api_user):\n    \"\"\"\n    Return the job tree folder structure as the json format of python dict.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get job tree information\n        jobtree_info = query_internal_api(\"/internal/jobtree\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(jobtree_info)\n\n\n# ******************** Job Tree API ******************** #\n\n# Plugins API - GET Method\n@gui.route(\"/api/plugins\", methods=[\"GET\"])\n@token_required\ndef plugins_endpoint(current_api_user):\n    \"\"\"\n    Return plugins information, category and names of the plugins in the category.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get plugins information\n        plugins_info = query_internal_api(\"/internal/plugins\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(plugins_info)\n\n\n# Plugin API - GET Method\n@gui.route(\"/api/plugins/<plugin_name>\", methods=[\"GET\"])\n@token_required\ndef plugin_endpoint(current_api_user, plugin_name: str):\n    \"\"\"\n    Return single plugin information like name and docstring.\n\n    :param plugin_name: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get plugin information\n        plugin_info = query_internal_api(f\"/internal/plugins/{plugin_name}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(plugin_info)\n\n\n# ******************** Helper Functions ******************** #\n\n# Validate uploaded filename.\ndef allowed_file(filename):\n    return \".\" in filename and filename.rsplit(\".\", 1)[1].lower() in ALLOWED_EXTENSIONS\n\n\n# Make HTTP request to the Internal Flask Server which is running on a GangaThread which has access to ganga namespace.\ndef query_internal_api(route: str, method: str, **kwargs):\n    \"\"\"\n    :param route: str\n    :param method: str\n    :param kwargs: dict\n    :return: dict\n\n    Make a HTTP request to the Internal API Flask server which runs on a GangaThread to query data from Ganga.\n    Check response status code and extract the data or raise an exception accordingly.\n\n    kwargs can be param, json, etc. Any attribute that is supported by the requests module.\n    \"\"\"\n\n    # Internal url for communicating with API server running on a GangaThread\n    INTERNAL_URL = f\"http://localhost:{gui.config['INTERNAL_PORT']}\"\n\n    # Raise error if HTTP method not supported\n    if method not in [\"get\", \"post\", \"put\", \"delete\"]:\n        raise Exception(f\"Unsupported method: {method}\")\n\n    # Made the HTTP requests, along with whatever arguments provided\n    res = getattr(requests, method)(INTERNAL_URL + route, **kwargs)\n\n    # Check is request is OK\n    if res.status_code != 200:\n        raise Exception(res.json().get(\"message\"))\n\n    # Return request data\n    return res.json()\n\n\ndef create_session_defaults():\n    \"\"\"\n    Create user session defaults and assign default values to them.\n    \"\"\"\n\n    # Set session defaults for templates filter\n    if \"templates_per_page\" not in session:\n        session[\"templates_per_page\"] = 10\n    if \"templates_filter\" not in session:\n        session[\"templates_filter\"] = {key: \"any\" for key in [\"application\", \"backend\"]}\n\n    # Set session defaults for jobs filter\n    if \"jobs_per_page\" not in session:\n        session[\"jobs_per_page\"] = 10\n    if \"jobs_filter\" not in session:\n        session[\"jobs_filter\"] = {key: \"any\" for key in [\"status\", \"application\", \"backend\"]}\n\n    # Set session defaults for subjobs filter\n    if \"subjobs_per_page\" not in session:\n        session[\"subjobs_per_page\"] = 10\n    if \"subjobs_filter\" not in session:\n        session[\"subjobs_filter\"] = {key: \"any\" for key in [\"status\", \"application\", \"backend\"]}\n\n\n# Ping internal API server\ndef ping_internal():\n    \"\"\"\n    Ping internal API server if it is running\n    \"\"\"\n\n    trials = 0\n    while True:\n        try:\n            ping = query_internal_api(\"/ping\", \"get\")\n            if ping is True:\n                return True\n        except:\n            time.sleep(2)\n\n        print(\"Internal API server not online (mostly because Ganga is booting up), retrying...\")\n        trials += 1\n        if trials > 20:\n            return False\n\n\ndef start_ganga(internal_port: int, args: str = \"\"):\n    \"\"\"\n    Start a ganga session in a pseudo terminal and stores the file descriptor of the terminal as well as the PID of the ganga session.\n    :param args: str - str of arguments to provide to ganga\n    :param internal_port: int\n    \"\"\"\n\n    # Create child process attached to a pty that we can read from and write to\n    (child_pid, fd) = pty.fork()\n\n    if child_pid == 0:\n        # This is the child process fork. Anything printed here will show up in the pty, including the output of this subprocess\n        ganga_env = os.environ.copy()\n        ganga_env[\"WEB_CLI\"] = \"True\"\n        ganga_env[\"INTERNAL_PORT\"] = str(internal_port)\n        subprocess.run(f\"ganga --webgui {args}\", shell=True, env=ganga_env)\n    else:\n        # This is the parent process fork. Store fd (connected to the child\u2019s controlling terminal) and child pid\n        gui.config[\"FD\"] = fd\n        gui.config[\"CHILD_PID\"] = child_pid\n        set_windowsize(fd, 50, 50)\n        print(\"Ganga started, PID: \", child_pid)\n\n\n# Set the window size of the pseudo terminal according to the size in the frontend\ndef set_windowsize(fd, row, col, xpix=0, ypix=0):\n    winsize = struct.pack(\"HHHH\", row, col, xpix, ypix)\n    fcntl.ioctl(fd, termios.TIOCSWINSZ, winsize)\n\n\n# Read and forward that data from the pseudo terminal to the frontend\ndef read_and_forward_pty_output():\n    max_read_bytes = 1024 * 20\n    while True:\n        socketio.sleep(0.01)\n        if gui.config[\"FD\"]:\n            timeout_sec = 0\n            (data_ready, _, _) = select.select([gui.config[\"FD\"]], [], [], timeout_sec)\n            if data_ready:\n                output = os.read(gui.config[\"FD\"], max_read_bytes).decode()\n                socketio.emit(\"pty-output\", {\"output\": output}, namespace=\"/pty\")\n\n\ndef start_web_cli(host: str, port: int, internal_port: int, log_output=True, ganga_args: str = \"\"):\n    \"\"\"\n    Start the web server on eventlet serving the terminal on the specified port. (Production ready server)\n    :param ganga_args: str - arguments to be passed to ganga\n    :param host: str\n    :param port: int\n    :param internal_port: int\n    \"\"\"\n\n    from GangaGUI.start import create_default_user\n\n    # Create default user\n    gui_user, gui_password = create_default_user()\n\n    print(f\"Starting the GUI server on http://{host}:{port}\")\n    print(f\"You login information for the GUI is: Username: {gui_user.user} Password: {gui_password}\")\n\n    gui.config[\"INTERNAL_PORT\"] = internal_port\n    gui.config[\"WEB_CLI\"] = True\n    gui.config[\"GANGA_ARGS\"] = ganga_args\n    socketio.run(gui, host=host, port=port, log_output=log_output)  # TODO\n\n\n# ******************** Shutdown Function ******************** #\n\n# Route used to shutdown the Internal API server and GUI server\n@gui.route(\"/shutdown\", methods=[\"GET\"])\ndef shutdown():\n\n    if gui.config[\"WEB_CLI\"] is True:\n        flash(\"WEB CLI Mode is on, cannot self shutdown server. Consider doing manually.\", \"warning\")\n        return redirect(url_for(\"dashboard\"))\n\n    try:\n        response_info = query_internal_api(\"/shutdown\", \"get\")\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return \"GUI Shutdown Successful.\"\n\n# ******************** EOF ******************** #\n"], "fixing_code": ["import os\nimport jwt\nimport json\nimport requests\nimport time\nimport select\nimport termios\nimport struct\nimport fcntl\nimport subprocess\nimport pty\nimport sys\nimport datetime\nfrom functools import wraps\nfrom werkzeug.utils import secure_filename, safe_join\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom flask import Flask, request, jsonify, render_template, flash, redirect, url_for, session, send_file, make_response\nfrom flask_login import login_user, login_required, logout_user, current_user, UserMixin\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\nfrom flask_socketio import SocketIO\nfrom GangaGUI.gui.config import Config\n\n# ******************** Initialisation of Flask App for GUI ******************** #\n\n\n# GUI Flask App and set configuration from ./config.py file\ngui = Flask(__name__)\ngui.config.from_object(Config)\n\n# Database object which is used to interact with the \"gui.sqlite\" in gangadir/gui folder\n# NOTE: IT HAS NO RELATION WITH THE GANGA PERSISTENT DATABASE\ndb = SQLAlchemy(gui)\n\n# Login manage for the view routes\nlogin = LoginManager(gui)\nlogin.login_view = \"login\"\nlogin.login_message = \"Please Login to Access this Page.\"\nlogin.login_message_category = \"warning\"\n\n# For websocket, for communication between frontend and backend\nsocketio = SocketIO(gui)\n\n\n# ******************** The user class for database and authentication ******************** #\n\n# ORM Class to represent Users - used to access the GUI & API resources\nclass User(UserMixin, db.Model):\n    __tablename__ = \"users\"\n    id = db.Column(db.Integer, primary_key=True)\n    public_id = db.Column(db.String(64), unique=True)\n    user = db.Column(db.String(32), unique=True)\n    password_hash = db.Column(db.String(64))\n    role = db.Column(db.String(32))\n    pinned_jobs = db.Column(db.Text)\n\n    def store_password_hash(self, password: str):\n        self.password_hash = generate_password_hash(password)\n\n    def verify_password(self, password: str) -> bool:\n        return check_password_hash(self.password_hash, password)\n\n    def generate_auth_token(self, expires_in_days: int = 5) -> str:\n        return jwt.encode(\n            {\"public_id\": self.public_id, \"exp\": datetime.datetime.utcnow() + datetime.timedelta(days=expires_in_days)},\n            gui.config[\"SECRET_KEY\"], algorithm=\"HS256\")\n\n    def __repr__(self):\n        return \"User {}: {} (Public ID: {}, Role: {})\".format(self.id, self.user, self.public_id, self.role)\n\n\n# User Loader Function for Flask Login\n@login.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))\n\n\n# ******************** Global Variables ******************** #\n\n\n# Colors showed for different job statuses in the GUI based on Bootstrap CSS\nstatus_color = {\n    \"new\": \"info\",\n    \"completed\": \"success\",\n    \"completed_frozen\" : \"success\",\n    \"failed\": \"danger\",\n    \"failed_frozen\" : \"danger\",\n    \"running\": \"primary\",\n    \"submitted\": \"secondary\",\n    \"killed\": \"warning\"\n}\n\n# Allowed extensions when uploading any files to GUI\nALLOWED_EXTENSIONS = {\"txt\", \"py\"}\n\n# Variables to globally store plugins and actions\nactions = {}\nplugins = {}\n\n\n# ******************** Run Before First Request ******************** #\n\n\n# Execute before first request\n@gui.before_first_request\ndef initial_run():\n    \"\"\"\n    This function runs before first request. It stores actions and plugins information from the ganga. It create default session cookies. If WEB_CLI is also started then it also starts a Ganga session.\n    \"\"\"\n\n    global actions, plugins\n\n    # Start ganga if WEB_CLI mode is True\n    if gui.config['WEB_CLI'] is True:\n        start_ganga(gui.config['INTERNAL_PORT'], args=gui.config[\"GANGA_ARGS\"])\n        session[\"WEB_CLI\"] = True\n    elif gui.config['INTERNAL_PORT'] is None:\n        gui.config['INTERNAL_PORT'] = os.environ['INTERNAL_PORT']\n\n    # If user is authenticated, log them out. This happens after a fresh start of the GUI server.\n    if current_user.is_authenticated:\n        logout_user()\n\n    # Create user session defaults\n    create_session_defaults()\n\n    # Check if internal server is online, exit after 20s of retrying\n    if not ping_internal():\n        print(\"INTERNAL SERVER UNAVAILABLE, TERMINATING...\")\n        sys.exit(1)\n\n    # Get job actions and plugins information from ganga\n    try:\n        # Get actions and plugins data once\n        actions = query_internal_api(\"/internal/jobs/actions\", \"get\")\n        plugins = query_internal_api(\"/internal/plugins\", \"get\")\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n\n# ******************** View Routes ******************** #\n\n\n# Login View\n@gui.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    \"\"\"\n    Handles login route of the GUI.\n    \"\"\"\n\n    # If already authenticated, logout\n    if current_user.is_authenticated:\n        return redirect(url_for(\"dashboard\"))\n\n    # Login user\n    if request.method == \"POST\":\n\n        # Form data\n        username = request.form.get(\"username\")\n        password = request.form.get(\"password\")\n\n        # Database query\n        user = User.query.filter_by(user=username).first()\n\n        # If valid user, login\n        if user and user.verify_password(password):\n            login_user(user, True)\n            flash(\"Login successful\", \"success\")\n            return redirect(url_for(\"dashboard\"))\n\n        flash(\"Error identifying the user\", \"danger\")\n\n    # Get users from the database\n    users = User.query.all()\n\n    return render_template(\"login.html\", title=\"Login\", users=users)\n\n\n# Logout View\n@gui.route(\"/logout\", methods=[\"GET\"])\ndef logout():\n    \"\"\"\n    Logout user from GUI\n    \"\"\"\n\n    # Logout\n    if current_user.is_authenticated:\n        logout_user()\n\n    return redirect(url_for(\"login\"))\n\n\n# Dashboard view\n@gui.route(\"/\")\n@login_required\ndef dashboard():\n    \"\"\"\n    Handles the dashboard route of the GUI.\n    \"\"\"\n\n    quick_statistics = {}\n    recent_jobs_info = []\n    pinned_jobs_info = []\n\n    try:\n        # Query overall statistics\n        quick_statistics = query_internal_api(\"/internal/jobs/statistics\", \"get\")\n\n        # Query recent 10 jobs\n        recent_jobs_info = query_internal_api(\"/internal/jobs/recent\", \"get\")\n\n        # Query pinned jobs\n        u = current_user\n        pinned_jobs_info = query_internal_api(\"/internal/jobs\", \"get\", params={\n            \"ids\": u.pinned_jobs if u.pinned_jobs is not None else json.dumps([]),\n            \"auto-validate-ids\": True})\n\n    except Exception as err:\n        # Flash the error in the GUI\n        flash(str(err), \"danger\")\n\n    return render_template(\"dashboard.html\",\n                           title=\"Dashboard\",\n                           quick_statistics=quick_statistics,\n                           recent_jobs_info=recent_jobs_info,\n                           pinned_jobs_info=pinned_jobs_info,\n                           status_color=status_color)\n\n\n# Config view\n@gui.route(\"/config\", methods=[\"GET\", \"POST\"])\n@login_required\ndef config_page():\n    \"\"\"\n    Handles the config route of the GUI.\n    \"\"\"\n\n    full_config_info = []\n    config_info = []\n    section = None\n\n    # When GUI request for specific section\n    if request.method == \"POST\":\n        # Get section name for request form data\n        section = request.form.get(\"section\")\n        section = None if section in [\"\", None] else section\n\n    try:\n        # Query full config\n        full_config_info = query_internal_api(\"/internal/config\", \"get\")\n\n        # If asked for specific section, add only that for displaying\n        config_info = full_config_info if section is None else [s for s in full_config_info if s[\"name\"] == section]\n\n    except Exception as err:\n        # Flash the error in the GUI\n        flash(str(err), \"danger\")\n\n    return render_template(\"config.html\", title=\"Config\", full_config_info=full_config_info, config_info=config_info)\n\n#Edit gangarc\n@gui.route(\"/config_edit\",methods=[\"GET\", \"POST\"])\n@login_required\ndef edit_config_page():\n    \"\"\"\n    Edit gangarc file from the GUI\n    \"\"\"\n    gui_rc = gui.config[\"GANGA_RC\"]\n    with open(gui_rc, \"rt\") as f:\n        ganga_config = f.read()\n    if request.method == 'POST':\n        config_ganga = request.form['config-data']\n        with open(gui_rc, 'w') as f1:\n            f1.write(str(config_ganga))\n        flash(\".gangarc Edited\", \"success\")\n        with open(gui_rc, \"rt\") as f2:\n            ganga_config = f2.read()\n    return render_template(\"config_edit.html\", title=\"Edit gangarc\", ganga_config=ganga_config)\n    \n@login_required\n# Create view\n@gui.route(\"/create\", methods=[\"GET\", \"POST\"])\ndef create_page():\n    \"\"\"\n    Handles create route of the GUI.\n    \"\"\"\n\n    # Handle file uploads\n    if request.method == \"POST\":\n\n        # Load from the uploaded file\n        if \"loadfile\" in request.files:\n            loadfile = request.files[\"loadfile\"]\n            if loadfile.filename == \"\":\n                flash(\"No file selected\", \"warning\")\n                return redirect(request.url)\n\n            # If valid file, the save the file\n            if loadfile and allowed_file(loadfile.filename):\n                save_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"loadfile.txt\")\n                loadfile.save(save_path)\n\n                # Load the file\n                try:\n                    # Query to load the file\n                    response_info = query_internal_api(\"/internal/load\", \"get\", params={\"path\": save_path})\n\n                except Exception as err:\n                    # Display error in the GUI\n                    flash(str(err), \"danger\")\n                    return redirect(request.url)\n\n                # Success message\n                flash(response_info.get(\"message\"), \"success\")\n                return redirect(request.url)\n\n        # Run file using the runfile GPI function\n        if \"runfile\" in request.files:\n            runfile = request.files[\"runfile\"]\n            if runfile.filename == \"\":\n                flash(\"No file selected\", \"warning\")\n                return redirect(request.url)\n\n            # If valid file, save the file\n            if runfile and allowed_file(runfile.filename):\n                save_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"runfile.py\")\n                runfile.save(save_path)\n\n                # Run the file\n                try:\n                    # Query ganga to run the file\n                    response_info = query_internal_api(\"/internal/runfile\", \"get\", params={\"path\": save_path})\n\n                except Exception as err:\n                    # Display error back to GUI\n                    flash(str(err), \"danger\")\n                    return redirect(request.url)\n\n                # Success message\n                flash(response_info.get(\"message\"), \"success\")\n                return redirect(request.url)\n\n        # No file case\n        flash(\"No file, retry!\", \"warning\")\n        return redirect(request.url)\n\n    try:\n        # Query templates info\n        templates_info = query_internal_api(\"/internal/templates\", \"get\",\n                                            params={\"recent\": True, \"length\": \"6\"})\n\n    except Exception as err:\n        # Display error to GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template(\"create.html\", title=\"Create\", templates_info=templates_info)\n\n\n# Runfile view\n@gui.route(\"/create/runfile\", methods=[\"GET\", \"POST\"])\n@login_required\ndef runfile_page():\n    \"\"\"\n    Quick create a runfile to be run using the runfile GPI function.\n    \"\"\"\n\n    # Runfile path\n    runfile_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"runfile.py\")\n\n    # Save runfile data from frontend\n    if request.method == \"POST\":\n        runfile_data = request.form.get(\"runfile-data\")\n        with open(runfile_path, \"w+\") as f:\n            f.write(runfile_data)\n\n        # Run the file\n        try:\n            # Query ganga to run the file\n            response_info = query_internal_api(\"/internal/runfile\", \"get\", params={\"path\": runfile_path})\n            flash(response_info[\"message\"], \"success\")\n\n        except Exception as err:\n            # Display error back in the GUI\n            flash(str(err), \"danger\")\n            return redirect(request.url)\n\n    return render_template(\"runfile.html\", title=\"Runfile\")\n\n\n# Templates view\n@gui.route(\"/templates\", methods=[\"GET\", \"POST\"])\n@login_required\ndef templates_page():\n    \"\"\"\n    Handles the templates route of the GUI. Displays templates in a tabular form.\n    \"\"\"\n\n    # Update filter values\n    if request.method == \"POST\":\n        # Add filter data to user session\n        session[\"templates_per_page\"] = int(request.form.get(\"templates-per-page\"))\n        session[\"templates_filter\"] = {key: request.form.get(form_name) for key, form_name in\n                                       zip([\"application\", \"backend\"], [\"template-application\", \"template-backend\"])}\n\n    # Current page\n    current_page = int(request.args.get(\"page\")) if request.args.get(\"page\") is not None else 0\n\n    # Get user defined value from session\n    templates_per_page = session[\"templates_per_page\"]\n\n    try:\n\n        # Query total number of templates\n        templates_length = query_internal_api(\"/internal/templates/length\", \"get\", params=session[\"templates_filter\"])\n\n        # Calculate number of max pages\n        number_of_pages = (int(templates_length) // int(templates_per_page)) + 1\n\n        # if current page exceeds last possible page, redirect to last page\n        if current_page >= number_of_pages:\n            return redirect(url_for(\"templates_page\", page=number_of_pages - 1))\n\n        # Add templates filters and range options for query params\n        params = session[\"templates_filter\"].copy()\n        params.update({\n            \"recent\": True,\n            \"length\": templates_per_page,\n            \"offset\": current_page\n        })\n\n        # Query templates information\n        templates_info = query_internal_api(\"/internal/templates\", \"get\", params=params)\n\n    except Exception as err:\n        # Flash error if any\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"create_page\"))\n\n    return render_template(\"templates.html\",\n                           title=\"Templates\",\n                           number_of_pages=number_of_pages,\n                           current_page=current_page,\n                           backends=plugins[\"backends\"],\n                           applications=plugins[\"applications\"],\n                           templates_info=templates_info)\n\n\n# Jobs view\n@gui.route(\"/jobs\", methods=[\"GET\", \"POST\"])\n@login_required\ndef jobs_page():\n    \"\"\"\n    Handles jobs route of the GUI. Displays jobs in a tabular view.\n    \"\"\"\n\n    # Update filter values\n    if request.method == \"POST\":\n        # Add form data to user session\n        session[\"jobs_per_page\"] = int(request.form.get(\"jobs-per-page\"))\n        session[\"jobs_filter\"] = {key: request.form.get(form_name) for key, form_name in\n                                  zip([\"status\", \"application\", \"backend\"],\n                                      [\"job-status\", \"job-application\", \"job-backend\"])}\n\n    # Current page\n    current_page = int(request.args.get(\"page\")) if request.args.get(\"page\") is not None else 0\n\n    # Get user defined value from user session\n    jobs_per_page = session[\"jobs_per_page\"]\n\n    try:\n\n        # Query total number of jobs\n        jobs_length = query_internal_api(\"/internal/jobs/length\", \"get\", params=session[\"jobs_filter\"])\n\n        # Calculate number of max pages\n        number_of_pages = (int(jobs_length) // int(jobs_per_page)) + 1\n\n        # if current page exceeds last possible page, redirect to last page\n        if current_page >= number_of_pages:\n            return redirect(url_for(\"jobs_page\", page=number_of_pages - 1))\n\n        # Add jobs filters and range options for query params\n        params = session[\"jobs_filter\"].copy()\n        params.update({\n            \"recent\": True,\n            \"length\": jobs_per_page,\n            \"offset\": current_page\n        })\n\n        # Query jobs information\n        jobs_info = query_internal_api(\"/internal/jobs\", \"get\", params=params)\n\n    except Exception as err:\n        # Display error back to GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template(\"jobs.html\",\n                           title=\"Jobs\",\n                           jobs_info=jobs_info,\n                           backends=plugins[\"backends\"],\n                           applications=plugins[\"applications\"],\n                           number_of_pages=number_of_pages,\n                           current_page=current_page,\n                           status_color=status_color)\n\n\n# Job view\n@gui.route('/jobs/<int:job_id>')\n@login_required\ndef job_page(job_id: int):\n    \"\"\"\n    Handles job route of the GUI. Displays all the information about the job.\n    :param job_id: int\n    \"\"\"\n\n    stdout = None\n    stderr = None\n\n    try:\n\n        # Query job information\n        job_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"get\")\n\n        # Query full print of the job\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/full-print\", \"get\")\n\n        # stdout and stderr path\n        stdout_path = os.path.join(job_info[\"outputdir\"], \"stdout\")\n        stderr_path = os.path.join(job_info[\"outputdir\"], \"stderr\")\n\n        # Get stdout\n        if os.path.exists(stdout_path):\n            with open(stdout_path) as f:\n                stdout = f.read()\n\n        # Get stderr\n        if os.path.exists(stderr_path):\n            with open(stderr_path) as f:\n                stderr = f.read()\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"jobs_page\"))\n\n    return render_template(\"job.html\",\n                           title=f\"Job {job_id}\",\n                           job_info=job_info,\n                           status_color=status_color,\n                           attribute_actions=actions.get(\"attributes\"),\n                           method_actions=actions.get(\"methods\"),\n                           stdout=stdout,\n                           stderr=stderr,\n                           full_print_info=full_print_info)\n\n\n# Export job\n@gui.route(\"/jobs/<int:job_id>/export\")\n@login_required\ndef job_export(job_id: int):\n    \"\"\"\n    Sends the job file which is generated using export function of GPI.\n    :param job_id: int\n    \"\"\"\n\n    # Path to save file using export GPI function\n    export_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], f\"export.txt\")\n\n    try:\n\n        # Query to export the job at export path\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/export\", \"get\", params={\"path\": export_path})\n\n        # Send file\n        return send_file(export_path, as_attachment=True, cache_timeout=0, attachment_filename=f\"Job_{job_id}.txt\")\n\n    except Exception as err:\n        # Display error back to GUI\n        flash(str(err), \"danger\")\n\n    return redirect(url_for(\"job_page\", job_id=job_id))\n\n\n# Edit job\n@gui.route(\"/jobs/<int:job_id>/edit\", methods=[\"GET\", \"POST\"])\n@login_required\ndef job_edit(job_id: int):\n    \"\"\"\n    Show the exported job text on the GUI for it to be edited and submit. Will create a new job after submission.\n    :param job_id: int\n    \"\"\"\n\n    # Save paths\n    loadfile_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"loadfile.txt\")\n    export_path = os.path.join(gui.config[\"UPLOAD_FOLDER\"], \"export.txt\")\n\n    # Create a new job with the submitted information\n    if request.method == \"POST\":\n\n        # Save the edited job info\n        edited_job_info = request.form.get(\"edited-job-info\")\n        with open(loadfile_path, \"w+\") as f:\n            f.write(edited_job_info)\n\n        # Load the file\n        try:\n            # Query to load the job\n            response_info = query_internal_api(\"/internal/load\", \"get\", params={\"path\": loadfile_path})\n            flash(response_info[\"message\"], \"success\")\n\n        except Exception as err:\n            # Display error on the GUI\n            flash(str(err), \"danger\")\n            return redirect(request.url)\n\n    try:\n        # Query to export the job text\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/export\", \"get\", params={\"path\": export_path})\n\n        # Read exported job file to display\n        with open(export_path) as f:\n            exported_data = f.read()\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    return render_template(\"edit_job.html\", title=f\"Edit Job {job_id}\", job_id=job_id, exported_data=exported_data)\n\n\n# Browse job directory\n@gui.route(\"/job/<int:job_id>/browse\", defaults={\"path\": \"\"})\n@gui.route(\"/job/<int:job_id>/browse/<path:path>\")\n@login_required\ndef job_browse(job_id: int, path):\n    \"\"\"\n    Browse directory of the job.\n    :param job_id: int\n    :param path: str\n    \"\"\"\n\n    try:\n        # Query job information\n        job_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"get\")\n\n        # Base directory of the job\n        job_base_dir = os.path.dirname(os.path.dirname(job_info[\"outputdir\"]))\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    # Join the base and the requested path\n    abs_path = safe_join(job_base_dir, path)\n\n    # URL path variable for going back\n    back_path = os.path.dirname(abs_path).replace(job_base_dir, \"\")\n\n    # If path doesn't exist\n    if not os.path.exists(abs_path):\n        flash(\"Directory for this job does not exist.\", \"warning\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    # Check if path is a file and send\n    if os.path.isfile(abs_path):\n        return send_file(abs_path)\n\n    files_info = []\n\n    # Show directory contents\n    files = os.listdir(abs_path)\n\n    # Store directory information\n    for file in files:\n        files_info.append({\n            \"file\": file,\n            \"directory\": os.path.isdir(os.path.join(abs_path, file))\n        })\n\n    return render_template('job_dir.html', title=f\"Job {job_id} Directory\",\n                           job_id=job_id,\n                           abs_path=abs_path,\n                           files_info=files_info,\n                           back_path=back_path)\n\n\n# Subjobs view\n@gui.route(\"/jobs/<int:job_id>/subjobs\", methods=[\"GET\", \"POST\"])\n@login_required\ndef subjobs_page(job_id: int):\n    \"\"\"\n    Handles subjobs view of the GUI. Displays subjobs of a job in a tabular form.\n    :param job_id: int\n    \"\"\"\n\n    # Change filter values\n    if request.method == \"POST\":\n        # Add form data to client session\n        session[\"subjobs_per_page\"] = int(request.form.get(\"subjobs-per-page\"))\n        session[\"subjobs_filter\"] = {key: request.form.get(form_name) for key, form_name in\n                                     zip([\"status\", \"application\", \"backend\"],\n                                         [\"subjob-status\", \"subjob-application\", \"subjob-backend\"])}\n\n    # Current page\n    current_page = int(request.args.get(\"page\")) if request.args.get(\"page\") is not None else 0\n\n    # Get user defined value from session\n    subjobs_per_page = session[\"subjobs_per_page\"]\n\n    try:\n        # Query total number of subjobs\n        subjobs_length = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/length\", \"get\",\n                                            params=session[\"subjobs_filter\"])\n\n        # Calculate number of max pages\n        number_of_pages = (int(subjobs_length) // int(subjobs_per_page)) + 1\n\n        # if current page exceeds last possible page, redirect to last page\n        if current_page >= number_of_pages:\n            return redirect(url_for(\"subjobs_page\", page=number_of_pages - 1, job_id=job_id))\n\n        # Add subjobs filters and range options for query params\n        params = session[\"subjobs_filter\"].copy()\n        params.update({\n            \"recent\": True,\n            \"length\": subjobs_per_page,\n            \"offset\": current_page\n        })\n\n        # Query subjobs information\n        subjobs_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs\", \"get\", params=params)\n\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"job_page\", job_id=job_id))\n\n    return render_template(\"subjobs.html\",\n                           title=f\"Subjobs - Job {job_id}\",\n                           status_color=status_color,\n                           number_of_pages=number_of_pages,\n                           current_page=current_page,\n                           backends=plugins[\"backends\"],\n                           applications=plugins[\"applications\"],\n                           subjobs_info=subjobs_info,\n                           job_id=job_id)\n\n\n# Subjob view\n@gui.route(\"/jobs/<int:job_id>/subjobs/<int:subjob_id>\", methods=[\"GET\"])\n@login_required\ndef subjob_page(job_id: int, subjob_id: int):\n    \"\"\"\n    Handles subjob route of the GUI. Displays extensive details of a subjob.\n    :param job_id: int\n    :param subjob_id: int\n    \"\"\"\n\n    stdout = None\n    stderr = None\n\n    try:\n\n        # Query job information\n        job_outputdir = query_internal_api(f\"/internal/jobs/{job_id}/outputdir\", \"get\")\n\n        # Query subjob information\n        subjob_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}\", \"get\")\n\n        # Query full print of the job\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/full-print\", \"get\")\n\n        # Extract browse path that can be used by job_browse route\n        job_dir_basepath = os.path.dirname(os.path.dirname(job_outputdir[\"outputdir\"]))\n        subjob_dir_basepath = os.path.dirname(os.path.dirname(subjob_info[\"outputdir\"]))\n        browse_path = subjob_dir_basepath.replace(job_dir_basepath, \"\")\n\n        # stdout and stderr path\n        stdout_path = os.path.join(subjob_info[\"outputdir\"], \"stdout\")\n        stderr_path = os.path.join(subjob_info[\"outputdir\"], \"stderr\")\n\n        # Get stdout\n        if os.path.exists(stdout_path):\n            with open(stdout_path) as f:\n                stdout = f.read()\n\n        # Get stderr\n        if os.path.exists(stderr_path):\n            with open(stderr_path) as f:\n                stderr = f.read()\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"subjobs_page\", job_id=job_id))\n\n    return render_template(\"subjob.html\",\n                           title=f\"Subjob {subjob_id} - Job {job_id}\",\n                           subjob_info=subjob_info,\n                           status_color=status_color,\n                           attribute_actions=actions[\"attributes\"],\n                           method_actions=actions[\"methods\"],\n                           stdout=stdout,\n                           stderr=stderr,\n                           full_print_info=full_print_info,\n                           job_id=job_id,\n                           browse_path=browse_path)\n\n\n# Credential view\n@gui.route(\"/credentials\")\n@login_required\ndef credentials_page():\n    \"\"\"\n    Handles credential store view of the GUI. Displays credentials in a tabular form.\n    \"\"\"\n\n    try:\n        # Query credential store information\n        credentials_info = query_internal_api(\"/internal/credentials\", \"get\")\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template('credentials.html', credential_info_list=credentials_info)\n\n@gui.route(\"/queue\", methods=[\"GET\"])\n@login_required\ndef queue_page():\n    \"\"\"\n    Displays queues information\n    \"\"\"\n    try:\n        queue_info = query_internal_api(\"/internal/queue\", \"get\")\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template('queue.html', queue_info_list=queue_info)\n\n# Plugins view\n@gui.route('/plugins')\n@login_required\ndef plugins_page():\n    \"\"\"\n    Handles plugins route of the GUI. Displays the list of plugins.\n    \"\"\"\n\n    try:\n        # Store plugins information\n        plugins_info = plugins\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template('plugins.html', plugins_info=plugins_info)\n\n\n# Plugin view\n@gui.route(\"/plugin/<plugin_name>\")\n@login_required\ndef plugin_page(plugin_name: str):\n    \"\"\"\n    Displays information about the plugin like it's docstring.\n    :param plugin_name: str\n    \"\"\"\n\n    try:\n        # Query plugin information\n        plugin_info = query_internal_api(f\"/internal/plugins/{plugin_name}\", \"get\")\n\n    except Exception as err:\n        # Display error on the GUI\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"plugins_page\"))\n\n    return render_template(\"plugin.html\", title=f\"{plugin_name}\", plugin_info=plugin_info)\n\n\n# Ganga logs view\n@gui.route(\"/logs\")\n@login_required\ndef logs_page():\n    \"\"\"\n    Diplay ganga log file.\n    :return:\n    \"\"\"\n\n    ganga_log_path = gui.config[\"GANGA_LOG\"]\n    gui_accesslog_path = gui.config[\"ACCESS_LOG\"]\n    gui_errorlog_path = gui.config[\"ERROR_LOG\"]\n\n    try:\n        # Get ganga log\n        with open(ganga_log_path, \"rt\") as f:\n            ganga_log_data = f.read()\n\n        # Get GUI access log\n        with open(gui_accesslog_path, \"rt\") as f:\n            gui_accesslog_data = f.read()\n\n        # Get GUI error log\n        with open(gui_errorlog_path, \"rt\") as f:\n            gui_errorlog_data = f.read()\n\n    except Exception as err:\n        flash(str(err), \"danger\")\n        return redirect(url_for(\"dashboard\"))\n\n    return render_template(\"logs.html\", title=\"Logs\", ganga_log_data=ganga_log_data,\n                           gui_accesslog_data=gui_accesslog_data, gui_errorlog_data=gui_errorlog_data)\n\n\n@gui.route(\"/storage\", defaults={\"path\": \"\"}, methods=[\"GET\", \"POST\"])\n@gui.route(\"/storage/<path:path>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef storage_page(path):\n    \"\"\"\n    A convenience feature to store some file remotely in gangadir/storage\n    \"\"\"\n\n    # Storage folder path\n    storage_folder = gui.config[\"STORAGE_FOLDER\"]\n\n    # Join the storage path and the requested path\n    abs_path = os.path.join(storage_folder, path)\n\n    # Handle file uploads\n    if request.method == \"POST\":\n\n        # Uploaded file\n        if \"storagefile\" in request.files:\n            storagefile = request.files[\"storagefile\"]\n            if storagefile.filename == \"\":\n                flash(\"No file selected\", \"warning\")\n                return redirect(request.url)\n\n            # If valid file, the save the file\n            if storagefile:\n                # Directory check\n                if not os.path.isdir(abs_path):\n                    flash(\"Error while uploading the file\", \"danger\")\n                    return redirect(request.url)\n\n                filename = secure_filename(storagefile.filename)\n                save_path = os.path.join(abs_path, filename)\n                storagefile.save(save_path)\n\n                # Success message\n                flash(\"Successfully uploaded the file.\", \"success\")\n                return redirect(request.url)\n\n        # No file case\n        flash(\"No file, retry!\", \"warning\")\n        return redirect(request.url)\n\n    # URL path variable for going back\n    back_path = os.path.dirname(abs_path).replace(storage_folder, \"\")\n\n    # If path doesn't exist\n    if not os.path.exists(abs_path):\n        flash(\"Directory does not exist.\", \"warning\")\n        return redirect(url_for(\"dashboard\"))\n\n    # Check if path is a file and send\n    if os.path.isfile(abs_path):\n        return send_file(abs_path)\n\n    files_info = []\n\n    # Show directory contents\n    files = os.listdir(abs_path)\n\n    # Store directory information\n    for file in files:\n        files_info.append({\n            \"file\": file,\n            \"directory\": os.path.isdir(os.path.join(abs_path, file))\n        })\n\n    return render_template(\"storage.html\", title=\"Storage\",\n                           abs_path=abs_path,\n                           files_info=files_info,\n                           back_path=back_path)\n\n\n# Serve CLI\n@gui.route(\"/cli\")\n@login_required\ndef serve_cli():\n    return render_template(\"cli.html\")\n\n\n# Establish a websocket connection from the frontend to the server\n@socketio.on(\"connect\", namespace=\"/pty\")\ndef connect():\n    \"\"\"\n    New client connected, start reading and writing from the pseudo terminal.\n    \"\"\"\n\n    if gui.config[\"CHILD_PID\"] and current_user.is_authenticated:\n        # Start background reading and emitting the output of the pseudo terminal\n        socketio.start_background_task(target=read_and_forward_pty_output)\n        return\n\n\n# Input from the frontend\n@socketio.on(\"pty-input\", namespace=\"/pty\")\ndef pty_input(data):\n    \"\"\"\n    Write to the child pty. The pty sees this as if you are typing in a real terminal.\n    \"\"\"\n\n    if gui.config[\"FD\"] and current_user.is_authenticated:\n        os.write(gui.config[\"FD\"], data[\"input\"].encode())\n\n\n# Resize the pseudo terminal when the frontend is resized\n@socketio.on(\"resize\", namespace=\"/pty\")\ndef resize(data):\n    \"\"\"\n    Resize the pseudo terminal according to the dimension at the frontend.\n    :param data: contains information about rows and cols of the frontend terminal.\n    \"\"\"\n\n    if gui.config[\"FD\"] and current_user.is_authenticated:\n        set_windowsize(gui.config[\"FD\"], data[\"rows\"], data[\"cols\"])\n\n\n# ******************** Token Based Authentication ******************** #\n\n# Generate token for API authentication - token validity 5 days\n@gui.route(\"/token\", methods=[\"POST\"])\ndef generate_token():\n    \"\"\"\n    Using the 'user' and 'password' data from the form body, validates the user and returns a JSON Web Token (JWT).\n    \"\"\"\n\n    # Request form data\n    request_json = request.json if request.json else {}\n    request_user = request_json.get(\"username\")\n    request_password = request_json.get(\"password\")\n\n    # Handle no user or no password case\n    if not request_user or not request_password:\n        response_data = {\"success\": False, \"message\": \"Could not verify user.\"}\n        return jsonify(response_data), 401\n\n    # Verify user and accordingly return the token\n    user = User.query.filter_by(user=request_user).first()\n    if user and user.verify_password(request_password):\n        token = user.generate_auth_token().decode(\"UTF-8\")\n        response_data = {\"token\": token}\n        return jsonify(response_data)\n\n    # If authentication fails, return 401 HTTP code\n    response_data = {\"success\": False, \"message\": \"Could not verify user.\"}\n    return jsonify(response_data), 401\n\n\n# ******************** Token Authentication Decorator ******************** #\n\n# Decorator for token protected routes\ndef token_required(f):\n    \"\"\"\n    Decorator which validates the request header token in 'X-Acess-Token' field, and returns the user.\n    \"\"\"\n\n    @wraps(f)\n    def decorated(*args, **kwargs):\n\n        token = None\n\n        # Extract token from headers\n        if \"X-Access-Token\" in request.headers:\n            token = request.headers[\"X-Access-Token\"]\n\n        if not token:\n            return jsonify({\"success\": False, \"message\": \"Token is missing\"}), 401\n\n        # Decode the token and subsequently identify the user\n        try:\n            data = jwt.decode(token, gui.config[\"SECRET_KEY\"], algorithms=[\"HS256\"])\n            current_api_user = User.query.filter_by(public_id=data[\"public_id\"]).first()\n            if current_api_user is None:\n                return jsonify({\"success\": False, \"message\": \"Token is old. Please renew\"}), 401\n        except jwt.ExpiredSignatureError:\n            return jsonify({\"success\": False, \"message\": \"Token is expired\"}), 401\n        except jwt.InvalidTokenError:\n            return jsonify({\"success\": False, \"message\": \"Token is invalid\"}), 401\n        except:\n            return jsonify({\"success\": False, \"message\": \"Could not verify token\"}), 401\n\n        return f(current_api_user, *args, **kwargs)\n\n    return decorated\n\n\n# ******************** Job API ******************** #\n\n\n# Single job information API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>\", methods=[\"GET\"])\n@token_required\ndef job_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Given the job_id, returns the general information related to the job in JSON format.\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query job information to the GPI\n        job_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(job_info)\n\n\n# Single job attribute information API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/<attribute>\", methods=[\"GET\"])\n@token_required\ndef job_attribute_endpoint(current_api_user, job_id: int, attribute: str):\n    \"\"\"\n    Given the job_id and attribute, returns the attribute information in the JSON format.\n\n    :param job_id: int\n    :param attribute: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query job attribute information from ganga\n        job_attribute_info = query_internal_api(f\"/internal/jobs/{job_id}/{attribute}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(job_attribute_info)\n\n\n# Single job full print API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/full-print\", methods=[\"GET\"])\n@token_required\ndef job_full_print_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Return full print of the job.\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query job full print from ganga\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/full-print\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(full_print_info)\n\n\n# Create job using template API - POST Method\n@gui.route(\"/api/jobs/create\", methods=[\"POST\"])\n@token_required\ndef job_create_endpoint(current_api_user):\n    \"\"\"\n    Create a new job using the existing template.\n\n    IMPORTANT: template_id NEEDS to be provided in the request body. job_name can optionally be provided in the request body.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Request data\n    data = {\n        \"template_id\": request.json.get(\"template_id\"),\n        \"job_name\": request.json.get(\"job_name\")\n    }\n\n    try:\n        # Query ganga to create a job using the template id\n        response_info = query_internal_api(\"/internal/jobs/create\", \"post\", json=data)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Copy job API - PUT Method\n@gui.route(\"/api/jobs/<int:job_id>/copy\", methods=[\"PUT\"])\n@token_required\ndef job_copy_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Create a copy of the job.\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    :param job_id: int\n    \"\"\"\n\n    try:\n        # Query ganga to copy the job\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/copy\", \"put\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Job action API - PUT Method\n@gui.route(\"/api/jobs/<int:job_id>/<action>\", methods=[\"PUT\"])\n@token_required\ndef job_action_endpoint(current_api_user, job_id: int, action: str):\n    \"\"\"\n    Given the job_id and action in the endpoint, perform the action on the job.\n\n    The action can be any method or attribute change that can be called on the Job object.\n\n    Example:\n    1)\n        PUT http://localhost:5000/job/13/resubmit\n\n        The above request will resubmit the job with ID 13.\n\n    2)\n        PUT http://localhost:5000/job/13/force_status\n        {\"force_status\":\"failed\"}\n\n        The above request will force status of the job with ID 13 to killed. If unsuccessful will return back the error.\n\n    3)\n        PUT http://localhost:5000/job/13/name\n        {\"name\"=\"New Name\"}\n\n        The above request will change the name of the job with ID 13 to \"New Name\". Notice how the required values\n        are passed in the request body with the same name as action.\n\n    NOTE: It is NECESSARY to send body in JSON format for the request to be parsed in JSON.\n\n    :param job_id: int\n    :param action: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Request data\n    request_data = request.json\n\n    try:\n        # Query ganga to perform the action\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/{action}\", \"put\", json=request_data)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Job delete API - DELETE Method\n@gui.route(\"/api/jobs/<int:job_id>\", methods=[\"DELETE\"])\n@token_required\ndef job_delete_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Given the job id, removes the job from the job repository.\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to delete the job\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}\", \"delete\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# Pin the Job\n@gui.route(\"/api/jobs/<int:job_id>/pin\", methods=[\"PUT\"])\n@token_required\ndef job_pin_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Pin the given job, which is then shown in the dashboard.\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Get current user\n    u = current_user\n\n    # Load pinned jobs of the user from the database\n    pinned_jobs = json.loads(u.pinned_jobs) if u.pinned_jobs is not None else []\n\n    # Pin job\n    if job_id not in pinned_jobs:\n        pinned_jobs.append(job_id)\n\n    # Add new pinned jobs to the database\n    u.pinned_jobs = json.dumps(pinned_jobs)\n    db.session.add(u)\n    db.session.commit()\n\n    return jsonify({\"success\": True, \"message\": f\"Successfully pinned Job (ID={job_id}).\"})\n\n\n# Unpin the job\n@gui.route(\"/api/jobs/<int:job_id>/unpin\", methods=[\"PUT\"])\n@token_required\ndef job_unpin_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Unpin the job, and make the required change to the GUI database.\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    # Get the user from the database\n    u = current_user\n\n    # Load user's pinned job from the database\n    pinned_jobs = json.loads(u.pinned_jobs) if u.pinned_jobs is not None else []\n\n    # Unpin the job\n    if job_id in pinned_jobs:\n        pinned_jobs.remove(job_id)\n\n    # Commit changes to the database\n    u.pinned_jobs = json.dumps(pinned_jobs)\n    db.session.add(u)\n    db.session.commit()\n\n    return jsonify({\"success\": True, \"message\": f\"Successfully unpinned Job (ID={job_id}).\"})\n\n\n# ******************** Subjobs API ******************** #\n\n# Subjobs API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs\", methods=[\"GET\"])\n@token_required\ndef subjobs_endpoint(current_api_user, job_id: int):\n    \"\"\"\n    Returns a list subjobs of a particular job in a similar way as Jobs API.\n\n    The parameter accepted are:\n    * ids: provide a JSON string of list of IDs\n    * status: provide subjob status as a string for filter\n    * application: provide subjob application as a string for filter\n    * backend: provide backend application as a string for filter\n    * recent: if provided, starts a list from recent subjobs to old\n    * length: number of subjobs to be returned, provide as a int\n    * offset: how many subjobs to skip before returning the specified length of subjobs. Provide as int.\n        offset works as: number of subjobs skipped = offset * length\n\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    params = {\n        \"ids\": request.args.get(\"ids\"),\n        \"status\": request.args.get(\"status\"),\n        \"application\": request.args.get(\"application\"),\n        \"backend\": request.args.get(\"backend\"),\n        \"recent\": request.args.get(\"recent\"),\n        \"length\": request.args.get(\"length\"),\n        \"offset\": request.args.get(\"offset\")\n    }\n\n    try:\n        # Query ganga for subjobs information\n        subjobs_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs\", \"get\", params=params)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(subjobs_info)\n\n\n# Single subjob info API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>\", methods=[\"GET\"])\n@token_required\ndef subjob_endpoint(current_api_user, job_id: int, subjob_id: int):\n    \"\"\"\n    Returns information of a single subjob related to a particular job\n\n    :param job_id: int\n    :param subjob_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query subjob information to ganga\n        subjob_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(subjob_info)\n\n\n# Single Subjob Attribute Info API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>/<attribute>\", methods=[\"GET\"])\n@token_required\ndef subjob_attribute_endpoint(current_api_user, job_id: int, subjob_id: int, attribute: str):\n    \"\"\"\n    Given the job id, subjob id and attribute; return the attribute information in the string format via JSON.\n\n    :param job_id: int\n    :param subjob_id: int\n    :param attribute: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query attribute information from ganga\n        subjob_attribute_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/{attribute}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(subjob_attribute_info)\n\n\n# Single subjob full print API - GET Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>/full-print\", methods=[\"GET\"])\n@token_required\ndef subjob_full_print_endpoint(current_api_user, job_id: int, subjob_id: int):\n    \"\"\"\n    Return full print of the subjob.\n\n    :param subjob_id: int\n    :param job_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query subjob full print from ganga\n        full_print_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/full-print\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(full_print_info)\n\n\n# Copy subjob API - PUT Method\n@gui.route(\"/api/jobs/<int:job_id>/subjobs/<int:subjob_id>/copy\", methods=[\"PUT\"])\n@token_required\ndef subjob_copy_endpoint(current_api_user, job_id: int, subjob_id: int):\n    \"\"\"\n    Create a copy of the subjob into a new job.\n    :param job_id:\n    :param subjob_id:\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to copy subjob\n        response_info = query_internal_api(f\"/internal/jobs/{job_id}/subjobs/{subjob_id}/copy\", \"put\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# ******************** Jobs API ******************** #\n\n# Jobs API - GET Method\n@gui.route(\"/api/jobs\", methods=[\"GET\"])\n@token_required\ndef jobs_endpoint(current_api_user):\n    \"\"\"\n    Returns a list of jobs with general information in JSON format.\n\n    The parameter accepted are:\n    * ids: provide a JSON string of list of IDs\n    * status: provide job status as a string for filter\n    * application: provide job application as a string for filter\n    * backend: provide backend application as a string for filter\n    * recent: if provided, starts a list from recent job to old\n    * length: number of job to be returned, provide as a int\n    * offset: how many job to skip before returning the specified length of job. Provide as int.\n        offset works like: number of job skipped = offset * length\n    * auto-validate-ids: If ids provided in ids parameters does not exist in job repository, then skip those ids.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    params = {\n        \"ids\": request.args.get(\"ids\"),\n        \"status\": request.args.get(\"status\"),\n        \"application\": request.args.get(\"application\"),\n        \"backend\": request.args.get(\"backend\"),\n        \"recent\": request.args.get(\"recent\"),\n        \"length\": request.args.get(\"length\"),\n        \"offset\": request.args.get(\"offset\"),\n        \"auto-validate-ids\": request.args.get(\"auto-validate-ids\")\n    }\n\n    try:\n        # Get jobs information according to select filter and range filter\n        jobs_info = query_internal_api(f\"/internal/jobs\", \"get\", params=params)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(jobs_info)\n\n\n# Jobs statistics API - GET Method\n@gui.route(\"/api/jobs/statistics\", methods=[\"GET\"])\n@token_required\ndef jobs_statistics_endpoint(current_api_user):\n    \"\"\"\n    Returns the number of jobs in new, running, completed, killed, failed status.\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get statistics information\n        statistics = query_internal_api(\"/internal/jobs/statistics\", \"get\")\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(statistics)\n\n@gui.route(\"/api/queue\", methods=[\"GET\"])\n@token_required\ndef queue_endpoint(current_api_user):\n\n    try:\n        queue_info = query_internal_api(\"/internal/queue\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(queue_info)\n\n@gui.route(\"/api/queue/chart\", methods=[\"GET\",\"POST\"])\ndef queue_chart_endpoint():\n\n    \n    chart_info = query_internal_api(\"/internal/queue/data\", \"get\")\n    response = make_response(json.dumps(chart_info))\n    response.content_type = 'application/json'\n    return response\n\n# Job incomplete ids API - GET Method\n@gui.route(\"/api/jobs/incomplete_ids\", methods=[\"GET\"])\n@token_required\ndef jobs_incomplete_ids_endpoint(current_api_user):\n    \"\"\"\n    Returns a list of incomplete job ids in JSON format.\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get incomplete ids list\n        incomplete_ids_list = query_internal_api(\"/internal/jobs/incomplete-ids\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(incomplete_ids_list)\n\n\n# ******************** Config API ******************** #\n\n# Config API - GET Method\n@gui.route(\"/api/config\", methods=[\"GET\"], defaults={\"section\": \"\"})\n@gui.route(\"/api/config/<section>\", methods=[\"GET\"])\n@token_required\ndef config_endpoint(current_api_user, section: str):\n    \"\"\"\n    Returns a list of all the section of the configuration and their options as well as the values in JSON format.\n\n    If section is provide, returns information about the section in JSON format.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get config information\n        if section != \"\":\n            config_info = query_internal_api(f\"/internal/config/{section}\", \"get\")\n        else:\n            config_info = query_internal_api(\"/internal/config\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(config_info)\n\n\n# ******************** Templates API ******************** #\n\n# Templates API - GET Method\n@gui.route(\"/api/templates\", methods=[\"GET\"])\n@token_required\ndef templates_endpoint(current_api_user):\n    \"\"\"\n    Returns a list of objects containing template info in JSON format.\n\n    * ids: provide a JSON string of list of IDs\n    * status: provide template status as a string for filter\n    * application: provide template application as a string for filter\n    * backend: provide backend application as a string for filter\n    * recent: if provided, starts a list from recent template to old\n    * length: number of template to be returned, provide as a int\n    * offset: how many template to skip before returning the specified length of template. Provide as int.\n        offset works like: number of template skipped = offset * length\n\n    :param current_api_user: Information of the current_user based on the request's JWT token\n    \"\"\"\n\n    params = {\n        \"application\": request.args.get(\"application\"),\n        \"backend\": request.args.get(\"backend\"),\n        \"recent\": request.args.get(\"recent\"),\n        \"length\": request.args.get(\"length\"),\n        \"offset\": request.args.get(\"offset\"),\n    }\n\n    try:\n        # Query ganga for templates information\n        templates_info = query_internal_api(\"/internal/templates\", \"get\", params=params)\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(templates_info)\n\n\n# Single template full print API - GET Method\n@gui.route(\"/api/templates/<int:template_id>/full-print\", methods=[\"GET\"])\n@token_required\ndef template_full_print_endpoint(current_api_user, template_id: int):\n    \"\"\"\n    Return full print of the template.\n\n    :param template_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query template full print from ganga\n        full_print_info = query_internal_api(f\"/internal/templates/{template_id}/full-print\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(full_print_info)\n\n\n# Template API - DELETE Method\n@gui.route(\"/api/templates/<int:template_id>\", methods=[\"DELETE\"])\n@token_required\ndef delete_template_endpoint(current_api_user, template_id: int):\n    \"\"\"\n\n    Given the templates id, delete it from the template repository.\n\n    :param template_id: int\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to remove the template\n        response_info = query_internal_api(f\"/internal/templates/{template_id}\", \"delete\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# ******************** Credentials API ******************** #\n\n# Credential store API - GET Method\n@gui.route(\"/api/credentials\", methods=[\"GET\"])\n@token_required\ndef credentials_endpoint(current_api_user):\n    \"\"\"\n    Return a list of credentials and their information in JSON format.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga for credentials information\n        credentials_info = query_internal_api(\"/internal/credentials\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(credentials_info)\n\n\n# Credential Store API - PUT Method - Renew all credentials\n@gui.route(\"/api/credentials/renew\", methods=[\"PUT\"])\n@token_required\ndef credentials_renew_endpoint(current_api_user):\n    \"\"\"\n    Renew all the credentials in the credential store.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to renew credentials\n        response_info = query_internal_api(\"/internal/credentials/renew\", \"put\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(response_info)\n\n\n# ******************** Job Tree API ******************** #\n\n# Job tree API - GET Method\n@gui.route(\"/api/jobtree\", methods=[\"GET\"])\n@token_required\ndef jobtree_endpoint(current_api_user):\n    \"\"\"\n    Return the job tree folder structure as the json format of python dict.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get job tree information\n        jobtree_info = query_internal_api(\"/internal/jobtree\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(jobtree_info)\n\n\n# ******************** Job Tree API ******************** #\n\n# Plugins API - GET Method\n@gui.route(\"/api/plugins\", methods=[\"GET\"])\n@token_required\ndef plugins_endpoint(current_api_user):\n    \"\"\"\n    Return plugins information, category and names of the plugins in the category.\n\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get plugins information\n        plugins_info = query_internal_api(\"/internal/plugins\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(plugins_info)\n\n\n# Plugin API - GET Method\n@gui.route(\"/api/plugins/<plugin_name>\", methods=[\"GET\"])\n@token_required\ndef plugin_endpoint(current_api_user, plugin_name: str):\n    \"\"\"\n    Return single plugin information like name and docstring.\n\n    :param plugin_name: str\n    :param current_api_user: Information of the current_api_user based on the request's JWT token\n    \"\"\"\n\n    try:\n        # Query ganga to get plugin information\n        plugin_info = query_internal_api(f\"/internal/plugins/{plugin_name}\", \"get\")\n\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return jsonify(plugin_info)\n\n\n# ******************** Helper Functions ******************** #\n\n# Validate uploaded filename.\ndef allowed_file(filename):\n    return \".\" in filename and filename.rsplit(\".\", 1)[1].lower() in ALLOWED_EXTENSIONS\n\n\n# Make HTTP request to the Internal Flask Server which is running on a GangaThread which has access to ganga namespace.\ndef query_internal_api(route: str, method: str, **kwargs):\n    \"\"\"\n    :param route: str\n    :param method: str\n    :param kwargs: dict\n    :return: dict\n\n    Make a HTTP request to the Internal API Flask server which runs on a GangaThread to query data from Ganga.\n    Check response status code and extract the data or raise an exception accordingly.\n\n    kwargs can be param, json, etc. Any attribute that is supported by the requests module.\n    \"\"\"\n\n    # Internal url for communicating with API server running on a GangaThread\n    INTERNAL_URL = f\"http://localhost:{gui.config['INTERNAL_PORT']}\"\n\n    # Raise error if HTTP method not supported\n    if method not in [\"get\", \"post\", \"put\", \"delete\"]:\n        raise Exception(f\"Unsupported method: {method}\")\n\n    # Made the HTTP requests, along with whatever arguments provided\n    res = getattr(requests, method)(INTERNAL_URL + route, **kwargs)\n\n    # Check is request is OK\n    if res.status_code != 200:\n        raise Exception(res.json().get(\"message\"))\n\n    # Return request data\n    return res.json()\n\n\ndef create_session_defaults():\n    \"\"\"\n    Create user session defaults and assign default values to them.\n    \"\"\"\n\n    # Set session defaults for templates filter\n    if \"templates_per_page\" not in session:\n        session[\"templates_per_page\"] = 10\n    if \"templates_filter\" not in session:\n        session[\"templates_filter\"] = {key: \"any\" for key in [\"application\", \"backend\"]}\n\n    # Set session defaults for jobs filter\n    if \"jobs_per_page\" not in session:\n        session[\"jobs_per_page\"] = 10\n    if \"jobs_filter\" not in session:\n        session[\"jobs_filter\"] = {key: \"any\" for key in [\"status\", \"application\", \"backend\"]}\n\n    # Set session defaults for subjobs filter\n    if \"subjobs_per_page\" not in session:\n        session[\"subjobs_per_page\"] = 10\n    if \"subjobs_filter\" not in session:\n        session[\"subjobs_filter\"] = {key: \"any\" for key in [\"status\", \"application\", \"backend\"]}\n\n\n# Ping internal API server\ndef ping_internal():\n    \"\"\"\n    Ping internal API server if it is running\n    \"\"\"\n\n    trials = 0\n    while True:\n        try:\n            ping = query_internal_api(\"/ping\", \"get\")\n            if ping is True:\n                return True\n        except:\n            time.sleep(2)\n\n        print(\"Internal API server not online (mostly because Ganga is booting up), retrying...\")\n        trials += 1\n        if trials > 20:\n            return False\n\n\ndef start_ganga(internal_port: int, args: str = \"\"):\n    \"\"\"\n    Start a ganga session in a pseudo terminal and stores the file descriptor of the terminal as well as the PID of the ganga session.\n    :param args: str - str of arguments to provide to ganga\n    :param internal_port: int\n    \"\"\"\n\n    # Create child process attached to a pty that we can read from and write to\n    (child_pid, fd) = pty.fork()\n\n    if child_pid == 0:\n        # This is the child process fork. Anything printed here will show up in the pty, including the output of this subprocess\n        ganga_env = os.environ.copy()\n        ganga_env[\"WEB_CLI\"] = \"True\"\n        ganga_env[\"INTERNAL_PORT\"] = str(internal_port)\n        subprocess.run(f\"ganga --webgui {args}\", shell=True, env=ganga_env)\n    else:\n        # This is the parent process fork. Store fd (connected to the child\u2019s controlling terminal) and child pid\n        gui.config[\"FD\"] = fd\n        gui.config[\"CHILD_PID\"] = child_pid\n        set_windowsize(fd, 50, 50)\n        print(\"Ganga started, PID: \", child_pid)\n\n\n# Set the window size of the pseudo terminal according to the size in the frontend\ndef set_windowsize(fd, row, col, xpix=0, ypix=0):\n    winsize = struct.pack(\"HHHH\", row, col, xpix, ypix)\n    fcntl.ioctl(fd, termios.TIOCSWINSZ, winsize)\n\n\n# Read and forward that data from the pseudo terminal to the frontend\ndef read_and_forward_pty_output():\n    max_read_bytes = 1024 * 20\n    while True:\n        socketio.sleep(0.01)\n        if gui.config[\"FD\"]:\n            timeout_sec = 0\n            (data_ready, _, _) = select.select([gui.config[\"FD\"]], [], [], timeout_sec)\n            if data_ready:\n                output = os.read(gui.config[\"FD\"], max_read_bytes).decode()\n                socketio.emit(\"pty-output\", {\"output\": output}, namespace=\"/pty\")\n\n\ndef start_web_cli(host: str, port: int, internal_port: int, log_output=True, ganga_args: str = \"\"):\n    \"\"\"\n    Start the web server on eventlet serving the terminal on the specified port. (Production ready server)\n    :param ganga_args: str - arguments to be passed to ganga\n    :param host: str\n    :param port: int\n    :param internal_port: int\n    \"\"\"\n\n    from GangaGUI.start import create_default_user\n\n    # Create default user\n    gui_user, gui_password = create_default_user()\n\n    print(f\"Starting the GUI server on http://{host}:{port}\")\n    print(f\"You login information for the GUI is: Username: {gui_user.user} Password: {gui_password}\")\n\n    gui.config[\"INTERNAL_PORT\"] = internal_port\n    gui.config[\"WEB_CLI\"] = True\n    gui.config[\"GANGA_ARGS\"] = ganga_args\n    socketio.run(gui, host=host, port=port, log_output=log_output)  # TODO\n\n\n# ******************** Shutdown Function ******************** #\n\n# Route used to shutdown the Internal API server and GUI server\n@gui.route(\"/shutdown\", methods=[\"GET\"])\ndef shutdown():\n\n    if gui.config[\"WEB_CLI\"] is True:\n        flash(\"WEB CLI Mode is on, cannot self shutdown server. Consider doing manually.\", \"warning\")\n        return redirect(url_for(\"dashboard\"))\n\n    try:\n        response_info = query_internal_api(\"/shutdown\", \"get\")\n    except Exception as err:\n        return jsonify({\"success\": False, \"message\": str(err)}), 400\n\n    return \"GUI Shutdown Successful.\"\n\n# ******************** EOF ******************** #\n"], "filenames": ["ganga/GangaGUI/gui/routes.py"], "buggy_code_start_loc": [15], "buggy_code_end_loc": [660], "fixing_code_start_loc": [15], "fixing_code_end_loc": [660], "type": "CWE-22", "message": "The ganga-devs/ganga repository before 8.5.10 on GitHub allows absolute path traversal because the Flask send_file function is used unsafely.", "other": {"cve": {"id": "CVE-2022-31507", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-11T01:15:08.293", "lastModified": "2022-07-15T11:49:55.480", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ganga-devs/ganga repository before 8.5.10 on GitHub allows absolute path traversal because the Flask send_file function is used unsafely."}, {"lang": "es", "value": "El repositorio ganga-devs/ganga versiones anteriores a 8.5.10 en GitHub, permite un salto de ruta absoluto porque la funci\u00f3n send_file de Flask es usada de forma no segura"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ganga_project:ganga:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.5.10", "matchCriteriaId": "42E110D6-338D-490D-8886-8A9564B0A072"}]}]}], "references": [{"url": "https://github.com/ganga-devs/ganga/commit/730e7aba192407d35eb37dd7938d49071124be8c", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ganga-devs/ganga/releases/tag/8.5.10", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/github/securitylab/issues/669#issuecomment-1117265726", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ganga-devs/ganga/commit/730e7aba192407d35eb37dd7938d49071124be8c"}}