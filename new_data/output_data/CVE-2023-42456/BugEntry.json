{"buggy_code": ["#![forbid(unsafe_code)]\n\nuse crate::cli::{help, SudoAction, SudoOptions};\nuse crate::common::{resolve::resolve_current_user, Context, Error};\nuse crate::log::dev_info;\nuse crate::system::timestamp::RecordScope;\nuse crate::system::User;\nuse crate::system::{time::Duration, timestamp::SessionRecordFile, Process};\nuse pam::PamAuthenticator;\nuse pipeline::{Pipeline, PolicyPlugin};\nuse std::env;\nuse std::path::Path;\n\nmod diagnostic;\nmod pam;\nmod pipeline;\n\nconst VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n\nfn candidate_sudoers_file() -> &'static Path {\n    let pb_rs: &'static Path = Path::new(\"/etc/sudoers-rs\");\n    if pb_rs.exists() {\n        dev_info!(\"Running with /etc/sudoers-rs file\");\n        pb_rs\n    } else {\n        dev_info!(\"Running with /etc/sudoers file\");\n        Path::new(\"/etc/sudoers\")\n    }\n}\n\n#[derive(Default)]\npub(crate) struct SudoersPolicy {}\n\nimpl PolicyPlugin for SudoersPolicy {\n    type PreJudgementPolicy = crate::sudoers::Sudoers;\n    type Policy = crate::sudoers::Judgement;\n\n    fn init(&mut self) -> Result<Self::PreJudgementPolicy, Error> {\n        let sudoers_path = candidate_sudoers_file();\n\n        let (sudoers, syntax_errors) = crate::sudoers::Sudoers::open(sudoers_path)\n            .map_err(|e| Error::Configuration(format!(\"{e}\")))?;\n\n        for crate::sudoers::Error(pos, error) in syntax_errors {\n            diagnostic::diagnostic!(\"{error}\", sudoers_path @ pos);\n        }\n\n        Ok(sudoers)\n    }\n\n    fn judge(\n        &mut self,\n        pre: Self::PreJudgementPolicy,\n        context: &Context,\n    ) -> Result<Self::Policy, Error> {\n        Ok(pre.check(\n            &context.current_user,\n            &context.hostname,\n            crate::sudoers::Request {\n                user: &context.target_user,\n                group: &context.target_group,\n                command: &context.command.command,\n                arguments: &context.command.arguments,\n            },\n        ))\n    }\n}\n\nfn sudo_process() -> Result<(), Error> {\n    crate::log::SudoLogger::new(\"sudo: \").into_global_logger();\n\n    dev_info!(\"development logs are enabled\");\n\n    self_check()?;\n\n    let pipeline = Pipeline {\n        policy: SudoersPolicy::default(),\n        authenticator: PamAuthenticator::new_cli(),\n    };\n\n    // parse cli options\n    match SudoOptions::from_env() {\n        Ok(options) => match options.action {\n            SudoAction::Help => {\n                eprintln_ignore_io_error!(\"{}\", help::long_help_message());\n                std::process::exit(0);\n            }\n            SudoAction::Version => {\n                eprintln_ignore_io_error!(\"sudo-rs {VERSION}\");\n                std::process::exit(0);\n            }\n            SudoAction::RemoveTimestamp => {\n                let user = resolve_current_user()?;\n                let mut record_file =\n                    SessionRecordFile::open_for_user(&user.name, Duration::seconds(0))?;\n                record_file.reset()?;\n                Ok(())\n            }\n            SudoAction::ResetTimestamp => {\n                if let Some(scope) = RecordScope::for_process(&Process::new()) {\n                    let user = resolve_current_user()?;\n                    let mut record_file =\n                        SessionRecordFile::open_for_user(&user.name, Duration::seconds(0))?;\n                    record_file.disable(scope, None)?;\n                }\n                Ok(())\n            }\n            SudoAction::Validate => pipeline.run_validate(options),\n            SudoAction::Run(ref cmd) => {\n                // special case for when no command is given\n                if cmd.is_empty() && !options.shell && !options.login {\n                    eprintln_ignore_io_error!(\"{}\", help::USAGE_MSG);\n                    std::process::exit(1);\n                } else {\n                    pipeline.run(options)\n                }\n            }\n            SudoAction::List(_) => pipeline.run_list(options),\n            SudoAction::Edit(_) => {\n                unimplemented!();\n            }\n        },\n        Err(e) => {\n            eprintln_ignore_io_error!(\"{e}\\n{}\", help::USAGE_MSG);\n            std::process::exit(1);\n        }\n    }\n}\n\nfn self_check() -> Result<(), Error> {\n    const ROOT: u32 = 0;\n\n    let euid = User::effective_uid();\n    if euid == ROOT {\n        Ok(())\n    } else {\n        Err(Error::SelfCheck)\n    }\n}\n\npub fn main() {\n    match sudo_process() {\n        Ok(()) => (),\n        Err(error) => {\n            if !error.is_silent() {\n                diagnostic::diagnostic!(\"{error}\");\n            }\n            std::process::exit(1);\n        }\n    }\n}\n", "use std::ffi::OsStr;\nuse std::process::exit;\n\nuse crate::cli::SudoOptions;\nuse crate::common::{resolve::expand_tilde_in_path, Context, Environment, Error};\nuse crate::env::environment;\nuse crate::exec::{ExecOutput, ExitReason};\nuse crate::log::{auth_info, auth_warn};\nuse crate::sudo::Duration;\nuse crate::sudoers::{Authorization, AuthorizationAllowed, DirChange, Policy, PreJudgementPolicy};\nuse crate::system::interface::UserId;\nuse crate::system::term::current_tty_name;\nuse crate::system::timestamp::{RecordScope, SessionRecordFile, TouchResult};\nuse crate::system::{escape_os_str_lossy, Process};\n\nmod list;\n\npub trait PolicyPlugin {\n    type PreJudgementPolicy: PreJudgementPolicy;\n    type Policy: Policy;\n\n    fn init(&mut self) -> Result<Self::PreJudgementPolicy, Error>;\n    fn judge(\n        &mut self,\n        pre: Self::PreJudgementPolicy,\n        context: &Context,\n    ) -> Result<Self::Policy, Error>;\n}\n\npub trait AuthPlugin {\n    fn init(&mut self, context: &Context) -> Result<(), Error>;\n    fn authenticate(&mut self, non_interactive: bool, max_tries: u16) -> Result<(), Error>;\n    fn pre_exec(&mut self, target_user: &str) -> Result<Environment, Error>;\n    fn cleanup(&mut self);\n}\n\npub struct Pipeline<Policy: PolicyPlugin, Auth: AuthPlugin> {\n    pub policy: Policy,\n    pub authenticator: Auth,\n}\n\nimpl<Policy: PolicyPlugin, Auth: AuthPlugin> Pipeline<Policy, Auth> {\n    pub fn run(mut self, cmd_opts: SudoOptions) -> Result<(), Error> {\n        let pre = self.policy.init()?;\n        let mut context = build_context(cmd_opts, &pre)?;\n\n        let policy = self.policy.judge(pre, &context)?;\n        let authorization = policy.authorization();\n\n        match authorization {\n            Authorization::Forbidden => {\n                return Err(Error::auth(&format!(\n                    \"I'm sorry {}. I'm afraid I can't do that\",\n                    context.current_user.name\n                )));\n            }\n            Authorization::Allowed(auth) => {\n                self.apply_policy_to_context(&mut context, &policy)?;\n                self.auth_and_update_record_file(&context, auth)?;\n            }\n        }\n\n        let additional_env = self.authenticator.pre_exec(&context.target_user.name)?;\n\n        // build environment\n        let current_env = std::env::vars_os().collect();\n        let target_env =\n            environment::get_target_environment(current_env, additional_env, &context, &policy);\n\n        let pid = context.process.pid;\n\n        // run command and return corresponding exit code\n        let exec_result = if context.command.resolved {\n            log_command_execution(&context);\n\n            crate::exec::run_command(&context, target_env)\n                .map_err(|io_error| Error::IoError(Some(context.command.command), io_error))\n        } else {\n            Err(Error::CommandNotFound(context.command.command))\n        };\n\n        self.authenticator.cleanup();\n\n        let ExecOutput {\n            command_exit_reason,\n            restore_signal_handlers,\n        } = exec_result?;\n\n        // Run any clean-up code before this line.\n        restore_signal_handlers();\n\n        match command_exit_reason {\n            ExitReason::Code(code) => exit(code),\n            ExitReason::Signal(signal) => {\n                crate::system::kill(pid, signal)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn run_validate(mut self, cmd_opts: SudoOptions) -> Result<(), Error> {\n        let pre = self.policy.init()?;\n        let context = build_context(cmd_opts, &pre)?;\n\n        match pre.validate_authorization() {\n            Authorization::Forbidden => {\n                return Err(Error::auth(&format!(\n                    \"I'm sorry {}. I'm afraid I can't do that\",\n                    context.current_user.name\n                )));\n            }\n            Authorization::Allowed(auth) => {\n                self.auth_and_update_record_file(&context, auth)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn auth_and_update_record_file(\n        &mut self,\n        context: &Context,\n        AuthorizationAllowed {\n            must_authenticate,\n            prior_validity,\n            allowed_attempts,\n        }: AuthorizationAllowed,\n    ) -> Result<(), Error> {\n        let scope = RecordScope::for_process(&Process::new());\n        let mut auth_status = determine_auth_status(\n            must_authenticate,\n            context.use_session_records,\n            scope,\n            context.current_user.uid,\n            &context.current_user.name,\n            prior_validity,\n        );\n        self.authenticator.init(context)?;\n        if auth_status.must_authenticate {\n            self.authenticator\n                .authenticate(context.non_interactive, allowed_attempts)?;\n            if let (Some(record_file), Some(scope)) = (&mut auth_status.record_file, scope) {\n                match record_file.create(scope, context.current_user.uid) {\n                    Ok(_) => (),\n                    Err(e) => {\n                        auth_warn!(\"Could not update session record file with new record: {e}\");\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn apply_policy_to_context(\n        &mut self,\n        context: &mut Context,\n        policy: &<Policy as PolicyPlugin>::Policy,\n    ) -> Result<(), crate::common::Error> {\n        // see if the chdir flag is permitted\n        match policy.chdir() {\n            DirChange::Any => {}\n            DirChange::Strict(optdir) => {\n                if context.chdir.is_some() {\n                    return Err(Error::ChDirNotAllowed {\n                        chdir: context.chdir.clone().unwrap(),\n                        command: context.command.command.clone(),\n                    });\n                } else {\n                    context.chdir = optdir.map(std::path::PathBuf::from)\n                }\n            }\n        }\n\n        // expand tildes in the path with the users home directory\n        if let Some(dir) = context.chdir.take() {\n            context.chdir = Some(expand_tilde_in_path(&context.target_user.name, dir)?)\n        }\n\n        // override the default pty behaviour if indicated\n        if !policy.use_pty() {\n            context.use_pty = false\n        }\n\n        Ok(())\n    }\n}\n\nfn build_context(cmd_opts: SudoOptions, pre: &dyn PreJudgementPolicy) -> Result<Context, Error> {\n    let secure_path: String = pre\n        .secure_path()\n        .unwrap_or_else(|| std::env::var(\"PATH\").unwrap_or_default());\n    Context::build_from_options(cmd_opts, secure_path)\n}\n\n/// This should determine what the authentication status for the given record\n/// match limit and origin/target user from the context is.\nfn determine_auth_status(\n    must_policy_authenticate: bool,\n    use_session_records: bool,\n    record_for: Option<RecordScope>,\n    auth_uid: UserId,\n    current_user: &str,\n    prior_validity: Duration,\n) -> AuthStatus {\n    if !must_policy_authenticate {\n        AuthStatus::new(false, None)\n    } else if let (true, Some(record_for)) = (use_session_records, record_for) {\n        match SessionRecordFile::open_for_user(current_user, prior_validity) {\n            Ok(mut sr) => {\n                match sr.touch(record_for, auth_uid) {\n                    // if a record was found and updated within the timeout, we do not need to authenticate\n                    Ok(TouchResult::Updated { .. }) => AuthStatus::new(false, Some(sr)),\n                    Ok(TouchResult::NotFound | TouchResult::Outdated { .. }) => {\n                        AuthStatus::new(true, Some(sr))\n                    }\n                    Err(e) => {\n                        auth_warn!(\"Unexpected error while reading session information: {e}\");\n                        AuthStatus::new(true, None)\n                    }\n                }\n            }\n            // if we cannot open the session record file we just assume there is none and continue as normal\n            Err(e) => {\n                auth_warn!(\"Could not use session information: {e}\");\n                AuthStatus::new(true, None)\n            }\n        }\n    } else {\n        AuthStatus::new(true, None)\n    }\n}\n\nstruct AuthStatus<'a> {\n    must_authenticate: bool,\n    record_file: Option<SessionRecordFile<'a>>,\n}\n\nimpl<'a> AuthStatus<'a> {\n    fn new(must_authenticate: bool, record_file: Option<SessionRecordFile<'a>>) -> AuthStatus<'a> {\n        AuthStatus {\n            must_authenticate,\n            record_file,\n        }\n    }\n}\n\nfn log_command_execution(context: &Context) {\n    let tty_info = if let Ok(tty_name) = current_tty_name() {\n        format!(\"TTY={} ;\", escape_os_str_lossy(&tty_name))\n    } else {\n        String::from(\"\")\n    };\n    let pwd = escape_os_str_lossy(\n        std::env::current_dir()\n            .as_ref()\n            .map(|s| s.as_os_str())\n            .unwrap_or_else(|_| OsStr::new(\"unknown\")),\n    );\n    let user = context.target_user.name.escape_debug().collect::<String>();\n    auth_info!(\n        \"{} : {} PWD={} ; USER={} ; COMMAND={}\",\n        &context.current_user.name,\n        tty_info,\n        pwd,\n        user,\n        &context.command\n    );\n}\n", "use std::{\n    fs::File,\n    io::{self, Cursor, Read, Seek, Write},\n    path::PathBuf,\n};\n\nuse crate::log::{auth_info, auth_warn};\n\nuse super::{\n    audit::secure_open_cookie_file,\n    file::FileLock,\n    interface::UserId,\n    time::{Duration, SystemTime},\n    Process, WithProcess,\n};\n\n/// Truncates or extends the underlying data\npub trait SetLength {\n    /// After this is called, the underlying data will either be truncated\n    /// up to new_len bytes, or it will have been extended by zero bytes up to\n    /// new_len.\n    fn set_len(&mut self, new_len: usize) -> io::Result<()>;\n}\n\nimpl SetLength for File {\n    fn set_len(&mut self, new_len: usize) -> io::Result<()> {\n        File::set_len(self, new_len as u64)\n    }\n}\n\ntype BoolStorage = u8;\n\nconst SIZE_OF_TS: i64 = std::mem::size_of::<SystemTime>() as i64;\nconst SIZE_OF_BOOL: i64 = std::mem::size_of::<BoolStorage>() as i64;\nconst MOD_OFFSET: i64 = SIZE_OF_TS + SIZE_OF_BOOL;\n\n#[derive(Debug)]\npub struct SessionRecordFile<'u> {\n    file: File,\n    timeout: Duration,\n    for_user: &'u str,\n}\n\nimpl<'u> SessionRecordFile<'u> {\n    const BASE_PATH: &'static str = \"/var/run/sudo-rs/ts\";\n\n    pub fn open_for_user(user: &'u str, timeout: Duration) -> io::Result<Self> {\n        let mut path = PathBuf::from(Self::BASE_PATH);\n        path.push(user);\n        SessionRecordFile::new(user, secure_open_cookie_file(&path)?, timeout)\n    }\n\n    const FILE_VERSION: u16 = 1;\n    const MAGIC_NUM: u16 = 0x50D0;\n    const VERSION_OFFSET: u64 = Self::MAGIC_NUM.to_le_bytes().len() as u64;\n    const FIRST_RECORD_OFFSET: u64 =\n        Self::VERSION_OFFSET + Self::FILE_VERSION.to_le_bytes().len() as u64;\n\n    /// Create a new SessionRecordFile from the given i/o stream.\n    /// Timestamps in this file are considered valid if they were created or\n    /// updated at most `timeout` time ago.\n    pub fn new(for_user: &'u str, io: File, timeout: Duration) -> io::Result<Self> {\n        let mut session_records = SessionRecordFile {\n            file: io,\n            timeout,\n            for_user,\n        };\n\n        // match the magic number, otherwise reset the file\n        match session_records.read_magic()? {\n            Some(magic) if magic == Self::MAGIC_NUM => (),\n            x => {\n                if let Some(_magic) = x {\n                    auth_info!(\"Session records file for user '{for_user}' is invalid, resetting\");\n                }\n\n                session_records.init(Self::VERSION_OFFSET)?;\n            }\n        }\n\n        // match the file version\n        match session_records.read_version()? {\n            Some(v) if v == Self::FILE_VERSION => (),\n            x => {\n                if let Some(v) = x {\n                    auth_info!(\"Session records file for user '{for_user}' has invalid version {v}, only file version {} is supported, resetting\", Self::FILE_VERSION);\n                } else {\n                    auth_info!(\n                        \"Session records file did not contain file version information, resetting\"\n                    );\n                }\n\n                session_records.init(Self::FIRST_RECORD_OFFSET)?;\n            }\n        }\n\n        // we are ready to read records\n        Ok(session_records)\n    }\n\n    /// Read the magic number from the input stream\n    fn read_magic(&mut self) -> io::Result<Option<u16>> {\n        let mut magic_bytes = [0; std::mem::size_of::<u16>()];\n        match self.file.read_exact(&mut magic_bytes) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => Ok(None),\n            Err(e) => Err(e),\n            Ok(()) => Ok(Some(u16::from_le_bytes(magic_bytes))),\n        }\n    }\n\n    /// Read the version number from the input stream\n    fn read_version(&mut self) -> io::Result<Option<u16>> {\n        let mut version_bytes = [0; std::mem::size_of::<u16>()];\n        match self.file.read_exact(&mut version_bytes) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => Ok(None),\n            Err(e) => Err(e),\n            Ok(()) => Ok(Some(u16::from_le_bytes(version_bytes))),\n        }\n    }\n\n    /// Initialize a new empty stream. If the stream/file was already filled\n    /// before it will be truncated.\n    fn init(&mut self, offset: u64) -> io::Result<()> {\n        // lock the file to indicate that we are currently writing to it\n        let lock = FileLock::exclusive(&self.file, false)?;\n\n        self.file.set_len(0)?;\n        self.file.rewind()?;\n        self.file.write_all(&Self::MAGIC_NUM.to_le_bytes())?;\n        self.file.write_all(&Self::FILE_VERSION.to_le_bytes())?;\n        self.file.seek(io::SeekFrom::Start(offset))?;\n\n        lock.unlock()?;\n\n        Ok(())\n    }\n\n    /// Read the next record and keep note of the start and end positions in the file of that record\n    ///\n    /// This method assumes that the file is already exclusively locked.\n    fn next_record(&mut self) -> io::Result<Option<SessionRecord>> {\n        // record the position at which this record starts (including size bytes)\n        let mut record_length_bytes = [0; std::mem::size_of::<u16>()];\n\n        let curr_pos = self.file.stream_position()?;\n\n        // if eof occurs here we assume we reached the end of the file\n        let record_length = match self.file.read_exact(&mut record_length_bytes) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => return Ok(None),\n            Err(e) => return Err(e),\n            Ok(()) => u16::from_le_bytes(record_length_bytes),\n        };\n\n        // special case when record_length is zero\n        if record_length == 0 {\n            return Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"Found empty record\",\n            ));\n        }\n\n        let mut buf = vec![0; record_length as usize];\n        match self.file.read_exact(&mut buf) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => {\n                // there was half a record here, we clear the rest of the file\n                auth_info!(\"Found incomplete record in session records file for {}, clearing rest of the file\", self.for_user);\n                self.file.set_len(curr_pos)?;\n                return Ok(None);\n            }\n            Err(e) => return Err(e),\n            Ok(()) => (),\n        }\n\n        // we now try and decode the data read into a session record\n        match SessionRecord::from_bytes(&buf) {\n            Err(_) => {\n                // any error assumes that this file is nonsense from this point\n                // onwards, so we clear the file up to the start of this record\n                auth_info!(\"Found invalid record in session records file for {}, clearing rest of the file\", self.for_user);\n\n                self.file.set_len(curr_pos)?;\n                Ok(None)\n            }\n            Ok(record) => Ok(Some(record)),\n        }\n    }\n\n    /// Try and find a record for the given scope and auth user id and update\n    /// that record time to the current time. This will not create a new record\n    /// when one is not found. A record will only be updated if it is still\n    /// valid at this time.\n    pub fn touch(&mut self, scope: RecordScope, auth_user: UserId) -> io::Result<TouchResult> {\n        // lock the file to indicate that we are currently in a writing operation\n        let lock = FileLock::exclusive(&self.file, false)?;\n        self.seek_to_first_record()?;\n        while let Some(record) = self.next_record()? {\n            // only touch if record is enabled\n            if record.enabled && record.matches(&scope, auth_user) {\n                let now = SystemTime::now()?;\n                if record.written_between(now - self.timeout, now) {\n                    // move back to where the timestamp is and overwrite with the latest time\n                    self.file.seek(io::SeekFrom::Current(-MOD_OFFSET))?;\n                    let new_time = SystemTime::now()?;\n                    new_time.encode(&mut self.file)?;\n\n                    // make sure we can still go to the end of the record\n                    self.file.seek(io::SeekFrom::Current(SIZE_OF_BOOL))?;\n\n                    // writing is done, unlock and return\n                    lock.unlock()?;\n                    return Ok(TouchResult::Updated {\n                        old_time: record.timestamp,\n                        new_time,\n                    });\n                } else {\n                    lock.unlock()?;\n                    return Ok(TouchResult::Outdated {\n                        time: record.timestamp,\n                    });\n                }\n            }\n        }\n\n        lock.unlock()?;\n        Ok(TouchResult::NotFound)\n    }\n\n    /// Disable all records that match the given scope. If an auth user id is\n    /// given then only records with the given scope that are targetting that\n    /// specific user will be disabled.\n    pub fn disable(&mut self, scope: RecordScope, auth_user: Option<UserId>) -> io::Result<()> {\n        let lock = FileLock::exclusive(&self.file, false)?;\n        self.seek_to_first_record()?;\n        while let Some(record) = self.next_record()? {\n            let must_disable = auth_user\n                .map(|tu| record.matches(&scope, tu))\n                .unwrap_or_else(|| record.scope == scope);\n            if must_disable {\n                self.file.seek(io::SeekFrom::Current(-SIZE_OF_BOOL))?;\n                write_bool(false, &mut self.file)?;\n            }\n        }\n        lock.unlock()?;\n        Ok(())\n    }\n\n    /// Create a new record for the given scope and auth user id.\n    /// If there is an existing record that matches the scope and auth user,\n    /// then that record will be updated.\n    pub fn create(&mut self, scope: RecordScope, auth_user: UserId) -> io::Result<CreateResult> {\n        // lock the file to indicate that we are currently writing to it\n        let lock = FileLock::exclusive(&self.file, false)?;\n        self.seek_to_first_record()?;\n        while let Some(record) = self.next_record()? {\n            if record.matches(&scope, auth_user) {\n                self.file.seek(io::SeekFrom::Current(-MOD_OFFSET))?;\n                let new_time = SystemTime::now()?;\n                new_time.encode(&mut self.file)?;\n                write_bool(true, &mut self.file)?;\n                lock.unlock()?;\n                return Ok(CreateResult::Updated {\n                    old_time: record.timestamp,\n                    new_time,\n                });\n            }\n        }\n\n        // record was not found in the list so far, create a new one\n        let record = SessionRecord::new(scope, auth_user)?;\n\n        // make sure we really are at the end of the file\n        self.file.seek(io::SeekFrom::End(0))?;\n\n        self.write_record(&record)?;\n        lock.unlock()?;\n\n        Ok(CreateResult::Created {\n            time: record.timestamp,\n        })\n    }\n\n    /// Completely resets the entire file and removes all records.\n    pub fn reset(&mut self) -> io::Result<()> {\n        self.init(0)\n    }\n\n    /// Write a new record at the current position in the file.\n    fn write_record(&mut self, record: &SessionRecord) -> io::Result<()> {\n        // convert the new record to byte representation and make sure that it fits\n        let bytes = record.as_bytes()?;\n        let record_length = bytes.len();\n        if record_length > u16::MAX as usize {\n            return Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"A record with an unexpectedly large size was created\",\n            ));\n        }\n        let record_length = record_length as u16; // store as u16\n\n        // write the record\n        self.file.write_all(&record_length.to_le_bytes())?;\n        self.file.write_all(&bytes)?;\n\n        Ok(())\n    }\n\n    /// Move to where the first record starts.\n    fn seek_to_first_record(&mut self) -> io::Result<()> {\n        self.file\n            .seek(io::SeekFrom::Start(Self::FIRST_RECORD_OFFSET))?;\n        Ok(())\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum TouchResult {\n    /// The record was found and within the timeout, and it was refreshed\n    Updated {\n        old_time: SystemTime,\n        new_time: SystemTime,\n    },\n    /// A record was found, but it was no longer valid\n    Outdated { time: SystemTime },\n    /// A record was not found that matches the input\n    NotFound,\n}\n\npub enum CreateResult {\n    /// The record was found and it was refreshed\n    Updated {\n        old_time: SystemTime,\n        new_time: SystemTime,\n    },\n    /// A new record was created and was set to the time returned\n    Created { time: SystemTime },\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum RecordScope {\n    Tty {\n        tty_device: libc::dev_t,\n        session_pid: libc::pid_t,\n        init_time: SystemTime,\n    },\n    Ppid {\n        group_pid: libc::pid_t,\n        init_time: SystemTime,\n    },\n}\n\nimpl RecordScope {\n    fn encode(&self, target: &mut impl Write) -> std::io::Result<()> {\n        match self {\n            RecordScope::Tty {\n                tty_device,\n                session_pid,\n                init_time,\n            } => {\n                target.write_all(&[1u8])?;\n                let b = tty_device.to_le_bytes();\n                target.write_all(&b)?;\n                let b = session_pid.to_le_bytes();\n                target.write_all(&b)?;\n                init_time.encode(target)?;\n            }\n            RecordScope::Ppid {\n                group_pid,\n                init_time,\n            } => {\n                target.write_all(&[2u8])?;\n                let b = group_pid.to_le_bytes();\n                target.write_all(&b)?;\n                init_time.encode(target)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn decode(from: &mut impl Read) -> std::io::Result<RecordScope> {\n        let mut buf = [0; 1];\n        from.read_exact(&mut buf)?;\n        match buf[0] {\n            1 => {\n                let mut buf = [0; std::mem::size_of::<libc::dev_t>()];\n                from.read_exact(&mut buf)?;\n                let tty_device = libc::dev_t::from_le_bytes(buf);\n                let mut buf = [0; std::mem::size_of::<libc::pid_t>()];\n                from.read_exact(&mut buf)?;\n                let session_pid = libc::pid_t::from_le_bytes(buf);\n                let init_time = SystemTime::decode(from)?;\n                Ok(RecordScope::Tty {\n                    tty_device,\n                    session_pid,\n                    init_time,\n                })\n            }\n            2 => {\n                let mut buf = [0; std::mem::size_of::<libc::pid_t>()];\n                from.read_exact(&mut buf)?;\n                let group_pid = libc::pid_t::from_le_bytes(buf);\n                let init_time = SystemTime::decode(from)?;\n                Ok(RecordScope::Ppid {\n                    group_pid,\n                    init_time,\n                })\n            }\n            x => Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                format!(\"Unexpected scope variant discriminator: {x}\"),\n            )),\n        }\n    }\n\n    /// Tries to determine a record match scope for the current context.\n    /// This should never produce an error since any actual error should just be\n    /// ignored and no session record file should be used in that case.\n    pub fn for_process(process: &Process) -> Option<RecordScope> {\n        let tty = Process::tty_device_id(WithProcess::Current);\n        if let Ok(Some(tty_device)) = tty {\n            if let Ok(init_time) = Process::starting_time(WithProcess::Other(process.session_id)) {\n                Some(RecordScope::Tty {\n                    tty_device,\n                    session_pid: process.session_id,\n                    init_time,\n                })\n            } else {\n                auth_warn!(\"Could not get terminal foreground process starting time\");\n                None\n            }\n        } else if let Some(parent_pid) = process.parent_pid {\n            if let Ok(init_time) = Process::starting_time(WithProcess::Other(parent_pid)) {\n                Some(RecordScope::Ppid {\n                    group_pid: parent_pid,\n                    init_time,\n                })\n            } else {\n                auth_warn!(\"Could not get parent process starting time\");\n                None\n            }\n        } else {\n            None\n        }\n    }\n}\n\nfn write_bool(b: bool, target: &mut impl Write) -> io::Result<()> {\n    let s: BoolStorage = if b { 0xFF } else { 0x00 };\n    let bytes = s.to_le_bytes();\n    target.write_all(&bytes)?;\n    Ok(())\n}\n\n/// A record in the session record file\n#[derive(Debug, PartialEq, Eq)]\npub struct SessionRecord {\n    /// The scope for which the current record applies, i.e. what process group\n    /// or which TTY for interactive sessions\n    scope: RecordScope,\n    /// The user that needs to be authenticated against\n    auth_user: libc::uid_t,\n    /// The timestamp at which the time was created. This must always be a time\n    /// originating from a monotonic clock that continues counting during system\n    /// sleep.\n    timestamp: SystemTime,\n    /// Disabled records act as if they do not exist, but their storage can\n    /// be re-used when recreating for the same scope and auth user\n    enabled: bool,\n}\n\nimpl SessionRecord {\n    /// Create a new record that is scoped to the specified scope and has `auth_user` as\n    /// the target for authentication for the session.\n    fn new(scope: RecordScope, auth_user: UserId) -> io::Result<SessionRecord> {\n        Ok(Self::init(scope, auth_user, true, SystemTime::now()?))\n    }\n\n    /// Initialize a new record with the given parameters\n    fn init(\n        scope: RecordScope,\n        auth_user: UserId,\n        enabled: bool,\n        timestamp: SystemTime,\n    ) -> SessionRecord {\n        SessionRecord {\n            scope,\n            auth_user,\n            timestamp,\n            enabled,\n        }\n    }\n\n    /// Encode a record into the given stream\n    fn encode(&self, target: &mut impl Write) -> std::io::Result<()> {\n        self.scope.encode(target)?;\n\n        // write user id\n        let buf = self.auth_user.to_le_bytes();\n        target.write_all(&buf)?;\n\n        // write timestamp\n        self.timestamp.encode(target)?;\n\n        // write enabled boolean\n        write_bool(self.enabled, target)?;\n\n        Ok(())\n    }\n\n    /// Decode a record from the given stream\n    fn decode(from: &mut impl Read) -> std::io::Result<SessionRecord> {\n        let scope = RecordScope::decode(from)?;\n\n        // auth user id\n        let mut buf = [0; std::mem::size_of::<libc::uid_t>()];\n        from.read_exact(&mut buf)?;\n        let auth_user = libc::uid_t::from_le_bytes(buf);\n\n        // timestamp\n        let timestamp = SystemTime::decode(from)?;\n\n        // enabled boolean\n        let mut buf = [0; std::mem::size_of::<BoolStorage>()];\n        from.read_exact(&mut buf)?;\n        let enabled = match BoolStorage::from_le_bytes(buf) {\n            0xFF => true,\n            0x00 => false,\n            _ => {\n                return Err(io::Error::new(\n                    io::ErrorKind::InvalidData,\n                    \"Invalid boolean value detected in input stream\",\n                ))\n            }\n        };\n\n        Ok(SessionRecord::init(scope, auth_user, enabled, timestamp))\n    }\n\n    /// Convert the record to a vector of bytes for storage.\n    pub fn as_bytes(&self) -> std::io::Result<Vec<u8>> {\n        let mut v = vec![];\n        self.encode(&mut v)?;\n        Ok(v)\n    }\n\n    /// Convert the given byte slice to a session record, the byte slice must\n    /// be fully consumed for this conversion to be valid.\n    pub fn from_bytes(data: &[u8]) -> std::io::Result<SessionRecord> {\n        let mut cursor = Cursor::new(data);\n        let record = SessionRecord::decode(&mut cursor)?;\n        if cursor.position() != data.len() as u64 {\n            Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"Record size and record length did not match\",\n            ))\n        } else {\n            Ok(record)\n        }\n    }\n\n    /// Returns true if this record matches the specified scope and is for the\n    /// specified target auth user.\n    pub fn matches(&self, scope: &RecordScope, auth_user: UserId) -> bool {\n        self.scope == *scope && self.auth_user == auth_user\n    }\n\n    /// Returns true if this record was written somewhere in the time range\n    /// between `early_time` (inclusive) and `later_time` (inclusive), where\n    /// early timestamp may not be later than the later timestamp.\n    pub fn written_between(&self, early_time: SystemTime, later_time: SystemTime) -> bool {\n        early_time <= later_time && self.timestamp >= early_time && self.timestamp <= later_time\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use crate::system::tests::tempfile;\n\n    impl SetLength for Cursor<Vec<u8>> {\n        fn set_len(&mut self, new_len: usize) -> io::Result<()> {\n            self.get_mut().truncate(new_len);\n            while self.get_mut().len() < new_len {\n                self.get_mut().push(0);\n            }\n            Ok(())\n        }\n    }\n\n    impl SetLength for Cursor<&mut Vec<u8>> {\n        fn set_len(&mut self, new_len: usize) -> io::Result<()> {\n            self.get_mut().truncate(new_len);\n            while self.get_mut().len() < new_len {\n                self.get_mut().push(0);\n            }\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn can_encode_and_decode() {\n        let tty_sample = SessionRecord::new(\n            RecordScope::Tty {\n                tty_device: 10,\n                session_pid: 42,\n                init_time: SystemTime::now().unwrap() - Duration::seconds(150),\n            },\n            999,\n        )\n        .unwrap();\n\n        let mut bytes = tty_sample.as_bytes().unwrap();\n        let decoded = SessionRecord::from_bytes(&bytes).unwrap();\n        assert_eq!(tty_sample, decoded);\n\n        // we provide some invalid input\n        assert!(SessionRecord::from_bytes(&bytes[1..]).is_err());\n\n        // we have remaining input after decoding\n        bytes.push(0);\n        assert!(SessionRecord::from_bytes(&bytes).is_err());\n\n        let ppid_sample = SessionRecord::new(\n            RecordScope::Ppid {\n                group_pid: 42,\n                init_time: SystemTime::now().unwrap(),\n            },\n            123,\n        )\n        .unwrap();\n        let bytes = ppid_sample.as_bytes().unwrap();\n        let decoded = SessionRecord::from_bytes(&bytes).unwrap();\n        assert_eq!(ppid_sample, decoded);\n    }\n\n    #[test]\n    fn timestamp_record_matches_works() {\n        let init_time = SystemTime::now().unwrap();\n        let scope = RecordScope::Tty {\n            tty_device: 12,\n            session_pid: 1234,\n            init_time,\n        };\n\n        let tty_sample = SessionRecord::new(scope, 675).unwrap();\n\n        assert!(tty_sample.matches(&scope, 675));\n        assert!(!tty_sample.matches(&scope, 789));\n        assert!(!tty_sample.matches(\n            &RecordScope::Tty {\n                tty_device: 20,\n                session_pid: 1234,\n                init_time\n            },\n            675\n        ));\n        assert!(!tty_sample.matches(\n            &RecordScope::Ppid {\n                group_pid: 42,\n                init_time\n            },\n            675\n        ));\n\n        // make sure time is different\n        std::thread::sleep(std::time::Duration::from_millis(1));\n        assert!(!tty_sample.matches(\n            &RecordScope::Tty {\n                tty_device: 12,\n                session_pid: 1234,\n                init_time: SystemTime::now().unwrap()\n            },\n            675\n        ));\n    }\n\n    #[test]\n    fn timestamp_record_written_between_works() {\n        let some_time = SystemTime::now().unwrap() + Duration::minutes(100);\n        let scope = RecordScope::Tty {\n            tty_device: 12,\n            session_pid: 1234,\n            init_time: some_time,\n        };\n        let sample = SessionRecord::init(scope, 1234, true, some_time);\n\n        let dur = Duration::seconds(30);\n\n        assert!(sample.written_between(some_time, some_time));\n        assert!(sample.written_between(some_time, some_time + dur));\n        assert!(sample.written_between(some_time - dur, some_time));\n        assert!(!sample.written_between(some_time + dur, some_time - dur));\n        assert!(!sample.written_between(some_time + dur, some_time + dur + dur));\n        assert!(!sample.written_between(some_time - dur - dur, some_time - dur));\n    }\n\n    fn tempfile_with_data(data: &[u8]) -> io::Result<File> {\n        let mut file = tempfile()?;\n        file.write_all(data)?;\n        file.rewind()?;\n        Ok(file)\n    }\n\n    fn data_from_tempfile(mut f: File) -> io::Result<Vec<u8>> {\n        let mut v = vec![];\n        f.rewind()?;\n        f.read_to_end(&mut v)?;\n        Ok(v)\n    }\n\n    #[test]\n    fn session_record_file_header_checks() {\n        // valid header should remain valid\n        let c = tempfile_with_data(&[0xD0, 0x50, 0x01, 0x00]).unwrap();\n        let timeout = Duration::seconds(30);\n        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n\n        // invalid headers should be corrected\n        let c = tempfile_with_data(&[0xAB, 0xBA]).unwrap();\n        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n\n        // empty header should be filled in\n        let c = tempfile_with_data(&[]).unwrap();\n        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n\n        // invalid version should reset file\n        let c = tempfile_with_data(&[0xD0, 0x50, 0xAB, 0xBA, 0x0, 0x0]).unwrap();\n        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n    }\n\n    #[test]\n    fn can_create_and_update_valid_file() {\n        let timeout = Duration::seconds(30);\n        let c = tempfile_with_data(&[]).unwrap();\n        let mut srf = SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).unwrap();\n        let tty_scope = RecordScope::Tty {\n            tty_device: 0,\n            session_pid: 0,\n            init_time: SystemTime::new(0, 0),\n        };\n        let auth_user = 2424;\n        let res = srf.create(tty_scope, auth_user).unwrap();\n        let CreateResult::Created { time } = res else {\n            panic!(\"Expected record to be created\");\n        };\n\n        std::thread::sleep(std::time::Duration::from_millis(1));\n        let second = srf.touch(tty_scope, auth_user).unwrap();\n        let TouchResult::Updated { old_time, new_time } = second else {\n            panic!(\"Expected record to be updated\");\n        };\n        assert_eq!(time, old_time);\n        assert_ne!(old_time, new_time);\n\n        std::thread::sleep(std::time::Duration::from_millis(1));\n        let res = srf.create(tty_scope, auth_user).unwrap();\n        let CreateResult::Updated { .. } = res else {\n            panic!(\"Expected record to be updated\");\n        };\n\n        // reset the file\n        assert!(srf.reset().is_ok());\n\n        // after all this the data should be just an empty header\n        let data = data_from_tempfile(c).unwrap();\n        assert_eq!(&data, &[0xD0, 0x50, 0x01, 0x00]);\n    }\n}\n"], "fixing_code": ["#![forbid(unsafe_code)]\n\nuse crate::cli::{help, SudoAction, SudoOptions};\nuse crate::common::{resolve::resolve_current_user, Context, Error};\nuse crate::log::dev_info;\nuse crate::system::timestamp::RecordScope;\nuse crate::system::User;\nuse crate::system::{time::Duration, timestamp::SessionRecordFile, Process};\nuse pam::PamAuthenticator;\nuse pipeline::{Pipeline, PolicyPlugin};\nuse std::env;\nuse std::path::Path;\n\nmod diagnostic;\nmod pam;\nmod pipeline;\n\nconst VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n\nfn candidate_sudoers_file() -> &'static Path {\n    let pb_rs: &'static Path = Path::new(\"/etc/sudoers-rs\");\n    if pb_rs.exists() {\n        dev_info!(\"Running with /etc/sudoers-rs file\");\n        pb_rs\n    } else {\n        dev_info!(\"Running with /etc/sudoers file\");\n        Path::new(\"/etc/sudoers\")\n    }\n}\n\n#[derive(Default)]\npub(crate) struct SudoersPolicy {}\n\nimpl PolicyPlugin for SudoersPolicy {\n    type PreJudgementPolicy = crate::sudoers::Sudoers;\n    type Policy = crate::sudoers::Judgement;\n\n    fn init(&mut self) -> Result<Self::PreJudgementPolicy, Error> {\n        let sudoers_path = candidate_sudoers_file();\n\n        let (sudoers, syntax_errors) = crate::sudoers::Sudoers::open(sudoers_path)\n            .map_err(|e| Error::Configuration(format!(\"{e}\")))?;\n\n        for crate::sudoers::Error(pos, error) in syntax_errors {\n            diagnostic::diagnostic!(\"{error}\", sudoers_path @ pos);\n        }\n\n        Ok(sudoers)\n    }\n\n    fn judge(\n        &mut self,\n        pre: Self::PreJudgementPolicy,\n        context: &Context,\n    ) -> Result<Self::Policy, Error> {\n        Ok(pre.check(\n            &context.current_user,\n            &context.hostname,\n            crate::sudoers::Request {\n                user: &context.target_user,\n                group: &context.target_group,\n                command: &context.command.command,\n                arguments: &context.command.arguments,\n            },\n        ))\n    }\n}\n\nfn sudo_process() -> Result<(), Error> {\n    crate::log::SudoLogger::new(\"sudo: \").into_global_logger();\n\n    dev_info!(\"development logs are enabled\");\n\n    self_check()?;\n\n    let pipeline = Pipeline {\n        policy: SudoersPolicy::default(),\n        authenticator: PamAuthenticator::new_cli(),\n    };\n\n    // parse cli options\n    match SudoOptions::from_env() {\n        Ok(options) => match options.action {\n            SudoAction::Help => {\n                eprintln_ignore_io_error!(\"{}\", help::long_help_message());\n                std::process::exit(0);\n            }\n            SudoAction::Version => {\n                eprintln_ignore_io_error!(\"sudo-rs {VERSION}\");\n                std::process::exit(0);\n            }\n            SudoAction::RemoveTimestamp => {\n                let user = resolve_current_user()?;\n                let mut record_file =\n                    SessionRecordFile::open_for_user(user.uid, Duration::seconds(0))?;\n                record_file.reset()?;\n                Ok(())\n            }\n            SudoAction::ResetTimestamp => {\n                if let Some(scope) = RecordScope::for_process(&Process::new()) {\n                    let user = resolve_current_user()?;\n                    let mut record_file =\n                        SessionRecordFile::open_for_user(user.uid, Duration::seconds(0))?;\n                    record_file.disable(scope, None)?;\n                }\n                Ok(())\n            }\n            SudoAction::Validate => pipeline.run_validate(options),\n            SudoAction::Run(ref cmd) => {\n                // special case for when no command is given\n                if cmd.is_empty() && !options.shell && !options.login {\n                    eprintln_ignore_io_error!(\"{}\", help::USAGE_MSG);\n                    std::process::exit(1);\n                } else {\n                    pipeline.run(options)\n                }\n            }\n            SudoAction::List(_) => pipeline.run_list(options),\n            SudoAction::Edit(_) => {\n                unimplemented!();\n            }\n        },\n        Err(e) => {\n            eprintln_ignore_io_error!(\"{e}\\n{}\", help::USAGE_MSG);\n            std::process::exit(1);\n        }\n    }\n}\n\nfn self_check() -> Result<(), Error> {\n    const ROOT: u32 = 0;\n\n    let euid = User::effective_uid();\n    if euid == ROOT {\n        Ok(())\n    } else {\n        Err(Error::SelfCheck)\n    }\n}\n\npub fn main() {\n    match sudo_process() {\n        Ok(()) => (),\n        Err(error) => {\n            if !error.is_silent() {\n                diagnostic::diagnostic!(\"{error}\");\n            }\n            std::process::exit(1);\n        }\n    }\n}\n", "use std::ffi::OsStr;\nuse std::process::exit;\n\nuse crate::cli::SudoOptions;\nuse crate::common::{resolve::expand_tilde_in_path, Context, Environment, Error};\nuse crate::env::environment;\nuse crate::exec::{ExecOutput, ExitReason};\nuse crate::log::{auth_info, auth_warn};\nuse crate::sudo::Duration;\nuse crate::sudoers::{Authorization, AuthorizationAllowed, DirChange, Policy, PreJudgementPolicy};\nuse crate::system::interface::UserId;\nuse crate::system::term::current_tty_name;\nuse crate::system::timestamp::{RecordScope, SessionRecordFile, TouchResult};\nuse crate::system::{escape_os_str_lossy, Process};\n\nmod list;\n\npub trait PolicyPlugin {\n    type PreJudgementPolicy: PreJudgementPolicy;\n    type Policy: Policy;\n\n    fn init(&mut self) -> Result<Self::PreJudgementPolicy, Error>;\n    fn judge(\n        &mut self,\n        pre: Self::PreJudgementPolicy,\n        context: &Context,\n    ) -> Result<Self::Policy, Error>;\n}\n\npub trait AuthPlugin {\n    fn init(&mut self, context: &Context) -> Result<(), Error>;\n    fn authenticate(&mut self, non_interactive: bool, max_tries: u16) -> Result<(), Error>;\n    fn pre_exec(&mut self, target_user: &str) -> Result<Environment, Error>;\n    fn cleanup(&mut self);\n}\n\npub struct Pipeline<Policy: PolicyPlugin, Auth: AuthPlugin> {\n    pub policy: Policy,\n    pub authenticator: Auth,\n}\n\nimpl<Policy: PolicyPlugin, Auth: AuthPlugin> Pipeline<Policy, Auth> {\n    pub fn run(mut self, cmd_opts: SudoOptions) -> Result<(), Error> {\n        let pre = self.policy.init()?;\n        let mut context = build_context(cmd_opts, &pre)?;\n\n        let policy = self.policy.judge(pre, &context)?;\n        let authorization = policy.authorization();\n\n        match authorization {\n            Authorization::Forbidden => {\n                return Err(Error::auth(&format!(\n                    \"I'm sorry {}. I'm afraid I can't do that\",\n                    context.current_user.name\n                )));\n            }\n            Authorization::Allowed(auth) => {\n                self.apply_policy_to_context(&mut context, &policy)?;\n                self.auth_and_update_record_file(&context, auth)?;\n            }\n        }\n\n        let additional_env = self.authenticator.pre_exec(&context.target_user.name)?;\n\n        // build environment\n        let current_env = std::env::vars_os().collect();\n        let target_env =\n            environment::get_target_environment(current_env, additional_env, &context, &policy);\n\n        let pid = context.process.pid;\n\n        // run command and return corresponding exit code\n        let exec_result = if context.command.resolved {\n            log_command_execution(&context);\n\n            crate::exec::run_command(&context, target_env)\n                .map_err(|io_error| Error::IoError(Some(context.command.command), io_error))\n        } else {\n            Err(Error::CommandNotFound(context.command.command))\n        };\n\n        self.authenticator.cleanup();\n\n        let ExecOutput {\n            command_exit_reason,\n            restore_signal_handlers,\n        } = exec_result?;\n\n        // Run any clean-up code before this line.\n        restore_signal_handlers();\n\n        match command_exit_reason {\n            ExitReason::Code(code) => exit(code),\n            ExitReason::Signal(signal) => {\n                crate::system::kill(pid, signal)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn run_validate(mut self, cmd_opts: SudoOptions) -> Result<(), Error> {\n        let pre = self.policy.init()?;\n        let context = build_context(cmd_opts, &pre)?;\n\n        match pre.validate_authorization() {\n            Authorization::Forbidden => {\n                return Err(Error::auth(&format!(\n                    \"I'm sorry {}. I'm afraid I can't do that\",\n                    context.current_user.name\n                )));\n            }\n            Authorization::Allowed(auth) => {\n                self.auth_and_update_record_file(&context, auth)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn auth_and_update_record_file(\n        &mut self,\n        context: &Context,\n        AuthorizationAllowed {\n            must_authenticate,\n            prior_validity,\n            allowed_attempts,\n        }: AuthorizationAllowed,\n    ) -> Result<(), Error> {\n        let scope = RecordScope::for_process(&Process::new());\n        let mut auth_status = determine_auth_status(\n            must_authenticate,\n            context.use_session_records,\n            scope,\n            context.current_user.uid,\n            context.current_user.uid,\n            prior_validity,\n        );\n        self.authenticator.init(context)?;\n        if auth_status.must_authenticate {\n            self.authenticator\n                .authenticate(context.non_interactive, allowed_attempts)?;\n            if let (Some(record_file), Some(scope)) = (&mut auth_status.record_file, scope) {\n                match record_file.create(scope, context.current_user.uid) {\n                    Ok(_) => (),\n                    Err(e) => {\n                        auth_warn!(\"Could not update session record file with new record: {e}\");\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn apply_policy_to_context(\n        &mut self,\n        context: &mut Context,\n        policy: &<Policy as PolicyPlugin>::Policy,\n    ) -> Result<(), crate::common::Error> {\n        // see if the chdir flag is permitted\n        match policy.chdir() {\n            DirChange::Any => {}\n            DirChange::Strict(optdir) => {\n                if context.chdir.is_some() {\n                    return Err(Error::ChDirNotAllowed {\n                        chdir: context.chdir.clone().unwrap(),\n                        command: context.command.command.clone(),\n                    });\n                } else {\n                    context.chdir = optdir.map(std::path::PathBuf::from)\n                }\n            }\n        }\n\n        // expand tildes in the path with the users home directory\n        if let Some(dir) = context.chdir.take() {\n            context.chdir = Some(expand_tilde_in_path(&context.target_user.name, dir)?)\n        }\n\n        // override the default pty behaviour if indicated\n        if !policy.use_pty() {\n            context.use_pty = false\n        }\n\n        Ok(())\n    }\n}\n\nfn build_context(cmd_opts: SudoOptions, pre: &dyn PreJudgementPolicy) -> Result<Context, Error> {\n    let secure_path: String = pre\n        .secure_path()\n        .unwrap_or_else(|| std::env::var(\"PATH\").unwrap_or_default());\n    Context::build_from_options(cmd_opts, secure_path)\n}\n\n/// This should determine what the authentication status for the given record\n/// match limit and origin/target user from the context is.\nfn determine_auth_status(\n    must_policy_authenticate: bool,\n    use_session_records: bool,\n    record_for: Option<RecordScope>,\n    auth_uid: UserId,\n    current_user: UserId,\n    prior_validity: Duration,\n) -> AuthStatus {\n    if !must_policy_authenticate {\n        AuthStatus::new(false, None)\n    } else if let (true, Some(record_for)) = (use_session_records, record_for) {\n        match SessionRecordFile::open_for_user(current_user, prior_validity) {\n            Ok(mut sr) => {\n                match sr.touch(record_for, auth_uid) {\n                    // if a record was found and updated within the timeout, we do not need to authenticate\n                    Ok(TouchResult::Updated { .. }) => AuthStatus::new(false, Some(sr)),\n                    Ok(TouchResult::NotFound | TouchResult::Outdated { .. }) => {\n                        AuthStatus::new(true, Some(sr))\n                    }\n                    Err(e) => {\n                        auth_warn!(\"Unexpected error while reading session information: {e}\");\n                        AuthStatus::new(true, None)\n                    }\n                }\n            }\n            // if we cannot open the session record file we just assume there is none and continue as normal\n            Err(e) => {\n                auth_warn!(\"Could not use session information: {e}\");\n                AuthStatus::new(true, None)\n            }\n        }\n    } else {\n        AuthStatus::new(true, None)\n    }\n}\n\nstruct AuthStatus {\n    must_authenticate: bool,\n    record_file: Option<SessionRecordFile>,\n}\n\nimpl AuthStatus {\n    fn new(must_authenticate: bool, record_file: Option<SessionRecordFile>) -> AuthStatus {\n        AuthStatus {\n            must_authenticate,\n            record_file,\n        }\n    }\n}\n\nfn log_command_execution(context: &Context) {\n    let tty_info = if let Ok(tty_name) = current_tty_name() {\n        format!(\"TTY={} ;\", escape_os_str_lossy(&tty_name))\n    } else {\n        String::from(\"\")\n    };\n    let pwd = escape_os_str_lossy(\n        std::env::current_dir()\n            .as_ref()\n            .map(|s| s.as_os_str())\n            .unwrap_or_else(|_| OsStr::new(\"unknown\")),\n    );\n    let user = context.target_user.name.escape_debug().collect::<String>();\n    auth_info!(\n        \"{} : {} PWD={} ; USER={} ; COMMAND={}\",\n        &context.current_user.name,\n        tty_info,\n        pwd,\n        user,\n        &context.command\n    );\n}\n", "use std::{\n    fs::File,\n    io::{self, Cursor, Read, Seek, Write},\n    path::PathBuf,\n};\n\nuse crate::log::{auth_info, auth_warn};\n\nuse super::{\n    audit::secure_open_cookie_file,\n    file::FileLock,\n    interface::UserId,\n    time::{Duration, SystemTime},\n    Process, WithProcess,\n};\n\n/// Truncates or extends the underlying data\npub trait SetLength {\n    /// After this is called, the underlying data will either be truncated\n    /// up to new_len bytes, or it will have been extended by zero bytes up to\n    /// new_len.\n    fn set_len(&mut self, new_len: usize) -> io::Result<()>;\n}\n\nimpl SetLength for File {\n    fn set_len(&mut self, new_len: usize) -> io::Result<()> {\n        File::set_len(self, new_len as u64)\n    }\n}\n\ntype BoolStorage = u8;\n\nconst SIZE_OF_TS: i64 = std::mem::size_of::<SystemTime>() as i64;\nconst SIZE_OF_BOOL: i64 = std::mem::size_of::<BoolStorage>() as i64;\nconst MOD_OFFSET: i64 = SIZE_OF_TS + SIZE_OF_BOOL;\n\n#[derive(Debug)]\npub struct SessionRecordFile {\n    file: File,\n    timeout: Duration,\n    for_user: UserId,\n}\n\nimpl SessionRecordFile {\n    const BASE_PATH: &'static str = \"/var/run/sudo-rs/ts\";\n\n    pub fn open_for_user(user: UserId, timeout: Duration) -> io::Result<Self> {\n        let mut path = PathBuf::from(Self::BASE_PATH);\n        path.push(user.to_string());\n        SessionRecordFile::new(user, secure_open_cookie_file(&path)?, timeout)\n    }\n\n    const FILE_VERSION: u16 = 1;\n    const MAGIC_NUM: u16 = 0x50D0;\n    const VERSION_OFFSET: u64 = Self::MAGIC_NUM.to_le_bytes().len() as u64;\n    const FIRST_RECORD_OFFSET: u64 =\n        Self::VERSION_OFFSET + Self::FILE_VERSION.to_le_bytes().len() as u64;\n\n    /// Create a new SessionRecordFile from the given i/o stream.\n    /// Timestamps in this file are considered valid if they were created or\n    /// updated at most `timeout` time ago.\n    pub fn new(for_user: UserId, io: File, timeout: Duration) -> io::Result<Self> {\n        let mut session_records = SessionRecordFile {\n            file: io,\n            timeout,\n            for_user,\n        };\n\n        // match the magic number, otherwise reset the file\n        match session_records.read_magic()? {\n            Some(magic) if magic == Self::MAGIC_NUM => (),\n            x => {\n                if let Some(_magic) = x {\n                    auth_info!(\"Session records file for user '{for_user}' is invalid, resetting\");\n                }\n\n                session_records.init(Self::VERSION_OFFSET)?;\n            }\n        }\n\n        // match the file version\n        match session_records.read_version()? {\n            Some(v) if v == Self::FILE_VERSION => (),\n            x => {\n                if let Some(v) = x {\n                    auth_info!(\"Session records file for user '{for_user}' has invalid version {v}, only file version {} is supported, resetting\", Self::FILE_VERSION);\n                } else {\n                    auth_info!(\n                        \"Session records file did not contain file version information, resetting\"\n                    );\n                }\n\n                session_records.init(Self::FIRST_RECORD_OFFSET)?;\n            }\n        }\n\n        // we are ready to read records\n        Ok(session_records)\n    }\n\n    /// Read the magic number from the input stream\n    fn read_magic(&mut self) -> io::Result<Option<u16>> {\n        let mut magic_bytes = [0; std::mem::size_of::<u16>()];\n        match self.file.read_exact(&mut magic_bytes) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => Ok(None),\n            Err(e) => Err(e),\n            Ok(()) => Ok(Some(u16::from_le_bytes(magic_bytes))),\n        }\n    }\n\n    /// Read the version number from the input stream\n    fn read_version(&mut self) -> io::Result<Option<u16>> {\n        let mut version_bytes = [0; std::mem::size_of::<u16>()];\n        match self.file.read_exact(&mut version_bytes) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => Ok(None),\n            Err(e) => Err(e),\n            Ok(()) => Ok(Some(u16::from_le_bytes(version_bytes))),\n        }\n    }\n\n    /// Initialize a new empty stream. If the stream/file was already filled\n    /// before it will be truncated.\n    fn init(&mut self, offset: u64) -> io::Result<()> {\n        // lock the file to indicate that we are currently writing to it\n        let lock = FileLock::exclusive(&self.file, false)?;\n\n        self.file.set_len(0)?;\n        self.file.rewind()?;\n        self.file.write_all(&Self::MAGIC_NUM.to_le_bytes())?;\n        self.file.write_all(&Self::FILE_VERSION.to_le_bytes())?;\n        self.file.seek(io::SeekFrom::Start(offset))?;\n\n        lock.unlock()?;\n\n        Ok(())\n    }\n\n    /// Read the next record and keep note of the start and end positions in the file of that record\n    ///\n    /// This method assumes that the file is already exclusively locked.\n    fn next_record(&mut self) -> io::Result<Option<SessionRecord>> {\n        // record the position at which this record starts (including size bytes)\n        let mut record_length_bytes = [0; std::mem::size_of::<u16>()];\n\n        let curr_pos = self.file.stream_position()?;\n\n        // if eof occurs here we assume we reached the end of the file\n        let record_length = match self.file.read_exact(&mut record_length_bytes) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => return Ok(None),\n            Err(e) => return Err(e),\n            Ok(()) => u16::from_le_bytes(record_length_bytes),\n        };\n\n        // special case when record_length is zero\n        if record_length == 0 {\n            return Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"Found empty record\",\n            ));\n        }\n\n        let mut buf = vec![0; record_length as usize];\n        match self.file.read_exact(&mut buf) {\n            Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => {\n                // there was half a record here, we clear the rest of the file\n                auth_info!(\"Found incomplete record in session records file for {}, clearing rest of the file\", self.for_user);\n                self.file.set_len(curr_pos)?;\n                return Ok(None);\n            }\n            Err(e) => return Err(e),\n            Ok(()) => (),\n        }\n\n        // we now try and decode the data read into a session record\n        match SessionRecord::from_bytes(&buf) {\n            Err(_) => {\n                // any error assumes that this file is nonsense from this point\n                // onwards, so we clear the file up to the start of this record\n                auth_info!(\"Found invalid record in session records file for {}, clearing rest of the file\", self.for_user);\n\n                self.file.set_len(curr_pos)?;\n                Ok(None)\n            }\n            Ok(record) => Ok(Some(record)),\n        }\n    }\n\n    /// Try and find a record for the given scope and auth user id and update\n    /// that record time to the current time. This will not create a new record\n    /// when one is not found. A record will only be updated if it is still\n    /// valid at this time.\n    pub fn touch(&mut self, scope: RecordScope, auth_user: UserId) -> io::Result<TouchResult> {\n        // lock the file to indicate that we are currently in a writing operation\n        let lock = FileLock::exclusive(&self.file, false)?;\n        self.seek_to_first_record()?;\n        while let Some(record) = self.next_record()? {\n            // only touch if record is enabled\n            if record.enabled && record.matches(&scope, auth_user) {\n                let now = SystemTime::now()?;\n                if record.written_between(now - self.timeout, now) {\n                    // move back to where the timestamp is and overwrite with the latest time\n                    self.file.seek(io::SeekFrom::Current(-MOD_OFFSET))?;\n                    let new_time = SystemTime::now()?;\n                    new_time.encode(&mut self.file)?;\n\n                    // make sure we can still go to the end of the record\n                    self.file.seek(io::SeekFrom::Current(SIZE_OF_BOOL))?;\n\n                    // writing is done, unlock and return\n                    lock.unlock()?;\n                    return Ok(TouchResult::Updated {\n                        old_time: record.timestamp,\n                        new_time,\n                    });\n                } else {\n                    lock.unlock()?;\n                    return Ok(TouchResult::Outdated {\n                        time: record.timestamp,\n                    });\n                }\n            }\n        }\n\n        lock.unlock()?;\n        Ok(TouchResult::NotFound)\n    }\n\n    /// Disable all records that match the given scope. If an auth user id is\n    /// given then only records with the given scope that are targetting that\n    /// specific user will be disabled.\n    pub fn disable(&mut self, scope: RecordScope, auth_user: Option<UserId>) -> io::Result<()> {\n        let lock = FileLock::exclusive(&self.file, false)?;\n        self.seek_to_first_record()?;\n        while let Some(record) = self.next_record()? {\n            let must_disable = auth_user\n                .map(|tu| record.matches(&scope, tu))\n                .unwrap_or_else(|| record.scope == scope);\n            if must_disable {\n                self.file.seek(io::SeekFrom::Current(-SIZE_OF_BOOL))?;\n                write_bool(false, &mut self.file)?;\n            }\n        }\n        lock.unlock()?;\n        Ok(())\n    }\n\n    /// Create a new record for the given scope and auth user id.\n    /// If there is an existing record that matches the scope and auth user,\n    /// then that record will be updated.\n    pub fn create(&mut self, scope: RecordScope, auth_user: UserId) -> io::Result<CreateResult> {\n        // lock the file to indicate that we are currently writing to it\n        let lock = FileLock::exclusive(&self.file, false)?;\n        self.seek_to_first_record()?;\n        while let Some(record) = self.next_record()? {\n            if record.matches(&scope, auth_user) {\n                self.file.seek(io::SeekFrom::Current(-MOD_OFFSET))?;\n                let new_time = SystemTime::now()?;\n                new_time.encode(&mut self.file)?;\n                write_bool(true, &mut self.file)?;\n                lock.unlock()?;\n                return Ok(CreateResult::Updated {\n                    old_time: record.timestamp,\n                    new_time,\n                });\n            }\n        }\n\n        // record was not found in the list so far, create a new one\n        let record = SessionRecord::new(scope, auth_user)?;\n\n        // make sure we really are at the end of the file\n        self.file.seek(io::SeekFrom::End(0))?;\n\n        self.write_record(&record)?;\n        lock.unlock()?;\n\n        Ok(CreateResult::Created {\n            time: record.timestamp,\n        })\n    }\n\n    /// Completely resets the entire file and removes all records.\n    pub fn reset(&mut self) -> io::Result<()> {\n        self.init(0)\n    }\n\n    /// Write a new record at the current position in the file.\n    fn write_record(&mut self, record: &SessionRecord) -> io::Result<()> {\n        // convert the new record to byte representation and make sure that it fits\n        let bytes = record.as_bytes()?;\n        let record_length = bytes.len();\n        if record_length > u16::MAX as usize {\n            return Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"A record with an unexpectedly large size was created\",\n            ));\n        }\n        let record_length = record_length as u16; // store as u16\n\n        // write the record\n        self.file.write_all(&record_length.to_le_bytes())?;\n        self.file.write_all(&bytes)?;\n\n        Ok(())\n    }\n\n    /// Move to where the first record starts.\n    fn seek_to_first_record(&mut self) -> io::Result<()> {\n        self.file\n            .seek(io::SeekFrom::Start(Self::FIRST_RECORD_OFFSET))?;\n        Ok(())\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum TouchResult {\n    /// The record was found and within the timeout, and it was refreshed\n    Updated {\n        old_time: SystemTime,\n        new_time: SystemTime,\n    },\n    /// A record was found, but it was no longer valid\n    Outdated { time: SystemTime },\n    /// A record was not found that matches the input\n    NotFound,\n}\n\npub enum CreateResult {\n    /// The record was found and it was refreshed\n    Updated {\n        old_time: SystemTime,\n        new_time: SystemTime,\n    },\n    /// A new record was created and was set to the time returned\n    Created { time: SystemTime },\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum RecordScope {\n    Tty {\n        tty_device: libc::dev_t,\n        session_pid: libc::pid_t,\n        init_time: SystemTime,\n    },\n    Ppid {\n        group_pid: libc::pid_t,\n        init_time: SystemTime,\n    },\n}\n\nimpl RecordScope {\n    fn encode(&self, target: &mut impl Write) -> std::io::Result<()> {\n        match self {\n            RecordScope::Tty {\n                tty_device,\n                session_pid,\n                init_time,\n            } => {\n                target.write_all(&[1u8])?;\n                let b = tty_device.to_le_bytes();\n                target.write_all(&b)?;\n                let b = session_pid.to_le_bytes();\n                target.write_all(&b)?;\n                init_time.encode(target)?;\n            }\n            RecordScope::Ppid {\n                group_pid,\n                init_time,\n            } => {\n                target.write_all(&[2u8])?;\n                let b = group_pid.to_le_bytes();\n                target.write_all(&b)?;\n                init_time.encode(target)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn decode(from: &mut impl Read) -> std::io::Result<RecordScope> {\n        let mut buf = [0; 1];\n        from.read_exact(&mut buf)?;\n        match buf[0] {\n            1 => {\n                let mut buf = [0; std::mem::size_of::<libc::dev_t>()];\n                from.read_exact(&mut buf)?;\n                let tty_device = libc::dev_t::from_le_bytes(buf);\n                let mut buf = [0; std::mem::size_of::<libc::pid_t>()];\n                from.read_exact(&mut buf)?;\n                let session_pid = libc::pid_t::from_le_bytes(buf);\n                let init_time = SystemTime::decode(from)?;\n                Ok(RecordScope::Tty {\n                    tty_device,\n                    session_pid,\n                    init_time,\n                })\n            }\n            2 => {\n                let mut buf = [0; std::mem::size_of::<libc::pid_t>()];\n                from.read_exact(&mut buf)?;\n                let group_pid = libc::pid_t::from_le_bytes(buf);\n                let init_time = SystemTime::decode(from)?;\n                Ok(RecordScope::Ppid {\n                    group_pid,\n                    init_time,\n                })\n            }\n            x => Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                format!(\"Unexpected scope variant discriminator: {x}\"),\n            )),\n        }\n    }\n\n    /// Tries to determine a record match scope for the current context.\n    /// This should never produce an error since any actual error should just be\n    /// ignored and no session record file should be used in that case.\n    pub fn for_process(process: &Process) -> Option<RecordScope> {\n        let tty = Process::tty_device_id(WithProcess::Current);\n        if let Ok(Some(tty_device)) = tty {\n            if let Ok(init_time) = Process::starting_time(WithProcess::Other(process.session_id)) {\n                Some(RecordScope::Tty {\n                    tty_device,\n                    session_pid: process.session_id,\n                    init_time,\n                })\n            } else {\n                auth_warn!(\"Could not get terminal foreground process starting time\");\n                None\n            }\n        } else if let Some(parent_pid) = process.parent_pid {\n            if let Ok(init_time) = Process::starting_time(WithProcess::Other(parent_pid)) {\n                Some(RecordScope::Ppid {\n                    group_pid: parent_pid,\n                    init_time,\n                })\n            } else {\n                auth_warn!(\"Could not get parent process starting time\");\n                None\n            }\n        } else {\n            None\n        }\n    }\n}\n\nfn write_bool(b: bool, target: &mut impl Write) -> io::Result<()> {\n    let s: BoolStorage = if b { 0xFF } else { 0x00 };\n    let bytes = s.to_le_bytes();\n    target.write_all(&bytes)?;\n    Ok(())\n}\n\n/// A record in the session record file\n#[derive(Debug, PartialEq, Eq)]\npub struct SessionRecord {\n    /// The scope for which the current record applies, i.e. what process group\n    /// or which TTY for interactive sessions\n    scope: RecordScope,\n    /// The user that needs to be authenticated against\n    auth_user: libc::uid_t,\n    /// The timestamp at which the time was created. This must always be a time\n    /// originating from a monotonic clock that continues counting during system\n    /// sleep.\n    timestamp: SystemTime,\n    /// Disabled records act as if they do not exist, but their storage can\n    /// be re-used when recreating for the same scope and auth user\n    enabled: bool,\n}\n\nimpl SessionRecord {\n    /// Create a new record that is scoped to the specified scope and has `auth_user` as\n    /// the target for authentication for the session.\n    fn new(scope: RecordScope, auth_user: UserId) -> io::Result<SessionRecord> {\n        Ok(Self::init(scope, auth_user, true, SystemTime::now()?))\n    }\n\n    /// Initialize a new record with the given parameters\n    fn init(\n        scope: RecordScope,\n        auth_user: UserId,\n        enabled: bool,\n        timestamp: SystemTime,\n    ) -> SessionRecord {\n        SessionRecord {\n            scope,\n            auth_user,\n            timestamp,\n            enabled,\n        }\n    }\n\n    /// Encode a record into the given stream\n    fn encode(&self, target: &mut impl Write) -> std::io::Result<()> {\n        self.scope.encode(target)?;\n\n        // write user id\n        let buf = self.auth_user.to_le_bytes();\n        target.write_all(&buf)?;\n\n        // write timestamp\n        self.timestamp.encode(target)?;\n\n        // write enabled boolean\n        write_bool(self.enabled, target)?;\n\n        Ok(())\n    }\n\n    /// Decode a record from the given stream\n    fn decode(from: &mut impl Read) -> std::io::Result<SessionRecord> {\n        let scope = RecordScope::decode(from)?;\n\n        // auth user id\n        let mut buf = [0; std::mem::size_of::<libc::uid_t>()];\n        from.read_exact(&mut buf)?;\n        let auth_user = libc::uid_t::from_le_bytes(buf);\n\n        // timestamp\n        let timestamp = SystemTime::decode(from)?;\n\n        // enabled boolean\n        let mut buf = [0; std::mem::size_of::<BoolStorage>()];\n        from.read_exact(&mut buf)?;\n        let enabled = match BoolStorage::from_le_bytes(buf) {\n            0xFF => true,\n            0x00 => false,\n            _ => {\n                return Err(io::Error::new(\n                    io::ErrorKind::InvalidData,\n                    \"Invalid boolean value detected in input stream\",\n                ))\n            }\n        };\n\n        Ok(SessionRecord::init(scope, auth_user, enabled, timestamp))\n    }\n\n    /// Convert the record to a vector of bytes for storage.\n    pub fn as_bytes(&self) -> std::io::Result<Vec<u8>> {\n        let mut v = vec![];\n        self.encode(&mut v)?;\n        Ok(v)\n    }\n\n    /// Convert the given byte slice to a session record, the byte slice must\n    /// be fully consumed for this conversion to be valid.\n    pub fn from_bytes(data: &[u8]) -> std::io::Result<SessionRecord> {\n        let mut cursor = Cursor::new(data);\n        let record = SessionRecord::decode(&mut cursor)?;\n        if cursor.position() != data.len() as u64 {\n            Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"Record size and record length did not match\",\n            ))\n        } else {\n            Ok(record)\n        }\n    }\n\n    /// Returns true if this record matches the specified scope and is for the\n    /// specified target auth user.\n    pub fn matches(&self, scope: &RecordScope, auth_user: UserId) -> bool {\n        self.scope == *scope && self.auth_user == auth_user\n    }\n\n    /// Returns true if this record was written somewhere in the time range\n    /// between `early_time` (inclusive) and `later_time` (inclusive), where\n    /// early timestamp may not be later than the later timestamp.\n    pub fn written_between(&self, early_time: SystemTime, later_time: SystemTime) -> bool {\n        early_time <= later_time && self.timestamp >= early_time && self.timestamp <= later_time\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use crate::system::tests::tempfile;\n\n    const TEST_USER_ID: UserId = 1000;\n\n    impl SetLength for Cursor<Vec<u8>> {\n        fn set_len(&mut self, new_len: usize) -> io::Result<()> {\n            self.get_mut().truncate(new_len);\n            while self.get_mut().len() < new_len {\n                self.get_mut().push(0);\n            }\n            Ok(())\n        }\n    }\n\n    impl SetLength for Cursor<&mut Vec<u8>> {\n        fn set_len(&mut self, new_len: usize) -> io::Result<()> {\n            self.get_mut().truncate(new_len);\n            while self.get_mut().len() < new_len {\n                self.get_mut().push(0);\n            }\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn can_encode_and_decode() {\n        let tty_sample = SessionRecord::new(\n            RecordScope::Tty {\n                tty_device: 10,\n                session_pid: 42,\n                init_time: SystemTime::now().unwrap() - Duration::seconds(150),\n            },\n            999,\n        )\n        .unwrap();\n\n        let mut bytes = tty_sample.as_bytes().unwrap();\n        let decoded = SessionRecord::from_bytes(&bytes).unwrap();\n        assert_eq!(tty_sample, decoded);\n\n        // we provide some invalid input\n        assert!(SessionRecord::from_bytes(&bytes[1..]).is_err());\n\n        // we have remaining input after decoding\n        bytes.push(0);\n        assert!(SessionRecord::from_bytes(&bytes).is_err());\n\n        let ppid_sample = SessionRecord::new(\n            RecordScope::Ppid {\n                group_pid: 42,\n                init_time: SystemTime::now().unwrap(),\n            },\n            123,\n        )\n        .unwrap();\n        let bytes = ppid_sample.as_bytes().unwrap();\n        let decoded = SessionRecord::from_bytes(&bytes).unwrap();\n        assert_eq!(ppid_sample, decoded);\n    }\n\n    #[test]\n    fn timestamp_record_matches_works() {\n        let init_time = SystemTime::now().unwrap();\n        let scope = RecordScope::Tty {\n            tty_device: 12,\n            session_pid: 1234,\n            init_time,\n        };\n\n        let tty_sample = SessionRecord::new(scope, 675).unwrap();\n\n        assert!(tty_sample.matches(&scope, 675));\n        assert!(!tty_sample.matches(&scope, 789));\n        assert!(!tty_sample.matches(\n            &RecordScope::Tty {\n                tty_device: 20,\n                session_pid: 1234,\n                init_time\n            },\n            675\n        ));\n        assert!(!tty_sample.matches(\n            &RecordScope::Ppid {\n                group_pid: 42,\n                init_time\n            },\n            675\n        ));\n\n        // make sure time is different\n        std::thread::sleep(std::time::Duration::from_millis(1));\n        assert!(!tty_sample.matches(\n            &RecordScope::Tty {\n                tty_device: 12,\n                session_pid: 1234,\n                init_time: SystemTime::now().unwrap()\n            },\n            675\n        ));\n    }\n\n    #[test]\n    fn timestamp_record_written_between_works() {\n        let some_time = SystemTime::now().unwrap() + Duration::minutes(100);\n        let scope = RecordScope::Tty {\n            tty_device: 12,\n            session_pid: 1234,\n            init_time: some_time,\n        };\n        let sample = SessionRecord::init(scope, 1234, true, some_time);\n\n        let dur = Duration::seconds(30);\n\n        assert!(sample.written_between(some_time, some_time));\n        assert!(sample.written_between(some_time, some_time + dur));\n        assert!(sample.written_between(some_time - dur, some_time));\n        assert!(!sample.written_between(some_time + dur, some_time - dur));\n        assert!(!sample.written_between(some_time + dur, some_time + dur + dur));\n        assert!(!sample.written_between(some_time - dur - dur, some_time - dur));\n    }\n\n    fn tempfile_with_data(data: &[u8]) -> io::Result<File> {\n        let mut file = tempfile()?;\n        file.write_all(data)?;\n        file.rewind()?;\n        Ok(file)\n    }\n\n    fn data_from_tempfile(mut f: File) -> io::Result<Vec<u8>> {\n        let mut v = vec![];\n        f.rewind()?;\n        f.read_to_end(&mut v)?;\n        Ok(v)\n    }\n\n    #[test]\n    fn session_record_file_header_checks() {\n        // valid header should remain valid\n        let c = tempfile_with_data(&[0xD0, 0x50, 0x01, 0x00]).unwrap();\n        let timeout = Duration::seconds(30);\n        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n\n        // invalid headers should be corrected\n        let c = tempfile_with_data(&[0xAB, 0xBA]).unwrap();\n        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n\n        // empty header should be filled in\n        let c = tempfile_with_data(&[]).unwrap();\n        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n\n        // invalid version should reset file\n        let c = tempfile_with_data(&[0xD0, 0x50, 0xAB, 0xBA, 0x0, 0x0]).unwrap();\n        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n        let v = data_from_tempfile(c).unwrap();\n        assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n    }\n\n    #[test]\n    fn can_create_and_update_valid_file() {\n        let timeout = Duration::seconds(30);\n        let c = tempfile_with_data(&[]).unwrap();\n        let mut srf =\n            SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).unwrap();\n        let tty_scope = RecordScope::Tty {\n            tty_device: 0,\n            session_pid: 0,\n            init_time: SystemTime::new(0, 0),\n        };\n        let auth_user = 2424;\n        let res = srf.create(tty_scope, auth_user).unwrap();\n        let CreateResult::Created { time } = res else {\n            panic!(\"Expected record to be created\");\n        };\n\n        std::thread::sleep(std::time::Duration::from_millis(1));\n        let second = srf.touch(tty_scope, auth_user).unwrap();\n        let TouchResult::Updated { old_time, new_time } = second else {\n            panic!(\"Expected record to be updated\");\n        };\n        assert_eq!(time, old_time);\n        assert_ne!(old_time, new_time);\n\n        std::thread::sleep(std::time::Duration::from_millis(1));\n        let res = srf.create(tty_scope, auth_user).unwrap();\n        let CreateResult::Updated { .. } = res else {\n            panic!(\"Expected record to be updated\");\n        };\n\n        // reset the file\n        assert!(srf.reset().is_ok());\n\n        // after all this the data should be just an empty header\n        let data = data_from_tempfile(c).unwrap();\n        assert_eq!(&data, &[0xD0, 0x50, 0x01, 0x00]);\n    }\n}\n"], "filenames": ["src/sudo/mod.rs", "src/sudo/pipeline.rs", "src/system/timestamp.rs"], "buggy_code_start_loc": [95, 136, 38], "buggy_code_end_loc": [104, 242, 745], "fixing_code_start_loc": [95, 136, 38], "fixing_code_end_loc": [104, 242, 748], "type": "CWE-22", "message": "Sudo-rs, a memory safe implementation of sudo and su, allows users to not have to enter authentication at every sudo attempt, but instead only requiring authentication every once in a while in every terminal or process group. Only once a configurable timeout has passed will the user have to re-authenticate themselves. Supporting this functionality is a set of session files (timestamps) for each user, stored in `/var/run/sudo-rs/ts`. These files are named according to the username from which the sudo attempt is made (the origin user).\n\nAn issue was discovered in versions prior to 0.2.1 where usernames containing the `.` and `/` characters could result in the corruption of specific files on the filesystem. As usernames are generally not limited by the characters they can contain, a username appearing to be a relative path can be constructed. For example we could add a user to the system containing the username `../../../../bin/cp`. When logged in as a user with that name, that user could run `sudo -K` to clear their session record file. The session code then constructs the path to the session file by concatenating the username to the session file storage directory, resulting in a resolved path of `/bin/cp`. The code then clears that file, resulting in the `cp` binary effectively being removed from the system.\n\nAn attacker needs to be able to login as a user with a constructed username. Given that such a username is unlikely to exist on an existing system, they will also need to be able to create the users with the constructed usernames.\n\nThe issue is patched in version 0.2.1 of sudo-rs. Sudo-rs now uses the uid for the user instead of their username for determining the filename. Note that an upgrade to this version will result in existing session files being ignored and users will be forced to re-authenticate. It also fully eliminates any possibility of path traversal, given that uids are always integer values.\n\nThe `sudo -K` and `sudo -k` commands can run, even if a user has no sudo access. As a workaround, make sure that one's system does not contain any users with a specially crafted username. While this is the case and while untrusted users do not have the ability to create arbitrary users on the system, one should not be able to exploit this issue.", "other": {"cve": {"id": "CVE-2023-42456", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-21T16:15:09.980", "lastModified": "2023-11-04T03:15:07.827", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sudo-rs, a memory safe implementation of sudo and su, allows users to not have to enter authentication at every sudo attempt, but instead only requiring authentication every once in a while in every terminal or process group. Only once a configurable timeout has passed will the user have to re-authenticate themselves. Supporting this functionality is a set of session files (timestamps) for each user, stored in `/var/run/sudo-rs/ts`. These files are named according to the username from which the sudo attempt is made (the origin user).\n\nAn issue was discovered in versions prior to 0.2.1 where usernames containing the `.` and `/` characters could result in the corruption of specific files on the filesystem. As usernames are generally not limited by the characters they can contain, a username appearing to be a relative path can be constructed. For example we could add a user to the system containing the username `../../../../bin/cp`. When logged in as a user with that name, that user could run `sudo -K` to clear their session record file. The session code then constructs the path to the session file by concatenating the username to the session file storage directory, resulting in a resolved path of `/bin/cp`. The code then clears that file, resulting in the `cp` binary effectively being removed from the system.\n\nAn attacker needs to be able to login as a user with a constructed username. Given that such a username is unlikely to exist on an existing system, they will also need to be able to create the users with the constructed usernames.\n\nThe issue is patched in version 0.2.1 of sudo-rs. Sudo-rs now uses the uid for the user instead of their username for determining the filename. Note that an upgrade to this version will result in existing session files being ignored and users will be forced to re-authenticate. It also fully eliminates any possibility of path traversal, given that uids are always integer values.\n\nThe `sudo -K` and `sudo -k` commands can run, even if a user has no sudo access. As a workaround, make sure that one's system does not contain any users with a specially crafted username. While this is the case and while untrusted users do not have the ability to create arbitrary users on the system, one should not be able to exploit this issue."}, {"lang": "es", "value": "Sudo-rs, una implementaci\u00f3n segura de memoria de sudo y su, permite a los usuarios no tener que ingresar autenticaci\u00f3n en cada intento de sudo, sino que solo requiere autenticaci\u00f3n de vez en cuando en cada terminal o grupo de procesos. Solo una vez que haya transcurrido un tiempo de espera configurable, el usuario deber\u00e1 volver a autenticarse. Esta funcionalidad admite un conjunto de archivos de sesi\u00f3n (marcas de tiempo) para cada usuario, almacenados en `/var/run/sudo-rs/ts`. Estos archivos se nombran seg\u00fan el nombre de usuario desde el que se realiza el intento de sudo (el usuario de origen). Se descubri\u00f3 un problema en versiones anteriores a la 0.2.1 donde los nombres de usuario que conten\u00edan los caracteres `.` y `/` pod\u00edan provocar la corrupci\u00f3n de archivos espec\u00edficos en el sistema de archivos. Como los nombres de usuario generalmente no est\u00e1n limitados por los caracteres que pueden contener, se puede construir un nombre de usuario que parezca un Path Traversal. Por ejemplo, podr\u00edamos agregar un usuario al sistema que contenga el nombre de usuario `../../../../bin/cp`. Cuando iniciaba sesi\u00f3n como usuario con ese nombre, ese usuario pod\u00eda ejecutar `sudo -K` para borrar su archivo de registro de sesi\u00f3n. Luego, el c\u00f3digo de sesi\u00f3n construye la ruta al archivo de sesi\u00f3n concatenando el nombre de usuario al directorio de almacenamiento del archivo de sesi\u00f3n, lo que da como resultado una ruta resuelta de `/bin/cp`. Luego, el c\u00f3digo borra ese archivo, lo que da como resultado que el binario `cp` se elimine efectivamente del sistema. Un atacante debe poder iniciar sesi\u00f3n como usuario con un nombre de usuario construido. Dado que es poco probable que dicho nombre de usuario exista en un sistema existente, tambi\u00e9n deber\u00e1n poder crear usuarios con los nombres de usuario creados. El problema se solucion\u00f3 en la versi\u00f3n 0.2.1 de sudo-rs. Sudo-rs ahora usa el uid del usuario en lugar de su nombre de usuario para determinar el nombre del archivo. Tenga en cuenta que una actualizaci\u00f3n a esta versi\u00f3n har\u00e1 que se ignoren los archivos de sesi\u00f3n existentes y los usuarios se ver\u00e1n obligados a volver a autenticarse. Tambi\u00e9n elimina por completo cualquier posibilidad de Path Traversal, dado que los uids son siempre valores enteros. Los comandos `sudo -K` y `sudo -k` se pueden ejecutar, incluso si un usuario no tiene acceso a sudo. Como workaround, aseg\u00farese de que su sistema no contenga ning\u00fan usuario con un nombre de usuario especialmente manipulado. Si bien este es el caso y aunque los usuarios que no son de confianza no tienen la capacidad de crear usuarios arbitrarios en el sistema, no se deber\u00eda poder explotar este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 0.6, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-23"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:memorysafety:sudo:*:*:*:*:*:rust:*:*", "versionEndExcluding": "0.2.1", "matchCriteriaId": "B8E119A1-5AFE-4E8E-AB2A-889307A83799"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/11/02/1", "source": "security-advisories@github.com"}, {"url": "https://ferrous-systems.com/blog/sudo-rs-audit/", "source": "security-advisories@github.com"}, {"url": "https://github.com/memorysafety/sudo-rs/commit/bfdbda22968e3de43fa8246cab1681cfd5d5493d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/memorysafety/sudo-rs/security/advisories/GHSA-2r3c-m6v7-9354", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/memorysafety/sudo-rs/commit/bfdbda22968e3de43fa8246cab1681cfd5d5493d"}}