{"buggy_code": ["/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parse Composite Document Files, the format used in Microsoft Office\n * document files before they switched to zipped XML.\n * Info from: http://sc.openoffice.org/compdocfileformat.pdf\n *\n * N.B. This is the \"Composite Document File\" format, and not the\n * \"Compound Document Format\", nor the \"Channel Definition Format\".\n */\n\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: cdf.c,v 1.115 2019/08/23 14:29:14 christos Exp $\")\n#endif\n\n#include <assert.h>\n#ifdef CDF_DEBUG\n#include <err.h>\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <limits.h>\n\n#ifndef EFTYPE\n#define EFTYPE EINVAL\n#endif\n\n#ifndef SIZE_T_MAX\n#define SIZE_T_MAX CAST(size_t, ~0ULL)\n#endif\n\n#include \"cdf.h\"\n\n#ifdef CDF_DEBUG\n#define DPRINTF(a) printf a, fflush(stdout)\n#else\n#define DPRINTF(a)\n#endif\n\nstatic union {\n\tchar s[4];\n\tuint32_t u;\n} cdf_bo;\n\n#define NEED_SWAP\t(cdf_bo.u == CAST(uint32_t, 0x01020304))\n\n#define CDF_TOLE8(x)\t\\\n    (CAST(uint64_t, NEED_SWAP ? _cdf_tole8(x) : CAST(uint64_t, x)))\n#define CDF_TOLE4(x)\t\\\n    (CAST(uint32_t, NEED_SWAP ? _cdf_tole4(x) : CAST(uint32_t, x)))\n#define CDF_TOLE2(x)\t\\\n    (CAST(uint16_t, NEED_SWAP ? _cdf_tole2(x) : CAST(uint16_t, x)))\n#define CDF_TOLE(x)\t(/*CONSTCOND*/sizeof(x) == 2 ? \\\n\t\t\t    CDF_TOLE2(CAST(uint16_t, x)) : \\\n\t\t\t(/*CONSTCOND*/sizeof(x) == 4 ? \\\n\t\t\t    CDF_TOLE4(CAST(uint32_t, x)) : \\\n\t\t\t    CDF_TOLE8(CAST(uint64_t, x))))\n#define CDF_GETUINT32(x, y)\tcdf_getuint32(x, y)\n\n#define CDF_MALLOC(n) cdf_malloc(__FILE__, __LINE__, (n))\n#define CDF_REALLOC(p, n) cdf_realloc(__FILE__, __LINE__, (p), (n))\n#define CDF_CALLOC(n, u) cdf_calloc(__FILE__, __LINE__, (n), (u))\n\n\n/*ARGSUSED*/\nstatic void *\ncdf_malloc(const char *file __attribute__((__unused__)),\n    size_t line __attribute__((__unused__)), size_t n)\n{\n\tDPRINTF((\"%s,%\" SIZE_T_FORMAT \"u: %s %\" SIZE_T_FORMAT \"u\\n\",\n\t    file, line, __func__, n));\n\treturn malloc(n);\n}\n\n/*ARGSUSED*/\nstatic void *\ncdf_realloc(const char *file __attribute__((__unused__)),\n    size_t line __attribute__((__unused__)), void *p, size_t n)\n{\n\tDPRINTF((\"%s,%\" SIZE_T_FORMAT \"u: %s %\" SIZE_T_FORMAT \"u\\n\",\n\t    file, line, __func__, n));\n\treturn realloc(p, n);\n}\n\n/*ARGSUSED*/\nstatic void *\ncdf_calloc(const char *file __attribute__((__unused__)),\n    size_t line __attribute__((__unused__)), size_t n, size_t u)\n{\n\tDPRINTF((\"%s,%\" SIZE_T_FORMAT \"u: %s %\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u\\n\", file, line, __func__, n, u));\n\treturn calloc(n, u);\n}\n\n/*\n * swap a short\n */\nstatic uint16_t\n_cdf_tole2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));\n\tuint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));\n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}\n\n/*\n * swap an int\n */\nstatic uint32_t\n_cdf_tole4(uint32_t sv)\n{\n\tuint32_t rv;\n\tuint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));\n\tuint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));\n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\treturn rv;\n}\n\n/*\n * swap a quad\n */\nstatic uint64_t\n_cdf_tole8(uint64_t sv)\n{\n\tuint64_t rv;\n\tuint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));\n\tuint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));\n\td[0] = s[7];\n\td[1] = s[6];\n\td[2] = s[5];\n\td[3] = s[4];\n\td[4] = s[3];\n\td[5] = s[2];\n\td[6] = s[1];\n\td[7] = s[0];\n\treturn rv;\n}\n\n/*\n * grab a uint32_t from a possibly unaligned address, and return it in\n * the native host order.\n */\nstatic uint32_t\ncdf_getuint32(const uint8_t *p, size_t offs)\n{\n\tuint32_t rv;\n\t(void)memcpy(&rv, p + offs * sizeof(uint32_t), sizeof(rv));\n\treturn CDF_TOLE4(rv);\n}\n\n#define CDF_UNPACK(a)\t\\\n    (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)\n#define CDF_UNPACKA(a)\t\\\n    (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)\n\nuint16_t\ncdf_tole2(uint16_t sv)\n{\n\treturn CDF_TOLE2(sv);\n}\n\nuint32_t\ncdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}\n\nuint64_t\ncdf_tole8(uint64_t sv)\n{\n\treturn CDF_TOLE8(sv);\n}\n\nvoid\ncdf_swap_header(cdf_header_t *h)\n{\n\tsize_t i;\n\n\th->h_magic = CDF_TOLE8(h->h_magic);\n\th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);\n\th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);\n\th->h_revision = CDF_TOLE2(h->h_revision);\n\th->h_version = CDF_TOLE2(h->h_version);\n\th->h_byte_order = CDF_TOLE2(h->h_byte_order);\n\th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);\n\th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);\n\th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);\n\th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);\n\th->h_min_size_standard_stream =\n\t    CDF_TOLE4(h->h_min_size_standard_stream);\n\th->h_secid_first_sector_in_short_sat =\n\t    CDF_TOLE4(CAST(uint32_t, h->h_secid_first_sector_in_short_sat));\n\th->h_num_sectors_in_short_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_short_sat);\n\th->h_secid_first_sector_in_master_sat =\n\t    CDF_TOLE4(CAST(uint32_t, h->h_secid_first_sector_in_master_sat));\n\th->h_num_sectors_in_master_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\th->h_master_sat[i] =\n\t\t    CDF_TOLE4(CAST(uint32_t, h->h_master_sat[i]));\n\t}\n}\n\nvoid\ncdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}\n\nvoid\ncdf_swap_dir(cdf_directory_t *d)\n{\n\td->d_namelen = CDF_TOLE2(d->d_namelen);\n\td->d_left_child = CDF_TOLE4(CAST(uint32_t, d->d_left_child));\n\td->d_right_child = CDF_TOLE4(CAST(uint32_t, d->d_right_child));\n\td->d_storage = CDF_TOLE4(CAST(uint32_t, d->d_storage));\n\td->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);\n\td->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);\n\td->d_flags = CDF_TOLE4(d->d_flags);\n\td->d_created = CDF_TOLE8(CAST(uint64_t, d->d_created));\n\td->d_modified = CDF_TOLE8(CAST(uint64_t, d->d_modified));\n\td->d_stream_first_sector = CDF_TOLE4(\n\t    CAST(uint32_t, d->d_stream_first_sector));\n\td->d_size = CDF_TOLE4(d->d_size);\n}\n\nvoid\ncdf_swap_class(cdf_classid_t *d)\n{\n\td->cl_dword = CDF_TOLE4(d->cl_dword);\n\td->cl_word[0] = CDF_TOLE2(d->cl_word[0]);\n\td->cl_word[1] = CDF_TOLE2(d->cl_word[1]);\n}\n\nvoid\ncdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}\n\nint\ncdf_zero_stream(cdf_stream_t *scn)\n{\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\tscn->sst_ss = 0;\n\tfree(scn->sst_tab);\n\tscn->sst_tab = NULL;\n\treturn -1;\n}\n\nstatic size_t\ncdf_check_stream(const cdf_stream_t *sst, const cdf_header_t *h)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tassert(ss == sst->sst_ss);\n\treturn sst->sst_ss;\n}\n\nstatic int\ncdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = RCAST(const char *, sst->sst_tab);\n\tconst char *e = RCAST(const char *, p) + tail;\n\tsize_t ss = cdf_check_stream(sst, h);\n\t/*LINTED*/(void)&line;\n\tif (e >= b && CAST(size_t, e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nstatic ssize_t\ncdf_read(const cdf_info_t *info, off_t off, void *buf, size_t len)\n{\n\tsize_t siz = CAST(size_t, off + len);\n\n\tif (CAST(off_t, off + len) != CAST(off_t, siz))\n\t\tgoto out;\n\n\tif (info->i_buf != NULL && info->i_len >= siz) {\n\t\t(void)memcpy(buf, &info->i_buf[off], len);\n\t\treturn CAST(ssize_t, len);\n\t}\n\n\tif (info->i_fd == -1)\n\t\tgoto out;\n\n\tif (pread(info->i_fd, buf, len, off) != CAST(ssize_t, len))\n\t\treturn -1;\n\n\treturn CAST(ssize_t, len);\nout:\n\terrno = EINVAL;\n\treturn -1;\n}\n\nint\ncdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, CAST(off_t, 0), buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic %#\" INT64_T_FORMAT \"x != %#\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size %hu\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size %hu\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n\nssize_t\ncdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tsize_t pos;\n\n\tif (SIZE_T_MAX / ss < CAST(size_t, id))\n\t\treturn -1;\n\n\tpos = CDF_SEC_POS(h, id);\n\tassert(ss == len);\n\treturn cdf_read(info, CAST(off_t, pos), RCAST(char *, buf) + offs, len);\n}\n\nssize_t\ncdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos;\n\n\tif (SIZE_T_MAX / ss < CAST(size_t, id))\n\t\treturn -1;\n\n\tpos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\tgoto out;\n\t}\n\t(void)memcpy(RCAST(char *, buf) + offs,\n\t    RCAST(const char *, sst->sst_tab) + pos, len);\n\treturn len;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n/*\n * Read the sector allocation table.\n */\nint\ncdf_read_sat(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat)\n{\n\tsize_t i, j, k;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t *msa, mid, sec;\n\tsize_t nsatpersec = (ss / sizeof(mid)) - 1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\n#define CDF_SEC_LIMIT (UINT32_MAX / (64 * ss))\n\tif ((nsatpersec > 0 &&\n\t    h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec) ||\n\t    i > CDF_SEC_LIMIT) {\n\t\tDPRINTF((\"Number of sectors in master SAT too big %u %\"\n\t\t    SIZE_T_FORMAT \"u\\n\", h->h_num_sectors_in_master_sat, i));\n\t\terrno = EFTYPE;\n\t\treturn -1;\n\t}\n\n\tsat->sat_len = h->h_num_sectors_in_master_sat * nsatpersec + i;\n\tDPRINTF((\"sat_len = %\" SIZE_T_FORMAT \"u ss = %\" SIZE_T_FORMAT \"u\\n\",\n\t    sat->sat_len, ss));\n\tif ((sat->sat_tab = CAST(cdf_secid_t *, CDF_CALLOC(sat->sat_len, ss)))\n\t    == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] < 0)\n\t\t\tbreak;\n\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t    h->h_master_sat[i]) != CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading sector %d\", h->h_master_sat[i]));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((msa = CAST(cdf_secid_t *, CDF_CALLOC(1, ss))) == NULL)\n\t\tgoto out1;\n\n\tmid = h->h_secid_first_sector_in_master_sat;\n\tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {\n\t\tif (mid < 0)\n\t\t\tgoto out;\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Reading master sector loop limit\"));\n\t\t\tgoto out3;\n\t\t}\n\t\tif (cdf_read_sector(info, msa, 0, ss, h, mid) !=\n\t\t    CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading master sector %d\", mid));\n\t\t\tgoto out2;\n\t\t}\n\t\tfor (k = 0; k < nsatpersec; k++, i++) {\n\t\t\tsec = CDF_TOLE4(CAST(uint32_t, msa[k]));\n\t\t\tif (sec < 0)\n\t\t\t\tgoto out;\n\t\t\tif (i >= sat->sat_len) {\n\t\t\t    DPRINTF((\"Out of bounds reading MSA %\"\n\t\t\t\tSIZE_T_FORMAT \"u >= %\" SIZE_T_FORMAT \"u\",\n\t\t\t\ti, sat->sat_len));\n\t\t\t    goto out3;\n\t\t\t}\n\t\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t\t    sec) != CAST(ssize_t, ss)) {\n\t\t\t\tDPRINTF((\"Reading sector %d\",\n\t\t\t\t    CDF_TOLE4(msa[k])));\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\t\tmid = CDF_TOLE4(CAST(uint32_t, msa[nsatpersec]));\n\t}\nout:\n\tsat->sat_len = i;\n\tfree(msa);\n\treturn 0;\nout3:\n\terrno = EFTYPE;\nout2:\n\tfree(msa);\nout1:\n\tfree(sat->sat_tab);\n\treturn -1;\n}\n\nsize_t\ncdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n{\n\tsize_t i, j;\n\tcdf_secid_t maxsector = CAST(cdf_secid_t, (sat->sat_len * size)\n\t    / sizeof(maxsector));\n\n\tDPRINTF((\"Chain:\"));\n\tif (sid == CDF_SECID_END_OF_CHAIN) {\n\t\t/* 0-length chain. */\n\t\tDPRINTF((\" empty\\n\"));\n\t\treturn 0;\n\t}\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (sid >= maxsector) {\n\t\t\tDPRINTF((\"Sector %d >= %d\\n\", sid, maxsector));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\" none, sid: %d\\n\", sid));\n\t\tgoto out;\n\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\nout:\n\terrno = EFTYPE;\n\treturn CAST(size_t, -1);\n}\n\nint\ncdf_read_long_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tssize_t nr;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(sat, sid, ss);\n\tscn->sst_dirlen = MAX(h->h_min_size_standard_stream, len);\n\tscn->sst_ss = ss;\n\n\tif (sid == CDF_SECID_END_OF_CHAIN || len == 0)\n\t\treturn cdf_zero_stream(scn);\n\n\tif (scn->sst_len == CAST(size_t, -1))\n\t\tgoto out;\n\n\tscn->sst_tab = CDF_CALLOC(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read long sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading long sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((nr = cdf_read_sector(info, scn->sst_tab, i * ss, ss, h,\n\t\t    sid)) != CAST(ssize_t, ss)) {\n\t\t\tif (i == scn->sst_len - 1 && nr > 0) {\n\t\t\t\t/* Last sector might be truncated */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tDPRINTF((\"Reading long sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}\n\nint\ncdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\tscn->sst_ss = ss;\n\n\tif (scn->sst_len == CAST(size_t, -1))\n\t\tgoto out;\n\n\tscn->sst_tab = CDF_CALLOC(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, ssat->sat_tab[sid]));\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}\n\nint\ncdf_read_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\n\tif (len < h->h_min_size_standard_stream && sst->sst_tab != NULL)\n\t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,\n\t\t    scn);\n\telse\n\t\treturn cdf_read_long_sector_chain(info, h, sat, sid, len, scn);\n}\n\nint\ncdf_read_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h), ns, nd;\n\tchar *buf;\n\tcdf_secid_t sid = h->h_secid_first_directory;\n\n\tns = cdf_count_chain(sat, sid, ss);\n\tif (ns == CAST(size_t, -1))\n\t\treturn -1;\n\n\tnd = ss / CDF_DIRECTORY_SIZE;\n\n\tdir->dir_len = ns * nd;\n\tdir->dir_tab = CAST(cdf_directory_t *,\n\t    CDF_CALLOC(dir->dir_len, sizeof(dir->dir_tab[0])));\n\tif (dir->dir_tab == NULL)\n\t\treturn -1;\n\n\tif ((buf = CAST(char *, CDF_MALLOC(ss))) == NULL) {\n\t\tfree(dir->dir_tab);\n\t\treturn -1;\n\t}\n\n\tfor (j = i = 0; i < ns; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read dir loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, buf, 0, ss, h, sid) !=\n\t\t    CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading directory sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < nd; j++) {\n\t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],\n\t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\tif (NEED_SWAP)\n\t\tfor (i = 0; i < dir->dir_len; i++)\n\t\t\tcdf_swap_dir(&dir->dir_tab[i]);\n\tfree(buf);\n\treturn 0;\nout:\n\tfree(dir->dir_tab);\n\tfree(buf);\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n\nint\ncdf_read_ssat(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_sat_t *ssat)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;\n\n\tssat->sat_tab = NULL;\n\tssat->sat_len = cdf_count_chain(sat, sid, ss);\n\tif (ssat->sat_len == CAST(size_t, -1))\n\t\tgoto out;\n\n\tssat->sat_tab = CAST(cdf_secid_t *, CDF_CALLOC(ssat->sat_len, ss));\n\tif (ssat->sat_tab == NULL)\n\t\tgoto out1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sat sector loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= ssat->sat_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    ssat->sat_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, ssat->sat_tab, i * ss, ss, h, sid) !=\n\t\t    CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading short sat sector %d\", sid));\n\t\t\tgoto out1;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\nout1:\n\tfree(ssat->sat_tab);\n\treturn -1;\n}\n\nint\ncdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (i == dir->dir_len) {\n\t\tDPRINTF((\"Cannot find root storage dir\\n\"));\n\t\tgoto out;\n\t}\n\td = &dir->dir_tab[i];\n\t*root = d;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (d->d_stream_first_sector < 0) {\n\t\tDPRINTF((\"No first secror in dir\\n\"));\n\t\tgoto out;\n\t}\n\n\treturn cdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\t(void)cdf_zero_stream(scn);\n\treturn 0;\n}\n\nstatic int\ncdf_namecmp(const char *d, const uint16_t *s, size_t l)\n{\n\tfor (; l--; d++, s++)\n\t\tif (*d != CDF_TOLE2(*s))\n\t\t\treturn CAST(unsigned char, *d) - CDF_TOLE2(*s);\n\treturn 0;\n}\n\nint\ncdf_read_doc_summary_info(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, cdf_stream_t *scn)\n{\n\treturn cdf_read_user_stream(info, h, sat, ssat, sst, dir,\n\t    \"\\05DocumentSummaryInformation\", scn);\n}\n\nint\ncdf_read_summary_info(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, cdf_stream_t *scn)\n{\n\treturn cdf_read_user_stream(info, h, sat, ssat, sst, dir,\n\t    \"\\05SummaryInformation\", scn);\n}\n\nint\ncdf_read_user_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)\n{\n\tconst cdf_directory_t *d;\n\tint i = cdf_find_stream(dir, name, CDF_DIR_TYPE_USER_STREAM);\n\n\tif (i <= 0) {\n\t\tmemset(scn, 0, sizeof(*scn));\n\t\treturn -1;\n\t}\n\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}\n\nint\ncdf_find_stream(const cdf_dir_t *dir, const char *name, int type)\n{\n\tsize_t i, name_len = strlen(name) + 1;\n\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == type &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, name_len)\n\t\t    == 0)\n\t\t\tbreak;\n\tif (i > 0)\n\t\treturn CAST(int, i);\n\n\tDPRINTF((\"Cannot find type %d `%s'\\n\", type, name));\n\terrno = ESRCH;\n\treturn 0;\n}\n\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 64)\n#define CDF_PROP_LIMIT (UINT32_MAX / (64 * sizeof(cdf_property_info_t)))\n\nstatic const void *\ncdf_offset(const void *p, size_t l)\n{\n\treturn CAST(const void *, CAST(const uint8_t *, p) + l);\n}\n\nstatic const uint8_t *\ncdf_get_property_info_pos(const cdf_stream_t *sst, const cdf_header_t *h,\n    const uint8_t *p, const uint8_t *e, size_t i)\n{\n\tsize_t tail = (i << 1) + 1;\n\tsize_t ofs;\n\tconst uint8_t *q;\n\n\tif (p >= e) {\n\t\tDPRINTF((\"Past end %p < %p\\n\", e, p));\n\t\treturn NULL;\n\t}\n\tif (cdf_check_stream_offset(sst, h, p, (tail + 1) * sizeof(uint32_t),\n\t    __LINE__) == -1)\n\t\treturn NULL;\n\tofs = CDF_GETUINT32(p, tail);\n\tq = CAST(const uint8_t *, cdf_offset(CAST(const void *, p),\n\t    ofs - 2 * sizeof(uint32_t)));\n\n\tif (q < p) {\n\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n\t\treturn NULL;\n\t}\n\n\tif (q >= e) {\n\t\tDPRINTF((\"Ran off the end %p >= %p\\n\", q, e));\n\t\treturn NULL;\n\t}\n\treturn q;\n}\n\nstatic cdf_property_info_t *\ncdf_grow_info(cdf_property_info_t **info, size_t *maxcount, size_t incr)\n{\n\tcdf_property_info_t *inp;\n\tsize_t newcount = *maxcount + incr;\n\n\tif (newcount > CDF_PROP_LIMIT) {\n\t\tDPRINTF((\"exceeded property limit %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\", newcount, CDF_PROP_LIMIT));\n\t\tgoto out;\n\t}\n\tinp = CAST(cdf_property_info_t *,\n\t    CDF_REALLOC(*info, newcount * sizeof(*inp)));\n\tif (inp == NULL)\n\t\tgoto out;\n\n\t*info = inp;\n\t*maxcount = newcount;\n\treturn inp;\nout:\n\tfree(*info);\n\t*maxcount = 0;\n\t*info = NULL;\n\treturn NULL;\n}\n\nstatic int\ncdf_copy_info(cdf_property_info_t *inp, const void *p, const void *e,\n    size_t len)\n{\n\tif (inp->pi_type & CDF_VECTOR)\n\t\treturn 0;\n\n\tif (CAST(size_t, CAST(const char *, e) - CAST(const char *, p)) < len)\n\t\treturn 0;\n\n\t(void)memcpy(&inp->pi_val, p, len);\n\n\tswitch (len) {\n\tcase 2:\n\t\tinp->pi_u16 = CDF_TOLE2(inp->pi_u16);\n\t\tbreak;\n\tcase 4:\n\t\tinp->pi_u32 = CDF_TOLE4(inp->pi_u32);\n\t\tbreak;\n\tcase 8:\n\t\tinp->pi_u64 = CDF_TOLE8(inp->pi_u64);\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\treturn 1;\n}\n\nint\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nint\ncdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, RCAST(const void *,\n\t    RCAST(const char *, sst->sst_tab)\n\t    + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE4(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,\n\t    count, &maxcount) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\n\n#define extract_catalog_field(t, f, l) \\\n    if (b + l + sizeof(cep->f) > eb) { \\\n\t    cep->ce_namlen = 0; \\\n\t    break; \\\n    } \\\n    memcpy(&cep->f, b + (l), sizeof(cep->f)); \\\n    ce[i].f = CAST(t, CDF_TOLE(cep->f))\n\nint\ncdf_unpack_catalog(const cdf_header_t *h, const cdf_stream_t *sst,\n    cdf_catalog_t **cat)\n{\n\tsize_t ss = cdf_check_stream(sst, h);\n\tconst char *b = CAST(const char *, sst->sst_tab);\n\tconst char *nb, *eb = b + ss * sst->sst_len;\n\tsize_t nr, i, j, k;\n\tcdf_catalog_entry_t *ce;\n\tuint16_t reclen;\n\tconst uint16_t *np;\n\n\tfor (nr = 0;; nr++) {\n\t\tmemcpy(&reclen, b, sizeof(reclen));\n\t\treclen = CDF_TOLE2(reclen);\n\t\tif (reclen == 0)\n\t\t\tbreak;\n\t\tb += reclen;\n\t\tif (b > eb)\n\t\t    break;\n\t}\n\tif (nr == 0)\n\t\treturn -1;\n\tnr--;\n\t*cat = CAST(cdf_catalog_t *,\n\t    CDF_MALLOC(sizeof(cdf_catalog_t) + nr * sizeof(*ce)));\n\tif (*cat == NULL)\n\t\treturn -1;\n\tce = (*cat)->cat_e;\n\tmemset(ce, 0, nr * sizeof(*ce));\n\tb = CAST(const char *, sst->sst_tab);\n\tfor (j = i = 0; i < nr; b += reclen) {\n\t\tcdf_catalog_entry_t *cep = &ce[j];\n\t\tuint16_t rlen;\n\n\t\textract_catalog_field(uint16_t, ce_namlen, 0);\n\t\textract_catalog_field(uint16_t, ce_num, 4);\n\t\textract_catalog_field(uint64_t, ce_timestamp, 8);\n\t\treclen = cep->ce_namlen;\n\n\t\tif (reclen < 14) {\n\t\t\tcep->ce_namlen = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcep->ce_namlen = __arraycount(cep->ce_name) - 1;\n\t\trlen = reclen - 14;\n\t\tif (cep->ce_namlen > rlen)\n\t\t\tcep->ce_namlen = rlen;\n\n\t\tnp = CAST(const uint16_t *, CAST(const void *, (b + 16)));\n\t\tnb = CAST(const char *, CAST(const void *,\n\t\t    (np + cep->ce_namlen)));\n\t\tif (nb > eb) {\n\t\t\tcep->ce_namlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (k = 0; k < cep->ce_namlen; k++)\n\t\t\tcep->ce_name[k] = np[k]; /* XXX: CDF_TOLE2? */\n\t\tcep->ce_name[cep->ce_namlen] = 0;\n\t\tj = i;\n\t\ti++;\n\t}\n\t(*cat)->cat_num = j;\n\treturn 0;\n}\n\nint\ncdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)\n{\n\treturn snprintf(buf, buflen, \"%.8x-%.4x-%.4x-%.2x%.2x-\"\n\t    \"%.2x%.2x%.2x%.2x%.2x%.2x\", id->cl_dword, id->cl_word[0],\n\t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],\n\t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],\n\t    id->cl_six[5]);\n}\n\nstatic const struct {\n\tuint32_t v;\n\tconst char *n;\n} vn[] = {\n\t{ CDF_PROPERTY_CODE_PAGE, \"Code page\" },\n\t{ CDF_PROPERTY_TITLE, \"Title\" },\n\t{ CDF_PROPERTY_SUBJECT, \"Subject\" },\n\t{ CDF_PROPERTY_AUTHOR, \"Author\" },\n\t{ CDF_PROPERTY_KEYWORDS, \"Keywords\" },\n\t{ CDF_PROPERTY_COMMENTS, \"Comments\" },\n\t{ CDF_PROPERTY_TEMPLATE, \"Template\" },\n\t{ CDF_PROPERTY_LAST_SAVED_BY, \"Last Saved By\" },\n\t{ CDF_PROPERTY_REVISION_NUMBER, \"Revision Number\" },\n\t{ CDF_PROPERTY_TOTAL_EDITING_TIME, \"Total Editing Time\" },\n\t{ CDF_PROPERTY_LAST_PRINTED, \"Last Printed\" },\n\t{ CDF_PROPERTY_CREATE_TIME, \"Create Time/Date\" },\n\t{ CDF_PROPERTY_LAST_SAVED_TIME, \"Last Saved Time/Date\" },\n\t{ CDF_PROPERTY_NUMBER_OF_PAGES, \"Number of Pages\" },\n\t{ CDF_PROPERTY_NUMBER_OF_WORDS, \"Number of Words\" },\n\t{ CDF_PROPERTY_NUMBER_OF_CHARACTERS, \"Number of Characters\" },\n\t{ CDF_PROPERTY_THUMBNAIL, \"Thumbnail\" },\n\t{ CDF_PROPERTY_NAME_OF_APPLICATION, \"Name of Creating Application\" },\n\t{ CDF_PROPERTY_SECURITY, \"Security\" },\n\t{ CDF_PROPERTY_LOCALE_ID, \"Locale ID\" },\n};\n\nint\ncdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < __arraycount(vn); i++)\n\t\tif (vn[i].v == p)\n\t\t\treturn snprintf(buf, bufsiz, \"%s\", vn[i].n);\n\treturn snprintf(buf, bufsiz, \"%#x\", p);\n}\n\nint\ncdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)\n{\n\tint len = 0;\n\tint days, hours, mins, secs;\n\n\tts /= CDF_TIME_PREC;\n\tsecs = CAST(int, ts % 60);\n\tts /= 60;\n\tmins = CAST(int, ts % 60);\n\tts /= 60;\n\thours = CAST(int, ts % 24);\n\tts /= 24;\n\tdays = CAST(int, ts);\n\n\tif (days) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%dd+\", days);\n\t\tif (CAST(size_t, len) >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tif (days || hours) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", hours);\n\t\tif (CAST(size_t, len) >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", mins);\n\tif (CAST(size_t, len) >= bufsiz)\n\t\treturn len;\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d\", secs);\n\treturn len;\n}\n\nchar *\ncdf_u16tos8(char *buf, size_t len, const uint16_t *p)\n{\n\tsize_t i;\n\tfor (i = 0; i < len && p[i]; i++)\n\t\tbuf[i] = CAST(char, p[i]);\n\tbuf[i] = '\\0';\n\treturn buf;\n}\n\n#ifdef CDF_DEBUG\nvoid\ncdf_dump_header(const cdf_header_t *h)\n{\n\tsize_t i;\n\n#define DUMP(a, b) (void)fprintf(stderr, \"%40.40s = \" a \"\\n\", # b, h->h_ ## b)\n#define DUMP2(a, b) (void)fprintf(stderr, \"%40.40s = \" a \" (\" a \")\\n\", # b, \\\n    h->h_ ## b, 1 << h->h_ ## b)\n\tDUMP(\"%d\", revision);\n\tDUMP(\"%d\", version);\n\tDUMP(\"%#x\", byte_order);\n\tDUMP2(\"%d\", sec_size_p2);\n\tDUMP2(\"%d\", short_sec_size_p2);\n\tDUMP(\"%d\", num_sectors_in_sat);\n\tDUMP(\"%d\", secid_first_directory);\n\tDUMP(\"%d\", min_size_standard_stream);\n\tDUMP(\"%d\", secid_first_sector_in_short_sat);\n\tDUMP(\"%d\", num_sectors_in_short_sat);\n\tDUMP(\"%d\", secid_first_sector_in_master_sat);\n\tDUMP(\"%d\", num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\t\t(void)fprintf(stderr, \"%35.35s[%.3\" SIZE_T_FORMAT \"u] = %d\\n\",\n\t\t    \"master_sat\", i, h->h_master_sat[i]);\n\t}\n}\n\nvoid\ncdf_dump_sat(const char *prefix, const cdf_sat_t *sat, size_t size)\n{\n\tsize_t i, j, s = size / sizeof(cdf_secid_t);\n\n\tfor (i = 0; i < sat->sat_len; i++) {\n\t\t(void)fprintf(stderr, \"%s[%\" SIZE_T_FORMAT \"u]:\\n%.6\"\n\t\t    SIZE_T_FORMAT \"u: \", prefix, i, i * s);\n\t\tfor (j = 0; j < s; j++) {\n\t\t\t(void)fprintf(stderr, \"%5d, \",\n\t\t\t    CDF_TOLE4(sat->sat_tab[s * i + j]));\n\t\t\tif ((j + 1) % 10 == 0)\n\t\t\t\t(void)fprintf(stderr, \"\\n%.6\" SIZE_T_FORMAT\n\t\t\t\t    \"u: \", i * s + j + 1);\n\t\t}\n\t\t(void)fprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\ncdf_dump(const void *v, size_t len)\n{\n\tsize_t i, j;\n\tconst unsigned char *p = v;\n\tchar abuf[16];\n\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}\n\nvoid\ncdf_dump_stream(const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_ss;\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}\n\nvoid\ncdf_dump_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tcdf_directory_t *d;\n\tchar name[__arraycount(d->d_name)];\n\tcdf_stream_t scn;\n\tstruct timespec ts;\n\n\tstatic const char *types[] = { \"empty\", \"user storage\",\n\t    \"user stream\", \"lockbytes\", \"property\", \"root storage\" };\n\n\tfor (i = 0; i < dir->dir_len; i++) {\n\t\tchar buf[26];\n\t\td = &dir->dir_tab[i];\n\t\tfor (j = 0; j < sizeof(name); j++)\n\t\t\tname[j] = (char)CDF_TOLE2(d->d_name[j]);\n\t\t(void)fprintf(stderr, \"Directory %\" SIZE_T_FORMAT \"u: %s\\n\",\n\t\t    i, name);\n\t\tif (d->d_type < __arraycount(types))\n\t\t\t(void)fprintf(stderr, \"Type: %s\\n\", types[d->d_type]);\n\t\telse\n\t\t\t(void)fprintf(stderr, \"Type: %d\\n\", d->d_type);\n\t\t(void)fprintf(stderr, \"Color: %s\\n\",\n\t\t    d->d_color ? \"black\" : \"red\");\n\t\t(void)fprintf(stderr, \"Left child: %d\\n\", d->d_left_child);\n\t\t(void)fprintf(stderr, \"Right child: %d\\n\", d->d_right_child);\n\t\t(void)fprintf(stderr, \"Flags: %#x\\n\", d->d_flags);\n\t\tcdf_timestamp_to_timespec(&ts, d->d_created);\n\t\t(void)fprintf(stderr, \"Created %s\", cdf_ctime(&ts.tv_sec, buf));\n\t\tcdf_timestamp_to_timespec(&ts, d->d_modified);\n\t\t(void)fprintf(stderr, \"Modified %s\",\n\t\t    cdf_ctime(&ts.tv_sec, buf));\n\t\t(void)fprintf(stderr, \"Stream %d\\n\", d->d_stream_first_sector);\n\t\t(void)fprintf(stderr, \"Size %d\\n\", d->d_size);\n\t\tswitch (d->d_type) {\n\t\tcase CDF_DIR_TYPE_USER_STORAGE:\n\t\t\t(void)fprintf(stderr, \"Storage: %d\\n\", d->d_storage);\n\t\t\tbreak;\n\t\tcase CDF_DIR_TYPE_USER_STREAM:\n\t\t\tif (sst == NULL)\n\t\t\t\tbreak;\n\t\t\tif (cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {\n\t\t\t\twarn(\"Can't read stream for %s at %d len %d\",\n\t\t\t\t    name, d->d_stream_first_sector, d->d_size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcdf_dump_stream(&scn);\n\t\t\tfree(scn.sst_tab);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n}\n\nvoid\ncdf_dump_property_info(const cdf_property_info_t *info, size_t count)\n{\n\tcdf_timestamp_t tp;\n\tstruct timespec ts;\n\tchar buf[64];\n\tsize_t i, j;\n\n\tfor (i = 0; i < count; i++) {\n\t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n\t\t(void)fprintf(stderr, \"%\" SIZE_T_FORMAT \"u) %s: \", i, buf);\n\t\tswitch (info[i].pi_type) {\n\t\tcase CDF_NULL:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\t(void)fprintf(stderr, \"signed 16 [%hd]\\n\",\n\t\t\t    info[i].pi_s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\t(void)fprintf(stderr, \"signed 32 [%d]\\n\",\n\t\t\t    info[i].pi_s32);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED32:\n\t\t\t(void)fprintf(stderr, \"unsigned 32 [%u]\\n\",\n\t\t\t    info[i].pi_u32);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\t(void)fprintf(stderr, \"float [%g]\\n\",\n\t\t\t    info[i].pi_f);\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\t(void)fprintf(stderr, \"double [%g]\\n\",\n\t\t\t    info[i].pi_d);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\t\t(void)fprintf(stderr, \"string %u [%.*s]\\n\",\n\t\t\t    info[i].pi_str.s_len,\n\t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\t(void)fprintf(stderr, \"string %u [\",\n\t\t\t    info[i].pi_str.s_len);\n\t\t\tfor (j = 0; j < info[i].pi_str.s_len - 1; j++)\n\t\t\t    (void)fputc(info[i].pi_str.s_buf[j << 1], stderr);\n\t\t\t(void)fprintf(stderr, \"]\\n\");\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\ttp = info[i].pi_tp;\n\t\t\tif (tp < 1000000000000000LL) {\n\t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\\n\", buf);\n\t\t\t} else {\n\t\t\t\tchar tbuf[26];\n\t\t\t\tcdf_timestamp_to_timespec(&ts, tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\",\n\t\t\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\t(void)fprintf(stderr, \"CLIPBOARD %u\\n\", info[i].pi_u32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    info[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid\ncdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tchar buf[128];\n\tcdf_summary_info_header_t ssi;\n\tcdf_property_info_t *info;\n\tsize_t count;\n\n\t(void)&h;\n\tif (cdf_unpack_summary_info(sst, h, &ssi, &info, &count) == -1)\n\t\treturn;\n\t(void)fprintf(stderr, \"Endian: %#x\\n\", ssi.si_byte_order);\n\t(void)fprintf(stderr, \"Os Version %d.%d\\n\", ssi.si_os_version & 0xff,\n\t    ssi.si_os_version >> 8);\n\t(void)fprintf(stderr, \"Os %d\\n\", ssi.si_os);\n\tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);\n\t(void)fprintf(stderr, \"Class %s\\n\", buf);\n\t(void)fprintf(stderr, \"Count %d\\n\", ssi.si_count);\n\tcdf_dump_property_info(info, count);\n\tfree(info);\n}\n\n\nvoid\ncdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}\n\n#endif\n\n#ifdef TEST\nint\nmain(int argc, char *argv[])\n{\n\tint i;\n\tcdf_header_t h;\n\tcdf_sat_t sat, ssat;\n\tcdf_stream_t sst, scn;\n\tcdf_dir_t dir;\n\tcdf_info_t info;\n\tconst cdf_directory_t *root;\n#ifdef __linux__\n#define getprogname() __progname\n\textern char *__progname;\n#endif\n\tif (argc < 2) {\n\t\t(void)fprintf(stderr, \"Usage: %s <filename>\\n\", getprogname());\n\t\treturn -1;\n\t}\n\n\tinfo.i_buf = NULL;\n\tinfo.i_len = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif ((info.i_fd = open(argv[1], O_RDONLY)) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot open `%s'\", argv[1]);\n\n\t\tif (cdf_read_header(&info, &h) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read header\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_header(&h);\n#endif\n\n\t\tif (cdf_read_sat(&info, &h, &sat) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read sat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_ssat(&info, &h, &sat, &ssat) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read ssat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_dir(&info, &h, &sat, &dir) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read dir\");\n\n\t\tif (cdf_read_short_stream(&info, &h, &sat, &dir, &sst, &root)\n\t\t    == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read short stream\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_stream(&sst);\n#endif\n\n#ifdef CDF_DEBUG\n\t\tcdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n\n\n\t\tif (cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n\t\t    &scn) == -1)\n\t\t\twarn(\"Cannot read summary info\");\n#ifdef CDF_DEBUG\n\t\telse\n\t\t\tcdf_dump_summary_info(&h, &scn);\n#endif\n\t\tif (cdf_read_user_stream(&info, &h, &sat, &ssat, &sst,\n\t\t    &dir, \"Catalog\", &scn) == -1)\n\t\t\twarn(\"Cannot read catalog\");\n#ifdef CDF_DEBUG\n\t\telse\n\t\t\tcdf_dump_catalog(&h, &scn);\n#endif\n\n\t\t(void)close(info.i_fd);\n\t}\n\n\treturn 0;\n}\n#endif\n", "/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parse Composite Document Files, the format used in Microsoft Office\n * document files before they switched to zipped XML.\n * Info from: http://sc.openoffice.org/compdocfileformat.pdf\n *\n * N.B. This is the \"Composite Document File\" format, and not the\n * \"Compound Document Format\", nor the \"Channel Definition Format\".\n */\n\n#ifndef _H_CDF_\n#define _H_CDF_\n\n#ifdef WIN32\n#include <winsock2.h>\n#define timespec timeval\n#define tv_nsec tv_usec\n#endif\n#ifdef __DJGPP__\n#define timespec timeval\n#define tv_nsec tv_usec\n#endif\n\ntypedef int32_t cdf_secid_t;\n\n#define CDF_LOOP_LIMIT\t\t\t\t\t10000\n\n#define CDF_SECID_NULL\t\t\t\t\t0\n#define CDF_SECID_FREE\t\t\t\t\t-1\n#define CDF_SECID_END_OF_CHAIN\t\t\t\t-2\n#define CDF_SECID_SECTOR_ALLOCATION_TABLE\t\t-3\n#define CDF_SECID_MASTER_SECTOR_ALLOCATION_TABLE\t-4\n\ntypedef struct {\n\tuint64_t\th_magic;\n#define CDF_MAGIC\t0xE11AB1A1E011CFD0LL\n\tuint64_t\th_uuid[2];\n\tuint16_t\th_revision;\n\tuint16_t\th_version;\n\tuint16_t\th_byte_order;\n\tuint16_t\th_sec_size_p2;\n\tuint16_t\th_short_sec_size_p2;\n\tuint8_t\t\th_unused0[10];\n\tuint32_t\th_num_sectors_in_sat;\n\tuint32_t\th_secid_first_directory;\n\tuint8_t\t\th_unused1[4];\n\tuint32_t\th_min_size_standard_stream;\n\tcdf_secid_t\th_secid_first_sector_in_short_sat;\n\tuint32_t\th_num_sectors_in_short_sat;\n\tcdf_secid_t\th_secid_first_sector_in_master_sat;\n\tuint32_t\th_num_sectors_in_master_sat;\n\tcdf_secid_t\th_master_sat[436/4];\n} cdf_header_t;\n\n#define CDF_SEC_SIZE(h) CAST(size_t, 1 << (h)->h_sec_size_p2)\n#define CDF_SEC_POS(h, secid) (CDF_SEC_SIZE(h) + (secid) * CDF_SEC_SIZE(h))\n#define CDF_SHORT_SEC_SIZE(h)\tCAST(size_t, 1 << (h)->h_short_sec_size_p2)\n#define CDF_SHORT_SEC_POS(h, secid) ((secid) * CDF_SHORT_SEC_SIZE(h))\n\ntypedef int32_t cdf_dirid_t;\n#define CDF_DIRID_NULL\t-1\n\ntypedef int64_t cdf_timestamp_t;\n#define CDF_BASE_YEAR\t1601\n#define CDF_TIME_PREC\t10000000\n\ntypedef struct {\n\tuint16_t\td_name[32];\n\tuint16_t\td_namelen;\n\tuint8_t\t\td_type;\n#define CDF_DIR_TYPE_EMPTY\t\t0\n#define CDF_DIR_TYPE_USER_STORAGE\t1\n#define CDF_DIR_TYPE_USER_STREAM\t2\n#define CDF_DIR_TYPE_LOCKBYTES\t\t3\n#define CDF_DIR_TYPE_PROPERTY\t\t4\n#define CDF_DIR_TYPE_ROOT_STORAGE\t5\n\tuint8_t\t\td_color;\n#define CDF_DIR_COLOR_READ\t0\n#define CDF_DIR_COLOR_BLACK\t1\n\tcdf_dirid_t\td_left_child;\n\tcdf_dirid_t\td_right_child;\n\tcdf_dirid_t\td_storage;\n\tuint64_t\td_storage_uuid[2];\n\tuint32_t\td_flags;\n\tcdf_timestamp_t d_created;\n\tcdf_timestamp_t d_modified;\n\tcdf_secid_t\td_stream_first_sector;\n\tuint32_t\td_size;\n\tuint32_t\td_unused0;\n} cdf_directory_t;\n\n#define CDF_DIRECTORY_SIZE\t128\n\ntypedef struct {\n\tcdf_secid_t *sat_tab;\n\tsize_t sat_len;\n} cdf_sat_t;\n\ntypedef struct {\n\tcdf_directory_t *dir_tab;\n\tsize_t dir_len;\n} cdf_dir_t;\n\ntypedef struct {\n\tvoid *sst_tab;\n\tsize_t sst_len;\t\t/* Number of sectors */\n\tsize_t sst_dirlen;\t/* Directory sector size */\n\tsize_t sst_ss;\t\t/* Sector size */\n} cdf_stream_t;\n\ntypedef struct {\n\tuint32_t\tcl_dword;\n\tuint16_t\tcl_word[2];\n\tuint8_t\t\tcl_two[2];\n\tuint8_t\t\tcl_six[6];\n} cdf_classid_t;\n\ntypedef struct {\n\tuint16_t\tsi_byte_order;\n\tuint16_t\tsi_zero;\n\tuint16_t\tsi_os_version;\n\tuint16_t\tsi_os;\n\tcdf_classid_t\tsi_class;\n\tuint32_t\tsi_count;\n} cdf_summary_info_header_t;\n\n#define CDF_SECTION_DECLARATION_OFFSET 0x1c\n\ntypedef struct {\n\tcdf_classid_t\tsd_class;\n\tuint32_t\tsd_offset;\n} cdf_section_declaration_t;\n\ntypedef struct {\n\tuint32_t\tsh_len;\n\tuint32_t\tsh_properties;\n} cdf_section_header_t;\n\ntypedef struct {\n\tuint32_t\tpi_id;\n\tuint32_t\tpi_type;\n\tunion {\n\t\tuint16_t\t_pi_u16;\n\t\tint16_t\t\t_pi_s16;\n\t\tuint32_t\t_pi_u32;\n\t\tint32_t\t\t_pi_s32;\n\t\tuint64_t\t_pi_u64;\n\t\tint64_t\t\t_pi_s64;\n\t\tcdf_timestamp_t _pi_tp;\n\t\tfloat\t\t_pi_f;\n\t\tdouble\t\t_pi_d;\n\t\tstruct {\n\t\t\tuint32_t s_len;\n\t\t\tconst char *s_buf;\n\t\t} _pi_str;\n\t} pi_val;\n#define pi_u64\tpi_val._pi_u64\n#define pi_s64\tpi_val._pi_s64\n#define pi_u32\tpi_val._pi_u32\n#define pi_s32\tpi_val._pi_s32\n#define pi_u16\tpi_val._pi_u16\n#define pi_s16\tpi_val._pi_s16\n#define pi_f\tpi_val._pi_f\n#define pi_d\tpi_val._pi_d\n#define pi_tp\tpi_val._pi_tp\n#define pi_str\tpi_val._pi_str\n} cdf_property_info_t;\n\n#define CDF_ROUND(val, by)     (((val) + (by) - 1) & ~((by) - 1))\n\n/* Variant type definitions */\n#define CDF_EMPTY\t\t0x00000000\n#define CDF_NULL\t\t0x00000001\n#define CDF_SIGNED16\t\t0x00000002\n#define CDF_SIGNED32\t\t0x00000003\n#define CDF_FLOAT\t\t0x00000004\n#define CDF_DOUBLE\t\t0x00000005\n#define CDF_CY\t\t\t0x00000006\n#define CDF_DATE\t\t0x00000007\n#define CDF_BSTR\t\t0x00000008\n#define CDF_DISPATCH\t\t0x00000009\n#define CDF_ERROR\t\t0x0000000a\n#define CDF_BOOL\t\t0x0000000b\n#define CDF_VARIANT\t\t0x0000000c\n#define CDF_UNKNOWN\t\t0x0000000d\n#define CDF_DECIMAL\t\t0x0000000e\n#define CDF_SIGNED8\t\t0x00000010\n#define CDF_UNSIGNED8\t\t0x00000011\n#define CDF_UNSIGNED16\t\t0x00000012\n#define CDF_UNSIGNED32\t\t0x00000013\n#define CDF_SIGNED64\t\t0x00000014\n#define CDF_UNSIGNED64\t\t0x00000015\n#define CDF_INT\t\t\t0x00000016\n#define CDF_UINT\t\t0x00000017\n#define CDF_VOID\t\t0x00000018\n#define CDF_HRESULT\t\t0x00000019\n#define CDF_PTR\t\t\t0x0000001a\n#define CDF_SAFEARRAY\t\t0x0000001b\n#define CDF_CARRAY\t\t0x0000001c\n#define CDF_USERDEFINED\t\t0x0000001d\n#define CDF_LENGTH32_STRING\t0x0000001e\n#define CDF_LENGTH32_WSTRING\t0x0000001f\n#define CDF_FILETIME\t\t0x00000040\n#define CDF_BLOB\t\t0x00000041\n#define CDF_STREAM\t\t0x00000042\n#define CDF_STORAGE\t\t0x00000043\n#define CDF_STREAMED_OBJECT\t0x00000044\n#define CDF_STORED_OBJECT\t0x00000045\n#define CDF_BLOB_OBJECT\t\t0x00000046\n#define CDF_CLIPBOARD\t\t0x00000047\n#define CDF_CLSID\t\t0x00000048\n#define CDF_VECTOR\t\t0x00001000\n#define CDF_ARRAY\t\t0x00002000\n#define CDF_BYREF\t\t0x00004000\n#define CDF_RESERVED\t\t0x00008000\n#define CDF_ILLEGAL\t\t0x0000ffff\n#define CDF_ILLEGALMASKED\t0x00000fff\n#define CDF_TYPEMASK\t\t0x00000fff\n\n#define CDF_PROPERTY_CODE_PAGE\t\t\t0x00000001\n#define CDF_PROPERTY_TITLE\t\t\t0x00000002\n#define CDF_PROPERTY_SUBJECT\t\t\t0x00000003\n#define CDF_PROPERTY_AUTHOR\t\t\t0x00000004\n#define CDF_PROPERTY_KEYWORDS\t\t\t0x00000005\n#define CDF_PROPERTY_COMMENTS\t\t\t0x00000006\n#define CDF_PROPERTY_TEMPLATE\t\t\t0x00000007\n#define CDF_PROPERTY_LAST_SAVED_BY\t\t0x00000008\n#define CDF_PROPERTY_REVISION_NUMBER\t\t0x00000009\n#define CDF_PROPERTY_TOTAL_EDITING_TIME\t\t0x0000000a\n#define CDF_PROPERTY_LAST_PRINTED\t\t0X0000000b\n#define CDF_PROPERTY_CREATE_TIME\t\t0x0000000c\n#define CDF_PROPERTY_LAST_SAVED_TIME\t\t0x0000000d\n#define CDF_PROPERTY_NUMBER_OF_PAGES\t\t0x0000000e\n#define CDF_PROPERTY_NUMBER_OF_WORDS\t\t0x0000000f\n#define CDF_PROPERTY_NUMBER_OF_CHARACTERS\t0x00000010\n#define CDF_PROPERTY_THUMBNAIL\t\t\t0x00000011\n#define CDF_PROPERTY_NAME_OF_APPLICATION\t0x00000012\n#define CDF_PROPERTY_SECURITY\t\t\t0x00000013\n#define CDF_PROPERTY_LOCALE_ID\t\t\t0x80000000\n\ntypedef struct {\n\tint i_fd;\n\tconst unsigned char *i_buf;\n\tsize_t i_len;\n} cdf_info_t;\n\n\ntypedef struct {\n\tuint16_t ce_namlen;\n\tuint32_t ce_num;\n\tuint64_t ce_timestamp;\n\tuint16_t ce_name[256];\n} cdf_catalog_entry_t;\n\ntypedef struct {\n\tsize_t cat_num;\n\tcdf_catalog_entry_t cat_e[1];\n} cdf_catalog_t;\n\nstruct timespec;\nint cdf_timestamp_to_timespec(struct timespec *, cdf_timestamp_t);\nint cdf_timespec_to_timestamp(cdf_timestamp_t *, const struct timespec *);\nint cdf_read_header(const cdf_info_t *, cdf_header_t *);\nvoid cdf_swap_header(cdf_header_t *);\nvoid cdf_unpack_header(cdf_header_t *, char *);\nvoid cdf_swap_dir(cdf_directory_t *);\nvoid cdf_unpack_dir(cdf_directory_t *, char *);\nvoid cdf_swap_class(cdf_classid_t *);\nssize_t cdf_read_sector(const cdf_info_t *, void *, size_t, size_t,\n    const cdf_header_t *, cdf_secid_t);\nssize_t cdf_read_short_sector(const cdf_stream_t *, void *, size_t, size_t,\n    const cdf_header_t *, cdf_secid_t);\nint cdf_read_sat(const cdf_info_t *, cdf_header_t *, cdf_sat_t *);\nsize_t cdf_count_chain(const cdf_sat_t *, cdf_secid_t, size_t);\nint cdf_read_long_sector_chain(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, cdf_secid_t, size_t, cdf_stream_t *);\nint cdf_read_short_sector_chain(const cdf_header_t *, const cdf_sat_t *,\n    const cdf_stream_t *, cdf_secid_t, size_t, cdf_stream_t *);\nint cdf_read_sector_chain(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *, cdf_secid_t,\n    size_t, cdf_stream_t *);\nint cdf_read_dir(const cdf_info_t *, const cdf_header_t *, const cdf_sat_t *,\n    cdf_dir_t *);\nint cdf_read_ssat(const cdf_info_t *, const cdf_header_t *, const cdf_sat_t *,\n    cdf_sat_t *);\nint cdf_read_short_stream(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_dir_t *, cdf_stream_t *,\n    const cdf_directory_t **);\nint cdf_read_property_info(const cdf_stream_t *, const cdf_header_t *, uint32_t,\n    cdf_property_info_t **, size_t *, size_t *);\nint cdf_read_user_stream(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *,\n    const cdf_dir_t *, const char *, cdf_stream_t *);\nint cdf_find_stream(const cdf_dir_t *, const char *, int);\nint cdf_zero_stream(cdf_stream_t *);\nint cdf_read_doc_summary_info(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *,\n    const cdf_dir_t *, cdf_stream_t *);\nint cdf_read_summary_info(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *,\n    const cdf_dir_t *, cdf_stream_t *);\nint cdf_unpack_summary_info(const cdf_stream_t *, const cdf_header_t *,\n    cdf_summary_info_header_t *, cdf_property_info_t **, size_t *);\nint cdf_unpack_catalog(const cdf_header_t *, const cdf_stream_t *,\n    cdf_catalog_t **);\nint cdf_print_classid(char *, size_t, const cdf_classid_t *);\nint cdf_print_property_name(char *, size_t, uint32_t);\nint cdf_print_elapsed_time(char *, size_t, cdf_timestamp_t);\nuint16_t cdf_tole2(uint16_t);\nuint32_t cdf_tole4(uint32_t);\nuint64_t cdf_tole8(uint64_t);\nchar *cdf_ctime(const time_t *, char *);\nchar *cdf_u16tos8(char *, size_t, const uint16_t *);\n\n#ifdef CDF_DEBUG\nvoid cdf_dump_header(const cdf_header_t *);\nvoid cdf_dump_sat(const char *, const cdf_sat_t *, size_t);\nvoid cdf_dump(const void *, size_t);\nvoid cdf_dump_stream(const cdf_stream_t *);\nvoid cdf_dump_dir(const cdf_info_t *, const cdf_header_t *, const cdf_sat_t *,\n    const cdf_sat_t *, const cdf_stream_t *, const cdf_dir_t *);\nvoid cdf_dump_property_info(const cdf_property_info_t *, size_t);\nvoid cdf_dump_summary_info(const cdf_header_t *, const cdf_stream_t *);\nvoid cdf_dump_catalog(const cdf_header_t *, const cdf_stream_t *);\n#endif\n\n\n#endif /* _H_CDF_ */\n"], "fixing_code": ["/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parse Composite Document Files, the format used in Microsoft Office\n * document files before they switched to zipped XML.\n * Info from: http://sc.openoffice.org/compdocfileformat.pdf\n *\n * N.B. This is the \"Composite Document File\" format, and not the\n * \"Compound Document Format\", nor the \"Channel Definition Format\".\n */\n\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: cdf.c,v 1.116 2019/08/26 14:31:39 christos Exp $\")\n#endif\n\n#include <assert.h>\n#ifdef CDF_DEBUG\n#include <err.h>\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <limits.h>\n\n#ifndef EFTYPE\n#define EFTYPE EINVAL\n#endif\n\n#ifndef SIZE_T_MAX\n#define SIZE_T_MAX CAST(size_t, ~0ULL)\n#endif\n\n#include \"cdf.h\"\n\n#ifdef CDF_DEBUG\n#define DPRINTF(a) printf a, fflush(stdout)\n#else\n#define DPRINTF(a)\n#endif\n\nstatic union {\n\tchar s[4];\n\tuint32_t u;\n} cdf_bo;\n\n#define NEED_SWAP\t(cdf_bo.u == CAST(uint32_t, 0x01020304))\n\n#define CDF_TOLE8(x)\t\\\n    (CAST(uint64_t, NEED_SWAP ? _cdf_tole8(x) : CAST(uint64_t, x)))\n#define CDF_TOLE4(x)\t\\\n    (CAST(uint32_t, NEED_SWAP ? _cdf_tole4(x) : CAST(uint32_t, x)))\n#define CDF_TOLE2(x)\t\\\n    (CAST(uint16_t, NEED_SWAP ? _cdf_tole2(x) : CAST(uint16_t, x)))\n#define CDF_TOLE(x)\t(/*CONSTCOND*/sizeof(x) == 2 ? \\\n\t\t\t    CDF_TOLE2(CAST(uint16_t, x)) : \\\n\t\t\t(/*CONSTCOND*/sizeof(x) == 4 ? \\\n\t\t\t    CDF_TOLE4(CAST(uint32_t, x)) : \\\n\t\t\t    CDF_TOLE8(CAST(uint64_t, x))))\n#define CDF_GETUINT32(x, y)\tcdf_getuint32(x, y)\n\n#define CDF_MALLOC(n) cdf_malloc(__FILE__, __LINE__, (n))\n#define CDF_REALLOC(p, n) cdf_realloc(__FILE__, __LINE__, (p), (n))\n#define CDF_CALLOC(n, u) cdf_calloc(__FILE__, __LINE__, (n), (u))\n\n\n/*ARGSUSED*/\nstatic void *\ncdf_malloc(const char *file __attribute__((__unused__)),\n    size_t line __attribute__((__unused__)), size_t n)\n{\n\tDPRINTF((\"%s,%\" SIZE_T_FORMAT \"u: %s %\" SIZE_T_FORMAT \"u\\n\",\n\t    file, line, __func__, n));\n\treturn malloc(n);\n}\n\n/*ARGSUSED*/\nstatic void *\ncdf_realloc(const char *file __attribute__((__unused__)),\n    size_t line __attribute__((__unused__)), void *p, size_t n)\n{\n\tDPRINTF((\"%s,%\" SIZE_T_FORMAT \"u: %s %\" SIZE_T_FORMAT \"u\\n\",\n\t    file, line, __func__, n));\n\treturn realloc(p, n);\n}\n\n/*ARGSUSED*/\nstatic void *\ncdf_calloc(const char *file __attribute__((__unused__)),\n    size_t line __attribute__((__unused__)), size_t n, size_t u)\n{\n\tDPRINTF((\"%s,%\" SIZE_T_FORMAT \"u: %s %\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u\\n\", file, line, __func__, n, u));\n\treturn calloc(n, u);\n}\n\n/*\n * swap a short\n */\nstatic uint16_t\n_cdf_tole2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));\n\tuint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));\n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}\n\n/*\n * swap an int\n */\nstatic uint32_t\n_cdf_tole4(uint32_t sv)\n{\n\tuint32_t rv;\n\tuint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));\n\tuint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));\n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\treturn rv;\n}\n\n/*\n * swap a quad\n */\nstatic uint64_t\n_cdf_tole8(uint64_t sv)\n{\n\tuint64_t rv;\n\tuint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));\n\tuint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));\n\td[0] = s[7];\n\td[1] = s[6];\n\td[2] = s[5];\n\td[3] = s[4];\n\td[4] = s[3];\n\td[5] = s[2];\n\td[6] = s[1];\n\td[7] = s[0];\n\treturn rv;\n}\n\n/*\n * grab a uint32_t from a possibly unaligned address, and return it in\n * the native host order.\n */\nstatic uint32_t\ncdf_getuint32(const uint8_t *p, size_t offs)\n{\n\tuint32_t rv;\n\t(void)memcpy(&rv, p + offs * sizeof(uint32_t), sizeof(rv));\n\treturn CDF_TOLE4(rv);\n}\n\n#define CDF_UNPACK(a)\t\\\n    (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)\n#define CDF_UNPACKA(a)\t\\\n    (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)\n\nuint16_t\ncdf_tole2(uint16_t sv)\n{\n\treturn CDF_TOLE2(sv);\n}\n\nuint32_t\ncdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}\n\nuint64_t\ncdf_tole8(uint64_t sv)\n{\n\treturn CDF_TOLE8(sv);\n}\n\nvoid\ncdf_swap_header(cdf_header_t *h)\n{\n\tsize_t i;\n\n\th->h_magic = CDF_TOLE8(h->h_magic);\n\th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);\n\th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);\n\th->h_revision = CDF_TOLE2(h->h_revision);\n\th->h_version = CDF_TOLE2(h->h_version);\n\th->h_byte_order = CDF_TOLE2(h->h_byte_order);\n\th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);\n\th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);\n\th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);\n\th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);\n\th->h_min_size_standard_stream =\n\t    CDF_TOLE4(h->h_min_size_standard_stream);\n\th->h_secid_first_sector_in_short_sat =\n\t    CDF_TOLE4(CAST(uint32_t, h->h_secid_first_sector_in_short_sat));\n\th->h_num_sectors_in_short_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_short_sat);\n\th->h_secid_first_sector_in_master_sat =\n\t    CDF_TOLE4(CAST(uint32_t, h->h_secid_first_sector_in_master_sat));\n\th->h_num_sectors_in_master_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\th->h_master_sat[i] =\n\t\t    CDF_TOLE4(CAST(uint32_t, h->h_master_sat[i]));\n\t}\n}\n\nvoid\ncdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}\n\nvoid\ncdf_swap_dir(cdf_directory_t *d)\n{\n\td->d_namelen = CDF_TOLE2(d->d_namelen);\n\td->d_left_child = CDF_TOLE4(CAST(uint32_t, d->d_left_child));\n\td->d_right_child = CDF_TOLE4(CAST(uint32_t, d->d_right_child));\n\td->d_storage = CDF_TOLE4(CAST(uint32_t, d->d_storage));\n\td->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);\n\td->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);\n\td->d_flags = CDF_TOLE4(d->d_flags);\n\td->d_created = CDF_TOLE8(CAST(uint64_t, d->d_created));\n\td->d_modified = CDF_TOLE8(CAST(uint64_t, d->d_modified));\n\td->d_stream_first_sector = CDF_TOLE4(\n\t    CAST(uint32_t, d->d_stream_first_sector));\n\td->d_size = CDF_TOLE4(d->d_size);\n}\n\nvoid\ncdf_swap_class(cdf_classid_t *d)\n{\n\td->cl_dword = CDF_TOLE4(d->cl_dword);\n\td->cl_word[0] = CDF_TOLE2(d->cl_word[0]);\n\td->cl_word[1] = CDF_TOLE2(d->cl_word[1]);\n}\n\nvoid\ncdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}\n\nint\ncdf_zero_stream(cdf_stream_t *scn)\n{\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\tscn->sst_ss = 0;\n\tfree(scn->sst_tab);\n\tscn->sst_tab = NULL;\n\treturn -1;\n}\n\nstatic size_t\ncdf_check_stream(const cdf_stream_t *sst, const cdf_header_t *h)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tassert(ss == sst->sst_ss);\n\treturn sst->sst_ss;\n}\n\nstatic int\ncdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = RCAST(const char *, sst->sst_tab);\n\tconst char *e = RCAST(const char *, p) + tail;\n\tsize_t ss = cdf_check_stream(sst, h);\n\t/*LINTED*/(void)&line;\n\tif (e >= b && CAST(size_t, e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nstatic ssize_t\ncdf_read(const cdf_info_t *info, off_t off, void *buf, size_t len)\n{\n\tsize_t siz = CAST(size_t, off + len);\n\n\tif (CAST(off_t, off + len) != CAST(off_t, siz))\n\t\tgoto out;\n\n\tif (info->i_buf != NULL && info->i_len >= siz) {\n\t\t(void)memcpy(buf, &info->i_buf[off], len);\n\t\treturn CAST(ssize_t, len);\n\t}\n\n\tif (info->i_fd == -1)\n\t\tgoto out;\n\n\tif (pread(info->i_fd, buf, len, off) != CAST(ssize_t, len))\n\t\treturn -1;\n\n\treturn CAST(ssize_t, len);\nout:\n\terrno = EINVAL;\n\treturn -1;\n}\n\nint\ncdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, CAST(off_t, 0), buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic %#\" INT64_T_FORMAT \"x != %#\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size %hu\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size %hu\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n\nssize_t\ncdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tsize_t pos;\n\n\tif (SIZE_T_MAX / ss < CAST(size_t, id))\n\t\treturn -1;\n\n\tpos = CDF_SEC_POS(h, id);\n\tassert(ss == len);\n\treturn cdf_read(info, CAST(off_t, pos), RCAST(char *, buf) + offs, len);\n}\n\nssize_t\ncdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos;\n\n\tif (SIZE_T_MAX / ss < CAST(size_t, id))\n\t\treturn -1;\n\n\tpos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\tgoto out;\n\t}\n\t(void)memcpy(RCAST(char *, buf) + offs,\n\t    RCAST(const char *, sst->sst_tab) + pos, len);\n\treturn len;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n/*\n * Read the sector allocation table.\n */\nint\ncdf_read_sat(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat)\n{\n\tsize_t i, j, k;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t *msa, mid, sec;\n\tsize_t nsatpersec = (ss / sizeof(mid)) - 1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\n#define CDF_SEC_LIMIT (UINT32_MAX / (64 * ss))\n\tif ((nsatpersec > 0 &&\n\t    h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec) ||\n\t    i > CDF_SEC_LIMIT) {\n\t\tDPRINTF((\"Number of sectors in master SAT too big %u %\"\n\t\t    SIZE_T_FORMAT \"u\\n\", h->h_num_sectors_in_master_sat, i));\n\t\terrno = EFTYPE;\n\t\treturn -1;\n\t}\n\n\tsat->sat_len = h->h_num_sectors_in_master_sat * nsatpersec + i;\n\tDPRINTF((\"sat_len = %\" SIZE_T_FORMAT \"u ss = %\" SIZE_T_FORMAT \"u\\n\",\n\t    sat->sat_len, ss));\n\tif ((sat->sat_tab = CAST(cdf_secid_t *, CDF_CALLOC(sat->sat_len, ss)))\n\t    == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] < 0)\n\t\t\tbreak;\n\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t    h->h_master_sat[i]) != CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading sector %d\", h->h_master_sat[i]));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((msa = CAST(cdf_secid_t *, CDF_CALLOC(1, ss))) == NULL)\n\t\tgoto out1;\n\n\tmid = h->h_secid_first_sector_in_master_sat;\n\tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {\n\t\tif (mid < 0)\n\t\t\tgoto out;\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Reading master sector loop limit\"));\n\t\t\tgoto out3;\n\t\t}\n\t\tif (cdf_read_sector(info, msa, 0, ss, h, mid) !=\n\t\t    CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading master sector %d\", mid));\n\t\t\tgoto out2;\n\t\t}\n\t\tfor (k = 0; k < nsatpersec; k++, i++) {\n\t\t\tsec = CDF_TOLE4(CAST(uint32_t, msa[k]));\n\t\t\tif (sec < 0)\n\t\t\t\tgoto out;\n\t\t\tif (i >= sat->sat_len) {\n\t\t\t    DPRINTF((\"Out of bounds reading MSA %\"\n\t\t\t\tSIZE_T_FORMAT \"u >= %\" SIZE_T_FORMAT \"u\",\n\t\t\t\ti, sat->sat_len));\n\t\t\t    goto out3;\n\t\t\t}\n\t\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t\t    sec) != CAST(ssize_t, ss)) {\n\t\t\t\tDPRINTF((\"Reading sector %d\",\n\t\t\t\t    CDF_TOLE4(msa[k])));\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\t\tmid = CDF_TOLE4(CAST(uint32_t, msa[nsatpersec]));\n\t}\nout:\n\tsat->sat_len = i;\n\tfree(msa);\n\treturn 0;\nout3:\n\terrno = EFTYPE;\nout2:\n\tfree(msa);\nout1:\n\tfree(sat->sat_tab);\n\treturn -1;\n}\n\nsize_t\ncdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n{\n\tsize_t i, j;\n\tcdf_secid_t maxsector = CAST(cdf_secid_t, (sat->sat_len * size)\n\t    / sizeof(maxsector));\n\n\tDPRINTF((\"Chain:\"));\n\tif (sid == CDF_SECID_END_OF_CHAIN) {\n\t\t/* 0-length chain. */\n\t\tDPRINTF((\" empty\\n\"));\n\t\treturn 0;\n\t}\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (sid >= maxsector) {\n\t\t\tDPRINTF((\"Sector %d >= %d\\n\", sid, maxsector));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\" none, sid: %d\\n\", sid));\n\t\tgoto out;\n\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\nout:\n\terrno = EFTYPE;\n\treturn CAST(size_t, -1);\n}\n\nint\ncdf_read_long_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tssize_t nr;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(sat, sid, ss);\n\tscn->sst_dirlen = MAX(h->h_min_size_standard_stream, len);\n\tscn->sst_ss = ss;\n\n\tif (sid == CDF_SECID_END_OF_CHAIN || len == 0)\n\t\treturn cdf_zero_stream(scn);\n\n\tif (scn->sst_len == CAST(size_t, -1))\n\t\tgoto out;\n\n\tscn->sst_tab = CDF_CALLOC(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read long sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading long sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((nr = cdf_read_sector(info, scn->sst_tab, i * ss, ss, h,\n\t\t    sid)) != CAST(ssize_t, ss)) {\n\t\t\tif (i == scn->sst_len - 1 && nr > 0) {\n\t\t\t\t/* Last sector might be truncated */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tDPRINTF((\"Reading long sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}\n\nint\ncdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\tscn->sst_ss = ss;\n\n\tif (scn->sst_len == CAST(size_t, -1))\n\t\tgoto out;\n\n\tscn->sst_tab = CDF_CALLOC(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, ssat->sat_tab[sid]));\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}\n\nint\ncdf_read_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\n\tif (len < h->h_min_size_standard_stream && sst->sst_tab != NULL)\n\t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,\n\t\t    scn);\n\telse\n\t\treturn cdf_read_long_sector_chain(info, h, sat, sid, len, scn);\n}\n\nint\ncdf_read_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h), ns, nd;\n\tchar *buf;\n\tcdf_secid_t sid = h->h_secid_first_directory;\n\n\tns = cdf_count_chain(sat, sid, ss);\n\tif (ns == CAST(size_t, -1))\n\t\treturn -1;\n\n\tnd = ss / CDF_DIRECTORY_SIZE;\n\n\tdir->dir_len = ns * nd;\n\tdir->dir_tab = CAST(cdf_directory_t *,\n\t    CDF_CALLOC(dir->dir_len, sizeof(dir->dir_tab[0])));\n\tif (dir->dir_tab == NULL)\n\t\treturn -1;\n\n\tif ((buf = CAST(char *, CDF_MALLOC(ss))) == NULL) {\n\t\tfree(dir->dir_tab);\n\t\treturn -1;\n\t}\n\n\tfor (j = i = 0; i < ns; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read dir loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, buf, 0, ss, h, sid) !=\n\t\t    CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading directory sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < nd; j++) {\n\t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],\n\t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\tif (NEED_SWAP)\n\t\tfor (i = 0; i < dir->dir_len; i++)\n\t\t\tcdf_swap_dir(&dir->dir_tab[i]);\n\tfree(buf);\n\treturn 0;\nout:\n\tfree(dir->dir_tab);\n\tfree(buf);\n\terrno = EFTYPE;\n\treturn -1;\n}\n\n\nint\ncdf_read_ssat(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_sat_t *ssat)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;\n\n\tssat->sat_tab = NULL;\n\tssat->sat_len = cdf_count_chain(sat, sid, ss);\n\tif (ssat->sat_len == CAST(size_t, -1))\n\t\tgoto out;\n\n\tssat->sat_tab = CAST(cdf_secid_t *, CDF_CALLOC(ssat->sat_len, ss));\n\tif (ssat->sat_tab == NULL)\n\t\tgoto out1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sat sector loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= ssat->sat_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    ssat->sat_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, ssat->sat_tab, i * ss, ss, h, sid) !=\n\t\t    CAST(ssize_t, ss)) {\n\t\t\tDPRINTF((\"Reading short sat sector %d\", sid));\n\t\t\tgoto out1;\n\t\t}\n\t\tsid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\nout1:\n\tfree(ssat->sat_tab);\n\treturn -1;\n}\n\nint\ncdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (i == dir->dir_len) {\n\t\tDPRINTF((\"Cannot find root storage dir\\n\"));\n\t\tgoto out;\n\t}\n\td = &dir->dir_tab[i];\n\t*root = d;\n\n\t/* If the it is not there, just fake it; some docs don't have it */\n\tif (d->d_stream_first_sector < 0) {\n\t\tDPRINTF((\"No first secror in dir\\n\"));\n\t\tgoto out;\n\t}\n\n\treturn cdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\t(void)cdf_zero_stream(scn);\n\treturn 0;\n}\n\nstatic int\ncdf_namecmp(const char *d, const uint16_t *s, size_t l)\n{\n\tfor (; l--; d++, s++)\n\t\tif (*d != CDF_TOLE2(*s))\n\t\t\treturn CAST(unsigned char, *d) - CDF_TOLE2(*s);\n\treturn 0;\n}\n\nint\ncdf_read_doc_summary_info(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, cdf_stream_t *scn)\n{\n\treturn cdf_read_user_stream(info, h, sat, ssat, sst, dir,\n\t    \"\\05DocumentSummaryInformation\", scn);\n}\n\nint\ncdf_read_summary_info(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, cdf_stream_t *scn)\n{\n\treturn cdf_read_user_stream(info, h, sat, ssat, sst, dir,\n\t    \"\\05SummaryInformation\", scn);\n}\n\nint\ncdf_read_user_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)\n{\n\tconst cdf_directory_t *d;\n\tint i = cdf_find_stream(dir, name, CDF_DIR_TYPE_USER_STREAM);\n\n\tif (i <= 0) {\n\t\tmemset(scn, 0, sizeof(*scn));\n\t\treturn -1;\n\t}\n\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}\n\nint\ncdf_find_stream(const cdf_dir_t *dir, const char *name, int type)\n{\n\tsize_t i, name_len = strlen(name) + 1;\n\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == type &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, name_len)\n\t\t    == 0)\n\t\t\tbreak;\n\tif (i > 0)\n\t\treturn CAST(int, i);\n\n\tDPRINTF((\"Cannot find type %d `%s'\\n\", type, name));\n\terrno = ESRCH;\n\treturn 0;\n}\n\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 64)\n#define CDF_PROP_LIMIT (UINT32_MAX / (64 * sizeof(cdf_property_info_t)))\n\nstatic const void *\ncdf_offset(const void *p, size_t l)\n{\n\treturn CAST(const void *, CAST(const uint8_t *, p) + l);\n}\n\nstatic const uint8_t *\ncdf_get_property_info_pos(const cdf_stream_t *sst, const cdf_header_t *h,\n    const uint8_t *p, const uint8_t *e, size_t i)\n{\n\tsize_t tail = (i << 1) + 1;\n\tsize_t ofs;\n\tconst uint8_t *q;\n\n\tif (p >= e) {\n\t\tDPRINTF((\"Past end %p < %p\\n\", e, p));\n\t\treturn NULL;\n\t}\n\tif (cdf_check_stream_offset(sst, h, p, (tail + 1) * sizeof(uint32_t),\n\t    __LINE__) == -1)\n\t\treturn NULL;\n\tofs = CDF_GETUINT32(p, tail);\n\tq = CAST(const uint8_t *, cdf_offset(CAST(const void *, p),\n\t    ofs - 2 * sizeof(uint32_t)));\n\n\tif (q < p) {\n\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n\t\treturn NULL;\n\t}\n\n\tif (q >= e) {\n\t\tDPRINTF((\"Ran off the end %p >= %p\\n\", q, e));\n\t\treturn NULL;\n\t}\n\treturn q;\n}\n\nstatic cdf_property_info_t *\ncdf_grow_info(cdf_property_info_t **info, size_t *maxcount, size_t incr)\n{\n\tcdf_property_info_t *inp;\n\tsize_t newcount = *maxcount + incr;\n\n\tif (newcount > CDF_PROP_LIMIT) {\n\t\tDPRINTF((\"exceeded property limit %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\", newcount, CDF_PROP_LIMIT));\n\t\tgoto out;\n\t}\n\tinp = CAST(cdf_property_info_t *,\n\t    CDF_REALLOC(*info, newcount * sizeof(*inp)));\n\tif (inp == NULL)\n\t\tgoto out;\n\n\t*info = inp;\n\t*maxcount = newcount;\n\treturn inp;\nout:\n\tfree(*info);\n\t*maxcount = 0;\n\t*info = NULL;\n\treturn NULL;\n}\n\nstatic int\ncdf_copy_info(cdf_property_info_t *inp, const void *p, const void *e,\n    size_t len)\n{\n\tif (inp->pi_type & CDF_VECTOR)\n\t\treturn 0;\n\n\tif (CAST(size_t, CAST(const char *, e) - CAST(const char *, p)) < len)\n\t\treturn 0;\n\n\t(void)memcpy(&inp->pi_val, p, len);\n\n\tswitch (len) {\n\tcase 2:\n\t\tinp->pi_u16 = CDF_TOLE2(inp->pi_u16);\n\t\tbreak;\n\tcase 4:\n\t\tinp->pi_u32 = CDF_TOLE4(inp->pi_u32);\n\t\tbreak;\n\tcase 8:\n\t\tinp->pi_u64 = CDF_TOLE8(inp->pi_u64);\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\treturn 1;\n}\n\nint\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements > CDF_ELEMENT_LIMIT || nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == %\"\n\t\t\t\t    SIZE_T_FORMAT \"u\\n\", nelements));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nint\ncdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, RCAST(const void *,\n\t    RCAST(const char *, sst->sst_tab)\n\t    + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE4(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,\n\t    count, &maxcount) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\n\n#define extract_catalog_field(t, f, l) \\\n    if (b + l + sizeof(cep->f) > eb) { \\\n\t    cep->ce_namlen = 0; \\\n\t    break; \\\n    } \\\n    memcpy(&cep->f, b + (l), sizeof(cep->f)); \\\n    ce[i].f = CAST(t, CDF_TOLE(cep->f))\n\nint\ncdf_unpack_catalog(const cdf_header_t *h, const cdf_stream_t *sst,\n    cdf_catalog_t **cat)\n{\n\tsize_t ss = cdf_check_stream(sst, h);\n\tconst char *b = CAST(const char *, sst->sst_tab);\n\tconst char *nb, *eb = b + ss * sst->sst_len;\n\tsize_t nr, i, j, k;\n\tcdf_catalog_entry_t *ce;\n\tuint16_t reclen;\n\tconst uint16_t *np;\n\n\tfor (nr = 0;; nr++) {\n\t\tmemcpy(&reclen, b, sizeof(reclen));\n\t\treclen = CDF_TOLE2(reclen);\n\t\tif (reclen == 0)\n\t\t\tbreak;\n\t\tb += reclen;\n\t\tif (b > eb)\n\t\t    break;\n\t}\n\tif (nr == 0)\n\t\treturn -1;\n\tnr--;\n\t*cat = CAST(cdf_catalog_t *,\n\t    CDF_MALLOC(sizeof(cdf_catalog_t) + nr * sizeof(*ce)));\n\tif (*cat == NULL)\n\t\treturn -1;\n\tce = (*cat)->cat_e;\n\tmemset(ce, 0, nr * sizeof(*ce));\n\tb = CAST(const char *, sst->sst_tab);\n\tfor (j = i = 0; i < nr; b += reclen) {\n\t\tcdf_catalog_entry_t *cep = &ce[j];\n\t\tuint16_t rlen;\n\n\t\textract_catalog_field(uint16_t, ce_namlen, 0);\n\t\textract_catalog_field(uint16_t, ce_num, 4);\n\t\textract_catalog_field(uint64_t, ce_timestamp, 8);\n\t\treclen = cep->ce_namlen;\n\n\t\tif (reclen < 14) {\n\t\t\tcep->ce_namlen = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcep->ce_namlen = __arraycount(cep->ce_name) - 1;\n\t\trlen = reclen - 14;\n\t\tif (cep->ce_namlen > rlen)\n\t\t\tcep->ce_namlen = rlen;\n\n\t\tnp = CAST(const uint16_t *, CAST(const void *, (b + 16)));\n\t\tnb = CAST(const char *, CAST(const void *,\n\t\t    (np + cep->ce_namlen)));\n\t\tif (nb > eb) {\n\t\t\tcep->ce_namlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (k = 0; k < cep->ce_namlen; k++)\n\t\t\tcep->ce_name[k] = np[k]; /* XXX: CDF_TOLE2? */\n\t\tcep->ce_name[cep->ce_namlen] = 0;\n\t\tj = i;\n\t\ti++;\n\t}\n\t(*cat)->cat_num = j;\n\treturn 0;\n}\n\nint\ncdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)\n{\n\treturn snprintf(buf, buflen, \"%.8x-%.4x-%.4x-%.2x%.2x-\"\n\t    \"%.2x%.2x%.2x%.2x%.2x%.2x\", id->cl_dword, id->cl_word[0],\n\t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],\n\t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],\n\t    id->cl_six[5]);\n}\n\nstatic const struct {\n\tuint32_t v;\n\tconst char *n;\n} vn[] = {\n\t{ CDF_PROPERTY_CODE_PAGE, \"Code page\" },\n\t{ CDF_PROPERTY_TITLE, \"Title\" },\n\t{ CDF_PROPERTY_SUBJECT, \"Subject\" },\n\t{ CDF_PROPERTY_AUTHOR, \"Author\" },\n\t{ CDF_PROPERTY_KEYWORDS, \"Keywords\" },\n\t{ CDF_PROPERTY_COMMENTS, \"Comments\" },\n\t{ CDF_PROPERTY_TEMPLATE, \"Template\" },\n\t{ CDF_PROPERTY_LAST_SAVED_BY, \"Last Saved By\" },\n\t{ CDF_PROPERTY_REVISION_NUMBER, \"Revision Number\" },\n\t{ CDF_PROPERTY_TOTAL_EDITING_TIME, \"Total Editing Time\" },\n\t{ CDF_PROPERTY_LAST_PRINTED, \"Last Printed\" },\n\t{ CDF_PROPERTY_CREATE_TIME, \"Create Time/Date\" },\n\t{ CDF_PROPERTY_LAST_SAVED_TIME, \"Last Saved Time/Date\" },\n\t{ CDF_PROPERTY_NUMBER_OF_PAGES, \"Number of Pages\" },\n\t{ CDF_PROPERTY_NUMBER_OF_WORDS, \"Number of Words\" },\n\t{ CDF_PROPERTY_NUMBER_OF_CHARACTERS, \"Number of Characters\" },\n\t{ CDF_PROPERTY_THUMBNAIL, \"Thumbnail\" },\n\t{ CDF_PROPERTY_NAME_OF_APPLICATION, \"Name of Creating Application\" },\n\t{ CDF_PROPERTY_SECURITY, \"Security\" },\n\t{ CDF_PROPERTY_LOCALE_ID, \"Locale ID\" },\n};\n\nint\ncdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < __arraycount(vn); i++)\n\t\tif (vn[i].v == p)\n\t\t\treturn snprintf(buf, bufsiz, \"%s\", vn[i].n);\n\treturn snprintf(buf, bufsiz, \"%#x\", p);\n}\n\nint\ncdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)\n{\n\tint len = 0;\n\tint days, hours, mins, secs;\n\n\tts /= CDF_TIME_PREC;\n\tsecs = CAST(int, ts % 60);\n\tts /= 60;\n\tmins = CAST(int, ts % 60);\n\tts /= 60;\n\thours = CAST(int, ts % 24);\n\tts /= 24;\n\tdays = CAST(int, ts);\n\n\tif (days) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%dd+\", days);\n\t\tif (CAST(size_t, len) >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tif (days || hours) {\n\t\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", hours);\n\t\tif (CAST(size_t, len) >= bufsiz)\n\t\t\treturn len;\n\t}\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d:\", mins);\n\tif (CAST(size_t, len) >= bufsiz)\n\t\treturn len;\n\n\tlen += snprintf(buf + len, bufsiz - len, \"%.2d\", secs);\n\treturn len;\n}\n\nchar *\ncdf_u16tos8(char *buf, size_t len, const uint16_t *p)\n{\n\tsize_t i;\n\tfor (i = 0; i < len && p[i]; i++)\n\t\tbuf[i] = CAST(char, p[i]);\n\tbuf[i] = '\\0';\n\treturn buf;\n}\n\n#ifdef CDF_DEBUG\nvoid\ncdf_dump_header(const cdf_header_t *h)\n{\n\tsize_t i;\n\n#define DUMP(a, b) (void)fprintf(stderr, \"%40.40s = \" a \"\\n\", # b, h->h_ ## b)\n#define DUMP2(a, b) (void)fprintf(stderr, \"%40.40s = \" a \" (\" a \")\\n\", # b, \\\n    h->h_ ## b, 1 << h->h_ ## b)\n\tDUMP(\"%d\", revision);\n\tDUMP(\"%d\", version);\n\tDUMP(\"%#x\", byte_order);\n\tDUMP2(\"%d\", sec_size_p2);\n\tDUMP2(\"%d\", short_sec_size_p2);\n\tDUMP(\"%d\", num_sectors_in_sat);\n\tDUMP(\"%d\", secid_first_directory);\n\tDUMP(\"%d\", min_size_standard_stream);\n\tDUMP(\"%d\", secid_first_sector_in_short_sat);\n\tDUMP(\"%d\", num_sectors_in_short_sat);\n\tDUMP(\"%d\", secid_first_sector_in_master_sat);\n\tDUMP(\"%d\", num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\t\t(void)fprintf(stderr, \"%35.35s[%.3\" SIZE_T_FORMAT \"u] = %d\\n\",\n\t\t    \"master_sat\", i, h->h_master_sat[i]);\n\t}\n}\n\nvoid\ncdf_dump_sat(const char *prefix, const cdf_sat_t *sat, size_t size)\n{\n\tsize_t i, j, s = size / sizeof(cdf_secid_t);\n\n\tfor (i = 0; i < sat->sat_len; i++) {\n\t\t(void)fprintf(stderr, \"%s[%\" SIZE_T_FORMAT \"u]:\\n%.6\"\n\t\t    SIZE_T_FORMAT \"u: \", prefix, i, i * s);\n\t\tfor (j = 0; j < s; j++) {\n\t\t\t(void)fprintf(stderr, \"%5d, \",\n\t\t\t    CDF_TOLE4(sat->sat_tab[s * i + j]));\n\t\t\tif ((j + 1) % 10 == 0)\n\t\t\t\t(void)fprintf(stderr, \"\\n%.6\" SIZE_T_FORMAT\n\t\t\t\t    \"u: \", i * s + j + 1);\n\t\t}\n\t\t(void)fprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\ncdf_dump(const void *v, size_t len)\n{\n\tsize_t i, j;\n\tconst unsigned char *p = v;\n\tchar abuf[16];\n\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}\n\nvoid\ncdf_dump_stream(const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_ss;\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}\n\nvoid\ncdf_dump_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tcdf_directory_t *d;\n\tchar name[__arraycount(d->d_name)];\n\tcdf_stream_t scn;\n\tstruct timespec ts;\n\n\tstatic const char *types[] = { \"empty\", \"user storage\",\n\t    \"user stream\", \"lockbytes\", \"property\", \"root storage\" };\n\n\tfor (i = 0; i < dir->dir_len; i++) {\n\t\tchar buf[26];\n\t\td = &dir->dir_tab[i];\n\t\tfor (j = 0; j < sizeof(name); j++)\n\t\t\tname[j] = (char)CDF_TOLE2(d->d_name[j]);\n\t\t(void)fprintf(stderr, \"Directory %\" SIZE_T_FORMAT \"u: %s\\n\",\n\t\t    i, name);\n\t\tif (d->d_type < __arraycount(types))\n\t\t\t(void)fprintf(stderr, \"Type: %s\\n\", types[d->d_type]);\n\t\telse\n\t\t\t(void)fprintf(stderr, \"Type: %d\\n\", d->d_type);\n\t\t(void)fprintf(stderr, \"Color: %s\\n\",\n\t\t    d->d_color ? \"black\" : \"red\");\n\t\t(void)fprintf(stderr, \"Left child: %d\\n\", d->d_left_child);\n\t\t(void)fprintf(stderr, \"Right child: %d\\n\", d->d_right_child);\n\t\t(void)fprintf(stderr, \"Flags: %#x\\n\", d->d_flags);\n\t\tcdf_timestamp_to_timespec(&ts, d->d_created);\n\t\t(void)fprintf(stderr, \"Created %s\", cdf_ctime(&ts.tv_sec, buf));\n\t\tcdf_timestamp_to_timespec(&ts, d->d_modified);\n\t\t(void)fprintf(stderr, \"Modified %s\",\n\t\t    cdf_ctime(&ts.tv_sec, buf));\n\t\t(void)fprintf(stderr, \"Stream %d\\n\", d->d_stream_first_sector);\n\t\t(void)fprintf(stderr, \"Size %d\\n\", d->d_size);\n\t\tswitch (d->d_type) {\n\t\tcase CDF_DIR_TYPE_USER_STORAGE:\n\t\t\t(void)fprintf(stderr, \"Storage: %d\\n\", d->d_storage);\n\t\t\tbreak;\n\t\tcase CDF_DIR_TYPE_USER_STREAM:\n\t\t\tif (sst == NULL)\n\t\t\t\tbreak;\n\t\t\tif (cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {\n\t\t\t\twarn(\"Can't read stream for %s at %d len %d\",\n\t\t\t\t    name, d->d_stream_first_sector, d->d_size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcdf_dump_stream(&scn);\n\t\t\tfree(scn.sst_tab);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n}\n\nvoid\ncdf_dump_property_info(const cdf_property_info_t *info, size_t count)\n{\n\tcdf_timestamp_t tp;\n\tstruct timespec ts;\n\tchar buf[64];\n\tsize_t i, j;\n\n\tfor (i = 0; i < count; i++) {\n\t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n\t\t(void)fprintf(stderr, \"%\" SIZE_T_FORMAT \"u) %s: \", i, buf);\n\t\tswitch (info[i].pi_type) {\n\t\tcase CDF_NULL:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\t(void)fprintf(stderr, \"signed 16 [%hd]\\n\",\n\t\t\t    info[i].pi_s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\t(void)fprintf(stderr, \"signed 32 [%d]\\n\",\n\t\t\t    info[i].pi_s32);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED32:\n\t\t\t(void)fprintf(stderr, \"unsigned 32 [%u]\\n\",\n\t\t\t    info[i].pi_u32);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\t(void)fprintf(stderr, \"float [%g]\\n\",\n\t\t\t    info[i].pi_f);\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\t(void)fprintf(stderr, \"double [%g]\\n\",\n\t\t\t    info[i].pi_d);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\t\t(void)fprintf(stderr, \"string %u [%.*s]\\n\",\n\t\t\t    info[i].pi_str.s_len,\n\t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\t(void)fprintf(stderr, \"string %u [\",\n\t\t\t    info[i].pi_str.s_len);\n\t\t\tfor (j = 0; j < info[i].pi_str.s_len - 1; j++)\n\t\t\t    (void)fputc(info[i].pi_str.s_buf[j << 1], stderr);\n\t\t\t(void)fprintf(stderr, \"]\\n\");\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\ttp = info[i].pi_tp;\n\t\t\tif (tp < 1000000000000000LL) {\n\t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\\n\", buf);\n\t\t\t} else {\n\t\t\t\tchar tbuf[26];\n\t\t\t\tcdf_timestamp_to_timespec(&ts, tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\",\n\t\t\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\t(void)fprintf(stderr, \"CLIPBOARD %u\\n\", info[i].pi_u32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    info[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid\ncdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tchar buf[128];\n\tcdf_summary_info_header_t ssi;\n\tcdf_property_info_t *info;\n\tsize_t count;\n\n\t(void)&h;\n\tif (cdf_unpack_summary_info(sst, h, &ssi, &info, &count) == -1)\n\t\treturn;\n\t(void)fprintf(stderr, \"Endian: %#x\\n\", ssi.si_byte_order);\n\t(void)fprintf(stderr, \"Os Version %d.%d\\n\", ssi.si_os_version & 0xff,\n\t    ssi.si_os_version >> 8);\n\t(void)fprintf(stderr, \"Os %d\\n\", ssi.si_os);\n\tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);\n\t(void)fprintf(stderr, \"Class %s\\n\", buf);\n\t(void)fprintf(stderr, \"Count %d\\n\", ssi.si_count);\n\tcdf_dump_property_info(info, count);\n\tfree(info);\n}\n\n\nvoid\ncdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}\n\n#endif\n\n#ifdef TEST\nint\nmain(int argc, char *argv[])\n{\n\tint i;\n\tcdf_header_t h;\n\tcdf_sat_t sat, ssat;\n\tcdf_stream_t sst, scn;\n\tcdf_dir_t dir;\n\tcdf_info_t info;\n\tconst cdf_directory_t *root;\n#ifdef __linux__\n#define getprogname() __progname\n\textern char *__progname;\n#endif\n\tif (argc < 2) {\n\t\t(void)fprintf(stderr, \"Usage: %s <filename>\\n\", getprogname());\n\t\treturn -1;\n\t}\n\n\tinfo.i_buf = NULL;\n\tinfo.i_len = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif ((info.i_fd = open(argv[1], O_RDONLY)) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot open `%s'\", argv[1]);\n\n\t\tif (cdf_read_header(&info, &h) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read header\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_header(&h);\n#endif\n\n\t\tif (cdf_read_sat(&info, &h, &sat) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read sat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_ssat(&info, &h, &sat, &ssat) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read ssat\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n\t\tif (cdf_read_dir(&info, &h, &sat, &dir) == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read dir\");\n\n\t\tif (cdf_read_short_stream(&info, &h, &sat, &dir, &sst, &root)\n\t\t    == -1)\n\t\t\terr(EXIT_FAILURE, \"Cannot read short stream\");\n#ifdef CDF_DEBUG\n\t\tcdf_dump_stream(&sst);\n#endif\n\n#ifdef CDF_DEBUG\n\t\tcdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n\n\n\t\tif (cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n\t\t    &scn) == -1)\n\t\t\twarn(\"Cannot read summary info\");\n#ifdef CDF_DEBUG\n\t\telse\n\t\t\tcdf_dump_summary_info(&h, &scn);\n#endif\n\t\tif (cdf_read_user_stream(&info, &h, &sat, &ssat, &sst,\n\t\t    &dir, \"Catalog\", &scn) == -1)\n\t\t\twarn(\"Cannot read catalog\");\n#ifdef CDF_DEBUG\n\t\telse\n\t\t\tcdf_dump_catalog(&h, &scn);\n#endif\n\n\t\t(void)close(info.i_fd);\n\t}\n\n\treturn 0;\n}\n#endif\n", "/*-\n * Copyright (c) 2008 Christos Zoulas\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parse Composite Document Files, the format used in Microsoft Office\n * document files before they switched to zipped XML.\n * Info from: http://sc.openoffice.org/compdocfileformat.pdf\n *\n * N.B. This is the \"Composite Document File\" format, and not the\n * \"Compound Document Format\", nor the \"Channel Definition Format\".\n */\n\n#ifndef _H_CDF_\n#define _H_CDF_\n\n#ifdef WIN32\n#include <winsock2.h>\n#define timespec timeval\n#define tv_nsec tv_usec\n#endif\n#ifdef __DJGPP__\n#define timespec timeval\n#define tv_nsec tv_usec\n#endif\n\ntypedef int32_t cdf_secid_t;\n\n#define CDF_LOOP_LIMIT\t\t\t\t\t10000\n#define CDF_ELEMENT_LIMIT\t\t\t\t100000\n\n#define CDF_SECID_NULL\t\t\t\t\t0\n#define CDF_SECID_FREE\t\t\t\t\t-1\n#define CDF_SECID_END_OF_CHAIN\t\t\t\t-2\n#define CDF_SECID_SECTOR_ALLOCATION_TABLE\t\t-3\n#define CDF_SECID_MASTER_SECTOR_ALLOCATION_TABLE\t-4\n\ntypedef struct {\n\tuint64_t\th_magic;\n#define CDF_MAGIC\t0xE11AB1A1E011CFD0LL\n\tuint64_t\th_uuid[2];\n\tuint16_t\th_revision;\n\tuint16_t\th_version;\n\tuint16_t\th_byte_order;\n\tuint16_t\th_sec_size_p2;\n\tuint16_t\th_short_sec_size_p2;\n\tuint8_t\t\th_unused0[10];\n\tuint32_t\th_num_sectors_in_sat;\n\tuint32_t\th_secid_first_directory;\n\tuint8_t\t\th_unused1[4];\n\tuint32_t\th_min_size_standard_stream;\n\tcdf_secid_t\th_secid_first_sector_in_short_sat;\n\tuint32_t\th_num_sectors_in_short_sat;\n\tcdf_secid_t\th_secid_first_sector_in_master_sat;\n\tuint32_t\th_num_sectors_in_master_sat;\n\tcdf_secid_t\th_master_sat[436/4];\n} cdf_header_t;\n\n#define CDF_SEC_SIZE(h) CAST(size_t, 1 << (h)->h_sec_size_p2)\n#define CDF_SEC_POS(h, secid) (CDF_SEC_SIZE(h) + (secid) * CDF_SEC_SIZE(h))\n#define CDF_SHORT_SEC_SIZE(h)\tCAST(size_t, 1 << (h)->h_short_sec_size_p2)\n#define CDF_SHORT_SEC_POS(h, secid) ((secid) * CDF_SHORT_SEC_SIZE(h))\n\ntypedef int32_t cdf_dirid_t;\n#define CDF_DIRID_NULL\t-1\n\ntypedef int64_t cdf_timestamp_t;\n#define CDF_BASE_YEAR\t1601\n#define CDF_TIME_PREC\t10000000\n\ntypedef struct {\n\tuint16_t\td_name[32];\n\tuint16_t\td_namelen;\n\tuint8_t\t\td_type;\n#define CDF_DIR_TYPE_EMPTY\t\t0\n#define CDF_DIR_TYPE_USER_STORAGE\t1\n#define CDF_DIR_TYPE_USER_STREAM\t2\n#define CDF_DIR_TYPE_LOCKBYTES\t\t3\n#define CDF_DIR_TYPE_PROPERTY\t\t4\n#define CDF_DIR_TYPE_ROOT_STORAGE\t5\n\tuint8_t\t\td_color;\n#define CDF_DIR_COLOR_READ\t0\n#define CDF_DIR_COLOR_BLACK\t1\n\tcdf_dirid_t\td_left_child;\n\tcdf_dirid_t\td_right_child;\n\tcdf_dirid_t\td_storage;\n\tuint64_t\td_storage_uuid[2];\n\tuint32_t\td_flags;\n\tcdf_timestamp_t d_created;\n\tcdf_timestamp_t d_modified;\n\tcdf_secid_t\td_stream_first_sector;\n\tuint32_t\td_size;\n\tuint32_t\td_unused0;\n} cdf_directory_t;\n\n#define CDF_DIRECTORY_SIZE\t128\n\ntypedef struct {\n\tcdf_secid_t *sat_tab;\n\tsize_t sat_len;\n} cdf_sat_t;\n\ntypedef struct {\n\tcdf_directory_t *dir_tab;\n\tsize_t dir_len;\n} cdf_dir_t;\n\ntypedef struct {\n\tvoid *sst_tab;\n\tsize_t sst_len;\t\t/* Number of sectors */\n\tsize_t sst_dirlen;\t/* Directory sector size */\n\tsize_t sst_ss;\t\t/* Sector size */\n} cdf_stream_t;\n\ntypedef struct {\n\tuint32_t\tcl_dword;\n\tuint16_t\tcl_word[2];\n\tuint8_t\t\tcl_two[2];\n\tuint8_t\t\tcl_six[6];\n} cdf_classid_t;\n\ntypedef struct {\n\tuint16_t\tsi_byte_order;\n\tuint16_t\tsi_zero;\n\tuint16_t\tsi_os_version;\n\tuint16_t\tsi_os;\n\tcdf_classid_t\tsi_class;\n\tuint32_t\tsi_count;\n} cdf_summary_info_header_t;\n\n#define CDF_SECTION_DECLARATION_OFFSET 0x1c\n\ntypedef struct {\n\tcdf_classid_t\tsd_class;\n\tuint32_t\tsd_offset;\n} cdf_section_declaration_t;\n\ntypedef struct {\n\tuint32_t\tsh_len;\n\tuint32_t\tsh_properties;\n} cdf_section_header_t;\n\ntypedef struct {\n\tuint32_t\tpi_id;\n\tuint32_t\tpi_type;\n\tunion {\n\t\tuint16_t\t_pi_u16;\n\t\tint16_t\t\t_pi_s16;\n\t\tuint32_t\t_pi_u32;\n\t\tint32_t\t\t_pi_s32;\n\t\tuint64_t\t_pi_u64;\n\t\tint64_t\t\t_pi_s64;\n\t\tcdf_timestamp_t _pi_tp;\n\t\tfloat\t\t_pi_f;\n\t\tdouble\t\t_pi_d;\n\t\tstruct {\n\t\t\tuint32_t s_len;\n\t\t\tconst char *s_buf;\n\t\t} _pi_str;\n\t} pi_val;\n#define pi_u64\tpi_val._pi_u64\n#define pi_s64\tpi_val._pi_s64\n#define pi_u32\tpi_val._pi_u32\n#define pi_s32\tpi_val._pi_s32\n#define pi_u16\tpi_val._pi_u16\n#define pi_s16\tpi_val._pi_s16\n#define pi_f\tpi_val._pi_f\n#define pi_d\tpi_val._pi_d\n#define pi_tp\tpi_val._pi_tp\n#define pi_str\tpi_val._pi_str\n} cdf_property_info_t;\n\n#define CDF_ROUND(val, by)     (((val) + (by) - 1) & ~((by) - 1))\n\n/* Variant type definitions */\n#define CDF_EMPTY\t\t0x00000000\n#define CDF_NULL\t\t0x00000001\n#define CDF_SIGNED16\t\t0x00000002\n#define CDF_SIGNED32\t\t0x00000003\n#define CDF_FLOAT\t\t0x00000004\n#define CDF_DOUBLE\t\t0x00000005\n#define CDF_CY\t\t\t0x00000006\n#define CDF_DATE\t\t0x00000007\n#define CDF_BSTR\t\t0x00000008\n#define CDF_DISPATCH\t\t0x00000009\n#define CDF_ERROR\t\t0x0000000a\n#define CDF_BOOL\t\t0x0000000b\n#define CDF_VARIANT\t\t0x0000000c\n#define CDF_UNKNOWN\t\t0x0000000d\n#define CDF_DECIMAL\t\t0x0000000e\n#define CDF_SIGNED8\t\t0x00000010\n#define CDF_UNSIGNED8\t\t0x00000011\n#define CDF_UNSIGNED16\t\t0x00000012\n#define CDF_UNSIGNED32\t\t0x00000013\n#define CDF_SIGNED64\t\t0x00000014\n#define CDF_UNSIGNED64\t\t0x00000015\n#define CDF_INT\t\t\t0x00000016\n#define CDF_UINT\t\t0x00000017\n#define CDF_VOID\t\t0x00000018\n#define CDF_HRESULT\t\t0x00000019\n#define CDF_PTR\t\t\t0x0000001a\n#define CDF_SAFEARRAY\t\t0x0000001b\n#define CDF_CARRAY\t\t0x0000001c\n#define CDF_USERDEFINED\t\t0x0000001d\n#define CDF_LENGTH32_STRING\t0x0000001e\n#define CDF_LENGTH32_WSTRING\t0x0000001f\n#define CDF_FILETIME\t\t0x00000040\n#define CDF_BLOB\t\t0x00000041\n#define CDF_STREAM\t\t0x00000042\n#define CDF_STORAGE\t\t0x00000043\n#define CDF_STREAMED_OBJECT\t0x00000044\n#define CDF_STORED_OBJECT\t0x00000045\n#define CDF_BLOB_OBJECT\t\t0x00000046\n#define CDF_CLIPBOARD\t\t0x00000047\n#define CDF_CLSID\t\t0x00000048\n#define CDF_VECTOR\t\t0x00001000\n#define CDF_ARRAY\t\t0x00002000\n#define CDF_BYREF\t\t0x00004000\n#define CDF_RESERVED\t\t0x00008000\n#define CDF_ILLEGAL\t\t0x0000ffff\n#define CDF_ILLEGALMASKED\t0x00000fff\n#define CDF_TYPEMASK\t\t0x00000fff\n\n#define CDF_PROPERTY_CODE_PAGE\t\t\t0x00000001\n#define CDF_PROPERTY_TITLE\t\t\t0x00000002\n#define CDF_PROPERTY_SUBJECT\t\t\t0x00000003\n#define CDF_PROPERTY_AUTHOR\t\t\t0x00000004\n#define CDF_PROPERTY_KEYWORDS\t\t\t0x00000005\n#define CDF_PROPERTY_COMMENTS\t\t\t0x00000006\n#define CDF_PROPERTY_TEMPLATE\t\t\t0x00000007\n#define CDF_PROPERTY_LAST_SAVED_BY\t\t0x00000008\n#define CDF_PROPERTY_REVISION_NUMBER\t\t0x00000009\n#define CDF_PROPERTY_TOTAL_EDITING_TIME\t\t0x0000000a\n#define CDF_PROPERTY_LAST_PRINTED\t\t0X0000000b\n#define CDF_PROPERTY_CREATE_TIME\t\t0x0000000c\n#define CDF_PROPERTY_LAST_SAVED_TIME\t\t0x0000000d\n#define CDF_PROPERTY_NUMBER_OF_PAGES\t\t0x0000000e\n#define CDF_PROPERTY_NUMBER_OF_WORDS\t\t0x0000000f\n#define CDF_PROPERTY_NUMBER_OF_CHARACTERS\t0x00000010\n#define CDF_PROPERTY_THUMBNAIL\t\t\t0x00000011\n#define CDF_PROPERTY_NAME_OF_APPLICATION\t0x00000012\n#define CDF_PROPERTY_SECURITY\t\t\t0x00000013\n#define CDF_PROPERTY_LOCALE_ID\t\t\t0x80000000\n\ntypedef struct {\n\tint i_fd;\n\tconst unsigned char *i_buf;\n\tsize_t i_len;\n} cdf_info_t;\n\n\ntypedef struct {\n\tuint16_t ce_namlen;\n\tuint32_t ce_num;\n\tuint64_t ce_timestamp;\n\tuint16_t ce_name[256];\n} cdf_catalog_entry_t;\n\ntypedef struct {\n\tsize_t cat_num;\n\tcdf_catalog_entry_t cat_e[1];\n} cdf_catalog_t;\n\nstruct timespec;\nint cdf_timestamp_to_timespec(struct timespec *, cdf_timestamp_t);\nint cdf_timespec_to_timestamp(cdf_timestamp_t *, const struct timespec *);\nint cdf_read_header(const cdf_info_t *, cdf_header_t *);\nvoid cdf_swap_header(cdf_header_t *);\nvoid cdf_unpack_header(cdf_header_t *, char *);\nvoid cdf_swap_dir(cdf_directory_t *);\nvoid cdf_unpack_dir(cdf_directory_t *, char *);\nvoid cdf_swap_class(cdf_classid_t *);\nssize_t cdf_read_sector(const cdf_info_t *, void *, size_t, size_t,\n    const cdf_header_t *, cdf_secid_t);\nssize_t cdf_read_short_sector(const cdf_stream_t *, void *, size_t, size_t,\n    const cdf_header_t *, cdf_secid_t);\nint cdf_read_sat(const cdf_info_t *, cdf_header_t *, cdf_sat_t *);\nsize_t cdf_count_chain(const cdf_sat_t *, cdf_secid_t, size_t);\nint cdf_read_long_sector_chain(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, cdf_secid_t, size_t, cdf_stream_t *);\nint cdf_read_short_sector_chain(const cdf_header_t *, const cdf_sat_t *,\n    const cdf_stream_t *, cdf_secid_t, size_t, cdf_stream_t *);\nint cdf_read_sector_chain(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *, cdf_secid_t,\n    size_t, cdf_stream_t *);\nint cdf_read_dir(const cdf_info_t *, const cdf_header_t *, const cdf_sat_t *,\n    cdf_dir_t *);\nint cdf_read_ssat(const cdf_info_t *, const cdf_header_t *, const cdf_sat_t *,\n    cdf_sat_t *);\nint cdf_read_short_stream(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_dir_t *, cdf_stream_t *,\n    const cdf_directory_t **);\nint cdf_read_property_info(const cdf_stream_t *, const cdf_header_t *, uint32_t,\n    cdf_property_info_t **, size_t *, size_t *);\nint cdf_read_user_stream(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *,\n    const cdf_dir_t *, const char *, cdf_stream_t *);\nint cdf_find_stream(const cdf_dir_t *, const char *, int);\nint cdf_zero_stream(cdf_stream_t *);\nint cdf_read_doc_summary_info(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *,\n    const cdf_dir_t *, cdf_stream_t *);\nint cdf_read_summary_info(const cdf_info_t *, const cdf_header_t *,\n    const cdf_sat_t *, const cdf_sat_t *, const cdf_stream_t *,\n    const cdf_dir_t *, cdf_stream_t *);\nint cdf_unpack_summary_info(const cdf_stream_t *, const cdf_header_t *,\n    cdf_summary_info_header_t *, cdf_property_info_t **, size_t *);\nint cdf_unpack_catalog(const cdf_header_t *, const cdf_stream_t *,\n    cdf_catalog_t **);\nint cdf_print_classid(char *, size_t, const cdf_classid_t *);\nint cdf_print_property_name(char *, size_t, uint32_t);\nint cdf_print_elapsed_time(char *, size_t, cdf_timestamp_t);\nuint16_t cdf_tole2(uint16_t);\nuint32_t cdf_tole4(uint32_t);\nuint64_t cdf_tole8(uint64_t);\nchar *cdf_ctime(const time_t *, char *);\nchar *cdf_u16tos8(char *, size_t, const uint16_t *);\n\n#ifdef CDF_DEBUG\nvoid cdf_dump_header(const cdf_header_t *);\nvoid cdf_dump_sat(const char *, const cdf_sat_t *, size_t);\nvoid cdf_dump(const void *, size_t);\nvoid cdf_dump_stream(const cdf_stream_t *);\nvoid cdf_dump_dir(const cdf_info_t *, const cdf_header_t *, const cdf_sat_t *,\n    const cdf_sat_t *, const cdf_stream_t *, const cdf_dir_t *);\nvoid cdf_dump_property_info(const cdf_property_info_t *, size_t);\nvoid cdf_dump_summary_info(const cdf_header_t *, const cdf_stream_t *);\nvoid cdf_dump_catalog(const cdf_header_t *, const cdf_stream_t *);\n#endif\n\n\n#endif /* _H_CDF_ */\n"], "filenames": ["src/cdf.c", "src/cdf.h"], "buggy_code_start_loc": [38, 50], "buggy_code_end_loc": [1075, 50], "fixing_code_start_loc": [38, 51], "fixing_code_end_loc": [1073, 52], "type": "CWE-787", "message": "cdf_read_property_info in cdf.c in file through 5.37 does not restrict the number of CDF_VECTOR elements, which allows a heap-based buffer overflow (4-byte out-of-bounds write).", "other": {"cve": {"id": "CVE-2019-18218", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-21T05:15:10.520", "lastModified": "2022-11-09T17:55:47.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cdf_read_property_info in cdf.c in file through 5.37 does not restrict the number of CDF_VECTOR elements, which allows a heap-based buffer overflow (4-byte out-of-bounds write)."}, {"lang": "es", "value": "La funci\u00f3n cdf_read_property_info en el archivo cdf.c en file versiones hasta 5.37, no restringe el n\u00famero de elementos CDF_VECTOR, lo que permite un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria (escritura fuera de l\u00edmites de 4 bytes)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:file_project:file:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.37", "matchCriteriaId": "E1772C1F-4B0A-483E-ACC7-AD225B58532B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:*:*:*:*:*:linux:*:*", "versionStartIncluding": "7.3", "matchCriteriaId": "9FBC1BD0-FF12-4691-8751-5F245D991989"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00044.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16780", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/46a8443f76cec4b41ec736eca396984c74664f84", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00032.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/07/msg00008.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CV6PFCEYHYALMTT45QE2U5C5TEJZQPXJ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/D6BJVGXSCC6NMIAWX36FPWHEIFON3OSE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VBK6XOJR6OVWT2FUEBO7V7KCOSSLAP52/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-24", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200115-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4172-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4172-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4550", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/file/file/commit/46a8443f76cec4b41ec736eca396984c74664f84"}}