{"buggy_code": ["Changes in PDFio\n================\n\n\nv1.1.1 (Month DD, YYYY)\n-----------------------\n\n- Fixed a build issue.\n\n\nv1.1.0 (February 6, 2023)\n-------------------------\n\n- CVE-2023-24808: Fixed a potential denial-of-service with corrupt PDF files.\n- Added `pdfioFileCreateTemporary` function (Issue #29)\n- Added `pdfioDictIterateKeys` function (Issue #31)\n- Added `pdfioContentPathEnd` function.\n- Added protection against opening multiple streams in the same file at the\n  same time.\n- Documentation updates (Issue #37)\n- Fixed \"install-shared\" target (Issue #32)\n- Fixed `pdfioFileGet...` metadata APIs (Issue #33)\n- Fixed `pdfioContentMatrixRotate` function.\n\n\nv1.0.1 (March 2, 2022)\n----------------------\n\n- Added missing `pdfioPageGetNumStreams` and `pdfioPageOpenStream` functions.\n- Added demo pdfiototext utility.\n- Fixed bug in `pdfioStreamGetToken`.\n\n\nv1.0.0 (December 14, 2021)\n--------------------------\n\n- First stable release.\n\n\nv1.0rc1 (November 30, 2021)\n---------------------------\n\n- Fixed a few stack/buffer overflow bugs discovered via fuzzing.\n\n\nv1.0b2 (November 7, 2021)\n-------------------------\n\n- Added `pdfioFileCreateOutput` API to support streaming output of PDF\n  (Issue #21)\n- Fixed `all-shared` target (Issue #22)\n- Fixed memory leaks (Issue #23)\n- Updated `pdfioContentSetDashPattern` to accept `double` values (Issue #25)\n- Added support for reading and writing encrypted PDFs (Issue #26)\n- Fixed some issues identified by a Coverity scan.\n\n\nv1.0b1 (August 30, 2021)\n------------------------\n\n- Initial release\n", "//\n// PDF stream functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic unsigned char\tstream_paeth(unsigned char a, unsigned char b, unsigned char c);\nstatic ssize_t\t\tstream_read(pdfio_stream_t *st, char *buffer, size_t bytes);\nstatic bool\t\tstream_write(pdfio_stream_t *st, const void *buffer, size_t bytes);\nstatic const char\t*zstrerror(int error);\n\n\n//\n// 'pdfioStreamClose()' - Close a (data) stream in a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamClose(pdfio_stream_t *st)\t// I - Stream\n{\n  bool ret = true;\t\t\t// Return value\n\n\n  // Range check input...\n  if (!st)\n    return (false);\n\n  // Finish reads/writes and free memory...\n  if (st->pdf->mode == _PDFIO_MODE_READ)\n  {\n    if (st->filter == PDFIO_FILTER_FLATE)\n      inflateEnd(&(st->flate));\n  }\n  else\n  {\n    // Close stream for writing...\n    if (st->filter == PDFIO_FILTER_FLATE)\n    {\n      // Finalize flate compression stream...\n      int status;\t\t\t// Deflate status\n\n      while ((status = deflate(&st->flate, Z_FINISH)) != Z_STREAM_END)\n      {\n        size_t\tbytes = sizeof(st->cbuffer) - st->flate.avail_out,\n\t\t\t\t\t// Bytes to write\n\t\toutbytes;\t\t// Actual bytes written\n\n\tif (status < Z_OK && status != Z_BUF_ERROR)\n\t{\n\t  _pdfioFileError(st->pdf, \"Flate compression failed: %s\", zstrerror(status));\n\t  ret = false;\n\t  goto done;\n\t}\n\n\tif (st->crypto_cb)\n\t{\n\t  // Encrypt it first...\n\t  outbytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, bytes & (size_t)~15);\n\t}\n\telse\n\t{\n\t  // No encryption\n\t  outbytes = bytes;\n\t}\n\n\tif (!_pdfioFileWrite(st->pdf, st->cbuffer, outbytes))\n\t{\n\t  ret = false;\n\t  goto done;\n\t}\n\n        if (bytes > outbytes)\n        {\n          bytes -= outbytes;\n          memmove(st->cbuffer, st->cbuffer + outbytes, bytes);\n        }\n        else\n        {\n          bytes = 0;\n        }\n\n\tst->flate.next_out  = (Bytef *)st->cbuffer + bytes;\n\tst->flate.avail_out = (uInt)(sizeof(st->cbuffer) - bytes);\n      }\n\n      if (st->flate.avail_out < (uInt)sizeof(st->cbuffer))\n      {\n        // Write any residuals...\n        size_t bytes = sizeof(st->cbuffer) - st->flate.avail_out;\n\t\t\t\t\t// Bytes to write\n\n\tif (st->crypto_cb)\n\t{\n\t  // Encrypt it first...\n\t  bytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, bytes);\n\t}\n\n\tif (!_pdfioFileWrite(st->pdf, st->cbuffer, bytes))\n\t{\n\t  ret = false;\n\t  goto done;\n\t}\n      }\n\n      deflateEnd(&st->flate);\n    }\n    else if (st->crypto_cb && st->bufptr > st->buffer)\n    {\n      // Encrypt and flush\n      uint8_t\ttemp[8192];\t\t// Temporary buffer\n      size_t\toutbytes;\t\t// Output bytes\n\n      outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, (uint8_t *)st->buffer, (size_t)(st->bufptr - st->buffer));\n      if (!_pdfioFileWrite(st->pdf, temp, outbytes))\n      {\n        ret = false;\n        goto done;\n      }\n    }\n\n    // Save the length of this stream...\n    st->obj->stream_length = (size_t)(_pdfioFileTell(st->pdf) - st->obj->stream_offset);\n\n    // End of stream marker...\n    if (!_pdfioFilePuts(st->pdf, \"\\nendstream\\nendobj\\n\"))\n    {\n      ret = false;\n      goto done;\n    }\n\n    // Update the length as needed...\n    if (st->length_obj)\n    {\n      st->length_obj->value.value.number = st->obj->stream_length;\n      pdfioObjClose(st->length_obj);\n    }\n    else if (st->obj->length_offset)\n    {\n      // Seek back to the \"/Length 9999999999\" we wrote...\n      if (_pdfioFileSeek(st->pdf, st->obj->length_offset, SEEK_SET) < 0)\n      {\n        ret = false;\n        goto done;\n      }\n\n      // Write the updated length value...\n      if (!_pdfioFilePrintf(st->pdf, \"%-10lu\", (unsigned long)st->obj->stream_length))\n      {\n        ret = false;\n        goto done;\n      }\n\n      // Seek to the end of the PDF file...\n      if (_pdfioFileSeek(st->pdf, 0, SEEK_END) < 0)\n      {\n        ret = false;\n        goto done;\n      }\n    }\n  }\n\n  done:\n\n  st->pdf->current_obj = NULL;\n\n  free(st->prbuffer);\n  free(st->psbuffer);\n  free(st);\n\n  return (ret);\n}\n\n\n//\n// '_pdfioStreamCreate()' - Create a stream for writing.\n//\n// Note: pdfioObjCreateStream handles writing the object and its dictionary.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\n_pdfioStreamCreate(\n    pdfio_obj_t    *obj,\t\t// I - Object\n    pdfio_obj_t    *length_obj,\t\t// I - Length object, if any\n    pdfio_filter_t compression)\t\t// I - Compression to apply\n{\n  pdfio_stream_t\t*st;\t\t// Stream\n\n\n  // Allocate a new stream object...\n  if ((st = (pdfio_stream_t *)calloc(1, sizeof(pdfio_stream_t))) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to allocate memory for a stream.\");\n    return (NULL);\n  }\n\n  st->pdf        = obj->pdf;\n  st->obj        = obj;\n  st->length_obj = length_obj;\n  st->filter     = compression;\n  st->bufptr     = st->buffer;\n  st->bufend     = st->buffer + sizeof(st->buffer);\n\n  if (obj->pdf->encryption)\n  {\n    uint8_t\tiv[64];\t\t\t// Initialization vector\n    size_t\tivlen = sizeof(iv);\t// Length of initialization vector, if any\n\n    if ((st->crypto_cb = _pdfioCryptoMakeWriter(st->pdf, obj, &st->crypto_ctx, iv, &ivlen)) == NULL)\n    {\n      // TODO: Add error message?\n      free(st);\n      return (NULL);\n    }\n\n    if (ivlen > 0)\n      _pdfioFileWrite(st->pdf, iv, ivlen);\n  }\n\n  if (compression == PDFIO_FILTER_FLATE)\n  {\n    // Flate compression\n    pdfio_dict_t *params = pdfioDictGetDict(obj->value.value.dict, \"DecodeParms\");\n\t\t\t\t\t// Decoding parameters\n    int bpc = (int)pdfioDictGetNumber(params, \"BitsPerComponent\");\n\t\t\t\t\t// Bits per component\n    int colors = (int)pdfioDictGetNumber(params, \"Colors\");\n\t\t\t\t\t// Number of colors\n    int columns = (int)pdfioDictGetNumber(params, \"Columns\");\n\t\t\t\t\t// Number of columns\n    int predictor = (int)pdfioDictGetNumber(params, \"Predictor\");\n\t\t\t\t\t// Predictory value, if any\n    int status;\t\t\t\t// ZLIB status code\n\n    PDFIO_DEBUG(\"_pdfioStreamCreate: FlateDecode - BitsPerComponent=%d, Colors=%d, Columns=%d, Predictor=%d\\n\", bpc, colors, columns, predictor);\n\n    if (bpc == 0)\n    {\n      bpc = 8;\n    }\n    else if (bpc < 1 || bpc == 3 || (bpc > 4 && bpc < 8) || (bpc > 8 && bpc < 16) || bpc > 16)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported BitsPerColor value %d.\", bpc);\n      free(st);\n      return (NULL);\n    }\n\n    if (colors == 0)\n    {\n      colors = 1;\n    }\n    else if (colors < 0 || colors > 4)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported Colors value %d.\", colors);\n      free(st);\n      return (NULL);\n    }\n\n    if (columns == 0)\n    {\n      columns = 1;\n    }\n    else if (columns < 0)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported Columns value %d.\", columns);\n      free(st);\n      return (NULL);\n    }\n\n    if ((predictor > 1 && predictor < 10) || predictor > 15)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported Predictor function %d.\", predictor);\n      free(st);\n      return (NULL);\n    }\n    else if (predictor)\n    {\n      // Using a PNG predictor function\n      st->predictor = (_pdfio_predictor_t)predictor;\n      st->pbpixel   = (size_t)(bpc * colors + 7) / 8;\n      st->pbsize    = (size_t)(bpc * colors * columns + 7) / 8;\n      if (predictor >= 10)\n\tst->pbsize ++;\t\t// Add PNG predictor byte\n\n      if ((st->prbuffer = calloc(1, st->pbsize - 1)) == NULL || (st->psbuffer = calloc(1, st->pbsize)) == NULL)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to allocate %lu bytes for Predictor buffers.\", (unsigned long)st->pbsize);\n\tfree(st->prbuffer);\n\tfree(st->psbuffer);\n\tfree(st);\n\treturn (NULL);\n      }\n    }\n    else\n      st->predictor = _PDFIO_PREDICTOR_NONE;\n\n    st->flate.next_out  = (Bytef *)st->cbuffer;\n    st->flate.avail_out = (uInt)sizeof(st->cbuffer);\n\n    if ((status = deflateInit(&(st->flate), 9)) != Z_OK)\n    {\n      _pdfioFileError(st->pdf, \"Unable to start Flate filter: %s\", zstrerror(status));\n      free(st->prbuffer);\n      free(st->psbuffer);\n      free(st);\n      return (NULL);\n    }\n  }\n\n  return (st);\n}\n\n\n//\n// 'pdfioStreamConsume()' - Consume bytes from the stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on EOF\npdfioStreamConsume(pdfio_stream_t *st,\t// I - Stream\n                   size_t         bytes)// I - Number of bytes to consume\n{\n  size_t\tremaining;\t\t// Remaining bytes in buffer\n  ssize_t\trbytes;\t\t\t// Bytes read\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !bytes)\n    return (false);\n\n  // Skip bytes in the stream buffer until we've consumed the requested number\n  // or get to the end of the stream...\n  while ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)\n  {\n    bytes -= remaining;\n\n    if ((rbytes = stream_read(st, st->buffer, sizeof(st->buffer))) > 0)\n    {\n      st->bufptr = st->buffer;\n      st->bufend = st->buffer + rbytes;\n    }\n    else\n    {\n      st->bufptr = st->bufend = st->buffer;\n      return (false);\n    }\n  }\n\n  st->bufptr += bytes;\n\n  return (true);\n}\n\n\n//\n// 'pdfioStreamGetToken()' - Read a single PDF token from a stream.\n//\n// This function reads a single PDF token from a stream.  Operator tokens,\n// boolean values, and numbers are returned as-is in the provided string buffer.\n// String values start with the opening parenthesis ('(') but have all escaping\n// resolved and the terminating parenthesis removed.  Hexadecimal string values\n// start with the opening angle bracket ('<') and have all whitespace and the\n// terminating angle bracket removed.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on EOF\npdfioStreamGetToken(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    char           *buffer,\t\t// I - String buffer\n    size_t         bufsize)\t\t// I - Size of string buffer\n{\n  _pdfio_token_t\ttb;\t\t// Token buffer/stack\n  bool\t\t\tret;\t\t// Return value\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bufsize)\n    return (false);\n\n  // Read using the token engine...\n  _pdfioTokenInit(&tb, st->pdf, (_pdfio_tconsume_cb_t)pdfioStreamConsume, (_pdfio_tpeek_cb_t)pdfioStreamPeek, st);\n\n  ret = _pdfioTokenRead(&tb, buffer, bufsize);\n  _pdfioTokenFlush(&tb);\n\n  return (ret);\n}\n\n\n//\n// '_pdfioStreamOpen()' - Create a stream for reading.\n//\n// Note: pdfioObjOpenStream handles loading the object's dictionary and\n// getting the start of the stream data.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\n_pdfioStreamOpen(pdfio_obj_t *obj,\t// I - Object\n                 bool        decode)\t// I - Decode/decompress the stream?\n{\n  pdfio_stream_t\t*st;\t\t// Stream\n  pdfio_dict_t\t\t*dict = pdfioObjGetDict(obj);\n\t\t\t\t\t// Object dictionary\n\n\n  PDFIO_DEBUG(\"_pdfioStreamOpen(obj=%p(%u), decode=%s)\\n\", obj, (unsigned)obj->number, decode ? \"true\" : \"false\");\n\n  // Allocate a new stream object...\n  if ((st = (pdfio_stream_t *)calloc(1, sizeof(pdfio_stream_t))) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to allocate memory for a stream.\");\n    return (NULL);\n  }\n\n  st->pdf = obj->pdf;\n  st->obj = obj;\n\n  if ((st->remaining = pdfioObjGetLength(obj)) == 0)\n  {\n    free(st);\n    return (NULL);\n  }\n\n  if (_pdfioFileSeek(st->pdf, obj->stream_offset, SEEK_SET) != obj->stream_offset)\n  {\n    free(st);\n    return (NULL);\n  }\n\n  if (obj->pdf->encryption)\n  {\n    uint8_t\tiv[64];\t\t\t// Initialization vector\n    size_t\tivlen;\t\t\t// Length of initialization vector, if any\n\n    ivlen = (size_t)_pdfioFilePeek(st->pdf, iv, sizeof(iv));\n\n    if ((st->crypto_cb = _pdfioCryptoMakeReader(st->pdf, obj, &st->crypto_ctx, iv, &ivlen)) == NULL)\n    {\n      // TODO: Add error message?\n      free(st);\n      return (NULL);\n    }\n\n    if (ivlen > 0)\n      _pdfioFileConsume(st->pdf, ivlen);\n\n    if (st->pdf->encryption >= PDFIO_ENCRYPTION_AES_128)\n      st->remaining = (st->remaining + 15) & (size_t)~15;\n  }\n\n  if (decode)\n  {\n    // Try to decode/decompress the contents of this object...\n    const char\t*filter = pdfioDictGetName(dict, \"Filter\");\n\t\t\t\t\t// Filter value\n\n    if (!filter)\n    {\n      // No single filter name, do we have a compound filter?\n      if (pdfioDictGetArray(dict, \"Filter\"))\n      {\n\t// TODO: Implement compound filters...\n\t_pdfioFileError(st->pdf, \"Unsupported compound stream filter.\");\n\tfree(st);\n\treturn (NULL);\n      }\n\n      // No filter, read as-is...\n      st->filter = PDFIO_FILTER_NONE;\n    }\n    else if (!strcmp(filter, \"FlateDecode\"))\n    {\n      // Flate compression\n      pdfio_dict_t *params = pdfioDictGetDict(dict, \"DecodeParms\");\n\t\t\t\t\t// Decoding parameters\n      int bpc = (int)pdfioDictGetNumber(params, \"BitsPerComponent\");\n\t\t\t\t\t// Bits per component\n      int colors = (int)pdfioDictGetNumber(params, \"Colors\");\n\t\t\t\t\t// Number of colors\n      int columns = (int)pdfioDictGetNumber(params, \"Columns\");\n\t\t\t\t\t// Number of columns\n      int predictor = (int)pdfioDictGetNumber(params, \"Predictor\");\n\t\t\t\t\t// Predictory value, if any\n      int status;\t\t\t// ZLIB status\n      ssize_t rbytes;\t\t\t// Bytes read\n\n      PDFIO_DEBUG(\"_pdfioStreamOpen: FlateDecode - BitsPerComponent=%d, Colors=%d, Columns=%d, Predictor=%d\\n\", bpc, colors, columns, predictor);\n\n      st->filter = PDFIO_FILTER_FLATE;\n\n      if (bpc == 0)\n      {\n        bpc = 8;\n      }\n      else if (bpc < 1 || bpc == 3 || (bpc > 4 && bpc < 8) || (bpc > 8 && bpc < 16) || bpc > 16)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported BitsPerColor value %d.\", bpc);\n        free(st);\n        return (NULL);\n      }\n\n      if (colors == 0)\n      {\n        colors = 1;\n      }\n      else if (colors < 0 || colors > 4)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported Colors value %d.\", colors);\n        free(st);\n        return (NULL);\n      }\n\n      if (columns == 0)\n      {\n        columns = 1;\n      }\n      else if (columns < 0)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported Columns value %d.\", columns);\n        free(st);\n        return (NULL);\n      }\n\n      if ((predictor > 2 && predictor < 10) || predictor > 15)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported Predictor function %d.\", predictor);\n        free(st);\n        return (NULL);\n      }\n      else if (predictor > 1)\n      {\n        // Using a predictor function\n        st->predictor = (_pdfio_predictor_t)predictor;\n        st->pbpixel   = (size_t)(bpc * colors + 7) / 8;\n        st->pbsize    = (size_t)(bpc * colors * columns + 7) / 8;\n        if (predictor >= 10)\n          st->pbsize ++;\t\t// Add PNG predictor byte\n\n        if ((st->prbuffer = calloc(1, st->pbsize - 1)) == NULL || (st->psbuffer = calloc(1, st->pbsize)) == NULL)\n        {\n          _pdfioFileError(st->pdf, \"Unable to allocate %lu bytes for Predictor buffers.\", (unsigned long)st->pbsize);\n\t  free(st->prbuffer);\n\t  free(st->psbuffer);\n\t  free(st);\n\t  return (NULL);\n        }\n      }\n      else\n        st->predictor = _PDFIO_PREDICTOR_NONE;\n\n      if (sizeof(st->cbuffer) > st->remaining)\n\trbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n      else\n\trbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n      if (rbytes <= 0)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to read bytes for stream.\");\n\tfree(st->prbuffer);\n\tfree(st->psbuffer);\n\tfree(st);\n\treturn (NULL);\n      }\n\n      if (st->crypto_cb)\n        rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n      st->flate.next_in  = (Bytef *)st->cbuffer;\n      st->flate.avail_in = (uInt)rbytes;\n\n      if (st->cbuffer[0] == 0x0a)\n      {\n        st->flate.next_in ++;\t\t// Skip newline\n        st->flate.avail_in --;\n      }\n\n      PDFIO_DEBUG(\"_pdfioStreamOpen: avail_in=%u, cbuffer=<%02X%02X%02X%02X%02X%02X%02X%02X...>\\n\", st->flate.avail_in, st->cbuffer[0], st->cbuffer[1], st->cbuffer[2], st->cbuffer[3], st->cbuffer[4], st->cbuffer[5], st->cbuffer[6], st->cbuffer[7]);\n\n      if ((status = inflateInit(&(st->flate))) != Z_OK)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to start Flate filter: %s\", zstrerror(status));\n\tfree(st->prbuffer);\n\tfree(st->psbuffer);\n\tfree(st);\n\treturn (NULL);\n      }\n\n      st->remaining -= st->flate.avail_in;\n    }\n    else if (!strcmp(filter, \"LZWDecode\"))\n    {\n      // LZW compression\n      st->filter = PDFIO_FILTER_LZW;\n    }\n    else\n    {\n      // Something else we don't support\n      _pdfioFileError(st->pdf, \"Unsupported stream filter '/%s'.\", filter);\n      free(st);\n      return (NULL);\n    }\n  }\n  else\n  {\n    // Just return the stream data as-is...\n    st->filter = PDFIO_FILTER_NONE;\n  }\n\n  return (st);\n}\n\n\n//\n// 'pdfioStreamPeek()' - Peek at data in a stream.\n//\n\nssize_t\t\t\t\t\t// O - Bytes returned or `-1` on error\npdfioStreamPeek(pdfio_stream_t *st,\t// I - Stream\n                void           *buffer,\t// I - Buffer\n                size_t         bytes)\t// I - Size of buffer\n{\n  size_t\tremaining;\t\t// Remaining bytes in buffer\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bytes)\n    return (-1);\n\n  // See if we have enough bytes in the buffer...\n  if ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)\n  {\n    // No, shift the buffer and read more\n    ssize_t\trbytes;\t\t\t// Bytes read\n\n    if (remaining > 0)\n      memmove(st->buffer, st->bufptr, remaining);\n\n    st->bufptr = st->buffer;\n    st->bufend = st->buffer + remaining;\n\n    if ((rbytes = stream_read(st, st->bufend, sizeof(st->buffer) - remaining)) > 0)\n    {\n      st->bufend += rbytes;\n      remaining  += (size_t)rbytes;\n    }\n  }\n\n  // Copy bytes from the buffer...\n  if (bytes > remaining)\n    bytes = remaining;\n\n  memcpy(buffer, st->bufptr, bytes);\n\n  // Return the number of bytes that were copied...\n  return ((ssize_t)bytes);\n}\n\n\n//\n// 'pdfioStreamPrintf()' - Write a formatted string to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamPrintf(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    const char     *format,\t\t// I - `printf`-style format string\n    ...)\t\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8192];\t\t// String buffer\n  va_list\tap;\t\t\t// Argument pointer\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !format)\n    return (false);\n\n  // Format the string...\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  // Write the string...\n  return (pdfioStreamWrite(st, buffer, strlen(buffer)));\n}\n\n\n//\n// 'pdfioStreamPutChar()' - Write a single character to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamPutChar(pdfio_stream_t *st,\t// I - Stream\n                   int            ch)\t// I - Character\n{\n  char\tbuffer[1];\t\t\t// Write buffer\n\n\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE)\n    return (false);\n\n  buffer[0] = (char)ch;\n\n  return (pdfioStreamWrite(st, buffer, 1));\n}\n\n\n//\n// 'pdfioStreamPuts()' - Write a literal string to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamPuts(pdfio_stream_t *st,\t// I - Stream\n                const char     *s)\t// I - Literal string\n{\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !s)\n    return (false);\n  else\n    return (pdfioStreamWrite(st, s, strlen(s)));\n}\n\n\n//\n// 'pdfioStreamRead()' - Read data from a stream.\n//\n// This function reads data from a stream.  When reading decoded image data\n// from a stream, you *must* read whole scanlines.  The\n// @link pdfioImageGetBytesPerLine@ function can be used to determine the\n// proper read length.\n//\n\nssize_t\t\t\t\t\t// O - Number of bytes read or `-1` on error\npdfioStreamRead(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    void           *buffer,\t\t// I - Buffer\n    size_t         bytes)\t\t// I - Bytes to read\n{\n  char\t\t*bufptr = (char *)buffer;\n\t\t\t\t\t// Pointer into buffer\n  size_t\tremaining;\t\t// Remaining bytes in buffer\n  ssize_t\trbytes;\t\t\t// Bytes read\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bytes)\n    return (-1);\n\n  // Loop until we have the requested bytes or hit the end of the stream...\n  while ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)\n  {\n    memcpy(bufptr, st->bufptr, remaining);\n    bufptr += remaining;\n    bytes -= remaining;\n\n    if (bytes >= sizeof(st->buffer))\n    {\n      // Read large amounts directly to caller's buffer...\n      if ((rbytes = stream_read(st, bufptr, bytes)) > 0)\n        bufptr += rbytes;\n\n      bytes      = 0;\n      st->bufptr = st->bufend = st->buffer;\n      break;\n    }\n    else if ((rbytes = stream_read(st, st->buffer, sizeof(st->buffer))) > 0)\n    {\n      st->bufptr = st->buffer;\n      st->bufend = st->buffer + rbytes;\n    }\n    else\n    {\n      st->bufptr = st->bufend = st->buffer;\n      bytes = 0;\n      break;\n    }\n  }\n\n  // Copy any remaining bytes from the stream buffer...\n  if (bytes > 0)\n  {\n    memcpy(bufptr, st->bufptr, bytes);\n    bufptr     += bytes;\n    st->bufptr += bytes;\n  }\n\n  // Return the number of bytes that were read...\n  return (bufptr - (char *)buffer);\n}\n\n\n//\n// 'pdfioStreamWrite()' - Write data to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success or `false` on failure\npdfioStreamWrite(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    const void     *buffer,\t\t// I - Data to write\n    size_t         bytes)\t\t// I - Number of bytes to write\n{\n  size_t\t\tpbpixel,\t// Size of pixel in bytes\n      \t\t\tpbline,\t\t// Bytes per line\n\t\t\tremaining;\t// Remaining bytes on this line\n  const unsigned char\t*bufptr,\t// Pointer into buffer\n\t\t\t*bufsecond;\t// Pointer to second pixel in buffer\n  unsigned char\t\t*sptr,\t\t// Pointer into sbuffer\n\t\t\t*pptr;\t\t// Previous raw buffer\n\n\n  PDFIO_DEBUG(\"pdfioStreamWrite(st=%p, buffer=%p, bytes=%lu)\\n\", st, buffer, (unsigned long)bytes);\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !buffer || !bytes)\n    return (false);\n\n  // Write it...\n  if (st->filter == PDFIO_FILTER_NONE)\n  {\n    // No filtering...\n    if (st->crypto_cb)\n    {\n      // Encrypt data before writing...\n      uint8_t\ttemp[8192];\t\t// Temporary buffer\n      size_t\tcbytes,\t\t\t// Current bytes\n\t\toutbytes;\t\t// Output bytes\n\n      bufptr = (const unsigned char *)buffer;\n\n      while (bytes > 0)\n      {\n        if (st->bufptr > st->buffer || bytes < 16)\n        {\n          // Write through the stream's buffer...\n          if ((cbytes = bytes) > (size_t)(st->bufend - st->bufptr))\n            cbytes = (size_t)(st->bufend - st->bufptr);\n\n          memcpy(st->bufptr, bufptr, cbytes);\n          st->bufptr += cbytes;\n          if (st->bufptr >= st->bufend)\n          {\n            // Encrypt and flush\n\t    outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, (uint8_t *)st->buffer, sizeof(st->buffer));\n\t    if (!_pdfioFileWrite(st->pdf, temp, outbytes))\n\t      return (false);\n\n\t    st->bufptr = st->buffer;\n          }\n        }\n        else\n        {\n          // Write directly up to sizeof(temp) bytes...\n          if ((cbytes = bytes) > sizeof(temp))\n            cbytes = sizeof(temp);\n          if (cbytes & 15)\n          {\n            // AES has a 16-byte block size, so save the last few bytes...\n            cbytes &= (size_t)~15;\n          }\n\n\t  outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, bufptr, cbytes);\n\t  if (!_pdfioFileWrite(st->pdf, temp, outbytes))\n\t    return (false);\n        }\n\n        bytes -= cbytes;\n        bufptr += cbytes;\n      }\n\n      return (true);\n    }\n    else\n    {\n      // Write unencrypted...\n      return (_pdfioFileWrite(st->pdf, buffer, bytes));\n    }\n  }\n\n  pbline = st->pbsize - 1;\n\n  if (st->predictor == _PDFIO_PREDICTOR_NONE)\n  {\n    // No predictor, just write it out straight...\n    return (stream_write(st, buffer, bytes));\n  }\n  else if ((bytes % pbline) != 0)\n  {\n    _pdfioFileError(st->pdf, \"Write buffer size must be a multiple of a complete row.\");\n    return (false);\n  }\n\n  pbpixel   = st->pbpixel;\n  bufptr    = (const unsigned char *)buffer;\n  bufsecond = bufptr + pbpixel;\n\n  while (bytes > 0)\n  {\n    // Store the PNG predictor in the first byte of the buffer...\n    if (st->predictor == _PDFIO_PREDICTOR_PNG_AUTO)\n      st->psbuffer[0] = 4;\t\t// Use Paeth predictor for auto...\n    else\n      st->psbuffer[0] = (unsigned char)(st->predictor - 10);\n\n    // Then process the current line using the specified PNG predictor...\n    sptr = st->psbuffer + 1;\n    pptr = st->prbuffer;\n\n    switch (st->predictor)\n    {\n      default :\n          // Anti-compiler-warning code (NONE is handled above, TIFF is not supported for writing)\n\t  return (false);\n\n      case _PDFIO_PREDICTOR_PNG_NONE :\n          // No PNG predictor...\n          memcpy(sptr, buffer, pbline);\n          break;\n\n      case _PDFIO_PREDICTOR_PNG_SUB :\n\t  // Encode the difference from the previous column\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++)\n\t  {\n\t    if (bufptr >= bufsecond)\n\t      *sptr = *bufptr - bufptr[-(int)pbpixel];\n\t    else\n\t      *sptr = *bufptr;\n\t  }\n\t  break;\n\n      case _PDFIO_PREDICTOR_PNG_UP :\n\t  // Encode the difference from the previous line\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)\n\t  {\n\t    *sptr = *bufptr - *pptr;\n\t  }\n\t  break;\n\n      case _PDFIO_PREDICTOR_PNG_AVERAGE :\n          // Encode the difference with the average of the previous column and line\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)\n\t  {\n\t    if (bufptr >= bufsecond)\n\t      *sptr = *bufptr - (bufptr[-(int)pbpixel] + *pptr) / 2;\n\t    else\n\t      *sptr = *bufptr - *pptr / 2;\n\t  }\n\t  break;\n\n      case _PDFIO_PREDICTOR_PNG_PAETH :\n      case _PDFIO_PREDICTOR_PNG_AUTO :\n          // Encode the difference with a linear transform function\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)\n\t  {\n\t    if (bufptr >= bufsecond)\n\t      *sptr = *bufptr - stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);\n\t    else\n\t      *sptr = *bufptr - stream_paeth(0, *pptr, 0);\n\t  }\n\t  break;\n    }\n\n    // Write the encoded line...\n    if (!stream_write(st, st->psbuffer, st->pbsize))\n      return (false);\n\n    memcpy(st->prbuffer, buffer, pbline);\n    bytes -= pbline;\n  }\n\n  return (true);\n}\n\n\n//\n// 'stream_paeth()' - PaethPredictor function for PNG decompression filter.\n//\n\nstatic unsigned char\t\t\t// O - Predictor value\nstream_paeth(unsigned char a,\t\t// I - Left pixel\n             unsigned char b,\t\t// I - Top pixel\n             unsigned char c)\t\t// I - Top-left pixel\n{\n  int\tp = a + b - c;\t\t\t// Initial estimate\n  int\tpa = abs(p - a);\t\t// Distance to a\n  int\tpb = abs(p - b);\t\t// Distance to b\n  int\tpc = abs(p - c);\t\t// Distance to c\n\n  return ((pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c);\n}\n\n\n//\n// 'stream_read()' - Read data from a stream, including filters.\n//\n\nstatic ssize_t\t\t\t\t// O - Number of bytes read or `-1` on error\nstream_read(pdfio_stream_t *st,\t\t// I - Stream\n            char           *buffer,\t// I - Buffer\n            size_t         bytes)\t// I - Number of bytes to read\n{\n  ssize_t\trbytes;\t\t\t// Bytes read\n\n\n  if (st->filter == PDFIO_FILTER_NONE)\n  {\n    // No filtering, but limit reads to the length of the stream...\n    if (bytes > st->remaining)\n      rbytes = _pdfioFileRead(st->pdf, buffer, st->remaining);\n    else\n      rbytes = _pdfioFileRead(st->pdf, buffer, bytes);\n\n    if (rbytes > 0)\n    {\n      st->remaining -= (size_t)rbytes;\n\n      if (st->crypto_cb)\n        (st->crypto_cb)(&st->crypto_ctx, (uint8_t *)buffer, (uint8_t *)buffer, (size_t)rbytes);\n    }\n\n    return (rbytes);\n  }\n  else if (st->filter == PDFIO_FILTER_FLATE)\n  {\n    // Deflate compression...\n    int\tstatus;\t\t\t\t// Status of decompression\n\n    if (st->predictor == _PDFIO_PREDICTOR_NONE)\n    {\n      // Decompress into the buffer...\n      PDFIO_DEBUG(\"stream_read: No predictor.\\n\");\n\n      if (st->flate.avail_in == 0)\n      {\n\t// Read more from the file...\n\tif (sizeof(st->cbuffer) > st->remaining)\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\telse\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\tif (rbytes <= 0)\n\t  return (-1);\t\t\t// End of file...\n\n\tif (st->crypto_cb)\n\t  rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\tst->remaining      -= (size_t)rbytes;\n\tst->flate.next_in  = (Bytef *)st->cbuffer;\n\tst->flate.avail_in = (uInt)rbytes;\n      }\n\n      st->flate.next_out  = (Bytef *)buffer;\n      st->flate.avail_out = (uInt)bytes;\n\n      if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\treturn (-1);\n      }\n\n      return (st->flate.next_out - (Bytef *)buffer);\n    }\n    else if (st->predictor == _PDFIO_PREDICTOR_TIFF2)\n    {\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer;\n\t\t\t\t\t// Current (raw) line\n\n      PDFIO_DEBUG(\"stream_read: TIFF predictor 2.\\n\");\n\n      if (bytes < st->pbsize)\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END)\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n        return (-1);\t\t\t// Early end of stream\n\n      for (; bufptr < bufsecond; remaining --, sptr ++)\n\t*bufptr++ = *sptr;\n      for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n\t*bufptr = *sptr + bufptr[-(int)pbpixel];\n\n      return ((ssize_t)st->pbsize);\n    }\n    else\n    {\n      // PNG predictor\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize - 1;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer + 1,\n\t\t\t\t\t// Current (raw) line\n\t\t\t*pptr = st->prbuffer;\n\t\t\t\t\t// Previous (raw) line\n\n      PDFIO_DEBUG(\"stream_read: PNG predictor.\\n\");\n\n      if (bytes < (st->pbsize - 1))\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr - 1;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END)\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n      {\n\t// Early end of stream\n        PDFIO_DEBUG(\"stream_read: Early EOF (remaining=%u, avail_in=%d, avail_out=%d, data_type=%d, next_in=<%02X%02X%02X%02X...>).\\n\", (unsigned)st->remaining, st->flate.avail_in, st->flate.avail_out, st->flate.data_type, st->flate.next_in[0], st->flate.next_in[1], st->flate.next_in[2], st->flate.next_in[3]);\n        return (-1);\n      }\n\n      // Apply predictor for this line\n      PDFIO_DEBUG(\"stream_read: Line %02X %02X %02X %02X %02X.\\n\", sptr[-1], sptr[0], sptr[0], sptr[2], sptr[3]);\n\n      switch (sptr[-1])\n      {\n        case 0 : // None\n        case 10 : // None (for buggy PDF writers)\n            memcpy(buffer, sptr, remaining);\n            break;\n        case 1 : // Sub\n        case 11 : // Sub (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++)\n              *bufptr++ = *sptr;\n            for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n              *bufptr = *sptr + bufptr[-(int)pbpixel];\n            break;\n        case 2 : // Up\n        case 12 : // Up (for buggy PDF writers)\n            for (; remaining > 0; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + *pptr;\n            break;\n        case 3 : // Average\n        case 13 : // Average (for buggy PDF writers)\n\t    for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n\t      *bufptr++ = *sptr + *pptr / 2;\n\t    for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n\t      *bufptr = *sptr + (bufptr[-(int)pbpixel] + *pptr) / 2;\n            break;\n        case 4 : // Paeth\n        case 14 : // Paeth (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + stream_paeth(0, *pptr, 0);\n            for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n              *bufptr = *sptr + stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);\n            break;\n\n        default :\n            _pdfioFileError(st->pdf, \"Bad PNG filter %d in data stream.\", sptr[-1]);\n            return (-1);\n      }\n\n      // Copy the computed line and swap buffers...\n      memcpy(st->prbuffer, buffer, st->pbsize - 1);\n\n      // Return the number of bytes we copied for this line...\n      return ((ssize_t)(st->pbsize - 1));\n    }\n  }\n\n  // If we get here something bad happened...\n  return (-1);\n}\n\n\n//\n// 'stream_write()' - Write flate-compressed data...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nstream_write(pdfio_stream_t *st,\t// I - Stream\n             const void     *buffer,\t// I - Buffer to write\n             size_t         bytes)\t// I - Number of bytes to write\n{\n  int\tstatus;\t\t\t\t// Compression status\n\n\n  // Flate-compress the buffer...\n  st->flate.avail_in = (uInt)bytes;\n  st->flate.next_in  = (Bytef *)buffer;\n\n  while (st->flate.avail_in > 0)\n  {\n    if (st->flate.avail_out < (sizeof(st->cbuffer) / 8))\n    {\n      // Flush the compression buffer...\n      size_t\tcbytes = sizeof(st->cbuffer) - st->flate.avail_out,\n\t\toutbytes;\n\n      if (st->crypto_cb)\n      {\n        // Encrypt it first...\n        outbytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, cbytes & (size_t)~15);\n      }\n      else\n      {\n        outbytes = cbytes;\n      }\n\n//      fprintf(stderr, \"stream_write: bytes=%u, outbytes=%u\\n\", (unsigned)bytes, (unsigned)outbytes);\n\n      if (!_pdfioFileWrite(st->pdf, st->cbuffer, outbytes))\n        return (false);\n\n      if (cbytes > outbytes)\n      {\n        cbytes -= outbytes;\n        memmove(st->cbuffer, st->cbuffer + outbytes, cbytes);\n      }\n      else\n      {\n        cbytes = 0;\n      }\n\n      st->flate.next_out  = (Bytef *)st->cbuffer + cbytes;\n      st->flate.avail_out = (uInt)(sizeof(st->cbuffer) - cbytes);\n    }\n\n    // Deflate what we can this time...\n    status = deflate(&st->flate, Z_NO_FLUSH);\n\n    if (status < Z_OK && status != Z_BUF_ERROR)\n    {\n      _pdfioFileError(st->pdf, \"Flate compression failed: %s\", zstrerror(status));\n      return (false);\n    }\n  }\n\n  return (true);\n}\n\n\n//\n// 'zstrerror()' - Return a string for a zlib error number.\n//\n\nstatic const char *\t\t\t// O - Error string\nzstrerror(int error)\t\t\t// I - Error number\n{\n  switch (error)\n  {\n    case Z_OK :\n        return (\"No error.\");\n\n    case Z_STREAM_END :\n        return (\"End of stream.\");\n\n    case Z_NEED_DICT :\n        return (\"Need a huffman dictinary.\");\n\n    case Z_ERRNO :\n        return (strerror(errno));\n\n    case Z_STREAM_ERROR :\n        return (\"Stream error.\");\n\n    case Z_DATA_ERROR :\n        return (\"Data error.\");\n\n    case Z_MEM_ERROR :\n        return (\"Out of memory.\");\n\n    case Z_BUF_ERROR :\n        return (\"Out of buffers.\");\n\n    case Z_VERSION_ERROR :\n        return (\"Mismatched zlib library.\");\n\n    default :\n        return (\"Unknown error.\");\n  }\n}\n"], "fixing_code": ["Changes in PDFio\n================\n\n\nv1.1.1 (March 20, 2023)\n-----------------------\n\n- CVE-2023-NNNNN: Fixed a potential denial-of-service with corrupt PDF files.\n- Fixed a build issue.\n\n\nv1.1.0 (February 6, 2023)\n-------------------------\n\n- CVE-2023-24808: Fixed a potential denial-of-service with corrupt PDF files.\n- Added `pdfioFileCreateTemporary` function (Issue #29)\n- Added `pdfioDictIterateKeys` function (Issue #31)\n- Added `pdfioContentPathEnd` function.\n- Added protection against opening multiple streams in the same file at the\n  same time.\n- Documentation updates (Issue #37)\n- Fixed \"install-shared\" target (Issue #32)\n- Fixed `pdfioFileGet...` metadata APIs (Issue #33)\n- Fixed `pdfioContentMatrixRotate` function.\n\n\nv1.0.1 (March 2, 2022)\n----------------------\n\n- Added missing `pdfioPageGetNumStreams` and `pdfioPageOpenStream` functions.\n- Added demo pdfiototext utility.\n- Fixed bug in `pdfioStreamGetToken`.\n\n\nv1.0.0 (December 14, 2021)\n--------------------------\n\n- First stable release.\n\n\nv1.0rc1 (November 30, 2021)\n---------------------------\n\n- Fixed a few stack/buffer overflow bugs discovered via fuzzing.\n\n\nv1.0b2 (November 7, 2021)\n-------------------------\n\n- Added `pdfioFileCreateOutput` API to support streaming output of PDF\n  (Issue #21)\n- Fixed `all-shared` target (Issue #22)\n- Fixed memory leaks (Issue #23)\n- Updated `pdfioContentSetDashPattern` to accept `double` values (Issue #25)\n- Added support for reading and writing encrypted PDFs (Issue #26)\n- Fixed some issues identified by a Coverity scan.\n\n\nv1.0b1 (August 30, 2021)\n------------------------\n\n- Initial release\n", "//\n// PDF stream functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic unsigned char\tstream_paeth(unsigned char a, unsigned char b, unsigned char c);\nstatic ssize_t\t\tstream_read(pdfio_stream_t *st, char *buffer, size_t bytes);\nstatic bool\t\tstream_write(pdfio_stream_t *st, const void *buffer, size_t bytes);\nstatic const char\t*zstrerror(int error);\n\n\n//\n// 'pdfioStreamClose()' - Close a (data) stream in a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamClose(pdfio_stream_t *st)\t// I - Stream\n{\n  bool ret = true;\t\t\t// Return value\n\n\n  // Range check input...\n  if (!st)\n    return (false);\n\n  // Finish reads/writes and free memory...\n  if (st->pdf->mode == _PDFIO_MODE_READ)\n  {\n    if (st->filter == PDFIO_FILTER_FLATE)\n      inflateEnd(&(st->flate));\n  }\n  else\n  {\n    // Close stream for writing...\n    if (st->filter == PDFIO_FILTER_FLATE)\n    {\n      // Finalize flate compression stream...\n      int status;\t\t\t// Deflate status\n\n      while ((status = deflate(&st->flate, Z_FINISH)) != Z_STREAM_END)\n      {\n        size_t\tbytes = sizeof(st->cbuffer) - st->flate.avail_out,\n\t\t\t\t\t// Bytes to write\n\t\toutbytes;\t\t// Actual bytes written\n\n\tif (status < Z_OK && status != Z_BUF_ERROR)\n\t{\n\t  _pdfioFileError(st->pdf, \"Flate compression failed: %s\", zstrerror(status));\n\t  ret = false;\n\t  goto done;\n\t}\n\n\tif (st->crypto_cb)\n\t{\n\t  // Encrypt it first...\n\t  outbytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, bytes & (size_t)~15);\n\t}\n\telse\n\t{\n\t  // No encryption\n\t  outbytes = bytes;\n\t}\n\n\tif (!_pdfioFileWrite(st->pdf, st->cbuffer, outbytes))\n\t{\n\t  ret = false;\n\t  goto done;\n\t}\n\n        if (bytes > outbytes)\n        {\n          bytes -= outbytes;\n          memmove(st->cbuffer, st->cbuffer + outbytes, bytes);\n        }\n        else\n        {\n          bytes = 0;\n        }\n\n\tst->flate.next_out  = (Bytef *)st->cbuffer + bytes;\n\tst->flate.avail_out = (uInt)(sizeof(st->cbuffer) - bytes);\n      }\n\n      if (st->flate.avail_out < (uInt)sizeof(st->cbuffer))\n      {\n        // Write any residuals...\n        size_t bytes = sizeof(st->cbuffer) - st->flate.avail_out;\n\t\t\t\t\t// Bytes to write\n\n\tif (st->crypto_cb)\n\t{\n\t  // Encrypt it first...\n\t  bytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, bytes);\n\t}\n\n\tif (!_pdfioFileWrite(st->pdf, st->cbuffer, bytes))\n\t{\n\t  ret = false;\n\t  goto done;\n\t}\n      }\n\n      deflateEnd(&st->flate);\n    }\n    else if (st->crypto_cb && st->bufptr > st->buffer)\n    {\n      // Encrypt and flush\n      uint8_t\ttemp[8192];\t\t// Temporary buffer\n      size_t\toutbytes;\t\t// Output bytes\n\n      outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, (uint8_t *)st->buffer, (size_t)(st->bufptr - st->buffer));\n      if (!_pdfioFileWrite(st->pdf, temp, outbytes))\n      {\n        ret = false;\n        goto done;\n      }\n    }\n\n    // Save the length of this stream...\n    st->obj->stream_length = (size_t)(_pdfioFileTell(st->pdf) - st->obj->stream_offset);\n\n    // End of stream marker...\n    if (!_pdfioFilePuts(st->pdf, \"\\nendstream\\nendobj\\n\"))\n    {\n      ret = false;\n      goto done;\n    }\n\n    // Update the length as needed...\n    if (st->length_obj)\n    {\n      st->length_obj->value.value.number = st->obj->stream_length;\n      pdfioObjClose(st->length_obj);\n    }\n    else if (st->obj->length_offset)\n    {\n      // Seek back to the \"/Length 9999999999\" we wrote...\n      if (_pdfioFileSeek(st->pdf, st->obj->length_offset, SEEK_SET) < 0)\n      {\n        ret = false;\n        goto done;\n      }\n\n      // Write the updated length value...\n      if (!_pdfioFilePrintf(st->pdf, \"%-10lu\", (unsigned long)st->obj->stream_length))\n      {\n        ret = false;\n        goto done;\n      }\n\n      // Seek to the end of the PDF file...\n      if (_pdfioFileSeek(st->pdf, 0, SEEK_END) < 0)\n      {\n        ret = false;\n        goto done;\n      }\n    }\n  }\n\n  done:\n\n  st->pdf->current_obj = NULL;\n\n  free(st->prbuffer);\n  free(st->psbuffer);\n  free(st);\n\n  return (ret);\n}\n\n\n//\n// '_pdfioStreamCreate()' - Create a stream for writing.\n//\n// Note: pdfioObjCreateStream handles writing the object and its dictionary.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\n_pdfioStreamCreate(\n    pdfio_obj_t    *obj,\t\t// I - Object\n    pdfio_obj_t    *length_obj,\t\t// I - Length object, if any\n    pdfio_filter_t compression)\t\t// I - Compression to apply\n{\n  pdfio_stream_t\t*st;\t\t// Stream\n\n\n  // Allocate a new stream object...\n  if ((st = (pdfio_stream_t *)calloc(1, sizeof(pdfio_stream_t))) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to allocate memory for a stream.\");\n    return (NULL);\n  }\n\n  st->pdf        = obj->pdf;\n  st->obj        = obj;\n  st->length_obj = length_obj;\n  st->filter     = compression;\n  st->bufptr     = st->buffer;\n  st->bufend     = st->buffer + sizeof(st->buffer);\n\n  if (obj->pdf->encryption)\n  {\n    uint8_t\tiv[64];\t\t\t// Initialization vector\n    size_t\tivlen = sizeof(iv);\t// Length of initialization vector, if any\n\n    if ((st->crypto_cb = _pdfioCryptoMakeWriter(st->pdf, obj, &st->crypto_ctx, iv, &ivlen)) == NULL)\n    {\n      // TODO: Add error message?\n      free(st);\n      return (NULL);\n    }\n\n    if (ivlen > 0)\n      _pdfioFileWrite(st->pdf, iv, ivlen);\n  }\n\n  if (compression == PDFIO_FILTER_FLATE)\n  {\n    // Flate compression\n    pdfio_dict_t *params = pdfioDictGetDict(obj->value.value.dict, \"DecodeParms\");\n\t\t\t\t\t// Decoding parameters\n    int bpc = (int)pdfioDictGetNumber(params, \"BitsPerComponent\");\n\t\t\t\t\t// Bits per component\n    int colors = (int)pdfioDictGetNumber(params, \"Colors\");\n\t\t\t\t\t// Number of colors\n    int columns = (int)pdfioDictGetNumber(params, \"Columns\");\n\t\t\t\t\t// Number of columns\n    int predictor = (int)pdfioDictGetNumber(params, \"Predictor\");\n\t\t\t\t\t// Predictory value, if any\n    int status;\t\t\t\t// ZLIB status code\n\n    PDFIO_DEBUG(\"_pdfioStreamCreate: FlateDecode - BitsPerComponent=%d, Colors=%d, Columns=%d, Predictor=%d\\n\", bpc, colors, columns, predictor);\n\n    if (bpc == 0)\n    {\n      bpc = 8;\n    }\n    else if (bpc < 1 || bpc == 3 || (bpc > 4 && bpc < 8) || (bpc > 8 && bpc < 16) || bpc > 16)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported BitsPerColor value %d.\", bpc);\n      free(st);\n      return (NULL);\n    }\n\n    if (colors == 0)\n    {\n      colors = 1;\n    }\n    else if (colors < 0 || colors > 4)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported Colors value %d.\", colors);\n      free(st);\n      return (NULL);\n    }\n\n    if (columns == 0)\n    {\n      columns = 1;\n    }\n    else if (columns < 0)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported Columns value %d.\", columns);\n      free(st);\n      return (NULL);\n    }\n\n    if ((predictor > 1 && predictor < 10) || predictor > 15)\n    {\n      _pdfioFileError(st->pdf, \"Unsupported Predictor function %d.\", predictor);\n      free(st);\n      return (NULL);\n    }\n    else if (predictor)\n    {\n      // Using a PNG predictor function\n      st->predictor = (_pdfio_predictor_t)predictor;\n      st->pbpixel   = (size_t)(bpc * colors + 7) / 8;\n      st->pbsize    = (size_t)(bpc * colors * columns + 7) / 8;\n      if (predictor >= 10)\n\tst->pbsize ++;\t\t// Add PNG predictor byte\n\n      if ((st->prbuffer = calloc(1, st->pbsize - 1)) == NULL || (st->psbuffer = calloc(1, st->pbsize)) == NULL)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to allocate %lu bytes for Predictor buffers.\", (unsigned long)st->pbsize);\n\tfree(st->prbuffer);\n\tfree(st->psbuffer);\n\tfree(st);\n\treturn (NULL);\n      }\n    }\n    else\n      st->predictor = _PDFIO_PREDICTOR_NONE;\n\n    st->flate.next_out  = (Bytef *)st->cbuffer;\n    st->flate.avail_out = (uInt)sizeof(st->cbuffer);\n\n    if ((status = deflateInit(&(st->flate), 9)) != Z_OK)\n    {\n      _pdfioFileError(st->pdf, \"Unable to start Flate filter: %s\", zstrerror(status));\n      free(st->prbuffer);\n      free(st->psbuffer);\n      free(st);\n      return (NULL);\n    }\n  }\n\n  return (st);\n}\n\n\n//\n// 'pdfioStreamConsume()' - Consume bytes from the stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on EOF\npdfioStreamConsume(pdfio_stream_t *st,\t// I - Stream\n                   size_t         bytes)// I - Number of bytes to consume\n{\n  size_t\tremaining;\t\t// Remaining bytes in buffer\n  ssize_t\trbytes;\t\t\t// Bytes read\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !bytes)\n    return (false);\n\n  // Skip bytes in the stream buffer until we've consumed the requested number\n  // or get to the end of the stream...\n  while ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)\n  {\n    bytes -= remaining;\n\n    if ((rbytes = stream_read(st, st->buffer, sizeof(st->buffer))) > 0)\n    {\n      st->bufptr = st->buffer;\n      st->bufend = st->buffer + rbytes;\n    }\n    else\n    {\n      st->bufptr = st->bufend = st->buffer;\n      return (false);\n    }\n  }\n\n  st->bufptr += bytes;\n\n  return (true);\n}\n\n\n//\n// 'pdfioStreamGetToken()' - Read a single PDF token from a stream.\n//\n// This function reads a single PDF token from a stream.  Operator tokens,\n// boolean values, and numbers are returned as-is in the provided string buffer.\n// String values start with the opening parenthesis ('(') but have all escaping\n// resolved and the terminating parenthesis removed.  Hexadecimal string values\n// start with the opening angle bracket ('<') and have all whitespace and the\n// terminating angle bracket removed.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on EOF\npdfioStreamGetToken(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    char           *buffer,\t\t// I - String buffer\n    size_t         bufsize)\t\t// I - Size of string buffer\n{\n  _pdfio_token_t\ttb;\t\t// Token buffer/stack\n  bool\t\t\tret;\t\t// Return value\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bufsize)\n    return (false);\n\n  // Read using the token engine...\n  _pdfioTokenInit(&tb, st->pdf, (_pdfio_tconsume_cb_t)pdfioStreamConsume, (_pdfio_tpeek_cb_t)pdfioStreamPeek, st);\n\n  ret = _pdfioTokenRead(&tb, buffer, bufsize);\n  _pdfioTokenFlush(&tb);\n\n  return (ret);\n}\n\n\n//\n// '_pdfioStreamOpen()' - Create a stream for reading.\n//\n// Note: pdfioObjOpenStream handles loading the object's dictionary and\n// getting the start of the stream data.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\n_pdfioStreamOpen(pdfio_obj_t *obj,\t// I - Object\n                 bool        decode)\t// I - Decode/decompress the stream?\n{\n  pdfio_stream_t\t*st;\t\t// Stream\n  pdfio_dict_t\t\t*dict = pdfioObjGetDict(obj);\n\t\t\t\t\t// Object dictionary\n\n\n  PDFIO_DEBUG(\"_pdfioStreamOpen(obj=%p(%u), decode=%s)\\n\", obj, (unsigned)obj->number, decode ? \"true\" : \"false\");\n\n  // Allocate a new stream object...\n  if ((st = (pdfio_stream_t *)calloc(1, sizeof(pdfio_stream_t))) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to allocate memory for a stream.\");\n    return (NULL);\n  }\n\n  st->pdf = obj->pdf;\n  st->obj = obj;\n\n  if ((st->remaining = pdfioObjGetLength(obj)) == 0)\n  {\n    free(st);\n    return (NULL);\n  }\n\n  if (_pdfioFileSeek(st->pdf, obj->stream_offset, SEEK_SET) != obj->stream_offset)\n  {\n    free(st);\n    return (NULL);\n  }\n\n  if (obj->pdf->encryption)\n  {\n    uint8_t\tiv[64];\t\t\t// Initialization vector\n    size_t\tivlen;\t\t\t// Length of initialization vector, if any\n\n    ivlen = (size_t)_pdfioFilePeek(st->pdf, iv, sizeof(iv));\n\n    if ((st->crypto_cb = _pdfioCryptoMakeReader(st->pdf, obj, &st->crypto_ctx, iv, &ivlen)) == NULL)\n    {\n      // TODO: Add error message?\n      free(st);\n      return (NULL);\n    }\n\n    if (ivlen > 0)\n      _pdfioFileConsume(st->pdf, ivlen);\n\n    if (st->pdf->encryption >= PDFIO_ENCRYPTION_AES_128)\n      st->remaining = (st->remaining + 15) & (size_t)~15;\n  }\n\n  if (decode)\n  {\n    // Try to decode/decompress the contents of this object...\n    const char\t*filter = pdfioDictGetName(dict, \"Filter\");\n\t\t\t\t\t// Filter value\n\n    if (!filter)\n    {\n      // No single filter name, do we have a compound filter?\n      if (pdfioDictGetArray(dict, \"Filter\"))\n      {\n\t// TODO: Implement compound filters...\n\t_pdfioFileError(st->pdf, \"Unsupported compound stream filter.\");\n\tfree(st);\n\treturn (NULL);\n      }\n\n      // No filter, read as-is...\n      st->filter = PDFIO_FILTER_NONE;\n    }\n    else if (!strcmp(filter, \"FlateDecode\"))\n    {\n      // Flate compression\n      pdfio_dict_t *params = pdfioDictGetDict(dict, \"DecodeParms\");\n\t\t\t\t\t// Decoding parameters\n      int bpc = (int)pdfioDictGetNumber(params, \"BitsPerComponent\");\n\t\t\t\t\t// Bits per component\n      int colors = (int)pdfioDictGetNumber(params, \"Colors\");\n\t\t\t\t\t// Number of colors\n      int columns = (int)pdfioDictGetNumber(params, \"Columns\");\n\t\t\t\t\t// Number of columns\n      int predictor = (int)pdfioDictGetNumber(params, \"Predictor\");\n\t\t\t\t\t// Predictory value, if any\n      int status;\t\t\t// ZLIB status\n      ssize_t rbytes;\t\t\t// Bytes read\n\n      PDFIO_DEBUG(\"_pdfioStreamOpen: FlateDecode - BitsPerComponent=%d, Colors=%d, Columns=%d, Predictor=%d\\n\", bpc, colors, columns, predictor);\n\n      st->filter = PDFIO_FILTER_FLATE;\n\n      if (bpc == 0)\n      {\n        bpc = 8;\n      }\n      else if (bpc < 1 || bpc == 3 || (bpc > 4 && bpc < 8) || (bpc > 8 && bpc < 16) || bpc > 16)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported BitsPerColor value %d.\", bpc);\n        free(st);\n        return (NULL);\n      }\n\n      if (colors == 0)\n      {\n        colors = 1;\n      }\n      else if (colors < 0 || colors > 4)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported Colors value %d.\", colors);\n        free(st);\n        return (NULL);\n      }\n\n      if (columns == 0)\n      {\n        columns = 1;\n      }\n      else if (columns < 0)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported Columns value %d.\", columns);\n        free(st);\n        return (NULL);\n      }\n\n      if ((predictor > 2 && predictor < 10) || predictor > 15)\n      {\n        _pdfioFileError(st->pdf, \"Unsupported Predictor function %d.\", predictor);\n        free(st);\n        return (NULL);\n      }\n      else if (predictor > 1)\n      {\n        // Using a predictor function\n        st->predictor = (_pdfio_predictor_t)predictor;\n        st->pbpixel   = (size_t)(bpc * colors + 7) / 8;\n        st->pbsize    = (size_t)(bpc * colors * columns + 7) / 8;\n        if (predictor >= 10)\n          st->pbsize ++;\t\t// Add PNG predictor byte\n\n        if ((st->prbuffer = calloc(1, st->pbsize - 1)) == NULL || (st->psbuffer = calloc(1, st->pbsize)) == NULL)\n        {\n          _pdfioFileError(st->pdf, \"Unable to allocate %lu bytes for Predictor buffers.\", (unsigned long)st->pbsize);\n\t  free(st->prbuffer);\n\t  free(st->psbuffer);\n\t  free(st);\n\t  return (NULL);\n        }\n      }\n      else\n        st->predictor = _PDFIO_PREDICTOR_NONE;\n\n      if (sizeof(st->cbuffer) > st->remaining)\n\trbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n      else\n\trbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n      if (rbytes <= 0)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to read bytes for stream.\");\n\tfree(st->prbuffer);\n\tfree(st->psbuffer);\n\tfree(st);\n\treturn (NULL);\n      }\n\n      if (st->crypto_cb)\n        rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n      st->flate.next_in  = (Bytef *)st->cbuffer;\n      st->flate.avail_in = (uInt)rbytes;\n\n      if (st->cbuffer[0] == 0x0a)\n      {\n        st->flate.next_in ++;\t\t// Skip newline\n        st->flate.avail_in --;\n      }\n\n      PDFIO_DEBUG(\"_pdfioStreamOpen: avail_in=%u, cbuffer=<%02X%02X%02X%02X%02X%02X%02X%02X...>\\n\", st->flate.avail_in, st->cbuffer[0], st->cbuffer[1], st->cbuffer[2], st->cbuffer[3], st->cbuffer[4], st->cbuffer[5], st->cbuffer[6], st->cbuffer[7]);\n\n      if ((status = inflateInit(&(st->flate))) != Z_OK)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to start Flate filter: %s\", zstrerror(status));\n\tfree(st->prbuffer);\n\tfree(st->psbuffer);\n\tfree(st);\n\treturn (NULL);\n      }\n\n      st->remaining -= st->flate.avail_in;\n    }\n    else if (!strcmp(filter, \"LZWDecode\"))\n    {\n      // LZW compression\n      st->filter = PDFIO_FILTER_LZW;\n    }\n    else\n    {\n      // Something else we don't support\n      _pdfioFileError(st->pdf, \"Unsupported stream filter '/%s'.\", filter);\n      free(st);\n      return (NULL);\n    }\n  }\n  else\n  {\n    // Just return the stream data as-is...\n    st->filter = PDFIO_FILTER_NONE;\n  }\n\n  return (st);\n}\n\n\n//\n// 'pdfioStreamPeek()' - Peek at data in a stream.\n//\n\nssize_t\t\t\t\t\t// O - Bytes returned or `-1` on error\npdfioStreamPeek(pdfio_stream_t *st,\t// I - Stream\n                void           *buffer,\t// I - Buffer\n                size_t         bytes)\t// I - Size of buffer\n{\n  size_t\tremaining;\t\t// Remaining bytes in buffer\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bytes)\n    return (-1);\n\n  // See if we have enough bytes in the buffer...\n  if ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)\n  {\n    // No, shift the buffer and read more\n    ssize_t\trbytes;\t\t\t// Bytes read\n\n    if (remaining > 0)\n      memmove(st->buffer, st->bufptr, remaining);\n\n    st->bufptr = st->buffer;\n    st->bufend = st->buffer + remaining;\n\n    if ((rbytes = stream_read(st, st->bufend, sizeof(st->buffer) - remaining)) > 0)\n    {\n      st->bufend += rbytes;\n      remaining  += (size_t)rbytes;\n    }\n  }\n\n  // Copy bytes from the buffer...\n  if (bytes > remaining)\n    bytes = remaining;\n\n  memcpy(buffer, st->bufptr, bytes);\n\n  // Return the number of bytes that were copied...\n  return ((ssize_t)bytes);\n}\n\n\n//\n// 'pdfioStreamPrintf()' - Write a formatted string to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamPrintf(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    const char     *format,\t\t// I - `printf`-style format string\n    ...)\t\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8192];\t\t// String buffer\n  va_list\tap;\t\t\t// Argument pointer\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !format)\n    return (false);\n\n  // Format the string...\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  // Write the string...\n  return (pdfioStreamWrite(st, buffer, strlen(buffer)));\n}\n\n\n//\n// 'pdfioStreamPutChar()' - Write a single character to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamPutChar(pdfio_stream_t *st,\t// I - Stream\n                   int            ch)\t// I - Character\n{\n  char\tbuffer[1];\t\t\t// Write buffer\n\n\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE)\n    return (false);\n\n  buffer[0] = (char)ch;\n\n  return (pdfioStreamWrite(st, buffer, 1));\n}\n\n\n//\n// 'pdfioStreamPuts()' - Write a literal string to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioStreamPuts(pdfio_stream_t *st,\t// I - Stream\n                const char     *s)\t// I - Literal string\n{\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !s)\n    return (false);\n  else\n    return (pdfioStreamWrite(st, s, strlen(s)));\n}\n\n\n//\n// 'pdfioStreamRead()' - Read data from a stream.\n//\n// This function reads data from a stream.  When reading decoded image data\n// from a stream, you *must* read whole scanlines.  The\n// @link pdfioImageGetBytesPerLine@ function can be used to determine the\n// proper read length.\n//\n\nssize_t\t\t\t\t\t// O - Number of bytes read or `-1` on error\npdfioStreamRead(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    void           *buffer,\t\t// I - Buffer\n    size_t         bytes)\t\t// I - Bytes to read\n{\n  char\t\t*bufptr = (char *)buffer;\n\t\t\t\t\t// Pointer into buffer\n  size_t\tremaining;\t\t// Remaining bytes in buffer\n  ssize_t\trbytes;\t\t\t// Bytes read\n\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bytes)\n    return (-1);\n\n  // Loop until we have the requested bytes or hit the end of the stream...\n  while ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)\n  {\n    memcpy(bufptr, st->bufptr, remaining);\n    bufptr += remaining;\n    bytes -= remaining;\n\n    if (bytes >= sizeof(st->buffer))\n    {\n      // Read large amounts directly to caller's buffer...\n      if ((rbytes = stream_read(st, bufptr, bytes)) > 0)\n        bufptr += rbytes;\n\n      bytes      = 0;\n      st->bufptr = st->bufend = st->buffer;\n      break;\n    }\n    else if ((rbytes = stream_read(st, st->buffer, sizeof(st->buffer))) > 0)\n    {\n      st->bufptr = st->buffer;\n      st->bufend = st->buffer + rbytes;\n    }\n    else\n    {\n      st->bufptr = st->bufend = st->buffer;\n      bytes = 0;\n      break;\n    }\n  }\n\n  // Copy any remaining bytes from the stream buffer...\n  if (bytes > 0)\n  {\n    memcpy(bufptr, st->bufptr, bytes);\n    bufptr     += bytes;\n    st->bufptr += bytes;\n  }\n\n  // Return the number of bytes that were read...\n  return (bufptr - (char *)buffer);\n}\n\n\n//\n// 'pdfioStreamWrite()' - Write data to a stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success or `false` on failure\npdfioStreamWrite(\n    pdfio_stream_t *st,\t\t\t// I - Stream\n    const void     *buffer,\t\t// I - Data to write\n    size_t         bytes)\t\t// I - Number of bytes to write\n{\n  size_t\t\tpbpixel,\t// Size of pixel in bytes\n      \t\t\tpbline,\t\t// Bytes per line\n\t\t\tremaining;\t// Remaining bytes on this line\n  const unsigned char\t*bufptr,\t// Pointer into buffer\n\t\t\t*bufsecond;\t// Pointer to second pixel in buffer\n  unsigned char\t\t*sptr,\t\t// Pointer into sbuffer\n\t\t\t*pptr;\t\t// Previous raw buffer\n\n\n  PDFIO_DEBUG(\"pdfioStreamWrite(st=%p, buffer=%p, bytes=%lu)\\n\", st, buffer, (unsigned long)bytes);\n\n  // Range check input...\n  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !buffer || !bytes)\n    return (false);\n\n  // Write it...\n  if (st->filter == PDFIO_FILTER_NONE)\n  {\n    // No filtering...\n    if (st->crypto_cb)\n    {\n      // Encrypt data before writing...\n      uint8_t\ttemp[8192];\t\t// Temporary buffer\n      size_t\tcbytes,\t\t\t// Current bytes\n\t\toutbytes;\t\t// Output bytes\n\n      bufptr = (const unsigned char *)buffer;\n\n      while (bytes > 0)\n      {\n        if (st->bufptr > st->buffer || bytes < 16)\n        {\n          // Write through the stream's buffer...\n          if ((cbytes = bytes) > (size_t)(st->bufend - st->bufptr))\n            cbytes = (size_t)(st->bufend - st->bufptr);\n\n          memcpy(st->bufptr, bufptr, cbytes);\n          st->bufptr += cbytes;\n          if (st->bufptr >= st->bufend)\n          {\n            // Encrypt and flush\n\t    outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, (uint8_t *)st->buffer, sizeof(st->buffer));\n\t    if (!_pdfioFileWrite(st->pdf, temp, outbytes))\n\t      return (false);\n\n\t    st->bufptr = st->buffer;\n          }\n        }\n        else\n        {\n          // Write directly up to sizeof(temp) bytes...\n          if ((cbytes = bytes) > sizeof(temp))\n            cbytes = sizeof(temp);\n          if (cbytes & 15)\n          {\n            // AES has a 16-byte block size, so save the last few bytes...\n            cbytes &= (size_t)~15;\n          }\n\n\t  outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, bufptr, cbytes);\n\t  if (!_pdfioFileWrite(st->pdf, temp, outbytes))\n\t    return (false);\n        }\n\n        bytes -= cbytes;\n        bufptr += cbytes;\n      }\n\n      return (true);\n    }\n    else\n    {\n      // Write unencrypted...\n      return (_pdfioFileWrite(st->pdf, buffer, bytes));\n    }\n  }\n\n  pbline = st->pbsize - 1;\n\n  if (st->predictor == _PDFIO_PREDICTOR_NONE)\n  {\n    // No predictor, just write it out straight...\n    return (stream_write(st, buffer, bytes));\n  }\n  else if ((bytes % pbline) != 0)\n  {\n    _pdfioFileError(st->pdf, \"Write buffer size must be a multiple of a complete row.\");\n    return (false);\n  }\n\n  pbpixel   = st->pbpixel;\n  bufptr    = (const unsigned char *)buffer;\n  bufsecond = bufptr + pbpixel;\n\n  while (bytes > 0)\n  {\n    // Store the PNG predictor in the first byte of the buffer...\n    if (st->predictor == _PDFIO_PREDICTOR_PNG_AUTO)\n      st->psbuffer[0] = 4;\t\t// Use Paeth predictor for auto...\n    else\n      st->psbuffer[0] = (unsigned char)(st->predictor - 10);\n\n    // Then process the current line using the specified PNG predictor...\n    sptr = st->psbuffer + 1;\n    pptr = st->prbuffer;\n\n    switch (st->predictor)\n    {\n      default :\n          // Anti-compiler-warning code (NONE is handled above, TIFF is not supported for writing)\n\t  return (false);\n\n      case _PDFIO_PREDICTOR_PNG_NONE :\n          // No PNG predictor...\n          memcpy(sptr, buffer, pbline);\n          break;\n\n      case _PDFIO_PREDICTOR_PNG_SUB :\n\t  // Encode the difference from the previous column\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++)\n\t  {\n\t    if (bufptr >= bufsecond)\n\t      *sptr = *bufptr - bufptr[-(int)pbpixel];\n\t    else\n\t      *sptr = *bufptr;\n\t  }\n\t  break;\n\n      case _PDFIO_PREDICTOR_PNG_UP :\n\t  // Encode the difference from the previous line\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)\n\t  {\n\t    *sptr = *bufptr - *pptr;\n\t  }\n\t  break;\n\n      case _PDFIO_PREDICTOR_PNG_AVERAGE :\n          // Encode the difference with the average of the previous column and line\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)\n\t  {\n\t    if (bufptr >= bufsecond)\n\t      *sptr = *bufptr - (bufptr[-(int)pbpixel] + *pptr) / 2;\n\t    else\n\t      *sptr = *bufptr - *pptr / 2;\n\t  }\n\t  break;\n\n      case _PDFIO_PREDICTOR_PNG_PAETH :\n      case _PDFIO_PREDICTOR_PNG_AUTO :\n          // Encode the difference with a linear transform function\n\t  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)\n\t  {\n\t    if (bufptr >= bufsecond)\n\t      *sptr = *bufptr - stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);\n\t    else\n\t      *sptr = *bufptr - stream_paeth(0, *pptr, 0);\n\t  }\n\t  break;\n    }\n\n    // Write the encoded line...\n    if (!stream_write(st, st->psbuffer, st->pbsize))\n      return (false);\n\n    memcpy(st->prbuffer, buffer, pbline);\n    bytes -= pbline;\n  }\n\n  return (true);\n}\n\n\n//\n// 'stream_paeth()' - PaethPredictor function for PNG decompression filter.\n//\n\nstatic unsigned char\t\t\t// O - Predictor value\nstream_paeth(unsigned char a,\t\t// I - Left pixel\n             unsigned char b,\t\t// I - Top pixel\n             unsigned char c)\t\t// I - Top-left pixel\n{\n  int\tp = a + b - c;\t\t\t// Initial estimate\n  int\tpa = abs(p - a);\t\t// Distance to a\n  int\tpb = abs(p - b);\t\t// Distance to b\n  int\tpc = abs(p - c);\t\t// Distance to c\n\n  return ((pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c);\n}\n\n\n//\n// 'stream_read()' - Read data from a stream, including filters.\n//\n\nstatic ssize_t\t\t\t\t// O - Number of bytes read or `-1` on error\nstream_read(pdfio_stream_t *st,\t\t// I - Stream\n            char           *buffer,\t// I - Buffer\n            size_t         bytes)\t// I - Number of bytes to read\n{\n  ssize_t\trbytes;\t\t\t// Bytes read\n  uInt\t\tavail_in, avail_out;\t// Previous flate values\n\n\n  if (st->filter == PDFIO_FILTER_NONE)\n  {\n    // No filtering, but limit reads to the length of the stream...\n    if (bytes > st->remaining)\n      rbytes = _pdfioFileRead(st->pdf, buffer, st->remaining);\n    else\n      rbytes = _pdfioFileRead(st->pdf, buffer, bytes);\n\n    if (rbytes > 0)\n    {\n      st->remaining -= (size_t)rbytes;\n\n      if (st->crypto_cb)\n        (st->crypto_cb)(&st->crypto_ctx, (uint8_t *)buffer, (uint8_t *)buffer, (size_t)rbytes);\n    }\n\n    return (rbytes);\n  }\n  else if (st->filter == PDFIO_FILTER_FLATE)\n  {\n    // Deflate compression...\n    int\tstatus;\t\t\t\t// Status of decompression\n\n    if (st->predictor == _PDFIO_PREDICTOR_NONE)\n    {\n      // Decompress into the buffer...\n      PDFIO_DEBUG(\"stream_read: No predictor.\\n\");\n\n      if (st->flate.avail_in == 0)\n      {\n\t// Read more from the file...\n\tif (sizeof(st->cbuffer) > st->remaining)\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\telse\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\tif (rbytes <= 0)\n\t  return (-1);\t\t\t// End of file...\n\n\tif (st->crypto_cb)\n\t  rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\tst->remaining      -= (size_t)rbytes;\n\tst->flate.next_in  = (Bytef *)st->cbuffer;\n\tst->flate.avail_in = (uInt)rbytes;\n      }\n\n      st->flate.next_out  = (Bytef *)buffer;\n      st->flate.avail_out = (uInt)bytes;\n\n      avail_in  = st->flate.avail_in;\n      avail_out = st->flate.avail_out;\n\n      if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\treturn (-1);\n      }\n      else if (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out)\n      {\n\t_pdfioFileError(st->pdf, \"Corrupt stream data.\");\n\treturn (-1);\n      }\n\n      return (st->flate.next_out - (Bytef *)buffer);\n    }\n    else if (st->predictor == _PDFIO_PREDICTOR_TIFF2)\n    {\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer;\n\t\t\t\t\t// Current (raw) line\n\n      PDFIO_DEBUG(\"stream_read: TIFF predictor 2.\\n\");\n\n      if (bytes < st->pbsize)\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n        avail_in  = st->flate.avail_in;\n        avail_out = st->flate.avail_out;\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n        return (-1);\t\t\t// Early end of stream\n\n      for (; bufptr < bufsecond; remaining --, sptr ++)\n\t*bufptr++ = *sptr;\n      for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n\t*bufptr = *sptr + bufptr[-(int)pbpixel];\n\n      return ((ssize_t)st->pbsize);\n    }\n    else\n    {\n      // PNG predictor\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize - 1;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer + 1,\n\t\t\t\t\t// Current (raw) line\n\t\t\t*pptr = st->prbuffer;\n\t\t\t\t\t// Previous (raw) line\n\n      PDFIO_DEBUG(\"stream_read: PNG predictor.\\n\");\n\n      if (bytes < (st->pbsize - 1))\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr - 1;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n        avail_in  = st->flate.avail_in;\n        avail_out = st->flate.avail_out;\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n      {\n\t// Early end of stream\n        PDFIO_DEBUG(\"stream_read: Early EOF (remaining=%u, avail_in=%d, avail_out=%d, data_type=%d, next_in=<%02X%02X%02X%02X...>).\\n\", (unsigned)st->remaining, st->flate.avail_in, st->flate.avail_out, st->flate.data_type, st->flate.next_in[0], st->flate.next_in[1], st->flate.next_in[2], st->flate.next_in[3]);\n        return (-1);\n      }\n\n      // Apply predictor for this line\n      PDFIO_DEBUG(\"stream_read: Line %02X %02X %02X %02X %02X.\\n\", sptr[-1], sptr[0], sptr[0], sptr[2], sptr[3]);\n\n      switch (sptr[-1])\n      {\n        case 0 : // None\n        case 10 : // None (for buggy PDF writers)\n            memcpy(buffer, sptr, remaining);\n            break;\n        case 1 : // Sub\n        case 11 : // Sub (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++)\n              *bufptr++ = *sptr;\n            for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n              *bufptr = *sptr + bufptr[-(int)pbpixel];\n            break;\n        case 2 : // Up\n        case 12 : // Up (for buggy PDF writers)\n            for (; remaining > 0; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + *pptr;\n            break;\n        case 3 : // Average\n        case 13 : // Average (for buggy PDF writers)\n\t    for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n\t      *bufptr++ = *sptr + *pptr / 2;\n\t    for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n\t      *bufptr = *sptr + (bufptr[-(int)pbpixel] + *pptr) / 2;\n            break;\n        case 4 : // Paeth\n        case 14 : // Paeth (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + stream_paeth(0, *pptr, 0);\n            for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n              *bufptr = *sptr + stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);\n            break;\n\n        default :\n            _pdfioFileError(st->pdf, \"Bad PNG filter %d in data stream.\", sptr[-1]);\n            return (-1);\n      }\n\n      // Copy the computed line and swap buffers...\n      memcpy(st->prbuffer, buffer, st->pbsize - 1);\n\n      // Return the number of bytes we copied for this line...\n      return ((ssize_t)(st->pbsize - 1));\n    }\n  }\n\n  // If we get here something bad happened...\n  return (-1);\n}\n\n\n//\n// 'stream_write()' - Write flate-compressed data...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nstream_write(pdfio_stream_t *st,\t// I - Stream\n             const void     *buffer,\t// I - Buffer to write\n             size_t         bytes)\t// I - Number of bytes to write\n{\n  int\tstatus;\t\t\t\t// Compression status\n\n\n  // Flate-compress the buffer...\n  st->flate.avail_in = (uInt)bytes;\n  st->flate.next_in  = (Bytef *)buffer;\n\n  while (st->flate.avail_in > 0)\n  {\n    if (st->flate.avail_out < (sizeof(st->cbuffer) / 8))\n    {\n      // Flush the compression buffer...\n      size_t\tcbytes = sizeof(st->cbuffer) - st->flate.avail_out,\n\t\toutbytes;\n\n      if (st->crypto_cb)\n      {\n        // Encrypt it first...\n        outbytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, cbytes & (size_t)~15);\n      }\n      else\n      {\n        outbytes = cbytes;\n      }\n\n//      fprintf(stderr, \"stream_write: bytes=%u, outbytes=%u\\n\", (unsigned)bytes, (unsigned)outbytes);\n\n      if (!_pdfioFileWrite(st->pdf, st->cbuffer, outbytes))\n        return (false);\n\n      if (cbytes > outbytes)\n      {\n        cbytes -= outbytes;\n        memmove(st->cbuffer, st->cbuffer + outbytes, cbytes);\n      }\n      else\n      {\n        cbytes = 0;\n      }\n\n      st->flate.next_out  = (Bytef *)st->cbuffer + cbytes;\n      st->flate.avail_out = (uInt)(sizeof(st->cbuffer) - cbytes);\n    }\n\n    // Deflate what we can this time...\n    status = deflate(&st->flate, Z_NO_FLUSH);\n\n    if (status < Z_OK && status != Z_BUF_ERROR)\n    {\n      _pdfioFileError(st->pdf, \"Flate compression failed: %s\", zstrerror(status));\n      return (false);\n    }\n  }\n\n  return (true);\n}\n\n\n//\n// 'zstrerror()' - Return a string for a zlib error number.\n//\n\nstatic const char *\t\t\t// O - Error string\nzstrerror(int error)\t\t\t// I - Error number\n{\n  switch (error)\n  {\n    case Z_OK :\n        return (\"No error.\");\n\n    case Z_STREAM_END :\n        return (\"End of stream.\");\n\n    case Z_NEED_DICT :\n        return (\"Need a huffman dictinary.\");\n\n    case Z_ERRNO :\n        return (strerror(errno));\n\n    case Z_STREAM_ERROR :\n        return (\"Stream error.\");\n\n    case Z_DATA_ERROR :\n        return (\"Data error.\");\n\n    case Z_MEM_ERROR :\n        return (\"Out of memory.\");\n\n    case Z_BUF_ERROR :\n        return (\"Out of buffers.\");\n\n    case Z_VERSION_ERROR :\n        return (\"Mismatched zlib library.\");\n\n    default :\n        return (\"Unknown error.\");\n  }\n}\n"], "filenames": ["CHANGES.md", "pdfio-stream.c"], "buggy_code_start_loc": [5, 1010], "buggy_code_end_loc": [7, 1189], "fixing_code_start_loc": [5, 1011], "fixing_code_end_loc": [9, 1204], "type": "CWE-770", "message": "PDFio is a C library for reading and writing PDF files. In versions 1.1.0 and prior, a denial of service vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. This is different from CVE-2023-24808. A patch for this issue is available in version 1.1.1.", "other": {"cve": {"id": "CVE-2023-28428", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-20T15:15:12.360", "lastModified": "2023-03-24T18:35:15.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PDFio is a C library for reading and writing PDF files. In versions 1.1.0 and prior, a denial of service vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. This is different from CVE-2023-24808. A patch for this issue is available in version 1.1.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pdfio_project:pdfio:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "1476C11E-4858-423D-9719-0BF93A4B7208"}]}]}], "references": [{"url": "https://github.com/michaelrsweet/pdfio/commit/97d4955666779dc5b0665e15dd951a5c12426a31", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/michaelrsweet/pdfio/security/advisories/GHSA-68x8-9phf-j7jf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/michaelrsweet/pdfio/commit/97d4955666779dc5b0665e15dd951a5c12426a31"}}