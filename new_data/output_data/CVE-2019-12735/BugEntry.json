{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * getchar.c\n *\n * functions related with getting a character from the user/mapping/redo/...\n *\n * manipulations with redo buffer and stuff buffer\n * mappings and abbreviations\n */\n\n#include \"vim.h\"\n\n/*\n * These buffers are used for storing:\n * - stuffed characters: A command that is translated into another command.\n * - redo characters: will redo the last change.\n * - recorded characters: for the \"q\" command.\n *\n * The bytes are stored like in the typeahead buffer:\n * - K_SPECIAL introduces a special key (two more bytes follow).  A literal\n *   K_SPECIAL is stored as K_SPECIAL KS_SPECIAL KE_FILLER.\n * - CSI introduces a GUI termcap code (also when gui.in_use is FALSE,\n *   otherwise switching the GUI on would make mappings invalid).\n *   A literal CSI is stored as CSI KS_EXTRA KE_CSI.\n * These translations are also done on multi-byte characters!\n *\n * Escaping CSI bytes is done by the system-specific input functions, called\n * by ui_inchar().\n * Escaping K_SPECIAL is done by inchar().\n * Un-escaping is done by vgetc().\n */\n\n#define MINIMAL_SIZE 20\t\t\t/* minimal size for b_str */\n\nstatic buffheader_T redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T recordbuff = {{NULL, {NUL}}, NULL, 0, 0};\n\nstatic int typeahead_char = 0;\t\t/* typeahead char that's not flushed */\n\n/*\n * when block_redo is TRUE redo buffer will not be changed\n * used by edit() to repeat insertions and 'V' command for redoing\n */\nstatic int\tblock_redo = FALSE;\n\n/*\n * Make a hash value for a mapping.\n * \"mode\" is the lower 4 bits of the State for the mapping.\n * \"c1\" is the first character of the \"lhs\".\n * Returns a value between 0 and 255, index in maphash.\n * Put Normal/Visual mode mappings mostly separately from Insert/Cmdline mode.\n */\n#define MAP_HASH(mode, c1) (((mode) & (NORMAL + VISUAL + SELECTMODE + OP_PENDING + TERMINAL)) ? (c1) : ((c1) ^ 0x80))\n\n/*\n * Each mapping is put in one of the 256 hash lists, to speed up finding it.\n */\nstatic mapblock_T\t*(maphash[256]);\nstatic int\t\tmaphash_valid = FALSE;\n\n/*\n * List used for abbreviations.\n */\nstatic mapblock_T\t*first_abbr = NULL; /* first entry in abbrlist */\n\nstatic int\t\tKeyNoremap = 0;\t    /* remapping flags */\n\n/*\n * Variables used by vgetorpeek() and flush_buffers().\n *\n * typebuf.tb_buf[] contains all characters that are not consumed yet.\n * typebuf.tb_buf[typebuf.tb_off] is the first valid character.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.\n * The head of the buffer may contain the result of mappings, abbreviations\n * and @a commands.  The length of this part is typebuf.tb_maplen.\n * typebuf.tb_silent is the part where <silent> applies.\n * After the head are characters that come from the terminal.\n * typebuf.tb_no_abbr_cnt is the number of characters in typebuf.tb_buf that\n * should not be considered for abbreviations.\n * Some parts of typebuf.tb_buf may not be mapped. These parts are remembered\n * in typebuf.tb_noremap[], which is the same length as typebuf.tb_buf and\n * contains RM_NONE for the characters that are not to be remapped.\n * typebuf.tb_noremap[typebuf.tb_off] is the first valid flag.\n * (typebuf has been put in globals.h, because check_termcode() needs it).\n */\n#define RM_YES\t\t0\t/* tb_noremap: remap */\n#define RM_NONE\t\t1\t/* tb_noremap: don't remap */\n#define RM_SCRIPT\t2\t/* tb_noremap: remap local script mappings */\n#define RM_ABBR\t\t4\t/* tb_noremap: don't remap, do abbrev. */\n\n/* typebuf.tb_buf has three parts: room in front (for result of mappings), the\n * middle for typeahead and room for new characters (which needs to be 3 *\n * MAXMAPLEN) for the Amiga).\n */\n#define TYPELEN_INIT\t(5 * (MAXMAPLEN + 3))\nstatic char_u\ttypebuf_init[TYPELEN_INIT];\t/* initial typebuf.tb_buf */\nstatic char_u\tnoremapbuf_init[TYPELEN_INIT];\t/* initial typebuf.tb_noremap */\n\nstatic int\tlast_recorded_len = 0;\t/* number of last recorded chars */\n\nstatic int\tread_readbuf(buffheader_T *buf, int advance);\nstatic void\tinit_typebuf(void);\nstatic void\tmay_sync_undo(void);\nstatic void\tclosescript(void);\nstatic int\tvgetorpeek(int);\nstatic void\tmap_free(mapblock_T **);\nstatic void\tvalidate_maphash(void);\nstatic void\tshowmap(mapblock_T *mp, int local);\nstatic int\tinchar(char_u *buf, int maxlen, long wait_time);\n#ifdef FEAT_EVAL\nstatic char_u\t*eval_map_expr(char_u *str, int c);\n#endif\n\n/*\n * Free and clear a buffer.\n */\n    void\nfree_buff(buffheader_T *buf)\n{\n    buffblock_T\t*p, *np;\n\n    for (p = buf->bh_first.b_next; p != NULL; p = np)\n    {\n\tnp = p->b_next;\n\tvim_free(p);\n    }\n    buf->bh_first.b_next = NULL;\n}\n\n/*\n * Return the contents of a buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    static char_u *\nget_buffcont(\n    buffheader_T\t*buffer,\n    int\t\t\tdozero)\t    /* count == zero is not an error */\n{\n    long_u\t    count = 0;\n    char_u\t    *p = NULL;\n    char_u\t    *p2;\n    char_u\t    *str;\n    buffblock_T *bp;\n\n    /* compute the total length of the string */\n    for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\tcount += (long_u)STRLEN(bp->b_str);\n\n    if ((count || dozero) && (p = lalloc(count + 1, TRUE)) != NULL)\n    {\n\tp2 = p;\n\tfor (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\t    for (str = bp->b_str; *str; )\n\t\t*p2++ = *str++;\n\t*p2 = NUL;\n    }\n    return (p);\n}\n\n/*\n * Return the contents of the record buffer as a single string\n * and clear the record buffer.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_recorded(void)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    p = get_buffcont(&recordbuff, TRUE);\n    free_buff(&recordbuff);\n\n    /*\n     * Remove the characters that were added the last time, these must be the\n     * (possibly mapped) characters that stopped the recording.\n     */\n    len = STRLEN(p);\n    if ((int)len >= last_recorded_len)\n    {\n\tlen -= last_recorded_len;\n\tp[len] = NUL;\n    }\n\n    /*\n     * When stopping recording from Insert mode with CTRL-O q, also remove the\n     * CTRL-O.\n     */\n    if (len > 0 && restart_edit != 0 && p[len - 1] == Ctrl_O)\n\tp[len - 1] = NUL;\n\n    return (p);\n}\n\n/*\n * Return the contents of the redo buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_inserted(void)\n{\n    return get_buffcont(&redobuff, FALSE);\n}\n\n/*\n * Add string \"s\" after the current block of buffer \"buf\".\n * K_SPECIAL and CSI should have been escaped already.\n */\n    static void\nadd_buff(\n    buffheader_T\t*buf,\n    char_u\t\t*s,\n    long\t\tslen)\t/* length of \"s\" or -1 */\n{\n    buffblock_T *p;\n    long_u\t    len;\n\n    if (slen < 0)\n\tslen = (long)STRLEN(s);\n    if (slen == 0)\t\t\t\t/* don't add empty strings */\n\treturn;\n\n    if (buf->bh_first.b_next == NULL)\t/* first add to list */\n    {\n\tbuf->bh_space = 0;\n\tbuf->bh_curr = &(buf->bh_first);\n    }\n    else if (buf->bh_curr == NULL)\t/* buffer has already been read */\n    {\n\tiemsg(_(\"E222: Add to read buffer\"));\n\treturn;\n    }\n    else if (buf->bh_index != 0)\n\tmch_memmove(buf->bh_first.b_next->b_str,\n\t\t    buf->bh_first.b_next->b_str + buf->bh_index,\n\t\t    STRLEN(buf->bh_first.b_next->b_str + buf->bh_index) + 1);\n    buf->bh_index = 0;\n\n    if (buf->bh_space >= (int)slen)\n    {\n\tlen = (long_u)STRLEN(buf->bh_curr->b_str);\n\tvim_strncpy(buf->bh_curr->b_str + len, s, (size_t)slen);\n\tbuf->bh_space -= slen;\n    }\n    else\n    {\n\tif (slen < MINIMAL_SIZE)\n\t    len = MINIMAL_SIZE;\n\telse\n\t    len = slen;\n\tp = (buffblock_T *)lalloc((long_u)(sizeof(buffblock_T) + len),\n\t\t\t\t\t\t\t\t\tTRUE);\n\tif (p == NULL)\n\t    return; /* no space, just forget it */\n\tbuf->bh_space = (int)(len - slen);\n\tvim_strncpy(p->b_str, s, (size_t)slen);\n\n\tp->b_next = buf->bh_curr->b_next;\n\tbuf->bh_curr->b_next = p;\n\tbuf->bh_curr = p;\n    }\n    return;\n}\n\n/*\n * Add number \"n\" to buffer \"buf\".\n */\n    static void\nadd_num_buff(buffheader_T *buf, long n)\n{\n    char_u\tnumber[32];\n\n    sprintf((char *)number, \"%ld\", n);\n    add_buff(buf, number, -1L);\n}\n\n/*\n * Add character 'c' to buffer \"buf\".\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    static void\nadd_char_buff(buffheader_T *buf, int c)\n{\n    char_u\tbytes[MB_MAXBYTES + 1];\n    int\t\tlen;\n    int\t\ti;\n    char_u\ttemp[4];\n\n    if (IS_SPECIAL(c))\n\tlen = 1;\n    else\n\tlen = (*mb_char2bytes)(c, bytes);\n    for (i = 0; i < len; ++i)\n    {\n\tif (!IS_SPECIAL(c))\n\t    c = bytes[i];\n\n\tif (IS_SPECIAL(c) || c == K_SPECIAL || c == NUL)\n\t{\n\t    /* translate special key code into three byte sequence */\n\t    temp[0] = K_SPECIAL;\n\t    temp[1] = K_SECOND(c);\n\t    temp[2] = K_THIRD(c);\n\t    temp[3] = NUL;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    /* Translate a CSI to a CSI - KS_EXTRA - KE_CSI sequence */\n\t    temp[0] = CSI;\n\t    temp[1] = KS_EXTRA;\n\t    temp[2] = (int)KE_CSI;\n\t    temp[3] = NUL;\n\t}\n#endif\n\telse\n\t{\n\t    temp[0] = c;\n\t    temp[1] = NUL;\n\t}\n\tadd_buff(buf, temp, -1L);\n    }\n}\n\n/* First read ahead buffer. Used for translated commands. */\nstatic buffheader_T readbuf1 = {{NULL, {NUL}}, NULL, 0, 0};\n\n/* Second read ahead buffer. Used for redo. */\nstatic buffheader_T readbuf2 = {{NULL, {NUL}}, NULL, 0, 0};\n\n/*\n * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2\n * if that one is empty.\n * If advance == TRUE go to the next char.\n * No translation is done K_SPECIAL and CSI are escaped.\n */\n    static int\nread_readbuffers(int advance)\n{\n    int c;\n\n    c = read_readbuf(&readbuf1, advance);\n    if (c == NUL)\n\tc = read_readbuf(&readbuf2, advance);\n    return c;\n}\n\n    static int\nread_readbuf(buffheader_T *buf, int advance)\n{\n    char_u\tc;\n    buffblock_T\t*curr;\n\n    if (buf->bh_first.b_next == NULL)  /* buffer is empty */\n\treturn NUL;\n\n    curr = buf->bh_first.b_next;\n    c = curr->b_str[buf->bh_index];\n\n    if (advance)\n    {\n\tif (curr->b_str[++buf->bh_index] == NUL)\n\t{\n\t    buf->bh_first.b_next = curr->b_next;\n\t    vim_free(curr);\n\t    buf->bh_index = 0;\n\t}\n    }\n    return c;\n}\n\n/*\n * Prepare the read buffers for reading (if they contain something).\n */\n    static void\nstart_stuff(void)\n{\n    if (readbuf1.bh_first.b_next != NULL)\n    {\n\treadbuf1.bh_curr = &(readbuf1.bh_first);\n\treadbuf1.bh_space = 0;\n    }\n    if (readbuf2.bh_first.b_next != NULL)\n    {\n\treadbuf2.bh_curr = &(readbuf2.bh_first);\n\treadbuf2.bh_space = 0;\n    }\n}\n\n/*\n * Return TRUE if the stuff buffer is empty.\n */\n    int\nstuff_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL\n\t && readbuf2.bh_first.b_next == NULL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if readbuf1 is empty.  There may still be redo characters in\n * redbuf2.\n */\n    int\nreadbuf1_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL);\n}\n#endif\n\n/*\n * Set a typeahead character that won't be flushed.\n */\n    void\ntypeahead_noflush(int c)\n{\n    typeahead_char = c;\n}\n\n/*\n * Remove the contents of the stuff buffer and the mapped characters in the\n * typeahead buffer (used in case of an error).  If \"flush_typeahead\" is true,\n * flush all typeahead characters (used when interrupted by a CTRL-C).\n */\n    void\nflush_buffers(flush_buffers_T flush_typeahead)\n{\n    init_typebuf();\n\n    start_stuff();\n    while (read_readbuffers(TRUE) != NUL)\n\t;\n\n    if (flush_typeahead == FLUSH_MINIMAL)\n    {\n\t// remove mapped characters at the start only\n\ttypebuf.tb_off += typebuf.tb_maplen;\n\ttypebuf.tb_len -= typebuf.tb_maplen;\n    }\n    else\n    {\n\t// remove typeahead\n\tif (flush_typeahead == FLUSH_INPUT)\n\t    // We have to get all characters, because we may delete the first\n\t    // part of an escape sequence.  In an xterm we get one char at a\n\t    // time and we have to get them all.\n\t    while (inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 10L) != 0)\n\t\t;\n\ttypebuf.tb_off = MAXMAPLEN;\n\ttypebuf.tb_len = 0;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t/* Reset the flag that text received from a client or from feedkeys()\n\t * was inserted in the typeahead buffer. */\n\ttypebuf_was_filled = FALSE;\n#endif\n    }\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    cmd_silent = FALSE;\n    typebuf.tb_no_abbr_cnt = 0;\n}\n\n/*\n * The previous contents of the redo buffer is kept in old_redobuffer.\n * This is used for the CTRL-O <.> command in insert mode.\n */\n    void\nResetRedobuff(void)\n{\n    if (!block_redo)\n    {\n\tfree_buff(&old_redobuff);\n\told_redobuff = redobuff;\n\tredobuff.bh_first.b_next = NULL;\n    }\n}\n\n/*\n * Discard the contents of the redo buffer and restore the previous redo\n * buffer.\n */\n    void\nCancelRedo(void)\n{\n    if (!block_redo)\n    {\n\tfree_buff(&redobuff);\n\tredobuff = old_redobuff;\n\told_redobuff.bh_first.b_next = NULL;\n\tstart_stuff();\n\twhile (read_readbuffers(TRUE) != NUL)\n\t    ;\n    }\n}\n\n/*\n * Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.\n * Used before executing autocommands and user functions.\n */\n    void\nsaveRedobuff(save_redo_T *save_redo)\n{\n    char_u\t*s;\n\n    save_redo->sr_redobuff = redobuff;\n    redobuff.bh_first.b_next = NULL;\n    save_redo->sr_old_redobuff = old_redobuff;\n    old_redobuff.bh_first.b_next = NULL;\n\n    /* Make a copy, so that \":normal .\" in a function works. */\n    s = get_buffcont(&save_redo->sr_redobuff, FALSE);\n    if (s != NULL)\n    {\n\tadd_buff(&redobuff, s, -1L);\n\tvim_free(s);\n    }\n}\n\n/*\n * Restore redobuff and old_redobuff from save_redobuff and save_old_redobuff.\n * Used after executing autocommands and user functions.\n */\n    void\nrestoreRedobuff(save_redo_T *save_redo)\n{\n    free_buff(&redobuff);\n    redobuff = save_redo->sr_redobuff;\n    free_buff(&old_redobuff);\n    old_redobuff = save_redo->sr_old_redobuff;\n}\n\n/*\n * Append \"s\" to the redo buffer.\n * K_SPECIAL and CSI should already have been escaped.\n */\n    void\nAppendToRedobuff(char_u *s)\n{\n    if (!block_redo)\n\tadd_buff(&redobuff, s, -1L);\n}\n\n/*\n * Append to Redo buffer literally, escaping special characters with CTRL-V.\n * K_SPECIAL and CSI are escaped as well.\n */\n    void\nAppendToRedobuffLit(\n    char_u\t*str,\n    int\t\tlen)\t    /* length of \"str\" or -1 for up to the NUL */\n{\n    char_u\t*s = str;\n    int\t\tc;\n    char_u\t*start;\n\n    if (block_redo)\n\treturn;\n\n    while (len < 0 ? *s != NUL : s - str < len)\n    {\n\t/* Put a string of normal characters in the redo buffer (that's\n\t * faster). */\n\tstart = s;\n\twhile (*s >= ' '\n#ifndef EBCDIC\n\t\t&& *s < DEL\t/* EBCDIC: all chars above space are normal */\n#endif\n\t\t&& (len < 0 || s - str < len))\n\t    ++s;\n\n\t/* Don't put '0' or '^' as last character, just in case a CTRL-D is\n\t * typed next. */\n\tif (*s == NUL && (s[-1] == '0' || s[-1] == '^'))\n\t    --s;\n\tif (s > start)\n\t    add_buff(&redobuff, start, (long)(s - start));\n\n\tif (*s == NUL || (len >= 0 && s - str >= len))\n\t    break;\n\n\t/* Handle a special or multibyte character. */\n\tif (has_mbyte)\n\t    /* Handle composing chars separately. */\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\tif (c < ' ' || c == DEL || (*s == NUL && (c == '0' || c == '^')))\n\t    add_char_buff(&redobuff, Ctrl_V);\n\n\t/* CTRL-V '0' must be inserted as CTRL-V 048 (EBCDIC: xf0) */\n\tif (*s == NUL && c == '0')\n#ifdef EBCDIC\n\t    add_buff(&redobuff, (char_u *)\"xf0\", 3L);\n#else\n\t    add_buff(&redobuff, (char_u *)\"048\", 3L);\n#endif\n\telse\n\t    add_char_buff(&redobuff, c);\n    }\n}\n\n/*\n * Append a character to the redo buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nAppendCharToRedobuff(int c)\n{\n    if (!block_redo)\n\tadd_char_buff(&redobuff, c);\n}\n\n/*\n * Append a number to the redo buffer.\n */\n    void\nAppendNumberToRedobuff(long n)\n{\n    if (!block_redo)\n\tadd_num_buff(&redobuff, n);\n}\n\n/*\n * Append string \"s\" to the stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffReadbuff(char_u *s)\n{\n    add_buff(&readbuf1, s, -1L);\n}\n\n/*\n * Append string \"s\" to the redo stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffRedoReadbuff(char_u *s)\n{\n    add_buff(&readbuf2, s, -1L);\n}\n\n    void\nstuffReadbuffLen(char_u *s, long len)\n{\n    add_buff(&readbuf1, s, len);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Stuff \"s\" into the stuff buffer, leaving special key codes unmodified and\n * escaping other K_SPECIAL and CSI bytes.\n * Change CR, LF and ESC into a space.\n */\n    void\nstuffReadbuffSpec(char_u *s)\n{\n    int c;\n\n    while (*s != NUL)\n    {\n\tif (*s == K_SPECIAL && s[1] != NUL && s[2] != NUL)\n\t{\n\t    /* Insert special key literally. */\n\t    stuffReadbuffLen(s, 3L);\n\t    s += 3;\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char_adv(&s);\n\t    if (c == CAR || c == NL || c == ESC)\n\t\tc = ' ';\n\t    stuffcharReadbuff(c);\n\t}\n    }\n}\n#endif\n\n/*\n * Append a character to the stuff buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nstuffcharReadbuff(int c)\n{\n    add_char_buff(&readbuf1, c);\n}\n\n/*\n * Append a number to the stuff buffer.\n */\n    void\nstuffnumReadbuff(long n)\n{\n    add_num_buff(&readbuf1, n);\n}\n\n/*\n * Read a character from the redo buffer.  Translates K_SPECIAL, CSI and\n * multibyte characters.\n * The redo buffer is left as it is.\n * If init is TRUE, prepare for redo, return FAIL if nothing to redo, OK\n * otherwise.\n * If old is TRUE, use old_redobuff instead of redobuff.\n */\n    static int\nread_redo(int init, int old_redo)\n{\n    static buffblock_T\t*bp;\n    static char_u\t*p;\n    int\t\t\tc;\n    int\t\t\tn;\n    char_u\t\tbuf[MB_MAXBYTES + 1];\n    int\t\t\ti;\n\n    if (init)\n    {\n\tif (old_redo)\n\t    bp = old_redobuff.bh_first.b_next;\n\telse\n\t    bp = redobuff.bh_first.b_next;\n\tif (bp == NULL)\n\t    return FAIL;\n\tp = bp->b_str;\n\treturn OK;\n    }\n    if ((c = *p) != NUL)\n    {\n\t/* Reverse the conversion done by add_char_buff() */\n\t/* For a multi-byte character get all the bytes and return the\n\t * converted character. */\n\tif (has_mbyte && (c != K_SPECIAL || p[1] == KS_SPECIAL))\n\t    n = MB_BYTE2LEN_CHECK(c);\n\telse\n\t    n = 1;\n\tfor (i = 0; ; ++i)\n\t{\n\t    if (c == K_SPECIAL) /* special key or escaped K_SPECIAL */\n\t    {\n\t\tc = TO_SPECIAL(p[1], p[2]);\n\t\tp += 2;\n\t    }\n#ifdef FEAT_GUI\n\t    if (c == CSI)\t/* escaped CSI */\n\t\tp += 2;\n#endif\n\t    if (*++p == NUL && bp->b_next != NULL)\n\t    {\n\t\tbp = bp->b_next;\n\t\tp = bp->b_str;\n\t    }\n\t    buf[i] = c;\n\t    if (i == n - 1)\t/* last byte of a character */\n\t    {\n\t\tif (n != 1)\n\t\t    c = (*mb_ptr2char)(buf);\n\t\tbreak;\n\t    }\n\t    c = *p;\n\t    if (c == NUL)\t/* cannot happen? */\n\t\tbreak;\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Copy the rest of the redo buffer into the stuff buffer (in a slow way).\n * If old_redo is TRUE, use old_redobuff instead of redobuff.\n * The escaped K_SPECIAL and CSI are copied without translation.\n */\n    static void\ncopy_redo(int old_redo)\n{\n    int\t    c;\n\n    while ((c = read_redo(FALSE, old_redo)) != NUL)\n\tadd_char_buff(&readbuf2, c);\n}\n\n/*\n * Stuff the redo buffer into readbuf2.\n * Insert the redo count into the command.\n * If \"old_redo\" is TRUE, the last but one command is repeated\n * instead of the last command (inserting text). This is used for\n * CTRL-O <.> in insert mode\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo(long count, int old_redo)\n{\n    int\t    c;\n\n    /* init the pointers; return if nothing to redo */\n    if (read_redo(TRUE, old_redo) == FAIL)\n\treturn FAIL;\n\n    c = read_redo(FALSE, old_redo);\n\n    /* copy the buffer name, if present */\n    if (c == '\"')\n    {\n\tadd_buff(&readbuf2, (char_u *)\"\\\"\", 1L);\n\tc = read_redo(FALSE, old_redo);\n\n\t/* if a numbered buffer is used, increment the number */\n\tif (c >= '1' && c < '9')\n\t    ++c;\n\tadd_char_buff(&readbuf2, c);\n\n\t/* the expression register should be re-evaluated */\n\tif (c == '=')\n\t{\n\t    add_char_buff(&readbuf2, CAR);\n\t    cmd_silent = TRUE;\n\t}\n\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    if (c == 'v')   /* redo Visual */\n    {\n\tVIsual = curwin->w_cursor;\n\tVIsual_active = TRUE;\n\tVIsual_select = FALSE;\n\tVIsual_reselect = TRUE;\n\tredo_VIsual_busy = TRUE;\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    /* try to enter the count (in place of a previous count) */\n    if (count)\n    {\n\twhile (VIM_ISDIGIT(c))\t/* skip \"old\" count */\n\t    c = read_redo(FALSE, old_redo);\n\tadd_num_buff(&readbuf2, count);\n    }\n\n    /* copy from the redo buffer into the stuff buffer */\n    add_char_buff(&readbuf2, c);\n    copy_redo(old_redo);\n    return OK;\n}\n\n/*\n * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing\n * the redo buffer into readbuf2.\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo_ins(void)\n{\n    int\t    c;\n\n    if (read_redo(TRUE, FALSE) == FAIL)\n\treturn FAIL;\n    start_stuff();\n\n    /* skip the count and the command character */\n    while ((c = read_redo(FALSE, FALSE)) != NUL)\n    {\n\tif (vim_strchr((char_u *)\"AaIiRrOo\", c) != NULL)\n\t{\n\t    if (c == 'O' || c == 'o')\n\t\tadd_buff(&readbuf2, NL_STR, -1L);\n\t    break;\n\t}\n    }\n\n    /* copy the typed text from the redo buffer into the stuff buffer */\n    copy_redo(FALSE);\n    block_redo = TRUE;\n    return OK;\n}\n\n    void\nstop_redo_ins(void)\n{\n    block_redo = FALSE;\n}\n\n/*\n * Initialize typebuf.tb_buf to point to typebuf_init.\n * alloc() cannot be used here: In out-of-memory situations it would\n * be impossible to type anything.\n */\n    static void\ninit_typebuf(void)\n{\n    if (typebuf.tb_buf == NULL)\n    {\n\ttypebuf.tb_buf = typebuf_init;\n\ttypebuf.tb_noremap = noremapbuf_init;\n\ttypebuf.tb_buflen = TYPELEN_INIT;\n\ttypebuf.tb_len = 0;\n\ttypebuf.tb_off = MAXMAPLEN + 4;\n\ttypebuf.tb_change_cnt = 1;\n    }\n}\n\n/*\n * Insert a string in position 'offset' in the typeahead buffer (for \"@r\"\n * and \":normal\" command, vgetorpeek() and check_termcode()).\n *\n * If noremap is REMAP_YES, new string can be mapped again.\n * If noremap is REMAP_NONE, new string cannot be mapped again.\n * If noremap is REMAP_SKIP, fist char of new string cannot be mapped again,\n * but abbreviations are allowed.\n * If noremap is REMAP_SCRIPT, new string cannot be mapped again, except for\n *\t\t\tscript-local mappings.\n * If noremap is > 0, that many characters of the new string cannot be mapped.\n *\n * If nottyped is TRUE, the string does not return KeyTyped (don't use when\n * offset is non-zero!).\n *\n * If silent is TRUE, cmd_silent is set when the characters are obtained.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nins_typebuf(\n    char_u\t*str,\n    int\t\tnoremap,\n    int\t\toffset,\n    int\t\tnottyped,\n    int\t\tsilent)\n{\n    char_u\t*s1, *s2;\n    int\t\tnewlen;\n    int\t\taddlen;\n    int\t\ti;\n    int\t\tnewoff;\n    int\t\tval;\n    int\t\tnrm;\n\n    init_typebuf();\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n\n    addlen = (int)STRLEN(str);\n\n    if (offset == 0 && addlen <= typebuf.tb_off)\n    {\n\t/*\n\t * Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]\n\t */\n\ttypebuf.tb_off -= addlen;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else if (typebuf.tb_len == 0 && typebuf.tb_buflen\n\t\t\t\t\t       >= addlen + 3 * (MAXMAPLEN + 4))\n    {\n\t/*\n\t * Buffer is empty and string fits in the existing buffer.\n\t * Leave some space before and after, if possible.\n\t */\n\ttypebuf.tb_off = (typebuf.tb_buflen - addlen - 3 * (MAXMAPLEN + 4)) / 2;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else\n    {\n\t/*\n\t * Need to allocate a new buffer.\n\t * In typebuf.tb_buf there must always be room for 3 * (MAXMAPLEN + 4)\n\t * characters.  We add some extra room to avoid having to allocate too\n\t * often.\n\t */\n\tnewoff = MAXMAPLEN + 4;\n\tnewlen = typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);\n\tif (newlen < 0)\t\t    /* string is getting too long */\n\t{\n\t    emsg(_(e_toocompl));    /* also calls flush_buffers */\n\t    setcursor();\n\t    return FAIL;\n\t}\n\ts1 = alloc(newlen);\n\tif (s1 == NULL)\t\t    /* out of memory */\n\t    return FAIL;\n\ts2 = alloc(newlen);\n\tif (s2 == NULL)\t\t    /* out of memory */\n\t{\n\t    vim_free(s1);\n\t    return FAIL;\n\t}\n\ttypebuf.tb_buflen = newlen;\n\n\t/* copy the old chars, before the insertion point */\n\tmch_memmove(s1 + newoff, typebuf.tb_buf + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\t/* copy the new chars */\n\tmch_memmove(s1 + newoff + offset, str, (size_t)addlen);\n\t/* copy the old chars, after the insertion point, including the\tNUL at\n\t * the end */\n\tmch_memmove(s1 + newoff + offset + addlen,\n\t\t\t\t     typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\tif (typebuf.tb_buf != typebuf_init)\n\t    vim_free(typebuf.tb_buf);\n\ttypebuf.tb_buf = s1;\n\n\tmch_memmove(s2 + newoff, typebuf.tb_noremap + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\tmch_memmove(s2 + newoff + offset + addlen,\n\t\t   typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n\tif (typebuf.tb_noremap != noremapbuf_init)\n\t    vim_free(typebuf.tb_noremap);\n\ttypebuf.tb_noremap = s2;\n\n\ttypebuf.tb_off = newoff;\n    }\n    typebuf.tb_len += addlen;\n\n    /* If noremap == REMAP_SCRIPT: do remap script-local mappings. */\n    if (noremap == REMAP_SCRIPT)\n\tval = RM_SCRIPT;\n    else if (noremap == REMAP_SKIP)\n\tval = RM_ABBR;\n    else\n\tval = RM_NONE;\n\n    /*\n     * Adjust typebuf.tb_noremap[] for the new characters:\n     * If noremap == REMAP_NONE or REMAP_SCRIPT: new characters are\n     *\t\t\t(sometimes) not remappable\n     * If noremap == REMAP_YES: all the new characters are mappable\n     * If noremap  > 0: \"noremap\" characters are not remappable, the rest\n     *\t\t\tmappable\n     */\n    if (noremap == REMAP_SKIP)\n\tnrm = 1;\n    else if (noremap < 0)\n\tnrm = addlen;\n    else\n\tnrm = noremap;\n    for (i = 0; i < addlen; ++i)\n\ttypebuf.tb_noremap[typebuf.tb_off + i + offset] =\n\t\t\t\t\t\t  (--nrm >= 0) ? val : RM_YES;\n\n    /* tb_maplen and tb_silent only remember the length of mapped and/or\n     * silent mappings at the start of the buffer, assuming that a mapped\n     * sequence doesn't result in typed characters. */\n    if (nottyped || typebuf.tb_maplen > offset)\n\ttypebuf.tb_maplen += addlen;\n    if (silent || typebuf.tb_silent > offset)\n    {\n\ttypebuf.tb_silent += addlen;\n\tcmd_silent = TRUE;\n    }\n    if (typebuf.tb_no_abbr_cnt && offset == 0)\t/* and not used for abbrev.s */\n\ttypebuf.tb_no_abbr_cnt += addlen;\n\n    return OK;\n}\n\n/*\n * Put character \"c\" back into the typeahead buffer.\n * Can be used for a character obtained by vgetc() that needs to be put back.\n * Uses cmd_silent, KeyTyped and KeyNoremap to restore the flags belonging to\n * the char.\n */\n    void\nins_char_typebuf(int c)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    (void)ins_typebuf(buf, KeyNoremap, 0, !KeyTyped, cmd_silent);\n}\n\n/*\n * Return TRUE if the typeahead buffer was changed (while waiting for a\n * character to arrive).  Happens when a message was received from a client or\n * from feedkeys().\n * But check in a more generic way to avoid trouble: When \"typebuf.tb_buf\"\n * changed it was reallocated and the old pointer can no longer be used.\n * Or \"typebuf.tb_off\" may have been changed and we would overwrite characters\n * that was just added.\n */\n    int\ntypebuf_changed(\n    int\t\ttb_change_cnt)\t/* old value of typebuf.tb_change_cnt */\n{\n    return (tb_change_cnt != 0 && (typebuf.tb_change_cnt != tb_change_cnt\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n#endif\n\t   ));\n}\n\n/*\n * Return TRUE if there are no characters in the typeahead buffer that have\n * not been typed (result from a mapping or come from \":normal\").\n */\n    int\ntypebuf_typed(void)\n{\n    return typebuf.tb_maplen == 0;\n}\n\n/*\n * Return the number of characters that are mapped (or not typed).\n */\n    int\ntypebuf_maplen(void)\n{\n    return typebuf.tb_maplen;\n}\n\n/*\n * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]\n */\n    void\ndel_typebuf(int len, int offset)\n{\n    int\t    i;\n\n    if (len == 0)\n\treturn;\t\t/* nothing to do */\n\n    typebuf.tb_len -= len;\n\n    /*\n     * Easy case: Just increase typebuf.tb_off.\n     */\n    if (offset == 0 && typebuf.tb_buflen - (typebuf.tb_off + len)\n\t\t\t\t\t\t\t >= 3 * MAXMAPLEN + 3)\n\ttypebuf.tb_off += len;\n    /*\n     * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]\n     */\n    else\n    {\n\ti = typebuf.tb_off + offset;\n\t/*\n\t * Leave some extra room at the end to avoid reallocation.\n\t */\n\tif (typebuf.tb_off > MAXMAPLEN)\n\t{\n\t    mch_memmove(typebuf.tb_buf + MAXMAPLEN,\n\t\t\t     typebuf.tb_buf + typebuf.tb_off, (size_t)offset);\n\t    mch_memmove(typebuf.tb_noremap + MAXMAPLEN,\n\t\t\t typebuf.tb_noremap + typebuf.tb_off, (size_t)offset);\n\t    typebuf.tb_off = MAXMAPLEN;\n\t}\n\t/* adjust typebuf.tb_buf (include the NUL at the end) */\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t\t\t     typebuf.tb_buf + i + len,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\t/* adjust typebuf.tb_noremap[] */\n\tmch_memmove(typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t\t typebuf.tb_noremap + i + len,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n    }\n\n    if (typebuf.tb_maplen > offset)\t\t/* adjust tb_maplen */\n    {\n\tif (typebuf.tb_maplen < offset + len)\n\t    typebuf.tb_maplen = offset;\n\telse\n\t    typebuf.tb_maplen -= len;\n    }\n    if (typebuf.tb_silent > offset)\t\t/* adjust tb_silent */\n    {\n\tif (typebuf.tb_silent < offset + len)\n\t    typebuf.tb_silent = offset;\n\telse\n\t    typebuf.tb_silent -= len;\n    }\n    if (typebuf.tb_no_abbr_cnt > offset)\t/* adjust tb_no_abbr_cnt */\n    {\n\tif (typebuf.tb_no_abbr_cnt < offset + len)\n\t    typebuf.tb_no_abbr_cnt = offset;\n\telse\n\t    typebuf.tb_no_abbr_cnt -= len;\n    }\n\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n    /* Reset the flag that text received from a client or from feedkeys()\n     * was inserted in the typeahead buffer. */\n    typebuf_was_filled = FALSE;\n#endif\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n}\n\n/*\n * Write typed characters to script file.\n * If recording is on put the character in the recordbuffer.\n */\n    static void\ngotchars(char_u *chars, int len)\n{\n    char_u\t\t*s = chars;\n    int\t\t\ti;\n    static char_u\tbuf[4];\n    static int\t\tbuflen = 0;\n    int\t\t\ttodo = len;\n\n    while (todo--)\n    {\n\tbuf[buflen++] = *s++;\n\n\t// When receiving a special key sequence, store it until we have all\n\t// the bytes and we can decide what to do with it.\n\tif (buflen == 1 && buf[0] == K_SPECIAL)\n\t    continue;\n\tif (buflen == 2)\n\t    continue;\n\tif (buflen == 3 && buf[1] == KS_EXTRA\n\t\t       && (buf[2] == KE_FOCUSGAINED || buf[2] == KE_FOCUSLOST))\n\t{\n\t    // Drop K_FOCUSGAINED and K_FOCUSLOST, they are not useful in a\n\t    // recording.\n\t    buflen = 0;\n\t    continue;\n\t}\n\n\t/* Handle one byte at a time; no translation to be done. */\n\tfor (i = 0; i < buflen; ++i)\n\t    updatescript(buf[i]);\n\n\tif (reg_recording != 0)\n\t{\n\t    buf[buflen] = NUL;\n\t    add_buff(&recordbuff, buf, (long)buflen);\n\t    /* remember how many chars were last recorded */\n\t    last_recorded_len += buflen;\n\t}\n\tbuflen = 0;\n    }\n    may_sync_undo();\n\n#ifdef FEAT_EVAL\n    /* output \"debug mode\" message next time in debug mode */\n    debug_did_msg = FALSE;\n#endif\n\n    /* Since characters have been typed, consider the following to be in\n     * another mapping.  Search string will be kept in history. */\n    ++maptick;\n}\n\n/*\n * Sync undo.  Called when typed characters are obtained from the typeahead\n * buffer, or when a menu is used.\n * Do not sync:\n * - In Insert mode, unless cursor key has been used.\n * - While reading a script file.\n * - When no_u_sync is non-zero.\n */\n    static void\nmay_sync_undo(void)\n{\n    if ((!(State & (INSERT + CMDLINE)) || arrow_used)\n\t\t\t\t\t       && scriptin[curscript] == NULL)\n\tu_sync(FALSE);\n}\n\n/*\n * Make \"typebuf\" empty and allocate new buffers.\n * Returns FAIL when out of memory.\n */\n    int\nalloc_typebuf(void)\n{\n    typebuf.tb_buf = alloc(TYPELEN_INIT);\n    typebuf.tb_noremap = alloc(TYPELEN_INIT);\n    if (typebuf.tb_buf == NULL || typebuf.tb_noremap == NULL)\n    {\n\tfree_typebuf();\n\treturn FAIL;\n    }\n    typebuf.tb_buflen = TYPELEN_INIT;\n    typebuf.tb_off = MAXMAPLEN + 4;  /* can insert without realloc */\n    typebuf.tb_len = 0;\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    typebuf.tb_no_abbr_cnt = 0;\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n    return OK;\n}\n\n/*\n * Free the buffers of \"typebuf\".\n */\n    void\nfree_typebuf(void)\n{\n    if (typebuf.tb_buf == typebuf_init)\n\tinternal_error(\"Free typebuf 1\");\n    else\n\tvim_free(typebuf.tb_buf);\n    if (typebuf.tb_noremap == noremapbuf_init)\n\tinternal_error(\"Free typebuf 2\");\n    else\n\tvim_free(typebuf.tb_noremap);\n}\n\n/*\n * When doing \":so! file\", the current typeahead needs to be saved, and\n * restored when \"file\" has been read completely.\n */\nstatic typebuf_T saved_typebuf[NSCRIPT];\n\n    int\nsave_typebuf(void)\n{\n    init_typebuf();\n    saved_typebuf[curscript] = typebuf;\n    /* If out of memory: restore typebuf and close file. */\n    if (alloc_typebuf() == FAIL)\n    {\n\tclosescript();\n\treturn FAIL;\n    }\n    return OK;\n}\n\nstatic int old_char = -1;\t/* character put back by vungetc() */\nstatic int old_mod_mask;\t/* mod_mask for ungotten character */\n#ifdef FEAT_MOUSE\nstatic int old_mouse_row;\t/* mouse_row related to old_char */\nstatic int old_mouse_col;\t/* mouse_col related to old_char */\n#endif\n\n/*\n * Save all three kinds of typeahead, so that the user must type at a prompt.\n */\n    void\nsave_typeahead(tasave_T *tp)\n{\n    tp->save_typebuf = typebuf;\n    tp->typebuf_valid = (alloc_typebuf() == OK);\n    if (!tp->typebuf_valid)\n\ttypebuf = tp->save_typebuf;\n\n    tp->old_char = old_char;\n    tp->old_mod_mask = old_mod_mask;\n    old_char = -1;\n\n    tp->save_readbuf1 = readbuf1;\n    readbuf1.bh_first.b_next = NULL;\n    tp->save_readbuf2 = readbuf2;\n    readbuf2.bh_first.b_next = NULL;\n# ifdef USE_INPUT_BUF\n    tp->save_inputbuf = get_input_buf();\n# endif\n}\n\n/*\n * Restore the typeahead to what it was before calling save_typeahead().\n * The allocated memory is freed, can only be called once!\n */\n    void\nrestore_typeahead(tasave_T *tp)\n{\n    if (tp->typebuf_valid)\n    {\n\tfree_typebuf();\n\ttypebuf = tp->save_typebuf;\n    }\n\n    old_char = tp->old_char;\n    old_mod_mask = tp->old_mod_mask;\n\n    free_buff(&readbuf1);\n    readbuf1 = tp->save_readbuf1;\n    free_buff(&readbuf2);\n    readbuf2 = tp->save_readbuf2;\n# ifdef USE_INPUT_BUF\n    set_input_buf(tp->save_inputbuf);\n# endif\n}\n\n/*\n * Open a new script file for the \":source!\" command.\n */\n    void\nopenscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}\n\n/*\n * Close the currently active input script.\n */\n    static void\nclosescript(void)\n{\n    free_typebuf();\n    typebuf = saved_typebuf[curscript];\n\n    fclose(scriptin[curscript]);\n    scriptin[curscript] = NULL;\n    if (curscript > 0)\n\t--curscript;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclose_all_scripts(void)\n{\n    while (scriptin[0] != NULL)\n\tclosescript();\n}\n#endif\n\n#if defined(FEAT_INS_EXPAND) || defined(PROTO)\n/*\n * Return TRUE when reading keys from a script file.\n */\n    int\nusing_script(void)\n{\n    return scriptin[curscript] != NULL;\n}\n#endif\n\n/*\n * This function is called just before doing a blocking wait.  Thus after\n * waiting 'updatetime' for a character to arrive.\n */\n    void\nbefore_blocking(void)\n{\n    updatescript(0);\n#ifdef FEAT_EVAL\n    if (may_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n}\n\n/*\n * updatescipt() is called when a character can be written into the script file\n * or when we have waited some time for a character (c == 0)\n *\n * All the changed memfiles are synced if c == 0 or when the number of typed\n * characters reaches 'updatecount' and 'updatecount' is non-zero.\n */\n    void\nupdatescript(int c)\n{\n    static int\t    count = 0;\n\n    if (c && scriptout)\n\tputc(c, scriptout);\n    if (c == 0 || (p_uc > 0 && ++count >= p_uc))\n    {\n\tml_sync_all(c == 0, TRUE);\n\tcount = 0;\n    }\n}\n\n/*\n * Get the next input character.\n * Can return a special key or a multi-byte character.\n * Can return NUL when called recursively, use safe_vgetc() if that's not\n * wanted.\n * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.\n * Collects the bytes of a multibyte character into the whole character.\n * Returns the modifiers in the global \"mod_mask\".\n */\n    int\nvgetc(void)\n{\n    int\t\tc, c2;\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n\n#ifdef FEAT_EVAL\n    /* Do garbage collection when garbagecollect() was called previously and\n     * we are now at the toplevel. */\n    if (may_garbage_collect && want_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n\n    /*\n     * If a character was put back with vungetc, it was already processed.\n     * Return it directly.\n     */\n    if (old_char != -1)\n    {\n\tc = old_char;\n\told_char = -1;\n\tmod_mask = old_mod_mask;\n#ifdef FEAT_MOUSE\n\tmouse_row = old_mouse_row;\n\tmouse_col = old_mouse_col;\n#endif\n    }\n    else\n    {\n\tmod_mask = 0x0;\n\tlast_recorded_len = 0;\n\tfor (;;)\t\t// this is done twice if there are modifiers\n\t{\n\t    int did_inc = FALSE;\n\n\t    if (mod_mask\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t\t    || im_is_preediting()\n#endif\n\t\t    )\n\t    {\n\t\t// no mapping after modifier has been read\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\tdid_inc = TRUE;\t// mod_mask may change value\n\t    }\n\t    c = vgetorpeek(TRUE);\n\t    if (did_inc)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\n\t    // Get two extra bytes for special keys\n\t    if (c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t    || (gui.in_use && c == CSI)\n#endif\n\t       )\n\t    {\n\t\tint\t    save_allow_keys = allow_keys;\n\n\t\t++no_mapping;\n\t\tallow_keys = 0;\t\t// make sure BS is not found\n\t\tc2 = vgetorpeek(TRUE);\t// no mapping for these chars\n\t\tc = vgetorpeek(TRUE);\n\t\t--no_mapping;\n\t\tallow_keys = save_allow_keys;\n\t\tif (c2 == KS_MODIFIER)\n\t\t{\n\t\t    mod_mask = c;\n\t\t    continue;\n\t\t}\n\t\tc = TO_SPECIAL(c2, c);\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n\t\t// Handle K_TEAROFF here, the caller of vgetc() doesn't need to\n\t\t// know that a menu was torn off\n\t\tif (\n# ifdef VIMDLL\n\t\t    gui.in_use &&\n# endif\n\t\t    c == K_TEAROFF)\n\t\t{\n\t\t    char_u\tname[200];\n\t\t    int\t\ti;\n\n\t\t    // get menu path, it ends with a <CR>\n\t\t    for (i = 0; (c = vgetorpeek(TRUE)) != '\\r'; )\n\t\t    {\n\t\t\tname[i] = c;\n\t\t\tif (i < 199)\n\t\t\t    ++i;\n\t\t    }\n\t\t    name[i] = NUL;\n\t\t    gui_make_tearoff(name);\n\t\t    continue;\n\t\t}\n#endif\n#if defined(FEAT_GUI) && defined(FEAT_GUI_GTK) && defined(FEAT_MENU)\n\t\t// GTK: <F10> normally selects the menu, but it's passed until\n\t\t// here to allow mapping it.  Intercept and invoke the GTK\n\t\t// behavior if it's not mapped.\n\t\tif (c == K_F10 && gui.menubar != NULL)\n\t\t{\n\t\t    gtk_menu_shell_select_first(\n\t\t\t\t\t   GTK_MENU_SHELL(gui.menubar), FALSE);\n\t\t    continue;\n\t\t}\n#endif\n#ifdef FEAT_GUI\n\t\tif (gui.in_use)\n\t\t{\n\t\t    // Handle focus event here, so that the caller doesn't\n\t\t    // need to know about it.  Return K_IGNORE so that we loop\n\t\t    // once (needed if 'lazyredraw' is set).\n\t\t    if (c == K_FOCUSGAINED || c == K_FOCUSLOST)\n\t\t    {\n\t\t\tui_focus_change(c == K_FOCUSGAINED);\n\t\t\tc = K_IGNORE;\n\t\t    }\n\n\t\t    // Translate K_CSI to CSI.  The special key is only used\n\t\t    // to avoid it being recognized as the start of a special\n\t\t    // key.\n\t\t    if (c == K_CSI)\n\t\t\tc = CSI;\n\t\t}\n#endif\n\t    }\n\t    // a keypad or special function key was not mapped, use it like\n\t    // its ASCII equivalent\n\t    switch (c)\n\t    {\n\t\tcase K_KPLUS:\tc = '+'; break;\n\t\tcase K_KMINUS:\tc = '-'; break;\n\t\tcase K_KDIVIDE:\tc = '/'; break;\n\t\tcase K_KMULTIPLY: c = '*'; break;\n\t\tcase K_KENTER:\tc = CAR; break;\n\t\tcase K_KPOINT:\n#ifdef MSWIN\n\t\t\t\t// Can be either '.' or a ',',\n\t\t\t\t// depending on the type of keypad.\n\t\t\t\tc = MapVirtualKey(VK_DECIMAL, 2); break;\n#else\n\t\t\t\tc = '.'; break;\n#endif\n\t\tcase K_K0:\tc = '0'; break;\n\t\tcase K_K1:\tc = '1'; break;\n\t\tcase K_K2:\tc = '2'; break;\n\t\tcase K_K3:\tc = '3'; break;\n\t\tcase K_K4:\tc = '4'; break;\n\t\tcase K_K5:\tc = '5'; break;\n\t\tcase K_K6:\tc = '6'; break;\n\t\tcase K_K7:\tc = '7'; break;\n\t\tcase K_K8:\tc = '8'; break;\n\t\tcase K_K9:\tc = '9'; break;\n\n\t\tcase K_XHOME:\n\t\tcase K_ZHOME:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_HOME;\n\t\t\t\tbreak;\n\t\tcase K_XEND:\n\t\tcase K_ZEND:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_END;\n\t\t\t\tbreak;\n\n\t\tcase K_XUP:\tc = K_UP; break;\n\t\tcase K_XDOWN:\tc = K_DOWN; break;\n\t\tcase K_XLEFT:\tc = K_LEFT; break;\n\t\tcase K_XRIGHT:\tc = K_RIGHT; break;\n\t    }\n\n\t    // For a multi-byte character get all the bytes and return the\n\t    // converted character.\n\t    // Note: This will loop until enough bytes are received!\n\t    if (has_mbyte && (n = MB_BYTE2LEN_CHECK(c)) > 1)\n\t    {\n\t\t++no_mapping;\n\t\tbuf[0] = c;\n\t\tfor (i = 1; i < n; ++i)\n\t\t{\n\t\t    buf[i] = vgetorpeek(TRUE);\n\t\t    if (buf[i] == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t\t    || (\n# ifdef VIMDLL\n\t\t\t\tgui.in_use &&\n# endif\n\t\t\t\tbuf[i] == CSI)\n#endif\n\t\t\t    )\n\t\t    {\n\t\t\t// Must be a K_SPECIAL - KS_SPECIAL - KE_FILLER\n\t\t\t// sequence, which represents a K_SPECIAL (0x80),\n\t\t\t// or a CSI - KS_EXTRA - KE_CSI sequence, which\n\t\t\t// represents a CSI (0x9B),\n\t\t\t// or a K_SPECIAL - KS_EXTRA - KE_CSI, which is CSI\n\t\t\t// too.\n\t\t\tc = vgetorpeek(TRUE);\n\t\t\tif (vgetorpeek(TRUE) == (int)KE_CSI && c == KS_EXTRA)\n\t\t\t    buf[i] = CSI;\n\t\t    }\n\t\t}\n\t\t--no_mapping;\n\t\tc = (*mb_ptr2char)(buf);\n\t    }\n\n\t    break;\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * In the main loop \"may_garbage_collect\" can be set to do garbage\n     * collection in the first next vgetc().  It's disabled after that to\n     * avoid internally used Lists and Dicts to be freed.\n     */\n    may_garbage_collect = FALSE;\n#endif\n#ifdef FEAT_BEVAL_TERM\n    if (c != K_MOUSEMOVE && c != K_IGNORE)\n    {\n\t/* Don't trigger 'balloonexpr' unless only the mouse was moved. */\n\tbevalexpr_due_set = FALSE;\n\tui_remove_balloon();\n    }\n#endif\n\n    return c;\n}\n\n/*\n * Like vgetc(), but never return a NUL when called recursively, get a key\n * directly from the user (ignoring typeahead).\n */\n    int\nsafe_vgetc(void)\n{\n    int\tc;\n\n    c = vgetc();\n    if (c == NUL)\n\tc = get_keystroke();\n    return c;\n}\n\n/*\n * Like safe_vgetc(), but loop to handle K_IGNORE.\n * Also ignore scrollbar events.\n */\n    int\nplain_vgetc(void)\n{\n    int c;\n\n    do\n\tc = safe_vgetc();\n    while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\n    if (c == K_PS)\n\t/* Only handle the first pasted character.  Drop the rest, since we\n\t * don't know what to do with it. */\n\tc = bracketed_paste(PASTE_ONE_CHAR, FALSE, NULL);\n\n    return c;\n}\n\n/*\n * Check if a character is available, such that vgetc() will not block.\n * If the next character is a special character or multi-byte, the returned\n * character is not valid!.\n * Returns NUL if no character is available.\n */\n    int\nvpeekc(void)\n{\n    if (old_char != -1)\n\treturn old_char;\n    return vgetorpeek(FALSE);\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Like vpeekc(), but don't allow mapping.  Do allow checking for terminal\n * codes.\n */\n    int\nvpeekc_nomap(void)\n{\n    int\t\tc;\n\n    ++no_mapping;\n    ++allow_keys;\n    c = vpeekc();\n    --no_mapping;\n    --allow_keys;\n    return c;\n}\n#endif\n\n#if defined(FEAT_INS_EXPAND) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Check if any character is available, also half an escape sequence.\n * Trick: when no typeahead found, but there is something in the typeahead\n * buffer, it must be an ESC that is recognized as the start of a key code.\n */\n    int\nvpeekc_any(void)\n{\n    int\t\tc;\n\n    c = vpeekc();\n    if (c == NUL && typebuf.tb_len > 0)\n\tc = ESC;\n    return c;\n}\n#endif\n\n/*\n * Call vpeekc() without causing anything to be mapped.\n * Return TRUE if a character is available, FALSE otherwise.\n */\n    int\nchar_avail(void)\n{\n    int\t    retval;\n\n#ifdef FEAT_EVAL\n    /* When test_override(\"char_avail\", 1) was called pretend there is no\n     * typeahead. */\n    if (disable_char_avail_for_testing)\n\treturn FALSE;\n#endif\n    ++no_mapping;\n    retval = vpeekc();\n    --no_mapping;\n    return (retval != NUL);\n}\n\n/*\n * unget one character (can only be done once!)\n */\n    void\nvungetc(int c)\n{\n    old_char = c;\n    old_mod_mask = mod_mask;\n#ifdef FEAT_MOUSE\n    old_mouse_row = mouse_row;\n    old_mouse_col = mouse_col;\n#endif\n}\n\n/*\n * Get a byte:\n * 1. from the stuffbuffer\n *\tThis is used for abbreviated commands like \"D\" -> \"d$\".\n *\tAlso used to redo a command for \".\".\n * 2. from the typeahead buffer\n *\tStores text obtained previously but not used yet.\n *\tAlso stores the result of mappings.\n *\tAlso used for the \":normal\" command.\n * 3. from the user\n *\tThis may do a blocking wait if \"advance\" is TRUE.\n *\n * if \"advance\" is TRUE (vgetc()):\n *\tReally get the character.\n *\tKeyTyped is set to TRUE in the case the user typed the key.\n *\tKeyStuffed is TRUE if the character comes from the stuff buffer.\n * if \"advance\" is FALSE (vpeekc()):\n *\tJust look whether there is a character available.\n *\tReturn NUL if not.\n *\n * When \"no_mapping\" is zero, checks for mappings in the current mode.\n * Only returns one byte (of a multi-byte character).\n * K_SPECIAL and CSI may be escaped, need to get two more bytes then.\n */\n    static int\nvgetorpeek(int advance)\n{\n    int\t\tc, c1;\n    int\t\tkeylen;\n    char_u\t*s;\n    mapblock_T\t*mp;\n#ifdef FEAT_LOCALMAP\n    mapblock_T\t*mp2;\n#endif\n    mapblock_T\t*mp_match;\n    int\t\tmp_match_len = 0;\n    int\t\ttimedout = FALSE;\t    /* waited for more than 1 second\n\t\t\t\t\t\tfor mapping to complete */\n    int\t\tmapdepth = 0;\t    /* check for recursive mapping */\n    int\t\tmode_deleted = FALSE;   /* set when mode has been deleted */\n    int\t\tlocal_State;\n    int\t\tmlen;\n    int\t\tmax_mlen;\n    int\t\ti;\n#ifdef FEAT_CMDL_INFO\n    int\t\tnew_wcol, new_wrow;\n#endif\n#ifdef FEAT_GUI\n# ifdef FEAT_MENU\n    int\t\tidx;\n# endif\n    int\t\tshape_changed = FALSE;  /* adjusted cursor shape */\n#endif\n    int\t\tn;\n#ifdef FEAT_LANGMAP\n    int\t\tnolmaplen;\n#endif\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    local_State = get_real_state();\n\n    ++vgetc_busy;\n\n    if (advance)\n\tKeyStuffed = FALSE;\n\n    init_typebuf();\n    start_stuff();\n    if (advance && typebuf.tb_maplen == 0)\n\treg_executing = 0;\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t/* KeyTyped = FALSE;  When the command that stuffed something\n\t\t * was typed, behave like the stuffed command was typed.\n\t\t * needed for CTRL-W CTRL-] to open a fold, for example. */\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t/* no abbreviations now */\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\t    wait_time;\n\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t/* check for CTRL-C */\n\t\tkeylen = 0;\n\t\tif (got_int)\n\t\t{\n\t\t    /* flush all input */\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t\t      && (State & (INSERT + CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t/* Also record this character, it might be needed to\n\t\t\t * get out of Insert mode. */\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mappable key sequence.\n\t\t     * Walk through one maphash[] list until we find an\n\t\t     * entry that matches.\n\t\t     *\n\t\t     * Don't look for mappings if:\n\t\t     * - no_mapping set: mapping disabled (e.g. for CTRL-V)\n\t\t     * - maphash_valid not set: no mappings present.\n\t\t     * - typebuf.tb_buf[typebuf.tb_off] should not be remapped\n\t\t     * - in insert or cmdline mode and 'paste' option set\n\t\t     * - waiting for \"hit return to continue\" and CR or SPACE\n\t\t     *\t typed\n\t\t     * - waiting for a char with --more--\n\t\t     * - in Ctrl-X mode, and we get a valid char for that mode\n\t\t     */\n\t\t    mp = NULL;\n\t\t    max_mlen = 0;\n\t\t    c1 = typebuf.tb_buf[typebuf.tb_off];\n\t\t    if (no_mapping == 0 && maphash_valid\n\t\t\t    && (no_zero_mapping == 0 || c1 != '0')\n\t\t\t    && (typebuf.tb_maplen == 0\n\t\t\t\t|| (p_remap\n\t\t\t\t    && (typebuf.tb_noremap[typebuf.tb_off]\n\t\t\t\t\t\t    & (RM_NONE|RM_ABBR)) == 0))\n\t\t\t    && !(p_paste && (State & (INSERT + CMDLINE)))\n\t\t\t    && !(State == HITRETURN && (c1 == CAR || c1 == ' '))\n\t\t\t    && State != ASKMORE\n\t\t\t    && State != CONFIRM\n#ifdef FEAT_INS_EXPAND\n\t\t\t    && !((ctrl_x_mode_not_default()\n\t\t\t\t\t\t      && vim_is_ctrl_x_key(c1))\n\t\t\t\t    || ((compl_cont_status & CONT_LOCAL)\n\t\t\t\t\t&& (c1 == Ctrl_N || c1 == Ctrl_P)))\n#endif\n\t\t\t    )\n\t\t    {\n#ifdef FEAT_LANGMAP\n\t\t\tif (c1 == K_SPECIAL)\n\t\t\t    nolmaplen = 2;\n\t\t\telse\n\t\t\t{\n\t\t\t    LANGMAP_ADJUST(c1,\n\t\t\t\t\t   (State & (CMDLINE | INSERT)) == 0\n\t\t\t\t\t   && get_real_state() != SELECTMODE);\n\t\t\t    nolmaplen = 0;\n\t\t\t}\n#endif\n#ifdef FEAT_LOCALMAP\n\t\t\t/* First try buffer-local mappings. */\n\t\t\tmp = curbuf->b_maphash[MAP_HASH(local_State, c1)];\n\t\t\tmp2 = maphash[MAP_HASH(local_State, c1)];\n\t\t\tif (mp == NULL)\n\t\t\t{\n\t\t\t    /* There are no buffer-local mappings. */\n\t\t\t    mp = mp2;\n\t\t\t    mp2 = NULL;\n\t\t\t}\n#else\n\t\t\tmp = maphash[MAP_HASH(local_State, c1)];\n#endif\n\t\t\t/*\n\t\t\t * Loop until a partly matching mapping is found or\n\t\t\t * all (local) mappings have been checked.\n\t\t\t * The longest full match is remembered in \"mp_match\".\n\t\t\t * A full match is only accepted if there is no partly\n\t\t\t * match, so \"aa\" and \"aaa\" can both be mapped.\n\t\t\t */\n\t\t\tmp_match = NULL;\n\t\t\tmp_match_len = 0;\n\t\t\tfor ( ; mp != NULL;\n#ifdef FEAT_LOCALMAP\n\t\t\t\tmp->m_next == NULL ? (mp = mp2, mp2 = NULL) :\n#endif\n\t\t\t\t(mp = mp->m_next))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Only consider an entry if the first character\n\t\t\t     * matches and it is for the current state.\n\t\t\t     * Skip \":lmap\" mappings if keys were mapped.\n\t\t\t     */\n\t\t\t    if (mp->m_keys[0] == c1\n\t\t\t\t    && (mp->m_mode & local_State)\n\t\t\t\t    && ((mp->m_mode & LANGMAP) == 0\n\t\t\t\t\t|| typebuf.tb_maplen == 0))\n\t\t\t    {\n#ifdef FEAT_LANGMAP\n\t\t\t\tint\tnomap = nolmaplen;\n\t\t\t\tint\tc2;\n#endif\n\t\t\t\t/* find the match length of this mapping */\n\t\t\t\tfor (mlen = 1; mlen < typebuf.tb_len; ++mlen)\n\t\t\t\t{\n#ifdef FEAT_LANGMAP\n\t\t\t\t    c2 = typebuf.tb_buf[typebuf.tb_off + mlen];\n\t\t\t\t    if (nomap > 0)\n\t\t\t\t\t--nomap;\n\t\t\t\t    else if (c2 == K_SPECIAL)\n\t\t\t\t\tnomap = 2;\n\t\t\t\t    else\n\t\t\t\t\tLANGMAP_ADJUST(c2, TRUE);\n\t\t\t\t    if (mp->m_keys[mlen] != c2)\n#else\n\t\t\t\t    if (mp->m_keys[mlen] !=\n\t\t\t\t\ttypebuf.tb_buf[typebuf.tb_off + mlen])\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Don't allow mapping the first byte(s) of a\n\t\t\t\t * multi-byte char.  Happens when mapping\n\t\t\t\t * <M-a> and then changing 'encoding'. Beware\n\t\t\t\t * that 0x80 is escaped. */\n\t\t\t\t{\n\t\t\t\t    char_u *p1 = mp->m_keys;\n\t\t\t\t    char_u *p2 = mb_unescape(&p1);\n\n\t\t\t\t    if (has_mbyte && p2 != NULL\n\t\t\t\t\t  && MB_BYTE2LEN(c1) > MB_PTR2LEN(p2))\n\t\t\t\t\tmlen = 0;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Check an entry whether it matches.\n\t\t\t\t * - Full match: mlen == keylen\n\t\t\t\t * - Partly match: mlen == typebuf.tb_len\n\t\t\t\t */\n\t\t\t\tkeylen = mp->m_keylen;\n\t\t\t\tif (mlen == keylen\n\t\t\t\t     || (mlen == typebuf.tb_len\n\t\t\t\t\t\t  && typebuf.tb_len < keylen))\n\t\t\t\t{\n\t\t\t\t    /*\n\t\t\t\t     * If only script-local mappings are\n\t\t\t\t     * allowed, check if the mapping starts\n\t\t\t\t     * with K_SNR.\n\t\t\t\t     */\n\t\t\t\t    s = typebuf.tb_noremap + typebuf.tb_off;\n\t\t\t\t    if (*s == RM_SCRIPT\n\t\t\t\t\t    && (mp->m_keys[0] != K_SPECIAL\n\t\t\t\t\t\t|| mp->m_keys[1] != KS_EXTRA\n\t\t\t\t\t\t|| mp->m_keys[2]\n\t\t\t\t\t\t\t      != (int)KE_SNR))\n\t\t\t\t\tcontinue;\n\t\t\t\t    /*\n\t\t\t\t     * If one of the typed keys cannot be\n\t\t\t\t     * remapped, skip the entry.\n\t\t\t\t     */\n\t\t\t\t    for (n = mlen; --n >= 0; )\n\t\t\t\t\tif (*s++ & (RM_NONE|RM_ABBR))\n\t\t\t\t\t    break;\n\t\t\t\t    if (n >= 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t    if (keylen > typebuf.tb_len)\n\t\t\t\t    {\n\t\t\t\t\tif (!timedout && !(mp_match != NULL\n\t\t\t\t\t\t       && mp_match->m_nowait))\n\t\t\t\t\t{\n\t\t\t\t\t    /* break at a partly match */\n\t\t\t\t\t    keylen = KEYLEN_PART_MAP;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else if (keylen > mp_match_len)\n\t\t\t\t    {\n\t\t\t\t\t/* found a longer match */\n\t\t\t\t\tmp_match = mp;\n\t\t\t\t\tmp_match_len = keylen;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    /* No match; may have to check for\n\t\t\t\t     * termcode at next character. */\n\t\t\t\t    if (max_mlen < mlen)\n\t\t\t\t\tmax_mlen = mlen;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t/* If no partly match found, use the longest full\n\t\t\t * match. */\n\t\t\tif (keylen != KEYLEN_PART_MAP)\n\t\t\t{\n\t\t\t    mp = mp_match;\n\t\t\t    keylen = mp_match_len;\n\t\t\t}\n\t\t    }\n\n\t\t    /* Check for match with 'pastetoggle' */\n\t\t    if (*p_pt != NUL && mp == NULL && (State & (INSERT|NORMAL)))\n\t\t    {\n\t\t\tfor (mlen = 0; mlen < typebuf.tb_len && p_pt[mlen];\n\t\t\t\t\t\t\t\t       ++mlen)\n\t\t\t    if (p_pt[mlen] != typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t\t\t      + mlen])\n\t\t\t\t    break;\n\t\t\tif (p_pt[mlen] == NUL)\t/* match */\n\t\t\t{\n\t\t\t    /* write chars to script file(s) */\n\t\t\t    if (mlen > typebuf.tb_maplen)\n\t\t\t\tgotchars(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t\t  + typebuf.tb_maplen,\n\t\t\t\t\t\t    mlen - typebuf.tb_maplen);\n\n\t\t\t    del_typebuf(mlen, 0); /* remove the chars */\n\t\t\t    set_option_value((char_u *)\"paste\",\n\t\t\t\t\t\t     (long)!p_paste, NULL, 0);\n\t\t\t    if (!(State & INSERT))\n\t\t\t    {\n\t\t\t\tmsg_col = 0;\n\t\t\t\tmsg_row = Rows - 1;\n\t\t\t\tmsg_clr_eos();\t\t/* clear ruler */\n\t\t\t    }\n\t\t\t    status_redraw_all();\n\t\t\t    redraw_statuslines();\n\t\t\t    showmode();\n\t\t\t    setcursor();\n\t\t\t    continue;\n\t\t\t}\n\t\t\t/* Need more chars for partly match. */\n\t\t\tif (mlen == typebuf.tb_len)\n\t\t\t    keylen = KEYLEN_PART_KEY;\n\t\t\telse if (max_mlen < mlen)\n\t\t\t    /* no match, may have to check for termcode at\n\t\t\t     * next character */\n\t\t\t    max_mlen = mlen + 1;\n\t\t    }\n\n\t\t    if ((mp == NULL || max_mlen >= mp_match_len)\n\t\t\t\t\t\t && keylen != KEYLEN_PART_MAP)\n\t\t    {\n\t\t\tint\tsave_keylen = keylen;\n\n\t\t\t/*\n\t\t\t * When no matching mapping found or found a\n\t\t\t * non-matching mapping that matches at least what the\n\t\t\t * matching mapping matched:\n\t\t\t * Check if we have a terminal code, when:\n\t\t\t *  mapping is allowed,\n\t\t\t *  keys have not been mapped,\n\t\t\t *  and not an ESC sequence, not in insert mode or\n\t\t\t *\tp_ek is on,\n\t\t\t *  and when not timed out,\n\t\t\t */\n\t\t\tif ((no_mapping == 0 || allow_keys != 0)\n\t\t\t\t&& (typebuf.tb_maplen == 0\n\t\t\t\t    || (p_remap && typebuf.tb_noremap[\n\t\t\t\t\t\t   typebuf.tb_off] == RM_YES))\n\t\t\t\t&& !timedout)\n\t\t\t{\n\t\t\t    keylen = check_termcode(max_mlen + 1,\n\t\t\t\t\t\t\t       NULL, 0, NULL);\n\n\t\t\t    /* If no termcode matched but 'pastetoggle'\n\t\t\t     * matched partially it's like an incomplete key\n\t\t\t     * sequence. */\n\t\t\t    if (keylen == 0 && save_keylen == KEYLEN_PART_KEY)\n\t\t\t\tkeylen = KEYLEN_PART_KEY;\n\n\t\t\t    /*\n\t\t\t     * When getting a partial match, but the last\n\t\t\t     * characters were not typed, don't wait for a\n\t\t\t     * typed character to complete the termcode.\n\t\t\t     * This helps a lot when a \":normal\" command ends\n\t\t\t     * in an ESC.\n\t\t\t     */\n\t\t\t    if (keylen < 0\n\t\t\t\t       && typebuf.tb_len == typebuf.tb_maplen)\n\t\t\t\tkeylen = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    keylen = 0;\n\t\t\tif (keylen == 0)\t/* no matching terminal code */\n\t\t\t{\n#ifdef AMIGA\t\t\t/* check for window bounds report */\n\t\t\t    if (typebuf.tb_maplen == 0 && (typebuf.tb_buf[\n\t\t\t\t\t       typebuf.tb_off] & 0xff) == CSI)\n\t\t\t    {\n\t\t\t\tfor (s = typebuf.tb_buf + typebuf.tb_off + 1;\n\t\t\t\t\ts < typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t\t      + typebuf.tb_len\n\t\t\t\t   && (VIM_ISDIGIT(*s) || *s == ';'\n\t\t\t\t\t\t\t\t|| *s == ' ');\n\t\t\t\t\t++s)\n\t\t\t\t    ;\n\t\t\t\tif (*s == 'r' || *s == '|') /* found one */\n\t\t\t\t{\n\t\t\t\t    del_typebuf((int)(s + 1 -\n\t\t\t\t       (typebuf.tb_buf + typebuf.tb_off)), 0);\n\t\t\t\t    /* get size and redraw screen */\n\t\t\t\t    shell_resized();\n\t\t\t\t    continue;\n\t\t\t\t}\n\t\t\t\tif (*s == NUL)\t    /* need more characters */\n\t\t\t\t    keylen = KEYLEN_PART_KEY;\n\t\t\t    }\n\t\t\t    if (keylen >= 0)\n#endif\n\t\t\t      /* When there was a matching mapping and no\n\t\t\t       * termcode could be replaced after another one,\n\t\t\t       * use that mapping (loop around). If there was\n\t\t\t       * no mapping use the character from the\n\t\t\t       * typeahead buffer right here. */\n\t\t\t      if (mp == NULL)\n\t\t\t      {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\t\tc = typebuf.tb_buf[typebuf.tb_off] & 255;\n\t\t\t\tif (advance)\t/* remove chars from tb_buf */\n\t\t\t\t{\n\t\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\t\tKeyTyped = FALSE;\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t\t/* write char to script file(s) */\n\t\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t\t    }\n\t\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t\t    del_typebuf(1, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\t    /* got character, break for loop */\n\t\t\t      }\n\t\t\t}\n\t\t\tif (keylen > 0)\t    /* full matching terminal code */\n\t\t\t{\n#if defined(FEAT_GUI) && defined(FEAT_MENU)\n\t\t\t    if (typebuf.tb_len >= 2\n\t\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL\n\t\t\t\t\t && typebuf.tb_buf[typebuf.tb_off + 1]\n\t\t\t\t\t\t\t\t   == KS_MENU)\n\t\t\t    {\n\t\t\t\t/*\n\t\t\t\t * Using a menu may cause a break in undo!\n\t\t\t\t * It's like using gotchars(), but without\n\t\t\t\t * recording or writing to a script file.\n\t\t\t\t */\n\t\t\t\tmay_sync_undo();\n\t\t\t\tdel_typebuf(3, 0);\n\t\t\t\tidx = get_menu_index(current_menu, local_State);\n\t\t\t\tif (idx != MENU_INDEX_INVALID)\n\t\t\t\t{\n\t\t\t\t    /*\n\t\t\t\t     * In Select mode and a Visual mode menu\n\t\t\t\t     * is used:  Switch to Visual mode\n\t\t\t\t     * temporarily.  Append K_SELECT to switch\n\t\t\t\t     * back to Select mode.\n\t\t\t\t     */\n\t\t\t\t    if (VIsual_active && VIsual_select\n\t\t\t\t\t    && (current_menu->modes & VISUAL))\n\t\t\t\t    {\n\t\t\t\t\tVIsual_select = FALSE;\n\t\t\t\t\t(void)ins_typebuf(K_SELECT_STRING,\n\t\t\t\t\t\t  REMAP_NONE, 0, TRUE, FALSE);\n\t\t\t\t    }\n\t\t\t\t    ins_typebuf(current_menu->strings[idx],\n\t\t\t\t\t\tcurrent_menu->noremap[idx],\n\t\t\t\t\t\t0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t\t\t\t}\n\t\t\t    }\n#endif /* FEAT_GUI && FEAT_MENU */\n\t\t\t    continue;\t/* try mapping again */\n\t\t\t}\n\n\t\t\t/* Partial match: get some more characters.  When a\n\t\t\t * matching mapping was found use that one. */\n\t\t\tif (mp == NULL || keylen < 0)\n\t\t\t    keylen = KEYLEN_PART_KEY;\n\t\t\telse\n\t\t\t    keylen = mp_match_len;\n\t\t    }\n\n\t\t    /* complete match */\n\t\t    if (keylen >= 0 && keylen <= typebuf.tb_len)\n\t\t    {\n#ifdef FEAT_EVAL\n\t\t\tint save_m_expr;\n\t\t\tint save_m_noremap;\n\t\t\tint save_m_silent;\n\t\t\tchar_u *save_m_keys;\n\t\t\tchar_u *save_m_str;\n#else\n# define save_m_noremap mp->m_noremap\n# define save_m_silent mp->m_silent\n#endif\n\n\t\t\t/* write chars to script file(s) */\n\t\t\tif (keylen > typebuf.tb_maplen)\n\t\t\t    gotchars(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t\t  + typebuf.tb_maplen,\n\t\t\t\t\t\t  keylen - typebuf.tb_maplen);\n\n\t\t\tcmd_silent = (typebuf.tb_silent > 0);\n\t\t\tdel_typebuf(keylen, 0);\t/* remove the mapped keys */\n\n\t\t\t/*\n\t\t\t * Put the replacement string in front of mapstr.\n\t\t\t * The depth check catches \":map x y\" and \":map y x\".\n\t\t\t */\n\t\t\tif (++mapdepth >= p_mmd)\n\t\t\t{\n\t\t\t    emsg(_(\"E223: recursive mapping\"));\n\t\t\t    if (State & CMDLINE)\n\t\t\t\tredrawcmdline();\n\t\t\t    else\n\t\t\t\tsetcursor();\n\t\t\t    flush_buffers(FLUSH_MINIMAL);\n\t\t\t    mapdepth = 0;\t/* for next one */\n\t\t\t    c = -1;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In Select mode and a Visual mode mapping is used:\n\t\t\t * Switch to Visual mode temporarily.  Append K_SELECT\n\t\t\t * to switch back to Select mode.\n\t\t\t */\n\t\t\tif (VIsual_active && VIsual_select\n\t\t\t\t\t\t     && (mp->m_mode & VISUAL))\n\t\t\t{\n\t\t\t    VIsual_select = FALSE;\n\t\t\t    (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,\n\t\t\t\t\t\t\t      0, TRUE, FALSE);\n\t\t\t}\n\n#ifdef FEAT_EVAL\n\t\t\t/* Copy the values from *mp that are used, because\n\t\t\t * evaluating the expression may invoke a function\n\t\t\t * that redefines the mapping, thereby making *mp\n\t\t\t * invalid. */\n\t\t\tsave_m_expr = mp->m_expr;\n\t\t\tsave_m_noremap = mp->m_noremap;\n\t\t\tsave_m_silent = mp->m_silent;\n\t\t\tsave_m_keys = NULL;  /* only saved when needed */\n\t\t\tsave_m_str = NULL;  /* only saved when needed */\n\n\t\t\t/*\n\t\t\t * Handle \":map <expr>\": evaluate the {rhs} as an\n\t\t\t * expression.  Also save and restore the command line\n\t\t\t * for \"normal :\".\n\t\t\t */\n\t\t\tif (mp->m_expr)\n\t\t\t{\n\t\t\t    int\t\tsave_vgetc_busy = vgetc_busy;\n\n\t\t\t    vgetc_busy = 0;\n\t\t\t    save_m_keys = vim_strsave(mp->m_keys);\n\t\t\t    save_m_str = vim_strsave(mp->m_str);\n\t\t\t    s = eval_map_expr(save_m_str, NUL);\n\t\t\t    vgetc_busy = save_vgetc_busy;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    s = mp->m_str;\n\n\t\t\t/*\n\t\t\t * Insert the 'to' part in the typebuf.tb_buf.\n\t\t\t * If 'from' field is the same as the start of the\n\t\t\t * 'to' field, don't remap the first character (but do\n\t\t\t * allow abbreviations).\n\t\t\t * If m_noremap is set, don't remap the whole 'to'\n\t\t\t * part.\n\t\t\t */\n\t\t\tif (s == NULL)\n\t\t\t    i = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    int noremap;\n\n\t\t\t    if (save_m_noremap != REMAP_YES)\n\t\t\t\tnoremap = save_m_noremap;\n\t\t\t    else if (\n#ifdef FEAT_EVAL\n\t\t\t\tSTRNCMP(s, save_m_keys != NULL\n\t\t\t\t\t\t   ? save_m_keys : mp->m_keys,\n\t\t\t\t\t\t\t (size_t)keylen)\n#else\n\t\t\t\tSTRNCMP(s, mp->m_keys, (size_t)keylen)\n#endif\n\t\t\t\t   != 0)\n\t\t\t\tnoremap = REMAP_YES;\n\t\t\t    else\n\t\t\t\tnoremap = REMAP_SKIP;\n\t\t\t    i = ins_typebuf(s, noremap,\n\t\t\t\t\t0, TRUE, cmd_silent || save_m_silent);\n#ifdef FEAT_EVAL\n\t\t\t    if (save_m_expr)\n\t\t\t\tvim_free(s);\n#endif\n\t\t\t}\n#ifdef FEAT_EVAL\n\t\t\tvim_free(save_m_keys);\n\t\t\tvim_free(save_m_str);\n#endif\n\t\t\tif (i == FAIL)\n\t\t\t{\n\t\t\t    c = -1;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t */\n\t\tc = 0;\n#ifdef FEAT_CMDL_INFO\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n#endif\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0, vcol;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    /* may show a different cursor shape */\n\t\t    if (gui.in_use && State != NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    /* move cursor left, if possible */\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    if (did_ai)\n\t\t\t    {\n\t\t\t\t/*\n\t\t\t\t * We are expecting to truncate the trailing\n\t\t\t\t * white-space, so find the last non-white\n\t\t\t\t * character -- webb\n\t\t\t\t */\n\t\t\t\tcol = vcol = curwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\twhile (col < curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(ptr[col]))\n\t\t\t\t\tcurwin->w_wcol = vcol;\n\t\t\t\t    vcol += lbr_chartabsize(ptr, ptr + col,\n\t\t\t\t\t\t\t       (colnr_T)vcol);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcol += (*mb_ptr2len)(ptr + col);\n\t\t\t\t    else\n\t\t\t\t\t++col;\n\t\t\t\t}\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t/* no correction needed */\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    /* Correct when the cursor is on the right halve\n\t\t\t     * of a double-wide character. */\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n#ifdef FEAT_CMDL_INFO\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n#endif\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t/* end of input script reached */\n\n\t\t/* Allow mapping for just typed characters. When we get here c\n\t\t * is the number of extra bytes and typebuf.tb_len is 1. */\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t/* buffer full, don't map */\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n#ifdef FEAT_CMDWIN\n\t\t    static int tc = 0;\n#endif\n\n\t\t    /* No typeahead left and inside \":normal\".  Must return\n\t\t     * something to avoid getting stuck.  When an incomplete\n\t\t     * mapping is present, behave like it timed out. */\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t    /* When 'insertmode' is set, ESC just beeps in Insert\n\t\t     * mode.  Use CTRL-L to make edit() return.\n\t\t     * For the command line only CTRL-C always breaks it.\n\t\t     * For the cmdline window: Alternate between ESC and\n\t\t     * CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t     * cmdline window. */\n\t\t    if (p_im && (State & INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & CMDLINE)\n#ifdef FEAT_CMDWIN\n\t\t\t    || (cmdwin_type > 0 && tc == ESC)\n#endif\n\t\t\t    )\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n#ifdef FEAT_CMDWIN\n\t\t    tc = c;\n#endif\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t/* In insert mode a screen update is skipped when characters\n\t\t * are still available.  But when those available characters\n\t\t * are part of a mapping, and we are going to do a blocking\n\t\t * wait here.  Need to update the screen to display the\n\t\t * changed text so far. Also for when 'lazyredraw' is set and\n\t\t * redrawing was postponed because there was something in the\n\t\t * input buffer (e.g., termresponse). */\n\t\tif (((State & INSERT) != 0 || p_lz) && (State & CMDLINE) == 0\n\t\t\t  && advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); /* put cursor back where it belongs */\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n#ifdef FEAT_CMDL_INFO\n\t\ti = 0;\n#endif\n\t\tc1 = 0;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (NORMAL | INSERT)) || State == LANGMAP)\n\t\t\t    && State != HITRETURN)\n\t\t    {\n\t\t\t/* this looks nice when typing a dead character map */\n\t\t\tif (State & INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); /* put cursor back where it belongs */\n\t\t\t    c1 = 1;\n\t\t\t}\n#ifdef FEAT_CMDL_INFO\n\t\t\t/* need to use the col and row from above here */\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    i = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (i < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t\t\t      + i++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n#endif\n\t\t    }\n\n\t\t    /* this looks nice when typing a dead character map */\n\t\t    if ((State & CMDLINE)\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tc1 = 1;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set while waiting for a mapping\n\t\t    // that has a <Nop> RHS.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n#ifdef FEAT_CMDL_INFO\n\t\tif (i != 0)\n\t\t    pop_showcmd();\n#endif\n\t\tif (c1 == 1)\n\t\t{\n\t\t    if (State & INSERT)\n\t\t\tedit_unputchar();\n\t\t    if (State & CMDLINE)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t/* put cursor back where it belongs */\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t/* end of input script reached */\n\t\tif (c == NUL)\t\t/* no character available */\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t/* timed out */\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    /* allow mapping for just typed characters */\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    /* Get IM status right after getting keys, not after the\n\t\t     * timeout for a mapping (focus may be lost by then). */\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    /* for (;;) */\n\t}\t/* if (!character from stuffbuf) */\n\n\t/* if advance is FALSE don't loop on NULs */\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    /* delete mode later */\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    /* show mode later */\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    /* may unshow different cursor shape */\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}\n\n/*\n * inchar() - get one character from\n *\t1. a scriptfile\n *\t2. the keyboard\n *\n *  As much characters as we can get (upto 'maxlen') are put in \"buf\" and\n *  NUL terminated (buffer length must be 'maxlen' + 1).\n *  Minimum for \"maxlen\" is 3!!!!\n *\n *  \"tb_change_cnt\" is the value of typebuf.tb_change_cnt if \"buf\" points into\n *  it.  When typebuf.tb_change_cnt changes (e.g., when a message is received\n *  from a remote client) \"buf\" can no longer be used.  \"tb_change_cnt\" is 0\n *  otherwise.\n *\n *  If we got an interrupt all input is read until none is available.\n *\n *  If wait_time == 0  there is no waiting for the char.\n *  If wait_time == n  we wait for n msec for a character to arrive.\n *  If wait_time == -1 we wait forever for a character to arrive.\n *\n *  Return the number of obtained characters.\n *  Return -1 when end of input script reached.\n */\n    static int\ninchar(\n    char_u\t*buf,\n    int\t\tmaxlen,\n    long\twait_time)\t    /* milli seconds */\n{\n    int\t\tlen = 0;\t    /* init for GCC */\n    int\t\tretesc = FALSE;\t    /* return ESC with gotint */\n    int\t\tscript_char;\n    int\t\ttb_change_cnt = typebuf.tb_change_cnt;\n\n    if (wait_time == -1L || wait_time > 100L)  /* flush output before waiting */\n    {\n\tcursor_on();\n\tout_flush_cursor(FALSE, FALSE);\n#if defined(FEAT_GUI) && defined(FEAT_MOUSESHAPE)\n\tif (gui.in_use && postponed_mouseshape)\n\t    update_mouseshape(-1);\n#endif\n    }\n\n    /*\n     * Don't reset these when at the hit-return prompt, otherwise a endless\n     * recursive loop may result (write error in swapfile, hit-return, timeout\n     * on char wait, flush swapfile, write error....).\n     */\n    if (State != HITRETURN)\n    {\n\tdid_outofmem_msg = FALSE;   /* display out of memory message (again) */\n\tdid_swapwrite_msg = FALSE;  /* display swap file write error again */\n    }\n    undo_off = FALSE;\t\t    /* restart undo now */\n\n    /*\n     * Get a character from a script file if there is one.\n     * If interrupted: Stop reading script files, close them all.\n     */\n    script_char = -1;\n    while (scriptin[curscript] != NULL && script_char < 0\n#ifdef FEAT_EVAL\n\t    && !ignore_script\n#endif\n\t    )\n    {\n\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n\n\tif (got_int || (script_char = getc(scriptin[curscript])) < 0)\n\t{\n\t    /* Reached EOF.\n\t     * Careful: closescript() frees typebuf.tb_buf[] and buf[] may\n\t     * point inside typebuf.tb_buf[].  Don't use buf[] after this! */\n\t    closescript();\n\t    /*\n\t     * When reading script file is interrupted, return an ESC to get\n\t     * back to normal mode.\n\t     * Otherwise return -1, because typebuf.tb_buf[] has changed.\n\t     */\n\t    if (got_int)\n\t\tretesc = TRUE;\n\t    else\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    buf[0] = script_char;\n\t    len = 1;\n\t}\n    }\n\n    if (script_char < 0)\t/* did not get a character from script */\n    {\n\t/*\n\t * If we got an interrupt, skip all previously typed characters and\n\t * return TRUE if quit reading script file.\n\t * Stop reading typeahead when a single CTRL-C was read,\n\t * fill_input_buf() returns this when not able to read from stdin.\n\t * Don't use buf[] here, closescript() may have freed typebuf.tb_buf[]\n\t * and buf may be pointing inside typebuf.tb_buf[].\n\t */\n\tif (got_int)\n\t{\n#define DUM_LEN MAXMAPLEN * 3 + 3\n\t    char_u\tdum[DUM_LEN + 1];\n\n\t    for (;;)\n\t    {\n\t\tlen = ui_inchar(dum, DUM_LEN, 0L, 0);\n\t\tif (len == 0 || (len == 1 && dum[0] == 3))\n\t\t    break;\n\t    }\n\t    return retesc;\n\t}\n\n\t/*\n\t * Always flush the output characters when getting input characters\n\t * from the user and not just peeking.\n\t */\n\tif (wait_time == -1L || wait_time > 10L)\n\t    out_flush();\n\n\t/*\n\t * Fill up to a third of the buffer, because each character may be\n\t * tripled below.\n\t */\n\tlen = ui_inchar(buf, maxlen / 3, wait_time, tb_change_cnt);\n    }\n\n    /* If the typebuf was changed further down, it is like nothing was added by\n     * this call. */\n    if (typebuf_changed(tb_change_cnt))\n\treturn 0;\n\n    /* Note the change in the typeahead buffer, this matters for when\n     * vgetorpeek() is called recursively, e.g. using getchar(1) in a timer\n     * function. */\n    if (len > 0 && ++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n\n    return fix_input_buffer(buf, len);\n}\n\n/*\n * Fix typed characters for use by vgetc() and check_termcode().\n * \"buf[]\" must have room to triple the number of bytes!\n * Returns the new length.\n */\n    int\nfix_input_buffer(char_u *buf, int len)\n{\n    int\t\ti;\n    char_u\t*p = buf;\n\n    /*\n     * Two characters are special: NUL and K_SPECIAL.\n     * When compiled With the GUI CSI is also special.\n     * Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER\n     * Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER\n     * Replace       CSI by K_SPECIAL KS_EXTRA   KE_CSI\n     */\n    for (i = len; --i >= 0; ++p)\n    {\n#ifdef FEAT_GUI\n\t/* When the GUI is used any character can come after a CSI, don't\n\t * escape it. */\n\tif (gui.in_use && p[0] == CSI && i >= 2)\n\t{\n\t    p += 2;\n\t    i -= 2;\n\t}\n# ifndef MSWIN\n\t/* When the GUI is not used CSI needs to be escaped. */\n\telse if (!gui.in_use && p[0] == CSI)\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    *p++ = K_SPECIAL;\n\t    *p++ = KS_EXTRA;\n\t    *p = (int)KE_CSI;\n\t    len += 2;\n\t}\n# endif\n\telse\n#endif\n\tif (p[0] == NUL || (p[0] == K_SPECIAL\n\t\t    // timeout may generate K_CURSORHOLD\n\t\t    && (i < 2 || p[1] != KS_EXTRA || p[2] != (int)KE_CURSORHOLD)\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t\t    // Win32 console passes modifiers\n\t\t    && (\n# ifdef VIMDLL\n\t\t\tgui.in_use ||\n# endif\n\t\t\t(i < 2 || p[1] != KS_MODIFIER))\n#endif\n\t\t    ))\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    p[2] = K_THIRD(p[0]);\n\t    p[1] = K_SECOND(p[0]);\n\t    p[0] = K_SPECIAL;\n\t    p += 2;\n\t    len += 2;\n\t}\n    }\n    *p = NUL;\t\t// add trailing NUL\n    return len;\n}\n\n#if defined(USE_INPUT_BUF) || defined(PROTO)\n/*\n * Return TRUE when bytes are in the input buffer or in the typeahead buffer.\n * Normally the input buffer would be sufficient, but the server_to_input_buf()\n * or feedkeys() may insert characters in the typeahead buffer while we are\n * waiting for input to arrive.\n */\n    int\ninput_available(void)\n{\n    return (!vim_is_input_buf_empty()\n# if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n# endif\n\t    );\n}\n#endif\n\n/*\n * map[!]\t\t    : show all key mappings\n * map[!] {lhs}\t\t    : show key mapping for {lhs}\n * map[!] {lhs} {rhs}\t    : set key mapping for {lhs} to {rhs}\n * noremap[!] {lhs} {rhs}   : same, but no remapping for {rhs}\n * unmap[!] {lhs}\t    : remove key mapping for {lhs}\n * abbr\t\t\t    : show all abbreviations\n * abbr {lhs}\t\t    : show abbreviations for {lhs}\n * abbr {lhs} {rhs}\t    : set abbreviation for {lhs} to {rhs}\n * noreabbr {lhs} {rhs}\t    : same, but no remapping for {rhs}\n * unabbr {lhs}\t\t    : remove abbreviation for {lhs}\n *\n * maptype: 0 for :map, 1 for :unmap, 2 for noremap.\n *\n * arg is pointer to any arguments. Note: arg cannot be a read-only string,\n * it will be modified.\n *\n * for :map   mode is NORMAL + VISUAL + SELECTMODE + OP_PENDING\n * for :map!  mode is INSERT + CMDLINE\n * for :cmap  mode is CMDLINE\n * for :imap  mode is INSERT\n * for :lmap  mode is LANGMAP\n * for :nmap  mode is NORMAL\n * for :vmap  mode is VISUAL + SELECTMODE\n * for :xmap  mode is VISUAL\n * for :smap  mode is SELECTMODE\n * for :omap  mode is OP_PENDING\n * for :tmap  mode is TERMINAL\n *\n * for :abbr  mode is INSERT + CMDLINE\n * for :iabbr mode is INSERT\n * for :cabbr mode is CMDLINE\n *\n * Return 0 for success\n *\t  1 for invalid arguments\n *\t  2 for no match\n *\t  4 for out of mem\n *\t  5 for entry not unique\n */\n    int\ndo_map(\n    int\t\tmaptype,\n    char_u\t*arg,\n    int\t\tmode,\n    int\t\tabbrev)\t\t/* not a mapping but an abbreviation */\n{\n    char_u\t*keys;\n    mapblock_T\t*mp, **mpp;\n    char_u\t*rhs;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tlen = 0;\t/* init for GCC */\n    char_u\t*newstr;\n    int\t\thasarg;\n    int\t\thaskey;\n    int\t\tdid_it = FALSE;\n#ifdef FEAT_LOCALMAP\n    int\t\tdid_local = FALSE;\n#endif\n    int\t\tround;\n    char_u\t*keys_buf = NULL;\n    char_u\t*arg_buf = NULL;\n    int\t\tretval = 0;\n    int\t\tdo_backslash;\n    int\t\thash;\n    int\t\tnew_hash;\n    mapblock_T\t**abbr_table;\n    mapblock_T\t**map_table;\n    int\t\tunique = FALSE;\n    int\t\tnowait = FALSE;\n    int\t\tsilent = FALSE;\n    int\t\tspecial = FALSE;\n#ifdef FEAT_EVAL\n    int\t\texpr = FALSE;\n#endif\n    int\t\tnoremap;\n    char_u      *orig_rhs;\n\n    keys = arg;\n    map_table = maphash;\n    abbr_table = &first_abbr;\n\n    /* For \":noremap\" don't remap, otherwise do remap. */\n    if (maptype == 2)\n\tnoremap = REMAP_NONE;\n    else\n\tnoremap = REMAP_YES;\n\n    /* Accept <buffer>, <nowait>, <silent>, <expr> <script> and <unique> in\n     * any order. */\n    for (;;)\n    {\n#ifdef FEAT_LOCALMAP\n\t/*\n\t * Check for \"<buffer>\": mapping local to buffer.\n\t */\n\tif (STRNCMP(keys, \"<buffer>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    map_table = curbuf->b_maphash;\n\t    abbr_table = &curbuf->b_first_abbr;\n\t    continue;\n\t}\n#endif\n\n\t/*\n\t * Check for \"<nowait>\": don't wait for more characters.\n\t */\n\tif (STRNCMP(keys, \"<nowait>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    nowait = TRUE;\n\t    continue;\n\t}\n\n\t/*\n\t * Check for \"<silent>\": don't echo commands.\n\t */\n\tif (STRNCMP(keys, \"<silent>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    silent = TRUE;\n\t    continue;\n\t}\n\n\t/*\n\t * Check for \"<special>\": accept special keys in <>\n\t */\n\tif (STRNCMP(keys, \"<special>\", 9) == 0)\n\t{\n\t    keys = skipwhite(keys + 9);\n\t    special = TRUE;\n\t    continue;\n\t}\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Check for \"<script>\": remap script-local mappings only\n\t */\n\tif (STRNCMP(keys, \"<script>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    noremap = REMAP_SCRIPT;\n\t    continue;\n\t}\n\n\t/*\n\t * Check for \"<expr>\": {rhs} is an expression.\n\t */\n\tif (STRNCMP(keys, \"<expr>\", 6) == 0)\n\t{\n\t    keys = skipwhite(keys + 6);\n\t    expr = TRUE;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Check for \"<unique>\": don't overwrite an existing mapping.\n\t */\n\tif (STRNCMP(keys, \"<unique>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    unique = TRUE;\n\t    continue;\n\t}\n\tbreak;\n    }\n\n    validate_maphash();\n\n    /*\n     * Find end of keys and skip CTRL-Vs (and backslashes) in it.\n     * Accept backslash like CTRL-V when 'cpoptions' does not contain 'B'.\n     * with :unmap white space is included in the keys, no argument possible.\n     */\n    p = keys;\n    do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);\n    while (*p && (maptype == 1 || !VIM_ISWHITE(*p)))\n    {\n\tif ((p[0] == Ctrl_V || (do_backslash && p[0] == '\\\\')) &&\n\t\t\t\t\t\t\t\t  p[1] != NUL)\n\t    ++p;\t\t/* skip CTRL-V or backslash */\n\t++p;\n    }\n    if (*p != NUL)\n\t*p++ = NUL;\n\n    p = skipwhite(p);\n    rhs = p;\n    hasarg = (*rhs != NUL);\n    haskey = (*keys != NUL);\n\n    /* check for :unmap without argument */\n    if (maptype == 1 && !haskey)\n    {\n\tretval = 1;\n\tgoto theend;\n    }\n\n    /*\n     * If mapping has been given as ^V<C_UP> say, then replace the term codes\n     * with the appropriate two bytes. If it is a shifted special key, unshift\n     * it too, giving another two bytes.\n     * replace_termcodes() may move the result to allocated memory, which\n     * needs to be freed later (*keys_buf and *arg_buf).\n     * replace_termcodes() also removes CTRL-Vs and sometimes backslashes.\n     */\n    if (haskey)\n\tkeys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, special);\n    orig_rhs = rhs;\n    if (hasarg)\n    {\n\tif (STRICMP(rhs, \"<nop>\") == 0)\t    /* \"<Nop>\" means nothing */\n\t    rhs = (char_u *)\"\";\n\telse\n\t    rhs = replace_termcodes(rhs, &arg_buf, FALSE, TRUE, special);\n    }\n\n    /*\n     * check arguments and translate function keys\n     */\n    if (haskey)\n    {\n\tlen = (int)STRLEN(keys);\n\tif (len > MAXMAPLEN)\t\t/* maximum length of MAXMAPLEN chars */\n\t{\n\t    retval = 1;\n\t    goto theend;\n\t}\n\n\tif (abbrev && maptype != 1)\n\t{\n\t    /*\n\t     * If an abbreviation ends in a keyword character, the\n\t     * rest must be all keyword-char or all non-keyword-char.\n\t     * Otherwise we won't be able to find the start of it in a\n\t     * vi-compatible way.\n\t     */\n\t    if (has_mbyte)\n\t    {\n\t\tint\tfirst, last;\n\t\tint\tsame = -1;\n\n\t\tfirst = vim_iswordp(keys);\n\t\tlast = first;\n\t\tp = keys + (*mb_ptr2len)(keys);\n\t\tn = 1;\n\t\twhile (p < keys + len)\n\t\t{\n\t\t    ++n;\t\t\t/* nr of (multi-byte) chars */\n\t\t    last = vim_iswordp(p);\t/* type of last char */\n\t\t    if (same == -1 && last != first)\n\t\t\tsame = n - 1;\t\t/* count of same char type */\n\t\t    p += (*mb_ptr2len)(p);\n\t\t}\n\t\tif (last && n > 2 && same >= 0 && same < n - 1)\n\t\t{\n\t\t    retval = 1;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (vim_iswordc(keys[len - 1]))  // ends in keyword char\n\t\t    for (n = 0; n < len - 2; ++n)\n\t\t\tif (vim_iswordc(keys[n]) != vim_iswordc(keys[len - 2]))\n\t\t\t{\n\t\t\t    retval = 1;\n\t\t\t    goto theend;\n\t\t\t}\n\t    /* An abbreviation cannot contain white space. */\n\t    for (n = 0; n < len; ++n)\n\t\tif (VIM_ISWHITE(keys[n]))\n\t\t{\n\t\t    retval = 1;\n\t\t    goto theend;\n\t\t}\n\t}\n    }\n\n    if (haskey && hasarg && abbrev)\t/* if we will add an abbreviation */\n\tno_abbr = FALSE;\t\t/* reset flag that indicates there are\n\t\t\t\t\t\t\t    no abbreviations */\n\n    if (!haskey || (maptype != 1 && !hasarg))\n\tmsg_start();\n\n#ifdef FEAT_LOCALMAP\n    /*\n     * Check if a new local mapping wasn't already defined globally.\n     */\n    if (map_table == curbuf->b_maphash && haskey && hasarg && maptype != 1)\n    {\n\t/* need to loop over all global hash lists */\n\tfor (hash = 0; hash < 256 && !got_int; ++hash)\n\t{\n\t    if (abbrev)\n\t    {\n\t\tif (hash != 0)\t/* there is only one abbreviation list */\n\t\t    break;\n\t\tmp = first_abbr;\n\t    }\n\t    else\n\t\tmp = maphash[hash];\n\t    for ( ; mp != NULL && !got_int; mp = mp->m_next)\n\t    {\n\t\t/* check entries with the same mode */\n\t\tif ((mp->m_mode & mode) != 0\n\t\t\t&& mp->m_keylen == len\n\t\t\t&& unique\n\t\t\t&& STRNCMP(mp->m_keys, keys, (size_t)len) == 0)\n\t\t{\n\t\t    if (abbrev)\n\t\t\tsemsg(_(\"E224: global abbreviation already exists for %s\"),\n\t\t\t\tmp->m_keys);\n\t\t    else\n\t\t\tsemsg(_(\"E225: global mapping already exists for %s\"),\n\t\t\t\tmp->m_keys);\n\t\t    retval = 5;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * When listing global mappings, also list buffer-local ones here.\n     */\n    if (map_table != curbuf->b_maphash && !hasarg && maptype != 1)\n    {\n\t/* need to loop over all global hash lists */\n\tfor (hash = 0; hash < 256 && !got_int; ++hash)\n\t{\n\t    if (abbrev)\n\t    {\n\t\tif (hash != 0)\t/* there is only one abbreviation list */\n\t\t    break;\n\t\tmp = curbuf->b_first_abbr;\n\t    }\n\t    else\n\t\tmp = curbuf->b_maphash[hash];\n\t    for ( ; mp != NULL && !got_int; mp = mp->m_next)\n\t    {\n\t\t/* check entries with the same mode */\n\t\tif ((mp->m_mode & mode) != 0)\n\t\t{\n\t\t    if (!haskey)\t\t    /* show all entries */\n\t\t    {\n\t\t\tshowmap(mp, TRUE);\n\t\t\tdid_local = TRUE;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tn = mp->m_keylen;\n\t\t\tif (STRNCMP(mp->m_keys, keys,\n\t\t\t\t\t    (size_t)(n < len ? n : len)) == 0)\n\t\t\t{\n\t\t\t    showmap(mp, TRUE);\n\t\t\t    did_local = TRUE;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    /*\n     * Find an entry in the maphash[] list that matches.\n     * For :unmap we may loop two times: once to try to unmap an entry with a\n     * matching 'from' part, a second time, if the first fails, to unmap an\n     * entry with a matching 'to' part. This was done to allow \":ab foo bar\"\n     * to be unmapped by typing \":unab foo\", where \"foo\" will be replaced by\n     * \"bar\" because of the abbreviation.\n     */\n    for (round = 0; (round == 0 || maptype == 1) && round <= 1\n\t\t\t\t\t      && !did_it && !got_int; ++round)\n    {\n\t/* need to loop over all hash lists */\n\tfor (hash = 0; hash < 256 && !got_int; ++hash)\n\t{\n\t    if (abbrev)\n\t    {\n\t\tif (hash > 0)\t/* there is only one abbreviation list */\n\t\t    break;\n\t\tmpp = abbr_table;\n\t    }\n\t    else\n\t\tmpp = &(map_table[hash]);\n\t    for (mp = *mpp; mp != NULL && !got_int; mp = *mpp)\n\t    {\n\n\t\tif (!(mp->m_mode & mode))   /* skip entries with wrong mode */\n\t\t{\n\t\t    mpp = &(mp->m_next);\n\t\t    continue;\n\t\t}\n\t\tif (!haskey)\t\t    /* show all entries */\n\t\t{\n\t\t    showmap(mp, map_table != maphash);\n\t\t    did_it = TRUE;\n\t\t}\n\t\telse\t\t\t    /* do we have a match? */\n\t\t{\n\t\t    if (round)\t    /* second round: Try unmap \"rhs\" string */\n\t\t    {\n\t\t\tn = (int)STRLEN(mp->m_str);\n\t\t\tp = mp->m_str;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tn = mp->m_keylen;\n\t\t\tp = mp->m_keys;\n\t\t    }\n\t\t    if (STRNCMP(p, keys, (size_t)(n < len ? n : len)) == 0)\n\t\t    {\n\t\t\tif (maptype == 1)\t/* delete entry */\n\t\t\t{\n\t\t\t    /* Only accept a full match.  For abbreviations we\n\t\t\t     * ignore trailing space when matching with the\n\t\t\t     * \"lhs\", since an abbreviation can't have\n\t\t\t     * trailing space. */\n\t\t\t    if (n != len && (!abbrev || round || n > len\n\t\t\t\t\t       || *skipwhite(keys + n) != NUL))\n\t\t\t    {\n\t\t\t\tmpp = &(mp->m_next);\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * We reset the indicated mode bits. If nothing is\n\t\t\t     * left the entry is deleted below.\n\t\t\t     */\n\t\t\t    mp->m_mode &= ~mode;\n\t\t\t    did_it = TRUE;\t/* remember we did something */\n\t\t\t}\n\t\t\telse if (!hasarg)\t/* show matching entry */\n\t\t\t{\n\t\t\t    showmap(mp, map_table != maphash);\n\t\t\t    did_it = TRUE;\n\t\t\t}\n\t\t\telse if (n != len)\t/* new entry is ambiguous */\n\t\t\t{\n\t\t\t    mpp = &(mp->m_next);\n\t\t\t    continue;\n\t\t\t}\n\t\t\telse if (unique)\n\t\t\t{\n\t\t\t    if (abbrev)\n\t\t\t\tsemsg(_(\"E226: abbreviation already exists for %s\"),\n\t\t\t\t\t\t\t\t\t   p);\n\t\t\t    else\n\t\t\t\tsemsg(_(\"E227: mapping already exists for %s\"), p);\n\t\t\t    retval = 5;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\t\t\t/* new rhs for existing entry */\n\t\t\t{\n\t\t\t    mp->m_mode &= ~mode;\t/* remove mode bits */\n\t\t\t    if (mp->m_mode == 0 && !did_it) /* reuse entry */\n\t\t\t    {\n\t\t\t\tnewstr = vim_strsave(rhs);\n\t\t\t\tif (newstr == NULL)\n\t\t\t\t{\n\t\t\t\t    retval = 4;\t\t/* no mem */\n\t\t\t\t    goto theend;\n\t\t\t\t}\n\t\t\t\tvim_free(mp->m_str);\n\t\t\t\tmp->m_str = newstr;\n\t\t\t\tvim_free(mp->m_orig_str);\n\t\t\t\tmp->m_orig_str = vim_strsave(orig_rhs);\n\t\t\t\tmp->m_noremap = noremap;\n\t\t\t\tmp->m_nowait = nowait;\n\t\t\t\tmp->m_silent = silent;\n\t\t\t\tmp->m_mode = mode;\n#ifdef FEAT_EVAL\n\t\t\t\tmp->m_expr = expr;\n\t\t\t\tmp->m_script_ctx = current_sctx;\n\t\t\t\tmp->m_script_ctx.sc_lnum += sourcing_lnum;\n#endif\n\t\t\t\tdid_it = TRUE;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (mp->m_mode == 0)\t/* entry can be deleted */\n\t\t\t{\n\t\t\t    map_free(mpp);\n\t\t\t    continue;\t\t/* continue with *mpp */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * May need to put this entry into another hash list.\n\t\t\t */\n\t\t\tnew_hash = MAP_HASH(mp->m_mode, mp->m_keys[0]);\n\t\t\tif (!abbrev && new_hash != hash)\n\t\t\t{\n\t\t\t    *mpp = mp->m_next;\n\t\t\t    mp->m_next = map_table[new_hash];\n\t\t\t    map_table[new_hash] = mp;\n\n\t\t\t    continue;\t\t/* continue with *mpp */\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tmpp = &(mp->m_next);\n\t    }\n\t}\n    }\n\n    if (maptype == 1)\t\t\t    /* delete entry */\n    {\n\tif (!did_it)\n\t    retval = 2;\t\t\t    /* no match */\n\telse if (*keys == Ctrl_C)\n\t{\n\t    /* If CTRL-C has been unmapped, reuse it for Interrupting. */\n#ifdef FEAT_LOCALMAP\n\t    if (map_table == curbuf->b_maphash)\n\t\tcurbuf->b_mapped_ctrl_c &= ~mode;\n\t    else\n#endif\n\t\tmapped_ctrl_c &= ~mode;\n\t}\n\tgoto theend;\n    }\n\n    if (!haskey || !hasarg)\t\t    /* print entries */\n    {\n\tif (!did_it\n#ifdef FEAT_LOCALMAP\n\t\t&& !did_local\n#endif\n\t\t)\n\t{\n\t    if (abbrev)\n\t\tmsg(_(\"No abbreviation found\"));\n\t    else\n\t\tmsg(_(\"No mapping found\"));\n\t}\n\tgoto theend;\t\t\t    /* listing finished */\n    }\n\n    if (did_it)\t\t\t/* have added the new entry already */\n\tgoto theend;\n\n    /*\n     * Get here when adding a new entry to the maphash[] list or abbrlist.\n     */\n    mp = (mapblock_T *)alloc((unsigned)sizeof(mapblock_T));\n    if (mp == NULL)\n    {\n\tretval = 4;\t    /* no mem */\n\tgoto theend;\n    }\n\n    /* If CTRL-C has been mapped, don't always use it for Interrupting. */\n    if (*keys == Ctrl_C)\n    {\n#ifdef FEAT_LOCALMAP\n\tif (map_table == curbuf->b_maphash)\n\t    curbuf->b_mapped_ctrl_c |= mode;\n\telse\n#endif\n\t    mapped_ctrl_c |= mode;\n    }\n\n    mp->m_keys = vim_strsave(keys);\n    mp->m_str = vim_strsave(rhs);\n    mp->m_orig_str = vim_strsave(orig_rhs);\n    if (mp->m_keys == NULL || mp->m_str == NULL)\n    {\n\tvim_free(mp->m_keys);\n\tvim_free(mp->m_str);\n\tvim_free(mp->m_orig_str);\n\tvim_free(mp);\n\tretval = 4;\t/* no mem */\n\tgoto theend;\n    }\n    mp->m_keylen = (int)STRLEN(mp->m_keys);\n    mp->m_noremap = noremap;\n    mp->m_nowait = nowait;\n    mp->m_silent = silent;\n    mp->m_mode = mode;\n#ifdef FEAT_EVAL\n    mp->m_expr = expr;\n    mp->m_script_ctx = current_sctx;\n    mp->m_script_ctx.sc_lnum += sourcing_lnum;\n#endif\n\n    /* add the new entry in front of the abbrlist or maphash[] list */\n    if (abbrev)\n    {\n\tmp->m_next = *abbr_table;\n\t*abbr_table = mp;\n    }\n    else\n    {\n\tn = MAP_HASH(mp->m_mode, mp->m_keys[0]);\n\tmp->m_next = map_table[n];\n\tmap_table[n] = mp;\n    }\n\ntheend:\n    vim_free(keys_buf);\n    vim_free(arg_buf);\n    return retval;\n}\n\n/*\n * Delete one entry from the abbrlist or maphash[].\n * \"mpp\" is a pointer to the m_next field of the PREVIOUS entry!\n */\n    static void\nmap_free(mapblock_T **mpp)\n{\n    mapblock_T\t*mp;\n\n    mp = *mpp;\n    vim_free(mp->m_keys);\n    vim_free(mp->m_str);\n    vim_free(mp->m_orig_str);\n    *mpp = mp->m_next;\n    vim_free(mp);\n}\n\n/*\n * Initialize maphash[] for first use.\n */\n    static void\nvalidate_maphash(void)\n{\n    if (!maphash_valid)\n    {\n\tvim_memset(maphash, 0, sizeof(maphash));\n\tmaphash_valid = TRUE;\n    }\n}\n\n/*\n * Get the mapping mode from the command name.\n */\n    int\nget_map_mode(char_u **cmdp, int forceit)\n{\n    char_u\t*p;\n    int\t\tmodec;\n    int\t\tmode;\n\n    p = *cmdp;\n    modec = *p++;\n    if (modec == 'i')\n\tmode = INSERT;\t\t\t\t/* :imap */\n    else if (modec == 'l')\n\tmode = LANGMAP;\t\t\t\t/* :lmap */\n    else if (modec == 'c')\n\tmode = CMDLINE;\t\t\t\t/* :cmap */\n    else if (modec == 'n' && *p != 'o')\t\t    /* avoid :noremap */\n\tmode = NORMAL;\t\t\t\t/* :nmap */\n    else if (modec == 'v')\n\tmode = VISUAL + SELECTMODE;\t\t/* :vmap */\n    else if (modec == 'x')\n\tmode = VISUAL;\t\t\t\t/* :xmap */\n    else if (modec == 's')\n\tmode = SELECTMODE;\t\t\t/* :smap */\n    else if (modec == 'o')\n\tmode = OP_PENDING;\t\t\t/* :omap */\n    else if (modec == 't')\n\tmode = TERMINAL;\t\t\t/* :tmap */\n    else\n    {\n\t--p;\n\tif (forceit)\n\t    mode = INSERT + CMDLINE;\t\t/* :map ! */\n\telse\n\t    mode = VISUAL + SELECTMODE + NORMAL + OP_PENDING;/* :map */\n    }\n\n    *cmdp = p;\n    return mode;\n}\n\n/*\n * Clear all mappings or abbreviations.\n * 'abbr' should be FALSE for mappings, TRUE for abbreviations.\n */\n    void\nmap_clear(\n    char_u\t*cmdp,\n    char_u\t*arg UNUSED,\n    int\t\tforceit,\n    int\t\tabbr)\n{\n    int\t\tmode;\n#ifdef FEAT_LOCALMAP\n    int\t\tlocal;\n\n    local = (STRCMP(arg, \"<buffer>\") == 0);\n    if (!local && *arg != NUL)\n    {\n\temsg(_(e_invarg));\n\treturn;\n    }\n#endif\n\n    mode = get_map_mode(&cmdp, forceit);\n    map_clear_int(curbuf, mode,\n#ifdef FEAT_LOCALMAP\n\t    local,\n#else\n\t    FALSE,\n#endif\n\t    abbr);\n}\n\n/*\n * Clear all mappings in \"mode\".\n */\n    void\nmap_clear_int(\n    buf_T\t*buf UNUSED,\t/* buffer for local mappings */\n    int\t\tmode,\t\t/* mode in which to delete */\n    int\t\tlocal UNUSED,\t/* TRUE for buffer-local mappings */\n    int\t\tabbr)\t\t/* TRUE for abbreviations */\n{\n    mapblock_T\t*mp, **mpp;\n    int\t\thash;\n    int\t\tnew_hash;\n\n    validate_maphash();\n\n    for (hash = 0; hash < 256; ++hash)\n    {\n\tif (abbr)\n\t{\n\t    if (hash > 0)\t/* there is only one abbrlist */\n\t\tbreak;\n#ifdef FEAT_LOCALMAP\n\t    if (local)\n\t\tmpp = &buf->b_first_abbr;\n\t    else\n#endif\n\t\tmpp = &first_abbr;\n\t}\n\telse\n\t{\n#ifdef FEAT_LOCALMAP\n\t    if (local)\n\t\tmpp = &buf->b_maphash[hash];\n\t    else\n#endif\n\t\tmpp = &maphash[hash];\n\t}\n\twhile (*mpp != NULL)\n\t{\n\t    mp = *mpp;\n\t    if (mp->m_mode & mode)\n\t    {\n\t\tmp->m_mode &= ~mode;\n\t\tif (mp->m_mode == 0) /* entry can be deleted */\n\t\t{\n\t\t    map_free(mpp);\n\t\t    continue;\n\t\t}\n\t\t/*\n\t\t * May need to put this entry into another hash list.\n\t\t */\n\t\tnew_hash = MAP_HASH(mp->m_mode, mp->m_keys[0]);\n\t\tif (!abbr && new_hash != hash)\n\t\t{\n\t\t    *mpp = mp->m_next;\n#ifdef FEAT_LOCALMAP\n\t\t    if (local)\n\t\t    {\n\t\t\tmp->m_next = buf->b_maphash[new_hash];\n\t\t\tbuf->b_maphash[new_hash] = mp;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tmp->m_next = maphash[new_hash];\n\t\t\tmaphash[new_hash] = mp;\n\t\t    }\n\t\t    continue;\t\t/* continue with *mpp */\n\t\t}\n\t    }\n\t    mpp = &(mp->m_next);\n\t}\n    }\n}\n\n/*\n * Return characters to represent the map mode in an allocated string.\n * Returns NULL when out of memory.\n */\n    char_u *\nmap_mode_to_chars(int mode)\n{\n    garray_T    mapmode;\n\n    ga_init2(&mapmode, 1, 7);\n\n    if ((mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)\n\tga_append(&mapmode, '!');\t\t\t/* :map! */\n    else if (mode & INSERT)\n\tga_append(&mapmode, 'i');\t\t\t/* :imap */\n    else if (mode & LANGMAP)\n\tga_append(&mapmode, 'l');\t\t\t/* :lmap */\n    else if (mode & CMDLINE)\n\tga_append(&mapmode, 'c');\t\t\t/* :cmap */\n    else if ((mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING))\n\t\t\t\t == NORMAL + VISUAL + SELECTMODE + OP_PENDING)\n\tga_append(&mapmode, ' ');\t\t\t/* :map */\n    else\n    {\n\tif (mode & NORMAL)\n\t    ga_append(&mapmode, 'n');\t\t\t/* :nmap */\n\tif (mode & OP_PENDING)\n\t    ga_append(&mapmode, 'o');\t\t\t/* :omap */\n\tif ((mode & (VISUAL + SELECTMODE)) == VISUAL + SELECTMODE)\n\t    ga_append(&mapmode, 'v');\t\t\t/* :vmap */\n\telse\n\t{\n\t    if (mode & VISUAL)\n\t\tga_append(&mapmode, 'x');\t\t/* :xmap */\n\t    if (mode & SELECTMODE)\n\t\tga_append(&mapmode, 's');\t\t/* :smap */\n\t}\n    }\n\n    ga_append(&mapmode, NUL);\n    return (char_u *)mapmode.ga_data;\n}\n\n    static void\nshowmap(\n    mapblock_T\t*mp,\n    int\t\tlocal)\t    /* TRUE for buffer-local map */\n{\n    int\t\tlen = 1;\n    char_u\t*mapchars;\n\n    if (message_filtered(mp->m_keys) && message_filtered(mp->m_str))\n\treturn;\n\n    if (msg_didout || msg_silent != 0)\n    {\n\tmsg_putchar('\\n');\n\tif (got_int)\t    /* 'q' typed at MORE prompt */\n\t    return;\n    }\n\n    mapchars = map_mode_to_chars(mp->m_mode);\n    if (mapchars != NULL)\n    {\n\tmsg_puts((char *)mapchars);\n\tlen = (int)STRLEN(mapchars);\n\tvim_free(mapchars);\n    }\n\n    while (++len <= 3)\n\tmsg_putchar(' ');\n\n    /* Display the LHS.  Get length of what we write. */\n    len = msg_outtrans_special(mp->m_keys, TRUE, 0);\n    do\n    {\n\tmsg_putchar(' ');\t\t/* padd with blanks */\n\t++len;\n    } while (len < 12);\n\n    if (mp->m_noremap == REMAP_NONE)\n\tmsg_puts_attr(\"*\", HL_ATTR(HLF_8));\n    else if (mp->m_noremap == REMAP_SCRIPT)\n\tmsg_puts_attr(\"&\", HL_ATTR(HLF_8));\n    else\n\tmsg_putchar(' ');\n\n    if (local)\n\tmsg_putchar('@');\n    else\n\tmsg_putchar(' ');\n\n    /* Use FALSE below if we only want things like <Up> to show up as such on\n     * the rhs, and not M-x etc, TRUE gets both -- webb */\n    if (*mp->m_str == NUL)\n\tmsg_puts_attr(\"<Nop>\", HL_ATTR(HLF_8));\n    else\n    {\n\t/* Remove escaping of CSI, because \"m_str\" is in a format to be used\n\t * as typeahead. */\n\tchar_u *s = vim_strsave(mp->m_str);\n\tif (s != NULL)\n\t{\n\t    vim_unescape_csi(s);\n\t    msg_outtrans_special(s, FALSE, 0);\n\t    vim_free(s);\n\t}\n    }\n#ifdef FEAT_EVAL\n    if (p_verbose > 0)\n\tlast_set_msg(mp->m_script_ctx);\n#endif\n    out_flush();\t\t\t/* show one line at a time */\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if a map exists that has \"str\" in the rhs for mode \"modechars\".\n * Recognize termcap codes in \"str\".\n * Also checks mappings local to the current buffer.\n */\n    int\nmap_to_exists(char_u *str, char_u *modechars, int abbr)\n{\n    int\t\tmode = 0;\n    char_u\t*rhs;\n    char_u\t*buf;\n    int\t\tretval;\n\n    rhs = replace_termcodes(str, &buf, FALSE, TRUE, FALSE);\n\n    if (vim_strchr(modechars, 'n') != NULL)\n\tmode |= NORMAL;\n    if (vim_strchr(modechars, 'v') != NULL)\n\tmode |= VISUAL + SELECTMODE;\n    if (vim_strchr(modechars, 'x') != NULL)\n\tmode |= VISUAL;\n    if (vim_strchr(modechars, 's') != NULL)\n\tmode |= SELECTMODE;\n    if (vim_strchr(modechars, 'o') != NULL)\n\tmode |= OP_PENDING;\n    if (vim_strchr(modechars, 'i') != NULL)\n\tmode |= INSERT;\n    if (vim_strchr(modechars, 'l') != NULL)\n\tmode |= LANGMAP;\n    if (vim_strchr(modechars, 'c') != NULL)\n\tmode |= CMDLINE;\n\n    retval = map_to_exists_mode(rhs, mode, abbr);\n    vim_free(buf);\n\n    return retval;\n}\n#endif\n\n/*\n * Return TRUE if a map exists that has \"str\" in the rhs for mode \"mode\".\n * Also checks mappings local to the current buffer.\n */\n    int\nmap_to_exists_mode(char_u *rhs, int mode, int abbr)\n{\n    mapblock_T\t*mp;\n    int\t\thash;\n# ifdef FEAT_LOCALMAP\n    int\t\texp_buffer = FALSE;\n\n    validate_maphash();\n\n    /* Do it twice: once for global maps and once for local maps. */\n    for (;;)\n    {\n# endif\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (abbr)\n\t    {\n\t\tif (hash > 0)\t\t/* there is only one abbr list */\n\t\t    break;\n#ifdef FEAT_LOCALMAP\n\t\tif (exp_buffer)\n\t\t    mp = curbuf->b_first_abbr;\n\t\telse\n#endif\n\t\t    mp = first_abbr;\n\t    }\n# ifdef FEAT_LOCALMAP\n\t    else if (exp_buffer)\n\t\tmp = curbuf->b_maphash[hash];\n# endif\n\t    else\n\t\tmp = maphash[hash];\n\t    for (; mp; mp = mp->m_next)\n\t    {\n\t\tif ((mp->m_mode & mode)\n\t\t\t&& strstr((char *)mp->m_str, (char *)rhs) != NULL)\n\t\t    return TRUE;\n\t    }\n\t}\n# ifdef FEAT_LOCALMAP\n\tif (exp_buffer)\n\t    break;\n\texp_buffer = TRUE;\n    }\n# endif\n\n    return FALSE;\n}\n\n#if defined(FEAT_CMDL_COMPL) || defined(PROTO)\n/*\n * Used below when expanding mapping/abbreviation names.\n */\nstatic int\texpand_mapmodes = 0;\nstatic int\texpand_isabbrev = 0;\n#ifdef FEAT_LOCALMAP\nstatic int\texpand_buffer = FALSE;\n#endif\n\n/*\n * Work out what to complete when doing command line completion of mapping\n * or abbreviation names.\n */\n    char_u *\nset_context_in_map_cmd(\n    expand_T\t*xp,\n    char_u\t*cmd,\n    char_u\t*arg,\n    int\t\tforceit,\t/* TRUE if '!' given */\n    int\t\tisabbrev,\t/* TRUE if abbreviation */\n    int\t\tisunmap,\t/* TRUE if unmap/unabbrev command */\n    cmdidx_T\tcmdidx)\n{\n    if (forceit && cmdidx != CMD_map && cmdidx != CMD_unmap)\n\txp->xp_context = EXPAND_NOTHING;\n    else\n    {\n\tif (isunmap)\n\t    expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);\n\telse\n\t{\n\t    expand_mapmodes = INSERT + CMDLINE;\n\t    if (!isabbrev)\n\t\texpand_mapmodes += VISUAL + SELECTMODE + NORMAL + OP_PENDING;\n\t}\n\texpand_isabbrev = isabbrev;\n\txp->xp_context = EXPAND_MAPPINGS;\n#ifdef FEAT_LOCALMAP\n\texpand_buffer = FALSE;\n#endif\n\tfor (;;)\n\t{\n#ifdef FEAT_LOCALMAP\n\t    if (STRNCMP(arg, \"<buffer>\", 8) == 0)\n\t    {\n\t\texpand_buffer = TRUE;\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n#endif\n\t    if (STRNCMP(arg, \"<unique>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<nowait>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<silent>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<special>\", 9) == 0)\n\t    {\n\t\targ = skipwhite(arg + 9);\n\t\tcontinue;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (STRNCMP(arg, \"<script>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<expr>\", 6) == 0)\n\t    {\n\t\targ = skipwhite(arg + 6);\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\txp->xp_pattern = arg;\n    }\n\n    return NULL;\n}\n\n/*\n * Find all mapping/abbreviation names that match regexp \"regmatch\"'.\n * For command line expansion of \":[un]map\" and \":[un]abbrev\" in all modes.\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandMappings(\n    regmatch_T\t*regmatch,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    mapblock_T\t*mp;\n    int\t\thash;\n    int\t\tcount;\n    int\t\tround;\n    char_u\t*p;\n    int\t\ti;\n\n    validate_maphash();\n\n    *num_file = 0;\t\t    /* return values in case of FAIL */\n    *file = NULL;\n\n    /*\n     * round == 1: Count the matches.\n     * round == 2: Build the array to keep the matches.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\tcount = 0;\n\n\tfor (i = 0; i < 7; ++i)\n\t{\n\t    if (i == 0)\n\t\tp = (char_u *)\"<silent>\";\n\t    else if (i == 1)\n\t\tp = (char_u *)\"<unique>\";\n#ifdef FEAT_EVAL\n\t    else if (i == 2)\n\t\tp = (char_u *)\"<script>\";\n\t    else if (i == 3)\n\t\tp = (char_u *)\"<expr>\";\n#endif\n#ifdef FEAT_LOCALMAP\n\t    else if (i == 4 && !expand_buffer)\n\t\tp = (char_u *)\"<buffer>\";\n#endif\n\t    else if (i == 5)\n\t\tp = (char_u *)\"<nowait>\";\n\t    else if (i == 6)\n\t\tp = (char_u *)\"<special>\";\n\t    else\n\t\tcontinue;\n\n\t    if (vim_regexec(regmatch, p, (colnr_T)0))\n\t    {\n\t\tif (round == 1)\n\t\t    ++count;\n\t\telse\n\t\t    (*file)[count++] = vim_strsave(p);\n\t    }\n\t}\n\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (expand_isabbrev)\n\t    {\n\t\tif (hash > 0)\t/* only one abbrev list */\n\t\t    break; /* for (hash) */\n\t\tmp = first_abbr;\n\t    }\n#ifdef FEAT_LOCALMAP\n\t    else if (expand_buffer)\n\t\tmp = curbuf->b_maphash[hash];\n#endif\n\t    else\n\t\tmp = maphash[hash];\n\t    for (; mp; mp = mp->m_next)\n\t    {\n\t\tif (mp->m_mode & expand_mapmodes)\n\t\t{\n\t\t    p = translate_mapping(mp->m_keys);\n\t\t    if (p != NULL && vim_regexec(regmatch, p, (colnr_T)0))\n\t\t    {\n\t\t\tif (round == 1)\n\t\t\t    ++count;\n\t\t\telse\n\t\t\t{\n\t\t\t    (*file)[count++] = p;\n\t\t\t    p = NULL;\n\t\t\t}\n\t\t    }\n\t\t    vim_free(p);\n\t\t}\n\t    } /* for (mp) */\n\t} /* for (hash) */\n\n\tif (count == 0)\t\t\t/* no match found */\n\t    break; /* for (round) */\n\n\tif (round == 1)\n\t{\n\t    *file = (char_u **)alloc((unsigned)(count * sizeof(char_u *)));\n\t    if (*file == NULL)\n\t\treturn FAIL;\n\t}\n    } /* for (round) */\n\n    if (count > 1)\n    {\n\tchar_u\t**ptr1;\n\tchar_u\t**ptr2;\n\tchar_u\t**ptr3;\n\n\t/* Sort the matches */\n\tsort_strings(*file, count);\n\n\t/* Remove multiple entries */\n\tptr1 = *file;\n\tptr2 = ptr1 + 1;\n\tptr3 = ptr1 + count;\n\n\twhile (ptr2 < ptr3)\n\t{\n\t    if (STRCMP(*ptr1, *ptr2))\n\t\t*++ptr1 = *ptr2++;\n\t    else\n\t    {\n\t\tvim_free(*ptr2++);\n\t\tcount--;\n\t    }\n\t}\n    }\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n#endif /* FEAT_CMDL_COMPL */\n\n/*\n * Check for an abbreviation.\n * Cursor is at ptr[col].\n * When inserting, mincol is where insert started.\n * For the command line, mincol is what is to be skipped over.\n * \"c\" is the character typed before check_abbr was called.  It may have\n * ABBR_OFF added to avoid prepending a CTRL-V to it.\n *\n * Historic vi practice: The last character of an abbreviation must be an id\n * character ([a-zA-Z0-9_]). The characters in front of it must be all id\n * characters or all non-id characters. This allows for abbr. \"#i\" to\n * \"#include\".\n *\n * Vim addition: Allow for abbreviations that end in a non-keyword character.\n * Then there must be white space before the abbr.\n *\n * return TRUE if there is an abbreviation, FALSE if not\n */\n    int\ncheck_abbr(\n    int\t\tc,\n    char_u\t*ptr,\n    int\t\tcol,\n    int\t\tmincol)\n{\n    int\t\tlen;\n    int\t\tscol;\t\t/* starting column of the abbr. */\n    int\t\tj;\n    char_u\t*s;\n    char_u\ttb[MB_MAXBYTES + 4];\n    mapblock_T\t*mp;\n#ifdef FEAT_LOCALMAP\n    mapblock_T\t*mp2;\n#endif\n    int\t\tclen = 0;\t/* length in characters */\n    int\t\tis_id = TRUE;\n    int\t\tvim_abbr;\n\n    if (typebuf.tb_no_abbr_cnt)\t/* abbrev. are not recursive */\n\treturn FALSE;\n\n    /* no remapping implies no abbreviation, except for CTRL-] */\n    if ((KeyNoremap & (RM_NONE|RM_SCRIPT)) != 0 && c != Ctrl_RSB)\n\treturn FALSE;\n\n    /*\n     * Check for word before the cursor: If it ends in a keyword char all\n     * chars before it must be keyword chars or non-keyword chars, but not\n     * white space. If it ends in a non-keyword char we accept any characters\n     * before it except white space.\n     */\n    if (col == 0)\t\t\t\t/* cannot be an abbr. */\n\treturn FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\tp = mb_prevptr(ptr, ptr + col);\n\tif (!vim_iswordp(p))\n\t    vim_abbr = TRUE;\t\t\t/* Vim added abbr. */\n\telse\n\t{\n\t    vim_abbr = FALSE;\t\t\t/* vi compatible abbr. */\n\t    if (p > ptr)\n\t\tis_id = vim_iswordp(mb_prevptr(ptr, p));\n\t}\n\tclen = 1;\n\twhile (p > ptr + mincol)\n\t{\n\t    p = mb_prevptr(ptr, p);\n\t    if (vim_isspace(*p) || (!vim_abbr && is_id != vim_iswordp(p)))\n\t    {\n\t\tp += (*mb_ptr2len)(p);\n\t\tbreak;\n\t    }\n\t    ++clen;\n\t}\n\tscol = (int)(p - ptr);\n    }\n    else\n    {\n\tif (!vim_iswordc(ptr[col - 1]))\n\t    vim_abbr = TRUE;\t\t\t/* Vim added abbr. */\n\telse\n\t{\n\t    vim_abbr = FALSE;\t\t\t/* vi compatible abbr. */\n\t    if (col > 1)\n\t\tis_id = vim_iswordc(ptr[col - 2]);\n\t}\n\tfor (scol = col - 1; scol > 0 && !vim_isspace(ptr[scol - 1])\n\t\t&& (vim_abbr || is_id == vim_iswordc(ptr[scol - 1])); --scol)\n\t    ;\n    }\n\n    if (scol < mincol)\n\tscol = mincol;\n    if (scol < col)\t\t/* there is a word in front of the cursor */\n    {\n\tptr += scol;\n\tlen = col - scol;\n#ifdef FEAT_LOCALMAP\n\tmp = curbuf->b_first_abbr;\n\tmp2 = first_abbr;\n\tif (mp == NULL)\n\t{\n\t    mp = mp2;\n\t    mp2 = NULL;\n\t}\n#else\n\tmp = first_abbr;\n#endif\n\tfor ( ; mp;\n#ifdef FEAT_LOCALMAP\n\t\tmp->m_next == NULL ? (mp = mp2, mp2 = NULL) :\n#endif\n\t\t(mp = mp->m_next))\n\t{\n\t    int\t\tqlen = mp->m_keylen;\n\t    char_u\t*q = mp->m_keys;\n\t    int\t\tmatch;\n\n\t    if (vim_strbyte(mp->m_keys, K_SPECIAL) != NULL)\n\t    {\n\t\tchar_u *qe = vim_strsave(mp->m_keys);\n\n\t\t/* might have CSI escaped mp->m_keys */\n\t\tif (qe != NULL)\n\t\t{\n\t\t    q = qe;\n\t\t    vim_unescape_csi(q);\n\t\t    qlen = (int)STRLEN(q);\n\t\t}\n\t    }\n\n\t    /* find entries with right mode and keys */\n\t    match =    (mp->m_mode & State)\n\t\t    && qlen == len\n\t\t    && !STRNCMP(q, ptr, (size_t)len);\n\t    if (q != mp->m_keys)\n\t\tvim_free(q);\n\t    if (match)\n\t\tbreak;\n\t}\n\tif (mp != NULL)\n\t{\n\t    /*\n\t     * Found a match:\n\t     * Insert the rest of the abbreviation in typebuf.tb_buf[].\n\t     * This goes from end to start.\n\t     *\n\t     * Characters 0x000 - 0x100: normal chars, may need CTRL-V,\n\t     * except K_SPECIAL: Becomes K_SPECIAL KS_SPECIAL KE_FILLER\n\t     * Characters where IS_SPECIAL() == TRUE: key codes, need\n\t     * K_SPECIAL. Other characters (with ABBR_OFF): don't use CTRL-V.\n\t     *\n\t     * Character CTRL-] is treated specially - it completes the\n\t     * abbreviation, but is not inserted into the input stream.\n\t     */\n\t    j = 0;\n\t    if (c != Ctrl_RSB)\n\t    {\n\t\t\t\t\t/* special key code, split up */\n\t\tif (IS_SPECIAL(c) || c == K_SPECIAL)\n\t\t{\n\t\t    tb[j++] = K_SPECIAL;\n\t\t    tb[j++] = K_SECOND(c);\n\t\t    tb[j++] = K_THIRD(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (c < ABBR_OFF && (c < ' ' || c > '~'))\n\t\t\ttb[j++] = Ctrl_V;\t/* special char needs CTRL-V */\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t/* if ABBR_OFF has been added, remove it here */\n\t\t\tif (c >= ABBR_OFF)\n\t\t\t    c -= ABBR_OFF;\n\t\t\tj += (*mb_char2bytes)(c, tb + j);\n\t\t    }\n\t\t    else\n\t\t\ttb[j++] = c;\n\t\t}\n\t\ttb[j] = NUL;\n\t\t\t\t\t/* insert the last typed char */\n\t\t(void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);\n\t    }\n#ifdef FEAT_EVAL\n\t    if (mp->m_expr)\n\t\ts = eval_map_expr(mp->m_str, c);\n\t    else\n#endif\n\t\ts = mp->m_str;\n\t    if (s != NULL)\n\t    {\n\t\t\t\t\t/* insert the to string */\n\t\t(void)ins_typebuf(s, mp->m_noremap, 0, TRUE, mp->m_silent);\n\t\t\t\t\t/* no abbrev. for these chars */\n\t\ttypebuf.tb_no_abbr_cnt += (int)STRLEN(s) + j + 1;\n#ifdef FEAT_EVAL\n\t\tif (mp->m_expr)\n\t\t    vim_free(s);\n#endif\n\t    }\n\n\t    tb[0] = Ctrl_H;\n\t    tb[1] = NUL;\n\t    if (has_mbyte)\n\t\tlen = clen;\t/* Delete characters instead of bytes */\n\t    while (len-- > 0)\t\t/* delete the from string */\n\t\t(void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Evaluate the RHS of a mapping or abbreviations and take care of escaping\n * special characters.\n */\n    static char_u *\neval_map_expr(\n    char_u\t*str,\n    int\t\tc)\t    /* NUL or typed character for abbreviation */\n{\n    char_u\t*res;\n    char_u\t*p;\n    char_u\t*expr;\n    pos_T\tsave_cursor;\n    int\t\tsave_msg_col;\n    int\t\tsave_msg_row;\n\n    /* Remove escaping of CSI, because \"str\" is in a format to be used as\n     * typeahead. */\n    expr = vim_strsave(str);\n    if (expr == NULL)\n\treturn NULL;\n    vim_unescape_csi(expr);\n\n    /* Forbid changing text or using \":normal\" to avoid most of the bad side\n     * effects.  Also restore the cursor position. */\n    ++textlock;\n    ++ex_normal_lock;\n    set_vim_var_char(c);  /* set v:char to the typed character */\n    save_cursor = curwin->w_cursor;\n    save_msg_col = msg_col;\n    save_msg_row = msg_row;\n    p = eval_to_string(expr, NULL, FALSE);\n    --textlock;\n    --ex_normal_lock;\n    curwin->w_cursor = save_cursor;\n    msg_col = save_msg_col;\n    msg_row = save_msg_row;\n\n    vim_free(expr);\n\n    if (p == NULL)\n\treturn NULL;\n    /* Escape CSI in the result to be able to use the string as typeahead. */\n    res = vim_strsave_escape_csi(p);\n    vim_free(p);\n\n    return res;\n}\n#endif\n\n/*\n * Copy \"p\" to allocated memory, escaping K_SPECIAL and CSI so that the result\n * can be put in the typeahead buffer.\n * Returns NULL when out of memory.\n */\n    char_u *\nvim_strsave_escape_csi(\n    char_u *p)\n{\n    char_u\t*res;\n    char_u\t*s, *d;\n\n    /* Need a buffer to hold up to three times as much.  Four in case of an\n     * illegal utf-8 byte:\n     * 0xc0 -> 0xc3 0x80 -> 0xc3 K_SPECIAL KS_SPECIAL KE_FILLER */\n    res = alloc((unsigned)(STRLEN(p) * 4) + 1);\n    if (res != NULL)\n    {\n\td = res;\n\tfor (s = p; *s != NUL; )\n\t{\n\t    if (s[0] == K_SPECIAL && s[1] != NUL && s[2] != NUL)\n\t    {\n\t\t/* Copy special key unmodified. */\n\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t    }\n\t    else\n\t    {\n\t\t/* Add character, possibly multi-byte to destination, escaping\n\t\t * CSI and K_SPECIAL. Be careful, it can be an illegal byte! */\n\t\td = add_char2buf(PTR2CHAR(s), d);\n\t\ts += MB_CPTR2LEN(s);\n\t    }\n\t}\n\t*d = NUL;\n    }\n    return res;\n}\n\n/*\n * Remove escaping from CSI and K_SPECIAL characters.  Reverse of\n * vim_strsave_escape_csi().  Works in-place.\n */\n    void\nvim_unescape_csi(char_u *p)\n{\n    char_u\t*s = p, *d = p;\n\n    while (*s != NUL)\n    {\n\tif (s[0] == K_SPECIAL && s[1] == KS_SPECIAL && s[2] == KE_FILLER)\n\t{\n\t    *d++ = K_SPECIAL;\n\t    s += 3;\n\t}\n\telse if ((s[0] == K_SPECIAL || s[0] == CSI)\n\t\t\t\t   && s[1] == KS_EXTRA && s[2] == (int)KE_CSI)\n\t{\n\t    *d++ = CSI;\n\t    s += 3;\n\t}\n\telse\n\t    *d++ = *s++;\n    }\n    *d = NUL;\n}\n\n/*\n * Write map commands for the current mappings to an .exrc file.\n * Return FAIL on error, OK otherwise.\n */\n    int\nmakemap(\n    FILE\t*fd,\n    buf_T\t*buf)\t    /* buffer for local mappings or NULL */\n{\n    mapblock_T\t*mp;\n    char_u\tc1, c2, c3;\n    char_u\t*p;\n    char\t*cmd;\n    int\t\tabbr;\n    int\t\thash;\n    int\t\tdid_cpo = FALSE;\n    int\t\ti;\n\n    validate_maphash();\n\n    /*\n     * Do the loop twice: Once for mappings, once for abbreviations.\n     * Then loop over all map hash lists.\n     */\n    for (abbr = 0; abbr < 2; ++abbr)\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (abbr)\n\t    {\n\t\tif (hash > 0)\t\t/* there is only one abbr list */\n\t\t    break;\n#ifdef FEAT_LOCALMAP\n\t\tif (buf != NULL)\n\t\t    mp = buf->b_first_abbr;\n\t\telse\n#endif\n\t\t    mp = first_abbr;\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LOCALMAP\n\t\tif (buf != NULL)\n\t\t    mp = buf->b_maphash[hash];\n\t\telse\n#endif\n\t\t    mp = maphash[hash];\n\t    }\n\n\t    for ( ; mp; mp = mp->m_next)\n\t    {\n\t\t/* skip script-local mappings */\n\t\tif (mp->m_noremap == REMAP_SCRIPT)\n\t\t    continue;\n\n\t\t/* skip mappings that contain a <SNR> (script-local thing),\n\t\t * they probably don't work when loaded again */\n\t\tfor (p = mp->m_str; *p != NUL; ++p)\n\t\t    if (p[0] == K_SPECIAL && p[1] == KS_EXTRA\n\t\t\t\t\t\t       && p[2] == (int)KE_SNR)\n\t\t\tbreak;\n\t\tif (*p != NUL)\n\t\t    continue;\n\n\t\t/* It's possible to create a mapping and then \":unmap\" certain\n\t\t * modes.  We recreate this here by mapping the individual\n\t\t * modes, which requires up to three of them. */\n\t\tc1 = NUL;\n\t\tc2 = NUL;\n\t\tc3 = NUL;\n\t\tif (abbr)\n\t\t    cmd = \"abbr\";\n\t\telse\n\t\t    cmd = \"map\";\n\t\tswitch (mp->m_mode)\n\t\t{\n\t\t    case NORMAL + VISUAL + SELECTMODE + OP_PENDING:\n\t\t\tbreak;\n\t\t    case NORMAL:\n\t\t\tc1 = 'n';\n\t\t\tbreak;\n\t\t    case VISUAL:\n\t\t\tc1 = 'x';\n\t\t\tbreak;\n\t\t    case SELECTMODE:\n\t\t\tc1 = 's';\n\t\t\tbreak;\n\t\t    case OP_PENDING:\n\t\t\tc1 = 'o';\n\t\t\tbreak;\n\t\t    case NORMAL + VISUAL:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'x';\n\t\t\tbreak;\n\t\t    case NORMAL + SELECTMODE:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 's';\n\t\t\tbreak;\n\t\t    case NORMAL + OP_PENDING:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case VISUAL + SELECTMODE:\n\t\t\tc1 = 'v';\n\t\t\tbreak;\n\t\t    case VISUAL + OP_PENDING:\n\t\t\tc1 = 'x';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case SELECTMODE + OP_PENDING:\n\t\t\tc1 = 's';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case NORMAL + VISUAL + SELECTMODE:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'v';\n\t\t\tbreak;\n\t\t    case NORMAL + VISUAL + OP_PENDING:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'x';\n\t\t\tc3 = 'o';\n\t\t\tbreak;\n\t\t    case NORMAL + SELECTMODE + OP_PENDING:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 's';\n\t\t\tc3 = 'o';\n\t\t\tbreak;\n\t\t    case VISUAL + SELECTMODE + OP_PENDING:\n\t\t\tc1 = 'v';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case CMDLINE + INSERT:\n\t\t\tif (!abbr)\n\t\t\t    cmd = \"map!\";\n\t\t\tbreak;\n\t\t    case CMDLINE:\n\t\t\tc1 = 'c';\n\t\t\tbreak;\n\t\t    case INSERT:\n\t\t\tc1 = 'i';\n\t\t\tbreak;\n\t\t    case LANGMAP:\n\t\t\tc1 = 'l';\n\t\t\tbreak;\n\t\t    case TERMINAL:\n\t\t\tc1 = 't';\n\t\t\tbreak;\n\t\t    default:\n\t\t\tiemsg(_(\"E228: makemap: Illegal mode\"));\n\t\t\treturn FAIL;\n\t\t}\n\t\tdo\t/* do this twice if c2 is set, 3 times with c3 */\n\t\t{\n\t\t    /* When outputting <> form, need to make sure that 'cpo'\n\t\t     * is set to the Vim default. */\n\t\t    if (!did_cpo)\n\t\t    {\n\t\t\tif (*mp->m_str == NUL)\t\t/* will use <Nop> */\n\t\t\t    did_cpo = TRUE;\n\t\t\telse\n\t\t\t    for (i = 0; i < 2; ++i)\n\t\t\t\tfor (p = (i ? mp->m_str : mp->m_keys); *p; ++p)\n\t\t\t\t    if (*p == K_SPECIAL || *p == NL)\n\t\t\t\t\tdid_cpo = TRUE;\n\t\t\tif (did_cpo)\n\t\t\t{\n\t\t\t    if (fprintf(fd, \"let s:cpo_save=&cpo\") < 0\n\t\t\t\t    || put_eol(fd) < 0\n\t\t\t\t    || fprintf(fd, \"set cpo&vim\") < 0\n\t\t\t\t    || put_eol(fd) < 0)\n\t\t\t\treturn FAIL;\n\t\t\t}\n\t\t    }\n\t\t    if (c1 && putc(c1, fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_noremap != REMAP_YES && fprintf(fd, \"nore\") < 0)\n\t\t\treturn FAIL;\n\t\t    if (fputs(cmd, fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (buf != NULL && fputs(\" <buffer>\", fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_nowait && fputs(\" <nowait>\", fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_silent && fputs(\" <silent>\", fd) < 0)\n\t\t\treturn FAIL;\n#ifdef FEAT_EVAL\n\t\t    if (mp->m_noremap == REMAP_SCRIPT\n\t\t\t\t\t\t && fputs(\"<script>\", fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_expr && fputs(\" <expr>\", fd) < 0)\n\t\t\treturn FAIL;\n#endif\n\n\t\t    if (       putc(' ', fd) < 0\n\t\t\t    || put_escstr(fd, mp->m_keys, 0) == FAIL\n\t\t\t    || putc(' ', fd) < 0\n\t\t\t    || put_escstr(fd, mp->m_str, 1) == FAIL\n\t\t\t    || put_eol(fd) < 0)\n\t\t\treturn FAIL;\n\t\t    c1 = c2;\n\t\t    c2 = c3;\n\t\t    c3 = NUL;\n\t\t} while (c1 != NUL);\n\t    }\n\t}\n\n    if (did_cpo)\n\tif (fprintf(fd, \"let &cpo=s:cpo_save\") < 0\n\t\t|| put_eol(fd) < 0\n\t\t|| fprintf(fd, \"unlet s:cpo_save\") < 0\n\t\t|| put_eol(fd) < 0)\n\t    return FAIL;\n    return OK;\n}\n\n/*\n * write escape string to file\n * \"what\": 0 for :map lhs, 1 for :map rhs, 2 for :set\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nput_escstr(FILE *fd, char_u *strstart, int what)\n{\n    char_u\t*str = strstart;\n    int\t\tc;\n    int\t\tmodifiers;\n\n    /* :map xx <Nop> */\n    if (*str == NUL && what == 1)\n    {\n\tif (fprintf(fd, \"<Nop>\") < 0)\n\t    return FAIL;\n\treturn OK;\n    }\n\n    for ( ; *str != NUL; ++str)\n    {\n\tchar_u\t*p;\n\n\t/* Check for a multi-byte character, which may contain escaped\n\t * K_SPECIAL and CSI bytes */\n\tp = mb_unescape(&str);\n\tif (p != NULL)\n\t{\n\t    while (*p != NUL)\n\t\tif (fputc(*p++, fd) < 0)\n\t\t    return FAIL;\n\t    --str;\n\t    continue;\n\t}\n\n\tc = *str;\n\t/*\n\t * Special key codes have to be translated to be able to make sense\n\t * when they are read back.\n\t */\n\tif (c == K_SPECIAL && what != 2)\n\t{\n\t    modifiers = 0x0;\n\t    if (str[1] == KS_MODIFIER)\n\t    {\n\t\tmodifiers = str[2];\n\t\tstr += 3;\n\t\tc = *str;\n\t    }\n\t    if (c == K_SPECIAL)\n\t    {\n\t\tc = TO_SPECIAL(str[1], str[2]);\n\t\tstr += 2;\n\t    }\n\t    if (IS_SPECIAL(c) || modifiers)\t/* special key */\n\t    {\n\t\tif (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)\n\t\t    return FAIL;\n\t\tcontinue;\n\t    }\n\t}\n\n\t/*\n\t * A '\\n' in a map command should be written as <NL>.\n\t * A '\\n' in a set command should be written as \\^V^J.\n\t */\n\tif (c == NL)\n\t{\n\t    if (what == 2)\n\t    {\n\t\tif (fprintf(fd, IF_EB(\"\\\\\\026\\n\", \"\\\\\" CTRL_V_STR \"\\n\")) < 0)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tif (fprintf(fd, \"<NL>\") < 0)\n\t\t    return FAIL;\n\t    }\n\t    continue;\n\t}\n\n\t/*\n\t * Some characters have to be escaped with CTRL-V to\n\t * prevent them from misinterpreted in DoOneCmd().\n\t * A space, Tab and '\"' has to be escaped with a backslash to\n\t * prevent it to be misinterpreted in do_set().\n\t * A space has to be escaped with a CTRL-V when it's at the start of a\n\t * \":map\" rhs.\n\t * A '<' has to be escaped with a CTRL-V to prevent it being\n\t * interpreted as the start of a special key name.\n\t * A space in the lhs of a :map needs a CTRL-V.\n\t */\n\tif (what == 2 && (VIM_ISWHITE(c) || c == '\"' || c == '\\\\'))\n\t{\n\t    if (putc('\\\\', fd) < 0)\n\t\treturn FAIL;\n\t}\n\telse if (c < ' ' || c > '~' || c == '|'\n\t\t|| (what == 0 && c == ' ')\n\t\t|| (what == 1 && str == strstart && c == ' ')\n\t\t|| (what != 2 && c == '<'))\n\t{\n\t    if (putc(Ctrl_V, fd) < 0)\n\t\treturn FAIL;\n\t}\n\tif (putc(c, fd) < 0)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check all mappings for the presence of special key codes.\n * Used after \":set term=xxx\".\n */\n    void\ncheck_map_keycodes(void)\n{\n    mapblock_T\t*mp;\n    char_u\t*p;\n    int\t\ti;\n    char_u\tbuf[3];\n    char_u\t*save_name;\n    int\t\tabbr;\n    int\t\thash;\n#ifdef FEAT_LOCALMAP\n    buf_T\t*bp;\n#endif\n\n    validate_maphash();\n    save_name = sourcing_name;\n    sourcing_name = (char_u *)\"mappings\"; /* avoids giving error messages */\n\n#ifdef FEAT_LOCALMAP\n    /* This this once for each buffer, and then once for global\n     * mappings/abbreviations with bp == NULL */\n    for (bp = firstbuf; ; bp = bp->b_next)\n    {\n#endif\n\t/*\n\t * Do the loop twice: Once for mappings, once for abbreviations.\n\t * Then loop over all map hash lists.\n\t */\n\tfor (abbr = 0; abbr <= 1; ++abbr)\n\t    for (hash = 0; hash < 256; ++hash)\n\t    {\n\t\tif (abbr)\n\t\t{\n\t\t    if (hash)\t    /* there is only one abbr list */\n\t\t\tbreak;\n#ifdef FEAT_LOCALMAP\n\t\t    if (bp != NULL)\n\t\t\tmp = bp->b_first_abbr;\n\t\t    else\n#endif\n\t\t\tmp = first_abbr;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_LOCALMAP\n\t\t    if (bp != NULL)\n\t\t\tmp = bp->b_maphash[hash];\n\t\t    else\n#endif\n\t\t\tmp = maphash[hash];\n\t\t}\n\t\tfor ( ; mp != NULL; mp = mp->m_next)\n\t\t{\n\t\t    for (i = 0; i <= 1; ++i)\t/* do this twice */\n\t\t    {\n\t\t\tif (i == 0)\n\t\t\t    p = mp->m_keys;\t/* once for the \"from\" part */\n\t\t\telse\n\t\t\t    p = mp->m_str;\t/* and once for the \"to\" part */\n\t\t\twhile (*p)\n\t\t\t{\n\t\t\t    if (*p == K_SPECIAL)\n\t\t\t    {\n\t\t\t\t++p;\n\t\t\t\tif (*p < 128)   /* for \"normal\" tcap entries */\n\t\t\t\t{\n\t\t\t\t    buf[0] = p[0];\n\t\t\t\t    buf[1] = p[1];\n\t\t\t\t    buf[2] = NUL;\n\t\t\t\t    (void)add_termcap_entry(buf, FALSE);\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t    }\n\t\t\t    ++p;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n#ifdef FEAT_LOCALMAP\n\tif (bp == NULL)\n\t    break;\n    }\n#endif\n    sourcing_name = save_name;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Check the string \"keys\" against the lhs of all mappings.\n * Return pointer to rhs of mapping (mapblock->m_str).\n * NULL when no mapping found.\n */\n    char_u *\ncheck_map(\n    char_u\t*keys,\n    int\t\tmode,\n    int\t\texact,\t\t/* require exact match */\n    int\t\tign_mod,\t/* ignore preceding modifier */\n    int\t\tabbr,\t\t/* do abbreviations */\n    mapblock_T\t**mp_ptr,\t/* return: pointer to mapblock or NULL */\n    int\t\t*local_ptr)\t/* return: buffer-local mapping or NULL */\n{\n    int\t\thash;\n    int\t\tlen, minlen;\n    mapblock_T\t*mp;\n    char_u\t*s;\n#ifdef FEAT_LOCALMAP\n    int\t\tlocal;\n#endif\n\n    validate_maphash();\n\n    len = (int)STRLEN(keys);\n#ifdef FEAT_LOCALMAP\n    for (local = 1; local >= 0; --local)\n#endif\n\t/* loop over all hash lists */\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (abbr)\n\t    {\n\t\tif (hash > 0)\t\t/* there is only one list. */\n\t\t    break;\n#ifdef FEAT_LOCALMAP\n\t\tif (local)\n\t\t    mp = curbuf->b_first_abbr;\n\t\telse\n#endif\n\t\t    mp = first_abbr;\n\t    }\n#ifdef FEAT_LOCALMAP\n\t    else if (local)\n\t\tmp = curbuf->b_maphash[hash];\n#endif\n\t    else\n\t\tmp = maphash[hash];\n\t    for ( ; mp != NULL; mp = mp->m_next)\n\t    {\n\t\t/* skip entries with wrong mode, wrong length and not matching\n\t\t * ones */\n\t\tif ((mp->m_mode & mode) && (!exact || mp->m_keylen == len))\n\t\t{\n\t\t    if (len > mp->m_keylen)\n\t\t\tminlen = mp->m_keylen;\n\t\t    else\n\t\t\tminlen = len;\n\t\t    s = mp->m_keys;\n\t\t    if (ign_mod && s[0] == K_SPECIAL && s[1] == KS_MODIFIER\n\t\t\t\t\t\t\t       && s[2] != NUL)\n\t\t    {\n\t\t\ts += 3;\n\t\t\tif (len > mp->m_keylen - 3)\n\t\t\t    minlen = mp->m_keylen - 3;\n\t\t    }\n\t\t    if (STRNCMP(s, keys, minlen) == 0)\n\t\t    {\n\t\t\tif (mp_ptr != NULL)\n\t\t\t    *mp_ptr = mp;\n\t\t\tif (local_ptr != NULL)\n#ifdef FEAT_LOCALMAP\n\t\t\t    *local_ptr = local;\n#else\n\t\t\t    *local_ptr = 0;\n#endif\n\t\t\treturn mp->m_str;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    return NULL;\n}\n#endif\n\n#if defined(MSWIN) || defined(MACOS_X)\n\n# define VIS_SEL\t(VISUAL+SELECTMODE)\t/* abbreviation */\n\n/*\n * Default mappings for some often used keys.\n */\nstruct initmap\n{\n    char_u\t*arg;\n    int\t\tmode;\n};\n\n# ifdef FEAT_GUI_MSWIN\n/* Use the Windows (CUA) keybindings. (GUI) */\nstatic struct initmap initmappings[] =\n{\n\t/* paste, copy and cut */\n\t{(char_u *)\"<S-Insert> \\\"*P\", NORMAL},\n\t{(char_u *)\"<S-Insert> \\\"-d\\\"*P\", VIS_SEL},\n\t{(char_u *)\"<S-Insert> <C-R><C-O>*\", INSERT+CMDLINE},\n\t{(char_u *)\"<C-Insert> \\\"*y\", VIS_SEL},\n\t{(char_u *)\"<S-Del> \\\"*d\", VIS_SEL},\n\t{(char_u *)\"<C-Del> \\\"*d\", VIS_SEL},\n\t{(char_u *)\"<C-X> \\\"*d\", VIS_SEL},\n\t/* Missing: CTRL-C (cancel) and CTRL-V (block selection) */\n};\n# endif\n\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n/* Use the Windows (CUA) keybindings. (Console) */\nstatic struct initmap cinitmappings[] =\n{\n\t{(char_u *)\"\\316w <C-Home>\", NORMAL+VIS_SEL},\n\t{(char_u *)\"\\316w <C-Home>\", INSERT+CMDLINE},\n\t{(char_u *)\"\\316u <C-End>\", NORMAL+VIS_SEL},\n\t{(char_u *)\"\\316u <C-End>\", INSERT+CMDLINE},\n\n\t/* paste, copy and cut */\n#  ifdef FEAT_CLIPBOARD\n\t{(char_u *)\"\\316\\324 \\\"*P\", NORMAL},\t    /* SHIFT-Insert is \"*P */\n\t{(char_u *)\"\\316\\324 \\\"-d\\\"*P\", VIS_SEL},   /* SHIFT-Insert is \"-d\"*P */\n\t{(char_u *)\"\\316\\324 \\022\\017*\", INSERT},  /* SHIFT-Insert is ^R^O* */\n\t{(char_u *)\"\\316\\325 \\\"*y\", VIS_SEL},\t    /* CTRL-Insert is \"*y */\n\t{(char_u *)\"\\316\\327 \\\"*d\", VIS_SEL},\t    /* SHIFT-Del is \"*d */\n\t{(char_u *)\"\\316\\330 \\\"*d\", VIS_SEL},\t    /* CTRL-Del is \"*d */\n\t{(char_u *)\"\\030 \\\"*d\", VIS_SEL},\t    /* CTRL-X is \"*d */\n#  else\n\t{(char_u *)\"\\316\\324 P\", NORMAL},\t    /* SHIFT-Insert is P */\n\t{(char_u *)\"\\316\\324 \\\"-dP\", VIS_SEL},\t    /* SHIFT-Insert is \"-dP */\n\t{(char_u *)\"\\316\\324 \\022\\017\\\"\", INSERT}, /* SHIFT-Insert is ^R^O\" */\n\t{(char_u *)\"\\316\\325 y\", VIS_SEL},\t    /* CTRL-Insert is y */\n\t{(char_u *)\"\\316\\327 d\", VIS_SEL},\t    /* SHIFT-Del is d */\n\t{(char_u *)\"\\316\\330 d\", VIS_SEL},\t    /* CTRL-Del is d */\n#  endif\n};\n# endif\n\n# if defined(MACOS_X)\nstatic struct initmap initmappings[] =\n{\n\t/* Use the Standard MacOS binding. */\n\t/* paste, copy and cut */\n\t{(char_u *)\"<D-v> \\\"*P\", NORMAL},\n\t{(char_u *)\"<D-v> \\\"-d\\\"*P\", VIS_SEL},\n\t{(char_u *)\"<D-v> <C-R>*\", INSERT+CMDLINE},\n\t{(char_u *)\"<D-c> \\\"*y\", VIS_SEL},\n\t{(char_u *)\"<D-x> \\\"*d\", VIS_SEL},\n\t{(char_u *)\"<Backspace> \\\"-d\", VIS_SEL},\n};\n# endif\n\n# undef VIS_SEL\n#endif\n\n/*\n * Set up default mappings.\n */\n    void\ninit_mappings(void)\n{\n#if defined(MSWIN) || defined(MACOS_X)\n    int\t\ti;\n\n# if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n#  ifdef VIMDLL\n    if (!gui.starting)\n#  endif\n    {\n\tfor (i = 0;\n\t\ti < (int)(sizeof(cinitmappings) / sizeof(struct initmap)); ++i)\n\t    add_map(cinitmappings[i].arg, cinitmappings[i].mode);\n    }\n# endif\n# if defined(FEAT_GUI_MSWIN) || defined(MACOS_X)\n    for (i = 0; i < (int)(sizeof(initmappings) / sizeof(struct initmap)); ++i)\n\tadd_map(initmappings[i].arg, initmappings[i].mode);\n# endif\n#endif\n}\n\n#if defined(MSWIN) || defined(FEAT_CMDWIN) || defined(MACOS_X) \\\n\t\t\t\t\t\t\t     || defined(PROTO)\n/*\n * Add a mapping \"map\" for mode \"mode\".\n * Need to put string in allocated memory, because do_map() will modify it.\n */\n    void\nadd_map(char_u *map, int mode)\n{\n    char_u\t*s;\n    char_u\t*cpo_save = p_cpo;\n\n    p_cpo = (char_u *)\"\";\t/* Allow <> notation */\n    s = vim_strsave(map);\n    if (s != NULL)\n    {\n\t(void)do_map(0, s, mode, FALSE);\n\tvim_free(s);\n    }\n    p_cpo = cpo_save;\n}\n#endif\n", "\" Tests for the :source command.\n\nfunc Test_source_autocmd()\n  call writefile([\n\t\\ 'let did_source = 1',\n\t\\ ], 'Xsourced')\n  au SourcePre *source* let did_source_pre = 1\n  au SourcePost *source* let did_source_post = 1\n\n  source Xsourced\n\n  call assert_equal(g:did_source, 1)\n  call assert_equal(g:did_source_pre, 1)\n  call assert_equal(g:did_source_post, 1)\n\n  call delete('Xsourced')\n  au! SourcePre\n  au! SourcePost\n  unlet g:did_source\n  unlet g:did_source_pre\n  unlet g:did_source_post\nendfunc\n\nfunc Test_source_cmd()\n  au SourceCmd *source* let did_source = expand('<afile>')\n  au SourcePre *source* let did_source_pre = 2\n  au SourcePost *source* let did_source_post = 2\n\n  source Xsourced\n\n  call assert_equal(g:did_source, 'Xsourced')\n  call assert_false(exists('g:did_source_pre'))\n  call assert_equal(g:did_source_post, 2)\n\n  au! SourceCmd\n  au! SourcePre\n  au! SourcePost\nendfunc\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    char *date_time = __DATE__ \" \" __TIME__;\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t\t+ strlen(date_time);\n\n    longVersion = (char *)alloc((unsigned)len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TEXT_PROP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n/* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    /* Find the length of the longest item, use that + 1 as the column\n     * width. */\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    msg_puts(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    msg_puts(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * getchar.c\n *\n * functions related with getting a character from the user/mapping/redo/...\n *\n * manipulations with redo buffer and stuff buffer\n * mappings and abbreviations\n */\n\n#include \"vim.h\"\n\n/*\n * These buffers are used for storing:\n * - stuffed characters: A command that is translated into another command.\n * - redo characters: will redo the last change.\n * - recorded characters: for the \"q\" command.\n *\n * The bytes are stored like in the typeahead buffer:\n * - K_SPECIAL introduces a special key (two more bytes follow).  A literal\n *   K_SPECIAL is stored as K_SPECIAL KS_SPECIAL KE_FILLER.\n * - CSI introduces a GUI termcap code (also when gui.in_use is FALSE,\n *   otherwise switching the GUI on would make mappings invalid).\n *   A literal CSI is stored as CSI KS_EXTRA KE_CSI.\n * These translations are also done on multi-byte characters!\n *\n * Escaping CSI bytes is done by the system-specific input functions, called\n * by ui_inchar().\n * Escaping K_SPECIAL is done by inchar().\n * Un-escaping is done by vgetc().\n */\n\n#define MINIMAL_SIZE 20\t\t\t/* minimal size for b_str */\n\nstatic buffheader_T redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T recordbuff = {{NULL, {NUL}}, NULL, 0, 0};\n\nstatic int typeahead_char = 0;\t\t/* typeahead char that's not flushed */\n\n/*\n * when block_redo is TRUE redo buffer will not be changed\n * used by edit() to repeat insertions and 'V' command for redoing\n */\nstatic int\tblock_redo = FALSE;\n\n/*\n * Make a hash value for a mapping.\n * \"mode\" is the lower 4 bits of the State for the mapping.\n * \"c1\" is the first character of the \"lhs\".\n * Returns a value between 0 and 255, index in maphash.\n * Put Normal/Visual mode mappings mostly separately from Insert/Cmdline mode.\n */\n#define MAP_HASH(mode, c1) (((mode) & (NORMAL + VISUAL + SELECTMODE + OP_PENDING + TERMINAL)) ? (c1) : ((c1) ^ 0x80))\n\n/*\n * Each mapping is put in one of the 256 hash lists, to speed up finding it.\n */\nstatic mapblock_T\t*(maphash[256]);\nstatic int\t\tmaphash_valid = FALSE;\n\n/*\n * List used for abbreviations.\n */\nstatic mapblock_T\t*first_abbr = NULL; /* first entry in abbrlist */\n\nstatic int\t\tKeyNoremap = 0;\t    /* remapping flags */\n\n/*\n * Variables used by vgetorpeek() and flush_buffers().\n *\n * typebuf.tb_buf[] contains all characters that are not consumed yet.\n * typebuf.tb_buf[typebuf.tb_off] is the first valid character.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.\n * The head of the buffer may contain the result of mappings, abbreviations\n * and @a commands.  The length of this part is typebuf.tb_maplen.\n * typebuf.tb_silent is the part where <silent> applies.\n * After the head are characters that come from the terminal.\n * typebuf.tb_no_abbr_cnt is the number of characters in typebuf.tb_buf that\n * should not be considered for abbreviations.\n * Some parts of typebuf.tb_buf may not be mapped. These parts are remembered\n * in typebuf.tb_noremap[], which is the same length as typebuf.tb_buf and\n * contains RM_NONE for the characters that are not to be remapped.\n * typebuf.tb_noremap[typebuf.tb_off] is the first valid flag.\n * (typebuf has been put in globals.h, because check_termcode() needs it).\n */\n#define RM_YES\t\t0\t/* tb_noremap: remap */\n#define RM_NONE\t\t1\t/* tb_noremap: don't remap */\n#define RM_SCRIPT\t2\t/* tb_noremap: remap local script mappings */\n#define RM_ABBR\t\t4\t/* tb_noremap: don't remap, do abbrev. */\n\n/* typebuf.tb_buf has three parts: room in front (for result of mappings), the\n * middle for typeahead and room for new characters (which needs to be 3 *\n * MAXMAPLEN) for the Amiga).\n */\n#define TYPELEN_INIT\t(5 * (MAXMAPLEN + 3))\nstatic char_u\ttypebuf_init[TYPELEN_INIT];\t/* initial typebuf.tb_buf */\nstatic char_u\tnoremapbuf_init[TYPELEN_INIT];\t/* initial typebuf.tb_noremap */\n\nstatic int\tlast_recorded_len = 0;\t/* number of last recorded chars */\n\nstatic int\tread_readbuf(buffheader_T *buf, int advance);\nstatic void\tinit_typebuf(void);\nstatic void\tmay_sync_undo(void);\nstatic void\tclosescript(void);\nstatic int\tvgetorpeek(int);\nstatic void\tmap_free(mapblock_T **);\nstatic void\tvalidate_maphash(void);\nstatic void\tshowmap(mapblock_T *mp, int local);\nstatic int\tinchar(char_u *buf, int maxlen, long wait_time);\n#ifdef FEAT_EVAL\nstatic char_u\t*eval_map_expr(char_u *str, int c);\n#endif\n\n/*\n * Free and clear a buffer.\n */\n    void\nfree_buff(buffheader_T *buf)\n{\n    buffblock_T\t*p, *np;\n\n    for (p = buf->bh_first.b_next; p != NULL; p = np)\n    {\n\tnp = p->b_next;\n\tvim_free(p);\n    }\n    buf->bh_first.b_next = NULL;\n}\n\n/*\n * Return the contents of a buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    static char_u *\nget_buffcont(\n    buffheader_T\t*buffer,\n    int\t\t\tdozero)\t    /* count == zero is not an error */\n{\n    long_u\t    count = 0;\n    char_u\t    *p = NULL;\n    char_u\t    *p2;\n    char_u\t    *str;\n    buffblock_T *bp;\n\n    /* compute the total length of the string */\n    for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\tcount += (long_u)STRLEN(bp->b_str);\n\n    if ((count || dozero) && (p = lalloc(count + 1, TRUE)) != NULL)\n    {\n\tp2 = p;\n\tfor (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\t    for (str = bp->b_str; *str; )\n\t\t*p2++ = *str++;\n\t*p2 = NUL;\n    }\n    return (p);\n}\n\n/*\n * Return the contents of the record buffer as a single string\n * and clear the record buffer.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_recorded(void)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    p = get_buffcont(&recordbuff, TRUE);\n    free_buff(&recordbuff);\n\n    /*\n     * Remove the characters that were added the last time, these must be the\n     * (possibly mapped) characters that stopped the recording.\n     */\n    len = STRLEN(p);\n    if ((int)len >= last_recorded_len)\n    {\n\tlen -= last_recorded_len;\n\tp[len] = NUL;\n    }\n\n    /*\n     * When stopping recording from Insert mode with CTRL-O q, also remove the\n     * CTRL-O.\n     */\n    if (len > 0 && restart_edit != 0 && p[len - 1] == Ctrl_O)\n\tp[len - 1] = NUL;\n\n    return (p);\n}\n\n/*\n * Return the contents of the redo buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_inserted(void)\n{\n    return get_buffcont(&redobuff, FALSE);\n}\n\n/*\n * Add string \"s\" after the current block of buffer \"buf\".\n * K_SPECIAL and CSI should have been escaped already.\n */\n    static void\nadd_buff(\n    buffheader_T\t*buf,\n    char_u\t\t*s,\n    long\t\tslen)\t/* length of \"s\" or -1 */\n{\n    buffblock_T *p;\n    long_u\t    len;\n\n    if (slen < 0)\n\tslen = (long)STRLEN(s);\n    if (slen == 0)\t\t\t\t/* don't add empty strings */\n\treturn;\n\n    if (buf->bh_first.b_next == NULL)\t/* first add to list */\n    {\n\tbuf->bh_space = 0;\n\tbuf->bh_curr = &(buf->bh_first);\n    }\n    else if (buf->bh_curr == NULL)\t/* buffer has already been read */\n    {\n\tiemsg(_(\"E222: Add to read buffer\"));\n\treturn;\n    }\n    else if (buf->bh_index != 0)\n\tmch_memmove(buf->bh_first.b_next->b_str,\n\t\t    buf->bh_first.b_next->b_str + buf->bh_index,\n\t\t    STRLEN(buf->bh_first.b_next->b_str + buf->bh_index) + 1);\n    buf->bh_index = 0;\n\n    if (buf->bh_space >= (int)slen)\n    {\n\tlen = (long_u)STRLEN(buf->bh_curr->b_str);\n\tvim_strncpy(buf->bh_curr->b_str + len, s, (size_t)slen);\n\tbuf->bh_space -= slen;\n    }\n    else\n    {\n\tif (slen < MINIMAL_SIZE)\n\t    len = MINIMAL_SIZE;\n\telse\n\t    len = slen;\n\tp = (buffblock_T *)lalloc((long_u)(sizeof(buffblock_T) + len),\n\t\t\t\t\t\t\t\t\tTRUE);\n\tif (p == NULL)\n\t    return; /* no space, just forget it */\n\tbuf->bh_space = (int)(len - slen);\n\tvim_strncpy(p->b_str, s, (size_t)slen);\n\n\tp->b_next = buf->bh_curr->b_next;\n\tbuf->bh_curr->b_next = p;\n\tbuf->bh_curr = p;\n    }\n    return;\n}\n\n/*\n * Add number \"n\" to buffer \"buf\".\n */\n    static void\nadd_num_buff(buffheader_T *buf, long n)\n{\n    char_u\tnumber[32];\n\n    sprintf((char *)number, \"%ld\", n);\n    add_buff(buf, number, -1L);\n}\n\n/*\n * Add character 'c' to buffer \"buf\".\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    static void\nadd_char_buff(buffheader_T *buf, int c)\n{\n    char_u\tbytes[MB_MAXBYTES + 1];\n    int\t\tlen;\n    int\t\ti;\n    char_u\ttemp[4];\n\n    if (IS_SPECIAL(c))\n\tlen = 1;\n    else\n\tlen = (*mb_char2bytes)(c, bytes);\n    for (i = 0; i < len; ++i)\n    {\n\tif (!IS_SPECIAL(c))\n\t    c = bytes[i];\n\n\tif (IS_SPECIAL(c) || c == K_SPECIAL || c == NUL)\n\t{\n\t    /* translate special key code into three byte sequence */\n\t    temp[0] = K_SPECIAL;\n\t    temp[1] = K_SECOND(c);\n\t    temp[2] = K_THIRD(c);\n\t    temp[3] = NUL;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    /* Translate a CSI to a CSI - KS_EXTRA - KE_CSI sequence */\n\t    temp[0] = CSI;\n\t    temp[1] = KS_EXTRA;\n\t    temp[2] = (int)KE_CSI;\n\t    temp[3] = NUL;\n\t}\n#endif\n\telse\n\t{\n\t    temp[0] = c;\n\t    temp[1] = NUL;\n\t}\n\tadd_buff(buf, temp, -1L);\n    }\n}\n\n/* First read ahead buffer. Used for translated commands. */\nstatic buffheader_T readbuf1 = {{NULL, {NUL}}, NULL, 0, 0};\n\n/* Second read ahead buffer. Used for redo. */\nstatic buffheader_T readbuf2 = {{NULL, {NUL}}, NULL, 0, 0};\n\n/*\n * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2\n * if that one is empty.\n * If advance == TRUE go to the next char.\n * No translation is done K_SPECIAL and CSI are escaped.\n */\n    static int\nread_readbuffers(int advance)\n{\n    int c;\n\n    c = read_readbuf(&readbuf1, advance);\n    if (c == NUL)\n\tc = read_readbuf(&readbuf2, advance);\n    return c;\n}\n\n    static int\nread_readbuf(buffheader_T *buf, int advance)\n{\n    char_u\tc;\n    buffblock_T\t*curr;\n\n    if (buf->bh_first.b_next == NULL)  /* buffer is empty */\n\treturn NUL;\n\n    curr = buf->bh_first.b_next;\n    c = curr->b_str[buf->bh_index];\n\n    if (advance)\n    {\n\tif (curr->b_str[++buf->bh_index] == NUL)\n\t{\n\t    buf->bh_first.b_next = curr->b_next;\n\t    vim_free(curr);\n\t    buf->bh_index = 0;\n\t}\n    }\n    return c;\n}\n\n/*\n * Prepare the read buffers for reading (if they contain something).\n */\n    static void\nstart_stuff(void)\n{\n    if (readbuf1.bh_first.b_next != NULL)\n    {\n\treadbuf1.bh_curr = &(readbuf1.bh_first);\n\treadbuf1.bh_space = 0;\n    }\n    if (readbuf2.bh_first.b_next != NULL)\n    {\n\treadbuf2.bh_curr = &(readbuf2.bh_first);\n\treadbuf2.bh_space = 0;\n    }\n}\n\n/*\n * Return TRUE if the stuff buffer is empty.\n */\n    int\nstuff_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL\n\t && readbuf2.bh_first.b_next == NULL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if readbuf1 is empty.  There may still be redo characters in\n * redbuf2.\n */\n    int\nreadbuf1_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL);\n}\n#endif\n\n/*\n * Set a typeahead character that won't be flushed.\n */\n    void\ntypeahead_noflush(int c)\n{\n    typeahead_char = c;\n}\n\n/*\n * Remove the contents of the stuff buffer and the mapped characters in the\n * typeahead buffer (used in case of an error).  If \"flush_typeahead\" is true,\n * flush all typeahead characters (used when interrupted by a CTRL-C).\n */\n    void\nflush_buffers(flush_buffers_T flush_typeahead)\n{\n    init_typebuf();\n\n    start_stuff();\n    while (read_readbuffers(TRUE) != NUL)\n\t;\n\n    if (flush_typeahead == FLUSH_MINIMAL)\n    {\n\t// remove mapped characters at the start only\n\ttypebuf.tb_off += typebuf.tb_maplen;\n\ttypebuf.tb_len -= typebuf.tb_maplen;\n    }\n    else\n    {\n\t// remove typeahead\n\tif (flush_typeahead == FLUSH_INPUT)\n\t    // We have to get all characters, because we may delete the first\n\t    // part of an escape sequence.  In an xterm we get one char at a\n\t    // time and we have to get them all.\n\t    while (inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 10L) != 0)\n\t\t;\n\ttypebuf.tb_off = MAXMAPLEN;\n\ttypebuf.tb_len = 0;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t/* Reset the flag that text received from a client or from feedkeys()\n\t * was inserted in the typeahead buffer. */\n\ttypebuf_was_filled = FALSE;\n#endif\n    }\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    cmd_silent = FALSE;\n    typebuf.tb_no_abbr_cnt = 0;\n}\n\n/*\n * The previous contents of the redo buffer is kept in old_redobuffer.\n * This is used for the CTRL-O <.> command in insert mode.\n */\n    void\nResetRedobuff(void)\n{\n    if (!block_redo)\n    {\n\tfree_buff(&old_redobuff);\n\told_redobuff = redobuff;\n\tredobuff.bh_first.b_next = NULL;\n    }\n}\n\n/*\n * Discard the contents of the redo buffer and restore the previous redo\n * buffer.\n */\n    void\nCancelRedo(void)\n{\n    if (!block_redo)\n    {\n\tfree_buff(&redobuff);\n\tredobuff = old_redobuff;\n\told_redobuff.bh_first.b_next = NULL;\n\tstart_stuff();\n\twhile (read_readbuffers(TRUE) != NUL)\n\t    ;\n    }\n}\n\n/*\n * Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.\n * Used before executing autocommands and user functions.\n */\n    void\nsaveRedobuff(save_redo_T *save_redo)\n{\n    char_u\t*s;\n\n    save_redo->sr_redobuff = redobuff;\n    redobuff.bh_first.b_next = NULL;\n    save_redo->sr_old_redobuff = old_redobuff;\n    old_redobuff.bh_first.b_next = NULL;\n\n    /* Make a copy, so that \":normal .\" in a function works. */\n    s = get_buffcont(&save_redo->sr_redobuff, FALSE);\n    if (s != NULL)\n    {\n\tadd_buff(&redobuff, s, -1L);\n\tvim_free(s);\n    }\n}\n\n/*\n * Restore redobuff and old_redobuff from save_redobuff and save_old_redobuff.\n * Used after executing autocommands and user functions.\n */\n    void\nrestoreRedobuff(save_redo_T *save_redo)\n{\n    free_buff(&redobuff);\n    redobuff = save_redo->sr_redobuff;\n    free_buff(&old_redobuff);\n    old_redobuff = save_redo->sr_old_redobuff;\n}\n\n/*\n * Append \"s\" to the redo buffer.\n * K_SPECIAL and CSI should already have been escaped.\n */\n    void\nAppendToRedobuff(char_u *s)\n{\n    if (!block_redo)\n\tadd_buff(&redobuff, s, -1L);\n}\n\n/*\n * Append to Redo buffer literally, escaping special characters with CTRL-V.\n * K_SPECIAL and CSI are escaped as well.\n */\n    void\nAppendToRedobuffLit(\n    char_u\t*str,\n    int\t\tlen)\t    /* length of \"str\" or -1 for up to the NUL */\n{\n    char_u\t*s = str;\n    int\t\tc;\n    char_u\t*start;\n\n    if (block_redo)\n\treturn;\n\n    while (len < 0 ? *s != NUL : s - str < len)\n    {\n\t/* Put a string of normal characters in the redo buffer (that's\n\t * faster). */\n\tstart = s;\n\twhile (*s >= ' '\n#ifndef EBCDIC\n\t\t&& *s < DEL\t/* EBCDIC: all chars above space are normal */\n#endif\n\t\t&& (len < 0 || s - str < len))\n\t    ++s;\n\n\t/* Don't put '0' or '^' as last character, just in case a CTRL-D is\n\t * typed next. */\n\tif (*s == NUL && (s[-1] == '0' || s[-1] == '^'))\n\t    --s;\n\tif (s > start)\n\t    add_buff(&redobuff, start, (long)(s - start));\n\n\tif (*s == NUL || (len >= 0 && s - str >= len))\n\t    break;\n\n\t/* Handle a special or multibyte character. */\n\tif (has_mbyte)\n\t    /* Handle composing chars separately. */\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\tif (c < ' ' || c == DEL || (*s == NUL && (c == '0' || c == '^')))\n\t    add_char_buff(&redobuff, Ctrl_V);\n\n\t/* CTRL-V '0' must be inserted as CTRL-V 048 (EBCDIC: xf0) */\n\tif (*s == NUL && c == '0')\n#ifdef EBCDIC\n\t    add_buff(&redobuff, (char_u *)\"xf0\", 3L);\n#else\n\t    add_buff(&redobuff, (char_u *)\"048\", 3L);\n#endif\n\telse\n\t    add_char_buff(&redobuff, c);\n    }\n}\n\n/*\n * Append a character to the redo buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nAppendCharToRedobuff(int c)\n{\n    if (!block_redo)\n\tadd_char_buff(&redobuff, c);\n}\n\n/*\n * Append a number to the redo buffer.\n */\n    void\nAppendNumberToRedobuff(long n)\n{\n    if (!block_redo)\n\tadd_num_buff(&redobuff, n);\n}\n\n/*\n * Append string \"s\" to the stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffReadbuff(char_u *s)\n{\n    add_buff(&readbuf1, s, -1L);\n}\n\n/*\n * Append string \"s\" to the redo stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffRedoReadbuff(char_u *s)\n{\n    add_buff(&readbuf2, s, -1L);\n}\n\n    void\nstuffReadbuffLen(char_u *s, long len)\n{\n    add_buff(&readbuf1, s, len);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Stuff \"s\" into the stuff buffer, leaving special key codes unmodified and\n * escaping other K_SPECIAL and CSI bytes.\n * Change CR, LF and ESC into a space.\n */\n    void\nstuffReadbuffSpec(char_u *s)\n{\n    int c;\n\n    while (*s != NUL)\n    {\n\tif (*s == K_SPECIAL && s[1] != NUL && s[2] != NUL)\n\t{\n\t    /* Insert special key literally. */\n\t    stuffReadbuffLen(s, 3L);\n\t    s += 3;\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char_adv(&s);\n\t    if (c == CAR || c == NL || c == ESC)\n\t\tc = ' ';\n\t    stuffcharReadbuff(c);\n\t}\n    }\n}\n#endif\n\n/*\n * Append a character to the stuff buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nstuffcharReadbuff(int c)\n{\n    add_char_buff(&readbuf1, c);\n}\n\n/*\n * Append a number to the stuff buffer.\n */\n    void\nstuffnumReadbuff(long n)\n{\n    add_num_buff(&readbuf1, n);\n}\n\n/*\n * Read a character from the redo buffer.  Translates K_SPECIAL, CSI and\n * multibyte characters.\n * The redo buffer is left as it is.\n * If init is TRUE, prepare for redo, return FAIL if nothing to redo, OK\n * otherwise.\n * If old is TRUE, use old_redobuff instead of redobuff.\n */\n    static int\nread_redo(int init, int old_redo)\n{\n    static buffblock_T\t*bp;\n    static char_u\t*p;\n    int\t\t\tc;\n    int\t\t\tn;\n    char_u\t\tbuf[MB_MAXBYTES + 1];\n    int\t\t\ti;\n\n    if (init)\n    {\n\tif (old_redo)\n\t    bp = old_redobuff.bh_first.b_next;\n\telse\n\t    bp = redobuff.bh_first.b_next;\n\tif (bp == NULL)\n\t    return FAIL;\n\tp = bp->b_str;\n\treturn OK;\n    }\n    if ((c = *p) != NUL)\n    {\n\t/* Reverse the conversion done by add_char_buff() */\n\t/* For a multi-byte character get all the bytes and return the\n\t * converted character. */\n\tif (has_mbyte && (c != K_SPECIAL || p[1] == KS_SPECIAL))\n\t    n = MB_BYTE2LEN_CHECK(c);\n\telse\n\t    n = 1;\n\tfor (i = 0; ; ++i)\n\t{\n\t    if (c == K_SPECIAL) /* special key or escaped K_SPECIAL */\n\t    {\n\t\tc = TO_SPECIAL(p[1], p[2]);\n\t\tp += 2;\n\t    }\n#ifdef FEAT_GUI\n\t    if (c == CSI)\t/* escaped CSI */\n\t\tp += 2;\n#endif\n\t    if (*++p == NUL && bp->b_next != NULL)\n\t    {\n\t\tbp = bp->b_next;\n\t\tp = bp->b_str;\n\t    }\n\t    buf[i] = c;\n\t    if (i == n - 1)\t/* last byte of a character */\n\t    {\n\t\tif (n != 1)\n\t\t    c = (*mb_ptr2char)(buf);\n\t\tbreak;\n\t    }\n\t    c = *p;\n\t    if (c == NUL)\t/* cannot happen? */\n\t\tbreak;\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Copy the rest of the redo buffer into the stuff buffer (in a slow way).\n * If old_redo is TRUE, use old_redobuff instead of redobuff.\n * The escaped K_SPECIAL and CSI are copied without translation.\n */\n    static void\ncopy_redo(int old_redo)\n{\n    int\t    c;\n\n    while ((c = read_redo(FALSE, old_redo)) != NUL)\n\tadd_char_buff(&readbuf2, c);\n}\n\n/*\n * Stuff the redo buffer into readbuf2.\n * Insert the redo count into the command.\n * If \"old_redo\" is TRUE, the last but one command is repeated\n * instead of the last command (inserting text). This is used for\n * CTRL-O <.> in insert mode\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo(long count, int old_redo)\n{\n    int\t    c;\n\n    /* init the pointers; return if nothing to redo */\n    if (read_redo(TRUE, old_redo) == FAIL)\n\treturn FAIL;\n\n    c = read_redo(FALSE, old_redo);\n\n    /* copy the buffer name, if present */\n    if (c == '\"')\n    {\n\tadd_buff(&readbuf2, (char_u *)\"\\\"\", 1L);\n\tc = read_redo(FALSE, old_redo);\n\n\t/* if a numbered buffer is used, increment the number */\n\tif (c >= '1' && c < '9')\n\t    ++c;\n\tadd_char_buff(&readbuf2, c);\n\n\t/* the expression register should be re-evaluated */\n\tif (c == '=')\n\t{\n\t    add_char_buff(&readbuf2, CAR);\n\t    cmd_silent = TRUE;\n\t}\n\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    if (c == 'v')   /* redo Visual */\n    {\n\tVIsual = curwin->w_cursor;\n\tVIsual_active = TRUE;\n\tVIsual_select = FALSE;\n\tVIsual_reselect = TRUE;\n\tredo_VIsual_busy = TRUE;\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    /* try to enter the count (in place of a previous count) */\n    if (count)\n    {\n\twhile (VIM_ISDIGIT(c))\t/* skip \"old\" count */\n\t    c = read_redo(FALSE, old_redo);\n\tadd_num_buff(&readbuf2, count);\n    }\n\n    /* copy from the redo buffer into the stuff buffer */\n    add_char_buff(&readbuf2, c);\n    copy_redo(old_redo);\n    return OK;\n}\n\n/*\n * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing\n * the redo buffer into readbuf2.\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo_ins(void)\n{\n    int\t    c;\n\n    if (read_redo(TRUE, FALSE) == FAIL)\n\treturn FAIL;\n    start_stuff();\n\n    /* skip the count and the command character */\n    while ((c = read_redo(FALSE, FALSE)) != NUL)\n    {\n\tif (vim_strchr((char_u *)\"AaIiRrOo\", c) != NULL)\n\t{\n\t    if (c == 'O' || c == 'o')\n\t\tadd_buff(&readbuf2, NL_STR, -1L);\n\t    break;\n\t}\n    }\n\n    /* copy the typed text from the redo buffer into the stuff buffer */\n    copy_redo(FALSE);\n    block_redo = TRUE;\n    return OK;\n}\n\n    void\nstop_redo_ins(void)\n{\n    block_redo = FALSE;\n}\n\n/*\n * Initialize typebuf.tb_buf to point to typebuf_init.\n * alloc() cannot be used here: In out-of-memory situations it would\n * be impossible to type anything.\n */\n    static void\ninit_typebuf(void)\n{\n    if (typebuf.tb_buf == NULL)\n    {\n\ttypebuf.tb_buf = typebuf_init;\n\ttypebuf.tb_noremap = noremapbuf_init;\n\ttypebuf.tb_buflen = TYPELEN_INIT;\n\ttypebuf.tb_len = 0;\n\ttypebuf.tb_off = MAXMAPLEN + 4;\n\ttypebuf.tb_change_cnt = 1;\n    }\n}\n\n/*\n * Insert a string in position 'offset' in the typeahead buffer (for \"@r\"\n * and \":normal\" command, vgetorpeek() and check_termcode()).\n *\n * If noremap is REMAP_YES, new string can be mapped again.\n * If noremap is REMAP_NONE, new string cannot be mapped again.\n * If noremap is REMAP_SKIP, fist char of new string cannot be mapped again,\n * but abbreviations are allowed.\n * If noremap is REMAP_SCRIPT, new string cannot be mapped again, except for\n *\t\t\tscript-local mappings.\n * If noremap is > 0, that many characters of the new string cannot be mapped.\n *\n * If nottyped is TRUE, the string does not return KeyTyped (don't use when\n * offset is non-zero!).\n *\n * If silent is TRUE, cmd_silent is set when the characters are obtained.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nins_typebuf(\n    char_u\t*str,\n    int\t\tnoremap,\n    int\t\toffset,\n    int\t\tnottyped,\n    int\t\tsilent)\n{\n    char_u\t*s1, *s2;\n    int\t\tnewlen;\n    int\t\taddlen;\n    int\t\ti;\n    int\t\tnewoff;\n    int\t\tval;\n    int\t\tnrm;\n\n    init_typebuf();\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n\n    addlen = (int)STRLEN(str);\n\n    if (offset == 0 && addlen <= typebuf.tb_off)\n    {\n\t/*\n\t * Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]\n\t */\n\ttypebuf.tb_off -= addlen;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else if (typebuf.tb_len == 0 && typebuf.tb_buflen\n\t\t\t\t\t       >= addlen + 3 * (MAXMAPLEN + 4))\n    {\n\t/*\n\t * Buffer is empty and string fits in the existing buffer.\n\t * Leave some space before and after, if possible.\n\t */\n\ttypebuf.tb_off = (typebuf.tb_buflen - addlen - 3 * (MAXMAPLEN + 4)) / 2;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else\n    {\n\t/*\n\t * Need to allocate a new buffer.\n\t * In typebuf.tb_buf there must always be room for 3 * (MAXMAPLEN + 4)\n\t * characters.  We add some extra room to avoid having to allocate too\n\t * often.\n\t */\n\tnewoff = MAXMAPLEN + 4;\n\tnewlen = typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);\n\tif (newlen < 0)\t\t    /* string is getting too long */\n\t{\n\t    emsg(_(e_toocompl));    /* also calls flush_buffers */\n\t    setcursor();\n\t    return FAIL;\n\t}\n\ts1 = alloc(newlen);\n\tif (s1 == NULL)\t\t    /* out of memory */\n\t    return FAIL;\n\ts2 = alloc(newlen);\n\tif (s2 == NULL)\t\t    /* out of memory */\n\t{\n\t    vim_free(s1);\n\t    return FAIL;\n\t}\n\ttypebuf.tb_buflen = newlen;\n\n\t/* copy the old chars, before the insertion point */\n\tmch_memmove(s1 + newoff, typebuf.tb_buf + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\t/* copy the new chars */\n\tmch_memmove(s1 + newoff + offset, str, (size_t)addlen);\n\t/* copy the old chars, after the insertion point, including the\tNUL at\n\t * the end */\n\tmch_memmove(s1 + newoff + offset + addlen,\n\t\t\t\t     typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\tif (typebuf.tb_buf != typebuf_init)\n\t    vim_free(typebuf.tb_buf);\n\ttypebuf.tb_buf = s1;\n\n\tmch_memmove(s2 + newoff, typebuf.tb_noremap + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\tmch_memmove(s2 + newoff + offset + addlen,\n\t\t   typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n\tif (typebuf.tb_noremap != noremapbuf_init)\n\t    vim_free(typebuf.tb_noremap);\n\ttypebuf.tb_noremap = s2;\n\n\ttypebuf.tb_off = newoff;\n    }\n    typebuf.tb_len += addlen;\n\n    /* If noremap == REMAP_SCRIPT: do remap script-local mappings. */\n    if (noremap == REMAP_SCRIPT)\n\tval = RM_SCRIPT;\n    else if (noremap == REMAP_SKIP)\n\tval = RM_ABBR;\n    else\n\tval = RM_NONE;\n\n    /*\n     * Adjust typebuf.tb_noremap[] for the new characters:\n     * If noremap == REMAP_NONE or REMAP_SCRIPT: new characters are\n     *\t\t\t(sometimes) not remappable\n     * If noremap == REMAP_YES: all the new characters are mappable\n     * If noremap  > 0: \"noremap\" characters are not remappable, the rest\n     *\t\t\tmappable\n     */\n    if (noremap == REMAP_SKIP)\n\tnrm = 1;\n    else if (noremap < 0)\n\tnrm = addlen;\n    else\n\tnrm = noremap;\n    for (i = 0; i < addlen; ++i)\n\ttypebuf.tb_noremap[typebuf.tb_off + i + offset] =\n\t\t\t\t\t\t  (--nrm >= 0) ? val : RM_YES;\n\n    /* tb_maplen and tb_silent only remember the length of mapped and/or\n     * silent mappings at the start of the buffer, assuming that a mapped\n     * sequence doesn't result in typed characters. */\n    if (nottyped || typebuf.tb_maplen > offset)\n\ttypebuf.tb_maplen += addlen;\n    if (silent || typebuf.tb_silent > offset)\n    {\n\ttypebuf.tb_silent += addlen;\n\tcmd_silent = TRUE;\n    }\n    if (typebuf.tb_no_abbr_cnt && offset == 0)\t/* and not used for abbrev.s */\n\ttypebuf.tb_no_abbr_cnt += addlen;\n\n    return OK;\n}\n\n/*\n * Put character \"c\" back into the typeahead buffer.\n * Can be used for a character obtained by vgetc() that needs to be put back.\n * Uses cmd_silent, KeyTyped and KeyNoremap to restore the flags belonging to\n * the char.\n */\n    void\nins_char_typebuf(int c)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    (void)ins_typebuf(buf, KeyNoremap, 0, !KeyTyped, cmd_silent);\n}\n\n/*\n * Return TRUE if the typeahead buffer was changed (while waiting for a\n * character to arrive).  Happens when a message was received from a client or\n * from feedkeys().\n * But check in a more generic way to avoid trouble: When \"typebuf.tb_buf\"\n * changed it was reallocated and the old pointer can no longer be used.\n * Or \"typebuf.tb_off\" may have been changed and we would overwrite characters\n * that was just added.\n */\n    int\ntypebuf_changed(\n    int\t\ttb_change_cnt)\t/* old value of typebuf.tb_change_cnt */\n{\n    return (tb_change_cnt != 0 && (typebuf.tb_change_cnt != tb_change_cnt\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n#endif\n\t   ));\n}\n\n/*\n * Return TRUE if there are no characters in the typeahead buffer that have\n * not been typed (result from a mapping or come from \":normal\").\n */\n    int\ntypebuf_typed(void)\n{\n    return typebuf.tb_maplen == 0;\n}\n\n/*\n * Return the number of characters that are mapped (or not typed).\n */\n    int\ntypebuf_maplen(void)\n{\n    return typebuf.tb_maplen;\n}\n\n/*\n * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]\n */\n    void\ndel_typebuf(int len, int offset)\n{\n    int\t    i;\n\n    if (len == 0)\n\treturn;\t\t/* nothing to do */\n\n    typebuf.tb_len -= len;\n\n    /*\n     * Easy case: Just increase typebuf.tb_off.\n     */\n    if (offset == 0 && typebuf.tb_buflen - (typebuf.tb_off + len)\n\t\t\t\t\t\t\t >= 3 * MAXMAPLEN + 3)\n\ttypebuf.tb_off += len;\n    /*\n     * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]\n     */\n    else\n    {\n\ti = typebuf.tb_off + offset;\n\t/*\n\t * Leave some extra room at the end to avoid reallocation.\n\t */\n\tif (typebuf.tb_off > MAXMAPLEN)\n\t{\n\t    mch_memmove(typebuf.tb_buf + MAXMAPLEN,\n\t\t\t     typebuf.tb_buf + typebuf.tb_off, (size_t)offset);\n\t    mch_memmove(typebuf.tb_noremap + MAXMAPLEN,\n\t\t\t typebuf.tb_noremap + typebuf.tb_off, (size_t)offset);\n\t    typebuf.tb_off = MAXMAPLEN;\n\t}\n\t/* adjust typebuf.tb_buf (include the NUL at the end) */\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t\t\t     typebuf.tb_buf + i + len,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\t/* adjust typebuf.tb_noremap[] */\n\tmch_memmove(typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t\t typebuf.tb_noremap + i + len,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n    }\n\n    if (typebuf.tb_maplen > offset)\t\t/* adjust tb_maplen */\n    {\n\tif (typebuf.tb_maplen < offset + len)\n\t    typebuf.tb_maplen = offset;\n\telse\n\t    typebuf.tb_maplen -= len;\n    }\n    if (typebuf.tb_silent > offset)\t\t/* adjust tb_silent */\n    {\n\tif (typebuf.tb_silent < offset + len)\n\t    typebuf.tb_silent = offset;\n\telse\n\t    typebuf.tb_silent -= len;\n    }\n    if (typebuf.tb_no_abbr_cnt > offset)\t/* adjust tb_no_abbr_cnt */\n    {\n\tif (typebuf.tb_no_abbr_cnt < offset + len)\n\t    typebuf.tb_no_abbr_cnt = offset;\n\telse\n\t    typebuf.tb_no_abbr_cnt -= len;\n    }\n\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n    /* Reset the flag that text received from a client or from feedkeys()\n     * was inserted in the typeahead buffer. */\n    typebuf_was_filled = FALSE;\n#endif\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n}\n\n/*\n * Write typed characters to script file.\n * If recording is on put the character in the recordbuffer.\n */\n    static void\ngotchars(char_u *chars, int len)\n{\n    char_u\t\t*s = chars;\n    int\t\t\ti;\n    static char_u\tbuf[4];\n    static int\t\tbuflen = 0;\n    int\t\t\ttodo = len;\n\n    while (todo--)\n    {\n\tbuf[buflen++] = *s++;\n\n\t// When receiving a special key sequence, store it until we have all\n\t// the bytes and we can decide what to do with it.\n\tif (buflen == 1 && buf[0] == K_SPECIAL)\n\t    continue;\n\tif (buflen == 2)\n\t    continue;\n\tif (buflen == 3 && buf[1] == KS_EXTRA\n\t\t       && (buf[2] == KE_FOCUSGAINED || buf[2] == KE_FOCUSLOST))\n\t{\n\t    // Drop K_FOCUSGAINED and K_FOCUSLOST, they are not useful in a\n\t    // recording.\n\t    buflen = 0;\n\t    continue;\n\t}\n\n\t/* Handle one byte at a time; no translation to be done. */\n\tfor (i = 0; i < buflen; ++i)\n\t    updatescript(buf[i]);\n\n\tif (reg_recording != 0)\n\t{\n\t    buf[buflen] = NUL;\n\t    add_buff(&recordbuff, buf, (long)buflen);\n\t    /* remember how many chars were last recorded */\n\t    last_recorded_len += buflen;\n\t}\n\tbuflen = 0;\n    }\n    may_sync_undo();\n\n#ifdef FEAT_EVAL\n    /* output \"debug mode\" message next time in debug mode */\n    debug_did_msg = FALSE;\n#endif\n\n    /* Since characters have been typed, consider the following to be in\n     * another mapping.  Search string will be kept in history. */\n    ++maptick;\n}\n\n/*\n * Sync undo.  Called when typed characters are obtained from the typeahead\n * buffer, or when a menu is used.\n * Do not sync:\n * - In Insert mode, unless cursor key has been used.\n * - While reading a script file.\n * - When no_u_sync is non-zero.\n */\n    static void\nmay_sync_undo(void)\n{\n    if ((!(State & (INSERT + CMDLINE)) || arrow_used)\n\t\t\t\t\t       && scriptin[curscript] == NULL)\n\tu_sync(FALSE);\n}\n\n/*\n * Make \"typebuf\" empty and allocate new buffers.\n * Returns FAIL when out of memory.\n */\n    int\nalloc_typebuf(void)\n{\n    typebuf.tb_buf = alloc(TYPELEN_INIT);\n    typebuf.tb_noremap = alloc(TYPELEN_INIT);\n    if (typebuf.tb_buf == NULL || typebuf.tb_noremap == NULL)\n    {\n\tfree_typebuf();\n\treturn FAIL;\n    }\n    typebuf.tb_buflen = TYPELEN_INIT;\n    typebuf.tb_off = MAXMAPLEN + 4;  /* can insert without realloc */\n    typebuf.tb_len = 0;\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    typebuf.tb_no_abbr_cnt = 0;\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n    return OK;\n}\n\n/*\n * Free the buffers of \"typebuf\".\n */\n    void\nfree_typebuf(void)\n{\n    if (typebuf.tb_buf == typebuf_init)\n\tinternal_error(\"Free typebuf 1\");\n    else\n\tvim_free(typebuf.tb_buf);\n    if (typebuf.tb_noremap == noremapbuf_init)\n\tinternal_error(\"Free typebuf 2\");\n    else\n\tvim_free(typebuf.tb_noremap);\n}\n\n/*\n * When doing \":so! file\", the current typeahead needs to be saved, and\n * restored when \"file\" has been read completely.\n */\nstatic typebuf_T saved_typebuf[NSCRIPT];\n\n    int\nsave_typebuf(void)\n{\n    init_typebuf();\n    saved_typebuf[curscript] = typebuf;\n    /* If out of memory: restore typebuf and close file. */\n    if (alloc_typebuf() == FAIL)\n    {\n\tclosescript();\n\treturn FAIL;\n    }\n    return OK;\n}\n\nstatic int old_char = -1;\t/* character put back by vungetc() */\nstatic int old_mod_mask;\t/* mod_mask for ungotten character */\n#ifdef FEAT_MOUSE\nstatic int old_mouse_row;\t/* mouse_row related to old_char */\nstatic int old_mouse_col;\t/* mouse_col related to old_char */\n#endif\n\n/*\n * Save all three kinds of typeahead, so that the user must type at a prompt.\n */\n    void\nsave_typeahead(tasave_T *tp)\n{\n    tp->save_typebuf = typebuf;\n    tp->typebuf_valid = (alloc_typebuf() == OK);\n    if (!tp->typebuf_valid)\n\ttypebuf = tp->save_typebuf;\n\n    tp->old_char = old_char;\n    tp->old_mod_mask = old_mod_mask;\n    old_char = -1;\n\n    tp->save_readbuf1 = readbuf1;\n    readbuf1.bh_first.b_next = NULL;\n    tp->save_readbuf2 = readbuf2;\n    readbuf2.bh_first.b_next = NULL;\n# ifdef USE_INPUT_BUF\n    tp->save_inputbuf = get_input_buf();\n# endif\n}\n\n/*\n * Restore the typeahead to what it was before calling save_typeahead().\n * The allocated memory is freed, can only be called once!\n */\n    void\nrestore_typeahead(tasave_T *tp)\n{\n    if (tp->typebuf_valid)\n    {\n\tfree_typebuf();\n\ttypebuf = tp->save_typebuf;\n    }\n\n    old_char = tp->old_char;\n    old_mod_mask = tp->old_mod_mask;\n\n    free_buff(&readbuf1);\n    readbuf1 = tp->save_readbuf1;\n    free_buff(&readbuf2);\n    readbuf2 = tp->save_readbuf2;\n# ifdef USE_INPUT_BUF\n    set_input_buf(tp->save_inputbuf);\n# endif\n}\n\n/*\n * Open a new script file for the \":source!\" command.\n */\n    void\nopenscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n\n    // Disallow sourcing a file in the sandbox, the commands would be executed\n    // later, possibly outside of the sandbox.\n    if (check_secure())\n\treturn;\n\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}\n\n/*\n * Close the currently active input script.\n */\n    static void\nclosescript(void)\n{\n    free_typebuf();\n    typebuf = saved_typebuf[curscript];\n\n    fclose(scriptin[curscript]);\n    scriptin[curscript] = NULL;\n    if (curscript > 0)\n\t--curscript;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclose_all_scripts(void)\n{\n    while (scriptin[0] != NULL)\n\tclosescript();\n}\n#endif\n\n#if defined(FEAT_INS_EXPAND) || defined(PROTO)\n/*\n * Return TRUE when reading keys from a script file.\n */\n    int\nusing_script(void)\n{\n    return scriptin[curscript] != NULL;\n}\n#endif\n\n/*\n * This function is called just before doing a blocking wait.  Thus after\n * waiting 'updatetime' for a character to arrive.\n */\n    void\nbefore_blocking(void)\n{\n    updatescript(0);\n#ifdef FEAT_EVAL\n    if (may_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n}\n\n/*\n * updatescipt() is called when a character can be written into the script file\n * or when we have waited some time for a character (c == 0)\n *\n * All the changed memfiles are synced if c == 0 or when the number of typed\n * characters reaches 'updatecount' and 'updatecount' is non-zero.\n */\n    void\nupdatescript(int c)\n{\n    static int\t    count = 0;\n\n    if (c && scriptout)\n\tputc(c, scriptout);\n    if (c == 0 || (p_uc > 0 && ++count >= p_uc))\n    {\n\tml_sync_all(c == 0, TRUE);\n\tcount = 0;\n    }\n}\n\n/*\n * Get the next input character.\n * Can return a special key or a multi-byte character.\n * Can return NUL when called recursively, use safe_vgetc() if that's not\n * wanted.\n * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.\n * Collects the bytes of a multibyte character into the whole character.\n * Returns the modifiers in the global \"mod_mask\".\n */\n    int\nvgetc(void)\n{\n    int\t\tc, c2;\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n\n#ifdef FEAT_EVAL\n    /* Do garbage collection when garbagecollect() was called previously and\n     * we are now at the toplevel. */\n    if (may_garbage_collect && want_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n\n    /*\n     * If a character was put back with vungetc, it was already processed.\n     * Return it directly.\n     */\n    if (old_char != -1)\n    {\n\tc = old_char;\n\told_char = -1;\n\tmod_mask = old_mod_mask;\n#ifdef FEAT_MOUSE\n\tmouse_row = old_mouse_row;\n\tmouse_col = old_mouse_col;\n#endif\n    }\n    else\n    {\n\tmod_mask = 0x0;\n\tlast_recorded_len = 0;\n\tfor (;;)\t\t// this is done twice if there are modifiers\n\t{\n\t    int did_inc = FALSE;\n\n\t    if (mod_mask\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t\t    || im_is_preediting()\n#endif\n\t\t    )\n\t    {\n\t\t// no mapping after modifier has been read\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\tdid_inc = TRUE;\t// mod_mask may change value\n\t    }\n\t    c = vgetorpeek(TRUE);\n\t    if (did_inc)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\n\t    // Get two extra bytes for special keys\n\t    if (c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t    || (gui.in_use && c == CSI)\n#endif\n\t       )\n\t    {\n\t\tint\t    save_allow_keys = allow_keys;\n\n\t\t++no_mapping;\n\t\tallow_keys = 0;\t\t// make sure BS is not found\n\t\tc2 = vgetorpeek(TRUE);\t// no mapping for these chars\n\t\tc = vgetorpeek(TRUE);\n\t\t--no_mapping;\n\t\tallow_keys = save_allow_keys;\n\t\tif (c2 == KS_MODIFIER)\n\t\t{\n\t\t    mod_mask = c;\n\t\t    continue;\n\t\t}\n\t\tc = TO_SPECIAL(c2, c);\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n\t\t// Handle K_TEAROFF here, the caller of vgetc() doesn't need to\n\t\t// know that a menu was torn off\n\t\tif (\n# ifdef VIMDLL\n\t\t    gui.in_use &&\n# endif\n\t\t    c == K_TEAROFF)\n\t\t{\n\t\t    char_u\tname[200];\n\t\t    int\t\ti;\n\n\t\t    // get menu path, it ends with a <CR>\n\t\t    for (i = 0; (c = vgetorpeek(TRUE)) != '\\r'; )\n\t\t    {\n\t\t\tname[i] = c;\n\t\t\tif (i < 199)\n\t\t\t    ++i;\n\t\t    }\n\t\t    name[i] = NUL;\n\t\t    gui_make_tearoff(name);\n\t\t    continue;\n\t\t}\n#endif\n#if defined(FEAT_GUI) && defined(FEAT_GUI_GTK) && defined(FEAT_MENU)\n\t\t// GTK: <F10> normally selects the menu, but it's passed until\n\t\t// here to allow mapping it.  Intercept and invoke the GTK\n\t\t// behavior if it's not mapped.\n\t\tif (c == K_F10 && gui.menubar != NULL)\n\t\t{\n\t\t    gtk_menu_shell_select_first(\n\t\t\t\t\t   GTK_MENU_SHELL(gui.menubar), FALSE);\n\t\t    continue;\n\t\t}\n#endif\n#ifdef FEAT_GUI\n\t\tif (gui.in_use)\n\t\t{\n\t\t    // Handle focus event here, so that the caller doesn't\n\t\t    // need to know about it.  Return K_IGNORE so that we loop\n\t\t    // once (needed if 'lazyredraw' is set).\n\t\t    if (c == K_FOCUSGAINED || c == K_FOCUSLOST)\n\t\t    {\n\t\t\tui_focus_change(c == K_FOCUSGAINED);\n\t\t\tc = K_IGNORE;\n\t\t    }\n\n\t\t    // Translate K_CSI to CSI.  The special key is only used\n\t\t    // to avoid it being recognized as the start of a special\n\t\t    // key.\n\t\t    if (c == K_CSI)\n\t\t\tc = CSI;\n\t\t}\n#endif\n\t    }\n\t    // a keypad or special function key was not mapped, use it like\n\t    // its ASCII equivalent\n\t    switch (c)\n\t    {\n\t\tcase K_KPLUS:\tc = '+'; break;\n\t\tcase K_KMINUS:\tc = '-'; break;\n\t\tcase K_KDIVIDE:\tc = '/'; break;\n\t\tcase K_KMULTIPLY: c = '*'; break;\n\t\tcase K_KENTER:\tc = CAR; break;\n\t\tcase K_KPOINT:\n#ifdef MSWIN\n\t\t\t\t// Can be either '.' or a ',',\n\t\t\t\t// depending on the type of keypad.\n\t\t\t\tc = MapVirtualKey(VK_DECIMAL, 2); break;\n#else\n\t\t\t\tc = '.'; break;\n#endif\n\t\tcase K_K0:\tc = '0'; break;\n\t\tcase K_K1:\tc = '1'; break;\n\t\tcase K_K2:\tc = '2'; break;\n\t\tcase K_K3:\tc = '3'; break;\n\t\tcase K_K4:\tc = '4'; break;\n\t\tcase K_K5:\tc = '5'; break;\n\t\tcase K_K6:\tc = '6'; break;\n\t\tcase K_K7:\tc = '7'; break;\n\t\tcase K_K8:\tc = '8'; break;\n\t\tcase K_K9:\tc = '9'; break;\n\n\t\tcase K_XHOME:\n\t\tcase K_ZHOME:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_HOME;\n\t\t\t\tbreak;\n\t\tcase K_XEND:\n\t\tcase K_ZEND:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_END;\n\t\t\t\tbreak;\n\n\t\tcase K_XUP:\tc = K_UP; break;\n\t\tcase K_XDOWN:\tc = K_DOWN; break;\n\t\tcase K_XLEFT:\tc = K_LEFT; break;\n\t\tcase K_XRIGHT:\tc = K_RIGHT; break;\n\t    }\n\n\t    // For a multi-byte character get all the bytes and return the\n\t    // converted character.\n\t    // Note: This will loop until enough bytes are received!\n\t    if (has_mbyte && (n = MB_BYTE2LEN_CHECK(c)) > 1)\n\t    {\n\t\t++no_mapping;\n\t\tbuf[0] = c;\n\t\tfor (i = 1; i < n; ++i)\n\t\t{\n\t\t    buf[i] = vgetorpeek(TRUE);\n\t\t    if (buf[i] == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t\t    || (\n# ifdef VIMDLL\n\t\t\t\tgui.in_use &&\n# endif\n\t\t\t\tbuf[i] == CSI)\n#endif\n\t\t\t    )\n\t\t    {\n\t\t\t// Must be a K_SPECIAL - KS_SPECIAL - KE_FILLER\n\t\t\t// sequence, which represents a K_SPECIAL (0x80),\n\t\t\t// or a CSI - KS_EXTRA - KE_CSI sequence, which\n\t\t\t// represents a CSI (0x9B),\n\t\t\t// or a K_SPECIAL - KS_EXTRA - KE_CSI, which is CSI\n\t\t\t// too.\n\t\t\tc = vgetorpeek(TRUE);\n\t\t\tif (vgetorpeek(TRUE) == (int)KE_CSI && c == KS_EXTRA)\n\t\t\t    buf[i] = CSI;\n\t\t    }\n\t\t}\n\t\t--no_mapping;\n\t\tc = (*mb_ptr2char)(buf);\n\t    }\n\n\t    break;\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * In the main loop \"may_garbage_collect\" can be set to do garbage\n     * collection in the first next vgetc().  It's disabled after that to\n     * avoid internally used Lists and Dicts to be freed.\n     */\n    may_garbage_collect = FALSE;\n#endif\n#ifdef FEAT_BEVAL_TERM\n    if (c != K_MOUSEMOVE && c != K_IGNORE)\n    {\n\t/* Don't trigger 'balloonexpr' unless only the mouse was moved. */\n\tbevalexpr_due_set = FALSE;\n\tui_remove_balloon();\n    }\n#endif\n\n    return c;\n}\n\n/*\n * Like vgetc(), but never return a NUL when called recursively, get a key\n * directly from the user (ignoring typeahead).\n */\n    int\nsafe_vgetc(void)\n{\n    int\tc;\n\n    c = vgetc();\n    if (c == NUL)\n\tc = get_keystroke();\n    return c;\n}\n\n/*\n * Like safe_vgetc(), but loop to handle K_IGNORE.\n * Also ignore scrollbar events.\n */\n    int\nplain_vgetc(void)\n{\n    int c;\n\n    do\n\tc = safe_vgetc();\n    while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\n    if (c == K_PS)\n\t/* Only handle the first pasted character.  Drop the rest, since we\n\t * don't know what to do with it. */\n\tc = bracketed_paste(PASTE_ONE_CHAR, FALSE, NULL);\n\n    return c;\n}\n\n/*\n * Check if a character is available, such that vgetc() will not block.\n * If the next character is a special character or multi-byte, the returned\n * character is not valid!.\n * Returns NUL if no character is available.\n */\n    int\nvpeekc(void)\n{\n    if (old_char != -1)\n\treturn old_char;\n    return vgetorpeek(FALSE);\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Like vpeekc(), but don't allow mapping.  Do allow checking for terminal\n * codes.\n */\n    int\nvpeekc_nomap(void)\n{\n    int\t\tc;\n\n    ++no_mapping;\n    ++allow_keys;\n    c = vpeekc();\n    --no_mapping;\n    --allow_keys;\n    return c;\n}\n#endif\n\n#if defined(FEAT_INS_EXPAND) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Check if any character is available, also half an escape sequence.\n * Trick: when no typeahead found, but there is something in the typeahead\n * buffer, it must be an ESC that is recognized as the start of a key code.\n */\n    int\nvpeekc_any(void)\n{\n    int\t\tc;\n\n    c = vpeekc();\n    if (c == NUL && typebuf.tb_len > 0)\n\tc = ESC;\n    return c;\n}\n#endif\n\n/*\n * Call vpeekc() without causing anything to be mapped.\n * Return TRUE if a character is available, FALSE otherwise.\n */\n    int\nchar_avail(void)\n{\n    int\t    retval;\n\n#ifdef FEAT_EVAL\n    /* When test_override(\"char_avail\", 1) was called pretend there is no\n     * typeahead. */\n    if (disable_char_avail_for_testing)\n\treturn FALSE;\n#endif\n    ++no_mapping;\n    retval = vpeekc();\n    --no_mapping;\n    return (retval != NUL);\n}\n\n/*\n * unget one character (can only be done once!)\n */\n    void\nvungetc(int c)\n{\n    old_char = c;\n    old_mod_mask = mod_mask;\n#ifdef FEAT_MOUSE\n    old_mouse_row = mouse_row;\n    old_mouse_col = mouse_col;\n#endif\n}\n\n/*\n * Get a byte:\n * 1. from the stuffbuffer\n *\tThis is used for abbreviated commands like \"D\" -> \"d$\".\n *\tAlso used to redo a command for \".\".\n * 2. from the typeahead buffer\n *\tStores text obtained previously but not used yet.\n *\tAlso stores the result of mappings.\n *\tAlso used for the \":normal\" command.\n * 3. from the user\n *\tThis may do a blocking wait if \"advance\" is TRUE.\n *\n * if \"advance\" is TRUE (vgetc()):\n *\tReally get the character.\n *\tKeyTyped is set to TRUE in the case the user typed the key.\n *\tKeyStuffed is TRUE if the character comes from the stuff buffer.\n * if \"advance\" is FALSE (vpeekc()):\n *\tJust look whether there is a character available.\n *\tReturn NUL if not.\n *\n * When \"no_mapping\" is zero, checks for mappings in the current mode.\n * Only returns one byte (of a multi-byte character).\n * K_SPECIAL and CSI may be escaped, need to get two more bytes then.\n */\n    static int\nvgetorpeek(int advance)\n{\n    int\t\tc, c1;\n    int\t\tkeylen;\n    char_u\t*s;\n    mapblock_T\t*mp;\n#ifdef FEAT_LOCALMAP\n    mapblock_T\t*mp2;\n#endif\n    mapblock_T\t*mp_match;\n    int\t\tmp_match_len = 0;\n    int\t\ttimedout = FALSE;\t    /* waited for more than 1 second\n\t\t\t\t\t\tfor mapping to complete */\n    int\t\tmapdepth = 0;\t    /* check for recursive mapping */\n    int\t\tmode_deleted = FALSE;   /* set when mode has been deleted */\n    int\t\tlocal_State;\n    int\t\tmlen;\n    int\t\tmax_mlen;\n    int\t\ti;\n#ifdef FEAT_CMDL_INFO\n    int\t\tnew_wcol, new_wrow;\n#endif\n#ifdef FEAT_GUI\n# ifdef FEAT_MENU\n    int\t\tidx;\n# endif\n    int\t\tshape_changed = FALSE;  /* adjusted cursor shape */\n#endif\n    int\t\tn;\n#ifdef FEAT_LANGMAP\n    int\t\tnolmaplen;\n#endif\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    local_State = get_real_state();\n\n    ++vgetc_busy;\n\n    if (advance)\n\tKeyStuffed = FALSE;\n\n    init_typebuf();\n    start_stuff();\n    if (advance && typebuf.tb_maplen == 0)\n\treg_executing = 0;\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t/* KeyTyped = FALSE;  When the command that stuffed something\n\t\t * was typed, behave like the stuffed command was typed.\n\t\t * needed for CTRL-W CTRL-] to open a fold, for example. */\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t/* no abbreviations now */\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\t    wait_time;\n\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t/* check for CTRL-C */\n\t\tkeylen = 0;\n\t\tif (got_int)\n\t\t{\n\t\t    /* flush all input */\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t\t      && (State & (INSERT + CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t/* Also record this character, it might be needed to\n\t\t\t * get out of Insert mode. */\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mappable key sequence.\n\t\t     * Walk through one maphash[] list until we find an\n\t\t     * entry that matches.\n\t\t     *\n\t\t     * Don't look for mappings if:\n\t\t     * - no_mapping set: mapping disabled (e.g. for CTRL-V)\n\t\t     * - maphash_valid not set: no mappings present.\n\t\t     * - typebuf.tb_buf[typebuf.tb_off] should not be remapped\n\t\t     * - in insert or cmdline mode and 'paste' option set\n\t\t     * - waiting for \"hit return to continue\" and CR or SPACE\n\t\t     *\t typed\n\t\t     * - waiting for a char with --more--\n\t\t     * - in Ctrl-X mode, and we get a valid char for that mode\n\t\t     */\n\t\t    mp = NULL;\n\t\t    max_mlen = 0;\n\t\t    c1 = typebuf.tb_buf[typebuf.tb_off];\n\t\t    if (no_mapping == 0 && maphash_valid\n\t\t\t    && (no_zero_mapping == 0 || c1 != '0')\n\t\t\t    && (typebuf.tb_maplen == 0\n\t\t\t\t|| (p_remap\n\t\t\t\t    && (typebuf.tb_noremap[typebuf.tb_off]\n\t\t\t\t\t\t    & (RM_NONE|RM_ABBR)) == 0))\n\t\t\t    && !(p_paste && (State & (INSERT + CMDLINE)))\n\t\t\t    && !(State == HITRETURN && (c1 == CAR || c1 == ' '))\n\t\t\t    && State != ASKMORE\n\t\t\t    && State != CONFIRM\n#ifdef FEAT_INS_EXPAND\n\t\t\t    && !((ctrl_x_mode_not_default()\n\t\t\t\t\t\t      && vim_is_ctrl_x_key(c1))\n\t\t\t\t    || ((compl_cont_status & CONT_LOCAL)\n\t\t\t\t\t&& (c1 == Ctrl_N || c1 == Ctrl_P)))\n#endif\n\t\t\t    )\n\t\t    {\n#ifdef FEAT_LANGMAP\n\t\t\tif (c1 == K_SPECIAL)\n\t\t\t    nolmaplen = 2;\n\t\t\telse\n\t\t\t{\n\t\t\t    LANGMAP_ADJUST(c1,\n\t\t\t\t\t   (State & (CMDLINE | INSERT)) == 0\n\t\t\t\t\t   && get_real_state() != SELECTMODE);\n\t\t\t    nolmaplen = 0;\n\t\t\t}\n#endif\n#ifdef FEAT_LOCALMAP\n\t\t\t/* First try buffer-local mappings. */\n\t\t\tmp = curbuf->b_maphash[MAP_HASH(local_State, c1)];\n\t\t\tmp2 = maphash[MAP_HASH(local_State, c1)];\n\t\t\tif (mp == NULL)\n\t\t\t{\n\t\t\t    /* There are no buffer-local mappings. */\n\t\t\t    mp = mp2;\n\t\t\t    mp2 = NULL;\n\t\t\t}\n#else\n\t\t\tmp = maphash[MAP_HASH(local_State, c1)];\n#endif\n\t\t\t/*\n\t\t\t * Loop until a partly matching mapping is found or\n\t\t\t * all (local) mappings have been checked.\n\t\t\t * The longest full match is remembered in \"mp_match\".\n\t\t\t * A full match is only accepted if there is no partly\n\t\t\t * match, so \"aa\" and \"aaa\" can both be mapped.\n\t\t\t */\n\t\t\tmp_match = NULL;\n\t\t\tmp_match_len = 0;\n\t\t\tfor ( ; mp != NULL;\n#ifdef FEAT_LOCALMAP\n\t\t\t\tmp->m_next == NULL ? (mp = mp2, mp2 = NULL) :\n#endif\n\t\t\t\t(mp = mp->m_next))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Only consider an entry if the first character\n\t\t\t     * matches and it is for the current state.\n\t\t\t     * Skip \":lmap\" mappings if keys were mapped.\n\t\t\t     */\n\t\t\t    if (mp->m_keys[0] == c1\n\t\t\t\t    && (mp->m_mode & local_State)\n\t\t\t\t    && ((mp->m_mode & LANGMAP) == 0\n\t\t\t\t\t|| typebuf.tb_maplen == 0))\n\t\t\t    {\n#ifdef FEAT_LANGMAP\n\t\t\t\tint\tnomap = nolmaplen;\n\t\t\t\tint\tc2;\n#endif\n\t\t\t\t/* find the match length of this mapping */\n\t\t\t\tfor (mlen = 1; mlen < typebuf.tb_len; ++mlen)\n\t\t\t\t{\n#ifdef FEAT_LANGMAP\n\t\t\t\t    c2 = typebuf.tb_buf[typebuf.tb_off + mlen];\n\t\t\t\t    if (nomap > 0)\n\t\t\t\t\t--nomap;\n\t\t\t\t    else if (c2 == K_SPECIAL)\n\t\t\t\t\tnomap = 2;\n\t\t\t\t    else\n\t\t\t\t\tLANGMAP_ADJUST(c2, TRUE);\n\t\t\t\t    if (mp->m_keys[mlen] != c2)\n#else\n\t\t\t\t    if (mp->m_keys[mlen] !=\n\t\t\t\t\ttypebuf.tb_buf[typebuf.tb_off + mlen])\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Don't allow mapping the first byte(s) of a\n\t\t\t\t * multi-byte char.  Happens when mapping\n\t\t\t\t * <M-a> and then changing 'encoding'. Beware\n\t\t\t\t * that 0x80 is escaped. */\n\t\t\t\t{\n\t\t\t\t    char_u *p1 = mp->m_keys;\n\t\t\t\t    char_u *p2 = mb_unescape(&p1);\n\n\t\t\t\t    if (has_mbyte && p2 != NULL\n\t\t\t\t\t  && MB_BYTE2LEN(c1) > MB_PTR2LEN(p2))\n\t\t\t\t\tmlen = 0;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Check an entry whether it matches.\n\t\t\t\t * - Full match: mlen == keylen\n\t\t\t\t * - Partly match: mlen == typebuf.tb_len\n\t\t\t\t */\n\t\t\t\tkeylen = mp->m_keylen;\n\t\t\t\tif (mlen == keylen\n\t\t\t\t     || (mlen == typebuf.tb_len\n\t\t\t\t\t\t  && typebuf.tb_len < keylen))\n\t\t\t\t{\n\t\t\t\t    /*\n\t\t\t\t     * If only script-local mappings are\n\t\t\t\t     * allowed, check if the mapping starts\n\t\t\t\t     * with K_SNR.\n\t\t\t\t     */\n\t\t\t\t    s = typebuf.tb_noremap + typebuf.tb_off;\n\t\t\t\t    if (*s == RM_SCRIPT\n\t\t\t\t\t    && (mp->m_keys[0] != K_SPECIAL\n\t\t\t\t\t\t|| mp->m_keys[1] != KS_EXTRA\n\t\t\t\t\t\t|| mp->m_keys[2]\n\t\t\t\t\t\t\t      != (int)KE_SNR))\n\t\t\t\t\tcontinue;\n\t\t\t\t    /*\n\t\t\t\t     * If one of the typed keys cannot be\n\t\t\t\t     * remapped, skip the entry.\n\t\t\t\t     */\n\t\t\t\t    for (n = mlen; --n >= 0; )\n\t\t\t\t\tif (*s++ & (RM_NONE|RM_ABBR))\n\t\t\t\t\t    break;\n\t\t\t\t    if (n >= 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t    if (keylen > typebuf.tb_len)\n\t\t\t\t    {\n\t\t\t\t\tif (!timedout && !(mp_match != NULL\n\t\t\t\t\t\t       && mp_match->m_nowait))\n\t\t\t\t\t{\n\t\t\t\t\t    /* break at a partly match */\n\t\t\t\t\t    keylen = KEYLEN_PART_MAP;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else if (keylen > mp_match_len)\n\t\t\t\t    {\n\t\t\t\t\t/* found a longer match */\n\t\t\t\t\tmp_match = mp;\n\t\t\t\t\tmp_match_len = keylen;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    /* No match; may have to check for\n\t\t\t\t     * termcode at next character. */\n\t\t\t\t    if (max_mlen < mlen)\n\t\t\t\t\tmax_mlen = mlen;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t/* If no partly match found, use the longest full\n\t\t\t * match. */\n\t\t\tif (keylen != KEYLEN_PART_MAP)\n\t\t\t{\n\t\t\t    mp = mp_match;\n\t\t\t    keylen = mp_match_len;\n\t\t\t}\n\t\t    }\n\n\t\t    /* Check for match with 'pastetoggle' */\n\t\t    if (*p_pt != NUL && mp == NULL && (State & (INSERT|NORMAL)))\n\t\t    {\n\t\t\tfor (mlen = 0; mlen < typebuf.tb_len && p_pt[mlen];\n\t\t\t\t\t\t\t\t       ++mlen)\n\t\t\t    if (p_pt[mlen] != typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t\t\t      + mlen])\n\t\t\t\t    break;\n\t\t\tif (p_pt[mlen] == NUL)\t/* match */\n\t\t\t{\n\t\t\t    /* write chars to script file(s) */\n\t\t\t    if (mlen > typebuf.tb_maplen)\n\t\t\t\tgotchars(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t\t  + typebuf.tb_maplen,\n\t\t\t\t\t\t    mlen - typebuf.tb_maplen);\n\n\t\t\t    del_typebuf(mlen, 0); /* remove the chars */\n\t\t\t    set_option_value((char_u *)\"paste\",\n\t\t\t\t\t\t     (long)!p_paste, NULL, 0);\n\t\t\t    if (!(State & INSERT))\n\t\t\t    {\n\t\t\t\tmsg_col = 0;\n\t\t\t\tmsg_row = Rows - 1;\n\t\t\t\tmsg_clr_eos();\t\t/* clear ruler */\n\t\t\t    }\n\t\t\t    status_redraw_all();\n\t\t\t    redraw_statuslines();\n\t\t\t    showmode();\n\t\t\t    setcursor();\n\t\t\t    continue;\n\t\t\t}\n\t\t\t/* Need more chars for partly match. */\n\t\t\tif (mlen == typebuf.tb_len)\n\t\t\t    keylen = KEYLEN_PART_KEY;\n\t\t\telse if (max_mlen < mlen)\n\t\t\t    /* no match, may have to check for termcode at\n\t\t\t     * next character */\n\t\t\t    max_mlen = mlen + 1;\n\t\t    }\n\n\t\t    if ((mp == NULL || max_mlen >= mp_match_len)\n\t\t\t\t\t\t && keylen != KEYLEN_PART_MAP)\n\t\t    {\n\t\t\tint\tsave_keylen = keylen;\n\n\t\t\t/*\n\t\t\t * When no matching mapping found or found a\n\t\t\t * non-matching mapping that matches at least what the\n\t\t\t * matching mapping matched:\n\t\t\t * Check if we have a terminal code, when:\n\t\t\t *  mapping is allowed,\n\t\t\t *  keys have not been mapped,\n\t\t\t *  and not an ESC sequence, not in insert mode or\n\t\t\t *\tp_ek is on,\n\t\t\t *  and when not timed out,\n\t\t\t */\n\t\t\tif ((no_mapping == 0 || allow_keys != 0)\n\t\t\t\t&& (typebuf.tb_maplen == 0\n\t\t\t\t    || (p_remap && typebuf.tb_noremap[\n\t\t\t\t\t\t   typebuf.tb_off] == RM_YES))\n\t\t\t\t&& !timedout)\n\t\t\t{\n\t\t\t    keylen = check_termcode(max_mlen + 1,\n\t\t\t\t\t\t\t       NULL, 0, NULL);\n\n\t\t\t    /* If no termcode matched but 'pastetoggle'\n\t\t\t     * matched partially it's like an incomplete key\n\t\t\t     * sequence. */\n\t\t\t    if (keylen == 0 && save_keylen == KEYLEN_PART_KEY)\n\t\t\t\tkeylen = KEYLEN_PART_KEY;\n\n\t\t\t    /*\n\t\t\t     * When getting a partial match, but the last\n\t\t\t     * characters were not typed, don't wait for a\n\t\t\t     * typed character to complete the termcode.\n\t\t\t     * This helps a lot when a \":normal\" command ends\n\t\t\t     * in an ESC.\n\t\t\t     */\n\t\t\t    if (keylen < 0\n\t\t\t\t       && typebuf.tb_len == typebuf.tb_maplen)\n\t\t\t\tkeylen = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    keylen = 0;\n\t\t\tif (keylen == 0)\t/* no matching terminal code */\n\t\t\t{\n#ifdef AMIGA\t\t\t/* check for window bounds report */\n\t\t\t    if (typebuf.tb_maplen == 0 && (typebuf.tb_buf[\n\t\t\t\t\t       typebuf.tb_off] & 0xff) == CSI)\n\t\t\t    {\n\t\t\t\tfor (s = typebuf.tb_buf + typebuf.tb_off + 1;\n\t\t\t\t\ts < typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t\t      + typebuf.tb_len\n\t\t\t\t   && (VIM_ISDIGIT(*s) || *s == ';'\n\t\t\t\t\t\t\t\t|| *s == ' ');\n\t\t\t\t\t++s)\n\t\t\t\t    ;\n\t\t\t\tif (*s == 'r' || *s == '|') /* found one */\n\t\t\t\t{\n\t\t\t\t    del_typebuf((int)(s + 1 -\n\t\t\t\t       (typebuf.tb_buf + typebuf.tb_off)), 0);\n\t\t\t\t    /* get size and redraw screen */\n\t\t\t\t    shell_resized();\n\t\t\t\t    continue;\n\t\t\t\t}\n\t\t\t\tif (*s == NUL)\t    /* need more characters */\n\t\t\t\t    keylen = KEYLEN_PART_KEY;\n\t\t\t    }\n\t\t\t    if (keylen >= 0)\n#endif\n\t\t\t      /* When there was a matching mapping and no\n\t\t\t       * termcode could be replaced after another one,\n\t\t\t       * use that mapping (loop around). If there was\n\t\t\t       * no mapping use the character from the\n\t\t\t       * typeahead buffer right here. */\n\t\t\t      if (mp == NULL)\n\t\t\t      {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\t\tc = typebuf.tb_buf[typebuf.tb_off] & 255;\n\t\t\t\tif (advance)\t/* remove chars from tb_buf */\n\t\t\t\t{\n\t\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\t\tKeyTyped = FALSE;\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t\t/* write char to script file(s) */\n\t\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t\t    }\n\t\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t\t    del_typebuf(1, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\t    /* got character, break for loop */\n\t\t\t      }\n\t\t\t}\n\t\t\tif (keylen > 0)\t    /* full matching terminal code */\n\t\t\t{\n#if defined(FEAT_GUI) && defined(FEAT_MENU)\n\t\t\t    if (typebuf.tb_len >= 2\n\t\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL\n\t\t\t\t\t && typebuf.tb_buf[typebuf.tb_off + 1]\n\t\t\t\t\t\t\t\t   == KS_MENU)\n\t\t\t    {\n\t\t\t\t/*\n\t\t\t\t * Using a menu may cause a break in undo!\n\t\t\t\t * It's like using gotchars(), but without\n\t\t\t\t * recording or writing to a script file.\n\t\t\t\t */\n\t\t\t\tmay_sync_undo();\n\t\t\t\tdel_typebuf(3, 0);\n\t\t\t\tidx = get_menu_index(current_menu, local_State);\n\t\t\t\tif (idx != MENU_INDEX_INVALID)\n\t\t\t\t{\n\t\t\t\t    /*\n\t\t\t\t     * In Select mode and a Visual mode menu\n\t\t\t\t     * is used:  Switch to Visual mode\n\t\t\t\t     * temporarily.  Append K_SELECT to switch\n\t\t\t\t     * back to Select mode.\n\t\t\t\t     */\n\t\t\t\t    if (VIsual_active && VIsual_select\n\t\t\t\t\t    && (current_menu->modes & VISUAL))\n\t\t\t\t    {\n\t\t\t\t\tVIsual_select = FALSE;\n\t\t\t\t\t(void)ins_typebuf(K_SELECT_STRING,\n\t\t\t\t\t\t  REMAP_NONE, 0, TRUE, FALSE);\n\t\t\t\t    }\n\t\t\t\t    ins_typebuf(current_menu->strings[idx],\n\t\t\t\t\t\tcurrent_menu->noremap[idx],\n\t\t\t\t\t\t0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t\t\t\t}\n\t\t\t    }\n#endif /* FEAT_GUI && FEAT_MENU */\n\t\t\t    continue;\t/* try mapping again */\n\t\t\t}\n\n\t\t\t/* Partial match: get some more characters.  When a\n\t\t\t * matching mapping was found use that one. */\n\t\t\tif (mp == NULL || keylen < 0)\n\t\t\t    keylen = KEYLEN_PART_KEY;\n\t\t\telse\n\t\t\t    keylen = mp_match_len;\n\t\t    }\n\n\t\t    /* complete match */\n\t\t    if (keylen >= 0 && keylen <= typebuf.tb_len)\n\t\t    {\n#ifdef FEAT_EVAL\n\t\t\tint save_m_expr;\n\t\t\tint save_m_noremap;\n\t\t\tint save_m_silent;\n\t\t\tchar_u *save_m_keys;\n\t\t\tchar_u *save_m_str;\n#else\n# define save_m_noremap mp->m_noremap\n# define save_m_silent mp->m_silent\n#endif\n\n\t\t\t/* write chars to script file(s) */\n\t\t\tif (keylen > typebuf.tb_maplen)\n\t\t\t    gotchars(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t\t  + typebuf.tb_maplen,\n\t\t\t\t\t\t  keylen - typebuf.tb_maplen);\n\n\t\t\tcmd_silent = (typebuf.tb_silent > 0);\n\t\t\tdel_typebuf(keylen, 0);\t/* remove the mapped keys */\n\n\t\t\t/*\n\t\t\t * Put the replacement string in front of mapstr.\n\t\t\t * The depth check catches \":map x y\" and \":map y x\".\n\t\t\t */\n\t\t\tif (++mapdepth >= p_mmd)\n\t\t\t{\n\t\t\t    emsg(_(\"E223: recursive mapping\"));\n\t\t\t    if (State & CMDLINE)\n\t\t\t\tredrawcmdline();\n\t\t\t    else\n\t\t\t\tsetcursor();\n\t\t\t    flush_buffers(FLUSH_MINIMAL);\n\t\t\t    mapdepth = 0;\t/* for next one */\n\t\t\t    c = -1;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In Select mode and a Visual mode mapping is used:\n\t\t\t * Switch to Visual mode temporarily.  Append K_SELECT\n\t\t\t * to switch back to Select mode.\n\t\t\t */\n\t\t\tif (VIsual_active && VIsual_select\n\t\t\t\t\t\t     && (mp->m_mode & VISUAL))\n\t\t\t{\n\t\t\t    VIsual_select = FALSE;\n\t\t\t    (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,\n\t\t\t\t\t\t\t      0, TRUE, FALSE);\n\t\t\t}\n\n#ifdef FEAT_EVAL\n\t\t\t/* Copy the values from *mp that are used, because\n\t\t\t * evaluating the expression may invoke a function\n\t\t\t * that redefines the mapping, thereby making *mp\n\t\t\t * invalid. */\n\t\t\tsave_m_expr = mp->m_expr;\n\t\t\tsave_m_noremap = mp->m_noremap;\n\t\t\tsave_m_silent = mp->m_silent;\n\t\t\tsave_m_keys = NULL;  /* only saved when needed */\n\t\t\tsave_m_str = NULL;  /* only saved when needed */\n\n\t\t\t/*\n\t\t\t * Handle \":map <expr>\": evaluate the {rhs} as an\n\t\t\t * expression.  Also save and restore the command line\n\t\t\t * for \"normal :\".\n\t\t\t */\n\t\t\tif (mp->m_expr)\n\t\t\t{\n\t\t\t    int\t\tsave_vgetc_busy = vgetc_busy;\n\n\t\t\t    vgetc_busy = 0;\n\t\t\t    save_m_keys = vim_strsave(mp->m_keys);\n\t\t\t    save_m_str = vim_strsave(mp->m_str);\n\t\t\t    s = eval_map_expr(save_m_str, NUL);\n\t\t\t    vgetc_busy = save_vgetc_busy;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    s = mp->m_str;\n\n\t\t\t/*\n\t\t\t * Insert the 'to' part in the typebuf.tb_buf.\n\t\t\t * If 'from' field is the same as the start of the\n\t\t\t * 'to' field, don't remap the first character (but do\n\t\t\t * allow abbreviations).\n\t\t\t * If m_noremap is set, don't remap the whole 'to'\n\t\t\t * part.\n\t\t\t */\n\t\t\tif (s == NULL)\n\t\t\t    i = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    int noremap;\n\n\t\t\t    if (save_m_noremap != REMAP_YES)\n\t\t\t\tnoremap = save_m_noremap;\n\t\t\t    else if (\n#ifdef FEAT_EVAL\n\t\t\t\tSTRNCMP(s, save_m_keys != NULL\n\t\t\t\t\t\t   ? save_m_keys : mp->m_keys,\n\t\t\t\t\t\t\t (size_t)keylen)\n#else\n\t\t\t\tSTRNCMP(s, mp->m_keys, (size_t)keylen)\n#endif\n\t\t\t\t   != 0)\n\t\t\t\tnoremap = REMAP_YES;\n\t\t\t    else\n\t\t\t\tnoremap = REMAP_SKIP;\n\t\t\t    i = ins_typebuf(s, noremap,\n\t\t\t\t\t0, TRUE, cmd_silent || save_m_silent);\n#ifdef FEAT_EVAL\n\t\t\t    if (save_m_expr)\n\t\t\t\tvim_free(s);\n#endif\n\t\t\t}\n#ifdef FEAT_EVAL\n\t\t\tvim_free(save_m_keys);\n\t\t\tvim_free(save_m_str);\n#endif\n\t\t\tif (i == FAIL)\n\t\t\t{\n\t\t\t    c = -1;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t */\n\t\tc = 0;\n#ifdef FEAT_CMDL_INFO\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n#endif\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0, vcol;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    /* may show a different cursor shape */\n\t\t    if (gui.in_use && State != NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    /* move cursor left, if possible */\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    if (did_ai)\n\t\t\t    {\n\t\t\t\t/*\n\t\t\t\t * We are expecting to truncate the trailing\n\t\t\t\t * white-space, so find the last non-white\n\t\t\t\t * character -- webb\n\t\t\t\t */\n\t\t\t\tcol = vcol = curwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\twhile (col < curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(ptr[col]))\n\t\t\t\t\tcurwin->w_wcol = vcol;\n\t\t\t\t    vcol += lbr_chartabsize(ptr, ptr + col,\n\t\t\t\t\t\t\t       (colnr_T)vcol);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcol += (*mb_ptr2len)(ptr + col);\n\t\t\t\t    else\n\t\t\t\t\t++col;\n\t\t\t\t}\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t/* no correction needed */\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    /* Correct when the cursor is on the right halve\n\t\t\t     * of a double-wide character. */\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n#ifdef FEAT_CMDL_INFO\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n#endif\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t/* end of input script reached */\n\n\t\t/* Allow mapping for just typed characters. When we get here c\n\t\t * is the number of extra bytes and typebuf.tb_len is 1. */\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t/* buffer full, don't map */\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n#ifdef FEAT_CMDWIN\n\t\t    static int tc = 0;\n#endif\n\n\t\t    /* No typeahead left and inside \":normal\".  Must return\n\t\t     * something to avoid getting stuck.  When an incomplete\n\t\t     * mapping is present, behave like it timed out. */\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t    /* When 'insertmode' is set, ESC just beeps in Insert\n\t\t     * mode.  Use CTRL-L to make edit() return.\n\t\t     * For the command line only CTRL-C always breaks it.\n\t\t     * For the cmdline window: Alternate between ESC and\n\t\t     * CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t     * cmdline window. */\n\t\t    if (p_im && (State & INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & CMDLINE)\n#ifdef FEAT_CMDWIN\n\t\t\t    || (cmdwin_type > 0 && tc == ESC)\n#endif\n\t\t\t    )\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n#ifdef FEAT_CMDWIN\n\t\t    tc = c;\n#endif\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t/* In insert mode a screen update is skipped when characters\n\t\t * are still available.  But when those available characters\n\t\t * are part of a mapping, and we are going to do a blocking\n\t\t * wait here.  Need to update the screen to display the\n\t\t * changed text so far. Also for when 'lazyredraw' is set and\n\t\t * redrawing was postponed because there was something in the\n\t\t * input buffer (e.g., termresponse). */\n\t\tif (((State & INSERT) != 0 || p_lz) && (State & CMDLINE) == 0\n\t\t\t  && advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); /* put cursor back where it belongs */\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n#ifdef FEAT_CMDL_INFO\n\t\ti = 0;\n#endif\n\t\tc1 = 0;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (NORMAL | INSERT)) || State == LANGMAP)\n\t\t\t    && State != HITRETURN)\n\t\t    {\n\t\t\t/* this looks nice when typing a dead character map */\n\t\t\tif (State & INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); /* put cursor back where it belongs */\n\t\t\t    c1 = 1;\n\t\t\t}\n#ifdef FEAT_CMDL_INFO\n\t\t\t/* need to use the col and row from above here */\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    i = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (i < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t\t\t      + i++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n#endif\n\t\t    }\n\n\t\t    /* this looks nice when typing a dead character map */\n\t\t    if ((State & CMDLINE)\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tc1 = 1;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set while waiting for a mapping\n\t\t    // that has a <Nop> RHS.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n#ifdef FEAT_CMDL_INFO\n\t\tif (i != 0)\n\t\t    pop_showcmd();\n#endif\n\t\tif (c1 == 1)\n\t\t{\n\t\t    if (State & INSERT)\n\t\t\tedit_unputchar();\n\t\t    if (State & CMDLINE)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t/* put cursor back where it belongs */\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t/* end of input script reached */\n\t\tif (c == NUL)\t\t/* no character available */\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t/* timed out */\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    /* allow mapping for just typed characters */\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    /* Get IM status right after getting keys, not after the\n\t\t     * timeout for a mapping (focus may be lost by then). */\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    /* for (;;) */\n\t}\t/* if (!character from stuffbuf) */\n\n\t/* if advance is FALSE don't loop on NULs */\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    /* delete mode later */\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    /* show mode later */\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    /* may unshow different cursor shape */\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}\n\n/*\n * inchar() - get one character from\n *\t1. a scriptfile\n *\t2. the keyboard\n *\n *  As much characters as we can get (upto 'maxlen') are put in \"buf\" and\n *  NUL terminated (buffer length must be 'maxlen' + 1).\n *  Minimum for \"maxlen\" is 3!!!!\n *\n *  \"tb_change_cnt\" is the value of typebuf.tb_change_cnt if \"buf\" points into\n *  it.  When typebuf.tb_change_cnt changes (e.g., when a message is received\n *  from a remote client) \"buf\" can no longer be used.  \"tb_change_cnt\" is 0\n *  otherwise.\n *\n *  If we got an interrupt all input is read until none is available.\n *\n *  If wait_time == 0  there is no waiting for the char.\n *  If wait_time == n  we wait for n msec for a character to arrive.\n *  If wait_time == -1 we wait forever for a character to arrive.\n *\n *  Return the number of obtained characters.\n *  Return -1 when end of input script reached.\n */\n    static int\ninchar(\n    char_u\t*buf,\n    int\t\tmaxlen,\n    long\twait_time)\t    /* milli seconds */\n{\n    int\t\tlen = 0;\t    /* init for GCC */\n    int\t\tretesc = FALSE;\t    /* return ESC with gotint */\n    int\t\tscript_char;\n    int\t\ttb_change_cnt = typebuf.tb_change_cnt;\n\n    if (wait_time == -1L || wait_time > 100L)  /* flush output before waiting */\n    {\n\tcursor_on();\n\tout_flush_cursor(FALSE, FALSE);\n#if defined(FEAT_GUI) && defined(FEAT_MOUSESHAPE)\n\tif (gui.in_use && postponed_mouseshape)\n\t    update_mouseshape(-1);\n#endif\n    }\n\n    /*\n     * Don't reset these when at the hit-return prompt, otherwise a endless\n     * recursive loop may result (write error in swapfile, hit-return, timeout\n     * on char wait, flush swapfile, write error....).\n     */\n    if (State != HITRETURN)\n    {\n\tdid_outofmem_msg = FALSE;   /* display out of memory message (again) */\n\tdid_swapwrite_msg = FALSE;  /* display swap file write error again */\n    }\n    undo_off = FALSE;\t\t    /* restart undo now */\n\n    /*\n     * Get a character from a script file if there is one.\n     * If interrupted: Stop reading script files, close them all.\n     */\n    script_char = -1;\n    while (scriptin[curscript] != NULL && script_char < 0\n#ifdef FEAT_EVAL\n\t    && !ignore_script\n#endif\n\t    )\n    {\n\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n\n\tif (got_int || (script_char = getc(scriptin[curscript])) < 0)\n\t{\n\t    /* Reached EOF.\n\t     * Careful: closescript() frees typebuf.tb_buf[] and buf[] may\n\t     * point inside typebuf.tb_buf[].  Don't use buf[] after this! */\n\t    closescript();\n\t    /*\n\t     * When reading script file is interrupted, return an ESC to get\n\t     * back to normal mode.\n\t     * Otherwise return -1, because typebuf.tb_buf[] has changed.\n\t     */\n\t    if (got_int)\n\t\tretesc = TRUE;\n\t    else\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    buf[0] = script_char;\n\t    len = 1;\n\t}\n    }\n\n    if (script_char < 0)\t/* did not get a character from script */\n    {\n\t/*\n\t * If we got an interrupt, skip all previously typed characters and\n\t * return TRUE if quit reading script file.\n\t * Stop reading typeahead when a single CTRL-C was read,\n\t * fill_input_buf() returns this when not able to read from stdin.\n\t * Don't use buf[] here, closescript() may have freed typebuf.tb_buf[]\n\t * and buf may be pointing inside typebuf.tb_buf[].\n\t */\n\tif (got_int)\n\t{\n#define DUM_LEN MAXMAPLEN * 3 + 3\n\t    char_u\tdum[DUM_LEN + 1];\n\n\t    for (;;)\n\t    {\n\t\tlen = ui_inchar(dum, DUM_LEN, 0L, 0);\n\t\tif (len == 0 || (len == 1 && dum[0] == 3))\n\t\t    break;\n\t    }\n\t    return retesc;\n\t}\n\n\t/*\n\t * Always flush the output characters when getting input characters\n\t * from the user and not just peeking.\n\t */\n\tif (wait_time == -1L || wait_time > 10L)\n\t    out_flush();\n\n\t/*\n\t * Fill up to a third of the buffer, because each character may be\n\t * tripled below.\n\t */\n\tlen = ui_inchar(buf, maxlen / 3, wait_time, tb_change_cnt);\n    }\n\n    /* If the typebuf was changed further down, it is like nothing was added by\n     * this call. */\n    if (typebuf_changed(tb_change_cnt))\n\treturn 0;\n\n    /* Note the change in the typeahead buffer, this matters for when\n     * vgetorpeek() is called recursively, e.g. using getchar(1) in a timer\n     * function. */\n    if (len > 0 && ++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n\n    return fix_input_buffer(buf, len);\n}\n\n/*\n * Fix typed characters for use by vgetc() and check_termcode().\n * \"buf[]\" must have room to triple the number of bytes!\n * Returns the new length.\n */\n    int\nfix_input_buffer(char_u *buf, int len)\n{\n    int\t\ti;\n    char_u\t*p = buf;\n\n    /*\n     * Two characters are special: NUL and K_SPECIAL.\n     * When compiled With the GUI CSI is also special.\n     * Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER\n     * Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER\n     * Replace       CSI by K_SPECIAL KS_EXTRA   KE_CSI\n     */\n    for (i = len; --i >= 0; ++p)\n    {\n#ifdef FEAT_GUI\n\t/* When the GUI is used any character can come after a CSI, don't\n\t * escape it. */\n\tif (gui.in_use && p[0] == CSI && i >= 2)\n\t{\n\t    p += 2;\n\t    i -= 2;\n\t}\n# ifndef MSWIN\n\t/* When the GUI is not used CSI needs to be escaped. */\n\telse if (!gui.in_use && p[0] == CSI)\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    *p++ = K_SPECIAL;\n\t    *p++ = KS_EXTRA;\n\t    *p = (int)KE_CSI;\n\t    len += 2;\n\t}\n# endif\n\telse\n#endif\n\tif (p[0] == NUL || (p[0] == K_SPECIAL\n\t\t    // timeout may generate K_CURSORHOLD\n\t\t    && (i < 2 || p[1] != KS_EXTRA || p[2] != (int)KE_CURSORHOLD)\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t\t    // Win32 console passes modifiers\n\t\t    && (\n# ifdef VIMDLL\n\t\t\tgui.in_use ||\n# endif\n\t\t\t(i < 2 || p[1] != KS_MODIFIER))\n#endif\n\t\t    ))\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    p[2] = K_THIRD(p[0]);\n\t    p[1] = K_SECOND(p[0]);\n\t    p[0] = K_SPECIAL;\n\t    p += 2;\n\t    len += 2;\n\t}\n    }\n    *p = NUL;\t\t// add trailing NUL\n    return len;\n}\n\n#if defined(USE_INPUT_BUF) || defined(PROTO)\n/*\n * Return TRUE when bytes are in the input buffer or in the typeahead buffer.\n * Normally the input buffer would be sufficient, but the server_to_input_buf()\n * or feedkeys() may insert characters in the typeahead buffer while we are\n * waiting for input to arrive.\n */\n    int\ninput_available(void)\n{\n    return (!vim_is_input_buf_empty()\n# if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n# endif\n\t    );\n}\n#endif\n\n/*\n * map[!]\t\t    : show all key mappings\n * map[!] {lhs}\t\t    : show key mapping for {lhs}\n * map[!] {lhs} {rhs}\t    : set key mapping for {lhs} to {rhs}\n * noremap[!] {lhs} {rhs}   : same, but no remapping for {rhs}\n * unmap[!] {lhs}\t    : remove key mapping for {lhs}\n * abbr\t\t\t    : show all abbreviations\n * abbr {lhs}\t\t    : show abbreviations for {lhs}\n * abbr {lhs} {rhs}\t    : set abbreviation for {lhs} to {rhs}\n * noreabbr {lhs} {rhs}\t    : same, but no remapping for {rhs}\n * unabbr {lhs}\t\t    : remove abbreviation for {lhs}\n *\n * maptype: 0 for :map, 1 for :unmap, 2 for noremap.\n *\n * arg is pointer to any arguments. Note: arg cannot be a read-only string,\n * it will be modified.\n *\n * for :map   mode is NORMAL + VISUAL + SELECTMODE + OP_PENDING\n * for :map!  mode is INSERT + CMDLINE\n * for :cmap  mode is CMDLINE\n * for :imap  mode is INSERT\n * for :lmap  mode is LANGMAP\n * for :nmap  mode is NORMAL\n * for :vmap  mode is VISUAL + SELECTMODE\n * for :xmap  mode is VISUAL\n * for :smap  mode is SELECTMODE\n * for :omap  mode is OP_PENDING\n * for :tmap  mode is TERMINAL\n *\n * for :abbr  mode is INSERT + CMDLINE\n * for :iabbr mode is INSERT\n * for :cabbr mode is CMDLINE\n *\n * Return 0 for success\n *\t  1 for invalid arguments\n *\t  2 for no match\n *\t  4 for out of mem\n *\t  5 for entry not unique\n */\n    int\ndo_map(\n    int\t\tmaptype,\n    char_u\t*arg,\n    int\t\tmode,\n    int\t\tabbrev)\t\t/* not a mapping but an abbreviation */\n{\n    char_u\t*keys;\n    mapblock_T\t*mp, **mpp;\n    char_u\t*rhs;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tlen = 0;\t/* init for GCC */\n    char_u\t*newstr;\n    int\t\thasarg;\n    int\t\thaskey;\n    int\t\tdid_it = FALSE;\n#ifdef FEAT_LOCALMAP\n    int\t\tdid_local = FALSE;\n#endif\n    int\t\tround;\n    char_u\t*keys_buf = NULL;\n    char_u\t*arg_buf = NULL;\n    int\t\tretval = 0;\n    int\t\tdo_backslash;\n    int\t\thash;\n    int\t\tnew_hash;\n    mapblock_T\t**abbr_table;\n    mapblock_T\t**map_table;\n    int\t\tunique = FALSE;\n    int\t\tnowait = FALSE;\n    int\t\tsilent = FALSE;\n    int\t\tspecial = FALSE;\n#ifdef FEAT_EVAL\n    int\t\texpr = FALSE;\n#endif\n    int\t\tnoremap;\n    char_u      *orig_rhs;\n\n    keys = arg;\n    map_table = maphash;\n    abbr_table = &first_abbr;\n\n    /* For \":noremap\" don't remap, otherwise do remap. */\n    if (maptype == 2)\n\tnoremap = REMAP_NONE;\n    else\n\tnoremap = REMAP_YES;\n\n    /* Accept <buffer>, <nowait>, <silent>, <expr> <script> and <unique> in\n     * any order. */\n    for (;;)\n    {\n#ifdef FEAT_LOCALMAP\n\t/*\n\t * Check for \"<buffer>\": mapping local to buffer.\n\t */\n\tif (STRNCMP(keys, \"<buffer>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    map_table = curbuf->b_maphash;\n\t    abbr_table = &curbuf->b_first_abbr;\n\t    continue;\n\t}\n#endif\n\n\t/*\n\t * Check for \"<nowait>\": don't wait for more characters.\n\t */\n\tif (STRNCMP(keys, \"<nowait>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    nowait = TRUE;\n\t    continue;\n\t}\n\n\t/*\n\t * Check for \"<silent>\": don't echo commands.\n\t */\n\tif (STRNCMP(keys, \"<silent>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    silent = TRUE;\n\t    continue;\n\t}\n\n\t/*\n\t * Check for \"<special>\": accept special keys in <>\n\t */\n\tif (STRNCMP(keys, \"<special>\", 9) == 0)\n\t{\n\t    keys = skipwhite(keys + 9);\n\t    special = TRUE;\n\t    continue;\n\t}\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Check for \"<script>\": remap script-local mappings only\n\t */\n\tif (STRNCMP(keys, \"<script>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    noremap = REMAP_SCRIPT;\n\t    continue;\n\t}\n\n\t/*\n\t * Check for \"<expr>\": {rhs} is an expression.\n\t */\n\tif (STRNCMP(keys, \"<expr>\", 6) == 0)\n\t{\n\t    keys = skipwhite(keys + 6);\n\t    expr = TRUE;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Check for \"<unique>\": don't overwrite an existing mapping.\n\t */\n\tif (STRNCMP(keys, \"<unique>\", 8) == 0)\n\t{\n\t    keys = skipwhite(keys + 8);\n\t    unique = TRUE;\n\t    continue;\n\t}\n\tbreak;\n    }\n\n    validate_maphash();\n\n    /*\n     * Find end of keys and skip CTRL-Vs (and backslashes) in it.\n     * Accept backslash like CTRL-V when 'cpoptions' does not contain 'B'.\n     * with :unmap white space is included in the keys, no argument possible.\n     */\n    p = keys;\n    do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);\n    while (*p && (maptype == 1 || !VIM_ISWHITE(*p)))\n    {\n\tif ((p[0] == Ctrl_V || (do_backslash && p[0] == '\\\\')) &&\n\t\t\t\t\t\t\t\t  p[1] != NUL)\n\t    ++p;\t\t/* skip CTRL-V or backslash */\n\t++p;\n    }\n    if (*p != NUL)\n\t*p++ = NUL;\n\n    p = skipwhite(p);\n    rhs = p;\n    hasarg = (*rhs != NUL);\n    haskey = (*keys != NUL);\n\n    /* check for :unmap without argument */\n    if (maptype == 1 && !haskey)\n    {\n\tretval = 1;\n\tgoto theend;\n    }\n\n    /*\n     * If mapping has been given as ^V<C_UP> say, then replace the term codes\n     * with the appropriate two bytes. If it is a shifted special key, unshift\n     * it too, giving another two bytes.\n     * replace_termcodes() may move the result to allocated memory, which\n     * needs to be freed later (*keys_buf and *arg_buf).\n     * replace_termcodes() also removes CTRL-Vs and sometimes backslashes.\n     */\n    if (haskey)\n\tkeys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, special);\n    orig_rhs = rhs;\n    if (hasarg)\n    {\n\tif (STRICMP(rhs, \"<nop>\") == 0)\t    /* \"<Nop>\" means nothing */\n\t    rhs = (char_u *)\"\";\n\telse\n\t    rhs = replace_termcodes(rhs, &arg_buf, FALSE, TRUE, special);\n    }\n\n    /*\n     * check arguments and translate function keys\n     */\n    if (haskey)\n    {\n\tlen = (int)STRLEN(keys);\n\tif (len > MAXMAPLEN)\t\t/* maximum length of MAXMAPLEN chars */\n\t{\n\t    retval = 1;\n\t    goto theend;\n\t}\n\n\tif (abbrev && maptype != 1)\n\t{\n\t    /*\n\t     * If an abbreviation ends in a keyword character, the\n\t     * rest must be all keyword-char or all non-keyword-char.\n\t     * Otherwise we won't be able to find the start of it in a\n\t     * vi-compatible way.\n\t     */\n\t    if (has_mbyte)\n\t    {\n\t\tint\tfirst, last;\n\t\tint\tsame = -1;\n\n\t\tfirst = vim_iswordp(keys);\n\t\tlast = first;\n\t\tp = keys + (*mb_ptr2len)(keys);\n\t\tn = 1;\n\t\twhile (p < keys + len)\n\t\t{\n\t\t    ++n;\t\t\t/* nr of (multi-byte) chars */\n\t\t    last = vim_iswordp(p);\t/* type of last char */\n\t\t    if (same == -1 && last != first)\n\t\t\tsame = n - 1;\t\t/* count of same char type */\n\t\t    p += (*mb_ptr2len)(p);\n\t\t}\n\t\tif (last && n > 2 && same >= 0 && same < n - 1)\n\t\t{\n\t\t    retval = 1;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (vim_iswordc(keys[len - 1]))  // ends in keyword char\n\t\t    for (n = 0; n < len - 2; ++n)\n\t\t\tif (vim_iswordc(keys[n]) != vim_iswordc(keys[len - 2]))\n\t\t\t{\n\t\t\t    retval = 1;\n\t\t\t    goto theend;\n\t\t\t}\n\t    /* An abbreviation cannot contain white space. */\n\t    for (n = 0; n < len; ++n)\n\t\tif (VIM_ISWHITE(keys[n]))\n\t\t{\n\t\t    retval = 1;\n\t\t    goto theend;\n\t\t}\n\t}\n    }\n\n    if (haskey && hasarg && abbrev)\t/* if we will add an abbreviation */\n\tno_abbr = FALSE;\t\t/* reset flag that indicates there are\n\t\t\t\t\t\t\t    no abbreviations */\n\n    if (!haskey || (maptype != 1 && !hasarg))\n\tmsg_start();\n\n#ifdef FEAT_LOCALMAP\n    /*\n     * Check if a new local mapping wasn't already defined globally.\n     */\n    if (map_table == curbuf->b_maphash && haskey && hasarg && maptype != 1)\n    {\n\t/* need to loop over all global hash lists */\n\tfor (hash = 0; hash < 256 && !got_int; ++hash)\n\t{\n\t    if (abbrev)\n\t    {\n\t\tif (hash != 0)\t/* there is only one abbreviation list */\n\t\t    break;\n\t\tmp = first_abbr;\n\t    }\n\t    else\n\t\tmp = maphash[hash];\n\t    for ( ; mp != NULL && !got_int; mp = mp->m_next)\n\t    {\n\t\t/* check entries with the same mode */\n\t\tif ((mp->m_mode & mode) != 0\n\t\t\t&& mp->m_keylen == len\n\t\t\t&& unique\n\t\t\t&& STRNCMP(mp->m_keys, keys, (size_t)len) == 0)\n\t\t{\n\t\t    if (abbrev)\n\t\t\tsemsg(_(\"E224: global abbreviation already exists for %s\"),\n\t\t\t\tmp->m_keys);\n\t\t    else\n\t\t\tsemsg(_(\"E225: global mapping already exists for %s\"),\n\t\t\t\tmp->m_keys);\n\t\t    retval = 5;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * When listing global mappings, also list buffer-local ones here.\n     */\n    if (map_table != curbuf->b_maphash && !hasarg && maptype != 1)\n    {\n\t/* need to loop over all global hash lists */\n\tfor (hash = 0; hash < 256 && !got_int; ++hash)\n\t{\n\t    if (abbrev)\n\t    {\n\t\tif (hash != 0)\t/* there is only one abbreviation list */\n\t\t    break;\n\t\tmp = curbuf->b_first_abbr;\n\t    }\n\t    else\n\t\tmp = curbuf->b_maphash[hash];\n\t    for ( ; mp != NULL && !got_int; mp = mp->m_next)\n\t    {\n\t\t/* check entries with the same mode */\n\t\tif ((mp->m_mode & mode) != 0)\n\t\t{\n\t\t    if (!haskey)\t\t    /* show all entries */\n\t\t    {\n\t\t\tshowmap(mp, TRUE);\n\t\t\tdid_local = TRUE;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tn = mp->m_keylen;\n\t\t\tif (STRNCMP(mp->m_keys, keys,\n\t\t\t\t\t    (size_t)(n < len ? n : len)) == 0)\n\t\t\t{\n\t\t\t    showmap(mp, TRUE);\n\t\t\t    did_local = TRUE;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    /*\n     * Find an entry in the maphash[] list that matches.\n     * For :unmap we may loop two times: once to try to unmap an entry with a\n     * matching 'from' part, a second time, if the first fails, to unmap an\n     * entry with a matching 'to' part. This was done to allow \":ab foo bar\"\n     * to be unmapped by typing \":unab foo\", where \"foo\" will be replaced by\n     * \"bar\" because of the abbreviation.\n     */\n    for (round = 0; (round == 0 || maptype == 1) && round <= 1\n\t\t\t\t\t      && !did_it && !got_int; ++round)\n    {\n\t/* need to loop over all hash lists */\n\tfor (hash = 0; hash < 256 && !got_int; ++hash)\n\t{\n\t    if (abbrev)\n\t    {\n\t\tif (hash > 0)\t/* there is only one abbreviation list */\n\t\t    break;\n\t\tmpp = abbr_table;\n\t    }\n\t    else\n\t\tmpp = &(map_table[hash]);\n\t    for (mp = *mpp; mp != NULL && !got_int; mp = *mpp)\n\t    {\n\n\t\tif (!(mp->m_mode & mode))   /* skip entries with wrong mode */\n\t\t{\n\t\t    mpp = &(mp->m_next);\n\t\t    continue;\n\t\t}\n\t\tif (!haskey)\t\t    /* show all entries */\n\t\t{\n\t\t    showmap(mp, map_table != maphash);\n\t\t    did_it = TRUE;\n\t\t}\n\t\telse\t\t\t    /* do we have a match? */\n\t\t{\n\t\t    if (round)\t    /* second round: Try unmap \"rhs\" string */\n\t\t    {\n\t\t\tn = (int)STRLEN(mp->m_str);\n\t\t\tp = mp->m_str;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tn = mp->m_keylen;\n\t\t\tp = mp->m_keys;\n\t\t    }\n\t\t    if (STRNCMP(p, keys, (size_t)(n < len ? n : len)) == 0)\n\t\t    {\n\t\t\tif (maptype == 1)\t/* delete entry */\n\t\t\t{\n\t\t\t    /* Only accept a full match.  For abbreviations we\n\t\t\t     * ignore trailing space when matching with the\n\t\t\t     * \"lhs\", since an abbreviation can't have\n\t\t\t     * trailing space. */\n\t\t\t    if (n != len && (!abbrev || round || n > len\n\t\t\t\t\t       || *skipwhite(keys + n) != NUL))\n\t\t\t    {\n\t\t\t\tmpp = &(mp->m_next);\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * We reset the indicated mode bits. If nothing is\n\t\t\t     * left the entry is deleted below.\n\t\t\t     */\n\t\t\t    mp->m_mode &= ~mode;\n\t\t\t    did_it = TRUE;\t/* remember we did something */\n\t\t\t}\n\t\t\telse if (!hasarg)\t/* show matching entry */\n\t\t\t{\n\t\t\t    showmap(mp, map_table != maphash);\n\t\t\t    did_it = TRUE;\n\t\t\t}\n\t\t\telse if (n != len)\t/* new entry is ambiguous */\n\t\t\t{\n\t\t\t    mpp = &(mp->m_next);\n\t\t\t    continue;\n\t\t\t}\n\t\t\telse if (unique)\n\t\t\t{\n\t\t\t    if (abbrev)\n\t\t\t\tsemsg(_(\"E226: abbreviation already exists for %s\"),\n\t\t\t\t\t\t\t\t\t   p);\n\t\t\t    else\n\t\t\t\tsemsg(_(\"E227: mapping already exists for %s\"), p);\n\t\t\t    retval = 5;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\t\t\t/* new rhs for existing entry */\n\t\t\t{\n\t\t\t    mp->m_mode &= ~mode;\t/* remove mode bits */\n\t\t\t    if (mp->m_mode == 0 && !did_it) /* reuse entry */\n\t\t\t    {\n\t\t\t\tnewstr = vim_strsave(rhs);\n\t\t\t\tif (newstr == NULL)\n\t\t\t\t{\n\t\t\t\t    retval = 4;\t\t/* no mem */\n\t\t\t\t    goto theend;\n\t\t\t\t}\n\t\t\t\tvim_free(mp->m_str);\n\t\t\t\tmp->m_str = newstr;\n\t\t\t\tvim_free(mp->m_orig_str);\n\t\t\t\tmp->m_orig_str = vim_strsave(orig_rhs);\n\t\t\t\tmp->m_noremap = noremap;\n\t\t\t\tmp->m_nowait = nowait;\n\t\t\t\tmp->m_silent = silent;\n\t\t\t\tmp->m_mode = mode;\n#ifdef FEAT_EVAL\n\t\t\t\tmp->m_expr = expr;\n\t\t\t\tmp->m_script_ctx = current_sctx;\n\t\t\t\tmp->m_script_ctx.sc_lnum += sourcing_lnum;\n#endif\n\t\t\t\tdid_it = TRUE;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (mp->m_mode == 0)\t/* entry can be deleted */\n\t\t\t{\n\t\t\t    map_free(mpp);\n\t\t\t    continue;\t\t/* continue with *mpp */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * May need to put this entry into another hash list.\n\t\t\t */\n\t\t\tnew_hash = MAP_HASH(mp->m_mode, mp->m_keys[0]);\n\t\t\tif (!abbrev && new_hash != hash)\n\t\t\t{\n\t\t\t    *mpp = mp->m_next;\n\t\t\t    mp->m_next = map_table[new_hash];\n\t\t\t    map_table[new_hash] = mp;\n\n\t\t\t    continue;\t\t/* continue with *mpp */\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tmpp = &(mp->m_next);\n\t    }\n\t}\n    }\n\n    if (maptype == 1)\t\t\t    /* delete entry */\n    {\n\tif (!did_it)\n\t    retval = 2;\t\t\t    /* no match */\n\telse if (*keys == Ctrl_C)\n\t{\n\t    /* If CTRL-C has been unmapped, reuse it for Interrupting. */\n#ifdef FEAT_LOCALMAP\n\t    if (map_table == curbuf->b_maphash)\n\t\tcurbuf->b_mapped_ctrl_c &= ~mode;\n\t    else\n#endif\n\t\tmapped_ctrl_c &= ~mode;\n\t}\n\tgoto theend;\n    }\n\n    if (!haskey || !hasarg)\t\t    /* print entries */\n    {\n\tif (!did_it\n#ifdef FEAT_LOCALMAP\n\t\t&& !did_local\n#endif\n\t\t)\n\t{\n\t    if (abbrev)\n\t\tmsg(_(\"No abbreviation found\"));\n\t    else\n\t\tmsg(_(\"No mapping found\"));\n\t}\n\tgoto theend;\t\t\t    /* listing finished */\n    }\n\n    if (did_it)\t\t\t/* have added the new entry already */\n\tgoto theend;\n\n    /*\n     * Get here when adding a new entry to the maphash[] list or abbrlist.\n     */\n    mp = (mapblock_T *)alloc((unsigned)sizeof(mapblock_T));\n    if (mp == NULL)\n    {\n\tretval = 4;\t    /* no mem */\n\tgoto theend;\n    }\n\n    /* If CTRL-C has been mapped, don't always use it for Interrupting. */\n    if (*keys == Ctrl_C)\n    {\n#ifdef FEAT_LOCALMAP\n\tif (map_table == curbuf->b_maphash)\n\t    curbuf->b_mapped_ctrl_c |= mode;\n\telse\n#endif\n\t    mapped_ctrl_c |= mode;\n    }\n\n    mp->m_keys = vim_strsave(keys);\n    mp->m_str = vim_strsave(rhs);\n    mp->m_orig_str = vim_strsave(orig_rhs);\n    if (mp->m_keys == NULL || mp->m_str == NULL)\n    {\n\tvim_free(mp->m_keys);\n\tvim_free(mp->m_str);\n\tvim_free(mp->m_orig_str);\n\tvim_free(mp);\n\tretval = 4;\t/* no mem */\n\tgoto theend;\n    }\n    mp->m_keylen = (int)STRLEN(mp->m_keys);\n    mp->m_noremap = noremap;\n    mp->m_nowait = nowait;\n    mp->m_silent = silent;\n    mp->m_mode = mode;\n#ifdef FEAT_EVAL\n    mp->m_expr = expr;\n    mp->m_script_ctx = current_sctx;\n    mp->m_script_ctx.sc_lnum += sourcing_lnum;\n#endif\n\n    /* add the new entry in front of the abbrlist or maphash[] list */\n    if (abbrev)\n    {\n\tmp->m_next = *abbr_table;\n\t*abbr_table = mp;\n    }\n    else\n    {\n\tn = MAP_HASH(mp->m_mode, mp->m_keys[0]);\n\tmp->m_next = map_table[n];\n\tmap_table[n] = mp;\n    }\n\ntheend:\n    vim_free(keys_buf);\n    vim_free(arg_buf);\n    return retval;\n}\n\n/*\n * Delete one entry from the abbrlist or maphash[].\n * \"mpp\" is a pointer to the m_next field of the PREVIOUS entry!\n */\n    static void\nmap_free(mapblock_T **mpp)\n{\n    mapblock_T\t*mp;\n\n    mp = *mpp;\n    vim_free(mp->m_keys);\n    vim_free(mp->m_str);\n    vim_free(mp->m_orig_str);\n    *mpp = mp->m_next;\n    vim_free(mp);\n}\n\n/*\n * Initialize maphash[] for first use.\n */\n    static void\nvalidate_maphash(void)\n{\n    if (!maphash_valid)\n    {\n\tvim_memset(maphash, 0, sizeof(maphash));\n\tmaphash_valid = TRUE;\n    }\n}\n\n/*\n * Get the mapping mode from the command name.\n */\n    int\nget_map_mode(char_u **cmdp, int forceit)\n{\n    char_u\t*p;\n    int\t\tmodec;\n    int\t\tmode;\n\n    p = *cmdp;\n    modec = *p++;\n    if (modec == 'i')\n\tmode = INSERT;\t\t\t\t/* :imap */\n    else if (modec == 'l')\n\tmode = LANGMAP;\t\t\t\t/* :lmap */\n    else if (modec == 'c')\n\tmode = CMDLINE;\t\t\t\t/* :cmap */\n    else if (modec == 'n' && *p != 'o')\t\t    /* avoid :noremap */\n\tmode = NORMAL;\t\t\t\t/* :nmap */\n    else if (modec == 'v')\n\tmode = VISUAL + SELECTMODE;\t\t/* :vmap */\n    else if (modec == 'x')\n\tmode = VISUAL;\t\t\t\t/* :xmap */\n    else if (modec == 's')\n\tmode = SELECTMODE;\t\t\t/* :smap */\n    else if (modec == 'o')\n\tmode = OP_PENDING;\t\t\t/* :omap */\n    else if (modec == 't')\n\tmode = TERMINAL;\t\t\t/* :tmap */\n    else\n    {\n\t--p;\n\tif (forceit)\n\t    mode = INSERT + CMDLINE;\t\t/* :map ! */\n\telse\n\t    mode = VISUAL + SELECTMODE + NORMAL + OP_PENDING;/* :map */\n    }\n\n    *cmdp = p;\n    return mode;\n}\n\n/*\n * Clear all mappings or abbreviations.\n * 'abbr' should be FALSE for mappings, TRUE for abbreviations.\n */\n    void\nmap_clear(\n    char_u\t*cmdp,\n    char_u\t*arg UNUSED,\n    int\t\tforceit,\n    int\t\tabbr)\n{\n    int\t\tmode;\n#ifdef FEAT_LOCALMAP\n    int\t\tlocal;\n\n    local = (STRCMP(arg, \"<buffer>\") == 0);\n    if (!local && *arg != NUL)\n    {\n\temsg(_(e_invarg));\n\treturn;\n    }\n#endif\n\n    mode = get_map_mode(&cmdp, forceit);\n    map_clear_int(curbuf, mode,\n#ifdef FEAT_LOCALMAP\n\t    local,\n#else\n\t    FALSE,\n#endif\n\t    abbr);\n}\n\n/*\n * Clear all mappings in \"mode\".\n */\n    void\nmap_clear_int(\n    buf_T\t*buf UNUSED,\t/* buffer for local mappings */\n    int\t\tmode,\t\t/* mode in which to delete */\n    int\t\tlocal UNUSED,\t/* TRUE for buffer-local mappings */\n    int\t\tabbr)\t\t/* TRUE for abbreviations */\n{\n    mapblock_T\t*mp, **mpp;\n    int\t\thash;\n    int\t\tnew_hash;\n\n    validate_maphash();\n\n    for (hash = 0; hash < 256; ++hash)\n    {\n\tif (abbr)\n\t{\n\t    if (hash > 0)\t/* there is only one abbrlist */\n\t\tbreak;\n#ifdef FEAT_LOCALMAP\n\t    if (local)\n\t\tmpp = &buf->b_first_abbr;\n\t    else\n#endif\n\t\tmpp = &first_abbr;\n\t}\n\telse\n\t{\n#ifdef FEAT_LOCALMAP\n\t    if (local)\n\t\tmpp = &buf->b_maphash[hash];\n\t    else\n#endif\n\t\tmpp = &maphash[hash];\n\t}\n\twhile (*mpp != NULL)\n\t{\n\t    mp = *mpp;\n\t    if (mp->m_mode & mode)\n\t    {\n\t\tmp->m_mode &= ~mode;\n\t\tif (mp->m_mode == 0) /* entry can be deleted */\n\t\t{\n\t\t    map_free(mpp);\n\t\t    continue;\n\t\t}\n\t\t/*\n\t\t * May need to put this entry into another hash list.\n\t\t */\n\t\tnew_hash = MAP_HASH(mp->m_mode, mp->m_keys[0]);\n\t\tif (!abbr && new_hash != hash)\n\t\t{\n\t\t    *mpp = mp->m_next;\n#ifdef FEAT_LOCALMAP\n\t\t    if (local)\n\t\t    {\n\t\t\tmp->m_next = buf->b_maphash[new_hash];\n\t\t\tbuf->b_maphash[new_hash] = mp;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tmp->m_next = maphash[new_hash];\n\t\t\tmaphash[new_hash] = mp;\n\t\t    }\n\t\t    continue;\t\t/* continue with *mpp */\n\t\t}\n\t    }\n\t    mpp = &(mp->m_next);\n\t}\n    }\n}\n\n/*\n * Return characters to represent the map mode in an allocated string.\n * Returns NULL when out of memory.\n */\n    char_u *\nmap_mode_to_chars(int mode)\n{\n    garray_T    mapmode;\n\n    ga_init2(&mapmode, 1, 7);\n\n    if ((mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)\n\tga_append(&mapmode, '!');\t\t\t/* :map! */\n    else if (mode & INSERT)\n\tga_append(&mapmode, 'i');\t\t\t/* :imap */\n    else if (mode & LANGMAP)\n\tga_append(&mapmode, 'l');\t\t\t/* :lmap */\n    else if (mode & CMDLINE)\n\tga_append(&mapmode, 'c');\t\t\t/* :cmap */\n    else if ((mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING))\n\t\t\t\t == NORMAL + VISUAL + SELECTMODE + OP_PENDING)\n\tga_append(&mapmode, ' ');\t\t\t/* :map */\n    else\n    {\n\tif (mode & NORMAL)\n\t    ga_append(&mapmode, 'n');\t\t\t/* :nmap */\n\tif (mode & OP_PENDING)\n\t    ga_append(&mapmode, 'o');\t\t\t/* :omap */\n\tif ((mode & (VISUAL + SELECTMODE)) == VISUAL + SELECTMODE)\n\t    ga_append(&mapmode, 'v');\t\t\t/* :vmap */\n\telse\n\t{\n\t    if (mode & VISUAL)\n\t\tga_append(&mapmode, 'x');\t\t/* :xmap */\n\t    if (mode & SELECTMODE)\n\t\tga_append(&mapmode, 's');\t\t/* :smap */\n\t}\n    }\n\n    ga_append(&mapmode, NUL);\n    return (char_u *)mapmode.ga_data;\n}\n\n    static void\nshowmap(\n    mapblock_T\t*mp,\n    int\t\tlocal)\t    /* TRUE for buffer-local map */\n{\n    int\t\tlen = 1;\n    char_u\t*mapchars;\n\n    if (message_filtered(mp->m_keys) && message_filtered(mp->m_str))\n\treturn;\n\n    if (msg_didout || msg_silent != 0)\n    {\n\tmsg_putchar('\\n');\n\tif (got_int)\t    /* 'q' typed at MORE prompt */\n\t    return;\n    }\n\n    mapchars = map_mode_to_chars(mp->m_mode);\n    if (mapchars != NULL)\n    {\n\tmsg_puts((char *)mapchars);\n\tlen = (int)STRLEN(mapchars);\n\tvim_free(mapchars);\n    }\n\n    while (++len <= 3)\n\tmsg_putchar(' ');\n\n    /* Display the LHS.  Get length of what we write. */\n    len = msg_outtrans_special(mp->m_keys, TRUE, 0);\n    do\n    {\n\tmsg_putchar(' ');\t\t/* padd with blanks */\n\t++len;\n    } while (len < 12);\n\n    if (mp->m_noremap == REMAP_NONE)\n\tmsg_puts_attr(\"*\", HL_ATTR(HLF_8));\n    else if (mp->m_noremap == REMAP_SCRIPT)\n\tmsg_puts_attr(\"&\", HL_ATTR(HLF_8));\n    else\n\tmsg_putchar(' ');\n\n    if (local)\n\tmsg_putchar('@');\n    else\n\tmsg_putchar(' ');\n\n    /* Use FALSE below if we only want things like <Up> to show up as such on\n     * the rhs, and not M-x etc, TRUE gets both -- webb */\n    if (*mp->m_str == NUL)\n\tmsg_puts_attr(\"<Nop>\", HL_ATTR(HLF_8));\n    else\n    {\n\t/* Remove escaping of CSI, because \"m_str\" is in a format to be used\n\t * as typeahead. */\n\tchar_u *s = vim_strsave(mp->m_str);\n\tif (s != NULL)\n\t{\n\t    vim_unescape_csi(s);\n\t    msg_outtrans_special(s, FALSE, 0);\n\t    vim_free(s);\n\t}\n    }\n#ifdef FEAT_EVAL\n    if (p_verbose > 0)\n\tlast_set_msg(mp->m_script_ctx);\n#endif\n    out_flush();\t\t\t/* show one line at a time */\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if a map exists that has \"str\" in the rhs for mode \"modechars\".\n * Recognize termcap codes in \"str\".\n * Also checks mappings local to the current buffer.\n */\n    int\nmap_to_exists(char_u *str, char_u *modechars, int abbr)\n{\n    int\t\tmode = 0;\n    char_u\t*rhs;\n    char_u\t*buf;\n    int\t\tretval;\n\n    rhs = replace_termcodes(str, &buf, FALSE, TRUE, FALSE);\n\n    if (vim_strchr(modechars, 'n') != NULL)\n\tmode |= NORMAL;\n    if (vim_strchr(modechars, 'v') != NULL)\n\tmode |= VISUAL + SELECTMODE;\n    if (vim_strchr(modechars, 'x') != NULL)\n\tmode |= VISUAL;\n    if (vim_strchr(modechars, 's') != NULL)\n\tmode |= SELECTMODE;\n    if (vim_strchr(modechars, 'o') != NULL)\n\tmode |= OP_PENDING;\n    if (vim_strchr(modechars, 'i') != NULL)\n\tmode |= INSERT;\n    if (vim_strchr(modechars, 'l') != NULL)\n\tmode |= LANGMAP;\n    if (vim_strchr(modechars, 'c') != NULL)\n\tmode |= CMDLINE;\n\n    retval = map_to_exists_mode(rhs, mode, abbr);\n    vim_free(buf);\n\n    return retval;\n}\n#endif\n\n/*\n * Return TRUE if a map exists that has \"str\" in the rhs for mode \"mode\".\n * Also checks mappings local to the current buffer.\n */\n    int\nmap_to_exists_mode(char_u *rhs, int mode, int abbr)\n{\n    mapblock_T\t*mp;\n    int\t\thash;\n# ifdef FEAT_LOCALMAP\n    int\t\texp_buffer = FALSE;\n\n    validate_maphash();\n\n    /* Do it twice: once for global maps and once for local maps. */\n    for (;;)\n    {\n# endif\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (abbr)\n\t    {\n\t\tif (hash > 0)\t\t/* there is only one abbr list */\n\t\t    break;\n#ifdef FEAT_LOCALMAP\n\t\tif (exp_buffer)\n\t\t    mp = curbuf->b_first_abbr;\n\t\telse\n#endif\n\t\t    mp = first_abbr;\n\t    }\n# ifdef FEAT_LOCALMAP\n\t    else if (exp_buffer)\n\t\tmp = curbuf->b_maphash[hash];\n# endif\n\t    else\n\t\tmp = maphash[hash];\n\t    for (; mp; mp = mp->m_next)\n\t    {\n\t\tif ((mp->m_mode & mode)\n\t\t\t&& strstr((char *)mp->m_str, (char *)rhs) != NULL)\n\t\t    return TRUE;\n\t    }\n\t}\n# ifdef FEAT_LOCALMAP\n\tif (exp_buffer)\n\t    break;\n\texp_buffer = TRUE;\n    }\n# endif\n\n    return FALSE;\n}\n\n#if defined(FEAT_CMDL_COMPL) || defined(PROTO)\n/*\n * Used below when expanding mapping/abbreviation names.\n */\nstatic int\texpand_mapmodes = 0;\nstatic int\texpand_isabbrev = 0;\n#ifdef FEAT_LOCALMAP\nstatic int\texpand_buffer = FALSE;\n#endif\n\n/*\n * Work out what to complete when doing command line completion of mapping\n * or abbreviation names.\n */\n    char_u *\nset_context_in_map_cmd(\n    expand_T\t*xp,\n    char_u\t*cmd,\n    char_u\t*arg,\n    int\t\tforceit,\t/* TRUE if '!' given */\n    int\t\tisabbrev,\t/* TRUE if abbreviation */\n    int\t\tisunmap,\t/* TRUE if unmap/unabbrev command */\n    cmdidx_T\tcmdidx)\n{\n    if (forceit && cmdidx != CMD_map && cmdidx != CMD_unmap)\n\txp->xp_context = EXPAND_NOTHING;\n    else\n    {\n\tif (isunmap)\n\t    expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);\n\telse\n\t{\n\t    expand_mapmodes = INSERT + CMDLINE;\n\t    if (!isabbrev)\n\t\texpand_mapmodes += VISUAL + SELECTMODE + NORMAL + OP_PENDING;\n\t}\n\texpand_isabbrev = isabbrev;\n\txp->xp_context = EXPAND_MAPPINGS;\n#ifdef FEAT_LOCALMAP\n\texpand_buffer = FALSE;\n#endif\n\tfor (;;)\n\t{\n#ifdef FEAT_LOCALMAP\n\t    if (STRNCMP(arg, \"<buffer>\", 8) == 0)\n\t    {\n\t\texpand_buffer = TRUE;\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n#endif\n\t    if (STRNCMP(arg, \"<unique>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<nowait>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<silent>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<special>\", 9) == 0)\n\t    {\n\t\targ = skipwhite(arg + 9);\n\t\tcontinue;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (STRNCMP(arg, \"<script>\", 8) == 0)\n\t    {\n\t\targ = skipwhite(arg + 8);\n\t\tcontinue;\n\t    }\n\t    if (STRNCMP(arg, \"<expr>\", 6) == 0)\n\t    {\n\t\targ = skipwhite(arg + 6);\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\txp->xp_pattern = arg;\n    }\n\n    return NULL;\n}\n\n/*\n * Find all mapping/abbreviation names that match regexp \"regmatch\"'.\n * For command line expansion of \":[un]map\" and \":[un]abbrev\" in all modes.\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandMappings(\n    regmatch_T\t*regmatch,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    mapblock_T\t*mp;\n    int\t\thash;\n    int\t\tcount;\n    int\t\tround;\n    char_u\t*p;\n    int\t\ti;\n\n    validate_maphash();\n\n    *num_file = 0;\t\t    /* return values in case of FAIL */\n    *file = NULL;\n\n    /*\n     * round == 1: Count the matches.\n     * round == 2: Build the array to keep the matches.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\tcount = 0;\n\n\tfor (i = 0; i < 7; ++i)\n\t{\n\t    if (i == 0)\n\t\tp = (char_u *)\"<silent>\";\n\t    else if (i == 1)\n\t\tp = (char_u *)\"<unique>\";\n#ifdef FEAT_EVAL\n\t    else if (i == 2)\n\t\tp = (char_u *)\"<script>\";\n\t    else if (i == 3)\n\t\tp = (char_u *)\"<expr>\";\n#endif\n#ifdef FEAT_LOCALMAP\n\t    else if (i == 4 && !expand_buffer)\n\t\tp = (char_u *)\"<buffer>\";\n#endif\n\t    else if (i == 5)\n\t\tp = (char_u *)\"<nowait>\";\n\t    else if (i == 6)\n\t\tp = (char_u *)\"<special>\";\n\t    else\n\t\tcontinue;\n\n\t    if (vim_regexec(regmatch, p, (colnr_T)0))\n\t    {\n\t\tif (round == 1)\n\t\t    ++count;\n\t\telse\n\t\t    (*file)[count++] = vim_strsave(p);\n\t    }\n\t}\n\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (expand_isabbrev)\n\t    {\n\t\tif (hash > 0)\t/* only one abbrev list */\n\t\t    break; /* for (hash) */\n\t\tmp = first_abbr;\n\t    }\n#ifdef FEAT_LOCALMAP\n\t    else if (expand_buffer)\n\t\tmp = curbuf->b_maphash[hash];\n#endif\n\t    else\n\t\tmp = maphash[hash];\n\t    for (; mp; mp = mp->m_next)\n\t    {\n\t\tif (mp->m_mode & expand_mapmodes)\n\t\t{\n\t\t    p = translate_mapping(mp->m_keys);\n\t\t    if (p != NULL && vim_regexec(regmatch, p, (colnr_T)0))\n\t\t    {\n\t\t\tif (round == 1)\n\t\t\t    ++count;\n\t\t\telse\n\t\t\t{\n\t\t\t    (*file)[count++] = p;\n\t\t\t    p = NULL;\n\t\t\t}\n\t\t    }\n\t\t    vim_free(p);\n\t\t}\n\t    } /* for (mp) */\n\t} /* for (hash) */\n\n\tif (count == 0)\t\t\t/* no match found */\n\t    break; /* for (round) */\n\n\tif (round == 1)\n\t{\n\t    *file = (char_u **)alloc((unsigned)(count * sizeof(char_u *)));\n\t    if (*file == NULL)\n\t\treturn FAIL;\n\t}\n    } /* for (round) */\n\n    if (count > 1)\n    {\n\tchar_u\t**ptr1;\n\tchar_u\t**ptr2;\n\tchar_u\t**ptr3;\n\n\t/* Sort the matches */\n\tsort_strings(*file, count);\n\n\t/* Remove multiple entries */\n\tptr1 = *file;\n\tptr2 = ptr1 + 1;\n\tptr3 = ptr1 + count;\n\n\twhile (ptr2 < ptr3)\n\t{\n\t    if (STRCMP(*ptr1, *ptr2))\n\t\t*++ptr1 = *ptr2++;\n\t    else\n\t    {\n\t\tvim_free(*ptr2++);\n\t\tcount--;\n\t    }\n\t}\n    }\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n#endif /* FEAT_CMDL_COMPL */\n\n/*\n * Check for an abbreviation.\n * Cursor is at ptr[col].\n * When inserting, mincol is where insert started.\n * For the command line, mincol is what is to be skipped over.\n * \"c\" is the character typed before check_abbr was called.  It may have\n * ABBR_OFF added to avoid prepending a CTRL-V to it.\n *\n * Historic vi practice: The last character of an abbreviation must be an id\n * character ([a-zA-Z0-9_]). The characters in front of it must be all id\n * characters or all non-id characters. This allows for abbr. \"#i\" to\n * \"#include\".\n *\n * Vim addition: Allow for abbreviations that end in a non-keyword character.\n * Then there must be white space before the abbr.\n *\n * return TRUE if there is an abbreviation, FALSE if not\n */\n    int\ncheck_abbr(\n    int\t\tc,\n    char_u\t*ptr,\n    int\t\tcol,\n    int\t\tmincol)\n{\n    int\t\tlen;\n    int\t\tscol;\t\t/* starting column of the abbr. */\n    int\t\tj;\n    char_u\t*s;\n    char_u\ttb[MB_MAXBYTES + 4];\n    mapblock_T\t*mp;\n#ifdef FEAT_LOCALMAP\n    mapblock_T\t*mp2;\n#endif\n    int\t\tclen = 0;\t/* length in characters */\n    int\t\tis_id = TRUE;\n    int\t\tvim_abbr;\n\n    if (typebuf.tb_no_abbr_cnt)\t/* abbrev. are not recursive */\n\treturn FALSE;\n\n    /* no remapping implies no abbreviation, except for CTRL-] */\n    if ((KeyNoremap & (RM_NONE|RM_SCRIPT)) != 0 && c != Ctrl_RSB)\n\treturn FALSE;\n\n    /*\n     * Check for word before the cursor: If it ends in a keyword char all\n     * chars before it must be keyword chars or non-keyword chars, but not\n     * white space. If it ends in a non-keyword char we accept any characters\n     * before it except white space.\n     */\n    if (col == 0)\t\t\t\t/* cannot be an abbr. */\n\treturn FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\tp = mb_prevptr(ptr, ptr + col);\n\tif (!vim_iswordp(p))\n\t    vim_abbr = TRUE;\t\t\t/* Vim added abbr. */\n\telse\n\t{\n\t    vim_abbr = FALSE;\t\t\t/* vi compatible abbr. */\n\t    if (p > ptr)\n\t\tis_id = vim_iswordp(mb_prevptr(ptr, p));\n\t}\n\tclen = 1;\n\twhile (p > ptr + mincol)\n\t{\n\t    p = mb_prevptr(ptr, p);\n\t    if (vim_isspace(*p) || (!vim_abbr && is_id != vim_iswordp(p)))\n\t    {\n\t\tp += (*mb_ptr2len)(p);\n\t\tbreak;\n\t    }\n\t    ++clen;\n\t}\n\tscol = (int)(p - ptr);\n    }\n    else\n    {\n\tif (!vim_iswordc(ptr[col - 1]))\n\t    vim_abbr = TRUE;\t\t\t/* Vim added abbr. */\n\telse\n\t{\n\t    vim_abbr = FALSE;\t\t\t/* vi compatible abbr. */\n\t    if (col > 1)\n\t\tis_id = vim_iswordc(ptr[col - 2]);\n\t}\n\tfor (scol = col - 1; scol > 0 && !vim_isspace(ptr[scol - 1])\n\t\t&& (vim_abbr || is_id == vim_iswordc(ptr[scol - 1])); --scol)\n\t    ;\n    }\n\n    if (scol < mincol)\n\tscol = mincol;\n    if (scol < col)\t\t/* there is a word in front of the cursor */\n    {\n\tptr += scol;\n\tlen = col - scol;\n#ifdef FEAT_LOCALMAP\n\tmp = curbuf->b_first_abbr;\n\tmp2 = first_abbr;\n\tif (mp == NULL)\n\t{\n\t    mp = mp2;\n\t    mp2 = NULL;\n\t}\n#else\n\tmp = first_abbr;\n#endif\n\tfor ( ; mp;\n#ifdef FEAT_LOCALMAP\n\t\tmp->m_next == NULL ? (mp = mp2, mp2 = NULL) :\n#endif\n\t\t(mp = mp->m_next))\n\t{\n\t    int\t\tqlen = mp->m_keylen;\n\t    char_u\t*q = mp->m_keys;\n\t    int\t\tmatch;\n\n\t    if (vim_strbyte(mp->m_keys, K_SPECIAL) != NULL)\n\t    {\n\t\tchar_u *qe = vim_strsave(mp->m_keys);\n\n\t\t/* might have CSI escaped mp->m_keys */\n\t\tif (qe != NULL)\n\t\t{\n\t\t    q = qe;\n\t\t    vim_unescape_csi(q);\n\t\t    qlen = (int)STRLEN(q);\n\t\t}\n\t    }\n\n\t    /* find entries with right mode and keys */\n\t    match =    (mp->m_mode & State)\n\t\t    && qlen == len\n\t\t    && !STRNCMP(q, ptr, (size_t)len);\n\t    if (q != mp->m_keys)\n\t\tvim_free(q);\n\t    if (match)\n\t\tbreak;\n\t}\n\tif (mp != NULL)\n\t{\n\t    /*\n\t     * Found a match:\n\t     * Insert the rest of the abbreviation in typebuf.tb_buf[].\n\t     * This goes from end to start.\n\t     *\n\t     * Characters 0x000 - 0x100: normal chars, may need CTRL-V,\n\t     * except K_SPECIAL: Becomes K_SPECIAL KS_SPECIAL KE_FILLER\n\t     * Characters where IS_SPECIAL() == TRUE: key codes, need\n\t     * K_SPECIAL. Other characters (with ABBR_OFF): don't use CTRL-V.\n\t     *\n\t     * Character CTRL-] is treated specially - it completes the\n\t     * abbreviation, but is not inserted into the input stream.\n\t     */\n\t    j = 0;\n\t    if (c != Ctrl_RSB)\n\t    {\n\t\t\t\t\t/* special key code, split up */\n\t\tif (IS_SPECIAL(c) || c == K_SPECIAL)\n\t\t{\n\t\t    tb[j++] = K_SPECIAL;\n\t\t    tb[j++] = K_SECOND(c);\n\t\t    tb[j++] = K_THIRD(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (c < ABBR_OFF && (c < ' ' || c > '~'))\n\t\t\ttb[j++] = Ctrl_V;\t/* special char needs CTRL-V */\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t/* if ABBR_OFF has been added, remove it here */\n\t\t\tif (c >= ABBR_OFF)\n\t\t\t    c -= ABBR_OFF;\n\t\t\tj += (*mb_char2bytes)(c, tb + j);\n\t\t    }\n\t\t    else\n\t\t\ttb[j++] = c;\n\t\t}\n\t\ttb[j] = NUL;\n\t\t\t\t\t/* insert the last typed char */\n\t\t(void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);\n\t    }\n#ifdef FEAT_EVAL\n\t    if (mp->m_expr)\n\t\ts = eval_map_expr(mp->m_str, c);\n\t    else\n#endif\n\t\ts = mp->m_str;\n\t    if (s != NULL)\n\t    {\n\t\t\t\t\t/* insert the to string */\n\t\t(void)ins_typebuf(s, mp->m_noremap, 0, TRUE, mp->m_silent);\n\t\t\t\t\t/* no abbrev. for these chars */\n\t\ttypebuf.tb_no_abbr_cnt += (int)STRLEN(s) + j + 1;\n#ifdef FEAT_EVAL\n\t\tif (mp->m_expr)\n\t\t    vim_free(s);\n#endif\n\t    }\n\n\t    tb[0] = Ctrl_H;\n\t    tb[1] = NUL;\n\t    if (has_mbyte)\n\t\tlen = clen;\t/* Delete characters instead of bytes */\n\t    while (len-- > 0)\t\t/* delete the from string */\n\t\t(void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Evaluate the RHS of a mapping or abbreviations and take care of escaping\n * special characters.\n */\n    static char_u *\neval_map_expr(\n    char_u\t*str,\n    int\t\tc)\t    /* NUL or typed character for abbreviation */\n{\n    char_u\t*res;\n    char_u\t*p;\n    char_u\t*expr;\n    pos_T\tsave_cursor;\n    int\t\tsave_msg_col;\n    int\t\tsave_msg_row;\n\n    /* Remove escaping of CSI, because \"str\" is in a format to be used as\n     * typeahead. */\n    expr = vim_strsave(str);\n    if (expr == NULL)\n\treturn NULL;\n    vim_unescape_csi(expr);\n\n    /* Forbid changing text or using \":normal\" to avoid most of the bad side\n     * effects.  Also restore the cursor position. */\n    ++textlock;\n    ++ex_normal_lock;\n    set_vim_var_char(c);  /* set v:char to the typed character */\n    save_cursor = curwin->w_cursor;\n    save_msg_col = msg_col;\n    save_msg_row = msg_row;\n    p = eval_to_string(expr, NULL, FALSE);\n    --textlock;\n    --ex_normal_lock;\n    curwin->w_cursor = save_cursor;\n    msg_col = save_msg_col;\n    msg_row = save_msg_row;\n\n    vim_free(expr);\n\n    if (p == NULL)\n\treturn NULL;\n    /* Escape CSI in the result to be able to use the string as typeahead. */\n    res = vim_strsave_escape_csi(p);\n    vim_free(p);\n\n    return res;\n}\n#endif\n\n/*\n * Copy \"p\" to allocated memory, escaping K_SPECIAL and CSI so that the result\n * can be put in the typeahead buffer.\n * Returns NULL when out of memory.\n */\n    char_u *\nvim_strsave_escape_csi(\n    char_u *p)\n{\n    char_u\t*res;\n    char_u\t*s, *d;\n\n    /* Need a buffer to hold up to three times as much.  Four in case of an\n     * illegal utf-8 byte:\n     * 0xc0 -> 0xc3 0x80 -> 0xc3 K_SPECIAL KS_SPECIAL KE_FILLER */\n    res = alloc((unsigned)(STRLEN(p) * 4) + 1);\n    if (res != NULL)\n    {\n\td = res;\n\tfor (s = p; *s != NUL; )\n\t{\n\t    if (s[0] == K_SPECIAL && s[1] != NUL && s[2] != NUL)\n\t    {\n\t\t/* Copy special key unmodified. */\n\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t    }\n\t    else\n\t    {\n\t\t/* Add character, possibly multi-byte to destination, escaping\n\t\t * CSI and K_SPECIAL. Be careful, it can be an illegal byte! */\n\t\td = add_char2buf(PTR2CHAR(s), d);\n\t\ts += MB_CPTR2LEN(s);\n\t    }\n\t}\n\t*d = NUL;\n    }\n    return res;\n}\n\n/*\n * Remove escaping from CSI and K_SPECIAL characters.  Reverse of\n * vim_strsave_escape_csi().  Works in-place.\n */\n    void\nvim_unescape_csi(char_u *p)\n{\n    char_u\t*s = p, *d = p;\n\n    while (*s != NUL)\n    {\n\tif (s[0] == K_SPECIAL && s[1] == KS_SPECIAL && s[2] == KE_FILLER)\n\t{\n\t    *d++ = K_SPECIAL;\n\t    s += 3;\n\t}\n\telse if ((s[0] == K_SPECIAL || s[0] == CSI)\n\t\t\t\t   && s[1] == KS_EXTRA && s[2] == (int)KE_CSI)\n\t{\n\t    *d++ = CSI;\n\t    s += 3;\n\t}\n\telse\n\t    *d++ = *s++;\n    }\n    *d = NUL;\n}\n\n/*\n * Write map commands for the current mappings to an .exrc file.\n * Return FAIL on error, OK otherwise.\n */\n    int\nmakemap(\n    FILE\t*fd,\n    buf_T\t*buf)\t    /* buffer for local mappings or NULL */\n{\n    mapblock_T\t*mp;\n    char_u\tc1, c2, c3;\n    char_u\t*p;\n    char\t*cmd;\n    int\t\tabbr;\n    int\t\thash;\n    int\t\tdid_cpo = FALSE;\n    int\t\ti;\n\n    validate_maphash();\n\n    /*\n     * Do the loop twice: Once for mappings, once for abbreviations.\n     * Then loop over all map hash lists.\n     */\n    for (abbr = 0; abbr < 2; ++abbr)\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (abbr)\n\t    {\n\t\tif (hash > 0)\t\t/* there is only one abbr list */\n\t\t    break;\n#ifdef FEAT_LOCALMAP\n\t\tif (buf != NULL)\n\t\t    mp = buf->b_first_abbr;\n\t\telse\n#endif\n\t\t    mp = first_abbr;\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LOCALMAP\n\t\tif (buf != NULL)\n\t\t    mp = buf->b_maphash[hash];\n\t\telse\n#endif\n\t\t    mp = maphash[hash];\n\t    }\n\n\t    for ( ; mp; mp = mp->m_next)\n\t    {\n\t\t/* skip script-local mappings */\n\t\tif (mp->m_noremap == REMAP_SCRIPT)\n\t\t    continue;\n\n\t\t/* skip mappings that contain a <SNR> (script-local thing),\n\t\t * they probably don't work when loaded again */\n\t\tfor (p = mp->m_str; *p != NUL; ++p)\n\t\t    if (p[0] == K_SPECIAL && p[1] == KS_EXTRA\n\t\t\t\t\t\t       && p[2] == (int)KE_SNR)\n\t\t\tbreak;\n\t\tif (*p != NUL)\n\t\t    continue;\n\n\t\t/* It's possible to create a mapping and then \":unmap\" certain\n\t\t * modes.  We recreate this here by mapping the individual\n\t\t * modes, which requires up to three of them. */\n\t\tc1 = NUL;\n\t\tc2 = NUL;\n\t\tc3 = NUL;\n\t\tif (abbr)\n\t\t    cmd = \"abbr\";\n\t\telse\n\t\t    cmd = \"map\";\n\t\tswitch (mp->m_mode)\n\t\t{\n\t\t    case NORMAL + VISUAL + SELECTMODE + OP_PENDING:\n\t\t\tbreak;\n\t\t    case NORMAL:\n\t\t\tc1 = 'n';\n\t\t\tbreak;\n\t\t    case VISUAL:\n\t\t\tc1 = 'x';\n\t\t\tbreak;\n\t\t    case SELECTMODE:\n\t\t\tc1 = 's';\n\t\t\tbreak;\n\t\t    case OP_PENDING:\n\t\t\tc1 = 'o';\n\t\t\tbreak;\n\t\t    case NORMAL + VISUAL:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'x';\n\t\t\tbreak;\n\t\t    case NORMAL + SELECTMODE:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 's';\n\t\t\tbreak;\n\t\t    case NORMAL + OP_PENDING:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case VISUAL + SELECTMODE:\n\t\t\tc1 = 'v';\n\t\t\tbreak;\n\t\t    case VISUAL + OP_PENDING:\n\t\t\tc1 = 'x';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case SELECTMODE + OP_PENDING:\n\t\t\tc1 = 's';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case NORMAL + VISUAL + SELECTMODE:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'v';\n\t\t\tbreak;\n\t\t    case NORMAL + VISUAL + OP_PENDING:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 'x';\n\t\t\tc3 = 'o';\n\t\t\tbreak;\n\t\t    case NORMAL + SELECTMODE + OP_PENDING:\n\t\t\tc1 = 'n';\n\t\t\tc2 = 's';\n\t\t\tc3 = 'o';\n\t\t\tbreak;\n\t\t    case VISUAL + SELECTMODE + OP_PENDING:\n\t\t\tc1 = 'v';\n\t\t\tc2 = 'o';\n\t\t\tbreak;\n\t\t    case CMDLINE + INSERT:\n\t\t\tif (!abbr)\n\t\t\t    cmd = \"map!\";\n\t\t\tbreak;\n\t\t    case CMDLINE:\n\t\t\tc1 = 'c';\n\t\t\tbreak;\n\t\t    case INSERT:\n\t\t\tc1 = 'i';\n\t\t\tbreak;\n\t\t    case LANGMAP:\n\t\t\tc1 = 'l';\n\t\t\tbreak;\n\t\t    case TERMINAL:\n\t\t\tc1 = 't';\n\t\t\tbreak;\n\t\t    default:\n\t\t\tiemsg(_(\"E228: makemap: Illegal mode\"));\n\t\t\treturn FAIL;\n\t\t}\n\t\tdo\t/* do this twice if c2 is set, 3 times with c3 */\n\t\t{\n\t\t    /* When outputting <> form, need to make sure that 'cpo'\n\t\t     * is set to the Vim default. */\n\t\t    if (!did_cpo)\n\t\t    {\n\t\t\tif (*mp->m_str == NUL)\t\t/* will use <Nop> */\n\t\t\t    did_cpo = TRUE;\n\t\t\telse\n\t\t\t    for (i = 0; i < 2; ++i)\n\t\t\t\tfor (p = (i ? mp->m_str : mp->m_keys); *p; ++p)\n\t\t\t\t    if (*p == K_SPECIAL || *p == NL)\n\t\t\t\t\tdid_cpo = TRUE;\n\t\t\tif (did_cpo)\n\t\t\t{\n\t\t\t    if (fprintf(fd, \"let s:cpo_save=&cpo\") < 0\n\t\t\t\t    || put_eol(fd) < 0\n\t\t\t\t    || fprintf(fd, \"set cpo&vim\") < 0\n\t\t\t\t    || put_eol(fd) < 0)\n\t\t\t\treturn FAIL;\n\t\t\t}\n\t\t    }\n\t\t    if (c1 && putc(c1, fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_noremap != REMAP_YES && fprintf(fd, \"nore\") < 0)\n\t\t\treturn FAIL;\n\t\t    if (fputs(cmd, fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (buf != NULL && fputs(\" <buffer>\", fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_nowait && fputs(\" <nowait>\", fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_silent && fputs(\" <silent>\", fd) < 0)\n\t\t\treturn FAIL;\n#ifdef FEAT_EVAL\n\t\t    if (mp->m_noremap == REMAP_SCRIPT\n\t\t\t\t\t\t && fputs(\"<script>\", fd) < 0)\n\t\t\treturn FAIL;\n\t\t    if (mp->m_expr && fputs(\" <expr>\", fd) < 0)\n\t\t\treturn FAIL;\n#endif\n\n\t\t    if (       putc(' ', fd) < 0\n\t\t\t    || put_escstr(fd, mp->m_keys, 0) == FAIL\n\t\t\t    || putc(' ', fd) < 0\n\t\t\t    || put_escstr(fd, mp->m_str, 1) == FAIL\n\t\t\t    || put_eol(fd) < 0)\n\t\t\treturn FAIL;\n\t\t    c1 = c2;\n\t\t    c2 = c3;\n\t\t    c3 = NUL;\n\t\t} while (c1 != NUL);\n\t    }\n\t}\n\n    if (did_cpo)\n\tif (fprintf(fd, \"let &cpo=s:cpo_save\") < 0\n\t\t|| put_eol(fd) < 0\n\t\t|| fprintf(fd, \"unlet s:cpo_save\") < 0\n\t\t|| put_eol(fd) < 0)\n\t    return FAIL;\n    return OK;\n}\n\n/*\n * write escape string to file\n * \"what\": 0 for :map lhs, 1 for :map rhs, 2 for :set\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nput_escstr(FILE *fd, char_u *strstart, int what)\n{\n    char_u\t*str = strstart;\n    int\t\tc;\n    int\t\tmodifiers;\n\n    /* :map xx <Nop> */\n    if (*str == NUL && what == 1)\n    {\n\tif (fprintf(fd, \"<Nop>\") < 0)\n\t    return FAIL;\n\treturn OK;\n    }\n\n    for ( ; *str != NUL; ++str)\n    {\n\tchar_u\t*p;\n\n\t/* Check for a multi-byte character, which may contain escaped\n\t * K_SPECIAL and CSI bytes */\n\tp = mb_unescape(&str);\n\tif (p != NULL)\n\t{\n\t    while (*p != NUL)\n\t\tif (fputc(*p++, fd) < 0)\n\t\t    return FAIL;\n\t    --str;\n\t    continue;\n\t}\n\n\tc = *str;\n\t/*\n\t * Special key codes have to be translated to be able to make sense\n\t * when they are read back.\n\t */\n\tif (c == K_SPECIAL && what != 2)\n\t{\n\t    modifiers = 0x0;\n\t    if (str[1] == KS_MODIFIER)\n\t    {\n\t\tmodifiers = str[2];\n\t\tstr += 3;\n\t\tc = *str;\n\t    }\n\t    if (c == K_SPECIAL)\n\t    {\n\t\tc = TO_SPECIAL(str[1], str[2]);\n\t\tstr += 2;\n\t    }\n\t    if (IS_SPECIAL(c) || modifiers)\t/* special key */\n\t    {\n\t\tif (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)\n\t\t    return FAIL;\n\t\tcontinue;\n\t    }\n\t}\n\n\t/*\n\t * A '\\n' in a map command should be written as <NL>.\n\t * A '\\n' in a set command should be written as \\^V^J.\n\t */\n\tif (c == NL)\n\t{\n\t    if (what == 2)\n\t    {\n\t\tif (fprintf(fd, IF_EB(\"\\\\\\026\\n\", \"\\\\\" CTRL_V_STR \"\\n\")) < 0)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tif (fprintf(fd, \"<NL>\") < 0)\n\t\t    return FAIL;\n\t    }\n\t    continue;\n\t}\n\n\t/*\n\t * Some characters have to be escaped with CTRL-V to\n\t * prevent them from misinterpreted in DoOneCmd().\n\t * A space, Tab and '\"' has to be escaped with a backslash to\n\t * prevent it to be misinterpreted in do_set().\n\t * A space has to be escaped with a CTRL-V when it's at the start of a\n\t * \":map\" rhs.\n\t * A '<' has to be escaped with a CTRL-V to prevent it being\n\t * interpreted as the start of a special key name.\n\t * A space in the lhs of a :map needs a CTRL-V.\n\t */\n\tif (what == 2 && (VIM_ISWHITE(c) || c == '\"' || c == '\\\\'))\n\t{\n\t    if (putc('\\\\', fd) < 0)\n\t\treturn FAIL;\n\t}\n\telse if (c < ' ' || c > '~' || c == '|'\n\t\t|| (what == 0 && c == ' ')\n\t\t|| (what == 1 && str == strstart && c == ' ')\n\t\t|| (what != 2 && c == '<'))\n\t{\n\t    if (putc(Ctrl_V, fd) < 0)\n\t\treturn FAIL;\n\t}\n\tif (putc(c, fd) < 0)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check all mappings for the presence of special key codes.\n * Used after \":set term=xxx\".\n */\n    void\ncheck_map_keycodes(void)\n{\n    mapblock_T\t*mp;\n    char_u\t*p;\n    int\t\ti;\n    char_u\tbuf[3];\n    char_u\t*save_name;\n    int\t\tabbr;\n    int\t\thash;\n#ifdef FEAT_LOCALMAP\n    buf_T\t*bp;\n#endif\n\n    validate_maphash();\n    save_name = sourcing_name;\n    sourcing_name = (char_u *)\"mappings\"; /* avoids giving error messages */\n\n#ifdef FEAT_LOCALMAP\n    /* This this once for each buffer, and then once for global\n     * mappings/abbreviations with bp == NULL */\n    for (bp = firstbuf; ; bp = bp->b_next)\n    {\n#endif\n\t/*\n\t * Do the loop twice: Once for mappings, once for abbreviations.\n\t * Then loop over all map hash lists.\n\t */\n\tfor (abbr = 0; abbr <= 1; ++abbr)\n\t    for (hash = 0; hash < 256; ++hash)\n\t    {\n\t\tif (abbr)\n\t\t{\n\t\t    if (hash)\t    /* there is only one abbr list */\n\t\t\tbreak;\n#ifdef FEAT_LOCALMAP\n\t\t    if (bp != NULL)\n\t\t\tmp = bp->b_first_abbr;\n\t\t    else\n#endif\n\t\t\tmp = first_abbr;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_LOCALMAP\n\t\t    if (bp != NULL)\n\t\t\tmp = bp->b_maphash[hash];\n\t\t    else\n#endif\n\t\t\tmp = maphash[hash];\n\t\t}\n\t\tfor ( ; mp != NULL; mp = mp->m_next)\n\t\t{\n\t\t    for (i = 0; i <= 1; ++i)\t/* do this twice */\n\t\t    {\n\t\t\tif (i == 0)\n\t\t\t    p = mp->m_keys;\t/* once for the \"from\" part */\n\t\t\telse\n\t\t\t    p = mp->m_str;\t/* and once for the \"to\" part */\n\t\t\twhile (*p)\n\t\t\t{\n\t\t\t    if (*p == K_SPECIAL)\n\t\t\t    {\n\t\t\t\t++p;\n\t\t\t\tif (*p < 128)   /* for \"normal\" tcap entries */\n\t\t\t\t{\n\t\t\t\t    buf[0] = p[0];\n\t\t\t\t    buf[1] = p[1];\n\t\t\t\t    buf[2] = NUL;\n\t\t\t\t    (void)add_termcap_entry(buf, FALSE);\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t    }\n\t\t\t    ++p;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n#ifdef FEAT_LOCALMAP\n\tif (bp == NULL)\n\t    break;\n    }\n#endif\n    sourcing_name = save_name;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Check the string \"keys\" against the lhs of all mappings.\n * Return pointer to rhs of mapping (mapblock->m_str).\n * NULL when no mapping found.\n */\n    char_u *\ncheck_map(\n    char_u\t*keys,\n    int\t\tmode,\n    int\t\texact,\t\t/* require exact match */\n    int\t\tign_mod,\t/* ignore preceding modifier */\n    int\t\tabbr,\t\t/* do abbreviations */\n    mapblock_T\t**mp_ptr,\t/* return: pointer to mapblock or NULL */\n    int\t\t*local_ptr)\t/* return: buffer-local mapping or NULL */\n{\n    int\t\thash;\n    int\t\tlen, minlen;\n    mapblock_T\t*mp;\n    char_u\t*s;\n#ifdef FEAT_LOCALMAP\n    int\t\tlocal;\n#endif\n\n    validate_maphash();\n\n    len = (int)STRLEN(keys);\n#ifdef FEAT_LOCALMAP\n    for (local = 1; local >= 0; --local)\n#endif\n\t/* loop over all hash lists */\n\tfor (hash = 0; hash < 256; ++hash)\n\t{\n\t    if (abbr)\n\t    {\n\t\tif (hash > 0)\t\t/* there is only one list. */\n\t\t    break;\n#ifdef FEAT_LOCALMAP\n\t\tif (local)\n\t\t    mp = curbuf->b_first_abbr;\n\t\telse\n#endif\n\t\t    mp = first_abbr;\n\t    }\n#ifdef FEAT_LOCALMAP\n\t    else if (local)\n\t\tmp = curbuf->b_maphash[hash];\n#endif\n\t    else\n\t\tmp = maphash[hash];\n\t    for ( ; mp != NULL; mp = mp->m_next)\n\t    {\n\t\t/* skip entries with wrong mode, wrong length and not matching\n\t\t * ones */\n\t\tif ((mp->m_mode & mode) && (!exact || mp->m_keylen == len))\n\t\t{\n\t\t    if (len > mp->m_keylen)\n\t\t\tminlen = mp->m_keylen;\n\t\t    else\n\t\t\tminlen = len;\n\t\t    s = mp->m_keys;\n\t\t    if (ign_mod && s[0] == K_SPECIAL && s[1] == KS_MODIFIER\n\t\t\t\t\t\t\t       && s[2] != NUL)\n\t\t    {\n\t\t\ts += 3;\n\t\t\tif (len > mp->m_keylen - 3)\n\t\t\t    minlen = mp->m_keylen - 3;\n\t\t    }\n\t\t    if (STRNCMP(s, keys, minlen) == 0)\n\t\t    {\n\t\t\tif (mp_ptr != NULL)\n\t\t\t    *mp_ptr = mp;\n\t\t\tif (local_ptr != NULL)\n#ifdef FEAT_LOCALMAP\n\t\t\t    *local_ptr = local;\n#else\n\t\t\t    *local_ptr = 0;\n#endif\n\t\t\treturn mp->m_str;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    return NULL;\n}\n#endif\n\n#if defined(MSWIN) || defined(MACOS_X)\n\n# define VIS_SEL\t(VISUAL+SELECTMODE)\t/* abbreviation */\n\n/*\n * Default mappings for some often used keys.\n */\nstruct initmap\n{\n    char_u\t*arg;\n    int\t\tmode;\n};\n\n# ifdef FEAT_GUI_MSWIN\n/* Use the Windows (CUA) keybindings. (GUI) */\nstatic struct initmap initmappings[] =\n{\n\t/* paste, copy and cut */\n\t{(char_u *)\"<S-Insert> \\\"*P\", NORMAL},\n\t{(char_u *)\"<S-Insert> \\\"-d\\\"*P\", VIS_SEL},\n\t{(char_u *)\"<S-Insert> <C-R><C-O>*\", INSERT+CMDLINE},\n\t{(char_u *)\"<C-Insert> \\\"*y\", VIS_SEL},\n\t{(char_u *)\"<S-Del> \\\"*d\", VIS_SEL},\n\t{(char_u *)\"<C-Del> \\\"*d\", VIS_SEL},\n\t{(char_u *)\"<C-X> \\\"*d\", VIS_SEL},\n\t/* Missing: CTRL-C (cancel) and CTRL-V (block selection) */\n};\n# endif\n\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n/* Use the Windows (CUA) keybindings. (Console) */\nstatic struct initmap cinitmappings[] =\n{\n\t{(char_u *)\"\\316w <C-Home>\", NORMAL+VIS_SEL},\n\t{(char_u *)\"\\316w <C-Home>\", INSERT+CMDLINE},\n\t{(char_u *)\"\\316u <C-End>\", NORMAL+VIS_SEL},\n\t{(char_u *)\"\\316u <C-End>\", INSERT+CMDLINE},\n\n\t/* paste, copy and cut */\n#  ifdef FEAT_CLIPBOARD\n\t{(char_u *)\"\\316\\324 \\\"*P\", NORMAL},\t    /* SHIFT-Insert is \"*P */\n\t{(char_u *)\"\\316\\324 \\\"-d\\\"*P\", VIS_SEL},   /* SHIFT-Insert is \"-d\"*P */\n\t{(char_u *)\"\\316\\324 \\022\\017*\", INSERT},  /* SHIFT-Insert is ^R^O* */\n\t{(char_u *)\"\\316\\325 \\\"*y\", VIS_SEL},\t    /* CTRL-Insert is \"*y */\n\t{(char_u *)\"\\316\\327 \\\"*d\", VIS_SEL},\t    /* SHIFT-Del is \"*d */\n\t{(char_u *)\"\\316\\330 \\\"*d\", VIS_SEL},\t    /* CTRL-Del is \"*d */\n\t{(char_u *)\"\\030 \\\"*d\", VIS_SEL},\t    /* CTRL-X is \"*d */\n#  else\n\t{(char_u *)\"\\316\\324 P\", NORMAL},\t    /* SHIFT-Insert is P */\n\t{(char_u *)\"\\316\\324 \\\"-dP\", VIS_SEL},\t    /* SHIFT-Insert is \"-dP */\n\t{(char_u *)\"\\316\\324 \\022\\017\\\"\", INSERT}, /* SHIFT-Insert is ^R^O\" */\n\t{(char_u *)\"\\316\\325 y\", VIS_SEL},\t    /* CTRL-Insert is y */\n\t{(char_u *)\"\\316\\327 d\", VIS_SEL},\t    /* SHIFT-Del is d */\n\t{(char_u *)\"\\316\\330 d\", VIS_SEL},\t    /* CTRL-Del is d */\n#  endif\n};\n# endif\n\n# if defined(MACOS_X)\nstatic struct initmap initmappings[] =\n{\n\t/* Use the Standard MacOS binding. */\n\t/* paste, copy and cut */\n\t{(char_u *)\"<D-v> \\\"*P\", NORMAL},\n\t{(char_u *)\"<D-v> \\\"-d\\\"*P\", VIS_SEL},\n\t{(char_u *)\"<D-v> <C-R>*\", INSERT+CMDLINE},\n\t{(char_u *)\"<D-c> \\\"*y\", VIS_SEL},\n\t{(char_u *)\"<D-x> \\\"*d\", VIS_SEL},\n\t{(char_u *)\"<Backspace> \\\"-d\", VIS_SEL},\n};\n# endif\n\n# undef VIS_SEL\n#endif\n\n/*\n * Set up default mappings.\n */\n    void\ninit_mappings(void)\n{\n#if defined(MSWIN) || defined(MACOS_X)\n    int\t\ti;\n\n# if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n#  ifdef VIMDLL\n    if (!gui.starting)\n#  endif\n    {\n\tfor (i = 0;\n\t\ti < (int)(sizeof(cinitmappings) / sizeof(struct initmap)); ++i)\n\t    add_map(cinitmappings[i].arg, cinitmappings[i].mode);\n    }\n# endif\n# if defined(FEAT_GUI_MSWIN) || defined(MACOS_X)\n    for (i = 0; i < (int)(sizeof(initmappings) / sizeof(struct initmap)); ++i)\n\tadd_map(initmappings[i].arg, initmappings[i].mode);\n# endif\n#endif\n}\n\n#if defined(MSWIN) || defined(FEAT_CMDWIN) || defined(MACOS_X) \\\n\t\t\t\t\t\t\t     || defined(PROTO)\n/*\n * Add a mapping \"map\" for mode \"mode\".\n * Need to put string in allocated memory, because do_map() will modify it.\n */\n    void\nadd_map(char_u *map, int mode)\n{\n    char_u\t*s;\n    char_u\t*cpo_save = p_cpo;\n\n    p_cpo = (char_u *)\"\";\t/* Allow <> notation */\n    s = vim_strsave(map);\n    if (s != NULL)\n    {\n\t(void)do_map(0, s, mode, FALSE);\n\tvim_free(s);\n    }\n    p_cpo = cpo_save;\n}\n#endif\n", "\" Tests for the :source command.\n\nfunc Test_source_autocmd()\n  call writefile([\n\t\\ 'let did_source = 1',\n\t\\ ], 'Xsourced')\n  au SourcePre *source* let did_source_pre = 1\n  au SourcePost *source* let did_source_post = 1\n\n  source Xsourced\n\n  call assert_equal(g:did_source, 1)\n  call assert_equal(g:did_source_pre, 1)\n  call assert_equal(g:did_source_post, 1)\n\n  call delete('Xsourced')\n  au! SourcePre\n  au! SourcePost\n  unlet g:did_source\n  unlet g:did_source_pre\n  unlet g:did_source_post\nendfunc\n\nfunc Test_source_cmd()\n  au SourceCmd *source* let did_source = expand('<afile>')\n  au SourcePre *source* let did_source_pre = 2\n  au SourcePost *source* let did_source_post = 2\n\n  source Xsourced\n\n  call assert_equal(g:did_source, 'Xsourced')\n  call assert_false(exists('g:did_source_pre'))\n  call assert_equal(g:did_source_post, 2)\n\n  au! SourceCmd\n  au! SourcePre\n  au! SourcePost\nendfunc\n\nfunc Test_source_sandbox()\n  new\n  call writefile([\"Ohello\\<Esc>\"], 'Xsourcehello')\n  source! Xsourcehello | echo\n  call assert_equal('hello', getline(1))\n  call assert_fails('sandbox source! Xsourcehello', 'E48:')\n  bwipe!\nendfunc\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    char *date_time = __DATE__ \" \" __TIME__;\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t\t+ strlen(date_time);\n\n    longVersion = (char *)alloc((unsigned)len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TEXT_PROP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n/* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    /* Find the length of the longest item, use that + 1 as the column\n     * width. */\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    msg_puts(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    msg_puts(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/getchar.c", "src/testdir/test_source.vim", "src/version.c"], "buggy_code_start_loc": [1409, 38, 769], "buggy_code_end_loc": [1409, 38, 769], "fixing_code_start_loc": [1410, 39, 770], "fixing_code_end_loc": [1416, 48, 772], "type": "CWE-78", "message": "getchar.c in Vim before 8.1.1365 and Neovim before 0.3.6 allows remote attackers to execute arbitrary OS commands via the :source! command in a modeline, as demonstrated by execute in Vim, and assert_fails or nvim_input in Neovim.", "other": {"cve": {"id": "CVE-2019-12735", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-05T14:29:11.387", "lastModified": "2019-06-13T21:29:16.003", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "getchar.c in Vim before 8.1.1365 and Neovim before 0.3.6 allows remote attackers to execute arbitrary OS commands via the :source! command in a modeline, as demonstrated by execute in Vim, and assert_fails or nvim_input in Neovim."}, {"lang": "es", "value": "El archivo getchar.c en Vim anterior a versi\u00f3n 8.1.1365 y Neovim anterior a versi\u00f3n 0.3.6 permite a los atacantes remotos ejecutar comandos arbitrarios del sistema operativo por medio de: comando source! en el componente modeline, como es demostrado por la ejecuci\u00f3n en Vim, y assert_fails o nvim_input en Neovim."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.1.1365", "matchCriteriaId": "E64CDC4D-44E0-41D9-B0FF-EBE09F8FE096"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neovim:neovim:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.6", "matchCriteriaId": "E3E1B71E-EB89-4AA5-8635-88ADDFD41830"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00031.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00036.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00037.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00034.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00050.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00075.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/108724", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1619", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1774", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1793", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1947", "source": "cve@mitre.org"}, {"url": "https://bugs.debian.org/930020", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.debian.org/930024", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/neovim/neovim/pull/10082", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/53575521406739cf20bbe4e384d88e7dca11f040", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00003.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2BMDSHTF754TITC6AQJPCS5IRIDMMIM7/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TRIRBC2YRGKPAWVRMZS4SZTGGCVRVZPR/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Jul/39", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Jun/33", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202003-04", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K93144355", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K93144355?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4016-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4016-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4467", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4487", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/vim/vim/commit/53575521406739cf20bbe4e384d88e7dca11f040"}}