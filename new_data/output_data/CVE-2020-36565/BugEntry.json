{"buggy_code": ["/*\nPackage echo implements high performance, minimalist Go web framework.\n\nExample:\n\n  package main\n\n  import (\n    \"net/http\"\n\n    \"github.com/labstack/echo/v4\"\n    \"github.com/labstack/echo/v4/middleware\"\n  )\n\n  // Handler\n  func hello(c echo.Context) error {\n    return c.String(http.StatusOK, \"Hello, World!\")\n  }\n\n  func main() {\n    // Echo instance\n    e := echo.New()\n\n    // Middleware\n    e.Use(middleware.Logger())\n    e.Use(middleware.Recover())\n\n    // Routes\n    e.GET(\"/\", hello)\n\n    // Start server\n    e.Logger.Fatal(e.Start(\":1323\"))\n  }\n\nLearn more at https://echo.labstack.com\n*/\npackage echo\n\nimport (\n\t\"bytes\"\n\tstdContext \"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\tstdLog \"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/labstack/gommon/color\"\n\t\"github.com/labstack/gommon/log\"\n\t\"golang.org/x/crypto/acme\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\ntype (\n\t// Echo is the top-level framework instance.\n\tEcho struct {\n\t\tcommon\n\t\tStdLogger        *stdLog.Logger\n\t\tcolorer          *color.Color\n\t\tpremiddleware    []MiddlewareFunc\n\t\tmiddleware       []MiddlewareFunc\n\t\tmaxParam         *int\n\t\trouter           *Router\n\t\trouters          map[string]*Router\n\t\tnotFoundHandler  HandlerFunc\n\t\tpool             sync.Pool\n\t\tServer           *http.Server\n\t\tTLSServer        *http.Server\n\t\tListener         net.Listener\n\t\tTLSListener      net.Listener\n\t\tAutoTLSManager   autocert.Manager\n\t\tDisableHTTP2     bool\n\t\tDebug            bool\n\t\tHideBanner       bool\n\t\tHidePort         bool\n\t\tHTTPErrorHandler HTTPErrorHandler\n\t\tBinder           Binder\n\t\tValidator        Validator\n\t\tRenderer         Renderer\n\t\tLogger           Logger\n\t\tIPExtractor      IPExtractor\n\t\tListenerNetwork  string\n\t}\n\n\t// Route contains a handler and information for matching against requests.\n\tRoute struct {\n\t\tMethod string `json:\"method\"`\n\t\tPath   string `json:\"path\"`\n\t\tName   string `json:\"name\"`\n\t}\n\n\t// HTTPError represents an error that occurred while handling a request.\n\tHTTPError struct {\n\t\tCode     int         `json:\"-\"`\n\t\tMessage  interface{} `json:\"message\"`\n\t\tInternal error       `json:\"-\"` // Stores the error returned by an external dependency\n\t}\n\n\t// MiddlewareFunc defines a function to process middleware.\n\tMiddlewareFunc func(HandlerFunc) HandlerFunc\n\n\t// HandlerFunc defines a function to serve HTTP requests.\n\tHandlerFunc func(Context) error\n\n\t// HTTPErrorHandler is a centralized HTTP error handler.\n\tHTTPErrorHandler func(error, Context)\n\n\t// Validator is the interface that wraps the Validate function.\n\tValidator interface {\n\t\tValidate(i interface{}) error\n\t}\n\n\t// Renderer is the interface that wraps the Render function.\n\tRenderer interface {\n\t\tRender(io.Writer, string, interface{}, Context) error\n\t}\n\n\t// Map defines a generic map of type `map[string]interface{}`.\n\tMap map[string]interface{}\n\n\t// Common struct for Echo & Group.\n\tcommon struct{}\n)\n\n// HTTP methods\n// NOTE: Deprecated, please use the stdlib constants directly instead.\nconst (\n\tCONNECT = http.MethodConnect\n\tDELETE  = http.MethodDelete\n\tGET     = http.MethodGet\n\tHEAD    = http.MethodHead\n\tOPTIONS = http.MethodOptions\n\tPATCH   = http.MethodPatch\n\tPOST    = http.MethodPost\n\t// PROPFIND = \"PROPFIND\"\n\tPUT   = http.MethodPut\n\tTRACE = http.MethodTrace\n)\n\n// MIME types\nconst (\n\tMIMEApplicationJSON                  = \"application/json\"\n\tMIMEApplicationJSONCharsetUTF8       = MIMEApplicationJSON + \"; \" + charsetUTF8\n\tMIMEApplicationJavaScript            = \"application/javascript\"\n\tMIMEApplicationJavaScriptCharsetUTF8 = MIMEApplicationJavaScript + \"; \" + charsetUTF8\n\tMIMEApplicationXML                   = \"application/xml\"\n\tMIMEApplicationXMLCharsetUTF8        = MIMEApplicationXML + \"; \" + charsetUTF8\n\tMIMETextXML                          = \"text/xml\"\n\tMIMETextXMLCharsetUTF8               = MIMETextXML + \"; \" + charsetUTF8\n\tMIMEApplicationForm                  = \"application/x-www-form-urlencoded\"\n\tMIMEApplicationProtobuf              = \"application/protobuf\"\n\tMIMEApplicationMsgpack               = \"application/msgpack\"\n\tMIMETextHTML                         = \"text/html\"\n\tMIMETextHTMLCharsetUTF8              = MIMETextHTML + \"; \" + charsetUTF8\n\tMIMETextPlain                        = \"text/plain\"\n\tMIMETextPlainCharsetUTF8             = MIMETextPlain + \"; \" + charsetUTF8\n\tMIMEMultipartForm                    = \"multipart/form-data\"\n\tMIMEOctetStream                      = \"application/octet-stream\"\n)\n\nconst (\n\tcharsetUTF8 = \"charset=UTF-8\"\n\t// PROPFIND Method can be used on collection and property resources.\n\tPROPFIND = \"PROPFIND\"\n\t// REPORT Method can be used to get information about a resource, see rfc 3253\n\tREPORT = \"REPORT\"\n)\n\n// Headers\nconst (\n\tHeaderAccept              = \"Accept\"\n\tHeaderAcceptEncoding      = \"Accept-Encoding\"\n\tHeaderAllow               = \"Allow\"\n\tHeaderAuthorization       = \"Authorization\"\n\tHeaderContentDisposition  = \"Content-Disposition\"\n\tHeaderContentEncoding     = \"Content-Encoding\"\n\tHeaderContentLength       = \"Content-Length\"\n\tHeaderContentType         = \"Content-Type\"\n\tHeaderCookie              = \"Cookie\"\n\tHeaderSetCookie           = \"Set-Cookie\"\n\tHeaderIfModifiedSince     = \"If-Modified-Since\"\n\tHeaderLastModified        = \"Last-Modified\"\n\tHeaderLocation            = \"Location\"\n\tHeaderUpgrade             = \"Upgrade\"\n\tHeaderVary                = \"Vary\"\n\tHeaderWWWAuthenticate     = \"WWW-Authenticate\"\n\tHeaderXForwardedFor       = \"X-Forwarded-For\"\n\tHeaderXForwardedProto     = \"X-Forwarded-Proto\"\n\tHeaderXForwardedProtocol  = \"X-Forwarded-Protocol\"\n\tHeaderXForwardedSsl       = \"X-Forwarded-Ssl\"\n\tHeaderXUrlScheme          = \"X-Url-Scheme\"\n\tHeaderXHTTPMethodOverride = \"X-HTTP-Method-Override\"\n\tHeaderXRealIP             = \"X-Real-IP\"\n\tHeaderXRequestID          = \"X-Request-ID\"\n\tHeaderXRequestedWith      = \"X-Requested-With\"\n\tHeaderServer              = \"Server\"\n\tHeaderOrigin              = \"Origin\"\n\n\t// Access control\n\tHeaderAccessControlRequestMethod    = \"Access-Control-Request-Method\"\n\tHeaderAccessControlRequestHeaders   = \"Access-Control-Request-Headers\"\n\tHeaderAccessControlAllowOrigin      = \"Access-Control-Allow-Origin\"\n\tHeaderAccessControlAllowMethods     = \"Access-Control-Allow-Methods\"\n\tHeaderAccessControlAllowHeaders     = \"Access-Control-Allow-Headers\"\n\tHeaderAccessControlAllowCredentials = \"Access-Control-Allow-Credentials\"\n\tHeaderAccessControlExposeHeaders    = \"Access-Control-Expose-Headers\"\n\tHeaderAccessControlMaxAge           = \"Access-Control-Max-Age\"\n\n\t// Security\n\tHeaderStrictTransportSecurity         = \"Strict-Transport-Security\"\n\tHeaderXContentTypeOptions             = \"X-Content-Type-Options\"\n\tHeaderXXSSProtection                  = \"X-XSS-Protection\"\n\tHeaderXFrameOptions                   = \"X-Frame-Options\"\n\tHeaderContentSecurityPolicy           = \"Content-Security-Policy\"\n\tHeaderContentSecurityPolicyReportOnly = \"Content-Security-Policy-Report-Only\"\n\tHeaderXCSRFToken                      = \"X-CSRF-Token\"\n\tHeaderReferrerPolicy                  = \"Referrer-Policy\"\n)\n\nconst (\n\t// Version of Echo\n\tVersion = \"4.1.17\"\n\twebsite = \"https://echo.labstack.com\"\n\t// http://patorjk.com/software/taag/#p=display&f=Small%20Slant&t=Echo\n\tbanner = `\n   ____    __\n  / __/___/ /  ___\n / _// __/ _ \\/ _ \\\n/___/\\__/_//_/\\___/ %s\nHigh performance, minimalist Go web framework\n%s\n____________________________________O/_______\n                                    O\\\n`\n)\n\nvar (\n\tmethods = [...]string{\n\t\thttp.MethodConnect,\n\t\thttp.MethodDelete,\n\t\thttp.MethodGet,\n\t\thttp.MethodHead,\n\t\thttp.MethodOptions,\n\t\thttp.MethodPatch,\n\t\thttp.MethodPost,\n\t\tPROPFIND,\n\t\thttp.MethodPut,\n\t\thttp.MethodTrace,\n\t\tREPORT,\n\t}\n)\n\n// Errors\nvar (\n\tErrUnsupportedMediaType        = NewHTTPError(http.StatusUnsupportedMediaType)\n\tErrNotFound                    = NewHTTPError(http.StatusNotFound)\n\tErrUnauthorized                = NewHTTPError(http.StatusUnauthorized)\n\tErrForbidden                   = NewHTTPError(http.StatusForbidden)\n\tErrMethodNotAllowed            = NewHTTPError(http.StatusMethodNotAllowed)\n\tErrStatusRequestEntityTooLarge = NewHTTPError(http.StatusRequestEntityTooLarge)\n\tErrTooManyRequests             = NewHTTPError(http.StatusTooManyRequests)\n\tErrBadRequest                  = NewHTTPError(http.StatusBadRequest)\n\tErrBadGateway                  = NewHTTPError(http.StatusBadGateway)\n\tErrInternalServerError         = NewHTTPError(http.StatusInternalServerError)\n\tErrRequestTimeout              = NewHTTPError(http.StatusRequestTimeout)\n\tErrServiceUnavailable          = NewHTTPError(http.StatusServiceUnavailable)\n\tErrValidatorNotRegistered      = errors.New(\"validator not registered\")\n\tErrRendererNotRegistered       = errors.New(\"renderer not registered\")\n\tErrInvalidRedirectCode         = errors.New(\"invalid redirect status code\")\n\tErrCookieNotFound              = errors.New(\"cookie not found\")\n\tErrInvalidCertOrKeyType        = errors.New(\"invalid cert or key type, must be string or []byte\")\n\tErrInvalidListenerNetwork      = errors.New(\"invalid listener network\")\n)\n\n// Error handlers\nvar (\n\tNotFoundHandler = func(c Context) error {\n\t\treturn ErrNotFound\n\t}\n\n\tMethodNotAllowedHandler = func(c Context) error {\n\t\treturn ErrMethodNotAllowed\n\t}\n)\n\n// New creates an instance of Echo.\nfunc New() (e *Echo) {\n\te = &Echo{\n\t\tServer:    new(http.Server),\n\t\tTLSServer: new(http.Server),\n\t\tAutoTLSManager: autocert.Manager{\n\t\t\tPrompt: autocert.AcceptTOS,\n\t\t},\n\t\tLogger:          log.New(\"echo\"),\n\t\tcolorer:         color.New(),\n\t\tmaxParam:        new(int),\n\t\tListenerNetwork: \"tcp\",\n\t}\n\te.Server.Handler = e\n\te.TLSServer.Handler = e\n\te.HTTPErrorHandler = e.DefaultHTTPErrorHandler\n\te.Binder = &DefaultBinder{}\n\te.Logger.SetLevel(log.ERROR)\n\te.StdLogger = stdLog.New(e.Logger.Output(), e.Logger.Prefix()+\": \", 0)\n\te.pool.New = func() interface{} {\n\t\treturn e.NewContext(nil, nil)\n\t}\n\te.router = NewRouter(e)\n\te.routers = map[string]*Router{}\n\treturn\n}\n\n// NewContext returns a Context instance.\nfunc (e *Echo) NewContext(r *http.Request, w http.ResponseWriter) Context {\n\treturn &context{\n\t\trequest:  r,\n\t\tresponse: NewResponse(w, e),\n\t\tstore:    make(Map),\n\t\techo:     e,\n\t\tpvalues:  make([]string, *e.maxParam),\n\t\thandler:  NotFoundHandler,\n\t}\n}\n\n// Router returns the default router.\nfunc (e *Echo) Router() *Router {\n\treturn e.router\n}\n\n// Routers returns the map of host => router.\nfunc (e *Echo) Routers() map[string]*Router {\n\treturn e.routers\n}\n\n// DefaultHTTPErrorHandler is the default HTTP error handler. It sends a JSON response\n// with status code.\nfunc (e *Echo) DefaultHTTPErrorHandler(err error, c Context) {\n\the, ok := err.(*HTTPError)\n\tif ok {\n\t\tif he.Internal != nil {\n\t\t\tif herr, ok := he.Internal.(*HTTPError); ok {\n\t\t\t\the = herr\n\t\t\t}\n\t\t}\n\t} else {\n\t\the = &HTTPError{\n\t\t\tCode:    http.StatusInternalServerError,\n\t\t\tMessage: http.StatusText(http.StatusInternalServerError),\n\t\t}\n\t}\n\n\t// Issue #1426\n\tcode := he.Code\n\tmessage := he.Message\n\tif m, ok := he.Message.(string); ok {\n\t\tif e.Debug {\n\t\t\tmessage = Map{\"message\": m, \"error\": err.Error()}\n\t\t} else {\n\t\t\tmessage = Map{\"message\": m}\n\t\t}\n\t}\n\n\t// Send response\n\tif !c.Response().Committed {\n\t\tif c.Request().Method == http.MethodHead { // Issue #608\n\t\t\terr = c.NoContent(he.Code)\n\t\t} else {\n\t\t\terr = c.JSON(code, message)\n\t\t}\n\t\tif err != nil {\n\t\t\te.Logger.Error(err)\n\t\t}\n\t}\n}\n\n// Pre adds middleware to the chain which is run before router.\nfunc (e *Echo) Pre(middleware ...MiddlewareFunc) {\n\te.premiddleware = append(e.premiddleware, middleware...)\n}\n\n// Use adds middleware to the chain which is run after router.\nfunc (e *Echo) Use(middleware ...MiddlewareFunc) {\n\te.middleware = append(e.middleware, middleware...)\n}\n\n// CONNECT registers a new CONNECT route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) CONNECT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodConnect, path, h, m...)\n}\n\n// DELETE registers a new DELETE route for a path with matching handler in the router\n// with optional route-level middleware.\nfunc (e *Echo) DELETE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodDelete, path, h, m...)\n}\n\n// GET registers a new GET route for a path with matching handler in the router\n// with optional route-level middleware.\nfunc (e *Echo) GET(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodGet, path, h, m...)\n}\n\n// HEAD registers a new HEAD route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) HEAD(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodHead, path, h, m...)\n}\n\n// OPTIONS registers a new OPTIONS route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) OPTIONS(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodOptions, path, h, m...)\n}\n\n// PATCH registers a new PATCH route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) PATCH(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPatch, path, h, m...)\n}\n\n// POST registers a new POST route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) POST(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPost, path, h, m...)\n}\n\n// PUT registers a new PUT route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) PUT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPut, path, h, m...)\n}\n\n// TRACE registers a new TRACE route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) TRACE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodTrace, path, h, m...)\n}\n\n// Any registers a new route for all HTTP methods and path with matching handler\n// in the router with optional route-level middleware.\nfunc (e *Echo) Any(path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = e.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\n// Match registers a new route for multiple HTTP methods and path with matching\n// handler in the router with optional route-level middleware.\nfunc (e *Echo) Match(methods []string, path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = e.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\n// Static registers a new route with path prefix to serve static files from the\n// provided root directory.\nfunc (e *Echo) Static(prefix, root string) *Route {\n\tif root == \"\" {\n\t\troot = \".\" // For security we want to restrict to CWD.\n\t}\n\treturn e.static(prefix, root, e.GET)\n}\n\nfunc (common) static(prefix, root string, get func(string, HandlerFunc, ...MiddlewareFunc) *Route) *Route {\n\th := func(c Context) error {\n\t\tp, err := url.PathUnescape(c.Param(\"*\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tname := filepath.Join(root, path.Clean(\"/\"+p)) // \"/\"+ for security\n\t\tfi, err := os.Stat(name)\n\t\tif err != nil {\n\t\t\t// The access path does not exist\n\t\t\treturn NotFoundHandler(c)\n\t\t}\n\n\t\t// If the request is for a directory and does not end with \"/\"\n\t\tp = c.Request().URL.Path // path must not be empty.\n\t\tif fi.IsDir() && p[len(p)-1] != '/' {\n\t\t\t// Redirect to ends with \"/\"\n\t\t\treturn c.Redirect(http.StatusMovedPermanently, p+\"/\")\n\t\t}\n\t\treturn c.File(name)\n\t}\n\tif prefix == \"/\" {\n\t\treturn get(prefix+\"*\", h)\n\t}\n\treturn get(prefix+\"/*\", h)\n}\n\nfunc (common) file(path, file string, get func(string, HandlerFunc, ...MiddlewareFunc) *Route,\n\tm ...MiddlewareFunc) *Route {\n\treturn get(path, func(c Context) error {\n\t\treturn c.File(file)\n\t}, m...)\n}\n\n// File registers a new route with path to serve a static file with optional route-level middleware.\nfunc (e *Echo) File(path, file string, m ...MiddlewareFunc) *Route {\n\treturn e.file(path, file, e.GET, m...)\n}\n\nfunc (e *Echo) add(host, method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route {\n\tname := handlerName(handler)\n\trouter := e.findRouter(host)\n\trouter.Add(method, path, func(c Context) error {\n\t\th := applyMiddleware(handler, middleware...)\n\t\treturn h(c)\n\t})\n\tr := &Route{\n\t\tMethod: method,\n\t\tPath:   path,\n\t\tName:   name,\n\t}\n\te.router.routes[method+path] = r\n\treturn r\n}\n\n// Add registers a new route for an HTTP method and path with matching handler\n// in the router with optional route-level middleware.\nfunc (e *Echo) Add(method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route {\n\treturn e.add(\"\", method, path, handler, middleware...)\n}\n\n// Host creates a new router group for the provided host and optional host-level middleware.\nfunc (e *Echo) Host(name string, m ...MiddlewareFunc) (g *Group) {\n\te.routers[name] = NewRouter(e)\n\tg = &Group{host: name, echo: e}\n\tg.Use(m...)\n\treturn\n}\n\n// Group creates a new router group with prefix and optional group-level middleware.\nfunc (e *Echo) Group(prefix string, m ...MiddlewareFunc) (g *Group) {\n\tg = &Group{prefix: prefix, echo: e}\n\tg.Use(m...)\n\treturn\n}\n\n// URI generates a URI from handler.\nfunc (e *Echo) URI(handler HandlerFunc, params ...interface{}) string {\n\tname := handlerName(handler)\n\treturn e.Reverse(name, params...)\n}\n\n// URL is an alias for `URI` function.\nfunc (e *Echo) URL(h HandlerFunc, params ...interface{}) string {\n\treturn e.URI(h, params...)\n}\n\n// Reverse generates an URL from route name and provided parameters.\nfunc (e *Echo) Reverse(name string, params ...interface{}) string {\n\turi := new(bytes.Buffer)\n\tln := len(params)\n\tn := 0\n\tfor _, r := range e.router.routes {\n\t\tif r.Name == name {\n\t\t\tfor i, l := 0, len(r.Path); i < l; i++ {\n\t\t\t\tif (r.Path[i] == ':' || r.Path[i] == '*') && n < ln {\n\t\t\t\t\tfor ; i < l && r.Path[i] != '/'; i++ {\n\t\t\t\t\t}\n\t\t\t\t\turi.WriteString(fmt.Sprintf(\"%v\", params[n]))\n\t\t\t\t\tn++\n\t\t\t\t}\n\t\t\t\tif i < l {\n\t\t\t\t\turi.WriteByte(r.Path[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn uri.String()\n}\n\n// Routes returns the registered routes.\nfunc (e *Echo) Routes() []*Route {\n\troutes := make([]*Route, 0, len(e.router.routes))\n\tfor _, v := range e.router.routes {\n\t\troutes = append(routes, v)\n\t}\n\treturn routes\n}\n\n// AcquireContext returns an empty `Context` instance from the pool.\n// You must return the context by calling `ReleaseContext()`.\nfunc (e *Echo) AcquireContext() Context {\n\treturn e.pool.Get().(Context)\n}\n\n// ReleaseContext returns the `Context` instance back to the pool.\n// You must call it after `AcquireContext()`.\nfunc (e *Echo) ReleaseContext(c Context) {\n\te.pool.Put(c)\n}\n\n// ServeHTTP implements `http.Handler` interface, which serves HTTP requests.\nfunc (e *Echo) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Acquire context\n\tc := e.pool.Get().(*context)\n\tc.Reset(r, w)\n\th := NotFoundHandler\n\n\tif e.premiddleware == nil {\n\t\te.findRouter(r.Host).Find(r.Method, r.URL.EscapedPath(), c)\n\t\th = c.Handler()\n\t\th = applyMiddleware(h, e.middleware...)\n\t} else {\n\t\th = func(c Context) error {\n\t\t\te.findRouter(r.Host).Find(r.Method, r.URL.EscapedPath(), c)\n\t\t\th := c.Handler()\n\t\t\th = applyMiddleware(h, e.middleware...)\n\t\t\treturn h(c)\n\t\t}\n\t\th = applyMiddleware(h, e.premiddleware...)\n\t}\n\n\t// Execute chain\n\tif err := h(c); err != nil {\n\t\te.HTTPErrorHandler(err, c)\n\t}\n\n\t// Release context\n\te.pool.Put(c)\n}\n\n// Start starts an HTTP server.\nfunc (e *Echo) Start(address string) error {\n\te.Server.Addr = address\n\treturn e.StartServer(e.Server)\n}\n\n// StartTLS starts an HTTPS server.\n// If `certFile` or `keyFile` is `string` the values are treated as file paths.\n// If `certFile` or `keyFile` is `[]byte` the values are treated as the certificate or key as-is.\nfunc (e *Echo) StartTLS(address string, certFile, keyFile interface{}) (err error) {\n\tvar cert []byte\n\tif cert, err = filepathOrContent(certFile); err != nil {\n\t\treturn\n\t}\n\n\tvar key []byte\n\tif key, err = filepathOrContent(keyFile); err != nil {\n\t\treturn\n\t}\n\n\ts := e.TLSServer\n\ts.TLSConfig = new(tls.Config)\n\ts.TLSConfig.Certificates = make([]tls.Certificate, 1)\n\tif s.TLSConfig.Certificates[0], err = tls.X509KeyPair(cert, key); err != nil {\n\t\treturn\n\t}\n\n\treturn e.startTLS(address)\n}\n\nfunc filepathOrContent(fileOrContent interface{}) (content []byte, err error) {\n\tswitch v := fileOrContent.(type) {\n\tcase string:\n\t\treturn ioutil.ReadFile(v)\n\tcase []byte:\n\t\treturn v, nil\n\tdefault:\n\t\treturn nil, ErrInvalidCertOrKeyType\n\t}\n}\n\n// StartAutoTLS starts an HTTPS server using certificates automatically installed from https://letsencrypt.org.\nfunc (e *Echo) StartAutoTLS(address string) error {\n\ts := e.TLSServer\n\ts.TLSConfig = new(tls.Config)\n\ts.TLSConfig.GetCertificate = e.AutoTLSManager.GetCertificate\n\ts.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, acme.ALPNProto)\n\treturn e.startTLS(address)\n}\n\nfunc (e *Echo) startTLS(address string) error {\n\ts := e.TLSServer\n\ts.Addr = address\n\tif !e.DisableHTTP2 {\n\t\ts.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, \"h2\")\n\t}\n\treturn e.StartServer(e.TLSServer)\n}\n\n// StartServer starts a custom http server.\nfunc (e *Echo) StartServer(s *http.Server) (err error) {\n\t// Setup\n\te.colorer.SetOutput(e.Logger.Output())\n\ts.ErrorLog = e.StdLogger\n\ts.Handler = e\n\tif e.Debug {\n\t\te.Logger.SetLevel(log.DEBUG)\n\t}\n\n\tif !e.HideBanner {\n\t\te.colorer.Printf(banner, e.colorer.Red(\"v\"+Version), e.colorer.Blue(website))\n\t}\n\n\tif s.TLSConfig == nil {\n\t\tif e.Listener == nil {\n\t\t\te.Listener, err = newListener(s.Addr, e.ListenerNetwork)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif !e.HidePort {\n\t\t\te.colorer.Printf(\"\u21e8 http server started on %s\\n\", e.colorer.Green(e.Listener.Addr()))\n\t\t}\n\t\treturn s.Serve(e.Listener)\n\t}\n\tif e.TLSListener == nil {\n\t\tl, err := newListener(s.Addr, e.ListenerNetwork)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\te.TLSListener = tls.NewListener(l, s.TLSConfig)\n\t}\n\tif !e.HidePort {\n\t\te.colorer.Printf(\"\u21e8 https server started on %s\\n\", e.colorer.Green(e.TLSListener.Addr()))\n\t}\n\treturn s.Serve(e.TLSListener)\n}\n\n// StartH2CServer starts a custom http/2 server with h2c (HTTP/2 Cleartext).\nfunc (e *Echo) StartH2CServer(address string, h2s *http2.Server) (err error) {\n\t// Setup\n\ts := e.Server\n\ts.Addr = address\n\te.colorer.SetOutput(e.Logger.Output())\n\ts.ErrorLog = e.StdLogger\n\ts.Handler = h2c.NewHandler(e, h2s)\n\tif e.Debug {\n\t\te.Logger.SetLevel(log.DEBUG)\n\t}\n\n\tif !e.HideBanner {\n\t\te.colorer.Printf(banner, e.colorer.Red(\"v\"+Version), e.colorer.Blue(website))\n\t}\n\n\tif e.Listener == nil {\n\t\te.Listener, err = newListener(s.Addr, e.ListenerNetwork)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif !e.HidePort {\n\t\te.colorer.Printf(\"\u21e8 http server started on %s\\n\", e.colorer.Green(e.Listener.Addr()))\n\t}\n\treturn s.Serve(e.Listener)\n}\n\n// Close immediately stops the server.\n// It internally calls `http.Server#Close()`.\nfunc (e *Echo) Close() error {\n\tif err := e.TLSServer.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn e.Server.Close()\n}\n\n// Shutdown stops the server gracefully.\n// It internally calls `http.Server#Shutdown()`.\nfunc (e *Echo) Shutdown(ctx stdContext.Context) error {\n\tif err := e.TLSServer.Shutdown(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn e.Server.Shutdown(ctx)\n}\n\n// NewHTTPError creates a new HTTPError instance.\nfunc NewHTTPError(code int, message ...interface{}) *HTTPError {\n\the := &HTTPError{Code: code, Message: http.StatusText(code)}\n\tif len(message) > 0 {\n\t\the.Message = message[0]\n\t}\n\treturn he\n}\n\n// Error makes it compatible with `error` interface.\nfunc (he *HTTPError) Error() string {\n\tif he.Internal == nil {\n\t\treturn fmt.Sprintf(\"code=%d, message=%v\", he.Code, he.Message)\n\t}\n\treturn fmt.Sprintf(\"code=%d, message=%v, internal=%v\", he.Code, he.Message, he.Internal)\n}\n\n// SetInternal sets error to HTTPError.Internal\nfunc (he *HTTPError) SetInternal(err error) *HTTPError {\n\the.Internal = err\n\treturn he\n}\n\n// Unwrap satisfies the Go 1.13 error wrapper interface.\nfunc (he *HTTPError) Unwrap() error {\n\treturn he.Internal\n}\n\n// WrapHandler wraps `http.Handler` into `echo.HandlerFunc`.\nfunc WrapHandler(h http.Handler) HandlerFunc {\n\treturn func(c Context) error {\n\t\th.ServeHTTP(c.Response(), c.Request())\n\t\treturn nil\n\t}\n}\n\n// WrapMiddleware wraps `func(http.Handler) http.Handler` into `echo.MiddlewareFunc`\nfunc WrapMiddleware(m func(http.Handler) http.Handler) MiddlewareFunc {\n\treturn func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) (err error) {\n\t\t\tm(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tc.SetRequest(r)\n\t\t\t\tc.SetResponse(NewResponse(w, c.Echo()))\n\t\t\t\terr = next(c)\n\t\t\t})).ServeHTTP(c.Response(), c.Request())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (e *Echo) findRouter(host string) *Router {\n\tif len(e.routers) > 0 {\n\t\tif r, ok := e.routers[host]; ok {\n\t\t\treturn r\n\t\t}\n\t}\n\treturn e.router\n}\n\nfunc handlerName(h HandlerFunc) string {\n\tt := reflect.ValueOf(h).Type()\n\tif t.Kind() == reflect.Func {\n\t\treturn runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name()\n\t}\n\treturn t.String()\n}\n\n// // PathUnescape is wraps `url.PathUnescape`\n// func PathUnescape(s string) (string, error) {\n// \treturn url.PathUnescape(s)\n// }\n\n// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted\n// connections. It's used by ListenAndServe and ListenAndServeTLS so\n// dead TCP connections (e.g. closing laptop mid-download) eventually\n// go away.\ntype tcpKeepAliveListener struct {\n\t*net.TCPListener\n}\n\nfunc (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {\n\tif c, err = ln.AcceptTCP(); err != nil {\n\t\treturn\n\t} else if err = c.(*net.TCPConn).SetKeepAlive(true); err != nil {\n\t\treturn\n\t}\n\t// Ignore error from setting the KeepAlivePeriod as some systems, such as\n\t// OpenBSD, do not support setting TCP_USER_TIMEOUT on IPPROTO_TCP\n\t_ = c.(*net.TCPConn).SetKeepAlivePeriod(3 * time.Minute)\n\treturn\n}\n\nfunc newListener(address, network string) (*tcpKeepAliveListener, error) {\n\tif network != \"tcp\" && network != \"tcp4\" && network != \"tcp6\" {\n\t\treturn nil, ErrInvalidListenerNetwork\n\t}\n\tl, err := net.Listen(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tcpKeepAliveListener{l.(*net.TCPListener)}, nil\n}\n\nfunc applyMiddleware(h HandlerFunc, middleware ...MiddlewareFunc) HandlerFunc {\n\tfor i := len(middleware) - 1; i >= 0; i-- {\n\t\th = middleware[i](h)\n\t}\n\treturn h\n}\n", "package echo\n\nimport (\n\t\"bytes\"\n\tstdContext \"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/http2\"\n)\n\ntype (\n\tuser struct {\n\t\tID   int    `json:\"id\" xml:\"id\" form:\"id\" query:\"id\" param:\"id\"`\n\t\tName string `json:\"name\" xml:\"name\" form:\"name\" query:\"name\" param:\"name\"`\n\t}\n)\n\nconst (\n\tuserJSON                    = `{\"id\":1,\"name\":\"Jon Snow\"}`\n\tuserXML                     = `<user><id>1</id><name>Jon Snow</name></user>`\n\tuserForm                    = `id=1&name=Jon Snow`\n\tinvalidContent              = \"invalid content\"\n\tuserJSONInvalidType         = `{\"id\":\"1\",\"name\":\"Jon Snow\"}`\n\tuserXMLConvertNumberError   = `<user><id>Number one</id><name>Jon Snow</name></user>`\n\tuserXMLUnsupportedTypeError = `<user><>Number one</><name>Jon Snow</name></user>`\n)\n\nconst userJSONPretty = `{\n  \"id\": 1,\n  \"name\": \"Jon Snow\"\n}`\n\nconst userXMLPretty = `<user>\n  <id>1</id>\n  <name>Jon Snow</name>\n</user>`\n\nfunc TestEcho(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\n\t// Router\n\tassert.NotNil(t, e.Router())\n\n\t// DefaultHTTPErrorHandler\n\te.DefaultHTTPErrorHandler(errors.New(\"error\"), c)\n\tassert.Equal(t, http.StatusInternalServerError, rec.Code)\n}\n\nfunc TestEchoStatic(t *testing.T) {\n\te := New()\n\n\tassert := assert.New(t)\n\n\t// OK\n\te.Static(\"/images\", \"_fixture/images\")\n\tc, b := request(http.MethodGet, \"/images/walle.png\", e)\n\tassert.Equal(http.StatusOK, c)\n\tassert.NotEmpty(b)\n\n\t// No file\n\te.Static(\"/images\", \"_fixture/scripts\")\n\tc, _ = request(http.MethodGet, \"/images/bolt.png\", e)\n\tassert.Equal(http.StatusNotFound, c)\n\n\t// Directory\n\te.Static(\"/images\", \"_fixture/images\")\n\tc, _ = request(http.MethodGet, \"/images/\", e)\n\tassert.Equal(http.StatusNotFound, c)\n\n\t// Directory Redirect\n\te.Static(\"/\", \"_fixture\")\n\treq := httptest.NewRequest(http.MethodGet, \"/folder\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(http.StatusMovedPermanently, rec.Code)\n\tassert.Equal(\"/folder/\", rec.HeaderMap[\"Location\"][0])\n\n\t// Directory with index.html\n\te.Static(\"/\", \"_fixture\")\n\tc, r := request(http.MethodGet, \"/\", e)\n\tassert.Equal(http.StatusOK, c)\n\tassert.Equal(true, strings.HasPrefix(r, \"<!doctype html>\"))\n\n\t// Sub-directory with index.html\n\tc, r = request(http.MethodGet, \"/folder/\", e)\n\tassert.Equal(http.StatusOK, c)\n\tassert.Equal(true, strings.HasPrefix(r, \"<!doctype html>\"))\n\n}\n\nfunc TestEchoFile(t *testing.T) {\n\te := New()\n\te.File(\"/walle\", \"_fixture/images/walle.png\")\n\tc, b := request(http.MethodGet, \"/walle\", e)\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.NotEmpty(t, b)\n}\n\nfunc TestEchoMiddleware(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\n\te.Pre(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tassert.Empty(t, c.Path())\n\t\t\tbuf.WriteString(\"-1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"2\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"3\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\t// Route\n\te.GET(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tc, b := request(http.MethodGet, \"/\", e)\n\tassert.Equal(t, \"-1123\", buf.String())\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.Equal(t, \"OK\", b)\n}\n\nfunc TestEchoMiddlewareError(t *testing.T) {\n\te := New()\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn errors.New(\"error\")\n\t\t}\n\t})\n\te.GET(\"/\", NotFoundHandler)\n\tc, _ := request(http.MethodGet, \"/\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n}\n\nfunc TestEchoHandler(t *testing.T) {\n\te := New()\n\n\t// HandlerFunc\n\te.GET(\"/ok\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tc, b := request(http.MethodGet, \"/ok\", e)\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.Equal(t, \"OK\", b)\n}\n\nfunc TestEchoWrapHandler(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\th := WrapHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"test\"))\n\t}))\n\tif assert.NoError(t, h(c)) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"test\", rec.Body.String())\n\t}\n}\n\nfunc TestEchoWrapMiddleware(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tbuf := new(bytes.Buffer)\n\tmw := WrapMiddleware(func(h http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tbuf.Write([]byte(\"mw\"))\n\t\t\th.ServeHTTP(w, r)\n\t\t})\n\t})\n\th := mw(func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\tif assert.NoError(t, h(c)) {\n\t\tassert.Equal(t, \"mw\", buf.String())\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"OK\", rec.Body.String())\n\t}\n}\n\nfunc TestEchoConnect(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodConnect, \"/\", e)\n}\n\nfunc TestEchoDelete(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodDelete, \"/\", e)\n}\n\nfunc TestEchoGet(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodGet, \"/\", e)\n}\n\nfunc TestEchoHead(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodHead, \"/\", e)\n}\n\nfunc TestEchoOptions(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodOptions, \"/\", e)\n}\n\nfunc TestEchoPatch(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPatch, \"/\", e)\n}\n\nfunc TestEchoPost(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPost, \"/\", e)\n}\n\nfunc TestEchoPut(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPut, \"/\", e)\n}\n\nfunc TestEchoTrace(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodTrace, \"/\", e)\n}\n\nfunc TestEchoAny(t *testing.T) { // JFC\n\te := New()\n\te.Any(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Any\")\n\t})\n}\n\nfunc TestEchoMatch(t *testing.T) { // JFC\n\te := New()\n\te.Match([]string{http.MethodGet, http.MethodPost}, \"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Match\")\n\t})\n}\n\nfunc TestEchoURL(t *testing.T) {\n\te := New()\n\tstatic := func(Context) error { return nil }\n\tgetUser := func(Context) error { return nil }\n\tgetAny := func(Context) error { return nil }\n\tgetFile := func(Context) error { return nil }\n\n\te.GET(\"/static/file\", static)\n\te.GET(\"/users/:id\", getUser)\n\te.GET(\"/documents/*\", getAny)\n\tg := e.Group(\"/group\")\n\tg.GET(\"/users/:uid/files/:fid\", getFile)\n\n\tassert := assert.New(t)\n\n\tassert.Equal(\"/static/file\", e.URL(static))\n\tassert.Equal(\"/users/:id\", e.URL(getUser))\n\tassert.Equal(\"/users/1\", e.URL(getUser, \"1\"))\n\tassert.Equal(\"/users/1\", e.URL(getUser, \"1\"))\n\tassert.Equal(\"/documents/foo.txt\", e.URL(getAny, \"foo.txt\"))\n\tassert.Equal(\"/documents/*\", e.URL(getAny))\n\tassert.Equal(\"/group/users/1/files/:fid\", e.URL(getFile, \"1\"))\n\tassert.Equal(\"/group/users/1/files/1\", e.URL(getFile, \"1\", \"1\"))\n}\n\nfunc TestEchoRoutes(t *testing.T) {\n\te := New()\n\troutes := []*Route{\n\t\t{http.MethodGet, \"/users/:user/events\", \"\"},\n\t\t{http.MethodGet, \"/users/:user/events/public\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/refs\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/tags\", \"\"},\n\t}\n\tfor _, r := range routes {\n\t\te.Add(r.Method, r.Path, func(c Context) error {\n\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t})\n\t}\n\n\tif assert.Equal(t, len(routes), len(e.Routes())) {\n\t\tfor _, r := range e.Routes() {\n\t\t\tfound := false\n\t\t\tfor _, rr := range routes {\n\t\t\t\tif r.Method == rr.Method && r.Path == rr.Path {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tt.Errorf(\"Route %s %s not found\", r.Method, r.Path)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEchoEncodedPath(t *testing.T) {\n\te := New()\n\te.GET(\"/:id\", func(c Context) error {\n\t\treturn c.NoContent(http.StatusOK)\n\t})\n\treq := httptest.NewRequest(http.MethodGet, \"/with%2Fslash\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestEchoGroup(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\te.Use(MiddlewareFunc(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"0\")\n\t\t\treturn next(c)\n\t\t}\n\t}))\n\th := func(c Context) error {\n\t\treturn c.NoContent(http.StatusOK)\n\t}\n\n\t//--------\n\t// Routes\n\t//--------\n\n\te.GET(\"/users\", h)\n\n\t// Group\n\tg1 := e.Group(\"/group1\")\n\tg1.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg1.GET(\"\", h)\n\n\t// Nested groups with middleware\n\tg2 := e.Group(\"/group2\")\n\tg2.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"2\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg3 := g2.Group(\"/group3\")\n\tg3.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"3\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg3.GET(\"\", h)\n\n\trequest(http.MethodGet, \"/users\", e)\n\tassert.Equal(t, \"0\", buf.String())\n\n\tbuf.Reset()\n\trequest(http.MethodGet, \"/group1\", e)\n\tassert.Equal(t, \"01\", buf.String())\n\n\tbuf.Reset()\n\trequest(http.MethodGet, \"/group2/group3\", e)\n\tassert.Equal(t, \"023\", buf.String())\n}\n\nfunc TestEchoNotFound(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/files\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusNotFound, rec.Code)\n}\n\nfunc TestEchoMethodNotAllowed(t *testing.T) {\n\te := New()\n\te.GET(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Echo!\")\n\t})\n\treq := httptest.NewRequest(http.MethodPost, \"/\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusMethodNotAllowed, rec.Code)\n}\n\nfunc TestEchoContext(t *testing.T) {\n\te := New()\n\tc := e.AcquireContext()\n\tassert.IsType(t, new(context), c)\n\te.ReleaseContext(c)\n}\n\nfunc TestEchoStart(t *testing.T) {\n\te := New()\n\tgo func() {\n\t\tassert.NoError(t, e.Start(\":0\"))\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n}\n\nfunc TestEchoStartTLS(t *testing.T) {\n\te := New()\n\tgo func() {\n\t\terr := e.StartTLS(\":0\", \"_fixture/certs/cert.pem\", \"_fixture/certs/key.pem\")\n\t\t// Prevent the test to fail after closing the servers\n\t\tif err != http.ErrServerClosed {\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n\n\te.Close()\n}\n\nfunc TestEchoStartTLSByteString(t *testing.T) {\n\tcert, err := ioutil.ReadFile(\"_fixture/certs/cert.pem\")\n\trequire.NoError(t, err)\n\tkey, err := ioutil.ReadFile(\"_fixture/certs/key.pem\")\n\trequire.NoError(t, err)\n\n\ttestCases := []struct {\n\t\tcert        interface{}\n\t\tkey         interface{}\n\t\texpectedErr error\n\t\tname        string\n\t}{\n\t\t{\n\t\t\tcert:        \"_fixture/certs/cert.pem\",\n\t\t\tkey:         \"_fixture/certs/key.pem\",\n\t\t\texpectedErr: nil,\n\t\t\tname:        `ValidCertAndKeyFilePath`,\n\t\t},\n\t\t{\n\t\t\tcert:        cert,\n\t\t\tkey:         key,\n\t\t\texpectedErr: nil,\n\t\t\tname:        `ValidCertAndKeyByteString`,\n\t\t},\n\t\t{\n\t\t\tcert:        cert,\n\t\t\tkey:         1,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidKeyType`,\n\t\t},\n\t\t{\n\t\t\tcert:        0,\n\t\t\tkey:         key,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidCertType`,\n\t\t},\n\t\t{\n\t\t\tcert:        0,\n\t\t\tkey:         1,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidCertAndKeyTypes`,\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.HideBanner = true\n\n\t\t\tgo func() {\n\t\t\t\terr := e.StartTLS(\":0\", test.cert, test.key)\n\t\t\t\tif test.expectedErr != nil {\n\t\t\t\t\trequire.EqualError(t, err, test.expectedErr.Error())\n\t\t\t\t} else if err != http.ErrServerClosed { // Prevent the test to fail after closing the servers\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t\trequire.NoError(t, e.Close())\n\t\t})\n\t}\n}\n\nfunc TestEchoStartAutoTLS(t *testing.T) {\n\te := New()\n\terrChan := make(chan error, 0)\n\n\tgo func() {\n\t\terrChan <- e.StartAutoTLS(\":0\")\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n\n\tselect {\n\tcase err := <-errChan:\n\t\tassert.NoError(t, err)\n\tdefault:\n\t\tassert.NoError(t, e.Close())\n\t}\n}\n\nfunc TestEchoStartH2CServer(t *testing.T) {\n\te := New()\n\te.Debug = true\n\th2s := &http2.Server{}\n\n\tgo func() {\n\t\tassert.NoError(t, e.StartH2CServer(\":0\", h2s))\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n}\n\nfunc testMethod(t *testing.T, method, path string, e *Echo) {\n\tp := reflect.ValueOf(path)\n\th := reflect.ValueOf(func(c Context) error {\n\t\treturn c.String(http.StatusOK, method)\n\t})\n\ti := interface{}(e)\n\treflect.ValueOf(i).MethodByName(method).Call([]reflect.Value{p, h})\n\t_, body := request(method, path, e)\n\tassert.Equal(t, method, body)\n}\n\nfunc request(method, path string, e *Echo) (int, string) {\n\treq := httptest.NewRequest(method, path, nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\treturn rec.Code, rec.Body.String()\n}\n\nfunc TestHTTPError(t *testing.T) {\n\tt.Run(\"non-internal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\n\t\tassert.Equal(t, \"code=400, message=map[code:12]\", err.Error())\n\t})\n\tt.Run(\"internal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\t\terr.SetInternal(errors.New(\"internal error\"))\n\t\tassert.Equal(t, \"code=400, message=map[code:12], internal=internal error\", err.Error())\n\t})\n}\n\nfunc TestDefaultHTTPErrorHandler(t *testing.T) {\n\te := New()\n\te.Debug = true\n\te.Any(\"/plain\", func(c Context) error {\n\t\treturn errors.New(\"An error occurred\")\n\t})\n\te.Any(\"/badrequest\", func(c Context) error {\n\t\treturn NewHTTPError(http.StatusBadRequest, \"Invalid request\")\n\t})\n\te.Any(\"/servererror\", func(c Context) error {\n\t\treturn NewHTTPError(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"code\":    33,\n\t\t\t\"message\": \"Something bad happened\",\n\t\t\t\"error\":   \"stackinfo\",\n\t\t})\n\t})\n\t// With Debug=true plain response contains error message\n\tc, b := request(http.MethodGet, \"/plain\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\n  \\\"error\\\": \\\"An error occurred\\\",\\n  \\\"message\\\": \\\"Internal Server Error\\\"\\n}\\n\", b)\n\t// and special handling for HTTPError\n\tc, b = request(http.MethodGet, \"/badrequest\", e)\n\tassert.Equal(t, http.StatusBadRequest, c)\n\tassert.Equal(t, \"{\\n  \\\"error\\\": \\\"code=400, message=Invalid request\\\",\\n  \\\"message\\\": \\\"Invalid request\\\"\\n}\\n\", b)\n\t// complex errors are serialized to pretty JSON\n\tc, b = request(http.MethodGet, \"/servererror\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\n  \\\"code\\\": 33,\\n  \\\"error\\\": \\\"stackinfo\\\",\\n  \\\"message\\\": \\\"Something bad happened\\\"\\n}\\n\", b)\n\n\te.Debug = false\n\t// With Debug=false the error response is shortened\n\tc, b = request(http.MethodGet, \"/plain\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\\"message\\\":\\\"Internal Server Error\\\"}\\n\", b)\n\tc, b = request(http.MethodGet, \"/badrequest\", e)\n\tassert.Equal(t, http.StatusBadRequest, c)\n\tassert.Equal(t, \"{\\\"message\\\":\\\"Invalid request\\\"}\\n\", b)\n\t// No difference for error response with non plain string errors\n\tc, b = request(http.MethodGet, \"/servererror\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\\"code\\\":33,\\\"error\\\":\\\"stackinfo\\\",\\\"message\\\":\\\"Something bad happened\\\"}\\n\", b)\n}\n\nfunc TestEchoClose(t *testing.T) {\n\te := New()\n\terrCh := make(chan error)\n\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tif err := e.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.NoError(t, e.Close())\n\n\terr := <-errCh\n\tassert.Equal(t, err.Error(), \"http: Server closed\")\n}\n\nfunc TestEchoShutdown(t *testing.T) {\n\te := New()\n\terrCh := make(chan error)\n\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tif err := e.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx, cancel := stdContext.WithTimeout(stdContext.Background(), 10*time.Second)\n\tdefer cancel()\n\tassert.NoError(t, e.Shutdown(ctx))\n\n\terr := <-errCh\n\tassert.Equal(t, err.Error(), \"http: Server closed\")\n}\n\nvar listenerNetworkTests = []struct {\n\ttest    string\n\tnetwork string\n\taddress string\n}{\n\t{\"tcp ipv4 address\", \"tcp\", \"127.0.0.1:1323\"},\n\t{\"tcp ipv6 address\", \"tcp\", \"[::1]:1323\"},\n\t{\"tcp4 ipv4 address\", \"tcp4\", \"127.0.0.1:1323\"},\n\t{\"tcp6 ipv6 address\", \"tcp6\", \"[::1]:1323\"},\n}\n\nfunc TestEchoListenerNetwork(t *testing.T) {\n\tfor _, tt := range listenerNetworkTests {\n\t\tt.Run(tt.test, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.ListenerNetwork = tt.network\n\n\t\t\t// HandlerFunc\n\t\t\te.GET(\"/ok\", func(c Context) error {\n\t\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t\t})\n\n\t\t\terrCh := make(chan error)\n\n\t\t\tgo func() {\n\t\t\t\terrCh <- e.Start(tt.address)\n\t\t\t}()\n\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t\tif resp, err := http.Get(fmt.Sprintf(\"http://%s/ok\", tt.address)); err == nil {\n\t\t\t\tdefer resp.Body.Close()\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n\n\t\t\t\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\t\t\t\tassert.Equal(t, \"OK\", string(body))\n\t\t\t\t} else {\n\t\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t}\n\n\t\t\tif err := e.Close(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEchoListenerNetworkInvalid(t *testing.T) {\n\te := New()\n\te.ListenerNetwork = \"unix\"\n\n\t// HandlerFunc\n\te.GET(\"/ok\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tassert.Equal(t, ErrInvalidListenerNetwork, e.Start(\":1323\"))\n}\n\nfunc TestEchoReverse(t *testing.T) {\n\tassert := assert.New(t)\n\n\te := New()\n\tdummyHandler := func(Context) error { return nil }\n\n\te.GET(\"/static\", dummyHandler).Name = \"/static\"\n\te.GET(\"/static/*\", dummyHandler).Name = \"/static/*\"\n\te.GET(\"/params/:foo\", dummyHandler).Name = \"/params/:foo\"\n\te.GET(\"/params/:foo/bar/:qux\", dummyHandler).Name = \"/params/:foo/bar/:qux\"\n\te.GET(\"/params/:foo/bar/:qux/*\", dummyHandler).Name = \"/params/:foo/bar/:qux/*\"\n\n\tassert.Equal(\"/static\", e.Reverse(\"/static\"))\n\tassert.Equal(\"/static\", e.Reverse(\"/static\", \"missing param\"))\n\tassert.Equal(\"/static/*\", e.Reverse(\"/static/*\"))\n\tassert.Equal(\"/static/foo.txt\", e.Reverse(\"/static/*\", \"foo.txt\"))\n\n\tassert.Equal(\"/params/:foo\", e.Reverse(\"/params/:foo\"))\n\tassert.Equal(\"/params/one\", e.Reverse(\"/params/:foo\", \"one\"))\n\tassert.Equal(\"/params/:foo/bar/:qux\", e.Reverse(\"/params/:foo/bar/:qux\"))\n\tassert.Equal(\"/params/one/bar/:qux\", e.Reverse(\"/params/:foo/bar/:qux\", \"one\"))\n\tassert.Equal(\"/params/one/bar/two\", e.Reverse(\"/params/:foo/bar/:qux\", \"one\", \"two\"))\n\tassert.Equal(\"/params/one/bar/two/three\", e.Reverse(\"/params/:foo/bar/:qux/*\", \"one\", \"two\", \"three\"))\n}\n", "package middleware\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/gommon/bytes\"\n)\n\ntype (\n\t// StaticConfig defines the config for Static middleware.\n\tStaticConfig struct {\n\t\t// Skipper defines a function to skip middleware.\n\t\tSkipper Skipper\n\n\t\t// Root directory from where the static content is served.\n\t\t// Required.\n\t\tRoot string `yaml:\"root\"`\n\n\t\t// Index file for serving a directory.\n\t\t// Optional. Default value \"index.html\".\n\t\tIndex string `yaml:\"index\"`\n\n\t\t// Enable HTML5 mode by forwarding all not-found requests to root so that\n\t\t// SPA (single-page application) can handle the routing.\n\t\t// Optional. Default value false.\n\t\tHTML5 bool `yaml:\"html5\"`\n\n\t\t// Enable directory browsing.\n\t\t// Optional. Default value false.\n\t\tBrowse bool `yaml:\"browse\"`\n\n\t\t// Enable ignoring of the base of the URL path.\n\t\t// Example: when assigning a static middleware to a non root path group,\n\t\t// the filesystem path is not doubled\n\t\t// Optional. Default value false.\n\t\tIgnoreBase bool `yaml:\"ignoreBase\"`\n\t}\n)\n\nconst html = `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>{{ .Name }}</title>\n  <style>\n    body {\n\t\t\tfont-family: Menlo, Consolas, monospace;\n\t\t\tpadding: 48px;\n\t\t}\n\t\theader {\n\t\t\tpadding: 4px 16px;\n\t\t\tfont-size: 24px;\n\t\t}\n    ul {\n\t\t\tlist-style-type: none;\n\t\t\tmargin: 0;\n    \tpadding: 20px 0 0 0;\n\t\t\tdisplay: flex;\n\t\t\tflex-wrap: wrap;\n    }\n    li {\n\t\t\twidth: 300px;\n\t\t\tpadding: 16px;\n\t\t}\n\t\tli a {\n\t\t\tdisplay: block;\n\t\t\toverflow: hidden;\n\t\t\twhite-space: nowrap;\n\t\t\ttext-overflow: ellipsis;\n\t\t\ttext-decoration: none;\n\t\t\ttransition: opacity 0.25s;\n\t\t}\n\t\tli span {\n\t\t\tcolor: #707070;\n\t\t\tfont-size: 12px;\n\t\t}\n\t\tli a:hover {\n\t\t\topacity: 0.50;\n\t\t}\n\t\t.dir {\n\t\t\tcolor: #E91E63;\n\t\t}\n\t\t.file {\n\t\t\tcolor: #673AB7;\n\t\t}\n  </style>\n</head>\n<body>\n\t<header>\n\t\t{{ .Name }}\n\t</header>\n\t<ul>\n\t\t{{ range .Files }}\n\t\t<li>\n\t\t{{ if .Dir }}\n\t\t\t{{ $name := print .Name \"/\" }}\n\t\t\t<a class=\"dir\" href=\"{{ $name }}\">{{ $name }}</a>\n\t\t\t{{ else }}\n\t\t\t<a class=\"file\" href=\"{{ .Name }}\">{{ .Name }}</a>\n\t\t\t<span>{{ .Size }}</span>\n\t\t{{ end }}\n\t\t</li>\n\t\t{{ end }}\n  </ul>\n</body>\n</html>\n`\n\nvar (\n\t// DefaultStaticConfig is the default Static middleware config.\n\tDefaultStaticConfig = StaticConfig{\n\t\tSkipper: DefaultSkipper,\n\t\tIndex:   \"index.html\",\n\t}\n)\n\n// Static returns a Static middleware to serves static content from the provided\n// root directory.\nfunc Static(root string) echo.MiddlewareFunc {\n\tc := DefaultStaticConfig\n\tc.Root = root\n\treturn StaticWithConfig(c)\n}\n\n// StaticWithConfig returns a Static middleware with config.\n// See `Static()`.\nfunc StaticWithConfig(config StaticConfig) echo.MiddlewareFunc {\n\t// Defaults\n\tif config.Root == \"\" {\n\t\tconfig.Root = \".\" // For security we want to restrict to CWD.\n\t}\n\tif config.Skipper == nil {\n\t\tconfig.Skipper = DefaultStaticConfig.Skipper\n\t}\n\tif config.Index == \"\" {\n\t\tconfig.Index = DefaultStaticConfig.Index\n\t}\n\n\t// Index template\n\tt, err := template.New(\"index\").Parse(html)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"echo: %v\", err))\n\t}\n\n\treturn func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) (err error) {\n\t\t\tif config.Skipper(c) {\n\t\t\t\treturn next(c)\n\t\t\t}\n\n\t\t\tp := c.Request().URL.Path\n\t\t\tif strings.HasSuffix(c.Path(), \"*\") { // When serving from a group, e.g. `/static*`.\n\t\t\t\tp = c.Param(\"*\")\n\t\t\t}\n\t\t\tp, err = url.PathUnescape(p)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tname := filepath.Join(config.Root, path.Clean(\"/\"+p)) // \"/\"+ for security\n\n\t\t\tif config.IgnoreBase {\n\t\t\t\troutePath := path.Base(strings.TrimRight(c.Path(), \"/*\"))\n\t\t\t\tbaseURLPath := path.Base(p)\n\t\t\t\tif baseURLPath == routePath {\n\t\t\t\t\ti := strings.LastIndex(name, routePath)\n\t\t\t\t\tname = name[:i] + strings.Replace(name[i:], routePath, \"\", 1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfi, err := os.Stat(name)\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\tif err = next(c); err != nil {\n\t\t\t\t\t\tif he, ok := err.(*echo.HTTPError); ok {\n\t\t\t\t\t\t\tif config.HTML5 && he.Code == http.StatusNotFound {\n\t\t\t\t\t\t\t\treturn c.File(filepath.Join(config.Root, config.Index))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif fi.IsDir() {\n\t\t\t\tindex := filepath.Join(name, config.Index)\n\t\t\t\tfi, err = os.Stat(index)\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tif config.Browse {\n\t\t\t\t\t\treturn listDir(t, name, c.Response())\n\t\t\t\t\t}\n\t\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\t\treturn next(c)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\treturn c.File(index)\n\t\t\t}\n\n\t\t\treturn c.File(name)\n\t\t}\n\t}\n}\n\nfunc listDir(t *template.Template, name string, res *echo.Response) (err error) {\n\tfile, err := os.Open(name)\n\tif err != nil {\n\t\treturn\n\t}\n\tfiles, err := file.Readdir(-1)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Create directory index\n\tres.Header().Set(echo.HeaderContentType, echo.MIMETextHTMLCharsetUTF8)\n\tdata := struct {\n\t\tName  string\n\t\tFiles []interface{}\n\t}{\n\t\tName: name,\n\t}\n\tfor _, f := range files {\n\t\tdata.Files = append(data.Files, struct {\n\t\t\tName string\n\t\t\tDir  bool\n\t\t\tSize string\n\t\t}{f.Name(), f.IsDir(), bytes.Format(f.Size())})\n\t}\n\treturn t.Execute(res, data)\n}\n"], "fixing_code": ["/*\nPackage echo implements high performance, minimalist Go web framework.\n\nExample:\n\n  package main\n\n  import (\n    \"net/http\"\n\n    \"github.com/labstack/echo/v4\"\n    \"github.com/labstack/echo/v4/middleware\"\n  )\n\n  // Handler\n  func hello(c echo.Context) error {\n    return c.String(http.StatusOK, \"Hello, World!\")\n  }\n\n  func main() {\n    // Echo instance\n    e := echo.New()\n\n    // Middleware\n    e.Use(middleware.Logger())\n    e.Use(middleware.Recover())\n\n    // Routes\n    e.GET(\"/\", hello)\n\n    // Start server\n    e.Logger.Fatal(e.Start(\":1323\"))\n  }\n\nLearn more at https://echo.labstack.com\n*/\npackage echo\n\nimport (\n\t\"bytes\"\n\tstdContext \"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\tstdLog \"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/labstack/gommon/color\"\n\t\"github.com/labstack/gommon/log\"\n\t\"golang.org/x/crypto/acme\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\ntype (\n\t// Echo is the top-level framework instance.\n\tEcho struct {\n\t\tcommon\n\t\tStdLogger        *stdLog.Logger\n\t\tcolorer          *color.Color\n\t\tpremiddleware    []MiddlewareFunc\n\t\tmiddleware       []MiddlewareFunc\n\t\tmaxParam         *int\n\t\trouter           *Router\n\t\trouters          map[string]*Router\n\t\tnotFoundHandler  HandlerFunc\n\t\tpool             sync.Pool\n\t\tServer           *http.Server\n\t\tTLSServer        *http.Server\n\t\tListener         net.Listener\n\t\tTLSListener      net.Listener\n\t\tAutoTLSManager   autocert.Manager\n\t\tDisableHTTP2     bool\n\t\tDebug            bool\n\t\tHideBanner       bool\n\t\tHidePort         bool\n\t\tHTTPErrorHandler HTTPErrorHandler\n\t\tBinder           Binder\n\t\tValidator        Validator\n\t\tRenderer         Renderer\n\t\tLogger           Logger\n\t\tIPExtractor      IPExtractor\n\t\tListenerNetwork  string\n\t}\n\n\t// Route contains a handler and information for matching against requests.\n\tRoute struct {\n\t\tMethod string `json:\"method\"`\n\t\tPath   string `json:\"path\"`\n\t\tName   string `json:\"name\"`\n\t}\n\n\t// HTTPError represents an error that occurred while handling a request.\n\tHTTPError struct {\n\t\tCode     int         `json:\"-\"`\n\t\tMessage  interface{} `json:\"message\"`\n\t\tInternal error       `json:\"-\"` // Stores the error returned by an external dependency\n\t}\n\n\t// MiddlewareFunc defines a function to process middleware.\n\tMiddlewareFunc func(HandlerFunc) HandlerFunc\n\n\t// HandlerFunc defines a function to serve HTTP requests.\n\tHandlerFunc func(Context) error\n\n\t// HTTPErrorHandler is a centralized HTTP error handler.\n\tHTTPErrorHandler func(error, Context)\n\n\t// Validator is the interface that wraps the Validate function.\n\tValidator interface {\n\t\tValidate(i interface{}) error\n\t}\n\n\t// Renderer is the interface that wraps the Render function.\n\tRenderer interface {\n\t\tRender(io.Writer, string, interface{}, Context) error\n\t}\n\n\t// Map defines a generic map of type `map[string]interface{}`.\n\tMap map[string]interface{}\n\n\t// Common struct for Echo & Group.\n\tcommon struct{}\n)\n\n// HTTP methods\n// NOTE: Deprecated, please use the stdlib constants directly instead.\nconst (\n\tCONNECT = http.MethodConnect\n\tDELETE  = http.MethodDelete\n\tGET     = http.MethodGet\n\tHEAD    = http.MethodHead\n\tOPTIONS = http.MethodOptions\n\tPATCH   = http.MethodPatch\n\tPOST    = http.MethodPost\n\t// PROPFIND = \"PROPFIND\"\n\tPUT   = http.MethodPut\n\tTRACE = http.MethodTrace\n)\n\n// MIME types\nconst (\n\tMIMEApplicationJSON                  = \"application/json\"\n\tMIMEApplicationJSONCharsetUTF8       = MIMEApplicationJSON + \"; \" + charsetUTF8\n\tMIMEApplicationJavaScript            = \"application/javascript\"\n\tMIMEApplicationJavaScriptCharsetUTF8 = MIMEApplicationJavaScript + \"; \" + charsetUTF8\n\tMIMEApplicationXML                   = \"application/xml\"\n\tMIMEApplicationXMLCharsetUTF8        = MIMEApplicationXML + \"; \" + charsetUTF8\n\tMIMETextXML                          = \"text/xml\"\n\tMIMETextXMLCharsetUTF8               = MIMETextXML + \"; \" + charsetUTF8\n\tMIMEApplicationForm                  = \"application/x-www-form-urlencoded\"\n\tMIMEApplicationProtobuf              = \"application/protobuf\"\n\tMIMEApplicationMsgpack               = \"application/msgpack\"\n\tMIMETextHTML                         = \"text/html\"\n\tMIMETextHTMLCharsetUTF8              = MIMETextHTML + \"; \" + charsetUTF8\n\tMIMETextPlain                        = \"text/plain\"\n\tMIMETextPlainCharsetUTF8             = MIMETextPlain + \"; \" + charsetUTF8\n\tMIMEMultipartForm                    = \"multipart/form-data\"\n\tMIMEOctetStream                      = \"application/octet-stream\"\n)\n\nconst (\n\tcharsetUTF8 = \"charset=UTF-8\"\n\t// PROPFIND Method can be used on collection and property resources.\n\tPROPFIND = \"PROPFIND\"\n\t// REPORT Method can be used to get information about a resource, see rfc 3253\n\tREPORT = \"REPORT\"\n)\n\n// Headers\nconst (\n\tHeaderAccept              = \"Accept\"\n\tHeaderAcceptEncoding      = \"Accept-Encoding\"\n\tHeaderAllow               = \"Allow\"\n\tHeaderAuthorization       = \"Authorization\"\n\tHeaderContentDisposition  = \"Content-Disposition\"\n\tHeaderContentEncoding     = \"Content-Encoding\"\n\tHeaderContentLength       = \"Content-Length\"\n\tHeaderContentType         = \"Content-Type\"\n\tHeaderCookie              = \"Cookie\"\n\tHeaderSetCookie           = \"Set-Cookie\"\n\tHeaderIfModifiedSince     = \"If-Modified-Since\"\n\tHeaderLastModified        = \"Last-Modified\"\n\tHeaderLocation            = \"Location\"\n\tHeaderUpgrade             = \"Upgrade\"\n\tHeaderVary                = \"Vary\"\n\tHeaderWWWAuthenticate     = \"WWW-Authenticate\"\n\tHeaderXForwardedFor       = \"X-Forwarded-For\"\n\tHeaderXForwardedProto     = \"X-Forwarded-Proto\"\n\tHeaderXForwardedProtocol  = \"X-Forwarded-Protocol\"\n\tHeaderXForwardedSsl       = \"X-Forwarded-Ssl\"\n\tHeaderXUrlScheme          = \"X-Url-Scheme\"\n\tHeaderXHTTPMethodOverride = \"X-HTTP-Method-Override\"\n\tHeaderXRealIP             = \"X-Real-IP\"\n\tHeaderXRequestID          = \"X-Request-ID\"\n\tHeaderXRequestedWith      = \"X-Requested-With\"\n\tHeaderServer              = \"Server\"\n\tHeaderOrigin              = \"Origin\"\n\n\t// Access control\n\tHeaderAccessControlRequestMethod    = \"Access-Control-Request-Method\"\n\tHeaderAccessControlRequestHeaders   = \"Access-Control-Request-Headers\"\n\tHeaderAccessControlAllowOrigin      = \"Access-Control-Allow-Origin\"\n\tHeaderAccessControlAllowMethods     = \"Access-Control-Allow-Methods\"\n\tHeaderAccessControlAllowHeaders     = \"Access-Control-Allow-Headers\"\n\tHeaderAccessControlAllowCredentials = \"Access-Control-Allow-Credentials\"\n\tHeaderAccessControlExposeHeaders    = \"Access-Control-Expose-Headers\"\n\tHeaderAccessControlMaxAge           = \"Access-Control-Max-Age\"\n\n\t// Security\n\tHeaderStrictTransportSecurity         = \"Strict-Transport-Security\"\n\tHeaderXContentTypeOptions             = \"X-Content-Type-Options\"\n\tHeaderXXSSProtection                  = \"X-XSS-Protection\"\n\tHeaderXFrameOptions                   = \"X-Frame-Options\"\n\tHeaderContentSecurityPolicy           = \"Content-Security-Policy\"\n\tHeaderContentSecurityPolicyReportOnly = \"Content-Security-Policy-Report-Only\"\n\tHeaderXCSRFToken                      = \"X-CSRF-Token\"\n\tHeaderReferrerPolicy                  = \"Referrer-Policy\"\n)\n\nconst (\n\t// Version of Echo\n\tVersion = \"4.1.17\"\n\twebsite = \"https://echo.labstack.com\"\n\t// http://patorjk.com/software/taag/#p=display&f=Small%20Slant&t=Echo\n\tbanner = `\n   ____    __\n  / __/___/ /  ___\n / _// __/ _ \\/ _ \\\n/___/\\__/_//_/\\___/ %s\nHigh performance, minimalist Go web framework\n%s\n____________________________________O/_______\n                                    O\\\n`\n)\n\nvar (\n\tmethods = [...]string{\n\t\thttp.MethodConnect,\n\t\thttp.MethodDelete,\n\t\thttp.MethodGet,\n\t\thttp.MethodHead,\n\t\thttp.MethodOptions,\n\t\thttp.MethodPatch,\n\t\thttp.MethodPost,\n\t\tPROPFIND,\n\t\thttp.MethodPut,\n\t\thttp.MethodTrace,\n\t\tREPORT,\n\t}\n)\n\n// Errors\nvar (\n\tErrUnsupportedMediaType        = NewHTTPError(http.StatusUnsupportedMediaType)\n\tErrNotFound                    = NewHTTPError(http.StatusNotFound)\n\tErrUnauthorized                = NewHTTPError(http.StatusUnauthorized)\n\tErrForbidden                   = NewHTTPError(http.StatusForbidden)\n\tErrMethodNotAllowed            = NewHTTPError(http.StatusMethodNotAllowed)\n\tErrStatusRequestEntityTooLarge = NewHTTPError(http.StatusRequestEntityTooLarge)\n\tErrTooManyRequests             = NewHTTPError(http.StatusTooManyRequests)\n\tErrBadRequest                  = NewHTTPError(http.StatusBadRequest)\n\tErrBadGateway                  = NewHTTPError(http.StatusBadGateway)\n\tErrInternalServerError         = NewHTTPError(http.StatusInternalServerError)\n\tErrRequestTimeout              = NewHTTPError(http.StatusRequestTimeout)\n\tErrServiceUnavailable          = NewHTTPError(http.StatusServiceUnavailable)\n\tErrValidatorNotRegistered      = errors.New(\"validator not registered\")\n\tErrRendererNotRegistered       = errors.New(\"renderer not registered\")\n\tErrInvalidRedirectCode         = errors.New(\"invalid redirect status code\")\n\tErrCookieNotFound              = errors.New(\"cookie not found\")\n\tErrInvalidCertOrKeyType        = errors.New(\"invalid cert or key type, must be string or []byte\")\n\tErrInvalidListenerNetwork      = errors.New(\"invalid listener network\")\n)\n\n// Error handlers\nvar (\n\tNotFoundHandler = func(c Context) error {\n\t\treturn ErrNotFound\n\t}\n\n\tMethodNotAllowedHandler = func(c Context) error {\n\t\treturn ErrMethodNotAllowed\n\t}\n)\n\n// New creates an instance of Echo.\nfunc New() (e *Echo) {\n\te = &Echo{\n\t\tServer:    new(http.Server),\n\t\tTLSServer: new(http.Server),\n\t\tAutoTLSManager: autocert.Manager{\n\t\t\tPrompt: autocert.AcceptTOS,\n\t\t},\n\t\tLogger:          log.New(\"echo\"),\n\t\tcolorer:         color.New(),\n\t\tmaxParam:        new(int),\n\t\tListenerNetwork: \"tcp\",\n\t}\n\te.Server.Handler = e\n\te.TLSServer.Handler = e\n\te.HTTPErrorHandler = e.DefaultHTTPErrorHandler\n\te.Binder = &DefaultBinder{}\n\te.Logger.SetLevel(log.ERROR)\n\te.StdLogger = stdLog.New(e.Logger.Output(), e.Logger.Prefix()+\": \", 0)\n\te.pool.New = func() interface{} {\n\t\treturn e.NewContext(nil, nil)\n\t}\n\te.router = NewRouter(e)\n\te.routers = map[string]*Router{}\n\treturn\n}\n\n// NewContext returns a Context instance.\nfunc (e *Echo) NewContext(r *http.Request, w http.ResponseWriter) Context {\n\treturn &context{\n\t\trequest:  r,\n\t\tresponse: NewResponse(w, e),\n\t\tstore:    make(Map),\n\t\techo:     e,\n\t\tpvalues:  make([]string, *e.maxParam),\n\t\thandler:  NotFoundHandler,\n\t}\n}\n\n// Router returns the default router.\nfunc (e *Echo) Router() *Router {\n\treturn e.router\n}\n\n// Routers returns the map of host => router.\nfunc (e *Echo) Routers() map[string]*Router {\n\treturn e.routers\n}\n\n// DefaultHTTPErrorHandler is the default HTTP error handler. It sends a JSON response\n// with status code.\nfunc (e *Echo) DefaultHTTPErrorHandler(err error, c Context) {\n\the, ok := err.(*HTTPError)\n\tif ok {\n\t\tif he.Internal != nil {\n\t\t\tif herr, ok := he.Internal.(*HTTPError); ok {\n\t\t\t\the = herr\n\t\t\t}\n\t\t}\n\t} else {\n\t\the = &HTTPError{\n\t\t\tCode:    http.StatusInternalServerError,\n\t\t\tMessage: http.StatusText(http.StatusInternalServerError),\n\t\t}\n\t}\n\n\t// Issue #1426\n\tcode := he.Code\n\tmessage := he.Message\n\tif m, ok := he.Message.(string); ok {\n\t\tif e.Debug {\n\t\t\tmessage = Map{\"message\": m, \"error\": err.Error()}\n\t\t} else {\n\t\t\tmessage = Map{\"message\": m}\n\t\t}\n\t}\n\n\t// Send response\n\tif !c.Response().Committed {\n\t\tif c.Request().Method == http.MethodHead { // Issue #608\n\t\t\terr = c.NoContent(he.Code)\n\t\t} else {\n\t\t\terr = c.JSON(code, message)\n\t\t}\n\t\tif err != nil {\n\t\t\te.Logger.Error(err)\n\t\t}\n\t}\n}\n\n// Pre adds middleware to the chain which is run before router.\nfunc (e *Echo) Pre(middleware ...MiddlewareFunc) {\n\te.premiddleware = append(e.premiddleware, middleware...)\n}\n\n// Use adds middleware to the chain which is run after router.\nfunc (e *Echo) Use(middleware ...MiddlewareFunc) {\n\te.middleware = append(e.middleware, middleware...)\n}\n\n// CONNECT registers a new CONNECT route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) CONNECT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodConnect, path, h, m...)\n}\n\n// DELETE registers a new DELETE route for a path with matching handler in the router\n// with optional route-level middleware.\nfunc (e *Echo) DELETE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodDelete, path, h, m...)\n}\n\n// GET registers a new GET route for a path with matching handler in the router\n// with optional route-level middleware.\nfunc (e *Echo) GET(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodGet, path, h, m...)\n}\n\n// HEAD registers a new HEAD route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) HEAD(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodHead, path, h, m...)\n}\n\n// OPTIONS registers a new OPTIONS route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) OPTIONS(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodOptions, path, h, m...)\n}\n\n// PATCH registers a new PATCH route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) PATCH(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPatch, path, h, m...)\n}\n\n// POST registers a new POST route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) POST(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPost, path, h, m...)\n}\n\n// PUT registers a new PUT route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) PUT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPut, path, h, m...)\n}\n\n// TRACE registers a new TRACE route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) TRACE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodTrace, path, h, m...)\n}\n\n// Any registers a new route for all HTTP methods and path with matching handler\n// in the router with optional route-level middleware.\nfunc (e *Echo) Any(path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = e.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\n// Match registers a new route for multiple HTTP methods and path with matching\n// handler in the router with optional route-level middleware.\nfunc (e *Echo) Match(methods []string, path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = e.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\n// Static registers a new route with path prefix to serve static files from the\n// provided root directory.\nfunc (e *Echo) Static(prefix, root string) *Route {\n\tif root == \"\" {\n\t\troot = \".\" // For security we want to restrict to CWD.\n\t}\n\treturn e.static(prefix, root, e.GET)\n}\n\nfunc (common) static(prefix, root string, get func(string, HandlerFunc, ...MiddlewareFunc) *Route) *Route {\n\th := func(c Context) error {\n\t\tp, err := url.PathUnescape(c.Param(\"*\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tname := filepath.Join(root, filepath.Clean(\"/\"+p)) // \"/\"+ for security\n\t\tfi, err := os.Stat(name)\n\t\tif err != nil {\n\t\t\t// The access path does not exist\n\t\t\treturn NotFoundHandler(c)\n\t\t}\n\n\t\t// If the request is for a directory and does not end with \"/\"\n\t\tp = c.Request().URL.Path // path must not be empty.\n\t\tif fi.IsDir() && p[len(p)-1] != '/' {\n\t\t\t// Redirect to ends with \"/\"\n\t\t\treturn c.Redirect(http.StatusMovedPermanently, p+\"/\")\n\t\t}\n\t\treturn c.File(name)\n\t}\n\tif prefix == \"/\" {\n\t\treturn get(prefix+\"*\", h)\n\t}\n\treturn get(prefix+\"/*\", h)\n}\n\nfunc (common) file(path, file string, get func(string, HandlerFunc, ...MiddlewareFunc) *Route,\n\tm ...MiddlewareFunc) *Route {\n\treturn get(path, func(c Context) error {\n\t\treturn c.File(file)\n\t}, m...)\n}\n\n// File registers a new route with path to serve a static file with optional route-level middleware.\nfunc (e *Echo) File(path, file string, m ...MiddlewareFunc) *Route {\n\treturn e.file(path, file, e.GET, m...)\n}\n\nfunc (e *Echo) add(host, method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route {\n\tname := handlerName(handler)\n\trouter := e.findRouter(host)\n\trouter.Add(method, path, func(c Context) error {\n\t\th := applyMiddleware(handler, middleware...)\n\t\treturn h(c)\n\t})\n\tr := &Route{\n\t\tMethod: method,\n\t\tPath:   path,\n\t\tName:   name,\n\t}\n\te.router.routes[method+path] = r\n\treturn r\n}\n\n// Add registers a new route for an HTTP method and path with matching handler\n// in the router with optional route-level middleware.\nfunc (e *Echo) Add(method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route {\n\treturn e.add(\"\", method, path, handler, middleware...)\n}\n\n// Host creates a new router group for the provided host and optional host-level middleware.\nfunc (e *Echo) Host(name string, m ...MiddlewareFunc) (g *Group) {\n\te.routers[name] = NewRouter(e)\n\tg = &Group{host: name, echo: e}\n\tg.Use(m...)\n\treturn\n}\n\n// Group creates a new router group with prefix and optional group-level middleware.\nfunc (e *Echo) Group(prefix string, m ...MiddlewareFunc) (g *Group) {\n\tg = &Group{prefix: prefix, echo: e}\n\tg.Use(m...)\n\treturn\n}\n\n// URI generates a URI from handler.\nfunc (e *Echo) URI(handler HandlerFunc, params ...interface{}) string {\n\tname := handlerName(handler)\n\treturn e.Reverse(name, params...)\n}\n\n// URL is an alias for `URI` function.\nfunc (e *Echo) URL(h HandlerFunc, params ...interface{}) string {\n\treturn e.URI(h, params...)\n}\n\n// Reverse generates an URL from route name and provided parameters.\nfunc (e *Echo) Reverse(name string, params ...interface{}) string {\n\turi := new(bytes.Buffer)\n\tln := len(params)\n\tn := 0\n\tfor _, r := range e.router.routes {\n\t\tif r.Name == name {\n\t\t\tfor i, l := 0, len(r.Path); i < l; i++ {\n\t\t\t\tif (r.Path[i] == ':' || r.Path[i] == '*') && n < ln {\n\t\t\t\t\tfor ; i < l && r.Path[i] != '/'; i++ {\n\t\t\t\t\t}\n\t\t\t\t\turi.WriteString(fmt.Sprintf(\"%v\", params[n]))\n\t\t\t\t\tn++\n\t\t\t\t}\n\t\t\t\tif i < l {\n\t\t\t\t\turi.WriteByte(r.Path[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn uri.String()\n}\n\n// Routes returns the registered routes.\nfunc (e *Echo) Routes() []*Route {\n\troutes := make([]*Route, 0, len(e.router.routes))\n\tfor _, v := range e.router.routes {\n\t\troutes = append(routes, v)\n\t}\n\treturn routes\n}\n\n// AcquireContext returns an empty `Context` instance from the pool.\n// You must return the context by calling `ReleaseContext()`.\nfunc (e *Echo) AcquireContext() Context {\n\treturn e.pool.Get().(Context)\n}\n\n// ReleaseContext returns the `Context` instance back to the pool.\n// You must call it after `AcquireContext()`.\nfunc (e *Echo) ReleaseContext(c Context) {\n\te.pool.Put(c)\n}\n\n// ServeHTTP implements `http.Handler` interface, which serves HTTP requests.\nfunc (e *Echo) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Acquire context\n\tc := e.pool.Get().(*context)\n\tc.Reset(r, w)\n\th := NotFoundHandler\n\n\tif e.premiddleware == nil {\n\t\te.findRouter(r.Host).Find(r.Method, r.URL.EscapedPath(), c)\n\t\th = c.Handler()\n\t\th = applyMiddleware(h, e.middleware...)\n\t} else {\n\t\th = func(c Context) error {\n\t\t\te.findRouter(r.Host).Find(r.Method, r.URL.EscapedPath(), c)\n\t\t\th := c.Handler()\n\t\t\th = applyMiddleware(h, e.middleware...)\n\t\t\treturn h(c)\n\t\t}\n\t\th = applyMiddleware(h, e.premiddleware...)\n\t}\n\n\t// Execute chain\n\tif err := h(c); err != nil {\n\t\te.HTTPErrorHandler(err, c)\n\t}\n\n\t// Release context\n\te.pool.Put(c)\n}\n\n// Start starts an HTTP server.\nfunc (e *Echo) Start(address string) error {\n\te.Server.Addr = address\n\treturn e.StartServer(e.Server)\n}\n\n// StartTLS starts an HTTPS server.\n// If `certFile` or `keyFile` is `string` the values are treated as file paths.\n// If `certFile` or `keyFile` is `[]byte` the values are treated as the certificate or key as-is.\nfunc (e *Echo) StartTLS(address string, certFile, keyFile interface{}) (err error) {\n\tvar cert []byte\n\tif cert, err = filepathOrContent(certFile); err != nil {\n\t\treturn\n\t}\n\n\tvar key []byte\n\tif key, err = filepathOrContent(keyFile); err != nil {\n\t\treturn\n\t}\n\n\ts := e.TLSServer\n\ts.TLSConfig = new(tls.Config)\n\ts.TLSConfig.Certificates = make([]tls.Certificate, 1)\n\tif s.TLSConfig.Certificates[0], err = tls.X509KeyPair(cert, key); err != nil {\n\t\treturn\n\t}\n\n\treturn e.startTLS(address)\n}\n\nfunc filepathOrContent(fileOrContent interface{}) (content []byte, err error) {\n\tswitch v := fileOrContent.(type) {\n\tcase string:\n\t\treturn ioutil.ReadFile(v)\n\tcase []byte:\n\t\treturn v, nil\n\tdefault:\n\t\treturn nil, ErrInvalidCertOrKeyType\n\t}\n}\n\n// StartAutoTLS starts an HTTPS server using certificates automatically installed from https://letsencrypt.org.\nfunc (e *Echo) StartAutoTLS(address string) error {\n\ts := e.TLSServer\n\ts.TLSConfig = new(tls.Config)\n\ts.TLSConfig.GetCertificate = e.AutoTLSManager.GetCertificate\n\ts.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, acme.ALPNProto)\n\treturn e.startTLS(address)\n}\n\nfunc (e *Echo) startTLS(address string) error {\n\ts := e.TLSServer\n\ts.Addr = address\n\tif !e.DisableHTTP2 {\n\t\ts.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, \"h2\")\n\t}\n\treturn e.StartServer(e.TLSServer)\n}\n\n// StartServer starts a custom http server.\nfunc (e *Echo) StartServer(s *http.Server) (err error) {\n\t// Setup\n\te.colorer.SetOutput(e.Logger.Output())\n\ts.ErrorLog = e.StdLogger\n\ts.Handler = e\n\tif e.Debug {\n\t\te.Logger.SetLevel(log.DEBUG)\n\t}\n\n\tif !e.HideBanner {\n\t\te.colorer.Printf(banner, e.colorer.Red(\"v\"+Version), e.colorer.Blue(website))\n\t}\n\n\tif s.TLSConfig == nil {\n\t\tif e.Listener == nil {\n\t\t\te.Listener, err = newListener(s.Addr, e.ListenerNetwork)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif !e.HidePort {\n\t\t\te.colorer.Printf(\"\u21e8 http server started on %s\\n\", e.colorer.Green(e.Listener.Addr()))\n\t\t}\n\t\treturn s.Serve(e.Listener)\n\t}\n\tif e.TLSListener == nil {\n\t\tl, err := newListener(s.Addr, e.ListenerNetwork)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\te.TLSListener = tls.NewListener(l, s.TLSConfig)\n\t}\n\tif !e.HidePort {\n\t\te.colorer.Printf(\"\u21e8 https server started on %s\\n\", e.colorer.Green(e.TLSListener.Addr()))\n\t}\n\treturn s.Serve(e.TLSListener)\n}\n\n// StartH2CServer starts a custom http/2 server with h2c (HTTP/2 Cleartext).\nfunc (e *Echo) StartH2CServer(address string, h2s *http2.Server) (err error) {\n\t// Setup\n\ts := e.Server\n\ts.Addr = address\n\te.colorer.SetOutput(e.Logger.Output())\n\ts.ErrorLog = e.StdLogger\n\ts.Handler = h2c.NewHandler(e, h2s)\n\tif e.Debug {\n\t\te.Logger.SetLevel(log.DEBUG)\n\t}\n\n\tif !e.HideBanner {\n\t\te.colorer.Printf(banner, e.colorer.Red(\"v\"+Version), e.colorer.Blue(website))\n\t}\n\n\tif e.Listener == nil {\n\t\te.Listener, err = newListener(s.Addr, e.ListenerNetwork)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif !e.HidePort {\n\t\te.colorer.Printf(\"\u21e8 http server started on %s\\n\", e.colorer.Green(e.Listener.Addr()))\n\t}\n\treturn s.Serve(e.Listener)\n}\n\n// Close immediately stops the server.\n// It internally calls `http.Server#Close()`.\nfunc (e *Echo) Close() error {\n\tif err := e.TLSServer.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn e.Server.Close()\n}\n\n// Shutdown stops the server gracefully.\n// It internally calls `http.Server#Shutdown()`.\nfunc (e *Echo) Shutdown(ctx stdContext.Context) error {\n\tif err := e.TLSServer.Shutdown(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn e.Server.Shutdown(ctx)\n}\n\n// NewHTTPError creates a new HTTPError instance.\nfunc NewHTTPError(code int, message ...interface{}) *HTTPError {\n\the := &HTTPError{Code: code, Message: http.StatusText(code)}\n\tif len(message) > 0 {\n\t\the.Message = message[0]\n\t}\n\treturn he\n}\n\n// Error makes it compatible with `error` interface.\nfunc (he *HTTPError) Error() string {\n\tif he.Internal == nil {\n\t\treturn fmt.Sprintf(\"code=%d, message=%v\", he.Code, he.Message)\n\t}\n\treturn fmt.Sprintf(\"code=%d, message=%v, internal=%v\", he.Code, he.Message, he.Internal)\n}\n\n// SetInternal sets error to HTTPError.Internal\nfunc (he *HTTPError) SetInternal(err error) *HTTPError {\n\the.Internal = err\n\treturn he\n}\n\n// Unwrap satisfies the Go 1.13 error wrapper interface.\nfunc (he *HTTPError) Unwrap() error {\n\treturn he.Internal\n}\n\n// WrapHandler wraps `http.Handler` into `echo.HandlerFunc`.\nfunc WrapHandler(h http.Handler) HandlerFunc {\n\treturn func(c Context) error {\n\t\th.ServeHTTP(c.Response(), c.Request())\n\t\treturn nil\n\t}\n}\n\n// WrapMiddleware wraps `func(http.Handler) http.Handler` into `echo.MiddlewareFunc`\nfunc WrapMiddleware(m func(http.Handler) http.Handler) MiddlewareFunc {\n\treturn func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) (err error) {\n\t\t\tm(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tc.SetRequest(r)\n\t\t\t\tc.SetResponse(NewResponse(w, c.Echo()))\n\t\t\t\terr = next(c)\n\t\t\t})).ServeHTTP(c.Response(), c.Request())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (e *Echo) findRouter(host string) *Router {\n\tif len(e.routers) > 0 {\n\t\tif r, ok := e.routers[host]; ok {\n\t\t\treturn r\n\t\t}\n\t}\n\treturn e.router\n}\n\nfunc handlerName(h HandlerFunc) string {\n\tt := reflect.ValueOf(h).Type()\n\tif t.Kind() == reflect.Func {\n\t\treturn runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name()\n\t}\n\treturn t.String()\n}\n\n// // PathUnescape is wraps `url.PathUnescape`\n// func PathUnescape(s string) (string, error) {\n// \treturn url.PathUnescape(s)\n// }\n\n// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted\n// connections. It's used by ListenAndServe and ListenAndServeTLS so\n// dead TCP connections (e.g. closing laptop mid-download) eventually\n// go away.\ntype tcpKeepAliveListener struct {\n\t*net.TCPListener\n}\n\nfunc (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {\n\tif c, err = ln.AcceptTCP(); err != nil {\n\t\treturn\n\t} else if err = c.(*net.TCPConn).SetKeepAlive(true); err != nil {\n\t\treturn\n\t}\n\t// Ignore error from setting the KeepAlivePeriod as some systems, such as\n\t// OpenBSD, do not support setting TCP_USER_TIMEOUT on IPPROTO_TCP\n\t_ = c.(*net.TCPConn).SetKeepAlivePeriod(3 * time.Minute)\n\treturn\n}\n\nfunc newListener(address, network string) (*tcpKeepAliveListener, error) {\n\tif network != \"tcp\" && network != \"tcp4\" && network != \"tcp6\" {\n\t\treturn nil, ErrInvalidListenerNetwork\n\t}\n\tl, err := net.Listen(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tcpKeepAliveListener{l.(*net.TCPListener)}, nil\n}\n\nfunc applyMiddleware(h HandlerFunc, middleware ...MiddlewareFunc) HandlerFunc {\n\tfor i := len(middleware) - 1; i >= 0; i-- {\n\t\th = middleware[i](h)\n\t}\n\treturn h\n}\n", "package echo\n\nimport (\n\t\"bytes\"\n\tstdContext \"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/http2\"\n)\n\ntype (\n\tuser struct {\n\t\tID   int    `json:\"id\" xml:\"id\" form:\"id\" query:\"id\" param:\"id\"`\n\t\tName string `json:\"name\" xml:\"name\" form:\"name\" query:\"name\" param:\"name\"`\n\t}\n)\n\nconst (\n\tuserJSON                    = `{\"id\":1,\"name\":\"Jon Snow\"}`\n\tuserXML                     = `<user><id>1</id><name>Jon Snow</name></user>`\n\tuserForm                    = `id=1&name=Jon Snow`\n\tinvalidContent              = \"invalid content\"\n\tuserJSONInvalidType         = `{\"id\":\"1\",\"name\":\"Jon Snow\"}`\n\tuserXMLConvertNumberError   = `<user><id>Number one</id><name>Jon Snow</name></user>`\n\tuserXMLUnsupportedTypeError = `<user><>Number one</><name>Jon Snow</name></user>`\n)\n\nconst userJSONPretty = `{\n  \"id\": 1,\n  \"name\": \"Jon Snow\"\n}`\n\nconst userXMLPretty = `<user>\n  <id>1</id>\n  <name>Jon Snow</name>\n</user>`\n\nfunc TestEcho(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\n\t// Router\n\tassert.NotNil(t, e.Router())\n\n\t// DefaultHTTPErrorHandler\n\te.DefaultHTTPErrorHandler(errors.New(\"error\"), c)\n\tassert.Equal(t, http.StatusInternalServerError, rec.Code)\n}\n\nfunc TestEchoStatic(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname                 string\n\t\tgivenPrefix          string\n\t\tgivenRoot            string\n\t\twhenURL              string\n\t\texpectStatus         int\n\t\texpectHeaderLocation string\n\t\texpectBodyStartsWith string\n\t}{\n\t\t{\n\t\t\tname:                 \"ok\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenRoot:            \"_fixture/images\",\n\t\t\twhenURL:              \"/images/walle.png\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: string([]byte{0x89, 0x50, 0x4e, 0x47}),\n\t\t},\n\t\t{\n\t\t\tname:                 \"No file\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenRoot:            \"_fixture/scripts\",\n\t\t\twhenURL:              \"/images/bolt.png\",\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenRoot:            \"_fixture/images\",\n\t\t\twhenURL:              \"/images/\",\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory Redirect\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/folder\",\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/folder/\",\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory with index.html\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Sub-directory with index.html\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/folder/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"do not allow directory traversal (backslash - windows separator)\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture/\",\n\t\t\twhenURL:              `/..\\\\middleware/basic_auth.go`,\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"do not allow directory traversal (slash - unix separator)\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture/\",\n\t\t\twhenURL:              `/../middleware/basic_auth.go`,\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.Static(tc.givenPrefix, tc.givenRoot)\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\te.ServeHTTP(rec, req)\n\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\tbody := rec.Body.String()\n\t\t\tif tc.expectBodyStartsWith != \"\" {\n\t\t\t\tassert.True(t, strings.HasPrefix(body, tc.expectBodyStartsWith))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, \"\", body)\n\t\t\t}\n\n\t\t\tif tc.expectHeaderLocation != \"\" {\n\t\t\t\tassert.Equal(t, tc.expectHeaderLocation, rec.Result().Header[\"Location\"][0])\n\t\t\t} else {\n\t\t\t\t_, ok := rec.Result().Header[\"Location\"]\n\t\t\t\tassert.False(t, ok)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEchoFile(t *testing.T) {\n\te := New()\n\te.File(\"/walle\", \"_fixture/images/walle.png\")\n\tc, b := request(http.MethodGet, \"/walle\", e)\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.NotEmpty(t, b)\n}\n\nfunc TestEchoMiddleware(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\n\te.Pre(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tassert.Empty(t, c.Path())\n\t\t\tbuf.WriteString(\"-1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"2\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"3\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\t// Route\n\te.GET(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tc, b := request(http.MethodGet, \"/\", e)\n\tassert.Equal(t, \"-1123\", buf.String())\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.Equal(t, \"OK\", b)\n}\n\nfunc TestEchoMiddlewareError(t *testing.T) {\n\te := New()\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn errors.New(\"error\")\n\t\t}\n\t})\n\te.GET(\"/\", NotFoundHandler)\n\tc, _ := request(http.MethodGet, \"/\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n}\n\nfunc TestEchoHandler(t *testing.T) {\n\te := New()\n\n\t// HandlerFunc\n\te.GET(\"/ok\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tc, b := request(http.MethodGet, \"/ok\", e)\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.Equal(t, \"OK\", b)\n}\n\nfunc TestEchoWrapHandler(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\th := WrapHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"test\"))\n\t}))\n\tif assert.NoError(t, h(c)) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"test\", rec.Body.String())\n\t}\n}\n\nfunc TestEchoWrapMiddleware(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tbuf := new(bytes.Buffer)\n\tmw := WrapMiddleware(func(h http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tbuf.Write([]byte(\"mw\"))\n\t\t\th.ServeHTTP(w, r)\n\t\t})\n\t})\n\th := mw(func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\tif assert.NoError(t, h(c)) {\n\t\tassert.Equal(t, \"mw\", buf.String())\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"OK\", rec.Body.String())\n\t}\n}\n\nfunc TestEchoConnect(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodConnect, \"/\", e)\n}\n\nfunc TestEchoDelete(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodDelete, \"/\", e)\n}\n\nfunc TestEchoGet(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodGet, \"/\", e)\n}\n\nfunc TestEchoHead(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodHead, \"/\", e)\n}\n\nfunc TestEchoOptions(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodOptions, \"/\", e)\n}\n\nfunc TestEchoPatch(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPatch, \"/\", e)\n}\n\nfunc TestEchoPost(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPost, \"/\", e)\n}\n\nfunc TestEchoPut(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPut, \"/\", e)\n}\n\nfunc TestEchoTrace(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodTrace, \"/\", e)\n}\n\nfunc TestEchoAny(t *testing.T) { // JFC\n\te := New()\n\te.Any(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Any\")\n\t})\n}\n\nfunc TestEchoMatch(t *testing.T) { // JFC\n\te := New()\n\te.Match([]string{http.MethodGet, http.MethodPost}, \"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Match\")\n\t})\n}\n\nfunc TestEchoURL(t *testing.T) {\n\te := New()\n\tstatic := func(Context) error { return nil }\n\tgetUser := func(Context) error { return nil }\n\tgetAny := func(Context) error { return nil }\n\tgetFile := func(Context) error { return nil }\n\n\te.GET(\"/static/file\", static)\n\te.GET(\"/users/:id\", getUser)\n\te.GET(\"/documents/*\", getAny)\n\tg := e.Group(\"/group\")\n\tg.GET(\"/users/:uid/files/:fid\", getFile)\n\n\tassert := assert.New(t)\n\n\tassert.Equal(\"/static/file\", e.URL(static))\n\tassert.Equal(\"/users/:id\", e.URL(getUser))\n\tassert.Equal(\"/users/1\", e.URL(getUser, \"1\"))\n\tassert.Equal(\"/users/1\", e.URL(getUser, \"1\"))\n\tassert.Equal(\"/documents/foo.txt\", e.URL(getAny, \"foo.txt\"))\n\tassert.Equal(\"/documents/*\", e.URL(getAny))\n\tassert.Equal(\"/group/users/1/files/:fid\", e.URL(getFile, \"1\"))\n\tassert.Equal(\"/group/users/1/files/1\", e.URL(getFile, \"1\", \"1\"))\n}\n\nfunc TestEchoRoutes(t *testing.T) {\n\te := New()\n\troutes := []*Route{\n\t\t{http.MethodGet, \"/users/:user/events\", \"\"},\n\t\t{http.MethodGet, \"/users/:user/events/public\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/refs\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/tags\", \"\"},\n\t}\n\tfor _, r := range routes {\n\t\te.Add(r.Method, r.Path, func(c Context) error {\n\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t})\n\t}\n\n\tif assert.Equal(t, len(routes), len(e.Routes())) {\n\t\tfor _, r := range e.Routes() {\n\t\t\tfound := false\n\t\t\tfor _, rr := range routes {\n\t\t\t\tif r.Method == rr.Method && r.Path == rr.Path {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tt.Errorf(\"Route %s %s not found\", r.Method, r.Path)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEchoEncodedPath(t *testing.T) {\n\te := New()\n\te.GET(\"/:id\", func(c Context) error {\n\t\treturn c.NoContent(http.StatusOK)\n\t})\n\treq := httptest.NewRequest(http.MethodGet, \"/with%2Fslash\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestEchoGroup(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\te.Use(MiddlewareFunc(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"0\")\n\t\t\treturn next(c)\n\t\t}\n\t}))\n\th := func(c Context) error {\n\t\treturn c.NoContent(http.StatusOK)\n\t}\n\n\t//--------\n\t// Routes\n\t//--------\n\n\te.GET(\"/users\", h)\n\n\t// Group\n\tg1 := e.Group(\"/group1\")\n\tg1.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg1.GET(\"\", h)\n\n\t// Nested groups with middleware\n\tg2 := e.Group(\"/group2\")\n\tg2.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"2\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg3 := g2.Group(\"/group3\")\n\tg3.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"3\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg3.GET(\"\", h)\n\n\trequest(http.MethodGet, \"/users\", e)\n\tassert.Equal(t, \"0\", buf.String())\n\n\tbuf.Reset()\n\trequest(http.MethodGet, \"/group1\", e)\n\tassert.Equal(t, \"01\", buf.String())\n\n\tbuf.Reset()\n\trequest(http.MethodGet, \"/group2/group3\", e)\n\tassert.Equal(t, \"023\", buf.String())\n}\n\nfunc TestEchoNotFound(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/files\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusNotFound, rec.Code)\n}\n\nfunc TestEchoMethodNotAllowed(t *testing.T) {\n\te := New()\n\te.GET(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Echo!\")\n\t})\n\treq := httptest.NewRequest(http.MethodPost, \"/\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusMethodNotAllowed, rec.Code)\n}\n\nfunc TestEchoContext(t *testing.T) {\n\te := New()\n\tc := e.AcquireContext()\n\tassert.IsType(t, new(context), c)\n\te.ReleaseContext(c)\n}\n\nfunc TestEchoStart(t *testing.T) {\n\te := New()\n\tgo func() {\n\t\tassert.NoError(t, e.Start(\":0\"))\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n}\n\nfunc TestEchoStartTLS(t *testing.T) {\n\te := New()\n\tgo func() {\n\t\terr := e.StartTLS(\":0\", \"_fixture/certs/cert.pem\", \"_fixture/certs/key.pem\")\n\t\t// Prevent the test to fail after closing the servers\n\t\tif err != http.ErrServerClosed {\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n\n\te.Close()\n}\n\nfunc TestEchoStartTLSByteString(t *testing.T) {\n\tcert, err := ioutil.ReadFile(\"_fixture/certs/cert.pem\")\n\trequire.NoError(t, err)\n\tkey, err := ioutil.ReadFile(\"_fixture/certs/key.pem\")\n\trequire.NoError(t, err)\n\n\ttestCases := []struct {\n\t\tcert        interface{}\n\t\tkey         interface{}\n\t\texpectedErr error\n\t\tname        string\n\t}{\n\t\t{\n\t\t\tcert:        \"_fixture/certs/cert.pem\",\n\t\t\tkey:         \"_fixture/certs/key.pem\",\n\t\t\texpectedErr: nil,\n\t\t\tname:        `ValidCertAndKeyFilePath`,\n\t\t},\n\t\t{\n\t\t\tcert:        cert,\n\t\t\tkey:         key,\n\t\t\texpectedErr: nil,\n\t\t\tname:        `ValidCertAndKeyByteString`,\n\t\t},\n\t\t{\n\t\t\tcert:        cert,\n\t\t\tkey:         1,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidKeyType`,\n\t\t},\n\t\t{\n\t\t\tcert:        0,\n\t\t\tkey:         key,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidCertType`,\n\t\t},\n\t\t{\n\t\t\tcert:        0,\n\t\t\tkey:         1,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidCertAndKeyTypes`,\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.HideBanner = true\n\n\t\t\tgo func() {\n\t\t\t\terr := e.StartTLS(\":0\", test.cert, test.key)\n\t\t\t\tif test.expectedErr != nil {\n\t\t\t\t\trequire.EqualError(t, err, test.expectedErr.Error())\n\t\t\t\t} else if err != http.ErrServerClosed { // Prevent the test to fail after closing the servers\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t\trequire.NoError(t, e.Close())\n\t\t})\n\t}\n}\n\nfunc TestEchoStartAutoTLS(t *testing.T) {\n\te := New()\n\terrChan := make(chan error, 0)\n\n\tgo func() {\n\t\terrChan <- e.StartAutoTLS(\":0\")\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n\n\tselect {\n\tcase err := <-errChan:\n\t\tassert.NoError(t, err)\n\tdefault:\n\t\tassert.NoError(t, e.Close())\n\t}\n}\n\nfunc TestEchoStartH2CServer(t *testing.T) {\n\te := New()\n\te.Debug = true\n\th2s := &http2.Server{}\n\n\tgo func() {\n\t\tassert.NoError(t, e.StartH2CServer(\":0\", h2s))\n\t}()\n\ttime.Sleep(200 * time.Millisecond)\n}\n\nfunc testMethod(t *testing.T, method, path string, e *Echo) {\n\tp := reflect.ValueOf(path)\n\th := reflect.ValueOf(func(c Context) error {\n\t\treturn c.String(http.StatusOK, method)\n\t})\n\ti := interface{}(e)\n\treflect.ValueOf(i).MethodByName(method).Call([]reflect.Value{p, h})\n\t_, body := request(method, path, e)\n\tassert.Equal(t, method, body)\n}\n\nfunc request(method, path string, e *Echo) (int, string) {\n\treq := httptest.NewRequest(method, path, nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\treturn rec.Code, rec.Body.String()\n}\n\nfunc TestHTTPError(t *testing.T) {\n\tt.Run(\"non-internal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\n\t\tassert.Equal(t, \"code=400, message=map[code:12]\", err.Error())\n\t})\n\tt.Run(\"internal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\t\terr.SetInternal(errors.New(\"internal error\"))\n\t\tassert.Equal(t, \"code=400, message=map[code:12], internal=internal error\", err.Error())\n\t})\n}\n\nfunc TestDefaultHTTPErrorHandler(t *testing.T) {\n\te := New()\n\te.Debug = true\n\te.Any(\"/plain\", func(c Context) error {\n\t\treturn errors.New(\"An error occurred\")\n\t})\n\te.Any(\"/badrequest\", func(c Context) error {\n\t\treturn NewHTTPError(http.StatusBadRequest, \"Invalid request\")\n\t})\n\te.Any(\"/servererror\", func(c Context) error {\n\t\treturn NewHTTPError(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"code\":    33,\n\t\t\t\"message\": \"Something bad happened\",\n\t\t\t\"error\":   \"stackinfo\",\n\t\t})\n\t})\n\t// With Debug=true plain response contains error message\n\tc, b := request(http.MethodGet, \"/plain\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\n  \\\"error\\\": \\\"An error occurred\\\",\\n  \\\"message\\\": \\\"Internal Server Error\\\"\\n}\\n\", b)\n\t// and special handling for HTTPError\n\tc, b = request(http.MethodGet, \"/badrequest\", e)\n\tassert.Equal(t, http.StatusBadRequest, c)\n\tassert.Equal(t, \"{\\n  \\\"error\\\": \\\"code=400, message=Invalid request\\\",\\n  \\\"message\\\": \\\"Invalid request\\\"\\n}\\n\", b)\n\t// complex errors are serialized to pretty JSON\n\tc, b = request(http.MethodGet, \"/servererror\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\n  \\\"code\\\": 33,\\n  \\\"error\\\": \\\"stackinfo\\\",\\n  \\\"message\\\": \\\"Something bad happened\\\"\\n}\\n\", b)\n\n\te.Debug = false\n\t// With Debug=false the error response is shortened\n\tc, b = request(http.MethodGet, \"/plain\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\\"message\\\":\\\"Internal Server Error\\\"}\\n\", b)\n\tc, b = request(http.MethodGet, \"/badrequest\", e)\n\tassert.Equal(t, http.StatusBadRequest, c)\n\tassert.Equal(t, \"{\\\"message\\\":\\\"Invalid request\\\"}\\n\", b)\n\t// No difference for error response with non plain string errors\n\tc, b = request(http.MethodGet, \"/servererror\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n\tassert.Equal(t, \"{\\\"code\\\":33,\\\"error\\\":\\\"stackinfo\\\",\\\"message\\\":\\\"Something bad happened\\\"}\\n\", b)\n}\n\nfunc TestEchoClose(t *testing.T) {\n\te := New()\n\terrCh := make(chan error)\n\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tif err := e.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.NoError(t, e.Close())\n\n\terr := <-errCh\n\tassert.Equal(t, err.Error(), \"http: Server closed\")\n}\n\nfunc TestEchoShutdown(t *testing.T) {\n\te := New()\n\terrCh := make(chan error)\n\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tif err := e.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx, cancel := stdContext.WithTimeout(stdContext.Background(), 10*time.Second)\n\tdefer cancel()\n\tassert.NoError(t, e.Shutdown(ctx))\n\n\terr := <-errCh\n\tassert.Equal(t, err.Error(), \"http: Server closed\")\n}\n\nvar listenerNetworkTests = []struct {\n\ttest    string\n\tnetwork string\n\taddress string\n}{\n\t{\"tcp ipv4 address\", \"tcp\", \"127.0.0.1:1323\"},\n\t{\"tcp ipv6 address\", \"tcp\", \"[::1]:1323\"},\n\t{\"tcp4 ipv4 address\", \"tcp4\", \"127.0.0.1:1323\"},\n\t{\"tcp6 ipv6 address\", \"tcp6\", \"[::1]:1323\"},\n}\n\nfunc TestEchoListenerNetwork(t *testing.T) {\n\tfor _, tt := range listenerNetworkTests {\n\t\tt.Run(tt.test, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.ListenerNetwork = tt.network\n\n\t\t\t// HandlerFunc\n\t\t\te.GET(\"/ok\", func(c Context) error {\n\t\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t\t})\n\n\t\t\terrCh := make(chan error)\n\n\t\t\tgo func() {\n\t\t\t\terrCh <- e.Start(tt.address)\n\t\t\t}()\n\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t\tif resp, err := http.Get(fmt.Sprintf(\"http://%s/ok\", tt.address)); err == nil {\n\t\t\t\tdefer resp.Body.Close()\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n\n\t\t\t\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\t\t\t\tassert.Equal(t, \"OK\", string(body))\n\t\t\t\t} else {\n\t\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t}\n\n\t\t\tif err := e.Close(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEchoListenerNetworkInvalid(t *testing.T) {\n\te := New()\n\te.ListenerNetwork = \"unix\"\n\n\t// HandlerFunc\n\te.GET(\"/ok\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tassert.Equal(t, ErrInvalidListenerNetwork, e.Start(\":1323\"))\n}\n\nfunc TestEchoReverse(t *testing.T) {\n\tassert := assert.New(t)\n\n\te := New()\n\tdummyHandler := func(Context) error { return nil }\n\n\te.GET(\"/static\", dummyHandler).Name = \"/static\"\n\te.GET(\"/static/*\", dummyHandler).Name = \"/static/*\"\n\te.GET(\"/params/:foo\", dummyHandler).Name = \"/params/:foo\"\n\te.GET(\"/params/:foo/bar/:qux\", dummyHandler).Name = \"/params/:foo/bar/:qux\"\n\te.GET(\"/params/:foo/bar/:qux/*\", dummyHandler).Name = \"/params/:foo/bar/:qux/*\"\n\n\tassert.Equal(\"/static\", e.Reverse(\"/static\"))\n\tassert.Equal(\"/static\", e.Reverse(\"/static\", \"missing param\"))\n\tassert.Equal(\"/static/*\", e.Reverse(\"/static/*\"))\n\tassert.Equal(\"/static/foo.txt\", e.Reverse(\"/static/*\", \"foo.txt\"))\n\n\tassert.Equal(\"/params/:foo\", e.Reverse(\"/params/:foo\"))\n\tassert.Equal(\"/params/one\", e.Reverse(\"/params/:foo\", \"one\"))\n\tassert.Equal(\"/params/:foo/bar/:qux\", e.Reverse(\"/params/:foo/bar/:qux\"))\n\tassert.Equal(\"/params/one/bar/:qux\", e.Reverse(\"/params/:foo/bar/:qux\", \"one\"))\n\tassert.Equal(\"/params/one/bar/two\", e.Reverse(\"/params/:foo/bar/:qux\", \"one\", \"two\"))\n\tassert.Equal(\"/params/one/bar/two/three\", e.Reverse(\"/params/:foo/bar/:qux/*\", \"one\", \"two\", \"three\"))\n}\n", "package middleware\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/gommon/bytes\"\n)\n\ntype (\n\t// StaticConfig defines the config for Static middleware.\n\tStaticConfig struct {\n\t\t// Skipper defines a function to skip middleware.\n\t\tSkipper Skipper\n\n\t\t// Root directory from where the static content is served.\n\t\t// Required.\n\t\tRoot string `yaml:\"root\"`\n\n\t\t// Index file for serving a directory.\n\t\t// Optional. Default value \"index.html\".\n\t\tIndex string `yaml:\"index\"`\n\n\t\t// Enable HTML5 mode by forwarding all not-found requests to root so that\n\t\t// SPA (single-page application) can handle the routing.\n\t\t// Optional. Default value false.\n\t\tHTML5 bool `yaml:\"html5\"`\n\n\t\t// Enable directory browsing.\n\t\t// Optional. Default value false.\n\t\tBrowse bool `yaml:\"browse\"`\n\n\t\t// Enable ignoring of the base of the URL path.\n\t\t// Example: when assigning a static middleware to a non root path group,\n\t\t// the filesystem path is not doubled\n\t\t// Optional. Default value false.\n\t\tIgnoreBase bool `yaml:\"ignoreBase\"`\n\t}\n)\n\nconst html = `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>{{ .Name }}</title>\n  <style>\n    body {\n\t\t\tfont-family: Menlo, Consolas, monospace;\n\t\t\tpadding: 48px;\n\t\t}\n\t\theader {\n\t\t\tpadding: 4px 16px;\n\t\t\tfont-size: 24px;\n\t\t}\n    ul {\n\t\t\tlist-style-type: none;\n\t\t\tmargin: 0;\n    \tpadding: 20px 0 0 0;\n\t\t\tdisplay: flex;\n\t\t\tflex-wrap: wrap;\n    }\n    li {\n\t\t\twidth: 300px;\n\t\t\tpadding: 16px;\n\t\t}\n\t\tli a {\n\t\t\tdisplay: block;\n\t\t\toverflow: hidden;\n\t\t\twhite-space: nowrap;\n\t\t\ttext-overflow: ellipsis;\n\t\t\ttext-decoration: none;\n\t\t\ttransition: opacity 0.25s;\n\t\t}\n\t\tli span {\n\t\t\tcolor: #707070;\n\t\t\tfont-size: 12px;\n\t\t}\n\t\tli a:hover {\n\t\t\topacity: 0.50;\n\t\t}\n\t\t.dir {\n\t\t\tcolor: #E91E63;\n\t\t}\n\t\t.file {\n\t\t\tcolor: #673AB7;\n\t\t}\n  </style>\n</head>\n<body>\n\t<header>\n\t\t{{ .Name }}\n\t</header>\n\t<ul>\n\t\t{{ range .Files }}\n\t\t<li>\n\t\t{{ if .Dir }}\n\t\t\t{{ $name := print .Name \"/\" }}\n\t\t\t<a class=\"dir\" href=\"{{ $name }}\">{{ $name }}</a>\n\t\t\t{{ else }}\n\t\t\t<a class=\"file\" href=\"{{ .Name }}\">{{ .Name }}</a>\n\t\t\t<span>{{ .Size }}</span>\n\t\t{{ end }}\n\t\t</li>\n\t\t{{ end }}\n  </ul>\n</body>\n</html>\n`\n\nvar (\n\t// DefaultStaticConfig is the default Static middleware config.\n\tDefaultStaticConfig = StaticConfig{\n\t\tSkipper: DefaultSkipper,\n\t\tIndex:   \"index.html\",\n\t}\n)\n\n// Static returns a Static middleware to serves static content from the provided\n// root directory.\nfunc Static(root string) echo.MiddlewareFunc {\n\tc := DefaultStaticConfig\n\tc.Root = root\n\treturn StaticWithConfig(c)\n}\n\n// StaticWithConfig returns a Static middleware with config.\n// See `Static()`.\nfunc StaticWithConfig(config StaticConfig) echo.MiddlewareFunc {\n\t// Defaults\n\tif config.Root == \"\" {\n\t\tconfig.Root = \".\" // For security we want to restrict to CWD.\n\t}\n\tif config.Skipper == nil {\n\t\tconfig.Skipper = DefaultStaticConfig.Skipper\n\t}\n\tif config.Index == \"\" {\n\t\tconfig.Index = DefaultStaticConfig.Index\n\t}\n\n\t// Index template\n\tt, err := template.New(\"index\").Parse(html)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"echo: %v\", err))\n\t}\n\n\treturn func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) (err error) {\n\t\t\tif config.Skipper(c) {\n\t\t\t\treturn next(c)\n\t\t\t}\n\n\t\t\tp := c.Request().URL.Path\n\t\t\tif strings.HasSuffix(c.Path(), \"*\") { // When serving from a group, e.g. `/static*`.\n\t\t\t\tp = c.Param(\"*\")\n\t\t\t}\n\t\t\tp, err = url.PathUnescape(p)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tname := filepath.Join(config.Root, filepath.Clean(\"/\"+p)) // \"/\"+ for security\n\n\t\t\tif config.IgnoreBase {\n\t\t\t\troutePath := path.Base(strings.TrimRight(c.Path(), \"/*\"))\n\t\t\t\tbaseURLPath := path.Base(p)\n\t\t\t\tif baseURLPath == routePath {\n\t\t\t\t\ti := strings.LastIndex(name, routePath)\n\t\t\t\t\tname = name[:i] + strings.Replace(name[i:], routePath, \"\", 1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfi, err := os.Stat(name)\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\tif err = next(c); err != nil {\n\t\t\t\t\t\tif he, ok := err.(*echo.HTTPError); ok {\n\t\t\t\t\t\t\tif config.HTML5 && he.Code == http.StatusNotFound {\n\t\t\t\t\t\t\t\treturn c.File(filepath.Join(config.Root, config.Index))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif fi.IsDir() {\n\t\t\t\tindex := filepath.Join(name, config.Index)\n\t\t\t\tfi, err = os.Stat(index)\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tif config.Browse {\n\t\t\t\t\t\treturn listDir(t, name, c.Response())\n\t\t\t\t\t}\n\t\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\t\treturn next(c)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\treturn c.File(index)\n\t\t\t}\n\n\t\t\treturn c.File(name)\n\t\t}\n\t}\n}\n\nfunc listDir(t *template.Template, name string, res *echo.Response) (err error) {\n\tfile, err := os.Open(name)\n\tif err != nil {\n\t\treturn\n\t}\n\tfiles, err := file.Readdir(-1)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Create directory index\n\tres.Header().Set(echo.HeaderContentType, echo.MIMETextHTMLCharsetUTF8)\n\tdata := struct {\n\t\tName  string\n\t\tFiles []interface{}\n\t}{\n\t\tName: name,\n\t}\n\tfor _, f := range files {\n\t\tdata.Files = append(data.Files, struct {\n\t\t\tName string\n\t\t\tDir  bool\n\t\t\tSize string\n\t\t}{f.Name(), f.IsDir(), bytes.Format(f.Size())})\n\t}\n\treturn t.Execute(res, data)\n}\n"], "filenames": ["echo.go", "echo_test.go", "middleware/static.go"], "buggy_code_start_loc": [52, 63, 170], "buggy_code_end_loc": [490, 102, 171], "fixing_code_start_loc": [51, 63, 170], "fixing_code_end_loc": [489, 162, 171], "type": "CWE-22", "message": "Due to improper sanitization of user input on Windows, the static file handler allows for directory traversal, allowing an attacker to read files outside of the target directory that the server has permission to read.", "other": {"cve": {"id": "CVE-2020-36565", "sourceIdentifier": "security@golang.org", "published": "2022-12-07T17:15:09.910", "lastModified": "2022-12-12T15:18:15.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Due to improper sanitization of user input on Windows, the static file handler allows for directory traversal, allowing an attacker to read files outside of the target directory that the server has permission to read."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:labstack:echo:*:*:*:*:*:go:*:*", "versionEndExcluding": "4.2.0", "matchCriteriaId": "FA1ABB43-0434-4FBD-B5C4-0417346F426C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/labstack/echo/commit/4422e3b66b9fd498ed1ae1d0242d660d0ed3faaa", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/labstack/echo/pull/1718", "source": "security@golang.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2021-0051", "source": "security@golang.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/labstack/echo/commit/4422e3b66b9fd498ed1ae1d0242d660d0ed3faaa"}}