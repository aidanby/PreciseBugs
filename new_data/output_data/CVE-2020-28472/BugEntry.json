{"buggy_code": ["import { join, sep } from \"path\";\n\nimport { ENV_CONFIG_PATH, ENV_CREDENTIALS_PATH, loadSharedConfigFiles } from \"./\";\n\njest.mock(\"fs\", () => {\n  interface FsModule {\n    __addMatcher(toMatch: string, toReturn: string): void;\n    __clearMatchers(): void;\n    readFile: (path: string, encoding: string, cb: (err: Error | null, data?: string) => void) => void;\n  }\n\n  const fs: FsModule = <FsModule>jest.genMockFromModule(\"fs\");\n  const matchers = new Map<string, string>();\n\n  function readFile(path: string, encoding: string, callback: (err: Error | null, data?: string) => void): void {\n    if (matchers.has(path)) {\n      callback(null, matchers.get(path));\n      return;\n    }\n\n    callback(new Error(\"ENOENT: no such file or directory\"));\n  }\n\n  fs.__addMatcher = function (toMatch: string, toReturn: string): void {\n    matchers.set(toMatch, toReturn);\n  };\n  fs.__clearMatchers = function (): void {\n    matchers.clear();\n  };\n  fs.readFile = readFile;\n\n  return fs;\n});\nimport fs from \"fs\";\nconst { __addMatcher, __clearMatchers } = fs as any;\n\njest.mock(\"os\", () => {\n  interface OsModule {\n    homedir: () => string;\n  }\n\n  const os: OsModule = <OsModule>jest.genMockFromModule(\"os\");\n  const path = require(\"path\");\n\n  os.homedir = () => path.sep + path.join(\"home\", \"user\");\n\n  return os;\n});\nimport { homedir } from \"os\";\n\nconst DEFAULT_CREDS = {\n  accessKeyId: \"AKIAIOSFODNN7EXAMPLE\",\n  secretAccessKey: \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n  sessionToken: \"sessionToken\",\n};\n\nconst FOO_CREDS = {\n  accessKeyId: \"foo\",\n  secretAccessKey: \"bar\",\n  sessionToken: \"baz\",\n};\n\nconst FIZZ_CREDS = {\n  accessKeyId: \"fizz\",\n  secretAccessKey: \"buzz\",\n  sessionToken: \"pop\",\n};\n\nconst envAtLoadTime: { [key: string]: string | undefined } = [\n  ENV_CONFIG_PATH,\n  ENV_CREDENTIALS_PATH,\n  \"HOME\",\n  \"USERPROFILE\",\n  \"HOMEPATH\",\n  \"HOMEDRIVE\",\n].reduce((envState: { [key: string]: string | undefined }, varName: string) => {\n  envState[varName] = process.env[varName];\n  return envState;\n}, {});\n\nbeforeEach(() => {\n  __clearMatchers();\n  Object.keys(envAtLoadTime).forEach((envKey) => {\n    delete process.env[envKey];\n  });\n});\n\nafterAll(() => {\n  __clearMatchers();\n  Object.keys(envAtLoadTime).forEach((envKey) => {\n    process.env[envKey] = envAtLoadTime[envKey];\n  });\n});\n\ndescribe(\"loadSharedConfigFiles\", () => {\n  it(\"should return empty objects if no files are found\", async () => {\n    const profiles = await loadSharedConfigFiles();\n    expect(profiles.configFile).toEqual({});\n    expect(profiles.credentialsFile).toEqual({});\n  });\n\n  describe(\"shared credentials file\", () => {\n    const SIMPLE_CREDS_FILE = `[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}\n\n[foo]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`;\n\n    const parsed = {\n      default: {\n        aws_access_key_id: DEFAULT_CREDS.accessKeyId,\n        aws_secret_access_key: DEFAULT_CREDS.secretAccessKey,\n        aws_session_token: DEFAULT_CREDS.sessionToken,\n      },\n      foo: {\n        aws_access_key_id: FOO_CREDS.accessKeyId,\n        aws_secret_access_key: FOO_CREDS.secretAccessKey,\n        aws_session_token: FOO_CREDS.sessionToken,\n      },\n    };\n\n    const DEFAULT_PATH = join(homedir(), \".aws\", \"credentials\");\n\n    it(\"should read credentials from ~/.aws/credentials\", async () => {\n      __addMatcher(DEFAULT_PATH, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should read from a filepath if provided\", async () => {\n      const customPath = join(homedir(), \".aws\", \"foo\");\n      __addMatcher(customPath, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles({ filepath: customPath })).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(`should read from a filepath specified in ${ENV_CREDENTIALS_PATH}`, async () => {\n      process.env[ENV_CREDENTIALS_PATH] = join(\"foo\", \"bar\", \"baz\");\n      __addMatcher(process.env[ENV_CREDENTIALS_PATH], SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should prefer a provided filepath over one specified via environment variables\", async () => {\n      process.env[ENV_CREDENTIALS_PATH] = join(\"foo\", \"bar\", \"baz\");\n      const customPath = join(\"fizz\", \"buzz\", \"pop\");\n      __addMatcher(customPath, SIMPLE_CREDS_FILE);\n\n      __addMatcher(process.env[ENV_CREDENTIALS_PATH], \"\");\n\n      expect(await loadSharedConfigFiles({ filepath: customPath })).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should use $HOME when available\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      __addMatcher(`${sep}foo${sep}bar${sep}.aws${sep}credentials`, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should use $USERPROFILE when available\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      __addMatcher(`C:\\\\Users\\\\user${sep}.aws${sep}credentials`, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should use $HOMEPATH/$HOMEDRIVE when available\", async () => {\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user\";\n      __addMatcher(`D:\\\\Users\\\\user${sep}.aws${sep}credentials`, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should prefer $HOME to $USERPROFILE\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {\n          default: parsed.default,\n        },\n      });\n    });\n\n    it(\"should prefer $USERPROFILE to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {\n          default: parsed.default,\n        },\n      });\n    });\n\n    it(\"should prefer $HOME to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {\n          default: parsed.default,\n        },\n      });\n    });\n  });\n\n  describe(\"shared config file\", () => {\n    const SIMPLE_CONFIG_FILE = `[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}\n\n[profile foo]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}\n\n[profile \"fizz buzz\"]\naws_access_key_id = ${FIZZ_CREDS.accessKeyId}\naws_secret_access_key = ${FIZZ_CREDS.secretAccessKey}\naws_session_token = ${FIZZ_CREDS.sessionToken}`;\n\n    const parsed = {\n      default: {\n        aws_access_key_id: DEFAULT_CREDS.accessKeyId,\n        aws_secret_access_key: DEFAULT_CREDS.secretAccessKey,\n        aws_session_token: DEFAULT_CREDS.sessionToken,\n      },\n      foo: {\n        aws_access_key_id: FOO_CREDS.accessKeyId,\n        aws_secret_access_key: FOO_CREDS.secretAccessKey,\n        aws_session_token: FOO_CREDS.sessionToken,\n      },\n      \"fizz buzz\": {\n        aws_access_key_id: FIZZ_CREDS.accessKeyId,\n        aws_secret_access_key: FIZZ_CREDS.secretAccessKey,\n        aws_session_token: FIZZ_CREDS.sessionToken,\n      },\n    };\n\n    const DEFAULT_PATH = join(homedir(), \".aws\", \"config\");\n\n    it(\"should read credentials from ~/.aws/config\", async () => {\n      __addMatcher(DEFAULT_PATH, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should ignore non-profile sections of the file\", async () => {\n      __addMatcher(\n        DEFAULT_PATH,\n        `[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}\n\n[profile foo]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}\n\n[foo]\naws_access_key_id = ${FIZZ_CREDS.accessKeyId}\naws_secret_access_key = ${FIZZ_CREDS.secretAccessKey}\naws_session_token = ${FIZZ_CREDS.sessionToken}\n\n[fizz]\nkey = value`\n      );\n\n      const { configFile } = await loadSharedConfigFiles();\n      expect(configFile.default).toEqual(parsed.default);\n      expect(configFile.foo).toEqual(parsed.foo);\n      expect(configFile.fizz).toBeUndefined();\n    });\n\n    it(\"should read from a filepath if provided\", async () => {\n      const customPath = join(homedir(), \".aws\", \"foo\");\n      __addMatcher(customPath, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles({ configFilepath: customPath })).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(`should read from a filepath specified in ${ENV_CREDENTIALS_PATH}`, async () => {\n      process.env[ENV_CONFIG_PATH] = join(\"foo\", \"bar\", \"baz\");\n      __addMatcher(process.env[ENV_CONFIG_PATH], SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should prefer a provided filepath over one specified via environment variables\", async () => {\n      process.env[ENV_CONFIG_PATH] = join(\"foo\", \"bar\", \"baz\");\n      const customPath = join(\"fizz\", \"buzz\", \"pop\");\n      __addMatcher(\n        customPath,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        process.env[ENV_CONFIG_PATH],\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles({ configFilepath: customPath })).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n\n    it(\"should use $HOME when available\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      __addMatcher(`${sep}foo${sep}bar${sep}.aws${sep}config`, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should use $USERPROFILE when available\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      __addMatcher(`C:\\\\Users\\\\user${sep}.aws${sep}config`, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should use $HOMEPATH/$HOMEDRIVE when available\", async () => {\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user\";\n      __addMatcher(`D:\\\\Users\\\\user${sep}.aws${sep}config`, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should prefer $HOME to $USERPROFILE\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n\n    it(\"should prefer $USERPROFILE to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n\n    it(\"should prefer $HOME to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n  });\n});\n", "import { readFile } from \"fs\";\nimport { homedir } from \"os\";\nimport { join, sep } from \"path\";\n\nexport const ENV_CREDENTIALS_PATH = \"AWS_SHARED_CREDENTIALS_FILE\";\nexport const ENV_CONFIG_PATH = \"AWS_CONFIG_FILE\";\n\nexport interface SharedConfigInit {\n  /**\n   * The path at which to locate the ini credentials file. Defaults to the\n   * value of the `AWS_SHARED_CREDENTIALS_FILE` environment variable (if\n   * defined) or `~/.aws/credentials` otherwise.\n   */\n  filepath?: string;\n\n  /**\n   * The path at which to locate the ini config file. Defaults to the value of\n   * the `AWS_CONFIG_FILE` environment variable (if defined) or\n   * `~/.aws/config` otherwise.\n   */\n  configFilepath?: string;\n}\n\nexport interface Profile {\n  [key: string]: string | undefined;\n}\n\nexport interface ParsedIniData {\n  [key: string]: Profile;\n}\n\nexport interface SharedConfigFiles {\n  credentialsFile: ParsedIniData;\n  configFile: ParsedIniData;\n}\n\nconst swallowError = () => ({});\n\nexport function loadSharedConfigFiles(init: SharedConfigInit = {}): Promise<SharedConfigFiles> {\n  const {\n    filepath = process.env[ENV_CREDENTIALS_PATH] || join(getHomeDir(), \".aws\", \"credentials\"),\n    configFilepath = process.env[ENV_CONFIG_PATH] || join(getHomeDir(), \".aws\", \"config\"),\n  } = init;\n\n  return Promise.all([\n    slurpFile(configFilepath).then(parseIni).then(normalizeConfigFile).catch(swallowError),\n    slurpFile(filepath).then(parseIni).catch(swallowError),\n  ]).then((parsedFiles: Array<ParsedIniData>) => {\n    const [configFile, credentialsFile] = parsedFiles;\n    return {\n      configFile,\n      credentialsFile,\n    };\n  });\n}\n\nconst profileKeyRegex = /^profile\\s([\"'])?([^\\1]+)\\1$/;\nfunction normalizeConfigFile(data: ParsedIniData): ParsedIniData {\n  const map: ParsedIniData = {};\n  for (const key of Object.keys(data)) {\n    let matches: Array<string> | null;\n    if (key === \"default\") {\n      map.default = data.default;\n    } else if ((matches = profileKeyRegex.exec(key))) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const [_1, _2, normalizedKey] = matches;\n      if (normalizedKey) {\n        map[normalizedKey] = data[key];\n      }\n    }\n  }\n\n  return map;\n}\n\nfunction parseIni(iniData: string): ParsedIniData {\n  const map: ParsedIniData = {};\n  let currentSection: string | undefined;\n  for (let line of iniData.split(/\\r?\\n/)) {\n    line = line.split(/(^|\\s)[;#]/)[0]; // remove comments\n    const section = line.match(/^\\s*\\[([^\\[\\]]+)]\\s*$/);\n    if (section) {\n      currentSection = section[1];\n    } else if (currentSection) {\n      const item = line.match(/^\\s*(.+?)\\s*=\\s*(.+?)\\s*$/);\n      if (item) {\n        map[currentSection] = map[currentSection] || {};\n        map[currentSection][item[1]] = item[2];\n      }\n    }\n  }\n\n  return map;\n}\n\nfunction slurpFile(path: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    readFile(path, \"utf8\", (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nfunction getHomeDir(): string {\n  const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${sep}` } = process.env;\n\n  if (HOME) return HOME;\n  if (USERPROFILE) return USERPROFILE;\n  if (HOMEPATH) return `${HOMEDRIVE}${HOMEPATH}`;\n\n  return homedir();\n}\n"], "fixing_code": ["import { join, sep } from \"path\";\n\nimport { ENV_CONFIG_PATH, ENV_CREDENTIALS_PATH, loadSharedConfigFiles } from \"./\";\n\njest.mock(\"fs\", () => {\n  interface FsModule {\n    __addMatcher(toMatch: string, toReturn: string): void;\n    __clearMatchers(): void;\n    readFile: (path: string, encoding: string, cb: (err: Error | null, data?: string) => void) => void;\n  }\n\n  const fs: FsModule = <FsModule>jest.genMockFromModule(\"fs\");\n  const matchers = new Map<string, string>();\n\n  function readFile(path: string, encoding: string, callback: (err: Error | null, data?: string) => void): void {\n    if (matchers.has(path)) {\n      callback(null, matchers.get(path));\n      return;\n    }\n\n    callback(new Error(\"ENOENT: no such file or directory\"));\n  }\n\n  fs.__addMatcher = function (toMatch: string, toReturn: string): void {\n    matchers.set(toMatch, toReturn);\n  };\n  fs.__clearMatchers = function (): void {\n    matchers.clear();\n  };\n  fs.readFile = readFile;\n\n  return fs;\n});\nimport fs from \"fs\";\nconst { __addMatcher, __clearMatchers } = fs as any;\n\njest.mock(\"os\", () => {\n  interface OsModule {\n    homedir: () => string;\n  }\n\n  const os: OsModule = <OsModule>jest.genMockFromModule(\"os\");\n  const path = require(\"path\");\n\n  os.homedir = () => path.sep + path.join(\"home\", \"user\");\n\n  return os;\n});\nimport { homedir } from \"os\";\n\nconst DEFAULT_CREDS = {\n  accessKeyId: \"AKIAIOSFODNN7EXAMPLE\",\n  secretAccessKey: \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n  sessionToken: \"sessionToken\",\n};\n\nconst FOO_CREDS = {\n  accessKeyId: \"foo\",\n  secretAccessKey: \"bar\",\n  sessionToken: \"baz\",\n};\n\nconst FIZZ_CREDS = {\n  accessKeyId: \"fizz\",\n  secretAccessKey: \"buzz\",\n  sessionToken: \"pop\",\n};\n\nconst envAtLoadTime: { [key: string]: string | undefined } = [\n  ENV_CONFIG_PATH,\n  ENV_CREDENTIALS_PATH,\n  \"HOME\",\n  \"USERPROFILE\",\n  \"HOMEPATH\",\n  \"HOMEDRIVE\",\n].reduce((envState: { [key: string]: string | undefined }, varName: string) => {\n  envState[varName] = process.env[varName];\n  return envState;\n}, {});\n\nbeforeEach(() => {\n  __clearMatchers();\n  Object.keys(envAtLoadTime).forEach((envKey) => {\n    delete process.env[envKey];\n  });\n});\n\nafterAll(() => {\n  __clearMatchers();\n  Object.keys(envAtLoadTime).forEach((envKey) => {\n    process.env[envKey] = envAtLoadTime[envKey];\n  });\n});\n\ndescribe(\"loadSharedConfigFiles\", () => {\n  it(\"should return empty objects if no files are found\", async () => {\n    const profiles = await loadSharedConfigFiles();\n    expect(profiles.configFile).toEqual({});\n    expect(profiles.credentialsFile).toEqual({});\n  });\n\n  describe(\"shared credentials file\", () => {\n    const SIMPLE_CREDS_FILE = `[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}\n\n[foo]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`;\n\n    const parsed = {\n      default: {\n        aws_access_key_id: DEFAULT_CREDS.accessKeyId,\n        aws_secret_access_key: DEFAULT_CREDS.secretAccessKey,\n        aws_session_token: DEFAULT_CREDS.sessionToken,\n      },\n      foo: {\n        aws_access_key_id: FOO_CREDS.accessKeyId,\n        aws_secret_access_key: FOO_CREDS.secretAccessKey,\n        aws_session_token: FOO_CREDS.sessionToken,\n      },\n    };\n\n    const DEFAULT_PATH = join(homedir(), \".aws\", \"credentials\");\n\n    it(\"should read credentials from ~/.aws/credentials\", async () => {\n      __addMatcher(DEFAULT_PATH, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should read from a filepath if provided\", async () => {\n      const customPath = join(homedir(), \".aws\", \"foo\");\n      __addMatcher(customPath, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles({ filepath: customPath })).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(`should read from a filepath specified in ${ENV_CREDENTIALS_PATH}`, async () => {\n      process.env[ENV_CREDENTIALS_PATH] = join(\"foo\", \"bar\", \"baz\");\n      __addMatcher(process.env[ENV_CREDENTIALS_PATH], SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should prefer a provided filepath over one specified via environment variables\", async () => {\n      process.env[ENV_CREDENTIALS_PATH] = join(\"foo\", \"bar\", \"baz\");\n      const customPath = join(\"fizz\", \"buzz\", \"pop\");\n      __addMatcher(customPath, SIMPLE_CREDS_FILE);\n\n      __addMatcher(process.env[ENV_CREDENTIALS_PATH], \"\");\n\n      expect(await loadSharedConfigFiles({ filepath: customPath })).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should use $HOME when available\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      __addMatcher(`${sep}foo${sep}bar${sep}.aws${sep}credentials`, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should use $USERPROFILE when available\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      __addMatcher(`C:\\\\Users\\\\user${sep}.aws${sep}credentials`, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should use $HOMEPATH/$HOMEDRIVE when available\", async () => {\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user\";\n      __addMatcher(`D:\\\\Users\\\\user${sep}.aws${sep}credentials`, SIMPLE_CREDS_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: parsed,\n      });\n    });\n\n    it(\"should prefer $HOME to $USERPROFILE\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {\n          default: parsed.default,\n        },\n      });\n    });\n\n    it(\"should prefer $USERPROFILE to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {\n          default: parsed.default,\n        },\n      });\n    });\n\n    it(\"should prefer $HOME to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}credentials`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {\n          default: parsed.default,\n        },\n      });\n    });\n\n    it(\"should ignore profile name in block list\", async () => {\n      __addMatcher(\n        DEFAULT_PATH,\n        `\n[__proto__]\nfoo = not_exist`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {},\n      });\n    });\n  });\n\n  describe(\"shared config file\", () => {\n    const SIMPLE_CONFIG_FILE = `[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}\n\n[profile foo]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}\n\n[profile \"fizz buzz\"]\naws_access_key_id = ${FIZZ_CREDS.accessKeyId}\naws_secret_access_key = ${FIZZ_CREDS.secretAccessKey}\naws_session_token = ${FIZZ_CREDS.sessionToken}`;\n\n    const parsed = {\n      default: {\n        aws_access_key_id: DEFAULT_CREDS.accessKeyId,\n        aws_secret_access_key: DEFAULT_CREDS.secretAccessKey,\n        aws_session_token: DEFAULT_CREDS.sessionToken,\n      },\n      foo: {\n        aws_access_key_id: FOO_CREDS.accessKeyId,\n        aws_secret_access_key: FOO_CREDS.secretAccessKey,\n        aws_session_token: FOO_CREDS.sessionToken,\n      },\n      \"fizz buzz\": {\n        aws_access_key_id: FIZZ_CREDS.accessKeyId,\n        aws_secret_access_key: FIZZ_CREDS.secretAccessKey,\n        aws_session_token: FIZZ_CREDS.sessionToken,\n      },\n    };\n\n    const DEFAULT_PATH = join(homedir(), \".aws\", \"config\");\n\n    it(\"should read credentials from ~/.aws/config\", async () => {\n      __addMatcher(DEFAULT_PATH, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should ignore non-profile sections of the file\", async () => {\n      __addMatcher(\n        DEFAULT_PATH,\n        `[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}\n\n[profile foo]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}\n\n[foo]\naws_access_key_id = ${FIZZ_CREDS.accessKeyId}\naws_secret_access_key = ${FIZZ_CREDS.secretAccessKey}\naws_session_token = ${FIZZ_CREDS.sessionToken}\n\n[fizz]\nkey = value`\n      );\n\n      const { configFile } = await loadSharedConfigFiles();\n      expect(configFile.default).toEqual(parsed.default);\n      expect(configFile.foo).toEqual(parsed.foo);\n      expect(configFile.fizz).toBeUndefined();\n    });\n\n    it(\"should read from a filepath if provided\", async () => {\n      const customPath = join(homedir(), \".aws\", \"foo\");\n      __addMatcher(customPath, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles({ configFilepath: customPath })).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(`should read from a filepath specified in ${ENV_CREDENTIALS_PATH}`, async () => {\n      process.env[ENV_CONFIG_PATH] = join(\"foo\", \"bar\", \"baz\");\n      __addMatcher(process.env[ENV_CONFIG_PATH], SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should prefer a provided filepath over one specified via environment variables\", async () => {\n      process.env[ENV_CONFIG_PATH] = join(\"foo\", \"bar\", \"baz\");\n      const customPath = join(\"fizz\", \"buzz\", \"pop\");\n      __addMatcher(\n        customPath,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        process.env[ENV_CONFIG_PATH],\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles({ configFilepath: customPath })).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n\n    it(\"should use $HOME when available\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      __addMatcher(`${sep}foo${sep}bar${sep}.aws${sep}config`, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should use $USERPROFILE when available\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      __addMatcher(`C:\\\\Users\\\\user${sep}.aws${sep}config`, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should use $HOMEPATH/$HOMEDRIVE when available\", async () => {\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user\";\n      __addMatcher(`D:\\\\Users\\\\user${sep}.aws${sep}config`, SIMPLE_CONFIG_FILE);\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: parsed,\n      });\n    });\n\n    it(\"should prefer $HOME to $USERPROFILE\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n\n    it(\"should prefer $USERPROFILE to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.USERPROFILE = \"C:\\\\Users\\\\user\";\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `C:\\\\Users\\\\user${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n\n    it(\"should prefer $HOME to $HOMEDRIVE+$HOMEPATH\", async () => {\n      process.env.HOME = `${sep}foo${sep}bar`;\n      process.env.HOMEDRIVE = \"D:\\\\\";\n      process.env.HOMEPATH = \"Users\\\\user2\";\n\n      __addMatcher(\n        `${sep}foo${sep}bar${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${DEFAULT_CREDS.accessKeyId}\naws_secret_access_key = ${DEFAULT_CREDS.secretAccessKey}\naws_session_token = ${DEFAULT_CREDS.sessionToken}`.trim()\n      );\n\n      __addMatcher(\n        `D:\\\\Users\\\\user2${sep}.aws${sep}config`,\n        `\n[default]\naws_access_key_id = ${FOO_CREDS.accessKeyId}\naws_secret_access_key = ${FOO_CREDS.secretAccessKey}\naws_session_token = ${FOO_CREDS.sessionToken}`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        credentialsFile: {},\n        configFile: { default: parsed.default },\n      });\n    });\n\n    it(\"should ignore profile name in block list\", async () => {\n      __addMatcher(\n        DEFAULT_PATH,\n        `\n[profile __proto__]\nfoo = not_exist`.trim()\n      );\n\n      expect(await loadSharedConfigFiles()).toEqual({\n        configFile: {},\n        credentialsFile: {},\n      });\n    });\n  });\n});\n", "import { readFile } from \"fs\";\nimport { homedir } from \"os\";\nimport { join, sep } from \"path\";\n\nexport const ENV_CREDENTIALS_PATH = \"AWS_SHARED_CREDENTIALS_FILE\";\nexport const ENV_CONFIG_PATH = \"AWS_CONFIG_FILE\";\n\nexport interface SharedConfigInit {\n  /**\n   * The path at which to locate the ini credentials file. Defaults to the\n   * value of the `AWS_SHARED_CREDENTIALS_FILE` environment variable (if\n   * defined) or `~/.aws/credentials` otherwise.\n   */\n  filepath?: string;\n\n  /**\n   * The path at which to locate the ini config file. Defaults to the value of\n   * the `AWS_CONFIG_FILE` environment variable (if defined) or\n   * `~/.aws/config` otherwise.\n   */\n  configFilepath?: string;\n}\n\nexport interface Profile {\n  [key: string]: string | undefined;\n}\n\nexport interface ParsedIniData {\n  [key: string]: Profile;\n}\n\nexport interface SharedConfigFiles {\n  credentialsFile: ParsedIniData;\n  configFile: ParsedIniData;\n}\n\nconst swallowError = () => ({});\n\nexport const loadSharedConfigFiles = (init: SharedConfigInit = {}): Promise<SharedConfigFiles> => {\n  const {\n    filepath = process.env[ENV_CREDENTIALS_PATH] || join(getHomeDir(), \".aws\", \"credentials\"),\n    configFilepath = process.env[ENV_CONFIG_PATH] || join(getHomeDir(), \".aws\", \"config\"),\n  } = init;\n\n  return Promise.all([\n    slurpFile(configFilepath).then(parseIni).then(normalizeConfigFile).catch(swallowError),\n    slurpFile(filepath).then(parseIni).catch(swallowError),\n  ]).then((parsedFiles: Array<ParsedIniData>) => {\n    const [configFile, credentialsFile] = parsedFiles;\n    return {\n      configFile,\n      credentialsFile,\n    };\n  });\n};\n\nconst profileKeyRegex = /^profile\\s([\"'])?([^\\1]+)\\1$/;\nconst normalizeConfigFile = (data: ParsedIniData): ParsedIniData => {\n  const map: ParsedIniData = {};\n  for (const key of Object.keys(data)) {\n    let matches: Array<string> | null;\n    if (key === \"default\") {\n      map.default = data.default;\n    } else if ((matches = profileKeyRegex.exec(key))) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const [_1, _2, normalizedKey] = matches;\n      if (normalizedKey) {\n        map[normalizedKey] = data[key];\n      }\n    }\n  }\n\n  return map;\n};\n\nconst profileNameBlockList = [\"__proto__\", \"profile __proto__\"];\nconst parseIni = (iniData: string): ParsedIniData => {\n  const map: ParsedIniData = {};\n  let currentSection: string | undefined;\n  for (let line of iniData.split(/\\r?\\n/)) {\n    line = line.split(/(^|\\s)[;#]/)[0]; // remove comments\n    const section = line.match(/^\\s*\\[([^\\[\\]]+)]\\s*$/);\n    if (section) {\n      currentSection = section[1];\n      if (profileNameBlockList.includes(currentSection)) {\n        throw new Error(`Found invalid profile name \"${currentSection}\"`);\n      }\n    } else if (currentSection) {\n      const item = line.match(/^\\s*(.+?)\\s*=\\s*(.+?)\\s*$/);\n      if (item) {\n        map[currentSection] = map[currentSection] || {};\n        map[currentSection][item[1]] = item[2];\n      }\n    }\n  }\n\n  return map;\n};\n\nconst slurpFile = (path: string): Promise<string> =>\n  new Promise((resolve, reject) => {\n    readFile(path, \"utf8\", (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n\nconst getHomeDir = (): string => {\n  const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${sep}` } = process.env;\n\n  if (HOME) return HOME;\n  if (USERPROFILE) return USERPROFILE;\n  if (HOMEPATH) return `${HOMEDRIVE}${HOMEPATH}`;\n\n  return homedir();\n};\n"], "filenames": ["packages/shared-ini-file-loader/src/index.spec.ts", "packages/shared-ini-file-loader/src/index.ts"], "buggy_code_start_loc": [289, 39], "buggy_code_end_loc": [529, 117], "fixing_code_start_loc": [290, 39], "fixing_code_end_loc": [558, 120], "type": "NVD-CWE-noinfo", "message": "This affects the package @aws-sdk/shared-ini-file-loader before 1.0.0-rc.9; the package aws-sdk before 2.814.0. If an attacker submits a malicious INI file to an application that parses it with loadSharedConfigFiles , they will pollute the prototype on the application. This can be exploited further depending on the context.", "other": {"cve": {"id": "CVE-2020-28472", "sourceIdentifier": "report@snyk.io", "published": "2021-01-19T11:15:13.027", "lastModified": "2021-01-28T15:16:55.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package @aws-sdk/shared-ini-file-loader before 1.0.0-rc.9; the package aws-sdk before 2.814.0. If an attacker submits a malicious INI file to an application that parses it with loadSharedConfigFiles , they will pollute the prototype on the application. This can be exploited further depending on the context."}, {"lang": "es", "value": "Esto afecta al paquete @aws-sdk/shared-ini-file-loader versiones anteriores a 1.0.0-rc.9;&#xa0;el paquete aws-sdk versiones anteriores a 2.814.0.&#xa0;Si un atacante env\u00eda un archivo INI malicioso hacia una aplicaci\u00f3n que lo analiza con la funci\u00f3n loadSharedConfigFiles, contaminar\u00e1 el prototipo de la aplicaci\u00f3n.&#xa0;Esto puede ser explotado a\u00fan m\u00e1s dependiendo del contexto"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_sdk_for_javascipt:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.814.0", "matchCriteriaId": "4B9D15C1-7835-40B7-86A0-BEC86A09377B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:alpha1:*:*:*:node.js:*:*", "matchCriteriaId": "E4CC8788-7AEE-4613-B931-A69DA0630877"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:alpha2:*:*:*:node.js:*:*", "matchCriteriaId": "8ED57E34-4BEC-4BB3-98B1-B98BA1E0ADD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:alpha3:*:*:*:node.js:*:*", "matchCriteriaId": "AA8CF45E-E139-46EB-A651-636EC6496359"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:beta1:*:*:*:node.js:*:*", "matchCriteriaId": "74038A5B-4691-460B-85F6-E5CD819EE40B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:beta2:*:*:*:node.js:*:*", "matchCriteriaId": "E7D3816B-AF57-4882-B2C9-5E9525384389"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:beta3:*:*:*:node.js:*:*", "matchCriteriaId": "9F0D0480-6C83-4965-A28C-7A454BF7B746"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:beta4:*:*:*:node.js:*:*", "matchCriteriaId": "AE2DBB1D-F20D-4D84-A55B-9407C175A5A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma1:*:*:*:node.js:*:*", "matchCriteriaId": "DC401A8E-508D-44A0-AE88-6DF6D2A8B385"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma2:*:*:*:node.js:*:*", "matchCriteriaId": "14D7C530-E946-4F93-AD45-5FB44DA84D44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma3:*:*:*:node.js:*:*", "matchCriteriaId": "2508E88C-3C1C-494F-AA87-78C50BBD375D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma4:*:*:*:node.js:*:*", "matchCriteriaId": "CCD4DCF2-AE3D-4F48-BD70-1EE4E901A6F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma5:*:*:*:node.js:*:*", "matchCriteriaId": "FC1163F8-369C-47DA-B2BA-B928E7677C7F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma6:*:*:*:node.js:*:*", "matchCriteriaId": "CA2BAEC0-C485-45F4-B949-F4BD0DE4DAA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma7:*:*:*:node.js:*:*", "matchCriteriaId": "C789D328-FEC7-4686-B266-AF6A5E0D5F53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:gamma8:*:*:*:node.js:*:*", "matchCriteriaId": "920F1CDF-2DDB-4676-AA90-6D0BE69C5C69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:rc1:*:*:*:node.js:*:*", "matchCriteriaId": "32E0E5F4-87AB-4A23-8ADE-021E9FAD1EF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:rc2:*:*:*:node.js:*:*", "matchCriteriaId": "8ECDEF82-7A6B-414A-9D4E-9DE60791659D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:rc3:*:*:*:node.js:*:*", "matchCriteriaId": "7F4C56E0-3038-402C-9BA5-495B0AF4045B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_shared_configuration_file_loader:1.0.0:rc8:*:*:*:node.js:*:*", "matchCriteriaId": "CAEDBEC9-7C13-4634-BC34-E13698BEDC6F"}]}]}], "references": [{"url": "https://github.com/aws/aws-sdk-js-v3/commit/a209082dff913939672bb069964b33aa4c5409a9", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/aws/aws-sdk-js/pull/3585/commits/7d72aff2a941173733fcb6741b104cd83d3bc611", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWER-1059426", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1059425", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-AWSSDK-1059424", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-AWSSDKSHAREDINIFILELOADER-1049304", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aws/aws-sdk-js-v3/commit/a209082dff913939672bb069964b33aa4c5409a9"}}