{"buggy_code": ["// Ogg Vorbis audio decoder - v1.16 - public domain\n// http://nothings.org/stb_vorbis/\n//\n// Original version written by Sean Barrett in 2007.\n//\n// Originally sponsored by RAD Game Tools. Seeking implementation\n// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,\n// Elias Software, Aras Pranckevicius, and Sean Barrett.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// Limitations:\n//\n//   - floor 0 not supported (used in old ogg vorbis files pre-2004)\n//   - lossless sample-truncation at beginning ignored\n//   - cannot concatenate multiple vorbis streams\n//   - sample positions are 32-bit, limiting seekable 192Khz\n//       files to around 6 hours (Ogg supports 64-bit)\n//\n// Feature contributors:\n//    Dougall Johnson (sample-exact seeking)\n//\n// Bugfix/warning contributors:\n//    Terje Mathisen     Niklas Frykholm     Andy Hill\n//    Casey Muratori     John Bolton         Gargaj\n//    Laurent Gomila     Marc LeBlanc        Ronny Chevalier\n//    Bernhard Wodo      Evan Balster        alxprd@github\n//    Tom Beaumont       Ingo Leitgeb        Nicolas Guillemot\n//    Phillip Bennefall  Rohit               Thiago Goulart\n//    manxorist@github   saga musix          github:infatum\n//    Timur Gagiev\n//\n// Partial history:\n//    1.16    - 2019-03-04 - fix warnings\n//    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n//    1.14    - 2018-02-11 - delete bogus dealloca usage\n//    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n//    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n//    1.11    - 2017-07-23 - fix MinGW compilation \n//    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n//    1.09    - 2016-04-04 - back out 'truncation of last frame' fix from previous version\n//    1.08    - 2016-04-02 - warnings; setup memory leaks; truncation of last frame\n//    1.07    - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const\n//    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n//                           some crash fixes when out of memory or with corrupt files\n//                           fix some inappropriately signed shifts\n//    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n//    1.04    - 2014-08-27 - fix missing const-correct case in API\n//    1.03    - 2014-08-07 - warning fixes\n//    1.02    - 2014-07-09 - declare qsort comparison as explicitly _cdecl in Windows\n//    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float (interleaved was correct)\n//    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;\n//                           (API change) report sample rate for decode-full-file funcs\n//\n// See end of file for full version history.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  HEADER BEGINS HERE\n//\n\n#ifndef STB_VORBIS_INCLUDE_STB_VORBIS_H\n#define STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n#define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n///////////   THREAD SAFETY\n\n// Individual stb_vorbis* handles are not thread-safe; you cannot decode from\n// them from multiple threads at the same time. However, you can have multiple\n// stb_vorbis* handles and decode from them independently in multiple thrads.\n\n\n///////////   MEMORY ALLOCATION\n\n// normally stb_vorbis uses malloc() to allocate memory at startup,\n// and alloca() to allocate temporary memory during a frame on the\n// stack. (Memory consumption will depend on the amount of setup\n// data in the file and how you set the compile flags for speed\n// vs. size. In my test files the maximal-size usage is ~150KB.)\n//\n// You can modify the wrapper functions in the source (setup_malloc,\n// setup_temp_malloc, temp_malloc) to change this behavior, or you\n// can use a simpler allocation model: you pass in a buffer from\n// which stb_vorbis will allocate _all_ its memory (including the\n// temp memory). \"open\" may fail with a VORBIS_outofmem if you\n// do not pass in enough data; there is no way to determine how\n// much you do need except to succeed (at which point you can\n// query get_info to find the exact amount required. yes I know\n// this is lame).\n//\n// If you pass in a non-NULL buffer of the type below, allocation\n// will occur from it as described above. Otherwise just pass NULL\n// to use malloc()/alloca()\n\ntypedef struct\n{\n   char *alloc_buffer;\n   int   alloc_buffer_length_in_bytes;\n} stb_vorbis_alloc;\n\n\n///////////   FUNCTIONS USEABLE WITH ALL INPUT MODES\n\ntypedef struct stb_vorbis stb_vorbis;\n\ntypedef struct\n{\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int setup_temp_memory_required;\n   unsigned int temp_memory_required;\n\n   int max_frame_size;\n} stb_vorbis_info;\n\n// get general information about the file\nextern stb_vorbis_info stb_vorbis_get_info(stb_vorbis *f);\n\n// get the last error detected (clears it, too)\nextern int stb_vorbis_get_error(stb_vorbis *f);\n\n// close an ogg vorbis file and free all memory in use\nextern void stb_vorbis_close(stb_vorbis *f);\n\n// this function returns the offset (in samples) from the beginning of the\n// file that will be returned by the next decode, if it is known, or -1\n// otherwise. after a flush_pushdata() call, this may take a while before\n// it becomes valid again.\n// NOT WORKING YET after a seek with PULLDATA API\nextern int stb_vorbis_get_sample_offset(stb_vorbis *f);\n\n// returns the current seek point within the file, or offset from the beginning\n// of the memory buffer. In pushdata mode it returns 0.\nextern unsigned int stb_vorbis_get_file_offset(stb_vorbis *f);\n\n///////////   PUSHDATA API\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\n// this API allows you to get blocks of data from any source and hand\n// them to stb_vorbis. you have to buffer them; stb_vorbis will tell\n// you how much it used, and you have to give it the rest next time;\n// and stb_vorbis may not have enough data to work with and you will\n// need to give it the same data again PLUS more. Note that the Vorbis\n// specification does not bound the size of an individual frame.\n\nextern stb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char * datablock, int datablock_length_in_bytes,\n         int *datablock_memory_consumed_in_bytes,\n         int *error,\n         const stb_vorbis_alloc *alloc_buffer);\n// create a vorbis decoder by passing in the initial data block containing\n//    the ogg&vorbis headers (you don't need to do parse them, just provide\n//    the first N bytes of the file--you're told if it's not enough, see below)\n// on success, returns an stb_vorbis *, does not set error, returns the amount of\n//    data parsed/consumed on this call in *datablock_memory_consumed_in_bytes;\n// on failure, returns NULL on error and sets *error, does not change *datablock_memory_consumed\n// if returns NULL and *error is VORBIS_need_more_data, then the input block was\n//       incomplete and you need to pass in a larger block from the start of the file\n\nextern int stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,\n         const unsigned char *datablock, int datablock_length_in_bytes,\n         int *channels,             // place to write number of float * buffers\n         float ***output,           // place to write float ** array of float * buffers\n         int *samples               // place to write number of output samples\n     );\n// decode a frame of audio sample data if possible from the passed-in data block\n//\n// return value: number of bytes we used from datablock\n//\n// possible cases:\n//     0 bytes used, 0 samples output (need more data)\n//     N bytes used, 0 samples output (resynching the stream, keep going)\n//     N bytes used, M samples output (one frame of data)\n// note that after opening a file, you will ALWAYS get one N-bytes,0-sample\n// frame, because Vorbis always \"discards\" the first frame.\n//\n// Note that on resynch, stb_vorbis will rarely consume all of the buffer,\n// instead only datablock_length_in_bytes-3 or less. This is because it wants\n// to avoid missing parts of a page header if they cross a datablock boundary,\n// without writing state-machiney code to record a partial detection.\n//\n// The number of channels returned are stored in *channels (which can be\n// NULL--it is always the same as the number of channels reported by\n// get_info). *output will contain an array of float* buffers, one per\n// channel. In other words, (*output)[0][0] contains the first sample from\n// the first channel, and (*output)[1][0] contains the first sample from\n// the second channel.\n\nextern void stb_vorbis_flush_pushdata(stb_vorbis *f);\n// inform stb_vorbis that your next datablock will not be contiguous with\n// previous ones (e.g. you've seeked in the data); future attempts to decode\n// frames will cause stb_vorbis to resynchronize (as noted above), and\n// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it\n// will begin decoding the _next_ frame.\n//\n// if you want to seek using pushdata, you need to seek in your file, then\n// call stb_vorbis_flush_pushdata(), then start calling decoding, then once\n// decoding is returning you data, call stb_vorbis_get_sample_offset, and\n// if you don't like the result, seek your file again and repeat.\n#endif\n\n\n//////////   PULLING INPUT API\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n// This API assumes stb_vorbis is allowed to pull data from a source--\n// either a block of memory containing the _entire_ vorbis stream, or a\n// FILE * that you or it create, or possibly some other reading mechanism\n// if you go modify the source to replace the FILE * case with some kind\n// of callback to your code. (But if you don't support seeking, you may\n// just want to go ahead and use pushdata.)\n\n#if !defined(STB_VORBIS_NO_STDIO) && !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output);\n#endif\n#if !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_memory(const unsigned char *mem, int len, int *channels, int *sample_rate, short **output);\n#endif\n// decode an entire file and output the data interleaved into a malloc()ed\n// buffer stored in *output. The return value is the number of samples\n// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.\n// When you're done with it, just free() the pointer returned in *output.\n\nextern stb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an ogg vorbis stream in memory (note\n// this must be the entire stream!). on failure, returns NULL and sets *error\n\n#ifndef STB_VORBIS_NO_STDIO\nextern stb_vorbis * stb_vorbis_open_filename(const char *filename,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from a filename via fopen(). on failure,\n// returns NULL and sets *error (possibly to VORBIS_file_open_failure).\n\nextern stb_vorbis * stb_vorbis_open_file(FILE *f, int close_handle_on_close,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell). on failure, returns NULL and sets *error.\n// note that stb_vorbis must \"own\" this stream; if you seek it in between\n// calls to stb_vorbis, it will become confused. Moreover, if you attempt to\n// perform stb_vorbis_seek_*() operations on this file, it will assume it\n// owns the _entire_ rest of the file after the start point. Use the next\n// function, stb_vorbis_open_file_section(), to limit it.\n\nextern stb_vorbis * stb_vorbis_open_file_section(FILE *f, int close_handle_on_close,\n                int *error, const stb_vorbis_alloc *alloc_buffer, unsigned int len);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell); the stream will be of length 'len' bytes.\n// on failure, returns NULL and sets *error. note that stb_vorbis must \"own\"\n// this stream; if you seek it in between calls to stb_vorbis, it will become\n// confused.\n#endif\n\nextern int stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number);\nextern int stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number);\n// these functions seek in the Vorbis file to (approximately) 'sample_number'.\n// after calling seek_frame(), the next call to get_frame_*() will include\n// the specified sample. after calling stb_vorbis_seek(), the next call to\n// stb_vorbis_get_samples_* will start with the specified sample. If you\n// do not need to seek to EXACTLY the target sample when using get_samples_*,\n// you can also use seek_frame().\n\nextern int stb_vorbis_seek_start(stb_vorbis *f);\n// this function is equivalent to stb_vorbis_seek(f,0)\n\nextern unsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f);\nextern float        stb_vorbis_stream_length_in_seconds(stb_vorbis *f);\n// these functions return the total length of the vorbis stream\n\nextern int stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output);\n// decode the next frame and return the number of samples. the number of\n// channels returned are stored in *channels (which can be NULL--it is always\n// the same as the number of channels reported by get_info). *output will\n// contain an array of float* buffers, one per channel. These outputs will\n// be overwritten on the next call to stb_vorbis_get_frame_*.\n//\n// You generally should not intermix calls to stb_vorbis_get_frame_*()\n// and stb_vorbis_get_samples_*(), since the latter calls the former.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts);\nextern int stb_vorbis_get_frame_short            (stb_vorbis *f, int num_c, short **buffer, int num_samples);\n#endif\n// decode the next frame and return the number of *samples* per channel.\n// Note that for interleaved data, you pass in the number of shorts (the\n// size of your array), but the return value is the number of samples per\n// channel, not the total number of samples.\n//\n// The data is coerced to the number of channels you request according to the\n// channel coercion rules (see below). You must pass in the size of your\n// buffer(s) so that stb_vorbis will not overwrite the end of the buffer.\n// The maximum buffer size needed can be gotten from get_info(); however,\n// the Vorbis I specification implies an absolute maximum of 4096 samples\n// per channel.\n\n// Channel coercion rules:\n//    Let M be the number of channels requested, and N the number of channels present,\n//    and Cn be the nth channel; let stereo L be the sum of all L and center channels,\n//    and stereo R be the sum of all R and center channels (channel assignment from the\n//    vorbis spec).\n//        M    N       output\n//        1    k      sum(Ck) for all k\n//        2    *      stereo L, stereo R\n//        k    l      k > l, the first l channels, then 0s\n//        k    l      k <= l, the first k channels\n//    Note that this is not _good_ surround etc. mixing at all! It's just so\n//    you get something useful.\n\nextern int stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats);\nextern int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples);\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.\n// Returns the number of samples stored per channel; it may be less than requested\n// at the end of the file. If there are no more samples in the file, returns 0.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts);\nextern int stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int num_samples);\n#endif\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. Applies the coercion rules above\n// to produce 'channels' channels. Returns the number of samples stored per channel;\n// it may be less than requested at the end of the file. If there are no more\n// samples in the file, returns 0.\n\n#endif\n\n////////   ERROR CODES\n\nenum STBVorbisError\n{\n   VORBIS__no_error,\n\n   VORBIS_need_more_data=1,             // not a real error\n\n   VORBIS_invalid_api_mixing,           // can't mix API modes\n   VORBIS_outofmem,                     // not enough memory\n   VORBIS_feature_not_supported,        // uses floor 0\n   VORBIS_too_many_channels,            // STB_VORBIS_MAX_CHANNELS is too small\n   VORBIS_file_open_failure,            // fopen() failed\n   VORBIS_seek_without_length,          // can't seek in unknown-length file\n\n   VORBIS_unexpected_eof=10,            // file is truncated?\n   VORBIS_seek_invalid,                 // seek past EOF\n\n   // decoding errors (corrupt/invalid stream) -- you probably\n   // don't care about the exact details of these\n\n   // vorbis errors:\n   VORBIS_invalid_setup=20,\n   VORBIS_invalid_stream,\n\n   // ogg errors:\n   VORBIS_missing_capture_pattern=30,\n   VORBIS_invalid_stream_structure_version,\n   VORBIS_continued_packet_flag_invalid,\n   VORBIS_incorrect_stream_serial_number,\n   VORBIS_invalid_first_page,\n   VORBIS_bad_packet_type,\n   VORBIS_cant_find_last_page,\n   VORBIS_seek_failed,\n   VORBIS_ogg_skeleton_not_supported\n};\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // STB_VORBIS_INCLUDE_STB_VORBIS_H\n//\n//  HEADER ENDS HERE\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifndef STB_VORBIS_HEADER_ONLY\n\n// global configuration settings (e.g. set these in the project/makefile),\n// or just set them in this file at the top (although ideally the first few\n// should be visible when the header file is compiled too, although it's not\n// crucial)\n\n// STB_VORBIS_NO_PUSHDATA_API\n//     does not compile the code for the various stb_vorbis_*_pushdata()\n//     functions\n// #define STB_VORBIS_NO_PUSHDATA_API\n\n// STB_VORBIS_NO_PULLDATA_API\n//     does not compile the code for the non-pushdata APIs\n// #define STB_VORBIS_NO_PULLDATA_API\n\n// STB_VORBIS_NO_STDIO\n//     does not compile the code for the APIs that use FILE *s internally\n//     or externally (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_STDIO\n\n// STB_VORBIS_NO_INTEGER_CONVERSION\n//     does not compile the code for converting audio sample data from\n//     float to integer (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_INTEGER_CONVERSION\n\n// STB_VORBIS_NO_FAST_SCALED_FLOAT\n//      does not use a fast float-to-int trick to accelerate float-to-int on\n//      most platforms which requires endianness be defined correctly.\n//#define STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n\n// STB_VORBIS_MAX_CHANNELS [number]\n//     globally define this to the maximum number of channels you need.\n//     The spec does not put a restriction on channels except that\n//     the count is stored in a byte, so 255 is the hard limit.\n//     Reducing this saves about 16 bytes per value, so using 16 saves\n//     (255-16)*16 or around 4KB. Plus anything other memory usage\n//     I forgot to account for. Can probably go as low as 8 (7.1 audio),\n//     6 (5.1 audio), or 2 (stereo only).\n#ifndef STB_VORBIS_MAX_CHANNELS\n#define STB_VORBIS_MAX_CHANNELS    16  // enough for anyone?\n#endif\n\n// STB_VORBIS_PUSHDATA_CRC_COUNT [number]\n//     after a flush_pushdata(), stb_vorbis begins scanning for the\n//     next valid page, without backtracking. when it finds something\n//     that looks like a page, it streams through it and verifies its\n//     CRC32. Should that validation fail, it keeps scanning. But it's\n//     possible that _while_ streaming through to check the CRC32 of\n//     one candidate page, it sees another candidate page. This #define\n//     determines how many \"overlapping\" candidate pages it can search\n//     at once. Note that \"real\" pages are typically ~4KB to ~8KB, whereas\n//     garbage pages could be as big as 64KB, but probably average ~16KB.\n//     So don't hose ourselves by scanning an apparent 64KB page and\n//     missing a ton of real ones in the interim; so minimum of 2\n#ifndef STB_VORBIS_PUSHDATA_CRC_COUNT\n#define STB_VORBIS_PUSHDATA_CRC_COUNT  4\n#endif\n\n// STB_VORBIS_FAST_HUFFMAN_LENGTH [number]\n//     sets the log size of the huffman-acceleration table.  Maximum\n//     supported value is 24. with larger numbers, more decodings are O(1),\n//     but the table size is larger so worse cache missing, so you'll have\n//     to probe (and try multiple ogg vorbis files) to find the sweet spot.\n#ifndef STB_VORBIS_FAST_HUFFMAN_LENGTH\n#define STB_VORBIS_FAST_HUFFMAN_LENGTH   10\n#endif\n\n// STB_VORBIS_FAST_BINARY_LENGTH [number]\n//     sets the log size of the binary-search acceleration table. this\n//     is used in similar fashion to the fast-huffman size to set initial\n//     parameters for the binary search\n\n// STB_VORBIS_FAST_HUFFMAN_INT\n//     The fast huffman tables are much more efficient if they can be\n//     stored as 16-bit results instead of 32-bit results. This restricts\n//     the codebooks to having only 65535 possible outcomes, though.\n//     (At least, accelerated by the huffman table.)\n#ifndef STB_VORBIS_FAST_HUFFMAN_INT\n#define STB_VORBIS_FAST_HUFFMAN_SHORT\n#endif\n\n// STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n//     If the 'fast huffman' search doesn't succeed, then stb_vorbis falls\n//     back on binary searching for the correct one. This requires storing\n//     extra tables with the huffman codes in sorted order. Defining this\n//     symbol trades off space for speed by forcing a linear search in the\n//     non-fast case, except for \"sparse\" codebooks.\n// #define STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n\n// STB_VORBIS_DIVIDES_IN_RESIDUE\n//     stb_vorbis precomputes the result of the scalar residue decoding\n//     that would otherwise require a divide per chunk. you can trade off\n//     space for time by defining this symbol.\n// #define STB_VORBIS_DIVIDES_IN_RESIDUE\n\n// STB_VORBIS_DIVIDES_IN_CODEBOOK\n//     vorbis VQ codebooks can be encoded two ways: with every case explicitly\n//     stored, or with all elements being chosen from a small range of values,\n//     and all values possible in all elements. By default, stb_vorbis expands\n//     this latter kind out to look like the former kind for ease of decoding,\n//     because otherwise an integer divide-per-vector-element is required to\n//     unpack the index. If you define STB_VORBIS_DIVIDES_IN_CODEBOOK, you can\n//     trade off storage for speed.\n//#define STB_VORBIS_DIVIDES_IN_CODEBOOK\n\n#ifdef STB_VORBIS_CODEBOOK_SHORTS\n#error \"STB_VORBIS_CODEBOOK_SHORTS is no longer supported as it produced incorrect results for some input formats\"\n#endif\n\n// STB_VORBIS_DIVIDE_TABLE\n//     this replaces small integer divides in the floor decode loop with\n//     table lookups. made less than 1% difference, so disabled by default.\n\n// STB_VORBIS_NO_INLINE_DECODE\n//     disables the inlining of the scalar codebook fast-huffman decode.\n//     might save a little codespace; useful for debugging\n// #define STB_VORBIS_NO_INLINE_DECODE\n\n// STB_VORBIS_NO_DEFER_FLOOR\n//     Normally we only decode the floor without synthesizing the actual\n//     full curve. We can instead synthesize the curve immediately. This\n//     requires more memory and is very likely slower, so I don't think\n//     you'd ever want to do it except for debugging.\n// #define STB_VORBIS_NO_DEFER_FLOOR\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n#ifdef STB_VORBIS_NO_PULLDATA_API\n   #define STB_VORBIS_NO_INTEGER_CONVERSION\n   #define STB_VORBIS_NO_STDIO\n#endif\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n   #define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n   // only need endianness for fast-float-to-int, which we don't\n   // use for pushdata\n\n   #ifndef STB_VORBIS_BIG_ENDIAN\n     #define STB_VORBIS_ENDIAN  0\n   #else\n     #define STB_VORBIS_ENDIAN  1\n   #endif\n\n#endif\n#endif\n\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef STB_VORBIS_NO_CRT\n   #include <stdlib.h>\n   #include <string.h>\n   #include <assert.h>\n   #include <math.h>\n\n   // find definition of alloca if it's not in stdlib.h:\n   #if defined(_MSC_VER) || defined(__MINGW32__)\n      #include <malloc.h>\n   #endif\n   #if defined(__linux__) || defined(__linux) || defined(__EMSCRIPTEN__)\n      #include <alloca.h>\n   #endif\n#else // STB_VORBIS_NO_CRT\n   #define NULL 0\n   #define malloc(s)   0\n   #define free(s)     ((void) 0)\n   #define realloc(s)  0\n#endif // STB_VORBIS_NO_CRT\n\n#include <limits.h>\n\n#ifdef __MINGW32__\n   // eff you mingw:\n   //     \"fixed\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32882927/\n   //     \"no that broke the build, reverted, who cares about C\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32890381/\n   #ifdef __forceinline\n   #undef __forceinline\n   #endif\n   #define __forceinline\n   #define alloca __builtin_alloca\n#elif !defined(_MSC_VER)\n   #if __GNUC__\n      #define __forceinline inline\n   #else\n      #define __forceinline\n   #endif\n#endif\n\n#if STB_VORBIS_MAX_CHANNELS > 256\n#error \"Value of STB_VORBIS_MAX_CHANNELS outside of allowed range\"\n#endif\n\n#if STB_VORBIS_FAST_HUFFMAN_LENGTH > 24\n#error \"Value of STB_VORBIS_FAST_HUFFMAN_LENGTH outside of allowed range\"\n#endif\n\n\n#if 0\n#include <crtdbg.h>\n#define CHECK(f)   _CrtIsValidHeapPointer(f->channel_buffers[1])\n#else\n#define CHECK(f)   ((void) 0)\n#endif\n\n#define MAX_BLOCKSIZE_LOG  13   // from specification\n#define MAX_BLOCKSIZE      (1 << MAX_BLOCKSIZE_LOG)\n\n\ntypedef unsigned char  uint8;\ntypedef   signed char   int8;\ntypedef unsigned short uint16;\ntypedef   signed short  int16;\ntypedef unsigned int   uint32;\ntypedef   signed int    int32;\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n\ntypedef float codetype;\n\n// @NOTE\n//\n// Some arrays below are tagged \"//varies\", which means it's actually\n// a variable-sized piece of data, but rather than malloc I assume it's\n// small enough it's better to just allocate it all together with the\n// main thing\n//\n// Most of the variables are specified with the smallest size I could pack\n// them into. It might give better performance to make them all full-sized\n// integers. It should be safe to freely rearrange the structures or change\n// the sizes larger--nothing relies on silently truncating etc., nor the\n// order of variables.\n\n#define FAST_HUFFMAN_TABLE_SIZE   (1 << STB_VORBIS_FAST_HUFFMAN_LENGTH)\n#define FAST_HUFFMAN_TABLE_MASK   (FAST_HUFFMAN_TABLE_SIZE - 1)\n\ntypedef struct\n{\n   int dimensions, entries;\n   uint8 *codeword_lengths;\n   float  minimum_value;\n   float  delta_value;\n   uint8  value_bits;\n   uint8  lookup_type;\n   uint8  sequence_p;\n   uint8  sparse;\n   uint32 lookup_values;\n   codetype *multiplicands;\n   uint32 *codewords;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n    int16  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #else\n    int32  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #endif\n   uint32 *sorted_codewords;\n   int    *sorted_values;\n   int     sorted_entries;\n} Codebook;\n\ntypedef struct\n{\n   uint8 order;\n   uint16 rate;\n   uint16 bark_map_size;\n   uint8 amplitude_bits;\n   uint8 amplitude_offset;\n   uint8 number_of_books;\n   uint8 book_list[16]; // varies\n} Floor0;\n\ntypedef struct\n{\n   uint8 partitions;\n   uint8 partition_class_list[32]; // varies\n   uint8 class_dimensions[16]; // varies\n   uint8 class_subclasses[16]; // varies\n   uint8 class_masterbooks[16]; // varies\n   int16 subclass_books[16][8]; // varies\n   uint16 Xlist[31*8+2]; // varies\n   uint8 sorted_order[31*8+2];\n   uint8 neighbors[31*8+2][2];\n   uint8 floor1_multiplier;\n   uint8 rangebits;\n   int values;\n} Floor1;\n\ntypedef union\n{\n   Floor0 floor0;\n   Floor1 floor1;\n} Floor;\n\ntypedef struct\n{\n   uint32 begin, end;\n   uint32 part_size;\n   uint8 classifications;\n   uint8 classbook;\n   uint8 **classdata;\n   int16 (*residue_books)[8];\n} Residue;\n\ntypedef struct\n{\n   uint8 magnitude;\n   uint8 angle;\n   uint8 mux;\n} MappingChannel;\n\ntypedef struct\n{\n   uint16 coupling_steps;\n   MappingChannel *chan;\n   uint8  submaps;\n   uint8  submap_floor[15]; // varies\n   uint8  submap_residue[15]; // varies\n} Mapping;\n\ntypedef struct\n{\n   uint8 blockflag;\n   uint8 mapping;\n   uint16 windowtype;\n   uint16 transformtype;\n} Mode;\n\ntypedef struct\n{\n   uint32  goal_crc;    // expected crc if match\n   int     bytes_left;  // bytes left in packet\n   uint32  crc_so_far;  // running crc\n   int     bytes_done;  // bytes processed in _current_ chunk\n   uint32  sample_loc;  // granule pos encoded in page\n} CRCscan;\n\ntypedef struct\n{\n   uint32 page_start, page_end;\n   uint32 last_decoded_sample;\n} ProbedPage;\n\nstruct stb_vorbis\n{\n  // user-accessible info\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int temp_memory_required;\n   unsigned int setup_temp_memory_required;\n\n  // input config\n#ifndef STB_VORBIS_NO_STDIO\n   FILE *f;\n   uint32 f_start;\n   int close_on_free;\n#endif\n\n   uint8 *stream;\n   uint8 *stream_start;\n   uint8 *stream_end;\n\n   uint32 stream_len;\n\n   uint8  push_mode;\n\n   uint32 first_audio_page_offset;\n\n   ProbedPage p_first, p_last;\n\n  // memory management\n   stb_vorbis_alloc alloc;\n   int setup_offset;\n   int temp_offset;\n\n  // run-time results\n   int eof;\n   enum STBVorbisError error;\n\n  // user-useful data\n\n  // header info\n   int blocksize[2];\n   int blocksize_0, blocksize_1;\n   int codebook_count;\n   Codebook *codebooks;\n   int floor_count;\n   uint16 floor_types[64]; // varies\n   Floor *floor_config;\n   int residue_count;\n   uint16 residue_types[64]; // varies\n   Residue *residue_config;\n   int mapping_count;\n   Mapping *mapping;\n   int mode_count;\n   Mode mode_config[64];  // varies\n\n   uint32 total_samples;\n\n  // decode buffer\n   float *channel_buffers[STB_VORBIS_MAX_CHANNELS];\n   float *outputs        [STB_VORBIS_MAX_CHANNELS];\n\n   float *previous_window[STB_VORBIS_MAX_CHANNELS];\n   int previous_length;\n\n   #ifndef STB_VORBIS_NO_DEFER_FLOOR\n   int16 *finalY[STB_VORBIS_MAX_CHANNELS];\n   #else\n   float *floor_buffers[STB_VORBIS_MAX_CHANNELS];\n   #endif\n\n   uint32 current_loc; // sample location of next frame to decode\n   int    current_loc_valid;\n\n  // per-blocksize precomputed data\n   \n   // twiddle factors\n   float *A[2],*B[2],*C[2];\n   float *window[2];\n   uint16 *bit_reverse[2];\n\n  // current page/packet/segment streaming info\n   uint32 serial; // stream serial number for verification\n   int last_page;\n   int segment_count;\n   uint8 segments[255];\n   uint8 page_flag;\n   uint8 bytes_in_seg;\n   uint8 first_decode;\n   int next_seg;\n   int last_seg;  // flag that we're on the last segment\n   int last_seg_which; // what was the segment number of the last seg?\n   uint32 acc;\n   int valid_bits;\n   int packet_bytes;\n   int end_seg_with_known_loc;\n   uint32 known_loc_for_packet;\n   int discard_samples_deferred;\n   uint32 samples_output;\n\n  // push mode scanning\n   int page_crc_tests; // only in push_mode: number of tests active; -1 if not searching\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n   CRCscan scan[STB_VORBIS_PUSHDATA_CRC_COUNT];\n#endif\n\n  // sample-access\n   int channel_buffer_start;\n   int channel_buffer_end;\n};\n\n#if defined(STB_VORBIS_NO_PUSHDATA_API)\n   #define IS_PUSH_MODE(f)   FALSE\n#elif defined(STB_VORBIS_NO_PULLDATA_API)\n   #define IS_PUSH_MODE(f)   TRUE\n#else\n   #define IS_PUSH_MODE(f)   ((f)->push_mode)\n#endif\n\ntypedef struct stb_vorbis vorb;\n\nstatic int error(vorb *f, enum STBVorbisError e)\n{\n   f->error = e;\n   if (!f->eof && e != VORBIS_need_more_data) {\n      f->error=e; // breakpoint for debugging\n   }\n   return 0;\n}\n\n\n// these functions are used for allocating temporary memory\n// while decoding. if you can afford the stack space, use\n// alloca(); otherwise, provide a temp buffer and it will\n// allocate out of those.\n\n#define array_size_required(count,size)  (count*(sizeof(void *)+(size)))\n\n#define temp_alloc(f,size)              (f->alloc.alloc_buffer ? setup_temp_malloc(f,size) : alloca(size))\n#define temp_free(f,p)                  0\n#define temp_alloc_save(f)              ((f)->temp_offset)\n#define temp_alloc_restore(f,p)         ((f)->temp_offset = (p))\n\n#define temp_block_array(f,count,size)  make_block_array(temp_alloc(f,array_size_required(count,size)), count, size)\n\n// given a sufficiently large block of memory, make an array of pointers to subblocks of it\nstatic void *make_block_array(void *mem, int count, int size)\n{\n   int i;\n   void ** p = (void **) mem;\n   char *q = (char *) (p + count);\n   for (i=0; i < count; ++i) {\n      p[i] = q;\n      q += size;\n   }\n   return p;\n}\n\nstatic void *setup_malloc(vorb *f, int sz)\n{\n   sz = (sz+3) & ~3;\n   f->setup_memory_required += sz;\n   if (f->alloc.alloc_buffer) {\n      void *p = (char *) f->alloc.alloc_buffer + f->setup_offset;\n      if (f->setup_offset + sz > f->temp_offset) return NULL;\n      f->setup_offset += sz;\n      return p;\n   }\n   return sz ? malloc(sz) : NULL;\n}\n\nstatic void setup_free(vorb *f, void *p)\n{\n   if (f->alloc.alloc_buffer) return; // do nothing; setup mem is a stack\n   free(p);\n}\n\nstatic void *setup_temp_malloc(vorb *f, int sz)\n{\n   sz = (sz+3) & ~3;\n   if (f->alloc.alloc_buffer) {\n      if (f->temp_offset - sz < f->setup_offset) return NULL;\n      f->temp_offset -= sz;\n      return (char *) f->alloc.alloc_buffer + f->temp_offset;\n   }\n   return malloc(sz);\n}\n\nstatic void setup_temp_free(vorb *f, void *p, int sz)\n{\n   if (f->alloc.alloc_buffer) {\n      f->temp_offset += (sz+3)&~3;\n      return;\n   }\n   free(p);\n}\n\n#define CRC32_POLY    0x04c11db7   // from spec\n\nstatic uint32 crc_table[256];\nstatic void crc32_init(void)\n{\n   int i,j;\n   uint32 s;\n   for(i=0; i < 256; i++) {\n      for (s=(uint32) i << 24, j=0; j < 8; ++j)\n         s = (s << 1) ^ (s >= (1U<<31) ? CRC32_POLY : 0);\n      crc_table[i] = s;\n   }\n}\n\nstatic __forceinline uint32 crc32_update(uint32 crc, uint8 byte)\n{\n   return (crc << 8) ^ crc_table[byte ^ (crc >> 24)];\n}\n\n\n// used in setup, and for huffman that doesn't go fast path\nstatic unsigned int bit_reverse(unsigned int n)\n{\n  n = ((n & 0xAAAAAAAA) >>  1) | ((n & 0x55555555) << 1);\n  n = ((n & 0xCCCCCCCC) >>  2) | ((n & 0x33333333) << 2);\n  n = ((n & 0xF0F0F0F0) >>  4) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n & 0xFF00FF00) >>  8) | ((n & 0x00FF00FF) << 8);\n  return (n >> 16) | (n << 16);\n}\n\nstatic float square(float x)\n{\n   return x*x;\n}\n\n// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3\n// as required by the specification. fast(?) implementation from stb.h\n// @OPTIMIZE: called multiple times per-packet with \"constants\"; move to setup\nstatic int ilog(int32 n)\n{\n   static signed char log2_4[16] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 };\n\n   if (n < 0) return 0; // signed n returns 0\n\n   // 2 compares if n < 16, 3 compares otherwise (4 if signed or n > 1<<29)\n   if (n < (1 << 14))\n        if (n < (1 <<  4))            return  0 + log2_4[n      ];\n        else if (n < (1 <<  9))       return  5 + log2_4[n >>  5];\n             else                     return 10 + log2_4[n >> 10];\n   else if (n < (1 << 24))\n             if (n < (1 << 19))       return 15 + log2_4[n >> 15];\n             else                     return 20 + log2_4[n >> 20];\n        else if (n < (1 << 29))       return 25 + log2_4[n >> 25];\n             else                     return 30 + log2_4[n >> 30];\n}\n\n#ifndef M_PI\n  #define M_PI  3.14159265358979323846264f  // from CRC\n#endif\n\n// code length assigned to a value with no huffman encoding\n#define NO_CODE   255\n\n/////////////////////// LEAF SETUP FUNCTIONS //////////////////////////\n//\n// these functions are only called at setup, and only a few times\n// per file\n\nstatic float float32_unpack(uint32 x)\n{\n   // from the specification\n   uint32 mantissa = x & 0x1fffff;\n   uint32 sign = x & 0x80000000;\n   uint32 exp = (x & 0x7fe00000) >> 21;\n   double res = sign ? -(double)mantissa : (double)mantissa;\n   return (float) ldexp((float)res, exp-788);\n}\n\n\n// zlib & jpeg huffman tables assume that the output symbols\n// can either be arbitrarily arranged, or have monotonically\n// increasing frequencies--they rely on the lengths being sorted;\n// this makes for a very simple generation algorithm.\n// vorbis allows a huffman table with non-sorted lengths. This\n// requires a more sophisticated construction, since symbols in\n// order do not map to huffman codes \"in order\".\nstatic void add_entry(Codebook *c, uint32 huff_code, int symbol, int count, int len, uint32 *values)\n{\n   if (!c->sparse) {\n      c->codewords      [symbol] = huff_code;\n   } else {\n      c->codewords       [count] = huff_code;\n      c->codeword_lengths[count] = len;\n      values             [count] = symbol;\n   }\n}\n\nstatic int compute_codewords(Codebook *c, uint8 *len, int n, uint32 *values)\n{\n   int i,k,m=0;\n   uint32 available[32];\n\n   memset(available, 0, sizeof(available));\n   // find the first entry\n   for (k=0; k < n; ++k) if (len[k] < NO_CODE) break;\n   if (k == n) { assert(c->sorted_entries == 0); return TRUE; }\n   // add to the list\n   add_entry(c, 0, k, m++, len[k], values);\n   // add all available leaves\n   for (i=1; i <= len[k]; ++i)\n      available[i] = 1U << (32-i);\n   // note that the above code treats the first case specially,\n   // but it's really the same as the following code, so they\n   // could probably be combined (except the initial code is 0,\n   // and I use 0 in available[] to mean 'empty')\n   for (i=k+1; i < n; ++i) {\n      uint32 res;\n      int z = len[i], y;\n      if (z == NO_CODE) continue;\n      // find lowest available leaf (should always be earliest,\n      // which is what the specification calls for)\n      // note that this property, and the fact we can never have\n      // more than one free leaf at a given level, isn't totally\n      // trivial to prove, but it seems true and the assert never\n      // fires, so!\n      while (z > 0 && !available[z]) --z;\n      if (z == 0) { return FALSE; }\n      res = available[z];\n      assert(z >= 0 && z < 32);\n      available[z] = 0;\n      add_entry(c, bit_reverse(res), i, m++, len[i], values);\n      // propagate availability up the tree\n      if (z != len[i]) {\n         assert(len[i] >= 0 && len[i] < 32);\n         for (y=len[i]; y > z; --y) {\n            assert(available[y] == 0);\n            available[y] = res + (1 << (32-y));\n         }\n      }\n   }\n   return TRUE;\n}\n\n// accelerated huffman table allows fast O(1) match of all symbols\n// of length <= STB_VORBIS_FAST_HUFFMAN_LENGTH\nstatic void compute_accelerated_huffman(Codebook *c)\n{\n   int i, len;\n   for (i=0; i < FAST_HUFFMAN_TABLE_SIZE; ++i)\n      c->fast_huffman[i] = -1;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n   if (len > 32767) len = 32767; // largest possible value we can encode!\n   #endif\n   for (i=0; i < len; ++i) {\n      if (c->codeword_lengths[i] <= STB_VORBIS_FAST_HUFFMAN_LENGTH) {\n         uint32 z = c->sparse ? bit_reverse(c->sorted_codewords[i]) : c->codewords[i];\n         // set table entries for all bit combinations in the higher bits\n         while (z < FAST_HUFFMAN_TABLE_SIZE) {\n             c->fast_huffman[z] = i;\n             z += 1 << c->codeword_lengths[i];\n         }\n      }\n   }\n}\n\n#ifdef _MSC_VER\n#define STBV_CDECL __cdecl\n#else\n#define STBV_CDECL\n#endif\n\nstatic int STBV_CDECL uint32_compare(const void *p, const void *q)\n{\n   uint32 x = * (uint32 *) p;\n   uint32 y = * (uint32 *) q;\n   return x < y ? -1 : x > y;\n}\n\nstatic int include_in_sort(Codebook *c, uint8 len)\n{\n   if (c->sparse) { assert(len != NO_CODE); return TRUE; }\n   if (len == NO_CODE) return FALSE;\n   if (len > STB_VORBIS_FAST_HUFFMAN_LENGTH) return TRUE;\n   return FALSE;\n}\n\n// if the fast table above doesn't work, we want to binary\n// search them... need to reverse the bits\nstatic void compute_sorted_huffman(Codebook *c, uint8 *lengths, uint32 *values)\n{\n   int i, len;\n   // build a list of all the entries\n   // OPTIMIZATION: don't include the short ones, since they'll be caught by FAST_HUFFMAN.\n   // this is kind of a frivolous optimization--I don't see any performance improvement,\n   // but it's like 4 extra lines of code, so.\n   if (!c->sparse) {\n      int k = 0;\n      for (i=0; i < c->entries; ++i)\n         if (include_in_sort(c, lengths[i])) \n            c->sorted_codewords[k++] = bit_reverse(c->codewords[i]);\n      assert(k == c->sorted_entries);\n   } else {\n      for (i=0; i < c->sorted_entries; ++i)\n         c->sorted_codewords[i] = bit_reverse(c->codewords[i]);\n   }\n\n   qsort(c->sorted_codewords, c->sorted_entries, sizeof(c->sorted_codewords[0]), uint32_compare);\n   c->sorted_codewords[c->sorted_entries] = 0xffffffff;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   // now we need to indicate how they correspond; we could either\n   //   #1: sort a different data structure that says who they correspond to\n   //   #2: for each sorted entry, search the original list to find who corresponds\n   //   #3: for each original entry, find the sorted entry\n   // #1 requires extra storage, #2 is slow, #3 can use binary search!\n   for (i=0; i < len; ++i) {\n      int huff_len = c->sparse ? lengths[values[i]] : lengths[i];\n      if (include_in_sort(c,huff_len)) {\n         uint32 code = bit_reverse(c->codewords[i]);\n         int x=0, n=c->sorted_entries;\n         while (n > 1) {\n            // invariant: sc[x] <= code < sc[x+n]\n            int m = x + (n >> 1);\n            if (c->sorted_codewords[m] <= code) {\n               x = m;\n               n -= (n>>1);\n            } else {\n               n >>= 1;\n            }\n         }\n         assert(c->sorted_codewords[x] == code);\n         if (c->sparse) {\n            c->sorted_values[x] = values[i];\n            c->codeword_lengths[x] = huff_len;\n         } else {\n            c->sorted_values[x] = i;\n         }\n      }\n   }\n}\n\n// only run while parsing the header (3 times)\nstatic int vorbis_validate(uint8 *data)\n{\n   static uint8 vorbis[6] = { 'v', 'o', 'r', 'b', 'i', 's' };\n   return memcmp(data, vorbis, 6) == 0;\n}\n\n// called from setup only, once per code book\n// (formula implied by specification)\nstatic int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) / dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n      ++r;                                              // floor() to avoid _ftol() when non-CRT\n   assert(pow((float) r+1, dim) > entries);\n   assert((int) floor(pow((float) r, dim)) <= entries); // (int),floor() as above\n   return r;\n}\n\n// called twice per file\nstatic void compute_twiddle_factors(int n, float *A, float *B, float *C)\n{\n   int n4 = n >> 2, n8 = n >> 3;\n   int k,k2;\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2) * 0.5f;\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2) * 0.5f;\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n}\n\nstatic void compute_window(int n, float *window)\n{\n   int n2 = n >> 1, i;\n   for (i=0; i < n2; ++i)\n      window[i] = (float) sin(0.5 * M_PI * square((float) sin((i - 0 + 0.5) / n2 * 0.5 * M_PI)));\n}\n\nstatic void compute_bitreverse(int n, uint16 *rev)\n{\n   int ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   int i, n8 = n >> 3;\n   for (i=0; i < n8; ++i)\n      rev[i] = (bit_reverse(i) >> (32-ld+3)) << 2;\n}\n\nstatic int init_blocksize(vorb *f, int b, int n)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3;\n   f->A[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->B[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->C[b] = (float *) setup_malloc(f, sizeof(float) * n4);\n   if (!f->A[b] || !f->B[b] || !f->C[b]) return error(f, VORBIS_outofmem);\n   compute_twiddle_factors(n, f->A[b], f->B[b], f->C[b]);\n   f->window[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   if (!f->window[b]) return error(f, VORBIS_outofmem);\n   compute_window(n, f->window[b]);\n   f->bit_reverse[b] = (uint16 *) setup_malloc(f, sizeof(uint16) * n8);\n   if (!f->bit_reverse[b]) return error(f, VORBIS_outofmem);\n   compute_bitreverse(n, f->bit_reverse[b]);\n   return TRUE;\n}\n\nstatic void neighbors(uint16 *x, int n, int *plow, int *phigh)\n{\n   int low = -1;\n   int high = 65536;\n   int i;\n   for (i=0; i < n; ++i) {\n      if (x[i] > low  && x[i] < x[n]) { *plow  = i; low = x[i]; }\n      if (x[i] < high && x[i] > x[n]) { *phigh = i; high = x[i]; }\n   }\n}\n\n// this has been repurposed so y is now the original index instead of y\ntypedef struct\n{\n   uint16 x,id;\n} stbv__floor_ordering;\n\nstatic int STBV_CDECL point_compare(const void *p, const void *q)\n{\n   stbv__floor_ordering *a = (stbv__floor_ordering *) p;\n   stbv__floor_ordering *b = (stbv__floor_ordering *) q;\n   return a->x < b->x ? -1 : a->x > b->x;\n}\n\n//\n/////////////////////// END LEAF SETUP FUNCTIONS //////////////////////////\n\n\n#if defined(STB_VORBIS_NO_STDIO)\n   #define USE_MEMORY(z)    TRUE\n#else\n   #define USE_MEMORY(z)    ((z)->stream)\n#endif\n\nstatic uint8 get8(vorb *z)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream >= z->stream_end) { z->eof = TRUE; return 0; }\n      return *z->stream++;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n   int c = fgetc(z->f);\n   if (c == EOF) { z->eof = TRUE; return 0; }\n   return c;\n   }\n   #endif\n}\n\nstatic uint32 get32(vorb *f)\n{\n   uint32 x;\n   x = get8(f);\n   x += get8(f) << 8;\n   x += get8(f) << 16;\n   x += (uint32) get8(f) << 24;\n   return x;\n}\n\nstatic int getn(vorb *z, uint8 *data, int n)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream+n > z->stream_end) { z->eof = 1; return 0; }\n      memcpy(data, z->stream, n);\n      z->stream += n;\n      return 1;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO   \n   if (fread(data, n, 1, z->f) == 1)\n      return 1;\n   else {\n      z->eof = 1;\n      return 0;\n   }\n   #endif\n}\n\nstatic void skip(vorb *z, int n)\n{\n   if (USE_MEMORY(z)) {\n      z->stream += n;\n      if (z->stream >= z->stream_end) z->eof = 1;\n      return;\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n      long x = ftell(z->f);\n      fseek(z->f, x+n, SEEK_SET);\n   }\n   #endif\n}\n\nstatic int set_file_offset(stb_vorbis *f, unsigned int loc)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   f->eof = 0;\n   if (USE_MEMORY(f)) {\n      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n         f->stream = f->stream_end;\n         f->eof = 1;\n         return 0;\n      } else {\n         f->stream = f->stream_start + loc;\n         return 1;\n      }\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (loc + f->f_start < loc || loc >= 0x80000000) {\n      loc = 0x7fffffff;\n      f->eof = 1;\n   } else {\n      loc += f->f_start;\n   }\n   if (!fseek(f->f, loc, SEEK_SET))\n      return 1;\n   f->eof = 1;\n   fseek(f->f, f->f_start, SEEK_END);\n   return 0;\n   #endif\n}\n\n\nstatic uint8 ogg_page_header[4] = { 0x4f, 0x67, 0x67, 0x53 };\n\nstatic int capture_pattern(vorb *f)\n{\n   if (0x4f != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x53 != get8(f)) return FALSE;\n   return TRUE;\n}\n\n#define PAGEFLAG_continued_packet   1\n#define PAGEFLAG_first_page         2\n#define PAGEFLAG_last_page          4\n\nstatic int start_page_no_capturepattern(vorb *f)\n{\n   uint32 loc0,loc1,n;\n   // stream structure version\n   if (0 != get8(f)) return error(f, VORBIS_invalid_stream_structure_version);\n   // header flag\n   f->page_flag = get8(f);\n   // absolute granule position\n   loc0 = get32(f); \n   loc1 = get32(f);\n   // @TODO: validate loc0,loc1 as valid positions?\n   // stream serial number -- vorbis doesn't interleave, so discard\n   get32(f);\n   //if (f->serial != get32(f)) return error(f, VORBIS_incorrect_stream_serial_number);\n   // page sequence number\n   n = get32(f);\n   f->last_page = n;\n   // CRC32\n   get32(f);\n   // page_segments\n   f->segment_count = get8(f);\n   if (!getn(f, f->segments, f->segment_count))\n      return error(f, VORBIS_unexpected_eof);\n   // assume we _don't_ know any the sample position of any segments\n   f->end_seg_with_known_loc = -2;\n   if (loc0 != ~0U || loc1 != ~0U) {\n      int i;\n      // determine which packet is the last one that will complete\n      for (i=f->segment_count-1; i >= 0; --i)\n         if (f->segments[i] < 255)\n            break;\n      // 'i' is now the index of the _last_ segment of a packet that ends\n      if (i >= 0) {\n         f->end_seg_with_known_loc = i;\n         f->known_loc_for_packet   = loc0;\n      }\n   }\n   if (f->first_decode) {\n      int i,len;\n      ProbedPage p;\n      len = 0;\n      for (i=0; i < f->segment_count; ++i)\n         len += f->segments[i];\n      len += 27 + f->segment_count;\n      p.page_start = f->first_audio_page_offset;\n      p.page_end = p.page_start + len;\n      p.last_decoded_sample = loc0;\n      f->p_first = p;\n   }\n   f->next_seg = 0;\n   return TRUE;\n}\n\nstatic int start_page(vorb *f)\n{\n   if (!capture_pattern(f)) return error(f, VORBIS_missing_capture_pattern);\n   return start_page_no_capturepattern(f);\n}\n\nstatic int start_packet(vorb *f)\n{\n   while (f->next_seg == -1) {\n      if (!start_page(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet)\n         return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   // f->next_seg is now valid\n   return TRUE;\n}\n\nstatic int maybe_start_packet(vorb *f)\n{\n   if (f->next_seg == -1) {\n      int x = get8(f);\n      if (f->eof) return FALSE; // EOF at page boundary is not an error!\n      if (0x4f != x      ) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x53 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (!start_page_no_capturepattern(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet) {\n         // set up enough state that we can read this packet if we want,\n         // e.g. during recovery\n         f->last_seg = FALSE;\n         f->bytes_in_seg = 0;\n         return error(f, VORBIS_continued_packet_flag_invalid);\n      }\n   }\n   return start_packet(f);\n}\n\nstatic int next_segment(vorb *f)\n{\n   int len;\n   if (f->last_seg) return 0;\n   if (f->next_seg == -1) {\n      f->last_seg_which = f->segment_count-1; // in case start_page fails\n      if (!start_page(f)) { f->last_seg = 1; return 0; }\n      if (!(f->page_flag & PAGEFLAG_continued_packet)) return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   len = f->segments[f->next_seg++];\n   if (len < 255) {\n      f->last_seg = TRUE;\n      f->last_seg_which = f->next_seg-1;\n   }\n   if (f->next_seg >= f->segment_count)\n      f->next_seg = -1;\n   assert(f->bytes_in_seg == 0);\n   f->bytes_in_seg = len;\n   return len;\n}\n\n#define EOP    (-1)\n#define INVALID_BITS  (-1)\n\nstatic int get8_packet_raw(vorb *f)\n{\n   if (!f->bytes_in_seg) {  // CLANG!\n      if (f->last_seg) return EOP;\n      else if (!next_segment(f)) return EOP;\n   }\n   assert(f->bytes_in_seg > 0);\n   --f->bytes_in_seg;\n   ++f->packet_bytes;\n   return get8(f);\n}\n\nstatic int get8_packet(vorb *f)\n{\n   int x = get8_packet_raw(f);\n   f->valid_bits = 0;\n   return x;\n}\n\nstatic void flush_packet(vorb *f)\n{\n   while (get8_packet_raw(f) != EOP);\n}\n\n// @OPTIMIZE: this is the secondary bit decoder, so it's probably not as important\n// as the huffman decoder?\nstatic uint32 get_bits(vorb *f, int n)\n{\n   uint32 z;\n\n   if (f->valid_bits < 0) return 0;\n   if (f->valid_bits < n) {\n      if (n > 24) {\n         // the accumulator technique below would not work correctly in this case\n         z = get_bits(f, 24);\n         z += get_bits(f, n-24) << 24;\n         return z;\n      }\n      if (f->valid_bits == 0) f->acc = 0;\n      while (f->valid_bits < n) {\n         int z = get8_packet_raw(f);\n         if (z == EOP) {\n            f->valid_bits = INVALID_BITS;\n            return 0;\n         }\n         f->acc += z << f->valid_bits;\n         f->valid_bits += 8;\n      }\n   }\n   if (f->valid_bits < 0) return 0;\n   z = f->acc & ((1 << n)-1);\n   f->acc >>= n;\n   f->valid_bits -= n;\n   return z;\n}\n\n// @OPTIMIZE: primary accumulator for huffman\n// expand the buffer to as many bits as possible without reading off end of packet\n// it might be nice to allow f->valid_bits and f->acc to be stored in registers,\n// e.g. cache them locally and decode locally\nstatic __forceinline void prep_huffman(vorb *f)\n{\n   if (f->valid_bits <= 24) {\n      if (f->valid_bits == 0) f->acc = 0;\n      do {\n         int z;\n         if (f->last_seg && !f->bytes_in_seg) return;\n         z = get8_packet_raw(f);\n         if (z == EOP) return;\n         f->acc += (unsigned) z << f->valid_bits;\n         f->valid_bits += 8;\n      } while (f->valid_bits <= 24);\n   }\n}\n\nenum\n{\n   VORBIS_packet_id = 1,\n   VORBIS_packet_comment = 3,\n   VORBIS_packet_setup = 5\n};\n\nstatic int codebook_decode_scalar_raw(vorb *f, Codebook *c)\n{\n   int i;\n   prep_huffman(f);\n\n   if (c->codewords == NULL && c->sorted_codewords == NULL)\n      return -1;\n\n   // cases to use binary search: sorted_codewords && !c->codewords\n   //                             sorted_codewords && c->entries > 8\n   if (c->entries > 8 ? c->sorted_codewords!=NULL : !c->codewords) {\n      // binary search\n      uint32 code = bit_reverse(f->acc);\n      int x=0, n=c->sorted_entries, len;\n\n      while (n > 1) {\n         // invariant: sc[x] <= code < sc[x+n]\n         int m = x + (n >> 1);\n         if (c->sorted_codewords[m] <= code) {\n            x = m;\n            n -= (n>>1);\n         } else {\n            n >>= 1;\n         }\n      }\n      // x is now the sorted index\n      if (!c->sparse) x = c->sorted_values[x];\n      // x is now sorted index if sparse, or symbol otherwise\n      len = c->codeword_lengths[x];\n      if (f->valid_bits >= len) {\n         f->acc >>= len;\n         f->valid_bits -= len;\n         return x;\n      }\n\n      f->valid_bits = 0;\n      return -1;\n   }\n\n   // if small, linear search\n   assert(!c->sparse);\n   for (i=0; i < c->entries; ++i) {\n      if (c->codeword_lengths[i] == NO_CODE) continue;\n      if (c->codewords[i] == (f->acc & ((1 << c->codeword_lengths[i])-1))) {\n         if (f->valid_bits >= c->codeword_lengths[i]) {\n            f->acc >>= c->codeword_lengths[i];\n            f->valid_bits -= c->codeword_lengths[i];\n            return i;\n         }\n         f->valid_bits = 0;\n         return -1;\n      }\n   }\n\n   error(f, VORBIS_invalid_stream);\n   f->valid_bits = 0;\n   return -1;\n}\n\n#ifndef STB_VORBIS_NO_INLINE_DECODE\n\n#define DECODE_RAW(var, f,c)                                  \\\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)        \\\n      prep_huffman(f);                                        \\\n   var = f->acc & FAST_HUFFMAN_TABLE_MASK;                    \\\n   var = c->fast_huffman[var];                                \\\n   if (var >= 0) {                                            \\\n      int n = c->codeword_lengths[var];                       \\\n      f->acc >>= n;                                           \\\n      f->valid_bits -= n;                                     \\\n      if (f->valid_bits < 0) { f->valid_bits = 0; var = -1; } \\\n   } else {                                                   \\\n      var = codebook_decode_scalar_raw(f,c);                  \\\n   }\n\n#else\n\nstatic int codebook_decode_scalar(vorb *f, Codebook *c)\n{\n   int i;\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)\n      prep_huffman(f);\n   // fast huffman table lookup\n   i = f->acc & FAST_HUFFMAN_TABLE_MASK;\n   i = c->fast_huffman[i];\n   if (i >= 0) {\n      f->acc >>= c->codeword_lengths[i];\n      f->valid_bits -= c->codeword_lengths[i];\n      if (f->valid_bits < 0) { f->valid_bits = 0; return -1; }\n      return i;\n   }\n   return codebook_decode_scalar_raw(f,c);\n}\n\n#define DECODE_RAW(var,f,c)    var = codebook_decode_scalar(f,c);\n\n#endif\n\n#define DECODE(var,f,c)                                       \\\n   DECODE_RAW(var,f,c)                                        \\\n   if (c->sparse) var = c->sorted_values[var];\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n  #define DECODE_VQ(var,f,c)   DECODE_RAW(var,f,c)\n#else\n  #define DECODE_VQ(var,f,c)   DECODE(var,f,c)\n#endif\n\n\n\n\n\n\n// CODEBOOK_ELEMENT_FAST is an optimization for the CODEBOOK_FLOATS case\n// where we avoid one addition\n#define CODEBOOK_ELEMENT(c,off)          (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_FAST(c,off)     (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_BASE(c)         (0)\n\nstatic int codebook_decode_start(vorb *f, Codebook *c)\n{\n   int z = -1;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)\n      error(f, VORBIS_invalid_stream);\n   else {\n      DECODE_VQ(z,f,c);\n      if (c->sparse) assert(z < c->sorted_entries);\n      if (z < 0) {  // check for EOP\n         if (!f->bytes_in_seg)\n            if (f->last_seg)\n               return z;\n         error(f, VORBIS_invalid_stream);\n      }\n   }\n   return z;\n}\n\nstatic int codebook_decode(vorb *f, Codebook *c, float *output, int len)\n{\n   int i,z = codebook_decode_start(f,c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i] += val;\n         if (c->sequence_p) last = val + c->minimum_value;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   if (c->sequence_p) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n         output[i] += val;\n         last = val + c->minimum_value;\n      }\n   } else {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         output[i] += CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      }\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_step(vorb *f, Codebook *c, float *output, int len, int step)\n{\n   int i,z = codebook_decode_start(f,c);\n   float last = CODEBOOK_ELEMENT_BASE(c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i*step] += val;\n         if (c->sequence_p) last = val;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   for (i=0; i < len; ++i) {\n      float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      output[i*step] += val;\n      if (c->sequence_p) last = val;\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_deinterleave_repeat(vorb *f, Codebook *c, float **outputs, int ch, int *c_inter_p, int *p_inter_p, int len, int total_decode)\n{\n   int c_inter = *c_inter_p;\n   int p_inter = *p_inter_p;\n   int i,z, effective = c->dimensions;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)   return error(f, VORBIS_invalid_stream);\n\n   while (total_decode > 0) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      DECODE_VQ(z,f,c);\n      #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      assert(!c->sparse || z < c->sorted_entries);\n      #endif\n      if (z < 0) {\n         if (!f->bytes_in_seg)\n            if (f->last_seg) return FALSE;\n         return error(f, VORBIS_invalid_stream);\n      }\n\n      // if this will take us off the end of the buffers, stop short!\n      // we check by computing the length of the virtual interleaved\n      // buffer (len*ch), our current offset within it (p_inter*ch)+(c_inter),\n      // and the length we'll be using (effective)\n      if (c_inter + p_inter*ch + effective > len * ch) {\n         effective = len*ch - (p_inter*ch - c_inter);\n      }\n\n   #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      if (c->lookup_type == 1) {\n         int div = 1;\n         for (i=0; i < effective; ++i) {\n            int off = (z / div) % c->lookup_values;\n            float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n            if (outputs[c_inter])\n               outputs[c_inter][p_inter] += val;\n            if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            if (c->sequence_p) last = val;\n            div *= c->lookup_values;\n         }\n      } else\n   #endif\n      {\n         z *= c->dimensions;\n         if (c->sequence_p) {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n               last = val;\n            }\n         } else {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            }\n         }\n      }\n\n      total_decode -= effective;\n   }\n   *c_inter_p = c_inter;\n   *p_inter_p = p_inter;\n   return TRUE;\n}\n\nstatic int predict_point(int x, int x0, int x1, int y0, int y1)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   // @OPTIMIZE: force int division to round in the right direction... is this necessary on x86?\n   int err = abs(dy) * (x - x0);\n   int off = err / adx;\n   return dy < 0 ? y0 - off : y0 + off;\n}\n\n// the following table is block-copied from the specification\nstatic float inverse_db_table[256] =\n{\n  1.0649863e-07f, 1.1341951e-07f, 1.2079015e-07f, 1.2863978e-07f, \n  1.3699951e-07f, 1.4590251e-07f, 1.5538408e-07f, 1.6548181e-07f, \n  1.7623575e-07f, 1.8768855e-07f, 1.9988561e-07f, 2.1287530e-07f, \n  2.2670913e-07f, 2.4144197e-07f, 2.5713223e-07f, 2.7384213e-07f, \n  2.9163793e-07f, 3.1059021e-07f, 3.3077411e-07f, 3.5226968e-07f, \n  3.7516214e-07f, 3.9954229e-07f, 4.2550680e-07f, 4.5315863e-07f, \n  4.8260743e-07f, 5.1396998e-07f, 5.4737065e-07f, 5.8294187e-07f, \n  6.2082472e-07f, 6.6116941e-07f, 7.0413592e-07f, 7.4989464e-07f, \n  7.9862701e-07f, 8.5052630e-07f, 9.0579828e-07f, 9.6466216e-07f, \n  1.0273513e-06f, 1.0941144e-06f, 1.1652161e-06f, 1.2409384e-06f, \n  1.3215816e-06f, 1.4074654e-06f, 1.4989305e-06f, 1.5963394e-06f, \n  1.7000785e-06f, 1.8105592e-06f, 1.9282195e-06f, 2.0535261e-06f, \n  2.1869758e-06f, 2.3290978e-06f, 2.4804557e-06f, 2.6416497e-06f, \n  2.8133190e-06f, 2.9961443e-06f, 3.1908506e-06f, 3.3982101e-06f, \n  3.6190449e-06f, 3.8542308e-06f, 4.1047004e-06f, 4.3714470e-06f, \n  4.6555282e-06f, 4.9580707e-06f, 5.2802740e-06f, 5.6234160e-06f, \n  5.9888572e-06f, 6.3780469e-06f, 6.7925283e-06f, 7.2339451e-06f, \n  7.7040476e-06f, 8.2047000e-06f, 8.7378876e-06f, 9.3057248e-06f, \n  9.9104632e-06f, 1.0554501e-05f, 1.1240392e-05f, 1.1970856e-05f, \n  1.2748789e-05f, 1.3577278e-05f, 1.4459606e-05f, 1.5399272e-05f, \n  1.6400004e-05f, 1.7465768e-05f, 1.8600792e-05f, 1.9809576e-05f, \n  2.1096914e-05f, 2.2467911e-05f, 2.3928002e-05f, 2.5482978e-05f, \n  2.7139006e-05f, 2.8902651e-05f, 3.0780908e-05f, 3.2781225e-05f, \n  3.4911534e-05f, 3.7180282e-05f, 3.9596466e-05f, 4.2169667e-05f, \n  4.4910090e-05f, 4.7828601e-05f, 5.0936773e-05f, 5.4246931e-05f, \n  5.7772202e-05f, 6.1526565e-05f, 6.5524908e-05f, 6.9783085e-05f, \n  7.4317983e-05f, 7.9147585e-05f, 8.4291040e-05f, 8.9768747e-05f, \n  9.5602426e-05f, 0.00010181521f, 0.00010843174f, 0.00011547824f, \n  0.00012298267f, 0.00013097477f, 0.00013948625f, 0.00014855085f, \n  0.00015820453f, 0.00016848555f, 0.00017943469f, 0.00019109536f, \n  0.00020351382f, 0.00021673929f, 0.00023082423f, 0.00024582449f, \n  0.00026179955f, 0.00027881276f, 0.00029693158f, 0.00031622787f, \n  0.00033677814f, 0.00035866388f, 0.00038197188f, 0.00040679456f, \n  0.00043323036f, 0.00046138411f, 0.00049136745f, 0.00052329927f, \n  0.00055730621f, 0.00059352311f, 0.00063209358f, 0.00067317058f, \n  0.00071691700f, 0.00076350630f, 0.00081312324f, 0.00086596457f, \n  0.00092223983f, 0.00098217216f, 0.0010459992f,  0.0011139742f, \n  0.0011863665f,  0.0012634633f,  0.0013455702f,  0.0014330129f, \n  0.0015261382f,  0.0016253153f,  0.0017309374f,  0.0018434235f, \n  0.0019632195f,  0.0020908006f,  0.0022266726f,  0.0023713743f, \n  0.0025254795f,  0.0026895994f,  0.0028643847f,  0.0030505286f, \n  0.0032487691f,  0.0034598925f,  0.0036847358f,  0.0039241906f, \n  0.0041792066f,  0.0044507950f,  0.0047400328f,  0.0050480668f, \n  0.0053761186f,  0.0057254891f,  0.0060975636f,  0.0064938176f, \n  0.0069158225f,  0.0073652516f,  0.0078438871f,  0.0083536271f, \n  0.0088964928f,  0.009474637f,   0.010090352f,   0.010746080f, \n  0.011444421f,   0.012188144f,   0.012980198f,   0.013823725f, \n  0.014722068f,   0.015678791f,   0.016697687f,   0.017782797f, \n  0.018938423f,   0.020169149f,   0.021479854f,   0.022875735f, \n  0.024362330f,   0.025945531f,   0.027631618f,   0.029427276f, \n  0.031339626f,   0.033376252f,   0.035545228f,   0.037855157f, \n  0.040315199f,   0.042935108f,   0.045725273f,   0.048696758f, \n  0.051861348f,   0.055231591f,   0.058820850f,   0.062643361f, \n  0.066714279f,   0.071049749f,   0.075666962f,   0.080584227f, \n  0.085821044f,   0.091398179f,   0.097337747f,   0.10366330f, \n  0.11039993f,    0.11757434f,    0.12521498f,    0.13335215f, \n  0.14201813f,    0.15124727f,    0.16107617f,    0.17154380f, \n  0.18269168f,    0.19456402f,    0.20720788f,    0.22067342f, \n  0.23501402f,    0.25028656f,    0.26655159f,    0.28387361f, \n  0.30232132f,    0.32196786f,    0.34289114f,    0.36517414f, \n  0.38890521f,    0.41417847f,    0.44109412f,    0.46975890f, \n  0.50028648f,    0.53279791f,    0.56742212f,    0.60429640f, \n  0.64356699f,    0.68538959f,    0.72993007f,    0.77736504f, \n  0.82788260f,    0.88168307f,    0.9389798f,     1.0f\n};\n\n\n// @OPTIMIZE: if you want to replace this bresenham line-drawing routine,\n// note that you must produce bit-identical output to decode correctly;\n// this specific sequence of operations is specified in the spec (it's\n// drawing integer-quantized frequency-space lines that the encoder\n// expects to be exactly the same)\n//     ... also, isn't the whole point of Bresenham's algorithm to NOT\n// have to divide in the setup? sigh.\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n#define LINE_OP(a,b)   a *= b\n#else\n#define LINE_OP(a,b)   a = b\n#endif\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n#define DIVTAB_NUMER   32\n#define DIVTAB_DENOM   64\nint8 integer_divide_table[DIVTAB_NUMER][DIVTAB_DENOM]; // 2KB\n#endif\n\nstatic __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n   ady -= abs(base) * adx;\n   if (x1 > n) x1 = n;\n   if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y]);\n      for (++x; x < x1; ++x) {\n         err += ady;\n         if (err >= adx) {\n            err -= adx;\n            y += sy;\n         } else\n            y += base;\n         LINE_OP(output[x], inverse_db_table[y]);\n      }\n   }\n}\n\nstatic int residue_decode(vorb *f, Codebook *book, float *target, int offset, int n, int rtype)\n{\n   int k;\n   if (rtype == 0) {\n      int step = n / book->dimensions;\n      for (k=0; k < step; ++k)\n         if (!codebook_decode_step(f, book, target+offset+k, n-offset-k, step))\n            return FALSE;\n   } else {\n      for (k=0; k < n; ) {\n         if (!codebook_decode(f, book, target+offset, n-k))\n            return FALSE;\n         k += book->dimensions;\n         offset += book->dimensions;\n      }\n   }\n   return TRUE;\n}\n\n// n is 1/2 of the blocksize --\n// specification: \"Correct per-vector decode length is [n]/2\"\nstatic void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)\n{\n   int i,j,pass;\n   Residue *r = f->residue_config + rn;\n   int rtype = f->residue_types[rn];\n   int c = r->classbook;\n   int classwords = f->codebooks[c].dimensions;\n   unsigned int actual_size = rtype == 2 ? n*2 : n;\n   unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);\n   unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);\n   int n_read = limit_r_end - limit_r_begin;\n   int part_read = n_read / r->part_size;\n   int temp_alloc_point = temp_alloc_save(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f->channels, part_read * sizeof(**part_classdata));\n   #else\n   int **classifications = (int **) temp_block_array(f,f->channels, part_read * sizeof(**classifications));\n   #endif\n\n   CHECK(f);\n\n   for (i=0; i < ch; ++i)\n      if (!do_not_decode[i])\n         memset(residue_buffers[i], 0, sizeof(float) * n);\n\n   if (rtype == 2 && ch != 1) {\n      for (j=0; j < ch; ++j)\n         if (!do_not_decode[j])\n            break;\n      if (j == ch)\n         goto done;\n\n      for (pass=0; pass < 8; ++pass) {\n         int pcount = 0, class_set = 0;\n         if (ch == 2) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = (z & 1), p_inter = z>>1;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #else\n                     // saves 1%\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #endif\n                  } else {\n                     z += r->part_size;\n                     c_inter = z & 1;\n                     p_inter = z >> 1;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         } else if (ch == 1) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = 0, p_inter = z;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                  } else {\n                     z += r->part_size;\n                     c_inter = 0;\n                     p_inter = z;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         } else {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = z % ch, p_inter = z/ch;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                  } else {\n                     z += r->part_size;\n                     c_inter = z % ch;\n                     p_inter = z / ch;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         }\n      }\n      goto done;\n   }\n   CHECK(f);\n\n   for (pass=0; pass < 8; ++pass) {\n      int pcount = 0, class_set=0;\n      while (pcount < part_read) {\n         if (pass == 0) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int temp;\n                  DECODE(temp,f,c);\n                  if (temp == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[j][class_set] = r->classdata[temp];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[j][i+pcount] = temp % r->classifications;\n                     temp /= r->classifications;\n                  }\n                  #endif\n               }\n            }\n         }\n         for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[j][class_set][i];\n                  #else\n                  int c = classifications[j][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     float *target = residue_buffers[j];\n                     int offset = r->begin + pcount * r->part_size;\n                     int n = r->part_size;\n                     Codebook *book = f->codebooks + b;\n                     if (!residue_decode(f, book, target, offset, n, rtype))\n                        goto done;\n                  }\n               }\n            }\n         }\n         #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n         ++class_set;\n         #endif\n      }\n   }\n  done:\n   CHECK(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   temp_free(f,part_classdata);\n   #else\n   temp_free(f,classifications);\n   #endif\n   temp_alloc_restore(f,temp_alloc_point);\n}\n\n\n#if 0\n// slow way for debugging\nvoid inverse_mdct_slow(float *buffer, int n)\n{\n   int i,j;\n   int n2 = n >> 1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         // formula from paper:\n         //acc += n/4.0f * x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n         // formula from wikipedia\n         //acc += 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         // these are equivalent, except the formula from the paper inverts the multiplier!\n         // however, what actually works is NO MULTIPLIER!?!\n         //acc += 64 * 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         acc += x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// same as above, but just barely able to run in real time on modern machines\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   float mcos[16384];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 2) -1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < 4*n; ++i)\n      mcos[i] = (float) cos(M_PI / 2 * i / n);\n\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         acc += x[j] * mcos[(2 * i + 1 + n2)*(2*j+1) & nmask];\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// transform to use a slow dct-iv; this is STILL basically trivial,\n// but only requires half as many ops\nvoid dct_iv_slow(float *buffer, int n)\n{\n   float mcos[16384];\n   float x[2048];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 3) - 1;\n   memcpy(x, buffer, sizeof(*x) * n);\n   for (i=0; i < 8*n; ++i)\n      mcos[i] = (float) cos(M_PI / 4 * i / n);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n; ++j)\n         acc += x[j] * mcos[((2 * i + 1)*(2*j+1)) & nmask];\n      buffer[i] = acc;\n   }\n}\n\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   int i, n4 = n >> 2, n2 = n >> 1, n3_4 = n - n4;\n   float temp[4096];\n\n   memcpy(temp, buffer, n2 * sizeof(float));\n   dct_iv_slow(temp, n2);  // returns -c'-d, a-b'\n\n   for (i=0; i < n4  ; ++i) buffer[i] = temp[i+n4];            // a-b'\n   for (   ; i < n3_4; ++i) buffer[i] = -temp[n3_4 - i - 1];   // b-a', c+d'\n   for (   ; i < n   ; ++i) buffer[i] = -temp[i - n3_4];       // c'+d\n}\n#endif\n\n#ifndef LIBVORBIS_MDCT\n#define LIBVORBIS_MDCT 0\n#endif\n\n#if LIBVORBIS_MDCT\n// directly call the vorbis MDCT using an interface documented\n// by Jeff Roberts... useful for performance comparison\ntypedef struct \n{\n  int n;\n  int log2n;\n  \n  float *trig;\n  int   *bitrev;\n\n  float scale;\n} mdct_lookup;\n\nextern void mdct_init(mdct_lookup *lookup, int n);\nextern void mdct_clear(mdct_lookup *l);\nextern void mdct_backward(mdct_lookup *init, float *in, float *out);\n\nmdct_lookup M1,M2;\n\nvoid inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   mdct_lookup *M;\n   if (M1.n == n) M = &M1;\n   else if (M2.n == n) M = &M2;\n   else if (M1.n == 0) { mdct_init(&M1, n); M = &M1; }\n   else { \n      if (M2.n) __asm int 3;\n      mdct_init(&M2, n);\n      M = &M2;\n   }\n\n   mdct_backward(M, buffer, buffer);\n}\n#endif\n\n\n// the following were split out into separate functions while optimizing;\n// they could be pushed back up but eh. __forceinline showed no change;\n// they're probably already being inlined.\nstatic void imdct_step3_iter0_loop(int n, float *e, int i_off, int k_off, float *A)\n{\n   float *ee0 = e + i_off;\n   float *ee2 = ee0 + k_off;\n   int i;\n\n   assert((n & 3) == 0);\n   for (i=(n>>2); i > 0; --i) {\n      float k00_20, k01_21;\n      k00_20  = ee0[ 0] - ee2[ 0];\n      k01_21  = ee0[-1] - ee2[-1];\n      ee0[ 0] += ee2[ 0];//ee0[ 0] = ee0[ 0] + ee2[ 0];\n      ee0[-1] += ee2[-1];//ee0[-1] = ee0[-1] + ee2[-1];\n      ee2[ 0] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-1] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-2] - ee2[-2];\n      k01_21  = ee0[-3] - ee2[-3];\n      ee0[-2] += ee2[-2];//ee0[-2] = ee0[-2] + ee2[-2];\n      ee0[-3] += ee2[-3];//ee0[-3] = ee0[-3] + ee2[-3];\n      ee2[-2] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-3] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-4] - ee2[-4];\n      k01_21  = ee0[-5] - ee2[-5];\n      ee0[-4] += ee2[-4];//ee0[-4] = ee0[-4] + ee2[-4];\n      ee0[-5] += ee2[-5];//ee0[-5] = ee0[-5] + ee2[-5];\n      ee2[-4] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-5] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-6] - ee2[-6];\n      k01_21  = ee0[-7] - ee2[-7];\n      ee0[-6] += ee2[-6];//ee0[-6] = ee0[-6] + ee2[-6];\n      ee0[-7] += ee2[-7];//ee0[-7] = ee0[-7] + ee2[-7];\n      ee2[-6] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-7] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n      ee0 -= 8;\n      ee2 -= 8;\n   }\n}\n\nstatic void imdct_step3_inner_r_loop(int lim, float *e, int d0, int k_off, float *A, int k1)\n{\n   int i;\n   float k00_20, k01_21;\n\n   float *e0 = e + d0;\n   float *e2 = e0 + k_off;\n\n   for (i=lim >> 2; i > 0; --i) {\n      k00_20 = e0[-0] - e2[-0];\n      k01_21 = e0[-1] - e2[-1];\n      e0[-0] += e2[-0];//e0[-0] = e0[-0] + e2[-0];\n      e0[-1] += e2[-1];//e0[-1] = e0[-1] + e2[-1];\n      e2[-0] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-1] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-2] - e2[-2];\n      k01_21 = e0[-3] - e2[-3];\n      e0[-2] += e2[-2];//e0[-2] = e0[-2] + e2[-2];\n      e0[-3] += e2[-3];//e0[-3] = e0[-3] + e2[-3];\n      e2[-2] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-3] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-4] - e2[-4];\n      k01_21 = e0[-5] - e2[-5];\n      e0[-4] += e2[-4];//e0[-4] = e0[-4] + e2[-4];\n      e0[-5] += e2[-5];//e0[-5] = e0[-5] + e2[-5];\n      e2[-4] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-5] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-6] - e2[-6];\n      k01_21 = e0[-7] - e2[-7];\n      e0[-6] += e2[-6];//e0[-6] = e0[-6] + e2[-6];\n      e0[-7] += e2[-7];//e0[-7] = e0[-7] + e2[-7];\n      e2[-6] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-7] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      e0 -= 8;\n      e2 -= 8;\n\n      A += k1;\n   }\n}\n\nstatic void imdct_step3_inner_s_loop(int n, float *e, int i_off, int k_off, float *A, int a_off, int k0)\n{\n   int i;\n   float A0 = A[0];\n   float A1 = A[0+1];\n   float A2 = A[0+a_off];\n   float A3 = A[0+a_off+1];\n   float A4 = A[0+a_off*2+0];\n   float A5 = A[0+a_off*2+1];\n   float A6 = A[0+a_off*3+0];\n   float A7 = A[0+a_off*3+1];\n\n   float k00,k11;\n\n   float *ee0 = e  +i_off;\n   float *ee2 = ee0+k_off;\n\n   for (i=n; i > 0; --i) {\n      k00     = ee0[ 0] - ee2[ 0];\n      k11     = ee0[-1] - ee2[-1];\n      ee0[ 0] =  ee0[ 0] + ee2[ 0];\n      ee0[-1] =  ee0[-1] + ee2[-1];\n      ee2[ 0] = (k00) * A0 - (k11) * A1;\n      ee2[-1] = (k11) * A0 + (k00) * A1;\n\n      k00     = ee0[-2] - ee2[-2];\n      k11     = ee0[-3] - ee2[-3];\n      ee0[-2] =  ee0[-2] + ee2[-2];\n      ee0[-3] =  ee0[-3] + ee2[-3];\n      ee2[-2] = (k00) * A2 - (k11) * A3;\n      ee2[-3] = (k11) * A2 + (k00) * A3;\n\n      k00     = ee0[-4] - ee2[-4];\n      k11     = ee0[-5] - ee2[-5];\n      ee0[-4] =  ee0[-4] + ee2[-4];\n      ee0[-5] =  ee0[-5] + ee2[-5];\n      ee2[-4] = (k00) * A4 - (k11) * A5;\n      ee2[-5] = (k11) * A4 + (k00) * A5;\n\n      k00     = ee0[-6] - ee2[-6];\n      k11     = ee0[-7] - ee2[-7];\n      ee0[-6] =  ee0[-6] + ee2[-6];\n      ee0[-7] =  ee0[-7] + ee2[-7];\n      ee2[-6] = (k00) * A6 - (k11) * A7;\n      ee2[-7] = (k11) * A6 + (k00) * A7;\n\n      ee0 -= k0;\n      ee2 -= k0;\n   }\n}\n\nstatic __forceinline void iter_54(float *z)\n{\n   float k00,k11,k22,k33;\n   float y0,y1,y2,y3;\n\n   k00  = z[ 0] - z[-4];\n   y0   = z[ 0] + z[-4];\n   y2   = z[-2] + z[-6];\n   k22  = z[-2] - z[-6];\n\n   z[-0] = y0 + y2;      // z0 + z4 + z2 + z6\n   z[-2] = y0 - y2;      // z0 + z4 - z2 - z6\n\n   // done with y0,y2\n\n   k33  = z[-3] - z[-7];\n\n   z[-4] = k00 + k33;    // z0 - z4 + z3 - z7\n   z[-6] = k00 - k33;    // z0 - z4 - z3 + z7\n\n   // done with k33\n\n   k11  = z[-1] - z[-5];\n   y1   = z[-1] + z[-5];\n   y3   = z[-3] + z[-7];\n\n   z[-1] = y1 + y3;      // z1 + z5 + z3 + z7\n   z[-3] = y1 - y3;      // z1 + z5 - z3 - z7\n   z[-5] = k11 - k22;    // z1 - z5 + z2 - z6\n   z[-7] = k11 + k22;    // z1 - z5 - z2 + z6\n}\n\nstatic void imdct_step3_inner_s_loop_ld654(int n, float *e, int i_off, float *A, int base_n)\n{\n   int a_off = base_n >> 3;\n   float A2 = A[0+a_off];\n   float *z = e + i_off;\n   float *base = z - 16 * n;\n\n   while (z > base) {\n      float k00,k11;\n\n      k00   = z[-0] - z[-8];\n      k11   = z[-1] - z[-9];\n      z[-0] = z[-0] + z[-8];\n      z[-1] = z[-1] + z[-9];\n      z[-8] =  k00;\n      z[-9] =  k11 ;\n\n      k00    = z[ -2] - z[-10];\n      k11    = z[ -3] - z[-11];\n      z[ -2] = z[ -2] + z[-10];\n      z[ -3] = z[ -3] + z[-11];\n      z[-10] = (k00+k11) * A2;\n      z[-11] = (k11-k00) * A2;\n\n      k00    = z[-12] - z[ -4];  // reverse to avoid a unary negation\n      k11    = z[ -5] - z[-13];\n      z[ -4] = z[ -4] + z[-12];\n      z[ -5] = z[ -5] + z[-13];\n      z[-12] = k11;\n      z[-13] = k00;\n\n      k00    = z[-14] - z[ -6];  // reverse to avoid a unary negation\n      k11    = z[ -7] - z[-15];\n      z[ -6] = z[ -6] + z[-14];\n      z[ -7] = z[ -7] + z[-15];\n      z[-14] = (k00+k11) * A2;\n      z[-15] = (k00-k11) * A2;\n\n      iter_54(z);\n      iter_54(z-8);\n      z -= 16;\n   }\n}\n\nstatic void inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int ld;\n   // @OPTIMIZE: reduce register pressure by using fewer variables?\n   int save_point = temp_alloc_save(f);\n   float *buf2 = (float *) temp_alloc(f, n2 * sizeof(*buf2));\n   float *u=NULL,*v=NULL;\n   // twiddle factors\n   float *A = f->A[blocktype];\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // See notes about bugs in that paper in less-optimal implementation 'inverse_mdct_old' after this function.\n\n   // kernel from paper\n\n\n   // merged:\n   //   copy and reflect spectral data\n   //   step 0\n\n   // note that it turns out that the items added together during\n   // this step are, in fact, being added to themselves (as reflected\n   // by step 0). inexplicable inefficiency! this became obvious\n   // once I combined the passes.\n\n   // so there's a missing 'times 2' here (for adding X to itself).\n   // this propagates through linearly to the end, where the numbers\n   // are 1/2 too small, and need to be compensated for.\n\n   {\n      float *d,*e, *AA, *e_stop;\n      d = &buf2[n2-2];\n      AA = A;\n      e = &buffer[0];\n      e_stop = &buffer[n2];\n      while (e != e_stop) {\n         d[1] = (e[0] * AA[0] - e[2]*AA[1]);\n         d[0] = (e[0] * AA[1] + e[2]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e += 4;\n      }\n\n      e = &buffer[n2-3];\n      while (d >= buf2) {\n         d[1] = (-e[2] * AA[0] - -e[0]*AA[1]);\n         d[0] = (-e[2] * AA[1] + -e[0]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e -= 4;\n      }\n   }\n\n   // now we use symbolic names for these, so that we can\n   // possibly swap their meaning as we change which operations\n   // are in place\n\n   u = buffer;\n   v = buf2;\n\n   // step 2    (paper output is w, now u)\n   // this could be in place, but the data ends up in the wrong\n   // place... _somebody_'s got to swap it, so this is nominated\n   {\n      float *AA = &A[n2-8];\n      float *d0,*d1, *e0, *e1;\n\n      e0 = &v[n4];\n      e1 = &v[0];\n\n      d0 = &u[n4];\n      d1 = &u[0];\n\n      while (AA >= A) {\n         float v40_20, v41_21;\n\n         v41_21 = e0[1] - e1[1];\n         v40_20 = e0[0] - e1[0];\n         d0[1]  = e0[1] + e1[1];\n         d0[0]  = e0[0] + e1[0];\n         d1[1]  = v41_21*AA[4] - v40_20*AA[5];\n         d1[0]  = v40_20*AA[4] + v41_21*AA[5];\n\n         v41_21 = e0[3] - e1[3];\n         v40_20 = e0[2] - e1[2];\n         d0[3]  = e0[3] + e1[3];\n         d0[2]  = e0[2] + e1[2];\n         d1[3]  = v41_21*AA[0] - v40_20*AA[1];\n         d1[2]  = v40_20*AA[0] + v41_21*AA[1];\n\n         AA -= 8;\n\n         d0 += 4;\n         d1 += 4;\n         e0 += 4;\n         e1 += 4;\n      }\n   }\n\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n\n   // optimized step 3:\n\n   // the original step3 loop can be nested r inside s or s inside r;\n   // it's written originally as s inside r, but this is dumb when r\n   // iterates many times, and s few. So I have two copies of it and\n   // switch between them halfway.\n\n   // this is iteration 0 of step 3\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*0, -(n >> 3), A);\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*1, -(n >> 3), A);\n\n   // this is iteration 1 of step 3\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*0, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*1, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*2, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*3, -(n >> 4), A, 16);\n\n   l=2;\n   for (; l < (ld-3)>>1; ++l) {\n      int k0 = n >> (l+2), k0_2 = k0>>1;\n      int lim = 1 << (l+1);\n      int i;\n      for (i=0; i < lim; ++i)\n         imdct_step3_inner_r_loop(n >> (l+4), u, n2-1 - k0*i, -k0_2, A, 1 << (l+3));\n   }\n\n   for (; l < ld-6; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3), k0_2 = k0>>1;\n      int rlim = n >> (l+6), r;\n      int lim = 1 << (l+1);\n      int i_off;\n      float *A0 = A;\n      i_off = n2-1;\n      for (r=rlim; r > 0; --r) {\n         imdct_step3_inner_s_loop(lim, u, i_off, -k0_2, A0, k1, k0);\n         A0 += k1*4;\n         i_off -= 8;\n      }\n   }\n\n   // iterations with count:\n   //   ld-6,-5,-4 all interleaved together\n   //       the big win comes from getting rid of needless flops\n   //         due to the constants on pass 5 & 4 being all 1 and 0;\n   //       combining them to be simultaneous to improve cache made little difference\n   imdct_step3_inner_s_loop_ld654(n >> 5, u, n2-1, A, n);\n\n   // output is u\n\n   // step 4, 5, and 6\n   // cannot be in-place because of step 5\n   {\n      uint16 *bitrev = f->bit_reverse[blocktype];\n      // weirdly, I'd have thought reading sequentially and writing\n      // erratically would have been better than vice-versa, but in\n      // fact that's not what my testing showed. (That is, with\n      // j = bitreverse(i), do you read i and write j, or read j and write i.)\n\n      float *d0 = &v[n4-4];\n      float *d1 = &v[n2-4];\n      while (d0 >= v) {\n         int k4;\n\n         k4 = bitrev[0];\n         d1[3] = u[k4+0];\n         d1[2] = u[k4+1];\n         d0[3] = u[k4+2];\n         d0[2] = u[k4+3];\n\n         k4 = bitrev[1];\n         d1[1] = u[k4+0];\n         d1[0] = u[k4+1];\n         d0[1] = u[k4+2];\n         d0[0] = u[k4+3];\n         \n         d0 -= 4;\n         d1 -= 4;\n         bitrev += 2;\n      }\n   }\n   // (paper output is u, now v)\n\n\n   // data must be in buf2\n   assert(v == buf2);\n\n   // step 7   (paper output is v, now v)\n   // this is now in place\n   {\n      float *C = f->C[blocktype];\n      float *d, *e;\n\n      d = v;\n      e = v + n2 - 4;\n\n      while (d < e) {\n         float a02,a11,b0,b1,b2,b3;\n\n         a02 = d[0] - e[2];\n         a11 = d[1] + e[3];\n\n         b0 = C[1]*a02 + C[0]*a11;\n         b1 = C[1]*a11 - C[0]*a02;\n\n         b2 = d[0] + e[ 2];\n         b3 = d[1] - e[ 3];\n\n         d[0] = b2 + b0;\n         d[1] = b3 + b1;\n         e[2] = b2 - b0;\n         e[3] = b1 - b3;\n\n         a02 = d[2] - e[0];\n         a11 = d[3] + e[1];\n\n         b0 = C[3]*a02 + C[2]*a11;\n         b1 = C[3]*a11 - C[2]*a02;\n\n         b2 = d[2] + e[ 0];\n         b3 = d[3] - e[ 1];\n\n         d[2] = b2 + b0;\n         d[3] = b3 + b1;\n         e[0] = b2 - b0;\n         e[1] = b1 - b3;\n\n         C += 4;\n         d += 4;\n         e -= 4;\n      }\n   }\n\n   // data must be in buf2\n\n\n   // step 8+decode   (paper output is X, now buffer)\n   // this generates pairs of data a la 8 and pushes them directly through\n   // the decode kernel (pushing rather than pulling) to avoid having\n   // to make another pass later\n\n   // this cannot POSSIBLY be in place, so we refer to the buffers directly\n\n   {\n      float *d0,*d1,*d2,*d3;\n\n      float *B = f->B[blocktype] + n2 - 8;\n      float *e = buf2 + n2 - 8;\n      d0 = &buffer[0];\n      d1 = &buffer[n2-4];\n      d2 = &buffer[n2];\n      d3 = &buffer[n-4];\n      while (e >= v) {\n         float p0,p1,p2,p3;\n\n         p3 =  e[6]*B[7] - e[7]*B[6];\n         p2 = -e[6]*B[6] - e[7]*B[7]; \n\n         d0[0] =   p3;\n         d1[3] = - p3;\n         d2[0] =   p2;\n         d3[3] =   p2;\n\n         p1 =  e[4]*B[5] - e[5]*B[4];\n         p0 = -e[4]*B[4] - e[5]*B[5]; \n\n         d0[1] =   p1;\n         d1[2] = - p1;\n         d2[1] =   p0;\n         d3[2] =   p0;\n\n         p3 =  e[2]*B[3] - e[3]*B[2];\n         p2 = -e[2]*B[2] - e[3]*B[3]; \n\n         d0[2] =   p3;\n         d1[1] = - p3;\n         d2[2] =   p2;\n         d3[1] =   p2;\n\n         p1 =  e[0]*B[1] - e[1]*B[0];\n         p0 = -e[0]*B[0] - e[1]*B[1]; \n\n         d0[3] =   p1;\n         d1[0] = - p1;\n         d2[3] =   p0;\n         d3[0] =   p0;\n\n         B -= 8;\n         e -= 8;\n         d0 += 4;\n         d2 += 4;\n         d1 -= 4;\n         d3 -= 4;\n      }\n   }\n\n   temp_free(f,buf2);\n   temp_alloc_restore(f,save_point);\n}\n\n#if 0\n// this is the original version of the above code, if you want to optimize it from scratch\nvoid inverse_mdct_naive(float *buffer, int n)\n{\n   float s;\n   float A[1 << 12], B[1 << 12], C[1 << 11];\n   int i,k,k2,k4, n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int n3_4 = n - n4, ld;\n   // how can they claim this only uses N words?!\n   // oh, because they're only used sparsely, whoops\n   float u[1 << 13], X[1 << 13], v[1 << 13], w[1 << 13];\n   // set up twiddle factors\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2);\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2);\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // Note there are bugs in that pseudocode, presumably due to them attempting\n   // to rename the arrays nicely rather than representing the way their actual\n   // implementation bounces buffers back and forth. As a result, even in the\n   // \"some formulars corrected\" version, a direct implementation fails. These\n   // are noted below as \"paper bug\".\n\n   // copy and reflect spectral data\n   for (k=0; k < n2; ++k) u[k] = buffer[k];\n   for (   ; k < n ; ++k) u[k] = -buffer[n - k - 1];\n   // kernel from paper\n   // step 1\n   for (k=k2=k4=0; k < n4; k+=1, k2+=2, k4+=4) {\n      v[n-k4-1] = (u[k4] - u[n-k4-1]) * A[k2]   - (u[k4+2] - u[n-k4-3])*A[k2+1];\n      v[n-k4-3] = (u[k4] - u[n-k4-1]) * A[k2+1] + (u[k4+2] - u[n-k4-3])*A[k2];\n   }\n   // step 2\n   for (k=k4=0; k < n8; k+=1, k4+=4) {\n      w[n2+3+k4] = v[n2+3+k4] + v[k4+3];\n      w[n2+1+k4] = v[n2+1+k4] + v[k4+1];\n      w[k4+3]    = (v[n2+3+k4] - v[k4+3])*A[n2-4-k4] - (v[n2+1+k4]-v[k4+1])*A[n2-3-k4];\n      w[k4+1]    = (v[n2+1+k4] - v[k4+1])*A[n2-4-k4] + (v[n2+3+k4]-v[k4+3])*A[n2-3-k4];\n   }\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   for (l=0; l < ld-3; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3);\n      int rlim = n >> (l+4), r4, r;\n      int s2lim = 1 << (l+2), s2;\n      for (r=r4=0; r < rlim; r4+=4,++r) {\n         for (s2=0; s2 < s2lim; s2+=2) {\n            u[n-1-k0*s2-r4] = w[n-1-k0*s2-r4] + w[n-1-k0*(s2+1)-r4];\n            u[n-3-k0*s2-r4] = w[n-3-k0*s2-r4] + w[n-3-k0*(s2+1)-r4];\n            u[n-1-k0*(s2+1)-r4] = (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1]\n                                - (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1+1];\n            u[n-3-k0*(s2+1)-r4] = (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1]\n                                + (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1+1];\n         }\n      }\n      if (l+1 < ld-3) {\n         // paper bug: ping-ponging of u&w here is omitted\n         memcpy(w, u, sizeof(u));\n      }\n   }\n\n   // step 4\n   for (i=0; i < n8; ++i) {\n      int j = bit_reverse(i) >> (32-ld+3);\n      assert(j < n8);\n      if (i == j) {\n         // paper bug: original code probably swapped in place; if copying,\n         //            need to directly copy in this case\n         int i8 = i << 3;\n         v[i8+1] = u[i8+1];\n         v[i8+3] = u[i8+3];\n         v[i8+5] = u[i8+5];\n         v[i8+7] = u[i8+7];\n      } else if (i < j) {\n         int i8 = i << 3, j8 = j << 3;\n         v[j8+1] = u[i8+1], v[i8+1] = u[j8 + 1];\n         v[j8+3] = u[i8+3], v[i8+3] = u[j8 + 3];\n         v[j8+5] = u[i8+5], v[i8+5] = u[j8 + 5];\n         v[j8+7] = u[i8+7], v[i8+7] = u[j8 + 7];\n      }\n   }\n   // step 5\n   for (k=0; k < n2; ++k) {\n      w[k] = v[k*2+1];\n   }\n   // step 6\n   for (k=k2=k4=0; k < n8; ++k, k2 += 2, k4 += 4) {\n      u[n-1-k2] = w[k4];\n      u[n-2-k2] = w[k4+1];\n      u[n3_4 - 1 - k2] = w[k4+2];\n      u[n3_4 - 2 - k2] = w[k4+3];\n   }\n   // step 7\n   for (k=k2=0; k < n8; ++k, k2 += 2) {\n      v[n2 + k2 ] = ( u[n2 + k2] + u[n-2-k2] + C[k2+1]*(u[n2+k2]-u[n-2-k2]) + C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n-2 - k2] = ( u[n2 + k2] + u[n-2-k2] - C[k2+1]*(u[n2+k2]-u[n-2-k2]) - C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n2+1+ k2] = ( u[n2+1+k2] - u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n      v[n-1 - k2] = (-u[n2+1+k2] + u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n   }\n   // step 8\n   for (k=k2=0; k < n4; ++k,k2 += 2) {\n      X[k]      = v[k2+n2]*B[k2  ] + v[k2+1+n2]*B[k2+1];\n      X[n2-1-k] = v[k2+n2]*B[k2+1] - v[k2+1+n2]*B[k2  ];\n   }\n\n   // decode kernel to output\n   // determined the following value experimentally\n   // (by first figuring out what made inverse_mdct_slow work); then matching that here\n   // (probably vorbis encoder premultiplies by n or n/2, to save it on the decoder?)\n   s = 0.5; // theoretically would be n4\n\n   // [[[ note! the s value of 0.5 is compensated for by the B[] in the current code,\n   //     so it needs to use the \"old\" B values to behave correctly, or else\n   //     set s to 1.0 ]]]\n   for (i=0; i < n4  ; ++i) buffer[i] = s * X[i+n4];\n   for (   ; i < n3_4; ++i) buffer[i] = -s * X[n3_4 - i - 1];\n   for (   ; i < n   ; ++i) buffer[i] = -s * X[i - n3_4];\n}\n#endif\n\nstatic float *get_window(vorb *f, int len)\n{\n   len <<= 1;\n   if (len == f->blocksize_0) return f->window[0];\n   if (len == f->blocksize_1) return f->window[1];\n   assert(0);\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\ntypedef int16 YTYPE;\n#else\ntypedef int YTYPE;\n#endif\nstatic int do_floor(vorb *f, Mapping *map, int i, int n, float *target, YTYPE *finalY, uint8 *step2_flag)\n{\n   int n2 = n >> 1;\n   int s = map->chan[i].mux, floor;\n   floor = map->submap_floor[s];\n   if (f->floor_types[floor] == 0) {\n      return error(f, VORBIS_invalid_stream);\n   } else {\n      Floor1 *g = &f->floor_config[floor].floor1;\n      int j,q;\n      int lx = 0, ly = finalY[0] * g->floor1_multiplier;\n      for (q=1; q < g->values; ++q) {\n         j = g->sorted_order[q];\n         #ifndef STB_VORBIS_NO_DEFER_FLOOR\n         if (finalY[j] >= 0)\n         #else\n         if (step2_flag[j])\n         #endif\n         {\n            int hy = finalY[j] * g->floor1_multiplier;\n            int hx = g->Xlist[j];\n            if (lx != hx)\n               draw_line(target, lx,ly, hx,hy, n2);\n            CHECK(f);\n            lx = hx, ly = hy;\n         }\n      }\n      if (lx < n2) {\n         // optimization of: draw_line(target, lx,ly, n,ly, n2);\n         for (j=lx; j < n2; ++j)\n            LINE_OP(target[j], inverse_db_table[ly]);\n         CHECK(f);\n      }\n   }\n   return TRUE;\n}\n\n// The meaning of \"left\" and \"right\"\n//\n// For a given frame:\n//     we compute samples from 0..n\n//     window_center is n/2\n//     we'll window and mix the samples from left_start to left_end with data from the previous frame\n//     all of the samples from left_end to right_start can be output without mixing; however,\n//        this interval is 0-length except when transitioning between short and long frames\n//     all of the samples from right_start to right_end need to be mixed with the next frame,\n//        which we don't have, so those get saved in a buffer\n//     frame N's right_end-right_start, the number of samples to mix with the next frame,\n//        has to be the same as frame N+1's left_end-left_start (which they are by\n//        construction)\n\nstatic int vorbis_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   Mode *m;\n   int i, n, prev, next, window_center;\n   f->channel_buffer_start = f->channel_buffer_end = 0;\n\n  retry:\n   if (f->eof) return FALSE;\n   if (!maybe_start_packet(f))\n      return FALSE;\n   // check packet type\n   if (get_bits(f,1) != 0) {\n      if (IS_PUSH_MODE(f))\n         return error(f,VORBIS_bad_packet_type);\n      while (EOP != get8_packet(f));\n      goto retry;\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   i = get_bits(f, ilog(f->mode_count-1));\n   if (i == EOP) return FALSE;\n   if (i >= f->mode_count) return FALSE;\n   *mode = i;\n   m = f->mode_config + i;\n   if (m->blockflag) {\n      n = f->blocksize_1;\n      prev = get_bits(f,1);\n      next = get_bits(f,1);\n   } else {\n      prev = next = 0;\n      n = f->blocksize_0;\n   }\n\n// WINDOWING\n\n   window_center = n >> 1;\n   if (m->blockflag && !prev) {\n      *p_left_start = (n - f->blocksize_0) >> 2;\n      *p_left_end   = (n + f->blocksize_0) >> 2;\n   } else {\n      *p_left_start = 0;\n      *p_left_end   = window_center;\n   }\n   if (m->blockflag && !next) {\n      *p_right_start = (n*3 - f->blocksize_0) >> 2;\n      *p_right_end   = (n*3 + f->blocksize_0) >> 2;\n   } else {\n      *p_right_start = window_center;\n      *p_right_end   = n;\n   }\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet_rest(vorb *f, int *len, Mode *m, int left_start, int left_end, int right_start, int right_end, int *p_left)\n{\n   Mapping *map;\n   int i,j,k,n,n2;\n   int zero_channel[256];\n   int really_zero_channel[256];\n\n// WINDOWING\n\n   n = f->blocksize[m->blockflag];\n   map = &f->mapping[m->mapping];\n\n// FLOORS\n   n2 = n >> 1;\n\n   CHECK(f);\n\n   for (i=0; i < f->channels; ++i) {\n      int s = map->chan[i].mux, floor;\n      zero_channel[i] = FALSE;\n      floor = map->submap_floor[s];\n      if (f->floor_types[floor] == 0) {\n         return error(f, VORBIS_invalid_stream);\n      } else {\n         Floor1 *g = &f->floor_config[floor].floor1;\n         if (get_bits(f, 1)) {\n            short *finalY;\n            uint8 step2_flag[256];\n            static int range_list[4] = { 256, 128, 86, 64 };\n            int range = range_list[g->floor1_multiplier-1];\n            int offset = 2;\n            finalY = f->finalY[i];\n            finalY[0] = get_bits(f, ilog(range)-1);\n            finalY[1] = get_bits(f, ilog(range)-1);\n            for (j=0; j < g->partitions; ++j) {\n               int pclass = g->partition_class_list[j];\n               int cdim = g->class_dimensions[pclass];\n               int cbits = g->class_subclasses[pclass];\n               int csub = (1 << cbits)-1;\n               int cval = 0;\n               if (cbits) {\n                  Codebook *c = f->codebooks + g->class_masterbooks[pclass];\n                  DECODE(cval,f,c);\n               }\n               for (k=0; k < cdim; ++k) {\n                  int book = g->subclass_books[pclass][cval & csub];\n                  cval = cval >> cbits;\n                  if (book >= 0) {\n                     int temp;\n                     Codebook *c = f->codebooks + book;\n                     DECODE(temp,f,c);\n                     finalY[offset++] = temp;\n                  } else\n                     finalY[offset++] = 0;\n               }\n            }\n            if (f->valid_bits == INVALID_BITS) goto error; // behavior according to spec\n            step2_flag[0] = step2_flag[1] = 1;\n            for (j=2; j < g->values; ++j) {\n               int low, high, pred, highroom, lowroom, room, val;\n               low = g->neighbors[j][0];\n               high = g->neighbors[j][1];\n               //neighbors(g->Xlist, j, &low, &high);\n               pred = predict_point(g->Xlist[j], g->Xlist[low], g->Xlist[high], finalY[low], finalY[high]);\n               val = finalY[j];\n               highroom = range - pred;\n               lowroom = pred;\n               if (highroom < lowroom)\n                  room = highroom * 2;\n               else\n                  room = lowroom * 2;\n               if (val) {\n                  step2_flag[low] = step2_flag[high] = 1;\n                  step2_flag[j] = 1;\n                  if (val >= room)\n                     if (highroom > lowroom)\n                        finalY[j] = val - lowroom + pred;\n                     else\n                        finalY[j] = pred - val + highroom - 1;\n                  else\n                     if (val & 1)\n                        finalY[j] = pred - ((val+1)>>1);\n                     else\n                        finalY[j] = pred + (val>>1);\n               } else {\n                  step2_flag[j] = 0;\n                  finalY[j] = pred;\n               }\n            }\n\n#ifdef STB_VORBIS_NO_DEFER_FLOOR\n            do_floor(f, map, i, n, f->floor_buffers[i], finalY, step2_flag);\n#else\n            // defer final floor computation until _after_ residue\n            for (j=0; j < g->values; ++j) {\n               if (!step2_flag[j])\n                  finalY[j] = -1;\n            }\n#endif\n         } else {\n           error:\n            zero_channel[i] = TRUE;\n         }\n         // So we just defer everything else to later\n\n         // at this point we've decoded the floor into buffer\n      }\n   }\n   CHECK(f);\n   // at this point we've decoded all floors\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   // re-enable coupled channels if necessary\n   memcpy(really_zero_channel, zero_channel, sizeof(really_zero_channel[0]) * f->channels);\n   for (i=0; i < map->coupling_steps; ++i)\n      if (!zero_channel[map->chan[i].magnitude] || !zero_channel[map->chan[i].angle]) {\n         zero_channel[map->chan[i].magnitude] = zero_channel[map->chan[i].angle] = FALSE;\n      }\n\n   CHECK(f);\n// RESIDUE DECODE\n   for (i=0; i < map->submaps; ++i) {\n      float *residue_buffers[STB_VORBIS_MAX_CHANNELS];\n      int r;\n      uint8 do_not_decode[256];\n      int ch = 0;\n      for (j=0; j < f->channels; ++j) {\n         if (map->chan[j].mux == i) {\n            if (zero_channel[j]) {\n               do_not_decode[ch] = TRUE;\n               residue_buffers[ch] = NULL;\n            } else {\n               do_not_decode[ch] = FALSE;\n               residue_buffers[ch] = f->channel_buffers[j];\n            }\n            ++ch;\n         }\n      }\n      r = map->submap_residue[i];\n      decode_residue(f, residue_buffers, ch, n2, r, do_not_decode);\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   CHECK(f);\n\n// INVERSE COUPLING\n   for (i = map->coupling_steps-1; i >= 0; --i) {\n      int n2 = n >> 1;\n      float *m = f->channel_buffers[map->chan[i].magnitude];\n      float *a = f->channel_buffers[map->chan[i].angle    ];\n      for (j=0; j < n2; ++j) {\n         float a2,m2;\n         if (m[j] > 0)\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] - a[j];\n            else\n               a2 = m[j], m2 = m[j] + a[j];\n         else\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] + a[j];\n            else\n               a2 = m[j], m2 = m[j] - a[j];\n         m[j] = m2;\n         a[j] = a2;\n      }\n   }\n   CHECK(f);\n\n   // finish decoding the floors\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         do_floor(f, map, i, n, f->channel_buffers[i], f->finalY[i], NULL);\n      }\n   }\n#else\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         for (j=0; j < n2; ++j)\n            f->channel_buffers[i][j] *= f->floor_buffers[i][j];\n      }\n   }\n#endif\n\n// INVERSE MDCT\n   CHECK(f);\n   for (i=0; i < f->channels; ++i)\n      inverse_mdct(f->channel_buffers[i], n, f, m->blockflag);\n   CHECK(f);\n\n   // this shouldn't be necessary, unless we exited on an error\n   // and want to flush to get to the next packet\n   flush_packet(f);\n\n   if (f->first_decode) {\n      // assume we start so first non-discarded sample is sample 0\n      // this isn't to spec, but spec would require us to read ahead\n      // and decode the size of all current frames--could be done,\n      // but presumably it's not a commonly used feature\n      f->current_loc = -n2; // start of first frame is positioned for discard\n      // we might have to discard samples \"from\" the next frame too,\n      // if we're lapping a large block then a small at the start?\n      f->discard_samples_deferred = n - right_end;\n      f->current_loc_valid = TRUE;\n      f->first_decode = FALSE;\n   } else if (f->discard_samples_deferred) {\n      if (f->discard_samples_deferred >= right_start - left_start) {\n         f->discard_samples_deferred -= (right_start - left_start);\n         left_start = right_start;\n         *p_left = left_start;\n      } else {\n         left_start += f->discard_samples_deferred;\n         *p_left = left_start;\n         f->discard_samples_deferred = 0;\n      }\n   } else if (f->previous_length == 0 && f->current_loc_valid) {\n      // we're recovering from a seek... that means we're going to discard\n      // the samples from this packet even though we know our position from\n      // the last page header, so we need to update the position based on\n      // the discarded samples here\n      // but wait, the code below is going to add this in itself even\n      // on a discard, so we don't need to do it here...\n   }\n\n   // check if we have ogg information about the sample # for this packet\n   if (f->last_seg_which == f->end_seg_with_known_loc) {\n      // if we have a valid current loc, and this is final:\n      if (f->current_loc_valid && (f->page_flag & PAGEFLAG_last_page)) {\n         uint32 current_end = f->known_loc_for_packet;\n         // then let's infer the size of the (probably) short final frame\n         if (current_end < f->current_loc + (right_end-left_start)) {\n            if (current_end < f->current_loc) {\n               // negative truncation, that's impossible!\n               *len = 0;\n            } else {\n               *len = current_end - f->current_loc;\n            }\n            *len += left_start; // this doesn't seem right, but has no ill effect on my test files\n            if (*len > right_end) *len = right_end; // this should never happen\n            f->current_loc += *len;\n            return TRUE;\n         }\n      }\n      // otherwise, just set our sample loc\n      // guess that the ogg granule pos refers to the _middle_ of the\n      // last frame?\n      // set f->current_loc to the position of left_start\n      f->current_loc = f->known_loc_for_packet - (n2-left_start);\n      f->current_loc_valid = TRUE;\n   }\n   if (f->current_loc_valid)\n      f->current_loc += (right_start - left_start);\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   *len = right_end;  // ignore samples after the window goes to 0\n   CHECK(f);\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet(vorb *f, int *len, int *p_left, int *p_right)\n{\n   int mode, left_end, right_end;\n   if (!vorbis_decode_initial(f, p_left, &left_end, p_right, &right_end, &mode)) return 0;\n   return vorbis_decode_packet_rest(f, len, f->mode_config + mode, *p_left, left_end, *p_right, right_end, p_left);\n}\n\nstatic int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)\n{\n   int prev,i,j;\n   // we use right&left (the start of the right- and left-window sin()-regions)\n   // to determine how much to return, rather than inferring from the rules\n   // (same result, clearer code); 'left' indicates where our sin() window\n   // starts, therefore where the previous window's right edge starts, and\n   // therefore where to start mixing from the previous buffer. 'right'\n   // indicates where our sin() ending-window starts, therefore that's where\n   // we start saving, and where our returned-data ends.\n\n   // mixin from previous window\n   if (f->previous_length) {\n      int i,j, n = f->previous_length;\n      float *w = get_window(f, n);\n      for (i=0; i < f->channels; ++i) {\n         for (j=0; j < n; ++j)\n            f->channel_buffers[i][left+j] =\n               f->channel_buffers[i][left+j]*w[    j] +\n               f->previous_window[i][     j]*w[n-1-j];\n      }\n   }\n\n   prev = f->previous_length;\n\n   // last half of this data becomes previous window\n   f->previous_length = len - right;\n\n   // @OPTIMIZE: could avoid this copy by double-buffering the\n   // output (flipping previous_window with channel_buffers), but\n   // then previous_window would have to be 2x as large, and\n   // channel_buffers couldn't be temp mem (although they're NOT\n   // currently temp mem, they could be (unless we want to level\n   // performance by spreading out the computation))\n   for (i=0; i < f->channels; ++i)\n      for (j=0; right+j < len; ++j)\n         f->previous_window[i][j] = f->channel_buffers[i][right+j];\n\n   if (!prev)\n      // there was no previous packet, so this data isn't valid...\n      // this isn't entirely true, only the would-have-overlapped data\n      // isn't valid, but this seems to be what the spec requires\n      return 0;\n\n   // truncate a short frame\n   if (len < right) right = len;\n\n   f->samples_output += right-left;\n\n   return right - left;\n}\n\nstatic int vorbis_pump_first_frame(stb_vorbis *f)\n{\n   int len, right, left, res;\n   res = vorbis_decode_packet(f, &len, &left, &right);\n   if (res)\n      vorbis_finish_frame(f, len, left, right);\n   return res;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\nstatic int is_whole_packet_present(stb_vorbis *f, int end_page)\n{\n   // make sure that we have the packet available before continuing...\n   // this requires a full ogg parse, but we know we can fetch from f->stream\n\n   // instead of coding this out explicitly, we could save the current read state,\n   // read the next packet with get8() until end-of-packet, check f->eof, then\n   // reset the state? but that would be slower, esp. since we'd have over 256 bytes\n   // of state to restore (primarily the page segment table)\n\n   int s = f->next_seg, first = TRUE;\n   uint8 *p = f->stream;\n\n   if (s != -1) { // if we're not starting the packet with a 'continue on next page' flag\n      for (; s < f->segment_count; ++s) {\n         p += f->segments[s];\n         if (f->segments[s] < 255)               // stop at first short segment\n            break;\n      }\n      // either this continues, or it ends it...\n      if (end_page)\n         if (s < f->segment_count-1)             return error(f, VORBIS_invalid_stream);\n      if (s == f->segment_count)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   for (; s == -1;) {\n      uint8 *q; \n      int n;\n\n      // check that we have the page header ready\n      if (p + 26 >= f->stream_end)               return error(f, VORBIS_need_more_data);\n      // validate the page\n      if (memcmp(p, ogg_page_header, 4))         return error(f, VORBIS_invalid_stream);\n      if (p[4] != 0)                             return error(f, VORBIS_invalid_stream);\n      if (first) { // the first segment must NOT have 'continued_packet', later ones MUST\n         if (f->previous_length)\n            if ((p[5] & PAGEFLAG_continued_packet))  return error(f, VORBIS_invalid_stream);\n         // if no previous length, we're resynching, so we can come in on a continued-packet,\n         // which we'll just drop\n      } else {\n         if (!(p[5] & PAGEFLAG_continued_packet)) return error(f, VORBIS_invalid_stream);\n      }\n      n = p[26]; // segment counts\n      q = p+27;  // q points to segment table\n      p = q + n; // advance past header\n      // make sure we've read the segment table\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      for (s=0; s < n; ++s) {\n         p += q[s];\n         if (q[s] < 255)\n            break;\n      }\n      if (end_page)\n         if (s < n-1)                            return error(f, VORBIS_invalid_stream);\n      if (s == n)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   return TRUE;\n}\n#endif // !STB_VORBIS_NO_PUSHDATA_API\n\nstatic int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}\n\nstatic void vorbis_deinit(stb_vorbis *p)\n{\n   int i,j;\n   if (p->residue_config) {\n      for (i=0; i < p->residue_count; ++i) {\n         Residue *r = p->residue_config+i;\n         if (r->classdata) {\n            for (j=0; j < p->codebooks[r->classbook].entries; ++j)\n               setup_free(p, r->classdata[j]);\n            setup_free(p, r->classdata);\n         }\n         setup_free(p, r->residue_books);\n      }\n   }\n\n   if (p->codebooks) {\n      CHECK(p);\n      for (i=0; i < p->codebook_count; ++i) {\n         Codebook *c = p->codebooks + i;\n         setup_free(p, c->codeword_lengths);\n         setup_free(p, c->multiplicands);\n         setup_free(p, c->codewords);\n         setup_free(p, c->sorted_codewords);\n         // c->sorted_values[-1] is the first entry in the array\n         setup_free(p, c->sorted_values ? c->sorted_values-1 : NULL);\n      }\n      setup_free(p, p->codebooks);\n   }\n   setup_free(p, p->floor_config);\n   setup_free(p, p->residue_config);\n   if (p->mapping) {\n      for (i=0; i < p->mapping_count; ++i)\n         setup_free(p, p->mapping[i].chan);\n      setup_free(p, p->mapping);\n   }\n   CHECK(p);\n   for (i=0; i < p->channels && i < STB_VORBIS_MAX_CHANNELS; ++i) {\n      setup_free(p, p->channel_buffers[i]);\n      setup_free(p, p->previous_window[i]);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      setup_free(p, p->floor_buffers[i]);\n      #endif\n      setup_free(p, p->finalY[i]);\n   }\n   for (i=0; i < 2; ++i) {\n      setup_free(p, p->A[i]);\n      setup_free(p, p->B[i]);\n      setup_free(p, p->C[i]);\n      setup_free(p, p->window[i]);\n      setup_free(p, p->bit_reverse[i]);\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (p->close_on_free) fclose(p->f);\n   #endif\n}\n\nvoid stb_vorbis_close(stb_vorbis *p)\n{\n   if (p == NULL) return;\n   vorbis_deinit(p);\n   setup_free(p,p);\n}\n\nstatic void vorbis_init(stb_vorbis *p, const stb_vorbis_alloc *z)\n{\n   memset(p, 0, sizeof(*p)); // NULL out all malloc'd pointers to start\n   if (z) {\n      p->alloc = *z;\n      p->alloc.alloc_buffer_length_in_bytes = (p->alloc.alloc_buffer_length_in_bytes+3) & ~3;\n      p->temp_offset = p->alloc.alloc_buffer_length_in_bytes;\n   }\n   p->eof = 0;\n   p->error = VORBIS__no_error;\n   p->stream = NULL;\n   p->codebooks = NULL;\n   p->page_crc_tests = -1;\n   #ifndef STB_VORBIS_NO_STDIO\n   p->close_on_free = FALSE;\n   p->f = NULL;\n   #endif\n}\n\nint stb_vorbis_get_sample_offset(stb_vorbis *f)\n{\n   if (f->current_loc_valid)\n      return f->current_loc;\n   else\n      return -1;\n}\n\nstb_vorbis_info stb_vorbis_get_info(stb_vorbis *f)\n{\n   stb_vorbis_info d;\n   d.channels = f->channels;\n   d.sample_rate = f->sample_rate;\n   d.setup_memory_required = f->setup_memory_required;\n   d.setup_temp_memory_required = f->setup_temp_memory_required;\n   d.temp_memory_required = f->temp_memory_required;\n   d.max_frame_size = f->blocksize_1 >> 1;\n   return d;\n}\n\nint stb_vorbis_get_error(stb_vorbis *f)\n{\n   int e = f->error;\n   f->error = VORBIS__no_error;\n   return e;\n}\n\nstatic stb_vorbis * vorbis_alloc(stb_vorbis *f)\n{\n   stb_vorbis *p = (stb_vorbis *) setup_malloc(f, sizeof(*p));\n   return p;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\nvoid stb_vorbis_flush_pushdata(stb_vorbis *f)\n{\n   f->previous_length = 0;\n   f->page_crc_tests  = 0;\n   f->discard_samples_deferred = 0;\n   f->current_loc_valid = FALSE;\n   f->first_decode = FALSE;\n   f->samples_output = 0;\n   f->channel_buffer_start = 0;\n   f->channel_buffer_end = 0;\n}\n\nstatic int vorbis_search_for_page_pushdata(vorb *f, uint8 *data, int data_len)\n{\n   int i,n;\n   for (i=0; i < f->page_crc_tests; ++i)\n      f->scan[i].bytes_done = 0;\n\n   // if we have room for more scans, search for them first, because\n   // they may cause us to stop early if their header is incomplete\n   if (f->page_crc_tests < STB_VORBIS_PUSHDATA_CRC_COUNT) {\n      if (data_len < 4) return 0;\n      data_len -= 3; // need to look for 4-byte sequence, so don't miss\n                     // one that straddles a boundary\n      for (i=0; i < data_len; ++i) {\n         if (data[i] == 0x4f) {\n            if (0==memcmp(data+i, ogg_page_header, 4)) {\n               int j,len;\n               uint32 crc;\n               // make sure we have the whole page header\n               if (i+26 >= data_len || i+27+data[i+26] >= data_len) {\n                  // only read up to this page start, so hopefully we'll\n                  // have the whole page header start next time\n                  data_len = i;\n                  break;\n               }\n               // ok, we have it all; compute the length of the page\n               len = 27 + data[i+26];\n               for (j=0; j < data[i+26]; ++j)\n                  len += data[i+27+j];\n               // scan everything up to the embedded crc (which we must 0)\n               crc = 0;\n               for (j=0; j < 22; ++j)\n                  crc = crc32_update(crc, data[i+j]);\n               // now process 4 0-bytes\n               for (   ; j < 26; ++j)\n                  crc = crc32_update(crc, 0);\n               // len is the total number of bytes we need to scan\n               n = f->page_crc_tests++;\n               f->scan[n].bytes_left = len-j;\n               f->scan[n].crc_so_far = crc;\n               f->scan[n].goal_crc = data[i+22] + (data[i+23] << 8) + (data[i+24]<<16) + (data[i+25]<<24);\n               // if the last frame on a page is continued to the next, then\n               // we can't recover the sample_loc immediately\n               if (data[i+27+data[i+26]-1] == 255)\n                  f->scan[n].sample_loc = ~0;\n               else\n                  f->scan[n].sample_loc = data[i+6] + (data[i+7] << 8) + (data[i+ 8]<<16) + (data[i+ 9]<<24);\n               f->scan[n].bytes_done = i+j;\n               if (f->page_crc_tests == STB_VORBIS_PUSHDATA_CRC_COUNT)\n                  break;\n               // keep going if we still have room for more\n            }\n         }\n      }\n   }\n\n   for (i=0; i < f->page_crc_tests;) {\n      uint32 crc;\n      int j;\n      int n = f->scan[i].bytes_done;\n      int m = f->scan[i].bytes_left;\n      if (m > data_len - n) m = data_len - n;\n      // m is the bytes to scan in the current chunk\n      crc = f->scan[i].crc_so_far;\n      for (j=0; j < m; ++j)\n         crc = crc32_update(crc, data[n+j]);\n      f->scan[i].bytes_left -= m;\n      f->scan[i].crc_so_far = crc;\n      if (f->scan[i].bytes_left == 0) {\n         // does it match?\n         if (f->scan[i].crc_so_far == f->scan[i].goal_crc) {\n            // Houston, we have page\n            data_len = n+m; // consumption amount is wherever that scan ended\n            f->page_crc_tests = -1; // drop out of page scan mode\n            f->previous_length = 0; // decode-but-don't-output one frame\n            f->next_seg = -1;       // start a new page\n            f->current_loc = f->scan[i].sample_loc; // set the current sample location\n                                    // to the amount we'd have decoded had we decoded this page\n            f->current_loc_valid = f->current_loc != ~0U;\n            return data_len;\n         }\n         // delete entry\n         f->scan[i] = f->scan[--f->page_crc_tests];\n      } else {\n         ++i;\n      }\n   }\n\n   return data_len;\n}\n\n// return value: number of bytes we used\nint stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,                   // the file we're decoding\n         const uint8 *data, int data_len, // the memory available for decoding\n         int *channels,                   // place to write number of float * buffers\n         float ***output,                 // place to write float ** array of float * buffers\n         int *samples                     // place to write number of output samples\n     )\n{\n   int i;\n   int len,right,left;\n\n   if (!IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (f->page_crc_tests >= 0) {\n      *samples = 0;\n      return vorbis_search_for_page_pushdata(f, (uint8 *) data, data_len);\n   }\n\n   f->stream     = (uint8 *) data;\n   f->stream_end = (uint8 *) data + data_len;\n   f->error      = VORBIS__no_error;\n\n   // check that we have the entire packet in memory\n   if (!is_whole_packet_present(f, FALSE)) {\n      *samples = 0;\n      return 0;\n   }\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      // save the actual error we encountered\n      enum STBVorbisError error = f->error;\n      if (error == VORBIS_bad_packet_type) {\n         // flush and resynch\n         f->error = VORBIS__no_error;\n         while (get8_packet(f) != EOP)\n            if (f->eof) break;\n         *samples = 0;\n         return (int) (f->stream - data);\n      }\n      if (error == VORBIS_continued_packet_flag_invalid) {\n         if (f->previous_length == 0) {\n            // we may be resynching, in which case it's ok to hit one\n            // of these; just discard the packet\n            f->error = VORBIS__no_error;\n            while (get8_packet(f) != EOP)\n               if (f->eof) break;\n            *samples = 0;\n            return (int) (f->stream - data);\n         }\n      }\n      // if we get an error while parsing, what to do?\n      // well, it DEFINITELY won't work to continue from where we are!\n      stb_vorbis_flush_pushdata(f);\n      // restore the error that actually made us bail\n      f->error = error;\n      *samples = 0;\n      return 1;\n   }\n\n   // success!\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   if (channels) *channels = f->channels;\n   *samples = len;\n   *output = f->outputs;\n   return (int) (f->stream - data);\n}\n\nstb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char *data, int data_len, // the memory available for decoding\n         int *data_used,              // only defined if result is not NULL\n         int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.stream     = (uint8 *) data;\n   p.stream_end = (uint8 *) data + data_len;\n   p.push_mode  = TRUE;\n   if (!start_decoder(&p)) {\n      if (p.eof)\n         *error = VORBIS_need_more_data;\n      else\n         *error = p.error;\n      return NULL;\n   }\n   f = vorbis_alloc(&p);\n   if (f) {\n      *f = p;\n      *data_used = (int) (f->stream - data);\n      *error = 0;\n      return f;\n   } else {\n      vorbis_deinit(&p);\n      return NULL;\n   }\n}\n#endif // STB_VORBIS_NO_PUSHDATA_API\n\nunsigned int stb_vorbis_get_file_offset(stb_vorbis *f)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   if (USE_MEMORY(f)) return (unsigned int) (f->stream - f->stream_start);\n   #ifndef STB_VORBIS_NO_STDIO\n   return (unsigned int) (ftell(f->f) - f->f_start);\n   #endif\n}\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n//\n// DATA-PULLING API\n//\n\nstatic uint32 vorbis_find_page(stb_vorbis *f, uint32 *end, uint32 *last)\n{\n   for(;;) {\n      int n;\n      if (f->eof) return 0;\n      n = get8(f);\n      if (n == 0x4f) { // page header candidate\n         unsigned int retry_loc = stb_vorbis_get_file_offset(f);\n         int i;\n         // check if we're off the end of a file_section stream\n         if (retry_loc - 25 > f->stream_len)\n            return 0;\n         // check the rest of the header\n         for (i=1; i < 4; ++i)\n            if (get8(f) != ogg_page_header[i])\n               break;\n         if (f->eof) return 0;\n         if (i == 4) {\n            uint8 header[27];\n            uint32 i, crc, goal, len;\n            for (i=0; i < 4; ++i)\n               header[i] = ogg_page_header[i];\n            for (; i < 27; ++i)\n               header[i] = get8(f);\n            if (f->eof) return 0;\n            if (header[4] != 0) goto invalid;\n            goal = header[22] + (header[23] << 8) + (header[24]<<16) + (header[25]<<24);\n            for (i=22; i < 26; ++i)\n               header[i] = 0;\n            crc = 0;\n            for (i=0; i < 27; ++i)\n               crc = crc32_update(crc, header[i]);\n            len = 0;\n            for (i=0; i < header[26]; ++i) {\n               int s = get8(f);\n               crc = crc32_update(crc, s);\n               len += s;\n            }\n            if (len && f->eof) return 0;\n            for (i=0; i < len; ++i)\n               crc = crc32_update(crc, get8(f));\n            // finished parsing probable page\n            if (crc == goal) {\n               // we could now check that it's either got the last\n               // page flag set, OR it's followed by the capture\n               // pattern, but I guess TECHNICALLY you could have\n               // a file with garbage between each ogg page and recover\n               // from it automatically? So even though that paranoia\n               // might decrease the chance of an invalid decode by\n               // another 2^32, not worth it since it would hose those\n               // invalid-but-useful files?\n               if (end)\n                  *end = stb_vorbis_get_file_offset(f);\n               if (last) {\n                  if (header[5] & 0x04)\n                     *last = 1;\n                  else\n                     *last = 0;\n               }\n               set_file_offset(f, retry_loc-1);\n               return 1;\n            }\n         }\n        invalid:\n         // not a valid page, so rewind and look for next one\n         set_file_offset(f, retry_loc);\n      }\n   }\n}\n\n\n#define SAMPLE_unknown  0xffffffff\n\n// seeking is implemented with a binary search, which narrows down the range to\n// 64K, before using a linear search (because finding the synchronization\n// pattern can be expensive, and the chance we'd find the end page again is\n// relatively high for small ranges)\n//\n// two initial interpolation-style probes are used at the start of the search\n// to try to bound either side of the binary search sensibly, while still\n// working in O(log n) time if they fail.\n\nstatic int get_seek_page_info(stb_vorbis *f, ProbedPage *z)\n{\n   uint8 header[27], lacing[255];\n   int i,len;\n\n   // record where the page starts\n   z->page_start = stb_vorbis_get_file_offset(f);\n\n   // parse the header\n   getn(f, header, 27);\n   if (header[0] != 'O' || header[1] != 'g' || header[2] != 'g' || header[3] != 'S')\n      return 0;\n   getn(f, lacing, header[26]);\n\n   // determine the length of the payload\n   len = 0;\n   for (i=0; i < header[26]; ++i)\n      len += lacing[i];\n\n   // this implies where the page ends\n   z->page_end = z->page_start + 27 + header[26] + len;\n\n   // read the last-decoded sample out of the data\n   z->last_decoded_sample = header[6] + (header[7] << 8) + (header[8] << 16) + (header[9] << 24);\n\n   // restore file state to where we were\n   set_file_offset(f, z->page_start);\n   return 1;\n}\n\n// rarely used function to seek back to the preceding page while finding the\n// start of a packet\nstatic int go_to_page_before(stb_vorbis *f, unsigned int limit_offset)\n{\n   unsigned int previous_safe, end;\n\n   // now we want to seek back 64K from the limit\n   if (limit_offset >= 65536 && limit_offset-65536 >= f->first_audio_page_offset)\n      previous_safe = limit_offset - 65536;\n   else\n      previous_safe = f->first_audio_page_offset;\n\n   set_file_offset(f, previous_safe);\n\n   while (vorbis_find_page(f, &end, NULL)) {\n      if (end >= limit_offset && stb_vorbis_get_file_offset(f) < limit_offset)\n         return 1;\n      set_file_offset(f, end);\n   }\n\n   return 0;\n}\n\n// implements the search logic for finding a page and starting decoding. if\n// the function succeeds, current_loc_valid will be true and current_loc will\n// be less than or equal to the provided sample number (the closer the\n// better).\nstatic int seek_to_sample_coarse(stb_vorbis *f, uint32 sample_number)\n{\n   ProbedPage left, right, mid;\n   int i, start_seg_with_known_loc, end_pos, page_start;\n   uint32 delta, stream_length, padding;\n   double offset, bytes_per_sample;\n   int probe = 0;\n\n   // find the last page and validate the target sample\n   stream_length = stb_vorbis_stream_length_in_samples(f);\n   if (stream_length == 0)            return error(f, VORBIS_seek_without_length);\n   if (sample_number > stream_length) return error(f, VORBIS_seek_invalid);\n\n   // this is the maximum difference between the window-center (which is the\n   // actual granule position value), and the right-start (which the spec\n   // indicates should be the granule position (give or take one)).\n   padding = ((f->blocksize_1 - f->blocksize_0) >> 2);\n   if (sample_number < padding)\n      sample_number = 0;\n   else\n      sample_number -= padding;\n\n   left = f->p_first;\n   while (left.last_decoded_sample == ~0U) {\n      // (untested) the first page does not have a 'last_decoded_sample'\n      set_file_offset(f, left.page_end);\n      if (!get_seek_page_info(f, &left)) goto error;\n   }\n\n   right = f->p_last;\n   assert(right.last_decoded_sample != ~0U);\n\n   // starting from the start is handled differently\n   if (sample_number <= left.last_decoded_sample) {\n      if (stb_vorbis_seek_start(f))\n         return 1;\n      return 0;\n   }\n\n   while (left.page_end != right.page_start) {\n      assert(left.page_end < right.page_start);\n      // search range in bytes\n      delta = right.page_start - left.page_end;\n      if (delta <= 65536) {\n         // there's only 64K left to search - handle it linearly\n         set_file_offset(f, left.page_end);\n      } else {\n         if (probe < 2) {\n            if (probe == 0) {\n               // first probe (interpolate)\n               double data_bytes = right.page_end - left.page_start;\n               bytes_per_sample = data_bytes / right.last_decoded_sample;\n               offset = left.page_start + bytes_per_sample * (sample_number - left.last_decoded_sample);\n            } else {\n               // second probe (try to bound the other side)\n               double error = ((double) sample_number - mid.last_decoded_sample) * bytes_per_sample;\n               if (error >= 0 && error <  8000) error =  8000;\n               if (error <  0 && error > -8000) error = -8000;\n               offset += error * 2;\n            }\n\n            // ensure the offset is valid\n            if (offset < left.page_end)\n               offset = left.page_end;\n            if (offset > right.page_start - 65536)\n               offset = right.page_start - 65536;\n\n            set_file_offset(f, (unsigned int) offset);\n         } else {\n            // binary search for large ranges (offset by 32K to ensure\n            // we don't hit the right page)\n            set_file_offset(f, left.page_end + (delta / 2) - 32768);\n         }\n\n         if (!vorbis_find_page(f, NULL, NULL)) goto error;\n      }\n\n      for (;;) {\n         if (!get_seek_page_info(f, &mid)) goto error;\n         if (mid.last_decoded_sample != ~0U) break;\n         // (untested) no frames end on this page\n         set_file_offset(f, mid.page_end);\n         assert(mid.page_start < right.page_start);\n      }\n\n      // if we've just found the last page again then we're in a tricky file,\n      // and we're close enough.\n      if (mid.page_start == right.page_start)\n         break;\n\n      if (sample_number < mid.last_decoded_sample)\n         right = mid;\n      else\n         left = mid;\n\n      ++probe;\n   }\n\n   // seek back to start of the last packet\n   page_start = left.page_start;\n   set_file_offset(f, page_start);\n   if (!start_page(f)) return error(f, VORBIS_seek_failed);\n   end_pos = f->end_seg_with_known_loc;\n   assert(end_pos >= 0);\n\n   for (;;) {\n      for (i = end_pos; i > 0; --i)\n         if (f->segments[i-1] != 255)\n            break;\n\n      start_seg_with_known_loc = i;\n\n      if (start_seg_with_known_loc > 0 || !(f->page_flag & PAGEFLAG_continued_packet))\n         break;\n\n      // (untested) the final packet begins on an earlier page\n      if (!go_to_page_before(f, page_start))\n         goto error;\n\n      page_start = stb_vorbis_get_file_offset(f);\n      if (!start_page(f)) goto error;\n      end_pos = f->segment_count - 1;\n   }\n\n   // prepare to start decoding\n   f->current_loc_valid = FALSE;\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   f->previous_length = 0;\n   f->next_seg = start_seg_with_known_loc;\n\n   for (i = 0; i < start_seg_with_known_loc; i++)\n      skip(f, f->segments[i]);\n\n   // start decoding (optimizable - this frame is generally discarded)\n   if (!vorbis_pump_first_frame(f))\n      return 0;\n   if (f->current_loc > sample_number)\n      return error(f, VORBIS_seek_failed);\n   return 1;\n\nerror:\n   // try to restore the file to a valid state\n   stb_vorbis_seek_start(f);\n   return error(f, VORBIS_seek_failed);\n}\n\n// the same as vorbis_decode_initial, but without advancing\nstatic int peek_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   int bits_read, bytes_read;\n\n   if (!vorbis_decode_initial(f, p_left_start, p_left_end, p_right_start, p_right_end, mode))\n      return 0;\n\n   // either 1 or 2 bytes were read, figure out which so we can rewind\n   bits_read = 1 + ilog(f->mode_count-1);\n   if (f->mode_config[*mode].blockflag)\n      bits_read += 2;\n   bytes_read = (bits_read + 7) / 8;\n\n   f->bytes_in_seg += bytes_read;\n   f->packet_bytes -= bytes_read;\n   skip(f, -bytes_read);\n   if (f->next_seg == -1)\n      f->next_seg = f->segment_count - 1;\n   else\n      f->next_seg--;\n   f->valid_bits = 0;\n\n   return 1;\n}\n\nint stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number)\n{\n   uint32 max_frame_samples;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   // fast page-level search\n   if (!seek_to_sample_coarse(f, sample_number))\n      return 0;\n\n   assert(f->current_loc_valid);\n   assert(f->current_loc <= sample_number);\n\n   // linear search for the relevant packet\n   max_frame_samples = (f->blocksize_1*3 - f->blocksize_0) >> 2;\n   while (f->current_loc < sample_number) {\n      int left_start, left_end, right_start, right_end, mode, frame_samples;\n      if (!peek_decode_initial(f, &left_start, &left_end, &right_start, &right_end, &mode))\n         return error(f, VORBIS_seek_failed);\n      // calculate the number of samples returned by the next frame\n      frame_samples = right_start - left_start;\n      if (f->current_loc + frame_samples > sample_number) {\n         return 1; // the next frame will contain the sample\n      } else if (f->current_loc + frame_samples + max_frame_samples > sample_number) {\n         // there's a chance the frame after this could contain the sample\n         vorbis_pump_first_frame(f);\n      } else {\n         // this frame is too early to be relevant\n         f->current_loc += frame_samples;\n         f->previous_length = 0;\n         maybe_start_packet(f);\n         flush_packet(f);\n      }\n   }\n   // the next frame will start with the sample\n   assert(f->current_loc == sample_number);\n   return 1;\n}\n\nint stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number)\n{\n   if (!stb_vorbis_seek_frame(f, sample_number))\n      return 0;\n\n   if (sample_number != f->current_loc) {\n      int n;\n      uint32 frame_start = f->current_loc;\n      stb_vorbis_get_frame_float(f, &n, NULL);\n      assert(sample_number > frame_start);\n      assert(f->channel_buffer_start + (int) (sample_number-frame_start) <= f->channel_buffer_end);\n      f->channel_buffer_start += (sample_number - frame_start);\n   }\n\n   return 1;\n}\n\nint stb_vorbis_seek_start(stb_vorbis *f)\n{\n   if (IS_PUSH_MODE(f)) { return error(f, VORBIS_invalid_api_mixing); }\n   set_file_offset(f, f->first_audio_page_offset);\n   f->previous_length = 0;\n   f->first_decode = TRUE;\n   f->next_seg = -1;\n   return vorbis_pump_first_frame(f);\n}\n\nunsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f)\n{\n   unsigned int restore_offset, previous_safe;\n   unsigned int end, last_page_loc;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n   if (!f->total_samples) {\n      unsigned int last;\n      uint32 lo,hi;\n      char header[6];\n\n      // first, store the current decode position so we can restore it\n      restore_offset = stb_vorbis_get_file_offset(f);\n\n      // now we want to seek back 64K from the end (the last page must\n      // be at most a little less than 64K, but let's allow a little slop)\n      if (f->stream_len >= 65536 && f->stream_len-65536 >= f->first_audio_page_offset)\n         previous_safe = f->stream_len - 65536;\n      else\n         previous_safe = f->first_audio_page_offset;\n\n      set_file_offset(f, previous_safe);\n      // previous_safe is now our candidate 'earliest known place that seeking\n      // to will lead to the final page'\n\n      if (!vorbis_find_page(f, &end, &last)) {\n         // if we can't find a page, we're hosed!\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = 0xffffffff;\n         goto done;\n      }\n\n      // check if there are more pages\n      last_page_loc = stb_vorbis_get_file_offset(f);\n\n      // stop when the last_page flag is set, not when we reach eof;\n      // this allows us to stop short of a 'file_section' end without\n      // explicitly checking the length of the section\n      while (!last) {\n         set_file_offset(f, end);\n         if (!vorbis_find_page(f, &end, &last)) {\n            // the last page we found didn't have the 'last page' flag\n            // set. whoops!\n            break;\n         }\n         previous_safe = last_page_loc+1;\n         last_page_loc = stb_vorbis_get_file_offset(f);\n      }\n\n      set_file_offset(f, last_page_loc);\n\n      // parse the header\n      getn(f, (unsigned char *)header, 6);\n      // extract the absolute granule position\n      lo = get32(f);\n      hi = get32(f);\n      if (lo == 0xffffffff && hi == 0xffffffff) {\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = SAMPLE_unknown;\n         goto done;\n      }\n      if (hi)\n         lo = 0xfffffffe; // saturate\n      f->total_samples = lo;\n\n      f->p_last.page_start = last_page_loc;\n      f->p_last.page_end   = end;\n      f->p_last.last_decoded_sample = lo;\n\n     done:\n      set_file_offset(f, restore_offset);\n   }\n   return f->total_samples == SAMPLE_unknown ? 0 : f->total_samples;\n}\n\nfloat stb_vorbis_stream_length_in_seconds(stb_vorbis *f)\n{\n   return stb_vorbis_stream_length_in_samples(f) / (float) f->sample_rate;\n}\n\n\n\nint stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output)\n{\n   int len, right,left,i;\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      f->channel_buffer_start = f->channel_buffer_end = 0;\n      return 0;\n   }\n\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   f->channel_buffer_start = left;\n   f->channel_buffer_end   = left+len;\n\n   if (channels) *channels = f->channels;\n   if (output)   *output = f->outputs;\n   return len;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_file_section(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc, unsigned int length)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.f = file;\n   p.f_start = (uint32) ftell(file);\n   p.stream_len   = length;\n   p.close_on_free = close_on_free;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\nstb_vorbis * stb_vorbis_open_file(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc)\n{\n   unsigned int len, start;\n   start = (unsigned int) ftell(file);\n   fseek(file, 0, SEEK_END);\n   len = (unsigned int) (ftell(file) - start);\n   fseek(file, start, SEEK_SET);\n   return stb_vorbis_open_file_section(file, close_on_free, error, alloc, len);\n}\n\nstb_vorbis * stb_vorbis_open_filename(const char *filename, int *error, const stb_vorbis_alloc *alloc)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n   if (0 != fopen_s(&f, filename, \"rb\"))\n      f = NULL;\n#else\n   f = fopen(filename, \"rb\");\n#endif\n   if (f) \n      return stb_vorbis_open_file(f, TRUE, error, alloc);\n   if (error) *error = VORBIS_file_open_failure;\n   return NULL;\n}\n#endif // STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len, int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   if (data == NULL) return NULL;\n   vorbis_init(&p, alloc);\n   p.stream = (uint8 *) data;\n   p.stream_end = (uint8 *) data + len;\n   p.stream_start = (uint8 *) p.stream;\n   p.stream_len = len;\n   p.push_mode = FALSE;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         if (error) *error = VORBIS__no_error;\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#define PLAYBACK_MONO     1\n#define PLAYBACK_LEFT     2\n#define PLAYBACK_RIGHT    4\n\n#define L  (PLAYBACK_LEFT  | PLAYBACK_MONO)\n#define C  (PLAYBACK_LEFT  | PLAYBACK_RIGHT | PLAYBACK_MONO)\n#define R  (PLAYBACK_RIGHT | PLAYBACK_MONO)\n\nstatic int8 channel_position[7][6] =\n{\n   { 0 },\n   { C },\n   { L, R },\n   { L, C, R },\n   { L, R, L, R },\n   { L, C, R, L, R },\n   { L, C, R, L, R, C },\n};\n\n\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n   typedef union {\n      float f;\n      int i;\n   } float_conv;\n   typedef char stb_vorbis_float_size_test[sizeof(float)==4 && sizeof(int) == 4];\n   #define FASTDEF(x) float_conv x\n   // add (1<<23) to convert to int, then divide by 2^SHIFT, then add 0.5/2^SHIFT to round\n   #define MAGIC(SHIFT) (1.5f * (1 << (23-SHIFT)) + 0.5f/(1 << SHIFT))\n   #define ADDEND(SHIFT) (((150-SHIFT) << 23) + (1 << 22))\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) (temp.f = (x) + MAGIC(s), temp.i - ADDEND(s))\n   #define check_endianness()  \n#else\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) ((int) ((x) * (1 << (s))))\n   #define check_endianness()\n   #define FASTDEF(x)\n#endif\n\nstatic void copy_samples(short *dest, float *src, int len)\n{\n   int i;\n   check_endianness();\n   for (i=0; i < len; ++i) {\n      FASTDEF(temp);\n      int v = FAST_SCALED_FLOAT_TO_INT(temp, src[i],15);\n      if ((unsigned int) (v + 32768) > 65535)\n         v = v < 0 ? -32768 : 32767;\n      dest[i] = v;\n   }\n}\n\nstatic void compute_samples(int mask, short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define BUFFER_SIZE  32\n   float buffer[BUFFER_SIZE];\n   int i,j,o,n = BUFFER_SIZE;\n   check_endianness();\n   for (o = 0; o < len; o += BUFFER_SIZE) {\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         if (channel_position[num_c][j] & mask) {\n            for (i=0; i < n; ++i)\n               buffer[i] += data[j][d_offset+o+i];\n         }\n      }\n      for (i=0; i < n; ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o+i] = v;\n      }\n   }\n}\n\nstatic void compute_stereo_samples(short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define BUFFER_SIZE  32\n   float buffer[BUFFER_SIZE];\n   int i,j,o,n = BUFFER_SIZE >> 1;\n   // o is the offset in the source data\n   check_endianness();\n   for (o = 0; o < len; o += BUFFER_SIZE >> 1) {\n      // o2 is the offset in the output data\n      int o2 = o << 1;\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         int m = channel_position[num_c][j] & (PLAYBACK_LEFT | PLAYBACK_RIGHT);\n         if (m == (PLAYBACK_LEFT | PLAYBACK_RIGHT)) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_LEFT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_RIGHT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         }\n      }\n      for (i=0; i < (n<<1); ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o2+i] = v;\n      }\n   }\n}\n\nstatic void convert_samples_short(int buf_c, short **buffer, int b_offset, int data_c, float **data, int d_offset, int samples)\n{\n   int i;\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      static int channel_selector[3][2] = { {0}, {PLAYBACK_MONO}, {PLAYBACK_LEFT, PLAYBACK_RIGHT} };\n      for (i=0; i < buf_c; ++i)\n         compute_samples(channel_selector[buf_c][i], buffer[i]+b_offset, data_c, data, d_offset, samples);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      for (i=0; i < limit; ++i)\n         copy_samples(buffer[i]+b_offset, data[i]+d_offset, samples);\n      for (   ; i < buf_c; ++i)\n         memset(buffer[i]+b_offset, 0, sizeof(short) * samples);\n   }\n}\n\nint stb_vorbis_get_frame_short(stb_vorbis *f, int num_c, short **buffer, int num_samples)\n{\n   float **output;\n   int len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len > num_samples) len = num_samples;\n   if (len)\n      convert_samples_short(num_c, buffer, 0, f->channels, output, 0, len);\n   return len;\n}\n\nstatic void convert_channels_short_interleaved(int buf_c, short *buffer, int data_c, float **data, int d_offset, int len)\n{\n   int i;\n   check_endianness();\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      assert(buf_c == 2);\n      for (i=0; i < buf_c; ++i)\n         compute_stereo_samples(buffer, data_c, data, d_offset, len);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      int j;\n      for (j=0; j < len; ++j) {\n         for (i=0; i < limit; ++i) {\n            FASTDEF(temp);\n            float f = data[i][d_offset+j];\n            int v = FAST_SCALED_FLOAT_TO_INT(temp, f,15);//data[i][d_offset+j],15);\n            if ((unsigned int) (v + 32768) > 65535)\n               v = v < 0 ? -32768 : 32767;\n            *buffer++ = v;\n         }\n         for (   ; i < buf_c; ++i)\n            *buffer++ = 0;\n      }\n   }\n}\n\nint stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts)\n{\n   float **output;\n   int len;\n   if (num_c == 1) return stb_vorbis_get_frame_short(f,num_c,&buffer, num_shorts);\n   len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len) {\n      if (len*num_c > num_shorts) len = num_shorts / num_c;\n      convert_channels_short_interleaved(num_c, buffer, f->channels, output, 0, len);\n   }\n   return len;\n}\n\nint stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts)\n{\n   float **outputs;\n   int len = num_shorts / channels;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_channels_short_interleaved(channels, buffer, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      buffer += k*channels;\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int len)\n{\n   float **outputs;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_samples_short(channels, buffer, n, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\nint stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_filename(filename, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // NO_STDIO\n\nint stb_vorbis_decode_memory(const uint8 *mem, int len, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_memory(mem, len, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // STB_VORBIS_NO_INTEGER_CONVERSION\n\nint stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats)\n{\n   float **outputs;\n   int len = num_floats / channels;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int i,j;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      for (j=0; j < k; ++j) {\n         for (i=0; i < z; ++i)\n            *buffer++ = f->channel_buffers[i][f->channel_buffer_start+j];\n         for (   ; i < channels; ++i)\n            *buffer++ = 0;\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples)\n{\n   float **outputs;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < num_samples) {\n      int i;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= num_samples) k = num_samples - n;\n      if (k) {\n         for (i=0; i < z; ++i)\n            memcpy(buffer[i]+n, f->channel_buffers[i]+f->channel_buffer_start, sizeof(float)*k);\n         for (   ; i < channels; ++i)\n            memset(buffer[i]+n, 0, sizeof(float) * k);\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == num_samples)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n#endif // STB_VORBIS_NO_PULLDATA_API\n\n/* Version history\n    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n    1.11    - 2017-07-23 - fix MinGW compilation \n    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n    1.09    - 2016-04-04 - back out 'avoid discarding last frame' fix from previous version\n    1.08    - 2016-04-02 - fixed multiple warnings; fix setup memory leaks;\n                           avoid discarding last frame of audio data\n    1.07    - 2015-01-16 - fixed some warnings, fix mingw, const-correct API\n                           some more crash fixes when out of memory or with corrupt files \n    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n                           some crash fixes when out of memory or with corrupt files\n    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n    1.04    - 2014-08-27 - fix missing const-correct case in API\n    1.03    - 2014-08-07 - Warning fixes\n    1.02    - 2014-07-09 - Declare qsort compare function _cdecl on windows\n    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float\n    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in multichannel\n                           (API change) report sample rate for decode-full-file funcs\n    0.99996 - bracket #include <malloc.h> for macintosh compilation by Laurent Gomila\n    0.99995 - use union instead of pointer-cast for fast-float-to-int to avoid alias-optimization problem\n    0.99994 - change fast-float-to-int to work in single-precision FPU mode, remove endian-dependence\n    0.99993 - remove assert that fired on legal files with empty tables\n    0.99992 - rewind-to-start\n    0.99991 - bugfix to stb_vorbis_get_samples_short by Bernhard Wodo\n    0.9999 - (should have been 0.99990) fix no-CRT support, compiling as C++\n    0.9998 - add a full-decode function with a memory source\n    0.9997 - fix a bug in the read-from-FILE case in 0.9996 addition\n    0.9996 - query length of vorbis stream in samples/seconds\n    0.9995 - bugfix to another optimization that only happened in certain files\n    0.9994 - bugfix to one of the optimizations that caused significant (but inaudible?) errors\n    0.9993 - performance improvements; runs in 99% to 104% of time of reference implementation\n    0.9992 - performance improvement of IMDCT; now performs close to reference implementation\n    0.9991 - performance improvement of IMDCT\n    0.999 - (should have been 0.9990) performance improvement of IMDCT\n    0.998 - no-CRT support from Casey Muratori\n    0.997 - bugfixes for bugs found by Terje Mathisen\n    0.996 - bugfix: fast-huffman decode initialized incorrectly for sparse codebooks; fixing gives 10% speedup - found by Terje Mathisen\n    0.995 - bugfix: fix to 'effective' overrun detection - found by Terje Mathisen\n    0.994 - bugfix: garbage decode on final VQ symbol of a non-multiple - found by Terje Mathisen\n    0.993 - bugfix: pushdata API required 1 extra byte for empty page (failed to consume final page if empty) - found by Terje Mathisen\n    0.992 - fixes for MinGW warning\n    0.991 - turn fast-float-conversion on by default\n    0.990 - fix push-mode seek recovery if you seek into the headers\n    0.98b - fix to bad release of 0.98\n    0.98 - fix push-mode seek recovery; robustify float-to-int and support non-fast mode\n    0.97 - builds under c++ (typecasting, don't use 'class' keyword)\n    0.96 - somehow MY 0.95 was right, but the web one was wrong, so here's my 0.95 rereleased as 0.96, fixes a typo in the clamping code\n    0.95 - clamping code for 16-bit functions\n    0.94 - not publically released\n    0.93 - fixed all-zero-floor case (was decoding garbage)\n    0.92 - fixed a memory leak\n    0.91 - conditional compiles to omit parts of the API and the infrastructure to support them: STB_VORBIS_NO_PULLDATA_API, STB_VORBIS_NO_PUSHDATA_API, STB_VORBIS_NO_STDIO, STB_VORBIS_NO_INTEGER_CONVERSION\n    0.90 - first public release\n*/\n\n#endif // STB_VORBIS_HEADER_ONLY\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"], "fixing_code": ["// Ogg Vorbis audio decoder - v1.16 - public domain\n// http://nothings.org/stb_vorbis/\n//\n// Original version written by Sean Barrett in 2007.\n//\n// Originally sponsored by RAD Game Tools. Seeking implementation\n// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,\n// Elias Software, Aras Pranckevicius, and Sean Barrett.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// Limitations:\n//\n//   - floor 0 not supported (used in old ogg vorbis files pre-2004)\n//   - lossless sample-truncation at beginning ignored\n//   - cannot concatenate multiple vorbis streams\n//   - sample positions are 32-bit, limiting seekable 192Khz\n//       files to around 6 hours (Ogg supports 64-bit)\n//\n// Feature contributors:\n//    Dougall Johnson (sample-exact seeking)\n//\n// Bugfix/warning contributors:\n//    Terje Mathisen     Niklas Frykholm     Andy Hill\n//    Casey Muratori     John Bolton         Gargaj\n//    Laurent Gomila     Marc LeBlanc        Ronny Chevalier\n//    Bernhard Wodo      Evan Balster        alxprd@github\n//    Tom Beaumont       Ingo Leitgeb        Nicolas Guillemot\n//    Phillip Bennefall  Rohit               Thiago Goulart\n//    manxorist@github   saga musix          github:infatum\n//    Timur Gagiev\n//\n// Partial history:\n//    1.17    - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)\n//    1.16    - 2019-03-04 - fix warnings\n//    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n//    1.14    - 2018-02-11 - delete bogus dealloca usage\n//    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n//    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n//    1.11    - 2017-07-23 - fix MinGW compilation \n//    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n//    1.09    - 2016-04-04 - back out 'truncation of last frame' fix from previous version\n//    1.08    - 2016-04-02 - warnings; setup memory leaks; truncation of last frame\n//    1.07    - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const\n//    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n//                           some crash fixes when out of memory or with corrupt files\n//                           fix some inappropriately signed shifts\n//    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n//    1.04    - 2014-08-27 - fix missing const-correct case in API\n//    1.03    - 2014-08-07 - warning fixes\n//    1.02    - 2014-07-09 - declare qsort comparison as explicitly _cdecl in Windows\n//    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float (interleaved was correct)\n//    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;\n//                           (API change) report sample rate for decode-full-file funcs\n//\n// See end of file for full version history.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  HEADER BEGINS HERE\n//\n\n#ifndef STB_VORBIS_INCLUDE_STB_VORBIS_H\n#define STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n#define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n///////////   THREAD SAFETY\n\n// Individual stb_vorbis* handles are not thread-safe; you cannot decode from\n// them from multiple threads at the same time. However, you can have multiple\n// stb_vorbis* handles and decode from them independently in multiple thrads.\n\n\n///////////   MEMORY ALLOCATION\n\n// normally stb_vorbis uses malloc() to allocate memory at startup,\n// and alloca() to allocate temporary memory during a frame on the\n// stack. (Memory consumption will depend on the amount of setup\n// data in the file and how you set the compile flags for speed\n// vs. size. In my test files the maximal-size usage is ~150KB.)\n//\n// You can modify the wrapper functions in the source (setup_malloc,\n// setup_temp_malloc, temp_malloc) to change this behavior, or you\n// can use a simpler allocation model: you pass in a buffer from\n// which stb_vorbis will allocate _all_ its memory (including the\n// temp memory). \"open\" may fail with a VORBIS_outofmem if you\n// do not pass in enough data; there is no way to determine how\n// much you do need except to succeed (at which point you can\n// query get_info to find the exact amount required. yes I know\n// this is lame).\n//\n// If you pass in a non-NULL buffer of the type below, allocation\n// will occur from it as described above. Otherwise just pass NULL\n// to use malloc()/alloca()\n\ntypedef struct\n{\n   char *alloc_buffer;\n   int   alloc_buffer_length_in_bytes;\n} stb_vorbis_alloc;\n\n\n///////////   FUNCTIONS USEABLE WITH ALL INPUT MODES\n\ntypedef struct stb_vorbis stb_vorbis;\n\ntypedef struct\n{\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int setup_temp_memory_required;\n   unsigned int temp_memory_required;\n\n   int max_frame_size;\n} stb_vorbis_info;\n\n// get general information about the file\nextern stb_vorbis_info stb_vorbis_get_info(stb_vorbis *f);\n\n// get the last error detected (clears it, too)\nextern int stb_vorbis_get_error(stb_vorbis *f);\n\n// close an ogg vorbis file and free all memory in use\nextern void stb_vorbis_close(stb_vorbis *f);\n\n// this function returns the offset (in samples) from the beginning of the\n// file that will be returned by the next decode, if it is known, or -1\n// otherwise. after a flush_pushdata() call, this may take a while before\n// it becomes valid again.\n// NOT WORKING YET after a seek with PULLDATA API\nextern int stb_vorbis_get_sample_offset(stb_vorbis *f);\n\n// returns the current seek point within the file, or offset from the beginning\n// of the memory buffer. In pushdata mode it returns 0.\nextern unsigned int stb_vorbis_get_file_offset(stb_vorbis *f);\n\n///////////   PUSHDATA API\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\n// this API allows you to get blocks of data from any source and hand\n// them to stb_vorbis. you have to buffer them; stb_vorbis will tell\n// you how much it used, and you have to give it the rest next time;\n// and stb_vorbis may not have enough data to work with and you will\n// need to give it the same data again PLUS more. Note that the Vorbis\n// specification does not bound the size of an individual frame.\n\nextern stb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char * datablock, int datablock_length_in_bytes,\n         int *datablock_memory_consumed_in_bytes,\n         int *error,\n         const stb_vorbis_alloc *alloc_buffer);\n// create a vorbis decoder by passing in the initial data block containing\n//    the ogg&vorbis headers (you don't need to do parse them, just provide\n//    the first N bytes of the file--you're told if it's not enough, see below)\n// on success, returns an stb_vorbis *, does not set error, returns the amount of\n//    data parsed/consumed on this call in *datablock_memory_consumed_in_bytes;\n// on failure, returns NULL on error and sets *error, does not change *datablock_memory_consumed\n// if returns NULL and *error is VORBIS_need_more_data, then the input block was\n//       incomplete and you need to pass in a larger block from the start of the file\n\nextern int stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,\n         const unsigned char *datablock, int datablock_length_in_bytes,\n         int *channels,             // place to write number of float * buffers\n         float ***output,           // place to write float ** array of float * buffers\n         int *samples               // place to write number of output samples\n     );\n// decode a frame of audio sample data if possible from the passed-in data block\n//\n// return value: number of bytes we used from datablock\n//\n// possible cases:\n//     0 bytes used, 0 samples output (need more data)\n//     N bytes used, 0 samples output (resynching the stream, keep going)\n//     N bytes used, M samples output (one frame of data)\n// note that after opening a file, you will ALWAYS get one N-bytes,0-sample\n// frame, because Vorbis always \"discards\" the first frame.\n//\n// Note that on resynch, stb_vorbis will rarely consume all of the buffer,\n// instead only datablock_length_in_bytes-3 or less. This is because it wants\n// to avoid missing parts of a page header if they cross a datablock boundary,\n// without writing state-machiney code to record a partial detection.\n//\n// The number of channels returned are stored in *channels (which can be\n// NULL--it is always the same as the number of channels reported by\n// get_info). *output will contain an array of float* buffers, one per\n// channel. In other words, (*output)[0][0] contains the first sample from\n// the first channel, and (*output)[1][0] contains the first sample from\n// the second channel.\n\nextern void stb_vorbis_flush_pushdata(stb_vorbis *f);\n// inform stb_vorbis that your next datablock will not be contiguous with\n// previous ones (e.g. you've seeked in the data); future attempts to decode\n// frames will cause stb_vorbis to resynchronize (as noted above), and\n// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it\n// will begin decoding the _next_ frame.\n//\n// if you want to seek using pushdata, you need to seek in your file, then\n// call stb_vorbis_flush_pushdata(), then start calling decoding, then once\n// decoding is returning you data, call stb_vorbis_get_sample_offset, and\n// if you don't like the result, seek your file again and repeat.\n#endif\n\n\n//////////   PULLING INPUT API\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n// This API assumes stb_vorbis is allowed to pull data from a source--\n// either a block of memory containing the _entire_ vorbis stream, or a\n// FILE * that you or it create, or possibly some other reading mechanism\n// if you go modify the source to replace the FILE * case with some kind\n// of callback to your code. (But if you don't support seeking, you may\n// just want to go ahead and use pushdata.)\n\n#if !defined(STB_VORBIS_NO_STDIO) && !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output);\n#endif\n#if !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_memory(const unsigned char *mem, int len, int *channels, int *sample_rate, short **output);\n#endif\n// decode an entire file and output the data interleaved into a malloc()ed\n// buffer stored in *output. The return value is the number of samples\n// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.\n// When you're done with it, just free() the pointer returned in *output.\n\nextern stb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an ogg vorbis stream in memory (note\n// this must be the entire stream!). on failure, returns NULL and sets *error\n\n#ifndef STB_VORBIS_NO_STDIO\nextern stb_vorbis * stb_vorbis_open_filename(const char *filename,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from a filename via fopen(). on failure,\n// returns NULL and sets *error (possibly to VORBIS_file_open_failure).\n\nextern stb_vorbis * stb_vorbis_open_file(FILE *f, int close_handle_on_close,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell). on failure, returns NULL and sets *error.\n// note that stb_vorbis must \"own\" this stream; if you seek it in between\n// calls to stb_vorbis, it will become confused. Moreover, if you attempt to\n// perform stb_vorbis_seek_*() operations on this file, it will assume it\n// owns the _entire_ rest of the file after the start point. Use the next\n// function, stb_vorbis_open_file_section(), to limit it.\n\nextern stb_vorbis * stb_vorbis_open_file_section(FILE *f, int close_handle_on_close,\n                int *error, const stb_vorbis_alloc *alloc_buffer, unsigned int len);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell); the stream will be of length 'len' bytes.\n// on failure, returns NULL and sets *error. note that stb_vorbis must \"own\"\n// this stream; if you seek it in between calls to stb_vorbis, it will become\n// confused.\n#endif\n\nextern int stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number);\nextern int stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number);\n// these functions seek in the Vorbis file to (approximately) 'sample_number'.\n// after calling seek_frame(), the next call to get_frame_*() will include\n// the specified sample. after calling stb_vorbis_seek(), the next call to\n// stb_vorbis_get_samples_* will start with the specified sample. If you\n// do not need to seek to EXACTLY the target sample when using get_samples_*,\n// you can also use seek_frame().\n\nextern int stb_vorbis_seek_start(stb_vorbis *f);\n// this function is equivalent to stb_vorbis_seek(f,0)\n\nextern unsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f);\nextern float        stb_vorbis_stream_length_in_seconds(stb_vorbis *f);\n// these functions return the total length of the vorbis stream\n\nextern int stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output);\n// decode the next frame and return the number of samples. the number of\n// channels returned are stored in *channels (which can be NULL--it is always\n// the same as the number of channels reported by get_info). *output will\n// contain an array of float* buffers, one per channel. These outputs will\n// be overwritten on the next call to stb_vorbis_get_frame_*.\n//\n// You generally should not intermix calls to stb_vorbis_get_frame_*()\n// and stb_vorbis_get_samples_*(), since the latter calls the former.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts);\nextern int stb_vorbis_get_frame_short            (stb_vorbis *f, int num_c, short **buffer, int num_samples);\n#endif\n// decode the next frame and return the number of *samples* per channel.\n// Note that for interleaved data, you pass in the number of shorts (the\n// size of your array), but the return value is the number of samples per\n// channel, not the total number of samples.\n//\n// The data is coerced to the number of channels you request according to the\n// channel coercion rules (see below). You must pass in the size of your\n// buffer(s) so that stb_vorbis will not overwrite the end of the buffer.\n// The maximum buffer size needed can be gotten from get_info(); however,\n// the Vorbis I specification implies an absolute maximum of 4096 samples\n// per channel.\n\n// Channel coercion rules:\n//    Let M be the number of channels requested, and N the number of channels present,\n//    and Cn be the nth channel; let stereo L be the sum of all L and center channels,\n//    and stereo R be the sum of all R and center channels (channel assignment from the\n//    vorbis spec).\n//        M    N       output\n//        1    k      sum(Ck) for all k\n//        2    *      stereo L, stereo R\n//        k    l      k > l, the first l channels, then 0s\n//        k    l      k <= l, the first k channels\n//    Note that this is not _good_ surround etc. mixing at all! It's just so\n//    you get something useful.\n\nextern int stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats);\nextern int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples);\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.\n// Returns the number of samples stored per channel; it may be less than requested\n// at the end of the file. If there are no more samples in the file, returns 0.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts);\nextern int stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int num_samples);\n#endif\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. Applies the coercion rules above\n// to produce 'channels' channels. Returns the number of samples stored per channel;\n// it may be less than requested at the end of the file. If there are no more\n// samples in the file, returns 0.\n\n#endif\n\n////////   ERROR CODES\n\nenum STBVorbisError\n{\n   VORBIS__no_error,\n\n   VORBIS_need_more_data=1,             // not a real error\n\n   VORBIS_invalid_api_mixing,           // can't mix API modes\n   VORBIS_outofmem,                     // not enough memory\n   VORBIS_feature_not_supported,        // uses floor 0\n   VORBIS_too_many_channels,            // STB_VORBIS_MAX_CHANNELS is too small\n   VORBIS_file_open_failure,            // fopen() failed\n   VORBIS_seek_without_length,          // can't seek in unknown-length file\n\n   VORBIS_unexpected_eof=10,            // file is truncated?\n   VORBIS_seek_invalid,                 // seek past EOF\n\n   // decoding errors (corrupt/invalid stream) -- you probably\n   // don't care about the exact details of these\n\n   // vorbis errors:\n   VORBIS_invalid_setup=20,\n   VORBIS_invalid_stream,\n\n   // ogg errors:\n   VORBIS_missing_capture_pattern=30,\n   VORBIS_invalid_stream_structure_version,\n   VORBIS_continued_packet_flag_invalid,\n   VORBIS_incorrect_stream_serial_number,\n   VORBIS_invalid_first_page,\n   VORBIS_bad_packet_type,\n   VORBIS_cant_find_last_page,\n   VORBIS_seek_failed,\n   VORBIS_ogg_skeleton_not_supported\n};\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // STB_VORBIS_INCLUDE_STB_VORBIS_H\n//\n//  HEADER ENDS HERE\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifndef STB_VORBIS_HEADER_ONLY\n\n// global configuration settings (e.g. set these in the project/makefile),\n// or just set them in this file at the top (although ideally the first few\n// should be visible when the header file is compiled too, although it's not\n// crucial)\n\n// STB_VORBIS_NO_PUSHDATA_API\n//     does not compile the code for the various stb_vorbis_*_pushdata()\n//     functions\n// #define STB_VORBIS_NO_PUSHDATA_API\n\n// STB_VORBIS_NO_PULLDATA_API\n//     does not compile the code for the non-pushdata APIs\n// #define STB_VORBIS_NO_PULLDATA_API\n\n// STB_VORBIS_NO_STDIO\n//     does not compile the code for the APIs that use FILE *s internally\n//     or externally (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_STDIO\n\n// STB_VORBIS_NO_INTEGER_CONVERSION\n//     does not compile the code for converting audio sample data from\n//     float to integer (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_INTEGER_CONVERSION\n\n// STB_VORBIS_NO_FAST_SCALED_FLOAT\n//      does not use a fast float-to-int trick to accelerate float-to-int on\n//      most platforms which requires endianness be defined correctly.\n//#define STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n\n// STB_VORBIS_MAX_CHANNELS [number]\n//     globally define this to the maximum number of channels you need.\n//     The spec does not put a restriction on channels except that\n//     the count is stored in a byte, so 255 is the hard limit.\n//     Reducing this saves about 16 bytes per value, so using 16 saves\n//     (255-16)*16 or around 4KB. Plus anything other memory usage\n//     I forgot to account for. Can probably go as low as 8 (7.1 audio),\n//     6 (5.1 audio), or 2 (stereo only).\n#ifndef STB_VORBIS_MAX_CHANNELS\n#define STB_VORBIS_MAX_CHANNELS    16  // enough for anyone?\n#endif\n\n// STB_VORBIS_PUSHDATA_CRC_COUNT [number]\n//     after a flush_pushdata(), stb_vorbis begins scanning for the\n//     next valid page, without backtracking. when it finds something\n//     that looks like a page, it streams through it and verifies its\n//     CRC32. Should that validation fail, it keeps scanning. But it's\n//     possible that _while_ streaming through to check the CRC32 of\n//     one candidate page, it sees another candidate page. This #define\n//     determines how many \"overlapping\" candidate pages it can search\n//     at once. Note that \"real\" pages are typically ~4KB to ~8KB, whereas\n//     garbage pages could be as big as 64KB, but probably average ~16KB.\n//     So don't hose ourselves by scanning an apparent 64KB page and\n//     missing a ton of real ones in the interim; so minimum of 2\n#ifndef STB_VORBIS_PUSHDATA_CRC_COUNT\n#define STB_VORBIS_PUSHDATA_CRC_COUNT  4\n#endif\n\n// STB_VORBIS_FAST_HUFFMAN_LENGTH [number]\n//     sets the log size of the huffman-acceleration table.  Maximum\n//     supported value is 24. with larger numbers, more decodings are O(1),\n//     but the table size is larger so worse cache missing, so you'll have\n//     to probe (and try multiple ogg vorbis files) to find the sweet spot.\n#ifndef STB_VORBIS_FAST_HUFFMAN_LENGTH\n#define STB_VORBIS_FAST_HUFFMAN_LENGTH   10\n#endif\n\n// STB_VORBIS_FAST_BINARY_LENGTH [number]\n//     sets the log size of the binary-search acceleration table. this\n//     is used in similar fashion to the fast-huffman size to set initial\n//     parameters for the binary search\n\n// STB_VORBIS_FAST_HUFFMAN_INT\n//     The fast huffman tables are much more efficient if they can be\n//     stored as 16-bit results instead of 32-bit results. This restricts\n//     the codebooks to having only 65535 possible outcomes, though.\n//     (At least, accelerated by the huffman table.)\n#ifndef STB_VORBIS_FAST_HUFFMAN_INT\n#define STB_VORBIS_FAST_HUFFMAN_SHORT\n#endif\n\n// STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n//     If the 'fast huffman' search doesn't succeed, then stb_vorbis falls\n//     back on binary searching for the correct one. This requires storing\n//     extra tables with the huffman codes in sorted order. Defining this\n//     symbol trades off space for speed by forcing a linear search in the\n//     non-fast case, except for \"sparse\" codebooks.\n// #define STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n\n// STB_VORBIS_DIVIDES_IN_RESIDUE\n//     stb_vorbis precomputes the result of the scalar residue decoding\n//     that would otherwise require a divide per chunk. you can trade off\n//     space for time by defining this symbol.\n// #define STB_VORBIS_DIVIDES_IN_RESIDUE\n\n// STB_VORBIS_DIVIDES_IN_CODEBOOK\n//     vorbis VQ codebooks can be encoded two ways: with every case explicitly\n//     stored, or with all elements being chosen from a small range of values,\n//     and all values possible in all elements. By default, stb_vorbis expands\n//     this latter kind out to look like the former kind for ease of decoding,\n//     because otherwise an integer divide-per-vector-element is required to\n//     unpack the index. If you define STB_VORBIS_DIVIDES_IN_CODEBOOK, you can\n//     trade off storage for speed.\n//#define STB_VORBIS_DIVIDES_IN_CODEBOOK\n\n#ifdef STB_VORBIS_CODEBOOK_SHORTS\n#error \"STB_VORBIS_CODEBOOK_SHORTS is no longer supported as it produced incorrect results for some input formats\"\n#endif\n\n// STB_VORBIS_DIVIDE_TABLE\n//     this replaces small integer divides in the floor decode loop with\n//     table lookups. made less than 1% difference, so disabled by default.\n\n// STB_VORBIS_NO_INLINE_DECODE\n//     disables the inlining of the scalar codebook fast-huffman decode.\n//     might save a little codespace; useful for debugging\n// #define STB_VORBIS_NO_INLINE_DECODE\n\n// STB_VORBIS_NO_DEFER_FLOOR\n//     Normally we only decode the floor without synthesizing the actual\n//     full curve. We can instead synthesize the curve immediately. This\n//     requires more memory and is very likely slower, so I don't think\n//     you'd ever want to do it except for debugging.\n// #define STB_VORBIS_NO_DEFER_FLOOR\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n#ifdef STB_VORBIS_NO_PULLDATA_API\n   #define STB_VORBIS_NO_INTEGER_CONVERSION\n   #define STB_VORBIS_NO_STDIO\n#endif\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n   #define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n   // only need endianness for fast-float-to-int, which we don't\n   // use for pushdata\n\n   #ifndef STB_VORBIS_BIG_ENDIAN\n     #define STB_VORBIS_ENDIAN  0\n   #else\n     #define STB_VORBIS_ENDIAN  1\n   #endif\n\n#endif\n#endif\n\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef STB_VORBIS_NO_CRT\n   #include <stdlib.h>\n   #include <string.h>\n   #include <assert.h>\n   #include <math.h>\n\n   // find definition of alloca if it's not in stdlib.h:\n   #if defined(_MSC_VER) || defined(__MINGW32__)\n      #include <malloc.h>\n   #endif\n   #if defined(__linux__) || defined(__linux) || defined(__EMSCRIPTEN__)\n      #include <alloca.h>\n   #endif\n#else // STB_VORBIS_NO_CRT\n   #define NULL 0\n   #define malloc(s)   0\n   #define free(s)     ((void) 0)\n   #define realloc(s)  0\n#endif // STB_VORBIS_NO_CRT\n\n#include <limits.h>\n\n#ifdef __MINGW32__\n   // eff you mingw:\n   //     \"fixed\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32882927/\n   //     \"no that broke the build, reverted, who cares about C\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32890381/\n   #ifdef __forceinline\n   #undef __forceinline\n   #endif\n   #define __forceinline\n   #define alloca __builtin_alloca\n#elif !defined(_MSC_VER)\n   #if __GNUC__\n      #define __forceinline inline\n   #else\n      #define __forceinline\n   #endif\n#endif\n\n#if STB_VORBIS_MAX_CHANNELS > 256\n#error \"Value of STB_VORBIS_MAX_CHANNELS outside of allowed range\"\n#endif\n\n#if STB_VORBIS_FAST_HUFFMAN_LENGTH > 24\n#error \"Value of STB_VORBIS_FAST_HUFFMAN_LENGTH outside of allowed range\"\n#endif\n\n\n#if 0\n#include <crtdbg.h>\n#define CHECK(f)   _CrtIsValidHeapPointer(f->channel_buffers[1])\n#else\n#define CHECK(f)   ((void) 0)\n#endif\n\n#define MAX_BLOCKSIZE_LOG  13   // from specification\n#define MAX_BLOCKSIZE      (1 << MAX_BLOCKSIZE_LOG)\n\n\ntypedef unsigned char  uint8;\ntypedef   signed char   int8;\ntypedef unsigned short uint16;\ntypedef   signed short  int16;\ntypedef unsigned int   uint32;\ntypedef   signed int    int32;\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n\ntypedef float codetype;\n\n// @NOTE\n//\n// Some arrays below are tagged \"//varies\", which means it's actually\n// a variable-sized piece of data, but rather than malloc I assume it's\n// small enough it's better to just allocate it all together with the\n// main thing\n//\n// Most of the variables are specified with the smallest size I could pack\n// them into. It might give better performance to make them all full-sized\n// integers. It should be safe to freely rearrange the structures or change\n// the sizes larger--nothing relies on silently truncating etc., nor the\n// order of variables.\n\n#define FAST_HUFFMAN_TABLE_SIZE   (1 << STB_VORBIS_FAST_HUFFMAN_LENGTH)\n#define FAST_HUFFMAN_TABLE_MASK   (FAST_HUFFMAN_TABLE_SIZE - 1)\n\ntypedef struct\n{\n   int dimensions, entries;\n   uint8 *codeword_lengths;\n   float  minimum_value;\n   float  delta_value;\n   uint8  value_bits;\n   uint8  lookup_type;\n   uint8  sequence_p;\n   uint8  sparse;\n   uint32 lookup_values;\n   codetype *multiplicands;\n   uint32 *codewords;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n    int16  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #else\n    int32  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #endif\n   uint32 *sorted_codewords;\n   int    *sorted_values;\n   int     sorted_entries;\n} Codebook;\n\ntypedef struct\n{\n   uint8 order;\n   uint16 rate;\n   uint16 bark_map_size;\n   uint8 amplitude_bits;\n   uint8 amplitude_offset;\n   uint8 number_of_books;\n   uint8 book_list[16]; // varies\n} Floor0;\n\ntypedef struct\n{\n   uint8 partitions;\n   uint8 partition_class_list[32]; // varies\n   uint8 class_dimensions[16]; // varies\n   uint8 class_subclasses[16]; // varies\n   uint8 class_masterbooks[16]; // varies\n   int16 subclass_books[16][8]; // varies\n   uint16 Xlist[31*8+2]; // varies\n   uint8 sorted_order[31*8+2];\n   uint8 neighbors[31*8+2][2];\n   uint8 floor1_multiplier;\n   uint8 rangebits;\n   int values;\n} Floor1;\n\ntypedef union\n{\n   Floor0 floor0;\n   Floor1 floor1;\n} Floor;\n\ntypedef struct\n{\n   uint32 begin, end;\n   uint32 part_size;\n   uint8 classifications;\n   uint8 classbook;\n   uint8 **classdata;\n   int16 (*residue_books)[8];\n} Residue;\n\ntypedef struct\n{\n   uint8 magnitude;\n   uint8 angle;\n   uint8 mux;\n} MappingChannel;\n\ntypedef struct\n{\n   uint16 coupling_steps;\n   MappingChannel *chan;\n   uint8  submaps;\n   uint8  submap_floor[15]; // varies\n   uint8  submap_residue[15]; // varies\n} Mapping;\n\ntypedef struct\n{\n   uint8 blockflag;\n   uint8 mapping;\n   uint16 windowtype;\n   uint16 transformtype;\n} Mode;\n\ntypedef struct\n{\n   uint32  goal_crc;    // expected crc if match\n   int     bytes_left;  // bytes left in packet\n   uint32  crc_so_far;  // running crc\n   int     bytes_done;  // bytes processed in _current_ chunk\n   uint32  sample_loc;  // granule pos encoded in page\n} CRCscan;\n\ntypedef struct\n{\n   uint32 page_start, page_end;\n   uint32 last_decoded_sample;\n} ProbedPage;\n\nstruct stb_vorbis\n{\n  // user-accessible info\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int temp_memory_required;\n   unsigned int setup_temp_memory_required;\n\n  // input config\n#ifndef STB_VORBIS_NO_STDIO\n   FILE *f;\n   uint32 f_start;\n   int close_on_free;\n#endif\n\n   uint8 *stream;\n   uint8 *stream_start;\n   uint8 *stream_end;\n\n   uint32 stream_len;\n\n   uint8  push_mode;\n\n   uint32 first_audio_page_offset;\n\n   ProbedPage p_first, p_last;\n\n  // memory management\n   stb_vorbis_alloc alloc;\n   int setup_offset;\n   int temp_offset;\n\n  // run-time results\n   int eof;\n   enum STBVorbisError error;\n\n  // user-useful data\n\n  // header info\n   int blocksize[2];\n   int blocksize_0, blocksize_1;\n   int codebook_count;\n   Codebook *codebooks;\n   int floor_count;\n   uint16 floor_types[64]; // varies\n   Floor *floor_config;\n   int residue_count;\n   uint16 residue_types[64]; // varies\n   Residue *residue_config;\n   int mapping_count;\n   Mapping *mapping;\n   int mode_count;\n   Mode mode_config[64];  // varies\n\n   uint32 total_samples;\n\n  // decode buffer\n   float *channel_buffers[STB_VORBIS_MAX_CHANNELS];\n   float *outputs        [STB_VORBIS_MAX_CHANNELS];\n\n   float *previous_window[STB_VORBIS_MAX_CHANNELS];\n   int previous_length;\n\n   #ifndef STB_VORBIS_NO_DEFER_FLOOR\n   int16 *finalY[STB_VORBIS_MAX_CHANNELS];\n   #else\n   float *floor_buffers[STB_VORBIS_MAX_CHANNELS];\n   #endif\n\n   uint32 current_loc; // sample location of next frame to decode\n   int    current_loc_valid;\n\n  // per-blocksize precomputed data\n   \n   // twiddle factors\n   float *A[2],*B[2],*C[2];\n   float *window[2];\n   uint16 *bit_reverse[2];\n\n  // current page/packet/segment streaming info\n   uint32 serial; // stream serial number for verification\n   int last_page;\n   int segment_count;\n   uint8 segments[255];\n   uint8 page_flag;\n   uint8 bytes_in_seg;\n   uint8 first_decode;\n   int next_seg;\n   int last_seg;  // flag that we're on the last segment\n   int last_seg_which; // what was the segment number of the last seg?\n   uint32 acc;\n   int valid_bits;\n   int packet_bytes;\n   int end_seg_with_known_loc;\n   uint32 known_loc_for_packet;\n   int discard_samples_deferred;\n   uint32 samples_output;\n\n  // push mode scanning\n   int page_crc_tests; // only in push_mode: number of tests active; -1 if not searching\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n   CRCscan scan[STB_VORBIS_PUSHDATA_CRC_COUNT];\n#endif\n\n  // sample-access\n   int channel_buffer_start;\n   int channel_buffer_end;\n};\n\n#if defined(STB_VORBIS_NO_PUSHDATA_API)\n   #define IS_PUSH_MODE(f)   FALSE\n#elif defined(STB_VORBIS_NO_PULLDATA_API)\n   #define IS_PUSH_MODE(f)   TRUE\n#else\n   #define IS_PUSH_MODE(f)   ((f)->push_mode)\n#endif\n\ntypedef struct stb_vorbis vorb;\n\nstatic int error(vorb *f, enum STBVorbisError e)\n{\n   f->error = e;\n   if (!f->eof && e != VORBIS_need_more_data) {\n      f->error=e; // breakpoint for debugging\n   }\n   return 0;\n}\n\n\n// these functions are used for allocating temporary memory\n// while decoding. if you can afford the stack space, use\n// alloca(); otherwise, provide a temp buffer and it will\n// allocate out of those.\n\n#define array_size_required(count,size)  (count*(sizeof(void *)+(size)))\n\n#define temp_alloc(f,size)              (f->alloc.alloc_buffer ? setup_temp_malloc(f,size) : alloca(size))\n#define temp_free(f,p)                  0\n#define temp_alloc_save(f)              ((f)->temp_offset)\n#define temp_alloc_restore(f,p)         ((f)->temp_offset = (p))\n\n#define temp_block_array(f,count,size)  make_block_array(temp_alloc(f,array_size_required(count,size)), count, size)\n\n// given a sufficiently large block of memory, make an array of pointers to subblocks of it\nstatic void *make_block_array(void *mem, int count, int size)\n{\n   int i;\n   void ** p = (void **) mem;\n   char *q = (char *) (p + count);\n   for (i=0; i < count; ++i) {\n      p[i] = q;\n      q += size;\n   }\n   return p;\n}\n\nstatic void *setup_malloc(vorb *f, int sz)\n{\n   sz = (sz+3) & ~3;\n   f->setup_memory_required += sz;\n   if (f->alloc.alloc_buffer) {\n      void *p = (char *) f->alloc.alloc_buffer + f->setup_offset;\n      if (f->setup_offset + sz > f->temp_offset) return NULL;\n      f->setup_offset += sz;\n      return p;\n   }\n   return sz ? malloc(sz) : NULL;\n}\n\nstatic void setup_free(vorb *f, void *p)\n{\n   if (f->alloc.alloc_buffer) return; // do nothing; setup mem is a stack\n   free(p);\n}\n\nstatic void *setup_temp_malloc(vorb *f, int sz)\n{\n   sz = (sz+3) & ~3;\n   if (f->alloc.alloc_buffer) {\n      if (f->temp_offset - sz < f->setup_offset) return NULL;\n      f->temp_offset -= sz;\n      return (char *) f->alloc.alloc_buffer + f->temp_offset;\n   }\n   return malloc(sz);\n}\n\nstatic void setup_temp_free(vorb *f, void *p, int sz)\n{\n   if (f->alloc.alloc_buffer) {\n      f->temp_offset += (sz+3)&~3;\n      return;\n   }\n   free(p);\n}\n\n#define CRC32_POLY    0x04c11db7   // from spec\n\nstatic uint32 crc_table[256];\nstatic void crc32_init(void)\n{\n   int i,j;\n   uint32 s;\n   for(i=0; i < 256; i++) {\n      for (s=(uint32) i << 24, j=0; j < 8; ++j)\n         s = (s << 1) ^ (s >= (1U<<31) ? CRC32_POLY : 0);\n      crc_table[i] = s;\n   }\n}\n\nstatic __forceinline uint32 crc32_update(uint32 crc, uint8 byte)\n{\n   return (crc << 8) ^ crc_table[byte ^ (crc >> 24)];\n}\n\n\n// used in setup, and for huffman that doesn't go fast path\nstatic unsigned int bit_reverse(unsigned int n)\n{\n  n = ((n & 0xAAAAAAAA) >>  1) | ((n & 0x55555555) << 1);\n  n = ((n & 0xCCCCCCCC) >>  2) | ((n & 0x33333333) << 2);\n  n = ((n & 0xF0F0F0F0) >>  4) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n & 0xFF00FF00) >>  8) | ((n & 0x00FF00FF) << 8);\n  return (n >> 16) | (n << 16);\n}\n\nstatic float square(float x)\n{\n   return x*x;\n}\n\n// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3\n// as required by the specification. fast(?) implementation from stb.h\n// @OPTIMIZE: called multiple times per-packet with \"constants\"; move to setup\nstatic int ilog(int32 n)\n{\n   static signed char log2_4[16] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 };\n\n   if (n < 0) return 0; // signed n returns 0\n\n   // 2 compares if n < 16, 3 compares otherwise (4 if signed or n > 1<<29)\n   if (n < (1 << 14))\n        if (n < (1 <<  4))            return  0 + log2_4[n      ];\n        else if (n < (1 <<  9))       return  5 + log2_4[n >>  5];\n             else                     return 10 + log2_4[n >> 10];\n   else if (n < (1 << 24))\n             if (n < (1 << 19))       return 15 + log2_4[n >> 15];\n             else                     return 20 + log2_4[n >> 20];\n        else if (n < (1 << 29))       return 25 + log2_4[n >> 25];\n             else                     return 30 + log2_4[n >> 30];\n}\n\n#ifndef M_PI\n  #define M_PI  3.14159265358979323846264f  // from CRC\n#endif\n\n// code length assigned to a value with no huffman encoding\n#define NO_CODE   255\n\n/////////////////////// LEAF SETUP FUNCTIONS //////////////////////////\n//\n// these functions are only called at setup, and only a few times\n// per file\n\nstatic float float32_unpack(uint32 x)\n{\n   // from the specification\n   uint32 mantissa = x & 0x1fffff;\n   uint32 sign = x & 0x80000000;\n   uint32 exp = (x & 0x7fe00000) >> 21;\n   double res = sign ? -(double)mantissa : (double)mantissa;\n   return (float) ldexp((float)res, exp-788);\n}\n\n\n// zlib & jpeg huffman tables assume that the output symbols\n// can either be arbitrarily arranged, or have monotonically\n// increasing frequencies--they rely on the lengths being sorted;\n// this makes for a very simple generation algorithm.\n// vorbis allows a huffman table with non-sorted lengths. This\n// requires a more sophisticated construction, since symbols in\n// order do not map to huffman codes \"in order\".\nstatic void add_entry(Codebook *c, uint32 huff_code, int symbol, int count, int len, uint32 *values)\n{\n   if (!c->sparse) {\n      c->codewords      [symbol] = huff_code;\n   } else {\n      c->codewords       [count] = huff_code;\n      c->codeword_lengths[count] = len;\n      values             [count] = symbol;\n   }\n}\n\nstatic int compute_codewords(Codebook *c, uint8 *len, int n, uint32 *values)\n{\n   int i,k,m=0;\n   uint32 available[32];\n\n   memset(available, 0, sizeof(available));\n   // find the first entry\n   for (k=0; k < n; ++k) if (len[k] < NO_CODE) break;\n   if (k == n) { assert(c->sorted_entries == 0); return TRUE; }\n   // add to the list\n   add_entry(c, 0, k, m++, len[k], values);\n   // add all available leaves\n   for (i=1; i <= len[k]; ++i)\n      available[i] = 1U << (32-i);\n   // note that the above code treats the first case specially,\n   // but it's really the same as the following code, so they\n   // could probably be combined (except the initial code is 0,\n   // and I use 0 in available[] to mean 'empty')\n   for (i=k+1; i < n; ++i) {\n      uint32 res;\n      int z = len[i], y;\n      if (z == NO_CODE) continue;\n      // find lowest available leaf (should always be earliest,\n      // which is what the specification calls for)\n      // note that this property, and the fact we can never have\n      // more than one free leaf at a given level, isn't totally\n      // trivial to prove, but it seems true and the assert never\n      // fires, so!\n      while (z > 0 && !available[z]) --z;\n      if (z == 0) { return FALSE; }\n      res = available[z];\n      assert(z >= 0 && z < 32);\n      available[z] = 0;\n      add_entry(c, bit_reverse(res), i, m++, len[i], values);\n      // propagate availability up the tree\n      if (z != len[i]) {\n         assert(len[i] >= 0 && len[i] < 32);\n         for (y=len[i]; y > z; --y) {\n            assert(available[y] == 0);\n            available[y] = res + (1 << (32-y));\n         }\n      }\n   }\n   return TRUE;\n}\n\n// accelerated huffman table allows fast O(1) match of all symbols\n// of length <= STB_VORBIS_FAST_HUFFMAN_LENGTH\nstatic void compute_accelerated_huffman(Codebook *c)\n{\n   int i, len;\n   for (i=0; i < FAST_HUFFMAN_TABLE_SIZE; ++i)\n      c->fast_huffman[i] = -1;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n   if (len > 32767) len = 32767; // largest possible value we can encode!\n   #endif\n   for (i=0; i < len; ++i) {\n      if (c->codeword_lengths[i] <= STB_VORBIS_FAST_HUFFMAN_LENGTH) {\n         uint32 z = c->sparse ? bit_reverse(c->sorted_codewords[i]) : c->codewords[i];\n         // set table entries for all bit combinations in the higher bits\n         while (z < FAST_HUFFMAN_TABLE_SIZE) {\n             c->fast_huffman[z] = i;\n             z += 1 << c->codeword_lengths[i];\n         }\n      }\n   }\n}\n\n#ifdef _MSC_VER\n#define STBV_CDECL __cdecl\n#else\n#define STBV_CDECL\n#endif\n\nstatic int STBV_CDECL uint32_compare(const void *p, const void *q)\n{\n   uint32 x = * (uint32 *) p;\n   uint32 y = * (uint32 *) q;\n   return x < y ? -1 : x > y;\n}\n\nstatic int include_in_sort(Codebook *c, uint8 len)\n{\n   if (c->sparse) { assert(len != NO_CODE); return TRUE; }\n   if (len == NO_CODE) return FALSE;\n   if (len > STB_VORBIS_FAST_HUFFMAN_LENGTH) return TRUE;\n   return FALSE;\n}\n\n// if the fast table above doesn't work, we want to binary\n// search them... need to reverse the bits\nstatic void compute_sorted_huffman(Codebook *c, uint8 *lengths, uint32 *values)\n{\n   int i, len;\n   // build a list of all the entries\n   // OPTIMIZATION: don't include the short ones, since they'll be caught by FAST_HUFFMAN.\n   // this is kind of a frivolous optimization--I don't see any performance improvement,\n   // but it's like 4 extra lines of code, so.\n   if (!c->sparse) {\n      int k = 0;\n      for (i=0; i < c->entries; ++i)\n         if (include_in_sort(c, lengths[i])) \n            c->sorted_codewords[k++] = bit_reverse(c->codewords[i]);\n      assert(k == c->sorted_entries);\n   } else {\n      for (i=0; i < c->sorted_entries; ++i)\n         c->sorted_codewords[i] = bit_reverse(c->codewords[i]);\n   }\n\n   qsort(c->sorted_codewords, c->sorted_entries, sizeof(c->sorted_codewords[0]), uint32_compare);\n   c->sorted_codewords[c->sorted_entries] = 0xffffffff;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   // now we need to indicate how they correspond; we could either\n   //   #1: sort a different data structure that says who they correspond to\n   //   #2: for each sorted entry, search the original list to find who corresponds\n   //   #3: for each original entry, find the sorted entry\n   // #1 requires extra storage, #2 is slow, #3 can use binary search!\n   for (i=0; i < len; ++i) {\n      int huff_len = c->sparse ? lengths[values[i]] : lengths[i];\n      if (include_in_sort(c,huff_len)) {\n         uint32 code = bit_reverse(c->codewords[i]);\n         int x=0, n=c->sorted_entries;\n         while (n > 1) {\n            // invariant: sc[x] <= code < sc[x+n]\n            int m = x + (n >> 1);\n            if (c->sorted_codewords[m] <= code) {\n               x = m;\n               n -= (n>>1);\n            } else {\n               n >>= 1;\n            }\n         }\n         assert(c->sorted_codewords[x] == code);\n         if (c->sparse) {\n            c->sorted_values[x] = values[i];\n            c->codeword_lengths[x] = huff_len;\n         } else {\n            c->sorted_values[x] = i;\n         }\n      }\n   }\n}\n\n// only run while parsing the header (3 times)\nstatic int vorbis_validate(uint8 *data)\n{\n   static uint8 vorbis[6] = { 'v', 'o', 'r', 'b', 'i', 's' };\n   return memcmp(data, vorbis, 6) == 0;\n}\n\n// called from setup only, once per code book\n// (formula implied by specification)\nstatic int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) / dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n      ++r;                                              // floor() to avoid _ftol() when non-CRT\n   if (pow((float) r+1, dim) <= entries)\n      return -1;\n   if ((int) floor(pow((float) r, dim)) > entries)\n      return -1;\n   return r;\n}\n\n// called twice per file\nstatic void compute_twiddle_factors(int n, float *A, float *B, float *C)\n{\n   int n4 = n >> 2, n8 = n >> 3;\n   int k,k2;\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2) * 0.5f;\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2) * 0.5f;\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n}\n\nstatic void compute_window(int n, float *window)\n{\n   int n2 = n >> 1, i;\n   for (i=0; i < n2; ++i)\n      window[i] = (float) sin(0.5 * M_PI * square((float) sin((i - 0 + 0.5) / n2 * 0.5 * M_PI)));\n}\n\nstatic void compute_bitreverse(int n, uint16 *rev)\n{\n   int ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   int i, n8 = n >> 3;\n   for (i=0; i < n8; ++i)\n      rev[i] = (bit_reverse(i) >> (32-ld+3)) << 2;\n}\n\nstatic int init_blocksize(vorb *f, int b, int n)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3;\n   f->A[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->B[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->C[b] = (float *) setup_malloc(f, sizeof(float) * n4);\n   if (!f->A[b] || !f->B[b] || !f->C[b]) return error(f, VORBIS_outofmem);\n   compute_twiddle_factors(n, f->A[b], f->B[b], f->C[b]);\n   f->window[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   if (!f->window[b]) return error(f, VORBIS_outofmem);\n   compute_window(n, f->window[b]);\n   f->bit_reverse[b] = (uint16 *) setup_malloc(f, sizeof(uint16) * n8);\n   if (!f->bit_reverse[b]) return error(f, VORBIS_outofmem);\n   compute_bitreverse(n, f->bit_reverse[b]);\n   return TRUE;\n}\n\nstatic void neighbors(uint16 *x, int n, int *plow, int *phigh)\n{\n   int low = -1;\n   int high = 65536;\n   int i;\n   for (i=0; i < n; ++i) {\n      if (x[i] > low  && x[i] < x[n]) { *plow  = i; low = x[i]; }\n      if (x[i] < high && x[i] > x[n]) { *phigh = i; high = x[i]; }\n   }\n}\n\n// this has been repurposed so y is now the original index instead of y\ntypedef struct\n{\n   uint16 x,id;\n} stbv__floor_ordering;\n\nstatic int STBV_CDECL point_compare(const void *p, const void *q)\n{\n   stbv__floor_ordering *a = (stbv__floor_ordering *) p;\n   stbv__floor_ordering *b = (stbv__floor_ordering *) q;\n   return a->x < b->x ? -1 : a->x > b->x;\n}\n\n//\n/////////////////////// END LEAF SETUP FUNCTIONS //////////////////////////\n\n\n#if defined(STB_VORBIS_NO_STDIO)\n   #define USE_MEMORY(z)    TRUE\n#else\n   #define USE_MEMORY(z)    ((z)->stream)\n#endif\n\nstatic uint8 get8(vorb *z)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream >= z->stream_end) { z->eof = TRUE; return 0; }\n      return *z->stream++;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n   int c = fgetc(z->f);\n   if (c == EOF) { z->eof = TRUE; return 0; }\n   return c;\n   }\n   #endif\n}\n\nstatic uint32 get32(vorb *f)\n{\n   uint32 x;\n   x = get8(f);\n   x += get8(f) << 8;\n   x += get8(f) << 16;\n   x += (uint32) get8(f) << 24;\n   return x;\n}\n\nstatic int getn(vorb *z, uint8 *data, int n)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream+n > z->stream_end) { z->eof = 1; return 0; }\n      memcpy(data, z->stream, n);\n      z->stream += n;\n      return 1;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO   \n   if (fread(data, n, 1, z->f) == 1)\n      return 1;\n   else {\n      z->eof = 1;\n      return 0;\n   }\n   #endif\n}\n\nstatic void skip(vorb *z, int n)\n{\n   if (USE_MEMORY(z)) {\n      z->stream += n;\n      if (z->stream >= z->stream_end) z->eof = 1;\n      return;\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n      long x = ftell(z->f);\n      fseek(z->f, x+n, SEEK_SET);\n   }\n   #endif\n}\n\nstatic int set_file_offset(stb_vorbis *f, unsigned int loc)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   f->eof = 0;\n   if (USE_MEMORY(f)) {\n      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n         f->stream = f->stream_end;\n         f->eof = 1;\n         return 0;\n      } else {\n         f->stream = f->stream_start + loc;\n         return 1;\n      }\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (loc + f->f_start < loc || loc >= 0x80000000) {\n      loc = 0x7fffffff;\n      f->eof = 1;\n   } else {\n      loc += f->f_start;\n   }\n   if (!fseek(f->f, loc, SEEK_SET))\n      return 1;\n   f->eof = 1;\n   fseek(f->f, f->f_start, SEEK_END);\n   return 0;\n   #endif\n}\n\n\nstatic uint8 ogg_page_header[4] = { 0x4f, 0x67, 0x67, 0x53 };\n\nstatic int capture_pattern(vorb *f)\n{\n   if (0x4f != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x53 != get8(f)) return FALSE;\n   return TRUE;\n}\n\n#define PAGEFLAG_continued_packet   1\n#define PAGEFLAG_first_page         2\n#define PAGEFLAG_last_page          4\n\nstatic int start_page_no_capturepattern(vorb *f)\n{\n   uint32 loc0,loc1,n;\n   // stream structure version\n   if (0 != get8(f)) return error(f, VORBIS_invalid_stream_structure_version);\n   // header flag\n   f->page_flag = get8(f);\n   // absolute granule position\n   loc0 = get32(f); \n   loc1 = get32(f);\n   // @TODO: validate loc0,loc1 as valid positions?\n   // stream serial number -- vorbis doesn't interleave, so discard\n   get32(f);\n   //if (f->serial != get32(f)) return error(f, VORBIS_incorrect_stream_serial_number);\n   // page sequence number\n   n = get32(f);\n   f->last_page = n;\n   // CRC32\n   get32(f);\n   // page_segments\n   f->segment_count = get8(f);\n   if (!getn(f, f->segments, f->segment_count))\n      return error(f, VORBIS_unexpected_eof);\n   // assume we _don't_ know any the sample position of any segments\n   f->end_seg_with_known_loc = -2;\n   if (loc0 != ~0U || loc1 != ~0U) {\n      int i;\n      // determine which packet is the last one that will complete\n      for (i=f->segment_count-1; i >= 0; --i)\n         if (f->segments[i] < 255)\n            break;\n      // 'i' is now the index of the _last_ segment of a packet that ends\n      if (i >= 0) {\n         f->end_seg_with_known_loc = i;\n         f->known_loc_for_packet   = loc0;\n      }\n   }\n   if (f->first_decode) {\n      int i,len;\n      ProbedPage p;\n      len = 0;\n      for (i=0; i < f->segment_count; ++i)\n         len += f->segments[i];\n      len += 27 + f->segment_count;\n      p.page_start = f->first_audio_page_offset;\n      p.page_end = p.page_start + len;\n      p.last_decoded_sample = loc0;\n      f->p_first = p;\n   }\n   f->next_seg = 0;\n   return TRUE;\n}\n\nstatic int start_page(vorb *f)\n{\n   if (!capture_pattern(f)) return error(f, VORBIS_missing_capture_pattern);\n   return start_page_no_capturepattern(f);\n}\n\nstatic int start_packet(vorb *f)\n{\n   while (f->next_seg == -1) {\n      if (!start_page(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet)\n         return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   // f->next_seg is now valid\n   return TRUE;\n}\n\nstatic int maybe_start_packet(vorb *f)\n{\n   if (f->next_seg == -1) {\n      int x = get8(f);\n      if (f->eof) return FALSE; // EOF at page boundary is not an error!\n      if (0x4f != x      ) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x53 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (!start_page_no_capturepattern(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet) {\n         // set up enough state that we can read this packet if we want,\n         // e.g. during recovery\n         f->last_seg = FALSE;\n         f->bytes_in_seg = 0;\n         return error(f, VORBIS_continued_packet_flag_invalid);\n      }\n   }\n   return start_packet(f);\n}\n\nstatic int next_segment(vorb *f)\n{\n   int len;\n   if (f->last_seg) return 0;\n   if (f->next_seg == -1) {\n      f->last_seg_which = f->segment_count-1; // in case start_page fails\n      if (!start_page(f)) { f->last_seg = 1; return 0; }\n      if (!(f->page_flag & PAGEFLAG_continued_packet)) return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   len = f->segments[f->next_seg++];\n   if (len < 255) {\n      f->last_seg = TRUE;\n      f->last_seg_which = f->next_seg-1;\n   }\n   if (f->next_seg >= f->segment_count)\n      f->next_seg = -1;\n   assert(f->bytes_in_seg == 0);\n   f->bytes_in_seg = len;\n   return len;\n}\n\n#define EOP    (-1)\n#define INVALID_BITS  (-1)\n\nstatic int get8_packet_raw(vorb *f)\n{\n   if (!f->bytes_in_seg) {  // CLANG!\n      if (f->last_seg) return EOP;\n      else if (!next_segment(f)) return EOP;\n   }\n   assert(f->bytes_in_seg > 0);\n   --f->bytes_in_seg;\n   ++f->packet_bytes;\n   return get8(f);\n}\n\nstatic int get8_packet(vorb *f)\n{\n   int x = get8_packet_raw(f);\n   f->valid_bits = 0;\n   return x;\n}\n\nstatic void flush_packet(vorb *f)\n{\n   while (get8_packet_raw(f) != EOP);\n}\n\n// @OPTIMIZE: this is the secondary bit decoder, so it's probably not as important\n// as the huffman decoder?\nstatic uint32 get_bits(vorb *f, int n)\n{\n   uint32 z;\n\n   if (f->valid_bits < 0) return 0;\n   if (f->valid_bits < n) {\n      if (n > 24) {\n         // the accumulator technique below would not work correctly in this case\n         z = get_bits(f, 24);\n         z += get_bits(f, n-24) << 24;\n         return z;\n      }\n      if (f->valid_bits == 0) f->acc = 0;\n      while (f->valid_bits < n) {\n         int z = get8_packet_raw(f);\n         if (z == EOP) {\n            f->valid_bits = INVALID_BITS;\n            return 0;\n         }\n         f->acc += z << f->valid_bits;\n         f->valid_bits += 8;\n      }\n   }\n   if (f->valid_bits < 0) return 0;\n   z = f->acc & ((1 << n)-1);\n   f->acc >>= n;\n   f->valid_bits -= n;\n   return z;\n}\n\n// @OPTIMIZE: primary accumulator for huffman\n// expand the buffer to as many bits as possible without reading off end of packet\n// it might be nice to allow f->valid_bits and f->acc to be stored in registers,\n// e.g. cache them locally and decode locally\nstatic __forceinline void prep_huffman(vorb *f)\n{\n   if (f->valid_bits <= 24) {\n      if (f->valid_bits == 0) f->acc = 0;\n      do {\n         int z;\n         if (f->last_seg && !f->bytes_in_seg) return;\n         z = get8_packet_raw(f);\n         if (z == EOP) return;\n         f->acc += (unsigned) z << f->valid_bits;\n         f->valid_bits += 8;\n      } while (f->valid_bits <= 24);\n   }\n}\n\nenum\n{\n   VORBIS_packet_id = 1,\n   VORBIS_packet_comment = 3,\n   VORBIS_packet_setup = 5\n};\n\nstatic int codebook_decode_scalar_raw(vorb *f, Codebook *c)\n{\n   int i;\n   prep_huffman(f);\n\n   if (c->codewords == NULL && c->sorted_codewords == NULL)\n      return -1;\n\n   // cases to use binary search: sorted_codewords && !c->codewords\n   //                             sorted_codewords && c->entries > 8\n   if (c->entries > 8 ? c->sorted_codewords!=NULL : !c->codewords) {\n      // binary search\n      uint32 code = bit_reverse(f->acc);\n      int x=0, n=c->sorted_entries, len;\n\n      while (n > 1) {\n         // invariant: sc[x] <= code < sc[x+n]\n         int m = x + (n >> 1);\n         if (c->sorted_codewords[m] <= code) {\n            x = m;\n            n -= (n>>1);\n         } else {\n            n >>= 1;\n         }\n      }\n      // x is now the sorted index\n      if (!c->sparse) x = c->sorted_values[x];\n      // x is now sorted index if sparse, or symbol otherwise\n      len = c->codeword_lengths[x];\n      if (f->valid_bits >= len) {\n         f->acc >>= len;\n         f->valid_bits -= len;\n         return x;\n      }\n\n      f->valid_bits = 0;\n      return -1;\n   }\n\n   // if small, linear search\n   assert(!c->sparse);\n   for (i=0; i < c->entries; ++i) {\n      if (c->codeword_lengths[i] == NO_CODE) continue;\n      if (c->codewords[i] == (f->acc & ((1 << c->codeword_lengths[i])-1))) {\n         if (f->valid_bits >= c->codeword_lengths[i]) {\n            f->acc >>= c->codeword_lengths[i];\n            f->valid_bits -= c->codeword_lengths[i];\n            return i;\n         }\n         f->valid_bits = 0;\n         return -1;\n      }\n   }\n\n   error(f, VORBIS_invalid_stream);\n   f->valid_bits = 0;\n   return -1;\n}\n\n#ifndef STB_VORBIS_NO_INLINE_DECODE\n\n#define DECODE_RAW(var, f,c)                                  \\\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)        \\\n      prep_huffman(f);                                        \\\n   var = f->acc & FAST_HUFFMAN_TABLE_MASK;                    \\\n   var = c->fast_huffman[var];                                \\\n   if (var >= 0) {                                            \\\n      int n = c->codeword_lengths[var];                       \\\n      f->acc >>= n;                                           \\\n      f->valid_bits -= n;                                     \\\n      if (f->valid_bits < 0) { f->valid_bits = 0; var = -1; } \\\n   } else {                                                   \\\n      var = codebook_decode_scalar_raw(f,c);                  \\\n   }\n\n#else\n\nstatic int codebook_decode_scalar(vorb *f, Codebook *c)\n{\n   int i;\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)\n      prep_huffman(f);\n   // fast huffman table lookup\n   i = f->acc & FAST_HUFFMAN_TABLE_MASK;\n   i = c->fast_huffman[i];\n   if (i >= 0) {\n      f->acc >>= c->codeword_lengths[i];\n      f->valid_bits -= c->codeword_lengths[i];\n      if (f->valid_bits < 0) { f->valid_bits = 0; return -1; }\n      return i;\n   }\n   return codebook_decode_scalar_raw(f,c);\n}\n\n#define DECODE_RAW(var,f,c)    var = codebook_decode_scalar(f,c);\n\n#endif\n\n#define DECODE(var,f,c)                                       \\\n   DECODE_RAW(var,f,c)                                        \\\n   if (c->sparse) var = c->sorted_values[var];\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n  #define DECODE_VQ(var,f,c)   DECODE_RAW(var,f,c)\n#else\n  #define DECODE_VQ(var,f,c)   DECODE(var,f,c)\n#endif\n\n\n\n\n\n\n// CODEBOOK_ELEMENT_FAST is an optimization for the CODEBOOK_FLOATS case\n// where we avoid one addition\n#define CODEBOOK_ELEMENT(c,off)          (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_FAST(c,off)     (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_BASE(c)         (0)\n\nstatic int codebook_decode_start(vorb *f, Codebook *c)\n{\n   int z = -1;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)\n      error(f, VORBIS_invalid_stream);\n   else {\n      DECODE_VQ(z,f,c);\n      if (c->sparse) assert(z < c->sorted_entries);\n      if (z < 0) {  // check for EOP\n         if (!f->bytes_in_seg)\n            if (f->last_seg)\n               return z;\n         error(f, VORBIS_invalid_stream);\n      }\n   }\n   return z;\n}\n\nstatic int codebook_decode(vorb *f, Codebook *c, float *output, int len)\n{\n   int i,z = codebook_decode_start(f,c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i] += val;\n         if (c->sequence_p) last = val + c->minimum_value;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   if (c->sequence_p) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n         output[i] += val;\n         last = val + c->minimum_value;\n      }\n   } else {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         output[i] += CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      }\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_step(vorb *f, Codebook *c, float *output, int len, int step)\n{\n   int i,z = codebook_decode_start(f,c);\n   float last = CODEBOOK_ELEMENT_BASE(c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i*step] += val;\n         if (c->sequence_p) last = val;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   for (i=0; i < len; ++i) {\n      float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      output[i*step] += val;\n      if (c->sequence_p) last = val;\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_deinterleave_repeat(vorb *f, Codebook *c, float **outputs, int ch, int *c_inter_p, int *p_inter_p, int len, int total_decode)\n{\n   int c_inter = *c_inter_p;\n   int p_inter = *p_inter_p;\n   int i,z, effective = c->dimensions;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)   return error(f, VORBIS_invalid_stream);\n\n   while (total_decode > 0) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      DECODE_VQ(z,f,c);\n      #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      assert(!c->sparse || z < c->sorted_entries);\n      #endif\n      if (z < 0) {\n         if (!f->bytes_in_seg)\n            if (f->last_seg) return FALSE;\n         return error(f, VORBIS_invalid_stream);\n      }\n\n      // if this will take us off the end of the buffers, stop short!\n      // we check by computing the length of the virtual interleaved\n      // buffer (len*ch), our current offset within it (p_inter*ch)+(c_inter),\n      // and the length we'll be using (effective)\n      if (c_inter + p_inter*ch + effective > len * ch) {\n         effective = len*ch - (p_inter*ch - c_inter);\n      }\n\n   #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      if (c->lookup_type == 1) {\n         int div = 1;\n         for (i=0; i < effective; ++i) {\n            int off = (z / div) % c->lookup_values;\n            float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n            if (outputs[c_inter])\n               outputs[c_inter][p_inter] += val;\n            if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            if (c->sequence_p) last = val;\n            div *= c->lookup_values;\n         }\n      } else\n   #endif\n      {\n         z *= c->dimensions;\n         if (c->sequence_p) {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n               last = val;\n            }\n         } else {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            }\n         }\n      }\n\n      total_decode -= effective;\n   }\n   *c_inter_p = c_inter;\n   *p_inter_p = p_inter;\n   return TRUE;\n}\n\nstatic int predict_point(int x, int x0, int x1, int y0, int y1)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   // @OPTIMIZE: force int division to round in the right direction... is this necessary on x86?\n   int err = abs(dy) * (x - x0);\n   int off = err / adx;\n   return dy < 0 ? y0 - off : y0 + off;\n}\n\n// the following table is block-copied from the specification\nstatic float inverse_db_table[256] =\n{\n  1.0649863e-07f, 1.1341951e-07f, 1.2079015e-07f, 1.2863978e-07f, \n  1.3699951e-07f, 1.4590251e-07f, 1.5538408e-07f, 1.6548181e-07f, \n  1.7623575e-07f, 1.8768855e-07f, 1.9988561e-07f, 2.1287530e-07f, \n  2.2670913e-07f, 2.4144197e-07f, 2.5713223e-07f, 2.7384213e-07f, \n  2.9163793e-07f, 3.1059021e-07f, 3.3077411e-07f, 3.5226968e-07f, \n  3.7516214e-07f, 3.9954229e-07f, 4.2550680e-07f, 4.5315863e-07f, \n  4.8260743e-07f, 5.1396998e-07f, 5.4737065e-07f, 5.8294187e-07f, \n  6.2082472e-07f, 6.6116941e-07f, 7.0413592e-07f, 7.4989464e-07f, \n  7.9862701e-07f, 8.5052630e-07f, 9.0579828e-07f, 9.6466216e-07f, \n  1.0273513e-06f, 1.0941144e-06f, 1.1652161e-06f, 1.2409384e-06f, \n  1.3215816e-06f, 1.4074654e-06f, 1.4989305e-06f, 1.5963394e-06f, \n  1.7000785e-06f, 1.8105592e-06f, 1.9282195e-06f, 2.0535261e-06f, \n  2.1869758e-06f, 2.3290978e-06f, 2.4804557e-06f, 2.6416497e-06f, \n  2.8133190e-06f, 2.9961443e-06f, 3.1908506e-06f, 3.3982101e-06f, \n  3.6190449e-06f, 3.8542308e-06f, 4.1047004e-06f, 4.3714470e-06f, \n  4.6555282e-06f, 4.9580707e-06f, 5.2802740e-06f, 5.6234160e-06f, \n  5.9888572e-06f, 6.3780469e-06f, 6.7925283e-06f, 7.2339451e-06f, \n  7.7040476e-06f, 8.2047000e-06f, 8.7378876e-06f, 9.3057248e-06f, \n  9.9104632e-06f, 1.0554501e-05f, 1.1240392e-05f, 1.1970856e-05f, \n  1.2748789e-05f, 1.3577278e-05f, 1.4459606e-05f, 1.5399272e-05f, \n  1.6400004e-05f, 1.7465768e-05f, 1.8600792e-05f, 1.9809576e-05f, \n  2.1096914e-05f, 2.2467911e-05f, 2.3928002e-05f, 2.5482978e-05f, \n  2.7139006e-05f, 2.8902651e-05f, 3.0780908e-05f, 3.2781225e-05f, \n  3.4911534e-05f, 3.7180282e-05f, 3.9596466e-05f, 4.2169667e-05f, \n  4.4910090e-05f, 4.7828601e-05f, 5.0936773e-05f, 5.4246931e-05f, \n  5.7772202e-05f, 6.1526565e-05f, 6.5524908e-05f, 6.9783085e-05f, \n  7.4317983e-05f, 7.9147585e-05f, 8.4291040e-05f, 8.9768747e-05f, \n  9.5602426e-05f, 0.00010181521f, 0.00010843174f, 0.00011547824f, \n  0.00012298267f, 0.00013097477f, 0.00013948625f, 0.00014855085f, \n  0.00015820453f, 0.00016848555f, 0.00017943469f, 0.00019109536f, \n  0.00020351382f, 0.00021673929f, 0.00023082423f, 0.00024582449f, \n  0.00026179955f, 0.00027881276f, 0.00029693158f, 0.00031622787f, \n  0.00033677814f, 0.00035866388f, 0.00038197188f, 0.00040679456f, \n  0.00043323036f, 0.00046138411f, 0.00049136745f, 0.00052329927f, \n  0.00055730621f, 0.00059352311f, 0.00063209358f, 0.00067317058f, \n  0.00071691700f, 0.00076350630f, 0.00081312324f, 0.00086596457f, \n  0.00092223983f, 0.00098217216f, 0.0010459992f,  0.0011139742f, \n  0.0011863665f,  0.0012634633f,  0.0013455702f,  0.0014330129f, \n  0.0015261382f,  0.0016253153f,  0.0017309374f,  0.0018434235f, \n  0.0019632195f,  0.0020908006f,  0.0022266726f,  0.0023713743f, \n  0.0025254795f,  0.0026895994f,  0.0028643847f,  0.0030505286f, \n  0.0032487691f,  0.0034598925f,  0.0036847358f,  0.0039241906f, \n  0.0041792066f,  0.0044507950f,  0.0047400328f,  0.0050480668f, \n  0.0053761186f,  0.0057254891f,  0.0060975636f,  0.0064938176f, \n  0.0069158225f,  0.0073652516f,  0.0078438871f,  0.0083536271f, \n  0.0088964928f,  0.009474637f,   0.010090352f,   0.010746080f, \n  0.011444421f,   0.012188144f,   0.012980198f,   0.013823725f, \n  0.014722068f,   0.015678791f,   0.016697687f,   0.017782797f, \n  0.018938423f,   0.020169149f,   0.021479854f,   0.022875735f, \n  0.024362330f,   0.025945531f,   0.027631618f,   0.029427276f, \n  0.031339626f,   0.033376252f,   0.035545228f,   0.037855157f, \n  0.040315199f,   0.042935108f,   0.045725273f,   0.048696758f, \n  0.051861348f,   0.055231591f,   0.058820850f,   0.062643361f, \n  0.066714279f,   0.071049749f,   0.075666962f,   0.080584227f, \n  0.085821044f,   0.091398179f,   0.097337747f,   0.10366330f, \n  0.11039993f,    0.11757434f,    0.12521498f,    0.13335215f, \n  0.14201813f,    0.15124727f,    0.16107617f,    0.17154380f, \n  0.18269168f,    0.19456402f,    0.20720788f,    0.22067342f, \n  0.23501402f,    0.25028656f,    0.26655159f,    0.28387361f, \n  0.30232132f,    0.32196786f,    0.34289114f,    0.36517414f, \n  0.38890521f,    0.41417847f,    0.44109412f,    0.46975890f, \n  0.50028648f,    0.53279791f,    0.56742212f,    0.60429640f, \n  0.64356699f,    0.68538959f,    0.72993007f,    0.77736504f, \n  0.82788260f,    0.88168307f,    0.9389798f,     1.0f\n};\n\n\n// @OPTIMIZE: if you want to replace this bresenham line-drawing routine,\n// note that you must produce bit-identical output to decode correctly;\n// this specific sequence of operations is specified in the spec (it's\n// drawing integer-quantized frequency-space lines that the encoder\n// expects to be exactly the same)\n//     ... also, isn't the whole point of Bresenham's algorithm to NOT\n// have to divide in the setup? sigh.\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n#define LINE_OP(a,b)   a *= b\n#else\n#define LINE_OP(a,b)   a = b\n#endif\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n#define DIVTAB_NUMER   32\n#define DIVTAB_DENOM   64\nint8 integer_divide_table[DIVTAB_NUMER][DIVTAB_DENOM]; // 2KB\n#endif\n\nstatic __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n   ady -= abs(base) * adx;\n   if (x1 > n) x1 = n;\n   if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y&255]);\n      for (++x; x < x1; ++x) {\n         err += ady;\n         if (err >= adx) {\n            err -= adx;\n            y += sy;\n         } else\n            y += base;\n         LINE_OP(output[x], inverse_db_table[y&255]);\n      }\n   }\n}\n\nstatic int residue_decode(vorb *f, Codebook *book, float *target, int offset, int n, int rtype)\n{\n   int k;\n   if (rtype == 0) {\n      int step = n / book->dimensions;\n      for (k=0; k < step; ++k)\n         if (!codebook_decode_step(f, book, target+offset+k, n-offset-k, step))\n            return FALSE;\n   } else {\n      for (k=0; k < n; ) {\n         if (!codebook_decode(f, book, target+offset, n-k))\n            return FALSE;\n         k += book->dimensions;\n         offset += book->dimensions;\n      }\n   }\n   return TRUE;\n}\n\n// n is 1/2 of the blocksize --\n// specification: \"Correct per-vector decode length is [n]/2\"\nstatic void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)\n{\n   int i,j,pass;\n   Residue *r = f->residue_config + rn;\n   int rtype = f->residue_types[rn];\n   int c = r->classbook;\n   int classwords = f->codebooks[c].dimensions;\n   unsigned int actual_size = rtype == 2 ? n*2 : n;\n   unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);\n   unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);\n   int n_read = limit_r_end - limit_r_begin;\n   int part_read = n_read / r->part_size;\n   int temp_alloc_point = temp_alloc_save(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f->channels, part_read * sizeof(**part_classdata));\n   #else\n   int **classifications = (int **) temp_block_array(f,f->channels, part_read * sizeof(**classifications));\n   #endif\n\n   CHECK(f);\n\n   for (i=0; i < ch; ++i)\n      if (!do_not_decode[i])\n         memset(residue_buffers[i], 0, sizeof(float) * n);\n\n   if (rtype == 2 && ch != 1) {\n      for (j=0; j < ch; ++j)\n         if (!do_not_decode[j])\n            break;\n      if (j == ch)\n         goto done;\n\n      for (pass=0; pass < 8; ++pass) {\n         int pcount = 0, class_set = 0;\n         if (ch == 2) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = (z & 1), p_inter = z>>1;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #else\n                     // saves 1%\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #endif\n                  } else {\n                     z += r->part_size;\n                     c_inter = z & 1;\n                     p_inter = z >> 1;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         } else if (ch == 1) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = 0, p_inter = z;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                  } else {\n                     z += r->part_size;\n                     c_inter = 0;\n                     p_inter = z;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         } else {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = z % ch, p_inter = z/ch;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                  } else {\n                     z += r->part_size;\n                     c_inter = z % ch;\n                     p_inter = z / ch;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         }\n      }\n      goto done;\n   }\n   CHECK(f);\n\n   for (pass=0; pass < 8; ++pass) {\n      int pcount = 0, class_set=0;\n      while (pcount < part_read) {\n         if (pass == 0) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int temp;\n                  DECODE(temp,f,c);\n                  if (temp == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[j][class_set] = r->classdata[temp];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[j][i+pcount] = temp % r->classifications;\n                     temp /= r->classifications;\n                  }\n                  #endif\n               }\n            }\n         }\n         for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[j][class_set][i];\n                  #else\n                  int c = classifications[j][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     float *target = residue_buffers[j];\n                     int offset = r->begin + pcount * r->part_size;\n                     int n = r->part_size;\n                     Codebook *book = f->codebooks + b;\n                     if (!residue_decode(f, book, target, offset, n, rtype))\n                        goto done;\n                  }\n               }\n            }\n         }\n         #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n         ++class_set;\n         #endif\n      }\n   }\n  done:\n   CHECK(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   temp_free(f,part_classdata);\n   #else\n   temp_free(f,classifications);\n   #endif\n   temp_alloc_restore(f,temp_alloc_point);\n}\n\n\n#if 0\n// slow way for debugging\nvoid inverse_mdct_slow(float *buffer, int n)\n{\n   int i,j;\n   int n2 = n >> 1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         // formula from paper:\n         //acc += n/4.0f * x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n         // formula from wikipedia\n         //acc += 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         // these are equivalent, except the formula from the paper inverts the multiplier!\n         // however, what actually works is NO MULTIPLIER!?!\n         //acc += 64 * 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         acc += x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// same as above, but just barely able to run in real time on modern machines\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   float mcos[16384];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 2) -1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < 4*n; ++i)\n      mcos[i] = (float) cos(M_PI / 2 * i / n);\n\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         acc += x[j] * mcos[(2 * i + 1 + n2)*(2*j+1) & nmask];\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// transform to use a slow dct-iv; this is STILL basically trivial,\n// but only requires half as many ops\nvoid dct_iv_slow(float *buffer, int n)\n{\n   float mcos[16384];\n   float x[2048];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 3) - 1;\n   memcpy(x, buffer, sizeof(*x) * n);\n   for (i=0; i < 8*n; ++i)\n      mcos[i] = (float) cos(M_PI / 4 * i / n);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n; ++j)\n         acc += x[j] * mcos[((2 * i + 1)*(2*j+1)) & nmask];\n      buffer[i] = acc;\n   }\n}\n\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   int i, n4 = n >> 2, n2 = n >> 1, n3_4 = n - n4;\n   float temp[4096];\n\n   memcpy(temp, buffer, n2 * sizeof(float));\n   dct_iv_slow(temp, n2);  // returns -c'-d, a-b'\n\n   for (i=0; i < n4  ; ++i) buffer[i] = temp[i+n4];            // a-b'\n   for (   ; i < n3_4; ++i) buffer[i] = -temp[n3_4 - i - 1];   // b-a', c+d'\n   for (   ; i < n   ; ++i) buffer[i] = -temp[i - n3_4];       // c'+d\n}\n#endif\n\n#ifndef LIBVORBIS_MDCT\n#define LIBVORBIS_MDCT 0\n#endif\n\n#if LIBVORBIS_MDCT\n// directly call the vorbis MDCT using an interface documented\n// by Jeff Roberts... useful for performance comparison\ntypedef struct \n{\n  int n;\n  int log2n;\n  \n  float *trig;\n  int   *bitrev;\n\n  float scale;\n} mdct_lookup;\n\nextern void mdct_init(mdct_lookup *lookup, int n);\nextern void mdct_clear(mdct_lookup *l);\nextern void mdct_backward(mdct_lookup *init, float *in, float *out);\n\nmdct_lookup M1,M2;\n\nvoid inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   mdct_lookup *M;\n   if (M1.n == n) M = &M1;\n   else if (M2.n == n) M = &M2;\n   else if (M1.n == 0) { mdct_init(&M1, n); M = &M1; }\n   else { \n      if (M2.n) __asm int 3;\n      mdct_init(&M2, n);\n      M = &M2;\n   }\n\n   mdct_backward(M, buffer, buffer);\n}\n#endif\n\n\n// the following were split out into separate functions while optimizing;\n// they could be pushed back up but eh. __forceinline showed no change;\n// they're probably already being inlined.\nstatic void imdct_step3_iter0_loop(int n, float *e, int i_off, int k_off, float *A)\n{\n   float *ee0 = e + i_off;\n   float *ee2 = ee0 + k_off;\n   int i;\n\n   assert((n & 3) == 0);\n   for (i=(n>>2); i > 0; --i) {\n      float k00_20, k01_21;\n      k00_20  = ee0[ 0] - ee2[ 0];\n      k01_21  = ee0[-1] - ee2[-1];\n      ee0[ 0] += ee2[ 0];//ee0[ 0] = ee0[ 0] + ee2[ 0];\n      ee0[-1] += ee2[-1];//ee0[-1] = ee0[-1] + ee2[-1];\n      ee2[ 0] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-1] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-2] - ee2[-2];\n      k01_21  = ee0[-3] - ee2[-3];\n      ee0[-2] += ee2[-2];//ee0[-2] = ee0[-2] + ee2[-2];\n      ee0[-3] += ee2[-3];//ee0[-3] = ee0[-3] + ee2[-3];\n      ee2[-2] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-3] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-4] - ee2[-4];\n      k01_21  = ee0[-5] - ee2[-5];\n      ee0[-4] += ee2[-4];//ee0[-4] = ee0[-4] + ee2[-4];\n      ee0[-5] += ee2[-5];//ee0[-5] = ee0[-5] + ee2[-5];\n      ee2[-4] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-5] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-6] - ee2[-6];\n      k01_21  = ee0[-7] - ee2[-7];\n      ee0[-6] += ee2[-6];//ee0[-6] = ee0[-6] + ee2[-6];\n      ee0[-7] += ee2[-7];//ee0[-7] = ee0[-7] + ee2[-7];\n      ee2[-6] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-7] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n      ee0 -= 8;\n      ee2 -= 8;\n   }\n}\n\nstatic void imdct_step3_inner_r_loop(int lim, float *e, int d0, int k_off, float *A, int k1)\n{\n   int i;\n   float k00_20, k01_21;\n\n   float *e0 = e + d0;\n   float *e2 = e0 + k_off;\n\n   for (i=lim >> 2; i > 0; --i) {\n      k00_20 = e0[-0] - e2[-0];\n      k01_21 = e0[-1] - e2[-1];\n      e0[-0] += e2[-0];//e0[-0] = e0[-0] + e2[-0];\n      e0[-1] += e2[-1];//e0[-1] = e0[-1] + e2[-1];\n      e2[-0] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-1] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-2] - e2[-2];\n      k01_21 = e0[-3] - e2[-3];\n      e0[-2] += e2[-2];//e0[-2] = e0[-2] + e2[-2];\n      e0[-3] += e2[-3];//e0[-3] = e0[-3] + e2[-3];\n      e2[-2] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-3] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-4] - e2[-4];\n      k01_21 = e0[-5] - e2[-5];\n      e0[-4] += e2[-4];//e0[-4] = e0[-4] + e2[-4];\n      e0[-5] += e2[-5];//e0[-5] = e0[-5] + e2[-5];\n      e2[-4] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-5] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-6] - e2[-6];\n      k01_21 = e0[-7] - e2[-7];\n      e0[-6] += e2[-6];//e0[-6] = e0[-6] + e2[-6];\n      e0[-7] += e2[-7];//e0[-7] = e0[-7] + e2[-7];\n      e2[-6] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-7] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      e0 -= 8;\n      e2 -= 8;\n\n      A += k1;\n   }\n}\n\nstatic void imdct_step3_inner_s_loop(int n, float *e, int i_off, int k_off, float *A, int a_off, int k0)\n{\n   int i;\n   float A0 = A[0];\n   float A1 = A[0+1];\n   float A2 = A[0+a_off];\n   float A3 = A[0+a_off+1];\n   float A4 = A[0+a_off*2+0];\n   float A5 = A[0+a_off*2+1];\n   float A6 = A[0+a_off*3+0];\n   float A7 = A[0+a_off*3+1];\n\n   float k00,k11;\n\n   float *ee0 = e  +i_off;\n   float *ee2 = ee0+k_off;\n\n   for (i=n; i > 0; --i) {\n      k00     = ee0[ 0] - ee2[ 0];\n      k11     = ee0[-1] - ee2[-1];\n      ee0[ 0] =  ee0[ 0] + ee2[ 0];\n      ee0[-1] =  ee0[-1] + ee2[-1];\n      ee2[ 0] = (k00) * A0 - (k11) * A1;\n      ee2[-1] = (k11) * A0 + (k00) * A1;\n\n      k00     = ee0[-2] - ee2[-2];\n      k11     = ee0[-3] - ee2[-3];\n      ee0[-2] =  ee0[-2] + ee2[-2];\n      ee0[-3] =  ee0[-3] + ee2[-3];\n      ee2[-2] = (k00) * A2 - (k11) * A3;\n      ee2[-3] = (k11) * A2 + (k00) * A3;\n\n      k00     = ee0[-4] - ee2[-4];\n      k11     = ee0[-5] - ee2[-5];\n      ee0[-4] =  ee0[-4] + ee2[-4];\n      ee0[-5] =  ee0[-5] + ee2[-5];\n      ee2[-4] = (k00) * A4 - (k11) * A5;\n      ee2[-5] = (k11) * A4 + (k00) * A5;\n\n      k00     = ee0[-6] - ee2[-6];\n      k11     = ee0[-7] - ee2[-7];\n      ee0[-6] =  ee0[-6] + ee2[-6];\n      ee0[-7] =  ee0[-7] + ee2[-7];\n      ee2[-6] = (k00) * A6 - (k11) * A7;\n      ee2[-7] = (k11) * A6 + (k00) * A7;\n\n      ee0 -= k0;\n      ee2 -= k0;\n   }\n}\n\nstatic __forceinline void iter_54(float *z)\n{\n   float k00,k11,k22,k33;\n   float y0,y1,y2,y3;\n\n   k00  = z[ 0] - z[-4];\n   y0   = z[ 0] + z[-4];\n   y2   = z[-2] + z[-6];\n   k22  = z[-2] - z[-6];\n\n   z[-0] = y0 + y2;      // z0 + z4 + z2 + z6\n   z[-2] = y0 - y2;      // z0 + z4 - z2 - z6\n\n   // done with y0,y2\n\n   k33  = z[-3] - z[-7];\n\n   z[-4] = k00 + k33;    // z0 - z4 + z3 - z7\n   z[-6] = k00 - k33;    // z0 - z4 - z3 + z7\n\n   // done with k33\n\n   k11  = z[-1] - z[-5];\n   y1   = z[-1] + z[-5];\n   y3   = z[-3] + z[-7];\n\n   z[-1] = y1 + y3;      // z1 + z5 + z3 + z7\n   z[-3] = y1 - y3;      // z1 + z5 - z3 - z7\n   z[-5] = k11 - k22;    // z1 - z5 + z2 - z6\n   z[-7] = k11 + k22;    // z1 - z5 - z2 + z6\n}\n\nstatic void imdct_step3_inner_s_loop_ld654(int n, float *e, int i_off, float *A, int base_n)\n{\n   int a_off = base_n >> 3;\n   float A2 = A[0+a_off];\n   float *z = e + i_off;\n   float *base = z - 16 * n;\n\n   while (z > base) {\n      float k00,k11;\n\n      k00   = z[-0] - z[-8];\n      k11   = z[-1] - z[-9];\n      z[-0] = z[-0] + z[-8];\n      z[-1] = z[-1] + z[-9];\n      z[-8] =  k00;\n      z[-9] =  k11 ;\n\n      k00    = z[ -2] - z[-10];\n      k11    = z[ -3] - z[-11];\n      z[ -2] = z[ -2] + z[-10];\n      z[ -3] = z[ -3] + z[-11];\n      z[-10] = (k00+k11) * A2;\n      z[-11] = (k11-k00) * A2;\n\n      k00    = z[-12] - z[ -4];  // reverse to avoid a unary negation\n      k11    = z[ -5] - z[-13];\n      z[ -4] = z[ -4] + z[-12];\n      z[ -5] = z[ -5] + z[-13];\n      z[-12] = k11;\n      z[-13] = k00;\n\n      k00    = z[-14] - z[ -6];  // reverse to avoid a unary negation\n      k11    = z[ -7] - z[-15];\n      z[ -6] = z[ -6] + z[-14];\n      z[ -7] = z[ -7] + z[-15];\n      z[-14] = (k00+k11) * A2;\n      z[-15] = (k00-k11) * A2;\n\n      iter_54(z);\n      iter_54(z-8);\n      z -= 16;\n   }\n}\n\nstatic void inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int ld;\n   // @OPTIMIZE: reduce register pressure by using fewer variables?\n   int save_point = temp_alloc_save(f);\n   float *buf2 = (float *) temp_alloc(f, n2 * sizeof(*buf2));\n   float *u=NULL,*v=NULL;\n   // twiddle factors\n   float *A = f->A[blocktype];\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // See notes about bugs in that paper in less-optimal implementation 'inverse_mdct_old' after this function.\n\n   // kernel from paper\n\n\n   // merged:\n   //   copy and reflect spectral data\n   //   step 0\n\n   // note that it turns out that the items added together during\n   // this step are, in fact, being added to themselves (as reflected\n   // by step 0). inexplicable inefficiency! this became obvious\n   // once I combined the passes.\n\n   // so there's a missing 'times 2' here (for adding X to itself).\n   // this propagates through linearly to the end, where the numbers\n   // are 1/2 too small, and need to be compensated for.\n\n   {\n      float *d,*e, *AA, *e_stop;\n      d = &buf2[n2-2];\n      AA = A;\n      e = &buffer[0];\n      e_stop = &buffer[n2];\n      while (e != e_stop) {\n         d[1] = (e[0] * AA[0] - e[2]*AA[1]);\n         d[0] = (e[0] * AA[1] + e[2]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e += 4;\n      }\n\n      e = &buffer[n2-3];\n      while (d >= buf2) {\n         d[1] = (-e[2] * AA[0] - -e[0]*AA[1]);\n         d[0] = (-e[2] * AA[1] + -e[0]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e -= 4;\n      }\n   }\n\n   // now we use symbolic names for these, so that we can\n   // possibly swap their meaning as we change which operations\n   // are in place\n\n   u = buffer;\n   v = buf2;\n\n   // step 2    (paper output is w, now u)\n   // this could be in place, but the data ends up in the wrong\n   // place... _somebody_'s got to swap it, so this is nominated\n   {\n      float *AA = &A[n2-8];\n      float *d0,*d1, *e0, *e1;\n\n      e0 = &v[n4];\n      e1 = &v[0];\n\n      d0 = &u[n4];\n      d1 = &u[0];\n\n      while (AA >= A) {\n         float v40_20, v41_21;\n\n         v41_21 = e0[1] - e1[1];\n         v40_20 = e0[0] - e1[0];\n         d0[1]  = e0[1] + e1[1];\n         d0[0]  = e0[0] + e1[0];\n         d1[1]  = v41_21*AA[4] - v40_20*AA[5];\n         d1[0]  = v40_20*AA[4] + v41_21*AA[5];\n\n         v41_21 = e0[3] - e1[3];\n         v40_20 = e0[2] - e1[2];\n         d0[3]  = e0[3] + e1[3];\n         d0[2]  = e0[2] + e1[2];\n         d1[3]  = v41_21*AA[0] - v40_20*AA[1];\n         d1[2]  = v40_20*AA[0] + v41_21*AA[1];\n\n         AA -= 8;\n\n         d0 += 4;\n         d1 += 4;\n         e0 += 4;\n         e1 += 4;\n      }\n   }\n\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n\n   // optimized step 3:\n\n   // the original step3 loop can be nested r inside s or s inside r;\n   // it's written originally as s inside r, but this is dumb when r\n   // iterates many times, and s few. So I have two copies of it and\n   // switch between them halfway.\n\n   // this is iteration 0 of step 3\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*0, -(n >> 3), A);\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*1, -(n >> 3), A);\n\n   // this is iteration 1 of step 3\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*0, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*1, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*2, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*3, -(n >> 4), A, 16);\n\n   l=2;\n   for (; l < (ld-3)>>1; ++l) {\n      int k0 = n >> (l+2), k0_2 = k0>>1;\n      int lim = 1 << (l+1);\n      int i;\n      for (i=0; i < lim; ++i)\n         imdct_step3_inner_r_loop(n >> (l+4), u, n2-1 - k0*i, -k0_2, A, 1 << (l+3));\n   }\n\n   for (; l < ld-6; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3), k0_2 = k0>>1;\n      int rlim = n >> (l+6), r;\n      int lim = 1 << (l+1);\n      int i_off;\n      float *A0 = A;\n      i_off = n2-1;\n      for (r=rlim; r > 0; --r) {\n         imdct_step3_inner_s_loop(lim, u, i_off, -k0_2, A0, k1, k0);\n         A0 += k1*4;\n         i_off -= 8;\n      }\n   }\n\n   // iterations with count:\n   //   ld-6,-5,-4 all interleaved together\n   //       the big win comes from getting rid of needless flops\n   //         due to the constants on pass 5 & 4 being all 1 and 0;\n   //       combining them to be simultaneous to improve cache made little difference\n   imdct_step3_inner_s_loop_ld654(n >> 5, u, n2-1, A, n);\n\n   // output is u\n\n   // step 4, 5, and 6\n   // cannot be in-place because of step 5\n   {\n      uint16 *bitrev = f->bit_reverse[blocktype];\n      // weirdly, I'd have thought reading sequentially and writing\n      // erratically would have been better than vice-versa, but in\n      // fact that's not what my testing showed. (That is, with\n      // j = bitreverse(i), do you read i and write j, or read j and write i.)\n\n      float *d0 = &v[n4-4];\n      float *d1 = &v[n2-4];\n      while (d0 >= v) {\n         int k4;\n\n         k4 = bitrev[0];\n         d1[3] = u[k4+0];\n         d1[2] = u[k4+1];\n         d0[3] = u[k4+2];\n         d0[2] = u[k4+3];\n\n         k4 = bitrev[1];\n         d1[1] = u[k4+0];\n         d1[0] = u[k4+1];\n         d0[1] = u[k4+2];\n         d0[0] = u[k4+3];\n         \n         d0 -= 4;\n         d1 -= 4;\n         bitrev += 2;\n      }\n   }\n   // (paper output is u, now v)\n\n\n   // data must be in buf2\n   assert(v == buf2);\n\n   // step 7   (paper output is v, now v)\n   // this is now in place\n   {\n      float *C = f->C[blocktype];\n      float *d, *e;\n\n      d = v;\n      e = v + n2 - 4;\n\n      while (d < e) {\n         float a02,a11,b0,b1,b2,b3;\n\n         a02 = d[0] - e[2];\n         a11 = d[1] + e[3];\n\n         b0 = C[1]*a02 + C[0]*a11;\n         b1 = C[1]*a11 - C[0]*a02;\n\n         b2 = d[0] + e[ 2];\n         b3 = d[1] - e[ 3];\n\n         d[0] = b2 + b0;\n         d[1] = b3 + b1;\n         e[2] = b2 - b0;\n         e[3] = b1 - b3;\n\n         a02 = d[2] - e[0];\n         a11 = d[3] + e[1];\n\n         b0 = C[3]*a02 + C[2]*a11;\n         b1 = C[3]*a11 - C[2]*a02;\n\n         b2 = d[2] + e[ 0];\n         b3 = d[3] - e[ 1];\n\n         d[2] = b2 + b0;\n         d[3] = b3 + b1;\n         e[0] = b2 - b0;\n         e[1] = b1 - b3;\n\n         C += 4;\n         d += 4;\n         e -= 4;\n      }\n   }\n\n   // data must be in buf2\n\n\n   // step 8+decode   (paper output is X, now buffer)\n   // this generates pairs of data a la 8 and pushes them directly through\n   // the decode kernel (pushing rather than pulling) to avoid having\n   // to make another pass later\n\n   // this cannot POSSIBLY be in place, so we refer to the buffers directly\n\n   {\n      float *d0,*d1,*d2,*d3;\n\n      float *B = f->B[blocktype] + n2 - 8;\n      float *e = buf2 + n2 - 8;\n      d0 = &buffer[0];\n      d1 = &buffer[n2-4];\n      d2 = &buffer[n2];\n      d3 = &buffer[n-4];\n      while (e >= v) {\n         float p0,p1,p2,p3;\n\n         p3 =  e[6]*B[7] - e[7]*B[6];\n         p2 = -e[6]*B[6] - e[7]*B[7]; \n\n         d0[0] =   p3;\n         d1[3] = - p3;\n         d2[0] =   p2;\n         d3[3] =   p2;\n\n         p1 =  e[4]*B[5] - e[5]*B[4];\n         p0 = -e[4]*B[4] - e[5]*B[5]; \n\n         d0[1] =   p1;\n         d1[2] = - p1;\n         d2[1] =   p0;\n         d3[2] =   p0;\n\n         p3 =  e[2]*B[3] - e[3]*B[2];\n         p2 = -e[2]*B[2] - e[3]*B[3]; \n\n         d0[2] =   p3;\n         d1[1] = - p3;\n         d2[2] =   p2;\n         d3[1] =   p2;\n\n         p1 =  e[0]*B[1] - e[1]*B[0];\n         p0 = -e[0]*B[0] - e[1]*B[1]; \n\n         d0[3] =   p1;\n         d1[0] = - p1;\n         d2[3] =   p0;\n         d3[0] =   p0;\n\n         B -= 8;\n         e -= 8;\n         d0 += 4;\n         d2 += 4;\n         d1 -= 4;\n         d3 -= 4;\n      }\n   }\n\n   temp_free(f,buf2);\n   temp_alloc_restore(f,save_point);\n}\n\n#if 0\n// this is the original version of the above code, if you want to optimize it from scratch\nvoid inverse_mdct_naive(float *buffer, int n)\n{\n   float s;\n   float A[1 << 12], B[1 << 12], C[1 << 11];\n   int i,k,k2,k4, n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int n3_4 = n - n4, ld;\n   // how can they claim this only uses N words?!\n   // oh, because they're only used sparsely, whoops\n   float u[1 << 13], X[1 << 13], v[1 << 13], w[1 << 13];\n   // set up twiddle factors\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2);\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2);\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // Note there are bugs in that pseudocode, presumably due to them attempting\n   // to rename the arrays nicely rather than representing the way their actual\n   // implementation bounces buffers back and forth. As a result, even in the\n   // \"some formulars corrected\" version, a direct implementation fails. These\n   // are noted below as \"paper bug\".\n\n   // copy and reflect spectral data\n   for (k=0; k < n2; ++k) u[k] = buffer[k];\n   for (   ; k < n ; ++k) u[k] = -buffer[n - k - 1];\n   // kernel from paper\n   // step 1\n   for (k=k2=k4=0; k < n4; k+=1, k2+=2, k4+=4) {\n      v[n-k4-1] = (u[k4] - u[n-k4-1]) * A[k2]   - (u[k4+2] - u[n-k4-3])*A[k2+1];\n      v[n-k4-3] = (u[k4] - u[n-k4-1]) * A[k2+1] + (u[k4+2] - u[n-k4-3])*A[k2];\n   }\n   // step 2\n   for (k=k4=0; k < n8; k+=1, k4+=4) {\n      w[n2+3+k4] = v[n2+3+k4] + v[k4+3];\n      w[n2+1+k4] = v[n2+1+k4] + v[k4+1];\n      w[k4+3]    = (v[n2+3+k4] - v[k4+3])*A[n2-4-k4] - (v[n2+1+k4]-v[k4+1])*A[n2-3-k4];\n      w[k4+1]    = (v[n2+1+k4] - v[k4+1])*A[n2-4-k4] + (v[n2+3+k4]-v[k4+3])*A[n2-3-k4];\n   }\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   for (l=0; l < ld-3; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3);\n      int rlim = n >> (l+4), r4, r;\n      int s2lim = 1 << (l+2), s2;\n      for (r=r4=0; r < rlim; r4+=4,++r) {\n         for (s2=0; s2 < s2lim; s2+=2) {\n            u[n-1-k0*s2-r4] = w[n-1-k0*s2-r4] + w[n-1-k0*(s2+1)-r4];\n            u[n-3-k0*s2-r4] = w[n-3-k0*s2-r4] + w[n-3-k0*(s2+1)-r4];\n            u[n-1-k0*(s2+1)-r4] = (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1]\n                                - (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1+1];\n            u[n-3-k0*(s2+1)-r4] = (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1]\n                                + (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1+1];\n         }\n      }\n      if (l+1 < ld-3) {\n         // paper bug: ping-ponging of u&w here is omitted\n         memcpy(w, u, sizeof(u));\n      }\n   }\n\n   // step 4\n   for (i=0; i < n8; ++i) {\n      int j = bit_reverse(i) >> (32-ld+3);\n      assert(j < n8);\n      if (i == j) {\n         // paper bug: original code probably swapped in place; if copying,\n         //            need to directly copy in this case\n         int i8 = i << 3;\n         v[i8+1] = u[i8+1];\n         v[i8+3] = u[i8+3];\n         v[i8+5] = u[i8+5];\n         v[i8+7] = u[i8+7];\n      } else if (i < j) {\n         int i8 = i << 3, j8 = j << 3;\n         v[j8+1] = u[i8+1], v[i8+1] = u[j8 + 1];\n         v[j8+3] = u[i8+3], v[i8+3] = u[j8 + 3];\n         v[j8+5] = u[i8+5], v[i8+5] = u[j8 + 5];\n         v[j8+7] = u[i8+7], v[i8+7] = u[j8 + 7];\n      }\n   }\n   // step 5\n   for (k=0; k < n2; ++k) {\n      w[k] = v[k*2+1];\n   }\n   // step 6\n   for (k=k2=k4=0; k < n8; ++k, k2 += 2, k4 += 4) {\n      u[n-1-k2] = w[k4];\n      u[n-2-k2] = w[k4+1];\n      u[n3_4 - 1 - k2] = w[k4+2];\n      u[n3_4 - 2 - k2] = w[k4+3];\n   }\n   // step 7\n   for (k=k2=0; k < n8; ++k, k2 += 2) {\n      v[n2 + k2 ] = ( u[n2 + k2] + u[n-2-k2] + C[k2+1]*(u[n2+k2]-u[n-2-k2]) + C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n-2 - k2] = ( u[n2 + k2] + u[n-2-k2] - C[k2+1]*(u[n2+k2]-u[n-2-k2]) - C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n2+1+ k2] = ( u[n2+1+k2] - u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n      v[n-1 - k2] = (-u[n2+1+k2] + u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n   }\n   // step 8\n   for (k=k2=0; k < n4; ++k,k2 += 2) {\n      X[k]      = v[k2+n2]*B[k2  ] + v[k2+1+n2]*B[k2+1];\n      X[n2-1-k] = v[k2+n2]*B[k2+1] - v[k2+1+n2]*B[k2  ];\n   }\n\n   // decode kernel to output\n   // determined the following value experimentally\n   // (by first figuring out what made inverse_mdct_slow work); then matching that here\n   // (probably vorbis encoder premultiplies by n or n/2, to save it on the decoder?)\n   s = 0.5; // theoretically would be n4\n\n   // [[[ note! the s value of 0.5 is compensated for by the B[] in the current code,\n   //     so it needs to use the \"old\" B values to behave correctly, or else\n   //     set s to 1.0 ]]]\n   for (i=0; i < n4  ; ++i) buffer[i] = s * X[i+n4];\n   for (   ; i < n3_4; ++i) buffer[i] = -s * X[n3_4 - i - 1];\n   for (   ; i < n   ; ++i) buffer[i] = -s * X[i - n3_4];\n}\n#endif\n\nstatic float *get_window(vorb *f, int len)\n{\n   len <<= 1;\n   if (len == f->blocksize_0) return f->window[0];\n   if (len == f->blocksize_1) return f->window[1];\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\ntypedef int16 YTYPE;\n#else\ntypedef int YTYPE;\n#endif\nstatic int do_floor(vorb *f, Mapping *map, int i, int n, float *target, YTYPE *finalY, uint8 *step2_flag)\n{\n   int n2 = n >> 1;\n   int s = map->chan[i].mux, floor;\n   floor = map->submap_floor[s];\n   if (f->floor_types[floor] == 0) {\n      return error(f, VORBIS_invalid_stream);\n   } else {\n      Floor1 *g = &f->floor_config[floor].floor1;\n      int j,q;\n      int lx = 0, ly = finalY[0] * g->floor1_multiplier;\n      for (q=1; q < g->values; ++q) {\n         j = g->sorted_order[q];\n         #ifndef STB_VORBIS_NO_DEFER_FLOOR\n         if (finalY[j] >= 0)\n         #else\n         if (step2_flag[j])\n         #endif\n         {\n            int hy = finalY[j] * g->floor1_multiplier;\n            int hx = g->Xlist[j];\n            if (lx != hx)\n               draw_line(target, lx,ly, hx,hy, n2);\n            CHECK(f);\n            lx = hx, ly = hy;\n         }\n      }\n      if (lx < n2) {\n         // optimization of: draw_line(target, lx,ly, n,ly, n2);\n         for (j=lx; j < n2; ++j)\n            LINE_OP(target[j], inverse_db_table[ly]);\n         CHECK(f);\n      }\n   }\n   return TRUE;\n}\n\n// The meaning of \"left\" and \"right\"\n//\n// For a given frame:\n//     we compute samples from 0..n\n//     window_center is n/2\n//     we'll window and mix the samples from left_start to left_end with data from the previous frame\n//     all of the samples from left_end to right_start can be output without mixing; however,\n//        this interval is 0-length except when transitioning between short and long frames\n//     all of the samples from right_start to right_end need to be mixed with the next frame,\n//        which we don't have, so those get saved in a buffer\n//     frame N's right_end-right_start, the number of samples to mix with the next frame,\n//        has to be the same as frame N+1's left_end-left_start (which they are by\n//        construction)\n\nstatic int vorbis_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   Mode *m;\n   int i, n, prev, next, window_center;\n   f->channel_buffer_start = f->channel_buffer_end = 0;\n\n  retry:\n   if (f->eof) return FALSE;\n   if (!maybe_start_packet(f))\n      return FALSE;\n   // check packet type\n   if (get_bits(f,1) != 0) {\n      if (IS_PUSH_MODE(f))\n         return error(f,VORBIS_bad_packet_type);\n      while (EOP != get8_packet(f));\n      goto retry;\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   i = get_bits(f, ilog(f->mode_count-1));\n   if (i == EOP) return FALSE;\n   if (i >= f->mode_count) return FALSE;\n   *mode = i;\n   m = f->mode_config + i;\n   if (m->blockflag) {\n      n = f->blocksize_1;\n      prev = get_bits(f,1);\n      next = get_bits(f,1);\n   } else {\n      prev = next = 0;\n      n = f->blocksize_0;\n   }\n\n// WINDOWING\n\n   window_center = n >> 1;\n   if (m->blockflag && !prev) {\n      *p_left_start = (n - f->blocksize_0) >> 2;\n      *p_left_end   = (n + f->blocksize_0) >> 2;\n   } else {\n      *p_left_start = 0;\n      *p_left_end   = window_center;\n   }\n   if (m->blockflag && !next) {\n      *p_right_start = (n*3 - f->blocksize_0) >> 2;\n      *p_right_end   = (n*3 + f->blocksize_0) >> 2;\n   } else {\n      *p_right_start = window_center;\n      *p_right_end   = n;\n   }\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet_rest(vorb *f, int *len, Mode *m, int left_start, int left_end, int right_start, int right_end, int *p_left)\n{\n   Mapping *map;\n   int i,j,k,n,n2;\n   int zero_channel[256];\n   int really_zero_channel[256];\n\n// WINDOWING\n\n   n = f->blocksize[m->blockflag];\n   map = &f->mapping[m->mapping];\n\n// FLOORS\n   n2 = n >> 1;\n\n   CHECK(f);\n\n   for (i=0; i < f->channels; ++i) {\n      int s = map->chan[i].mux, floor;\n      zero_channel[i] = FALSE;\n      floor = map->submap_floor[s];\n      if (f->floor_types[floor] == 0) {\n         return error(f, VORBIS_invalid_stream);\n      } else {\n         Floor1 *g = &f->floor_config[floor].floor1;\n         if (get_bits(f, 1)) {\n            short *finalY;\n            uint8 step2_flag[256];\n            static int range_list[4] = { 256, 128, 86, 64 };\n            int range = range_list[g->floor1_multiplier-1];\n            int offset = 2;\n            finalY = f->finalY[i];\n            finalY[0] = get_bits(f, ilog(range)-1);\n            finalY[1] = get_bits(f, ilog(range)-1);\n            for (j=0; j < g->partitions; ++j) {\n               int pclass = g->partition_class_list[j];\n               int cdim = g->class_dimensions[pclass];\n               int cbits = g->class_subclasses[pclass];\n               int csub = (1 << cbits)-1;\n               int cval = 0;\n               if (cbits) {\n                  Codebook *c = f->codebooks + g->class_masterbooks[pclass];\n                  DECODE(cval,f,c);\n               }\n               for (k=0; k < cdim; ++k) {\n                  int book = g->subclass_books[pclass][cval & csub];\n                  cval = cval >> cbits;\n                  if (book >= 0) {\n                     int temp;\n                     Codebook *c = f->codebooks + book;\n                     DECODE(temp,f,c);\n                     finalY[offset++] = temp;\n                  } else\n                     finalY[offset++] = 0;\n               }\n            }\n            if (f->valid_bits == INVALID_BITS) goto error; // behavior according to spec\n            step2_flag[0] = step2_flag[1] = 1;\n            for (j=2; j < g->values; ++j) {\n               int low, high, pred, highroom, lowroom, room, val;\n               low = g->neighbors[j][0];\n               high = g->neighbors[j][1];\n               //neighbors(g->Xlist, j, &low, &high);\n               pred = predict_point(g->Xlist[j], g->Xlist[low], g->Xlist[high], finalY[low], finalY[high]);\n               val = finalY[j];\n               highroom = range - pred;\n               lowroom = pred;\n               if (highroom < lowroom)\n                  room = highroom * 2;\n               else\n                  room = lowroom * 2;\n               if (val) {\n                  step2_flag[low] = step2_flag[high] = 1;\n                  step2_flag[j] = 1;\n                  if (val >= room)\n                     if (highroom > lowroom)\n                        finalY[j] = val - lowroom + pred;\n                     else\n                        finalY[j] = pred - val + highroom - 1;\n                  else\n                     if (val & 1)\n                        finalY[j] = pred - ((val+1)>>1);\n                     else\n                        finalY[j] = pred + (val>>1);\n               } else {\n                  step2_flag[j] = 0;\n                  finalY[j] = pred;\n               }\n            }\n\n#ifdef STB_VORBIS_NO_DEFER_FLOOR\n            do_floor(f, map, i, n, f->floor_buffers[i], finalY, step2_flag);\n#else\n            // defer final floor computation until _after_ residue\n            for (j=0; j < g->values; ++j) {\n               if (!step2_flag[j])\n                  finalY[j] = -1;\n            }\n#endif\n         } else {\n           error:\n            zero_channel[i] = TRUE;\n         }\n         // So we just defer everything else to later\n\n         // at this point we've decoded the floor into buffer\n      }\n   }\n   CHECK(f);\n   // at this point we've decoded all floors\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   // re-enable coupled channels if necessary\n   memcpy(really_zero_channel, zero_channel, sizeof(really_zero_channel[0]) * f->channels);\n   for (i=0; i < map->coupling_steps; ++i)\n      if (!zero_channel[map->chan[i].magnitude] || !zero_channel[map->chan[i].angle]) {\n         zero_channel[map->chan[i].magnitude] = zero_channel[map->chan[i].angle] = FALSE;\n      }\n\n   CHECK(f);\n// RESIDUE DECODE\n   for (i=0; i < map->submaps; ++i) {\n      float *residue_buffers[STB_VORBIS_MAX_CHANNELS];\n      int r;\n      uint8 do_not_decode[256];\n      int ch = 0;\n      for (j=0; j < f->channels; ++j) {\n         if (map->chan[j].mux == i) {\n            if (zero_channel[j]) {\n               do_not_decode[ch] = TRUE;\n               residue_buffers[ch] = NULL;\n            } else {\n               do_not_decode[ch] = FALSE;\n               residue_buffers[ch] = f->channel_buffers[j];\n            }\n            ++ch;\n         }\n      }\n      r = map->submap_residue[i];\n      decode_residue(f, residue_buffers, ch, n2, r, do_not_decode);\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   CHECK(f);\n\n// INVERSE COUPLING\n   for (i = map->coupling_steps-1; i >= 0; --i) {\n      int n2 = n >> 1;\n      float *m = f->channel_buffers[map->chan[i].magnitude];\n      float *a = f->channel_buffers[map->chan[i].angle    ];\n      for (j=0; j < n2; ++j) {\n         float a2,m2;\n         if (m[j] > 0)\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] - a[j];\n            else\n               a2 = m[j], m2 = m[j] + a[j];\n         else\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] + a[j];\n            else\n               a2 = m[j], m2 = m[j] - a[j];\n         m[j] = m2;\n         a[j] = a2;\n      }\n   }\n   CHECK(f);\n\n   // finish decoding the floors\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         do_floor(f, map, i, n, f->channel_buffers[i], f->finalY[i], NULL);\n      }\n   }\n#else\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         for (j=0; j < n2; ++j)\n            f->channel_buffers[i][j] *= f->floor_buffers[i][j];\n      }\n   }\n#endif\n\n// INVERSE MDCT\n   CHECK(f);\n   for (i=0; i < f->channels; ++i)\n      inverse_mdct(f->channel_buffers[i], n, f, m->blockflag);\n   CHECK(f);\n\n   // this shouldn't be necessary, unless we exited on an error\n   // and want to flush to get to the next packet\n   flush_packet(f);\n\n   if (f->first_decode) {\n      // assume we start so first non-discarded sample is sample 0\n      // this isn't to spec, but spec would require us to read ahead\n      // and decode the size of all current frames--could be done,\n      // but presumably it's not a commonly used feature\n      f->current_loc = -n2; // start of first frame is positioned for discard\n      // we might have to discard samples \"from\" the next frame too,\n      // if we're lapping a large block then a small at the start?\n      f->discard_samples_deferred = n - right_end;\n      f->current_loc_valid = TRUE;\n      f->first_decode = FALSE;\n   } else if (f->discard_samples_deferred) {\n      if (f->discard_samples_deferred >= right_start - left_start) {\n         f->discard_samples_deferred -= (right_start - left_start);\n         left_start = right_start;\n         *p_left = left_start;\n      } else {\n         left_start += f->discard_samples_deferred;\n         *p_left = left_start;\n         f->discard_samples_deferred = 0;\n      }\n   } else if (f->previous_length == 0 && f->current_loc_valid) {\n      // we're recovering from a seek... that means we're going to discard\n      // the samples from this packet even though we know our position from\n      // the last page header, so we need to update the position based on\n      // the discarded samples here\n      // but wait, the code below is going to add this in itself even\n      // on a discard, so we don't need to do it here...\n   }\n\n   // check if we have ogg information about the sample # for this packet\n   if (f->last_seg_which == f->end_seg_with_known_loc) {\n      // if we have a valid current loc, and this is final:\n      if (f->current_loc_valid && (f->page_flag & PAGEFLAG_last_page)) {\n         uint32 current_end = f->known_loc_for_packet;\n         // then let's infer the size of the (probably) short final frame\n         if (current_end < f->current_loc + (right_end-left_start)) {\n            if (current_end < f->current_loc) {\n               // negative truncation, that's impossible!\n               *len = 0;\n            } else {\n               *len = current_end - f->current_loc;\n            }\n            *len += left_start; // this doesn't seem right, but has no ill effect on my test files\n            if (*len > right_end) *len = right_end; // this should never happen\n            f->current_loc += *len;\n            return TRUE;\n         }\n      }\n      // otherwise, just set our sample loc\n      // guess that the ogg granule pos refers to the _middle_ of the\n      // last frame?\n      // set f->current_loc to the position of left_start\n      f->current_loc = f->known_loc_for_packet - (n2-left_start);\n      f->current_loc_valid = TRUE;\n   }\n   if (f->current_loc_valid)\n      f->current_loc += (right_start - left_start);\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   *len = right_end;  // ignore samples after the window goes to 0\n   CHECK(f);\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet(vorb *f, int *len, int *p_left, int *p_right)\n{\n   int mode, left_end, right_end;\n   if (!vorbis_decode_initial(f, p_left, &left_end, p_right, &right_end, &mode)) return 0;\n   return vorbis_decode_packet_rest(f, len, f->mode_config + mode, *p_left, left_end, *p_right, right_end, p_left);\n}\n\nstatic int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)\n{\n   int prev,i,j;\n   // we use right&left (the start of the right- and left-window sin()-regions)\n   // to determine how much to return, rather than inferring from the rules\n   // (same result, clearer code); 'left' indicates where our sin() window\n   // starts, therefore where the previous window's right edge starts, and\n   // therefore where to start mixing from the previous buffer. 'right'\n   // indicates where our sin() ending-window starts, therefore that's where\n   // we start saving, and where our returned-data ends.\n\n   // mixin from previous window\n   if (f->previous_length) {\n      int i,j, n = f->previous_length;\n      float *w = get_window(f, n);\n      if (w == NULL) return 0;\n      for (i=0; i < f->channels; ++i) {\n         for (j=0; j < n; ++j)\n            f->channel_buffers[i][left+j] =\n               f->channel_buffers[i][left+j]*w[    j] +\n               f->previous_window[i][     j]*w[n-1-j];\n      }\n   }\n\n   prev = f->previous_length;\n\n   // last half of this data becomes previous window\n   f->previous_length = len - right;\n\n   // @OPTIMIZE: could avoid this copy by double-buffering the\n   // output (flipping previous_window with channel_buffers), but\n   // then previous_window would have to be 2x as large, and\n   // channel_buffers couldn't be temp mem (although they're NOT\n   // currently temp mem, they could be (unless we want to level\n   // performance by spreading out the computation))\n   for (i=0; i < f->channels; ++i)\n      for (j=0; right+j < len; ++j)\n         f->previous_window[i][j] = f->channel_buffers[i][right+j];\n\n   if (!prev)\n      // there was no previous packet, so this data isn't valid...\n      // this isn't entirely true, only the would-have-overlapped data\n      // isn't valid, but this seems to be what the spec requires\n      return 0;\n\n   // truncate a short frame\n   if (len < right) right = len;\n\n   f->samples_output += right-left;\n\n   return right - left;\n}\n\nstatic int vorbis_pump_first_frame(stb_vorbis *f)\n{\n   int len, right, left, res;\n   res = vorbis_decode_packet(f, &len, &left, &right);\n   if (res)\n      vorbis_finish_frame(f, len, left, right);\n   return res;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\nstatic int is_whole_packet_present(stb_vorbis *f, int end_page)\n{\n   // make sure that we have the packet available before continuing...\n   // this requires a full ogg parse, but we know we can fetch from f->stream\n\n   // instead of coding this out explicitly, we could save the current read state,\n   // read the next packet with get8() until end-of-packet, check f->eof, then\n   // reset the state? but that would be slower, esp. since we'd have over 256 bytes\n   // of state to restore (primarily the page segment table)\n\n   int s = f->next_seg, first = TRUE;\n   uint8 *p = f->stream;\n\n   if (s != -1) { // if we're not starting the packet with a 'continue on next page' flag\n      for (; s < f->segment_count; ++s) {\n         p += f->segments[s];\n         if (f->segments[s] < 255)               // stop at first short segment\n            break;\n      }\n      // either this continues, or it ends it...\n      if (end_page)\n         if (s < f->segment_count-1)             return error(f, VORBIS_invalid_stream);\n      if (s == f->segment_count)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   for (; s == -1;) {\n      uint8 *q; \n      int n;\n\n      // check that we have the page header ready\n      if (p + 26 >= f->stream_end)               return error(f, VORBIS_need_more_data);\n      // validate the page\n      if (memcmp(p, ogg_page_header, 4))         return error(f, VORBIS_invalid_stream);\n      if (p[4] != 0)                             return error(f, VORBIS_invalid_stream);\n      if (first) { // the first segment must NOT have 'continued_packet', later ones MUST\n         if (f->previous_length)\n            if ((p[5] & PAGEFLAG_continued_packet))  return error(f, VORBIS_invalid_stream);\n         // if no previous length, we're resynching, so we can come in on a continued-packet,\n         // which we'll just drop\n      } else {\n         if (!(p[5] & PAGEFLAG_continued_packet)) return error(f, VORBIS_invalid_stream);\n      }\n      n = p[26]; // segment counts\n      q = p+27;  // q points to segment table\n      p = q + n; // advance past header\n      // make sure we've read the segment table\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      for (s=0; s < n; ++s) {\n         p += q[s];\n         if (q[s] < 255)\n            break;\n      }\n      if (end_page)\n         if (s < n-1)                            return error(f, VORBIS_invalid_stream);\n      if (s == n)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   return TRUE;\n}\n#endif // !STB_VORBIS_NO_PUSHDATA_API\n\nstatic int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            int values = lookup1_values(c->entries, c->dimensions);\n            if (values < 0) return error(f, VORBIS_invalid_setup);\n            c->lookup_values = (uint32) values;\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values-1; ++j)\n            if (p[j].x == p[j+1].x)\n               return error(f, VORBIS_invalid_setup);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}\n\nstatic void vorbis_deinit(stb_vorbis *p)\n{\n   int i,j;\n   if (p->residue_config) {\n      for (i=0; i < p->residue_count; ++i) {\n         Residue *r = p->residue_config+i;\n         if (r->classdata) {\n            for (j=0; j < p->codebooks[r->classbook].entries; ++j)\n               setup_free(p, r->classdata[j]);\n            setup_free(p, r->classdata);\n         }\n         setup_free(p, r->residue_books);\n      }\n   }\n\n   if (p->codebooks) {\n      CHECK(p);\n      for (i=0; i < p->codebook_count; ++i) {\n         Codebook *c = p->codebooks + i;\n         setup_free(p, c->codeword_lengths);\n         setup_free(p, c->multiplicands);\n         setup_free(p, c->codewords);\n         setup_free(p, c->sorted_codewords);\n         // c->sorted_values[-1] is the first entry in the array\n         setup_free(p, c->sorted_values ? c->sorted_values-1 : NULL);\n      }\n      setup_free(p, p->codebooks);\n   }\n   setup_free(p, p->floor_config);\n   setup_free(p, p->residue_config);\n   if (p->mapping) {\n      for (i=0; i < p->mapping_count; ++i)\n         setup_free(p, p->mapping[i].chan);\n      setup_free(p, p->mapping);\n   }\n   CHECK(p);\n   for (i=0; i < p->channels && i < STB_VORBIS_MAX_CHANNELS; ++i) {\n      setup_free(p, p->channel_buffers[i]);\n      setup_free(p, p->previous_window[i]);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      setup_free(p, p->floor_buffers[i]);\n      #endif\n      setup_free(p, p->finalY[i]);\n   }\n   for (i=0; i < 2; ++i) {\n      setup_free(p, p->A[i]);\n      setup_free(p, p->B[i]);\n      setup_free(p, p->C[i]);\n      setup_free(p, p->window[i]);\n      setup_free(p, p->bit_reverse[i]);\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (p->close_on_free) fclose(p->f);\n   #endif\n}\n\nvoid stb_vorbis_close(stb_vorbis *p)\n{\n   if (p == NULL) return;\n   vorbis_deinit(p);\n   setup_free(p,p);\n}\n\nstatic void vorbis_init(stb_vorbis *p, const stb_vorbis_alloc *z)\n{\n   memset(p, 0, sizeof(*p)); // NULL out all malloc'd pointers to start\n   if (z) {\n      p->alloc = *z;\n      p->alloc.alloc_buffer_length_in_bytes = (p->alloc.alloc_buffer_length_in_bytes+3) & ~3;\n      p->temp_offset = p->alloc.alloc_buffer_length_in_bytes;\n   }\n   p->eof = 0;\n   p->error = VORBIS__no_error;\n   p->stream = NULL;\n   p->codebooks = NULL;\n   p->page_crc_tests = -1;\n   #ifndef STB_VORBIS_NO_STDIO\n   p->close_on_free = FALSE;\n   p->f = NULL;\n   #endif\n}\n\nint stb_vorbis_get_sample_offset(stb_vorbis *f)\n{\n   if (f->current_loc_valid)\n      return f->current_loc;\n   else\n      return -1;\n}\n\nstb_vorbis_info stb_vorbis_get_info(stb_vorbis *f)\n{\n   stb_vorbis_info d;\n   d.channels = f->channels;\n   d.sample_rate = f->sample_rate;\n   d.setup_memory_required = f->setup_memory_required;\n   d.setup_temp_memory_required = f->setup_temp_memory_required;\n   d.temp_memory_required = f->temp_memory_required;\n   d.max_frame_size = f->blocksize_1 >> 1;\n   return d;\n}\n\nint stb_vorbis_get_error(stb_vorbis *f)\n{\n   int e = f->error;\n   f->error = VORBIS__no_error;\n   return e;\n}\n\nstatic stb_vorbis * vorbis_alloc(stb_vorbis *f)\n{\n   stb_vorbis *p = (stb_vorbis *) setup_malloc(f, sizeof(*p));\n   return p;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\nvoid stb_vorbis_flush_pushdata(stb_vorbis *f)\n{\n   f->previous_length = 0;\n   f->page_crc_tests  = 0;\n   f->discard_samples_deferred = 0;\n   f->current_loc_valid = FALSE;\n   f->first_decode = FALSE;\n   f->samples_output = 0;\n   f->channel_buffer_start = 0;\n   f->channel_buffer_end = 0;\n}\n\nstatic int vorbis_search_for_page_pushdata(vorb *f, uint8 *data, int data_len)\n{\n   int i,n;\n   for (i=0; i < f->page_crc_tests; ++i)\n      f->scan[i].bytes_done = 0;\n\n   // if we have room for more scans, search for them first, because\n   // they may cause us to stop early if their header is incomplete\n   if (f->page_crc_tests < STB_VORBIS_PUSHDATA_CRC_COUNT) {\n      if (data_len < 4) return 0;\n      data_len -= 3; // need to look for 4-byte sequence, so don't miss\n                     // one that straddles a boundary\n      for (i=0; i < data_len; ++i) {\n         if (data[i] == 0x4f) {\n            if (0==memcmp(data+i, ogg_page_header, 4)) {\n               int j,len;\n               uint32 crc;\n               // make sure we have the whole page header\n               if (i+26 >= data_len || i+27+data[i+26] >= data_len) {\n                  // only read up to this page start, so hopefully we'll\n                  // have the whole page header start next time\n                  data_len = i;\n                  break;\n               }\n               // ok, we have it all; compute the length of the page\n               len = 27 + data[i+26];\n               for (j=0; j < data[i+26]; ++j)\n                  len += data[i+27+j];\n               // scan everything up to the embedded crc (which we must 0)\n               crc = 0;\n               for (j=0; j < 22; ++j)\n                  crc = crc32_update(crc, data[i+j]);\n               // now process 4 0-bytes\n               for (   ; j < 26; ++j)\n                  crc = crc32_update(crc, 0);\n               // len is the total number of bytes we need to scan\n               n = f->page_crc_tests++;\n               f->scan[n].bytes_left = len-j;\n               f->scan[n].crc_so_far = crc;\n               f->scan[n].goal_crc = data[i+22] + (data[i+23] << 8) + (data[i+24]<<16) + (data[i+25]<<24);\n               // if the last frame on a page is continued to the next, then\n               // we can't recover the sample_loc immediately\n               if (data[i+27+data[i+26]-1] == 255)\n                  f->scan[n].sample_loc = ~0;\n               else\n                  f->scan[n].sample_loc = data[i+6] + (data[i+7] << 8) + (data[i+ 8]<<16) + (data[i+ 9]<<24);\n               f->scan[n].bytes_done = i+j;\n               if (f->page_crc_tests == STB_VORBIS_PUSHDATA_CRC_COUNT)\n                  break;\n               // keep going if we still have room for more\n            }\n         }\n      }\n   }\n\n   for (i=0; i < f->page_crc_tests;) {\n      uint32 crc;\n      int j;\n      int n = f->scan[i].bytes_done;\n      int m = f->scan[i].bytes_left;\n      if (m > data_len - n) m = data_len - n;\n      // m is the bytes to scan in the current chunk\n      crc = f->scan[i].crc_so_far;\n      for (j=0; j < m; ++j)\n         crc = crc32_update(crc, data[n+j]);\n      f->scan[i].bytes_left -= m;\n      f->scan[i].crc_so_far = crc;\n      if (f->scan[i].bytes_left == 0) {\n         // does it match?\n         if (f->scan[i].crc_so_far == f->scan[i].goal_crc) {\n            // Houston, we have page\n            data_len = n+m; // consumption amount is wherever that scan ended\n            f->page_crc_tests = -1; // drop out of page scan mode\n            f->previous_length = 0; // decode-but-don't-output one frame\n            f->next_seg = -1;       // start a new page\n            f->current_loc = f->scan[i].sample_loc; // set the current sample location\n                                    // to the amount we'd have decoded had we decoded this page\n            f->current_loc_valid = f->current_loc != ~0U;\n            return data_len;\n         }\n         // delete entry\n         f->scan[i] = f->scan[--f->page_crc_tests];\n      } else {\n         ++i;\n      }\n   }\n\n   return data_len;\n}\n\n// return value: number of bytes we used\nint stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,                   // the file we're decoding\n         const uint8 *data, int data_len, // the memory available for decoding\n         int *channels,                   // place to write number of float * buffers\n         float ***output,                 // place to write float ** array of float * buffers\n         int *samples                     // place to write number of output samples\n     )\n{\n   int i;\n   int len,right,left;\n\n   if (!IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (f->page_crc_tests >= 0) {\n      *samples = 0;\n      return vorbis_search_for_page_pushdata(f, (uint8 *) data, data_len);\n   }\n\n   f->stream     = (uint8 *) data;\n   f->stream_end = (uint8 *) data + data_len;\n   f->error      = VORBIS__no_error;\n\n   // check that we have the entire packet in memory\n   if (!is_whole_packet_present(f, FALSE)) {\n      *samples = 0;\n      return 0;\n   }\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      // save the actual error we encountered\n      enum STBVorbisError error = f->error;\n      if (error == VORBIS_bad_packet_type) {\n         // flush and resynch\n         f->error = VORBIS__no_error;\n         while (get8_packet(f) != EOP)\n            if (f->eof) break;\n         *samples = 0;\n         return (int) (f->stream - data);\n      }\n      if (error == VORBIS_continued_packet_flag_invalid) {\n         if (f->previous_length == 0) {\n            // we may be resynching, in which case it's ok to hit one\n            // of these; just discard the packet\n            f->error = VORBIS__no_error;\n            while (get8_packet(f) != EOP)\n               if (f->eof) break;\n            *samples = 0;\n            return (int) (f->stream - data);\n         }\n      }\n      // if we get an error while parsing, what to do?\n      // well, it DEFINITELY won't work to continue from where we are!\n      stb_vorbis_flush_pushdata(f);\n      // restore the error that actually made us bail\n      f->error = error;\n      *samples = 0;\n      return 1;\n   }\n\n   // success!\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   if (channels) *channels = f->channels;\n   *samples = len;\n   *output = f->outputs;\n   return (int) (f->stream - data);\n}\n\nstb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char *data, int data_len, // the memory available for decoding\n         int *data_used,              // only defined if result is not NULL\n         int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.stream     = (uint8 *) data;\n   p.stream_end = (uint8 *) data + data_len;\n   p.push_mode  = TRUE;\n   if (!start_decoder(&p)) {\n      if (p.eof)\n         *error = VORBIS_need_more_data;\n      else\n         *error = p.error;\n      return NULL;\n   }\n   f = vorbis_alloc(&p);\n   if (f) {\n      *f = p;\n      *data_used = (int) (f->stream - data);\n      *error = 0;\n      return f;\n   } else {\n      vorbis_deinit(&p);\n      return NULL;\n   }\n}\n#endif // STB_VORBIS_NO_PUSHDATA_API\n\nunsigned int stb_vorbis_get_file_offset(stb_vorbis *f)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   if (USE_MEMORY(f)) return (unsigned int) (f->stream - f->stream_start);\n   #ifndef STB_VORBIS_NO_STDIO\n   return (unsigned int) (ftell(f->f) - f->f_start);\n   #endif\n}\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n//\n// DATA-PULLING API\n//\n\nstatic uint32 vorbis_find_page(stb_vorbis *f, uint32 *end, uint32 *last)\n{\n   for(;;) {\n      int n;\n      if (f->eof) return 0;\n      n = get8(f);\n      if (n == 0x4f) { // page header candidate\n         unsigned int retry_loc = stb_vorbis_get_file_offset(f);\n         int i;\n         // check if we're off the end of a file_section stream\n         if (retry_loc - 25 > f->stream_len)\n            return 0;\n         // check the rest of the header\n         for (i=1; i < 4; ++i)\n            if (get8(f) != ogg_page_header[i])\n               break;\n         if (f->eof) return 0;\n         if (i == 4) {\n            uint8 header[27];\n            uint32 i, crc, goal, len;\n            for (i=0; i < 4; ++i)\n               header[i] = ogg_page_header[i];\n            for (; i < 27; ++i)\n               header[i] = get8(f);\n            if (f->eof) return 0;\n            if (header[4] != 0) goto invalid;\n            goal = header[22] + (header[23] << 8) + (header[24]<<16) + (header[25]<<24);\n            for (i=22; i < 26; ++i)\n               header[i] = 0;\n            crc = 0;\n            for (i=0; i < 27; ++i)\n               crc = crc32_update(crc, header[i]);\n            len = 0;\n            for (i=0; i < header[26]; ++i) {\n               int s = get8(f);\n               crc = crc32_update(crc, s);\n               len += s;\n            }\n            if (len && f->eof) return 0;\n            for (i=0; i < len; ++i)\n               crc = crc32_update(crc, get8(f));\n            // finished parsing probable page\n            if (crc == goal) {\n               // we could now check that it's either got the last\n               // page flag set, OR it's followed by the capture\n               // pattern, but I guess TECHNICALLY you could have\n               // a file with garbage between each ogg page and recover\n               // from it automatically? So even though that paranoia\n               // might decrease the chance of an invalid decode by\n               // another 2^32, not worth it since it would hose those\n               // invalid-but-useful files?\n               if (end)\n                  *end = stb_vorbis_get_file_offset(f);\n               if (last) {\n                  if (header[5] & 0x04)\n                     *last = 1;\n                  else\n                     *last = 0;\n               }\n               set_file_offset(f, retry_loc-1);\n               return 1;\n            }\n         }\n        invalid:\n         // not a valid page, so rewind and look for next one\n         set_file_offset(f, retry_loc);\n      }\n   }\n}\n\n\n#define SAMPLE_unknown  0xffffffff\n\n// seeking is implemented with a binary search, which narrows down the range to\n// 64K, before using a linear search (because finding the synchronization\n// pattern can be expensive, and the chance we'd find the end page again is\n// relatively high for small ranges)\n//\n// two initial interpolation-style probes are used at the start of the search\n// to try to bound either side of the binary search sensibly, while still\n// working in O(log n) time if they fail.\n\nstatic int get_seek_page_info(stb_vorbis *f, ProbedPage *z)\n{\n   uint8 header[27], lacing[255];\n   int i,len;\n\n   // record where the page starts\n   z->page_start = stb_vorbis_get_file_offset(f);\n\n   // parse the header\n   getn(f, header, 27);\n   if (header[0] != 'O' || header[1] != 'g' || header[2] != 'g' || header[3] != 'S')\n      return 0;\n   getn(f, lacing, header[26]);\n\n   // determine the length of the payload\n   len = 0;\n   for (i=0; i < header[26]; ++i)\n      len += lacing[i];\n\n   // this implies where the page ends\n   z->page_end = z->page_start + 27 + header[26] + len;\n\n   // read the last-decoded sample out of the data\n   z->last_decoded_sample = header[6] + (header[7] << 8) + (header[8] << 16) + (header[9] << 24);\n\n   // restore file state to where we were\n   set_file_offset(f, z->page_start);\n   return 1;\n}\n\n// rarely used function to seek back to the preceding page while finding the\n// start of a packet\nstatic int go_to_page_before(stb_vorbis *f, unsigned int limit_offset)\n{\n   unsigned int previous_safe, end;\n\n   // now we want to seek back 64K from the limit\n   if (limit_offset >= 65536 && limit_offset-65536 >= f->first_audio_page_offset)\n      previous_safe = limit_offset - 65536;\n   else\n      previous_safe = f->first_audio_page_offset;\n\n   set_file_offset(f, previous_safe);\n\n   while (vorbis_find_page(f, &end, NULL)) {\n      if (end >= limit_offset && stb_vorbis_get_file_offset(f) < limit_offset)\n         return 1;\n      set_file_offset(f, end);\n   }\n\n   return 0;\n}\n\n// implements the search logic for finding a page and starting decoding. if\n// the function succeeds, current_loc_valid will be true and current_loc will\n// be less than or equal to the provided sample number (the closer the\n// better).\nstatic int seek_to_sample_coarse(stb_vorbis *f, uint32 sample_number)\n{\n   ProbedPage left, right, mid;\n   int i, start_seg_with_known_loc, end_pos, page_start;\n   uint32 delta, stream_length, padding;\n   double offset, bytes_per_sample;\n   int probe = 0;\n\n   // find the last page and validate the target sample\n   stream_length = stb_vorbis_stream_length_in_samples(f);\n   if (stream_length == 0)            return error(f, VORBIS_seek_without_length);\n   if (sample_number > stream_length) return error(f, VORBIS_seek_invalid);\n\n   // this is the maximum difference between the window-center (which is the\n   // actual granule position value), and the right-start (which the spec\n   // indicates should be the granule position (give or take one)).\n   padding = ((f->blocksize_1 - f->blocksize_0) >> 2);\n   if (sample_number < padding)\n      sample_number = 0;\n   else\n      sample_number -= padding;\n\n   left = f->p_first;\n   while (left.last_decoded_sample == ~0U) {\n      // (untested) the first page does not have a 'last_decoded_sample'\n      set_file_offset(f, left.page_end);\n      if (!get_seek_page_info(f, &left)) goto error;\n   }\n\n   right = f->p_last;\n   assert(right.last_decoded_sample != ~0U);\n\n   // starting from the start is handled differently\n   if (sample_number <= left.last_decoded_sample) {\n      if (stb_vorbis_seek_start(f))\n         return 1;\n      return 0;\n   }\n\n   while (left.page_end != right.page_start) {\n      assert(left.page_end < right.page_start);\n      // search range in bytes\n      delta = right.page_start - left.page_end;\n      if (delta <= 65536) {\n         // there's only 64K left to search - handle it linearly\n         set_file_offset(f, left.page_end);\n      } else {\n         if (probe < 2) {\n            if (probe == 0) {\n               // first probe (interpolate)\n               double data_bytes = right.page_end - left.page_start;\n               bytes_per_sample = data_bytes / right.last_decoded_sample;\n               offset = left.page_start + bytes_per_sample * (sample_number - left.last_decoded_sample);\n            } else {\n               // second probe (try to bound the other side)\n               double error = ((double) sample_number - mid.last_decoded_sample) * bytes_per_sample;\n               if (error >= 0 && error <  8000) error =  8000;\n               if (error <  0 && error > -8000) error = -8000;\n               offset += error * 2;\n            }\n\n            // ensure the offset is valid\n            if (offset < left.page_end)\n               offset = left.page_end;\n            if (offset > right.page_start - 65536)\n               offset = right.page_start - 65536;\n\n            set_file_offset(f, (unsigned int) offset);\n         } else {\n            // binary search for large ranges (offset by 32K to ensure\n            // we don't hit the right page)\n            set_file_offset(f, left.page_end + (delta / 2) - 32768);\n         }\n\n         if (!vorbis_find_page(f, NULL, NULL)) goto error;\n      }\n\n      for (;;) {\n         if (!get_seek_page_info(f, &mid)) goto error;\n         if (mid.last_decoded_sample != ~0U) break;\n         // (untested) no frames end on this page\n         set_file_offset(f, mid.page_end);\n         assert(mid.page_start < right.page_start);\n      }\n\n      // if we've just found the last page again then we're in a tricky file,\n      // and we're close enough.\n      if (mid.page_start == right.page_start)\n         break;\n\n      if (sample_number < mid.last_decoded_sample)\n         right = mid;\n      else\n         left = mid;\n\n      ++probe;\n   }\n\n   // seek back to start of the last packet\n   page_start = left.page_start;\n   set_file_offset(f, page_start);\n   if (!start_page(f)) return error(f, VORBIS_seek_failed);\n   end_pos = f->end_seg_with_known_loc;\n   assert(end_pos >= 0);\n\n   for (;;) {\n      for (i = end_pos; i > 0; --i)\n         if (f->segments[i-1] != 255)\n            break;\n\n      start_seg_with_known_loc = i;\n\n      if (start_seg_with_known_loc > 0 || !(f->page_flag & PAGEFLAG_continued_packet))\n         break;\n\n      // (untested) the final packet begins on an earlier page\n      if (!go_to_page_before(f, page_start))\n         goto error;\n\n      page_start = stb_vorbis_get_file_offset(f);\n      if (!start_page(f)) goto error;\n      end_pos = f->segment_count - 1;\n   }\n\n   // prepare to start decoding\n   f->current_loc_valid = FALSE;\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   f->previous_length = 0;\n   f->next_seg = start_seg_with_known_loc;\n\n   for (i = 0; i < start_seg_with_known_loc; i++)\n      skip(f, f->segments[i]);\n\n   // start decoding (optimizable - this frame is generally discarded)\n   if (!vorbis_pump_first_frame(f))\n      return 0;\n   if (f->current_loc > sample_number)\n      return error(f, VORBIS_seek_failed);\n   return 1;\n\nerror:\n   // try to restore the file to a valid state\n   stb_vorbis_seek_start(f);\n   return error(f, VORBIS_seek_failed);\n}\n\n// the same as vorbis_decode_initial, but without advancing\nstatic int peek_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   int bits_read, bytes_read;\n\n   if (!vorbis_decode_initial(f, p_left_start, p_left_end, p_right_start, p_right_end, mode))\n      return 0;\n\n   // either 1 or 2 bytes were read, figure out which so we can rewind\n   bits_read = 1 + ilog(f->mode_count-1);\n   if (f->mode_config[*mode].blockflag)\n      bits_read += 2;\n   bytes_read = (bits_read + 7) / 8;\n\n   f->bytes_in_seg += bytes_read;\n   f->packet_bytes -= bytes_read;\n   skip(f, -bytes_read);\n   if (f->next_seg == -1)\n      f->next_seg = f->segment_count - 1;\n   else\n      f->next_seg--;\n   f->valid_bits = 0;\n\n   return 1;\n}\n\nint stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number)\n{\n   uint32 max_frame_samples;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   // fast page-level search\n   if (!seek_to_sample_coarse(f, sample_number))\n      return 0;\n\n   assert(f->current_loc_valid);\n   assert(f->current_loc <= sample_number);\n\n   // linear search for the relevant packet\n   max_frame_samples = (f->blocksize_1*3 - f->blocksize_0) >> 2;\n   while (f->current_loc < sample_number) {\n      int left_start, left_end, right_start, right_end, mode, frame_samples;\n      if (!peek_decode_initial(f, &left_start, &left_end, &right_start, &right_end, &mode))\n         return error(f, VORBIS_seek_failed);\n      // calculate the number of samples returned by the next frame\n      frame_samples = right_start - left_start;\n      if (f->current_loc + frame_samples > sample_number) {\n         return 1; // the next frame will contain the sample\n      } else if (f->current_loc + frame_samples + max_frame_samples > sample_number) {\n         // there's a chance the frame after this could contain the sample\n         vorbis_pump_first_frame(f);\n      } else {\n         // this frame is too early to be relevant\n         f->current_loc += frame_samples;\n         f->previous_length = 0;\n         maybe_start_packet(f);\n         flush_packet(f);\n      }\n   }\n   // the next frame will start with the sample\n   assert(f->current_loc == sample_number);\n   return 1;\n}\n\nint stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number)\n{\n   if (!stb_vorbis_seek_frame(f, sample_number))\n      return 0;\n\n   if (sample_number != f->current_loc) {\n      int n;\n      uint32 frame_start = f->current_loc;\n      stb_vorbis_get_frame_float(f, &n, NULL);\n      assert(sample_number > frame_start);\n      assert(f->channel_buffer_start + (int) (sample_number-frame_start) <= f->channel_buffer_end);\n      f->channel_buffer_start += (sample_number - frame_start);\n   }\n\n   return 1;\n}\n\nint stb_vorbis_seek_start(stb_vorbis *f)\n{\n   if (IS_PUSH_MODE(f)) { return error(f, VORBIS_invalid_api_mixing); }\n   set_file_offset(f, f->first_audio_page_offset);\n   f->previous_length = 0;\n   f->first_decode = TRUE;\n   f->next_seg = -1;\n   return vorbis_pump_first_frame(f);\n}\n\nunsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f)\n{\n   unsigned int restore_offset, previous_safe;\n   unsigned int end, last_page_loc;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n   if (!f->total_samples) {\n      unsigned int last;\n      uint32 lo,hi;\n      char header[6];\n\n      // first, store the current decode position so we can restore it\n      restore_offset = stb_vorbis_get_file_offset(f);\n\n      // now we want to seek back 64K from the end (the last page must\n      // be at most a little less than 64K, but let's allow a little slop)\n      if (f->stream_len >= 65536 && f->stream_len-65536 >= f->first_audio_page_offset)\n         previous_safe = f->stream_len - 65536;\n      else\n         previous_safe = f->first_audio_page_offset;\n\n      set_file_offset(f, previous_safe);\n      // previous_safe is now our candidate 'earliest known place that seeking\n      // to will lead to the final page'\n\n      if (!vorbis_find_page(f, &end, &last)) {\n         // if we can't find a page, we're hosed!\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = 0xffffffff;\n         goto done;\n      }\n\n      // check if there are more pages\n      last_page_loc = stb_vorbis_get_file_offset(f);\n\n      // stop when the last_page flag is set, not when we reach eof;\n      // this allows us to stop short of a 'file_section' end without\n      // explicitly checking the length of the section\n      while (!last) {\n         set_file_offset(f, end);\n         if (!vorbis_find_page(f, &end, &last)) {\n            // the last page we found didn't have the 'last page' flag\n            // set. whoops!\n            break;\n         }\n         previous_safe = last_page_loc+1;\n         last_page_loc = stb_vorbis_get_file_offset(f);\n      }\n\n      set_file_offset(f, last_page_loc);\n\n      // parse the header\n      getn(f, (unsigned char *)header, 6);\n      // extract the absolute granule position\n      lo = get32(f);\n      hi = get32(f);\n      if (lo == 0xffffffff && hi == 0xffffffff) {\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = SAMPLE_unknown;\n         goto done;\n      }\n      if (hi)\n         lo = 0xfffffffe; // saturate\n      f->total_samples = lo;\n\n      f->p_last.page_start = last_page_loc;\n      f->p_last.page_end   = end;\n      f->p_last.last_decoded_sample = lo;\n\n     done:\n      set_file_offset(f, restore_offset);\n   }\n   return f->total_samples == SAMPLE_unknown ? 0 : f->total_samples;\n}\n\nfloat stb_vorbis_stream_length_in_seconds(stb_vorbis *f)\n{\n   return stb_vorbis_stream_length_in_samples(f) / (float) f->sample_rate;\n}\n\n\n\nint stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output)\n{\n   int len, right,left,i;\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      f->channel_buffer_start = f->channel_buffer_end = 0;\n      return 0;\n   }\n\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   f->channel_buffer_start = left;\n   f->channel_buffer_end   = left+len;\n\n   if (channels) *channels = f->channels;\n   if (output)   *output = f->outputs;\n   return len;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_file_section(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc, unsigned int length)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.f = file;\n   p.f_start = (uint32) ftell(file);\n   p.stream_len   = length;\n   p.close_on_free = close_on_free;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\nstb_vorbis * stb_vorbis_open_file(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc)\n{\n   unsigned int len, start;\n   start = (unsigned int) ftell(file);\n   fseek(file, 0, SEEK_END);\n   len = (unsigned int) (ftell(file) - start);\n   fseek(file, start, SEEK_SET);\n   return stb_vorbis_open_file_section(file, close_on_free, error, alloc, len);\n}\n\nstb_vorbis * stb_vorbis_open_filename(const char *filename, int *error, const stb_vorbis_alloc *alloc)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n   if (0 != fopen_s(&f, filename, \"rb\"))\n      f = NULL;\n#else\n   f = fopen(filename, \"rb\");\n#endif\n   if (f) \n      return stb_vorbis_open_file(f, TRUE, error, alloc);\n   if (error) *error = VORBIS_file_open_failure;\n   return NULL;\n}\n#endif // STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len, int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   if (data == NULL) return NULL;\n   vorbis_init(&p, alloc);\n   p.stream = (uint8 *) data;\n   p.stream_end = (uint8 *) data + len;\n   p.stream_start = (uint8 *) p.stream;\n   p.stream_len = len;\n   p.push_mode = FALSE;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         if (error) *error = VORBIS__no_error;\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#define PLAYBACK_MONO     1\n#define PLAYBACK_LEFT     2\n#define PLAYBACK_RIGHT    4\n\n#define L  (PLAYBACK_LEFT  | PLAYBACK_MONO)\n#define C  (PLAYBACK_LEFT  | PLAYBACK_RIGHT | PLAYBACK_MONO)\n#define R  (PLAYBACK_RIGHT | PLAYBACK_MONO)\n\nstatic int8 channel_position[7][6] =\n{\n   { 0 },\n   { C },\n   { L, R },\n   { L, C, R },\n   { L, R, L, R },\n   { L, C, R, L, R },\n   { L, C, R, L, R, C },\n};\n\n\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n   typedef union {\n      float f;\n      int i;\n   } float_conv;\n   typedef char stb_vorbis_float_size_test[sizeof(float)==4 && sizeof(int) == 4];\n   #define FASTDEF(x) float_conv x\n   // add (1<<23) to convert to int, then divide by 2^SHIFT, then add 0.5/2^SHIFT to round\n   #define MAGIC(SHIFT) (1.5f * (1 << (23-SHIFT)) + 0.5f/(1 << SHIFT))\n   #define ADDEND(SHIFT) (((150-SHIFT) << 23) + (1 << 22))\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) (temp.f = (x) + MAGIC(s), temp.i - ADDEND(s))\n   #define check_endianness()  \n#else\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) ((int) ((x) * (1 << (s))))\n   #define check_endianness()\n   #define FASTDEF(x)\n#endif\n\nstatic void copy_samples(short *dest, float *src, int len)\n{\n   int i;\n   check_endianness();\n   for (i=0; i < len; ++i) {\n      FASTDEF(temp);\n      int v = FAST_SCALED_FLOAT_TO_INT(temp, src[i],15);\n      if ((unsigned int) (v + 32768) > 65535)\n         v = v < 0 ? -32768 : 32767;\n      dest[i] = v;\n   }\n}\n\nstatic void compute_samples(int mask, short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define BUFFER_SIZE  32\n   float buffer[BUFFER_SIZE];\n   int i,j,o,n = BUFFER_SIZE;\n   check_endianness();\n   for (o = 0; o < len; o += BUFFER_SIZE) {\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         if (channel_position[num_c][j] & mask) {\n            for (i=0; i < n; ++i)\n               buffer[i] += data[j][d_offset+o+i];\n         }\n      }\n      for (i=0; i < n; ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o+i] = v;\n      }\n   }\n}\n\nstatic void compute_stereo_samples(short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define BUFFER_SIZE  32\n   float buffer[BUFFER_SIZE];\n   int i,j,o,n = BUFFER_SIZE >> 1;\n   // o is the offset in the source data\n   check_endianness();\n   for (o = 0; o < len; o += BUFFER_SIZE >> 1) {\n      // o2 is the offset in the output data\n      int o2 = o << 1;\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         int m = channel_position[num_c][j] & (PLAYBACK_LEFT | PLAYBACK_RIGHT);\n         if (m == (PLAYBACK_LEFT | PLAYBACK_RIGHT)) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_LEFT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_RIGHT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         }\n      }\n      for (i=0; i < (n<<1); ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o2+i] = v;\n      }\n   }\n}\n\nstatic void convert_samples_short(int buf_c, short **buffer, int b_offset, int data_c, float **data, int d_offset, int samples)\n{\n   int i;\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      static int channel_selector[3][2] = { {0}, {PLAYBACK_MONO}, {PLAYBACK_LEFT, PLAYBACK_RIGHT} };\n      for (i=0; i < buf_c; ++i)\n         compute_samples(channel_selector[buf_c][i], buffer[i]+b_offset, data_c, data, d_offset, samples);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      for (i=0; i < limit; ++i)\n         copy_samples(buffer[i]+b_offset, data[i]+d_offset, samples);\n      for (   ; i < buf_c; ++i)\n         memset(buffer[i]+b_offset, 0, sizeof(short) * samples);\n   }\n}\n\nint stb_vorbis_get_frame_short(stb_vorbis *f, int num_c, short **buffer, int num_samples)\n{\n   float **output;\n   int len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len > num_samples) len = num_samples;\n   if (len)\n      convert_samples_short(num_c, buffer, 0, f->channels, output, 0, len);\n   return len;\n}\n\nstatic void convert_channels_short_interleaved(int buf_c, short *buffer, int data_c, float **data, int d_offset, int len)\n{\n   int i;\n   check_endianness();\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      assert(buf_c == 2);\n      for (i=0; i < buf_c; ++i)\n         compute_stereo_samples(buffer, data_c, data, d_offset, len);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      int j;\n      for (j=0; j < len; ++j) {\n         for (i=0; i < limit; ++i) {\n            FASTDEF(temp);\n            float f = data[i][d_offset+j];\n            int v = FAST_SCALED_FLOAT_TO_INT(temp, f,15);//data[i][d_offset+j],15);\n            if ((unsigned int) (v + 32768) > 65535)\n               v = v < 0 ? -32768 : 32767;\n            *buffer++ = v;\n         }\n         for (   ; i < buf_c; ++i)\n            *buffer++ = 0;\n      }\n   }\n}\n\nint stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts)\n{\n   float **output;\n   int len;\n   if (num_c == 1) return stb_vorbis_get_frame_short(f,num_c,&buffer, num_shorts);\n   len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len) {\n      if (len*num_c > num_shorts) len = num_shorts / num_c;\n      convert_channels_short_interleaved(num_c, buffer, f->channels, output, 0, len);\n   }\n   return len;\n}\n\nint stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts)\n{\n   float **outputs;\n   int len = num_shorts / channels;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_channels_short_interleaved(channels, buffer, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      buffer += k*channels;\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int len)\n{\n   float **outputs;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_samples_short(channels, buffer, n, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\nint stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_filename(filename, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // NO_STDIO\n\nint stb_vorbis_decode_memory(const uint8 *mem, int len, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_memory(mem, len, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // STB_VORBIS_NO_INTEGER_CONVERSION\n\nint stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats)\n{\n   float **outputs;\n   int len = num_floats / channels;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int i,j;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      for (j=0; j < k; ++j) {\n         for (i=0; i < z; ++i)\n            *buffer++ = f->channel_buffers[i][f->channel_buffer_start+j];\n         for (   ; i < channels; ++i)\n            *buffer++ = 0;\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples)\n{\n   float **outputs;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < num_samples) {\n      int i;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= num_samples) k = num_samples - n;\n      if (k) {\n         for (i=0; i < z; ++i)\n            memcpy(buffer[i]+n, f->channel_buffers[i]+f->channel_buffer_start, sizeof(float)*k);\n         for (   ; i < channels; ++i)\n            memset(buffer[i]+n, 0, sizeof(float) * k);\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == num_samples)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n#endif // STB_VORBIS_NO_PULLDATA_API\n\n/* Version history\n    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13223, -13223\n                           found with Mayhem by ForAllSecure\n    1.16    - 2019-03-04 - fix warnings\n    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n    1.14    - 2018-02-11 - delete bogus dealloca usage\n    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n    1.11    - 2017-07-23 - fix MinGW compilation \n    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n    1.09    - 2016-04-04 - back out 'avoid discarding last frame' fix from previous version\n    1.08    - 2016-04-02 - fixed multiple warnings; fix setup memory leaks;\n                           avoid discarding last frame of audio data\n    1.07    - 2015-01-16 - fixed some warnings, fix mingw, const-correct API\n                           some more crash fixes when out of memory or with corrupt files \n    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n                           some crash fixes when out of memory or with corrupt files\n    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n    1.04    - 2014-08-27 - fix missing const-correct case in API\n    1.03    - 2014-08-07 - Warning fixes\n    1.02    - 2014-07-09 - Declare qsort compare function _cdecl on windows\n    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float\n    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in multichannel\n                           (API change) report sample rate for decode-full-file funcs\n    0.99996 - bracket #include <malloc.h> for macintosh compilation by Laurent Gomila\n    0.99995 - use union instead of pointer-cast for fast-float-to-int to avoid alias-optimization problem\n    0.99994 - change fast-float-to-int to work in single-precision FPU mode, remove endian-dependence\n    0.99993 - remove assert that fired on legal files with empty tables\n    0.99992 - rewind-to-start\n    0.99991 - bugfix to stb_vorbis_get_samples_short by Bernhard Wodo\n    0.9999 - (should have been 0.99990) fix no-CRT support, compiling as C++\n    0.9998 - add a full-decode function with a memory source\n    0.9997 - fix a bug in the read-from-FILE case in 0.9996 addition\n    0.9996 - query length of vorbis stream in samples/seconds\n    0.9995 - bugfix to another optimization that only happened in certain files\n    0.9994 - bugfix to one of the optimizations that caused significant (but inaudible?) errors\n    0.9993 - performance improvements; runs in 99% to 104% of time of reference implementation\n    0.9992 - performance improvement of IMDCT; now performs close to reference implementation\n    0.9991 - performance improvement of IMDCT\n    0.999 - (should have been 0.9990) performance improvement of IMDCT\n    0.998 - no-CRT support from Casey Muratori\n    0.997 - bugfixes for bugs found by Terje Mathisen\n    0.996 - bugfix: fast-huffman decode initialized incorrectly for sparse codebooks; fixing gives 10% speedup - found by Terje Mathisen\n    0.995 - bugfix: fix to 'effective' overrun detection - found by Terje Mathisen\n    0.994 - bugfix: garbage decode on final VQ symbol of a non-multiple - found by Terje Mathisen\n    0.993 - bugfix: pushdata API required 1 extra byte for empty page (failed to consume final page if empty) - found by Terje Mathisen\n    0.992 - fixes for MinGW warning\n    0.991 - turn fast-float-conversion on by default\n    0.990 - fix push-mode seek recovery if you seek into the headers\n    0.98b - fix to bad release of 0.98\n    0.98 - fix push-mode seek recovery; robustify float-to-int and support non-fast mode\n    0.97 - builds under c++ (typecasting, don't use 'class' keyword)\n    0.96 - somehow MY 0.95 was right, but the web one was wrong, so here's my 0.95 rereleased as 0.96, fixes a typo in the clamping code\n    0.95 - clamping code for 16-bit functions\n    0.94 - not publically released\n    0.93 - fixed all-zero-floor case (was decoding garbage)\n    0.92 - fixed a memory leak\n    0.91 - conditional compiles to omit parts of the API and the infrastructure to support them: STB_VORBIS_NO_PULLDATA_API, STB_VORBIS_NO_PUSHDATA_API, STB_VORBIS_NO_STDIO, STB_VORBIS_NO_INTEGER_CONVERSION\n    0.90 - first public release\n*/\n\n#endif // STB_VORBIS_HEADER_ONLY\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"], "filenames": ["stb_vorbis.c"], "buggy_code_start_loc": [35], "buggy_code_end_loc": [5388], "fixing_code_start_loc": [36], "fixing_code_end_loc": [5405], "type": "CWE-369", "message": "Division by zero in the predict_point function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.", "other": {"cve": {"id": "CVE-2019-13218", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-15T17:15:12.927", "lastModified": "2023-02-16T19:22:30.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Division by zero in the predict_point function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file."}, {"lang": "es", "value": "Una divisi\u00f3n por cero en la funci\u00f3n predict_point en stb_vorbis hasta el 04-03-2019, permite a un atacante causar una denegaci\u00f3n de servicio mediante la apertura de un archivo Ogg Vorbis dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:stb_vorbis_project:stb_vorbis:*:*:*:*:*:*:*:*", "versionEndIncluding": "2019-03-04", "matchCriteriaId": "258E6E77-C719-4D22-885D-61CEE1EB8844"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://nothings.org/stb_vorbis/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nothings/stb/commits/master/stb_vorbis.c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6"}}