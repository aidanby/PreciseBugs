{"buggy_code": ["/*\n *\tLinux IPv6 multicast routing support for BSD pim6sd\n *\tBased on net/ipv4/ipmr.c.\n *\n *\t(c) 2004 Mickael Hoerdt, <hoerdt@clarinet.u-strasbg.fr>\n *\t\tLSIIT Laboratory, Strasbourg, France\n *\t(c) 2004 Jean-Philippe Andriot, <jean-philippe.andriot@6WIND.com>\n *\t\t6WIND, Paris, France\n *\tCopyright (C)2007,2008 USAGI/WIDE Project\n *\t\tYOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/raw.h>\n#include <linux/notifier.h>\n#include <linux/if_arp.h>\n#include <net/checksum.h>\n#include <net/netlink.h>\n#include <net/fib_rules.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <linux/mroute6.h>\n#include <linux/pim.h>\n#include <net/addrconf.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/export.h>\n#include <net/ip6_checksum.h>\n#include <linux/netconf.h>\n\nstruct mr6_table {\n\tstruct list_head\tlist;\n\tpossible_net_t\t\tnet;\n\tu32\t\t\tid;\n\tstruct sock\t\t*mroute6_sk;\n\tstruct timer_list\tipmr_expire_timer;\n\tstruct list_head\tmfc6_unres_queue;\n\tstruct list_head\tmfc6_cache_array[MFC6_LINES];\n\tstruct mif_device\tvif6_table[MAXMIFS];\n\tint\t\t\tmaxvif;\n\tatomic_t\t\tcache_resolve_queue_len;\n\tbool\t\t\tmroute_do_assert;\n\tbool\t\t\tmroute_do_pim;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tint\t\t\tmroute_reg_vif_num;\n#endif\n};\n\nstruct ip6mr_rule {\n\tstruct fib_rule\t\tcommon;\n};\n\nstruct ip6mr_result {\n\tstruct mr6_table\t*mrt;\n};\n\n/* Big lock, protecting vif table, mrt cache and mroute socket state.\n   Note that the changes are semaphored via rtnl_lock.\n */\n\nstatic DEFINE_RWLOCK(mrt_lock);\n\n/*\n *\tMulticast router control variables\n */\n\n#define MIF_EXISTS(_mrt, _idx) ((_mrt)->vif6_table[_idx].dev != NULL)\n\n/* Special spinlock for queue of unresolved entries */\nstatic DEFINE_SPINLOCK(mfc_unres_lock);\n\n/* We return to original Alan's scheme. Hash table of resolved\n   entries is changed only in process context and protected\n   with weak lock mrt_lock. Queue of unresolved entries is protected\n   with strong spinlock mfc_unres_lock.\n\n   In this case data path is free of exclusive locks at all.\n */\n\nstatic struct kmem_cache *mrt_cachep __read_mostly;\n\nstatic struct mr6_table *ip6mr_new_table(struct net *net, u32 id);\nstatic void ip6mr_free_table(struct mr6_table *mrt);\n\nstatic void ip6_mr_forward(struct net *net, struct mr6_table *mrt,\n\t\t\t   struct sk_buff *skb, struct mfc6_cache *cache);\nstatic int ip6mr_cache_report(struct mr6_table *mrt, struct sk_buff *pkt,\n\t\t\t      mifi_t mifi, int assert);\nstatic int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\n\t\t\t       struct mfc6_cache *c, struct rtmsg *rtm);\nstatic void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,\n\t\t\t      int cmd);\nstatic int ip6mr_rtm_dumproute(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb);\nstatic void mroute_clean_tables(struct mr6_table *mrt, bool all);\nstatic void ipmr_expire_process(unsigned long arg);\n\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n#define ip6mr_for_each_table(mrt, net) \\\n\tlist_for_each_entry_rcu(mrt, &net->ipv6.mr6_tables, list)\n\nstatic struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\tstruct mr6_table *mrt;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (mrt->id == id)\n\t\t\treturn mrt;\n\t}\n\treturn NULL;\n}\n\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr6_table **mrt)\n{\n\tint err;\n\tstruct ip6mr_result res;\n\tstruct fib_lookup_arg arg = {\n\t\t.result = &res,\n\t\t.flags = FIB_LOOKUP_NOREF,\n\t};\n\n\terr = fib_rules_lookup(net->ipv6.mr6_rules_ops,\n\t\t\t       flowi6_to_flowi(flp6), 0, &arg);\n\tif (err < 0)\n\t\treturn err;\n\t*mrt = res.mrt;\n\treturn 0;\n}\n\nstatic int ip6mr_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t     int flags, struct fib_lookup_arg *arg)\n{\n\tstruct ip6mr_result *res = arg->result;\n\tstruct mr6_table *mrt;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\treturn -ENETUNREACH;\n\tcase FR_ACT_PROHIBIT:\n\t\treturn -EACCES;\n\tcase FR_ACT_BLACKHOLE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmrt = ip6mr_get_table(rule->fr_net, rule->table);\n\tif (!mrt)\n\t\treturn -EAGAIN;\n\tres->mrt = mrt;\n\treturn 0;\n}\n\nstatic int ip6mr_rule_match(struct fib_rule *rule, struct flowi *flp, int flags)\n{\n\treturn 1;\n}\n\nstatic const struct nla_policy ip6mr_rule_policy[FRA_MAX + 1] = {\n\tFRA_GENERIC_POLICY,\n};\n\nstatic int ip6mr_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t\tstruct fib_rule_hdr *frh, struct nlattr **tb)\n{\n\treturn 0;\n}\n\nstatic int ip6mr_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t      struct nlattr **tb)\n{\n\treturn 1;\n}\n\nstatic int ip6mr_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t   struct fib_rule_hdr *frh)\n{\n\tfrh->dst_len = 0;\n\tfrh->src_len = 0;\n\tfrh->tos     = 0;\n\treturn 0;\n}\n\nstatic const struct fib_rules_ops __net_initconst ip6mr_rules_ops_template = {\n\t.family\t\t= RTNL_FAMILY_IP6MR,\n\t.rule_size\t= sizeof(struct ip6mr_rule),\n\t.addr_size\t= sizeof(struct in6_addr),\n\t.action\t\t= ip6mr_rule_action,\n\t.match\t\t= ip6mr_rule_match,\n\t.configure\t= ip6mr_rule_configure,\n\t.compare\t= ip6mr_rule_compare,\n\t.fill\t\t= ip6mr_rule_fill,\n\t.nlgroup\t= RTNLGRP_IPV6_RULE,\n\t.policy\t\t= ip6mr_rule_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __net_init ip6mr_rules_init(struct net *net)\n{\n\tstruct fib_rules_ops *ops;\n\tstruct mr6_table *mrt;\n\tint err;\n\n\tops = fib_rules_register(&ip6mr_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tINIT_LIST_HEAD(&net->ipv6.mr6_tables);\n\n\tmrt = ip6mr_new_table(net, RT6_TABLE_DFLT);\n\tif (!mrt) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\terr = fib_default_rule_add(ops, 0x7fff, RT6_TABLE_DFLT, 0);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tnet->ipv6.mr6_rules_ops = ops;\n\treturn 0;\n\nerr2:\n\tip6mr_free_table(mrt);\nerr1:\n\tfib_rules_unregister(ops);\n\treturn err;\n}\n\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\n{\n\tstruct mr6_table *mrt, *next;\n\n\trtnl_lock();\n\tlist_for_each_entry_safe(mrt, next, &net->ipv6.mr6_tables, list) {\n\t\tlist_del(&mrt->list);\n\t\tip6mr_free_table(mrt);\n\t}\n\tfib_rules_unregister(net->ipv6.mr6_rules_ops);\n\trtnl_unlock();\n}\n#else\n#define ip6mr_for_each_table(mrt, net) \\\n\tfor (mrt = net->ipv6.mrt6; mrt; mrt = NULL)\n\nstatic struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\treturn net->ipv6.mrt6;\n}\n\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr6_table **mrt)\n{\n\t*mrt = net->ipv6.mrt6;\n\treturn 0;\n}\n\nstatic int __net_init ip6mr_rules_init(struct net *net)\n{\n\tnet->ipv6.mrt6 = ip6mr_new_table(net, RT6_TABLE_DFLT);\n\treturn net->ipv6.mrt6 ? 0 : -ENOMEM;\n}\n\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\n{\n\trtnl_lock();\n\tip6mr_free_table(net->ipv6.mrt6);\n\tnet->ipv6.mrt6 = NULL;\n\trtnl_unlock();\n}\n#endif\n\nstatic struct mr6_table *ip6mr_new_table(struct net *net, u32 id)\n{\n\tstruct mr6_table *mrt;\n\tunsigned int i;\n\n\tmrt = ip6mr_get_table(net, id);\n\tif (mrt)\n\t\treturn mrt;\n\n\tmrt = kzalloc(sizeof(*mrt), GFP_KERNEL);\n\tif (!mrt)\n\t\treturn NULL;\n\tmrt->id = id;\n\twrite_pnet(&mrt->net, net);\n\n\t/* Forwarding cache */\n\tfor (i = 0; i < MFC6_LINES; i++)\n\t\tINIT_LIST_HEAD(&mrt->mfc6_cache_array[i]);\n\n\tINIT_LIST_HEAD(&mrt->mfc6_unres_queue);\n\n\tsetup_timer(&mrt->ipmr_expire_timer, ipmr_expire_process,\n\t\t    (unsigned long)mrt);\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tmrt->mroute_reg_vif_num = -1;\n#endif\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n\tlist_add_tail_rcu(&mrt->list, &net->ipv6.mr6_tables);\n#endif\n\treturn mrt;\n}\n\nstatic void ip6mr_free_table(struct mr6_table *mrt)\n{\n\tdel_timer_sync(&mrt->ipmr_expire_timer);\n\tmroute_clean_tables(mrt, true);\n\tkfree(mrt);\n}\n\n#ifdef CONFIG_PROC_FS\n\nstruct ipmr_mfc_iter {\n\tstruct seq_net_private p;\n\tstruct mr6_table *mrt;\n\tstruct list_head *cache;\n\tint ct;\n};\n\n\nstatic struct mfc6_cache *ipmr_mfc_seq_idx(struct net *net,\n\t\t\t\t\t   struct ipmr_mfc_iter *it, loff_t pos)\n{\n\tstruct mr6_table *mrt = it->mrt;\n\tstruct mfc6_cache *mfc;\n\n\tread_lock(&mrt_lock);\n\tfor (it->ct = 0; it->ct < MFC6_LINES; it->ct++) {\n\t\tit->cache = &mrt->mfc6_cache_array[it->ct];\n\t\tlist_for_each_entry(mfc, it->cache, list)\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn mfc;\n\t}\n\tread_unlock(&mrt_lock);\n\n\tspin_lock_bh(&mfc_unres_lock);\n\tit->cache = &mrt->mfc6_unres_queue;\n\tlist_for_each_entry(mfc, it->cache, list)\n\t\tif (pos-- == 0)\n\t\t\treturn mfc;\n\tspin_unlock_bh(&mfc_unres_lock);\n\n\tit->cache = NULL;\n\treturn NULL;\n}\n\n/*\n *\tThe /proc interfaces to multicast routing /proc/ip6_mr_cache /proc/ip6_mr_vif\n */\n\nstruct ipmr_vif_iter {\n\tstruct seq_net_private p;\n\tstruct mr6_table *mrt;\n\tint ct;\n};\n\nstatic struct mif_device *ip6mr_vif_seq_idx(struct net *net,\n\t\t\t\t\t    struct ipmr_vif_iter *iter,\n\t\t\t\t\t    loff_t pos)\n{\n\tstruct mr6_table *mrt = iter->mrt;\n\n\tfor (iter->ct = 0; iter->ct < mrt->maxvif; ++iter->ct) {\n\t\tif (!MIF_EXISTS(mrt, iter->ct))\n\t\t\tcontinue;\n\t\tif (pos-- == 0)\n\t\t\treturn &mrt->vif6_table[iter->ct];\n\t}\n\treturn NULL;\n}\n\nstatic void *ip6mr_vif_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(mrt_lock)\n{\n\tstruct ipmr_vif_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn ERR_PTR(-ENOENT);\n\n\titer->mrt = mrt;\n\n\tread_lock(&mrt_lock);\n\treturn *pos ? ip6mr_vif_seq_idx(net, seq->private, *pos - 1)\n\t\t: SEQ_START_TOKEN;\n}\n\nstatic void *ip6mr_vif_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ipmr_vif_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt = iter->mrt;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ip6mr_vif_seq_idx(net, iter, 0);\n\n\twhile (++iter->ct < mrt->maxvif) {\n\t\tif (!MIF_EXISTS(mrt, iter->ct))\n\t\t\tcontinue;\n\t\treturn &mrt->vif6_table[iter->ct];\n\t}\n\treturn NULL;\n}\n\nstatic void ip6mr_vif_seq_stop(struct seq_file *seq, void *v)\n\t__releases(mrt_lock)\n{\n\tread_unlock(&mrt_lock);\n}\n\nstatic int ip6mr_vif_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ipmr_vif_iter *iter = seq->private;\n\tstruct mr6_table *mrt = iter->mrt;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Interface      BytesIn  PktsIn  BytesOut PktsOut Flags\\n\");\n\t} else {\n\t\tconst struct mif_device *vif = v;\n\t\tconst char *name = vif->dev ? vif->dev->name : \"none\";\n\n\t\tseq_printf(seq,\n\t\t\t   \"%2td %-10s %8ld %7ld  %8ld %7ld %05X\\n\",\n\t\t\t   vif - mrt->vif6_table,\n\t\t\t   name, vif->bytes_in, vif->pkt_in,\n\t\t\t   vif->bytes_out, vif->pkt_out,\n\t\t\t   vif->flags);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip6mr_vif_seq_ops = {\n\t.start = ip6mr_vif_seq_start,\n\t.next  = ip6mr_vif_seq_next,\n\t.stop  = ip6mr_vif_seq_stop,\n\t.show  = ip6mr_vif_seq_show,\n};\n\nstatic int ip6mr_vif_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &ip6mr_vif_seq_ops,\n\t\t\t    sizeof(struct ipmr_vif_iter));\n}\n\nstatic const struct file_operations ip6mr_vif_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open    = ip6mr_vif_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net,\n};\n\nstatic void *ipmr_mfc_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct ipmr_mfc_iter *it = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tit->mrt = mrt;\n\treturn *pos ? ipmr_mfc_seq_idx(net, seq->private, *pos - 1)\n\t\t: SEQ_START_TOKEN;\n}\n\nstatic void *ipmr_mfc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct mfc6_cache *mfc = v;\n\tstruct ipmr_mfc_iter *it = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt = it->mrt;\n\n\t++*pos;\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ipmr_mfc_seq_idx(net, seq->private, 0);\n\n\tif (mfc->list.next != it->cache)\n\t\treturn list_entry(mfc->list.next, struct mfc6_cache, list);\n\n\tif (it->cache == &mrt->mfc6_unres_queue)\n\t\tgoto end_of_list;\n\n\tBUG_ON(it->cache != &mrt->mfc6_cache_array[it->ct]);\n\n\twhile (++it->ct < MFC6_LINES) {\n\t\tit->cache = &mrt->mfc6_cache_array[it->ct];\n\t\tif (list_empty(it->cache))\n\t\t\tcontinue;\n\t\treturn list_first_entry(it->cache, struct mfc6_cache, list);\n\t}\n\n\t/* exhausted cache_array, show unresolved */\n\tread_unlock(&mrt_lock);\n\tit->cache = &mrt->mfc6_unres_queue;\n\tit->ct = 0;\n\n\tspin_lock_bh(&mfc_unres_lock);\n\tif (!list_empty(it->cache))\n\t\treturn list_first_entry(it->cache, struct mfc6_cache, list);\n\n end_of_list:\n\tspin_unlock_bh(&mfc_unres_lock);\n\tit->cache = NULL;\n\n\treturn NULL;\n}\n\nstatic void ipmr_mfc_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct ipmr_mfc_iter *it = seq->private;\n\tstruct mr6_table *mrt = it->mrt;\n\n\tif (it->cache == &mrt->mfc6_unres_queue)\n\t\tspin_unlock_bh(&mfc_unres_lock);\n\telse if (it->cache == &mrt->mfc6_cache_array[it->ct])\n\t\tread_unlock(&mrt_lock);\n}\n\nstatic int ipmr_mfc_seq_show(struct seq_file *seq, void *v)\n{\n\tint n;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Group                            \"\n\t\t\t \"Origin                           \"\n\t\t\t \"Iif      Pkts  Bytes     Wrong  Oifs\\n\");\n\t} else {\n\t\tconst struct mfc6_cache *mfc = v;\n\t\tconst struct ipmr_mfc_iter *it = seq->private;\n\t\tstruct mr6_table *mrt = it->mrt;\n\n\t\tseq_printf(seq, \"%pI6 %pI6 %-3hd\",\n\t\t\t   &mfc->mf6c_mcastgrp, &mfc->mf6c_origin,\n\t\t\t   mfc->mf6c_parent);\n\n\t\tif (it->cache != &mrt->mfc6_unres_queue) {\n\t\t\tseq_printf(seq, \" %8lu %8lu %8lu\",\n\t\t\t\t   mfc->mfc_un.res.pkt,\n\t\t\t\t   mfc->mfc_un.res.bytes,\n\t\t\t\t   mfc->mfc_un.res.wrong_if);\n\t\t\tfor (n = mfc->mfc_un.res.minvif;\n\t\t\t     n < mfc->mfc_un.res.maxvif; n++) {\n\t\t\t\tif (MIF_EXISTS(mrt, n) &&\n\t\t\t\t    mfc->mfc_un.res.ttls[n] < 255)\n\t\t\t\t\tseq_printf(seq,\n\t\t\t\t\t\t   \" %2d:%-3d\",\n\t\t\t\t\t\t   n, mfc->mfc_un.res.ttls[n]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* unresolved mfc_caches don't contain\n\t\t\t * pkt, bytes and wrong_if values\n\t\t\t */\n\t\t\tseq_printf(seq, \" %8lu %8lu %8lu\", 0ul, 0ul, 0ul);\n\t\t}\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ipmr_mfc_seq_ops = {\n\t.start = ipmr_mfc_seq_start,\n\t.next  = ipmr_mfc_seq_next,\n\t.stop  = ipmr_mfc_seq_stop,\n\t.show  = ipmr_mfc_seq_show,\n};\n\nstatic int ipmr_mfc_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &ipmr_mfc_seq_ops,\n\t\t\t    sizeof(struct ipmr_mfc_iter));\n}\n\nstatic const struct file_operations ip6mr_mfc_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open    = ipmr_mfc_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net,\n};\n#endif\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\nstatic int pim6_rcv(struct sk_buff *skb)\n{\n\tstruct pimreghdr *pim;\n\tstruct ipv6hdr   *encap;\n\tstruct net_device  *reg_dev = NULL;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint reg_vif_num;\n\n\tif (!pskb_may_pull(skb, sizeof(*pim) + sizeof(*encap)))\n\t\tgoto drop;\n\n\tpim = (struct pimreghdr *)skb_transport_header(skb);\n\tif (pim->type != ((PIM_VERSION << 4) | PIM_TYPE_REGISTER) ||\n\t    (pim->flags & PIM_NULL_REGISTER) ||\n\t    (csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\n\t\t\t     sizeof(*pim), IPPROTO_PIM,\n\t\t\t     csum_partial((void *)pim, sizeof(*pim), 0)) &&\n\t     csum_fold(skb_checksum(skb, 0, skb->len, 0))))\n\t\tgoto drop;\n\n\t/* check if the inner packet is destined to mcast group */\n\tencap = (struct ipv6hdr *)(skb_transport_header(skb) +\n\t\t\t\t   sizeof(*pim));\n\n\tif (!ipv6_addr_is_multicast(&encap->daddr) ||\n\t    encap->payload_len == 0 ||\n\t    ntohs(encap->payload_len) + sizeof(*pim) > skb->len)\n\t\tgoto drop;\n\n\tif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\n\t\tgoto drop;\n\treg_vif_num = mrt->mroute_reg_vif_num;\n\n\tread_lock(&mrt_lock);\n\tif (reg_vif_num >= 0)\n\t\treg_dev = mrt->vif6_table[reg_vif_num].dev;\n\tif (reg_dev)\n\t\tdev_hold(reg_dev);\n\tread_unlock(&mrt_lock);\n\n\tif (!reg_dev)\n\t\tgoto drop;\n\n\tskb->mac_header = skb->network_header;\n\tskb_pull(skb, (u8 *)encap - skb->data);\n\tskb_reset_network_header(skb);\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));\n\n\tnetif_rx(skb);\n\n\tdev_put(reg_dev);\n\treturn 0;\n drop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic const struct inet6_protocol pim6_protocol = {\n\t.handler\t=\tpim6_rcv,\n};\n\n/* Service routines creating virtual interfaces: PIMREG */\n\nstatic netdev_tx_t reg_vif_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif\t= dev->ifindex,\n\t\t.flowi6_iif\t= skb->skb_iif ? : LOOPBACK_IFINDEX,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint err;\n\n\terr = ip6mr_fib_lookup(net, &fl6, &mrt);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tread_lock(&mrt_lock);\n\tdev->stats.tx_bytes += skb->len;\n\tdev->stats.tx_packets++;\n\tip6mr_cache_report(mrt, skb, mrt->mroute_reg_vif_num, MRT6MSG_WHOLEPKT);\n\tread_unlock(&mrt_lock);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int reg_vif_get_iflink(const struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct net_device_ops reg_vif_netdev_ops = {\n\t.ndo_start_xmit\t= reg_vif_xmit,\n\t.ndo_get_iflink = reg_vif_get_iflink,\n};\n\nstatic void reg_vif_setup(struct net_device *dev)\n{\n\tdev->type\t\t= ARPHRD_PIMREG;\n\tdev->mtu\t\t= 1500 - sizeof(struct ipv6hdr) - 8;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->netdev_ops\t\t= &reg_vif_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic struct net_device *ip6mr_reg_vif(struct net *net, struct mr6_table *mrt)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\n\tif (mrt->id == RT6_TABLE_DFLT)\n\t\tsprintf(name, \"pim6reg\");\n\telse\n\t\tsprintf(name, \"pim6reg%u\", mrt->id);\n\n\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, reg_vif_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (register_netdevice(dev)) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tif (dev_open(dev))\n\t\tgoto failure;\n\n\tdev_hold(dev);\n\treturn dev;\n\nfailure:\n\tunregister_netdevice(dev);\n\treturn NULL;\n}\n#endif\n\n/*\n *\tDelete a VIF entry\n */\n\nstatic int mif6_delete(struct mr6_table *mrt, int vifi, struct list_head *head)\n{\n\tstruct mif_device *v;\n\tstruct net_device *dev;\n\tstruct inet6_dev *in6_dev;\n\n\tif (vifi < 0 || vifi >= mrt->maxvif)\n\t\treturn -EADDRNOTAVAIL;\n\n\tv = &mrt->vif6_table[vifi];\n\n\twrite_lock_bh(&mrt_lock);\n\tdev = v->dev;\n\tv->dev = NULL;\n\n\tif (!dev) {\n\t\twrite_unlock_bh(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (vifi == mrt->mroute_reg_vif_num)\n\t\tmrt->mroute_reg_vif_num = -1;\n#endif\n\n\tif (vifi + 1 == mrt->maxvif) {\n\t\tint tmp;\n\t\tfor (tmp = vifi - 1; tmp >= 0; tmp--) {\n\t\t\tif (MIF_EXISTS(mrt, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tmrt->maxvif = tmp + 1;\n\t}\n\n\twrite_unlock_bh(&mrt_lock);\n\n\tdev_set_allmulti(dev, -1);\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (in6_dev) {\n\t\tin6_dev->cnf.mc_forwarding--;\n\t\tinet6_netconf_notify_devconf(dev_net(dev),\n\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     dev->ifindex, &in6_dev->cnf);\n\t}\n\n\tif (v->flags & MIFF_REGISTER)\n\t\tunregister_netdevice_queue(dev, head);\n\n\tdev_put(dev);\n\treturn 0;\n}\n\nstatic inline void ip6mr_cache_free(struct mfc6_cache *c)\n{\n\tkmem_cache_free(mrt_cachep, c);\n}\n\n/* Destroy an unresolved cache entry, killing queued skbs\n   and reporting error to netlink readers.\n */\n\nstatic void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&mrt->cache_resolve_queue_len);\n\n\twhile ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {\n\t\tif (ipv6_hdr(skb)->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;\n\t\t\trtnl_unicast(skb, net, NETLINK_CB(skb).portid);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tip6mr_cache_free(c);\n}\n\n\n/* Timer process for all the unresolved queue. */\n\nstatic void ipmr_do_expire_process(struct mr6_table *mrt)\n{\n\tunsigned long now = jiffies;\n\tunsigned long expires = 10 * HZ;\n\tstruct mfc6_cache *c, *next;\n\n\tlist_for_each_entry_safe(c, next, &mrt->mfc6_unres_queue, list) {\n\t\tif (time_after(c->mfc_un.unres.expires, now)) {\n\t\t\t/* not yet... */\n\t\t\tunsigned long interval = c->mfc_un.unres.expires - now;\n\t\t\tif (interval < expires)\n\t\t\t\texpires = interval;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&c->list);\n\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\tip6mr_destroy_unres(mrt, c);\n\t}\n\n\tif (!list_empty(&mrt->mfc6_unres_queue))\n\t\tmod_timer(&mrt->ipmr_expire_timer, jiffies + expires);\n}\n\nstatic void ipmr_expire_process(unsigned long arg)\n{\n\tstruct mr6_table *mrt = (struct mr6_table *)arg;\n\n\tif (!spin_trylock(&mfc_unres_lock)) {\n\t\tmod_timer(&mrt->ipmr_expire_timer, jiffies + 1);\n\t\treturn;\n\t}\n\n\tif (!list_empty(&mrt->mfc6_unres_queue))\n\t\tipmr_do_expire_process(mrt);\n\n\tspin_unlock(&mfc_unres_lock);\n}\n\n/* Fill oifs list. It is called under write locked mrt_lock. */\n\nstatic void ip6mr_update_thresholds(struct mr6_table *mrt, struct mfc6_cache *cache,\n\t\t\t\t    unsigned char *ttls)\n{\n\tint vifi;\n\n\tcache->mfc_un.res.minvif = MAXMIFS;\n\tcache->mfc_un.res.maxvif = 0;\n\tmemset(cache->mfc_un.res.ttls, 255, MAXMIFS);\n\n\tfor (vifi = 0; vifi < mrt->maxvif; vifi++) {\n\t\tif (MIF_EXISTS(mrt, vifi) &&\n\t\t    ttls[vifi] && ttls[vifi] < 255) {\n\t\t\tcache->mfc_un.res.ttls[vifi] = ttls[vifi];\n\t\t\tif (cache->mfc_un.res.minvif > vifi)\n\t\t\t\tcache->mfc_un.res.minvif = vifi;\n\t\t\tif (cache->mfc_un.res.maxvif <= vifi)\n\t\t\t\tcache->mfc_un.res.maxvif = vifi + 1;\n\t\t}\n\t}\n\tcache->mfc_un.res.lastuse = jiffies;\n}\n\nstatic int mif6_add(struct net *net, struct mr6_table *mrt,\n\t\t    struct mif6ctl *vifc, int mrtsock)\n{\n\tint vifi = vifc->mif6c_mifi;\n\tstruct mif_device *v = &mrt->vif6_table[vifi];\n\tstruct net_device *dev;\n\tstruct inet6_dev *in6_dev;\n\tint err;\n\n\t/* Is vif busy ? */\n\tif (MIF_EXISTS(mrt, vifi))\n\t\treturn -EADDRINUSE;\n\n\tswitch (vifc->mif6c_flags) {\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MIFF_REGISTER:\n\t\t/*\n\t\t * Special Purpose VIF in PIM\n\t\t * All the packets will be sent to the daemon\n\t\t */\n\t\tif (mrt->mroute_reg_vif_num >= 0)\n\t\t\treturn -EADDRINUSE;\n\t\tdev = ip6mr_reg_vif(net, mrt);\n\t\tif (!dev)\n\t\t\treturn -ENOBUFS;\n\t\terr = dev_set_allmulti(dev, 1);\n\t\tif (err) {\n\t\t\tunregister_netdevice(dev);\n\t\t\tdev_put(dev);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n#endif\n\tcase 0:\n\t\tdev = dev_get_by_index(net, vifc->mif6c_pifi);\n\t\tif (!dev)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\terr = dev_set_allmulti(dev, 1);\n\t\tif (err) {\n\t\t\tdev_put(dev);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (in6_dev) {\n\t\tin6_dev->cnf.mc_forwarding++;\n\t\tinet6_netconf_notify_devconf(dev_net(dev),\n\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     dev->ifindex, &in6_dev->cnf);\n\t}\n\n\t/*\n\t *\tFill in the VIF structures\n\t */\n\tv->rate_limit = vifc->vifc_rate_limit;\n\tv->flags = vifc->mif6c_flags;\n\tif (!mrtsock)\n\t\tv->flags |= VIFF_STATIC;\n\tv->threshold = vifc->vifc_threshold;\n\tv->bytes_in = 0;\n\tv->bytes_out = 0;\n\tv->pkt_in = 0;\n\tv->pkt_out = 0;\n\tv->link = dev->ifindex;\n\tif (v->flags & MIFF_REGISTER)\n\t\tv->link = dev_get_iflink(dev);\n\n\t/* And finish update writing critical data */\n\twrite_lock_bh(&mrt_lock);\n\tv->dev = dev;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (v->flags & MIFF_REGISTER)\n\t\tmrt->mroute_reg_vif_num = vifi;\n#endif\n\tif (vifi + 1 > mrt->maxvif)\n\t\tmrt->maxvif = vifi + 1;\n\twrite_unlock_bh(&mrt_lock);\n\treturn 0;\n}\n\nstatic struct mfc6_cache *ip6mr_cache_find(struct mr6_table *mrt,\n\t\t\t\t\t   const struct in6_addr *origin,\n\t\t\t\t\t   const struct in6_addr *mcastgrp)\n{\n\tint line = MFC6_HASH(mcastgrp, origin);\n\tstruct mfc6_cache *c;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_origin, origin) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp))\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\n/* Look for a (*,*,oif) entry */\nstatic struct mfc6_cache *ip6mr_cache_find_any_parent(struct mr6_table *mrt,\n\t\t\t\t\t\t      mifi_t mifi)\n{\n\tint line = MFC6_HASH(&in6addr_any, &in6addr_any);\n\tstruct mfc6_cache *c;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\n\t\tif (ipv6_addr_any(&c->mf6c_origin) &&\n\t\t    ipv6_addr_any(&c->mf6c_mcastgrp) &&\n\t\t    (c->mfc_un.res.ttls[mifi] < 255))\n\t\t\treturn c;\n\n\treturn NULL;\n}\n\n/* Look for a (*,G) entry */\nstatic struct mfc6_cache *ip6mr_cache_find_any(struct mr6_table *mrt,\n\t\t\t\t\t       struct in6_addr *mcastgrp,\n\t\t\t\t\t       mifi_t mifi)\n{\n\tint line = MFC6_HASH(mcastgrp, &in6addr_any);\n\tstruct mfc6_cache *c, *proxy;\n\n\tif (ipv6_addr_any(mcastgrp))\n\t\tgoto skip;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\n\t\tif (ipv6_addr_any(&c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp)) {\n\t\t\tif (c->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\n\t\t\t/* It's ok if the mifi is part of the static tree */\n\t\t\tproxy = ip6mr_cache_find_any_parent(mrt,\n\t\t\t\t\t\t\t    c->mf6c_parent);\n\t\t\tif (proxy && proxy->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\t\t}\n\nskip:\n\treturn ip6mr_cache_find_any_parent(mrt, mifi);\n}\n\n/*\n *\tAllocate a multicast cache entry\n */\nstatic struct mfc6_cache *ip6mr_cache_alloc(void)\n{\n\tstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);\n\tif (!c)\n\t\treturn NULL;\n\tc->mfc_un.res.last_assert = jiffies - MFC_ASSERT_THRESH - 1;\n\tc->mfc_un.res.minvif = MAXMIFS;\n\treturn c;\n}\n\nstatic struct mfc6_cache *ip6mr_cache_alloc_unres(void)\n{\n\tstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_ATOMIC);\n\tif (!c)\n\t\treturn NULL;\n\tskb_queue_head_init(&c->mfc_un.unres.unresolved);\n\tc->mfc_un.unres.expires = jiffies + 10 * HZ;\n\treturn c;\n}\n\n/*\n *\tA cache entry has gone into a resolved state from queued\n */\n\nstatic void ip6mr_cache_resolve(struct net *net, struct mr6_table *mrt,\n\t\t\t\tstruct mfc6_cache *uc, struct mfc6_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tPlay the pending entries through our router\n\t */\n\n\twhile ((skb = __skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (ipv6_hdr(skb)->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));\n\n\t\t\tif (__ip6mr_fill_mroute(mrt, skb, c, nlmsg_data(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb_tail_pointer(skb) - (u8 *)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr *)nlmsg_data(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\trtnl_unicast(skb, net, NETLINK_CB(skb).portid);\n\t\t} else\n\t\t\tip6_mr_forward(net, mrt, skb, c);\n\t}\n}\n\n/*\n *\tBounce a cache query up to pim6sd. We could use netlink for this but pim6sd\n *\texpects the following bizarre scheme.\n *\n *\tCalled under mrt_lock.\n */\n\nstatic int ip6mr_cache_report(struct mr6_table *mrt, struct sk_buff *pkt,\n\t\t\t      mifi_t mifi, int assert)\n{\n\tstruct sk_buff *skb;\n\tstruct mrt6msg *msg;\n\tint ret;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (assert == MRT6MSG_WHOLEPKT)\n\t\tskb = skb_realloc_headroom(pkt, -skb_network_offset(pkt)\n\t\t\t\t\t\t+sizeof(*msg));\n\telse\n#endif\n\t\tskb = alloc_skb(sizeof(struct ipv6hdr) + sizeof(*msg), GFP_ATOMIC);\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t/* I suppose that internal messages\n\t * do not require checksums */\n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (assert == MRT6MSG_WHOLEPKT) {\n\t\t/* Ugly, but we have no choice with this interface.\n\t\t   Duplicate old header, fix length etc.\n\t\t   And all this only to mangle msg->im6_msgtype and\n\t\t   to set msg->im6_mbz to \"mbz\" :-)\n\t\t */\n\t\tskb_push(skb, -skb_network_offset(pkt));\n\n\t\tskb_push(skb, sizeof(*msg));\n\t\tskb_reset_transport_header(skb);\n\t\tmsg = (struct mrt6msg *)skb_transport_header(skb);\n\t\tmsg->im6_mbz = 0;\n\t\tmsg->im6_msgtype = MRT6MSG_WHOLEPKT;\n\t\tmsg->im6_mif = mrt->mroute_reg_vif_num;\n\t\tmsg->im6_pad = 0;\n\t\tmsg->im6_src = ipv6_hdr(pkt)->saddr;\n\t\tmsg->im6_dst = ipv6_hdr(pkt)->daddr;\n\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t} else\n#endif\n\t{\n\t/*\n\t *\tCopy the IP header\n\t */\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tskb_copy_to_linear_data(skb, ipv6_hdr(pkt), sizeof(struct ipv6hdr));\n\n\t/*\n\t *\tAdd our header\n\t */\n\tskb_put(skb, sizeof(*msg));\n\tskb_reset_transport_header(skb);\n\tmsg = (struct mrt6msg *)skb_transport_header(skb);\n\n\tmsg->im6_mbz = 0;\n\tmsg->im6_msgtype = assert;\n\tmsg->im6_mif = mifi;\n\tmsg->im6_pad = 0;\n\tmsg->im6_src = ipv6_hdr(pkt)->saddr;\n\tmsg->im6_dst = ipv6_hdr(pkt)->daddr;\n\n\tskb_dst_set(skb, dst_clone(skb_dst(pkt)));\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\tif (!mrt->mroute6_sk) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t *\tDeliver to user space multicast routing algorithms\n\t */\n\tret = sock_queue_rcv_skb(mrt->mroute6_sk, skb);\n\tif (ret < 0) {\n\t\tnet_warn_ratelimited(\"mroute6: pending queue full, dropping entries\\n\");\n\t\tkfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\n/*\n *\tQueue a packet for resolution. It gets locked cache entry!\n */\n\nstatic int\nip6mr_cache_unresolved(struct mr6_table *mrt, mifi_t mifi, struct sk_buff *skb)\n{\n\tbool found = false;\n\tint err;\n\tstruct mfc6_cache *c;\n\n\tspin_lock_bh(&mfc_unres_lock);\n\tlist_for_each_entry(c, &mrt->mfc6_unres_queue, list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_mcastgrp, &ipv6_hdr(skb)->daddr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_origin, &ipv6_hdr(skb)->saddr)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t/*\n\t\t *\tCreate a new entry if allowable\n\t\t */\n\n\t\tif (atomic_read(&mrt->cache_resolve_queue_len) >= 10 ||\n\t\t    (c = ip6mr_cache_alloc_unres()) == NULL) {\n\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\t/*\n\t\t *\tFill in the new cache entry\n\t\t */\n\t\tc->mf6c_parent = -1;\n\t\tc->mf6c_origin = ipv6_hdr(skb)->saddr;\n\t\tc->mf6c_mcastgrp = ipv6_hdr(skb)->daddr;\n\n\t\t/*\n\t\t *\tReflect first query at pim6sd\n\t\t */\n\t\terr = ip6mr_cache_report(mrt, skb, mifi, MRT6MSG_NOCACHE);\n\t\tif (err < 0) {\n\t\t\t/* If the report failed throw the cache entry\n\t\t\t   out - Brad Parker\n\t\t\t */\n\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\n\t\t\tip6mr_cache_free(c);\n\t\t\tkfree_skb(skb);\n\t\t\treturn err;\n\t\t}\n\n\t\tatomic_inc(&mrt->cache_resolve_queue_len);\n\t\tlist_add(&c->list, &mrt->mfc6_unres_queue);\n\t\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\n\t\tipmr_do_expire_process(mrt);\n\t}\n\n\t/*\n\t *\tSee if we can append the packet\n\t */\n\tif (c->mfc_un.unres.unresolved.qlen > 3) {\n\t\tkfree_skb(skb);\n\t\terr = -ENOBUFS;\n\t} else {\n\t\tskb_queue_tail(&c->mfc_un.unres.unresolved, skb);\n\t\terr = 0;\n\t}\n\n\tspin_unlock_bh(&mfc_unres_lock);\n\treturn err;\n}\n\n/*\n *\tMFC6 cache manipulation by user space\n */\n\nstatic int ip6mr_mfc_delete(struct mr6_table *mrt, struct mf6cctl *mfc,\n\t\t\t    int parent)\n{\n\tint line;\n\tstruct mfc6_cache *c, *next;\n\n\tline = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);\n\n\tlist_for_each_entry_safe(c, next, &mrt->mfc6_cache_array[line], list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_origin, &mfc->mf6cc_origin.sin6_addr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp,\n\t\t\t\t    &mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t\t    (parent == -1 || parent == c->mf6c_parent)) {\n\t\t\twrite_lock_bh(&mrt_lock);\n\t\t\tlist_del(&c->list);\n\t\t\twrite_unlock_bh(&mrt_lock);\n\n\t\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\t\tip6mr_cache_free(c);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic int ip6mr_device_event(struct notifier_block *this,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct mr6_table *mrt;\n\tstruct mif_device *v;\n\tint ct;\n\tLIST_HEAD(list);\n\n\tif (event != NETDEV_UNREGISTER)\n\t\treturn NOTIFY_DONE;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tv = &mrt->vif6_table[0];\n\t\tfor (ct = 0; ct < mrt->maxvif; ct++, v++) {\n\t\t\tif (v->dev == dev)\n\t\t\t\tmif6_delete(mrt, ct, &list);\n\t\t}\n\t}\n\tunregister_netdevice_many(&list);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ip6_mr_notifier = {\n\t.notifier_call = ip6mr_device_event\n};\n\n/*\n *\tSetup for IP multicast routing\n */\n\nstatic int __net_init ip6mr_net_init(struct net *net)\n{\n\tint err;\n\n\terr = ip6mr_rules_init(net);\n\tif (err < 0)\n\t\tgoto fail;\n\n#ifdef CONFIG_PROC_FS\n\terr = -ENOMEM;\n\tif (!proc_create(\"ip6_mr_vif\", 0, net->proc_net, &ip6mr_vif_fops))\n\t\tgoto proc_vif_fail;\n\tif (!proc_create(\"ip6_mr_cache\", 0, net->proc_net, &ip6mr_mfc_fops))\n\t\tgoto proc_cache_fail;\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_PROC_FS\nproc_cache_fail:\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\nproc_vif_fail:\n\tip6mr_rules_exit(net);\n#endif\nfail:\n\treturn err;\n}\n\nstatic void __net_exit ip6mr_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip6_mr_cache\", net->proc_net);\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\n#endif\n\tip6mr_rules_exit(net);\n}\n\nstatic struct pernet_operations ip6mr_net_ops = {\n\t.init = ip6mr_net_init,\n\t.exit = ip6mr_net_exit,\n};\n\nint __init ip6_mr_init(void)\n{\n\tint err;\n\n\tmrt_cachep = kmem_cache_create(\"ip6_mrt_cache\",\n\t\t\t\t       sizeof(struct mfc6_cache),\n\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t       NULL);\n\tif (!mrt_cachep)\n\t\treturn -ENOMEM;\n\n\terr = register_pernet_subsys(&ip6mr_net_ops);\n\tif (err)\n\t\tgoto reg_pernet_fail;\n\n\terr = register_netdevice_notifier(&ip6_mr_notifier);\n\tif (err)\n\t\tgoto reg_notif_fail;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (inet6_add_protocol(&pim6_protocol, IPPROTO_PIM) < 0) {\n\t\tpr_err(\"%s: can't add PIM protocol\\n\", __func__);\n\t\terr = -EAGAIN;\n\t\tgoto add_proto_fail;\n\t}\n#endif\n\trtnl_register(RTNL_FAMILY_IP6MR, RTM_GETROUTE, NULL,\n\t\t      ip6mr_rtm_dumproute, NULL);\n\treturn 0;\n#ifdef CONFIG_IPV6_PIMSM_V2\nadd_proto_fail:\n\tunregister_netdevice_notifier(&ip6_mr_notifier);\n#endif\nreg_notif_fail:\n\tunregister_pernet_subsys(&ip6mr_net_ops);\nreg_pernet_fail:\n\tkmem_cache_destroy(mrt_cachep);\n\treturn err;\n}\n\nvoid ip6_mr_cleanup(void)\n{\n\trtnl_unregister(RTNL_FAMILY_IP6MR, RTM_GETROUTE);\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tinet6_del_protocol(&pim6_protocol, IPPROTO_PIM);\n#endif\n\tunregister_netdevice_notifier(&ip6_mr_notifier);\n\tunregister_pernet_subsys(&ip6mr_net_ops);\n\tkmem_cache_destroy(mrt_cachep);\n}\n\nstatic int ip6mr_mfc_add(struct net *net, struct mr6_table *mrt,\n\t\t\t struct mf6cctl *mfc, int mrtsock, int parent)\n{\n\tbool found = false;\n\tint line;\n\tstruct mfc6_cache *uc, *c;\n\tunsigned char ttls[MAXMIFS];\n\tint i;\n\n\tif (mfc->mf6cc_parent >= MAXMIFS)\n\t\treturn -ENFILE;\n\n\tmemset(ttls, 255, MAXMIFS);\n\tfor (i = 0; i < MAXMIFS; i++) {\n\t\tif (IF_ISSET(i, &mfc->mf6cc_ifset))\n\t\t\tttls[i] = 1;\n\n\t}\n\n\tline = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_origin, &mfc->mf6cc_origin.sin6_addr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp,\n\t\t\t\t    &mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t\t    (parent == -1 || parent == mfc->mf6cc_parent)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\twrite_lock_bh(&mrt_lock);\n\t\tc->mf6c_parent = mfc->mf6cc_parent;\n\t\tip6mr_update_thresholds(mrt, c, ttls);\n\t\tif (!mrtsock)\n\t\t\tc->mfc_flags |= MFC_STATIC;\n\t\twrite_unlock_bh(&mrt_lock);\n\t\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\t\treturn 0;\n\t}\n\n\tif (!ipv6_addr_any(&mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t    !ipv6_addr_is_multicast(&mfc->mf6cc_mcastgrp.sin6_addr))\n\t\treturn -EINVAL;\n\n\tc = ip6mr_cache_alloc();\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tc->mf6c_origin = mfc->mf6cc_origin.sin6_addr;\n\tc->mf6c_mcastgrp = mfc->mf6cc_mcastgrp.sin6_addr;\n\tc->mf6c_parent = mfc->mf6cc_parent;\n\tip6mr_update_thresholds(mrt, c, ttls);\n\tif (!mrtsock)\n\t\tc->mfc_flags |= MFC_STATIC;\n\n\twrite_lock_bh(&mrt_lock);\n\tlist_add(&c->list, &mrt->mfc6_cache_array[line]);\n\twrite_unlock_bh(&mrt_lock);\n\n\t/*\n\t *\tCheck to see if we resolved a queued list. If so we\n\t *\tneed to send on the frames and tidy up.\n\t */\n\tfound = false;\n\tspin_lock_bh(&mfc_unres_lock);\n\tlist_for_each_entry(uc, &mrt->mfc6_unres_queue, list) {\n\t\tif (ipv6_addr_equal(&uc->mf6c_origin, &c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&uc->mf6c_mcastgrp, &c->mf6c_mcastgrp)) {\n\t\t\tlist_del(&uc->list);\n\t\t\tatomic_dec(&mrt->cache_resolve_queue_len);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&mrt->mfc6_unres_queue))\n\t\tdel_timer(&mrt->ipmr_expire_timer);\n\tspin_unlock_bh(&mfc_unres_lock);\n\n\tif (found) {\n\t\tip6mr_cache_resolve(net, mrt, uc, c);\n\t\tip6mr_cache_free(uc);\n\t}\n\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\treturn 0;\n}\n\n/*\n *\tClose the multicast socket, and clear the vif tables etc\n */\n\nstatic void mroute_clean_tables(struct mr6_table *mrt, bool all)\n{\n\tint i;\n\tLIST_HEAD(list);\n\tstruct mfc6_cache *c, *next;\n\n\t/*\n\t *\tShut down all active vif entries\n\t */\n\tfor (i = 0; i < mrt->maxvif; i++) {\n\t\tif (!all && (mrt->vif6_table[i].flags & VIFF_STATIC))\n\t\t\tcontinue;\n\t\tmif6_delete(mrt, i, &list);\n\t}\n\tunregister_netdevice_many(&list);\n\n\t/*\n\t *\tWipe the cache\n\t */\n\tfor (i = 0; i < MFC6_LINES; i++) {\n\t\tlist_for_each_entry_safe(c, next, &mrt->mfc6_cache_array[i], list) {\n\t\t\tif (!all && (c->mfc_flags & MFC_STATIC))\n\t\t\t\tcontinue;\n\t\t\twrite_lock_bh(&mrt_lock);\n\t\t\tlist_del(&c->list);\n\t\t\twrite_unlock_bh(&mrt_lock);\n\n\t\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\t\tip6mr_cache_free(c);\n\t\t}\n\t}\n\n\tif (atomic_read(&mrt->cache_resolve_queue_len) != 0) {\n\t\tspin_lock_bh(&mfc_unres_lock);\n\t\tlist_for_each_entry_safe(c, next, &mrt->mfc6_unres_queue, list) {\n\t\t\tlist_del(&c->list);\n\t\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\t\tip6mr_destroy_unres(mrt, c);\n\t\t}\n\t\tspin_unlock_bh(&mfc_unres_lock);\n\t}\n}\n\nstatic int ip6mr_sk_init(struct mr6_table *mrt, struct sock *sk)\n{\n\tint err = 0;\n\tstruct net *net = sock_net(sk);\n\n\trtnl_lock();\n\twrite_lock_bh(&mrt_lock);\n\tif (likely(mrt->mroute6_sk == NULL)) {\n\t\tmrt->mroute6_sk = sk;\n\t\tnet->ipv6.devconf_all->mc_forwarding++;\n\t} else {\n\t\terr = -EADDRINUSE;\n\t}\n\twrite_unlock_bh(&mrt_lock);\n\n\tif (!err)\n\t\tinet6_netconf_notify_devconf(net, NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t     net->ipv6.devconf_all);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nint ip6mr_sk_done(struct sock *sk)\n{\n\tint err = -EACCES;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\trtnl_lock();\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (sk == mrt->mroute6_sk) {\n\t\t\twrite_lock_bh(&mrt_lock);\n\t\t\tmrt->mroute6_sk = NULL;\n\t\t\tnet->ipv6.devconf_all->mc_forwarding--;\n\t\t\twrite_unlock_bh(&mrt_lock);\n\t\t\tinet6_netconf_notify_devconf(net,\n\t\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t\t     net->ipv6.devconf_all);\n\n\t\t\tmroute_clean_tables(mrt, false);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstruct sock *mroute6_socket(struct net *net, struct sk_buff *skb)\n{\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->skb_iif ? : LOOPBACK_IFINDEX,\n\t\t.flowi6_oif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\n\tif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\n\t\treturn NULL;\n\n\treturn mrt->mroute6_sk;\n}\n\n/*\n *\tSocket options and virtual interface manipulation. The whole\n *\tvirtual interface system is a complete heap, but unfortunately\n *\tthat's how BSD mrouted happens to think. Maybe one day with a proper\n *\tMOSPF/PIM router set up we can clean this up.\n */\n\nint ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, unsigned int optlen)\n{\n\tint ret, parent = 0;\n\tstruct mif6ctl vif;\n\tstruct mf6cctl mfc;\n\tmifi_t mifi;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tif (optname != MRT6_INIT) {\n\t\tif (sk != mrt->mroute6_sk && !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tswitch (optname) {\n\tcase MRT6_INIT:\n\t\tif (sk->sk_type != SOCK_RAW ||\n\t\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (optlen < sizeof(int))\n\t\t\treturn -EINVAL;\n\n\t\treturn ip6mr_sk_init(mrt, sk);\n\n\tcase MRT6_DONE:\n\t\treturn ip6mr_sk_done(sk);\n\n\tcase MRT6_ADD_MIF:\n\t\tif (optlen < sizeof(vif))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&vif, optval, sizeof(vif)))\n\t\t\treturn -EFAULT;\n\t\tif (vif.mif6c_mifi >= MAXMIFS)\n\t\t\treturn -ENFILE;\n\t\trtnl_lock();\n\t\tret = mif6_add(net, mrt, &vif, sk == mrt->mroute6_sk);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\tcase MRT6_DEL_MIF:\n\t\tif (optlen < sizeof(mifi_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&mifi, optval, sizeof(mifi_t)))\n\t\t\treturn -EFAULT;\n\t\trtnl_lock();\n\t\tret = mif6_delete(mrt, mifi, NULL);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\t/*\n\t *\tManipulate the forwarding caches. These live\n\t *\tin a sort of kernel/user symbiosis.\n\t */\n\tcase MRT6_ADD_MFC:\n\tcase MRT6_DEL_MFC:\n\t\tparent = -1;\n\tcase MRT6_ADD_MFC_PROXY:\n\tcase MRT6_DEL_MFC_PROXY:\n\t\tif (optlen < sizeof(mfc))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&mfc, optval, sizeof(mfc)))\n\t\t\treturn -EFAULT;\n\t\tif (parent == 0)\n\t\t\tparent = mfc.mf6cc_parent;\n\t\trtnl_lock();\n\t\tif (optname == MRT6_DEL_MFC || optname == MRT6_DEL_MFC_PROXY)\n\t\t\tret = ip6mr_mfc_delete(mrt, &mfc, parent);\n\t\telse\n\t\t\tret = ip6mr_mfc_add(net, mrt, &mfc,\n\t\t\t\t\t    sk == mrt->mroute6_sk, parent);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\t/*\n\t *\tControl PIM assert (to activate pim will activate assert)\n\t */\n\tcase MRT6_ASSERT:\n\t{\n\t\tint v;\n\n\t\tif (optlen != sizeof(v))\n\t\t\treturn -EINVAL;\n\t\tif (get_user(v, (int __user *)optval))\n\t\t\treturn -EFAULT;\n\t\tmrt->mroute_do_assert = v;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t{\n\t\tint v;\n\n\t\tif (optlen != sizeof(v))\n\t\t\treturn -EINVAL;\n\t\tif (get_user(v, (int __user *)optval))\n\t\t\treturn -EFAULT;\n\t\tv = !!v;\n\t\trtnl_lock();\n\t\tret = 0;\n\t\tif (v != mrt->mroute_do_pim) {\n\t\t\tmrt->mroute_do_pim = v;\n\t\t\tmrt->mroute_do_assert = v;\n\t\t}\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n\n#endif\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n\tcase MRT6_TABLE:\n\t{\n\t\tu32 v;\n\n\t\tif (optlen != sizeof(u32))\n\t\t\treturn -EINVAL;\n\t\tif (get_user(v, (u32 __user *)optval))\n\t\t\treturn -EFAULT;\n\t\t/* \"pim6reg%u\" should not exceed 16 bytes (IFNAMSIZ) */\n\t\tif (v != RT_TABLE_DEFAULT && v >= 100000000)\n\t\t\treturn -EINVAL;\n\t\tif (sk == mrt->mroute6_sk)\n\t\t\treturn -EBUSY;\n\n\t\trtnl_lock();\n\t\tret = 0;\n\t\tif (!ip6mr_new_table(net, v))\n\t\t\tret = -ENOMEM;\n\t\traw6_sk(sk)->ip6mr_table = v;\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n#endif\n\t/*\n\t *\tSpurious command, or MRT6_VERSION which you cannot\n\t *\tset.\n\t */\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\n/*\n *\tGetsock opt support for the multicast routing system.\n */\n\nint ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n *\tThe IP multicast ioctl support routines.\n */\n\nint ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg)\n{\n\tstruct sioc_sg_req6 sr;\n\tstruct sioc_mif_req6 vr;\n\tstruct mif_device *vif;\n\tstruct mfc6_cache *c;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (cmd) {\n\tcase SIOCGETMIFCNT_IN6:\n\t\tif (copy_from_user(&vr, arg, sizeof(vr)))\n\t\t\treturn -EFAULT;\n\t\tif (vr.mifi >= mrt->maxvif)\n\t\t\treturn -EINVAL;\n\t\tread_lock(&mrt_lock);\n\t\tvif = &mrt->vif6_table[vr.mifi];\n\t\tif (MIF_EXISTS(mrt, vr.mifi)) {\n\t\t\tvr.icount = vif->pkt_in;\n\t\t\tvr.ocount = vif->pkt_out;\n\t\t\tvr.ibytes = vif->bytes_in;\n\t\t\tvr.obytes = vif->bytes_out;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &vr, sizeof(vr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tcase SIOCGETSGCNT_IN6:\n\t\tif (copy_from_user(&sr, arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\tread_lock(&mrt_lock);\n\t\tc = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);\n\t\tif (c) {\n\t\t\tsr.pktcnt = c->mfc_un.res.pkt;\n\t\t\tsr.bytecnt = c->mfc_un.res.bytes;\n\t\t\tsr.wrong_if = c->mfc_un.res.wrong_if;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &sr, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_sioc_sg_req6 {\n\tstruct sockaddr_in6 src;\n\tstruct sockaddr_in6 grp;\n\tcompat_ulong_t pktcnt;\n\tcompat_ulong_t bytecnt;\n\tcompat_ulong_t wrong_if;\n};\n\nstruct compat_sioc_mif_req6 {\n\tmifi_t\tmifi;\n\tcompat_ulong_t icount;\n\tcompat_ulong_t ocount;\n\tcompat_ulong_t ibytes;\n\tcompat_ulong_t obytes;\n};\n\nint ip6mr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)\n{\n\tstruct compat_sioc_sg_req6 sr;\n\tstruct compat_sioc_mif_req6 vr;\n\tstruct mif_device *vif;\n\tstruct mfc6_cache *c;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (cmd) {\n\tcase SIOCGETMIFCNT_IN6:\n\t\tif (copy_from_user(&vr, arg, sizeof(vr)))\n\t\t\treturn -EFAULT;\n\t\tif (vr.mifi >= mrt->maxvif)\n\t\t\treturn -EINVAL;\n\t\tread_lock(&mrt_lock);\n\t\tvif = &mrt->vif6_table[vr.mifi];\n\t\tif (MIF_EXISTS(mrt, vr.mifi)) {\n\t\t\tvr.icount = vif->pkt_in;\n\t\t\tvr.ocount = vif->pkt_out;\n\t\t\tvr.ibytes = vif->bytes_in;\n\t\t\tvr.obytes = vif->bytes_out;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &vr, sizeof(vr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tcase SIOCGETSGCNT_IN6:\n\t\tif (copy_from_user(&sr, arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\tread_lock(&mrt_lock);\n\t\tc = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);\n\t\tif (c) {\n\t\t\tsr.pktcnt = c->mfc_un.res.pkt;\n\t\t\tsr.bytecnt = c->mfc_un.res.bytes;\n\t\t\tsr.wrong_if = c->mfc_un.res.wrong_if;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &sr, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\nstatic inline int ip6mr_forward2_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\tIPSTATS_MIB_OUTFORWDATAGRAMS);\n\t__IP6_ADD_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\tIPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn dst_output(net, sk, skb);\n}\n\n/*\n *\tProcessing handlers for ip6mr_forward\n */\n\nstatic int ip6mr_forward2(struct net *net, struct mr6_table *mrt,\n\t\t\t  struct sk_buff *skb, struct mfc6_cache *c, int vifi)\n{\n\tstruct ipv6hdr *ipv6h;\n\tstruct mif_device *vif = &mrt->vif6_table[vifi];\n\tstruct net_device *dev;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\n\tif (!vif->dev)\n\t\tgoto out_free;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (vif->flags & MIFF_REGISTER) {\n\t\tvif->pkt_out++;\n\t\tvif->bytes_out += skb->len;\n\t\tvif->dev->stats.tx_bytes += skb->len;\n\t\tvif->dev->stats.tx_packets++;\n\t\tip6mr_cache_report(mrt, skb, vifi, MRT6MSG_WHOLEPKT);\n\t\tgoto out_free;\n\t}\n#endif\n\n\tipv6h = ipv6_hdr(skb);\n\n\tfl6 = (struct flowi6) {\n\t\t.flowi6_oif = vif->link,\n\t\t.daddr = ipv6h->daddr,\n\t};\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (dst->error) {\n\t\tdst_release(dst);\n\t\tgoto out_free;\n\t}\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\n\t/*\n\t * RFC1584 teaches, that DVMRP/PIM router must deliver packets locally\n\t * not only before forwarding, but after forwarding on all output\n\t * interfaces. It is clear, if mrouter runs a multicasting\n\t * program, it should receive packets not depending to what interface\n\t * program is joined.\n\t * If we will not make it, the program will have to join on all\n\t * interfaces. On the other hand, multihoming host (or router, but\n\t * not mrouter) cannot join to more than one interface - it will\n\t * result in receiving multiple packets.\n\t */\n\tdev = vif->dev;\n\tskb->dev = dev;\n\tvif->pkt_out++;\n\tvif->bytes_out += skb->len;\n\n\t/* We are about to write */\n\t/* XXX: extension headers? */\n\tif (skb_cow(skb, sizeof(*ipv6h) + LL_RESERVED_SPACE(dev)))\n\t\tgoto out_free;\n\n\tipv6h = ipv6_hdr(skb);\n\tipv6h->hop_limit--;\n\n\tIP6CB(skb)->flags |= IP6SKB_FORWARDED;\n\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD,\n\t\t       net, NULL, skb, skb->dev, dev,\n\t\t       ip6mr_forward2_finish);\n\nout_free:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ip6mr_find_vif(struct mr6_table *mrt, struct net_device *dev)\n{\n\tint ct;\n\n\tfor (ct = mrt->maxvif - 1; ct >= 0; ct--) {\n\t\tif (mrt->vif6_table[ct].dev == dev)\n\t\t\tbreak;\n\t}\n\treturn ct;\n}\n\nstatic void ip6_mr_forward(struct net *net, struct mr6_table *mrt,\n\t\t\t   struct sk_buff *skb, struct mfc6_cache *cache)\n{\n\tint psend = -1;\n\tint vif, ct;\n\tint true_vifi = ip6mr_find_vif(mrt, skb->dev);\n\n\tvif = cache->mf6c_parent;\n\tcache->mfc_un.res.pkt++;\n\tcache->mfc_un.res.bytes += skb->len;\n\tcache->mfc_un.res.lastuse = jiffies;\n\n\tif (ipv6_addr_any(&cache->mf6c_origin) && true_vifi >= 0) {\n\t\tstruct mfc6_cache *cache_proxy;\n\n\t\t/* For an (*,G) entry, we only check that the incoming\n\t\t * interface is part of the static tree.\n\t\t */\n\t\tcache_proxy = ip6mr_cache_find_any_parent(mrt, vif);\n\t\tif (cache_proxy &&\n\t\t    cache_proxy->mfc_un.res.ttls[true_vifi] < 255)\n\t\t\tgoto forward;\n\t}\n\n\t/*\n\t * Wrong interface: drop packet and (maybe) send PIM assert.\n\t */\n\tif (mrt->vif6_table[vif].dev != skb->dev) {\n\t\tcache->mfc_un.res.wrong_if++;\n\n\t\tif (true_vifi >= 0 && mrt->mroute_do_assert &&\n\t\t    /* pimsm uses asserts, when switching from RPT to SPT,\n\t\t       so that we cannot check that packet arrived on an oif.\n\t\t       It is bad, but otherwise we would need to move pretty\n\t\t       large chunk of pimd to kernel. Ough... --ANK\n\t\t     */\n\t\t    (mrt->mroute_do_pim ||\n\t\t     cache->mfc_un.res.ttls[true_vifi] < 255) &&\n\t\t    time_after(jiffies,\n\t\t\t       cache->mfc_un.res.last_assert + MFC_ASSERT_THRESH)) {\n\t\t\tcache->mfc_un.res.last_assert = jiffies;\n\t\t\tip6mr_cache_report(mrt, skb, true_vifi, MRT6MSG_WRONGMIF);\n\t\t}\n\t\tgoto dont_forward;\n\t}\n\nforward:\n\tmrt->vif6_table[vif].pkt_in++;\n\tmrt->vif6_table[vif].bytes_in += skb->len;\n\n\t/*\n\t *\tForward the frame\n\t */\n\tif (ipv6_addr_any(&cache->mf6c_origin) &&\n\t    ipv6_addr_any(&cache->mf6c_mcastgrp)) {\n\t\tif (true_vifi >= 0 &&\n\t\t    true_vifi != cache->mf6c_parent &&\n\t\t    ipv6_hdr(skb)->hop_limit >\n\t\t\t\tcache->mfc_un.res.ttls[cache->mf6c_parent]) {\n\t\t\t/* It's an (*,*) entry and the packet is not coming from\n\t\t\t * the upstream: forward the packet to the upstream\n\t\t\t * only.\n\t\t\t */\n\t\t\tpsend = cache->mf6c_parent;\n\t\t\tgoto last_forward;\n\t\t}\n\t\tgoto dont_forward;\n\t}\n\tfor (ct = cache->mfc_un.res.maxvif - 1; ct >= cache->mfc_un.res.minvif; ct--) {\n\t\t/* For (*,G) entry, don't forward to the incoming interface */\n\t\tif ((!ipv6_addr_any(&cache->mf6c_origin) || ct != true_vifi) &&\n\t\t    ipv6_hdr(skb)->hop_limit > cache->mfc_un.res.ttls[ct]) {\n\t\t\tif (psend != -1) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\tip6mr_forward2(net, mrt, skb2, cache, psend);\n\t\t\t}\n\t\t\tpsend = ct;\n\t\t}\n\t}\nlast_forward:\n\tif (psend != -1) {\n\t\tip6mr_forward2(net, mrt, skb, cache, psend);\n\t\treturn;\n\t}\n\ndont_forward:\n\tkfree_skb(skb);\n}\n\n\n/*\n *\tMulticast packets for forwarding arrive here\n */\n\nint ip6_mr_input(struct sk_buff *skb)\n{\n\tstruct mfc6_cache *cache;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint err;\n\n\terr = ip6mr_fib_lookup(net, &fl6, &mrt);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tread_lock(&mrt_lock);\n\tcache = ip6mr_cache_find(mrt,\n\t\t\t\t &ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr);\n\tif (!cache) {\n\t\tint vif = ip6mr_find_vif(mrt, skb->dev);\n\n\t\tif (vif >= 0)\n\t\t\tcache = ip6mr_cache_find_any(mrt,\n\t\t\t\t\t\t     &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t     vif);\n\t}\n\n\t/*\n\t *\tNo usable cache entry\n\t */\n\tif (!cache) {\n\t\tint vif;\n\n\t\tvif = ip6mr_find_vif(mrt, skb->dev);\n\t\tif (vif >= 0) {\n\t\t\tint err = ip6mr_cache_unresolved(mrt, vif, skb);\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\treturn err;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tip6_mr_forward(net, mrt, skb, cache);\n\n\tread_unlock(&mrt_lock);\n\n\treturn 0;\n}\n\n\nstatic int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\n\t\t\t       struct mfc6_cache *c, struct rtmsg *rtm)\n{\n\tstruct rta_mfc_stats mfcs;\n\tstruct nlattr *mp_attr;\n\tstruct rtnexthop *nhp;\n\tunsigned long lastuse;\n\tint ct;\n\n\t/* If cache is unresolved, don't try to parse IIF and OIF */\n\tif (c->mf6c_parent >= MAXMIFS) {\n\t\trtm->rtm_flags |= RTNH_F_UNRESOLVED;\n\t\treturn -ENOENT;\n\t}\n\n\tif (MIF_EXISTS(mrt, c->mf6c_parent) &&\n\t    nla_put_u32(skb, RTA_IIF, mrt->vif6_table[c->mf6c_parent].dev->ifindex) < 0)\n\t\treturn -EMSGSIZE;\n\tmp_attr = nla_nest_start(skb, RTA_MULTIPATH);\n\tif (!mp_attr)\n\t\treturn -EMSGSIZE;\n\n\tfor (ct = c->mfc_un.res.minvif; ct < c->mfc_un.res.maxvif; ct++) {\n\t\tif (MIF_EXISTS(mrt, ct) && c->mfc_un.res.ttls[ct] < 255) {\n\t\t\tnhp = nla_reserve_nohdr(skb, sizeof(*nhp));\n\t\t\tif (!nhp) {\n\t\t\t\tnla_nest_cancel(skb, mp_attr);\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\n\t\t\tnhp->rtnh_flags = 0;\n\t\t\tnhp->rtnh_hops = c->mfc_un.res.ttls[ct];\n\t\t\tnhp->rtnh_ifindex = mrt->vif6_table[ct].dev->ifindex;\n\t\t\tnhp->rtnh_len = sizeof(*nhp);\n\t\t}\n\t}\n\n\tnla_nest_end(skb, mp_attr);\n\n\tlastuse = READ_ONCE(c->mfc_un.res.lastuse);\n\tlastuse = time_after_eq(jiffies, lastuse) ? jiffies - lastuse : 0;\n\n\tmfcs.mfcs_packets = c->mfc_un.res.pkt;\n\tmfcs.mfcs_bytes = c->mfc_un.res.bytes;\n\tmfcs.mfcs_wrong_if = c->mfc_un.res.wrong_if;\n\tif (nla_put_64bit(skb, RTA_MFC_STATS, sizeof(mfcs), &mfcs, RTA_PAD) ||\n\t    nla_put_u64_64bit(skb, RTA_EXPIRES, jiffies_to_clock_t(lastuse),\n\t\t\t      RTA_PAD))\n\t\treturn -EMSGSIZE;\n\n\trtm->rtm_type = RTN_MULTICAST;\n\treturn 1;\n}\n\nint ip6mr_get_route(struct net *net, struct sk_buff *skb, struct rtmsg *rtm,\n\t\t    u32 portid)\n{\n\tint err;\n\tstruct mr6_table *mrt;\n\tstruct mfc6_cache *cache;\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tread_lock(&mrt_lock);\n\tcache = ip6mr_cache_find(mrt, &rt->rt6i_src.addr, &rt->rt6i_dst.addr);\n\tif (!cache && skb->dev) {\n\t\tint vif = ip6mr_find_vif(mrt, skb->dev);\n\n\t\tif (vif >= 0)\n\t\t\tcache = ip6mr_cache_find_any(mrt, &rt->rt6i_dst.addr,\n\t\t\t\t\t\t     vif);\n\t}\n\n\tif (!cache) {\n\t\tstruct sk_buff *skb2;\n\t\tstruct ipv6hdr *iph;\n\t\tstruct net_device *dev;\n\t\tint vif;\n\n\t\tdev = skb->dev;\n\t\tif (!dev || (vif = ip6mr_find_vif(mrt, dev)) < 0) {\n\t\t\tread_unlock(&mrt_lock);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* really correct? */\n\t\tskb2 = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\t\tif (!skb2) {\n\t\t\tread_unlock(&mrt_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tNETLINK_CB(skb2).portid = portid;\n\t\tskb_reset_transport_header(skb2);\n\n\t\tskb_put(skb2, sizeof(struct ipv6hdr));\n\t\tskb_reset_network_header(skb2);\n\n\t\tiph = ipv6_hdr(skb2);\n\t\tiph->version = 0;\n\t\tiph->priority = 0;\n\t\tiph->flow_lbl[0] = 0;\n\t\tiph->flow_lbl[1] = 0;\n\t\tiph->flow_lbl[2] = 0;\n\t\tiph->payload_len = 0;\n\t\tiph->nexthdr = IPPROTO_NONE;\n\t\tiph->hop_limit = 0;\n\t\tiph->saddr = rt->rt6i_src.addr;\n\t\tiph->daddr = rt->rt6i_dst.addr;\n\n\t\terr = ip6mr_cache_unresolved(mrt, vif, skb2);\n\t\tread_unlock(&mrt_lock);\n\n\t\treturn err;\n\t}\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\tcache->mfc_flags |= MFC_NOTIFY;\n\n\terr = __ip6mr_fill_mroute(mrt, skb, cache, rtm);\n\tread_unlock(&mrt_lock);\n\treturn err;\n}\n\nstatic int ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\n\t\t\t     u32 portid, u32 seq, struct mfc6_cache *c, int cmd,\n\t\t\t     int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\tint err;\n\n\tnlh = nlmsg_put(skb, portid, seq, cmd, sizeof(*rtm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family   = RTNL_FAMILY_IP6MR;\n\trtm->rtm_dst_len  = 128;\n\trtm->rtm_src_len  = 128;\n\trtm->rtm_tos      = 0;\n\trtm->rtm_table    = mrt->id;\n\tif (nla_put_u32(skb, RTA_TABLE, mrt->id))\n\t\tgoto nla_put_failure;\n\trtm->rtm_type = RTN_MULTICAST;\n\trtm->rtm_scope    = RT_SCOPE_UNIVERSE;\n\tif (c->mfc_flags & MFC_STATIC)\n\t\trtm->rtm_protocol = RTPROT_STATIC;\n\telse\n\t\trtm->rtm_protocol = RTPROT_MROUTED;\n\trtm->rtm_flags    = 0;\n\n\tif (nla_put_in6_addr(skb, RTA_SRC, &c->mf6c_origin) ||\n\t    nla_put_in6_addr(skb, RTA_DST, &c->mf6c_mcastgrp))\n\t\tgoto nla_put_failure;\n\terr = __ip6mr_fill_mroute(mrt, skb, c, rtm);\n\t/* do not break the dump if cache is unresolved */\n\tif (err < 0 && err != -ENOENT)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mr6_msgsize(bool unresolved, int maxvif)\n{\n\tsize_t len =\n\t\tNLMSG_ALIGN(sizeof(struct rtmsg))\n\t\t+ nla_total_size(4)\t/* RTA_TABLE */\n\t\t+ nla_total_size(sizeof(struct in6_addr))\t/* RTA_SRC */\n\t\t+ nla_total_size(sizeof(struct in6_addr))\t/* RTA_DST */\n\t\t;\n\n\tif (!unresolved)\n\t\tlen = len\n\t\t      + nla_total_size(4)\t/* RTA_IIF */\n\t\t      + nla_total_size(0)\t/* RTA_MULTIPATH */\n\t\t      + maxvif * NLA_ALIGN(sizeof(struct rtnexthop))\n\t\t\t\t\t\t/* RTA_MFC_STATS */\n\t\t      + nla_total_size_64bit(sizeof(struct rta_mfc_stats))\n\t\t;\n\n\treturn len;\n}\n\nstatic void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,\n\t\t\t      int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mr6_msgsize(mfc->mf6c_parent >= MAXMIFS, mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = ip6mr_fill_mroute(mrt, skb, 0, 0, mfc, cmd, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_MROUTE, err);\n}\n\nstatic int ip6mr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct mr6_table *mrt;\n\tstruct mfc6_cache *mfc;\n\tunsigned int t = 0, s_t;\n\tunsigned int h = 0, s_h;\n\tunsigned int e = 0, s_e;\n\n\ts_t = cb->args[0];\n\ts_h = cb->args[1];\n\ts_e = cb->args[2];\n\n\tread_lock(&mrt_lock);\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (t < s_t)\n\t\t\tgoto next_table;\n\t\tif (t > s_t)\n\t\t\ts_h = 0;\n\t\tfor (h = s_h; h < MFC6_LINES; h++) {\n\t\t\tlist_for_each_entry(mfc, &mrt->mfc6_cache_array[h], list) {\n\t\t\t\tif (e < s_e)\n\t\t\t\t\tgoto next_entry;\n\t\t\t\tif (ip6mr_fill_mroute(mrt, skb,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t      mfc, RTM_NEWROUTE,\n\t\t\t\t\t\t      NLM_F_MULTI) < 0)\n\t\t\t\t\tgoto done;\nnext_entry:\n\t\t\t\te++;\n\t\t\t}\n\t\t\te = s_e = 0;\n\t\t}\n\t\tspin_lock_bh(&mfc_unres_lock);\n\t\tlist_for_each_entry(mfc, &mrt->mfc6_unres_queue, list) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next_entry2;\n\t\t\tif (ip6mr_fill_mroute(mrt, skb,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      mfc, RTM_NEWROUTE,\n\t\t\t\t\t      NLM_F_MULTI) < 0) {\n\t\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\t\t\t\tgoto done;\n\t\t\t}\nnext_entry2:\n\t\t\te++;\n\t\t}\n\t\tspin_unlock_bh(&mfc_unres_lock);\n\t\te = s_e = 0;\n\t\ts_h = 0;\nnext_table:\n\t\tt++;\n\t}\ndone:\n\tread_unlock(&mrt_lock);\n\n\tcb->args[2] = e;\n\tcb->args[1] = h;\n\tcb->args[0] = t;\n\n\treturn skb->len;\n}\n"], "fixing_code": ["/*\n *\tLinux IPv6 multicast routing support for BSD pim6sd\n *\tBased on net/ipv4/ipmr.c.\n *\n *\t(c) 2004 Mickael Hoerdt, <hoerdt@clarinet.u-strasbg.fr>\n *\t\tLSIIT Laboratory, Strasbourg, France\n *\t(c) 2004 Jean-Philippe Andriot, <jean-philippe.andriot@6WIND.com>\n *\t\t6WIND, Paris, France\n *\tCopyright (C)2007,2008 USAGI/WIDE Project\n *\t\tYOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/raw.h>\n#include <linux/notifier.h>\n#include <linux/if_arp.h>\n#include <net/checksum.h>\n#include <net/netlink.h>\n#include <net/fib_rules.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <linux/mroute6.h>\n#include <linux/pim.h>\n#include <net/addrconf.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/export.h>\n#include <net/ip6_checksum.h>\n#include <linux/netconf.h>\n\nstruct mr6_table {\n\tstruct list_head\tlist;\n\tpossible_net_t\t\tnet;\n\tu32\t\t\tid;\n\tstruct sock\t\t*mroute6_sk;\n\tstruct timer_list\tipmr_expire_timer;\n\tstruct list_head\tmfc6_unres_queue;\n\tstruct list_head\tmfc6_cache_array[MFC6_LINES];\n\tstruct mif_device\tvif6_table[MAXMIFS];\n\tint\t\t\tmaxvif;\n\tatomic_t\t\tcache_resolve_queue_len;\n\tbool\t\t\tmroute_do_assert;\n\tbool\t\t\tmroute_do_pim;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tint\t\t\tmroute_reg_vif_num;\n#endif\n};\n\nstruct ip6mr_rule {\n\tstruct fib_rule\t\tcommon;\n};\n\nstruct ip6mr_result {\n\tstruct mr6_table\t*mrt;\n};\n\n/* Big lock, protecting vif table, mrt cache and mroute socket state.\n   Note that the changes are semaphored via rtnl_lock.\n */\n\nstatic DEFINE_RWLOCK(mrt_lock);\n\n/*\n *\tMulticast router control variables\n */\n\n#define MIF_EXISTS(_mrt, _idx) ((_mrt)->vif6_table[_idx].dev != NULL)\n\n/* Special spinlock for queue of unresolved entries */\nstatic DEFINE_SPINLOCK(mfc_unres_lock);\n\n/* We return to original Alan's scheme. Hash table of resolved\n   entries is changed only in process context and protected\n   with weak lock mrt_lock. Queue of unresolved entries is protected\n   with strong spinlock mfc_unres_lock.\n\n   In this case data path is free of exclusive locks at all.\n */\n\nstatic struct kmem_cache *mrt_cachep __read_mostly;\n\nstatic struct mr6_table *ip6mr_new_table(struct net *net, u32 id);\nstatic void ip6mr_free_table(struct mr6_table *mrt);\n\nstatic void ip6_mr_forward(struct net *net, struct mr6_table *mrt,\n\t\t\t   struct sk_buff *skb, struct mfc6_cache *cache);\nstatic int ip6mr_cache_report(struct mr6_table *mrt, struct sk_buff *pkt,\n\t\t\t      mifi_t mifi, int assert);\nstatic int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\n\t\t\t       struct mfc6_cache *c, struct rtmsg *rtm);\nstatic void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,\n\t\t\t      int cmd);\nstatic int ip6mr_rtm_dumproute(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb);\nstatic void mroute_clean_tables(struct mr6_table *mrt, bool all);\nstatic void ipmr_expire_process(unsigned long arg);\n\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n#define ip6mr_for_each_table(mrt, net) \\\n\tlist_for_each_entry_rcu(mrt, &net->ipv6.mr6_tables, list)\n\nstatic struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\tstruct mr6_table *mrt;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (mrt->id == id)\n\t\t\treturn mrt;\n\t}\n\treturn NULL;\n}\n\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr6_table **mrt)\n{\n\tint err;\n\tstruct ip6mr_result res;\n\tstruct fib_lookup_arg arg = {\n\t\t.result = &res,\n\t\t.flags = FIB_LOOKUP_NOREF,\n\t};\n\n\terr = fib_rules_lookup(net->ipv6.mr6_rules_ops,\n\t\t\t       flowi6_to_flowi(flp6), 0, &arg);\n\tif (err < 0)\n\t\treturn err;\n\t*mrt = res.mrt;\n\treturn 0;\n}\n\nstatic int ip6mr_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t     int flags, struct fib_lookup_arg *arg)\n{\n\tstruct ip6mr_result *res = arg->result;\n\tstruct mr6_table *mrt;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\treturn -ENETUNREACH;\n\tcase FR_ACT_PROHIBIT:\n\t\treturn -EACCES;\n\tcase FR_ACT_BLACKHOLE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmrt = ip6mr_get_table(rule->fr_net, rule->table);\n\tif (!mrt)\n\t\treturn -EAGAIN;\n\tres->mrt = mrt;\n\treturn 0;\n}\n\nstatic int ip6mr_rule_match(struct fib_rule *rule, struct flowi *flp, int flags)\n{\n\treturn 1;\n}\n\nstatic const struct nla_policy ip6mr_rule_policy[FRA_MAX + 1] = {\n\tFRA_GENERIC_POLICY,\n};\n\nstatic int ip6mr_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t\tstruct fib_rule_hdr *frh, struct nlattr **tb)\n{\n\treturn 0;\n}\n\nstatic int ip6mr_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t      struct nlattr **tb)\n{\n\treturn 1;\n}\n\nstatic int ip6mr_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t   struct fib_rule_hdr *frh)\n{\n\tfrh->dst_len = 0;\n\tfrh->src_len = 0;\n\tfrh->tos     = 0;\n\treturn 0;\n}\n\nstatic const struct fib_rules_ops __net_initconst ip6mr_rules_ops_template = {\n\t.family\t\t= RTNL_FAMILY_IP6MR,\n\t.rule_size\t= sizeof(struct ip6mr_rule),\n\t.addr_size\t= sizeof(struct in6_addr),\n\t.action\t\t= ip6mr_rule_action,\n\t.match\t\t= ip6mr_rule_match,\n\t.configure\t= ip6mr_rule_configure,\n\t.compare\t= ip6mr_rule_compare,\n\t.fill\t\t= ip6mr_rule_fill,\n\t.nlgroup\t= RTNLGRP_IPV6_RULE,\n\t.policy\t\t= ip6mr_rule_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __net_init ip6mr_rules_init(struct net *net)\n{\n\tstruct fib_rules_ops *ops;\n\tstruct mr6_table *mrt;\n\tint err;\n\n\tops = fib_rules_register(&ip6mr_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tINIT_LIST_HEAD(&net->ipv6.mr6_tables);\n\n\tmrt = ip6mr_new_table(net, RT6_TABLE_DFLT);\n\tif (!mrt) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\terr = fib_default_rule_add(ops, 0x7fff, RT6_TABLE_DFLT, 0);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tnet->ipv6.mr6_rules_ops = ops;\n\treturn 0;\n\nerr2:\n\tip6mr_free_table(mrt);\nerr1:\n\tfib_rules_unregister(ops);\n\treturn err;\n}\n\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\n{\n\tstruct mr6_table *mrt, *next;\n\n\trtnl_lock();\n\tlist_for_each_entry_safe(mrt, next, &net->ipv6.mr6_tables, list) {\n\t\tlist_del(&mrt->list);\n\t\tip6mr_free_table(mrt);\n\t}\n\tfib_rules_unregister(net->ipv6.mr6_rules_ops);\n\trtnl_unlock();\n}\n#else\n#define ip6mr_for_each_table(mrt, net) \\\n\tfor (mrt = net->ipv6.mrt6; mrt; mrt = NULL)\n\nstatic struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\treturn net->ipv6.mrt6;\n}\n\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr6_table **mrt)\n{\n\t*mrt = net->ipv6.mrt6;\n\treturn 0;\n}\n\nstatic int __net_init ip6mr_rules_init(struct net *net)\n{\n\tnet->ipv6.mrt6 = ip6mr_new_table(net, RT6_TABLE_DFLT);\n\treturn net->ipv6.mrt6 ? 0 : -ENOMEM;\n}\n\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\n{\n\trtnl_lock();\n\tip6mr_free_table(net->ipv6.mrt6);\n\tnet->ipv6.mrt6 = NULL;\n\trtnl_unlock();\n}\n#endif\n\nstatic struct mr6_table *ip6mr_new_table(struct net *net, u32 id)\n{\n\tstruct mr6_table *mrt;\n\tunsigned int i;\n\n\tmrt = ip6mr_get_table(net, id);\n\tif (mrt)\n\t\treturn mrt;\n\n\tmrt = kzalloc(sizeof(*mrt), GFP_KERNEL);\n\tif (!mrt)\n\t\treturn NULL;\n\tmrt->id = id;\n\twrite_pnet(&mrt->net, net);\n\n\t/* Forwarding cache */\n\tfor (i = 0; i < MFC6_LINES; i++)\n\t\tINIT_LIST_HEAD(&mrt->mfc6_cache_array[i]);\n\n\tINIT_LIST_HEAD(&mrt->mfc6_unres_queue);\n\n\tsetup_timer(&mrt->ipmr_expire_timer, ipmr_expire_process,\n\t\t    (unsigned long)mrt);\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tmrt->mroute_reg_vif_num = -1;\n#endif\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n\tlist_add_tail_rcu(&mrt->list, &net->ipv6.mr6_tables);\n#endif\n\treturn mrt;\n}\n\nstatic void ip6mr_free_table(struct mr6_table *mrt)\n{\n\tdel_timer_sync(&mrt->ipmr_expire_timer);\n\tmroute_clean_tables(mrt, true);\n\tkfree(mrt);\n}\n\n#ifdef CONFIG_PROC_FS\n\nstruct ipmr_mfc_iter {\n\tstruct seq_net_private p;\n\tstruct mr6_table *mrt;\n\tstruct list_head *cache;\n\tint ct;\n};\n\n\nstatic struct mfc6_cache *ipmr_mfc_seq_idx(struct net *net,\n\t\t\t\t\t   struct ipmr_mfc_iter *it, loff_t pos)\n{\n\tstruct mr6_table *mrt = it->mrt;\n\tstruct mfc6_cache *mfc;\n\n\tread_lock(&mrt_lock);\n\tfor (it->ct = 0; it->ct < MFC6_LINES; it->ct++) {\n\t\tit->cache = &mrt->mfc6_cache_array[it->ct];\n\t\tlist_for_each_entry(mfc, it->cache, list)\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn mfc;\n\t}\n\tread_unlock(&mrt_lock);\n\n\tspin_lock_bh(&mfc_unres_lock);\n\tit->cache = &mrt->mfc6_unres_queue;\n\tlist_for_each_entry(mfc, it->cache, list)\n\t\tif (pos-- == 0)\n\t\t\treturn mfc;\n\tspin_unlock_bh(&mfc_unres_lock);\n\n\tit->cache = NULL;\n\treturn NULL;\n}\n\n/*\n *\tThe /proc interfaces to multicast routing /proc/ip6_mr_cache /proc/ip6_mr_vif\n */\n\nstruct ipmr_vif_iter {\n\tstruct seq_net_private p;\n\tstruct mr6_table *mrt;\n\tint ct;\n};\n\nstatic struct mif_device *ip6mr_vif_seq_idx(struct net *net,\n\t\t\t\t\t    struct ipmr_vif_iter *iter,\n\t\t\t\t\t    loff_t pos)\n{\n\tstruct mr6_table *mrt = iter->mrt;\n\n\tfor (iter->ct = 0; iter->ct < mrt->maxvif; ++iter->ct) {\n\t\tif (!MIF_EXISTS(mrt, iter->ct))\n\t\t\tcontinue;\n\t\tif (pos-- == 0)\n\t\t\treturn &mrt->vif6_table[iter->ct];\n\t}\n\treturn NULL;\n}\n\nstatic void *ip6mr_vif_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(mrt_lock)\n{\n\tstruct ipmr_vif_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn ERR_PTR(-ENOENT);\n\n\titer->mrt = mrt;\n\n\tread_lock(&mrt_lock);\n\treturn *pos ? ip6mr_vif_seq_idx(net, seq->private, *pos - 1)\n\t\t: SEQ_START_TOKEN;\n}\n\nstatic void *ip6mr_vif_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ipmr_vif_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt = iter->mrt;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ip6mr_vif_seq_idx(net, iter, 0);\n\n\twhile (++iter->ct < mrt->maxvif) {\n\t\tif (!MIF_EXISTS(mrt, iter->ct))\n\t\t\tcontinue;\n\t\treturn &mrt->vif6_table[iter->ct];\n\t}\n\treturn NULL;\n}\n\nstatic void ip6mr_vif_seq_stop(struct seq_file *seq, void *v)\n\t__releases(mrt_lock)\n{\n\tread_unlock(&mrt_lock);\n}\n\nstatic int ip6mr_vif_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ipmr_vif_iter *iter = seq->private;\n\tstruct mr6_table *mrt = iter->mrt;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Interface      BytesIn  PktsIn  BytesOut PktsOut Flags\\n\");\n\t} else {\n\t\tconst struct mif_device *vif = v;\n\t\tconst char *name = vif->dev ? vif->dev->name : \"none\";\n\n\t\tseq_printf(seq,\n\t\t\t   \"%2td %-10s %8ld %7ld  %8ld %7ld %05X\\n\",\n\t\t\t   vif - mrt->vif6_table,\n\t\t\t   name, vif->bytes_in, vif->pkt_in,\n\t\t\t   vif->bytes_out, vif->pkt_out,\n\t\t\t   vif->flags);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip6mr_vif_seq_ops = {\n\t.start = ip6mr_vif_seq_start,\n\t.next  = ip6mr_vif_seq_next,\n\t.stop  = ip6mr_vif_seq_stop,\n\t.show  = ip6mr_vif_seq_show,\n};\n\nstatic int ip6mr_vif_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &ip6mr_vif_seq_ops,\n\t\t\t    sizeof(struct ipmr_vif_iter));\n}\n\nstatic const struct file_operations ip6mr_vif_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open    = ip6mr_vif_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net,\n};\n\nstatic void *ipmr_mfc_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct ipmr_mfc_iter *it = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tit->mrt = mrt;\n\treturn *pos ? ipmr_mfc_seq_idx(net, seq->private, *pos - 1)\n\t\t: SEQ_START_TOKEN;\n}\n\nstatic void *ipmr_mfc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct mfc6_cache *mfc = v;\n\tstruct ipmr_mfc_iter *it = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr6_table *mrt = it->mrt;\n\n\t++*pos;\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn ipmr_mfc_seq_idx(net, seq->private, 0);\n\n\tif (mfc->list.next != it->cache)\n\t\treturn list_entry(mfc->list.next, struct mfc6_cache, list);\n\n\tif (it->cache == &mrt->mfc6_unres_queue)\n\t\tgoto end_of_list;\n\n\tBUG_ON(it->cache != &mrt->mfc6_cache_array[it->ct]);\n\n\twhile (++it->ct < MFC6_LINES) {\n\t\tit->cache = &mrt->mfc6_cache_array[it->ct];\n\t\tif (list_empty(it->cache))\n\t\t\tcontinue;\n\t\treturn list_first_entry(it->cache, struct mfc6_cache, list);\n\t}\n\n\t/* exhausted cache_array, show unresolved */\n\tread_unlock(&mrt_lock);\n\tit->cache = &mrt->mfc6_unres_queue;\n\tit->ct = 0;\n\n\tspin_lock_bh(&mfc_unres_lock);\n\tif (!list_empty(it->cache))\n\t\treturn list_first_entry(it->cache, struct mfc6_cache, list);\n\n end_of_list:\n\tspin_unlock_bh(&mfc_unres_lock);\n\tit->cache = NULL;\n\n\treturn NULL;\n}\n\nstatic void ipmr_mfc_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct ipmr_mfc_iter *it = seq->private;\n\tstruct mr6_table *mrt = it->mrt;\n\n\tif (it->cache == &mrt->mfc6_unres_queue)\n\t\tspin_unlock_bh(&mfc_unres_lock);\n\telse if (it->cache == &mrt->mfc6_cache_array[it->ct])\n\t\tread_unlock(&mrt_lock);\n}\n\nstatic int ipmr_mfc_seq_show(struct seq_file *seq, void *v)\n{\n\tint n;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Group                            \"\n\t\t\t \"Origin                           \"\n\t\t\t \"Iif      Pkts  Bytes     Wrong  Oifs\\n\");\n\t} else {\n\t\tconst struct mfc6_cache *mfc = v;\n\t\tconst struct ipmr_mfc_iter *it = seq->private;\n\t\tstruct mr6_table *mrt = it->mrt;\n\n\t\tseq_printf(seq, \"%pI6 %pI6 %-3hd\",\n\t\t\t   &mfc->mf6c_mcastgrp, &mfc->mf6c_origin,\n\t\t\t   mfc->mf6c_parent);\n\n\t\tif (it->cache != &mrt->mfc6_unres_queue) {\n\t\t\tseq_printf(seq, \" %8lu %8lu %8lu\",\n\t\t\t\t   mfc->mfc_un.res.pkt,\n\t\t\t\t   mfc->mfc_un.res.bytes,\n\t\t\t\t   mfc->mfc_un.res.wrong_if);\n\t\t\tfor (n = mfc->mfc_un.res.minvif;\n\t\t\t     n < mfc->mfc_un.res.maxvif; n++) {\n\t\t\t\tif (MIF_EXISTS(mrt, n) &&\n\t\t\t\t    mfc->mfc_un.res.ttls[n] < 255)\n\t\t\t\t\tseq_printf(seq,\n\t\t\t\t\t\t   \" %2d:%-3d\",\n\t\t\t\t\t\t   n, mfc->mfc_un.res.ttls[n]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* unresolved mfc_caches don't contain\n\t\t\t * pkt, bytes and wrong_if values\n\t\t\t */\n\t\t\tseq_printf(seq, \" %8lu %8lu %8lu\", 0ul, 0ul, 0ul);\n\t\t}\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ipmr_mfc_seq_ops = {\n\t.start = ipmr_mfc_seq_start,\n\t.next  = ipmr_mfc_seq_next,\n\t.stop  = ipmr_mfc_seq_stop,\n\t.show  = ipmr_mfc_seq_show,\n};\n\nstatic int ipmr_mfc_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &ipmr_mfc_seq_ops,\n\t\t\t    sizeof(struct ipmr_mfc_iter));\n}\n\nstatic const struct file_operations ip6mr_mfc_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open    = ipmr_mfc_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net,\n};\n#endif\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\nstatic int pim6_rcv(struct sk_buff *skb)\n{\n\tstruct pimreghdr *pim;\n\tstruct ipv6hdr   *encap;\n\tstruct net_device  *reg_dev = NULL;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint reg_vif_num;\n\n\tif (!pskb_may_pull(skb, sizeof(*pim) + sizeof(*encap)))\n\t\tgoto drop;\n\n\tpim = (struct pimreghdr *)skb_transport_header(skb);\n\tif (pim->type != ((PIM_VERSION << 4) | PIM_TYPE_REGISTER) ||\n\t    (pim->flags & PIM_NULL_REGISTER) ||\n\t    (csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\n\t\t\t     sizeof(*pim), IPPROTO_PIM,\n\t\t\t     csum_partial((void *)pim, sizeof(*pim), 0)) &&\n\t     csum_fold(skb_checksum(skb, 0, skb->len, 0))))\n\t\tgoto drop;\n\n\t/* check if the inner packet is destined to mcast group */\n\tencap = (struct ipv6hdr *)(skb_transport_header(skb) +\n\t\t\t\t   sizeof(*pim));\n\n\tif (!ipv6_addr_is_multicast(&encap->daddr) ||\n\t    encap->payload_len == 0 ||\n\t    ntohs(encap->payload_len) + sizeof(*pim) > skb->len)\n\t\tgoto drop;\n\n\tif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\n\t\tgoto drop;\n\treg_vif_num = mrt->mroute_reg_vif_num;\n\n\tread_lock(&mrt_lock);\n\tif (reg_vif_num >= 0)\n\t\treg_dev = mrt->vif6_table[reg_vif_num].dev;\n\tif (reg_dev)\n\t\tdev_hold(reg_dev);\n\tread_unlock(&mrt_lock);\n\n\tif (!reg_dev)\n\t\tgoto drop;\n\n\tskb->mac_header = skb->network_header;\n\tskb_pull(skb, (u8 *)encap - skb->data);\n\tskb_reset_network_header(skb);\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));\n\n\tnetif_rx(skb);\n\n\tdev_put(reg_dev);\n\treturn 0;\n drop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic const struct inet6_protocol pim6_protocol = {\n\t.handler\t=\tpim6_rcv,\n};\n\n/* Service routines creating virtual interfaces: PIMREG */\n\nstatic netdev_tx_t reg_vif_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif\t= dev->ifindex,\n\t\t.flowi6_iif\t= skb->skb_iif ? : LOOPBACK_IFINDEX,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint err;\n\n\terr = ip6mr_fib_lookup(net, &fl6, &mrt);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tread_lock(&mrt_lock);\n\tdev->stats.tx_bytes += skb->len;\n\tdev->stats.tx_packets++;\n\tip6mr_cache_report(mrt, skb, mrt->mroute_reg_vif_num, MRT6MSG_WHOLEPKT);\n\tread_unlock(&mrt_lock);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int reg_vif_get_iflink(const struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct net_device_ops reg_vif_netdev_ops = {\n\t.ndo_start_xmit\t= reg_vif_xmit,\n\t.ndo_get_iflink = reg_vif_get_iflink,\n};\n\nstatic void reg_vif_setup(struct net_device *dev)\n{\n\tdev->type\t\t= ARPHRD_PIMREG;\n\tdev->mtu\t\t= 1500 - sizeof(struct ipv6hdr) - 8;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->netdev_ops\t\t= &reg_vif_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic struct net_device *ip6mr_reg_vif(struct net *net, struct mr6_table *mrt)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\n\tif (mrt->id == RT6_TABLE_DFLT)\n\t\tsprintf(name, \"pim6reg\");\n\telse\n\t\tsprintf(name, \"pim6reg%u\", mrt->id);\n\n\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, reg_vif_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (register_netdevice(dev)) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tif (dev_open(dev))\n\t\tgoto failure;\n\n\tdev_hold(dev);\n\treturn dev;\n\nfailure:\n\tunregister_netdevice(dev);\n\treturn NULL;\n}\n#endif\n\n/*\n *\tDelete a VIF entry\n */\n\nstatic int mif6_delete(struct mr6_table *mrt, int vifi, struct list_head *head)\n{\n\tstruct mif_device *v;\n\tstruct net_device *dev;\n\tstruct inet6_dev *in6_dev;\n\n\tif (vifi < 0 || vifi >= mrt->maxvif)\n\t\treturn -EADDRNOTAVAIL;\n\n\tv = &mrt->vif6_table[vifi];\n\n\twrite_lock_bh(&mrt_lock);\n\tdev = v->dev;\n\tv->dev = NULL;\n\n\tif (!dev) {\n\t\twrite_unlock_bh(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (vifi == mrt->mroute_reg_vif_num)\n\t\tmrt->mroute_reg_vif_num = -1;\n#endif\n\n\tif (vifi + 1 == mrt->maxvif) {\n\t\tint tmp;\n\t\tfor (tmp = vifi - 1; tmp >= 0; tmp--) {\n\t\t\tif (MIF_EXISTS(mrt, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tmrt->maxvif = tmp + 1;\n\t}\n\n\twrite_unlock_bh(&mrt_lock);\n\n\tdev_set_allmulti(dev, -1);\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (in6_dev) {\n\t\tin6_dev->cnf.mc_forwarding--;\n\t\tinet6_netconf_notify_devconf(dev_net(dev),\n\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     dev->ifindex, &in6_dev->cnf);\n\t}\n\n\tif (v->flags & MIFF_REGISTER)\n\t\tunregister_netdevice_queue(dev, head);\n\n\tdev_put(dev);\n\treturn 0;\n}\n\nstatic inline void ip6mr_cache_free(struct mfc6_cache *c)\n{\n\tkmem_cache_free(mrt_cachep, c);\n}\n\n/* Destroy an unresolved cache entry, killing queued skbs\n   and reporting error to netlink readers.\n */\n\nstatic void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&mrt->cache_resolve_queue_len);\n\n\twhile ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {\n\t\tif (ipv6_hdr(skb)->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;\n\t\t\trtnl_unicast(skb, net, NETLINK_CB(skb).portid);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tip6mr_cache_free(c);\n}\n\n\n/* Timer process for all the unresolved queue. */\n\nstatic void ipmr_do_expire_process(struct mr6_table *mrt)\n{\n\tunsigned long now = jiffies;\n\tunsigned long expires = 10 * HZ;\n\tstruct mfc6_cache *c, *next;\n\n\tlist_for_each_entry_safe(c, next, &mrt->mfc6_unres_queue, list) {\n\t\tif (time_after(c->mfc_un.unres.expires, now)) {\n\t\t\t/* not yet... */\n\t\t\tunsigned long interval = c->mfc_un.unres.expires - now;\n\t\t\tif (interval < expires)\n\t\t\t\texpires = interval;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&c->list);\n\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\tip6mr_destroy_unres(mrt, c);\n\t}\n\n\tif (!list_empty(&mrt->mfc6_unres_queue))\n\t\tmod_timer(&mrt->ipmr_expire_timer, jiffies + expires);\n}\n\nstatic void ipmr_expire_process(unsigned long arg)\n{\n\tstruct mr6_table *mrt = (struct mr6_table *)arg;\n\n\tif (!spin_trylock(&mfc_unres_lock)) {\n\t\tmod_timer(&mrt->ipmr_expire_timer, jiffies + 1);\n\t\treturn;\n\t}\n\n\tif (!list_empty(&mrt->mfc6_unres_queue))\n\t\tipmr_do_expire_process(mrt);\n\n\tspin_unlock(&mfc_unres_lock);\n}\n\n/* Fill oifs list. It is called under write locked mrt_lock. */\n\nstatic void ip6mr_update_thresholds(struct mr6_table *mrt, struct mfc6_cache *cache,\n\t\t\t\t    unsigned char *ttls)\n{\n\tint vifi;\n\n\tcache->mfc_un.res.minvif = MAXMIFS;\n\tcache->mfc_un.res.maxvif = 0;\n\tmemset(cache->mfc_un.res.ttls, 255, MAXMIFS);\n\n\tfor (vifi = 0; vifi < mrt->maxvif; vifi++) {\n\t\tif (MIF_EXISTS(mrt, vifi) &&\n\t\t    ttls[vifi] && ttls[vifi] < 255) {\n\t\t\tcache->mfc_un.res.ttls[vifi] = ttls[vifi];\n\t\t\tif (cache->mfc_un.res.minvif > vifi)\n\t\t\t\tcache->mfc_un.res.minvif = vifi;\n\t\t\tif (cache->mfc_un.res.maxvif <= vifi)\n\t\t\t\tcache->mfc_un.res.maxvif = vifi + 1;\n\t\t}\n\t}\n\tcache->mfc_un.res.lastuse = jiffies;\n}\n\nstatic int mif6_add(struct net *net, struct mr6_table *mrt,\n\t\t    struct mif6ctl *vifc, int mrtsock)\n{\n\tint vifi = vifc->mif6c_mifi;\n\tstruct mif_device *v = &mrt->vif6_table[vifi];\n\tstruct net_device *dev;\n\tstruct inet6_dev *in6_dev;\n\tint err;\n\n\t/* Is vif busy ? */\n\tif (MIF_EXISTS(mrt, vifi))\n\t\treturn -EADDRINUSE;\n\n\tswitch (vifc->mif6c_flags) {\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MIFF_REGISTER:\n\t\t/*\n\t\t * Special Purpose VIF in PIM\n\t\t * All the packets will be sent to the daemon\n\t\t */\n\t\tif (mrt->mroute_reg_vif_num >= 0)\n\t\t\treturn -EADDRINUSE;\n\t\tdev = ip6mr_reg_vif(net, mrt);\n\t\tif (!dev)\n\t\t\treturn -ENOBUFS;\n\t\terr = dev_set_allmulti(dev, 1);\n\t\tif (err) {\n\t\t\tunregister_netdevice(dev);\n\t\t\tdev_put(dev);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n#endif\n\tcase 0:\n\t\tdev = dev_get_by_index(net, vifc->mif6c_pifi);\n\t\tif (!dev)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\terr = dev_set_allmulti(dev, 1);\n\t\tif (err) {\n\t\t\tdev_put(dev);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (in6_dev) {\n\t\tin6_dev->cnf.mc_forwarding++;\n\t\tinet6_netconf_notify_devconf(dev_net(dev),\n\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     dev->ifindex, &in6_dev->cnf);\n\t}\n\n\t/*\n\t *\tFill in the VIF structures\n\t */\n\tv->rate_limit = vifc->vifc_rate_limit;\n\tv->flags = vifc->mif6c_flags;\n\tif (!mrtsock)\n\t\tv->flags |= VIFF_STATIC;\n\tv->threshold = vifc->vifc_threshold;\n\tv->bytes_in = 0;\n\tv->bytes_out = 0;\n\tv->pkt_in = 0;\n\tv->pkt_out = 0;\n\tv->link = dev->ifindex;\n\tif (v->flags & MIFF_REGISTER)\n\t\tv->link = dev_get_iflink(dev);\n\n\t/* And finish update writing critical data */\n\twrite_lock_bh(&mrt_lock);\n\tv->dev = dev;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (v->flags & MIFF_REGISTER)\n\t\tmrt->mroute_reg_vif_num = vifi;\n#endif\n\tif (vifi + 1 > mrt->maxvif)\n\t\tmrt->maxvif = vifi + 1;\n\twrite_unlock_bh(&mrt_lock);\n\treturn 0;\n}\n\nstatic struct mfc6_cache *ip6mr_cache_find(struct mr6_table *mrt,\n\t\t\t\t\t   const struct in6_addr *origin,\n\t\t\t\t\t   const struct in6_addr *mcastgrp)\n{\n\tint line = MFC6_HASH(mcastgrp, origin);\n\tstruct mfc6_cache *c;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_origin, origin) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp))\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\n/* Look for a (*,*,oif) entry */\nstatic struct mfc6_cache *ip6mr_cache_find_any_parent(struct mr6_table *mrt,\n\t\t\t\t\t\t      mifi_t mifi)\n{\n\tint line = MFC6_HASH(&in6addr_any, &in6addr_any);\n\tstruct mfc6_cache *c;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\n\t\tif (ipv6_addr_any(&c->mf6c_origin) &&\n\t\t    ipv6_addr_any(&c->mf6c_mcastgrp) &&\n\t\t    (c->mfc_un.res.ttls[mifi] < 255))\n\t\t\treturn c;\n\n\treturn NULL;\n}\n\n/* Look for a (*,G) entry */\nstatic struct mfc6_cache *ip6mr_cache_find_any(struct mr6_table *mrt,\n\t\t\t\t\t       struct in6_addr *mcastgrp,\n\t\t\t\t\t       mifi_t mifi)\n{\n\tint line = MFC6_HASH(mcastgrp, &in6addr_any);\n\tstruct mfc6_cache *c, *proxy;\n\n\tif (ipv6_addr_any(mcastgrp))\n\t\tgoto skip;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\n\t\tif (ipv6_addr_any(&c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp)) {\n\t\t\tif (c->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\n\t\t\t/* It's ok if the mifi is part of the static tree */\n\t\t\tproxy = ip6mr_cache_find_any_parent(mrt,\n\t\t\t\t\t\t\t    c->mf6c_parent);\n\t\t\tif (proxy && proxy->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\t\t}\n\nskip:\n\treturn ip6mr_cache_find_any_parent(mrt, mifi);\n}\n\n/*\n *\tAllocate a multicast cache entry\n */\nstatic struct mfc6_cache *ip6mr_cache_alloc(void)\n{\n\tstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);\n\tif (!c)\n\t\treturn NULL;\n\tc->mfc_un.res.last_assert = jiffies - MFC_ASSERT_THRESH - 1;\n\tc->mfc_un.res.minvif = MAXMIFS;\n\treturn c;\n}\n\nstatic struct mfc6_cache *ip6mr_cache_alloc_unres(void)\n{\n\tstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_ATOMIC);\n\tif (!c)\n\t\treturn NULL;\n\tskb_queue_head_init(&c->mfc_un.unres.unresolved);\n\tc->mfc_un.unres.expires = jiffies + 10 * HZ;\n\treturn c;\n}\n\n/*\n *\tA cache entry has gone into a resolved state from queued\n */\n\nstatic void ip6mr_cache_resolve(struct net *net, struct mr6_table *mrt,\n\t\t\t\tstruct mfc6_cache *uc, struct mfc6_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tPlay the pending entries through our router\n\t */\n\n\twhile ((skb = __skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (ipv6_hdr(skb)->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));\n\n\t\t\tif (__ip6mr_fill_mroute(mrt, skb, c, nlmsg_data(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb_tail_pointer(skb) - (u8 *)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr *)nlmsg_data(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\trtnl_unicast(skb, net, NETLINK_CB(skb).portid);\n\t\t} else\n\t\t\tip6_mr_forward(net, mrt, skb, c);\n\t}\n}\n\n/*\n *\tBounce a cache query up to pim6sd. We could use netlink for this but pim6sd\n *\texpects the following bizarre scheme.\n *\n *\tCalled under mrt_lock.\n */\n\nstatic int ip6mr_cache_report(struct mr6_table *mrt, struct sk_buff *pkt,\n\t\t\t      mifi_t mifi, int assert)\n{\n\tstruct sk_buff *skb;\n\tstruct mrt6msg *msg;\n\tint ret;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (assert == MRT6MSG_WHOLEPKT)\n\t\tskb = skb_realloc_headroom(pkt, -skb_network_offset(pkt)\n\t\t\t\t\t\t+sizeof(*msg));\n\telse\n#endif\n\t\tskb = alloc_skb(sizeof(struct ipv6hdr) + sizeof(*msg), GFP_ATOMIC);\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t/* I suppose that internal messages\n\t * do not require checksums */\n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (assert == MRT6MSG_WHOLEPKT) {\n\t\t/* Ugly, but we have no choice with this interface.\n\t\t   Duplicate old header, fix length etc.\n\t\t   And all this only to mangle msg->im6_msgtype and\n\t\t   to set msg->im6_mbz to \"mbz\" :-)\n\t\t */\n\t\tskb_push(skb, -skb_network_offset(pkt));\n\n\t\tskb_push(skb, sizeof(*msg));\n\t\tskb_reset_transport_header(skb);\n\t\tmsg = (struct mrt6msg *)skb_transport_header(skb);\n\t\tmsg->im6_mbz = 0;\n\t\tmsg->im6_msgtype = MRT6MSG_WHOLEPKT;\n\t\tmsg->im6_mif = mrt->mroute_reg_vif_num;\n\t\tmsg->im6_pad = 0;\n\t\tmsg->im6_src = ipv6_hdr(pkt)->saddr;\n\t\tmsg->im6_dst = ipv6_hdr(pkt)->daddr;\n\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t} else\n#endif\n\t{\n\t/*\n\t *\tCopy the IP header\n\t */\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tskb_copy_to_linear_data(skb, ipv6_hdr(pkt), sizeof(struct ipv6hdr));\n\n\t/*\n\t *\tAdd our header\n\t */\n\tskb_put(skb, sizeof(*msg));\n\tskb_reset_transport_header(skb);\n\tmsg = (struct mrt6msg *)skb_transport_header(skb);\n\n\tmsg->im6_mbz = 0;\n\tmsg->im6_msgtype = assert;\n\tmsg->im6_mif = mifi;\n\tmsg->im6_pad = 0;\n\tmsg->im6_src = ipv6_hdr(pkt)->saddr;\n\tmsg->im6_dst = ipv6_hdr(pkt)->daddr;\n\n\tskb_dst_set(skb, dst_clone(skb_dst(pkt)));\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\tif (!mrt->mroute6_sk) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t *\tDeliver to user space multicast routing algorithms\n\t */\n\tret = sock_queue_rcv_skb(mrt->mroute6_sk, skb);\n\tif (ret < 0) {\n\t\tnet_warn_ratelimited(\"mroute6: pending queue full, dropping entries\\n\");\n\t\tkfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\n/*\n *\tQueue a packet for resolution. It gets locked cache entry!\n */\n\nstatic int\nip6mr_cache_unresolved(struct mr6_table *mrt, mifi_t mifi, struct sk_buff *skb)\n{\n\tbool found = false;\n\tint err;\n\tstruct mfc6_cache *c;\n\n\tspin_lock_bh(&mfc_unres_lock);\n\tlist_for_each_entry(c, &mrt->mfc6_unres_queue, list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_mcastgrp, &ipv6_hdr(skb)->daddr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_origin, &ipv6_hdr(skb)->saddr)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t/*\n\t\t *\tCreate a new entry if allowable\n\t\t */\n\n\t\tif (atomic_read(&mrt->cache_resolve_queue_len) >= 10 ||\n\t\t    (c = ip6mr_cache_alloc_unres()) == NULL) {\n\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\t/*\n\t\t *\tFill in the new cache entry\n\t\t */\n\t\tc->mf6c_parent = -1;\n\t\tc->mf6c_origin = ipv6_hdr(skb)->saddr;\n\t\tc->mf6c_mcastgrp = ipv6_hdr(skb)->daddr;\n\n\t\t/*\n\t\t *\tReflect first query at pim6sd\n\t\t */\n\t\terr = ip6mr_cache_report(mrt, skb, mifi, MRT6MSG_NOCACHE);\n\t\tif (err < 0) {\n\t\t\t/* If the report failed throw the cache entry\n\t\t\t   out - Brad Parker\n\t\t\t */\n\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\n\t\t\tip6mr_cache_free(c);\n\t\t\tkfree_skb(skb);\n\t\t\treturn err;\n\t\t}\n\n\t\tatomic_inc(&mrt->cache_resolve_queue_len);\n\t\tlist_add(&c->list, &mrt->mfc6_unres_queue);\n\t\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\n\t\tipmr_do_expire_process(mrt);\n\t}\n\n\t/*\n\t *\tSee if we can append the packet\n\t */\n\tif (c->mfc_un.unres.unresolved.qlen > 3) {\n\t\tkfree_skb(skb);\n\t\terr = -ENOBUFS;\n\t} else {\n\t\tskb_queue_tail(&c->mfc_un.unres.unresolved, skb);\n\t\terr = 0;\n\t}\n\n\tspin_unlock_bh(&mfc_unres_lock);\n\treturn err;\n}\n\n/*\n *\tMFC6 cache manipulation by user space\n */\n\nstatic int ip6mr_mfc_delete(struct mr6_table *mrt, struct mf6cctl *mfc,\n\t\t\t    int parent)\n{\n\tint line;\n\tstruct mfc6_cache *c, *next;\n\n\tline = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);\n\n\tlist_for_each_entry_safe(c, next, &mrt->mfc6_cache_array[line], list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_origin, &mfc->mf6cc_origin.sin6_addr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp,\n\t\t\t\t    &mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t\t    (parent == -1 || parent == c->mf6c_parent)) {\n\t\t\twrite_lock_bh(&mrt_lock);\n\t\t\tlist_del(&c->list);\n\t\t\twrite_unlock_bh(&mrt_lock);\n\n\t\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\t\tip6mr_cache_free(c);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic int ip6mr_device_event(struct notifier_block *this,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct mr6_table *mrt;\n\tstruct mif_device *v;\n\tint ct;\n\tLIST_HEAD(list);\n\n\tif (event != NETDEV_UNREGISTER)\n\t\treturn NOTIFY_DONE;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tv = &mrt->vif6_table[0];\n\t\tfor (ct = 0; ct < mrt->maxvif; ct++, v++) {\n\t\t\tif (v->dev == dev)\n\t\t\t\tmif6_delete(mrt, ct, &list);\n\t\t}\n\t}\n\tunregister_netdevice_many(&list);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ip6_mr_notifier = {\n\t.notifier_call = ip6mr_device_event\n};\n\n/*\n *\tSetup for IP multicast routing\n */\n\nstatic int __net_init ip6mr_net_init(struct net *net)\n{\n\tint err;\n\n\terr = ip6mr_rules_init(net);\n\tif (err < 0)\n\t\tgoto fail;\n\n#ifdef CONFIG_PROC_FS\n\terr = -ENOMEM;\n\tif (!proc_create(\"ip6_mr_vif\", 0, net->proc_net, &ip6mr_vif_fops))\n\t\tgoto proc_vif_fail;\n\tif (!proc_create(\"ip6_mr_cache\", 0, net->proc_net, &ip6mr_mfc_fops))\n\t\tgoto proc_cache_fail;\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_PROC_FS\nproc_cache_fail:\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\nproc_vif_fail:\n\tip6mr_rules_exit(net);\n#endif\nfail:\n\treturn err;\n}\n\nstatic void __net_exit ip6mr_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip6_mr_cache\", net->proc_net);\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\n#endif\n\tip6mr_rules_exit(net);\n}\n\nstatic struct pernet_operations ip6mr_net_ops = {\n\t.init = ip6mr_net_init,\n\t.exit = ip6mr_net_exit,\n};\n\nint __init ip6_mr_init(void)\n{\n\tint err;\n\n\tmrt_cachep = kmem_cache_create(\"ip6_mrt_cache\",\n\t\t\t\t       sizeof(struct mfc6_cache),\n\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t       NULL);\n\tif (!mrt_cachep)\n\t\treturn -ENOMEM;\n\n\terr = register_pernet_subsys(&ip6mr_net_ops);\n\tif (err)\n\t\tgoto reg_pernet_fail;\n\n\terr = register_netdevice_notifier(&ip6_mr_notifier);\n\tif (err)\n\t\tgoto reg_notif_fail;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (inet6_add_protocol(&pim6_protocol, IPPROTO_PIM) < 0) {\n\t\tpr_err(\"%s: can't add PIM protocol\\n\", __func__);\n\t\terr = -EAGAIN;\n\t\tgoto add_proto_fail;\n\t}\n#endif\n\trtnl_register(RTNL_FAMILY_IP6MR, RTM_GETROUTE, NULL,\n\t\t      ip6mr_rtm_dumproute, NULL);\n\treturn 0;\n#ifdef CONFIG_IPV6_PIMSM_V2\nadd_proto_fail:\n\tunregister_netdevice_notifier(&ip6_mr_notifier);\n#endif\nreg_notif_fail:\n\tunregister_pernet_subsys(&ip6mr_net_ops);\nreg_pernet_fail:\n\tkmem_cache_destroy(mrt_cachep);\n\treturn err;\n}\n\nvoid ip6_mr_cleanup(void)\n{\n\trtnl_unregister(RTNL_FAMILY_IP6MR, RTM_GETROUTE);\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tinet6_del_protocol(&pim6_protocol, IPPROTO_PIM);\n#endif\n\tunregister_netdevice_notifier(&ip6_mr_notifier);\n\tunregister_pernet_subsys(&ip6mr_net_ops);\n\tkmem_cache_destroy(mrt_cachep);\n}\n\nstatic int ip6mr_mfc_add(struct net *net, struct mr6_table *mrt,\n\t\t\t struct mf6cctl *mfc, int mrtsock, int parent)\n{\n\tbool found = false;\n\tint line;\n\tstruct mfc6_cache *uc, *c;\n\tunsigned char ttls[MAXMIFS];\n\tint i;\n\n\tif (mfc->mf6cc_parent >= MAXMIFS)\n\t\treturn -ENFILE;\n\n\tmemset(ttls, 255, MAXMIFS);\n\tfor (i = 0; i < MAXMIFS; i++) {\n\t\tif (IF_ISSET(i, &mfc->mf6cc_ifset))\n\t\t\tttls[i] = 1;\n\n\t}\n\n\tline = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_origin, &mfc->mf6cc_origin.sin6_addr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp,\n\t\t\t\t    &mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t\t    (parent == -1 || parent == mfc->mf6cc_parent)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\twrite_lock_bh(&mrt_lock);\n\t\tc->mf6c_parent = mfc->mf6cc_parent;\n\t\tip6mr_update_thresholds(mrt, c, ttls);\n\t\tif (!mrtsock)\n\t\t\tc->mfc_flags |= MFC_STATIC;\n\t\twrite_unlock_bh(&mrt_lock);\n\t\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\t\treturn 0;\n\t}\n\n\tif (!ipv6_addr_any(&mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t    !ipv6_addr_is_multicast(&mfc->mf6cc_mcastgrp.sin6_addr))\n\t\treturn -EINVAL;\n\n\tc = ip6mr_cache_alloc();\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tc->mf6c_origin = mfc->mf6cc_origin.sin6_addr;\n\tc->mf6c_mcastgrp = mfc->mf6cc_mcastgrp.sin6_addr;\n\tc->mf6c_parent = mfc->mf6cc_parent;\n\tip6mr_update_thresholds(mrt, c, ttls);\n\tif (!mrtsock)\n\t\tc->mfc_flags |= MFC_STATIC;\n\n\twrite_lock_bh(&mrt_lock);\n\tlist_add(&c->list, &mrt->mfc6_cache_array[line]);\n\twrite_unlock_bh(&mrt_lock);\n\n\t/*\n\t *\tCheck to see if we resolved a queued list. If so we\n\t *\tneed to send on the frames and tidy up.\n\t */\n\tfound = false;\n\tspin_lock_bh(&mfc_unres_lock);\n\tlist_for_each_entry(uc, &mrt->mfc6_unres_queue, list) {\n\t\tif (ipv6_addr_equal(&uc->mf6c_origin, &c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&uc->mf6c_mcastgrp, &c->mf6c_mcastgrp)) {\n\t\t\tlist_del(&uc->list);\n\t\t\tatomic_dec(&mrt->cache_resolve_queue_len);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&mrt->mfc6_unres_queue))\n\t\tdel_timer(&mrt->ipmr_expire_timer);\n\tspin_unlock_bh(&mfc_unres_lock);\n\n\tif (found) {\n\t\tip6mr_cache_resolve(net, mrt, uc, c);\n\t\tip6mr_cache_free(uc);\n\t}\n\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\treturn 0;\n}\n\n/*\n *\tClose the multicast socket, and clear the vif tables etc\n */\n\nstatic void mroute_clean_tables(struct mr6_table *mrt, bool all)\n{\n\tint i;\n\tLIST_HEAD(list);\n\tstruct mfc6_cache *c, *next;\n\n\t/*\n\t *\tShut down all active vif entries\n\t */\n\tfor (i = 0; i < mrt->maxvif; i++) {\n\t\tif (!all && (mrt->vif6_table[i].flags & VIFF_STATIC))\n\t\t\tcontinue;\n\t\tmif6_delete(mrt, i, &list);\n\t}\n\tunregister_netdevice_many(&list);\n\n\t/*\n\t *\tWipe the cache\n\t */\n\tfor (i = 0; i < MFC6_LINES; i++) {\n\t\tlist_for_each_entry_safe(c, next, &mrt->mfc6_cache_array[i], list) {\n\t\t\tif (!all && (c->mfc_flags & MFC_STATIC))\n\t\t\t\tcontinue;\n\t\t\twrite_lock_bh(&mrt_lock);\n\t\t\tlist_del(&c->list);\n\t\t\twrite_unlock_bh(&mrt_lock);\n\n\t\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\t\tip6mr_cache_free(c);\n\t\t}\n\t}\n\n\tif (atomic_read(&mrt->cache_resolve_queue_len) != 0) {\n\t\tspin_lock_bh(&mfc_unres_lock);\n\t\tlist_for_each_entry_safe(c, next, &mrt->mfc6_unres_queue, list) {\n\t\t\tlist_del(&c->list);\n\t\t\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\t\t\tip6mr_destroy_unres(mrt, c);\n\t\t}\n\t\tspin_unlock_bh(&mfc_unres_lock);\n\t}\n}\n\nstatic int ip6mr_sk_init(struct mr6_table *mrt, struct sock *sk)\n{\n\tint err = 0;\n\tstruct net *net = sock_net(sk);\n\n\trtnl_lock();\n\twrite_lock_bh(&mrt_lock);\n\tif (likely(mrt->mroute6_sk == NULL)) {\n\t\tmrt->mroute6_sk = sk;\n\t\tnet->ipv6.devconf_all->mc_forwarding++;\n\t} else {\n\t\terr = -EADDRINUSE;\n\t}\n\twrite_unlock_bh(&mrt_lock);\n\n\tif (!err)\n\t\tinet6_netconf_notify_devconf(net, NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t     net->ipv6.devconf_all);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nint ip6mr_sk_done(struct sock *sk)\n{\n\tint err = -EACCES;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\trtnl_lock();\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (sk == mrt->mroute6_sk) {\n\t\t\twrite_lock_bh(&mrt_lock);\n\t\t\tmrt->mroute6_sk = NULL;\n\t\t\tnet->ipv6.devconf_all->mc_forwarding--;\n\t\t\twrite_unlock_bh(&mrt_lock);\n\t\t\tinet6_netconf_notify_devconf(net,\n\t\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t\t     net->ipv6.devconf_all);\n\n\t\t\tmroute_clean_tables(mrt, false);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstruct sock *mroute6_socket(struct net *net, struct sk_buff *skb)\n{\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->skb_iif ? : LOOPBACK_IFINDEX,\n\t\t.flowi6_oif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\n\tif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\n\t\treturn NULL;\n\n\treturn mrt->mroute6_sk;\n}\n\n/*\n *\tSocket options and virtual interface manipulation. The whole\n *\tvirtual interface system is a complete heap, but unfortunately\n *\tthat's how BSD mrouted happens to think. Maybe one day with a proper\n *\tMOSPF/PIM router set up we can clean this up.\n */\n\nint ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, unsigned int optlen)\n{\n\tint ret, parent = 0;\n\tstruct mif6ctl vif;\n\tstruct mf6cctl mfc;\n\tmifi_t mifi;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tif (optname != MRT6_INIT) {\n\t\tif (sk != mrt->mroute6_sk && !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tswitch (optname) {\n\tcase MRT6_INIT:\n\t\tif (optlen < sizeof(int))\n\t\t\treturn -EINVAL;\n\n\t\treturn ip6mr_sk_init(mrt, sk);\n\n\tcase MRT6_DONE:\n\t\treturn ip6mr_sk_done(sk);\n\n\tcase MRT6_ADD_MIF:\n\t\tif (optlen < sizeof(vif))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&vif, optval, sizeof(vif)))\n\t\t\treturn -EFAULT;\n\t\tif (vif.mif6c_mifi >= MAXMIFS)\n\t\t\treturn -ENFILE;\n\t\trtnl_lock();\n\t\tret = mif6_add(net, mrt, &vif, sk == mrt->mroute6_sk);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\tcase MRT6_DEL_MIF:\n\t\tif (optlen < sizeof(mifi_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&mifi, optval, sizeof(mifi_t)))\n\t\t\treturn -EFAULT;\n\t\trtnl_lock();\n\t\tret = mif6_delete(mrt, mifi, NULL);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\t/*\n\t *\tManipulate the forwarding caches. These live\n\t *\tin a sort of kernel/user symbiosis.\n\t */\n\tcase MRT6_ADD_MFC:\n\tcase MRT6_DEL_MFC:\n\t\tparent = -1;\n\tcase MRT6_ADD_MFC_PROXY:\n\tcase MRT6_DEL_MFC_PROXY:\n\t\tif (optlen < sizeof(mfc))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&mfc, optval, sizeof(mfc)))\n\t\t\treturn -EFAULT;\n\t\tif (parent == 0)\n\t\t\tparent = mfc.mf6cc_parent;\n\t\trtnl_lock();\n\t\tif (optname == MRT6_DEL_MFC || optname == MRT6_DEL_MFC_PROXY)\n\t\t\tret = ip6mr_mfc_delete(mrt, &mfc, parent);\n\t\telse\n\t\t\tret = ip6mr_mfc_add(net, mrt, &mfc,\n\t\t\t\t\t    sk == mrt->mroute6_sk, parent);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\t/*\n\t *\tControl PIM assert (to activate pim will activate assert)\n\t */\n\tcase MRT6_ASSERT:\n\t{\n\t\tint v;\n\n\t\tif (optlen != sizeof(v))\n\t\t\treturn -EINVAL;\n\t\tif (get_user(v, (int __user *)optval))\n\t\t\treturn -EFAULT;\n\t\tmrt->mroute_do_assert = v;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t{\n\t\tint v;\n\n\t\tif (optlen != sizeof(v))\n\t\t\treturn -EINVAL;\n\t\tif (get_user(v, (int __user *)optval))\n\t\t\treturn -EFAULT;\n\t\tv = !!v;\n\t\trtnl_lock();\n\t\tret = 0;\n\t\tif (v != mrt->mroute_do_pim) {\n\t\t\tmrt->mroute_do_pim = v;\n\t\t\tmrt->mroute_do_assert = v;\n\t\t}\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n\n#endif\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n\tcase MRT6_TABLE:\n\t{\n\t\tu32 v;\n\n\t\tif (optlen != sizeof(u32))\n\t\t\treturn -EINVAL;\n\t\tif (get_user(v, (u32 __user *)optval))\n\t\t\treturn -EFAULT;\n\t\t/* \"pim6reg%u\" should not exceed 16 bytes (IFNAMSIZ) */\n\t\tif (v != RT_TABLE_DEFAULT && v >= 100000000)\n\t\t\treturn -EINVAL;\n\t\tif (sk == mrt->mroute6_sk)\n\t\t\treturn -EBUSY;\n\n\t\trtnl_lock();\n\t\tret = 0;\n\t\tif (!ip6mr_new_table(net, v))\n\t\t\tret = -ENOMEM;\n\t\traw6_sk(sk)->ip6mr_table = v;\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n#endif\n\t/*\n\t *\tSpurious command, or MRT6_VERSION which you cannot\n\t *\tset.\n\t */\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\n/*\n *\tGetsock opt support for the multicast routing system.\n */\n\nint ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n *\tThe IP multicast ioctl support routines.\n */\n\nint ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg)\n{\n\tstruct sioc_sg_req6 sr;\n\tstruct sioc_mif_req6 vr;\n\tstruct mif_device *vif;\n\tstruct mfc6_cache *c;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (cmd) {\n\tcase SIOCGETMIFCNT_IN6:\n\t\tif (copy_from_user(&vr, arg, sizeof(vr)))\n\t\t\treturn -EFAULT;\n\t\tif (vr.mifi >= mrt->maxvif)\n\t\t\treturn -EINVAL;\n\t\tread_lock(&mrt_lock);\n\t\tvif = &mrt->vif6_table[vr.mifi];\n\t\tif (MIF_EXISTS(mrt, vr.mifi)) {\n\t\t\tvr.icount = vif->pkt_in;\n\t\t\tvr.ocount = vif->pkt_out;\n\t\t\tvr.ibytes = vif->bytes_in;\n\t\t\tvr.obytes = vif->bytes_out;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &vr, sizeof(vr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tcase SIOCGETSGCNT_IN6:\n\t\tif (copy_from_user(&sr, arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\tread_lock(&mrt_lock);\n\t\tc = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);\n\t\tif (c) {\n\t\t\tsr.pktcnt = c->mfc_un.res.pkt;\n\t\t\tsr.bytecnt = c->mfc_un.res.bytes;\n\t\t\tsr.wrong_if = c->mfc_un.res.wrong_if;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &sr, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_sioc_sg_req6 {\n\tstruct sockaddr_in6 src;\n\tstruct sockaddr_in6 grp;\n\tcompat_ulong_t pktcnt;\n\tcompat_ulong_t bytecnt;\n\tcompat_ulong_t wrong_if;\n};\n\nstruct compat_sioc_mif_req6 {\n\tmifi_t\tmifi;\n\tcompat_ulong_t icount;\n\tcompat_ulong_t ocount;\n\tcompat_ulong_t ibytes;\n\tcompat_ulong_t obytes;\n};\n\nint ip6mr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)\n{\n\tstruct compat_sioc_sg_req6 sr;\n\tstruct compat_sioc_mif_req6 vr;\n\tstruct mif_device *vif;\n\tstruct mfc6_cache *c;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (cmd) {\n\tcase SIOCGETMIFCNT_IN6:\n\t\tif (copy_from_user(&vr, arg, sizeof(vr)))\n\t\t\treturn -EFAULT;\n\t\tif (vr.mifi >= mrt->maxvif)\n\t\t\treturn -EINVAL;\n\t\tread_lock(&mrt_lock);\n\t\tvif = &mrt->vif6_table[vr.mifi];\n\t\tif (MIF_EXISTS(mrt, vr.mifi)) {\n\t\t\tvr.icount = vif->pkt_in;\n\t\t\tvr.ocount = vif->pkt_out;\n\t\t\tvr.ibytes = vif->bytes_in;\n\t\t\tvr.obytes = vif->bytes_out;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &vr, sizeof(vr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tcase SIOCGETSGCNT_IN6:\n\t\tif (copy_from_user(&sr, arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\tread_lock(&mrt_lock);\n\t\tc = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);\n\t\tif (c) {\n\t\t\tsr.pktcnt = c->mfc_un.res.pkt;\n\t\t\tsr.bytecnt = c->mfc_un.res.bytes;\n\t\t\tsr.wrong_if = c->mfc_un.res.wrong_if;\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\tif (copy_to_user(arg, &sr, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\treturn -EADDRNOTAVAIL;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\nstatic inline int ip6mr_forward2_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\tIPSTATS_MIB_OUTFORWDATAGRAMS);\n\t__IP6_ADD_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\tIPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn dst_output(net, sk, skb);\n}\n\n/*\n *\tProcessing handlers for ip6mr_forward\n */\n\nstatic int ip6mr_forward2(struct net *net, struct mr6_table *mrt,\n\t\t\t  struct sk_buff *skb, struct mfc6_cache *c, int vifi)\n{\n\tstruct ipv6hdr *ipv6h;\n\tstruct mif_device *vif = &mrt->vif6_table[vifi];\n\tstruct net_device *dev;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\n\tif (!vif->dev)\n\t\tgoto out_free;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (vif->flags & MIFF_REGISTER) {\n\t\tvif->pkt_out++;\n\t\tvif->bytes_out += skb->len;\n\t\tvif->dev->stats.tx_bytes += skb->len;\n\t\tvif->dev->stats.tx_packets++;\n\t\tip6mr_cache_report(mrt, skb, vifi, MRT6MSG_WHOLEPKT);\n\t\tgoto out_free;\n\t}\n#endif\n\n\tipv6h = ipv6_hdr(skb);\n\n\tfl6 = (struct flowi6) {\n\t\t.flowi6_oif = vif->link,\n\t\t.daddr = ipv6h->daddr,\n\t};\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (dst->error) {\n\t\tdst_release(dst);\n\t\tgoto out_free;\n\t}\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\n\t/*\n\t * RFC1584 teaches, that DVMRP/PIM router must deliver packets locally\n\t * not only before forwarding, but after forwarding on all output\n\t * interfaces. It is clear, if mrouter runs a multicasting\n\t * program, it should receive packets not depending to what interface\n\t * program is joined.\n\t * If we will not make it, the program will have to join on all\n\t * interfaces. On the other hand, multihoming host (or router, but\n\t * not mrouter) cannot join to more than one interface - it will\n\t * result in receiving multiple packets.\n\t */\n\tdev = vif->dev;\n\tskb->dev = dev;\n\tvif->pkt_out++;\n\tvif->bytes_out += skb->len;\n\n\t/* We are about to write */\n\t/* XXX: extension headers? */\n\tif (skb_cow(skb, sizeof(*ipv6h) + LL_RESERVED_SPACE(dev)))\n\t\tgoto out_free;\n\n\tipv6h = ipv6_hdr(skb);\n\tipv6h->hop_limit--;\n\n\tIP6CB(skb)->flags |= IP6SKB_FORWARDED;\n\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD,\n\t\t       net, NULL, skb, skb->dev, dev,\n\t\t       ip6mr_forward2_finish);\n\nout_free:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ip6mr_find_vif(struct mr6_table *mrt, struct net_device *dev)\n{\n\tint ct;\n\n\tfor (ct = mrt->maxvif - 1; ct >= 0; ct--) {\n\t\tif (mrt->vif6_table[ct].dev == dev)\n\t\t\tbreak;\n\t}\n\treturn ct;\n}\n\nstatic void ip6_mr_forward(struct net *net, struct mr6_table *mrt,\n\t\t\t   struct sk_buff *skb, struct mfc6_cache *cache)\n{\n\tint psend = -1;\n\tint vif, ct;\n\tint true_vifi = ip6mr_find_vif(mrt, skb->dev);\n\n\tvif = cache->mf6c_parent;\n\tcache->mfc_un.res.pkt++;\n\tcache->mfc_un.res.bytes += skb->len;\n\tcache->mfc_un.res.lastuse = jiffies;\n\n\tif (ipv6_addr_any(&cache->mf6c_origin) && true_vifi >= 0) {\n\t\tstruct mfc6_cache *cache_proxy;\n\n\t\t/* For an (*,G) entry, we only check that the incoming\n\t\t * interface is part of the static tree.\n\t\t */\n\t\tcache_proxy = ip6mr_cache_find_any_parent(mrt, vif);\n\t\tif (cache_proxy &&\n\t\t    cache_proxy->mfc_un.res.ttls[true_vifi] < 255)\n\t\t\tgoto forward;\n\t}\n\n\t/*\n\t * Wrong interface: drop packet and (maybe) send PIM assert.\n\t */\n\tif (mrt->vif6_table[vif].dev != skb->dev) {\n\t\tcache->mfc_un.res.wrong_if++;\n\n\t\tif (true_vifi >= 0 && mrt->mroute_do_assert &&\n\t\t    /* pimsm uses asserts, when switching from RPT to SPT,\n\t\t       so that we cannot check that packet arrived on an oif.\n\t\t       It is bad, but otherwise we would need to move pretty\n\t\t       large chunk of pimd to kernel. Ough... --ANK\n\t\t     */\n\t\t    (mrt->mroute_do_pim ||\n\t\t     cache->mfc_un.res.ttls[true_vifi] < 255) &&\n\t\t    time_after(jiffies,\n\t\t\t       cache->mfc_un.res.last_assert + MFC_ASSERT_THRESH)) {\n\t\t\tcache->mfc_un.res.last_assert = jiffies;\n\t\t\tip6mr_cache_report(mrt, skb, true_vifi, MRT6MSG_WRONGMIF);\n\t\t}\n\t\tgoto dont_forward;\n\t}\n\nforward:\n\tmrt->vif6_table[vif].pkt_in++;\n\tmrt->vif6_table[vif].bytes_in += skb->len;\n\n\t/*\n\t *\tForward the frame\n\t */\n\tif (ipv6_addr_any(&cache->mf6c_origin) &&\n\t    ipv6_addr_any(&cache->mf6c_mcastgrp)) {\n\t\tif (true_vifi >= 0 &&\n\t\t    true_vifi != cache->mf6c_parent &&\n\t\t    ipv6_hdr(skb)->hop_limit >\n\t\t\t\tcache->mfc_un.res.ttls[cache->mf6c_parent]) {\n\t\t\t/* It's an (*,*) entry and the packet is not coming from\n\t\t\t * the upstream: forward the packet to the upstream\n\t\t\t * only.\n\t\t\t */\n\t\t\tpsend = cache->mf6c_parent;\n\t\t\tgoto last_forward;\n\t\t}\n\t\tgoto dont_forward;\n\t}\n\tfor (ct = cache->mfc_un.res.maxvif - 1; ct >= cache->mfc_un.res.minvif; ct--) {\n\t\t/* For (*,G) entry, don't forward to the incoming interface */\n\t\tif ((!ipv6_addr_any(&cache->mf6c_origin) || ct != true_vifi) &&\n\t\t    ipv6_hdr(skb)->hop_limit > cache->mfc_un.res.ttls[ct]) {\n\t\t\tif (psend != -1) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\tip6mr_forward2(net, mrt, skb2, cache, psend);\n\t\t\t}\n\t\t\tpsend = ct;\n\t\t}\n\t}\nlast_forward:\n\tif (psend != -1) {\n\t\tip6mr_forward2(net, mrt, skb, cache, psend);\n\t\treturn;\n\t}\n\ndont_forward:\n\tkfree_skb(skb);\n}\n\n\n/*\n *\tMulticast packets for forwarding arrive here\n */\n\nint ip6_mr_input(struct sk_buff *skb)\n{\n\tstruct mfc6_cache *cache;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint err;\n\n\terr = ip6mr_fib_lookup(net, &fl6, &mrt);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tread_lock(&mrt_lock);\n\tcache = ip6mr_cache_find(mrt,\n\t\t\t\t &ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr);\n\tif (!cache) {\n\t\tint vif = ip6mr_find_vif(mrt, skb->dev);\n\n\t\tif (vif >= 0)\n\t\t\tcache = ip6mr_cache_find_any(mrt,\n\t\t\t\t\t\t     &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t     vif);\n\t}\n\n\t/*\n\t *\tNo usable cache entry\n\t */\n\tif (!cache) {\n\t\tint vif;\n\n\t\tvif = ip6mr_find_vif(mrt, skb->dev);\n\t\tif (vif >= 0) {\n\t\t\tint err = ip6mr_cache_unresolved(mrt, vif, skb);\n\t\t\tread_unlock(&mrt_lock);\n\n\t\t\treturn err;\n\t\t}\n\t\tread_unlock(&mrt_lock);\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tip6_mr_forward(net, mrt, skb, cache);\n\n\tread_unlock(&mrt_lock);\n\n\treturn 0;\n}\n\n\nstatic int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\n\t\t\t       struct mfc6_cache *c, struct rtmsg *rtm)\n{\n\tstruct rta_mfc_stats mfcs;\n\tstruct nlattr *mp_attr;\n\tstruct rtnexthop *nhp;\n\tunsigned long lastuse;\n\tint ct;\n\n\t/* If cache is unresolved, don't try to parse IIF and OIF */\n\tif (c->mf6c_parent >= MAXMIFS) {\n\t\trtm->rtm_flags |= RTNH_F_UNRESOLVED;\n\t\treturn -ENOENT;\n\t}\n\n\tif (MIF_EXISTS(mrt, c->mf6c_parent) &&\n\t    nla_put_u32(skb, RTA_IIF, mrt->vif6_table[c->mf6c_parent].dev->ifindex) < 0)\n\t\treturn -EMSGSIZE;\n\tmp_attr = nla_nest_start(skb, RTA_MULTIPATH);\n\tif (!mp_attr)\n\t\treturn -EMSGSIZE;\n\n\tfor (ct = c->mfc_un.res.minvif; ct < c->mfc_un.res.maxvif; ct++) {\n\t\tif (MIF_EXISTS(mrt, ct) && c->mfc_un.res.ttls[ct] < 255) {\n\t\t\tnhp = nla_reserve_nohdr(skb, sizeof(*nhp));\n\t\t\tif (!nhp) {\n\t\t\t\tnla_nest_cancel(skb, mp_attr);\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\n\t\t\tnhp->rtnh_flags = 0;\n\t\t\tnhp->rtnh_hops = c->mfc_un.res.ttls[ct];\n\t\t\tnhp->rtnh_ifindex = mrt->vif6_table[ct].dev->ifindex;\n\t\t\tnhp->rtnh_len = sizeof(*nhp);\n\t\t}\n\t}\n\n\tnla_nest_end(skb, mp_attr);\n\n\tlastuse = READ_ONCE(c->mfc_un.res.lastuse);\n\tlastuse = time_after_eq(jiffies, lastuse) ? jiffies - lastuse : 0;\n\n\tmfcs.mfcs_packets = c->mfc_un.res.pkt;\n\tmfcs.mfcs_bytes = c->mfc_un.res.bytes;\n\tmfcs.mfcs_wrong_if = c->mfc_un.res.wrong_if;\n\tif (nla_put_64bit(skb, RTA_MFC_STATS, sizeof(mfcs), &mfcs, RTA_PAD) ||\n\t    nla_put_u64_64bit(skb, RTA_EXPIRES, jiffies_to_clock_t(lastuse),\n\t\t\t      RTA_PAD))\n\t\treturn -EMSGSIZE;\n\n\trtm->rtm_type = RTN_MULTICAST;\n\treturn 1;\n}\n\nint ip6mr_get_route(struct net *net, struct sk_buff *skb, struct rtmsg *rtm,\n\t\t    u32 portid)\n{\n\tint err;\n\tstruct mr6_table *mrt;\n\tstruct mfc6_cache *cache;\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tread_lock(&mrt_lock);\n\tcache = ip6mr_cache_find(mrt, &rt->rt6i_src.addr, &rt->rt6i_dst.addr);\n\tif (!cache && skb->dev) {\n\t\tint vif = ip6mr_find_vif(mrt, skb->dev);\n\n\t\tif (vif >= 0)\n\t\t\tcache = ip6mr_cache_find_any(mrt, &rt->rt6i_dst.addr,\n\t\t\t\t\t\t     vif);\n\t}\n\n\tif (!cache) {\n\t\tstruct sk_buff *skb2;\n\t\tstruct ipv6hdr *iph;\n\t\tstruct net_device *dev;\n\t\tint vif;\n\n\t\tdev = skb->dev;\n\t\tif (!dev || (vif = ip6mr_find_vif(mrt, dev)) < 0) {\n\t\t\tread_unlock(&mrt_lock);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* really correct? */\n\t\tskb2 = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\t\tif (!skb2) {\n\t\t\tread_unlock(&mrt_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tNETLINK_CB(skb2).portid = portid;\n\t\tskb_reset_transport_header(skb2);\n\n\t\tskb_put(skb2, sizeof(struct ipv6hdr));\n\t\tskb_reset_network_header(skb2);\n\n\t\tiph = ipv6_hdr(skb2);\n\t\tiph->version = 0;\n\t\tiph->priority = 0;\n\t\tiph->flow_lbl[0] = 0;\n\t\tiph->flow_lbl[1] = 0;\n\t\tiph->flow_lbl[2] = 0;\n\t\tiph->payload_len = 0;\n\t\tiph->nexthdr = IPPROTO_NONE;\n\t\tiph->hop_limit = 0;\n\t\tiph->saddr = rt->rt6i_src.addr;\n\t\tiph->daddr = rt->rt6i_dst.addr;\n\n\t\terr = ip6mr_cache_unresolved(mrt, vif, skb2);\n\t\tread_unlock(&mrt_lock);\n\n\t\treturn err;\n\t}\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\tcache->mfc_flags |= MFC_NOTIFY;\n\n\terr = __ip6mr_fill_mroute(mrt, skb, cache, rtm);\n\tread_unlock(&mrt_lock);\n\treturn err;\n}\n\nstatic int ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,\n\t\t\t     u32 portid, u32 seq, struct mfc6_cache *c, int cmd,\n\t\t\t     int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\tint err;\n\n\tnlh = nlmsg_put(skb, portid, seq, cmd, sizeof(*rtm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family   = RTNL_FAMILY_IP6MR;\n\trtm->rtm_dst_len  = 128;\n\trtm->rtm_src_len  = 128;\n\trtm->rtm_tos      = 0;\n\trtm->rtm_table    = mrt->id;\n\tif (nla_put_u32(skb, RTA_TABLE, mrt->id))\n\t\tgoto nla_put_failure;\n\trtm->rtm_type = RTN_MULTICAST;\n\trtm->rtm_scope    = RT_SCOPE_UNIVERSE;\n\tif (c->mfc_flags & MFC_STATIC)\n\t\trtm->rtm_protocol = RTPROT_STATIC;\n\telse\n\t\trtm->rtm_protocol = RTPROT_MROUTED;\n\trtm->rtm_flags    = 0;\n\n\tif (nla_put_in6_addr(skb, RTA_SRC, &c->mf6c_origin) ||\n\t    nla_put_in6_addr(skb, RTA_DST, &c->mf6c_mcastgrp))\n\t\tgoto nla_put_failure;\n\terr = __ip6mr_fill_mroute(mrt, skb, c, rtm);\n\t/* do not break the dump if cache is unresolved */\n\tif (err < 0 && err != -ENOENT)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mr6_msgsize(bool unresolved, int maxvif)\n{\n\tsize_t len =\n\t\tNLMSG_ALIGN(sizeof(struct rtmsg))\n\t\t+ nla_total_size(4)\t/* RTA_TABLE */\n\t\t+ nla_total_size(sizeof(struct in6_addr))\t/* RTA_SRC */\n\t\t+ nla_total_size(sizeof(struct in6_addr))\t/* RTA_DST */\n\t\t;\n\n\tif (!unresolved)\n\t\tlen = len\n\t\t      + nla_total_size(4)\t/* RTA_IIF */\n\t\t      + nla_total_size(0)\t/* RTA_MULTIPATH */\n\t\t      + maxvif * NLA_ALIGN(sizeof(struct rtnexthop))\n\t\t\t\t\t\t/* RTA_MFC_STATS */\n\t\t      + nla_total_size_64bit(sizeof(struct rta_mfc_stats))\n\t\t;\n\n\treturn len;\n}\n\nstatic void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,\n\t\t\t      int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mr6_msgsize(mfc->mf6c_parent >= MAXMIFS, mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = ip6mr_fill_mroute(mrt, skb, 0, 0, mfc, cmd, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_MROUTE, err);\n}\n\nstatic int ip6mr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct mr6_table *mrt;\n\tstruct mfc6_cache *mfc;\n\tunsigned int t = 0, s_t;\n\tunsigned int h = 0, s_h;\n\tunsigned int e = 0, s_e;\n\n\ts_t = cb->args[0];\n\ts_h = cb->args[1];\n\ts_e = cb->args[2];\n\n\tread_lock(&mrt_lock);\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (t < s_t)\n\t\t\tgoto next_table;\n\t\tif (t > s_t)\n\t\t\ts_h = 0;\n\t\tfor (h = s_h; h < MFC6_LINES; h++) {\n\t\t\tlist_for_each_entry(mfc, &mrt->mfc6_cache_array[h], list) {\n\t\t\t\tif (e < s_e)\n\t\t\t\t\tgoto next_entry;\n\t\t\t\tif (ip6mr_fill_mroute(mrt, skb,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t      mfc, RTM_NEWROUTE,\n\t\t\t\t\t\t      NLM_F_MULTI) < 0)\n\t\t\t\t\tgoto done;\nnext_entry:\n\t\t\t\te++;\n\t\t\t}\n\t\t\te = s_e = 0;\n\t\t}\n\t\tspin_lock_bh(&mfc_unres_lock);\n\t\tlist_for_each_entry(mfc, &mrt->mfc6_unres_queue, list) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next_entry2;\n\t\t\tif (ip6mr_fill_mroute(mrt, skb,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      mfc, RTM_NEWROUTE,\n\t\t\t\t\t      NLM_F_MULTI) < 0) {\n\t\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\t\t\t\tgoto done;\n\t\t\t}\nnext_entry2:\n\t\t\te++;\n\t\t}\n\t\tspin_unlock_bh(&mfc_unres_lock);\n\t\te = s_e = 0;\n\t\ts_h = 0;\nnext_table:\n\t\tt++;\n\t}\ndone:\n\tread_unlock(&mrt_lock);\n\n\tcb->args[2] = e;\n\tcb->args[1] = h;\n\tcb->args[0] = t;\n\n\treturn skb->len;\n}\n"], "filenames": ["net/ipv6/ip6mr.c"], "buggy_code_start_loc": [1668], "buggy_code_end_loc": [1817], "fixing_code_start_loc": [1669], "fixing_code_end_loc": [1823], "type": "CWE-20", "message": "An issue was discovered in net/ipv6/ip6mr.c in the Linux kernel before 4.11. By setting a specific socket option, an attacker can control a pointer in kernel land and cause an inet_csk_listen_stop general protection fault, or potentially execute arbitrary code under certain circumstances. The issue can be triggered as root (e.g., inside a default LXC container or with the CAP_NET_ADMIN capability) or after namespace unsharing. This occurs because sk_type and protocol are not checked in the appropriate part of the ip6_mroute_* functions. NOTE: this affects Linux distributions that use 4.9.x longterm kernels before 4.9.187.", "other": {"cve": {"id": "CVE-2017-18509", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-13T14:15:11.977", "lastModified": "2023-02-07T22:01:00.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in net/ipv6/ip6mr.c in the Linux kernel before 4.11. By setting a specific socket option, an attacker can control a pointer in kernel land and cause an inet_csk_listen_stop general protection fault, or potentially execute arbitrary code under certain circumstances. The issue can be triggered as root (e.g., inside a default LXC container or with the CAP_NET_ADMIN capability) or after namespace unsharing. This occurs because sk_type and protocol are not checked in the appropriate part of the ip6_mroute_* functions. NOTE: this affects Linux distributions that use 4.9.x longterm kernels before 4.9.187."}, {"lang": "es", "value": "Se detecto un problema en net / ipv6 / ip6mr.c en el kernel de Linux antes de 4.11. Al establecer una opci\u00f3n de socket espec\u00edfica, un atacante puede controlar un puntero en la tierra del kernel y causar una falla de protecci\u00f3n general inet_csk_listen_stop, o potencialmente ejecutar c\u00f3digo arbitrario bajo ciertas circunstancias. El problema se puede desencadenar como root (por ejemplo, dentro de un contenedor LXC predeterminado o con la capacidad CAP_NET_ADMIN) o despu\u00e9s de compartir el espacio de nombres. Esto ocurre porque sk_type y el protocolo no se verifican en la parte apropiada de las funciones ip6_mroute_ *. NOTA: esto afecta a las distribuciones de Linux que usan n\u00facleos a largo plazo 4.9.x anteriores a 4.9.187."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.16.72", "matchCriteriaId": "E21EF678-8293-4EB3-BEA1-B35262A1C235"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "4.4.187", "matchCriteriaId": "FDF8054B-AF6C-4939-9851-0D88BE49B3F6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.187", "matchCriteriaId": "3D233DCB-31B1-497B-B266-DA830EAEAE8F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.11", "matchCriteriaId": "28FFE753-2608-40BE-A218-483B3D8C0241"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/154059/Slackware-Security-Advisory-Slackware-14.2-kernel-Updates.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=99253eb750fda6a644d5188fb26c43bad8d5a745", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/99253eb750fda6a644d5188fb26c43bad8d5a745", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00016.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.openwall.net/netdev/2017/12/04/40", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://pulsesecurity.co.nz/advisories/linux-kernel-4.9-inetcsklistenstop-gpf", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://salsa.debian.org/kernel-team/linux/commit/baefcdc2f29923e7325ce4e1a72c3ff0a9800f32", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Aug/26", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K41582535", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K41582535?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4145-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4497", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/99253eb750fda6a644d5188fb26c43bad8d5a745"}}