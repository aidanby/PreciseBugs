{"buggy_code": [".gradle\n.idea\n*.iml\nbuild/\n", "language: java\njdk:\n  - oraclejdk8\n\nafter_success:\n  - ./gradlew lib:jacocoTestReport lib:coveralls", "package eu.hinsch.spring.boot.actuator.logview;\n\nimport freemarker.template.Configuration;\nimport freemarker.template.TemplateException;\nimport org.apache.commons.io.IOUtils;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.http.MediaType;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.freemarker.FreeMarkerTemplateUtils;\nimport org.springframework.util.Assert;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URLEncoder;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\n\n/**\n * Created by lh on 23/02/15.\n */\npublic class LogViewEndpoint implements MvcEndpoint{\n\n    private final List<FileProvider> fileProviders;\n    private final Configuration freemarkerConfig;\n    private final String loggingPath;\n    private final List<String> stylesheets;\n\n    public LogViewEndpoint(String loggingPath, List<String> stylesheets) {\n        this.loggingPath = loggingPath;\n        this.stylesheets = stylesheets;\n        fileProviders = asList(new FileSystemFileProvider(),\n                new ZipArchiveFileProvider(),\n                new TarGzArchiveFileProvider());\n        freemarkerConfig = new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);\n        freemarkerConfig.setClassForTemplateLoading(this.getClass(), \"/templates\");\n    }\n\n    @RequestMapping\n    public void redirect(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"log/\");\n    }\n\n    @RequestMapping(\"/\")\n    @ResponseBody\n    public String list(Model model, // TODO model should no longer be injected\n                       @RequestParam(required = false, defaultValue = \"FILENAME\") SortBy sortBy,\n                       @RequestParam(required = false, defaultValue = \"false\") boolean desc,\n                       @RequestParam(required = false) String base) throws IOException, TemplateException {\n        securityCheck(base);\n\n        Path currentFolder = loggingPath(base);\n\n        List<FileEntry> files = getFileProvider(currentFolder).getFileEntries(currentFolder);\n        List<FileEntry> sortedFiles = sortFiles(files, sortBy, desc);\n\n        model.addAttribute(\"sortBy\", sortBy);\n        model.addAttribute(\"desc\", desc);\n        model.addAttribute(\"files\", sortedFiles);\n        model.addAttribute(\"currentFolder\", currentFolder.toAbsolutePath().toString());\n        model.addAttribute(\"base\", base != null ? URLEncoder.encode(base, \"UTF-8\") : \"\");\n        model.addAttribute(\"parent\", getParent(currentFolder));\n        model.addAttribute(\"stylesheets\", stylesheets);\n\n        return FreeMarkerTemplateUtils.processTemplateIntoString(freemarkerConfig.getTemplate(\"logview.ftl\"), model);\n    }\n\n    private FileProvider getFileProvider(Path folder) {\n        return fileProviders.stream()\n                .filter(provider -> provider.canHandle(folder))\n                .findFirst()\n                .orElseThrow(() -> new RuntimeException(\"no file provider found for \" + folder.toString()));\n    }\n\n    private String getParent(Path loggingPath) {\n        Path basePath = loggingPath(null);\n        String parent = \"\";\n        if (!basePath.toString().equals(loggingPath.toString())) {\n            parent = loggingPath.getParent().toString();\n            if (parent.startsWith(basePath.toString())) {\n                parent = parent.substring(basePath.toString().length());\n            }\n        }\n        return parent;\n    }\n\n    private Path loggingPath(String base) {\n        return base != null ? Paths.get(loggingPath, base) : Paths.get(loggingPath);\n    }\n\n    private List<FileEntry> sortFiles(List<FileEntry> files, SortBy sortBy, boolean desc) {\n        Comparator<FileEntry> comparator = null;\n        switch (sortBy) {\n            case FILENAME:\n                comparator = (a, b) -> a.getFilename().compareTo(b.getFilename());\n                break;\n            case SIZE:\n                comparator = (a, b) -> Long.compare(a.getSize(), b.getSize());\n                break;\n            case MODIFIED:\n                comparator = (a, b) -> Long.compare(a.getModified().toMillis(), b.getModified().toMillis());\n                break;\n        }\n        List<FileEntry> sortedFiles = files.stream().sorted(comparator).collect(toList());\n\n        if (desc) {\n            Collections.reverse(sortedFiles);\n        }\n        return sortedFiles;\n    }\n\n    @RequestMapping(\"/view\")\n    public void view(@RequestParam String filename,\n                     @RequestParam(required = false) String base,\n                     @RequestParam(required = false) Integer tailLines,\n                     HttpServletResponse response) throws IOException {\n        securityCheck(filename);\n        response.setContentType(MediaType.TEXT_PLAIN_VALUE);\n\n        Path path = loggingPath(base);\n        FileProvider fileProvider = getFileProvider(path);\n        if (tailLines != null) {\n            fileProvider.tailContent(path, filename, response.getOutputStream(), tailLines);\n        }\n        else {\n            fileProvider.streamContent(path, filename, response.getOutputStream());\n        }\n    }\n\n    @RequestMapping(\"/search\")\n    public void search(@RequestParam String term, HttpServletResponse response) throws IOException {\n        Path folder = loggingPath(null);\n        List<FileEntry> files = getFileProvider(folder).getFileEntries(folder);\n        List<FileEntry> sortedFiles = sortFiles(files, SortBy.MODIFIED, false);\n\n        response.setContentType(MediaType.TEXT_PLAIN_VALUE);\n        ServletOutputStream outputStream = response.getOutputStream();\n\n        sortedFiles.stream()\n                .filter(file -> file.getFileType().equals(FileType.FILE))\n                .forEach(file -> searchAndStreamFile(file, term, outputStream));\n    }\n\n    private void searchAndStreamFile(FileEntry fileEntry, String term, OutputStream outputStream) {\n        Path folder = loggingPath(null);\n        try {\n            List<String> lines = IOUtils.readLines(new FileInputStream(new File(folder.toFile().toString(), fileEntry.getFilename())))\n                    .stream()\n                    .filter(line -> line.contains(term))\n                    .map(line -> \"[\" + fileEntry.getFilename() + \"] \" + line)\n                    .collect(toList());\n            for (String line : lines) {\n                outputStream.write(line.getBytes());\n                outputStream.write(System.lineSeparator().getBytes());\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"error reading file\", e);\n        }\n    }\n\n    private void securityCheck(String filename) {\n        Assert.doesNotContain(filename, \"..\");\n    }\n\n    @Override\n    public String getPath() {\n        return \"/log\";\n    }\n\n    @Override\n    public boolean isSensitive() {\n        return true;\n    }\n\n\n    @Override\n    public Class<? extends Endpoint> getEndpointType() {\n        return null;\n    }\n\n}\n", "package eu.hinsch.spring.boot.actuator.logview;\n\nimport org.apache.catalina.ssi.ByteArrayServletOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.rules.TemporaryFolder;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.springframework.ui.ExtendedModelMap;\nimport org.springframework.ui.Model;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@SuppressWarnings(\"unchecked\")\npublic class LogViewEndpointTest {\n\n    @Rule\n    public TemporaryFolder temporaryFolder = new TemporaryFolder();\n\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    @Mock\n    private HttpServletResponse response;\n\n    private LogViewEndpoint logViewEndpoint;\n\n    private Model model;\n    private long now;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        logViewEndpoint = new LogViewEndpoint(temporaryFolder.getRoot().getAbsolutePath(),\n                new LogViewEndpointAutoconfig.EndpointConfiguration().getStylesheets());\n        model = new ExtendedModelMap();\n        now = new Date().getTime();\n    }\n\n    @Test\n    public void shouldReturnEmptyFileListForEmptyDirectory() throws Exception {\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(model.containsAttribute(\"files\"), is(true));\n        assertThat(getFileEntries(), hasSize(0));\n    }\n\n    @Test\n    public void shouldListSortedByFilename() throws Exception {\n        // given\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"C.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"A.log\", \"B.log\", \"C.log\"));\n    }\n\n    @Test\n    public void shouldListReverseSortedByFilename() throws Exception {\n        // given\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"C.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, true, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"C.log\", \"B.log\", \"A.log\"));\n    }\n\n    @Test\n    public void shouldListSortedBySize() throws Exception {\n        // given\n        createFile(\"A.log\", \"xx\", now);\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"C.log\", \"xxx\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.SIZE, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"B.log\", \"A.log\", \"C.log\"));\n        assertThat(getFileSizes(), contains(1L, 2L, 3L));\n    }\n\n    @Test\n    public void shouldListSortedByDate() throws Exception {\n        // given\n        // TODO java 8 date api\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"B.log\", \"x\", now - 10 * 60 * 1000);\n        createFile(\"C.log\", \"x\", now - 5 * 60 * 1000);\n\n        // when\n        logViewEndpoint.list(model, SortBy.MODIFIED, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"B.log\", \"C.log\", \"A.log\"));\n        assertThat(getFilePrettyTimes(), contains(\"10 minutes ago\", \"5 minutes ago\", \"moments ago\"));\n    }\n\n    @Test\n    public void shouldSetFileTypeForFile() throws Exception {\n        // given\n        createFile(\"A.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileEntries().get(0).getFileType(), is(FileType.FILE));\n    }\n\n    @Test\n    public void shouldSetFileTypeForArchive() throws Exception {\n        // given\n        createFile(\"A.log.tar.gz\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileEntries().get(0).getFileType(), is(FileType.ARCHIVE));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInBaseFolder() throws Exception {\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"\"));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInSubfolder() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"subfolder\");\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"\"));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInNestedSubfolder() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n        temporaryFolder.newFolder(\"subfolder\", \"nested\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"subfolder/nested\");\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"/subfolder\"));\n    }\n\n    @Test\n    public void shouldIncludeSubfolderEntry() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFileType(), is(FileType.DIRECTORY));\n        assertThat(fileEntry.getFilename(), is(\"subfolder\"));\n    }\n\n    @Test\n    public void shouldListZipContent() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"file.zip\");\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFilename(), is(\"A.log\"));\n    }\n\n    @Test\n    public void shouldViewZipFileContent() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.zip\", null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"content\"));\n    }\n\n    private void createZipArchive(String archiveFileName, String contentFileName, String content) throws Exception {\n        try(ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(temporaryFolder.getRoot(), archiveFileName)))) {\n            ZipEntry zipEntry = new ZipEntry(contentFileName);\n            zos.putNextEntry(zipEntry);\n            IOUtils.write(content, zos);\n        }\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void shouldThrowExceptionWhenCallingTailForZip() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.zip\", 1, response);\n\n        // then -> exception\n    }\n\n    @Test\n    public void shouldListTarGzContent() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"file.tar.gz\");\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFilename(), is(\"A.log\"));\n    }\n\n    @Test\n    public void shouldViewTarGzFileContent() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.tar.gz\", null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"content\"));\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void shouldThrowExceptionWhenCallingTailForTarGz() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.tar.gz\", 1, response);\n\n        // then -> exception\n    }\n\n    private void createTarGzArchive(String archiveFileName, String contentFileName, String content) throws Exception {\n\n        try(TarArchiveOutputStream tos = new TarArchiveOutputStream(new GZIPOutputStream(\n                new BufferedOutputStream(new FileOutputStream(\n                        new File(temporaryFolder.getRoot(), archiveFileName)))))) {\n            tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\n            tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n            TarArchiveEntry archiveEntry = new TarArchiveEntry(contentFileName);\n            archiveEntry.setSize(content.length());\n            tos.putArchiveEntry(archiveEntry);\n            IOUtils.write(content, tos);\n            tos.closeArchiveEntry();\n        }\n    }\n\n    @Test\n    public void shouldRedirectWithoutTrainingSlash() throws IOException {\n        // when\n        logViewEndpoint.redirect(response);\n\n        // then\n        verify(response).sendRedirect(\"log/\");\n    }\n\n    @Test\n    public void shouldEndpointBeSensitive() {\n        assertThat(logViewEndpoint.isSensitive(), is(true));\n    }\n\n    @Test\n    public void shouldReturnContextPath() {\n        assertThat(logViewEndpoint.getPath(), is(\"/log\"));\n    }\n\n    @Test\n    public void shouldReturnNullEndpointType() {\n        assertThat(logViewEndpoint.getEndpointType(), is(nullValue()));\n    }\n\n    @Test\n    public void shouldNotAllowToListFileOutsideRoot() throws Exception {\n        // given\n        expectedException.expect(IllegalArgumentException.class);\n        expectedException.expectMessage(containsString(\"this String argument must not contain the substring [..]\"));\n\n        // when\n        logViewEndpoint.view(\"../somefile\", null, null, null);\n    }\n\n    @Test\n    public void shouldViewFile() throws Exception {\n        // given\n        createFile(\"file.log\", \"abc\", now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"file.log\", null, null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"abc\"));\n    }\n\n    @Test\n    public void shouldTailViewOnlyLastLine() throws Exception {\n        // given\n        createFile(\"file.log\", \"line1\" + System.lineSeparator() + \"line2\" + System.lineSeparator(), now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"file.log\", null, 1, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), not(containsString(\"line1\")));\n        assertThat(new String(outputStream.toByteArray()), containsString(\"line2\"));\n    }\n\n    @Test\n    public void shouldSearchInFiles() throws Exception {\n        // given\n        String sep = System.lineSeparator();\n        createFile(\"A.log\", \"A-line1\" + sep + \"A-line2\" + sep + \"A-line3\", now - 1);\n        createFile(\"B.log\", \"B-line1\" + sep + \"B-line2\" + sep + \"B-line3\", now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.search(\"line2\", response);\n\n        // then\n        String output = new String(outputStream.toByteArray());\n        assertThat(output, containsString(\"[A.log] A-line2\"));\n        assertThat(output, containsString(\"[B.log] B-line2\"));\n        assertThat(output, not(containsString(\"line1\")));\n        assertThat(output, not(containsString(\"line3\")));\n    }\n\n    private ByteArrayServletOutputStream mockResponseOutputStream() throws Exception {\n        ByteArrayServletOutputStream outputStream = new ByteArrayServletOutputStream();\n        when(response.getOutputStream()).thenReturn(outputStream);\n        return outputStream;\n    }\n\n    private List<String> getFileNames() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getFilename)\n                .collect(toList());\n    }\n\n    private List<Long> getFileSizes() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getSize)\n                .collect(toList());\n    }\n\n    private List<String> getFilePrettyTimes() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getModifiedPretty)\n                .collect(toList());\n    }\n\n    private List<FileEntry> getFileEntries() {\n        return (List<FileEntry>) model.asMap().get(\"files\");\n    }\n\n    private void createFile(String filename, String content, long modified) throws Exception {\n        File file = new File(temporaryFolder.getRoot(), filename);\n        FileUtils.write(file, content);\n        assertThat(file.setLastModified(modified), is(true));\n    }\n\n}"], "fixing_code": [".gradle\n.idea\n*.iml\nbuild/\nout/\n", "language: java\njdk:\n  - openjdk8\n\nafter_success:\n  - ./gradlew lib:jacocoTestReport lib:coveralls", "package eu.hinsch.spring.boot.actuator.logview;\n\nimport freemarker.template.Configuration;\nimport freemarker.template.TemplateException;\nimport org.apache.commons.io.IOUtils;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.http.MediaType;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.freemarker.FreeMarkerTemplateUtils;\nimport org.springframework.util.Assert;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URLEncoder;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\n\n/**\n * Created by lh on 23/02/15.\n */\npublic class LogViewEndpoint implements MvcEndpoint{\n\n    private final List<FileProvider> fileProviders;\n    private final Configuration freemarkerConfig;\n    private final String loggingPath;\n    private final List<String> stylesheets;\n\n    public LogViewEndpoint(String loggingPath, List<String> stylesheets) {\n        this.loggingPath = loggingPath;\n        this.stylesheets = stylesheets;\n        fileProviders = asList(new FileSystemFileProvider(),\n                new ZipArchiveFileProvider(),\n                new TarGzArchiveFileProvider());\n        freemarkerConfig = new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);\n        freemarkerConfig.setClassForTemplateLoading(this.getClass(), \"/templates\");\n    }\n\n    @RequestMapping\n    public void redirect(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"log/\");\n    }\n\n    @RequestMapping(\"/\")\n    @ResponseBody\n    public String list(Model model, // TODO model should no longer be injected\n                       @RequestParam(required = false, defaultValue = \"FILENAME\") SortBy sortBy,\n                       @RequestParam(required = false, defaultValue = \"false\") boolean desc,\n                       @RequestParam(required = false) String base) throws IOException, TemplateException {\n        Path currentFolder = loggingPath(base);\n        securityCheck(currentFolder, null);\n\n\n        List<FileEntry> files = getFileProvider(currentFolder).getFileEntries(currentFolder);\n        List<FileEntry> sortedFiles = sortFiles(files, sortBy, desc);\n\n        model.addAttribute(\"sortBy\", sortBy);\n        model.addAttribute(\"desc\", desc);\n        model.addAttribute(\"files\", sortedFiles);\n        model.addAttribute(\"currentFolder\", currentFolder.toAbsolutePath().toString());\n        model.addAttribute(\"base\", base != null ? URLEncoder.encode(base, \"UTF-8\") : \"\");\n        model.addAttribute(\"parent\", getParent(currentFolder));\n        model.addAttribute(\"stylesheets\", stylesheets);\n\n        return FreeMarkerTemplateUtils.processTemplateIntoString(freemarkerConfig.getTemplate(\"logview.ftl\"), model);\n    }\n\n    private FileProvider getFileProvider(Path folder) {\n        return fileProviders.stream()\n                .filter(provider -> provider.canHandle(folder))\n                .findFirst()\n                .orElseThrow(() -> new RuntimeException(\"no file provider found for \" + folder.toString()));\n    }\n\n    private String getParent(Path loggingPath) {\n        Path basePath = loggingPath(null);\n        String parent = \"\";\n        if (!basePath.toString().equals(loggingPath.toString())) {\n            parent = loggingPath.getParent().toString();\n            if (parent.startsWith(basePath.toString())) {\n                parent = parent.substring(basePath.toString().length());\n            }\n        }\n        return parent;\n    }\n\n    private Path loggingPath(String base) {\n        return base != null ? Paths.get(loggingPath, base) : Paths.get(loggingPath);\n    }\n\n    private List<FileEntry> sortFiles(List<FileEntry> files, SortBy sortBy, boolean desc) {\n        Comparator<FileEntry> comparator = null;\n        switch (sortBy) {\n            case FILENAME:\n                comparator = (a, b) -> a.getFilename().compareTo(b.getFilename());\n                break;\n            case SIZE:\n                comparator = (a, b) -> Long.compare(a.getSize(), b.getSize());\n                break;\n            case MODIFIED:\n                comparator = (a, b) -> Long.compare(a.getModified().toMillis(), b.getModified().toMillis());\n                break;\n        }\n        List<FileEntry> sortedFiles = files.stream().sorted(comparator).collect(toList());\n\n        if (desc) {\n            Collections.reverse(sortedFiles);\n        }\n        return sortedFiles;\n    }\n\n    @RequestMapping(\"/view\")\n    public void view(@RequestParam String filename,\n                     @RequestParam(required = false) String base,\n                     @RequestParam(required = false) Integer tailLines,\n                     HttpServletResponse response) throws IOException {\n\n        Path path = loggingPath(base);\n        securityCheck(path, filename);\n        response.setContentType(MediaType.TEXT_PLAIN_VALUE);\n        FileProvider fileProvider = getFileProvider(path);\n        if (tailLines != null) {\n            fileProvider.tailContent(path, filename, response.getOutputStream(), tailLines);\n        }\n        else {\n            fileProvider.streamContent(path, filename, response.getOutputStream());\n        }\n    }\n\n    @RequestMapping(\"/search\")\n    public void search(@RequestParam String term, HttpServletResponse response) throws IOException {\n        Path folder = loggingPath(null);\n        List<FileEntry> files = getFileProvider(folder).getFileEntries(folder);\n        List<FileEntry> sortedFiles = sortFiles(files, SortBy.MODIFIED, false);\n\n        response.setContentType(MediaType.TEXT_PLAIN_VALUE);\n        ServletOutputStream outputStream = response.getOutputStream();\n\n        sortedFiles.stream()\n                .filter(file -> file.getFileType().equals(FileType.FILE))\n                .forEach(file -> searchAndStreamFile(file, term, outputStream));\n    }\n\n    private void searchAndStreamFile(FileEntry fileEntry, String term, OutputStream outputStream) {\n        Path folder = loggingPath(null);\n        try {\n            List<String> lines = IOUtils.readLines(new FileInputStream(new File(folder.toFile().toString(), fileEntry.getFilename())))\n                    .stream()\n                    .filter(line -> line.contains(term))\n                    .map(line -> \"[\" + fileEntry.getFilename() + \"] \" + line)\n                    .collect(toList());\n            for (String line : lines) {\n                outputStream.write(line.getBytes());\n                outputStream.write(System.lineSeparator().getBytes());\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"error reading file\", e);\n        }\n    }\n\n    private void securityCheck(Path base, String filename) {\n        try {\n            String canonicalLoggingPath = (filename != null ? new File(base.toFile().toString(), filename) : new File(base.toFile().toString())).getCanonicalPath();\n            String baseCanonicalPath = new File(loggingPath).getCanonicalPath();\n            String errorMessage = \"File \" + base.toString() + \"/\" + filename + \" may not be located outside base path \" + loggingPath;\n            Assert.isTrue(canonicalLoggingPath.startsWith(baseCanonicalPath), errorMessage);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override\n    public String getPath() {\n        return \"/log\";\n    }\n\n    @Override\n    public boolean isSensitive() {\n        return true;\n    }\n\n\n    @Override\n    public Class<? extends Endpoint> getEndpointType() {\n        return null;\n    }\n\n}\n", "package eu.hinsch.spring.boot.actuator.logview;\n\nimport org.apache.catalina.ssi.ByteArrayServletOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.rules.TemporaryFolder;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.springframework.ui.ExtendedModelMap;\nimport org.springframework.ui.Model;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@SuppressWarnings(\"unchecked\")\npublic class LogViewEndpointTest {\n\n    @Rule\n    public TemporaryFolder temporaryFolder = new TemporaryFolder();\n\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    @Mock\n    private HttpServletResponse response;\n\n    private LogViewEndpoint logViewEndpoint;\n\n    private Model model;\n    private long now;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        logViewEndpoint = new LogViewEndpoint(temporaryFolder.getRoot().getAbsolutePath(),\n                new LogViewEndpointAutoconfig.EndpointConfiguration().getStylesheets());\n        model = new ExtendedModelMap();\n        now = new Date().getTime();\n    }\n\n    @Test\n    public void shouldReturnEmptyFileListForEmptyDirectory() throws Exception {\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(model.containsAttribute(\"files\"), is(true));\n        assertThat(getFileEntries(), hasSize(0));\n    }\n\n    @Test\n    public void shouldListSortedByFilename() throws Exception {\n        // given\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"C.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"A.log\", \"B.log\", \"C.log\"));\n    }\n\n    @Test\n    public void shouldListReverseSortedByFilename() throws Exception {\n        // given\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"C.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, true, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"C.log\", \"B.log\", \"A.log\"));\n    }\n\n    @Test\n    public void shouldListSortedBySize() throws Exception {\n        // given\n        createFile(\"A.log\", \"xx\", now);\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"C.log\", \"xxx\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.SIZE, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"B.log\", \"A.log\", \"C.log\"));\n        assertThat(getFileSizes(), contains(1L, 2L, 3L));\n    }\n\n    @Test\n    public void shouldListSortedByDate() throws Exception {\n        // given\n        // TODO java 8 date api\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"B.log\", \"x\", now - 10 * 60 * 1000);\n        createFile(\"C.log\", \"x\", now - 5 * 60 * 1000);\n\n        // when\n        logViewEndpoint.list(model, SortBy.MODIFIED, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"B.log\", \"C.log\", \"A.log\"));\n        assertThat(getFilePrettyTimes(), contains(\"10 minutes ago\", \"5 minutes ago\", \"moments ago\"));\n    }\n\n    @Test\n    public void shouldSetFileTypeForFile() throws Exception {\n        // given\n        createFile(\"A.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileEntries().get(0).getFileType(), is(FileType.FILE));\n    }\n\n    @Test\n    public void shouldSetFileTypeForArchive() throws Exception {\n        // given\n        createFile(\"A.log.tar.gz\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileEntries().get(0).getFileType(), is(FileType.ARCHIVE));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInBaseFolder() throws Exception {\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"\"));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInSubfolder() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"subfolder\");\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"\"));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInNestedSubfolder() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n        temporaryFolder.newFolder(\"subfolder\", \"nested\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"subfolder/nested\");\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"/subfolder\"));\n    }\n\n    @Test\n    public void shouldIncludeSubfolderEntry() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFileType(), is(FileType.DIRECTORY));\n        assertThat(fileEntry.getFilename(), is(\"subfolder\"));\n    }\n\n    @Test\n    public void shouldListZipContent() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"file.zip\");\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFilename(), is(\"A.log\"));\n    }\n\n    @Test\n    public void shouldViewZipFileContent() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.zip\", null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"content\"));\n    }\n\n    private void createZipArchive(String archiveFileName, String contentFileName, String content) throws Exception {\n        try(ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(temporaryFolder.getRoot(), archiveFileName)))) {\n            ZipEntry zipEntry = new ZipEntry(contentFileName);\n            zos.putNextEntry(zipEntry);\n            IOUtils.write(content, zos);\n        }\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void shouldThrowExceptionWhenCallingTailForZip() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.zip\", 1, response);\n\n        // then -> exception\n    }\n\n    @Test\n    public void shouldListTarGzContent() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"file.tar.gz\");\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFilename(), is(\"A.log\"));\n    }\n\n    @Test\n    public void shouldViewTarGzFileContent() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.tar.gz\", null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"content\"));\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void shouldThrowExceptionWhenCallingTailForTarGz() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.tar.gz\", 1, response);\n\n        // then -> exception\n    }\n\n    private void createTarGzArchive(String archiveFileName, String contentFileName, String content) throws Exception {\n\n        try(TarArchiveOutputStream tos = new TarArchiveOutputStream(new GZIPOutputStream(\n                new BufferedOutputStream(new FileOutputStream(\n                        new File(temporaryFolder.getRoot(), archiveFileName)))))) {\n            tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\n            tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n            TarArchiveEntry archiveEntry = new TarArchiveEntry(contentFileName);\n            archiveEntry.setSize(content.length());\n            tos.putArchiveEntry(archiveEntry);\n            IOUtils.write(content, tos);\n            tos.closeArchiveEntry();\n        }\n    }\n\n    @Test\n    public void shouldRedirectWithoutTrainingSlash() throws IOException {\n        // when\n        logViewEndpoint.redirect(response);\n\n        // then\n        verify(response).sendRedirect(\"log/\");\n    }\n\n    @Test\n    public void shouldEndpointBeSensitive() {\n        assertThat(logViewEndpoint.isSensitive(), is(true));\n    }\n\n    @Test\n    public void shouldReturnContextPath() {\n        assertThat(logViewEndpoint.getPath(), is(\"/log\"));\n    }\n\n    @Test\n    public void shouldReturnNullEndpointType() {\n        assertThat(logViewEndpoint.getEndpointType(), is(nullValue()));\n    }\n\n    @Test\n    public void shouldNotAllowToListFileOutsideRoot() throws Exception {\n        // given\n        expectedException.expect(IllegalArgumentException.class);\n        expectedException.expectMessage(containsString(\"may not be located outside base path\"));\n\n        // when\n        logViewEndpoint.view(\"../somefile\", null, null, null);\n    }\n\n    @Test\n    public void shouldNotAllowToListWithBaseOutsideRoot() throws Exception {\n        // given\n        expectedException.expect(IllegalArgumentException.class);\n        expectedException.expectMessage(containsString(\"may not be located outside base path\"));\n\n        // when\n        logViewEndpoint.view(\"somefile\", \"../otherdir\", null, null);\n    }\n\n    @Test\n    public void shouldViewFile() throws Exception {\n        // given\n        createFile(\"file.log\", \"abc\", now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"file.log\", null, null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"abc\"));\n    }\n\n    @Test\n    public void shouldTailViewOnlyLastLine() throws Exception {\n        // given\n        createFile(\"file.log\", \"line1\" + System.lineSeparator() + \"line2\" + System.lineSeparator(), now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"file.log\", null, 1, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), not(containsString(\"line1\")));\n        assertThat(new String(outputStream.toByteArray()), containsString(\"line2\"));\n    }\n\n    @Test\n    public void shouldSearchInFiles() throws Exception {\n        // given\n        String sep = System.lineSeparator();\n        createFile(\"A.log\", \"A-line1\" + sep + \"A-line2\" + sep + \"A-line3\", now - 1);\n        createFile(\"B.log\", \"B-line1\" + sep + \"B-line2\" + sep + \"B-line3\", now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.search(\"line2\", response);\n\n        // then\n        String output = new String(outputStream.toByteArray());\n        assertThat(output, containsString(\"[A.log] A-line2\"));\n        assertThat(output, containsString(\"[B.log] B-line2\"));\n        assertThat(output, not(containsString(\"line1\")));\n        assertThat(output, not(containsString(\"line3\")));\n    }\n\n    private ByteArrayServletOutputStream mockResponseOutputStream() throws Exception {\n        ByteArrayServletOutputStream outputStream = new ByteArrayServletOutputStream();\n        when(response.getOutputStream()).thenReturn(outputStream);\n        return outputStream;\n    }\n\n    private List<String> getFileNames() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getFilename)\n                .collect(toList());\n    }\n\n    private List<Long> getFileSizes() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getSize)\n                .collect(toList());\n    }\n\n    private List<String> getFilePrettyTimes() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getModifiedPretty)\n                .collect(toList());\n    }\n\n    private List<FileEntry> getFileEntries() {\n        return (List<FileEntry>) model.asMap().get(\"files\");\n    }\n\n    private void createFile(String filename, String content, long modified) throws Exception {\n        File file = new File(temporaryFolder.getRoot(), filename);\n        FileUtils.write(file, content);\n        assertThat(file.setLastModified(modified), is(true));\n    }\n\n}"], "filenames": [".gitignore", ".travis.yml", "lib/src/main/java/eu/hinsch/spring/boot/actuator/logview/LogViewEndpoint.java", "lib/src/test/java/eu/hinsch/spring/boot/actuator/logview/LogViewEndpointTest.java"], "buggy_code_start_loc": [4, 3, 63, 333], "buggy_code_end_loc": [4, 4, 176, 336], "fixing_code_start_loc": [5, 3, 62, 333], "fixing_code_end_loc": [6, 4, 183, 347], "type": "CWE-22", "message": "spring-boot-actuator-logview in a library that adds a simple logfile viewer as spring boot actuator endpoint. It is maven package \"eu.hinsch:spring-boot-actuator-logview\". In spring-boot-actuator-logview before version 0.2.13 there is a directory traversal vulnerability. The nature of this library is to expose a log file directory via admin (spring boot actuator) HTTP endpoints. Both the filename to view and a base folder (relative to the logging folder root) can be specified via request parameters. While the filename parameter was checked to prevent directory traversal exploits (so that `filename=../somefile` would not work), the base folder parameter was not sufficiently checked, so that `filename=somefile&base=../` could access a file outside the logging base directory). The vulnerability has been patched in release 0.2.13. Any users of 0.2.12 should be able to update without any issues as there are no other changes in that release. There is no workaround to fix the vulnerability other than updating or removing the dependency. However, removing read access of the user the application is run with to any directory not required for running the application can limit the impact. Additionally, access to the logview endpoint can be limited by deploying the application behind a reverse proxy.", "other": {"cve": {"id": "CVE-2021-21234", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-05T18:15:16.443", "lastModified": "2021-01-11T14:41:27.680", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "spring-boot-actuator-logview in a library that adds a simple logfile viewer as spring boot actuator endpoint. It is maven package \"eu.hinsch:spring-boot-actuator-logview\". In spring-boot-actuator-logview before version 0.2.13 there is a directory traversal vulnerability. The nature of this library is to expose a log file directory via admin (spring boot actuator) HTTP endpoints. Both the filename to view and a base folder (relative to the logging folder root) can be specified via request parameters. While the filename parameter was checked to prevent directory traversal exploits (so that `filename=../somefile` would not work), the base folder parameter was not sufficiently checked, so that `filename=somefile&base=../` could access a file outside the logging base directory). The vulnerability has been patched in release 0.2.13. Any users of 0.2.12 should be able to update without any issues as there are no other changes in that release. There is no workaround to fix the vulnerability other than updating or removing the dependency. However, removing read access of the user the application is run with to any directory not required for running the application can limit the impact. Additionally, access to the logview endpoint can be limited by deploying the application behind a reverse proxy."}, {"lang": "es", "value": "spring-boot-actuator-logview en una biblioteca que agrega un visualizador de archivo de registro simple como endpoint del actuador de arranque de resorte.&#xa0;Es el paquete maven \"eu.hinsch: spring-boot-actuator-logview\".&#xa0;En spring-boot-actuator-logview antes de la versi\u00f3n 0.2.13 se presenta una vulnerabilidad de salto de directorio.&#xa0;La naturaleza de esta biblioteca es exponer un directorio de archivos de registro por medio de los endpoints HTTP de administraci\u00f3n (actuador de arranque de resorte).&#xa0;Tanto el nombre del archivo a visualizar como una carpeta base (relativa a la carpeta root de registro) se pueden especificar mediante par\u00e1metros de petici\u00f3n.&#xa0;Si bien el par\u00e1metro filename se verific\u00f3 para impedir la explotaci\u00f3n del salto de directorio (de modo que \"filename=../somefile\" no funcionar\u00eda), el par\u00e1metro base folder no se verific\u00f3 lo suficiente, por lo que \"filename=somefile&amp;base=..\" podr\u00eda acceder a un archivo fuera del directorio base del registro).&#xa0;La vulnerabilidad se corrigi\u00f3 en la versi\u00f3n 0.2.13.&#xa0;Cualquier usuario de la versi\u00f3n 0.2.12 deber\u00eda poder actualizar sin ning\u00fan problema, ya que no existen otros cambios en esa versi\u00f3n.&#xa0;No existe una soluci\u00f3n alternativa para corregir la vulnerabilidad que no sea actualizar o eliminar la dependencia.&#xa0;Sin embargo, eliminar el acceso de lectura del usuario con el que se ejecuta la aplicaci\u00f3n en cualquier directorio que no sea necesario para ejecutar la aplicaci\u00f3n puede limitar el impacto.&#xa0;Adem\u00e1s, el acceso al endpoint de Logview se puede limitar mediante la implementaci\u00f3n de la aplicaci\u00f3n detr\u00e1s de un proxy inverso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:spring-boot-actuator-logview_project:spring-boot-actuator-logview:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.2.12", "matchCriteriaId": "F31F6783-0E0D-4F91-ACD2-E67BE0A13201"}]}]}], "references": [{"url": "https://github.com/lukashinsch/spring-boot-actuator-logview/commit/1c76e1ec3588c9f39e1a94bf27b5ff56eb8b17d6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lukashinsch/spring-boot-actuator-logview/commit/760acbb939a8d1f7d1a7dfcd51ca848eea04e772", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lukashinsch/spring-boot-actuator-logview/security/advisories/GHSA-p4q6-qxjx-8jgp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://search.maven.org/artifact/eu.hinsch/spring-boot-actuator-logview", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lukashinsch/spring-boot-actuator-logview/commit/1c76e1ec3588c9f39e1a94bf27b5ff56eb8b17d6"}}