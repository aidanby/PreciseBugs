{"buggy_code": ["/* radare - LGPL - Copyright 2010-2016 - nibble, pancake  */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"dyldcache.h\"\n\nstatic int r_bin_dyldcache_init(struct r_bin_dyldcache_obj_t* bin) {\n\tint len = r_buf_fread_at (bin->b, 0, (ut8*)&bin->hdr, \"16c4i7l\", 1);\n\tif (len == -1) {\n\t\tperror (\"read (cache_header)\");\n\t\treturn false;\n\t}\n\tbin->nlibs = bin->hdr.numlibs;\n\treturn true;\n}\n\nstatic int r_bin_dyldcache_apply_patch (struct r_buf_t* buf, ut32 data, ut64 offset) {\n\treturn r_buf_write_at (buf, offset, (ut8*)&data, sizeof (data));\n}\n\n#define NZ_OFFSET(x) if((x) > 0) r_bin_dyldcache_apply_patch (dbuf, (x) - linkedit_offset, (ut64)((size_t)&(x) - (size_t)data))\n\n/* TODO: Needs more testing and ERROR HANDLING */\nstruct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj_t* bin, int idx, int *nlib) {\n\tut64 liboff, linkedit_offset;\n\tut64 dyld_vmbase;\n\tut32 addend = 0;\n\tstruct r_bin_dyldcache_lib_t *ret = NULL;\n\tstruct dyld_cache_image_info* image_infos = NULL;\n\tstruct mach_header *mh;\n\tut8 *data, *cmdptr;\n\tint cmd, libsz = 0;\n\tRBuffer* dbuf;\n\tchar *libname;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->size < 1) {\n\t\teprintf (\"Empty file? (%s)\\n\", bin->file? bin->file: \"(null)\");\n\t\treturn NULL;\n\t}\n\tif (bin->nlibs < 0 || idx < 0 || idx >= bin->nlibs) {\n\t\treturn NULL;\n\t}\n\t*nlib = bin->nlibs;\n\tret = R_NEW0 (struct r_bin_dyldcache_lib_t);\n\tif (!ret) {\n\t\tperror (\"malloc (ret)\");\n\t\treturn NULL;\n\t}\n\tif (bin->hdr.startaddr > bin->size) {\n\t    \teprintf (\"corrupted dyldcache\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tif (bin->hdr.startaddr > bin->size || bin->hdr.baseaddroff > bin->size) {\n\t\teprintf (\"corrupted dyldcache\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\timage_infos = (struct dyld_cache_image_info*) (bin->b->buf + bin->hdr.startaddr);\n\tdyld_vmbase = *(ut64 *)(bin->b->buf + bin->hdr.baseaddroff);\n\tliboff = image_infos[idx].address - dyld_vmbase;\n\tif (liboff > bin->size) {\n\t\teprintf (\"Corrupted file\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->offset = liboff;\n\tif (image_infos[idx].pathFileOffset > bin->size) {\n\t    eprintf (\"corrupted file\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tlibname = (char *)(bin->b->buf + image_infos[idx].pathFileOffset);\n\t/* Locate lib hdr in cache */\n\tdata = bin->b->buf + liboff;\n\tmh = (struct mach_header *)data;\n\t/* Check it is mach-o */\n\tif (mh->magic != MH_MAGIC && mh->magic != MH_MAGIC_64) {\n\t\tif (mh->magic == 0xbebafeca) { //FAT binary\n\t\t\teprintf (\"FAT Binary\\n\");\n\t\t}\n\t\teprintf (\"Not mach-o\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\t/* Write mach-o hdr */\n\tif (!(dbuf = r_buf_new ())) {\n\t\teprintf (\"new (dbuf)\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\taddend = mh->magic == MH_MAGIC? sizeof (struct mach_header) : sizeof (struct mach_header_64);\n\tr_buf_set_bytes (dbuf, data, addend);\n\tcmdptr = data + addend;\n\t/* Write load commands */\n\tfor (cmd = 0; cmd < mh->ncmds; cmd++) {\n\t\tstruct load_command *lc = (struct load_command *)cmdptr;\n\t\tr_buf_append_bytes (dbuf, (ut8*)lc, lc->cmdsize);\n\t\tcmdptr += lc->cmdsize;\n\t}\n\tcmdptr = data + addend;\n\t/* Write segments */\n\tfor (cmd = linkedit_offset = 0; cmd < mh->ncmds; cmd++) {\n\t\tstruct load_command *lc = (struct load_command *)cmdptr;\n\t\tcmdptr += lc->cmdsize;\n\t\tswitch (lc->cmd) {\n\t\tcase LC_SEGMENT:\n\t\t\t{\n\t\t\t/* Write segment and patch offset */\n\t\t\tstruct segment_command *seg = (struct segment_command *)lc;\n\t\t\tint t = seg->filesize;\n\t\t\tif (seg->fileoff + seg->filesize > bin->size || seg->fileoff > bin->size) {\n\t\t\t\teprintf (\"malformed dyldcache\\n\");\n\t\t\t\tfree (ret);\n\t\t\t\tr_buf_free (dbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_buf_append_bytes (dbuf, bin->b->buf+seg->fileoff, t);\n\t\t\tr_bin_dyldcache_apply_patch (dbuf, dbuf->length, (ut64)((size_t)&seg->fileoff - (size_t)data));\n\t\t\t/* Patch section offsets */\n\t\t\tint sect_offset = seg->fileoff - libsz;\n\t\t\tlibsz = dbuf->length;\n\t\t\tif (!strcmp (seg->segname, \"__LINKEDIT\")) {\n\t\t\t\tlinkedit_offset = sect_offset;\n\t\t\t}\n\t\t\tif (seg->nsects > 0) {\n\t\t\t\tstruct section *sects = (struct section *)((ut8 *)seg + sizeof(struct segment_command));\n\t\t\t\tint nsect;\n\t\t\t\tfor (nsect = 0; nsect < seg->nsects; nsect++) {\n\t\t\t\t\tif (sects[nsect].offset > libsz) {\n\t\t\t\t\t\tr_bin_dyldcache_apply_patch (dbuf, sects[nsect].offset - sect_offset,\n\t\t\t\t\t\t\t(ut64)((size_t)&sects[nsect].offset - (size_t)data));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\t{\n\t\t\tstruct symtab_command *st = (struct symtab_command *)lc;\n\t\t\tNZ_OFFSET (st->symoff);\n\t\t\tNZ_OFFSET (st->stroff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\t{\n\t\t\tstruct dysymtab_command *st = (struct dysymtab_command *)lc;\n\t\t\tNZ_OFFSET (st->tocoff);\n\t\t\tNZ_OFFSET (st->modtaboff);\n\t\t\tNZ_OFFSET (st->extrefsymoff);\n\t\t\tNZ_OFFSET (st->indirectsymoff);\n\t\t\tNZ_OFFSET (st->extreloff);\n\t\t\tNZ_OFFSET (st->locreloff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tstruct dyld_info_command *st = (struct dyld_info_command *)lc;\n\t\t\tNZ_OFFSET (st->rebase_off);\n\t\t\tNZ_OFFSET (st->bind_off);\n\t\t\tNZ_OFFSET (st->weak_bind_off);\n\t\t\tNZ_OFFSET (st->lazy_bind_off);\n\t\t\tNZ_OFFSET (st->export_off);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Fill r_bin_dyldcache_lib_t ret */\n\tret->b = dbuf;\n\tstrncpy (ret->path, libname, sizeof (ret->path) - 1);\n\tret->size = libsz;\n\treturn ret;\n}\n\nvoid* r_bin_dyldcache_free(struct r_bin_dyldcache_obj_t* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tr_buf_free (bin->b);\n\tfree (bin);\n\treturn NULL;\n}\n\nvoid r_bin_dydlcache_get_libname(struct r_bin_dyldcache_lib_t *lib, char **libname) {\n\tchar *cur = lib->path;\n\tchar *res = lib->path;\n\tint path_length = strlen (lib->path);\n\twhile (cur < cur + path_length - 1) {\n\t\tcur = strchr (cur, '/');\n\t\tif (!cur) {\n\t\t\tbreak;\n\t\t}\n\t\tcur++;\n\t\tres = cur;\n\t}\n\t*libname = res;\n}\n\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_new(const char* file) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tut8 *buf;\n\tif (!(bin = R_NEW0 (struct r_bin_dyldcache_obj_t))) {\n\t\treturn NULL;\n\t}\n\tbin->file = file;\n\tif (!(buf = (ut8*)r_file_slurp (file, &bin->size))) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tfree (buf);\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\treturn bin;\n}\n\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2018 - nibble, pancake  */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"dyldcache.h\"\n\nstatic int r_bin_dyldcache_init(struct r_bin_dyldcache_obj_t* bin) {\n\tint len = r_buf_fread_at (bin->b, 0, (ut8*)&bin->hdr, \"16c4i7l\", 1);\n\tif (len == -1) {\n\t\tperror (\"read (cache_header)\");\n\t\treturn false;\n\t}\n\tbin->nlibs = bin->hdr.numlibs;\n\treturn true;\n}\n\nstatic int r_bin_dyldcache_apply_patch (struct r_buf_t* buf, ut32 data, ut64 offset) {\n\treturn r_buf_write_at (buf, offset, (ut8*)&data, sizeof (data));\n}\n\n#define NZ_OFFSET(x) if((x) > 0) r_bin_dyldcache_apply_patch (dbuf, (x) - linkedit_offset, (ut64)((size_t)&(x) - (size_t)data))\n\n// make it public in util/buf.c ?\nstatic ut64 r_buf_read64le (RBuffer *buf, ut64 off) {\n\tut8 data[8] = {0};\n\tr_buf_read_at (buf, off, data, 8);\n\treturn r_read_le64 (data);\n}\n\nstatic char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {\n\tut8 *data = malloc (len);\n\tif (data) {\n\t\tr_buf_read_at (buf, addr, data, len);\n\t\tdata[len-1] = 0;\n\t\treturn data;\n\t}\n\treturn NULL;\n}\n\n/* TODO: Needs more testing and ERROR HANDLING */\nstruct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj_t* bin, int idx, int *nlib) {\n\tut64 liboff, linkedit_offset;\n\tut64 dyld_vmbase;\n\tut32 addend = 0;\n\tstruct r_bin_dyldcache_lib_t *ret = NULL;\n\tstruct dyld_cache_image_info* image_infos = NULL;\n\tstruct mach_header *mh;\n\tut8 *data, *cmdptr;\n\tint cmd, libsz = 0;\n\tRBuffer* dbuf;\n\tchar *libname;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->size < 1) {\n\t\teprintf (\"Empty file? (%s)\\n\", bin->file? bin->file: \"(null)\");\n\t\treturn NULL;\n\t}\n\tif (bin->nlibs < 0 || idx < 0 || idx >= bin->nlibs) {\n\t\treturn NULL;\n\t}\n\t*nlib = bin->nlibs;\n\tret = R_NEW0 (struct r_bin_dyldcache_lib_t);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (bin->hdr.startaddr > bin->size) {\n\t    \teprintf (\"corrupted dyldcache\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\n\tif (bin->hdr.startaddr > bin->size || bin->hdr.baseaddroff > bin->size) {\n\t\teprintf (\"corrupted dyldcache\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tint sz = bin->nlibs * sizeof (struct dyld_cache_image_info);\n\timage_infos = malloc (sz); //(struct dyld_cache_image_info*) (bin->b->buf + bin->hdr.startaddr);\n\tif (!image_infos) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->b, bin->hdr.startaddr, (ut8*)image_infos, sz);\n\tdyld_vmbase = r_buf_read64le (bin->b, bin->hdr.baseaddroff);\n\tliboff = image_infos[idx].address - dyld_vmbase;\n\tif (liboff > bin->size) {\n\t\teprintf (\"Corrupted file\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->offset = liboff;\n\tint pfo = image_infos[idx].pathFileOffset;\n\tif (pfo < 0 || pfo > bin->size) {\n\t\teprintf (\"corrupted file: pathFileOffset > bin->size (%d)\\n\", pfo);\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tlibname = r_buf_read_string (bin->b, pfo, 64);\n\t/* Locate lib hdr in cache */\n\tdata = bin->b->buf + liboff;\n\tmh = (struct mach_header *)data;\n\t/* Check it is mach-o */\n\tif (mh->magic != MH_MAGIC && mh->magic != MH_MAGIC_64) {\n\t\tif (mh->magic == 0xbebafeca) { //FAT binary\n\t\t\teprintf (\"FAT Binary\\n\");\n\t\t}\n\t\teprintf (\"Not mach-o\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\t/* Write mach-o hdr */\n\tif (!(dbuf = r_buf_new ())) {\n\t\teprintf (\"new (dbuf)\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\taddend = mh->magic == MH_MAGIC? sizeof (struct mach_header) : sizeof (struct mach_header_64);\n\tr_buf_set_bytes (dbuf, data, addend);\n\tcmdptr = data + addend;\n\t/* Write load commands */\n\tfor (cmd = 0; cmd < mh->ncmds; cmd++) {\n\t\tstruct load_command *lc = (struct load_command *)cmdptr;\n\t\tr_buf_append_bytes (dbuf, (ut8*)lc, lc->cmdsize);\n\t\tcmdptr += lc->cmdsize;\n\t}\n\tcmdptr = data + addend;\n\t/* Write segments */\n\tfor (cmd = linkedit_offset = 0; cmd < mh->ncmds; cmd++) {\n\t\tstruct load_command *lc = (struct load_command *)cmdptr;\n\t\tcmdptr += lc->cmdsize;\n\t\tswitch (lc->cmd) {\n\t\tcase LC_SEGMENT:\n\t\t\t{\n\t\t\t/* Write segment and patch offset */\n\t\t\tstruct segment_command *seg = (struct segment_command *)lc;\n\t\t\tint t = seg->filesize;\n\t\t\tif (seg->fileoff + seg->filesize > bin->size || seg->fileoff > bin->size) {\n\t\t\t\teprintf (\"malformed dyldcache\\n\");\n\t\t\t\tfree (ret);\n\t\t\t\tr_buf_free (dbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_buf_append_bytes (dbuf, bin->b->buf+seg->fileoff, t);\n\t\t\tr_bin_dyldcache_apply_patch (dbuf, dbuf->length, (ut64)((size_t)&seg->fileoff - (size_t)data));\n\t\t\t/* Patch section offsets */\n\t\t\tint sect_offset = seg->fileoff - libsz;\n\t\t\tlibsz = dbuf->length;\n\t\t\tif (!strcmp (seg->segname, \"__LINKEDIT\")) {\n\t\t\t\tlinkedit_offset = sect_offset;\n\t\t\t}\n\t\t\tif (seg->nsects > 0) {\n\t\t\t\tstruct section *sects = (struct section *)((ut8 *)seg + sizeof(struct segment_command));\n\t\t\t\tint nsect;\n\t\t\t\tfor (nsect = 0; nsect < seg->nsects; nsect++) {\n\t\t\t\t\tif (sects[nsect].offset > libsz) {\n\t\t\t\t\t\tr_bin_dyldcache_apply_patch (dbuf, sects[nsect].offset - sect_offset,\n\t\t\t\t\t\t\t(ut64)((size_t)&sects[nsect].offset - (size_t)data));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\t{\n\t\t\tstruct symtab_command *st = (struct symtab_command *)lc;\n\t\t\tNZ_OFFSET (st->symoff);\n\t\t\tNZ_OFFSET (st->stroff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\t{\n\t\t\tstruct dysymtab_command *st = (struct dysymtab_command *)lc;\n\t\t\tNZ_OFFSET (st->tocoff);\n\t\t\tNZ_OFFSET (st->modtaboff);\n\t\t\tNZ_OFFSET (st->extrefsymoff);\n\t\t\tNZ_OFFSET (st->indirectsymoff);\n\t\t\tNZ_OFFSET (st->extreloff);\n\t\t\tNZ_OFFSET (st->locreloff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tstruct dyld_info_command *st = (struct dyld_info_command *)lc;\n\t\t\tNZ_OFFSET (st->rebase_off);\n\t\t\tNZ_OFFSET (st->bind_off);\n\t\t\tNZ_OFFSET (st->weak_bind_off);\n\t\t\tNZ_OFFSET (st->lazy_bind_off);\n\t\t\tNZ_OFFSET (st->export_off);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Fill r_bin_dyldcache_lib_t ret */\n\tret->b = dbuf;\n\tstrncpy (ret->path, libname, sizeof (ret->path) - 1);\n\tret->size = libsz;\n\treturn ret;\n}\n\nvoid* r_bin_dyldcache_free(struct r_bin_dyldcache_obj_t* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tr_buf_free (bin->b);\n\tfree (bin);\n\treturn NULL;\n}\n\nvoid r_bin_dydlcache_get_libname(struct r_bin_dyldcache_lib_t *lib, char **libname) {\n\tchar *cur = lib->path;\n\tchar *res = lib->path;\n\tint path_length = strlen (lib->path);\n\twhile (cur < cur + path_length - 1) {\n\t\tcur = strchr (cur, '/');\n\t\tif (!cur) {\n\t\t\tbreak;\n\t\t}\n\t\tcur++;\n\t\tres = cur;\n\t}\n\t*libname = res;\n}\n\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_new(const char* file) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tut8 *buf;\n\tif (!(bin = R_NEW0 (struct r_bin_dyldcache_obj_t))) {\n\t\treturn NULL;\n\t}\n\tbin->file = file;\n\tif (!(buf = (ut8*)r_file_slurp (file, &bin->size))) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tfree (buf);\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\treturn bin;\n}\n\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin = R_NEW0 (struct r_bin_dyldcache_obj_t);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!bin->b || !r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}\n"], "filenames": ["libr/bin/format/mach0/dyldcache.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [237], "fixing_code_start_loc": [1], "fixing_code_end_loc": [260], "type": "CWE-125", "message": "In radare2 prior to 3.1.1, r_bin_dyldcache_extract in libr/bin/format/mach0/dyldcache.c may allow attackers to cause a denial-of-service (application crash caused by out-of-bounds read) by crafting an input file.", "other": {"cve": {"id": "CVE-2018-20458", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-25T19:29:00.417", "lastModified": "2020-10-15T16:14:36.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In radare2 prior to 3.1.1, r_bin_dyldcache_extract in libr/bin/format/mach0/dyldcache.c may allow attackers to cause a denial-of-service (application crash caused by out-of-bounds read) by crafting an input file."}, {"lang": "es", "value": "En radare2 en versiones anteriores a la 3.1.1, r_bin_dyldcache_extract en libr/bin/format/mach0/dyldcache.c podr\u00eda permitir que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n provocado por una lectura fuera de l\u00edmites) manipulando un archivo de entradas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.1", "matchCriteriaId": "92DD0821-889B-4ED8-A24C-1F244A4522A1"}]}]}], "references": [{"url": "https://github.com/radare/radare2/issues/12374", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/commit/30f4c7b52a4e2dc0d0b1bae487d90f5437c69d19", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/30f4c7b52a4e2dc0d0b1bae487d90f5437c69d19"}}