{"buggy_code": ["import Users from '/imports/api/users';\nimport Logger from '/imports/startup/server/logger';\n\nconst MSG_DIRECT_TYPE = 'DIRECT';\nconst NODE_USER = 'nodeJSapp';\n\nexport const spokeTimeoutHandles = {};\nexport const clearSpokeTimeout = (meetingId, userId) => {\n  if (spokeTimeoutHandles[`${meetingId}-${userId}`]) {\n    Meteor.clearTimeout(spokeTimeoutHandles[`${meetingId}-${userId}`]);\n    delete spokeTimeoutHandles[`${meetingId}-${userId}`];\n  }\n};\n\nexport const indexOf = [].indexOf || function (item) {\n  for (let i = 0, l = this.length; i < l; i += 1) {\n    if (i in this && this[i] === item) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nexport const processForHTML5ServerOnly = (fn) => async (message, ...args) => {\n  const { envelope } = message;\n  const { routing } = envelope;\n  const { msgType, meetingId, userId } = routing;\n\n  const selector = {\n    userId,\n    meetingId,\n  };\n\n  const user = await Users.findOneAsync(selector);\n\n  const shouldSkip = user && msgType === MSG_DIRECT_TYPE && userId !== NODE_USER && user.clientType !== 'HTML5';\n  if (shouldSkip) return () => { };\n  return fn(message, ...args);\n};\n\nexport const extractCredentials = (credentials) => {\n  if (!credentials) return {};\n  const credentialsArray = credentials.split('--');\n  const meetingId = credentialsArray[0];\n  const requesterUserId = credentialsArray[1];\n  return { meetingId, requesterUserId };\n};\n\n// Creates a background job to periodically check the result of the provided function.\n// The provided function is publication-specific and must check the \"survival condition\" of the publication.\nexport const publicationSafeGuard = function (fn, self) {\n  let stopped = false;\n  const periodicCheck = async function () {\n    if (stopped) return;\n    const result = await fn();\n    if (!result) {\n      self.added(self._name, 'publication-stop-marker', { id: 'publication-stop-marker', stopped: true });\n      self.stop();\n    } else Meteor.setTimeout(periodicCheck, 1000);\n  };\n\n  self.onStop(() => {\n    stopped = true;\n    Logger.info(`Publication ${self._name} has stopped in server side`);\n  });\n\n  periodicCheck();\n};\n", "import { Meteor } from 'meteor/meteor';\nimport { check } from 'meteor/check';\nimport RedisPubSub from '/imports/startup/server/redis';\nimport RegexWebUrl from '/imports/utils/regex-weburl';\nimport { extractCredentials } from '/imports/api/common/server/helpers';\nimport Logger from '/imports/startup/server/logger';\n\nconst HTML_SAFE_MAP = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\n\nconst parseMessage = (message) => {\n  let parsedMessage = message || '';\n  parsedMessage = parsedMessage.trim();\n\n  // Replace <br/> with \\n\\r\n  parsedMessage = parsedMessage.replace(/<br\\s*[\\\\/]?>/gi, '\\n\\r');\n\n  // Sanitize. See: http://shebang.brandonmintern.com/foolproof-html-escaping-in-javascript/\n  parsedMessage = parsedMessage.replace(/[<>'\"]/g, (c) => HTML_SAFE_MAP[c]);\n\n  // Replace flash links to flash valid ones\n  parsedMessage = parsedMessage.replace(RegexWebUrl, \"<a href='event:$&'><u>$&</u></a>\");\n\n  return parsedMessage;\n};\n\nexport default function sendGroupChatMsg(chatId, message) {\n  const REDIS_CONFIG = Meteor.settings.private.redis;\n  const CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\n  const EVENT_NAME = 'SendGroupChatMessageMsg';\n\n  try {\n    const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n    check(meetingId, String);\n    check(requesterUserId, String);\n    check(chatId, String);\n    check(message, Object);\n    const parsedMessage = parseMessage(message.message);\n    message.message = parsedMessage;\n\n    const payload = {\n      msg: message,\n      chatId,\n    };\n\n    RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n  } catch (err) {\n    Logger.error(`Exception while invoking method sendGroupChatMsg ${err.stack}`);\n  }\n}\n", "import { GroupChatMsg } from '/imports/api/group-chat-msg';\nimport GroupChat from '/imports/api/group-chat';\nimport Logger from '/imports/startup/server/logger';\nimport flat from 'flat';\nimport { parseMessage } from './addGroupChatMsg';\n\nexport default async function addBulkGroupChatMsgs(msgs) {\n  if (!msgs.length) return;\n\n  const mappedMsgs = msgs\n    .map(({ chatId, meetingId, msg }) => {\n      const {\n        sender,\n        ...restMsg\n      } = msg;\n\n      return {\n        _id: new Mongo.ObjectID()._str,\n        ...restMsg,\n        meetingId,\n        chatId,\n        message: parseMessage(msg.message),\n        sender: sender.id,\n        senderName: sender.name,\n        senderRole: sender.role,\n      };\n    })\n    .map((el) => flat(el, { safe: true }))\n    .map((msg)=>{\n      const groupChat = GroupChat.findOne({ meetingId: msg.meetingId, chatId: msg.chatId });\n      return {\n        ...msg,\n        participants: [...groupChat.users],\n      };\n    });\n\n  try {\n    const { insertedCount } = await GroupChatMsg.rawCollection().insertMany(mappedMsgs);\n    msgs.length = 0;\n\n    if (insertedCount) {\n      Logger.info(`Inserted ${insertedCount} messages`);\n    }\n  } catch (err) {\n    Logger.error(`Error on bulk insert. ${err}`);\n  }\n}\n", "import { Meteor } from 'meteor/meteor';\nimport { check } from 'meteor/check';\nimport RedisPubSub from '/imports/startup/server/redis';\nimport Logger from '/imports/startup/server/logger';\nimport { extractCredentials } from '/imports/api/common/server/helpers';\n\nconst REDIS_CONFIG = Meteor.settings.private.redis;\nconst CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\nconst EVENT_NAME = 'SetGuestLobbyMessageCmdMsg';\n\nexport default function setGuestLobbyMessage(message) {\n  try {\n    check(message, String);\n\n    const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n    check(meetingId, String);\n    check(requesterUserId, String);\n\n    const payload = { message };\n\n    Logger.info(`User=${requesterUserId} set guest lobby message to ${message}`);\n\n    RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n  } catch (err) {\n    Logger.error(`Exception while invoking method setGuestLobbyMessage ${err.stack}`);\n  }\n}\n", "import { Meteor } from 'meteor/meteor';\nimport { check } from 'meteor/check';\nimport RedisPubSub from '/imports/startup/server/redis';\nimport Logger from '/imports/startup/server/logger';\nimport { extractCredentials } from '/imports/api/common/server/helpers';\n\nconst REDIS_CONFIG = Meteor.settings.private.redis;\nconst CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\nconst EVENT_NAME = 'SetPrivateGuestLobbyMessageCmdMsg';\n\nexport default function setPrivateGuestLobbyMessage(message, guestId) {\n  check(message, String);\n  check(guestId, String);\n\n  const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n  check(meetingId, String);\n  check(requesterUserId, String);\n\n  const payload = { guestId, message };\n\n  Logger.info(`User=${requesterUserId} sent a private guest lobby message to guest user=${guestId}`);\n\n  return RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n}\n\n"], "fixing_code": ["import Users from '/imports/api/users';\nimport Logger from '/imports/startup/server/logger';\nimport RegexWebUrl from '/imports/utils/regex-weburl';\n\nconst MSG_DIRECT_TYPE = 'DIRECT';\nconst NODE_USER = 'nodeJSapp';\n\nconst HTML_SAFE_MAP = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\n\nexport const parseMessage = (message) => {\n  let parsedMessage = message || '';\n  parsedMessage = parsedMessage.trim();\n\n  // Replace <br/> with \\n\\r\n  parsedMessage = parsedMessage.replace(/<br\\s*[\\\\/]?>/gi, '\\n\\r');\n\n  // Sanitize. See: http://shebang.brandonmintern.com/foolproof-html-escaping-in-javascript/\n  parsedMessage = parsedMessage.replace(/[<>'\"]/g, (c) => HTML_SAFE_MAP[c]);\n\n  // Replace flash links to flash valid ones\n  parsedMessage = parsedMessage.replace(RegexWebUrl, \"<a href='event:$&'><u>$&</u></a>\");\n\n  return parsedMessage;\n};\n\n\nexport const spokeTimeoutHandles = {};\nexport const clearSpokeTimeout = (meetingId, userId) => {\n  if (spokeTimeoutHandles[`${meetingId}-${userId}`]) {\n    Meteor.clearTimeout(spokeTimeoutHandles[`${meetingId}-${userId}`]);\n    delete spokeTimeoutHandles[`${meetingId}-${userId}`];\n  }\n};\n\nexport const indexOf = [].indexOf || function (item) {\n  for (let i = 0, l = this.length; i < l; i += 1) {\n    if (i in this && this[i] === item) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nexport const processForHTML5ServerOnly = (fn) => async (message, ...args) => {\n  const { envelope } = message;\n  const { routing } = envelope;\n  const { msgType, meetingId, userId } = routing;\n\n  const selector = {\n    userId,\n    meetingId,\n  };\n\n  const user = await Users.findOneAsync(selector);\n\n  const shouldSkip = user && msgType === MSG_DIRECT_TYPE && userId !== NODE_USER && user.clientType !== 'HTML5';\n  if (shouldSkip) return () => { };\n  return fn(message, ...args);\n};\n\nexport const extractCredentials = (credentials) => {\n  if (!credentials) return {};\n  const credentialsArray = credentials.split('--');\n  const meetingId = credentialsArray[0];\n  const requesterUserId = credentialsArray[1];\n  return { meetingId, requesterUserId };\n};\n\n// Creates a background job to periodically check the result of the provided function.\n// The provided function is publication-specific and must check the \"survival condition\" of the publication.\nexport const publicationSafeGuard = function (fn, self) {\n  let stopped = false;\n  const periodicCheck = async function () {\n    if (stopped) return;\n    const result = await fn();\n    if (!result) {\n      self.added(self._name, 'publication-stop-marker', { id: 'publication-stop-marker', stopped: true });\n      self.stop();\n    } else Meteor.setTimeout(periodicCheck, 1000);\n  };\n\n  self.onStop(() => {\n    stopped = true;\n    Logger.info(`Publication ${self._name} has stopped in server side`);\n  });\n\n  periodicCheck();\n};\n", "import { Meteor } from 'meteor/meteor';\nimport { check } from 'meteor/check';\nimport RedisPubSub from '/imports/startup/server/redis';\n\nimport { extractCredentials, parseMessage } from '/imports/api/common/server/helpers';\nimport Logger from '/imports/startup/server/logger';\n\nexport default function sendGroupChatMsg(chatId, message) {\n  const REDIS_CONFIG = Meteor.settings.private.redis;\n  const CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\n  const EVENT_NAME = 'SendGroupChatMessageMsg';\n\n  try {\n    const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n    check(meetingId, String);\n    check(requesterUserId, String);\n    check(chatId, String);\n    check(message, Object);\n    const parsedMessage = parseMessage(message.message);\n    message.message = parsedMessage;\n\n    const payload = {\n      msg: message,\n      chatId,\n    };\n\n    RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n  } catch (err) {\n    Logger.error(`Exception while invoking method sendGroupChatMsg ${err.stack}`);\n  }\n}\n", "import { GroupChatMsg } from '/imports/api/group-chat-msg';\nimport GroupChat from '/imports/api/group-chat';\nimport Logger from '/imports/startup/server/logger';\nimport flat from 'flat';\nimport { parseMessage } from '/imports/api/common/server/helpers';\n\nexport default async function addBulkGroupChatMsgs(msgs) {\n  if (!msgs.length) return;\n\n  const mappedMsgs = msgs\n    .map(({ chatId, meetingId, msg }) => {\n      const {\n        sender,\n        ...restMsg\n      } = msg;\n\n      return {\n        _id: new Mongo.ObjectID()._str,\n        ...restMsg,\n        meetingId,\n        chatId,\n        message: parseMessage(msg.message),\n        sender: sender.id,\n        senderName: sender.name,\n        senderRole: sender.role,\n      };\n    })\n    .map((el) => flat(el, { safe: true }))\n    .map((msg)=>{\n      const groupChat = GroupChat.findOne({ meetingId: msg.meetingId, chatId: msg.chatId });\n      return {\n        ...msg,\n        participants: [...groupChat.users],\n      };\n    });\n\n  try {\n    const { insertedCount } = await GroupChatMsg.rawCollection().insertMany(mappedMsgs);\n    msgs.length = 0;\n\n    if (insertedCount) {\n      Logger.info(`Inserted ${insertedCount} messages`);\n    }\n  } catch (err) {\n    Logger.error(`Error on bulk insert. ${err}`);\n  }\n}\n", "import { Meteor } from 'meteor/meteor';\nimport { check } from 'meteor/check';\nimport RedisPubSub from '/imports/startup/server/redis';\nimport Logger from '/imports/startup/server/logger';\nimport { extractCredentials, parseMessage } from '/imports/api/common/server/helpers';\n\nconst REDIS_CONFIG = Meteor.settings.private.redis;\nconst CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\nconst EVENT_NAME = 'SetGuestLobbyMessageCmdMsg';\n\nexport default function setGuestLobbyMessage(message) {\n  try {\n    check(message, String);\n\n    const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n    check(meetingId, String);\n    check(requesterUserId, String);\n    const payload = { message: parseMessage(message) };\n\n    Logger.info(`User=${requesterUserId} set guest lobby message to ${message}`);\n\n    RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n  } catch (err) {\n    Logger.error(`Exception while invoking method setGuestLobbyMessage ${err.stack}`);\n  }\n}\n", "import { Meteor } from 'meteor/meteor';\nimport { check } from 'meteor/check';\nimport RedisPubSub from '/imports/startup/server/redis';\nimport Logger from '/imports/startup/server/logger';\nimport { extractCredentials, parseMessage } from '/imports/api/common/server/helpers';\n\n\nconst REDIS_CONFIG = Meteor.settings.private.redis;\nconst CHANNEL = REDIS_CONFIG.channels.toAkkaApps;\nconst EVENT_NAME = 'SetPrivateGuestLobbyMessageCmdMsg';\n\nexport default function setPrivateGuestLobbyMessage(message, guestId) {\n  check(message, String);\n  check(guestId, String);\n\n  const { meetingId, requesterUserId } = extractCredentials(this.userId);\n\n  check(meetingId, String);\n  check(requesterUserId, String);\n\n  const payload = { guestId, message: parseMessage(message) };\n\n  Logger.info(`User=${requesterUserId} sent a private guest lobby message to guest user=${guestId}`);\n\n  return RedisPubSub.publishUserMessage(CHANNEL, EVENT_NAME, meetingId, requesterUserId, payload);\n}\n\n"], "filenames": ["bigbluebutton-html5/imports/api/common/server/helpers.js", "bigbluebutton-html5/imports/api/group-chat-msg/server/methods/sendGroupChatMsg.js", "bigbluebutton-html5/imports/api/group-chat-msg/server/modifiers/addBulkGroupChatMsgs.js", "bigbluebutton-html5/imports/api/guest-users/server/methods/setGuestLobbyMessage.js", "bigbluebutton-html5/imports/api/guest-users/server/methods/setPrivateGuestLobbyMessage.js"], "buggy_code_start_loc": [2, 4, 5, 5, 5], "buggy_code_end_loc": [5, 30, 6, 21, 21], "fixing_code_start_loc": [3, 4, 5, 5, 5], "fixing_code_end_loc": [31, 6, 6, 20, 22], "type": "CWE-79", "message": "BigBlueButton is an open-source virtual classroom. Prior to versions 2.6.11 and 2.7.0-beta.3, Guest Lobby was vulnerable to cross-site scripting when users wait to enter the meeting due to inserting unsanitized messages to the element using unsafe innerHTML. Text sanitizing was added for lobby messages starting in versions 2.6.11 and 2.7.0-beta.3. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-43797", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-30T23:15:08.317", "lastModified": "2023-11-07T23:08:05.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "BigBlueButton is an open-source virtual classroom. Prior to versions 2.6.11 and 2.7.0-beta.3, Guest Lobby was vulnerable to cross-site scripting when users wait to enter the meeting due to inserting unsanitized messages to the element using unsafe innerHTML. Text sanitizing was added for lobby messages starting in versions 2.6.11 and 2.7.0-beta.3. There are no known workarounds."}, {"lang": "es", "value": "BigBlueButton es un aula virtual de c\u00f3digo abierto. Antes de las versiones 2.6.11 y 2.7.0-beta.3, Guest Lobby era vulnerable a cross-site scripting cuando los usuarios esperaban para ingresar a la reuni\u00f3n debido a la inserci\u00f3n de mensajes no sanitizados en el elemento mediante un HTML interno no seguro. Se agreg\u00f3 sanitizaci\u00f3n de texto para los mensajes del lobby a partir de las versiones 2.6.11 y 2.7.0-beta.3. No se conocen workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.11", "matchCriteriaId": "E83CAE24-2B29-4265-B5E8-17E89637F0DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:2.7.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "C05D5D11-75BE-41FA-A62F-61F35B16BA9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:2.7.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "C23D21AA-EF44-4F61-9775-57E3AF206CEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:2.7.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "1E95E50E-3C1E-438A-BAEC-AE0DF69B2937"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:2.7.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "A7EC2B6A-1A13-40FE-85D6-30D596813394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:2.7.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "5A7D33D7-AE88-4ED4-82A4-BCFA7E828AD1"}]}]}], "references": [{"url": "https://github.com/bigbluebutton/bigbluebutton/commit/304bc851a00558f99a908880f4ac44234a074c9d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bigbluebutton/bigbluebutton/pull/18392", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/bigbluebutton/bigbluebutton/security/advisories/GHSA-v6wg-q866-h73x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bigbluebutton/bigbluebutton/commit/304bc851a00558f99a908880f4ac44234a074c9d"}}