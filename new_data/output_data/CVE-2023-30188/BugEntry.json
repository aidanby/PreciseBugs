{"buggy_code": ["\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#include \"docbuilder_p.h\"\n\nstd::wstring NSDoctRenderer::CDocBuilder_Private::m_sExternalDirectory = L\"\";\n\nvoid CV8RealTimeWorker::_LOGGING_ERROR_(const std::wstring& strType, const std::wstring& strError)\n{\n\tstd::string sT = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(strType);\n\tstd::string sE = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(strError);\n\n\tstd::cerr << sT << \": \" << sE << std::endl;\n}\n\nusing namespace NSJSBase;\n\nCV8RealTimeWorker::CV8RealTimeWorker(NSDoctRenderer::CDocBuilder* pBuilder)\n{\n\tm_nFileType = -1;\n\n\tm_context = new CJSContext();\n\tm_context->Initialize();\n\n\tm_isolate_scope = m_context->CreateIsolateScope();\n\tm_handle_scope  = m_context->CreateLocalScope();\n\n\tm_context->CreateGlobalForContext();\n\tCNativeControlEmbed::CreateObjectBuilderInContext(\"CreateNativeEngine\", m_context);\n\tCGraphicsEmbed::CreateObjectInContext(\"CreateNativeGraphics\", m_context);\n\tNSJSBase::CreateDefaults(m_context);\n\tm_context->CreateContext();\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tbuilder_CreateNative(\"builderJS\", m_context, pBuilder);\n}\nCV8RealTimeWorker::~CV8RealTimeWorker()\n{\n\tm_oContextData.Clear();\n\tm_handle_scope = NULL;\n\tm_isolate_scope = NULL;\n\tm_context->Dispose();\n}\n\nbool CV8RealTimeWorker::ExecuteCommand(const std::wstring& command, NSDoctRenderer::CDocBuilderValue* retValue)\n{\n\tLOGGER_SPEED_START\n\n\t\t\tif (retValue)\n\t\t\tretValue->Clear();\n\n\tstd::string commandA = U_TO_UTF8(command);\n\t//commandA = \"Api.\" + commandA;\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tLOGGER_SPEED_LAP(\"compile_command\")\n\n\t\t\tJSSmart<CJSValue> retNativeVal = m_context->runScript(commandA, try_catch);\n\tif(try_catch->Check())\n\t\treturn false;\n\n\tif (retValue)\n\t{\n\t\tNSDoctRenderer::CDocBuilderValue_Private* privateRet = (NSDoctRenderer::CDocBuilderValue_Private*)retValue->private_get_internal();\n\t\tprivateRet->m_context = m_context;\n\t\tprivateRet->m_value = retNativeVal;\n\t}\n\n\tLOGGER_SPEED_LAP(\"run_command\")\n\n\t\t\treturn true;\n}\n\nstd::string CV8RealTimeWorker::GetGlobalVariable()\n{\n\tstd::string commandA = \"JSON.stringify(GlobalVariable);\";\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tJSSmart<CJSValue> _value = m_context->runScript(commandA, try_catch);\n\tif(try_catch->Check())\n\t\treturn \"\";\n\tif(_value->isString())\n\t\treturn _value->toStringA();\n\treturn \"{}\";\n}\n\nstd::wstring CV8RealTimeWorker::GetJSVariable(std::wstring sParam)\n{\n\tstd::string sParamA = U_TO_UTF8(sParam);\n\tNSStringUtils::string_replaceA(sParamA, \"\\\\\\\"\", \"\\\"\");\n\tstd::string commandA = \"(function(){ return (\" + sParamA + \"); })()\";\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tJSSmart<CJSValue> _value = m_context->runScript(commandA, try_catch);\n\tif(try_catch->Check())\n\t\treturn L\"jsValue(\" + sParam + L\")\";\n\tif(_value->isString())\n\t\treturn _value->toStringW();\n\treturn L\"jsValue(\" + sParam + L\")\";\n}\n\nbool CV8RealTimeWorker::OpenFile(const std::wstring& sBasePath, const std::wstring& path, const std::string& sString, const std::wstring& sCachePath, CV8Params* pParams)\n{\n\tLOGGER_SPEED_START\n\n\t\t\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch>         try_catch = m_context->GetExceptions();\n\n\tLOGGER_SPEED_LAP(\"compile\");\n\n\tm_context->runScript(sString, try_catch, sCachePath);\n\tif(try_catch->Check())\n\t\treturn false;\n\n\tLOGGER_SPEED_LAP(\"run\")\n\n\t\t\tif (true)\n\t{\n\t\tstd::string sArg = m_sUtf8ArgumentJSON;\n\t\tif (sArg.empty())\n\t\t\tsArg = \"{}\";\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\\\", \"\\\\\\\\\");\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\"\", \"\\\\\\\"\");\n\t\tstd::string sArgument = \"var Argument = JSON.parse(\\\"\" + sArg + \"\\\");\";\n\n\t\tm_context->runScript(sArgument, try_catch);\n\t\tif (try_catch->Check())\n\t\t\treturn false;\n\t}\n\n\tif (true)\n\t{\n\t\tstd::string sArg = m_sGlobalVariable;\n\t\tif (sArg.empty())\n\t\t\tsArg = \"{}\";\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\\\", \"\\\\\\\\\");\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\"\", \"\\\\\\\"\");\n\n\t\tstd::string sScriptVar = \"var GlobalVariable = JSON.parse(\\\"\" + sArg + \"\\\");\";\n\n\t\tm_context->runScript(sScriptVar, try_catch);\n\t\tif (try_catch->Check())\n\t\t\treturn false;\n\t}\n\n\tNSNativeControl::CNativeControl* pNative = NULL;\n\tbool bIsBreak = false;\n\n\tJSSmart<CJSObject> global_js = m_context->GetGlobal();\n\tJSSmart<CJSValue> args[1];\n\targs[0] = CJSContext::createInt(0);\n\n\t// GET_NATIVE_ENGINE\n\tif (!bIsBreak)\n\t{\n\t\tJSSmart<CJSValue> js_result2 = global_js->call_func(\"GetNativeEngine\", 1, args);\n\t\tif (try_catch->Check())\n\t\t\tbIsBreak = true;\n\t\telse\n\t\t{\n\t\t\tJSSmart<CJSObject> objNative = js_result2->toObject();\n\t\t\tpNative = (NSNativeControl::CNativeControl*)objNative->getNative()->getObject();\n\t\t}\n\t}\n\n\tif (pNative != NULL)\n\t{\n\t\tif (pParams)\n\t\t{\n\t\t\tpNative->m_oParams = *pParams;\n\t\t}\n\n\t\tpNative->m_strFontsDirectory = sBasePath + L\"/sdkjs/common\";\n\t\tpNative->m_strImagesDirectory = path + L\"/media\";\n\n\t\tpNative->CheckFonts();\n\n\t\tif (0 == m_nFileType)\n\t\t\tpNative->m_strEditorType = L\"document\";\n\t\telse if (1 == m_nFileType)\n\t\t\tpNative->m_strEditorType = L\"presentation\";\n\t\telse\n\t\t\tpNative->m_strEditorType = L\"spreadsheet\";\n\n\t\tpNative->SetFilePath(path + L\"/Editor.bin\");\n\n\t\tpNative->m_sChangesBuilderPath = path + L\"/changes/changes0.json\";\n\n\t\tpNative->m_nMaxChangesNumber = -1;\n\t}\n\n\t// OPEN\n\tif (!bIsBreak)\n\t{\n\t\tCChangesWorker oWorkerLoader;\n\t\tint nVersion = oWorkerLoader.OpenNative(pNative->GetFilePath());\n\n\t\tJSSmart<CJSValue> args_open[3];\n\t\targs_open[0] = oWorkerLoader.GetDataFull()->toObject()->toValue();\n\t\targs_open[1] = CJSContext::createInt(nVersion);\n\t\tstd::wstring sXlsx = NSFile::GetDirectoryName(pNative->GetFilePath()) + L\"/Editor.xlsx\";\n\t\targs_open[2] = NSFile::CFileBinary::Exists(sXlsx) ? CJSContext::createString(sXlsx) : CJSContext::createUndefined();\n\n\t\tglobal_js->call_func(\"NativeOpenFileData\", 3, args_open);\n\t\tif (try_catch->Check())\n\t\t\tbIsBreak = true;\n\t}\n\n\tif (!bIsBreak)\n\t\tbIsBreak = !this->ExecuteCommand(L\"Api.asc_nativeInitBuilder();\");\n\tif (!bIsBreak)\n\t\tbIsBreak = !this->ExecuteCommand(L\"Api.asc_SetSilentMode(true);\");\n\n\tLOGGER_SPEED_LAP(\"open\")\n\n\t\t\treturn !bIsBreak;\n}\n\nbool CV8RealTimeWorker::SaveFileWithChanges(int type, const std::wstring& _path, const std::wstring& sJsonParams)\n{\n\tNSDoctRenderer::DoctRendererFormat::FormatFile _formatDst = NSDoctRenderer::DoctRendererFormat::DOCT;\n\tif (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t_formatDst = NSDoctRenderer::DoctRendererFormat::PPTT;\n\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t_formatDst = NSDoctRenderer::DoctRendererFormat::XLST;\n\telse if ((type & AVS_OFFICESTUDIO_FILE_CROSSPLATFORM) || (type & AVS_OFFICESTUDIO_FILE_IMAGE))\n\t\t_formatDst = NSDoctRenderer::DoctRendererFormat::PDF;\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tNSNativeControl::CNativeControl* pNative = NULL;\n\n\tJSSmart<CJSObject> global_js = m_context->GetGlobal();\n\tJSSmart<CJSValue> args[1];\n\targs[0] = CJSContext::createInt(0);\n\n\t// GET_NATIVE_ENGINE\n\tif (true)\n\t{\n\t\tJSSmart<CJSValue> js_result2 = global_js->call_func(\"GetNativeEngine\", 1, args);\n\t\tif (!try_catch->Check())\n\t\t{\n\t\t\tJSSmart<CJSObject> objNative = js_result2->toObject();\n\t\t\tpNative = (NSNativeControl::CNativeControl*)objNative->getNative()->getObject();\n\t\t}\n\t}\n\n\tif (pNative == NULL)\n\t\treturn false;\n\n\tif (_formatDst == NSDoctRenderer::DoctRendererFormat::PDF)\n\t\tthis->ExecuteCommand(L\"Api.asc_SetSilentMode(false);\");\n\n\tstd::wstring strError;\n\tbool bIsError = Doct_renderer_SaveFile_ForBuilder(_formatDst,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  _path,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  pNative,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  m_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  args,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  strError,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sJsonParams);\n\n\tif (_formatDst == NSDoctRenderer::DoctRendererFormat::PDF)\n\t\tthis->ExecuteCommand(L\"Api.asc_SetSilentMode(true);\");\n\n\treturn bIsError;\n}\n\nnamespace NSDoctRenderer\n{\n\tCString::CString()\n\t{\n\t\tm_internal = new CString_Private();\n\t}\n\tCString::CString(const CString& src)\n\t{\n\t\tm_internal = new CString_Private();\n\t\tsrc.m_internal->Copy(m_internal);\n\t}\n\tCString& CString::operator=(const CString& src)\n\t{\n\t\tsrc.m_internal->Copy(m_internal);\n\t\treturn *this;\n\t}\n\tCString::~CString()\n\t{\n\t\tdelete m_internal;\n\t}\n\twchar_t* CString::c_str() const\n\t{\n\t\treturn m_internal->m_data;\n\t}\n\n\tCDocBuilderContextScope::CDocBuilderContextScope()\n\t{\n\t\tm_internal = new CDocBuilderContextScope_Private();\n\t}\n\tCDocBuilderContextScope::CDocBuilderContextScope(const CDocBuilderContextScope& src)\n\t{\n\t\tm_internal = new CDocBuilderContextScope_Private();\n\t\tm_internal->m_scope_wrap = src.m_internal->m_scope_wrap;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t}\n\tCDocBuilderContextScope& CDocBuilderContextScope::operator=(const CDocBuilderContextScope& src)\n\t{\n\t\tm_internal->m_scope_wrap = src.m_internal->m_scope_wrap;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t\treturn *this;\n\t}\n\tCDocBuilderContextScope::~CDocBuilderContextScope()\n\t{\n\t\tClose();\n\t\tRELEASEOBJECT(m_internal);\n\t}\n\tvoid CDocBuilderContextScope::Close()\n\t{\n\t\tif (m_internal->m_scope_wrap.is_init() && 2 == m_internal->m_scope_wrap.GetCountReference())\n\t\t{\n\t\t\tm_internal->m_context_data->RemoveScope(m_internal->m_scope_wrap);\n\t\t\tm_internal->m_scope_wrap->Close();\n\t\t}\n\t}\n\n\tCDocBuilderValue::CDocBuilderValue()\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const CDocBuilderValue& src)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\t*this = src;\n\n\t\t// only for constructor\n\t\tif (src.m_internal->m_parent.is_init())\n\t\t\tm_internal->m_parent = src.m_internal->m_parent;\n\t}\n\tCDocBuilderValue& CDocBuilderValue::operator=(const CDocBuilderValue& src)\n\t{\n\t\tm_internal->m_context = src.m_internal->m_context;\n\t\tm_internal->m_value = src.m_internal->m_value;\n\n\t\tm_internal->m_nativeType = src.m_internal->m_nativeType;\n\t\tm_internal->m_nativeValue = src.m_internal->m_nativeValue;\n\n\t\tswitch (m_internal->m_nativeType)\n\t\t{\n\t\tcase CDocBuilderValue_Private::ptString:\n\t\t{\n\t\t\tsize_t len = wcslen(m_internal->m_nativeValue.sValue);\n\t\t\twchar_t* copy_ptr = new wchar_t[len + 1];\n\t\t\tmemcpy(copy_ptr, m_internal->m_nativeValue.sValue, (len + 1) * sizeof(wchar_t));\n\t\t\tm_internal->m_nativeValue.sValue = copy_ptr;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m_internal->m_parent.is_init())\n\t\t{\n\t\t\tm_internal->CheckNative();\n\n\t\t\tJSSmart<CJSValue> oParent = m_internal->m_parent->m_parent;\n\n\t\t\tif (oParent->isArray())\n\t\t\t{\n\t\t\t\tJSSmart<CJSArray> oParentArray = oParent->toArray();\n\t\t\t\toParentArray->set(m_internal->m_parent->m_parent_index, m_internal->m_value.GetPointer());\n\t\t\t}\n\t\t\telse if (oParent->isObject() && !m_internal->m_parent->m_parent_prop_name.empty())\n\t\t\t{\n\t\t\t\tJSSmart<CJSObject> oParentObject = oParent->toObject();\n\t\t\t\toParentObject->set(m_internal->m_parent->m_parent_prop_name.c_str(), m_internal->m_value.GetPointer());\n\t\t\t}\n\t\t}\n\n\t\treturn *this;\n\t}\n\tCDocBuilderValue::~CDocBuilderValue()\n\t{\n\t\tdelete m_internal;\n\t}\n\tvoid* CDocBuilderValue::private_get_internal()\n\t{\n\t\treturn (void*)m_internal;\n\t}\n\n\tbool CDocBuilderValue::IsEmpty()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn true;\n\t\treturn m_internal->m_value->isEmpty();\n\t}\n\tvoid CDocBuilderValue::Clear()\n\t{\n\t\tm_internal->Clear();\n\t}\n\tbool CDocBuilderValue::IsNull()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptNull) ? true : false;\n\t\treturn m_internal->m_value->isNull();\n\t}\n\tbool CDocBuilderValue::IsUndefined()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptUndefined) ? true : false;\n\t\treturn m_internal->m_value->isUndefined();\n\t}\n\tbool CDocBuilderValue::IsBool()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptBool) ? true : false;\n\t\treturn m_internal->m_value->isBool();\n\t}\n\tbool CDocBuilderValue::IsInt()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptInt) ? true : false;\n\t\treturn m_internal->m_value->isNumber();\n\t}\n\tbool CDocBuilderValue::IsDouble()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptDouble) ? true : false;\n\t\treturn m_internal->m_value->isNumber();\n\t}\n\tbool CDocBuilderValue::IsString()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptString) ? true : false;\n\t\treturn m_internal->m_value->isString();\n\t}\n\tbool CDocBuilderValue::IsObject()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isObject();\n\t}\n\tbool CDocBuilderValue::IsFunction()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isFunction();\n\t}\n\tbool CDocBuilderValue::IsArray()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isArray();\n\t}\n\tbool CDocBuilderValue::IsTypedArray()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isTypedArray();\n\t}\n\n\tunsigned int CDocBuilderValue::GetLength()\n\t{\n\t\tif (IsArray())\n\t\t{\n\t\t\tJSSmart<CJSArray> array = m_internal->m_value->toArray();\n\t\t\treturn (unsigned int)array->getCount();\n\t\t}\n\t\tif (IsTypedArray())\n\t\t{\n\t\t\tJSSmart<CJSTypedArray> array = m_internal->m_value->toTypedArray();\n\t\t\treturn (unsigned int)array->getCount();\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool CDocBuilderValue::ToBool()\n\t{\n\t\tif (!m_internal->m_value.is_init() && (m_internal->m_nativeType == CDocBuilderValue_Private::ptBool))\n\t\t\treturn m_internal->m_nativeValue.bValue;\n\n\t\tif (IsEmpty() || !m_internal->m_value->isBool())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->toBool();\n\t}\n\tint CDocBuilderValue::ToInt()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t{\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptInt)\n\t\t\t\treturn m_internal->m_nativeValue.nValue;\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptUInt)\n\t\t\t\treturn (int)m_internal->m_nativeValue.unValue;\n\t\t}\n\n\t\tif (IsEmpty() || !m_internal->m_value->isNumber())\n\t\t\treturn 0;\n\t\treturn m_internal->m_value->toInt32();\n\t}\n\tdouble CDocBuilderValue::ToDouble()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t{\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptDouble)\n\t\t\t\treturn m_internal->m_nativeValue.dValue;\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptInt)\n\t\t\t\treturn (double)m_internal->m_nativeValue.nValue;\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptUInt)\n\t\t\t\treturn (double)m_internal->m_nativeValue.unValue;\n\t\t}\n\n\t\tif (IsEmpty() || !m_internal->m_value->isNumber())\n\t\t\treturn 0;\n\t\treturn m_internal->m_value->toDouble();\n\t}\n\tCString CDocBuilderValue::ToString()\n\t{\n\t\tCString ret;\n\t\tif (!m_internal->m_value.is_init() && (m_internal->m_nativeType == CDocBuilderValue_Private::ptString))\n\t\t{\n\t\t\twchar_t* pValue = m_internal->m_nativeValue.sValue;\n\t\t\tsize_t len = wcslen(pValue);\n\t\t\twchar_t* buffer = new wchar_t[len + 1];\n\t\t\tmemcpy(buffer, pValue, len * sizeof(wchar_t));\n\t\t\tbuffer[len] = '\\0';\n\t\t\tret.m_internal->Attach(buffer);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (IsEmpty() || !m_internal->m_value->isString())\n\t\t\treturn ret;\n\t\tstd::wstring sValue = m_internal->m_value->toStringW();\n\t\tif (sValue.empty())\n\t\t\treturn ret;\n\t\tsize_t len = sValue.length();\n\t\twchar_t* buffer = new wchar_t[len + 1];\n\t\tmemcpy(buffer, sValue.c_str(), len * sizeof(wchar_t));\n\t\tbuffer[len] = '\\0';\n\t\tret.m_internal->Attach(buffer);\n\t\treturn ret;\n\t}\n\n\tCDocBuilderValue CDocBuilderValue::Get(const char* name)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->get(name);\n\n\t\tret.m_internal->m_parent = new CDocBuilderValue_Private::CParentValueInfo();\n\t\tret.m_internal->m_parent->m_parent = m_internal->m_value;\n\t\tret.m_internal->m_parent->m_parent_prop_name = std::string(name);\n\t\tret.m_internal->m_parent->m_parent_index = -1;\n\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Get(const wchar_t* name)\n\t{\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\t\treturn Get(sPropA.c_str());\n\t}\n\tCDocBuilderValue CDocBuilderValue::GetProperty(const wchar_t* name)\n\t{\n\t\treturn Get(name);\n\t}\n\tCDocBuilderValue CDocBuilderValue::operator[](const char* name)\n\t{\n\t\treturn Get(name);\n\t}\n\tCDocBuilderValue CDocBuilderValue::operator[](const wchar_t *name)\n\t{\n\t\treturn Get(name);\n\t}\n\n\tCDocBuilderValue CDocBuilderValue::Get(const int& index)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isArray())\n\t\t\treturn ret;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tJSSmart<CJSArray> array = m_internal->m_value->toArray();\n\t\tret.m_internal->m_value = array->get(index);\n\n\t\tret.m_internal->m_parent = new CDocBuilderValue_Private::CParentValueInfo();\n\t\tret.m_internal->m_parent->m_parent = m_internal->m_value;\n\t\tret.m_internal->m_parent->m_parent_index = index;\n\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::operator[](const int &index)\n\t{\n\t\treturn Get(index);\n\t}\n\n\tvoid CDocBuilderValue::Set(const wchar_t* name, CDocBuilderValue value)\n\t{\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tvalue.m_internal->CheckNative();\n\t\tm_internal->m_value->toObjectSmart()->set(sPropA.c_str(), value.m_internal->m_value.GetPointer());\n\t}\n\tvoid CDocBuilderValue::SetProperty(const wchar_t* name, CDocBuilderValue value)\n\t{\n\t\tSet(name, value);\n\t}\n\tvoid CDocBuilderValue::Set(const int& index, CDocBuilderValue value)\n\t{\n\t\tif (IsEmpty() || !m_internal->m_value->isArray())\n\t\t\treturn;\n\n\t\tJSSmart<CJSArray> array = m_internal->m_value->toArray();\n\t\tvalue.m_internal->CheckNative();\n\t\tarray->set(index, value.m_internal->m_value.GetPointer());\n\t}\n\n\t// primitives\n\tCDocBuilderValue::CDocBuilderValue(const bool& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateBool(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const int& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateInt(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const unsigned int& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateUInt(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const double& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateDouble(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const char* value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateString(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const wchar_t* value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateString(value);\n\t}\n\n\tCDocBuilderValue CDocBuilderValue::CreateUndefined()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->CreateUndefined();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::CreateNull()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->CreateNull();\n\t\treturn ret;\n\t}\n\n\t// Functions\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[1];\n\t\targv[0] = p1.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 1, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[2];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 2, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[3];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 3, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[4];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 4, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[5];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 5, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5, CDocBuilderValue p6)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tp6.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[6];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\t\targv[5] = p6.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 6, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str());\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[1];\n\t\targv[0] = p1.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 1, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[2];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 2, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[3];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 3, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[4];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 4, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[5];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 5, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5, CDocBuilderValue p6)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tp6.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[6];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\t\targv[5] = p6.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 6, argv);\n\t\treturn ret;\n\t}\n\n\tCDocBuilderContext::CDocBuilderContext()\n\t{\n\t\tm_internal = new CDocBuilderContext_Private();\n\t}\n\tCDocBuilderContext::CDocBuilderContext(const CDocBuilderContext& src)\n\t{\n\t\tm_internal = new CDocBuilderContext_Private();\n\t\tm_internal->m_context = src.m_internal->m_context;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t}\n\tCDocBuilderContext& CDocBuilderContext::operator=(const CDocBuilderContext& src)\n\t{\n\t\tm_internal->m_context = src.m_internal->m_context;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t\treturn *this;\n\t}\n\tCDocBuilderContext::~CDocBuilderContext()\n\t{\n\t\tRELEASEOBJECT(m_internal);\n\t}\n\n\tCDocBuilderValue CDocBuilderContext::CreateUndefined()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createUndefined();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateNull()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createNull();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateObject()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createObject();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateArray(const int& length)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createArray(length);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateTypedArray(unsigned char* buffer, const int& length, const bool& externalize)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createUint8Array(buffer, length, externalize);\n\t\treturn ret;\n\t}\n\n\tunsigned char* CDocBuilderContext::AllocMemoryTypedArray(const size_t& size)\n\t{\n\t\treturn NSJSBase::NSAllocator::Alloc(size);\n\t}\n\n\tvoid CDocBuilderContext::FreeMemoryTypedArray(unsigned char* data, const size_t& size)\n\t{\n\t\treturn NSJSBase::NSAllocator::Free(data, size);\n\t}\n\n\tCDocBuilderValue CDocBuilderContext::GetGlobal()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tJSSmart<CJSObject> obj = m_internal->m_context->GetGlobal();\n\t\tret.m_internal->m_value = obj->toValue();\n\t\treturn ret;\n\t}\n\n\tCDocBuilderContextScope CDocBuilderContext::CreateScope()\n\t{\n\t\tCDocBuilderContextScope ret;\n\t\tret.m_internal->m_scope_wrap = new CDocBuilderContextScopeWrap();\n\t\tret.m_internal->m_scope_wrap->m_scope = m_internal->m_context->CreateContextScope();\n\t\tret.m_internal->m_context_data = m_internal->m_context_data;\n\n\t\tm_internal->m_context_data->AddScope(ret.m_internal->m_scope_wrap);\n\t\treturn ret;\n\t}\n\n\tbool CDocBuilderContext::IsError()\n\t{\n\t\tJSSmart<CJSTryCatch> oTry = m_internal->m_context->GetExceptions();\n\t\treturn oTry->Check();\n\t}\n}\n\nnamespace NSDoctRenderer\n{\n\tvoid ParceParameters(const std::string& command, std::wstring* params, int& nCount)\n\t{\n\t\tconst char* _commandsPtr = command.c_str();\n\t\tsize_t _commandsLen = command.length();\n\t\tsize_t _currentPos = 0;\n\n\t\tint nIndex = 0;\n\n\t\twhile (true)\n\t\t{\n\t\t\twhile (_currentPos < _commandsLen && !(_commandsPtr[_currentPos] == '\\\"' && _commandsPtr[_currentPos - 1] != '\\\\'))\n\t\t\t\t++_currentPos;\n\n\t\t\t++_currentPos;\n\t\t\tsize_t _start = _currentPos;\n\n\t\t\twhile (_currentPos < _commandsLen && !(_commandsPtr[_currentPos] == '\\\"' && _commandsPtr[_currentPos - 1] != '\\\\'))\n\t\t\t\t++_currentPos;\n\n\t\t\tif (_currentPos > _start)\n\t\t\t{\n\t\t\t\tif (_currentPos == (_start + 1))\n\t\t\t\t\tparams[nIndex++] = L\"\";\n\t\t\t\telse\n\t\t\t\t\tparams[nIndex++] = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)(_commandsPtr + _start), (LONG)(_currentPos - _start));\n\t\t\t}\n\n\t\t\t++_currentPos;\n\n\t\t\tif (_currentPos >= _commandsLen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnCount = nIndex;\n\t}\n\n\tbool CDocBuilder::CreateFile(const int& type)\n\t{\n\t\tm_pInternal->m_nFileType = -1;\n\t\tif (!NSDirectory::Exists(m_pInternal->m_sTmpFolder))\n\t\t\tNSDirectory::CreateDirectory(m_pInternal->m_sTmpFolder);\n\n\t\treturn m_pInternal->CreateFile(type);\n\t}\n\tvoid CDocBuilder::SetTmpFolder(const wchar_t* folder)\n\t{\n\t\tif (m_pInternal->m_bIsServerSafeVersion)\n\t\t\treturn;\n\t\tm_pInternal->m_sTmpFolder = std::wstring(folder);\n\t}\n\tvoid CDocBuilder::CloseFile()\n\t{\n\t\tm_pInternal->CloseFile();\n\t}\n\n\tchar* CDocBuilder::GetVersion()\n\t{\n\t\tm_pInternal->Init();\n\n\t\tif (0 == m_pInternal->m_arDoctSDK.size())\n\t\t\treturn NULL;\n\n\t\tstd::wstring sFile;\n\t\tfor (std::vector<std::wstring>::iterator i = m_pInternal->m_arDoctSDK.begin(); i != m_pInternal->m_arDoctSDK.end(); i++)\n\t\t{\n\t\t\tif (std::wstring::npos != i->find(L\"sdk-all-min.js\"))\n\t\t\t{\n\t\t\t\tsFile = *i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sFile.empty())\n\t\t\treturn NULL;\n\n\t\tstd::string sData;\n\t\tif (!NSFile::CFileBinary::ReadAllTextUtf8A(sFile, sData))\n\t\t\treturn NULL;\n\n\t\tstd::string::size_type startPos = sData.find(\"Version:\");\n\t\tif (std::string::npos == startPos)\n\t\t\treturn NULL;\n\n\t\tstartPos += 8;\n\n\t\tstd::string::size_type endPos = sData.find(')', startPos);\n\t\tif (std::string::npos == endPos)\n\t\t\treturn NULL;\n\n\t\tsize_t sSrcLen = endPos - startPos + 1;\n\t\tif (sSrcLen == 0)\n\t\t\treturn NULL;\n\n\t\tchar* sRet = new char[sSrcLen + 1];\n\t\tmemcpy(sRet, sData.c_str() + startPos, sSrcLen);\n\t\tsRet[sSrcLen] = '\\0';\n\t\treturn sRet;\n\t}\n\n\tbool CDocBuilder::Run(const wchar_t* path)\n\t{\n\t\tstd::wstring sPath(path);\n\t\tif (!NSFile::CFileBinary::Exists(sPath))\n\t\t\tsPath = NSFile::GetProcessDirectory() + L\"/\" + sPath;\n\n\t\tstd::string sCommands;\n\t\tbool bRet = NSFile::CFileBinary::ReadAllTextUtf8A(sPath, sCommands);\n\n\t\tif (!bRet)\n\t\t{\n\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error\", L\"cannot read run file\");\n\t\t\treturn bRet;\n\t\t}\n\n\t\treturn this->RunTextA(sCommands.c_str());\n\t}\n\n\tbool CDocBuilder::RunTextW(const wchar_t* commands)\n\t{\n\t\tstd::wstring sCommandsW(commands);\n\t\tstd::string sCommands = U_TO_UTF8(sCommandsW);\n\t\treturn this->RunTextA(sCommands.c_str());\n\t}\n\n\tbool CDocBuilder::RunTextA(const char* commands)\n\t{\n\t\tm_pInternal->Init();\n\t\tstd::list<std::string> _commands;\n\t\tsize_t _commandsLen = strlen(commands);\n\t\tsize_t _currentPos = 0;\n\n\t\twhile (true)\n\t\t{\n\t\t\twhile (_currentPos < _commandsLen && (commands[_currentPos] == 0x0d || commands[_currentPos] == 0x0a))\n\t\t\t\t++_currentPos;\n\n\t\t\tsize_t _start = _currentPos;\n\n\t\t\twhile (_currentPos < _commandsLen && (commands[_currentPos] != 0x0d && commands[_currentPos] != 0x0a))\n\t\t\t\t++_currentPos;\n\n\t\t\tif (_currentPos > _start)\n\t\t\t{\n\t\t\t\tsize_t _start2 = _start;\n\t\t\t\twhile (_start2 < _currentPos && (commands[_start2] == '\\t' || commands[_start2] == ' '))\n\t\t\t\t\t++_start2;\n\n\t\t\t\tif (_currentPos > _start2 && (commands[_start2] != '#' && commands[_start2] != '/'))\n\t\t\t\t{\n\t\t\t\t\t_commands.push_back(std::string(commands + _start2, _currentPos - _start2));\n\t\t\t\t\t// DEBUG\n\t\t\t\t\t//std::cout << std::string(commands + _start2, _currentPos - _start2) << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_currentPos >= _commandsLen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstd::string sJsCommands = \"\";\n\t\tstd::wstring _builder_params[4]; // \u0441 \u0437\u0430\u043f\u0430\u0441\u043e\u043c\n\t\tfor (std::list<std::string>::iterator i = _commands.begin(); i != _commands.end(); i++)\n\t\t{\n\t\t\tconst std::string& command = *i;\n\t\t\tconst char* _data = command.c_str();\n\t\t\tsize_t _len = command.length();\n\n\t\t\tbool bIsBuilder = false;\n\t\t\tif (_len > 8)\n\t\t\t{\n\t\t\t\tif (_data[0] == 'b' &&\n\t\t\t\t\t\t_data[1] == 'u' &&\n\t\t\t\t\t\t_data[2] == 'i' &&\n\t\t\t\t\t\t_data[3] == 'l' &&\n\t\t\t\t\t\t_data[4] == 'd' &&\n\t\t\t\t\t\t_data[5] == 'e' &&\n\t\t\t\t\t\t_data[6] == 'r' &&\n\t\t\t\t\t\t_data[7] == '.')\n\t\t\t\t\tbIsBuilder = true;\n\t\t\t}\n\n\t\t\tbool bIsNoError = true;\n\t\t\tif (bIsBuilder)\n\t\t\t{\n\t\t\t\tif (!sJsCommands.empty())\n\t\t\t\t{\n\t\t\t\t\tstd::wstring sUnicodeCommand = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sJsCommands.c_str(), (LONG)sJsCommands.length());\n\t\t\t\t\tbIsNoError = this->ExecuteCommand(sUnicodeCommand.c_str());\n\t\t\t\t\tsJsCommands = \"\";\n\t\t\t\t\tif (!bIsNoError)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tsize_t _pos = 8;\n\t\t\t\twhile (_data[_pos] != '(')\n\t\t\t\t\t++_pos;\n\n\t\t\t\tstd::string sFuncNum(_data + 8, _pos - 8);\n\t\t\t\tint nCountParameters = 0;\n\t\t\t\tParceParameters(command, _builder_params, nCountParameters);\n\n\t\t\t\tfor (int nCheckParam = 0; nCheckParam < nCountParameters; ++nCheckParam)\n\t\t\t\t{\n\t\t\t\t\tif (0 == _builder_params[nCheckParam].find(L\"jsValue(\") && _builder_params[nCheckParam].length() > 9)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::wstring sParam = _builder_params[nCheckParam].substr(8, _builder_params[nCheckParam].length() - 9);\n\t\t\t\t\t\t_builder_params[nCheckParam] = m_pInternal->m_pWorker->GetJSVariable(sParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\"OpenFile\" == sFuncNum)\n\t\t\t\t\tbIsNoError = (0 == this->OpenFile(_builder_params[0].c_str(), _builder_params[1].c_str()));\n\t\t\t\telse if (\"CreateFile\" == sFuncNum)\n\t\t\t\t{\n\t\t\t\t\tif (L\"docx\" == _builder_params[0])\n\t\t\t\t\t\tbIsNoError = this->CreateFile(AVS_OFFICESTUDIO_FILE_DOCUMENT_DOCX);\n\t\t\t\t\telse if (L\"pptx\" == _builder_params[0])\n\t\t\t\t\t\tbIsNoError = this->CreateFile(AVS_OFFICESTUDIO_FILE_PRESENTATION_PPTX);\n\t\t\t\t\telse if (L\"xlsx\" == _builder_params[0])\n\t\t\t\t\t\tbIsNoError = this->CreateFile(AVS_OFFICESTUDIO_FILE_SPREADSHEET_XLSX);\n\t\t\t\t}\n\t\t\t\telse if (\"SetTmpFolder\" == sFuncNum)\n\t\t\t\t\tthis->SetTmpFolder(_builder_params[0].c_str());\n\t\t\t\telse if (\"CloseFile\" == sFuncNum)\n\t\t\t\t\tthis->CloseFile();\n\t\t\t\telse if (\"SaveFile\" == sFuncNum)\n\t\t\t\t{\n\t\t\t\t\tint nFormat = NSDoctRenderer::GetFormatByTexExtention(_builder_params[0]);\n\n\t\t\t\t\tif (m_pInternal->m_oParams.m_bSaveWithDoctrendererMode)\n\t\t\t\t\t{\n\t\t\t\t\t\t// \u043f\u0435\u0440\u0435\u0434 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\u043c \u0432 \u0442\u0430\u043a\u043e\u0439 \u0441\u0445\u0435\u043c\u0435 \u043d\u0443\u0436\u043d\u043e \u0441\u043a\u0438\u043d\u0443\u0442\u044c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f\n\t\t\t\t\t\tthis->ExecuteCommand(L\"Api.asc_Save();\");\n\t\t\t\t\t}\n\n\t\t\t\t\tconst wchar_t* sParams = NULL;\n\t\t\t\t\tif (nCountParameters > 2)\n\t\t\t\t\t\tsParams = _builder_params[2].c_str();\n\n\t\t\t\t\tthis->SaveFile(nFormat, _builder_params[1].c_str(), sParams);\n\t\t\t\t}\n\t\t\t\telse if (\"WriteData\" == sFuncNum)\n\t\t\t\t{\n\t\t\t\t\tbool isAppend = true;\n\t\t\t\t\tif (nCountParameters > 2)\n\t\t\t\t\t\tisAppend = (L\"true\" == _builder_params[2]) ? true : false;\n\n\t\t\t\t\tthis->WriteData(_builder_params[0].c_str(), _builder_params[1].c_str(), isAppend);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//bIsNoError = this->m_pInternal->ExecuteCommand(NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)_data, (LONG)_len));\n\t\t\t\tsJsCommands += command;\n\t\t\t\tsJsCommands += \"\\n\";\n\t\t\t}\n\n\t\t\tif (!bIsNoError)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (!sJsCommands.empty())\n\t\t{\n\t\t\t// \u0422\u0430\u043a\u043e\u0433\u043e \u0431\u044b\u0442\u044c \u043d\u0435 \u0434\u043e\u043b\u0436\u043d\u043e!!! \u0422\u0430\u043a \u043a\u0430\u043a \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043d\u0438\u043a\u0443\u0434\u0430 \u043d\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u0441\u044f. \u043f\u0443\u0441\u0442\u043e\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435.\n\t\t\tstd::wstring sUnicodeCommand = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sJsCommands.c_str(), (LONG)sJsCommands.length());\n\t\t\tbool bIsNoError = this->ExecuteCommand(sUnicodeCommand.c_str());\n\t\t\tsJsCommands = \"\";\n\t\t\tif (!bIsNoError)\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tvoid CDocBuilder::SetProperty(const char* param, const wchar_t* value)\n\t{\n\t\tstd::string sParam = std::string(param);\n\t\tif (sParam == \"--use-doctrenderer-scheme\")\n\t\t\tm_pInternal->m_oParams.m_bSaveWithDoctrendererMode = true;\n\t\telse if (sParam == \"--check-fonts\")\n\t\t{\n\t\t\tif (value && value[0] == '0')\n\t\t\t\tm_pInternal->m_oParams.m_bCheckFonts = false;\n\t\t\telse\n\t\t\t\tm_pInternal->m_oParams.m_bCheckFonts = true;\n\t\t}\n\t\telse if (sParam == \"--work-directory\")\n\t\t\tm_pInternal->m_oParams.m_sWorkDir = std::wstring(value);\n\t\telse if (sParam == \"--cache-scripts\")\n\t\t\tm_pInternal->m_bIsCacheScript = (std::wstring(value) == L\"true\");\n\t\telse if (sParam == \"--save-use-only-names\")\n\t\t{\n\t\t\tm_pInternal->m_bIsServerSafeVersion = true;\n\t\t\tm_pInternal->m_sFolderForSaveOnlyUseNames = std::wstring(value);\n\t\t}\n\t\telse if (sParam == \"--all-fonts-path\")\n\t\t{\n\t\t\tm_pInternal->SetAllFontsExternal(std::wstring(value));\n\t\t}\n\t\telse if (sParam == \"--argument\")\n\t\t{\n\t\t\tstd::wstring sArg(value);\n\t\t\tm_pInternal->m_oParams.m_sArgumentJSON = U_TO_UTF8(sArg);\n\t\t}\n\t\telse if (sParam == \"--fonts-system\")\n\t\t{\n\t\t\tm_pInternal->m_oParams.m_bIsSystemFonts = (std::wstring(value) == L\"true\");\n\t\t}\n\t\telse if (sParam == \"--fonts-dir\")\n\t\t{\n\t\t\tm_pInternal->m_oParams.m_arFontDirs.push_back(std::wstring(value));\n\t\t}\n\t}\n\tvoid CDocBuilder::SetPropertyW(const wchar_t* param, const wchar_t* value)\n\t{\n\t\tstd::wstring sW(param);\n\t\tstd::string sA = U_TO_UTF8(sW);\n\t\treturn this->SetProperty(sA.c_str(), value);\n\t}\n\n\tvoid CDocBuilder::Initialize(const wchar_t* directory)\n\t{\n\t\tstd::wstring sDirectory = L\"\";\n\t\tif (directory)\n\t\t\tsDirectory = std::wstring(directory);\n\n\t\tNSDoctRenderer::CDocBuilder_Private::m_sExternalDirectory = sDirectory;\n\t\tCJSContext::ExternalInitialize(sDirectory);\n\t}\n\n\tvoid CDocBuilder::Dispose()\n\t{\n\t\tCJSContext::ExternalDispose();\n\t}\n\n\tvoid CDocBuilder::WriteData(const wchar_t* path, const wchar_t* value, const bool& append)\n\t{\n\t\treturn m_pInternal->WriteData(path, value, append);\n\t}\n\n\tbool CDocBuilder::IsSaveWithDoctrendererMode()\n\t{\n\t\treturn m_pInternal->m_oParams.m_bSaveWithDoctrendererMode;\n\t}\n}\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#ifndef DOC_BUILDER_PRIVATE\n#define DOC_BUILDER_PRIVATE\n\n#include \"./config.h\"\n#include \"docbuilder.h\"\n#include \"doctrenderer.h\"\n\n#include <iostream>\n#include <list>\n\n#include \"../../Common/OfficeFileFormats.h\"\n#include \"../../Common/OfficeFileFormatChecker.h\"\n\n#include \"js_internal/js_base.h\"\n#include \"embed/NativeBuilderEmbed.h\"\n#include \"embed/NativeControlEmbed.h\"\n#include \"embed/GraphicsEmbed.h\"\n#include \"embed/Default.h\"\n#ifdef LINUX\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#endif\n\n#ifdef BUIDLER_OPEN_DOWNLOAD_ENABLED\n#include \"../../Common/Network/FileTransporter/include/FileTransporter.h\"\n#endif\n\n#include \"../fontengine/ApplicationFontsWorker.h\"\n\n#ifdef CreateFile\n#undef CreateFile\n#endif\n\nnamespace NSDoctRenderer\n{\n\tstatic int GetFormatByTexExtention(const std::wstring& sExt)\n\t{\n\t\tint nFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_DOCX;\n\t\tif (L\"docx\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_DOCX;\n\t\telse if (L\"doc\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_DOC;\n\t\telse if (L\"odt\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_ODT;\n\t\telse if (L\"rtf\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_RTF;\n\t\telse if (L\"txt\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_TXT;\n\t\telse if (L\"pptx\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_PRESENTATION_PPTX;\n\t\telse if (L\"odp\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_PRESENTATION_ODP;\n\t\telse if (L\"xlsx\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_XLSX;\n\t\telse if (L\"xls\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_XLS;\n\t\telse if (L\"ods\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_ODS;\n\t\telse if (L\"csv\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_CSV;\n\t\telse if (L\"pdf\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_CROSSPLATFORM_PDF;\n\t\telse if (L\"image\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_IMAGE;\n\t\telse if (L\"jpg\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_IMAGE;\n\t\telse if (L\"png\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_IMAGE;\n\t\treturn nFormat;\n\t}\n}\n\nnamespace NSDoctRenderer\n{\n\tclass CString_Private\n\t{\n\tpublic:\n\t\twchar_t* m_data;\n\n\tpublic:\n\t\tCString_Private()\n\t\t{\n\t\t\tm_data = NULL;\n\t\t}\n\t\t~CString_Private()\n\t\t{\n\t\t\tif (m_data)\n\t\t\t\tdelete [] m_data;\n\t\t}\n\n\t\tvoid Attach(wchar_t* data)\n\t\t{\n\t\t\tm_data = data;\n\t\t}\n\n\t\tvoid Copy(CString_Private* copy)\n\t\t{\n\t\t\tif (copy->m_data)\n\t\t\t{\n\t\t\t\tdelete [] copy->m_data;\n\t\t\t\tcopy->m_data = NULL;\n\t\t\t}\n\n\t\t\tif (m_data == NULL)\n\t\t\t\treturn;\n\n\t\t\tsize_t len = wcslen(m_data);\n\t\t\tcopy->m_data = new wchar_t[len + 1];\n\t\t\tmemcpy(copy->m_data, m_data, (len + 1) * sizeof(wchar_t));\n\t\t}\n\t};\n}\n\nclass CJSContextData;\nnamespace NSDoctRenderer\n{\n\tclass CDocBuilderContextScopeWrap\n\t{\n\tpublic:\n\t\tJSSmart<CJSContextScope> m_scope;\n\n\tpublic:\n\t\tCDocBuilderContextScopeWrap() : m_scope() {}\n\t\t~CDocBuilderContextScopeWrap() { Close(); }\n\n\t\tvoid Close() { m_scope.Release(); }\n\t};\n\n\tclass CDocBuilderContextScope_Private\n\t{\n\tpublic:\n\t\tJSSmart<CDocBuilderContextScopeWrap> m_scope_wrap;\n\t\tCJSContextData* m_context_data;\n\n\tpublic:\n\t\tCDocBuilderContextScope_Private() : m_scope_wrap() { m_context_data = NULL; }\n\t\t~CDocBuilderContextScope_Private() {}\n\t};\n\n\tclass CDocBuilderContext_Private\n\t{\n\tpublic:\n\t\tJSSmart<CJSContext> m_context;\n\t\tCJSContextData* m_context_data;\n\n\t\tCDocBuilderContext_Private() : m_context() { m_context_data = NULL; }\n\t\t~CDocBuilderContext_Private() { m_context.Release(); }\n\t};\n}\n\nnamespace NSDoctRenderer\n{\n\tclass CDocBuilderValue_Private\n\t{\n\tpublic:\n\t\tclass CParentValueInfo\n\t\t{\n\t\tpublic:\n\t\t\tJSSmart<CJSValue> m_parent;\n\t\t\tint m_parent_index;\n\t\t\tstd::string m_parent_prop_name;\n\n\t\tpublic:\n\t\t\tCParentValueInfo() : m_parent(), m_parent_index(-1), m_parent_prop_name(\"\")\n\t\t\t{\n\t\t\t}\n\t\t};\n\tpublic:\n\t\tJSSmart<CJSContext> m_context;\n\t\tJSSmart<CJSValue> m_value;\n\n\t\t// for operator [index]/[\"name\"] and setter without references\n\t\tJSSmart<CParentValueInfo> m_parent;\n\n\t\tenum PrimitiveType\n\t\t{\n\t\t\tptUndefined     = 0,\n\t\t\tptNull          = 1,\n\t\t\tptBool          = 2,\n\t\t\tptInt           = 3,\n\t\t\tptUInt          = 4,\n\t\t\tptDouble        = 5,\n\t\t\tptString        = 6\n\t\t};\n\n\t\tunion PrimitiveValue\n\t\t{\n\t\t\tbool bValue;\n\t\t\tint nValue;\n\t\t\tunsigned int unValue;\n\t\t\tdouble dValue;\n\t\t\twchar_t* sValue;\n\t\t};\n\n\t\tPrimitiveType m_nativeType;\n\t\tPrimitiveValue m_nativeValue;\n\n\tpublic:\n\t\tCDocBuilderValue_Private() : m_context(NULL)\n\t\t{\n\t\t\tm_nativeType = ptUndefined;\n\t\t}\n\t\t~CDocBuilderValue_Private()\n\t\t{\n\n\t\t}\n\t\tvoid Clear()\n\t\t{\n\t\t\tm_value.Release();\n\t\t\tClearNative();\n\t\t}\n\n\t\t// native\n\t\tvoid CreateUndefined()\n\t\t{\n\t\t\tm_nativeType = ptUndefined;\n\t\t}\n\t\tvoid CreateNull()\n\t\t{\n\t\t\tm_nativeType = ptNull;\n\t\t}\n\t\tvoid CreateBool(const bool& value)\n\t\t{\n\t\t\tm_nativeType = ptBool;\n\t\t\tm_nativeValue.bValue = value;\n\t\t}\n\t\tvoid CreateInt(const int& value)\n\t\t{\n\t\t\tm_nativeType = ptInt;\n\t\t\tm_nativeValue.nValue = value;\n\t\t}\n\t\tvoid CreateUInt(const unsigned int& value)\n\t\t{\n\t\t\tm_nativeType = ptUInt;\n\t\t\tm_nativeValue.unValue = value;\n\t\t}\n\t\tvoid CreateDouble(const double& value)\n\t\t{\n\t\t\tm_nativeType = ptDouble;\n\t\t\tm_nativeValue.dValue = value;\n\t\t}\n\t\tvoid CreateString(const wchar_t*& value)\n\t\t{\n\t\t\tsize_t len = wcslen(value) + 1;\n\t\t\tm_nativeType = ptString;\n\t\t\tm_nativeValue.sValue = new wchar_t[len];\n\t\t\tmemcpy(m_nativeValue.sValue, value, len * sizeof(wchar_t));\n\t\t}\n\t\tvoid CreateString(const char*& value)\n\t\t{\n\t\t\tstd::wstring sValue = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)value, strlen(value));\n\t\t\tconst wchar_t* strTmp = sValue.c_str();\n\t\t\tCreateString(strTmp);\n\t\t}\n\n\t\tvoid ClearNative()\n\t\t{\n\t\t\tif (m_nativeType == ptString)\n\t\t\t{\n\t\t\t\tdelete [] m_nativeValue.sValue;\n\t\t\t}\n\t\t\tm_nativeType = ptUndefined;\n\t\t}\n\n\t\tvoid CheckNative()\n\t\t{\n\t\t\tif (m_value.is_init())\n\t\t\t\treturn;\n\n\t\t\tswitch (m_nativeType)\n\t\t\t{\n\t\t\tcase ptUndefined:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createUndefined();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptNull:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createNull();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptBool:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createBool(m_nativeValue.bValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptInt:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createInt(m_nativeValue.nValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptUInt:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createUInt(m_nativeValue.unValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptDouble:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createDouble(m_nativeValue.dValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptString:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createString(m_nativeValue.sValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tClearNative();\n\t\t}\n\t};\n}\n\nclass CJSContextData\n{\nprivate:\n\tstd::vector<JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>> m_scopes;\n\npublic:\n\tCJSContextData() : m_scopes()\n\t{\n\t}\n\t~CJSContextData()\n\t{\n\t\tClear();\n\t}\n\n\tvoid Clear()\n\t{\n\t\tfor (std::vector<JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>>::iterator iter = m_scopes.begin(); iter != m_scopes.end(); iter++)\n\t\t{\n\t\t\t(*iter)->Close();\n\t\t}\n\t\tm_scopes.clear();\n\t}\n\n\tvoid RemoveScope(JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>& scope)\n\t{\n\t\tif (!scope.is_init())\n\t\t\treturn;\n\t\tfor (std::vector<JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>>::iterator iter = m_scopes.begin(); iter != m_scopes.end(); iter++)\n\t\t{\n\t\t\tif (scope.GetPointer() == iter->GetPointer())\n\t\t\t{\n\t\t\t\tm_scopes.erase(iter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid AddScope(JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>& scope)\n\t{\n\t\tm_scopes.push_back(scope);\n\t}\n};\n\nclass CV8RealTimeWorker\n{\npublic:\n\tJSSmart<CJSIsolateScope> m_isolate_scope;\n\tJSSmart<CJSLocalScope> m_handle_scope;\n\tJSSmart<CJSContext> m_context;\n\n\tint m_nFileType;\n\tstd::string m_sUtf8ArgumentJSON;\n\tstd::string m_sGlobalVariable;\n\n\tCJSContextData m_oContextData;\n\npublic:\n\n\tCV8RealTimeWorker(NSDoctRenderer::CDocBuilder* pBuilder);\n\t~CV8RealTimeWorker();\n\npublic:\n\n\tstatic void _LOGGING_ERROR_(const std::wstring& strType, const std::wstring& strError);\n\n\tbool ExecuteCommand(const std::wstring& command, NSDoctRenderer::CDocBuilderValue* retValue = NULL);\n\n\tstd::string GetGlobalVariable();\n\tstd::wstring GetJSVariable(std::wstring sParam);\n\n\tbool OpenFile(const std::wstring& sBasePath, const std::wstring& path, const std::string& sString, const std::wstring& sCachePath, CV8Params* pParams = NULL);\n\tbool SaveFileWithChanges(int type, const std::wstring& _path, const std::wstring& sJsonParams = L\"\");\n};\n\nnamespace NSDoctRenderer\n{\n\tclass CAdditionalData\n\t{\n\tpublic:\n\t\tCAdditionalData() {}\n\t\tvirtual ~CAdditionalData() {}\n\t\tvirtual std::string getParam(const std::wstring& name) { return \"\"; }\n\t};\n\n\tclass CDocBuilderParams\n\t{\n\tpublic:\n\t\tCDocBuilderParams() : m_bCheckFonts(false), m_sWorkDir(L\"\"), m_bSaveWithDoctrendererMode(false), m_sArgumentJSON(\"\"), m_bIsSystemFonts(true) {}\n\n\tpublic:\n\t\tbool m_bCheckFonts;\n\t\tstd::wstring m_sWorkDir;\n\t\tbool m_bSaveWithDoctrendererMode;\n\t\tstd::string m_sArgumentJSON;\n\n\t\tbool m_bIsSystemFonts;\n\t\tstd::vector<std::wstring> m_arFontDirs;\n\t};\n\n\tclass CDocBuilder_Private : public CDoctRendererConfig\n\t{\n\tpublic:\n\t\tstd::wstring m_strEditorType;\n\t\tstd::wstring m_strFilePath;\n\n\t\tstd::wstring m_sTmpFolder;\n\t\tstd::wstring m_sFileDir;\n\t\tint m_nFileType;\n\n\t\tstd::wstring m_sX2tPath;\n\n\t\tCV8RealTimeWorker* m_pWorker;\n\n\t\tCAdditionalData* m_pAdditionalData;\n\n\t\tCDocBuilderParams m_oParams;\n\t\tbool m_bIsInit;\n\n\t\tbool m_bIsCacheScript;\n\n\t\tbool m_bIsServerSafeVersion;\n\t\tstd::wstring m_sFolderForSaveOnlyUseNames;\n\n\t\tstd::string m_sGlobalVariable;\n\t\tbool m_bIsGlobalVariableUse;\n\n\t\tNSDoctRenderer::CDocBuilder* m_pParent;\n\n\t\tstatic std::wstring m_sExternalDirectory;\n\tpublic:\n\t\tCDocBuilder_Private() : CDoctRendererConfig(), m_sTmpFolder(NSFile::CFileBinary::GetTempPath()), m_nFileType(-1),\n\t\t\tm_pWorker(NULL), m_pAdditionalData(NULL), m_bIsInit(false), m_bIsCacheScript(true), m_bIsServerSafeVersion(false),\n\t\t\tm_sGlobalVariable(\"\"), m_bIsGlobalVariableUse(false), m_pParent(NULL)\n\t\t{\n\t\t}\n\n\t\tvoid Init()\n\t\t{\n\t\t\tif (m_bIsInit)\n\t\t\t\treturn;\n\n\t\t\tstd::wstring sWorkDir = m_oParams.m_sWorkDir;\n\t\t\tif (sWorkDir.empty() || !NSDirectory::Exists(sWorkDir))\n\t\t\t{\n\t\t\t\tsWorkDir = NSFile::GetProcessDirectory();\n\t\t\t\tif (!m_oParams.m_sWorkDir.empty())\n\t\t\t\t{\n\t\t\t\t\tstd::wstring sCheck = sWorkDir;\n\t\t\t\t\tif (0 != m_oParams.m_sWorkDir.find('/'))\n\t\t\t\t\t\tsCheck += L\"/\";\n\t\t\t\t\tsCheck += m_oParams.m_sWorkDir;\n\t\t\t\t\tif (NSDirectory::Exists(sCheck))\n\t\t\t\t\t\tsWorkDir = sCheck;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::wstring sNatural = NSFile::GetProcessDirectory();\n\t\t\t\tif (0 != sWorkDir.find('/'))\n\t\t\t\t\tsNatural += L\"/\";\n\t\t\t\tsNatural += sWorkDir;\n\t\t\t\tif (NSDirectory::Exists(sNatural))\n\t\t\t\t\tsWorkDir = sNatural;\n\t\t\t}\n\n\t\t\tm_sX2tPath = sWorkDir;\n\n\t\t\tCDoctRendererConfig::Parse(sWorkDir);\n\n\t\t\tCheckFonts(m_oParams.m_bCheckFonts);\n\n\t\t\tm_bIsInit = true;\n\t\t}\n\n\t\t~CDocBuilder_Private()\n\t\t{\n\t\t\tCloseFile();\n\n\t\t\tRELEASEOBJECT(m_pAdditionalData);\n\t\t}\n\n\t\tvoid CheckFonts(bool bIsCheckFonts)\n\t\t{\n\t\t\tstd::wstring sDirectory = NSFile::GetDirectoryName(m_strAllFonts);\n\t\t\tstd::wstring strFontsSelectionBin = sDirectory + L\"/font_selection.bin\";\n\n\t\t\tif (!bIsCheckFonts && NSFile::CFileBinary::Exists(strFontsSelectionBin))\n\t\t\t\treturn;\n\n\t\t\tCApplicationFontsWorker oWorker;\n\t\t\toWorker.m_bIsUseSystemFonts = m_oParams.m_bIsSystemFonts;\n\t\t\toWorker.m_arAdditionalFolders = m_oParams.m_arFontDirs;\n\t\t\toWorker.m_bIsNeedThumbnails = false;\n\t\t\toWorker.m_sDirectory = sDirectory;\n\t\t\t// \u044d\u0442\u043e \u043d\u0435 \u0440\u0430\u0431\u043e\u0447\u0430\u044f \u043f\u0430\u043f\u043a\u0430, \u0433\u0434\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0448\u0440\u0438\u0444\u0442\u044b\n\t\t\toWorker.m_bIsCleanDirectory = false;\n\t\t\tNSFonts::IApplicationFonts* pFonts = oWorker.Check();\n\t\t\tif(pFonts)\n\t\t\t\tpFonts->Release();\n\t\t}\n\n\t\tvoid CheckFileDir()\n\t\t{\n\t\t\tm_sFileDir = NSFile::CFileBinary::CreateTempFileWithUniqueName(m_sTmpFolder, L\"DE_\");\n\t\t\tif (NSFile::CFileBinary::Exists(m_sFileDir))\n\t\t\t\tNSFile::CFileBinary::Remove(m_sFileDir);\n\n\t\t\tNSStringUtils::string_replace(m_sFileDir, L\"\\\\\", L\"/\");\n\n\t\t\tstd::wstring::size_type nPosPoint = m_sFileDir.rfind('.');\n\t\t\tif (nPosPoint != std::wstring::npos && nPosPoint > m_sTmpFolder.length())\n\t\t\t{\n\t\t\t\tm_sFileDir = m_sFileDir.substr(0, nPosPoint);\n\t\t\t}\n\n\t\t\tm_nFileType = -1;\n\n\t\t\tNSDirectory::CreateDirectory(m_sFileDir);\n\t\t}\n\n\t\tbool CreateFile(int type)\n\t\t{\n\t\t\tInit();\n#if 1\n\t\t\tCheckFileDir();\n\n\t\t\tstd::wstring sEmptyPath = m_sX2tPath + L\"/empty/\";\n\n#if 0\n\t\t\tif (type & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"docx.bin\";\n\t\t\t\tm_nFileType = 0;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"pptx.bin\";\n\t\t\t\tm_nFileType = 1;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"xlsx.bin\";\n\t\t\t\tm_nFileType = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\t\tbool bRet = NSFile::CFileBinary::Copy(sEmptyPath, m_sFileDir + L\"/Editor.bin\");\n\t\t\tif (bRet)\n\t\t\t{\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/media\");\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/changes\");\n\t\t\t}\n#endif\n\n\t\t\tif (type & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"new.docx\";\n\t\t\t\tm_nFileType = 0;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"new.pptx\";\n\t\t\t\tm_nFileType = 1;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"new.xlsx\";\n\t\t\t\tm_nFileType = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\t\tbool bRet = (0 == ConvertToInternalFormat(m_sFileDir, sEmptyPath, L\"\")) ? true : false;\n\t\t\tif (bRet)\n\t\t\t{\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/media\");\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/changes\");\n\t\t\t}\n\n\t\t\treturn bRet;\n#else\n\t\t\tstd::wstring sPath = m_sX2tPath + L\"/empty/new.\";\n\t\t\tif (type & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t\tsPath += L\"docx\";\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t\tsPath += L\"pptx\";\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t\tsPath += L\"xlsx\";\n\t\t\treturn this->OpenFile(sPath, L\"\");\n#endif\n\t\t}\n\n\t\tvoid MoveFileOpen(const std::wstring& from, const std::wstring& to)\n\t\t{\n#ifdef BUIDLER_OPEN_DOWNLOAD_ENABLED\n\t\t\tint n1 = (int)from.find (L\"www\");\n\t\t\tint n2 = (int)from.find (L\"http\");\n\t\t\tint n3 = (int)from.find (L\"ftp\");\n\t\t\tint n4 = (int)from.find (L\"https\");\n\n\t\t\t//\u0435\u0441\u043b\u0438 nI \u0441\u0440\u0430\u043d\u0438\u0432\u0430\u0442\u044c \u043d\u0435 \u0441 0, \u0442\u043e \u0431\u0443\u0434\u0443\u0442 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b\n\t\t\t//\u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0432 \u0438\u043d\u0441\u0442\u0430\u043b\u044f\u0446\u0438\u0438 \u043c\u044b \u043a\u043b\u0430\u0434\u0435\u043c \u0444\u0430\u0439\u043b\u044b \u0432 /var/www...\n\t\t\tif (0 == n1 || 0 == n2 || 0 == n3 || 0 == n4)\n\t\t\t{\n\t\t\t\tNSNetwork::NSFileTransport::CFileDownloader oDownloader(from, false);\n\t\t\t\toDownloader.SetFilePath(to);\n\t\t\t\tif (oDownloader.DownloadSync())\n\t\t\t\t\treturn;\n\t\t\t}\n#endif\n\n#ifdef BUIDLER_OPEN_BASE64_ENABLED\n\t\t\tif (0 == from.find(L\"data:\"))\n\t\t\t{\n\t\t\t\tstd::wstring::size_type findBase64 = from.find(L\"base64,\");\n\t\t\t\tif (std::wstring::npos != findBase64)\n\t\t\t\t{\n\t\t\t\t\tint nStartBase64 = (int)findBase64;\n\t\t\t\t\tif (50 > nStartBase64)\n\t\t\t\t\t{\n\t\t\t\t\t\tnStartBase64 += 7;\n\t\t\t\t\t\tconst wchar_t* pStart = from.c_str() + nStartBase64;\n\t\t\t\t\t\tint nDataLen = (int)from.length() - nStartBase64;\n\n\t\t\t\t\t\tstd::string sBase64 = NSFile::CUtf8Converter::GetUtf8StringFromUnicode2(pStart, (LONG)nDataLen, false);\n\n\t\t\t\t\t\tBYTE* pDataDst = NULL;\n\t\t\t\t\t\tint nDataDstLen = 0;\n\t\t\t\t\t\tif (NSFile::CBase64Converter::Decode(sBase64.c_str(), (int)sBase64.length(), pDataDst, nDataLen))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNSFile::CFileBinary oFileDst;\n\t\t\t\t\t\t\tif (oFileDst.CreateFileW(to))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toFileDst.WriteFile(pDataDst, (DWORD)nDataDstLen);\n\t\t\t\t\t\t\t\toFileDst.CloseFile();\n\n\t\t\t\t\t\t\t\tRELEASEARRAYOBJECTS(pDataDst);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tRELEASEARRAYOBJECTS(pDataDst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\t// \u043d\u0435 \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0432 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438.\n\t\t\tif (m_bIsServerSafeVersion)\n\t\t\t\treturn;\n\n\t\t\tNSFile::CFileBinary::Copy(from, to);\n\t\t}\n\n\t\tint ConvertToInternalFormat(const std::wstring& sFolder, const std::wstring& sFile, const std::wstring& sParams)\n\t\t{\n\t\t\tNSStringUtils::CStringBuilder oBuilder;\n\t\t\toBuilder.WriteString(L\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><TaskQueueDataConvert><m_sFileFrom>\");\n\t\t\toBuilder.WriteEncodeXmlString(sFile);\n\t\t\toBuilder.WriteString(L\"</m_sFileFrom><m_sFileTo>\");\n\t\t\toBuilder.WriteEncodeXmlString(sFolder);\n\t\t\toBuilder.WriteString(L\"/Editor.bin</m_sFileTo><m_nFormatTo>8192</m_nFormatTo>\");\n\n\t\t\tif (!m_bIsNotUseConfigAllFontsDir)\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_sX2tPath + L\"/sdkjs/common\");\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(NSFile::GetDirectoryName(m_strAllFonts));\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\n\t\t\t\toBuilder.WriteString(L\"<m_sAllFontsPath>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_strAllFonts);\n\t\t\t\toBuilder.WriteString(L\"</m_sAllFontsPath>\");\n\t\t\t}\n\n\t\t\toBuilder.WriteString(L\"<m_bIsNoBase64>true</m_bIsNoBase64>\");\n\t\t\toBuilder.WriteString(L\"<m_sThemeDir>./sdkjs/slide/themes</m_sThemeDir><m_bDontSaveAdditional>true</m_bDontSaveAdditional>\");\n\t\t\toBuilder.WriteString(sParams);\n\t\t\toBuilder.WriteString(L\"</TaskQueueDataConvert>\");\n\n\t\t\tstd::wstring sXmlConvert = oBuilder.GetData();\n\n\t\t\tstd::wstring sConverterExe = m_sX2tPath + L\"/x2t\";\n\n\t\t\tint nReturnCode = 0;\n\n\t\t\tstd::wstring sTempFileForParams = sFolder + L\"/params_from.xml\";\n\t\t\tNSFile::CFileBinary::SaveToFile(sTempFileForParams, sXmlConvert, true);\n\n#ifdef WIN32\n\t\t\tstd::wstring sApp = L\"x2t32 \";\n\n\t\t\tif (NSFile::CFileBinary::Exists(sConverterExe + L\".exe\"))\n\t\t\t{\n\t\t\t\tsApp = L\"x2t \";\n\t\t\t\tsConverterExe += L\".exe\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tsConverterExe += L\"32.exe\";\n\n\t\t\tSTARTUPINFO sturtupinfo;\n\t\t\tZeroMemory(&sturtupinfo,sizeof(STARTUPINFO));\n\t\t\tsturtupinfo.cb = sizeof(STARTUPINFO);\n\n\t\t\tsApp += (L\"\\\"\" + sTempFileForParams + L\"\\\"\");\n\t\t\twchar_t* pCommandLine = NULL;\n\t\t\tif (true)\n\t\t\t{\n\t\t\t\tpCommandLine = new wchar_t[sApp.length() + 1];\n\t\t\t\tmemcpy(pCommandLine, sApp.c_str(), sApp.length() * sizeof(wchar_t));\n\t\t\t\tpCommandLine[sApp.length()] = (wchar_t)'\\0';\n\t\t\t}\n\n\t\t\tPROCESS_INFORMATION processinfo;\n\t\t\tZeroMemory(&processinfo,sizeof(PROCESS_INFORMATION));\n\t\t\tBOOL bResult = CreateProcessW(sConverterExe.c_str(), pCommandLine,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &sturtupinfo, &processinfo);\n\n\t\t\t::WaitForSingleObject(processinfo.hProcess, INFINITE);\n\n\t\t\tRELEASEARRAYOBJECTS(pCommandLine);\n\n\t\t\t//get exit code\n\t\t\tDWORD dwExitCode = 0;\n\t\t\tif (GetExitCodeProcess(processinfo.hProcess, &dwExitCode))\n\t\t\t{\n\t\t\t\tnReturnCode = (int)dwExitCode;\n\t\t\t}\n\n\t\t\tCloseHandle(processinfo.hProcess);\n\t\t\tCloseHandle(processinfo.hThread);\n\n#endif\n\n#ifdef LINUX\n\t\t\tpid_t pid = fork(); // create child process\n\t\t\tint status;\n\n\t\t\tstd::string sProgramm = U_TO_UTF8(sConverterExe);\n\t\t\tstd::string sXmlA = U_TO_UTF8(sTempFileForParams);\n\n\t\t\tswitch (pid)\n\t\t\t{\n\t\t\tcase -1: // error\n\t\t\t\tbreak;\n\n\t\t\tcase 0: // child process\n\t\t\t{\n\t\t\t\tstd::string sLibraryDir = sProgramm;\n\t\t\t\tstd::string sPATH = sProgramm;\n\t\t\t\tif (std::string::npos != sProgramm.find_last_of('/'))\n\t\t\t\t{\n\t\t\t\t\tsLibraryDir = \"LD_LIBRARY_PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t\tsPATH = \"PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t}\n\n#ifdef _MAC\n\t\t\t\tsLibraryDir = \"DY\" + sLibraryDir;\n#endif\n\n\t\t\t\tconst char* nargs[3];\n\t\t\t\tnargs[0] = sProgramm.c_str();\n\t\t\t\tnargs[1] = sXmlA.c_str();\n\t\t\t\tnargs[2] = NULL;\n\n#ifndef _MAC\n\t\t\t\tconst char* nenv[2];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = NULL;\n#else\n\t\t\t\tconst char* nenv[3];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = sPATH.c_str();\n\t\t\t\tnenv[2] = NULL;\n#endif\n\n\t\t\t\texecve(sProgramm.c_str(),\n\t\t\t\t\t   (char * const *)nargs,\n\t\t\t\t\t   (char * const *)nenv);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: // parent process, pid now contains the child pid\n\t\t\t\twhile (-1 == waitpid(pid, &status, 0)); // wait for child to complete\n\t\t\t\tif (WIFEXITED(status))\n\t\t\t\t{\n\t\t\t\t\tnReturnCode =  WEXITSTATUS(status);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tNSFile::CFileBinary::Remove(sTempFileForParams);\n\n\t\t\treturn nReturnCode;\n\t\t}\n\n\t\tstd::wstring GetFileCopyExt(const std::wstring& path)\n\t\t{\n\t\t\tstd::wstring sExtCopy = NSFile::GetFileExtention(path);\n\n\t\t\tif (true)\n\t\t\t{\n\t\t\t\t// \u0434\u043b\u044f \u0444\u0430\u0439\u043b\u043e\u0432 \u043f\u043e \u0441\u0441\u044b\u043b\u043a\u0435 - \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u043b\u043e\u0445\u0438\u043c.\n\t\t\t\tconst wchar_t* sExtCopyPtr = sExtCopy.c_str();\n\t\t\t\tint nExtCopyLen = sExtCopy.length();\n\t\t\t\tint nValidIndex = 0;\n\t\t\t\twhile (nValidIndex < nExtCopyLen)\n\t\t\t\t{\n\t\t\t\t\twchar_t c = sExtCopyPtr[nValidIndex];\n\t\t\t\t\tif ((c >= 'a' && c <= 'z') ||\n\t\t\t\t\t\t\t(c >= 'A' && c <= 'Z') ||\n\t\t\t\t\t\t\t(c >= '0' && c <= '9'))\n\t\t\t\t\t{\n\t\t\t\t\t\t++nValidIndex;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (nValidIndex > 0)\n\t\t\t\t{\n\t\t\t\t\tsExtCopy = sExtCopy.substr(0, nValidIndex);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsExtCopy = L\"tmp\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sExtCopy;\n\t\t}\n\n\t\tint OpenFile(const std::wstring& path, const std::wstring& params)\n\t\t{\n\t\t\tInit();\n\n\t\t\tLOGGER_SPEED_START\n\n\t\t\t\t\tCheckFileDir();\n\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/changes\");\n\n\t\t\tstd::wstring sExtCopy = GetFileCopyExt(path);\n\t\t\tstd::wstring sFileCopy = m_sFileDir + L\"/origin.\" + sExtCopy;\n\t\t\tMoveFileOpen(path, sFileCopy);\n\n\t\t\tCOfficeFileFormatChecker oChecker;\n\t\t\tif (!oChecker.isOfficeFile(sFileCopy))\n\t\t\t\treturn false;\n\n\t\t\tif (oChecker.nFileType & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t\tm_nFileType = 0;\n\t\t\tif (oChecker.nFileType & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t\tm_nFileType = 1;\n\t\t\tif (oChecker.nFileType & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t\tm_nFileType = 2;\n\n\t\t\tint nReturnCode = ConvertToInternalFormat(m_sFileDir, sFileCopy, params);\n\n\t\t\tLOGGER_SPEED_LAP(\"open_convert\")\n\n\t\t\t\t\tif (0 == nReturnCode)\n\t\t\t\t\treturn 0;\n\n\t\t\tNSDirectory::DeleteDirectory(m_sFileDir);\n\t\t\tm_sFileDir = L\"\";\n\t\t\tm_nFileType = -1;\n\n\t\t\tstd::wstring sErrorLog = L\"open file error (\" + std::to_wstring(nReturnCode) + L\")\";\n\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error: \", sErrorLog);\n\t\t\treturn nReturnCode;\n\t\t}\n\n\t\tvoid CloseFile()\n\t\t{\n\t\t\tInit();\n\n\t\t\tif (NSDirectory::Exists(m_sFileDir))\n\t\t\t\tNSDirectory::DeleteDirectory(m_sFileDir);\n\n\t\t\tm_sFileDir = L\"\";\n\t\t\tm_nFileType = -1;\n\n\t\t\tif (m_pWorker)\n\t\t\t\tm_sGlobalVariable = m_pWorker->GetGlobalVariable();\n\t\t\tRELEASEOBJECT(m_pWorker);\n\t\t}\n\n\t\tstd::wstring GetSaveFilePath(const std::wstring& path)\n\t\t{\n\t\t\tstd::wstring _path = path;\n\t\t\tif (!m_sFolderForSaveOnlyUseNames.empty())\n\t\t\t{\n\t\t\t\t_path = m_sFolderForSaveOnlyUseNames;\n\t\t\t\twchar_t last = m_sFolderForSaveOnlyUseNames.c_str()[m_sFolderForSaveOnlyUseNames.length() - 1];\n\t\t\t\tif (last != '/' && last != '\\\\')\n\t\t\t\t\t_path += L\"/\";\n\t\t\t\t_path += NSFile::GetFileName(path);\n\t\t\t}\n\n\t\t\tstd::wstring sDstFileDir = NSFile::GetDirectoryName(_path);\n\t\t\tif ((sDstFileDir != _path) && !NSDirectory::Exists(sDstFileDir))\n\t\t\t\tNSDirectory::CreateDirectories(sDstFileDir);\n\n\t\t\treturn _path;\n\t\t}\n\n\t\tint SaveFile(const int& type, const std::wstring& path, const wchar_t* params = NULL)\n\t\t{\n\t\t\tInit();\n\n\t\t\tif (-1 == m_nFileType)\n\t\t\t{\n\t\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error (save)\", L\"file not opened!\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tLOGGER_SPEED_START\n\n\t\t\t\t\tstd::wstring sConvertionParams = L\"\";\n\t\t\tif (NULL != params)\n\t\t\t{\n\t\t\t\tsConvertionParams = std::wstring(params);\n\t\t\t\tNSStringUtils::string_replace(sConvertionParams, L\"\\'\", L\"&quot;\");\n\t\t\t}\n\n\t\t\tstd::wstring sFileBin = L\"/Editor.bin\";\n\n\t\t\tif (!m_oParams.m_bSaveWithDoctrendererMode && m_pWorker)\n\t\t\t{\n\t\t\t\tstd::wstring sJsonParams = sConvertionParams;\n\t\t\t\tif (!sJsonParams.empty())\n\t\t\t\t{\n\t\t\t\t\tstd::wstring::size_type pos1 = sJsonParams.find(L\">\");\n\t\t\t\t\tstd::wstring::size_type pos2 = sJsonParams.find(L\"</\");\n\t\t\t\t\tif (std::wstring::npos != pos1 && std::wstring::npos != pos2)\n\t\t\t\t\t{\n\t\t\t\t\t\tsJsonParams = sJsonParams.substr(pos1 + 1, pos2 - pos1 - 1);\n\t\t\t\t\t\tNSStringUtils::string_replace(sJsonParams, L\"&quot;\", L\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsJsonParams = L\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis->m_pWorker->SaveFileWithChanges(type, m_sFileDir + L\"/Editor2.bin\", sJsonParams);\n\t\t\t\tsFileBin = L\"/Editor2.bin\";\n\t\t\t}\n\n\t\t\tNSStringUtils::CStringBuilder oBuilder;\n\n\t\t\tstd::wstring _path = GetSaveFilePath(path);\n\n\t\t\toBuilder.WriteString(L\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><TaskQueueDataConvert><m_sFileFrom>\");\n\t\t\toBuilder.WriteEncodeXmlString(m_sFileDir);\n\t\t\toBuilder.WriteString(sFileBin + L\"</m_sFileFrom><m_sFileTo>\");\n\t\t\toBuilder.WriteEncodeXmlString(_path);\n\t\t\toBuilder.WriteString(L\"</m_sFileTo><m_nFormatTo>\");\n\t\t\toBuilder.WriteString(std::to_wstring(type));\n\t\t\toBuilder.WriteString(L\"</m_nFormatTo><m_sThemeDir>\");\n\t\t\toBuilder.WriteEncodeXmlString(L\"./sdkjs/slide/themes\");\n\t\t\tif (!m_oParams.m_bSaveWithDoctrendererMode)\n\t\t\t\toBuilder.WriteString(L\"</m_sThemeDir><m_bDontSaveAdditional>true</m_bDontSaveAdditional>\");\n\t\t\telse\n\t\t\t\toBuilder.WriteString(L\"</m_sThemeDir><m_bFromChanges>true</m_bFromChanges><m_bDontSaveAdditional>true</m_bDontSaveAdditional>\");\n\t\t\toBuilder.WriteString(L\"<m_nCsvTxtEncoding>46</m_nCsvTxtEncoding><m_nCsvDelimiter>4</m_nCsvDelimiter>\");\n\n\t\t\tif (!m_bIsNotUseConfigAllFontsDir)\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_sX2tPath + L\"/sdkjs/common\");\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(NSFile::GetDirectoryName(m_strAllFonts));\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\n\t\t\t\toBuilder.WriteString(L\"<m_sAllFontsPath>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_strAllFonts);\n\t\t\t\toBuilder.WriteString(L\"</m_sAllFontsPath>\");\n\t\t\t}\n\n\t\t\tif (!sConvertionParams.empty())\n\t\t\t{\n\t\t\t\toBuilder.WriteString(sConvertionParams);\n\t\t\t}\n\n\t\t\tstd::wstring sDstTmpDir = NSDirectory::CreateDirectoryWithUniqueName(m_sFileDir);\n\n\t\t\toBuilder.WriteString(L\"<m_sTempDir>\");\n\t\t\toBuilder.WriteEncodeXmlString(sDstTmpDir);\n\t\t\toBuilder.WriteString(L\"</m_sTempDir>\");\n\n\t\t\toBuilder.WriteString(L\"</TaskQueueDataConvert>\");\n\n\t\t\tstd::wstring sXmlConvert = oBuilder.GetData();\n\n\t\t\tstd::wstring sConverterExe = m_sX2tPath + L\"/x2t\";\n\n\t\t\tint nReturnCode = 0;\n\n\t\t\tstd::wstring sTempFileForParams = m_sFileDir + L\"/params_to.xml\";\n\t\t\tNSFile::CFileBinary::SaveToFile(sTempFileForParams, sXmlConvert, true);\n\n#ifdef WIN32\n\t\t\tstd::wstring sApp = L\"x2t32 \";\n\n\t\t\tif (NSFile::CFileBinary::Exists(sConverterExe + L\".exe\"))\n\t\t\t{\n\t\t\t\tsApp = L\"x2t \";\n\t\t\t\tsConverterExe += L\".exe\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tsConverterExe += L\"32.exe\";\n\n\t\t\tSTARTUPINFO sturtupinfo;\n\t\t\tZeroMemory(&sturtupinfo,sizeof(STARTUPINFO));\n\t\t\tsturtupinfo.cb = sizeof(STARTUPINFO);\n\n\t\t\tsApp += (L\"\\\"\" + sTempFileForParams + L\"\\\"\");\n\t\t\twchar_t* pCommandLine = NULL;\n\t\t\tif (true)\n\t\t\t{\n\t\t\t\tpCommandLine = new wchar_t[sApp.length() + 1];\n\t\t\t\tmemcpy(pCommandLine, sApp.c_str(), sApp.length() * sizeof(wchar_t));\n\t\t\t\tpCommandLine[sApp.length()] = (wchar_t)'\\0';\n\t\t\t}\n\n\t\t\tPROCESS_INFORMATION processinfo;\n\t\t\tZeroMemory(&processinfo,sizeof(PROCESS_INFORMATION));\n\t\t\tBOOL bResult = CreateProcessW(sConverterExe.c_str(), pCommandLine,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &sturtupinfo, &processinfo);\n\n\t\t\t::WaitForSingleObject(processinfo.hProcess, INFINITE);\n\n\t\t\tRELEASEARRAYOBJECTS(pCommandLine);\n\n\t\t\t//get exit code\n\t\t\tDWORD dwExitCode = 0;\n\t\t\tif (GetExitCodeProcess(processinfo.hProcess, &dwExitCode))\n\t\t\t{\n\t\t\t\tnReturnCode = (int)dwExitCode;\n\t\t\t}\n\n\t\t\tCloseHandle(processinfo.hProcess);\n\t\t\tCloseHandle(processinfo.hThread);\n\n#endif\n\n#ifdef LINUX\n\t\t\tpid_t pid = fork(); // create child process\n\t\t\tint status;\n\n\t\t\tstd::string sProgramm = U_TO_UTF8(sConverterExe);\n\t\t\tstd::string sXmlA = U_TO_UTF8(sTempFileForParams);\n\n\t\t\tswitch (pid)\n\t\t\t{\n\t\t\tcase -1: // error\n\t\t\t\tbreak;\n\n\t\t\tcase 0: // child process\n\t\t\t{\n\t\t\t\tstd::string sLibraryDir = sProgramm;\n\t\t\t\tstd::string sPATH = sProgramm;\n\t\t\t\tif (std::string::npos != sProgramm.find_last_of('/'))\n\t\t\t\t{\n\t\t\t\t\tsLibraryDir = \"LD_LIBRARY_PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t\tsPATH = \"PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t}\n\n#ifdef _MAC\n\t\t\t\tsLibraryDir = \"DY\" + sLibraryDir;\n#endif\n\n\t\t\t\tconst char* nargs[3];\n\t\t\t\tnargs[0] = sProgramm.c_str();\n\t\t\t\tnargs[1] = sXmlA.c_str();\n\t\t\t\tnargs[2] = NULL;\n\n#ifndef _MAC\n\t\t\t\tconst char* nenv[2];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = NULL;\n#else\n\t\t\t\tconst char* nenv[3];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = sPATH.c_str();\n\t\t\t\tnenv[2] = NULL;\n#endif\n\n\t\t\t\texecve(sProgramm.c_str(),\n\t\t\t\t\t   (char * const *)nargs,\n\t\t\t\t\t   (char * const *)nenv);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: // parent process, pid now contains the child pid\n\t\t\t\twhile (-1 == waitpid(pid, &status, 0)); // wait for child to complete\n\t\t\t\tif (WIFEXITED(status))\n\t\t\t\t{\n\t\t\t\t\tnReturnCode =  WEXITSTATUS(status);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tNSDirectory::DeleteDirectory(sDstTmpDir);\n\t\t\tNSFile::CFileBinary::Remove(sTempFileForParams);\n\n\t\t\tLOGGER_SPEED_LAP(\"save_convert\")\n\n\t\t\t\t\tif (0 == nReturnCode)\n\t\t\t\t\treturn 0;\n\n\t\t\tstd::wstring sErrorLog = L\"save file error (\" + std::to_wstring(nReturnCode) + L\")\";\n\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error: \", sErrorLog);\n\t\t\treturn nReturnCode;\n\t\t}\n\n\t\tbool CheckWorker()\n\t\t{\n\t\t\tif (-1 == m_nFileType)\n\t\t\t{\n\t\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error (command)\", L\"file not opened!\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (NULL == m_pWorker)\n\t\t\t{\n\t\t\t\tm_pWorker = new CV8RealTimeWorker(m_pParent);\n\t\t\t\tm_pWorker->m_nFileType = m_nFileType;\n\t\t\t\tm_pWorker->m_sUtf8ArgumentJSON = m_oParams.m_sArgumentJSON;\n\t\t\t\tm_pWorker->m_sGlobalVariable = m_sGlobalVariable;\n\n\t\t\t\tstd::wstring sCachePath = L\"\";\n\t\t\t\tif (m_bIsCacheScript)\n\t\t\t\t\tsCachePath = GetScriptCache();\n\n\t\t\t\tCV8Params oParams;\n\t\t\t\toParams.IsServerSaveVersion = m_bIsServerSafeVersion;\n\t\t\t\toParams.DocumentDirectory = m_sFileDir;\n\n\t\t\t\tbool bOpen = m_pWorker->OpenFile(m_sX2tPath, m_sFileDir, GetScript(), sCachePath, &oParams);\n\t\t\t\tif (!bOpen)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tbool ExecuteCommand(const std::wstring& command, CDocBuilderValue* retValue = NULL)\n\t\t{\n\t\t\tif (command.length() < 7 && !retValue) // minimum command (!!!)\n\t\t\t\treturn true;\n\n\t\t\tInit();\n\n\t\t\tif (!CheckWorker())\n\t\t\t\treturn false;\n\n\t\t\treturn m_pWorker->ExecuteCommand(command, retValue);\n\t\t}\n\n\t\tCDocBuilderContext GetContext()\n\t\t{\n\t\t\tCDocBuilderContext ctx;\n\n\t\t\tif (!CheckWorker())\n\t\t\t\treturn ctx;\n\n\t\t\tctx.m_internal->m_context = m_pWorker->m_context;\n\t\t\tctx.m_internal->m_context_data = &m_pWorker->m_oContextData;\n\t\t\treturn ctx;\n\t\t}\n\n\t\tstd::string GetScript()\n\t\t{\n\t\t\tstd::vector<std::wstring>* arSdkFiles = NULL;\n\n\t\t\tswitch (m_nFileType)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arDoctSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arPpttSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arXlstSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tstd::string strScript = \"\";\n\t\t\tfor (size_t i = 0; i < m_arrFiles.size(); ++i)\n\t\t\t{\n\t\t\t\tstrScript += ReadScriptFile(m_arrFiles[i]);\n\t\t\t\tstrScript += \"\\n\\n\";\n\t\t\t}\n\n\t\t\tif (NULL != arSdkFiles)\n\t\t\t{\n\t\t\t\tfor (const std::wstring& i : *arSdkFiles)\n\t\t\t\t{\n\t\t\t\t\tstrScript += ReadScriptFile(i);\n\t\t\t\t\tstrScript += \"\\n\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m_nFileType == 2)\n\t\t\t\tstrScript += \"\\n$.ready();\";\n\n\t\t\treturn strScript;\n\t\t}\n\n\t\tstd::wstring GetScriptCache()\n\t\t{\n\t\t\tstd::vector<std::wstring>* arSdkFiles = NULL;\n\t\t\tswitch (m_nFileType)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arDoctSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arPpttSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arXlstSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn L\"\";\n\t\t\t}\n\n\t\t\tif (0 < arSdkFiles->size())\n\t\t\t{\n\t\t\t\treturn NSFile::GetDirectoryName(*arSdkFiles->begin()) + L\"/sdk-all.cache\";\n\t\t\t}\n\t\t\treturn L\"\";\n\t\t}\n\n\t\tstd::string ReadScriptFile(const std::wstring& strFile)\n\t\t{\n\t\t\tNSFile::CFileBinary oFile;\n\n\t\t\tif (!oFile.OpenFile(strFile))\n\t\t\t\treturn \"\";\n\n\t\t\tint nSize = (int)oFile.GetFileSize();\n\t\t\tif (nSize < 3)\n\t\t\t\treturn \"\";\n\n\t\t\tBYTE* pData = new BYTE[nSize];\n\t\t\tDWORD dwReadSize = 0;\n\t\t\toFile.ReadFile(pData, (DWORD)nSize, dwReadSize);\n\n\t\t\tint nOffset = 0;\n\t\t\tif (pData[0] == 0xEF && pData[1] == 0xBB && pData[2] == 0xBF)\n\t\t\t{\n\t\t\t\tnOffset = 3;\n\t\t\t}\n\n\t\t\tstd::string sReturn((char*)(pData + nOffset), nSize - nOffset);\n\n\t\t\tRELEASEARRAYOBJECTS(pData);\n\t\t\treturn sReturn;\n\t\t}\n\n\t\tvoid WriteData(const wchar_t* path, const wchar_t* value, const bool& append)\n\t\t{\n\t\t\tstd::wstring sValue(value);\n\t\t\tstd::string sValueA = U_TO_UTF8(sValue);\n\t\t\tNSStringUtils::string_replaceA(sValueA, \"%\", \"%%\");\n\n\t\t\tstd::wstring _sFile(path);\n\t\t\tstd::wstring sFile = GetSaveFilePath(_sFile);\n\n\t\t\tif (!append && NSFile::CFileBinary::Exists(sFile))\n\t\t\t\tNSFile::CFileBinary::Remove(sFile);\n\n\t\t\tNSFile::CFileBinary oFile;\n\t\t\tFILE* pFile = oFile.OpenFileNative(sFile, append ? L\"a+\" : L\"a\");\n\t\t\tif (pFile)\n\t\t\t{\n\t\t\t\tfprintf(pFile, sValueA.c_str());\n\t\t\t\tfclose(pFile);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#endif // DOC_BUILDER_PRIVATE\n", "#include \"../NativeControlEmbed.h\"\n#include \"../../js_internal/jsc/jsc_base.h\"\n\n@protocol IJSCNativeControl <JSExport>\n-(JSValue*) GetFilePath;\n-(JSValue*) SetFilePath : (JSValue*)path;\n-(JSValue*) GetFileId;\n-(JSValue*) SetFileId : (JSValue*)fileid;\n-(JSValue*) GetFileBinary : (JSValue*)file;\n-(JSValue*) GetFontBinary : (JSValue*)file;\n-(JSValue*) GetFontsDirectory;\n-(JSValue*) GetFileString : (JSValue*)file;\n-(JSValue*) GetEditorType;\n-(JSValue*) CheckNextChange;\n-(JSValue*) GetCountChanges;\n-(JSValue*) GetChangesFile : (JSValue*)index;\n-(JSValue*) Save_AllocNative : (JSValue*)len;\n-(JSValue*) Save_ReAllocNative : (JSValue*)pos : (JSValue*)len;\n-(JSValue*) Save_End : (JSValue*)pos : (JSValue*)len;\n-(JSValue*) AddImageInChanges : (JSValue*)img;\n-(JSValue*) ConsoleLog : (JSValue*)message;\n-(JSValue*) SaveChanges : (JSValue*)param : (JSValue*)delete_index : (JSValue*)count;\n-(JSValue*) ZipOpen : (JSValue*)name;\n-(JSValue*) ZipOpenBase64 : (JSValue*)name;\n-(JSValue*) ZipFileAsString : (JSValue*)name;\n-(JSValue*) ZipFileAsBinary : (JSValue*)name;\n-(JSValue*) ZipClose;\n-(JSValue*) GetImageUrl : (JSValue*)url;\n-(JSValue*) GetImagesPath;\n-(JSValue*) GetImageOriginalSize : (JSValue*)url;\n\n@end\n\n@interface CJSCNativeControl : NSObject<IJSCNativeControl, JSEmbedObjectProtocol>\n{\n@public\n    CNativeControlEmbed* m_internal;\n}\n@end\n\n@implementation CJSCNativeControl\n\nEMBED_OBJECT_WRAPPER_METHODS(CNativeControlEmbed)\n\nFUNCTION_WRAPPER_JS(GetFilePath, GetFilePath)\nFUNCTION_WRAPPER_JS_1(SetFilePath, SetFilePath)\nFUNCTION_WRAPPER_JS(GetFileId, GetFileId)\nFUNCTION_WRAPPER_JS_1(SetFileId, SetFileId)\nFUNCTION_WRAPPER_JS_1(GetFileBinary, GetFileBinary)\nFUNCTION_WRAPPER_JS_1(GetFontBinary, GetFontBinary);\nFUNCTION_WRAPPER_JS(GetFontsDirectory, GetFontsDirectory)\nFUNCTION_WRAPPER_JS_1(GetFileString, GetFileString)\nFUNCTION_WRAPPER_JS(GetEditorType, GetEditorType)\nFUNCTION_WRAPPER_JS(CheckNextChange, CheckNextChange)\nFUNCTION_WRAPPER_JS(GetCountChanges, GetCountChanges)\nFUNCTION_WRAPPER_JS_1(GetChangesFile, GetChangesFile)\nFUNCTION_WRAPPER_JS_1(Save_AllocNative, Save_AllocNative)\nFUNCTION_WRAPPER_JS_2(Save_ReAllocNative, Save_ReAllocNative)\nFUNCTION_WRAPPER_JS_2(Save_End, Save_End)\nFUNCTION_WRAPPER_JS_1(AddImageInChanges, AddImageInChanges)\nFUNCTION_WRAPPER_JS_1(ConsoleLog, ConsoleLog)\nFUNCTION_WRAPPER_JS_3(SaveChanges, SaveChanges)\nFUNCTION_WRAPPER_JS_1(ZipOpen, zipOpenFile)\nFUNCTION_WRAPPER_JS_1(ZipOpenBase64, zipOpenFileBase64)\nFUNCTION_WRAPPER_JS_1(ZipFileAsString, zipGetFileAsString)\nFUNCTION_WRAPPER_JS_1(ZipFileAsBinary, zipGetFileAsBinary)\nFUNCTION_WRAPPER_JS(ZipClose, zipCloseFile);\nFUNCTION_WRAPPER_JS_1(GetImageUrl, GetImageUrl);\nFUNCTION_WRAPPER_JS(GetImagesPath, GetImagesPath)\nFUNCTION_WRAPPER_JS_1(GetImageOriginalSize, GetImageOriginalSize);\n\n@end\n\nvoid CNativeControlEmbed::CreateObjectInContext(const std::string &name, JSSmart<CJSContext> context)\n{\n    context->m_internal->context[[NSString stringWithAString:name]] = ^(){\n        return [[CJSCNativeControl alloc] init];\n    };\n}\nvoid CNativeControlEmbed::CreateObjectBuilderInContext(const std::string &name, JSSmart<CJSContext> context)\n{\n    context->m_internal->context[[NSString stringWithAString:name]] = ^(){\n        return [[CJSCNativeControl alloc] init];\n    };\n}\n", "#include \"../NativeControlEmbed.h\"\n#include \"../../js_internal/v8/v8_base.h\"\n\nnamespace NSNativeControl\n{\n    #define CURRENTWRAPPER CNativeControlEmbed\n\n    FUNCTION_WRAPPER_V8(_GetFilePath, GetFilePath)\n    FUNCTION_WRAPPER_V8_1(_SetFilePath, SetFilePath)\n    FUNCTION_WRAPPER_V8(_GetFileId, GetFileId)\n    FUNCTION_WRAPPER_V8_1(_SetFileId, SetFileId)\n    FUNCTION_WRAPPER_V8_1(_GetFileArrayBuffer, GetFileBinary)\n    FUNCTION_WRAPPER_V8_1(_GetFontArrayBuffer, GetFontBinary)\n    FUNCTION_WRAPPER_V8(_GetFontsDirectory, GetFontsDirectory)\n    FUNCTION_WRAPPER_V8_1(_GetFileString, GetFileString)\n    FUNCTION_WRAPPER_V8(_GetEditorType, GetEditorType)\n    FUNCTION_WRAPPER_V8(_CheckNextChange, CheckNextChange)\n    FUNCTION_WRAPPER_V8(_GetChangesCount, GetCountChanges)\n    FUNCTION_WRAPPER_V8_1(_GetChangesFile, GetChangesFile)\n    FUNCTION_WRAPPER_V8_1(_Save_AllocNative, Save_AllocNative)\n    FUNCTION_WRAPPER_V8_2(_Save_ReAllocNative, Save_ReAllocNative)\n    FUNCTION_WRAPPER_V8_2(_Save_End, Save_End)\n    FUNCTION_WRAPPER_V8_1(_AddImageInChanges, AddImageInChanges)\n    FUNCTION_WRAPPER_V8_1(_ConsoleLog, ConsoleLog)\n    FUNCTION_WRAPPER_V8_3(_SaveChanges, SaveChanges)\n    FUNCTION_WRAPPER_V8_1(_zipOpenFile, zipOpenFile)\n    FUNCTION_WRAPPER_V8_1(_zipOpenFileBase64, zipOpenFileBase64)\n    FUNCTION_WRAPPER_V8_1(_zipGetFileAsString, zipGetFileAsString)\n    FUNCTION_WRAPPER_V8_1(_zipGetFileAsBinary, zipGetFileAsBinary)\n    FUNCTION_WRAPPER_V8(_zipCloseFile, zipCloseFile)\n    FUNCTION_WRAPPER_V8_1(_GetImageUrl, GetImageUrl)\n    FUNCTION_WRAPPER_V8_1(_GetImageOriginalSize, GetImageOriginalSize)\n    FUNCTION_WRAPPER_V8(_GetImagesPath, GetImagesPath)\n\n    v8::Handle<v8::ObjectTemplate> CreateNativeControlTemplate(v8::Isolate* isolate)\n    {\n        v8::EscapableHandleScope handle_scope(isolate);\n\n        v8::Local<v8::ObjectTemplate> result = v8::ObjectTemplate::New(V8IsolateOneArg);\n        result->SetInternalFieldCount(1);\n\n        NSV8Objects::Template_Set(result, \"SetFilePath\",        _SetFilePath);\n        NSV8Objects::Template_Set(result, \"GetFilePath\",        _GetFilePath);\n        NSV8Objects::Template_Set(result, \"SetFileId\",          _SetFileId);\n        NSV8Objects::Template_Set(result, \"GetFileId\",          _GetFileId);\n        NSV8Objects::Template_Set(result, \"GetFileBinary\",      _GetFileArrayBuffer);\n        NSV8Objects::Template_Set(result, \"GetFontBinary\",      _GetFontArrayBuffer);\n        NSV8Objects::Template_Set(result, \"GetFontsDirectory\",  _GetFontsDirectory);\n        NSV8Objects::Template_Set(result, \"GetFileString\",      _GetFileString);\n        NSV8Objects::Template_Set(result, \"GetEditorType\",      _GetEditorType);\n        NSV8Objects::Template_Set(result, \"CheckNextChange\",    _CheckNextChange);\n        NSV8Objects::Template_Set(result, \"GetCountChanges\",    _GetChangesCount);\n        NSV8Objects::Template_Set(result, \"GetChangesFile\",     _GetChangesFile);\n        NSV8Objects::Template_Set(result, \"Save_AllocNative\",   _Save_AllocNative);\n        NSV8Objects::Template_Set(result, \"Save_ReAllocNative\", _Save_ReAllocNative);\n        NSV8Objects::Template_Set(result, \"Save_End\",           _Save_End);\n        NSV8Objects::Template_Set(result, \"AddImageInChanges\",  _AddImageInChanges);\n        NSV8Objects::Template_Set(result, \"ConsoleLog\",         _ConsoleLog);\n        NSV8Objects::Template_Set(result, \"SaveChanges\",        _SaveChanges);\n        NSV8Objects::Template_Set(result, \"ZipOpen\",            _zipOpenFile);\n        NSV8Objects::Template_Set(result, \"ZipOpenBase64\",      _zipOpenFileBase64);\n        NSV8Objects::Template_Set(result, \"ZipFileAsString\",    _zipGetFileAsString);\n        NSV8Objects::Template_Set(result, \"ZipFileAsBinary\",    _zipGetFileAsBinary);\n        NSV8Objects::Template_Set(result, \"ZipClose\",           _zipCloseFile);\n        NSV8Objects::Template_Set(result, \"getImageUrl\",        _GetImageUrl);\n        NSV8Objects::Template_Set(result, \"getImagesDirectory\", _GetImagesPath);\n        NSV8Objects::Template_Set(result, \"GetImageOriginalSize\", _GetImageOriginalSize);\n\n        return handle_scope.Escape(result);\n    }\n\n    // \u0411\u0435\u0437 SaveChanges\n    v8::Handle<v8::ObjectTemplate> CreateNativeControlTemplateBuilder(v8::Isolate* isolate)\n    {\n        v8::EscapableHandleScope handle_scope(isolate);\n\n        v8::Local<v8::ObjectTemplate> result = v8::ObjectTemplate::New(V8IsolateOneArg);\n        result->SetInternalFieldCount(1);\n\n        NSV8Objects::Template_Set(result, \"SetFilePath\",        _SetFilePath);\n        NSV8Objects::Template_Set(result, \"GetFilePath\",        _GetFilePath);\n        NSV8Objects::Template_Set(result, \"SetFileId\",          _SetFileId);\n        NSV8Objects::Template_Set(result, \"GetFileId\",          _GetFileId);\n        NSV8Objects::Template_Set(result, \"GetFileBinary\",      _GetFileArrayBuffer);\n        NSV8Objects::Template_Set(result, \"GetFontBinary\",      _GetFontArrayBuffer);\n        NSV8Objects::Template_Set(result, \"GetFontsDirectory\",  _GetFontsDirectory);\n        NSV8Objects::Template_Set(result, \"GetFileString\",      _GetFileString);\n        NSV8Objects::Template_Set(result, \"GetEditorType\",      _GetEditorType);\n        NSV8Objects::Template_Set(result, \"CheckNextChange\",    _CheckNextChange);\n        NSV8Objects::Template_Set(result, \"GetCountChanges\",    _GetChangesCount);\n        NSV8Objects::Template_Set(result, \"GetChangesFile\",     _GetChangesFile);\n        NSV8Objects::Template_Set(result, \"Save_AllocNative\",   _Save_AllocNative);\n        NSV8Objects::Template_Set(result, \"Save_ReAllocNative\", _Save_ReAllocNative);\n        NSV8Objects::Template_Set(result, \"Save_End\",           _Save_End);\n        NSV8Objects::Template_Set(result, \"AddImageInChanges\",  _AddImageInChanges);\n        NSV8Objects::Template_Set(result, \"ConsoleLog\",         _ConsoleLog);\n        NSV8Objects::Template_Set(result, \"ZipOpen\",            _zipOpenFile);\n        NSV8Objects::Template_Set(result, \"ZipOpenBase64\",      _zipOpenFileBase64);\n        NSV8Objects::Template_Set(result, \"ZipFileAsString\",    _zipGetFileAsString);\n        NSV8Objects::Template_Set(result, \"ZipFileAsBinary\",    _zipGetFileAsBinary);\n        NSV8Objects::Template_Set(result, \"ZipClose\",           _zipCloseFile);\n        NSV8Objects::Template_Set(result, \"getImageUrl\",        _GetImageUrl);\n        NSV8Objects::Template_Set(result, \"getImagesDirectory\", _GetImagesPath);\n        NSV8Objects::Template_Set(result, \"GetImageOriginalSize\", _GetImageOriginalSize);\n\n        return handle_scope.Escape(result);\n    }\n\n    void CreateNativeObject(const v8::FunctionCallbackInfo<v8::Value>& args)\n    {\n        v8::Isolate* isolate = args.GetIsolate();\n        v8::HandleScope scope(isolate);\n\n        v8::Handle<v8::ObjectTemplate> NativeObjectTemplate = CreateNativeControlTemplate(isolate);\n        CNativeControlEmbed* pNativeObject = new CNativeControlEmbed();\n\n        v8::Local<v8::Object> obj = NativeObjectTemplate->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();\n        obj->SetInternalField(0, v8::External::New(CV8Worker::GetCurrent(), pNativeObject));\n\n        args.GetReturnValue().Set(obj);\n    }\n\n    // \u0411\u0435\u0437 SaveChanges\n    void CreateNativeObjectBuilder(const v8::FunctionCallbackInfo<v8::Value>& args)\n    {\n        v8::Isolate* isolate = args.GetIsolate();\n        v8::HandleScope scope(isolate);\n\n        v8::Handle<v8::ObjectTemplate> NativeObjectTemplate = CreateNativeControlTemplateBuilder(isolate);\n        CNativeControlEmbed* pNativeObject = new CNativeControlEmbed();\n\n        v8::Local<v8::Object> obj = NativeObjectTemplate->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();\n        obj->SetInternalField(0, v8::External::New(CV8Worker::GetCurrent(), pNativeObject));\n\n        args.GetReturnValue().Set(obj);\n    }\n}\n\nvoid CNativeControlEmbed::CreateObjectInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n    v8::Isolate* current = CV8Worker::GetCurrent();\n    context->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObject));\n}\n\nvoid CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n    v8::Isolate* current = CV8Worker::GetCurrent();\n    context->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}\n", "#include \"v8_base.h\"\n\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const char* str, const int& len)\n{\n\treturn v8::String::NewFromUtf8(i, str, kV8NormalString, len).ToLocalChecked();\n}\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const std::string& str)\n{\n\treturn v8::String::NewFromUtf8(i, str.c_str(), kV8NormalString, (int)str.length()).ToLocalChecked();\n}\n\nstd::wstring CV8Worker::m_sExternalDirectory = L\"\";\n\nnamespace NSJSBase\n{\n\tclass CCacheDataScript\n\t{\n\tprivate:\n\t\tBYTE* Data;\n\t\tint Length;\n\n\t\tstd::wstring Path;\n\n\tpublic:\n\t\tCCacheDataScript(const std::wstring& sPath)\n\t\t{\n\t\t\tData = NULL;\n\t\t\tLength = 0;\n\n\t\t\tPath = sPath;\n\n#ifndef V8_VERSION_89_PLUS\n\t\t\tif (!sPath.empty())\n\t\t\t{\n\t\t\t\tBYTE* _data = NULL;\n\t\t\t\tDWORD _data_length = 0;\n\t\t\t\tif (NSFile::CFileBinary::ReadAllBytes(sPath, &_data, _data_length))\n\t\t\t\t{\n\t\t\t\t\tData = _data;\n\t\t\t\t\tLength = (int)_data_length;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\t\t~CCacheDataScript()\n\t\t{\n\t\t\tRELEASEARRAYOBJECTS(Data);\n\t\t}\n\n#ifdef V8_VERSION_89_PLUS\n\t\tv8::Local<v8::Script> Compile(const v8::Local<v8::Context>& _context, const v8::Local<v8::String>& source)\n\t\t{\n\t\t\tv8::Local<v8::Script> script;\n\n\t\t\tif (Path.empty())\n\t\t\t{\n\t\t\t\t// no cache\n\t\t\t\tv8::ScriptCompiler::Source oSource(source);\n\t\t\t\tv8::MaybeLocal<v8::Script> sctiptMB = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kNoCompileOptions);\n\t\t\t\tif (!sctiptMB.IsEmpty())\n\t\t\t\t\tscript = sctiptMB.ToLocalChecked();\n\n\t\t\t\treturn script;\n\t\t\t}\n\n\t\t\tif (NSFile::CFileBinary::Exists(Path))\n\t\t\t{\n\t\t\t\t// load cache from file\n\t\t\t\tBYTE* _data = NULL;\n\t\t\t\tDWORD _data_length = 0;\n\t\t\t\tif (NSFile::CFileBinary::ReadAllBytes(Path, &_data, _data_length))\n\t\t\t\t{\n\t\t\t\t\tData = _data;\n\t\t\t\t\tLength = (int)_data_length;\n\t\t\t\t}\n\n\t\t\t\t// compile with cache\n\t\t\t\tv8::ScriptCompiler::CachedData* pCacheData = new v8::ScriptCompiler::CachedData(Data, Length);\n\t\t\t\tv8::ScriptCompiler::Source oSource(source, pCacheData);\n\n\t\t\t\tv8::MaybeLocal<v8::Script> sctiptMB = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kConsumeCodeCache);\n\t\t\t\tif (!sctiptMB.IsEmpty())\n\t\t\t\t\tscript = sctiptMB.ToLocalChecked();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv8::ScriptCompiler::CachedData* pCacheData = nullptr;\n\n\t\t\t\t// save cache to file\n\t\t\t\tNSFile::CFileBinary oFileTest;\n\t\t\t\tif (oFileTest.CreateFileW(Path))\n\t\t\t\t{\n\t\t\t\t\t// create cache data\n\t\t\t\t\tv8::ScriptCompiler::Source oSource(source);\n\t\t\t\t\tv8::Local<v8::Script> pScriptCache = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kNoCompileOptions).ToLocalChecked();\n\t\t\t\t\tpCacheData = v8::ScriptCompiler::CreateCodeCache(pScriptCache->GetUnboundScript());\n\n\t\t\t\t\tif (pCacheData)\n\t\t\t\t\t{\n\t\t\t\t\t\t// save cache to file\n\t\t\t\t\t\tNSFile::CFileBinary oFileTest;\n\t\t\t\t\t\tif (oFileTest.CreateFileW(Path))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toFileTest.WriteFile(pCacheData->data, (DWORD)pCacheData->length);\n\t\t\t\t\t\t\toFileTest.CloseFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// compile with/without(if pCacheData === NULL) cache data\n\t\t\t\tv8::ScriptCompiler::Source oSource2(source, pCacheData);\n\t\t\t\tv8::ScriptCompiler::CompileOptions compileOptions = (nullptr == pCacheData) ? v8::ScriptCompiler::kNoCompileOptions : v8::ScriptCompiler::kConsumeCodeCache;\n\n\t\t\t\tv8::MaybeLocal<v8::Script> sctiptMB = v8::ScriptCompiler::Compile(_context, &oSource2, compileOptions);\n\t\t\t\tif (!sctiptMB.IsEmpty())\n\t\t\t\t\tscript = sctiptMB.ToLocalChecked();\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n#else\n\t\tv8::Local<v8::Script> Compile(const v8::Local<v8::Context>& _context, const v8::Local<v8::String>& source)\n\t\t{\n\t\t\tv8::Local<v8::Script> script;\n\t\t\tif (NULL == Data)\n\t\t\t{\n\t\t\t\tv8::ScriptCompiler::Source oSource(source);\n\t\t\t\tscript = v8::ScriptCompiler::Compile(_context, &oSource, kV8ProduceCodeCache).ToLocalChecked();\n\n\t\t\t\tconst v8::ScriptCompiler::CachedData* _cachedData = oSource.GetCachedData();\n\t\t\t\tNSFile::CFileBinary oFileTest;\n\t\t\t\tif (_cachedData && oFileTest.CreateFileW(Path))\n\t\t\t\t{\n\t\t\t\t\toFileTest.WriteFile(_cachedData->data, (DWORD)_cachedData->length);\n\t\t\t\t\toFileTest.CloseFile();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv8::ScriptCompiler::CachedData* pCachedData = new v8::ScriptCompiler::CachedData(Data, Length);\n\t\t\t\tv8::ScriptCompiler::Source oSource(source, pCachedData);\n\t\t\t\tscript = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kConsumeCodeCache).ToLocalChecked();\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n#endif\n\n\t\tbool IsInit()\n\t\t{\n\t\t\treturn Data != NULL && Length > 0;\n\t\t}\n\t};\n\n\tclass CJSIsolateScopeV8 : public CJSIsolateScope\n\t{\n\tpublic:\n\t\tv8::Isolate::Scope  isolate_scope;\n\t\tv8::Locker          isolate_locker;\n\n\tpublic:\n\t\tCJSIsolateScopeV8(v8::Isolate* isolate) : CJSIsolateScope(),\n\t\t\tisolate_scope(isolate),\n\t\t\tisolate_locker(isolate)\n\t\t{\n\t\t}\n\t\tvirtual ~CJSIsolateScopeV8()\n\t\t{\n\t\t}\n\t};\n\n\tclass CJSContextScopeV8 : public CJSContextScope\n\t{\n\tpublic:\n\t\tv8::Context::Scope m_scope;\n\n\tpublic:\n\t\tCJSContextScopeV8(v8::Local<v8::Context> context) : m_scope(context)\n\t\t{\n\t\t}\n\t\tvirtual ~CJSContextScopeV8()\n\t\t{\n\t\t}\n\t};\n\n\tclass CJSLocalScopeV8 : public CJSLocalScope\n\t{\n\tpublic:\n\t\tv8::HandleScope m_scope;\n\n\tpublic:\n\t\tCJSLocalScopeV8() : m_scope(CV8Worker::GetCurrent())\n\t\t{\n\t\t}\n\t\tvirtual ~CJSLocalScopeV8()\n\t\t{\n\t\t}\n\t};\n\n\n\tCJSContext::CJSContext()\n\t{\n\t\tm_internal = new CJSContextPrivate();\n\t}\n\tCJSContext::~CJSContext()\n\t{\n\t\tRELEASEOBJECT(m_internal);\n\t}\n\n\tCJSTryCatch* CJSContext::GetExceptions()\n\t{\n\t\treturn new CV8TryCatch();\n\t}\n\n\tvoid CJSContext::Initialize()\n\t{\n\t\tm_internal->m_isolate = CV8Worker::getInitializer().CreateNew();\n\t}\n\tvoid CJSContext::Dispose()\n\t{\n#ifdef V8_INSPECTOR\n\t\tv8_debug::disposeInspector(m_internal->m_context);\n#endif\n\t\tm_internal->m_isolate->Dispose();\n\t\tm_internal->m_isolate = NULL;\n\t}\n\n\tvoid CJSContext::CreateContext()\n\t{\n\t\tm_internal->m_context = v8::Context::New(CV8Worker::GetCurrent(), NULL, m_internal->m_global);\n\t}\n\n\tvoid CJSContext::CreateGlobalForContext()\n\t{\n\t\tm_internal->m_global = v8::ObjectTemplate::New(CV8Worker::GetCurrent());\n\t}\n\n\tCJSObject* CJSContext::GetGlobal()\n\t{\n\t\tCJSObjectV8* ret = new CJSObjectV8();\n\t\tret->value = m_internal->m_context->Global();\n\t\treturn ret;\n\t}\n\n\tCJSIsolateScope* CJSContext::CreateIsolateScope()\n\t{\n\t\treturn new CJSIsolateScopeV8(m_internal->m_isolate);\n\t}\n\n\tCJSContextScope* CJSContext::CreateContextScope()\n\t{\n\t\tCJSContextScope* pScope = new CJSContextScopeV8(m_internal->m_context);\n\n\t\tJSSmart<CJSObject> global = GetCurrent()->GetGlobal();\n\t\tglobal->set(\"window\", global.GetPointer());\n\n\t\treturn pScope;\n\t}\n\n\tCJSLocalScope* CJSContext::CreateLocalScope()\n\t{\n\t\treturn new CJSLocalScopeV8();\n\t}\n\n\tCJSValue* CJSContext::createUndefined()\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->doUndefined();\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createNull()\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->doNull();\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createBool(const bool& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Boolean::New(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createInt(const int& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Integer::New(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createUInt(const unsigned int& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Integer::NewFromUnsigned(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createDouble(const double& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Number::New(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createString(const char* value, const int& length)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = CreateV8String(CV8Worker::GetCurrent(), value, length);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createString(const wchar_t* value, const int& length)\n\t{\n\t\tstd::string sUtf8 = NSFile::CUtf8Converter::GetUtf8StringFromUnicode2(value, (length != -1) ? (LONG)length : (LONG)wcslen(value));\n\t\treturn createString((const char*)sUtf8.c_str(), (int)sUtf8.length());\n\t}\n\n\tCJSValue* CJSContext::createString(const std::string& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = CreateV8String(CV8Worker::GetCurrent(), value.c_str(), (int)value.length());\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createString(const std::wstring& value)\n\t{\n\t\tstd::string sReturn = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(value);\n\t\treturn createString(sReturn);\n\t}\n\n\tCJSObject* CJSContext::createObject()\n\t{\n\t\tCJSObjectV8* _value = new CJSObjectV8();\n\t\t_value->value = v8::Object::New(CV8Worker::GetCurrent());\n\t\treturn _value;\n\t}\n\n\tCJSArray* CJSContext::createArray(const int& count)\n\t{\n\t\tCJSArrayV8* _value = new CJSArrayV8();\n\t\t_value->value = v8::Array::New(CV8Worker::GetCurrent(), count);\n\t\t_value->m_count = count;\n\t\treturn _value;\n\t}\n\n\tCJSTypedArray* CJSContext::createUint8Array(BYTE* data, int count, const bool& isExternalize)\n\t{\n\t\tCJSTypedArrayV8* _value = new CJSTypedArrayV8(data, count, isExternalize);\n\t\treturn _value;\n\t}\n\n\tJSSmart<CJSValue> CJSContext::runScript(const std::string& script, JSSmart<CJSTryCatch> exception, const std::wstring& scriptPath)\n\t{\n#ifdef V8_INSPECTOR\n\t\tv8_debug::before(m_internal->m_context, CV8Worker::getInitializer()->getPlatform(), \"\");\n#endif\n\t\tLOGGER_START\n\n\t\tv8::Local<v8::String> _source = CreateV8String(CV8Worker::GetCurrent(), script.c_str());\n\t\tv8::Local<v8::Script> _script;\n\t\tif(!scriptPath.empty())\n\t\t{\n\t\t\tstd::wstring sCachePath = scriptPath.substr(0, scriptPath.rfind(L\".\")) + L\".cache\";\n\t\t\tCCacheDataScript oCachedScript(sCachePath);\n\t\t\t_script = oCachedScript.Compile(m_internal->m_context, _source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv8::MaybeLocal<v8::Script> _scriptRetValue = v8::Script::Compile(V8ContextFirstArg _source);\n\t\t\tif (!_scriptRetValue.IsEmpty())\n\t\t\t\t_script = _scriptRetValue.ToLocalChecked();\n\t\t}\n\n\t\tLOGGER_LAP(\"compile\")\n\n\t\tCJSValueV8* _return = new CJSValueV8();\n\n\t\tv8::MaybeLocal<v8::Value> retValue;\n\t\tif (exception.is_init())\n\t\t{\n\t\t\tif (!exception->Check())\n\t\t\t\tretValue = _script->Run(V8ContextOneArg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretValue = _script->Run(V8ContextOneArg);\n\t\t}\n\n\t\tif (!retValue.IsEmpty())\n\t\t\t_return->value = retValue.ToLocalChecked();\n\n\t\tLOGGER_LAP(\"run\")\n\n\t\t\t\treturn _return;\n\t}\n\n\tCJSContext* CJSContext::GetCurrent()\n\t{\n\t\tCJSContext* ret = new CJSContext();\n\t\tret->m_internal->m_isolate = CV8Worker::GetCurrent();\n\t\tret->m_internal->m_context = ret->m_internal->m_isolate->GetCurrentContext();\n\t\t// global???\n\t\treturn ret;\n\t}\n\n\tCJSValue* CJSContext::JSON_Parse(const char *sTmp)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n#ifndef V8_OS_XP\n\t\tv8::MaybeLocal<v8::Value> retValue = v8::JSON::Parse(m_internal->m_context, CreateV8String(CV8Worker::GetCurrent(), sTmp));\n\t\tif (!retValue.IsEmpty())\n\t\t\t_value->value = retValue.ToLocalChecked();\n\t\telse\n\t\t\t_value->doUndefined();\n#else\n\t\t_value->value = v8::JSON::Parse(CreateV8String(CV8Worker::GetCurrent(), sTmp));\n#endif\n\t\treturn _value;\n\t}\n\n\tvoid CJSContext::MoveToThread(ASC_THREAD_ID* id)\n\t{\n\t\t// none\n\t}\n\n\tvoid CJSContext::ExternalInitialize(const std::wstring& sDirectory)\n\t{\n\t\tCV8Worker::m_sExternalDirectory = sDirectory;\n\t}\n\tvoid CJSContext::ExternalDispose()\n\t{\n\t\tCV8Worker::Dispose();\n\t}\n\tbool CJSContext::IsSupportNativeTypedArrays()\n\t{\n\t\treturn true;\n\t}\n\n\tunsigned char* NSAllocator::Alloc(const size_t& size)\n\t{\n\t\treturn (unsigned char*)CV8Worker::getInitializer().getAllocator()->AllocateUninitialized(size);\n\t}\n\tvoid NSAllocator::Free(unsigned char* data, const size_t& size)\n\t{\n\t\tCV8Worker::getInitializer().getAllocator()->Free(data, size);\n\t}\n}\n", "\ufeff#ifndef _BUILD_NATIVE_CONTROL_V8_BASE_H_\n#define _BUILD_NATIVE_CONTROL_V8_BASE_H_\n\n#ifdef V8_INSPECTOR\n#include \"inspector/inspector_interface.h\"\n#endif\n\n#include \"../js_base.h\"\n#include \"../js_logger.h\"\n#include <iostream>\n\n#ifdef __ANDROID__\n#ifndef DISABLE_MEMORY_LIMITATION\n#define DISABLE_MEMORY_LIMITATION\n#endif\n#endif\n\n#include \"v8.h\"\n#include \"libplatform/libplatform.h\"\n\n#ifndef DISABLE_MEMORY_LIMITATION\n#include \"src/base/sys-info.h\"\n#endif\n\n#ifdef V8_VERSION_89_PLUS\n#define kV8NormalString v8::NewStringType::kNormal\n#define kV8ProduceCodeCache v8::ScriptCompiler::kEagerCompile\n#define V8ContextFirstArg CV8Worker::GetCurrentContext(),\n#define V8ContextOneArg CV8Worker::GetCurrentContext()\n#define V8IsolateFirstArg CV8Worker::GetCurrent(),\n#define V8IsolateOneArg CV8Worker::GetCurrent()\n#define V8ToChecked ToChecked\n#else\n#define kV8NormalString v8::NewStringType::kNormal\n#define kV8ProduceCodeCache v8::ScriptCompiler::kProduceCodeCache\n#define V8ContextFirstArg CV8Worker::GetCurrentContext(),\n#define V8ContextOneArg CV8Worker::GetCurrentContext()\n#define V8IsolateFirstArg\n#define V8IsolateOneArg CV8Worker::GetCurrent()\n#ifdef V8_OS_XP\n#define V8ToChecked FromJust\n#else\n#define V8ToChecked ToChecked\n#endif\n#endif\n\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const char* str, const int& len = -1);\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const std::string& str);\n\n#ifdef __ANDROID__\n    #include <JniLogUtils.h>\n#endif\n\n#ifdef V8_OS_XP\nclass MallocArrayBufferAllocator : public v8::ArrayBuffer::Allocator\n{\npublic:\n    virtual void* Allocate(size_t length)\n    {\n        void* ret = malloc(length);\n        memset(ret, 0, length);\n        return ret;\n    }\n    virtual void* AllocateUninitialized(size_t length)\n    {\n        return malloc(length);\n    }\n    virtual void Free(void* data, size_t length)\n    {\n        free(data);\n    }\n};\n#endif\n\nclass CV8Initializer\n{\nprivate:\n#ifdef V8_VERSION_89_PLUS\n    std::unique_ptr<v8::Platform> m_platform;\n#else\n    v8::Platform* m_platform;\n#endif\n    v8::ArrayBuffer::Allocator* m_pAllocator;\n\npublic:\n    v8::Platform* getPlatform()\n    {\n#ifdef V8_VERSION_89_PLUS\n        return m_platform.get();\n#else\n        return m_platform;\n#endif\n    }\n    CV8Initializer(const std::wstring& sDirectory = L\"\")\n    {\n        std::wstring sPrW = sDirectory.empty() ? NSFile::GetProcessPath() : sDirectory;\n        std::string sPrA = U_TO_UTF8(sPrW);\n\n        m_pAllocator = NULL;\n\n    #ifndef V8_OS_XP\n        v8::V8::InitializeICUDefaultLocation(sPrA.c_str());\n        v8::V8::InitializeExternalStartupData(sPrA.c_str());\n        #ifdef V8_VERSION_89_PLUS\n        m_platform = v8::platform::NewDefaultPlatform();\n        v8::V8::InitializePlatform(m_platform.get());\n        #else\n        m_platform = v8::platform::CreateDefaultPlatform();\n        v8::V8::InitializePlatform(m_platform);\n        #endif\n        v8::V8::Initialize();\n    #else\n        m_platform = v8::platform::CreateDefaultPlatform();\n        v8::V8::InitializePlatform(m_platform);\n        v8::V8::Initialize();\n        v8::V8::InitializeICU();\n    #endif\n    }\n\n    void Dispose()\n    {\n#ifndef V8_VERSION_89_PLUS\n        if (!m_platform)\n            return;\n#else\n        if (!m_platform.get())\n            return;\n#endif\n\n        v8::V8::Dispose();\n        v8::V8::ShutdownPlatform();\n        if (m_pAllocator)\n            delete m_pAllocator;\n\n#ifndef V8_VERSION_89_PLUS\n        delete m_platform;\n        m_platform = NULL;\n#else\n        m_platform.reset();\n#endif\n    }\n\n    ~CV8Initializer()\n    {\n        Dispose();\n    }\n\n    v8::ArrayBuffer::Allocator* getAllocator()\n    {\n        return m_pAllocator;\n    }\n\n    v8::Isolate* CreateNew()\n    {\n        v8::Isolate::CreateParams create_params;\n    #ifndef V8_OS_XP\n        m_pAllocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n    #else\n        m_pAllocator = new MallocArrayBufferAllocator();\n    #endif\n        create_params.array_buffer_allocator = m_pAllocator;\n\n    #ifndef DISABLE_MEMORY_LIMITATION\n        int64_t nMaxVirtualMemory = v8::base::SysInfo::AmountOfVirtualMemory();\n        if (0 == nMaxVirtualMemory)\n            nMaxVirtualMemory = 4000000000; // 4Gb\n\n        create_params.constraints.ConfigureDefaults(\n              v8::base::SysInfo::AmountOfPhysicalMemory(),\n              nMaxVirtualMemory);\n    #endif\n\n        return v8::Isolate::New(create_params);\n    }\n};\n\nclass CV8Worker\n{\npublic:\n    CV8Worker() {}\n    ~CV8Worker() {}\n\n    static std::wstring m_sExternalDirectory;\n\n    static CV8Initializer& getInitializer()\n    {\n        static CV8Initializer oInitializer(m_sExternalDirectory);\n        return oInitializer;\n    }\n\n    static void Dispose()\n    {\n        getInitializer().Dispose();\n    }\n\n    static v8::Isolate* GetCurrent()\n    {\n        return v8::Isolate::GetCurrent();\n    }\n    static v8::Local<v8::Context> GetCurrentContext()\n    {\n        return v8::Isolate::GetCurrent()->GetCurrentContext();\n    }\n};\n\nnamespace NSJSBase\n{\n\n    template<typename V, typename B>\n    class CJSValueV8Template : public B\n    {\n    public:\n        v8::Local<V> value;\n\n        CJSValueV8Template()\n        {\n        }\n\n        CJSValueV8Template(const v8::Local<V>& _value)\n        {\n            value = _value;\n        }\n\n    public:\n\n        virtual ~CJSValueV8Template()\n        {\n            value.Clear();\n        }\n\n        virtual bool isUndefined()\n        {\n            return value.IsEmpty() ? false : value->IsUndefined();\n        }\n        virtual bool isNull()\n        {\n            return value.IsEmpty() ? false : value->IsNull();\n        }\n        virtual bool isBool()\n        {\n            return value.IsEmpty() ? false : value->IsBoolean();\n        }\n        virtual bool isNumber()\n        {\n            return value.IsEmpty() ? false : value->IsNumber();\n        }\n        virtual bool isString()\n        {\n            return value.IsEmpty() ? false : value->IsString();\n        }\n        virtual bool isArray()\n        {\n            return value.IsEmpty() ? false : value->IsArray();\n        }\n        virtual bool isTypedArray()\n        {\n            return value.IsEmpty() ? false : value->IsTypedArray();\n        }\n        virtual bool isObject()\n        {\n            return value.IsEmpty() ? false : value->IsObject();\n        }\n        virtual bool isFunction()\n        {\n            return value.IsEmpty() ? false : value->IsFunction();\n        }\n        virtual bool isEmpty()\n        {\n            return value.IsEmpty();\n        }\n\n        virtual void doUndefined()\n        {            \n        }\n\n        virtual void doNull()\n        {\n        }\n\n        virtual bool toBool()\n        {\n            return false;\n        }\n\n        virtual int toInt32()\n        {\n            return 0;\n        }\n\n        virtual unsigned int toUInt32()\n        {\n            return 0;\n        }\n\n        virtual double toDouble()\n        {\n            return 0;\n        }\n\n        virtual std::string toStringA()\n        {\n            return \"\";\n        }\n\n        virtual std::wstring toStringW()\n        {\n            return L\"\";\n        }\n\n        virtual CJSObject* toObject();\n        virtual CJSArray* toArray();\n        virtual CJSTypedArray* toTypedArray();\n        virtual CJSFunction* toFunction();\n    };\n\n    class CJSValueV8TemplatePrimitive : public CJSValueV8Template<v8::Value, CJSValue>\n    {\n    public:\n        CJSValueV8TemplatePrimitive()\n        {\n        }\n        CJSValueV8TemplatePrimitive(const v8::Local<v8::Value>& _value) : CJSValueV8Template<v8::Value, CJSValue>(_value)\n        {\n        }\n\n        virtual ~CJSValueV8TemplatePrimitive()\n        {\n            value.Clear();\n        }\n\n        virtual void doUndefined()\n        {\n            value = v8::Undefined(CV8Worker::GetCurrent());\n        }\n\n        virtual void doNull()\n        {\n            value = v8::Null(CV8Worker::GetCurrent());\n        }\n\n        virtual bool toBool()\n        {\n#ifdef V8_VERSION_89_PLUS\n            return value.IsEmpty() ? false : value->BooleanValue(V8IsolateOneArg);\n#else\n            return value.IsEmpty() ? false : value->BooleanValue(V8ContextOneArg).V8ToChecked();\n#endif\n        }\n\n        virtual int toInt32()\n        {\n            return value.IsEmpty() ? 0 : value->Int32Value(V8ContextOneArg).V8ToChecked();\n        }\n\n        virtual unsigned int toUInt32()\n        {\n            return value.IsEmpty() ? 0 : value->Uint32Value(V8ContextOneArg).V8ToChecked();\n        }\n\n        virtual double toDouble()\n        {\n            return value.IsEmpty() ? 0 : value->NumberValue(V8ContextOneArg).V8ToChecked();\n        }\n\n        virtual std::string toStringA()\n        {\n            if (value.IsEmpty())\n                return \"\";\n\n            v8::String::Utf8Value data(V8IsolateFirstArg value);\n            if (NULL == *data)\n                return \"\";\n\n            return std::string((char*)(*data), data.length());\n        }\n\n        virtual std::wstring toStringW()\n        {\n            if (value.IsEmpty())\n                return L\"\";\n\n            v8::String::Utf8Value data(V8IsolateFirstArg value);\n            if (NULL == *data)\n                return L\"\";\n\n            return NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)(*data), data.length());\n        }\n    };\n\n    typedef CJSValueV8TemplatePrimitive CJSValueV8;\n\n    class CJSObjectV8 : public CJSValueV8Template<v8::Object, CJSObject>\n    {\n    public:\n        CJSObjectV8()\n        {\n        }\n\n        virtual ~CJSObjectV8()\n        {\n            value.Clear();\n        }\n\n        virtual CJSValue* get(const char* name)\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            _value->value = value->Get(V8ContextFirstArg _name).ToLocalChecked();\n            return _value;\n        }\n\n        virtual void set(const char* name, CJSValue* value_param)\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(value_param);\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            value->Set(V8ContextFirstArg _name, _value->value);\n        }\n\n        virtual void set(const char* name, const int& _value)\n        {\n            v8::Isolate* isolate = CV8Worker::GetCurrent();\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            value->Set(V8ContextFirstArg _name, v8::Integer::New(isolate, _value));\n        }\n\n        virtual void set(const char* name, const double& _value)\n        {\n            v8::Isolate* isolate = CV8Worker::GetCurrent();\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            value->Set(V8ContextFirstArg _name, v8::Number::New(isolate, _value));\n        }\n\n        virtual CJSEmbedObject* getNative()\n        {\n            v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(value->GetInternalField(0));\n            return (CJSEmbedObject*)field->Value();\n        }\n\n        virtual JSSmart<CJSValue> call_func(const char* name, const int argc = 0, JSSmart<CJSValue> argv[] = NULL)\n        {\n#ifdef V8_INSPECTOR\n            v8_debug::before(V8ContextFirstArg CV8Worker::getInitializer()->getPlatform(), \"\");\n#endif\n            LOGGER_START\n\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            v8::Handle<v8::Value> _func = value->Get(V8ContextFirstArg _name).ToLocalChecked();\n\n            CJSValueV8* _return = new CJSValueV8();\n            if (_func->IsFunction())\n            {\n                v8::Handle<v8::Function> _funcN = v8::Handle<v8::Function>::Cast(_func);\n\n                if (0 == argc)\n                {\n                    v8::MaybeLocal<v8::Value> retValue = _funcN->Call(V8ContextFirstArg value, 0, NULL);\n                    if (!retValue.IsEmpty())\n                        _return->value = retValue.ToLocalChecked();\n                }\n                else\n                {\n                    v8::Local<v8::Value>* args = new v8::Local<v8::Value>[argc];\n                    for (int i = 0; i < argc; ++i)\n                    {\n                        CJSValueV8* _value_arg = static_cast<CJSValueV8*>(argv[i].operator ->());\n                        args[i] = _value_arg->value;\n                    }\n                    v8::MaybeLocal<v8::Value> retValue = _funcN->Call(V8ContextFirstArg value, argc, args);\n                    if (!retValue.IsEmpty())\n                        _return->value = retValue.ToLocalChecked();\n                    RELEASEARRAYOBJECTS(args);\n                }\n            }\n\n            LOGGER_LAP_NAME(name)\n\n            JSSmart<CJSValue> _ret = _return;\n            return _ret;\n        }\n\n        virtual JSSmart<CJSValue> toValue()\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value;\n            return _value;\n        }\n    };\n\n    class CJSArrayV8 : public CJSValueV8Template<v8::Array, CJSArray>\n    {\n    public:\n        int m_count;\n    public:\n        CJSArrayV8()\n        {\n            m_count = 0;\n        }\n        virtual ~CJSArrayV8()\n        {\n            value.Clear();\n        }\n\n        virtual int getCount()\n        {\n            return value->Length();\n        }\n\n        virtual JSSmart<CJSValue> get(const int& index)\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value->Get(V8ContextFirstArg index).ToLocalChecked();\n            return _value;\n        }\n\n        virtual void set(const int& index, CJSValue* value_param)\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(value_param);\n            value->Set(V8ContextFirstArg index, _value->value);\n        }\n\n        virtual void add(CJSValue* value_param)\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(value_param);\n            value->Set(V8ContextFirstArg getCount(), _value->value);\n        }\n\n        virtual void set(const int& index, const bool& _value)\n        {\n            value->Set(V8ContextFirstArg index, v8::Boolean::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void set(const int& index, const int& _value)\n        {\n            value->Set(V8ContextFirstArg index, v8::Integer::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void set(const int& index, const double& _value)\n        {\n            value->Set(V8ContextFirstArg index, v8::Number::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_null()\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Null(CV8Worker::GetCurrent()));\n        }\n\n        virtual void add_undefined()\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Undefined(CV8Worker::GetCurrent()));\n        }\n\n        virtual void add_bool(const bool& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Boolean::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_byte(const BYTE& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Integer::New(CV8Worker::GetCurrent(), (int)_value));\n        }\n\n        virtual void add_int(const int& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Integer::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_double(const double& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Number::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_stringa(const std::string& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, CreateV8String(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_string(const std::wstring& _value)\n        {\n            std::string sReturn = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(_value);\n            add_stringa(sReturn);\n        }\n\n        virtual JSSmart<CJSValue> toValue()\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value;\n            return _value;\n        }\n    };\n\n    class CJSTypedArrayV8 : public CJSValueV8Template<v8::Uint8Array, CJSTypedArray>\n    {\n    public:\n        CJSTypedArrayV8(BYTE* data = NULL, int count = 0, const bool& isExternalize = true)\n        {\n            if (0 < count)\n            {\n                v8::Local<v8::ArrayBuffer> _buffer = v8::ArrayBuffer::New(CV8Worker::GetCurrent(), (void*)data, (size_t)count,\n                        isExternalize ? v8::ArrayBufferCreationMode::kExternalized : v8::ArrayBufferCreationMode::kInternalized);\n                value = v8::Uint8Array::New(_buffer, 0, (size_t)count);\n            }\n        }\n        virtual ~CJSTypedArrayV8()\n        {\n            value.Clear();\n        }\n\n        virtual int getCount()\n        {\n            return (int)value->ByteLength();\n        }\n\n        virtual CJSDataBuffer getData()\n        {\n            v8::ArrayBuffer::Contents contents = value->Buffer()->GetContents();\n            CJSDataBuffer buffer;\n            buffer.Data = (BYTE*)contents.Data();\n            buffer.Len = contents.ByteLength();\n            buffer.IsExternalize = false;\n            return buffer;\n        }\n\n        virtual JSSmart<CJSValue> toValue()\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value;\n            return _value;\n        }\n    };\n\n    class CJSFunctionV8 : public CJSValueV8Template<v8::Function, CJSFunction>\n    {\n    public:\n        CJSFunctionV8()\n        {\n        }\n        virtual ~CJSFunctionV8()\n        {\n            value.Clear();\n        }\n\n        virtual CJSValue* Call(CJSValue* recv, int argc, JSSmart<CJSValue> argv[])\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(recv);\n            CJSValueV8* _return = new CJSValueV8();\n            if (0 == argc)\n            {\n                _return->value = value->Call(V8ContextFirstArg _value->value, 0, NULL).ToLocalChecked();\n            }\n            else\n            {\n                v8::Local<v8::Value>* args = new v8::Local<v8::Value>[argc];\n                for (int i = 0; i < argc; ++i)\n                {\n                    CJSValueV8* _value_arg = static_cast<CJSValueV8*>(argv[i].operator ->());\n                    args[i] = _value_arg->value;\n                }\n                _return->value = value->Call(V8ContextFirstArg _value->value, argc, args).ToLocalChecked();\n                RELEASEARRAYOBJECTS(args);\n            }\n            return _return;\n        }\n    };\n\n    template<typename V, typename B>\n    CJSObject* CJSValueV8Template<V, B>::toObject()\n    {\n        CJSObjectV8* _value = new CJSObjectV8();\n        _value->value = value->ToObject(V8ContextOneArg).ToLocalChecked();\n        return _value;\n    }\n\n    template<typename V, typename B>\n    CJSArray* CJSValueV8Template<V, B>::toArray()\n    {\n        CJSArrayV8* _value = new CJSArrayV8();\n        _value->value = v8::Local<v8::Array>::Cast(value);\n        return _value;\n    }\n\n    template<typename V, typename B>\n    CJSTypedArray* CJSValueV8Template<V, B>::toTypedArray()\n    {\n        CJSTypedArrayV8* _value = new CJSTypedArrayV8();\n        _value->value = v8::Local<v8::Uint8Array>::Cast(value);\n        return _value;\n    }\n\n    template<typename V, typename B>\n    CJSFunction* CJSValueV8Template<V, B>::toFunction()\n    {\n        CJSFunctionV8* _value = new CJSFunctionV8();\n        _value->value = v8::Local<v8::Function>::Cast(value);\n        return _value;\n    }\n}\n\nnamespace NSJSBase\n{\n    // TRY - CATCH\n    class CV8TryCatch : public CJSTryCatch\n    {\n    private:\n        v8::TryCatch try_catch;\n\n    public:\n        CV8TryCatch() : CJSTryCatch(), try_catch(V8IsolateOneArg)\n        {\n        }\n        virtual ~CV8TryCatch()\n        {\n        }\n\n    public:\n        virtual bool Check()\n        {\n            if (try_catch.HasCaught())\n            {\n                int nLineNumber             = try_catch.Message()->GetLineNumber(V8ContextOneArg).V8ToChecked();\n\n                JSSmart<CJSValueV8> _line = new CJSValueV8();\n                _line->value = try_catch.Message()->GetSourceLine(V8ContextOneArg).ToLocalChecked();\n\n                JSSmart<CJSValueV8> _exception = new CJSValueV8();\n                _exception->value = try_catch.Message()->Get();\n\n                std::string strCode        = _line->toStringA();\n                std::string strException   = _exception->toStringA();\n\n#if 1\n                v8::Local<v8::Value> stack_trace_string;\n                if (try_catch.StackTrace(V8ContextOneArg).ToLocal(&stack_trace_string) &&\n                    stack_trace_string->IsString() &&\n                    v8::Local<v8::String>::Cast(stack_trace_string)->Length() > 0)\n                {\n                    v8::String::Utf8Value data(V8IsolateFirstArg stack_trace_string);\n                    if (NULL != *data)\n                    {\n                        std::string sStack((char*)(*data), data.length());\n                        std::cerr << sStack << std::endl;\n                    }\n                }\n#endif\n\n#ifndef __ANDROID__\n                std::cerr << strException << std::endl;\n#else\n                LOGE(\"NSJSBase::CV8TryCatch::Check() - error:\");\n                LOGE(std::to_string(nLineNumber).c_str());\n                LOGE(strCode.c_str());\n                LOGE(strException.c_str());\n#endif\n                return true;\n            }\n            return false;\n        }\n    };\n}\n\nnamespace NSJSBase\n{\n    class CJSContextPrivate\n    {\n    public:\n        CV8Worker m_oWorker;\n        v8::Isolate* m_isolate;\n\n        v8::Local<v8::ObjectTemplate>   m_global;\n        v8::Local<v8::Context>          m_context;\n\n    public:\n        CJSContextPrivate() : m_oWorker(), m_isolate(NULL)\n        {\n        }\n    };\n}\n\nnamespace NSJSBase\n{\n    class CJSEmbedObjectPrivate : public CJSEmbedObjectPrivateBase\n    {\n    public:\n        v8::Persistent<v8::Object> handle;\n\n        CJSEmbedObjectPrivate(v8::Local<v8::Object> obj)\n        {\n            SetWeak(obj);\n        }\n        virtual ~CJSEmbedObjectPrivate()\n        {\n            ClearWeak();\n        }\n\n    public:\n        void SetWeak(v8::Local<v8::Object> obj)\n        {\n            v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(obj->GetInternalField(0));\n            CJSEmbedObject* pEmbedObject = (NSJSBase::CJSEmbedObject*)field->Value();\n\n            handle.Reset(CV8Worker::GetCurrent(), obj);\n            handle.SetWeak(pEmbedObject, EmbedObjectWeakCallback, v8::WeakCallbackType::kParameter);\n\n            pEmbedObject->embed_native_internal = this;\n        }\n        void ClearWeak()\n        {\n            if (handle.IsEmpty())\n                return;\n            handle.ClearWeak();\n            handle.Reset();\n        }\n\n        static void EmbedObjectWeakCallback(const v8::WeakCallbackInfo<CJSEmbedObject>& data)\n        {\n            v8::Isolate* isolate = data.GetIsolate();\n            v8::HandleScope scope(isolate);\n            CJSEmbedObject* wrap = data.GetParameter();\n            ((CJSEmbedObjectPrivate*)wrap->embed_native_internal)->handle.Reset();\n            delete wrap;\n        }\n\n        static void CreateWeaker(v8::Local<v8::Object> obj)\n        {\n            new CJSEmbedObjectPrivate(obj);\n        }\n    };\n}\n\nnamespace NSV8Objects\n{\n    static void Template_Set(v8::Local<v8::ObjectTemplate>& obj, const char* name, v8::FunctionCallback callback)\n    {\n        v8::Isolate* current = CV8Worker::GetCurrent();\n        obj->Set(CreateV8String(current, name), v8::FunctionTemplate::New(current, callback));\n    }\n}\n\ninline NSJSBase::CJSEmbedObject* unwrap_native(const v8::Local<v8::Object>& value)\n{\n    v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(value->GetInternalField(0));\n    return (NSJSBase::CJSEmbedObject*)field->Value();\n}\ninline NSJSBase::CJSEmbedObject* unwrap_native2(const v8::Local<v8::Value>& value)\n{\n    v8::Local<v8::Object> _obj = value->ToObject(V8ContextOneArg).ToLocalChecked();\n    v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(_obj->GetInternalField(0));\n    return (NSJSBase::CJSEmbedObject*)field->Value();\n}\n\ninline JSSmart<NSJSBase::CJSValue> js_value(const v8::Local<v8::Value>& value)\n{\n    return new NSJSBase::CJSValueV8(value);\n}\ninline JSSmart<NSJSBase::CJSValue> js_object(const v8::Local<v8::Object>& value)\n{\n    NSJSBase::CJSObjectV8* _ret = new NSJSBase::CJSObjectV8();\n    _ret->value = value;\n    return _ret;\n}\ninline void js_return(const v8::FunctionCallbackInfo<v8::Value>& args, JSSmart<NSJSBase::CJSValue>& value)\n{\n    if (value.is_init())\n    {\n        NSJSBase::CJSValueV8* _value = (NSJSBase::CJSValueV8*)(value.operator ->());\n        args.GetReturnValue().Set(_value->value);\n    }\n}\ninline void js_return(const v8::PropertyCallbackInfo<v8::Value>& info, JSSmart<NSJSBase::CJSValue>& value)\n{\n    if (value.is_init())\n    {\n        NSJSBase::CJSValueV8* _value = (NSJSBase::CJSValueV8*)(value.operator ->());\n        info.GetReturnValue().Set(_value->value);\n    }\n}\n\n#define PROPERTY_GET(NAME, NAME_EMBED)                                                      \\\n    void NAME(v8::Local<v8::String> _name, const v8::PropertyCallbackInfo<v8::Value>& info) \\\n    {                                                                                       \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(info.Holder());              \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED();                                        \\\n        js_return(info, ret);                                                               \\\n    }\n\n#define FUNCTION_WRAPPER_V8(NAME, NAME_EMBED)                                       \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                      \\\n    {                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED();                                \\\n        js_return(args, ret);                                                       \\\n    }\n\n#define FUNCTION_WRAPPER_V8_1(NAME, NAME_EMBED)                                     \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                      \\\n    {                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]));               \\\n        js_return(args, ret);                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_2(NAME, NAME_EMBED)                                             \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                              \\\n    {                                                                                       \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]));    \\\n        js_return(args, ret);                                                               \\\n    }\n#define FUNCTION_WRAPPER_V8_3(NAME, NAME_EMBED)                                                                 \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                  \\\n    {                                                                                                           \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                    \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]));     \\\n        js_return(args, ret);                                                                                   \\\n    }\n#define FUNCTION_WRAPPER_V8_4(NAME, NAME_EMBED)                                                                                 \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                  \\\n    {                                                                                                                           \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                    \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]));  \\\n        js_return(args, ret);                                                                                                   \\\n    }\n#define FUNCTION_WRAPPER_V8_5(NAME, NAME_EMBED)                                                                                                     \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]));   \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_6(NAME, NAME_EMBED)                                                                                                     \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]), js_value(args[5]));   \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_7(NAME, NAME_EMBED)                                                                                                     \\\nvoid NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                          \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]),    \\\n                                                   js_value(args[5]), js_value(args[6]));                                                           \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_8(NAME, NAME_EMBED)                                                                                                     \\\nvoid NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                          \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]),    \\\n                                                   js_value(args[5]), js_value(args[6]), js_value(args[7]));                                        \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_9(NAME, NAME_EMBED)                                                                                                     \\\nvoid NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                          \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]),    \\\n                                                   js_value(args[5]), js_value(args[6]), js_value(args[7]), js_value(args[8]));                     \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_10(NAME, NAME_EMBED)                                                                                                    \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]), js_value(args[5]), \\\n                                                  js_value(args[6]), js_value(args[7]), js_value(args[8]), js_value(args[9]));   \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_13(NAME, NAME_EMBED)                                                                                                    \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]), js_value(args[5]), \\\n                                                  js_value(args[6]), js_value(args[7]), js_value(args[8]), js_value(args[9]), js_value(args[10]), js_value(args[11]), \\\n                                                  js_value(args[12]));                                                                              \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n\n#endif // _BUILD_NATIVE_CONTROL_V8_BASE_H_\n"], "fixing_code": ["\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#include \"docbuilder_p.h\"\n\nstd::wstring NSDoctRenderer::CDocBuilder_Private::m_sExternalDirectory = L\"\";\n\nvoid CV8RealTimeWorker::_LOGGING_ERROR_(const std::wstring& strType, const std::wstring& strError)\n{\n\tstd::string sT = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(strType);\n\tstd::string sE = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(strError);\n\n\tstd::cerr << sT << \": \" << sE << std::endl;\n}\n\nusing namespace NSJSBase;\n\nCV8RealTimeWorker::CV8RealTimeWorker(NSDoctRenderer::CDocBuilder* pBuilder)\n{\n\tm_nFileType = -1;\n\n\tm_context = new CJSContext();\n\tm_context->Initialize();\n\n\tm_isolate_scope = m_context->CreateIsolateScope();\n\tm_handle_scope  = m_context->CreateLocalScope();\n\n\tm_context->CreateGlobalForContext();\n\tCNativeControlEmbed::CreateObjectBuilderInContext(\"CreateNativeEngine\", m_context);\n\tCGraphicsEmbed::CreateObjectInContext(\"CreateNativeGraphics\", m_context);\n\tNSJSBase::CreateDefaults(m_context);\n\tm_context->CreateContext();\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tbuilder_CreateNative(\"builderJS\", m_context, pBuilder);\n}\nCV8RealTimeWorker::~CV8RealTimeWorker()\n{\n\tm_oContextData.Clear();\n\tm_handle_scope = NULL;\n\tm_isolate_scope = NULL;\n\tm_context->Dispose();\n}\n\nbool CV8RealTimeWorker::ExecuteCommand(const std::wstring& command, NSDoctRenderer::CDocBuilderValue* retValue)\n{\n\tLOGGER_SPEED_START\n\n\tif (retValue)\n\t\tretValue->Clear();\n\n\tstd::string commandA = U_TO_UTF8(command);\n\t//commandA = \"Api.\" + commandA;\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tLOGGER_SPEED_LAP(\"compile_command\")\n\n\tJSSmart<CJSValue> retNativeVal = m_context->runScript(commandA, try_catch);\n\tif(try_catch->Check())\n\t\treturn false;\n\n\tif (retValue)\n\t{\n\t\tNSDoctRenderer::CDocBuilderValue_Private* privateRet = (NSDoctRenderer::CDocBuilderValue_Private*)retValue->private_get_internal();\n\t\tprivateRet->m_context = m_context;\n\t\tprivateRet->m_value = retNativeVal;\n\t}\n\n\tLOGGER_SPEED_LAP(\"run_command\")\n\n\treturn true;\n}\n\nstd::string CV8RealTimeWorker::GetGlobalVariable()\n{\n\tstd::string commandA = \"JSON.stringify(GlobalVariable);\";\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tJSSmart<CJSValue> _value = m_context->runScript(commandA, try_catch);\n\tif(try_catch->Check())\n\t\treturn \"\";\n\tif(_value->isString())\n\t\treturn _value->toStringA();\n\treturn \"{}\";\n}\n\nstd::wstring CV8RealTimeWorker::GetJSVariable(std::wstring sParam)\n{\n\tstd::string sParamA = U_TO_UTF8(sParam);\n\tNSStringUtils::string_replaceA(sParamA, \"\\\\\\\"\", \"\\\"\");\n\tstd::string commandA = \"(function(){ return (\" + sParamA + \"); })()\";\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tJSSmart<CJSValue> _value = m_context->runScript(commandA, try_catch);\n\tif(try_catch->Check())\n\t\treturn L\"jsValue(\" + sParam + L\")\";\n\tif(_value->isString())\n\t\treturn _value->toStringW();\n\treturn L\"jsValue(\" + sParam + L\")\";\n}\n\nbool CV8RealTimeWorker::OpenFile(const std::wstring& sBasePath, const std::wstring& path, const std::string& sString, const std::wstring& sCachePath, CV8Params* pParams)\n{\n\tLOGGER_SPEED_START\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch>         try_catch = m_context->GetExceptions();\n\n\tLOGGER_SPEED_LAP(\"compile\");\n\n\tm_context->runScript(sString, try_catch, sCachePath);\n\tif(try_catch->Check())\n\t\treturn false;\n\n\tLOGGER_SPEED_LAP(\"run\")\n\n\tif (true)\n\t{\n\t\tstd::string sArg = m_sUtf8ArgumentJSON;\n\t\tif (sArg.empty())\n\t\t\tsArg = \"{}\";\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\\\", \"\\\\\\\\\");\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\"\", \"\\\\\\\"\");\n\t\tstd::string sArgument = \"var Argument = JSON.parse(\\\"\" + sArg + \"\\\");\";\n\n\t\tm_context->runScript(sArgument, try_catch);\n\t\tif (try_catch->Check())\n\t\t\treturn false;\n\t}\n\n\tif (true)\n\t{\n\t\tstd::string sArg = m_sGlobalVariable;\n\t\tif (sArg.empty())\n\t\t\tsArg = \"{}\";\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\\\", \"\\\\\\\\\");\n\t\tNSStringUtils::string_replaceA(sArg, \"\\\"\", \"\\\\\\\"\");\n\n\t\tstd::string sScriptVar = \"var GlobalVariable = JSON.parse(\\\"\" + sArg + \"\\\");\";\n\n\t\tm_context->runScript(sScriptVar, try_catch);\n\t\tif (try_catch->Check())\n\t\t\treturn false;\n\t}\n\n\tNSNativeControl::CNativeControl* pNative = NULL;\n\tbool bIsBreak = false;\n\n\tJSSmart<CJSObject> global_js = m_context->GetGlobal();\n\tJSSmart<CJSValue> args[1];\n\targs[0] = CJSContext::createInt(0);\n\n\t// GET_NATIVE_ENGINE\n\tif (!bIsBreak)\n\t{\n\t\tJSSmart<CJSValue> js_result2 = global_js->call_func(\"GetNativeEngine\", 1, args);\n\t\tif (try_catch->Check())\n\t\t\tbIsBreak = true;\n\t\telse\n\t\t{\n\t\t\tJSSmart<CJSObject> objNative = js_result2->toObject();\n\t\t\tpNative = (NSNativeControl::CNativeControl*)objNative->getNative()->getObject();\n\t\t}\n\t}\n\n\tif (pNative != NULL)\n\t{\n\t\tif (pParams)\n\t\t{\n\t\t\tpNative->m_oParams = *pParams;\n\t\t}\n\n\t\tpNative->m_strFontsDirectory = sBasePath + L\"/sdkjs/common\";\n\t\tpNative->m_strImagesDirectory = path + L\"/media\";\n\n\t\tpNative->CheckFonts();\n\n\t\tif (0 == m_nFileType)\n\t\t\tpNative->m_strEditorType = L\"document\";\n\t\telse if (1 == m_nFileType)\n\t\t\tpNative->m_strEditorType = L\"presentation\";\n\t\telse\n\t\t\tpNative->m_strEditorType = L\"spreadsheet\";\n\n\t\tpNative->SetFilePath(path + L\"/Editor.bin\");\n\n\t\tpNative->m_sChangesBuilderPath = path + L\"/changes/changes0.json\";\n\n\t\tpNative->m_nMaxChangesNumber = -1;\n\t}\n\n\t// OPEN\n\tif (!bIsBreak)\n\t{\n\t\tCChangesWorker oWorkerLoader;\n\t\tint nVersion = oWorkerLoader.OpenNative(pNative->GetFilePath());\n\n\t\tJSSmart<CJSValue> args_open[3];\n\t\targs_open[0] = oWorkerLoader.GetDataFull()->toObject()->toValue();\n\t\targs_open[1] = CJSContext::createInt(nVersion);\n\t\tstd::wstring sXlsx = NSFile::GetDirectoryName(pNative->GetFilePath()) + L\"/Editor.xlsx\";\n\t\targs_open[2] = NSFile::CFileBinary::Exists(sXlsx) ? CJSContext::createString(sXlsx) : CJSContext::createUndefined();\n\n\t\tglobal_js->call_func(\"NativeOpenFileData\", 3, args_open);\n\t\tif (try_catch->Check())\n\t\t\tbIsBreak = true;\n\t}\n\n\tif (!bIsBreak)\n\t\tbIsBreak = !this->ExecuteCommand(L\"Api.asc_nativeInitBuilder();\");\n\tif (!bIsBreak)\n\t\tbIsBreak = !this->ExecuteCommand(L\"Api.asc_SetSilentMode(true);\");\n\n\tLOGGER_SPEED_LAP(\"open\")\n\n\treturn !bIsBreak;\n}\n\nbool CV8RealTimeWorker::SaveFileWithChanges(int type, const std::wstring& _path, const std::wstring& sJsonParams)\n{\n\tNSDoctRenderer::DoctRendererFormat::FormatFile _formatDst = NSDoctRenderer::DoctRendererFormat::DOCT;\n\tif (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t_formatDst = NSDoctRenderer::DoctRendererFormat::PPTT;\n\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t_formatDst = NSDoctRenderer::DoctRendererFormat::XLST;\n\telse if ((type & AVS_OFFICESTUDIO_FILE_CROSSPLATFORM) || (type & AVS_OFFICESTUDIO_FILE_IMAGE))\n\t\t_formatDst = NSDoctRenderer::DoctRendererFormat::PDF;\n\n\tJSSmart<CJSContextScope> context_scope = m_context->CreateContextScope();\n\tJSSmart<CJSTryCatch> try_catch = m_context->GetExceptions();\n\n\tNSNativeControl::CNativeControl* pNative = NULL;\n\n\tJSSmart<CJSObject> global_js = m_context->GetGlobal();\n\tJSSmart<CJSValue> args[1];\n\targs[0] = CJSContext::createInt(0);\n\n\t// GET_NATIVE_ENGINE\n\tif (true)\n\t{\n\t\tJSSmart<CJSValue> js_result2 = global_js->call_func(\"GetNativeEngine\", 1, args);\n\t\tif (!try_catch->Check())\n\t\t{\n\t\t\tJSSmart<CJSObject> objNative = js_result2->toObject();\n\t\t\tpNative = (NSNativeControl::CNativeControl*)objNative->getNative()->getObject();\n\t\t}\n\t}\n\n\tif (pNative == NULL)\n\t\treturn false;\n\n\tif (_formatDst == NSDoctRenderer::DoctRendererFormat::PDF)\n\t\tthis->ExecuteCommand(L\"Api.asc_SetSilentMode(false);\");\n\n\tstd::wstring strError;\n\tbool bIsError = Doct_renderer_SaveFile_ForBuilder(_formatDst,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  _path,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  pNative,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  m_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  args,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  strError,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sJsonParams);\n\n\tif (_formatDst == NSDoctRenderer::DoctRendererFormat::PDF)\n\t\tthis->ExecuteCommand(L\"Api.asc_SetSilentMode(true);\");\n\n\treturn bIsError;\n}\n\nnamespace NSDoctRenderer\n{\n\tCString::CString()\n\t{\n\t\tm_internal = new CString_Private();\n\t}\n\tCString::CString(const CString& src)\n\t{\n\t\tm_internal = new CString_Private();\n\t\tsrc.m_internal->Copy(m_internal);\n\t}\n\tCString& CString::operator=(const CString& src)\n\t{\n\t\tsrc.m_internal->Copy(m_internal);\n\t\treturn *this;\n\t}\n\tCString::~CString()\n\t{\n\t\tdelete m_internal;\n\t}\n\twchar_t* CString::c_str() const\n\t{\n\t\treturn m_internal->m_data;\n\t}\n\n\tCDocBuilderContextScope::CDocBuilderContextScope()\n\t{\n\t\tm_internal = new CDocBuilderContextScope_Private();\n\t}\n\tCDocBuilderContextScope::CDocBuilderContextScope(const CDocBuilderContextScope& src)\n\t{\n\t\tm_internal = new CDocBuilderContextScope_Private();\n\t\tm_internal->m_scope_wrap = src.m_internal->m_scope_wrap;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t}\n\tCDocBuilderContextScope& CDocBuilderContextScope::operator=(const CDocBuilderContextScope& src)\n\t{\n\t\tm_internal->m_scope_wrap = src.m_internal->m_scope_wrap;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t\treturn *this;\n\t}\n\tCDocBuilderContextScope::~CDocBuilderContextScope()\n\t{\n\t\tClose();\n\t\tRELEASEOBJECT(m_internal);\n\t}\n\tvoid CDocBuilderContextScope::Close()\n\t{\n\t\tif (m_internal->m_scope_wrap.is_init() && 2 == m_internal->m_scope_wrap.GetCountReference())\n\t\t{\n\t\t\tm_internal->m_context_data->RemoveScope(m_internal->m_scope_wrap);\n\t\t\tm_internal->m_scope_wrap->Close();\n\t\t}\n\t}\n\n\tCDocBuilderValue::CDocBuilderValue()\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const CDocBuilderValue& src)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\t*this = src;\n\n\t\t// only for constructor\n\t\tif (src.m_internal->m_parent.is_init())\n\t\t\tm_internal->m_parent = src.m_internal->m_parent;\n\t}\n\tCDocBuilderValue& CDocBuilderValue::operator=(const CDocBuilderValue& src)\n\t{\n\t\tm_internal->m_context = src.m_internal->m_context;\n\t\tm_internal->m_value = src.m_internal->m_value;\n\n\t\tm_internal->m_nativeType = src.m_internal->m_nativeType;\n\t\tm_internal->m_nativeValue = src.m_internal->m_nativeValue;\n\n\t\tswitch (m_internal->m_nativeType)\n\t\t{\n\t\tcase CDocBuilderValue_Private::ptString:\n\t\t{\n\t\t\tsize_t len = wcslen(m_internal->m_nativeValue.sValue);\n\t\t\twchar_t* copy_ptr = new wchar_t[len + 1];\n\t\t\tmemcpy(copy_ptr, m_internal->m_nativeValue.sValue, (len + 1) * sizeof(wchar_t));\n\t\t\tm_internal->m_nativeValue.sValue = copy_ptr;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m_internal->m_parent.is_init())\n\t\t{\n\t\t\tm_internal->CheckNative();\n\n\t\t\tJSSmart<CJSValue> oParent = m_internal->m_parent->m_parent;\n\n\t\t\tif (oParent->isArray())\n\t\t\t{\n\t\t\t\tJSSmart<CJSArray> oParentArray = oParent->toArray();\n\t\t\t\toParentArray->set(m_internal->m_parent->m_parent_index, m_internal->m_value.GetPointer());\n\t\t\t}\n\t\t\telse if (oParent->isObject() && !m_internal->m_parent->m_parent_prop_name.empty())\n\t\t\t{\n\t\t\t\tJSSmart<CJSObject> oParentObject = oParent->toObject();\n\t\t\t\toParentObject->set(m_internal->m_parent->m_parent_prop_name.c_str(), m_internal->m_value.GetPointer());\n\t\t\t}\n\t\t}\n\n\t\treturn *this;\n\t}\n\tCDocBuilderValue::~CDocBuilderValue()\n\t{\n\t\tdelete m_internal;\n\t}\n\tvoid* CDocBuilderValue::private_get_internal()\n\t{\n\t\treturn (void*)m_internal;\n\t}\n\n\tbool CDocBuilderValue::IsEmpty()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn true;\n\t\treturn m_internal->m_value->isEmpty();\n\t}\n\tvoid CDocBuilderValue::Clear()\n\t{\n\t\tm_internal->Clear();\n\t}\n\tbool CDocBuilderValue::IsNull()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptNull) ? true : false;\n\t\treturn m_internal->m_value->isNull();\n\t}\n\tbool CDocBuilderValue::IsUndefined()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptUndefined) ? true : false;\n\t\treturn m_internal->m_value->isUndefined();\n\t}\n\tbool CDocBuilderValue::IsBool()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptBool) ? true : false;\n\t\treturn m_internal->m_value->isBool();\n\t}\n\tbool CDocBuilderValue::IsInt()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptInt) ? true : false;\n\t\treturn m_internal->m_value->isNumber();\n\t}\n\tbool CDocBuilderValue::IsDouble()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptDouble) ? true : false;\n\t\treturn m_internal->m_value->isNumber();\n\t}\n\tbool CDocBuilderValue::IsString()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn (m_internal->m_nativeType == CDocBuilderValue_Private::ptString) ? true : false;\n\t\treturn m_internal->m_value->isString();\n\t}\n\tbool CDocBuilderValue::IsObject()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isObject();\n\t}\n\tbool CDocBuilderValue::IsFunction()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isFunction();\n\t}\n\tbool CDocBuilderValue::IsArray()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isArray();\n\t}\n\tbool CDocBuilderValue::IsTypedArray()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->isTypedArray();\n\t}\n\n\tunsigned int CDocBuilderValue::GetLength()\n\t{\n\t\tif (IsArray())\n\t\t{\n\t\t\tJSSmart<CJSArray> array = m_internal->m_value->toArray();\n\t\t\treturn (unsigned int)array->getCount();\n\t\t}\n\t\tif (IsTypedArray())\n\t\t{\n\t\t\tJSSmart<CJSTypedArray> array = m_internal->m_value->toTypedArray();\n\t\t\treturn (unsigned int)array->getCount();\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool CDocBuilderValue::ToBool()\n\t{\n\t\tif (!m_internal->m_value.is_init() && (m_internal->m_nativeType == CDocBuilderValue_Private::ptBool))\n\t\t\treturn m_internal->m_nativeValue.bValue;\n\n\t\tif (IsEmpty() || !m_internal->m_value->isBool())\n\t\t\treturn false;\n\t\treturn m_internal->m_value->toBool();\n\t}\n\tint CDocBuilderValue::ToInt()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t{\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptInt)\n\t\t\t\treturn m_internal->m_nativeValue.nValue;\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptUInt)\n\t\t\t\treturn (int)m_internal->m_nativeValue.unValue;\n\t\t}\n\n\t\tif (IsEmpty() || !m_internal->m_value->isNumber())\n\t\t\treturn 0;\n\t\treturn m_internal->m_value->toInt32();\n\t}\n\tdouble CDocBuilderValue::ToDouble()\n\t{\n\t\tif (!m_internal->m_value.is_init())\n\t\t{\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptDouble)\n\t\t\t\treturn m_internal->m_nativeValue.dValue;\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptInt)\n\t\t\t\treturn (double)m_internal->m_nativeValue.nValue;\n\t\t\tif (m_internal->m_nativeType == CDocBuilderValue_Private::ptUInt)\n\t\t\t\treturn (double)m_internal->m_nativeValue.unValue;\n\t\t}\n\n\t\tif (IsEmpty() || !m_internal->m_value->isNumber())\n\t\t\treturn 0;\n\t\treturn m_internal->m_value->toDouble();\n\t}\n\tCString CDocBuilderValue::ToString()\n\t{\n\t\tCString ret;\n\t\tif (!m_internal->m_value.is_init() && (m_internal->m_nativeType == CDocBuilderValue_Private::ptString))\n\t\t{\n\t\t\twchar_t* pValue = m_internal->m_nativeValue.sValue;\n\t\t\tsize_t len = wcslen(pValue);\n\t\t\twchar_t* buffer = new wchar_t[len + 1];\n\t\t\tmemcpy(buffer, pValue, len * sizeof(wchar_t));\n\t\t\tbuffer[len] = '\\0';\n\t\t\tret.m_internal->Attach(buffer);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (IsEmpty() || !m_internal->m_value->isString())\n\t\t\treturn ret;\n\t\tstd::wstring sValue = m_internal->m_value->toStringW();\n\t\tif (sValue.empty())\n\t\t\treturn ret;\n\t\tsize_t len = sValue.length();\n\t\twchar_t* buffer = new wchar_t[len + 1];\n\t\tmemcpy(buffer, sValue.c_str(), len * sizeof(wchar_t));\n\t\tbuffer[len] = '\\0';\n\t\tret.m_internal->Attach(buffer);\n\t\treturn ret;\n\t}\n\n\tCDocBuilderValue CDocBuilderValue::Get(const char* name)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->get(name);\n\n\t\tret.m_internal->m_parent = new CDocBuilderValue_Private::CParentValueInfo();\n\t\tret.m_internal->m_parent->m_parent = m_internal->m_value;\n\t\tret.m_internal->m_parent->m_parent_prop_name = std::string(name);\n\t\tret.m_internal->m_parent->m_parent_index = -1;\n\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Get(const wchar_t* name)\n\t{\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\t\treturn Get(sPropA.c_str());\n\t}\n\tCDocBuilderValue CDocBuilderValue::GetProperty(const wchar_t* name)\n\t{\n\t\treturn Get(name);\n\t}\n\tCDocBuilderValue CDocBuilderValue::operator[](const char* name)\n\t{\n\t\treturn Get(name);\n\t}\n\tCDocBuilderValue CDocBuilderValue::operator[](const wchar_t *name)\n\t{\n\t\treturn Get(name);\n\t}\n\n\tCDocBuilderValue CDocBuilderValue::Get(const int& index)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isArray())\n\t\t\treturn ret;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tJSSmart<CJSArray> array = m_internal->m_value->toArray();\n\t\tret.m_internal->m_value = array->get(index);\n\n\t\tret.m_internal->m_parent = new CDocBuilderValue_Private::CParentValueInfo();\n\t\tret.m_internal->m_parent->m_parent = m_internal->m_value;\n\t\tret.m_internal->m_parent->m_parent_index = index;\n\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::operator[](const int &index)\n\t{\n\t\treturn Get(index);\n\t}\n\n\tvoid CDocBuilderValue::Set(const wchar_t* name, CDocBuilderValue value)\n\t{\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tvalue.m_internal->CheckNative();\n\t\tm_internal->m_value->toObjectSmart()->set(sPropA.c_str(), value.m_internal->m_value.GetPointer());\n\t}\n\tvoid CDocBuilderValue::SetProperty(const wchar_t* name, CDocBuilderValue value)\n\t{\n\t\tSet(name, value);\n\t}\n\tvoid CDocBuilderValue::Set(const int& index, CDocBuilderValue value)\n\t{\n\t\tif (IsEmpty() || !m_internal->m_value->isArray())\n\t\t\treturn;\n\n\t\tJSSmart<CJSArray> array = m_internal->m_value->toArray();\n\t\tvalue.m_internal->CheckNative();\n\t\tarray->set(index, value.m_internal->m_value.GetPointer());\n\t}\n\n\t// primitives\n\tCDocBuilderValue::CDocBuilderValue(const bool& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateBool(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const int& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateInt(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const unsigned int& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateUInt(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const double& value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateDouble(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const char* value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateString(value);\n\t}\n\tCDocBuilderValue::CDocBuilderValue(const wchar_t* value)\n\t{\n\t\tm_internal = new CDocBuilderValue_Private();\n\t\tm_internal->CreateString(value);\n\t}\n\n\tCDocBuilderValue CDocBuilderValue::CreateUndefined()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->CreateUndefined();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::CreateNull()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->CreateNull();\n\t\treturn ret;\n\t}\n\n\t// Functions\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[1];\n\t\targv[0] = p1.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 1, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[2];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 2, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[3];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 3, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[4];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 4, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[5];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 5, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const char* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5, CDocBuilderValue p6)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tp6.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[6];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\t\targv[5] = p6.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(name, 6, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str());\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[1];\n\t\targv[0] = p1.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 1, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[2];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 2, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[3];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 3, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[4];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 4, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[5];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 5, argv);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderValue::Call(const wchar_t* name, CDocBuilderValue p1, CDocBuilderValue p2, CDocBuilderValue p3, CDocBuilderValue p4, CDocBuilderValue p5, CDocBuilderValue p6)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tif (IsEmpty() || !m_internal->m_value->isObject())\n\t\t\treturn ret;\n\n\t\tstd::wstring sProp(name);\n\t\tstd::string sPropA = U_TO_UTF8(sProp);\n\n\t\tp1.m_internal->CheckNative();\n\t\tp2.m_internal->CheckNative();\n\t\tp3.m_internal->CheckNative();\n\t\tp4.m_internal->CheckNative();\n\t\tp5.m_internal->CheckNative();\n\t\tp6.m_internal->CheckNative();\n\t\tJSSmart<CJSValue> argv[6];\n\t\targv[0] = p1.m_internal->m_value;\n\t\targv[1] = p2.m_internal->m_value;\n\t\targv[2] = p3.m_internal->m_value;\n\t\targv[3] = p4.m_internal->m_value;\n\t\targv[4] = p5.m_internal->m_value;\n\t\targv[5] = p6.m_internal->m_value;\n\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = m_internal->m_value->toObjectSmart()->call_func(sPropA.c_str(), 6, argv);\n\t\treturn ret;\n\t}\n\n\tCDocBuilderContext::CDocBuilderContext()\n\t{\n\t\tm_internal = new CDocBuilderContext_Private();\n\t}\n\tCDocBuilderContext::CDocBuilderContext(const CDocBuilderContext& src)\n\t{\n\t\tm_internal = new CDocBuilderContext_Private();\n\t\tm_internal->m_context = src.m_internal->m_context;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t}\n\tCDocBuilderContext& CDocBuilderContext::operator=(const CDocBuilderContext& src)\n\t{\n\t\tm_internal->m_context = src.m_internal->m_context;\n\t\tm_internal->m_context_data = src.m_internal->m_context_data;\n\t\treturn *this;\n\t}\n\tCDocBuilderContext::~CDocBuilderContext()\n\t{\n\t\tRELEASEOBJECT(m_internal);\n\t}\n\n\tCDocBuilderValue CDocBuilderContext::CreateUndefined()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createUndefined();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateNull()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createNull();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateObject()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createObject();\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateArray(const int& length)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createArray(length);\n\t\treturn ret;\n\t}\n\tCDocBuilderValue CDocBuilderContext::CreateTypedArray(unsigned char* buffer, const int& length, const bool& externalize)\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tret.m_internal->m_value = NSJSBase::CJSContext::createUint8Array(buffer, length, externalize);\n\t\treturn ret;\n\t}\n\n\tunsigned char* CDocBuilderContext::AllocMemoryTypedArray(const size_t& size)\n\t{\n\t\treturn NSJSBase::NSAllocator::Alloc(size);\n\t}\n\n\tvoid CDocBuilderContext::FreeMemoryTypedArray(unsigned char* data, const size_t& size)\n\t{\n\t\treturn NSJSBase::NSAllocator::Free(data, size);\n\t}\n\n\tCDocBuilderValue CDocBuilderContext::GetGlobal()\n\t{\n\t\tCDocBuilderValue ret;\n\t\tret.m_internal->m_context = m_internal->m_context;\n\t\tJSSmart<CJSObject> obj = m_internal->m_context->GetGlobal();\n\t\tret.m_internal->m_value = obj->toValue();\n\t\treturn ret;\n\t}\n\n\tCDocBuilderContextScope CDocBuilderContext::CreateScope()\n\t{\n\t\tCDocBuilderContextScope ret;\n\t\tret.m_internal->m_scope_wrap = new CDocBuilderContextScopeWrap();\n\t\tret.m_internal->m_scope_wrap->m_scope = m_internal->m_context->CreateContextScope();\n\t\tret.m_internal->m_context_data = m_internal->m_context_data;\n\n\t\tm_internal->m_context_data->AddScope(ret.m_internal->m_scope_wrap);\n\t\treturn ret;\n\t}\n\n\tbool CDocBuilderContext::IsError()\n\t{\n\t\tJSSmart<CJSTryCatch> oTry = m_internal->m_context->GetExceptions();\n\t\treturn oTry->Check();\n\t}\n}\n\nnamespace NSDoctRenderer\n{\n\tvoid ParceParameters(const std::string& command, std::wstring* params, int& nCount)\n\t{\n\t\tconst char* _commandsPtr = command.c_str();\n\t\tsize_t _commandsLen = command.length();\n\t\tsize_t _currentPos = 0;\n\n\t\tint nIndex = 0;\n\n\t\twhile (true)\n\t\t{\n\t\t\twhile (_currentPos < _commandsLen && !(_commandsPtr[_currentPos] == '\\\"' && _commandsPtr[_currentPos - 1] != '\\\\'))\n\t\t\t\t++_currentPos;\n\n\t\t\t++_currentPos;\n\t\t\tsize_t _start = _currentPos;\n\n\t\t\twhile (_currentPos < _commandsLen && !(_commandsPtr[_currentPos] == '\\\"' && _commandsPtr[_currentPos - 1] != '\\\\'))\n\t\t\t\t++_currentPos;\n\n\t\t\tif (_currentPos > _start)\n\t\t\t{\n\t\t\t\tif (_currentPos == (_start + 1))\n\t\t\t\t\tparams[nIndex++] = L\"\";\n\t\t\t\telse\n\t\t\t\t\tparams[nIndex++] = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)(_commandsPtr + _start), (LONG)(_currentPos - _start));\n\t\t\t}\n\n\t\t\t++_currentPos;\n\n\t\t\tif (_currentPos >= _commandsLen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnCount = nIndex;\n\t}\n\n\tbool CDocBuilder::CreateFile(const int& type)\n\t{\n\t\tm_pInternal->m_nFileType = -1;\n\t\tif (!NSDirectory::Exists(m_pInternal->m_sTmpFolder))\n\t\t\tNSDirectory::CreateDirectory(m_pInternal->m_sTmpFolder);\n\n\t\treturn m_pInternal->CreateFile(type);\n\t}\n\tvoid CDocBuilder::SetTmpFolder(const wchar_t* folder)\n\t{\n\t\tif (m_pInternal->m_bIsServerSafeVersion)\n\t\t\treturn;\n\t\tm_pInternal->m_sTmpFolder = std::wstring(folder);\n\t}\n\tvoid CDocBuilder::CloseFile()\n\t{\n\t\tm_pInternal->CloseFile();\n\t}\n\n\tchar* CDocBuilder::GetVersion()\n\t{\n\t\tm_pInternal->Init();\n\n\t\tif (0 == m_pInternal->m_arDoctSDK.size())\n\t\t\treturn NULL;\n\n\t\tstd::wstring sFile;\n\t\tfor (std::vector<std::wstring>::iterator i = m_pInternal->m_arDoctSDK.begin(); i != m_pInternal->m_arDoctSDK.end(); i++)\n\t\t{\n\t\t\tif (std::wstring::npos != i->find(L\"sdk-all-min.js\"))\n\t\t\t{\n\t\t\t\tsFile = *i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sFile.empty())\n\t\t\treturn NULL;\n\n\t\tstd::string sData;\n\t\tif (!NSFile::CFileBinary::ReadAllTextUtf8A(sFile, sData))\n\t\t\treturn NULL;\n\n\t\tstd::string::size_type startPos = sData.find(\"Version:\");\n\t\tif (std::string::npos == startPos)\n\t\t\treturn NULL;\n\n\t\tstartPos += 8;\n\n\t\tstd::string::size_type endPos = sData.find(')', startPos);\n\t\tif (std::string::npos == endPos)\n\t\t\treturn NULL;\n\n\t\tsize_t sSrcLen = endPos - startPos + 1;\n\t\tif (sSrcLen == 0)\n\t\t\treturn NULL;\n\n\t\tchar* sRet = new char[sSrcLen + 1];\n\t\tmemcpy(sRet, sData.c_str() + startPos, sSrcLen);\n\t\tsRet[sSrcLen] = '\\0';\n\t\treturn sRet;\n\t}\n\n\tbool CDocBuilder::Run(const wchar_t* path)\n\t{\n\t\tstd::wstring sPath(path);\n\t\tif (!NSFile::CFileBinary::Exists(sPath))\n\t\t\tsPath = NSFile::GetProcessDirectory() + L\"/\" + sPath;\n\n\t\tstd::string sCommands;\n\t\tbool bRet = NSFile::CFileBinary::ReadAllTextUtf8A(sPath, sCommands);\n\n\t\tif (!bRet)\n\t\t{\n\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error\", L\"cannot read run file\");\n\t\t\treturn bRet;\n\t\t}\n\n\t\treturn this->RunTextA(sCommands.c_str());\n\t}\n\n\tbool CDocBuilder::RunTextW(const wchar_t* commands)\n\t{\n\t\tstd::wstring sCommandsW(commands);\n\t\tstd::string sCommands = U_TO_UTF8(sCommandsW);\n\t\treturn this->RunTextA(sCommands.c_str());\n\t}\n\n\tbool CDocBuilder::RunTextA(const char* commands)\n\t{\n\t\tm_pInternal->Init();\n\t\tstd::list<std::string> _commands;\n\t\tsize_t _commandsLen = strlen(commands);\n\t\tsize_t _currentPos = 0;\n\n\t\twhile (true)\n\t\t{\n\t\t\twhile (_currentPos < _commandsLen && (commands[_currentPos] == 0x0d || commands[_currentPos] == 0x0a))\n\t\t\t\t++_currentPos;\n\n\t\t\tsize_t _start = _currentPos;\n\n\t\t\twhile (_currentPos < _commandsLen && (commands[_currentPos] != 0x0d && commands[_currentPos] != 0x0a))\n\t\t\t\t++_currentPos;\n\n\t\t\tif (_currentPos > _start)\n\t\t\t{\n\t\t\t\tsize_t _start2 = _start;\n\t\t\t\twhile (_start2 < _currentPos && (commands[_start2] == '\\t' || commands[_start2] == ' '))\n\t\t\t\t\t++_start2;\n\n\t\t\t\tif (_currentPos > _start2 && (commands[_start2] != '#' && commands[_start2] != '/'))\n\t\t\t\t{\n\t\t\t\t\t_commands.push_back(std::string(commands + _start2, _currentPos - _start2));\n\t\t\t\t\t// DEBUG\n\t\t\t\t\t//std::cout << std::string(commands + _start2, _currentPos - _start2) << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_currentPos >= _commandsLen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstd::string sJsCommands = \"\";\n\t\tstd::wstring _builder_params[4]; // \u0441 \u0437\u0430\u043f\u0430\u0441\u043e\u043c\n\t\tfor (std::list<std::string>::iterator i = _commands.begin(); i != _commands.end(); i++)\n\t\t{\n\t\t\tconst std::string& command = *i;\n\t\t\tconst char* _data = command.c_str();\n\t\t\tsize_t _len = command.length();\n\n\t\t\tbool bIsBuilder = false;\n\t\t\tif (_len > 8)\n\t\t\t{\n\t\t\t\tif (_data[0] == 'b' &&\n\t\t\t\t\t\t_data[1] == 'u' &&\n\t\t\t\t\t\t_data[2] == 'i' &&\n\t\t\t\t\t\t_data[3] == 'l' &&\n\t\t\t\t\t\t_data[4] == 'd' &&\n\t\t\t\t\t\t_data[5] == 'e' &&\n\t\t\t\t\t\t_data[6] == 'r' &&\n\t\t\t\t\t\t_data[7] == '.')\n\t\t\t\t\tbIsBuilder = true;\n\t\t\t}\n\n\t\t\tbool bIsNoError = true;\n\t\t\tif (bIsBuilder)\n\t\t\t{\n\t\t\t\tif (!sJsCommands.empty())\n\t\t\t\t{\n\t\t\t\t\tstd::wstring sUnicodeCommand = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sJsCommands.c_str(), (LONG)sJsCommands.length());\n\t\t\t\t\tbIsNoError = this->ExecuteCommand(sUnicodeCommand.c_str());\n\t\t\t\t\tsJsCommands = \"\";\n\t\t\t\t\tif (!bIsNoError)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tsize_t _pos = 8;\n\t\t\t\twhile (_data[_pos] != '(')\n\t\t\t\t\t++_pos;\n\n\t\t\t\tstd::string sFuncNum(_data + 8, _pos - 8);\n\t\t\t\tint nCountParameters = 0;\n\t\t\t\tParceParameters(command, _builder_params, nCountParameters);\n\n\t\t\t\tfor (int nCheckParam = 0; nCheckParam < nCountParameters; ++nCheckParam)\n\t\t\t\t{\n\t\t\t\t\tif (0 == _builder_params[nCheckParam].find(L\"jsValue(\") && _builder_params[nCheckParam].length() > 9)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::wstring sParam = _builder_params[nCheckParam].substr(8, _builder_params[nCheckParam].length() - 9);\n\t\t\t\t\t\t_builder_params[nCheckParam] = m_pInternal->m_pWorker->GetJSVariable(sParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\"OpenFile\" == sFuncNum)\n\t\t\t\t\tbIsNoError = (0 == this->OpenFile(_builder_params[0].c_str(), _builder_params[1].c_str()));\n\t\t\t\telse if (\"CreateFile\" == sFuncNum)\n\t\t\t\t{\n\t\t\t\t\tif (L\"docx\" == _builder_params[0])\n\t\t\t\t\t\tbIsNoError = this->CreateFile(AVS_OFFICESTUDIO_FILE_DOCUMENT_DOCX);\n\t\t\t\t\telse if (L\"pptx\" == _builder_params[0])\n\t\t\t\t\t\tbIsNoError = this->CreateFile(AVS_OFFICESTUDIO_FILE_PRESENTATION_PPTX);\n\t\t\t\t\telse if (L\"xlsx\" == _builder_params[0])\n\t\t\t\t\t\tbIsNoError = this->CreateFile(AVS_OFFICESTUDIO_FILE_SPREADSHEET_XLSX);\n\t\t\t\t}\n\t\t\t\telse if (\"SetTmpFolder\" == sFuncNum)\n\t\t\t\t\tthis->SetTmpFolder(_builder_params[0].c_str());\n\t\t\t\telse if (\"CloseFile\" == sFuncNum)\n\t\t\t\t\tthis->CloseFile();\n\t\t\t\telse if (\"SaveFile\" == sFuncNum)\n\t\t\t\t{\n\t\t\t\t\tint nFormat = NSDoctRenderer::GetFormatByTexExtention(_builder_params[0]);\n\n\t\t\t\t\tif (m_pInternal->m_oParams.m_bSaveWithDoctrendererMode)\n\t\t\t\t\t{\n\t\t\t\t\t\t// \u043f\u0435\u0440\u0435\u0434 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\u043c \u0432 \u0442\u0430\u043a\u043e\u0439 \u0441\u0445\u0435\u043c\u0435 \u043d\u0443\u0436\u043d\u043e \u0441\u043a\u0438\u043d\u0443\u0442\u044c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f\n\t\t\t\t\t\tthis->ExecuteCommand(L\"Api.asc_Save();\");\n\t\t\t\t\t}\n\n\t\t\t\t\tconst wchar_t* sParams = NULL;\n\t\t\t\t\tif (nCountParameters > 2)\n\t\t\t\t\t\tsParams = _builder_params[2].c_str();\n\n\t\t\t\t\tthis->SaveFile(nFormat, _builder_params[1].c_str(), sParams);\n\t\t\t\t}\n\t\t\t\telse if (\"WriteData\" == sFuncNum)\n\t\t\t\t{\n\t\t\t\t\tbool isAppend = true;\n\t\t\t\t\tif (nCountParameters > 2)\n\t\t\t\t\t\tisAppend = (L\"true\" == _builder_params[2]) ? true : false;\n\n\t\t\t\t\tthis->WriteData(_builder_params[0].c_str(), _builder_params[1].c_str(), isAppend);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//bIsNoError = this->m_pInternal->ExecuteCommand(NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)_data, (LONG)_len));\n\t\t\t\tsJsCommands += command;\n\t\t\t\tsJsCommands += \"\\n\";\n\t\t\t}\n\n\t\t\tif (!bIsNoError)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (!sJsCommands.empty())\n\t\t{\n\t\t\t// \u0422\u0430\u043a\u043e\u0433\u043e \u0431\u044b\u0442\u044c \u043d\u0435 \u0434\u043e\u043b\u0436\u043d\u043e!!! \u0422\u0430\u043a \u043a\u0430\u043a \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043d\u0438\u043a\u0443\u0434\u0430 \u043d\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u0441\u044f. \u043f\u0443\u0441\u0442\u043e\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435.\n\t\t\tstd::wstring sUnicodeCommand = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sJsCommands.c_str(), (LONG)sJsCommands.length());\n\t\t\tbool bIsNoError = this->ExecuteCommand(sUnicodeCommand.c_str());\n\t\t\tsJsCommands = \"\";\n\t\t\tif (!bIsNoError)\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tvoid CDocBuilder::SetProperty(const char* param, const wchar_t* value)\n\t{\n\t\tstd::string sParam = std::string(param);\n\t\tif (sParam == \"--use-doctrenderer-scheme\")\n\t\t\tm_pInternal->m_oParams.m_bSaveWithDoctrendererMode = true;\n\t\telse if (sParam == \"--check-fonts\")\n\t\t{\n\t\t\tif (value && value[0] == '0')\n\t\t\t\tm_pInternal->m_oParams.m_bCheckFonts = false;\n\t\t\telse\n\t\t\t\tm_pInternal->m_oParams.m_bCheckFonts = true;\n\t\t}\n\t\telse if (sParam == \"--work-directory\")\n\t\t\tm_pInternal->m_oParams.m_sWorkDir = std::wstring(value);\n\t\telse if (sParam == \"--cache-scripts\")\n\t\t\tm_pInternal->m_bIsCacheScript = (std::wstring(value) == L\"true\");\n\t\telse if (sParam == \"--save-use-only-names\")\n\t\t{\n\t\t\tm_pInternal->m_bIsServerSafeVersion = true;\n\t\t\tm_pInternal->m_sFolderForSaveOnlyUseNames = std::wstring(value);\n\t\t}\n\t\telse if (sParam == \"--all-fonts-path\")\n\t\t{\n\t\t\tm_pInternal->SetAllFontsExternal(std::wstring(value));\n\t\t}\n\t\telse if (sParam == \"--argument\")\n\t\t{\n\t\t\tstd::wstring sArg(value);\n\t\t\tm_pInternal->m_oParams.m_sArgumentJSON = U_TO_UTF8(sArg);\n\t\t}\n\t\telse if (sParam == \"--fonts-system\")\n\t\t{\n\t\t\tm_pInternal->m_oParams.m_bIsSystemFonts = (std::wstring(value) == L\"true\");\n\t\t}\n\t\telse if (sParam == \"--fonts-dir\")\n\t\t{\n\t\t\tm_pInternal->m_oParams.m_arFontDirs.push_back(std::wstring(value));\n\t\t}\n\t}\n\tvoid CDocBuilder::SetPropertyW(const wchar_t* param, const wchar_t* value)\n\t{\n\t\tstd::wstring sW(param);\n\t\tstd::string sA = U_TO_UTF8(sW);\n\t\treturn this->SetProperty(sA.c_str(), value);\n\t}\n\n\tvoid CDocBuilder::Initialize(const wchar_t* directory)\n\t{\n\t\tstd::wstring sDirectory = L\"\";\n\t\tif (directory)\n\t\t\tsDirectory = std::wstring(directory);\n\n\t\tNSDoctRenderer::CDocBuilder_Private::m_sExternalDirectory = sDirectory;\n\t\tCJSContext::ExternalInitialize(sDirectory);\n\t}\n\n\tvoid CDocBuilder::Dispose()\n\t{\n\t\tCJSContext::ExternalDispose();\n\t}\n\n\tvoid CDocBuilder::WriteData(const wchar_t* path, const wchar_t* value, const bool& append)\n\t{\n\t\treturn m_pInternal->WriteData(path, value, append);\n\t}\n\n\tbool CDocBuilder::IsSaveWithDoctrendererMode()\n\t{\n\t\treturn m_pInternal->m_oParams.m_bSaveWithDoctrendererMode;\n\t}\n}\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#ifndef DOC_BUILDER_PRIVATE\n#define DOC_BUILDER_PRIVATE\n\n#include \"./config.h\"\n#include \"docbuilder.h\"\n#include \"doctrenderer.h\"\n\n#include <iostream>\n#include <list>\n\n#include \"../../Common/OfficeFileFormats.h\"\n#include \"../../Common/OfficeFileFormatChecker.h\"\n\n#include \"js_internal/js_base.h\"\n#include \"embed/NativeBuilderEmbed.h\"\n#include \"embed/NativeControlEmbed.h\"\n#include \"embed/GraphicsEmbed.h\"\n#include \"embed/Default.h\"\n#ifdef LINUX\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#endif\n\n#ifdef BUIDLER_OPEN_DOWNLOAD_ENABLED\n#include \"../../Common/Network/FileTransporter/include/FileTransporter.h\"\n#endif\n\n#include \"../fontengine/ApplicationFontsWorker.h\"\n\n#ifdef CreateFile\n#undef CreateFile\n#endif\n\nnamespace NSDoctRenderer\n{\n\tstatic int GetFormatByTexExtention(const std::wstring& sExt)\n\t{\n\t\tint nFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_DOCX;\n\t\tif (L\"docx\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_DOCX;\n\t\telse if (L\"doc\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_DOC;\n\t\telse if (L\"odt\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_ODT;\n\t\telse if (L\"rtf\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_RTF;\n\t\telse if (L\"txt\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_DOCUMENT_TXT;\n\t\telse if (L\"pptx\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_PRESENTATION_PPTX;\n\t\telse if (L\"odp\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_PRESENTATION_ODP;\n\t\telse if (L\"xlsx\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_XLSX;\n\t\telse if (L\"xls\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_XLS;\n\t\telse if (L\"ods\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_ODS;\n\t\telse if (L\"csv\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_SPREADSHEET_CSV;\n\t\telse if (L\"pdf\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_CROSSPLATFORM_PDF;\n\t\telse if (L\"image\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_IMAGE;\n\t\telse if (L\"jpg\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_IMAGE;\n\t\telse if (L\"png\" == sExt)\n\t\t\tnFormat = AVS_OFFICESTUDIO_FILE_IMAGE;\n\t\treturn nFormat;\n\t}\n}\n\nnamespace NSDoctRenderer\n{\n\tclass CString_Private\n\t{\n\tpublic:\n\t\twchar_t* m_data;\n\n\tpublic:\n\t\tCString_Private()\n\t\t{\n\t\t\tm_data = NULL;\n\t\t}\n\t\t~CString_Private()\n\t\t{\n\t\t\tif (m_data)\n\t\t\t\tdelete [] m_data;\n\t\t}\n\n\t\tvoid Attach(wchar_t* data)\n\t\t{\n\t\t\tm_data = data;\n\t\t}\n\n\t\tvoid Copy(CString_Private* copy)\n\t\t{\n\t\t\tif (copy->m_data)\n\t\t\t{\n\t\t\t\tdelete [] copy->m_data;\n\t\t\t\tcopy->m_data = NULL;\n\t\t\t}\n\n\t\t\tif (m_data == NULL)\n\t\t\t\treturn;\n\n\t\t\tsize_t len = wcslen(m_data);\n\t\t\tcopy->m_data = new wchar_t[len + 1];\n\t\t\tmemcpy(copy->m_data, m_data, (len + 1) * sizeof(wchar_t));\n\t\t}\n\t};\n}\n\nclass CJSContextData;\nnamespace NSDoctRenderer\n{\n\tclass CDocBuilderContextScopeWrap\n\t{\n\tpublic:\n\t\tJSSmart<CJSContextScope> m_scope;\n\n\tpublic:\n\t\tCDocBuilderContextScopeWrap() : m_scope() {}\n\t\t~CDocBuilderContextScopeWrap() { Close(); }\n\n\t\tvoid Close() { m_scope.Release(); }\n\t};\n\n\tclass CDocBuilderContextScope_Private\n\t{\n\tpublic:\n\t\tJSSmart<CDocBuilderContextScopeWrap> m_scope_wrap;\n\t\tCJSContextData* m_context_data;\n\n\tpublic:\n\t\tCDocBuilderContextScope_Private() : m_scope_wrap() { m_context_data = NULL; }\n\t\t~CDocBuilderContextScope_Private() {}\n\t};\n\n\tclass CDocBuilderContext_Private\n\t{\n\tpublic:\n\t\tJSSmart<CJSContext> m_context;\n\t\tCJSContextData* m_context_data;\n\n\t\tCDocBuilderContext_Private() : m_context() { m_context_data = NULL; }\n\t\t~CDocBuilderContext_Private() { m_context.Release(); }\n\t};\n}\n\nnamespace NSDoctRenderer\n{\n\tclass CDocBuilderValue_Private\n\t{\n\tpublic:\n\t\tclass CParentValueInfo\n\t\t{\n\t\tpublic:\n\t\t\tJSSmart<CJSValue> m_parent;\n\t\t\tint m_parent_index;\n\t\t\tstd::string m_parent_prop_name;\n\n\t\tpublic:\n\t\t\tCParentValueInfo() : m_parent(), m_parent_index(-1), m_parent_prop_name(\"\")\n\t\t\t{\n\t\t\t}\n\t\t};\n\tpublic:\n\t\tJSSmart<CJSContext> m_context;\n\t\tJSSmart<CJSValue> m_value;\n\n\t\t// for operator [index]/[\"name\"] and setter without references\n\t\tJSSmart<CParentValueInfo> m_parent;\n\n\t\tenum PrimitiveType\n\t\t{\n\t\t\tptUndefined     = 0,\n\t\t\tptNull          = 1,\n\t\t\tptBool          = 2,\n\t\t\tptInt           = 3,\n\t\t\tptUInt          = 4,\n\t\t\tptDouble        = 5,\n\t\t\tptString        = 6\n\t\t};\n\n\t\tunion PrimitiveValue\n\t\t{\n\t\t\tbool bValue;\n\t\t\tint nValue;\n\t\t\tunsigned int unValue;\n\t\t\tdouble dValue;\n\t\t\twchar_t* sValue;\n\t\t};\n\n\t\tPrimitiveType m_nativeType;\n\t\tPrimitiveValue m_nativeValue;\n\n\tpublic:\n\t\tCDocBuilderValue_Private() : m_context(NULL)\n\t\t{\n\t\t\tm_nativeType = ptUndefined;\n\t\t}\n\t\t~CDocBuilderValue_Private()\n\t\t{\n\n\t\t}\n\t\tvoid Clear()\n\t\t{\n\t\t\tm_value.Release();\n\t\t\tClearNative();\n\t\t}\n\n\t\t// native\n\t\tvoid CreateUndefined()\n\t\t{\n\t\t\tm_nativeType = ptUndefined;\n\t\t}\n\t\tvoid CreateNull()\n\t\t{\n\t\t\tm_nativeType = ptNull;\n\t\t}\n\t\tvoid CreateBool(const bool& value)\n\t\t{\n\t\t\tm_nativeType = ptBool;\n\t\t\tm_nativeValue.bValue = value;\n\t\t}\n\t\tvoid CreateInt(const int& value)\n\t\t{\n\t\t\tm_nativeType = ptInt;\n\t\t\tm_nativeValue.nValue = value;\n\t\t}\n\t\tvoid CreateUInt(const unsigned int& value)\n\t\t{\n\t\t\tm_nativeType = ptUInt;\n\t\t\tm_nativeValue.unValue = value;\n\t\t}\n\t\tvoid CreateDouble(const double& value)\n\t\t{\n\t\t\tm_nativeType = ptDouble;\n\t\t\tm_nativeValue.dValue = value;\n\t\t}\n\t\tvoid CreateString(const wchar_t*& value)\n\t\t{\n\t\t\tsize_t len = wcslen(value) + 1;\n\t\t\tm_nativeType = ptString;\n\t\t\tm_nativeValue.sValue = new wchar_t[len];\n\t\t\tmemcpy(m_nativeValue.sValue, value, len * sizeof(wchar_t));\n\t\t}\n\t\tvoid CreateString(const char*& value)\n\t\t{\n\t\t\tstd::wstring sValue = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)value, strlen(value));\n\t\t\tconst wchar_t* strTmp = sValue.c_str();\n\t\t\tCreateString(strTmp);\n\t\t}\n\n\t\tvoid ClearNative()\n\t\t{\n\t\t\tif (m_nativeType == ptString)\n\t\t\t{\n\t\t\t\tdelete [] m_nativeValue.sValue;\n\t\t\t}\n\t\t\tm_nativeType = ptUndefined;\n\t\t}\n\n\t\tvoid CheckNative()\n\t\t{\n\t\t\tif (m_value.is_init())\n\t\t\t\treturn;\n\n\t\t\tswitch (m_nativeType)\n\t\t\t{\n\t\t\tcase ptUndefined:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createUndefined();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptNull:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createNull();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptBool:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createBool(m_nativeValue.bValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptInt:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createInt(m_nativeValue.nValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptUInt:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createUInt(m_nativeValue.unValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptDouble:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createDouble(m_nativeValue.dValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ptString:\n\t\t\t{\n\t\t\t\tm_value = NSJSBase::CJSContext::createString(m_nativeValue.sValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tClearNative();\n\t\t}\n\t};\n}\n\nclass CJSContextData\n{\nprivate:\n\tstd::vector<JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>> m_scopes;\n\npublic:\n\tCJSContextData() : m_scopes()\n\t{\n\t}\n\t~CJSContextData()\n\t{\n\t\tClear();\n\t}\n\n\tvoid Clear()\n\t{\n\t\tfor (std::vector<JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>>::iterator iter = m_scopes.begin(); iter != m_scopes.end(); iter++)\n\t\t{\n\t\t\t(*iter)->Close();\n\t\t}\n\t\tm_scopes.clear();\n\t}\n\n\tvoid RemoveScope(JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>& scope)\n\t{\n\t\tif (!scope.is_init())\n\t\t\treturn;\n\t\tfor (std::vector<JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>>::iterator iter = m_scopes.begin(); iter != m_scopes.end(); iter++)\n\t\t{\n\t\t\tif (scope.GetPointer() == iter->GetPointer())\n\t\t\t{\n\t\t\t\tm_scopes.erase(iter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid AddScope(JSSmart<NSDoctRenderer::CDocBuilderContextScopeWrap>& scope)\n\t{\n\t\tm_scopes.push_back(scope);\n\t}\n};\n\nclass CV8RealTimeWorker\n{\npublic:\n\tJSSmart<CJSIsolateScope> m_isolate_scope;\n\tJSSmart<CJSLocalScope> m_handle_scope;\n\tJSSmart<CJSContext> m_context;\n\n\tint m_nFileType;\n\tstd::string m_sUtf8ArgumentJSON;\n\tstd::string m_sGlobalVariable;\n\n\tCJSContextData m_oContextData;\n\npublic:\n\n\tCV8RealTimeWorker(NSDoctRenderer::CDocBuilder* pBuilder);\n\t~CV8RealTimeWorker();\n\npublic:\n\n\tstatic void _LOGGING_ERROR_(const std::wstring& strType, const std::wstring& strError);\n\n\tbool ExecuteCommand(const std::wstring& command, NSDoctRenderer::CDocBuilderValue* retValue = NULL);\n\n\tstd::string GetGlobalVariable();\n\tstd::wstring GetJSVariable(std::wstring sParam);\n\n\tbool OpenFile(const std::wstring& sBasePath, const std::wstring& path, const std::string& sString, const std::wstring& sCachePath, CV8Params* pParams = NULL);\n\tbool SaveFileWithChanges(int type, const std::wstring& _path, const std::wstring& sJsonParams = L\"\");\n};\n\nnamespace NSDoctRenderer\n{\n\tclass CAdditionalData\n\t{\n\tpublic:\n\t\tCAdditionalData() {}\n\t\tvirtual ~CAdditionalData() {}\n\t\tvirtual std::string getParam(const std::wstring& name) { return \"\"; }\n\t};\n\n\tclass CDocBuilderParams\n\t{\n\tpublic:\n\t\tCDocBuilderParams() : m_bCheckFonts(false), m_sWorkDir(L\"\"), m_bSaveWithDoctrendererMode(false), m_sArgumentJSON(\"\"), m_bIsSystemFonts(true) {}\n\n\tpublic:\n\t\tbool m_bCheckFonts;\n\t\tstd::wstring m_sWorkDir;\n\t\tbool m_bSaveWithDoctrendererMode;\n\t\tstd::string m_sArgumentJSON;\n\n\t\tbool m_bIsSystemFonts;\n\t\tstd::vector<std::wstring> m_arFontDirs;\n\t};\n\n\tclass CDocBuilder_Private : public CDoctRendererConfig\n\t{\n\tpublic:\n\t\tstd::wstring m_strEditorType;\n\t\tstd::wstring m_strFilePath;\n\n\t\tstd::wstring m_sTmpFolder;\n\t\tstd::wstring m_sFileDir;\n\t\tint m_nFileType;\n\n\t\tstd::wstring m_sX2tPath;\n\n\t\tCV8RealTimeWorker* m_pWorker;\n\n\t\tCAdditionalData* m_pAdditionalData;\n\n\t\tCDocBuilderParams m_oParams;\n\t\tbool m_bIsInit;\n\n\t\tbool m_bIsCacheScript;\n\n\t\tbool m_bIsServerSafeVersion;\n\t\tstd::wstring m_sFolderForSaveOnlyUseNames;\n\n\t\tstd::string m_sGlobalVariable;\n\t\tbool m_bIsGlobalVariableUse;\n\n\t\tNSDoctRenderer::CDocBuilder* m_pParent;\n\n\t\tstatic std::wstring m_sExternalDirectory;\n\tpublic:\n\t\tCDocBuilder_Private() : CDoctRendererConfig(), m_sTmpFolder(NSFile::CFileBinary::GetTempPath()), m_nFileType(-1),\n\t\t\tm_pWorker(NULL), m_pAdditionalData(NULL), m_bIsInit(false), m_bIsCacheScript(true), m_bIsServerSafeVersion(false),\n\t\t\tm_sGlobalVariable(\"\"), m_bIsGlobalVariableUse(false), m_pParent(NULL)\n\t\t{\n\t\t}\n\n\t\tvoid Init()\n\t\t{\n\t\t\tif (m_bIsInit)\n\t\t\t\treturn;\n\n\t\t\tstd::wstring sWorkDir = m_oParams.m_sWorkDir;\n\t\t\tif (sWorkDir.empty() || !NSDirectory::Exists(sWorkDir))\n\t\t\t{\n\t\t\t\tsWorkDir = NSFile::GetProcessDirectory();\n\t\t\t\tif (!m_oParams.m_sWorkDir.empty())\n\t\t\t\t{\n\t\t\t\t\tstd::wstring sCheck = sWorkDir;\n\t\t\t\t\tif (0 != m_oParams.m_sWorkDir.find('/'))\n\t\t\t\t\t\tsCheck += L\"/\";\n\t\t\t\t\tsCheck += m_oParams.m_sWorkDir;\n\t\t\t\t\tif (NSDirectory::Exists(sCheck))\n\t\t\t\t\t\tsWorkDir = sCheck;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::wstring sNatural = NSFile::GetProcessDirectory();\n\t\t\t\tif (0 != sWorkDir.find('/'))\n\t\t\t\t\tsNatural += L\"/\";\n\t\t\t\tsNatural += sWorkDir;\n\t\t\t\tif (NSDirectory::Exists(sNatural))\n\t\t\t\t\tsWorkDir = sNatural;\n\t\t\t}\n\n\t\t\tm_sX2tPath = sWorkDir;\n\n\t\t\tCDoctRendererConfig::Parse(sWorkDir);\n\n\t\t\tCheckFonts(m_oParams.m_bCheckFonts);\n\n\t\t\tm_bIsInit = true;\n\t\t}\n\n\t\t~CDocBuilder_Private()\n\t\t{\n\t\t\tCloseFile();\n\n\t\t\tRELEASEOBJECT(m_pAdditionalData);\n\t\t}\n\n\t\tvoid CheckFonts(bool bIsCheckFonts)\n\t\t{\n\t\t\tstd::wstring sDirectory = NSFile::GetDirectoryName(m_strAllFonts);\n\t\t\tstd::wstring strFontsSelectionBin = sDirectory + L\"/font_selection.bin\";\n\n\t\t\tif (!bIsCheckFonts && NSFile::CFileBinary::Exists(strFontsSelectionBin))\n\t\t\t\treturn;\n\n\t\t\tCApplicationFontsWorker oWorker;\n\t\t\toWorker.m_bIsUseSystemFonts = m_oParams.m_bIsSystemFonts;\n\t\t\toWorker.m_arAdditionalFolders = m_oParams.m_arFontDirs;\n\t\t\toWorker.m_bIsNeedThumbnails = false;\n\t\t\toWorker.m_sDirectory = sDirectory;\n\t\t\t// \u044d\u0442\u043e \u043d\u0435 \u0440\u0430\u0431\u043e\u0447\u0430\u044f \u043f\u0430\u043f\u043a\u0430, \u0433\u0434\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0448\u0440\u0438\u0444\u0442\u044b\n\t\t\toWorker.m_bIsCleanDirectory = false;\n\t\t\tNSFonts::IApplicationFonts* pFonts = oWorker.Check();\n\t\t\tif(pFonts)\n\t\t\t\tpFonts->Release();\n\t\t}\n\n\t\tvoid CheckFileDir()\n\t\t{\n\t\t\tm_sFileDir = NSFile::CFileBinary::CreateTempFileWithUniqueName(m_sTmpFolder, L\"DE_\");\n\t\t\tif (NSFile::CFileBinary::Exists(m_sFileDir))\n\t\t\t\tNSFile::CFileBinary::Remove(m_sFileDir);\n\n\t\t\tNSStringUtils::string_replace(m_sFileDir, L\"\\\\\", L\"/\");\n\n\t\t\tstd::wstring::size_type nPosPoint = m_sFileDir.rfind('.');\n\t\t\tif (nPosPoint != std::wstring::npos && nPosPoint > m_sTmpFolder.length())\n\t\t\t{\n\t\t\t\tm_sFileDir = m_sFileDir.substr(0, nPosPoint);\n\t\t\t}\n\n\t\t\tm_nFileType = -1;\n\n\t\t\tNSDirectory::CreateDirectory(m_sFileDir);\n\t\t}\n\n\t\tbool CreateFile(int type)\n\t\t{\n\t\t\tInit();\n#if 1\n\t\t\tCheckFileDir();\n\n\t\t\tstd::wstring sEmptyPath = m_sX2tPath + L\"/empty/\";\n\n#if 0\n\t\t\tif (type & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"docx.bin\";\n\t\t\t\tm_nFileType = 0;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"pptx.bin\";\n\t\t\t\tm_nFileType = 1;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"xlsx.bin\";\n\t\t\t\tm_nFileType = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\t\tbool bRet = NSFile::CFileBinary::Copy(sEmptyPath, m_sFileDir + L\"/Editor.bin\");\n\t\t\tif (bRet)\n\t\t\t{\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/media\");\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/changes\");\n\t\t\t}\n#endif\n\n\t\t\tif (type & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"new.docx\";\n\t\t\t\tm_nFileType = 0;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"new.pptx\";\n\t\t\t\tm_nFileType = 1;\n\t\t\t}\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t{\n\t\t\t\tsEmptyPath = sEmptyPath + L\"new.xlsx\";\n\t\t\t\tm_nFileType = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\t\tbool bRet = (0 == ConvertToInternalFormat(m_sFileDir, sEmptyPath, L\"\")) ? true : false;\n\t\t\tif (bRet)\n\t\t\t{\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/media\");\n\t\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/changes\");\n\t\t\t}\n\n\t\t\treturn bRet;\n#else\n\t\t\tstd::wstring sPath = m_sX2tPath + L\"/empty/new.\";\n\t\t\tif (type & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t\tsPath += L\"docx\";\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t\tsPath += L\"pptx\";\n\t\t\telse if (type & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t\tsPath += L\"xlsx\";\n\t\t\treturn this->OpenFile(sPath, L\"\");\n#endif\n\t\t}\n\n\t\tvoid MoveFileOpen(const std::wstring& from, const std::wstring& to)\n\t\t{\n#ifdef BUIDLER_OPEN_DOWNLOAD_ENABLED\n\t\t\tint n1 = (int)from.find (L\"www\");\n\t\t\tint n2 = (int)from.find (L\"http\");\n\t\t\tint n3 = (int)from.find (L\"ftp\");\n\t\t\tint n4 = (int)from.find (L\"https\");\n\n\t\t\t//\u0435\u0441\u043b\u0438 nI \u0441\u0440\u0430\u043d\u0438\u0432\u0430\u0442\u044c \u043d\u0435 \u0441 0, \u0442\u043e \u0431\u0443\u0434\u0443\u0442 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b\n\t\t\t//\u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0432 \u0438\u043d\u0441\u0442\u0430\u043b\u044f\u0446\u0438\u0438 \u043c\u044b \u043a\u043b\u0430\u0434\u0435\u043c \u0444\u0430\u0439\u043b\u044b \u0432 /var/www...\n\t\t\tif (0 == n1 || 0 == n2 || 0 == n3 || 0 == n4)\n\t\t\t{\n\t\t\t\tNSNetwork::NSFileTransport::CFileDownloader oDownloader(from, false);\n\t\t\t\toDownloader.SetFilePath(to);\n\t\t\t\tif (oDownloader.DownloadSync())\n\t\t\t\t\treturn;\n\t\t\t}\n#endif\n\n#ifdef BUIDLER_OPEN_BASE64_ENABLED\n\t\t\tif (0 == from.find(L\"data:\"))\n\t\t\t{\n\t\t\t\tstd::wstring::size_type findBase64 = from.find(L\"base64,\");\n\t\t\t\tif (std::wstring::npos != findBase64)\n\t\t\t\t{\n\t\t\t\t\tint nStartBase64 = (int)findBase64;\n\t\t\t\t\tif (50 > nStartBase64)\n\t\t\t\t\t{\n\t\t\t\t\t\tnStartBase64 += 7;\n\t\t\t\t\t\tconst wchar_t* pStart = from.c_str() + nStartBase64;\n\t\t\t\t\t\tint nDataLen = (int)from.length() - nStartBase64;\n\n\t\t\t\t\t\tstd::string sBase64 = NSFile::CUtf8Converter::GetUtf8StringFromUnicode2(pStart, (LONG)nDataLen, false);\n\n\t\t\t\t\t\tBYTE* pDataDst = NULL;\n\t\t\t\t\t\tint nDataDstLen = 0;\n\t\t\t\t\t\tif (NSFile::CBase64Converter::Decode(sBase64.c_str(), (int)sBase64.length(), pDataDst, nDataLen))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNSFile::CFileBinary oFileDst;\n\t\t\t\t\t\t\tif (oFileDst.CreateFileW(to))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toFileDst.WriteFile(pDataDst, (DWORD)nDataDstLen);\n\t\t\t\t\t\t\t\toFileDst.CloseFile();\n\n\t\t\t\t\t\t\t\tRELEASEARRAYOBJECTS(pDataDst);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tRELEASEARRAYOBJECTS(pDataDst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\t// \u043d\u0435 \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0432 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438.\n\t\t\tif (m_bIsServerSafeVersion)\n\t\t\t\treturn;\n\n\t\t\tNSFile::CFileBinary::Copy(from, to);\n\t\t}\n\n\t\tint ConvertToInternalFormat(const std::wstring& sFolder, const std::wstring& sFile, const std::wstring& sParams)\n\t\t{\n\t\t\tNSStringUtils::CStringBuilder oBuilder;\n\t\t\toBuilder.WriteString(L\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><TaskQueueDataConvert><m_sFileFrom>\");\n\t\t\toBuilder.WriteEncodeXmlString(sFile);\n\t\t\toBuilder.WriteString(L\"</m_sFileFrom><m_sFileTo>\");\n\t\t\toBuilder.WriteEncodeXmlString(sFolder);\n\t\t\toBuilder.WriteString(L\"/Editor.bin</m_sFileTo><m_nFormatTo>8192</m_nFormatTo>\");\n\n\t\t\tif (!m_bIsNotUseConfigAllFontsDir)\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_sX2tPath + L\"/sdkjs/common\");\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(NSFile::GetDirectoryName(m_strAllFonts));\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\n\t\t\t\toBuilder.WriteString(L\"<m_sAllFontsPath>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_strAllFonts);\n\t\t\t\toBuilder.WriteString(L\"</m_sAllFontsPath>\");\n\t\t\t}\n\n\t\t\toBuilder.WriteString(L\"<m_bIsNoBase64>true</m_bIsNoBase64>\");\n\t\t\toBuilder.WriteString(L\"<m_sThemeDir>./sdkjs/slide/themes</m_sThemeDir><m_bDontSaveAdditional>true</m_bDontSaveAdditional>\");\n\t\t\toBuilder.WriteString(sParams);\n\t\t\toBuilder.WriteString(L\"</TaskQueueDataConvert>\");\n\n\t\t\tstd::wstring sXmlConvert = oBuilder.GetData();\n\n\t\t\tstd::wstring sConverterExe = m_sX2tPath + L\"/x2t\";\n\n\t\t\tint nReturnCode = 0;\n\n\t\t\tstd::wstring sTempFileForParams = sFolder + L\"/params_from.xml\";\n\t\t\tNSFile::CFileBinary::SaveToFile(sTempFileForParams, sXmlConvert, true);\n\n#ifdef WIN32\n\t\t\tstd::wstring sApp = L\"x2t32 \";\n\n\t\t\tif (NSFile::CFileBinary::Exists(sConverterExe + L\".exe\"))\n\t\t\t{\n\t\t\t\tsApp = L\"x2t \";\n\t\t\t\tsConverterExe += L\".exe\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tsConverterExe += L\"32.exe\";\n\n\t\t\tSTARTUPINFO sturtupinfo;\n\t\t\tZeroMemory(&sturtupinfo,sizeof(STARTUPINFO));\n\t\t\tsturtupinfo.cb = sizeof(STARTUPINFO);\n\n\t\t\tsApp += (L\"\\\"\" + sTempFileForParams + L\"\\\"\");\n\t\t\twchar_t* pCommandLine = NULL;\n\t\t\tif (true)\n\t\t\t{\n\t\t\t\tpCommandLine = new wchar_t[sApp.length() + 1];\n\t\t\t\tmemcpy(pCommandLine, sApp.c_str(), sApp.length() * sizeof(wchar_t));\n\t\t\t\tpCommandLine[sApp.length()] = (wchar_t)'\\0';\n\t\t\t}\n\n\t\t\tPROCESS_INFORMATION processinfo;\n\t\t\tZeroMemory(&processinfo,sizeof(PROCESS_INFORMATION));\n\t\t\tBOOL bResult = CreateProcessW(sConverterExe.c_str(), pCommandLine,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &sturtupinfo, &processinfo);\n\n\t\t\t::WaitForSingleObject(processinfo.hProcess, INFINITE);\n\n\t\t\tRELEASEARRAYOBJECTS(pCommandLine);\n\n\t\t\t//get exit code\n\t\t\tDWORD dwExitCode = 0;\n\t\t\tif (GetExitCodeProcess(processinfo.hProcess, &dwExitCode))\n\t\t\t{\n\t\t\t\tnReturnCode = (int)dwExitCode;\n\t\t\t}\n\n\t\t\tCloseHandle(processinfo.hProcess);\n\t\t\tCloseHandle(processinfo.hThread);\n\n#endif\n\n#ifdef LINUX\n\t\t\tpid_t pid = fork(); // create child process\n\t\t\tint status;\n\n\t\t\tstd::string sProgramm = U_TO_UTF8(sConverterExe);\n\t\t\tstd::string sXmlA = U_TO_UTF8(sTempFileForParams);\n\n\t\t\tswitch (pid)\n\t\t\t{\n\t\t\tcase -1: // error\n\t\t\t\tbreak;\n\n\t\t\tcase 0: // child process\n\t\t\t{\n\t\t\t\tstd::string sLibraryDir = sProgramm;\n\t\t\t\tstd::string sPATH = sProgramm;\n\t\t\t\tif (std::string::npos != sProgramm.find_last_of('/'))\n\t\t\t\t{\n\t\t\t\t\tsLibraryDir = \"LD_LIBRARY_PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t\tsPATH = \"PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t}\n\n#ifdef _MAC\n\t\t\t\tsLibraryDir = \"DY\" + sLibraryDir;\n#endif\n\n\t\t\t\tconst char* nargs[3];\n\t\t\t\tnargs[0] = sProgramm.c_str();\n\t\t\t\tnargs[1] = sXmlA.c_str();\n\t\t\t\tnargs[2] = NULL;\n\n#ifndef _MAC\n\t\t\t\tconst char* nenv[2];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = NULL;\n#else\n\t\t\t\tconst char* nenv[3];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = sPATH.c_str();\n\t\t\t\tnenv[2] = NULL;\n#endif\n\n\t\t\t\texecve(sProgramm.c_str(),\n\t\t\t\t\t   (char * const *)nargs,\n\t\t\t\t\t   (char * const *)nenv);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: // parent process, pid now contains the child pid\n\t\t\t\twhile (-1 == waitpid(pid, &status, 0)); // wait for child to complete\n\t\t\t\tif (WIFEXITED(status))\n\t\t\t\t{\n\t\t\t\t\tnReturnCode =  WEXITSTATUS(status);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tNSFile::CFileBinary::Remove(sTempFileForParams);\n\n\t\t\treturn nReturnCode;\n\t\t}\n\n\t\tstd::wstring GetFileCopyExt(const std::wstring& path)\n\t\t{\n\t\t\tstd::wstring sExtCopy = NSFile::GetFileExtention(path);\n\n\t\t\tif (true)\n\t\t\t{\n\t\t\t\t// \u0434\u043b\u044f \u0444\u0430\u0439\u043b\u043e\u0432 \u043f\u043e \u0441\u0441\u044b\u043b\u043a\u0435 - \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u043b\u043e\u0445\u0438\u043c.\n\t\t\t\tconst wchar_t* sExtCopyPtr = sExtCopy.c_str();\n\t\t\t\tint nExtCopyLen = sExtCopy.length();\n\t\t\t\tint nValidIndex = 0;\n\t\t\t\twhile (nValidIndex < nExtCopyLen)\n\t\t\t\t{\n\t\t\t\t\twchar_t c = sExtCopyPtr[nValidIndex];\n\t\t\t\t\tif ((c >= 'a' && c <= 'z') ||\n\t\t\t\t\t\t\t(c >= 'A' && c <= 'Z') ||\n\t\t\t\t\t\t\t(c >= '0' && c <= '9'))\n\t\t\t\t\t{\n\t\t\t\t\t\t++nValidIndex;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (nValidIndex > 0)\n\t\t\t\t{\n\t\t\t\t\tsExtCopy = sExtCopy.substr(0, nValidIndex);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsExtCopy = L\"tmp\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sExtCopy;\n\t\t}\n\n\t\tint OpenFile(const std::wstring& path, const std::wstring& params)\n\t\t{\n\t\t\tInit();\n\n\t\t\tLOGGER_SPEED_START\n\n\t\t\tCheckFileDir();\n\t\t\tNSDirectory::CreateDirectory(m_sFileDir + L\"/changes\");\n\n\t\t\tstd::wstring sExtCopy = GetFileCopyExt(path);\n\t\t\tstd::wstring sFileCopy = m_sFileDir + L\"/origin.\" + sExtCopy;\n\t\t\tMoveFileOpen(path, sFileCopy);\n\n\t\t\tCOfficeFileFormatChecker oChecker;\n\t\t\tif (!oChecker.isOfficeFile(sFileCopy))\n\t\t\t\treturn false;\n\n\t\t\tif (oChecker.nFileType & AVS_OFFICESTUDIO_FILE_DOCUMENT)\n\t\t\t\tm_nFileType = 0;\n\t\t\tif (oChecker.nFileType & AVS_OFFICESTUDIO_FILE_PRESENTATION)\n\t\t\t\tm_nFileType = 1;\n\t\t\tif (oChecker.nFileType & AVS_OFFICESTUDIO_FILE_SPREADSHEET)\n\t\t\t\tm_nFileType = 2;\n\n\t\t\tint nReturnCode = ConvertToInternalFormat(m_sFileDir, sFileCopy, params);\n\n\t\t\tLOGGER_SPEED_LAP(\"open_convert\")\n\n\t\t\tif (0 == nReturnCode)\n\t\t\t\treturn 0;\n\n\t\t\tNSDirectory::DeleteDirectory(m_sFileDir);\n\t\t\tm_sFileDir = L\"\";\n\t\t\tm_nFileType = -1;\n\n\t\t\tstd::wstring sErrorLog = L\"open file error (\" + std::to_wstring(nReturnCode) + L\")\";\n\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error: \", sErrorLog);\n\t\t\treturn nReturnCode;\n\t\t}\n\n\t\tvoid CloseFile()\n\t\t{\n\t\t\tInit();\n\n\t\t\tif (NSDirectory::Exists(m_sFileDir))\n\t\t\t\tNSDirectory::DeleteDirectory(m_sFileDir);\n\n\t\t\tm_sFileDir = L\"\";\n\t\t\tm_nFileType = -1;\n\n\t\t\tif (m_pWorker)\n\t\t\t\tm_sGlobalVariable = m_pWorker->GetGlobalVariable();\n\t\t\tRELEASEOBJECT(m_pWorker);\n\t\t}\n\n\t\tstd::wstring GetSaveFilePath(const std::wstring& path)\n\t\t{\n\t\t\tstd::wstring _path = path;\n\t\t\tif (!m_sFolderForSaveOnlyUseNames.empty())\n\t\t\t{\n\t\t\t\t_path = m_sFolderForSaveOnlyUseNames;\n\t\t\t\twchar_t last = m_sFolderForSaveOnlyUseNames.c_str()[m_sFolderForSaveOnlyUseNames.length() - 1];\n\t\t\t\tif (last != '/' && last != '\\\\')\n\t\t\t\t\t_path += L\"/\";\n\t\t\t\t_path += NSFile::GetFileName(path);\n\t\t\t}\n\n\t\t\tstd::wstring sDstFileDir = NSFile::GetDirectoryName(_path);\n\t\t\tif ((sDstFileDir != _path) && !NSDirectory::Exists(sDstFileDir))\n\t\t\t\tNSDirectory::CreateDirectories(sDstFileDir);\n\n\t\t\treturn _path;\n\t\t}\n\n\t\tint SaveFile(const int& type, const std::wstring& path, const wchar_t* params = NULL)\n\t\t{\n\t\t\tInit();\n\n\t\t\tif (-1 == m_nFileType)\n\t\t\t{\n\t\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error (save)\", L\"file not opened!\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tLOGGER_SPEED_START\n\n\t\t\t\t\tstd::wstring sConvertionParams = L\"\";\n\t\t\tif (NULL != params)\n\t\t\t{\n\t\t\t\tsConvertionParams = std::wstring(params);\n\t\t\t\tNSStringUtils::string_replace(sConvertionParams, L\"\\'\", L\"&quot;\");\n\t\t\t}\n\n\t\t\tstd::wstring sFileBin = L\"/Editor.bin\";\n\n\t\t\tif (!m_oParams.m_bSaveWithDoctrendererMode && m_pWorker)\n\t\t\t{\n\t\t\t\tstd::wstring sJsonParams = sConvertionParams;\n\t\t\t\tif (!sJsonParams.empty())\n\t\t\t\t{\n\t\t\t\t\tstd::wstring::size_type pos1 = sJsonParams.find(L\">\");\n\t\t\t\t\tstd::wstring::size_type pos2 = sJsonParams.find(L\"</\");\n\t\t\t\t\tif (std::wstring::npos != pos1 && std::wstring::npos != pos2)\n\t\t\t\t\t{\n\t\t\t\t\t\tsJsonParams = sJsonParams.substr(pos1 + 1, pos2 - pos1 - 1);\n\t\t\t\t\t\tNSStringUtils::string_replace(sJsonParams, L\"&quot;\", L\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsJsonParams = L\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis->m_pWorker->SaveFileWithChanges(type, m_sFileDir + L\"/Editor2.bin\", sJsonParams);\n\t\t\t\tsFileBin = L\"/Editor2.bin\";\n\t\t\t}\n\n\t\t\tNSStringUtils::CStringBuilder oBuilder;\n\n\t\t\tstd::wstring _path = GetSaveFilePath(path);\n\n\t\t\toBuilder.WriteString(L\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><TaskQueueDataConvert><m_sFileFrom>\");\n\t\t\toBuilder.WriteEncodeXmlString(m_sFileDir);\n\t\t\toBuilder.WriteString(sFileBin + L\"</m_sFileFrom><m_sFileTo>\");\n\t\t\toBuilder.WriteEncodeXmlString(_path);\n\t\t\toBuilder.WriteString(L\"</m_sFileTo><m_nFormatTo>\");\n\t\t\toBuilder.WriteString(std::to_wstring(type));\n\t\t\toBuilder.WriteString(L\"</m_nFormatTo><m_sThemeDir>\");\n\t\t\toBuilder.WriteEncodeXmlString(L\"./sdkjs/slide/themes\");\n\t\t\tif (!m_oParams.m_bSaveWithDoctrendererMode)\n\t\t\t\toBuilder.WriteString(L\"</m_sThemeDir><m_bDontSaveAdditional>true</m_bDontSaveAdditional>\");\n\t\t\telse\n\t\t\t\toBuilder.WriteString(L\"</m_sThemeDir><m_bFromChanges>true</m_bFromChanges><m_bDontSaveAdditional>true</m_bDontSaveAdditional>\");\n\t\t\toBuilder.WriteString(L\"<m_nCsvTxtEncoding>46</m_nCsvTxtEncoding><m_nCsvDelimiter>4</m_nCsvDelimiter>\");\n\n\t\t\tif (!m_bIsNotUseConfigAllFontsDir)\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_sX2tPath + L\"/sdkjs/common\");\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toBuilder.WriteString(L\"<m_sFontDir>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(NSFile::GetDirectoryName(m_strAllFonts));\n\t\t\t\toBuilder.WriteString(L\"</m_sFontDir>\");\n\n\t\t\t\toBuilder.WriteString(L\"<m_sAllFontsPath>\");\n\t\t\t\toBuilder.WriteEncodeXmlString(m_strAllFonts);\n\t\t\t\toBuilder.WriteString(L\"</m_sAllFontsPath>\");\n\t\t\t}\n\n\t\t\tif (!sConvertionParams.empty())\n\t\t\t{\n\t\t\t\toBuilder.WriteString(sConvertionParams);\n\t\t\t}\n\n\t\t\tstd::wstring sDstTmpDir = NSDirectory::CreateDirectoryWithUniqueName(m_sFileDir);\n\n\t\t\toBuilder.WriteString(L\"<m_sTempDir>\");\n\t\t\toBuilder.WriteEncodeXmlString(sDstTmpDir);\n\t\t\toBuilder.WriteString(L\"</m_sTempDir>\");\n\n\t\t\toBuilder.WriteString(L\"</TaskQueueDataConvert>\");\n\n\t\t\tstd::wstring sXmlConvert = oBuilder.GetData();\n\n\t\t\tstd::wstring sConverterExe = m_sX2tPath + L\"/x2t\";\n\n\t\t\tint nReturnCode = 0;\n\n\t\t\tstd::wstring sTempFileForParams = m_sFileDir + L\"/params_to.xml\";\n\t\t\tNSFile::CFileBinary::SaveToFile(sTempFileForParams, sXmlConvert, true);\n\n#ifdef WIN32\n\t\t\tstd::wstring sApp = L\"x2t32 \";\n\n\t\t\tif (NSFile::CFileBinary::Exists(sConverterExe + L\".exe\"))\n\t\t\t{\n\t\t\t\tsApp = L\"x2t \";\n\t\t\t\tsConverterExe += L\".exe\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tsConverterExe += L\"32.exe\";\n\n\t\t\tSTARTUPINFO sturtupinfo;\n\t\t\tZeroMemory(&sturtupinfo,sizeof(STARTUPINFO));\n\t\t\tsturtupinfo.cb = sizeof(STARTUPINFO);\n\n\t\t\tsApp += (L\"\\\"\" + sTempFileForParams + L\"\\\"\");\n\t\t\twchar_t* pCommandLine = NULL;\n\t\t\tif (true)\n\t\t\t{\n\t\t\t\tpCommandLine = new wchar_t[sApp.length() + 1];\n\t\t\t\tmemcpy(pCommandLine, sApp.c_str(), sApp.length() * sizeof(wchar_t));\n\t\t\t\tpCommandLine[sApp.length()] = (wchar_t)'\\0';\n\t\t\t}\n\n\t\t\tPROCESS_INFORMATION processinfo;\n\t\t\tZeroMemory(&processinfo,sizeof(PROCESS_INFORMATION));\n\t\t\tBOOL bResult = CreateProcessW(sConverterExe.c_str(), pCommandLine,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &sturtupinfo, &processinfo);\n\n\t\t\t::WaitForSingleObject(processinfo.hProcess, INFINITE);\n\n\t\t\tRELEASEARRAYOBJECTS(pCommandLine);\n\n\t\t\t//get exit code\n\t\t\tDWORD dwExitCode = 0;\n\t\t\tif (GetExitCodeProcess(processinfo.hProcess, &dwExitCode))\n\t\t\t{\n\t\t\t\tnReturnCode = (int)dwExitCode;\n\t\t\t}\n\n\t\t\tCloseHandle(processinfo.hProcess);\n\t\t\tCloseHandle(processinfo.hThread);\n\n#endif\n\n#ifdef LINUX\n\t\t\tpid_t pid = fork(); // create child process\n\t\t\tint status;\n\n\t\t\tstd::string sProgramm = U_TO_UTF8(sConverterExe);\n\t\t\tstd::string sXmlA = U_TO_UTF8(sTempFileForParams);\n\n\t\t\tswitch (pid)\n\t\t\t{\n\t\t\tcase -1: // error\n\t\t\t\tbreak;\n\n\t\t\tcase 0: // child process\n\t\t\t{\n\t\t\t\tstd::string sLibraryDir = sProgramm;\n\t\t\t\tstd::string sPATH = sProgramm;\n\t\t\t\tif (std::string::npos != sProgramm.find_last_of('/'))\n\t\t\t\t{\n\t\t\t\t\tsLibraryDir = \"LD_LIBRARY_PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t\tsPATH = \"PATH=\" + sProgramm.substr(0, sProgramm.find_last_of('/'));\n\t\t\t\t}\n\n#ifdef _MAC\n\t\t\t\tsLibraryDir = \"DY\" + sLibraryDir;\n#endif\n\n\t\t\t\tconst char* nargs[3];\n\t\t\t\tnargs[0] = sProgramm.c_str();\n\t\t\t\tnargs[1] = sXmlA.c_str();\n\t\t\t\tnargs[2] = NULL;\n\n#ifndef _MAC\n\t\t\t\tconst char* nenv[2];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = NULL;\n#else\n\t\t\t\tconst char* nenv[3];\n\t\t\t\tnenv[0] = sLibraryDir.c_str();\n\t\t\t\tnenv[1] = sPATH.c_str();\n\t\t\t\tnenv[2] = NULL;\n#endif\n\n\t\t\t\texecve(sProgramm.c_str(),\n\t\t\t\t\t   (char * const *)nargs,\n\t\t\t\t\t   (char * const *)nenv);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: // parent process, pid now contains the child pid\n\t\t\t\twhile (-1 == waitpid(pid, &status, 0)); // wait for child to complete\n\t\t\t\tif (WIFEXITED(status))\n\t\t\t\t{\n\t\t\t\t\tnReturnCode =  WEXITSTATUS(status);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tNSDirectory::DeleteDirectory(sDstTmpDir);\n\t\t\tNSFile::CFileBinary::Remove(sTempFileForParams);\n\n\t\t\tLOGGER_SPEED_LAP(\"save_convert\")\n\n\t\t\t\t\tif (0 == nReturnCode)\n\t\t\t\t\treturn 0;\n\n\t\t\tstd::wstring sErrorLog = L\"save file error (\" + std::to_wstring(nReturnCode) + L\")\";\n\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error: \", sErrorLog);\n\t\t\treturn nReturnCode;\n\t\t}\n\n\t\tbool CheckWorker()\n\t\t{\n\t\t\tif (-1 == m_nFileType)\n\t\t\t{\n\t\t\t\tCV8RealTimeWorker::_LOGGING_ERROR_(L\"error (command)\", L\"file not opened!\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (NULL == m_pWorker)\n\t\t\t{\n\t\t\t\tm_pWorker = new CV8RealTimeWorker(m_pParent);\n\t\t\t\tm_pWorker->m_nFileType = m_nFileType;\n\t\t\t\tm_pWorker->m_sUtf8ArgumentJSON = m_oParams.m_sArgumentJSON;\n\t\t\t\tm_pWorker->m_sGlobalVariable = m_sGlobalVariable;\n\n\t\t\t\tstd::wstring sCachePath = L\"\";\n\t\t\t\tif (m_bIsCacheScript)\n\t\t\t\t\tsCachePath = GetScriptCache();\n\n\t\t\t\tCV8Params oParams;\n\t\t\t\toParams.IsServerSaveVersion = m_bIsServerSafeVersion;\n\t\t\t\toParams.DocumentDirectory = m_sFileDir;\n\n\t\t\t\tbool bOpen = m_pWorker->OpenFile(m_sX2tPath, m_sFileDir, GetScript(), sCachePath, &oParams);\n\t\t\t\tif (!bOpen)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tbool ExecuteCommand(const std::wstring& command, CDocBuilderValue* retValue = NULL)\n\t\t{\n\t\t\tif (command.length() < 7 && !retValue) // minimum command (!!!)\n\t\t\t\treturn true;\n\n\t\t\tInit();\n\n\t\t\tif (!CheckWorker())\n\t\t\t\treturn false;\n\n\t\t\treturn m_pWorker->ExecuteCommand(command, retValue);\n\t\t}\n\n\t\tCDocBuilderContext GetContext()\n\t\t{\n\t\t\tCDocBuilderContext ctx;\n\n\t\t\tif (!CheckWorker())\n\t\t\t\treturn ctx;\n\n\t\t\tctx.m_internal->m_context = m_pWorker->m_context;\n\t\t\tctx.m_internal->m_context_data = &m_pWorker->m_oContextData;\n\t\t\treturn ctx;\n\t\t}\n\n\t\tstd::string GetScript()\n\t\t{\n\t\t\tstd::vector<std::wstring>* arSdkFiles = NULL;\n\n\t\t\tswitch (m_nFileType)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arDoctSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arPpttSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arXlstSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tstd::string strScript = \"\";\n\t\t\tfor (size_t i = 0; i < m_arrFiles.size(); ++i)\n\t\t\t{\n\t\t\t\tstrScript += ReadScriptFile(m_arrFiles[i]);\n\t\t\t\tstrScript += \"\\n\\n\";\n\t\t\t}\n\n\t\t\tif (NULL != arSdkFiles)\n\t\t\t{\n\t\t\t\tfor (const std::wstring& i : *arSdkFiles)\n\t\t\t\t{\n\t\t\t\t\tstrScript += ReadScriptFile(i);\n\t\t\t\t\tstrScript += \"\\n\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m_nFileType == 2)\n\t\t\t\tstrScript += \"\\n$.ready();\";\n\n\t\t\treturn strScript;\n\t\t}\n\n\t\tstd::wstring GetScriptCache()\n\t\t{\n\t\t\tstd::vector<std::wstring>* arSdkFiles = NULL;\n\t\t\tswitch (m_nFileType)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arDoctSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arPpttSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tarSdkFiles = &m_arXlstSDK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn L\"\";\n\t\t\t}\n\n\t\t\tif (0 < arSdkFiles->size())\n\t\t\t{\n\t\t\t\treturn NSFile::GetDirectoryName(*arSdkFiles->begin()) + L\"/sdk-all.cache\";\n\t\t\t}\n\t\t\treturn L\"\";\n\t\t}\n\n\t\tstd::string ReadScriptFile(const std::wstring& strFile)\n\t\t{\n\t\t\tNSFile::CFileBinary oFile;\n\n\t\t\tif (!oFile.OpenFile(strFile))\n\t\t\t\treturn \"\";\n\n\t\t\tint nSize = (int)oFile.GetFileSize();\n\t\t\tif (nSize < 3)\n\t\t\t\treturn \"\";\n\n\t\t\tBYTE* pData = new BYTE[nSize];\n\t\t\tDWORD dwReadSize = 0;\n\t\t\toFile.ReadFile(pData, (DWORD)nSize, dwReadSize);\n\n\t\t\tint nOffset = 0;\n\t\t\tif (pData[0] == 0xEF && pData[1] == 0xBB && pData[2] == 0xBF)\n\t\t\t{\n\t\t\t\tnOffset = 3;\n\t\t\t}\n\n\t\t\tstd::string sReturn((char*)(pData + nOffset), nSize - nOffset);\n\n\t\t\tRELEASEARRAYOBJECTS(pData);\n\t\t\treturn sReturn;\n\t\t}\n\n\t\tvoid WriteData(const wchar_t* path, const wchar_t* value, const bool& append)\n\t\t{\n\t\t\tstd::wstring sValue(value);\n\t\t\tstd::string sValueA = U_TO_UTF8(sValue);\n\t\t\tNSStringUtils::string_replaceA(sValueA, \"%\", \"%%\");\n\n\t\t\tstd::wstring _sFile(path);\n\t\t\tstd::wstring sFile = GetSaveFilePath(_sFile);\n\n\t\t\tif (!append && NSFile::CFileBinary::Exists(sFile))\n\t\t\t\tNSFile::CFileBinary::Remove(sFile);\n\n\t\t\tNSFile::CFileBinary oFile;\n\t\t\tFILE* pFile = oFile.OpenFileNative(sFile, append ? L\"a+\" : L\"a\");\n\t\t\tif (pFile)\n\t\t\t{\n\t\t\t\tfprintf(pFile, sValueA.c_str());\n\t\t\t\tfclose(pFile);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#endif // DOC_BUILDER_PRIVATE\n", "#include \"../NativeControlEmbed.h\"\n#include \"../../js_internal/jsc/jsc_base.h\"\n\n@protocol IJSCNativeControl <JSExport>\n-(JSValue*) GetFilePath;\n-(JSValue*) SetFilePath : (JSValue*)path;\n-(JSValue*) GetFileId;\n-(JSValue*) SetFileId : (JSValue*)fileid;\n-(JSValue*) GetFileBinary : (JSValue*)file;\n-(JSValue*) GetFontBinary : (JSValue*)file;\n-(JSValue*) GetFontsDirectory;\n-(JSValue*) GetFileString : (JSValue*)file;\n-(JSValue*) GetEditorType;\n-(JSValue*) CheckNextChange;\n-(JSValue*) GetCountChanges;\n-(JSValue*) GetChangesFile : (JSValue*)index;\n//-(JSValue*) Save_AllocNative : (JSValue*)len;\n//-(JSValue*) Save_ReAllocNative : (JSValue*)pos : (JSValue*)len;\n-(JSValue*) Save_End : (JSValue*)pos : (JSValue*)len;\n-(JSValue*) AddImageInChanges : (JSValue*)img;\n-(JSValue*) ConsoleLog : (JSValue*)message;\n-(JSValue*) SaveChanges : (JSValue*)param : (JSValue*)delete_index : (JSValue*)count;\n-(JSValue*) ZipOpen : (JSValue*)name;\n-(JSValue*) ZipOpenBase64 : (JSValue*)name;\n-(JSValue*) ZipFileAsString : (JSValue*)name;\n-(JSValue*) ZipFileAsBinary : (JSValue*)name;\n-(JSValue*) ZipClose;\n-(JSValue*) GetImageUrl : (JSValue*)url;\n-(JSValue*) GetImagesPath;\n-(JSValue*) GetImageOriginalSize : (JSValue*)url;\n\n@end\n\n@interface CJSCNativeControl : NSObject<IJSCNativeControl, JSEmbedObjectProtocol>\n{\n@public\n    CNativeControlEmbed* m_internal;\n}\n@end\n\n@implementation CJSCNativeControl\n\nEMBED_OBJECT_WRAPPER_METHODS(CNativeControlEmbed)\n\nFUNCTION_WRAPPER_JS(GetFilePath, GetFilePath)\nFUNCTION_WRAPPER_JS_1(SetFilePath, SetFilePath)\nFUNCTION_WRAPPER_JS(GetFileId, GetFileId)\nFUNCTION_WRAPPER_JS_1(SetFileId, SetFileId)\nFUNCTION_WRAPPER_JS_1(GetFileBinary, GetFileBinary)\nFUNCTION_WRAPPER_JS_1(GetFontBinary, GetFontBinary);\nFUNCTION_WRAPPER_JS(GetFontsDirectory, GetFontsDirectory)\nFUNCTION_WRAPPER_JS_1(GetFileString, GetFileString)\nFUNCTION_WRAPPER_JS(GetEditorType, GetEditorType)\nFUNCTION_WRAPPER_JS(CheckNextChange, CheckNextChange)\nFUNCTION_WRAPPER_JS(GetCountChanges, GetCountChanges)\nFUNCTION_WRAPPER_JS_1(GetChangesFile, GetChangesFile)\n//FUNCTION_WRAPPER_JS_1(Save_AllocNative, Save_AllocNative)\n//FUNCTION_WRAPPER_JS_2(Save_ReAllocNative, Save_ReAllocNative)\nFUNCTION_WRAPPER_JS_2(Save_End, Save_End)\nFUNCTION_WRAPPER_JS_1(AddImageInChanges, AddImageInChanges)\nFUNCTION_WRAPPER_JS_1(ConsoleLog, ConsoleLog)\nFUNCTION_WRAPPER_JS_3(SaveChanges, SaveChanges)\nFUNCTION_WRAPPER_JS_1(ZipOpen, zipOpenFile)\nFUNCTION_WRAPPER_JS_1(ZipOpenBase64, zipOpenFileBase64)\nFUNCTION_WRAPPER_JS_1(ZipFileAsString, zipGetFileAsString)\nFUNCTION_WRAPPER_JS_1(ZipFileAsBinary, zipGetFileAsBinary)\nFUNCTION_WRAPPER_JS(ZipClose, zipCloseFile);\nFUNCTION_WRAPPER_JS_1(GetImageUrl, GetImageUrl);\nFUNCTION_WRAPPER_JS(GetImagesPath, GetImagesPath)\nFUNCTION_WRAPPER_JS_1(GetImageOriginalSize, GetImageOriginalSize);\n\n@end\n\nvoid CNativeControlEmbed::CreateObjectInContext(const std::string &name, JSSmart<CJSContext> context)\n{\n    context->m_internal->context[[NSString stringWithAString:name]] = ^(){\n        return [[CJSCNativeControl alloc] init];\n    };\n}\nvoid CNativeControlEmbed::CreateObjectBuilderInContext(const std::string &name, JSSmart<CJSContext> context)\n{\n    context->m_internal->context[[NSString stringWithAString:name]] = ^(){\n        return [[CJSCNativeControl alloc] init];\n    };\n}\n", "#include \"../NativeControlEmbed.h\"\n#include \"../../js_internal/v8/v8_base.h\"\n\nnamespace NSNativeControl\n{\n#define CURRENTWRAPPER CNativeControlEmbed\n\n\tFUNCTION_WRAPPER_V8(_GetFilePath, GetFilePath)\n\tFUNCTION_WRAPPER_V8_1(_SetFilePath, SetFilePath)\n\tFUNCTION_WRAPPER_V8(_GetFileId, GetFileId)\n\tFUNCTION_WRAPPER_V8_1(_SetFileId, SetFileId)\n\tFUNCTION_WRAPPER_V8_1(_GetFileArrayBuffer, GetFileBinary)\n\tFUNCTION_WRAPPER_V8_1(_GetFontArrayBuffer, GetFontBinary)\n\tFUNCTION_WRAPPER_V8(_GetFontsDirectory, GetFontsDirectory)\n\tFUNCTION_WRAPPER_V8_1(_GetFileString, GetFileString)\n\tFUNCTION_WRAPPER_V8(_GetEditorType, GetEditorType)\n\tFUNCTION_WRAPPER_V8(_CheckNextChange, CheckNextChange)\n\tFUNCTION_WRAPPER_V8(_GetChangesCount, GetCountChanges)\n\tFUNCTION_WRAPPER_V8_1(_GetChangesFile, GetChangesFile)\n\tFUNCTION_WRAPPER_V8_1(_Save_AllocNative, Save_AllocNative)\n\tFUNCTION_WRAPPER_V8_2(_Save_ReAllocNative, Save_ReAllocNative)\n\tFUNCTION_WRAPPER_V8_2(_Save_End, Save_End)\n\tFUNCTION_WRAPPER_V8_1(_AddImageInChanges, AddImageInChanges)\n\tFUNCTION_WRAPPER_V8_1(_ConsoleLog, ConsoleLog)\n\tFUNCTION_WRAPPER_V8_3(_SaveChanges, SaveChanges)\n\tFUNCTION_WRAPPER_V8_1(_zipOpenFile, zipOpenFile)\n\tFUNCTION_WRAPPER_V8_1(_zipOpenFileBase64, zipOpenFileBase64)\n\tFUNCTION_WRAPPER_V8_1(_zipGetFileAsString, zipGetFileAsString)\n\tFUNCTION_WRAPPER_V8_1(_zipGetFileAsBinary, zipGetFileAsBinary)\n\tFUNCTION_WRAPPER_V8(_zipCloseFile, zipCloseFile)\n\tFUNCTION_WRAPPER_V8_1(_GetImageUrl, GetImageUrl)\n\tFUNCTION_WRAPPER_V8_1(_GetImageOriginalSize, GetImageOriginalSize)\n\tFUNCTION_WRAPPER_V8(_GetImagesPath, GetImagesPath)\n\n\tv8::Handle<v8::ObjectTemplate> CreateNativeControlTemplate(v8::Isolate* isolate)\n\t{\n\t\tv8::EscapableHandleScope handle_scope(isolate);\n\n\t\tv8::Local<v8::ObjectTemplate> result = v8::ObjectTemplate::New(V8IsolateOneArg);\n\t\tresult->SetInternalFieldCount(1);\n\n\t\tNSV8Objects::Template_Set(result, \"SetFilePath\",        _SetFilePath);\n\t\tNSV8Objects::Template_Set(result, \"GetFilePath\",        _GetFilePath);\n\t\tNSV8Objects::Template_Set(result, \"SetFileId\",          _SetFileId);\n\t\tNSV8Objects::Template_Set(result, \"GetFileId\",          _GetFileId);\n\t\tNSV8Objects::Template_Set(result, \"GetFileBinary\",      _GetFileArrayBuffer);\n\t\tNSV8Objects::Template_Set(result, \"GetFontBinary\",      _GetFontArrayBuffer);\n\t\tNSV8Objects::Template_Set(result, \"GetFontsDirectory\",  _GetFontsDirectory);\n\t\tNSV8Objects::Template_Set(result, \"GetFileString\",      _GetFileString);\n\t\tNSV8Objects::Template_Set(result, \"GetEditorType\",      _GetEditorType);\n\t\tNSV8Objects::Template_Set(result, \"CheckNextChange\",    _CheckNextChange);\n\t\tNSV8Objects::Template_Set(result, \"GetCountChanges\",    _GetChangesCount);\n\t\tNSV8Objects::Template_Set(result, \"GetChangesFile\",     _GetChangesFile);\n\t\t//NSV8Objects::Template_Set(result, \"Save_AllocNative\",   _Save_AllocNative);\n\t\t//NSV8Objects::Template_Set(result, \"Save_ReAllocNative\", _Save_ReAllocNative);\n\t\tNSV8Objects::Template_Set(result, \"Save_End\",           _Save_End);\n\t\tNSV8Objects::Template_Set(result, \"AddImageInChanges\",  _AddImageInChanges);\n\t\tNSV8Objects::Template_Set(result, \"ConsoleLog\",         _ConsoleLog);\n\t\tNSV8Objects::Template_Set(result, \"SaveChanges\",        _SaveChanges);\n\t\tNSV8Objects::Template_Set(result, \"ZipOpen\",            _zipOpenFile);\n\t\tNSV8Objects::Template_Set(result, \"ZipOpenBase64\",      _zipOpenFileBase64);\n\t\tNSV8Objects::Template_Set(result, \"ZipFileAsString\",    _zipGetFileAsString);\n\t\tNSV8Objects::Template_Set(result, \"ZipFileAsBinary\",    _zipGetFileAsBinary);\n\t\tNSV8Objects::Template_Set(result, \"ZipClose\",           _zipCloseFile);\n\t\tNSV8Objects::Template_Set(result, \"getImageUrl\",        _GetImageUrl);\n\t\tNSV8Objects::Template_Set(result, \"getImagesDirectory\", _GetImagesPath);\n\t\tNSV8Objects::Template_Set(result, \"GetImageOriginalSize\", _GetImageOriginalSize);\n\n\t\treturn handle_scope.Escape(result);\n\t}\n\n\t// \u0411\u0435\u0437 SaveChanges\n\tv8::Handle<v8::ObjectTemplate> CreateNativeControlTemplateBuilder(v8::Isolate* isolate)\n\t{\n\t\tv8::EscapableHandleScope handle_scope(isolate);\n\n\t\tv8::Local<v8::ObjectTemplate> result = v8::ObjectTemplate::New(V8IsolateOneArg);\n\t\tresult->SetInternalFieldCount(1);\n\n\t\tNSV8Objects::Template_Set(result, \"SetFilePath\",        _SetFilePath);\n\t\tNSV8Objects::Template_Set(result, \"GetFilePath\",        _GetFilePath);\n\t\tNSV8Objects::Template_Set(result, \"SetFileId\",          _SetFileId);\n\t\tNSV8Objects::Template_Set(result, \"GetFileId\",          _GetFileId);\n\t\tNSV8Objects::Template_Set(result, \"GetFileBinary\",      _GetFileArrayBuffer);\n\t\tNSV8Objects::Template_Set(result, \"GetFontBinary\",      _GetFontArrayBuffer);\n\t\tNSV8Objects::Template_Set(result, \"GetFontsDirectory\",  _GetFontsDirectory);\n\t\tNSV8Objects::Template_Set(result, \"GetFileString\",      _GetFileString);\n\t\tNSV8Objects::Template_Set(result, \"GetEditorType\",      _GetEditorType);\n\t\tNSV8Objects::Template_Set(result, \"CheckNextChange\",    _CheckNextChange);\n\t\tNSV8Objects::Template_Set(result, \"GetCountChanges\",    _GetChangesCount);\n\t\tNSV8Objects::Template_Set(result, \"GetChangesFile\",     _GetChangesFile);\n\t\t//NSV8Objects::Template_Set(result, \"Save_AllocNative\",   _Save_AllocNative);\n\t\t//NSV8Objects::Template_Set(result, \"Save_ReAllocNative\", _Save_ReAllocNative);\n\t\tNSV8Objects::Template_Set(result, \"Save_End\",           _Save_End);\n\t\tNSV8Objects::Template_Set(result, \"AddImageInChanges\",  _AddImageInChanges);\n\t\tNSV8Objects::Template_Set(result, \"ConsoleLog\",         _ConsoleLog);\n\t\tNSV8Objects::Template_Set(result, \"ZipOpen\",            _zipOpenFile);\n\t\tNSV8Objects::Template_Set(result, \"ZipOpenBase64\",      _zipOpenFileBase64);\n\t\tNSV8Objects::Template_Set(result, \"ZipFileAsString\",    _zipGetFileAsString);\n\t\tNSV8Objects::Template_Set(result, \"ZipFileAsBinary\",    _zipGetFileAsBinary);\n\t\tNSV8Objects::Template_Set(result, \"ZipClose\",           _zipCloseFile);\n\t\tNSV8Objects::Template_Set(result, \"getImageUrl\",        _GetImageUrl);\n\t\tNSV8Objects::Template_Set(result, \"getImagesDirectory\", _GetImagesPath);\n\t\tNSV8Objects::Template_Set(result, \"GetImageOriginalSize\", _GetImageOriginalSize);\n\n\t\treturn handle_scope.Escape(result);\n\t}\n\n\tvoid CreateNativeObject(const v8::FunctionCallbackInfo<v8::Value>& args)\n\t{\n\t\tv8::Isolate* isolate = args.GetIsolate();\n\t\tv8::HandleScope scope(isolate);\n\n\t\tif (CIsolateAdditionalData::CheckSingletonType(isolate, CIsolateAdditionalData::iadtSingletonNative))\n\t\t{\n\t\t\targs.GetReturnValue().Set(v8::Undefined(isolate));\n\t\t\treturn;\n\t\t}\n\n\t\tv8::Handle<v8::ObjectTemplate> NativeObjectTemplate = CreateNativeControlTemplate(isolate);\n\t\tCNativeControlEmbed* pNativeObject = new CNativeControlEmbed();\n\n\t\tv8::Local<v8::Object> obj = NativeObjectTemplate->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();\n\t\tobj->SetInternalField(0, v8::External::New(CV8Worker::GetCurrent(), pNativeObject));\n\n\t\targs.GetReturnValue().Set(obj);\n\t}\n\n\t// \u0411\u0435\u0437 SaveChanges\n\tvoid CreateNativeObjectBuilder(const v8::FunctionCallbackInfo<v8::Value>& args)\n\t{\n\t\tv8::Isolate* isolate = args.GetIsolate();\n\t\tv8::HandleScope scope(isolate);\n\n\t\tif (CIsolateAdditionalData::CheckSingletonType(isolate, CIsolateAdditionalData::iadtSingletonNative))\n\t\t{\n\t\t\targs.GetReturnValue().Set(v8::Undefined(isolate));\n\t\t\treturn;\n\t\t}\n\n\t\tv8::Handle<v8::ObjectTemplate> NativeObjectTemplate = CreateNativeControlTemplateBuilder(isolate);\n\t\tCNativeControlEmbed* pNativeObject = new CNativeControlEmbed();\n\n\t\tv8::Local<v8::Object> obj = NativeObjectTemplate->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();\n\t\tobj->SetInternalField(0, v8::External::New(CV8Worker::GetCurrent(), pNativeObject));\n\n\t\targs.GetReturnValue().Set(obj);\n\t}\n}\n\nvoid CNativeControlEmbed::CreateObjectInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n\tv8::Isolate* current = CV8Worker::GetCurrent();\n\tcontext->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObject));\n}\n\nvoid CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n\tv8::Isolate* current = CV8Worker::GetCurrent();\n\tcontext->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}\n", "#include \"v8_base.h\"\n\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const char* str, const int& len)\n{\n\treturn v8::String::NewFromUtf8(i, str, kV8NormalString, len).ToLocalChecked();\n}\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const std::string& str)\n{\n\treturn v8::String::NewFromUtf8(i, str.c_str(), kV8NormalString, (int)str.length()).ToLocalChecked();\n}\n\nstd::wstring CV8Worker::m_sExternalDirectory = L\"\";\n\nnamespace NSJSBase\n{\n\tclass CCacheDataScript\n\t{\n\tprivate:\n\t\tBYTE* Data;\n\t\tint Length;\n\n\t\tstd::wstring Path;\n\n\tpublic:\n\t\tCCacheDataScript(const std::wstring& sPath)\n\t\t{\n\t\t\tData = NULL;\n\t\t\tLength = 0;\n\n\t\t\tPath = sPath;\n\n#ifndef V8_VERSION_89_PLUS\n\t\t\tif (!sPath.empty())\n\t\t\t{\n\t\t\t\tBYTE* _data = NULL;\n\t\t\t\tDWORD _data_length = 0;\n\t\t\t\tif (NSFile::CFileBinary::ReadAllBytes(sPath, &_data, _data_length))\n\t\t\t\t{\n\t\t\t\t\tData = _data;\n\t\t\t\t\tLength = (int)_data_length;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\t\t~CCacheDataScript()\n\t\t{\n\t\t\tRELEASEARRAYOBJECTS(Data);\n\t\t}\n\n#ifdef V8_VERSION_89_PLUS\n\t\tv8::Local<v8::Script> Compile(const v8::Local<v8::Context>& _context, const v8::Local<v8::String>& source)\n\t\t{\n\t\t\tv8::Local<v8::Script> script;\n\n\t\t\tif (Path.empty())\n\t\t\t{\n\t\t\t\t// no cache\n\t\t\t\tv8::ScriptCompiler::Source oSource(source);\n\t\t\t\tv8::MaybeLocal<v8::Script> sctiptMB = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kNoCompileOptions);\n\t\t\t\tif (!sctiptMB.IsEmpty())\n\t\t\t\t\tscript = sctiptMB.ToLocalChecked();\n\n\t\t\t\treturn script;\n\t\t\t}\n\n\t\t\tif (NSFile::CFileBinary::Exists(Path))\n\t\t\t{\n\t\t\t\t// load cache from file\n\t\t\t\tBYTE* _data = NULL;\n\t\t\t\tDWORD _data_length = 0;\n\t\t\t\tif (NSFile::CFileBinary::ReadAllBytes(Path, &_data, _data_length))\n\t\t\t\t{\n\t\t\t\t\tData = _data;\n\t\t\t\t\tLength = (int)_data_length;\n\t\t\t\t}\n\n\t\t\t\t// compile with cache\n\t\t\t\tv8::ScriptCompiler::CachedData* pCacheData = new v8::ScriptCompiler::CachedData(Data, Length);\n\t\t\t\tv8::ScriptCompiler::Source oSource(source, pCacheData);\n\n\t\t\t\tv8::MaybeLocal<v8::Script> sctiptMB = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kConsumeCodeCache);\n\t\t\t\tif (!sctiptMB.IsEmpty())\n\t\t\t\t\tscript = sctiptMB.ToLocalChecked();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv8::ScriptCompiler::CachedData* pCacheData = nullptr;\n\n\t\t\t\t// save cache to file\n\t\t\t\tNSFile::CFileBinary oFileTest;\n\t\t\t\tif (oFileTest.CreateFileW(Path))\n\t\t\t\t{\n\t\t\t\t\t// create cache data\n\t\t\t\t\tv8::ScriptCompiler::Source oSource(source);\n\t\t\t\t\tv8::Local<v8::Script> pScriptCache = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kNoCompileOptions).ToLocalChecked();\n\t\t\t\t\tpCacheData = v8::ScriptCompiler::CreateCodeCache(pScriptCache->GetUnboundScript());\n\n\t\t\t\t\tif (pCacheData)\n\t\t\t\t\t{\n\t\t\t\t\t\t// save cache to file\n\t\t\t\t\t\tNSFile::CFileBinary oFileTest;\n\t\t\t\t\t\tif (oFileTest.CreateFileW(Path))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toFileTest.WriteFile(pCacheData->data, (DWORD)pCacheData->length);\n\t\t\t\t\t\t\toFileTest.CloseFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// compile with/without(if pCacheData === NULL) cache data\n\t\t\t\tv8::ScriptCompiler::Source oSource2(source, pCacheData);\n\t\t\t\tv8::ScriptCompiler::CompileOptions compileOptions = (nullptr == pCacheData) ? v8::ScriptCompiler::kNoCompileOptions : v8::ScriptCompiler::kConsumeCodeCache;\n\n\t\t\t\tv8::MaybeLocal<v8::Script> sctiptMB = v8::ScriptCompiler::Compile(_context, &oSource2, compileOptions);\n\t\t\t\tif (!sctiptMB.IsEmpty())\n\t\t\t\t\tscript = sctiptMB.ToLocalChecked();\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n#else\n\t\tv8::Local<v8::Script> Compile(const v8::Local<v8::Context>& _context, const v8::Local<v8::String>& source)\n\t\t{\n\t\t\tv8::Local<v8::Script> script;\n\t\t\tif (NULL == Data)\n\t\t\t{\n\t\t\t\tv8::ScriptCompiler::Source oSource(source);\n\t\t\t\tscript = v8::ScriptCompiler::Compile(_context, &oSource, kV8ProduceCodeCache).ToLocalChecked();\n\n\t\t\t\tconst v8::ScriptCompiler::CachedData* _cachedData = oSource.GetCachedData();\n\t\t\t\tNSFile::CFileBinary oFileTest;\n\t\t\t\tif (_cachedData && oFileTest.CreateFileW(Path))\n\t\t\t\t{\n\t\t\t\t\toFileTest.WriteFile(_cachedData->data, (DWORD)_cachedData->length);\n\t\t\t\t\toFileTest.CloseFile();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv8::ScriptCompiler::CachedData* pCachedData = new v8::ScriptCompiler::CachedData(Data, Length);\n\t\t\t\tv8::ScriptCompiler::Source oSource(source, pCachedData);\n\t\t\t\tscript = v8::ScriptCompiler::Compile(_context, &oSource, v8::ScriptCompiler::kConsumeCodeCache).ToLocalChecked();\n\t\t\t}\n\t\t\treturn script;\n\t\t}\n#endif\n\n\t\tbool IsInit()\n\t\t{\n\t\t\treturn Data != NULL && Length > 0;\n\t\t}\n\t};\n\n\tclass CJSIsolateScopeV8 : public CJSIsolateScope\n\t{\n\tpublic:\n\t\tv8::Isolate::Scope  isolate_scope;\n\t\tv8::Locker          isolate_locker;\n\n\tpublic:\n\t\tCJSIsolateScopeV8(v8::Isolate* isolate) : CJSIsolateScope(),\n\t\t\tisolate_scope(isolate),\n\t\t\tisolate_locker(isolate)\n\t\t{\n\t\t}\n\t\tvirtual ~CJSIsolateScopeV8()\n\t\t{\n\t\t}\n\t};\n\n\tclass CJSContextScopeV8 : public CJSContextScope\n\t{\n\tpublic:\n\t\tv8::Context::Scope m_scope;\n\n\tpublic:\n\t\tCJSContextScopeV8(v8::Local<v8::Context> context) : m_scope(context)\n\t\t{\n\t\t}\n\t\tvirtual ~CJSContextScopeV8()\n\t\t{\n\t\t}\n\t};\n\n\tclass CJSLocalScopeV8 : public CJSLocalScope\n\t{\n\tpublic:\n\t\tv8::HandleScope m_scope;\n\n\tpublic:\n\t\tCJSLocalScopeV8() : m_scope(CV8Worker::GetCurrent())\n\t\t{\n\t\t}\n\t\tvirtual ~CJSLocalScopeV8()\n\t\t{\n\t\t}\n\t};\n\n\n\tCJSContext::CJSContext()\n\t{\n\t\tm_internal = new CJSContextPrivate();\n\t}\n\tCJSContext::~CJSContext()\n\t{\n\t\tRELEASEOBJECT(m_internal);\n\t}\n\n\tCJSTryCatch* CJSContext::GetExceptions()\n\t{\n\t\treturn new CV8TryCatch();\n\t}\n\n\tvoid CJSContext::Initialize()\n\t{\n\t\tm_internal->m_isolate = CV8Worker::getInitializer().CreateNew();\n\t}\n\tvoid CJSContext::Dispose()\n\t{\n#ifdef V8_INSPECTOR\n\t\tv8_debug::disposeInspector(m_internal->m_context);\n#endif\n\t\tunsigned int nEmbedDataCount = m_internal->m_isolate->GetNumberOfDataSlots();\n\t\tfor (unsigned int i = 0; i < nEmbedDataCount; ++i)\n\t\t{\n\t\t\tCIsolateAdditionalData* pAdditionData = (CIsolateAdditionalData*)m_internal->m_isolate->GetData(i);\n\t\t\tdelete pAdditionData;\n\t\t}\n\n\t\tm_internal->m_isolate->Dispose();\n\t\tm_internal->m_isolate = NULL;\n\t}\n\n\tvoid CJSContext::CreateContext()\n\t{\n\t\tm_internal->m_context = v8::Context::New(CV8Worker::GetCurrent(), NULL, m_internal->m_global);\n\t}\n\n\tvoid CJSContext::CreateGlobalForContext()\n\t{\n\t\tm_internal->m_global = v8::ObjectTemplate::New(CV8Worker::GetCurrent());\n\t}\n\n\tCJSObject* CJSContext::GetGlobal()\n\t{\n\t\tCJSObjectV8* ret = new CJSObjectV8();\n\t\tret->value = m_internal->m_context->Global();\n\t\treturn ret;\n\t}\n\n\tCJSIsolateScope* CJSContext::CreateIsolateScope()\n\t{\n\t\treturn new CJSIsolateScopeV8(m_internal->m_isolate);\n\t}\n\n\tCJSContextScope* CJSContext::CreateContextScope()\n\t{\n\t\tCJSContextScope* pScope = new CJSContextScopeV8(m_internal->m_context);\n\n\t\tJSSmart<CJSObject> global = GetCurrent()->GetGlobal();\n\t\tglobal->set(\"window\", global.GetPointer());\n\n\t\treturn pScope;\n\t}\n\n\tCJSLocalScope* CJSContext::CreateLocalScope()\n\t{\n\t\treturn new CJSLocalScopeV8();\n\t}\n\n\tCJSValue* CJSContext::createUndefined()\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->doUndefined();\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createNull()\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->doNull();\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createBool(const bool& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Boolean::New(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createInt(const int& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Integer::New(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createUInt(const unsigned int& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Integer::NewFromUnsigned(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createDouble(const double& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = v8::Number::New(CV8Worker::GetCurrent(), value);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createString(const char* value, const int& length)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = CreateV8String(CV8Worker::GetCurrent(), value, length);\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createString(const wchar_t* value, const int& length)\n\t{\n\t\tstd::string sUtf8 = NSFile::CUtf8Converter::GetUtf8StringFromUnicode2(value, (length != -1) ? (LONG)length : (LONG)wcslen(value));\n\t\treturn createString((const char*)sUtf8.c_str(), (int)sUtf8.length());\n\t}\n\n\tCJSValue* CJSContext::createString(const std::string& value)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n\t\t_value->value = CreateV8String(CV8Worker::GetCurrent(), value.c_str(), (int)value.length());\n\t\treturn _value;\n\t}\n\n\tCJSValue* CJSContext::createString(const std::wstring& value)\n\t{\n\t\tstd::string sReturn = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(value);\n\t\treturn createString(sReturn);\n\t}\n\n\tCJSObject* CJSContext::createObject()\n\t{\n\t\tCJSObjectV8* _value = new CJSObjectV8();\n\t\t_value->value = v8::Object::New(CV8Worker::GetCurrent());\n\t\treturn _value;\n\t}\n\n\tCJSArray* CJSContext::createArray(const int& count)\n\t{\n\t\tCJSArrayV8* _value = new CJSArrayV8();\n\t\t_value->value = v8::Array::New(CV8Worker::GetCurrent(), count);\n\t\t_value->m_count = count;\n\t\treturn _value;\n\t}\n\n\tCJSTypedArray* CJSContext::createUint8Array(BYTE* data, int count, const bool& isExternalize)\n\t{\n\t\tCJSTypedArrayV8* _value = new CJSTypedArrayV8(data, count, isExternalize);\n\t\treturn _value;\n\t}\n\n\tJSSmart<CJSValue> CJSContext::runScript(const std::string& script, JSSmart<CJSTryCatch> exception, const std::wstring& scriptPath)\n\t{\n#ifdef V8_INSPECTOR\n\t\tv8_debug::before(m_internal->m_context, CV8Worker::getInitializer()->getPlatform(), \"\");\n#endif\n\t\tLOGGER_START\n\n\t\tv8::Local<v8::String> _source = CreateV8String(CV8Worker::GetCurrent(), script.c_str());\n\t\tv8::Local<v8::Script> _script;\n\t\tif(!scriptPath.empty())\n\t\t{\n\t\t\tstd::wstring sCachePath = scriptPath.substr(0, scriptPath.rfind(L\".\")) + L\".cache\";\n\t\t\tCCacheDataScript oCachedScript(sCachePath);\n\t\t\t_script = oCachedScript.Compile(m_internal->m_context, _source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv8::MaybeLocal<v8::Script> _scriptRetValue = v8::Script::Compile(V8ContextFirstArg _source);\n\t\t\tif (!_scriptRetValue.IsEmpty())\n\t\t\t\t_script = _scriptRetValue.ToLocalChecked();\n\t\t}\n\n\t\tLOGGER_LAP(\"compile\")\n\n\t\tCJSValueV8* _return = new CJSValueV8();\n\n\t\tv8::MaybeLocal<v8::Value> retValue;\n\t\tif (exception.is_init())\n\t\t{\n\t\t\tif (!exception->Check())\n\t\t\t\tretValue = _script->Run(V8ContextOneArg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretValue = _script->Run(V8ContextOneArg);\n\t\t}\n\n\t\tif (!retValue.IsEmpty())\n\t\t\t_return->value = retValue.ToLocalChecked();\n\n\t\tLOGGER_LAP(\"run\")\n\n\t\t\t\treturn _return;\n\t}\n\n\tCJSContext* CJSContext::GetCurrent()\n\t{\n\t\tCJSContext* ret = new CJSContext();\n\t\tret->m_internal->m_isolate = CV8Worker::GetCurrent();\n\t\tret->m_internal->m_context = ret->m_internal->m_isolate->GetCurrentContext();\n\t\t// global???\n\t\treturn ret;\n\t}\n\n\tCJSValue* CJSContext::JSON_Parse(const char *sTmp)\n\t{\n\t\tCJSValueV8* _value = new CJSValueV8();\n#ifndef V8_OS_XP\n\t\tv8::MaybeLocal<v8::Value> retValue = v8::JSON::Parse(m_internal->m_context, CreateV8String(CV8Worker::GetCurrent(), sTmp));\n\t\tif (!retValue.IsEmpty())\n\t\t\t_value->value = retValue.ToLocalChecked();\n\t\telse\n\t\t\t_value->doUndefined();\n#else\n\t\t_value->value = v8::JSON::Parse(CreateV8String(CV8Worker::GetCurrent(), sTmp));\n#endif\n\t\treturn _value;\n\t}\n\n\tvoid CJSContext::MoveToThread(ASC_THREAD_ID* id)\n\t{\n\t\t// none\n\t}\n\n\tvoid CJSContext::ExternalInitialize(const std::wstring& sDirectory)\n\t{\n\t\tCV8Worker::m_sExternalDirectory = sDirectory;\n\t}\n\tvoid CJSContext::ExternalDispose()\n\t{\n\t\tCV8Worker::Dispose();\n\t}\n\tbool CJSContext::IsSupportNativeTypedArrays()\n\t{\n\t\treturn true;\n\t}\n\n\tunsigned char* NSAllocator::Alloc(const size_t& size)\n\t{\n\t\treturn (unsigned char*)CV8Worker::getInitializer().getAllocator()->AllocateUninitialized(size);\n\t}\n\tvoid NSAllocator::Free(unsigned char* data, const size_t& size)\n\t{\n\t\tCV8Worker::getInitializer().getAllocator()->Free(data, size);\n\t}\n}\n", "\ufeff#ifndef _BUILD_NATIVE_CONTROL_V8_BASE_H_\n#define _BUILD_NATIVE_CONTROL_V8_BASE_H_\n\n#ifdef V8_INSPECTOR\n#include \"inspector/inspector_interface.h\"\n#endif\n\n#include \"../js_base.h\"\n#include \"../js_logger.h\"\n#include <iostream>\n\n#ifdef __ANDROID__\n#ifndef DISABLE_MEMORY_LIMITATION\n#define DISABLE_MEMORY_LIMITATION\n#endif\n#endif\n\n#include \"v8.h\"\n#include \"libplatform/libplatform.h\"\n\n#ifndef DISABLE_MEMORY_LIMITATION\n#include \"src/base/sys-info.h\"\n#endif\n\n#ifdef V8_VERSION_89_PLUS\n#define kV8NormalString v8::NewStringType::kNormal\n#define kV8ProduceCodeCache v8::ScriptCompiler::kEagerCompile\n#define V8ContextFirstArg CV8Worker::GetCurrentContext(),\n#define V8ContextOneArg CV8Worker::GetCurrentContext()\n#define V8IsolateFirstArg CV8Worker::GetCurrent(),\n#define V8IsolateOneArg CV8Worker::GetCurrent()\n#define V8ToChecked ToChecked\n#else\n#define kV8NormalString v8::NewStringType::kNormal\n#define kV8ProduceCodeCache v8::ScriptCompiler::kProduceCodeCache\n#define V8ContextFirstArg CV8Worker::GetCurrentContext(),\n#define V8ContextOneArg CV8Worker::GetCurrentContext()\n#define V8IsolateFirstArg\n#define V8IsolateOneArg CV8Worker::GetCurrent()\n#ifdef V8_OS_XP\n#define V8ToChecked FromJust\n#else\n#define V8ToChecked ToChecked\n#endif\n#endif\n\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const char* str, const int& len = -1);\nv8::Local<v8::String> CreateV8String(v8::Isolate* i, const std::string& str);\n\n#ifdef __ANDROID__\n    #include <JniLogUtils.h>\n#endif\n\n#ifdef V8_OS_XP\nclass MallocArrayBufferAllocator : public v8::ArrayBuffer::Allocator\n{\npublic:\n    virtual void* Allocate(size_t length)\n    {\n        void* ret = malloc(length);\n        memset(ret, 0, length);\n        return ret;\n    }\n    virtual void* AllocateUninitialized(size_t length)\n    {\n        return malloc(length);\n    }\n    virtual void Free(void* data, size_t length)\n    {\n        free(data);\n    }\n};\n#endif\n\nclass CIsolateAdditionalData\n{\npublic:\n\tenum IsolateAdditionlDataType {\n\t\tiadtSingletonNative = 0,\n\t\tiadtUndefined = 255\n\t};\n\n\tIsolateAdditionlDataType m_eType;\npublic:\n\tCIsolateAdditionalData(const IsolateAdditionlDataType& type = iadtUndefined) { m_eType = type; }\n\tvirtual ~CIsolateAdditionalData() {}\n\n\tstatic bool CheckSingletonType(v8::Isolate* isolate, const IsolateAdditionlDataType& type, const bool& isAdd = true)\n\t{\n\t\tunsigned int nCount = isolate->GetNumberOfDataSlots();\n\t\tfor (unsigned int i = 0; i < nCount; ++i)\n\t\t{\n\t\t\tCIsolateAdditionalData* pData = (CIsolateAdditionalData*)isolate->GetData(i);\n\t\t\tif (pData->m_eType == type)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif (isAdd)\n\t\t{\n\t\t\tisolate->SetData(nCount, (void*)(new CIsolateAdditionalData(type)));\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nclass CV8Initializer\n{\nprivate:\n#ifdef V8_VERSION_89_PLUS\n    std::unique_ptr<v8::Platform> m_platform;\n#else\n    v8::Platform* m_platform;\n#endif\n    v8::ArrayBuffer::Allocator* m_pAllocator;\n\npublic:\n    v8::Platform* getPlatform()\n    {\n#ifdef V8_VERSION_89_PLUS\n        return m_platform.get();\n#else\n        return m_platform;\n#endif\n    }\n    CV8Initializer(const std::wstring& sDirectory = L\"\")\n    {\n        std::wstring sPrW = sDirectory.empty() ? NSFile::GetProcessPath() : sDirectory;\n        std::string sPrA = U_TO_UTF8(sPrW);\n\n        m_pAllocator = NULL;\n\n    #ifndef V8_OS_XP\n        v8::V8::InitializeICUDefaultLocation(sPrA.c_str());\n        v8::V8::InitializeExternalStartupData(sPrA.c_str());\n        #ifdef V8_VERSION_89_PLUS\n        m_platform = v8::platform::NewDefaultPlatform();\n        v8::V8::InitializePlatform(m_platform.get());\n        #else\n        m_platform = v8::platform::CreateDefaultPlatform();\n        v8::V8::InitializePlatform(m_platform);\n        #endif\n        v8::V8::Initialize();\n    #else\n        m_platform = v8::platform::CreateDefaultPlatform();\n        v8::V8::InitializePlatform(m_platform);\n        v8::V8::Initialize();\n        v8::V8::InitializeICU();\n    #endif\n    }\n\n    void Dispose()\n    {\n#ifndef V8_VERSION_89_PLUS\n        if (!m_platform)\n            return;\n#else\n        if (!m_platform.get())\n            return;\n#endif\n\n        v8::V8::Dispose();\n        v8::V8::ShutdownPlatform();\n        if (m_pAllocator)\n            delete m_pAllocator;\n\n#ifndef V8_VERSION_89_PLUS\n        delete m_platform;\n        m_platform = NULL;\n#else\n        m_platform.reset();\n#endif\n    }\n\n    ~CV8Initializer()\n    {\n        Dispose();\n    }\n\n    v8::ArrayBuffer::Allocator* getAllocator()\n    {\n        return m_pAllocator;\n    }\n\n    v8::Isolate* CreateNew()\n    {\n        v8::Isolate::CreateParams create_params;\n    #ifndef V8_OS_XP\n        m_pAllocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n    #else\n        m_pAllocator = new MallocArrayBufferAllocator();\n    #endif\n        create_params.array_buffer_allocator = m_pAllocator;\n\n    #ifndef DISABLE_MEMORY_LIMITATION\n        int64_t nMaxVirtualMemory = v8::base::SysInfo::AmountOfVirtualMemory();\n        if (0 == nMaxVirtualMemory)\n            nMaxVirtualMemory = 4000000000; // 4Gb\n\n        create_params.constraints.ConfigureDefaults(\n              v8::base::SysInfo::AmountOfPhysicalMemory(),\n              nMaxVirtualMemory);\n    #endif\n\n        return v8::Isolate::New(create_params);\n    }\n};\n\nclass CV8Worker\n{\npublic:\n    CV8Worker() {}\n    ~CV8Worker() {}\n\n    static std::wstring m_sExternalDirectory;\n\n    static CV8Initializer& getInitializer()\n    {\n        static CV8Initializer oInitializer(m_sExternalDirectory);\n        return oInitializer;\n    }\n\n    static void Dispose()\n    {\n        getInitializer().Dispose();\n    }\n\n    static v8::Isolate* GetCurrent()\n    {\n        return v8::Isolate::GetCurrent();\n    }\n    static v8::Local<v8::Context> GetCurrentContext()\n    {\n        return v8::Isolate::GetCurrent()->GetCurrentContext();\n    }\n};\n\nnamespace NSJSBase\n{\n\n    template<typename V, typename B>\n    class CJSValueV8Template : public B\n    {\n    public:\n        v8::Local<V> value;\n\n        CJSValueV8Template()\n        {\n        }\n\n        CJSValueV8Template(const v8::Local<V>& _value)\n        {\n            value = _value;\n        }\n\n    public:\n\n        virtual ~CJSValueV8Template()\n        {\n            value.Clear();\n        }\n\n        virtual bool isUndefined()\n        {\n            return value.IsEmpty() ? false : value->IsUndefined();\n        }\n        virtual bool isNull()\n        {\n            return value.IsEmpty() ? false : value->IsNull();\n        }\n        virtual bool isBool()\n        {\n            return value.IsEmpty() ? false : value->IsBoolean();\n        }\n        virtual bool isNumber()\n        {\n            return value.IsEmpty() ? false : value->IsNumber();\n        }\n        virtual bool isString()\n        {\n            return value.IsEmpty() ? false : value->IsString();\n        }\n        virtual bool isArray()\n        {\n            return value.IsEmpty() ? false : value->IsArray();\n        }\n        virtual bool isTypedArray()\n        {\n            return value.IsEmpty() ? false : value->IsTypedArray();\n        }\n        virtual bool isObject()\n        {\n            return value.IsEmpty() ? false : value->IsObject();\n        }\n        virtual bool isFunction()\n        {\n            return value.IsEmpty() ? false : value->IsFunction();\n        }\n        virtual bool isEmpty()\n        {\n            return value.IsEmpty();\n        }\n\n        virtual void doUndefined()\n        {            \n        }\n\n        virtual void doNull()\n        {\n        }\n\n        virtual bool toBool()\n        {\n            return false;\n        }\n\n        virtual int toInt32()\n        {\n            return 0;\n        }\n\n        virtual unsigned int toUInt32()\n        {\n            return 0;\n        }\n\n        virtual double toDouble()\n        {\n            return 0;\n        }\n\n        virtual std::string toStringA()\n        {\n            return \"\";\n        }\n\n        virtual std::wstring toStringW()\n        {\n            return L\"\";\n        }\n\n        virtual CJSObject* toObject();\n        virtual CJSArray* toArray();\n        virtual CJSTypedArray* toTypedArray();\n        virtual CJSFunction* toFunction();\n    };\n\n    class CJSValueV8TemplatePrimitive : public CJSValueV8Template<v8::Value, CJSValue>\n    {\n    public:\n        CJSValueV8TemplatePrimitive()\n        {\n        }\n        CJSValueV8TemplatePrimitive(const v8::Local<v8::Value>& _value) : CJSValueV8Template<v8::Value, CJSValue>(_value)\n        {\n        }\n\n        virtual ~CJSValueV8TemplatePrimitive()\n        {\n            value.Clear();\n        }\n\n        virtual void doUndefined()\n        {\n            value = v8::Undefined(CV8Worker::GetCurrent());\n        }\n\n        virtual void doNull()\n        {\n            value = v8::Null(CV8Worker::GetCurrent());\n        }\n\n        virtual bool toBool()\n        {\n#ifdef V8_VERSION_89_PLUS\n            return value.IsEmpty() ? false : value->BooleanValue(V8IsolateOneArg);\n#else\n            return value.IsEmpty() ? false : value->BooleanValue(V8ContextOneArg).V8ToChecked();\n#endif\n        }\n\n        virtual int toInt32()\n        {\n            return value.IsEmpty() ? 0 : value->Int32Value(V8ContextOneArg).V8ToChecked();\n        }\n\n        virtual unsigned int toUInt32()\n        {\n            return value.IsEmpty() ? 0 : value->Uint32Value(V8ContextOneArg).V8ToChecked();\n        }\n\n        virtual double toDouble()\n        {\n            return value.IsEmpty() ? 0 : value->NumberValue(V8ContextOneArg).V8ToChecked();\n        }\n\n        virtual std::string toStringA()\n        {\n            if (value.IsEmpty())\n                return \"\";\n\n            v8::String::Utf8Value data(V8IsolateFirstArg value);\n            if (NULL == *data)\n                return \"\";\n\n            return std::string((char*)(*data), data.length());\n        }\n\n        virtual std::wstring toStringW()\n        {\n            if (value.IsEmpty())\n                return L\"\";\n\n            v8::String::Utf8Value data(V8IsolateFirstArg value);\n            if (NULL == *data)\n                return L\"\";\n\n            return NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)(*data), data.length());\n        }\n    };\n\n    typedef CJSValueV8TemplatePrimitive CJSValueV8;\n\n    class CJSObjectV8 : public CJSValueV8Template<v8::Object, CJSObject>\n    {\n    public:\n        CJSObjectV8()\n        {\n        }\n\n        virtual ~CJSObjectV8()\n        {\n            value.Clear();\n        }\n\n        virtual CJSValue* get(const char* name)\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            _value->value = value->Get(V8ContextFirstArg _name).ToLocalChecked();\n            return _value;\n        }\n\n        virtual void set(const char* name, CJSValue* value_param)\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(value_param);\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            value->Set(V8ContextFirstArg _name, _value->value);\n        }\n\n        virtual void set(const char* name, const int& _value)\n        {\n            v8::Isolate* isolate = CV8Worker::GetCurrent();\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            value->Set(V8ContextFirstArg _name, v8::Integer::New(isolate, _value));\n        }\n\n        virtual void set(const char* name, const double& _value)\n        {\n            v8::Isolate* isolate = CV8Worker::GetCurrent();\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            value->Set(V8ContextFirstArg _name, v8::Number::New(isolate, _value));\n        }\n\n        virtual CJSEmbedObject* getNative()\n        {\n            v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(value->GetInternalField(0));\n            return (CJSEmbedObject*)field->Value();\n        }\n\n        virtual JSSmart<CJSValue> call_func(const char* name, const int argc = 0, JSSmart<CJSValue> argv[] = NULL)\n        {\n#ifdef V8_INSPECTOR\n            v8_debug::before(V8ContextFirstArg CV8Worker::getInitializer()->getPlatform(), \"\");\n#endif\n            LOGGER_START\n\n            v8::Local<v8::String> _name = CreateV8String(CV8Worker::GetCurrent(), name);\n            v8::Handle<v8::Value> _func = value->Get(V8ContextFirstArg _name).ToLocalChecked();\n\n            CJSValueV8* _return = new CJSValueV8();\n            if (_func->IsFunction())\n            {\n                v8::Handle<v8::Function> _funcN = v8::Handle<v8::Function>::Cast(_func);\n\n                if (0 == argc)\n                {\n                    v8::MaybeLocal<v8::Value> retValue = _funcN->Call(V8ContextFirstArg value, 0, NULL);\n                    if (!retValue.IsEmpty())\n                        _return->value = retValue.ToLocalChecked();\n                }\n                else\n                {\n                    v8::Local<v8::Value>* args = new v8::Local<v8::Value>[argc];\n                    for (int i = 0; i < argc; ++i)\n                    {\n                        CJSValueV8* _value_arg = static_cast<CJSValueV8*>(argv[i].operator ->());\n                        args[i] = _value_arg->value;\n                    }\n                    v8::MaybeLocal<v8::Value> retValue = _funcN->Call(V8ContextFirstArg value, argc, args);\n                    if (!retValue.IsEmpty())\n                        _return->value = retValue.ToLocalChecked();\n                    RELEASEARRAYOBJECTS(args);\n                }\n            }\n\n            LOGGER_LAP_NAME(name)\n\n            JSSmart<CJSValue> _ret = _return;\n            return _ret;\n        }\n\n        virtual JSSmart<CJSValue> toValue()\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value;\n            return _value;\n        }\n    };\n\n    class CJSArrayV8 : public CJSValueV8Template<v8::Array, CJSArray>\n    {\n    public:\n        int m_count;\n    public:\n        CJSArrayV8()\n        {\n            m_count = 0;\n        }\n        virtual ~CJSArrayV8()\n        {\n            value.Clear();\n        }\n\n        virtual int getCount()\n        {\n            return value->Length();\n        }\n\n        virtual JSSmart<CJSValue> get(const int& index)\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value->Get(V8ContextFirstArg index).ToLocalChecked();\n            return _value;\n        }\n\n        virtual void set(const int& index, CJSValue* value_param)\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(value_param);\n            value->Set(V8ContextFirstArg index, _value->value);\n        }\n\n        virtual void add(CJSValue* value_param)\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(value_param);\n            value->Set(V8ContextFirstArg getCount(), _value->value);\n        }\n\n        virtual void set(const int& index, const bool& _value)\n        {\n            value->Set(V8ContextFirstArg index, v8::Boolean::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void set(const int& index, const int& _value)\n        {\n            value->Set(V8ContextFirstArg index, v8::Integer::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void set(const int& index, const double& _value)\n        {\n            value->Set(V8ContextFirstArg index, v8::Number::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_null()\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Null(CV8Worker::GetCurrent()));\n        }\n\n        virtual void add_undefined()\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Undefined(CV8Worker::GetCurrent()));\n        }\n\n        virtual void add_bool(const bool& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Boolean::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_byte(const BYTE& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Integer::New(CV8Worker::GetCurrent(), (int)_value));\n        }\n\n        virtual void add_int(const int& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Integer::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_double(const double& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, v8::Number::New(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_stringa(const std::string& _value)\n        {\n            value->Set(V8ContextFirstArg m_count++, CreateV8String(CV8Worker::GetCurrent(), _value));\n        }\n\n        virtual void add_string(const std::wstring& _value)\n        {\n            std::string sReturn = NSFile::CUtf8Converter::GetUtf8StringFromUnicode(_value);\n            add_stringa(sReturn);\n        }\n\n        virtual JSSmart<CJSValue> toValue()\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value;\n            return _value;\n        }\n    };\n\n    class CJSTypedArrayV8 : public CJSValueV8Template<v8::Uint8Array, CJSTypedArray>\n    {\n    public:\n        CJSTypedArrayV8(BYTE* data = NULL, int count = 0, const bool& isExternalize = true)\n        {\n            if (0 < count)\n            {\n                v8::Local<v8::ArrayBuffer> _buffer = v8::ArrayBuffer::New(CV8Worker::GetCurrent(), (void*)data, (size_t)count,\n                        isExternalize ? v8::ArrayBufferCreationMode::kExternalized : v8::ArrayBufferCreationMode::kInternalized);\n                value = v8::Uint8Array::New(_buffer, 0, (size_t)count);\n            }\n        }\n        virtual ~CJSTypedArrayV8()\n        {\n            value.Clear();\n        }\n\n        virtual int getCount()\n        {\n            return (int)value->ByteLength();\n        }\n\n        virtual CJSDataBuffer getData()\n        {\n            v8::ArrayBuffer::Contents contents = value->Buffer()->GetContents();\n            CJSDataBuffer buffer;\n            buffer.Data = (BYTE*)contents.Data();\n            buffer.Len = contents.ByteLength();\n            buffer.IsExternalize = false;\n            return buffer;\n        }\n\n        virtual JSSmart<CJSValue> toValue()\n        {\n            CJSValueV8* _value = new CJSValueV8();\n            _value->value = value;\n            return _value;\n        }\n    };\n\n    class CJSFunctionV8 : public CJSValueV8Template<v8::Function, CJSFunction>\n    {\n    public:\n        CJSFunctionV8()\n        {\n        }\n        virtual ~CJSFunctionV8()\n        {\n            value.Clear();\n        }\n\n        virtual CJSValue* Call(CJSValue* recv, int argc, JSSmart<CJSValue> argv[])\n        {\n            CJSValueV8* _value = static_cast<CJSValueV8*>(recv);\n            CJSValueV8* _return = new CJSValueV8();\n            if (0 == argc)\n            {\n                _return->value = value->Call(V8ContextFirstArg _value->value, 0, NULL).ToLocalChecked();\n            }\n            else\n            {\n                v8::Local<v8::Value>* args = new v8::Local<v8::Value>[argc];\n                for (int i = 0; i < argc; ++i)\n                {\n                    CJSValueV8* _value_arg = static_cast<CJSValueV8*>(argv[i].operator ->());\n                    args[i] = _value_arg->value;\n                }\n                _return->value = value->Call(V8ContextFirstArg _value->value, argc, args).ToLocalChecked();\n                RELEASEARRAYOBJECTS(args);\n            }\n            return _return;\n        }\n    };\n\n    template<typename V, typename B>\n    CJSObject* CJSValueV8Template<V, B>::toObject()\n    {\n        CJSObjectV8* _value = new CJSObjectV8();\n        _value->value = value->ToObject(V8ContextOneArg).ToLocalChecked();\n        return _value;\n    }\n\n    template<typename V, typename B>\n    CJSArray* CJSValueV8Template<V, B>::toArray()\n    {\n        CJSArrayV8* _value = new CJSArrayV8();\n        _value->value = v8::Local<v8::Array>::Cast(value);\n        return _value;\n    }\n\n    template<typename V, typename B>\n    CJSTypedArray* CJSValueV8Template<V, B>::toTypedArray()\n    {\n        CJSTypedArrayV8* _value = new CJSTypedArrayV8();\n        _value->value = v8::Local<v8::Uint8Array>::Cast(value);\n        return _value;\n    }\n\n    template<typename V, typename B>\n    CJSFunction* CJSValueV8Template<V, B>::toFunction()\n    {\n        CJSFunctionV8* _value = new CJSFunctionV8();\n        _value->value = v8::Local<v8::Function>::Cast(value);\n        return _value;\n    }\n}\n\nnamespace NSJSBase\n{\n    // TRY - CATCH\n    class CV8TryCatch : public CJSTryCatch\n    {\n    private:\n        v8::TryCatch try_catch;\n\n    public:\n        CV8TryCatch() : CJSTryCatch(), try_catch(V8IsolateOneArg)\n        {\n        }\n        virtual ~CV8TryCatch()\n        {\n        }\n\n    public:\n        virtual bool Check()\n        {\n            if (try_catch.HasCaught())\n            {\n                int nLineNumber             = try_catch.Message()->GetLineNumber(V8ContextOneArg).V8ToChecked();\n\n                JSSmart<CJSValueV8> _line = new CJSValueV8();\n                _line->value = try_catch.Message()->GetSourceLine(V8ContextOneArg).ToLocalChecked();\n\n                JSSmart<CJSValueV8> _exception = new CJSValueV8();\n                _exception->value = try_catch.Message()->Get();\n\n                std::string strCode        = _line->toStringA();\n                std::string strException   = _exception->toStringA();\n\n#if 1\n                v8::Local<v8::Value> stack_trace_string;\n                if (try_catch.StackTrace(V8ContextOneArg).ToLocal(&stack_trace_string) &&\n                    stack_trace_string->IsString() &&\n                    v8::Local<v8::String>::Cast(stack_trace_string)->Length() > 0)\n                {\n                    v8::String::Utf8Value data(V8IsolateFirstArg stack_trace_string);\n                    if (NULL != *data)\n                    {\n                        std::string sStack((char*)(*data), data.length());\n                        std::cerr << sStack << std::endl;\n                    }\n                }\n#endif\n\n#ifndef __ANDROID__\n                std::cerr << strException << std::endl;\n#else\n                LOGE(\"NSJSBase::CV8TryCatch::Check() - error:\");\n                LOGE(std::to_string(nLineNumber).c_str());\n                LOGE(strCode.c_str());\n                LOGE(strException.c_str());\n#endif\n                return true;\n            }\n            return false;\n        }\n    };\n}\n\nnamespace NSJSBase\n{\n    class CJSContextPrivate\n    {\n    public:\n        CV8Worker m_oWorker;\n        v8::Isolate* m_isolate;\n\n        v8::Local<v8::ObjectTemplate>   m_global;\n        v8::Local<v8::Context>          m_context;\n\n    public:\n        CJSContextPrivate() : m_oWorker(), m_isolate(NULL)\n        {\n        }\n    };\n}\n\nnamespace NSJSBase\n{\n    class CJSEmbedObjectPrivate : public CJSEmbedObjectPrivateBase\n    {\n    public:\n        v8::Persistent<v8::Object> handle;\n\n        CJSEmbedObjectPrivate(v8::Local<v8::Object> obj)\n        {\n            SetWeak(obj);\n        }\n        virtual ~CJSEmbedObjectPrivate()\n        {\n            ClearWeak();\n        }\n\n    public:\n        void SetWeak(v8::Local<v8::Object> obj)\n        {\n            v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(obj->GetInternalField(0));\n            CJSEmbedObject* pEmbedObject = (NSJSBase::CJSEmbedObject*)field->Value();\n\n            handle.Reset(CV8Worker::GetCurrent(), obj);\n            handle.SetWeak(pEmbedObject, EmbedObjectWeakCallback, v8::WeakCallbackType::kParameter);\n\n            pEmbedObject->embed_native_internal = this;\n        }\n        void ClearWeak()\n        {\n            if (handle.IsEmpty())\n                return;\n            handle.ClearWeak();\n            handle.Reset();\n        }\n\n        static void EmbedObjectWeakCallback(const v8::WeakCallbackInfo<CJSEmbedObject>& data)\n        {\n            v8::Isolate* isolate = data.GetIsolate();\n            v8::HandleScope scope(isolate);\n            CJSEmbedObject* wrap = data.GetParameter();\n            ((CJSEmbedObjectPrivate*)wrap->embed_native_internal)->handle.Reset();\n            delete wrap;\n        }\n\n        static void CreateWeaker(v8::Local<v8::Object> obj)\n        {\n            new CJSEmbedObjectPrivate(obj);\n        }\n    };\n}\n\nnamespace NSV8Objects\n{\n    static void Template_Set(v8::Local<v8::ObjectTemplate>& obj, const char* name, v8::FunctionCallback callback)\n    {\n        v8::Isolate* current = CV8Worker::GetCurrent();\n        obj->Set(CreateV8String(current, name), v8::FunctionTemplate::New(current, callback));\n    }\n}\n\ninline NSJSBase::CJSEmbedObject* unwrap_native(const v8::Local<v8::Object>& value)\n{\n    v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(value->GetInternalField(0));\n    return (NSJSBase::CJSEmbedObject*)field->Value();\n}\ninline NSJSBase::CJSEmbedObject* unwrap_native2(const v8::Local<v8::Value>& value)\n{\n    v8::Local<v8::Object> _obj = value->ToObject(V8ContextOneArg).ToLocalChecked();\n    v8::Handle<v8::External> field = v8::Handle<v8::External>::Cast(_obj->GetInternalField(0));\n    return (NSJSBase::CJSEmbedObject*)field->Value();\n}\n\ninline JSSmart<NSJSBase::CJSValue> js_value(const v8::Local<v8::Value>& value)\n{\n    return new NSJSBase::CJSValueV8(value);\n}\ninline JSSmart<NSJSBase::CJSValue> js_object(const v8::Local<v8::Object>& value)\n{\n    NSJSBase::CJSObjectV8* _ret = new NSJSBase::CJSObjectV8();\n    _ret->value = value;\n    return _ret;\n}\ninline void js_return(const v8::FunctionCallbackInfo<v8::Value>& args, JSSmart<NSJSBase::CJSValue>& value)\n{\n    if (value.is_init())\n    {\n        NSJSBase::CJSValueV8* _value = (NSJSBase::CJSValueV8*)(value.operator ->());\n        args.GetReturnValue().Set(_value->value);\n    }\n}\ninline void js_return(const v8::PropertyCallbackInfo<v8::Value>& info, JSSmart<NSJSBase::CJSValue>& value)\n{\n    if (value.is_init())\n    {\n        NSJSBase::CJSValueV8* _value = (NSJSBase::CJSValueV8*)(value.operator ->());\n        info.GetReturnValue().Set(_value->value);\n    }\n}\n\n#define PROPERTY_GET(NAME, NAME_EMBED)                                                      \\\n    void NAME(v8::Local<v8::String> _name, const v8::PropertyCallbackInfo<v8::Value>& info) \\\n    {                                                                                       \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(info.Holder());              \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED();                                        \\\n        js_return(info, ret);                                                               \\\n    }\n\n#define FUNCTION_WRAPPER_V8(NAME, NAME_EMBED)                                       \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                      \\\n    {                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED();                                \\\n        js_return(args, ret);                                                       \\\n    }\n\n#define FUNCTION_WRAPPER_V8_1(NAME, NAME_EMBED)                                     \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                      \\\n    {                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]));               \\\n        js_return(args, ret);                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_2(NAME, NAME_EMBED)                                             \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                              \\\n    {                                                                                       \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]));    \\\n        js_return(args, ret);                                                               \\\n    }\n#define FUNCTION_WRAPPER_V8_3(NAME, NAME_EMBED)                                                                 \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                  \\\n    {                                                                                                           \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                    \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]));     \\\n        js_return(args, ret);                                                                                   \\\n    }\n#define FUNCTION_WRAPPER_V8_4(NAME, NAME_EMBED)                                                                                 \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                  \\\n    {                                                                                                                           \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                    \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]));  \\\n        js_return(args, ret);                                                                                                   \\\n    }\n#define FUNCTION_WRAPPER_V8_5(NAME, NAME_EMBED)                                                                                                     \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]));   \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_6(NAME, NAME_EMBED)                                                                                                     \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]), js_value(args[5]));   \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_7(NAME, NAME_EMBED)                                                                                                     \\\nvoid NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                          \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]),    \\\n                                                   js_value(args[5]), js_value(args[6]));                                                           \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_8(NAME, NAME_EMBED)                                                                                                     \\\nvoid NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                          \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]),    \\\n                                                   js_value(args[5]), js_value(args[6]), js_value(args[7]));                                        \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_9(NAME, NAME_EMBED)                                                                                                     \\\nvoid NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                          \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]),    \\\n                                                   js_value(args[5]), js_value(args[6]), js_value(args[7]), js_value(args[8]));                     \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_10(NAME, NAME_EMBED)                                                                                                    \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]), js_value(args[5]), \\\n                                                  js_value(args[6]), js_value(args[7]), js_value(args[8]), js_value(args[9]));   \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n#define FUNCTION_WRAPPER_V8_13(NAME, NAME_EMBED)                                                                                                    \\\n    void NAME(const v8::FunctionCallbackInfo<v8::Value>& args)                                                                                      \\\n    {                                                                                                                                               \\\n        CURRENTWRAPPER* _this = (CURRENTWRAPPER*)unwrap_native(args.Holder());                                                                        \\\n        JSSmart<CJSValue> ret = _this->NAME_EMBED(js_value(args[0]), js_value(args[1]), js_value(args[2]), js_value(args[3]), js_value(args[4]), js_value(args[5]), \\\n                                                  js_value(args[6]), js_value(args[7]), js_value(args[8]), js_value(args[9]), js_value(args[10]), js_value(args[11]), \\\n                                                  js_value(args[12]));                                                                              \\\n        js_return(args, ret);                                                                                                                       \\\n    }\n\n#endif // _BUILD_NATIVE_CONTROL_V8_BASE_H_\n"], "filenames": ["DesktopEditor/doctrenderer/docbuilder_p.cpp", "DesktopEditor/doctrenderer/docbuilder_p.h", "DesktopEditor/doctrenderer/embed/jsc/jsc_NativeControl.mm", "DesktopEditor/doctrenderer/embed/v8/v8_NativeControl.cpp", "DesktopEditor/doctrenderer/js_internal/v8/v8_base.cpp", "DesktopEditor/doctrenderer/js_internal/v8/v8_base.h"], "buggy_code_start_loc": [79, 893, 17, 6, 221, 73], "buggy_code_end_loc": [253, 917, 59, 149, 221, 73], "fixing_code_start_loc": [79, 893, 17, 6, 222, 74], "fixing_code_end_loc": [253, 917, 59, 161, 229, 106], "type": "CWE-835", "message": "Memory Exhaustion vulnerability in ONLYOFFICE Document Server 4.0.3 through 7.3.2 allows remote attackers to cause a denial of service via crafted JavaScript file.", "other": {"cve": {"id": "CVE-2023-30188", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-14T13:15:10.720", "lastModified": "2023-08-21T16:57:38.130", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memory Exhaustion vulnerability in ONLYOFFICE Document Server 4.0.3 through 7.3.2 allows remote attackers to cause a denial of service via crafted JavaScript file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:onlyoffice:document_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.3", "versionEndIncluding": "7.3.2", "matchCriteriaId": "F05076E0-A23D-4BEE-B161-248ACEFEA307"}]}]}], "references": [{"url": "http://onlyoffice.com", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://gist.github.com/merrychap/25eba8c4dd97c9e545edad1b8f0eadc2", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ONLYOFFICE/DocumentServer", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/ONLYOFFICE/core/blob/8ca40a44ce47a86168327a46db91253cf6bb205d/DesktopEditor/doctrenderer/", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/ONLYOFFICE/core/blob/8ca40a44ce47a86168327a46db91253cf6bb205d/DesktopEditor/doctrenderer/embed/NativeControlEmbed.cpp#L110", "source": "cve@mitre.org", "tags": ["Not Applicable"]}, {"url": "https://github.com/ONLYOFFICE/core/commit/2b6ad83b36afd9845085b536969d366d1d61150a", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ONLYOFFICE/core/commit/2b6ad83b36afd9845085b536969d366d1d61150a"}}