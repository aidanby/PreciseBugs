{"buggy_code": ["use crate::store::{StoreData, StoreOpaque, Stored};\nuse crate::{\n    AsContext, AsContextMut, CallHook, Engine, Extern, FuncType, Instance, InterruptHandle,\n    StoreContext, StoreContextMut, Trap, Val, ValType,\n};\nuse anyhow::{bail, Context as _, Result};\nuse std::cmp::max;\nuse std::error::Error;\nuse std::fmt;\nuse std::future::Future;\nuse std::mem;\nuse std::panic::{self, AssertUnwindSafe};\nuse std::pin::Pin;\nuse std::ptr::NonNull;\nuse std::sync::atomic::Ordering::Relaxed;\nuse std::sync::Arc;\nuse wasmtime_environ::{EntityIndex, FuncIndex};\nuse wasmtime_runtime::{\n    raise_user_trap, ExportFunction, InstanceAllocator, InstanceHandle, OnDemandInstanceAllocator,\n    VMCallerCheckedAnyfunc, VMContext, VMFunctionBody, VMFunctionImport, VMSharedSignatureIndex,\n    VMTrampoline,\n};\n\n/// A WebAssembly function which can be called.\n///\n/// This type can represent either an exported function from a WebAssembly\n/// module or a host-defined function which can be used to satisfy an import of\n/// a module. [`Func`] and can be used to both instantiate an [`Instance`] as\n/// well as be extracted from an [`Instance`].\n///\n/// [`Instance`]: crate::Instance\n///\n/// A [`Func`] \"belongs\" to the store that it was originally created within.\n/// Operations on a [`Func`] only work with the store it belongs to, and if\n/// another store is passed in by accident then methods will panic.\n///\n/// # `Func` and `async`\n///\n/// Functions from the perspective of WebAssembly are always synchronous. You\n/// might have an `async` function in Rust, however, which you'd like to make\n/// available from WebAssembly. Wasmtime supports asynchronously calling\n/// WebAssembly through native stack switching. You can get some more\n/// information about [asynchronous configs](crate::Config::async_support), but\n/// from the perspective of `Func` it's important to know that whether or not\n/// your [`Store`](crate::Store) is asynchronous will dictate whether you call\n/// functions through [`Func::call`] or [`Func::call_async`] (or the typed\n/// wrappers such as [`TypedFunc::call`] vs [`TypedFunc::call_async`]).\n///\n/// # To `Func::call` or to `Func::typed().call()`\n///\n/// There's a 2x2 matrix of methods to call [`Func`]. Invocations can either be\n/// asynchronous or synchronous. They can also be statically typed or not.\n/// Whether or not an invocation is asynchronous is indicated via the method\n/// being `async` and [`call_async`](Func::call_async) being the entry point.\n/// Otherwise for statically typed or not your options are:\n///\n/// * Dynamically typed - if you don't statically know the signature of the\n///   function that you're calling you'll be using [`Func::call`] or\n///   [`Func::call_async`]. These functions take a variable-length slice of\n///   \"boxed\" arguments in their [`Val`] representation. Additionally the\n///   results are returned as an owned slice of [`Val`]. These methods are not\n///   optimized due to the dynamic type checks that must occur, in addition to\n///   some dynamic allocations for where to put all the arguments. While this\n///   allows you to call all possible wasm function signatures, if you're\n///   looking for a speedier alternative you can also use...\n///\n/// * Statically typed - if you statically know the type signature of the wasm\n///   function you're calling, then you'll want to use the [`Func::typed`]\n///   method to acquire an instance of [`TypedFunc`]. This structure is static proof\n///   that the underlying wasm function has the ascripted type, and type\n///   validation is only done once up-front. The [`TypedFunc::call`] and\n///   [`TypedFunc::call_async`] methods are much more efficient than [`Func::call`]\n///   and [`Func::call_async`] because the type signature is statically known.\n///   This eschews runtime checks as much as possible to get into wasm as fast\n///   as possible.\n///\n/// # Examples\n///\n/// One way to get a `Func` is from an [`Instance`] after you've instantiated\n/// it:\n///\n/// ```\n/// # use wasmtime::*;\n/// # fn main() -> anyhow::Result<()> {\n/// let engine = Engine::default();\n/// let module = Module::new(&engine, r#\"(module (func (export \"foo\")))\"#)?;\n/// let mut store = Store::new(&engine, ());\n/// let instance = Instance::new(&mut store, &module, &[])?;\n/// let foo = instance.get_func(&mut store, \"foo\").expect(\"export wasn't a function\");\n///\n/// // Work with `foo` as a `Func` at this point, such as calling it\n/// // dynamically...\n/// match foo.call(&mut store, &[]) {\n///     Ok(result) => { /* ... */ }\n///     Err(trap) => {\n///         panic!(\"execution of `foo` resulted in a wasm trap: {}\", trap);\n///     }\n/// }\n/// foo.call(&mut store, &[])?;\n///\n/// // ... or we can make a static assertion about its signature and call it.\n/// // Our first call here can fail if the signatures don't match, and then the\n/// // second call can fail if the function traps (like the `match` above).\n/// let foo = foo.typed::<(), (), _>(&store)?;\n/// foo.call(&mut store, ())?;\n/// # Ok(())\n/// # }\n/// ```\n///\n/// You can also use the [`wrap` function](Func::wrap) to create a\n/// `Func`\n///\n/// ```\n/// # use wasmtime::*;\n/// # fn main() -> anyhow::Result<()> {\n/// let mut store = Store::<()>::default();\n///\n/// // Create a custom `Func` which can execute arbitrary code inside of the\n/// // closure.\n/// let add = Func::wrap(&mut store, |a: i32, b: i32| -> i32 { a + b });\n///\n/// // Next we can hook that up to a wasm module which uses it.\n/// let module = Module::new(\n///     store.engine(),\n///     r#\"\n///         (module\n///             (import \"\" \"\" (func $add (param i32 i32) (result i32)))\n///             (func (export \"call_add_twice\") (result i32)\n///                 i32.const 1\n///                 i32.const 2\n///                 call $add\n///                 i32.const 3\n///                 i32.const 4\n///                 call $add\n///                 i32.add))\n///     \"#,\n/// )?;\n/// let instance = Instance::new(&mut store, &module, &[add.into()])?;\n/// let call_add_twice = instance.get_typed_func::<(), i32, _>(&mut store, \"call_add_twice\")?;\n///\n/// assert_eq!(call_add_twice.call(&mut store, ())?, 10);\n/// # Ok(())\n/// # }\n/// ```\n///\n/// Or you could also create an entirely dynamic `Func`!\n///\n/// ```\n/// # use wasmtime::*;\n/// # fn main() -> anyhow::Result<()> {\n/// let mut store = Store::<()>::default();\n///\n/// // Here we need to define the type signature of our `Double` function and\n/// // then wrap it up in a `Func`\n/// let double_type = wasmtime::FuncType::new(\n///     [wasmtime::ValType::I32].iter().cloned(),\n///     [wasmtime::ValType::I32].iter().cloned(),\n/// );\n/// let double = Func::new(&mut store, double_type, |_, params, results| {\n///     let mut value = params[0].unwrap_i32();\n///     value *= 2;\n///     results[0] = value.into();\n///     Ok(())\n/// });\n///\n/// let module = Module::new(\n///     store.engine(),\n///     r#\"\n///         (module\n///             (import \"\" \"\" (func $double (param i32) (result i32)))\n///             (func $start\n///                 i32.const 1\n///                 call $double\n///                 drop)\n///             (start $start))\n///     \"#,\n/// )?;\n/// let instance = Instance::new(&mut store, &module, &[double.into()])?;\n/// // .. work with `instance` if necessary\n/// # Ok(())\n/// # }\n/// ```\n#[derive(Copy, Clone, Debug)]\n#[repr(transparent)] // here for the C API\npub struct Func(Stored<FuncData>);\n\n/// The three ways that a function can be created and referenced from within a\n/// store.\npub(crate) enum FuncData {\n    /// A function already owned by the store via some other means. This is\n    /// used, for example, when creating a `Func` from an instance's exported\n    /// function. The instance's `InstanceHandle` is already owned by the store\n    /// and we just have some pointers into that which represent how to call the\n    /// function.\n    StoreOwned {\n        trampoline: VMTrampoline,\n        export: ExportFunction,\n    },\n\n    /// A function is shared across possibly other stores, hence the `Arc`. This\n    /// variant happens when a `Linker`-defined function is instantiated within\n    /// a `Store` (e.g. via `Linker::get` or similar APIs). The `Arc` here\n    /// indicates that there's some number of other stores holding this function\n    /// too, so dropping this may not deallocate the underlying\n    /// `InstanceHandle`.\n    SharedHost(Arc<HostFunc>),\n\n    /// A uniquely-owned host function within a `Store`. This comes about with\n    /// `Func::new` or similar APIs. The `HostFunc` internally owns the\n    /// `InstanceHandle` and that will get dropped when this `HostFunc` itself\n    /// is dropped.\n    Host(HostFunc),\n}\n\nmacro_rules! for_each_function_signature {\n    ($mac:ident) => {\n        $mac!(0);\n        $mac!(1 A1);\n        $mac!(2 A1 A2);\n        $mac!(3 A1 A2 A3);\n        $mac!(4 A1 A2 A3 A4);\n        $mac!(5 A1 A2 A3 A4 A5);\n        $mac!(6 A1 A2 A3 A4 A5 A6);\n        $mac!(7 A1 A2 A3 A4 A5 A6 A7);\n        $mac!(8 A1 A2 A3 A4 A5 A6 A7 A8);\n        $mac!(9 A1 A2 A3 A4 A5 A6 A7 A8 A9);\n        $mac!(10 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10);\n        $mac!(11 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11);\n        $mac!(12 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12);\n        $mac!(13 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13);\n        $mac!(14 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14);\n        $mac!(15 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15);\n        $mac!(16 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16);\n    };\n}\n\nmod typed;\npub use typed::*;\n\nmacro_rules! generate_wrap_async_func {\n    ($num:tt $($args:ident)*) => (paste::paste!{\n        /// Same as [`Func::wrap`], except the closure asynchronously produces\n        /// its result. For more information see the [`Func`] documentation.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if called with a non-asynchronous store.\n        #[allow(non_snake_case)]\n        #[cfg(feature = \"async\")]\n        #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n        pub fn [<wrap $num _async>]<T, $($args,)* R>(\n            store: impl AsContextMut<Data = T>,\n            func: impl for<'a> Fn(Caller<'a, T>, $($args),*) -> Box<dyn Future<Output = R> + Send + 'a> + Send + Sync + 'static,\n        ) -> Func\n        where\n            $($args: WasmTy,)*\n            R: WasmRet,\n        {\n            assert!(store.as_context().async_support(), concat!(\"cannot use `wrap\", $num, \"_async` without enabling async support on the config\"));\n            Func::wrap(store, move |mut caller: Caller<'_, T>, $($args: $args),*| {\n                let async_cx = caller.store.as_context_mut().0.async_cx();\n                let mut future = Pin::from(func(caller, $($args),*));\n                match unsafe { async_cx.block_on(future.as_mut()) } {\n                    Ok(ret) => ret.into_fallible(),\n                    Err(e) => R::fallible_from_trap(e),\n                }\n            })\n        }\n    })\n}\n\nimpl Func {\n    /// Creates a new `Func` with the given arguments, typically to create a\n    /// host-defined function to pass as an import to a module.\n    ///\n    /// * `store` - the store in which to create this [`Func`], which will own\n    ///   the return value.\n    ///\n    /// * `ty` - the signature of this function, used to indicate what the\n    ///   inputs and outputs are.\n    ///\n    /// * `func` - the native code invoked whenever this `Func` will be called.\n    ///   This closure is provided a [`Caller`] as its first argument to learn\n    ///   information about the caller, and then it's passed a list of\n    ///   parameters as a slice along with a mutable slice of where to write\n    ///   results.\n    ///\n    /// Note that the implementation of `func` must adhere to the `ty` signature\n    /// given, error or traps may occur if it does not respect the `ty`\n    /// signature. For example if the function type declares that it returns one\n    /// i32 but the `func` closures does not write anything into the results\n    /// slice then a trap may be generated.\n    ///\n    /// Additionally note that this is quite a dynamic function since signatures\n    /// are not statically known. For a more performant and ergonomic `Func`\n    /// it's recommended to use [`Func::wrap`] if you can because with\n    /// statically known signatures Wasmtime can optimize the implementation\n    /// much more.\n    ///\n    /// For more information about `Send + Sync + 'static` requirements on the\n    /// `func`, see [`Func::wrap`](#why-send--sync--static).\n    #[cfg(compiler)]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"cranelift\")))] // see build.rs\n    pub fn new<T>(\n        mut store: impl AsContextMut<Data = T>,\n        ty: FuncType,\n        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,\n    ) -> Self {\n        let store = store.as_context_mut().0;\n\n        // part of this unsafety is about matching the `T` to a `Store<T>`,\n        // which is done through the `AsContextMut` bound above.\n        unsafe {\n            let host = HostFunc::new(store.engine(), ty, func);\n            host.into_func(store)\n        }\n    }\n\n    /// Creates a new host-defined WebAssembly function which, when called,\n    /// will run the asynchronous computation defined by `func` to completion\n    /// and then return the result to WebAssembly.\n    ///\n    /// This function is the asynchronous analogue of [`Func::new`] and much of\n    /// that documentation applies to this as well. The key difference is that\n    /// `func` returns a future instead of simply a `Result`. Note that the\n    /// returned future can close over any of the arguments, but it cannot close\n    /// over the state of the closure itself. It's recommended to store any\n    /// necessary async state in the `T` of the [`Store<T>`](crate::Store) which\n    /// can be accessed through [`Caller::data`] or [`Caller::data_mut`].\n    ///\n    /// For more information on `Send + Sync + 'static`, see\n    /// [`Func::wrap`](#why-send--sync--static).\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `store` is not associated with an [async\n    /// config](crate::Config::async_support).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// // Simulate some application-specific state as well as asynchronous\n    /// // functions to query that state.\n    /// struct MyDatabase {\n    ///     // ...\n    /// }\n    ///\n    /// impl MyDatabase {\n    ///     async fn get_row_count(&self) -> u32 {\n    ///         // ...\n    /// #       100\n    ///     }\n    /// }\n    ///\n    /// let my_database = MyDatabase {\n    ///     // ...\n    /// };\n    ///\n    /// // Using `new_async` we can hook up into calling our async\n    /// // `get_row_count` function.\n    /// let engine = Engine::new(Config::new().async_support(true))?;\n    /// let mut store = Store::new(&engine, MyDatabase {\n    ///     // ...\n    /// });\n    /// let get_row_count_type = wasmtime::FuncType::new(\n    ///     None,\n    ///     Some(wasmtime::ValType::I32),\n    /// );\n    /// let get = Func::new_async(&mut store, get_row_count_type, |caller, _params, results| {\n    ///     Box::new(async move {\n    ///         let count = caller.data().get_row_count().await;\n    ///         results[0] = Val::I32(count as i32);\n    ///         Ok(())\n    ///     })\n    /// });\n    /// // ...\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[cfg(all(feature = \"async\", feature = \"cranelift\"))]\n    #[cfg_attr(nightlydoc, doc(cfg(all(feature = \"async\", feature = \"cranelift\"))))]\n    pub fn new_async<T, F>(store: impl AsContextMut<Data = T>, ty: FuncType, func: F) -> Func\n    where\n        F: for<'a> Fn(\n                Caller<'a, T>,\n                &'a [Val],\n                &'a mut [Val],\n            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>\n            + Send\n            + Sync\n            + 'static,\n    {\n        assert!(\n            store.as_context().async_support(),\n            \"cannot use `new_async` without enabling async support in the config\"\n        );\n        Func::new(store, ty, move |mut caller, params, results| {\n            let async_cx = caller.store.as_context_mut().0.async_cx();\n            let mut future = Pin::from(func(caller, params, results));\n            match unsafe { async_cx.block_on(future.as_mut()) } {\n                Ok(Ok(())) => Ok(()),\n                Ok(Err(trap)) | Err(trap) => Err(trap),\n            }\n        })\n    }\n\n    pub(crate) unsafe fn from_caller_checked_anyfunc(\n        store: &mut StoreOpaque,\n        anyfunc: *mut VMCallerCheckedAnyfunc,\n    ) -> Option<Self> {\n        let anyfunc = NonNull::new(anyfunc)?;\n        debug_assert!(anyfunc.as_ref().type_index != VMSharedSignatureIndex::default());\n        let export = ExportFunction { anyfunc };\n        Some(Func::from_wasmtime_function(export, store))\n    }\n\n    /// Creates a new `Func` from the given Rust closure.\n    ///\n    /// This function will create a new `Func` which, when called, will\n    /// execute the given Rust closure. Unlike [`Func::new`] the target\n    /// function being called is known statically so the type signature can\n    /// be inferred. Rust types will map to WebAssembly types as follows:\n    ///\n    /// | Rust Argument Type  | WebAssembly Type |\n    /// |---------------------|------------------|\n    /// | `i32`               | `i32`            |\n    /// | `u32`               | `i32`            |\n    /// | `i64`               | `i64`            |\n    /// | `u64`               | `i64`            |\n    /// | `f32`               | `f32`            |\n    /// | `f64`               | `f64`            |\n    /// | (not supported)     | `v128`           |\n    /// | `Option<Func>`      | `funcref`        |\n    /// | `Option<ExternRef>` | `externref`      |\n    ///\n    /// Any of the Rust types can be returned from the closure as well, in\n    /// addition to some extra types\n    ///\n    /// | Rust Return Type  | WebAssembly Return Type | Meaning               |\n    /// |-------------------|-------------------------|-----------------------|\n    /// | `()`              | nothing                 | no return value       |\n    /// | `T`               | `T`                     | a single return value |\n    /// | `(T1, T2, ...)`   | `T1 T2 ...`             | multiple returns      |\n    ///\n    /// Note that all return types can also be wrapped in `Result<_, Trap>` to\n    /// indicate that the host function can generate a trap as well as possibly\n    /// returning a value.\n    ///\n    /// Finally you can also optionally take [`Caller`] as the first argument of\n    /// your closure. If inserted then you're able to inspect the caller's\n    /// state, for example the [`Memory`](crate::Memory) it has exported so you\n    /// can read what pointers point to.\n    ///\n    /// Note that when using this API, the intention is to create as thin of a\n    /// layer as possible for when WebAssembly calls the function provided. With\n    /// sufficient inlining and optimization the WebAssembly will call straight\n    /// into `func` provided, with no extra fluff entailed.\n    ///\n    /// # Why `Send + Sync + 'static`?\n    ///\n    /// All host functions defined in a [`Store`](crate::Store) (including\n    /// those from [`Func::new`] and other constructors) require that the\n    /// `func` provided is `Send + Sync + 'static`. Additionally host functions\n    /// always are `Fn` as opposed to `FnMut` or `FnOnce`. This can at-a-glance\n    /// feel restrictive since the closure cannot close over as many types as\n    /// before. The reason for this, though, is to ensure that\n    /// [`Store<T>`](crate::Store) can implement both the `Send` and `Sync`\n    /// traits.\n    ///\n    /// Fear not, however, because this isn't as restrictive as it seems! Host\n    /// functions are provided a [`Caller<'_, T>`](crate::Caller) argument which\n    /// allows access to the host-defined data within the\n    /// [`Store`](crate::Store). The `T` type is not required to be any of\n    /// `Send`, `Sync`, or `'static`! This means that you can store whatever\n    /// you'd like in `T` and have it accessible by all host functions.\n    /// Additionally mutable access to `T` is allowed through\n    /// [`Caller::data_mut`].\n    ///\n    /// Most host-defined [`Func`] values provide closures that end up not\n    /// actually closing over any values. These zero-sized types will use the\n    /// context from [`Caller`] for host-defined information.\n    ///\n    /// # Examples\n    ///\n    /// First up we can see how simple wasm imports can be implemented, such\n    /// as a function that adds its two arguments and returns the result.\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::<()>::default();\n    /// let add = Func::wrap(&mut store, |a: i32, b: i32| a + b);\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $add (param i32 i32) (result i32)))\n    ///             (func (export \"foo\") (param i32 i32) (result i32)\n    ///                 local.get 0\n    ///                 local.get 1\n    ///                 call $add))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[add.into()])?;\n    /// let foo = instance.get_typed_func::<(i32, i32), i32, _>(&mut store, \"foo\")?;\n    /// assert_eq!(foo.call(&mut store, (1, 2))?, 3);\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// We can also do the same thing, but generate a trap if the addition\n    /// overflows:\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::<()>::default();\n    /// let add = Func::wrap(&mut store, |a: i32, b: i32| {\n    ///     match a.checked_add(b) {\n    ///         Some(i) => Ok(i),\n    ///         None => Err(Trap::new(\"overflow\")),\n    ///     }\n    /// });\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $add (param i32 i32) (result i32)))\n    ///             (func (export \"foo\") (param i32 i32) (result i32)\n    ///                 local.get 0\n    ///                 local.get 1\n    ///                 call $add))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[add.into()])?;\n    /// let foo = instance.get_typed_func::<(i32, i32), i32, _>(&mut store, \"foo\")?;\n    /// assert_eq!(foo.call(&mut store, (1, 2))?, 3);\n    /// assert!(foo.call(&mut store, (i32::max_value(), 1)).is_err());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// And don't forget all the wasm types are supported!\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::<()>::default();\n    /// let debug = Func::wrap(&mut store, |a: i32, b: u32, c: f32, d: i64, e: u64, f: f64| {\n    ///\n    ///     println!(\"a={}\", a);\n    ///     println!(\"b={}\", b);\n    ///     println!(\"c={}\", c);\n    ///     println!(\"d={}\", d);\n    ///     println!(\"e={}\", e);\n    ///     println!(\"f={}\", f);\n    /// });\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $debug (param i32 i32 f32 i64 i64 f64)))\n    ///             (func (export \"foo\")\n    ///                 i32.const -1\n    ///                 i32.const 1\n    ///                 f32.const 2\n    ///                 i64.const -3\n    ///                 i64.const 3\n    ///                 f64.const 4\n    ///                 call $debug))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[debug.into()])?;\n    /// let foo = instance.get_typed_func::<(), (), _>(&mut store, \"foo\")?;\n    /// foo.call(&mut store, ())?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// Finally if you want to get really fancy you can also implement\n    /// imports that read/write wasm module's memory\n    ///\n    /// ```\n    /// use std::str;\n    ///\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::default();\n    /// let log_str = Func::wrap(&mut store, |mut caller: Caller<'_, ()>, ptr: i32, len: i32| {\n    ///     let mem = match caller.get_export(\"memory\") {\n    ///         Some(Extern::Memory(mem)) => mem,\n    ///         _ => return Err(Trap::new(\"failed to find host memory\")),\n    ///     };\n    ///     let data = mem.data(&caller)\n    ///         .get(ptr as u32 as usize..)\n    ///         .and_then(|arr| arr.get(..len as u32 as usize));\n    ///     let string = match data {\n    ///         Some(data) => match str::from_utf8(data) {\n    ///             Ok(s) => s,\n    ///             Err(_) => return Err(Trap::new(\"invalid utf-8\")),\n    ///         },\n    ///         None => return Err(Trap::new(\"pointer/length out of bounds\")),\n    ///     };\n    ///     assert_eq!(string, \"Hello, world!\");\n    ///     println!(\"{}\", string);\n    ///     Ok(())\n    /// });\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $log_str (param i32 i32)))\n    ///             (func (export \"foo\")\n    ///                 i32.const 4   ;; ptr\n    ///                 i32.const 13  ;; len\n    ///                 call $log_str)\n    ///             (memory (export \"memory\") 1)\n    ///             (data (i32.const 4) \"Hello, world!\"))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[log_str.into()])?;\n    /// let foo = instance.get_typed_func::<(), (), _>(&mut store, \"foo\")?;\n    /// foo.call(&mut store, ())?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn wrap<T, Params, Results>(\n        mut store: impl AsContextMut<Data = T>,\n        func: impl IntoFunc<T, Params, Results>,\n    ) -> Func {\n        let store = store.as_context_mut().0;\n        // part of this unsafety is about matching the `T` to a `Store<T>`,\n        // which is done through the `AsContextMut` bound above.\n        unsafe {\n            let host = HostFunc::wrap(store.engine(), func);\n            host.into_func(store)\n        }\n    }\n\n    for_each_function_signature!(generate_wrap_async_func);\n\n    /// Returns the underlying wasm type that this `Func` has.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this function.\n    pub fn ty(&self, store: impl AsContext) -> FuncType {\n        // Signatures should always be registered in the engine's registry of\n        // shared signatures, so we should be able to unwrap safely here.\n        let store = store.as_context();\n        let sig_index = unsafe { store[self.0].export().anyfunc.as_ref().type_index };\n        FuncType::from_wasm_func_type(\n            store\n                .engine()\n                .signatures()\n                .lookup_type(sig_index)\n                .expect(\"signature should be registered\"),\n        )\n    }\n\n    pub(crate) fn sig_index(&self, data: &StoreData) -> VMSharedSignatureIndex {\n        unsafe { data[self.0].export().anyfunc.as_ref().type_index }\n    }\n\n    /// Invokes this function with the `params` given, returning the results and\n    /// any trap, if one occurs.\n    ///\n    /// The `params` here must match the type signature of this `Func`, or a\n    /// trap will occur. If a trap occurs while executing this function, then a\n    /// trap will also be returned.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if called on a function belonging to an async\n    /// store. Asynchronous stores must always use `call_async`.\n    /// initiates a panic. Also panics if `store` does not own this function.\n    pub fn call(&self, mut store: impl AsContextMut, params: &[Val]) -> Result<Box<[Val]>> {\n        assert!(\n            !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        let my_ty = self.ty(&store);\n        self.call_impl(&mut store.as_context_mut(), my_ty, params)\n    }\n\n    /// Invokes this function with the `params` given, returning the results\n    /// asynchronously.\n    ///\n    /// This function is the same as [`Func::call`] except that it is\n    /// asynchronous. This is only compatible with stores associated with an\n    /// [asynchronous config](crate::Config::async_support).\n    ///\n    /// It's important to note that the execution of WebAssembly will happen\n    /// synchronously in the `poll` method of the future returned from this\n    /// function. Wasmtime does not manage its own thread pool or similar to\n    /// execute WebAssembly in. Future `poll` methods are generally expected to\n    /// resolve quickly, so it's recommended that you run or poll this future\n    /// in a \"blocking context\".\n    ///\n    /// For more information see the documentation on [asynchronous\n    /// configs](crate::Config::async_support).\n    ///\n    /// # Panics\n    ///\n    /// Panics if this is called on a function in a synchronous store. This\n    /// only works with functions defined within an asynchronous store. Also\n    /// panics if `store` does not own this function.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn call_async<T>(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        params: &[Val],\n    ) -> Result<Box<[Val]>>\n    where\n        T: Send,\n    {\n        let mut store = store.as_context_mut();\n        assert!(\n            store.0.async_support(),\n            \"cannot use `call_async` without enabling async support in the config\",\n        );\n        let my_ty = self.ty(&store);\n        let result = store\n            .on_fiber(|store| self.call_impl(store, my_ty, params))\n            .await??;\n        Ok(result)\n    }\n\n    fn call_impl<T>(\n        &self,\n        store: &mut StoreContextMut<'_, T>,\n        my_ty: FuncType,\n        params: &[Val],\n    ) -> Result<Box<[Val]>> {\n        let mut values_vec = write_params(store.0, &my_ty, params)?;\n\n        // Call the trampoline.\n        unsafe {\n            let data = &store.0.store_data()[self.0];\n            let trampoline = data.trampoline();\n            let anyfunc = data.export().anyfunc;\n            invoke_wasm_and_catch_traps(store, |callee| {\n                trampoline(\n                    (*anyfunc.as_ptr()).vmctx,\n                    callee,\n                    (*anyfunc.as_ptr()).func_ptr.as_ptr(),\n                    values_vec.as_mut_ptr(),\n                )\n            })?;\n        }\n\n        return Ok(read_results(store.0, &my_ty, &values_vec));\n\n        fn write_params(\n            store: &mut StoreOpaque,\n            ty: &FuncType,\n            params: &[Val],\n        ) -> Result<Vec<u128>> {\n            // We need to perform a dynamic check that the arguments given to us\n            // match the signature of this function and are appropriate to pass to\n            // this function. This involves checking to make sure we have the right\n            // number and types of arguments as well as making sure everything is\n            // from the same `Store`.\n            if ty.params().len() != params.len() {\n                bail!(\n                    \"expected {} arguments, got {}\",\n                    ty.params().len(),\n                    params.len()\n                );\n            }\n\n            let mut values_vec = vec![0; max(params.len(), ty.results().len())];\n\n            // Whenever we pass `externref`s from host code to Wasm code, they\n            // go into the `VMExternRefActivationsTable`. But the table might be\n            // at capacity already, so check for that. If it is at capacity\n            // (unlikely) then do a GC to free up space. This is necessary\n            // because otherwise we would either keep filling up the bump chunk\n            // and making it larger and larger or we would always take the slow\n            // path when inserting references into the table.\n            if ty.as_wasm_func_type().externref_params_count()\n                > store\n                    .externref_activations_table()\n                    .bump_capacity_remaining()\n            {\n                store.gc();\n            }\n\n            // Store the argument values into `values_vec`.\n            let param_tys = ty.params();\n            for ((arg, slot), ty) in params.iter().cloned().zip(&mut values_vec).zip(param_tys) {\n                if arg.ty() != ty {\n                    bail!(\n                        \"argument type mismatch: found {} but expected {}\",\n                        arg.ty(),\n                        ty\n                    );\n                }\n                if !arg.comes_from_same_store(store) {\n                    bail!(\"cross-`Store` values are not currently supported\");\n                }\n                unsafe {\n                    arg.write_value_without_gc(store, slot);\n                }\n            }\n\n            Ok(values_vec)\n        }\n\n        fn read_results(store: &mut StoreOpaque, ty: &FuncType, values_vec: &[u128]) -> Box<[Val]> {\n            let mut results = Vec::with_capacity(ty.results().len());\n            for (index, ty) in ty.results().enumerate() {\n                unsafe {\n                    let ptr = &values_vec[index];\n                    results.push(Val::read_value_from(store, ptr, ty));\n                }\n            }\n            results.into()\n        }\n    }\n\n    #[inline]\n    pub(crate) fn caller_checked_anyfunc(\n        &self,\n        store: &StoreOpaque,\n    ) -> NonNull<VMCallerCheckedAnyfunc> {\n        store.store_data()[self.0].export().anyfunc\n    }\n\n    pub(crate) unsafe fn from_wasmtime_function(\n        export: ExportFunction,\n        store: &mut StoreOpaque,\n    ) -> Self {\n        let anyfunc = export.anyfunc.as_ref();\n        let trampoline = store.lookup_trampoline(&*anyfunc);\n        let data = FuncData::StoreOwned { trampoline, export };\n        Func(store.store_data_mut().insert(data))\n    }\n\n    pub(crate) fn vmimport(&self, store: &mut StoreOpaque) -> VMFunctionImport {\n        unsafe {\n            let f = self.caller_checked_anyfunc(store);\n            VMFunctionImport {\n                body: f.as_ref().func_ptr,\n                vmctx: f.as_ref().vmctx,\n            }\n        }\n    }\n\n    pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {\n        store.store_data().contains(self.0)\n    }\n\n    fn invoke<T>(\n        mut caller: Caller<'_, T>,\n        ty: &FuncType,\n        values_vec: *mut u128,\n        func: &dyn Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap>,\n    ) -> Result<(), Trap> {\n        caller.store.0.call_hook(CallHook::CallingHost)?;\n\n        // Translate the raw JIT arguments in `values_vec` into a `Val` which\n        // we'll be passing as a slice. The storage for our slice-of-`Val` we'll\n        // be taking from the `Store`. We preserve our slice back into the\n        // `Store` after the hostcall, ideally amortizing the cost of allocating\n        // the storage across wasm->host calls.\n        //\n        // Note that we have a dynamic guarantee that `values_vec` is the\n        // appropriate length to both read all arguments from as well as store\n        // all results into.\n        let mut val_vec = caller.store.0.take_hostcall_val_storage();\n        debug_assert!(val_vec.is_empty());\n        let nparams = ty.params().len();\n        val_vec.reserve(nparams + ty.results().len());\n        for (i, ty) in ty.params().enumerate() {\n            unsafe {\n                let val = Val::read_value_from(caller.store.0, values_vec.add(i), ty);\n                val_vec.push(val);\n            }\n        }\n\n        val_vec.extend((0..ty.results().len()).map(|_| Val::null()));\n        let (params, results) = val_vec.split_at_mut(nparams);\n        func(caller.sub_caller(), params, results)?;\n\n        // See the comment in `Func::call_impl`'s `write_params` function.\n        if ty.as_wasm_func_type().externref_returns_count()\n            > caller\n                .store\n                .0\n                .externref_activations_table()\n                .bump_capacity_remaining()\n        {\n            caller.store.gc();\n        }\n\n        // Unlike our arguments we need to dynamically check that the return\n        // values produced are correct. There could be a bug in `func` that\n        // produces the wrong number, wrong types, or wrong stores of\n        // values, and we need to catch that here.\n        for (i, (ret, ty)) in results.iter().zip(ty.results()).enumerate() {\n            if ret.ty() != ty {\n                return Err(Trap::new(\n                    \"function attempted to return an incompatible value\",\n                ));\n            }\n            if !ret.comes_from_same_store(caller.store.0) {\n                return Err(Trap::new(\n                    \"cross-`Store` values are not currently supported\",\n                ));\n            }\n            unsafe {\n                ret.write_value_without_gc(caller.store.0, values_vec.add(i));\n            }\n        }\n\n        // Restore our `val_vec` back into the store so it's usable for the next\n        // hostcall to reuse our own storage.\n        val_vec.truncate(0);\n        caller.store.0.save_hostcall_val_storage(val_vec);\n        caller.store.0.call_hook(CallHook::ReturningFromHost)?;\n        Ok(())\n    }\n\n    /// Attempts to extract a typed object from this `Func` through which the\n    /// function can be called.\n    ///\n    /// This function serves as an alternative to [`Func::call`] and\n    /// [`Func::call_async`]. This method performs a static type check (using\n    /// the `Params` and `Results` type parameters on the underlying wasm\n    /// function. If the type check passes then a `TypedFunc` object is returned,\n    /// otherwise an error is returned describing the typecheck failure.\n    ///\n    /// The purpose of this relative to [`Func::call`] is that it's much more\n    /// efficient when used to invoke WebAssembly functions. With the types\n    /// statically known far less setup/teardown is required when invoking\n    /// WebAssembly. If speed is desired then this function is recommended to be\n    /// used instead of [`Func::call`] (which is more general, hence its\n    /// slowdown).\n    ///\n    /// The `Params` type parameter is used to describe the parameters of the\n    /// WebAssembly function. This can either be a single type (like `i32`), or\n    /// a tuple of types representing the list of parameters (like `(i32, f32,\n    /// f64)`). Additionally you can use `()` to represent that the function has\n    /// no parameters.\n    ///\n    /// The `Results` type parameter is used to describe the results of the\n    /// function. This behaves the same way as `Params`, but just for the\n    /// results of the function.\n    ///\n    /// The `S` type parameter represents the method of passing in the store\n    /// context, and can typically be specified as simply `_` when calling this\n    /// function.\n    ///\n    /// Translation between Rust types and WebAssembly types looks like:\n    ///\n    /// | WebAssembly | Rust                |\n    /// |-------------|---------------------|\n    /// | `i32`       | `i32` or `u32`      |\n    /// | `i64`       | `i64` or `u64`      |\n    /// | `f32`       | `f32`               |\n    /// | `f64`       | `f64`               |\n    /// | `externref` | `Option<ExternRef>` |\n    /// | `funcref`   | `Option<Func>`      |\n    /// | `v128`      | not supported       |\n    ///\n    /// (note that this mapping is the same as that of [`Func::wrap`]).\n    ///\n    /// Note that once the [`TypedFunc`] return value is acquired you'll use either\n    /// [`TypedFunc::call`] or [`TypedFunc::call_async`] as necessary to actually invoke\n    /// the function. This method does not invoke any WebAssembly code, it\n    /// simply performs a typecheck before returning the [`TypedFunc`] value.\n    ///\n    /// This method also has a convenience wrapper as\n    /// [`Instance::get_typed_func`](crate::Instance::get_typed_func) to\n    /// directly get a typed function value from an\n    /// [`Instance`](crate::Instance).\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `Params` or `Results` does not\n    /// match the native type of this WebAssembly function.\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if `store` does not own this function.\n    ///\n    /// # Examples\n    ///\n    /// An end-to-end example of calling a function which takes no parameters\n    /// and has no results:\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// let engine = Engine::default();\n    /// let mut store = Store::new(&engine, ());\n    /// let module = Module::new(&engine, r#\"(module (func (export \"foo\")))\"#)?;\n    /// let instance = Instance::new(&mut store, &module, &[])?;\n    /// let foo = instance.get_func(&mut store, \"foo\").expect(\"export wasn't a function\");\n    ///\n    /// // Note that this call can fail due to the typecheck not passing, but\n    /// // in our case we statically know the module so we know this should\n    /// // pass.\n    /// let typed = foo.typed::<(), (), _>(&store)?;\n    ///\n    /// // Note that this can fail if the wasm traps at runtime.\n    /// typed.call(&mut store, ())?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// You can also pass in multiple parameters and get a result back\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn foo(add: &Func, mut store: Store<()>) -> anyhow::Result<()> {\n    /// let typed = add.typed::<(i32, i64), f32, _>(&store)?;\n    /// assert_eq!(typed.call(&mut store, (1, 2))?, 3.0);\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// and similarly if a function has multiple results you can bind that too\n    ///\n    /// ```\n    /// # #[cfg(not(feature = \"old-x86-backend\"))]\n    /// # use wasmtime::*;\n    /// # #[cfg(not(feature = \"old-x86-backend\"))]\n    /// # fn foo(add_with_overflow: &Func, mut store: Store<()>) -> anyhow::Result<()> {\n    /// let typed = add_with_overflow.typed::<(u32, u32), (u32, i32), _>(&store)?;\n    /// let (result, overflow) = typed.call(&mut store, (u32::max_value(), 2))?;\n    /// assert_eq!(result, 1);\n    /// assert_eq!(overflow, 1);\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn typed<Params, Results, S>(&self, store: S) -> Result<TypedFunc<Params, Results>>\n    where\n        Params: WasmParams,\n        Results: WasmResults,\n        S: AsContext,\n    {\n        // Type-check that the params/results are all valid\n        let ty = self.ty(store);\n        Params::typecheck(ty.params()).context(\"type mismatch with parameters\")?;\n        Results::typecheck(ty.results()).context(\"type mismatch with results\")?;\n\n        // and then we can construct the typed version of this function\n        // (unsafely), which should be safe since we just did the type check above.\n        unsafe { Ok(TypedFunc::new_unchecked(*self)) }\n    }\n}\n\n/// Prepares for entrance into WebAssembly.\n///\n/// This function will set up context such that `closure` is allowed to call a\n/// raw trampoline or a raw WebAssembly function. This *must* be called to do\n/// things like catch traps and set up GC properly.\n///\n/// The `closure` provided receives a default \"callee\" `VMContext` parameter it\n/// can pass to the called wasm function, if desired.\npub(crate) fn invoke_wasm_and_catch_traps<T>(\n    store: &mut StoreContextMut<'_, T>,\n    closure: impl FnMut(*mut VMContext),\n) -> Result<(), Trap> {\n    unsafe {\n        let exit = enter_wasm(store)?;\n\n        if let Err(trap) = store.0.call_hook(CallHook::CallingWasm) {\n            exit_wasm(store, exit);\n            return Err(trap);\n        }\n        let result = wasmtime_runtime::catch_traps(\n            store.0.vminterrupts(),\n            store.0.signal_handler(),\n            store.0.default_callee(),\n            closure,\n        );\n        exit_wasm(store, exit);\n        store.0.call_hook(CallHook::ReturningFromWasm)?;\n        result.map_err(Trap::from_runtime_box)\n    }\n}\n\n/// This function is called to register state within `Store` whenever\n/// WebAssembly is entered within the `Store`.\n///\n/// This function sets up various limits such as:\n///\n/// * The stack limit. This is what ensures that we limit the stack space\n///   allocated by WebAssembly code and it's relative to the initial stack\n///   pointer that called into wasm.\n///\n/// * Stack canaries for externref gc tracing. Currently the implementation\n///   relies on walking frames but the stack walker isn't always 100% reliable,\n///   so a canary is used to ensure that if the canary is seen then it's\n///   guaranteed all wasm frames have been walked.\n///\n/// This function may fail if the the stack limit can't be set because an\n/// interrupt already happened.\nfn enter_wasm<T>(store: &mut StoreContextMut<'_, T>) -> Result<Option<usize>, Trap> {\n    // If this is a recursive call, e.g. our stack canary is already set, then\n    // we may be able to skip this function.\n    //\n    // For synchronous stores there's nothing else to do because all wasm calls\n    // happen synchronously and on the same stack. This means that the previous\n    // stack limit will suffice for the next recursive call.\n    //\n    // For asynchronous stores then each call happens on a separate native\n    // stack. This means that the previous stack limit is no longer relevant\n    // because we're on a separate stack. In this situation we need to\n    // update the stack limit, but we don't need to update the gc stack canary\n    // in this situation.\n    if store\n        .0\n        .externref_activations_table()\n        .stack_canary()\n        .is_some()\n        && !store.0.async_support()\n    {\n        return Ok(None);\n    }\n\n    let stack_pointer = psm::stack_pointer() as usize;\n\n    // Determine the stack pointer where, after which, any wasm code will\n    // immediately trap. This is checked on the entry to all wasm functions.\n    //\n    // Note that this isn't 100% precise. We are requested to give wasm\n    // `max_wasm_stack` bytes, but what we're actually doing is giving wasm\n    // probably a little less than `max_wasm_stack` because we're\n    // calculating the limit relative to this function's approximate stack\n    // pointer. Wasm will be executed on a frame beneath this one (or next\n    // to it). In any case it's expected to be at most a few hundred bytes\n    // of slop one way or another. When wasm is typically given a MB or so\n    // (a million bytes) the slop shouldn't matter too much.\n    //\n    // After we've got the stack limit then we store it into the `stack_limit`\n    // variable. Note that the store is an atomic swap to ensure that we can\n    // consume any previously-sent interrupt requests. If we found that wasm was\n    // previously interrupted then we immediately return a trap (after resetting\n    // the stack limit). Otherwise we're good to keep on going.\n    //\n    // Note the usage of `Relaxed` memory orderings here. This is specifically\n    // an optimization in the `Drop` below where a `Relaxed` store is speedier\n    // than a `SeqCst` store. The rationale for `Relaxed` here is that the\n    // atomic orderings here aren't actually protecting any memory, we're just\n    // trying to be atomic with respect to this one location in memory (for when\n    // `InterruptHandle` sends us a signal). Due to the lack of needing to\n    // synchronize with any other memory it's hoped that the choice of `Relaxed`\n    // here should be correct for our use case.\n    let wasm_stack_limit = stack_pointer - store.engine().config().max_wasm_stack;\n    let interrupts = store.0.interrupts();\n    let prev_stack = match interrupts.stack_limit.swap(wasm_stack_limit, Relaxed) {\n        wasmtime_environ::INTERRUPTED => {\n            // This means that an interrupt happened before we actually\n            // called this function, which means that we're now\n            // considered interrupted.\n            interrupts.stack_limit.store(usize::max_value(), Relaxed);\n            return Err(Trap::new_wasm(\n                None,\n                wasmtime_environ::TrapCode::Interrupt,\n                backtrace::Backtrace::new_unresolved(),\n            ));\n        }\n        n => n,\n    };\n\n    // The `usize::max_value()` sentinel is present on recursive calls to\n    // asynchronous stores here. In that situation we don't want to keep\n    // updating the stack canary, so only execute this once at the top.\n    if prev_stack == usize::max_value() {\n        debug_assert!(store\n            .0\n            .externref_activations_table()\n            .stack_canary()\n            .is_none());\n        store\n            .0\n            .externref_activations_table()\n            .set_stack_canary(Some(stack_pointer));\n    }\n\n    Ok(Some(prev_stack))\n}\n\nfn exit_wasm<T>(store: &mut StoreContextMut<'_, T>, prev_stack: Option<usize>) {\n    // If we don't have a previous stack pointer to restore, then there's no\n    // cleanup we need to perform here.\n    let prev_stack = match prev_stack {\n        Some(stack) => stack,\n        None => return,\n    };\n\n    // Only if we're restoring a top-level value do we clear the stack canary\n    // value. Otherwise our purpose here might be restoring a recursive stack\n    // limit but leaving the active canary in place.\n    if prev_stack == usize::max_value() {\n        store.0.externref_activations_table().set_stack_canary(None);\n    }\n\n    // see docs above for why this uses `Relaxed`\n    store.0.interrupts().stack_limit.store(prev_stack, Relaxed);\n}\n\n/// A trait implemented for types which can be returned from closures passed to\n/// [`Func::wrap`] and friends.\n///\n/// This trait should not be implemented by user types. This trait may change at\n/// any time internally. The types which implement this trait, however, are\n/// stable over time.\n///\n/// For more information see [`Func::wrap`]\npub unsafe trait WasmRet {\n    // Same as `WasmTy::Abi`.\n    #[doc(hidden)]\n    type Abi: Copy;\n    #[doc(hidden)]\n    type Retptr: Copy;\n\n    // Same as `WasmTy::compatible_with_store`.\n    #[doc(hidden)]\n    fn compatible_with_store(&self, store: &StoreOpaque) -> bool;\n\n    // Similar to `WasmTy::into_abi_for_arg` but used when host code is\n    // returning a value into Wasm, rather than host code passing an argument to\n    // a Wasm call. Unlike `into_abi_for_arg`, implementors of this method can\n    // raise traps, which means that callers must ensure that\n    // `invoke_wasm_and_catch_traps` is on the stack, and therefore this method\n    // is unsafe.\n    #[doc(hidden)]\n    unsafe fn into_abi_for_ret(\n        self,\n        store: &mut StoreOpaque,\n        ptr: Self::Retptr,\n    ) -> Result<Self::Abi, Trap>;\n\n    #[doc(hidden)]\n    fn func_type(params: impl Iterator<Item = ValType>) -> FuncType;\n\n    #[doc(hidden)]\n    unsafe fn wrap_trampoline(ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi);\n\n    // Utilities used to convert an instance of this type to a `Result`\n    // explicitly, used when wrapping async functions which always bottom-out\n    // in a function that returns a trap because futures can be cancelled.\n    #[doc(hidden)]\n    type Fallible: WasmRet<Abi = Self::Abi, Retptr = Self::Retptr>;\n    #[doc(hidden)]\n    fn into_fallible(self) -> Self::Fallible;\n    #[doc(hidden)]\n    fn fallible_from_trap(trap: Trap) -> Self::Fallible;\n}\n\nunsafe impl<T> WasmRet for T\nwhere\n    T: WasmTy,\n{\n    type Abi = <T as WasmTy>::Abi;\n    type Retptr = ();\n    type Fallible = Result<T, Trap>;\n\n    fn compatible_with_store(&self, store: &StoreOpaque) -> bool {\n        <Self as WasmTy>::compatible_with_store(self, store)\n    }\n\n    unsafe fn into_abi_for_ret(\n        self,\n        store: &mut StoreOpaque,\n        _retptr: (),\n    ) -> Result<Self::Abi, Trap> {\n        Ok(<Self as WasmTy>::into_abi(self, store))\n    }\n\n    fn func_type(params: impl Iterator<Item = ValType>) -> FuncType {\n        FuncType::new(params, Some(<Self as WasmTy>::valtype()))\n    }\n\n    unsafe fn wrap_trampoline(ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi) {\n        *ptr.cast::<Self::Abi>() = f(());\n    }\n\n    fn into_fallible(self) -> Result<T, Trap> {\n        Ok(self)\n    }\n\n    fn fallible_from_trap(trap: Trap) -> Result<T, Trap> {\n        Err(trap)\n    }\n}\n\nunsafe impl<T> WasmRet for Result<T, Trap>\nwhere\n    T: WasmRet,\n{\n    type Abi = <T as WasmRet>::Abi;\n    type Retptr = <T as WasmRet>::Retptr;\n    type Fallible = Self;\n\n    fn compatible_with_store(&self, store: &StoreOpaque) -> bool {\n        match self {\n            Ok(x) => <T as WasmRet>::compatible_with_store(x, store),\n            Err(_) => true,\n        }\n    }\n\n    unsafe fn into_abi_for_ret(\n        self,\n        store: &mut StoreOpaque,\n        retptr: Self::Retptr,\n    ) -> Result<Self::Abi, Trap> {\n        self.and_then(|val| val.into_abi_for_ret(store, retptr))\n    }\n\n    fn func_type(params: impl Iterator<Item = ValType>) -> FuncType {\n        T::func_type(params)\n    }\n\n    unsafe fn wrap_trampoline(ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi) {\n        T::wrap_trampoline(ptr, f)\n    }\n\n    fn into_fallible(self) -> Result<T, Trap> {\n        self\n    }\n\n    fn fallible_from_trap(trap: Trap) -> Result<T, Trap> {\n        Err(trap)\n    }\n}\n\nmacro_rules! impl_wasm_host_results {\n    ($n:tt $($t:ident)*) => (\n        #[allow(non_snake_case)]\n        unsafe impl<$($t),*> WasmRet for ($($t,)*)\n        where\n            $($t: WasmTy,)*\n            ($($t::Abi,)*): HostAbi,\n        {\n            type Abi = <($($t::Abi,)*) as HostAbi>::Abi;\n            type Retptr = <($($t::Abi,)*) as HostAbi>::Retptr;\n            type Fallible = Result<Self, Trap>;\n\n            #[inline]\n            fn compatible_with_store(&self, _store: &StoreOpaque) -> bool {\n                let ($($t,)*) = self;\n                $( $t.compatible_with_store(_store) && )* true\n            }\n\n            #[inline]\n            unsafe fn into_abi_for_ret(self, _store: &mut StoreOpaque, ptr: Self::Retptr) -> Result<Self::Abi, Trap> {\n                let ($($t,)*) = self;\n                let abi = ($($t.into_abi(_store),)*);\n                Ok(<($($t::Abi,)*) as HostAbi>::into_abi(abi, ptr))\n            }\n\n            fn func_type(params: impl Iterator<Item = ValType>) -> FuncType {\n                FuncType::new(\n                    params,\n                    std::array::IntoIter::new([$($t::valtype(),)*]),\n                )\n            }\n\n            #[allow(unused_assignments)]\n            unsafe fn wrap_trampoline(mut _ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi) {\n                let ($($t,)*) = <($($t::Abi,)*) as HostAbi>::call(f);\n                $(\n                    *_ptr.cast() = $t;\n                    _ptr = _ptr.add(1);\n                )*\n            }\n\n            #[inline]\n            fn into_fallible(self) -> Result<Self, Trap> {\n                Ok(self)\n            }\n\n            #[inline]\n            fn fallible_from_trap(trap: Trap) -> Result<Self, Trap> {\n                Err(trap)\n            }\n        }\n    )\n}\n\nfor_each_function_signature!(impl_wasm_host_results);\n\n// Internal trait representing how to communicate tuples of return values across\n// an ABI boundary. This internally corresponds to the \"wasmtime\" ABI inside of\n// cranelift itself. Notably the first element of each tuple is returned via the\n// typical system ABI (e.g. systemv or fastcall depending on platform) and all\n// other values are returned packed via the stack.\n//\n// This trait helps to encapsulate all the details of that.\n#[doc(hidden)]\npub trait HostAbi {\n    // A value returned from native functions which return `Self`\n    type Abi: Copy;\n    // A return pointer, added to the end of the argument list, for native\n    // functions that return `Self`. Note that a 0-sized type here should get\n    // elided at the ABI level.\n    type Retptr: Copy;\n\n    // Converts a value of `self` into its components. Stores necessary values\n    // into `ptr` and then returns whatever needs to be returned from the\n    // function.\n    unsafe fn into_abi(self, ptr: Self::Retptr) -> Self::Abi;\n\n    // Calls `f` with a suitably sized return area and requires `f` to return\n    // the raw abi value of the first element of our tuple. This will then\n    // unpack the `Retptr` and assemble it with `Self::Abi` to return an\n    // instance of the whole tuple.\n    unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self;\n}\n\nmacro_rules! impl_host_abi {\n    // Base case, everything is `()`\n    (0) => {\n        impl HostAbi for () {\n            type Abi = ();\n            type Retptr = ();\n\n            #[inline]\n            unsafe fn into_abi(self, _ptr: Self::Retptr) -> Self::Abi {}\n\n            #[inline]\n            unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self {\n                f(())\n            }\n        }\n    };\n\n    // In the 1-case the retptr is not present, so it's a 0-sized value.\n    (1 $a:ident) => {\n        impl<$a: Copy> HostAbi for ($a,) {\n            type Abi = $a;\n            type Retptr = ();\n\n            unsafe fn into_abi(self, _ptr: Self::Retptr) -> Self::Abi {\n                self.0\n            }\n\n            unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self {\n                (f(()),)\n            }\n        }\n    };\n\n    // This is where the more interesting case happens. The first element of the\n    // tuple is returned via `Abi` and all other elements are returned via\n    // `Retptr`. We create a `TupleRetNN` structure to represent all of the\n    // return values here.\n    //\n    // Also note that this isn't implemented for the old backend right now due\n    // to the original author not really being sure how to implement this in the\n    // old backend.\n    ($n:tt $t:ident $($u:ident)*) => {paste::paste!{\n        #[doc(hidden)]\n        #[allow(non_snake_case)]\n        #[repr(C)]\n        #[cfg(not(feature = \"old-x86-backend\"))]\n        pub struct [<TupleRet $n>]<$($u,)*> {\n            $($u: $u,)*\n        }\n\n        #[cfg(not(feature = \"old-x86-backend\"))]\n        #[allow(non_snake_case, unused_assignments)]\n        impl<$t: Copy, $($u: Copy,)*> HostAbi for ($t, $($u,)*) {\n            type Abi = $t;\n            type Retptr = *mut [<TupleRet $n>]<$($u,)*>;\n\n            unsafe fn into_abi(self, ptr: Self::Retptr) -> Self::Abi {\n                let ($t, $($u,)*) = self;\n                // Store the tail of our tuple into the return pointer...\n                $((*ptr).$u = $u;)*\n                // ... and return the head raw.\n                $t\n            }\n\n            unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self {\n                // Create space to store all the return values and then invoke\n                // the function.\n                let mut space = std::mem::MaybeUninit::uninit();\n                let t = f(space.as_mut_ptr());\n                let space = space.assume_init();\n\n                // Use the return value as the head of the tuple and unpack our\n                // return area to get the rest of the tuple.\n                (t, $(space.$u,)*)\n            }\n        }\n    }};\n}\n\nfor_each_function_signature!(impl_host_abi);\n\n/// Internal trait implemented for all arguments that can be passed to\n/// [`Func::wrap`] and [`Linker::func_wrap`](crate::Linker::func_wrap).\n///\n/// This trait should not be implemented by external users, it's only intended\n/// as an implementation detail of this crate.\npub trait IntoFunc<T, Params, Results>: Send + Sync + 'static {\n    #[doc(hidden)]\n    fn into_func(self, engine: &Engine) -> (InstanceHandle, VMTrampoline);\n}\n\n/// A structure representing the caller's context when creating a function\n/// via [`Func::wrap`].\n///\n/// This structure can be taken as the first parameter of a closure passed to\n/// [`Func::wrap`] or other constructors, and serves two purposes:\n///\n/// * First consumers can use [`Caller<'_, T>`](crate::Caller) to get access to\n///   [`StoreContextMut<'_, T>`](crate::StoreContextMut) and/or get access to\n///   `T` itself. This means that the [`Caller`] type can serve as a proxy to\n///   the original [`Store`](crate::Store) itself and is used to satisfy\n///   [`AsContext`] and [`AsContextMut`] bounds.\n///\n/// * Second a [`Caller`] can be used as the name implies, learning about the\n///   caller's context, namely it's exported memory and exported functions. This\n///   allows functions which take pointers as arguments to easily read the\n///   memory the pointers point into, or if a function is expected to call\n///   malloc in the wasm module to reserve space for the output you can do that.\n///\n/// Host functions which want access to [`Store`](crate::Store)-level state are\n/// recommended to use this type.\npub struct Caller<'a, T> {\n    pub(crate) store: StoreContextMut<'a, T>,\n    caller: &'a InstanceHandle,\n}\n\nimpl<T> Caller<'_, T> {\n    unsafe fn with<R>(caller: *mut VMContext, f: impl FnOnce(Caller<'_, T>) -> R) -> R {\n        assert!(!caller.is_null());\n        let instance = InstanceHandle::from_vmctx(caller);\n        let store = StoreContextMut::from_raw(instance.store());\n        f(Caller {\n            store,\n            caller: &instance,\n        })\n    }\n\n    fn sub_caller(&mut self) -> Caller<'_, T> {\n        Caller {\n            store: self.store.as_context_mut(),\n            caller: self.caller,\n        }\n    }\n\n    /// Looks up an export from the caller's module by the `name` given.\n    ///\n    /// Note that this function is only implemented for the `Extern::Memory`\n    /// and the `Extern::Func` types currently. No other exported structures\n    /// can be acquired through this method.\n    ///\n    /// Note that when accessing and calling exported functions, one should\n    /// adhere to the guidelines of the interface types proposal.  This method\n    /// is a temporary mechanism for accessing the caller's information until\n    /// interface types has been fully standardized and implemented. The\n    /// interface types proposal will obsolete this type and this will be\n    /// removed in the future at some point after interface types is\n    /// implemented. If you're relying on this method type it's recommended to\n    /// become familiar with interface types to ensure that your use case is\n    /// covered by the proposal.\n    ///\n    /// # Return\n    ///\n    /// If a memory or function export with the `name` provided was found, then it is\n    /// returned as a `Memory`. There are a number of situations, however, where\n    /// the memory or function may not be available:\n    ///\n    /// * The caller instance may not have an export named `name`\n    /// * The export named `name` may not be an exported memory\n    /// * There may not be a caller available, for example if `Func` was called\n    ///   directly from host code.\n    ///\n    /// It's recommended to take care when calling this API and gracefully\n    /// handling a `None` return value.\n    pub fn get_export(&mut self, name: &str) -> Option<Extern> {\n        // All instances created have a `host_state` with a pointer pointing\n        // back to themselves. If this caller doesn't have that `host_state`\n        // then it probably means it was a host-created object like `Func::new`\n        // which doesn't have any exports we want to return anyway.\n        match self\n            .caller\n            .host_state()\n            .downcast_ref::<Instance>()?\n            .get_export(&mut self.store, name)?\n        {\n            Extern::Func(f) => Some(Extern::Func(f)),\n            Extern::Memory(f) => Some(Extern::Memory(f)),\n            // Intentionally ignore other Extern items here since this API is\n            // supposed to be a temporary stop-gap until interface types.\n            _ => None,\n        }\n    }\n\n    /// Access the underlying data owned by this `Store`.\n    ///\n    /// Same as [`Store::data`](crate::Store::data)\n    pub fn data(&self) -> &T {\n        self.store.data()\n    }\n\n    /// Access the underlying data owned by this `Store`.\n    ///\n    /// Same as [`Store::data_mut`](crate::Store::data_mut)\n    pub fn data_mut(&mut self) -> &mut T {\n        self.store.data_mut()\n    }\n\n    /// Returns the underlying [`Engine`] this store is connected to.\n    pub fn engine(&self) -> &Engine {\n        self.store.engine()\n    }\n\n    /// Returns an [`InterruptHandle`] to interrupt wasm execution.\n    ///\n    /// See [`Store::interrupt_handle`](crate::Store::interrupt_handle) for more\n    /// information.\n    pub fn interrupt_handle(&self) -> Result<InterruptHandle> {\n        self.store.interrupt_handle()\n    }\n\n    /// Perform garbage collection of `ExternRef`s.\n    ///\n    /// Same as [`Store::gc`](crate::Store::gc).\n    pub fn gc(&mut self) {\n        self.store.gc()\n    }\n\n    /// Returns the fuel consumed by this store.\n    ///\n    /// For more information see [`Store::fuel_consumed`](crate::Store::fuel_consumed)\n    pub fn fuel_consumed(&self) -> Option<u64> {\n        self.store.fuel_consumed()\n    }\n\n    /// Inject more fuel into this store to be consumed when executing wasm code.\n    ///\n    /// For more information see [`Store::add_fuel`](crate::Store::add_fuel)\n    pub fn add_fuel(&mut self, fuel: u64) -> Result<()> {\n        self.store.add_fuel(fuel)\n    }\n\n    /// Synthetically consumes fuel from the store.\n    ///\n    /// For more information see [`Store::consume_fuel`](crate::Store::consume_fuel)\n    pub fn consume_fuel(&mut self, fuel: u64) -> Result<u64> {\n        self.store.consume_fuel(fuel)\n    }\n\n    /// Configures this `Store` to trap whenever fuel runs out.\n    ///\n    /// For more information see\n    /// [`Store::out_of_fuel_trap`](crate::Store::out_of_fuel_trap)\n    pub fn out_of_fuel_trap(&mut self) {\n        self.store.out_of_fuel_trap()\n    }\n\n    /// Configures this `Store` to yield while executing futures whenever fuel\n    /// runs out.\n    ///\n    /// For more information see\n    /// [`Store::out_of_fuel_async_yield`](crate::Store::out_of_fuel_async_yield)\n    pub fn out_of_fuel_async_yield(&mut self, injection_count: u64, fuel_to_inject: u64) {\n        self.store\n            .out_of_fuel_async_yield(injection_count, fuel_to_inject)\n    }\n}\n\nimpl<T> AsContext for Caller<'_, T> {\n    type Data = T;\n    fn as_context(&self) -> StoreContext<'_, T> {\n        self.store.as_context()\n    }\n}\n\nimpl<T> AsContextMut for Caller<'_, T> {\n    fn as_context_mut(&mut self) -> StoreContextMut<'_, T> {\n        self.store.as_context_mut()\n    }\n}\n\nfn cross_store_trap() -> Box<dyn Error + Send + Sync> {\n    #[derive(Debug)]\n    struct CrossStoreError;\n\n    impl Error for CrossStoreError {}\n\n    impl fmt::Display for CrossStoreError {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(\n                f,\n                \"host function attempted to return cross-`Store` \\\n                 value to Wasm\",\n            )\n        }\n    }\n\n    Box::new(CrossStoreError)\n}\n\nmacro_rules! impl_into_func {\n    ($num:tt $($args:ident)*) => {\n        // Implement for functions without a leading `&Caller` parameter,\n        // delegating to the implementation below which does have the leading\n        // `Caller` parameter.\n        #[allow(non_snake_case)]\n        impl<T, F, $($args,)* R> IntoFunc<T, ($($args,)*), R> for F\n        where\n            F: Fn($($args),*) -> R + Send + Sync + 'static,\n            $($args: WasmTy,)*\n            R: WasmRet,\n        {\n            fn into_func(self, engine: &Engine) -> (InstanceHandle, VMTrampoline) {\n                let f = move |_: Caller<'_, T>, $($args:$args),*| {\n                    self($($args),*)\n                };\n\n                f.into_func(engine)\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<T, F, $($args,)* R> IntoFunc<T, (Caller<'_, T>, $($args,)*), R> for F\n        where\n            F: Fn(Caller<'_, T>, $($args),*) -> R + Send + Sync + 'static,\n            $($args: WasmTy,)*\n            R: WasmRet,\n        {\n            fn into_func(self, engine: &Engine) -> (InstanceHandle, VMTrampoline) {\n                /// This shim is called by Wasm code, constructs a `Caller`,\n                /// calls the wrapped host function, and returns the translated\n                /// result back to Wasm.\n                ///\n                /// Note that this shim's ABI must *exactly* match that expected\n                /// by Cranelift, since Cranelift is generating raw function\n                /// calls directly to this function.\n                unsafe extern \"C\" fn wasm_to_host_shim<T, F, $($args,)* R>(\n                    vmctx: *mut VMContext,\n                    caller_vmctx: *mut VMContext,\n                    $( $args: $args::Abi, )*\n                    retptr: R::Retptr,\n                ) -> R::Abi\n                where\n                    F: Fn(Caller<'_, T>, $( $args ),*) -> R + 'static,\n                    $( $args: WasmTy, )*\n                    R: WasmRet,\n                {\n                    enum CallResult<U> {\n                        Ok(U),\n                        Trap(Box<dyn Error + Send + Sync>),\n                        Panic(Box<dyn std::any::Any + Send>),\n                    }\n\n                    // Note that this `result` is intentionally scoped into a\n                    // separate block. Handling traps and panics will involve\n                    // longjmp-ing from this function which means we won't run\n                    // destructors. As a result anything requiring a destructor\n                    // should be part of this block, and the long-jmp-ing\n                    // happens after the block in handling `CallResult`.\n                    let result = Caller::with(caller_vmctx, |mut caller| {\n                        let state = (*vmctx).host_state();\n                        // Double-check ourselves in debug mode, but we control\n                        // the `Any` here so an unsafe downcast should also\n                        // work.\n                        debug_assert!(state.is::<F>());\n                        let func = &*(state as *const _ as *const F);\n\n                        let ret = {\n                            panic::catch_unwind(AssertUnwindSafe(|| {\n                                if let Err(trap) = caller.store.0.call_hook(CallHook::CallingHost) {\n                                    return R::fallible_from_trap(trap);\n                                }\n                                $(let $args = $args::from_abi($args, caller.store.0);)*\n                                let r = func(\n                                    caller.sub_caller(),\n                                    $( $args, )*\n                                );\n                                if let Err(trap) = caller.store.0.call_hook(CallHook::ReturningFromHost) {\n                                    return R::fallible_from_trap(trap);\n                                }\n                                r.into_fallible()\n                            }))\n                        };\n\n                        // Note that we need to be careful when dealing with traps\n                        // here. Traps are implemented with longjmp/setjmp meaning\n                        // that it's not unwinding and consequently no Rust\n                        // destructors are run. We need to be careful to ensure that\n                        // nothing on the stack needs a destructor when we exit\n                        // abnormally from this `match`, e.g. on `Err`, on\n                        // cross-store-issues, or if `Ok(Err)` is raised.\n                        match ret {\n                            Err(panic) => CallResult::Panic(panic),\n                            Ok(ret) => {\n                                // Because the wrapped function is not `unsafe`, we\n                                // can't assume it returned a value that is\n                                // compatible with this store.\n                                if !ret.compatible_with_store(caller.store.0) {\n                                    CallResult::Trap(cross_store_trap())\n                                } else {\n                                    match ret.into_abi_for_ret(caller.store.0, retptr) {\n                                        Ok(val) => CallResult::Ok(val),\n                                        Err(trap) => CallResult::Trap(trap.into()),\n                                    }\n                                }\n\n                            }\n                        }\n                    });\n\n                    match result {\n                        CallResult::Ok(val) => val,\n                        CallResult::Trap(trap) => raise_user_trap(trap),\n                        CallResult::Panic(panic) => wasmtime_runtime::resume_panic(panic),\n                    }\n                }\n\n                /// This trampoline allows host code to indirectly call the\n                /// wrapped function (e.g. via `Func::call` on a `funcref` that\n                /// happens to reference our wrapped function).\n                ///\n                /// It reads the arguments out of the incoming `args` array,\n                /// calls the given function pointer, and then stores the result\n                /// back into the `args` array.\n                unsafe extern \"C\" fn host_trampoline<$($args,)* R>(\n                    callee_vmctx: *mut VMContext,\n                    caller_vmctx: *mut VMContext,\n                    ptr: *const VMFunctionBody,\n                    args: *mut u128,\n                )\n                where\n                    $($args: WasmTy,)*\n                    R: WasmRet,\n                {\n                    let ptr = mem::transmute::<\n                        *const VMFunctionBody,\n                        unsafe extern \"C\" fn(\n                            *mut VMContext,\n                            *mut VMContext,\n                            $( $args::Abi, )*\n                            R::Retptr,\n                        ) -> R::Abi,\n                    >(ptr);\n\n                    let mut _n = 0;\n                    $(\n                        let $args = *args.add(_n).cast::<$args::Abi>();\n                        _n += 1;\n                    )*\n                    R::wrap_trampoline(args, |retptr| {\n                        ptr(callee_vmctx, caller_vmctx, $( $args, )* retptr)\n                    });\n                }\n\n                let ty = R::func_type(\n                    None::<ValType>.into_iter()\n                        $(.chain(Some($args::valtype())))*\n                );\n\n                let shared_signature_id = engine.signatures().register(ty.as_wasm_func_type());\n\n                let trampoline = host_trampoline::<$($args,)* R>;\n\n\n                let instance = unsafe {\n                    crate::trampoline::create_raw_function(\n                        std::slice::from_raw_parts_mut(\n                            wasm_to_host_shim::<T, F, $($args,)* R> as *mut _,\n                            0,\n                        ),\n                        shared_signature_id,\n                        Box::new(self),\n                    )\n                    .expect(\"failed to create raw function\")\n                };\n\n                (instance, trampoline)\n            }\n        }\n    }\n}\n\nfor_each_function_signature!(impl_into_func);\n\n/// Representation of a host-defined function.\n///\n/// This is used for `Func::new` but also for `Linker`-defined functions. For\n/// `Func::new` this is stored within a `Store`, and for `Linker`-defined\n/// functions they wrap this up in `Arc` to enable shared ownership of this\n/// across many stores.\n///\n/// Technically this structure needs a `<T>` type parameter to connect to the\n/// `Store<T>` itself, but that's an unsafe contract of using this for now\n/// rather than part of the struct type (to avoid `Func<T>` in the API).\npub(crate) struct HostFunc {\n    // Owned `*mut VMContext` allocation. Deallocated when this `HostFunc` is\n    // dropped.\n    instance: InstanceHandle,\n    // Trampoline to enter this function from Rust.\n    trampoline: VMTrampoline,\n    // The loaded `ExportFunction` from the above `InstanceHandle` which has raw\n    // pointers and information about how to actually call this function (e.g.\n    // the actual address in JIT code and the vm shared function index).\n    export: ExportFunction,\n    // Stored to unregister this function's signature with the engine when this\n    // is dropped.\n    engine: Engine,\n}\n\nimpl HostFunc {\n    /// Analog of [`Func::new`]\n    #[cfg(compiler)]\n    pub fn new<T>(\n        engine: &Engine,\n        ty: FuncType,\n        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,\n    ) -> Self {\n        let ty_clone = ty.clone();\n\n        // Create a trampoline that converts raw u128 values to `Val`\n        let func = move |caller_vmctx, values_vec: *mut u128| unsafe {\n            Caller::with(caller_vmctx, |caller| {\n                Func::invoke(caller, &ty_clone, values_vec, &func)\n            })\n        };\n\n        let (instance, trampoline) = crate::trampoline::create_function(&ty, func, engine)\n            .expect(\"failed to create function\");\n        HostFunc::_new(engine, instance, trampoline)\n    }\n\n    /// Analog of [`Func::wrap`]\n    pub fn wrap<T, Params, Results>(\n        engine: &Engine,\n        func: impl IntoFunc<T, Params, Results>,\n    ) -> Self {\n        let (instance, trampoline) = func.into_func(engine);\n        HostFunc::_new(engine, instance, trampoline)\n    }\n\n    /// Requires that this function's signature is already registered within\n    /// `Engine`. This happens automatically during the above two constructors.\n    fn _new(engine: &Engine, instance: InstanceHandle, trampoline: VMTrampoline) -> Self {\n        let idx = EntityIndex::Function(FuncIndex::from_u32(0));\n        let export = match instance.lookup_by_declaration(&idx) {\n            wasmtime_runtime::Export::Function(f) => f,\n            _ => unreachable!(),\n        };\n\n        HostFunc {\n            instance,\n            trampoline,\n            export,\n            engine: engine.clone(),\n        }\n    }\n\n    /// Inserts this `HostFunc` into a `Store`, returning the `Func` pointing to\n    /// it.\n    ///\n    /// # Unsafety\n    ///\n    /// Can only be inserted into stores with a matching `T` relative to when\n    /// this `HostFunc` was first created.\n    pub unsafe fn to_func(self: &Arc<Self>, store: &mut StoreOpaque) -> Func {\n        self.register_trampoline(store);\n        let me = self.clone();\n        Func(store.store_data_mut().insert(FuncData::SharedHost(me)))\n    }\n\n    /// Same as [`HostFunc::to_func`], different ownership.\n    unsafe fn into_func(self, store: &mut StoreOpaque) -> Func {\n        self.register_trampoline(store);\n        Func(store.store_data_mut().insert(FuncData::Host(self)))\n    }\n\n    unsafe fn register_trampoline(&self, store: &mut StoreOpaque) {\n        let idx = self.export.anyfunc.as_ref().type_index;\n        store.register_host_trampoline(idx, self.trampoline);\n    }\n\n    pub(crate) fn sig_index(&self) -> VMSharedSignatureIndex {\n        unsafe { self.export.anyfunc.as_ref().type_index }\n    }\n}\n\nimpl Drop for HostFunc {\n    fn drop(&mut self) {\n        unsafe {\n            self.engine\n                .signatures()\n                .unregister(self.export.anyfunc.as_ref().type_index);\n\n            // Host functions are always allocated with the default (on-demand)\n            // allocator\n            OnDemandInstanceAllocator::default().deallocate(&self.instance);\n        }\n    }\n}\n\nimpl FuncData {\n    fn trampoline(&self) -> VMTrampoline {\n        match self {\n            FuncData::StoreOwned { trampoline, .. } => *trampoline,\n            FuncData::SharedHost(host) => host.trampoline,\n            FuncData::Host(host) => host.trampoline,\n        }\n    }\n\n    #[inline]\n    fn export(&self) -> &ExportFunction {\n        match self {\n            FuncData::StoreOwned { export, .. } => export,\n            FuncData::SharedHost(host) => &host.export,\n            FuncData::Host(host) => &host.export,\n        }\n    }\n}\n", "use crate::linker::Definition;\nuse crate::signatures::SignatureCollection;\nuse crate::store::{InstanceId, StoreData, StoreOpaque, Stored};\nuse crate::types::matching;\nuse crate::{\n    AsContext, AsContextMut, Engine, Export, Extern, ExternType, Func, Global, InstanceType,\n    Memory, Module, StoreContextMut, Table, Trap, TypedFunc,\n};\nuse anyhow::{anyhow, bail, Context, Error, Result};\nuse std::mem;\nuse std::sync::Arc;\nuse wasmtime_environ::{\n    EntityIndex, EntityType, FuncIndex, GlobalIndex, Initializer, InstanceIndex, MemoryIndex,\n    ModuleIndex, PrimaryMap, TableIndex,\n};\nuse wasmtime_jit::TypeTables;\nuse wasmtime_runtime::{\n    Imports, InstanceAllocationRequest, InstantiationError, VMContext, VMFunctionBody,\n    VMFunctionImport, VMGlobalImport, VMMemoryImport, VMTableImport,\n};\n\n/// An instantiated WebAssembly module.\n///\n/// This type represents the instantiation of a [`Module`]. Once instantiated\n/// you can access the [`exports`](Instance::exports) which are of type\n/// [`Extern`] and provide the ability to call functions, set globals, read\n/// memory, etc. When interacting with any wasm code you'll want to make an\n/// [`Instance`] to call any code or execute anything.\n///\n/// Instances are owned by a [`Store`](crate::Store) which is passed in at\n/// creation time. It's recommended to create instances with\n/// [`Linker::instantiate`](crate::Linker::instantiate) or similar\n/// [`Linker`](crate::Linker) methods, but a more low-level constructor is also\n/// available as [`Instance::new`].\n#[derive(Copy, Clone, Debug)]\n#[repr(transparent)]\npub struct Instance(Stored<InstanceData>);\n\npub(crate) enum InstanceData {\n    /// This variant is used for instances created through instantiation of a\n    /// module, e.g. `Instance::new` or various linker methods.\n    Instantiated {\n        /// The id of the instance within the store, used to find the original\n        /// `InstanceHandle`.\n        id: InstanceId,\n        /// A lazily-populated list of exports of this instance. The order of\n        /// exports here matches the order of the exports in the the original\n        /// module.\n        exports: Vec<Option<Extern>>,\n        /// The type information of the module that this was instantiated with.\n        types: Arc<TypeTables>,\n        signatures: Arc<SignatureCollection>,\n    },\n\n    /// This variant is used for synthetically created instances via `Linker`\n    /// APIs. This is only used for the module linking proposal at this time.\n    Synthetic(Arc<indexmap::IndexMap<String, Extern>>),\n}\n\nimpl Instance {\n    /// Creates a new [`Instance`] from the previously compiled [`Module`] and\n    /// list of `imports` specified.\n    ///\n    /// This method instantiates the `module` provided with the `imports`,\n    /// following the procedure in the [core specification][inst] to\n    /// instantiate. Instantiation can fail for a number of reasons (many\n    /// specified below), but if successful the `start` function will be\n    /// automatically run (if specified in the `module`) and then the\n    /// [`Instance`] will be returned.\n    ///\n    /// Per the WebAssembly spec, instantiation includes running the module's\n    /// start function, if it has one (not to be confused with the `_start`\n    /// function, which is not run).\n    ///\n    /// Note that this is a low-level function that just performs an\n    /// instantiation. See the [`Linker`](crate::Linker) struct for an API which\n    /// provides a convenient way to link imports and provides automatic Command\n    /// and Reactor behavior.\n    ///\n    /// ## Providing Imports\n    ///\n    /// The entries in the list of `imports` are intended to correspond 1:1\n    /// with the list of imports returned by [`Module::imports`]. Before\n    /// calling [`Instance::new`] you'll want to inspect the return value of\n    /// [`Module::imports`] and, for each import type, create an [`Extern`]\n    /// which corresponds to that type.  These [`Extern`] values are all then\n    /// collected into a list and passed to this function.\n    ///\n    /// Note that this function is intentionally relatively low level. For an\n    /// easier time passing imports by doing name-based resolution it's\n    /// recommended to instead use the [`Linker`](crate::Linker) type.\n    ///\n    /// ## Errors\n    ///\n    /// This function can fail for a number of reasons, including, but not\n    /// limited to:\n    ///\n    /// * The number of `imports` provided doesn't match the number of imports\n    ///   returned by the `module`'s [`Module::imports`] method.\n    /// * The type of any [`Extern`] doesn't match the corresponding\n    ///   [`ExternType`] entry that it maps to.\n    /// * The `start` function in the instance, if present, traps.\n    /// * Module/instance resource limits are exceeded.\n    ///\n    /// When instantiation fails it's recommended to inspect the return value to\n    /// see why it failed, or bubble it upwards. If you'd like to specifically\n    /// check for trap errors, you can use `error.downcast::<Trap>()`.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if called with a store associated with a\n    /// [`asynchronous config`](crate::Config::async_support). This function\n    /// will also panic if any [`Extern`] supplied is not owned by `store`.\n    ///\n    /// [inst]: https://webassembly.github.io/spec/core/exec/modules.html#exec-instantiation\n    /// [`ExternType`]: crate::ExternType\n    pub fn new(\n        mut store: impl AsContextMut,\n        module: &Module,\n        imports: &[Extern],\n    ) -> Result<Instance, Error> {\n        // This unsafety comes from `Instantiator::new` where we must typecheck\n        // first, which we are sure to do here.\n        let mut store = store.as_context_mut();\n        let mut i = unsafe {\n            typecheck_externs(store.0, module, imports)?;\n            Instantiator::new(store.0, module, ImportSource::Externs(imports))?\n        };\n        i.run(&mut store)\n    }\n\n    /// Same as [`Instance::new`], except for usage in [asynchronous stores].\n    ///\n    /// For more details about this function see the documentation on\n    /// [`Instance::new`]. The only difference between these two methods is that\n    /// this one will asynchronously invoke the wasm start function in case it\n    /// calls any imported function which is an asynchronous host function (e.g.\n    /// created with [`Func::new_async`](crate::Func::new_async).\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if called with a store associated with a\n    /// [`synchronous config`](crate::Config::new). This is only compatible with\n    /// stores associated with an [`asynchronous\n    /// config`](crate::Config::async_support).\n    ///\n    /// This function will also panic, like [`Instance::new`], if any [`Extern`]\n    /// specified does not belong to `store`.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn new_async<T>(\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n        imports: &[Extern],\n    ) -> Result<Instance, Error>\n    where\n        T: Send,\n    {\n        // See `new` for unsafety comments\n        let mut store = store.as_context_mut();\n        let mut i = unsafe {\n            typecheck_externs(store.0, module, imports)?;\n            Instantiator::new(store.0, module, ImportSource::Externs(imports))?\n        };\n        i.run_async(&mut store).await\n    }\n\n    pub(crate) fn from_wasmtime(handle: InstanceData, store: &mut StoreOpaque) -> Instance {\n        Instance(store.store_data_mut().insert(handle))\n    }\n\n    /// Returns the type signature of this instance.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn ty(&self, store: impl AsContext) -> InstanceType {\n        let store = store.as_context();\n        let mut ty = InstanceType::new();\n        match &store[self.0] {\n            InstanceData::Synthetic(items) => {\n                for (name, item) in items.iter() {\n                    ty.add_named_export(name, item.ty(&store));\n                }\n            }\n            InstanceData::Instantiated { id, types, .. } => {\n                let module = store.0.instance(*id).module();\n                for (name, idx) in module.exports.iter() {\n                    let export_ty = module.type_of(*idx);\n                    ty.add_named_export(name, ExternType::from_wasmtime(types, &export_ty));\n                }\n            }\n        }\n        ty\n    }\n\n    pub(crate) fn data<'a>(&self, store: &'a StoreData) -> &'a InstanceData {\n        &store[self.0]\n    }\n\n    pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {\n        store.store_data().contains(self.0)\n    }\n\n    /// Returns the list of exported items from this [`Instance`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn exports<'a, T: 'a>(\n        &'a self,\n        store: impl Into<StoreContextMut<'a, T>>,\n    ) -> impl ExactSizeIterator<Item = Export<'a>> + 'a {\n        self._exports(store.into().0)\n    }\n\n    fn _exports<'a>(\n        &'a self,\n        store: &'a mut StoreOpaque,\n    ) -> impl ExactSizeIterator<Item = Export<'a>> + 'a {\n        // If this is an `Instantiated` instance then all the `exports` may not\n        // be filled in. Fill them all in now if that's the case.\n        if let InstanceData::Instantiated { exports, id, .. } = &store[self.0] {\n            if exports.iter().any(|e| e.is_none()) {\n                let module = Arc::clone(store.instance(*id).module());\n                for name in module.exports.keys() {\n                    self._get_export(store, name);\n                }\n            }\n        }\n\n        return match &store.store_data()[self.0] {\n            InstanceData::Synthetic(names) => {\n                Either::A(names.iter().map(|(k, v)| Export::new(k, v.clone())))\n            }\n            InstanceData::Instantiated { exports, id, .. } => {\n                let module = store.instance(*id).module();\n                Either::B(\n                    module\n                        .exports\n                        .iter()\n                        .zip(exports)\n                        .map(|((name, _), export)| Export::new(name, export.clone().unwrap())),\n                )\n            }\n        };\n\n        enum Either<A, B> {\n            A(A),\n            B(B),\n        }\n\n        impl<A, B> Iterator for Either<A, B>\n        where\n            A: Iterator,\n            B: Iterator<Item = A::Item>,\n        {\n            type Item = A::Item;\n\n            fn next(&mut self) -> Option<A::Item> {\n                match self {\n                    Either::A(a) => a.next(),\n                    Either::B(b) => b.next(),\n                }\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                match self {\n                    Either::A(a) => a.size_hint(),\n                    Either::B(b) => b.size_hint(),\n                }\n            }\n        }\n\n        impl<A, B> ExactSizeIterator for Either<A, B>\n        where\n            A: ExactSizeIterator,\n            B: ExactSizeIterator<Item = A::Item>,\n        {\n            fn len(&self) -> usize {\n                match self {\n                    Either::A(a) => a.len(),\n                    Either::B(b) => b.len(),\n                }\n            }\n        }\n    }\n\n    /// Looks up an exported [`Extern`] value by name.\n    ///\n    /// This method will search the module for an export named `name` and return\n    /// the value, if found.\n    ///\n    /// Returns `None` if there was no export named `name`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    ///\n    /// # Why does `get_export` take a mutable context?\n    ///\n    /// This method requires a mutable context because an instance's exports are\n    /// lazily populated, and we cache them as they are accessed. This makes\n    /// instantiating a module faster, but also means this method requires a\n    /// mutable context.\n    pub fn get_export(&self, mut store: impl AsContextMut, name: &str) -> Option<Extern> {\n        self._get_export(store.as_context_mut().0, name)\n    }\n\n    fn _get_export(&self, store: &mut StoreOpaque, name: &str) -> Option<Extern> {\n        match &store[self.0] {\n            // Synthetic instances always have their entire list of exports\n            // already specified.\n            InstanceData::Synthetic(names) => names.get(name).cloned(),\n\n            // Instantiated instances will lazily fill in exports, so we process\n            // all that lazy logic here.\n            InstanceData::Instantiated { id, exports, .. } => {\n                let instance = store.instance(*id);\n                let (i, _, index) = instance.module().exports.get_full(name)?;\n                if let Some(export) = &exports[i] {\n                    return Some(export.clone());\n                }\n                let item = unsafe {\n                    Extern::from_wasmtime_export(instance.lookup_by_declaration(index), store)\n                };\n                let exports = match &mut store[self.0] {\n                    InstanceData::Instantiated { exports, .. } => exports,\n                    _ => unreachable!(),\n                };\n                exports[i] = Some(item.clone());\n                Some(item)\n            }\n        }\n    }\n\n    /// Looks up an exported [`Func`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a function.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_func(&self, store: impl AsContextMut, name: &str) -> Option<Func> {\n        self.get_export(store, name)?.into_func()\n    }\n\n    /// Looks up an exported [`Func`] value by name and with its type.\n    ///\n    /// This function is a convenience wrapper over [`Instance::get_func`] and\n    /// [`Func::typed`]. For more information see the linked documentation.\n    ///\n    /// Returns an error if `name` isn't a function export or if the export's\n    /// type did not match `Params` or `Results`\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_typed_func<Params, Results, S>(\n        &self,\n        mut store: S,\n        name: &str,\n    ) -> Result<TypedFunc<Params, Results>>\n    where\n        Params: crate::WasmParams,\n        Results: crate::WasmResults,\n        S: AsContextMut,\n    {\n        let f = self\n            .get_export(store.as_context_mut(), name)\n            .and_then(|f| f.into_func())\n            .ok_or_else(|| anyhow!(\"failed to find function export `{}`\", name))?;\n        Ok(f.typed::<Params, Results, _>(store)\n            .with_context(|| format!(\"failed to convert function `{}` to given type\", name))?)\n    }\n\n    /// Looks up an exported [`Table`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a table.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_table(&self, store: impl AsContextMut, name: &str) -> Option<Table> {\n        self.get_export(store, name)?.into_table()\n    }\n\n    /// Looks up an exported [`Memory`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a memory.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_memory(&self, store: impl AsContextMut, name: &str) -> Option<Memory> {\n        self.get_export(store, name)?.into_memory()\n    }\n\n    /// Looks up an exported [`Global`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a global.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_global(&self, store: impl AsContextMut, name: &str) -> Option<Global> {\n        self.get_export(store, name)?.into_global()\n    }\n}\n\nstruct Instantiator<'a> {\n    in_progress: Vec<ImportsBuilder<'a>>,\n    cur: ImportsBuilder<'a>,\n}\n\nstruct ImportsBuilder<'a> {\n    src: ImportSource<'a>,\n    functions: PrimaryMap<FuncIndex, VMFunctionImport>,\n    tables: PrimaryMap<TableIndex, VMTableImport>,\n    memories: PrimaryMap<MemoryIndex, VMMemoryImport>,\n    globals: PrimaryMap<GlobalIndex, VMGlobalImport>,\n    instances: PrimaryMap<InstanceIndex, Instance>,\n    modules: PrimaryMap<ModuleIndex, Module>,\n    initializer: usize,\n    module: Module,\n}\n\nenum ImportSource<'a> {\n    Externs(&'a [Extern]),\n    Definitions(&'a [Definition]),\n    Outer { initializer: usize },\n}\n\nimpl<'a> Instantiator<'a> {\n    /// Creates a new instantiation context used to process all the initializer\n    /// directives of a module.\n    ///\n    /// This doesn't do much work itself beyond setting things up.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe for a few reasons:\n    ///\n    /// * This assumes that `imports` has already been typechecked and is of the\n    ///   appropriate length. It is memory unsafe if the types of `imports` are\n    ///   not what `module` expects.\n    ///\n    /// * The `imports` must be safely able to get inserted into `store`. This\n    ///   only applies if `ImportSource::Definitions` is used because this will\n    ///   internally call `Definition::to_extern` which requires that any\n    ///   host functions in the list were created with an original `T` as the\n    ///   store that's being inserted into.\n    ///\n    /// * The `imports` must all come from the `store` specified.\n    unsafe fn new(\n        store: &StoreOpaque,\n        module: &Module,\n        imports: ImportSource<'a>,\n    ) -> Result<Instantiator<'a>> {\n        if !Engine::same(store.engine(), module.engine()) {\n            bail!(\"cross-`Engine` instantiation is not currently supported\");\n        }\n\n        Ok(Instantiator {\n            in_progress: Vec::new(),\n            cur: ImportsBuilder::new(module, imports),\n        })\n    }\n\n    fn run<T>(&mut self, store: &mut StoreContextMut<'_, T>) -> Result<Instance, Error> {\n        assert!(\n            !store.0.async_support(),\n            \"cannot use `new` when async support is enabled on the config\"\n        );\n\n        // NB: this is the same code as `run_async`. It's intentionally\n        // small but should be kept in sync (modulo the async bits).\n        loop {\n            if let Some((instance, start, toplevel)) = self.step(store.0)? {\n                if let Some(start) = start {\n                    Instantiator::start_raw(store, instance, start)?;\n                }\n                if toplevel {\n                    break Ok(instance);\n                }\n            }\n        }\n    }\n\n    #[cfg(feature = \"async\")]\n    async fn run_async<T>(&mut self, store: &mut StoreContextMut<'_, T>) -> Result<Instance, Error>\n    where\n        T: Send,\n    {\n        assert!(\n            store.0.async_support(),\n            \"cannot use `new_async` without enabling async support on the config\"\n        );\n\n        // NB: this is the same code as `run`. It's intentionally\n        // small but should be kept in sync (modulo the async bits).\n        loop {\n            let step = self.step(store.0)?;\n            if let Some((instance, start, toplevel)) = step {\n                if let Some(start) = start {\n                    store\n                        .on_fiber(|store| Instantiator::start_raw(store, instance, start))\n                        .await??;\n                }\n                if toplevel {\n                    break Ok(instance);\n                }\n            }\n        }\n    }\n\n    /// Processes the next initializer for the next instance being created\n    /// without running any wasm code.\n    ///\n    /// This function will process module initializers, handling recursive\n    /// instantiations of modules for module linking if necessary as well. This\n    /// does not actually execute any WebAssembly code, which means that it\n    /// will return whenever an instance is created (because its `start`\n    /// function may need to be executed).\n    ///\n    /// If this function returns `None`, then it simply needs to be called\n    /// again to execute the next initializer. Otherwise this function has two\n    /// return values:\n    ///\n    /// * The first is the raw handle to the instance that was just created.\n    ///   This instance must have its start function executed by the caller.\n    /// * The second is an optional list of items to get wrapped up in an\n    ///   `Instance`. This is only `Some` for the outermost instance that was\n    ///   created. If this is `None` callers need to keep calling this function\n    ///   since the instance created was simply for a recursive instance\n    ///   defined here.\n    fn step(\n        &mut self,\n        store: &mut StoreOpaque,\n    ) -> Result<Option<(Instance, Option<FuncIndex>, bool)>> {\n        if self.cur.initializer == 0 {\n            store.bump_resource_counts(&self.cur.module)?;\n        }\n\n        // Read the current module's initializer and move forward the\n        // initializer pointer as well.\n        self.cur.initializer += 1;\n        match self\n            .cur\n            .module\n            .env_module()\n            .initializers\n            .get(self.cur.initializer - 1)\n        {\n            Some(Initializer::Import { name, field, .. }) => {\n                match &mut self.cur.src {\n                    // If imports are coming from the runtime-provided list\n                    // (e.g. the root module being instantiated) then we\n                    // need to typecheck each item here before recording it.\n                    //\n                    // Note the `unwrap` here should be ok given the validation\n                    // above in `Instantiation::new`.\n                    ImportSource::Externs(list) => {\n                        let (head, remaining) = list.split_first().unwrap();\n                        *list = remaining;\n                        self.cur.push(head.clone(), store);\n                    }\n                    ImportSource::Definitions(list) => {\n                        let (head, remaining) = list.split_first().unwrap();\n                        *list = remaining;\n                        // This unsafety is encapsulated with\n                        // `Instantiator::new`, documented above.\n                        self.cur.push(unsafe { head.to_extern(store) }, store);\n                    }\n\n                    // Otherwise if arguments are coming from our outer\n                    // instance due to a recursive instantiation then we\n                    // look in the previous initializer's mapping of\n                    // arguments to figure out where to load the item from.\n                    // Note that no typechecking is necessary here due to\n                    // validation.\n                    ImportSource::Outer { initializer } => {\n                        debug_assert!(field.is_none());\n                        let outer = self.in_progress.last().unwrap();\n                        let args = match &outer.module.env_module().initializers[*initializer] {\n                            Initializer::Instantiate { args, .. } => args,\n                            _ => unreachable!(),\n                        };\n                        let index = args.get(name).expect(\"should be present after validation\");\n                        match *index {\n                            EntityIndex::Global(i) => {\n                                self.cur.globals.push(outer.globals[i]);\n                            }\n                            EntityIndex::Function(i) => {\n                                self.cur.functions.push(outer.functions[i]);\n                            }\n                            EntityIndex::Table(i) => {\n                                self.cur.tables.push(outer.tables[i]);\n                            }\n                            EntityIndex::Memory(i) => {\n                                self.cur.memories.push(outer.memories[i]);\n                            }\n                            EntityIndex::Module(i) => {\n                                self.cur.modules.push(outer.modules[i].clone());\n                            }\n                            EntityIndex::Instance(i) => {\n                                self.cur.instances.push(outer.instances[i].clone());\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Here we lookup our instance handle, find the right export,\n            // and then push that item into our own index space. We eschew\n            // type-checking since only valid modules should reach this point.\n            Some(Initializer::AliasInstanceExport { instance, export }) => {\n                let instance = self.cur.instances[*instance];\n                let export = instance._get_export(store, export).unwrap();\n                self.cur.push(export, store);\n            }\n\n            // A recursive instantiation of an instance.\n            //\n            // The `module` argument is used to create an import builder\n            // object, and we specify that the source of imports for the builder is\n            // this initializer's position so we can look at the `args` payload\n            // later.\n            //\n            // Once that's set up we save off `self.cur` into\n            // `self.in_progress` and start the instantiation of the child\n            // instance on the next execution of this function.\n            Some(Initializer::Instantiate { module, args: _ }) => {\n                let module = &self.cur.modules[*module];\n                let imports = ImportsBuilder::new(\n                    module,\n                    ImportSource::Outer {\n                        initializer: self.cur.initializer - 1,\n                    },\n                );\n                let prev = mem::replace(&mut self.cur, imports);\n                self.in_progress.push(prev);\n            }\n\n            // A new module is being defined, and the source of this module is\n            // our module's list of closed-over-modules.\n            //\n            // This is used for outer aliases.\n            Some(Initializer::DefineModule(upvar_index)) => {\n                self.cur\n                    .modules\n                    .push(self.cur.module.module_upvar(*upvar_index).clone());\n            }\n\n            // A new module is defined, created from a set of compiled\n            // artifacts. The new module value will be created with the\n            // specified artifacts being closed over as well as the specified\n            // set of module values in our index/upvar index spaces being closed\n            // over.\n            //\n            // This is used for defining submodules.\n            Some(Initializer::CreateModule {\n                artifact_index,\n                artifacts,\n                modules,\n            }) => {\n                let submodule = self.cur.module.create_submodule(\n                    *artifact_index,\n                    artifacts,\n                    modules,\n                    &self.cur.modules,\n                );\n                self.cur.modules.push(submodule);\n            }\n\n            // All initializers have been processed, which means we're ready to\n            // perform the actual raw instantiation with the raw import values.\n            // Once that's done if there's an in-progress module we record the\n            // instance in the index space. Otherwise this is the final module\n            // and we return the items out.\n            //\n            // Note that in all cases we return the raw instance handle to get\n            // the start function executed by the outer context.\n            None => {\n                let (instance, start) = self.instantiate_raw(store)?;\n                let toplevel = match self.in_progress.pop() {\n                    Some(imports) => {\n                        self.cur = imports;\n                        self.cur.instances.push(instance);\n                        false\n                    }\n                    None => true,\n                };\n                return Ok(Some((instance, start, toplevel)));\n            }\n        }\n\n        Ok(None)\n    }\n\n    fn instantiate_raw(\n        &mut self,\n        store: &mut StoreOpaque,\n    ) -> Result<(Instance, Option<FuncIndex>)> {\n        let compiled_module = self.cur.module.compiled_module();\n\n        // Register the module just before instantiation to ensure we keep the module\n        // properly referenced while in use by the store.\n        store.modules_mut().register(&self.cur.module);\n\n        unsafe {\n            // The first thing we do is issue an instance allocation request\n            // to the instance allocator. This, on success, will give us an\n            // instance handle.\n            //\n            // Note that the `host_state` here is a pointer back to the\n            // `Instance` we'll be returning from this function. This is a\n            // circular reference so we can't construct it before we construct\n            // this instance, so we determine what the ID is and then assert\n            // it's the same later when we do actually insert it.\n            let instance_to_be = store.store_data().next_id::<InstanceData>();\n            let mut instance_handle =\n                store\n                    .engine()\n                    .allocator()\n                    .allocate(InstanceAllocationRequest {\n                        module: compiled_module.module().clone(),\n                        image_base: compiled_module.code().as_ptr() as usize,\n                        functions: compiled_module.functions(),\n                        imports: self.cur.build(),\n                        shared_signatures: self.cur.module.signatures().as_module_map().into(),\n                        host_state: Box::new(Instance(instance_to_be)),\n                        store: Some(store.traitobj()),\n                        wasm_data: compiled_module.wasm_data(),\n                    })?;\n\n            // The instance still has lots of setup, for example\n            // data/elements/start/etc. This can all fail, but even on failure\n            // the instance may persist some state via previous successful\n            // initialization. For this reason once we have an instance handle\n            // we immediately insert it into the store to keep it alive.\n            //\n            // Note that we `clone` the instance handle just to make easier\n            // working the the borrow checker here easier. Technically the `&mut\n            // instance` has somewhat of a borrow on `store` (which\n            // conflicts with the borrow on `store.engine`) but this doesn't\n            // matter in practice since initialization isn't even running any\n            // code here anyway.\n            let id = store.add_instance(instance_handle.clone(), false);\n\n            // Additionally, before we start doing fallible instantiation, we\n            // do one more step which is to insert an `InstanceData`\n            // corresponding to this instance. This `InstanceData` can be used\n            // via `Caller::get_export` if our instance's state \"leaks\" into\n            // other instances, even if we don't return successfully from this\n            // function.\n            //\n            // We don't actually load all exports from the instance at this\n            // time, instead preferring to lazily load them as they're demanded.\n            // For module/instance exports, though, those aren't actually\n            // stored in the instance handle so we need to immediately handle\n            // those here.\n            let instance = {\n                let exports = compiled_module\n                    .module()\n                    .exports\n                    .values()\n                    .map(|index| {\n                        // Note that instances and modules are not handled by\n                        // `wasmtime_runtime`, they're handled by us in this crate. That\n                        // means we need to handle that here, otherwise we defer to the\n                        // instance to load the values.\n                        match *index {\n                            EntityIndex::Instance(i) => {\n                                Some(Extern::Instance(self.cur.instances[i].clone()))\n                            }\n                            EntityIndex::Module(i) => {\n                                Some(Extern::Module(self.cur.modules[i].clone()))\n                            }\n                            _ => None,\n                        }\n                    })\n                    .collect();\n                let data = InstanceData::Instantiated {\n                    id,\n                    exports,\n                    types: Arc::clone(self.cur.module.types()),\n                    signatures: Arc::clone(self.cur.module.signatures()),\n                };\n                Instance::from_wasmtime(data, store)\n            };\n\n            // double-check our guess of what the new instance's ID would be\n            // was actually correct.\n            assert_eq!(instance.0, instance_to_be);\n\n            // Now that we've recorded all information we need to about this\n            // instance within a `Store` we can start performing fallible\n            // initialization. Note that we still defer the `start` function to\n            // later since that may need to run asynchronously.\n            //\n            // If this returns an error (or if the start function traps) then\n            // any other initialization which may have succeeded which placed\n            // items from this instance into other instances should be ok when\n            // those items are loaded and run we'll have all the metadata to\n            // look at them.\n            store\n                .engine()\n                .allocator()\n                .initialize(\n                    &mut instance_handle,\n                    compiled_module.module(),\n                    store.engine().config().features.bulk_memory,\n                )\n                .map_err(|e| -> Error {\n                    match e {\n                        InstantiationError::Trap(trap) => Trap::from_runtime(trap).into(),\n                        other => other.into(),\n                    }\n                })?;\n\n            Ok((instance, compiled_module.module().start_func))\n        }\n    }\n\n    fn start_raw<T>(\n        store: &mut StoreContextMut<'_, T>,\n        instance: Instance,\n        start: FuncIndex,\n    ) -> Result<()> {\n        let id = match &store.0.store_data()[instance.0] {\n            InstanceData::Instantiated { id, .. } => *id,\n            InstanceData::Synthetic(_) => return Ok(()),\n        };\n        // If a start function is present, invoke it. Make sure we use all the\n        // trap-handling configuration in `store` as well.\n        let instance = store.0.instance(id);\n        let f = match instance.lookup_by_declaration(&EntityIndex::Function(start)) {\n            wasmtime_runtime::Export::Function(f) => f,\n            _ => unreachable!(), // valid modules shouldn't hit this\n        };\n        let vmctx = instance.vmctx_ptr();\n        unsafe {\n            super::func::invoke_wasm_and_catch_traps(store, |_default_callee| {\n                mem::transmute::<\n                    *const VMFunctionBody,\n                    unsafe extern \"C\" fn(*mut VMContext, *mut VMContext),\n                >(f.anyfunc.as_ref().func_ptr.as_ptr())(\n                    f.anyfunc.as_ref().vmctx, vmctx\n                )\n            })?;\n        }\n        Ok(())\n    }\n}\n\nimpl<'a> ImportsBuilder<'a> {\n    fn new(module: &Module, src: ImportSource<'a>) -> ImportsBuilder<'a> {\n        let raw = module.compiled_module().module();\n        ImportsBuilder {\n            src,\n            functions: PrimaryMap::with_capacity(raw.num_imported_funcs),\n            tables: PrimaryMap::with_capacity(raw.num_imported_tables),\n            memories: PrimaryMap::with_capacity(raw.num_imported_memories),\n            globals: PrimaryMap::with_capacity(raw.num_imported_globals),\n            instances: PrimaryMap::with_capacity(raw.instances.len()),\n            modules: PrimaryMap::with_capacity(raw.modules.len()),\n            module: module.clone(),\n            initializer: 0,\n        }\n    }\n\n    fn push(&mut self, item: Extern, store: &mut StoreOpaque) {\n        match item {\n            Extern::Func(i) => {\n                self.functions.push(i.vmimport(store));\n            }\n            Extern::Global(i) => {\n                self.globals.push(i.vmimport(store));\n            }\n            Extern::Table(i) => {\n                self.tables.push(i.vmimport(store));\n            }\n            Extern::Memory(i) => {\n                self.memories.push(i.vmimport(store));\n            }\n            Extern::Instance(i) => {\n                self.instances.push(i);\n            }\n            Extern::Module(m) => {\n                self.modules.push(m);\n            }\n        }\n    }\n\n    fn build(&self) -> Imports<'_> {\n        Imports {\n            tables: self.tables.values().as_slice(),\n            globals: self.globals.values().as_slice(),\n            memories: self.memories.values().as_slice(),\n            functions: self.functions.values().as_slice(),\n        }\n    }\n}\n\n/// An instance, pre-instantiation, that is ready to be instantiated.\n///\n/// This structure represents an instance *just before* it was instantiated,\n/// after all type-checking and imports have been resolved. The only thing left\n/// to do for this instance is to actually run the process of instantiation.\n///\n/// Note that an `InstancePre` may not be tied to any particular [`Store`] if\n/// none of the imports it closed over are tied to any particular [`Store`].\n///\n/// This structure is created through the [`Linker::instantiate_pre`] method,\n/// which also has some more information and examples.\n///\n/// [`Store`]: crate::Store\n/// [`Linker::instantiate_pre`]: crate::Linker::instantiate_pre\npub struct InstancePre<T> {\n    module: Module,\n    items: Vec<Definition>,\n    _marker: std::marker::PhantomData<fn() -> T>,\n}\n\nimpl<T> InstancePre<T> {\n    pub(crate) unsafe fn new(\n        store: &mut StoreOpaque,\n        module: &Module,\n        items: Vec<Definition>,\n    ) -> Result<InstancePre<T>> {\n        typecheck_defs(store, module, &items)?;\n        Ok(InstancePre {\n            module: module.clone(),\n            items,\n            _marker: std::marker::PhantomData,\n        })\n    }\n\n    /// Instantiates this instance, creating a new instance within the provided\n    /// `store`.\n    ///\n    /// This function will run the actual process of instantiation to\n    /// completion. This will use all of the previously-closed-over items as\n    /// imports to instantiate the module that this was originally created with.\n    ///\n    /// For more information about instantiation see [`Instance::new`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if any import closed over by this [`InstancePre`] isn't owned by\n    /// `store`, or if `store` has async support enabled.\n    pub fn instantiate(&self, mut store: impl AsContextMut<Data = T>) -> Result<Instance> {\n        // For the unsafety here the typecheck happened at creation time of this\n        // structure and then othrewise the `T` of `InstancePre<T>` connects any\n        // host functions we have in our definition list to the `store` that was\n        // passed in.\n        let mut store = store.as_context_mut();\n        let mut instantiator = unsafe {\n            self.ensure_comes_from_same_store(&store.0)?;\n            Instantiator::new(\n                store.0,\n                &self.module,\n                ImportSource::Definitions(&self.items),\n            )?\n        };\n        instantiator.run(&mut store)\n    }\n\n    /// Creates a new instance, running the start function asynchronously\n    /// instead of inline.\n    ///\n    /// For more information about asynchronous instantiation see the\n    /// documentation on [`Instance::new_async`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if any import closed over by this [`InstancePre`] isn't owned by\n    /// `store`, or if `store` does not have async support enabled.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn instantiate_async(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n    ) -> Result<Instance>\n    where\n        T: Send,\n    {\n        // For the unsafety here see above\n        let mut store = store.as_context_mut();\n        let mut i = unsafe {\n            self.ensure_comes_from_same_store(&store.0)?;\n            Instantiator::new(\n                store.0,\n                &self.module,\n                ImportSource::Definitions(&self.items),\n            )?\n        };\n        i.run_async(&mut store.as_context_mut()).await\n    }\n\n    fn ensure_comes_from_same_store(&self, store: &StoreOpaque) -> Result<()> {\n        for import in self.items.iter() {\n            if !import.comes_from_same_store(store) {\n                bail!(\"cross-`Store` instantiation is not currently supported\");\n            }\n        }\n        Ok(())\n    }\n}\n\nfn typecheck_externs(store: &mut StoreOpaque, module: &Module, imports: &[Extern]) -> Result<()> {\n    for import in imports {\n        if !import.comes_from_same_store(store) {\n            bail!(\"cross-`Store` instantiation is not currently supported\");\n        }\n    }\n    typecheck(store, module, imports, |cx, ty, item| cx.extern_(ty, item))\n}\n\nfn typecheck_defs(store: &mut StoreOpaque, module: &Module, imports: &[Definition]) -> Result<()> {\n    for import in imports {\n        if !import.comes_from_same_store(store) {\n            bail!(\"cross-`Store` instantiation is not currently supported\");\n        }\n    }\n    typecheck(store, module, imports, |cx, ty, item| {\n        cx.definition(ty, item)\n    })\n}\n\nfn typecheck<I>(\n    store: &mut StoreOpaque,\n    module: &Module,\n    imports: &[I],\n    check: impl Fn(&matching::MatchCx<'_>, &EntityType, &I) -> Result<()>,\n) -> Result<()> {\n    let env_module = module.compiled_module().module();\n    let expected = env_module.imports().count();\n    if expected != imports.len() {\n        bail!(\"expected {} imports, found {}\", expected, imports.len());\n    }\n    let cx = matching::MatchCx {\n        signatures: module.signatures(),\n        types: module.types(),\n        store: store,\n        engine: store.engine(),\n    };\n    for ((name, field, expected_ty), actual) in env_module.imports().zip(imports) {\n        check(&cx, &expected_ty, actual).with_context(|| {\n            let extra = match field {\n                Some(name) => format!(\"::{}\", name),\n                None => String::new(),\n            };\n            format!(\"incompatible import type for `{}{}`\", name, extra)\n        })?;\n    }\n    Ok(())\n}\n", "use crate::func::HostFunc;\nuse crate::instance::{InstanceData, InstancePre};\nuse crate::store::StoreOpaque;\nuse crate::{\n    AsContextMut, Caller, Engine, Extern, ExternType, Func, FuncType, ImportType, Instance,\n    IntoFunc, Module, StoreContextMut, Trap, Val,\n};\nuse anyhow::{anyhow, bail, Context, Error, Result};\nuse log::warn;\nuse std::collections::hash_map::{Entry, HashMap};\n#[cfg(feature = \"async\")]\nuse std::future::Future;\nuse std::marker;\n#[cfg(feature = \"async\")]\nuse std::pin::Pin;\nuse std::sync::Arc;\n\n/// Structure used to link wasm modules/instances together.\n///\n/// This structure is used to assist in instantiating a [`Module`]. A [`Linker`]\n/// is a way of performing name resolution to make instantiating a module easier\n/// than specifying positional imports to [`Instance::new`]. [`Linker`] is a\n/// name-based resolver where names are dynamically defined and then used to\n/// instantiate a [`Module`].\n///\n/// An important method is [`Linker::instantiate`] which takes a module to\n/// instantiate into the provided store. This method will automatically select\n/// all the right imports for the [`Module`] to be instantiated, and will\n/// otherwise return an error if an import isn't satisfied.\n///\n/// ## Name Resolution\n///\n/// As mentioned previously, `Linker` is a form of name resolver. It will be\n/// using the string-based names of imports on a module to attempt to select a\n/// matching item to hook up to it. This name resolution has two-levels of\n/// namespaces, a module level and a name level. Each item is defined within a\n/// module and then has its own name. This basically follows the wasm standard\n/// for modularization.\n///\n/// Names in a `Linker` cannot be defined twice, but allowing duplicates by\n/// shadowing the previous definition can be controlled with the\n/// [`Linker::allow_shadowing`] method.\n///\n/// ## Commands and Reactors\n///\n/// The [`Linker`] type provides conveniences for working with WASI Commands and\n/// Reactors through the [`Linker::module`] method. This will automatically\n/// handle instantiation and calling `_start` and such as appropriate\n/// depending on the inferred type of module.\n///\n/// ## Type parameter `T`\n///\n/// It's worth pointing out that the type parameter `T` on [`Linker<T>`] does\n/// not represent that `T` is stored within a [`Linker`]. Rather the `T` is used\n/// to ensure that linker-defined functions and stores instantiated into all use\n/// the same matching `T` as host state.\n///\n/// ## Multiple `Store`s\n///\n/// The [`Linker`] type is designed to be compatible, in some scenarios, with\n/// instantiation in multiple [`Store`]s. Specifically host-defined functions\n/// created in [`Linker`] with [`Linker::func_new`], [`Linker::func_wrap`], and\n/// their async versions are compatible to instantiate into any [`Store`]. This\n/// enables programs which want to instantiate lots of modules to create one\n/// [`Linker`] value at program start up and use that continuously for each\n/// [`Store`] created over the lifetime of the program.\n///\n/// Note that once [`Store`]-owned items, such as [`Global`], are defined witin\n/// a [`Linker`] then it is no longer compatible with any [`Store`]. At that\n/// point only the [`Store`] that owns the [`Global`] can be used to instantiate\n/// modules.\n///\n/// [`Store`]: crate::Store\n/// [`Global`]: crate::Global\npub struct Linker<T> {\n    engine: Engine,\n    string2idx: HashMap<Arc<str>, usize>,\n    strings: Vec<Arc<str>>,\n    map: HashMap<ImportKey, Definition>,\n    allow_shadowing: bool,\n    allow_unknown_exports: bool,\n    _marker: marker::PhantomData<fn() -> T>,\n}\n\nimpl<T> Clone for Linker<T> {\n    fn clone(&self) -> Linker<T> {\n        Linker {\n            engine: self.engine.clone(),\n            string2idx: self.string2idx.clone(),\n            strings: self.strings.clone(),\n            map: self.map.clone(),\n            allow_shadowing: self.allow_shadowing,\n            allow_unknown_exports: self.allow_unknown_exports,\n            _marker: self._marker,\n        }\n    }\n}\n\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\nstruct ImportKey {\n    name: usize,\n    module: usize,\n}\n\n#[derive(Clone)]\npub(crate) enum Definition {\n    Extern(Extern),\n    HostFunc(Arc<HostFunc>),\n    Instance(Arc<indexmap::IndexMap<String, Definition>>),\n}\n\nmacro_rules! generate_wrap_async_func {\n    ($num:tt $($args:ident)*) => (paste::paste!{\n        /// Asynchronous analog of [`Linker::func_wrap`].\n        ///\n        /// For more information also see\n        /// [`Func::wrapN_async`](crate::Func::wrap1_async).\n        #[allow(non_snake_case)]\n        #[cfg(feature = \"async\")]\n        #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n        pub fn [<func_wrap $num _async>]<$($args,)* R>(\n            &mut self,\n            module: &str,\n            name: &str,\n            func: impl for<'a> Fn(Caller<'a, T>, $($args),*) -> Box<dyn Future<Output = R> + Send + 'a> + Send + Sync + 'static,\n        ) -> Result<&mut Self>\n        where\n            $($args: crate::WasmTy,)*\n            R: crate::WasmRet,\n        {\n            assert!(\n                self.engine.config().async_support,\n                concat!(\n                    \"cannot use `func_wrap\",\n                    $num,\n                    \"_async` without enabling async support on the config\",\n                ),\n            );\n            self.func_wrap(module, name, move |mut caller: Caller<'_, T>, $($args: $args),*| {\n                let async_cx = caller.store.as_context_mut().0.async_cx();\n                let mut future = Pin::from(func(caller, $($args),*));\n                match unsafe { async_cx.block_on(future.as_mut()) } {\n                    Ok(ret) => ret.into_fallible(),\n                    Err(e) => R::fallible_from_trap(e),\n                }\n            })\n        }\n    })\n}\n\nimpl<T> Linker<T> {\n    /// Creates a new [`Linker`].\n    pub fn new(engine: &Engine) -> Linker<T> {\n        Linker {\n            engine: engine.clone(),\n            map: HashMap::new(),\n            string2idx: HashMap::new(),\n            strings: Vec::new(),\n            allow_shadowing: false,\n            allow_unknown_exports: false,\n            _marker: marker::PhantomData,\n        }\n    }\n\n    /// Returns the [`Engine`] this is connected to.\n    pub fn engine(&self) -> &Engine {\n        &self.engine\n    }\n\n    /// Configures whether this [`Linker`] will shadow previous duplicate\n    /// definitions of the same signature.\n    ///\n    /// By default a [`Linker`] will disallow duplicate definitions of the same\n    /// signature. This method, however, can be used to instead allow duplicates\n    /// and have the latest definition take precedence when linking modules.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// let mut linker = Linker::<()>::new(&engine);\n    /// linker.func_wrap(\"\", \"\", || {})?;\n    ///\n    /// // by default, duplicates are disallowed\n    /// assert!(linker.func_wrap(\"\", \"\", || {}).is_err());\n    ///\n    /// // but shadowing can be configured to be allowed as well\n    /// linker.allow_shadowing(true);\n    /// linker.func_wrap(\"\", \"\", || {})?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn allow_shadowing(&mut self, allow: bool) -> &mut Self {\n        self.allow_shadowing = allow;\n        self\n    }\n\n    /// Configures whether this [`Linker`] will allow unknown exports from\n    /// command modules.\n    ///\n    /// By default a [`Linker`] will error when unknown exports are encountered\n    /// in a command module while using [`Linker::module`].\n    ///\n    /// This method can be used to allow unknown exports from command modules.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let module = Module::new(&engine, \"(module)\")?;\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// linker.allow_unknown_exports(true);\n    /// linker.module(&mut store, \"mod\", &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn allow_unknown_exports(&mut self, allow: bool) -> &mut Self {\n        self.allow_unknown_exports = allow;\n        self\n    }\n\n    /// Defines a new item in this [`Linker`].\n    ///\n    /// This method will add a new definition, by name, to this instance of\n    /// [`Linker`]. The `module` and `name` provided are what to name the\n    /// `item`.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the `module` and `name` already identify an item\n    /// of the same type as the `item` provided and if shadowing is disallowed.\n    /// For more information see the documentation on [`Linker`].\n    ///\n    /// Also returns an error if `item` comes from a different store than this\n    /// [`Linker`] was created with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// let ty = GlobalType::new(ValType::I32, Mutability::Const);\n    /// let global = Global::new(&mut store, ty, Val::I32(0x1234))?;\n    /// linker.define(\"host\", \"offset\", global)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"offset\" (global i32))\n    ///         (memory 1)\n    ///         (data (global.get 0) \"foo\")\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn define(\n        &mut self,\n        module: &str,\n        name: &str,\n        item: impl Into<Extern>,\n    ) -> Result<&mut Self> {\n        let key = self.import_key(module, Some(name));\n        self.insert(key, Definition::Extern(item.into()))?;\n        Ok(self)\n    }\n\n    /// Same as [`Linker::define`], except only the name of the import is\n    /// provided, not a module name as well.\n    ///\n    /// This is only relevant when working with the module linking proposal\n    /// where one-level names are allowed (in addition to two-level names).\n    /// Otherwise this method need not be used.\n    pub fn define_name(&mut self, name: &str, item: impl Into<Extern>) -> Result<&mut Self> {\n        let key = self.import_key(name, None);\n        self.insert(key, Definition::Extern(item.into()))?;\n        Ok(self)\n    }\n\n    /// Creates a [`Func::new`]-style function named in this linker.\n    ///\n    /// For more information see [`Linker::func_wrap`].\n    #[cfg(compiler)]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"cranelift\")))] // see build.rs\n    pub fn func_new(\n        &mut self,\n        module: &str,\n        name: &str,\n        ty: FuncType,\n        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,\n    ) -> Result<&mut Self> {\n        let func = HostFunc::new(&self.engine, ty, func);\n        let key = self.import_key(module, Some(name));\n        self.insert(key, Definition::HostFunc(Arc::new(func)))?;\n        Ok(self)\n    }\n\n    /// Creates a [`Func::new_async`]-style function named in this linker.\n    ///\n    /// For more information see [`Linker::func_wrap`].\n    #[cfg(all(feature = \"async\", feature = \"cranelift\"))]\n    #[cfg_attr(nightlydoc, doc(cfg(all(feature = \"async\", feature = \"cranelift\"))))]\n    pub fn func_new_async<F>(\n        &mut self,\n        module: &str,\n        name: &str,\n        ty: FuncType,\n        func: F,\n    ) -> Result<&mut Self>\n    where\n        F: for<'a> Fn(\n                Caller<'a, T>,\n                &'a [Val],\n                &'a mut [Val],\n            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>\n            + Send\n            + Sync\n            + 'static,\n    {\n        assert!(\n            self.engine.config().async_support,\n            \"cannot use `func_new_async` without enabling async support in the config\"\n        );\n        self.func_new(module, name, ty, move |mut caller, params, results| {\n            let async_cx = caller.store.as_context_mut().0.async_cx();\n            let mut future = Pin::from(func(caller, params, results));\n            match unsafe { async_cx.block_on(future.as_mut()) } {\n                Ok(Ok(())) => Ok(()),\n                Ok(Err(trap)) | Err(trap) => Err(trap),\n            }\n        })\n    }\n\n    /// Define a host function within this linker.\n    ///\n    /// For information about how the host function operates, see\n    /// [`Func::wrap`]. That includes information about translating Rust types\n    /// to WebAssembly native types.\n    ///\n    /// This method creates a host-provided function in this linker under the\n    /// provided name. This method is distinct in its capability to create a\n    /// [`Store`](crate::Store)-independent function. This means that the\n    /// function defined here can be used to instantiate instances in multiple\n    /// different stores, or in other words the function can be loaded into\n    /// different stores.\n    ///\n    /// Note that the capability mentioned here applies to all other\n    /// host-function-defining-methods on [`Linker`] as well. All of them can be\n    /// used to create instances of [`Func`] within multiple stores. In a\n    /// multithreaded program, for example, this means that the host functions\n    /// could be called concurrently if different stores are executing on\n    /// different threads.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the `module` and `name` already identify an item\n    /// of the same type as the `item` provided and if shadowing is disallowed.\n    /// For more information see the documentation on [`Linker`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// let mut linker = Linker::new(&engine);\n    /// linker.func_wrap(\"host\", \"double\", |x: i32| x * 2)?;\n    /// linker.func_wrap(\"host\", \"log_i32\", |x: i32| println!(\"{}\", x))?;\n    /// linker.func_wrap(\"host\", \"log_str\", |caller: Caller<'_, ()>, ptr: i32, len: i32| {\n    ///     // ...\n    /// })?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"double\" (func (param i32) (result i32)))\n    ///         (import \"host\" \"log_i32\" (func (param i32)))\n    ///         (import \"host\" \"log_str\" (func (param i32 i32)))\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    ///\n    /// // instantiate in multiple different stores\n    /// for _ in 0..10 {\n    ///     let mut store = Store::new(&engine, ());\n    ///     linker.instantiate(&mut store, &module)?;\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn func_wrap<Params, Args>(\n        &mut self,\n        module: &str,\n        name: &str,\n        func: impl IntoFunc<T, Params, Args>,\n    ) -> Result<&mut Self> {\n        let func = HostFunc::wrap(&self.engine, func);\n        let key = self.import_key(module, Some(name));\n        self.insert(key, Definition::HostFunc(Arc::new(func)))?;\n        Ok(self)\n    }\n\n    for_each_function_signature!(generate_wrap_async_func);\n\n    /// Convenience wrapper to define an entire [`Instance`] in this linker.\n    ///\n    /// This function is a convenience wrapper around [`Linker::define`] which\n    /// will define all exports on `instance` into this linker. The module name\n    /// for each export is `module_name`, and the name for each export is the\n    /// name in the instance itself.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the any item is redefined twice in this linker (for\n    /// example the same `module_name` was already defined) and shadowing is\n    /// disallowed, or if `instance` comes from a different\n    /// [`Store`](crate::Store) than this [`Linker`] originally was created\n    /// with.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `instance` does not belong to `store`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    ///\n    /// // Instantiate a small instance...\n    /// let wat = r#\"(module (func (export \"run\") ))\"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance = linker.instantiate(&mut store, &module)?;\n    ///\n    /// // ... and inform the linker that the name of this instance is\n    /// // `instance1`. This defines the `instance1::run` name for our next\n    /// // module to use.\n    /// linker.instance(&mut store, \"instance1\", instance)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"instance1\" \"run\" (func $instance1_run))\n    ///         (func (export \"run\")\n    ///             call $instance1_run\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance = linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn instance(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        instance: Instance,\n    ) -> Result<&mut Self> {\n        for export in instance.exports(store.as_context_mut()) {\n            let key = self.import_key(module_name, Some(export.name()));\n            self.insert(key, Definition::Extern(export.into_extern()))?;\n        }\n        Ok(self)\n    }\n\n    /// Define automatic instantiations of a [`Module`] in this linker.\n    ///\n    /// This automatically handles [Commands and Reactors] instantiation and\n    /// initialization.\n    ///\n    /// Exported functions of a Command module may be called directly, however\n    /// instead of having a single instance which is reused for each call,\n    /// each call creates a new instance, which lives for the duration of the\n    /// call. The imports of the Command are resolved once, and reused for\n    /// each instantiation, so all dependencies need to be present at the time\n    /// when `Linker::module` is called.\n    ///\n    /// For Reactors, a single instance is created, and an initialization\n    /// function is called, and then its exports may be called.\n    ///\n    /// Ordinary modules which don't declare themselves to be either Commands\n    /// or Reactors are treated as Reactors without any initialization calls.\n    ///\n    /// [Commands and Reactors]: https://github.com/WebAssembly/WASI/blob/master/design/application-abi.md#current-unstable-abi\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the any item is redefined twice in this linker (for\n    /// example the same `module_name` was already defined) and shadowing is\n    /// disallowed, if `instance` comes from a different\n    /// [`Store`](crate::Store) than this [`Linker`] originally was created\n    /// with, or if a Reactor initialization function traps.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any item used to instantiate the provided [`Module`] is not\n    /// owned by `store`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    ///\n    /// // Instantiate a small instance and inform the linker that the name of\n    /// // this instance is `instance1`. This defines the `instance1::run` name\n    /// // for our next module to use.\n    /// let wat = r#\"(module (func (export \"run\") ))\"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.module(&mut store, \"instance1\", &module)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"instance1\" \"run\" (func $instance1_run))\n    ///         (func (export \"run\")\n    ///             call $instance1_run\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance = linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// For a Command, a new instance is created for each call.\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    ///\n    /// // Create a Command that attempts to count the number of times it is run, but is\n    /// // foiled by each call getting a new instance.\n    /// let wat = r#\"\n    ///     (module\n    ///         (global $counter (mut i32) (i32.const 0))\n    ///         (func (export \"_start\")\n    ///             (global.set $counter (i32.add (global.get $counter) (i32.const 1)))\n    ///         )\n    ///         (func (export \"read_counter\") (result i32)\n    ///             (global.get $counter)\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.module(&mut store, \"commander\", &module)?;\n    /// let run = linker.get_default(&mut store, \"\")?\n    ///     .typed::<(), (), _>(&store)?\n    ///     .clone();\n    /// run.call(&mut store, ())?;\n    /// run.call(&mut store, ())?;\n    /// run.call(&mut store, ())?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"commander\" \"_start\" (func $commander_start))\n    ///         (import \"commander\" \"read_counter\" (func $commander_read_counter (result i32)))\n    ///         (func (export \"run\") (result i32)\n    ///             call $commander_start\n    ///             call $commander_start\n    ///             call $commander_start\n    ///             call $commander_read_counter\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.module(&mut store, \"\", &module)?;\n    /// let run = linker.get(&mut store, \"\", Some(\"run\")).unwrap().into_func().unwrap();\n    /// let count = run.typed::<(), i32, _>(&store)?.call(&mut store, ())?;\n    /// assert_eq!(count, 0, \"a Command should get a fresh instance on each invocation\");\n    ///\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[cfg(compiler)]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"cranelift\")))] // see build.rs\n    pub fn module(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        module: &Module,\n    ) -> Result<&mut Self>\n    where\n        T: 'static,\n    {\n        // NB: this is intended to function the same as `Linker::module_async`,\n        // they should be kept in sync.\n        match ModuleKind::categorize(module)? {\n            ModuleKind::Command => {\n                self.command(\n                    store,\n                    module_name,\n                    module,\n                    |store, func_ty, export_name, instance_pre| {\n                        Func::new(\n                            store,\n                            func_ty.clone(),\n                            move |mut caller, params, results| {\n                                // Create a new instance for this command execution.\n                                let instance = instance_pre.instantiate(&mut caller)?;\n\n                                // `unwrap()` everything here because we know the instance contains a\n                                // function export with the given name and signature because we're\n                                // iterating over the module it was instantiated from.\n                                let command_results = instance\n                                    .get_export(&mut caller, &export_name)\n                                    .unwrap()\n                                    .into_func()\n                                    .unwrap()\n                                    .call(&mut caller, params)\n                                    .map_err(|error| error.downcast::<Trap>().unwrap())?;\n\n                                // Copy the return values into the output slice.\n                                for (result, command_result) in\n                                    results.iter_mut().zip(command_results.into_vec())\n                                {\n                                    *result = command_result;\n                                }\n\n                                Ok(())\n                            },\n                        )\n                    },\n                )\n            }\n            ModuleKind::Reactor => {\n                let instance = self.instantiate(&mut store, &module)?;\n\n                if let Some(export) = instance.get_export(&mut store, \"_initialize\") {\n                    if let Extern::Func(func) = export {\n                        func.typed::<(), (), _>(&store)\n                            .and_then(|f| f.call(&mut store, ()).map_err(Into::into))\n                            .context(\"calling the Reactor initialization function\")?;\n                    }\n                }\n\n                self.instance(store, module_name, instance)\n            }\n        }\n    }\n\n    /// Define automatic instantiations of a [`Module`] in this linker.\n    ///\n    /// This is the same as [`Linker::module`], except for async `Store`s.\n    #[cfg(all(feature = \"async\", feature = \"cranelift\"))]\n    #[cfg_attr(nightlydoc, doc(cfg(all(feature = \"async\", feature = \"cranelift\"))))]\n    pub async fn module_async(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        module: &Module,\n    ) -> Result<&mut Self>\n    where\n        T: Send + 'static,\n    {\n        // NB: this is intended to function the same as `Linker::module`, they\n        // should be kept in sync.\n        match ModuleKind::categorize(module)? {\n            ModuleKind::Command => self.command(\n                store,\n                module_name,\n                module,\n                |store, func_ty, export_name, instance_pre| {\n                    let upvars = Arc::new((instance_pre, export_name));\n                    Func::new_async(\n                        store,\n                        func_ty.clone(),\n                        move |mut caller, params, results| {\n                            let upvars = upvars.clone();\n                            Box::new(async move {\n                                let (instance_pre, export_name) = &*upvars;\n                                let instance = instance_pre.instantiate_async(&mut caller).await?;\n\n                                let command_results = instance\n                                    .get_export(&mut caller, &export_name)\n                                    .unwrap()\n                                    .into_func()\n                                    .unwrap()\n                                    .call_async(&mut caller, params)\n                                    .await\n                                    .map_err(|error| error.downcast::<Trap>().unwrap())?;\n\n                                for (result, command_result) in\n                                    results.iter_mut().zip(command_results.into_vec())\n                                {\n                                    *result = command_result;\n                                }\n                                Ok(())\n                            })\n                        },\n                    )\n                },\n            ),\n            ModuleKind::Reactor => {\n                let instance = self.instantiate_async(&mut store, &module).await?;\n\n                if let Some(export) = instance.get_export(&mut store, \"_initialize\") {\n                    if let Extern::Func(func) = export {\n                        let func = func\n                            .typed::<(), (), _>(&store)\n                            .context(\"loading the Reactor initialization function\")?;\n                        func.call_async(&mut store, ())\n                            .await\n                            .context(\"calling the Reactor initialization function\")?;\n                    }\n                }\n\n                self.instance(store, module_name, instance)\n            }\n        }\n    }\n\n    fn command(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        module: &Module,\n        mk_func: impl Fn(&mut StoreContextMut<T>, &FuncType, String, InstancePre<T>) -> Func,\n    ) -> Result<&mut Self>\n    where\n        T: 'static,\n    {\n        let mut store = store.as_context_mut();\n        for export in module.exports() {\n            if let Some(func_ty) = export.ty().func() {\n                let instance_pre = self.instantiate_pre(&mut store, module)?;\n                let export_name = export.name().to_owned();\n                let func = mk_func(&mut store, func_ty, export_name, instance_pre);\n                let key = self.import_key(module_name, Some(export.name()));\n                self.insert(key, Definition::Extern(func.into()))?;\n            } else if export.name() == \"memory\" && export.ty().memory().is_some() {\n                // Allow an exported \"memory\" memory for now.\n            } else if export.name() == \"__indirect_function_table\" && export.ty().table().is_some()\n            {\n                // Allow an exported \"__indirect_function_table\" table for now.\n            } else if export.name() == \"table\" && export.ty().table().is_some() {\n                // Allow an exported \"table\" table for now.\n            } else if export.name() == \"__data_end\" && export.ty().global().is_some() {\n                // Allow an exported \"__data_end\" memory for compatibility with toolchains\n                // which use --export-dynamic, which unfortunately doesn't work the way\n                // we want it to.\n                warn!(\"command module exporting '__data_end' is deprecated\");\n            } else if export.name() == \"__heap_base\" && export.ty().global().is_some() {\n                // Allow an exported \"__data_end\" memory for compatibility with toolchains\n                // which use --export-dynamic, which unfortunately doesn't work the way\n                // we want it to.\n                warn!(\"command module exporting '__heap_base' is deprecated\");\n            } else if export.name() == \"__dso_handle\" && export.ty().global().is_some() {\n                // Allow an exported \"__dso_handle\" memory for compatibility with toolchains\n                // which use --export-dynamic, which unfortunately doesn't work the way\n                // we want it to.\n                warn!(\"command module exporting '__dso_handle' is deprecated\")\n            } else if export.name() == \"__rtti_base\" && export.ty().global().is_some() {\n                // Allow an exported \"__rtti_base\" memory for compatibility with\n                // AssemblyScript.\n                warn!(\"command module exporting '__rtti_base' is deprecated; pass `--runtime half` to the AssemblyScript compiler\");\n            } else if !self.allow_unknown_exports {\n                bail!(\"command export '{}' is not a function\", export.name());\n            }\n        }\n\n        Ok(self)\n    }\n\n    /// Aliases one item's name as another.\n    ///\n    /// This method will alias an item with the specified `module` and `name`\n    /// under a new name of `as_module` and `as_name`.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if any shadowing violations happen while defining new\n    /// items, or if the original item wasn't defined.\n    pub fn alias(\n        &mut self,\n        module: &str,\n        name: &str,\n        as_module: &str,\n        as_name: &str,\n    ) -> Result<&mut Self> {\n        let src = self.import_key(module, Some(name));\n        let dst = self.import_key(as_module, Some(as_name));\n        match self.map.get(&src).cloned() {\n            Some(item) => self.insert(dst, item)?,\n            None => bail!(\"no item named `{}::{}` defined\", module, name),\n        }\n        Ok(self)\n    }\n\n    /// Aliases one module's name as another.\n    ///\n    /// This method will alias all currently defined under `module` to also be\n    /// defined under the name `as_module` too.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if any shadowing violations happen while defining new\n    /// items.\n    pub fn alias_module(&mut self, module: &str, as_module: &str) -> Result<()> {\n        let module = self.intern_str(module);\n        let as_module = self.intern_str(as_module);\n        let items = self\n            .map\n            .iter()\n            .filter(|(key, _def)| key.module == module)\n            .map(|(key, def)| (key.name, def.clone()))\n            .collect::<Vec<_>>();\n        for (name, item) in items {\n            self.insert(\n                ImportKey {\n                    module: as_module,\n                    name,\n                },\n                item,\n            )?;\n        }\n        Ok(())\n    }\n\n    fn insert(&mut self, key: ImportKey, item: Definition) -> Result<()> {\n        match self.map.entry(key) {\n            Entry::Occupied(_) if !self.allow_shadowing => {\n                let module = &self.strings[key.module];\n                let desc = match self.strings.get(key.name) {\n                    Some(name) => format!(\"{}::{}\", module, name),\n                    None => module.to_string(),\n                };\n                bail!(\"import of `{}` defined twice\", desc)\n            }\n            Entry::Occupied(mut o) => {\n                o.insert(item);\n            }\n            Entry::Vacant(v) => {\n                v.insert(item);\n            }\n        }\n        Ok(())\n    }\n\n    fn import_key(&mut self, module: &str, name: Option<&str>) -> ImportKey {\n        ImportKey {\n            module: self.intern_str(module),\n            name: name\n                .map(|name| self.intern_str(name))\n                .unwrap_or(usize::max_value()),\n        }\n    }\n\n    fn intern_str(&mut self, string: &str) -> usize {\n        if let Some(idx) = self.string2idx.get(string) {\n            return *idx;\n        }\n        let string: Arc<str> = string.into();\n        let idx = self.strings.len();\n        self.strings.push(string.clone());\n        self.string2idx.insert(string, idx);\n        idx\n    }\n\n    /// Attempts to instantiate the `module` provided.\n    ///\n    /// This method will attempt to assemble a list of imports that correspond\n    /// to the imports required by the [`Module`] provided. This list\n    /// of imports is then passed to [`Instance::new`] to continue the\n    /// instantiation process.\n    ///\n    /// Each import of `module` will be looked up in this [`Linker`] and must\n    /// have previously been defined. If it was previously defined with an\n    /// incorrect signature or if it was not previously defined then an error\n    /// will be returned because the import can not be satisfied.\n    ///\n    /// Per the WebAssembly spec, instantiation includes running the module's\n    /// start function, if it has one (not to be confused with the `_start`\n    /// function, which is not run).\n    ///\n    /// # Errors\n    ///\n    /// This method can fail because an import may not be found, or because\n    /// instantiation itself may fail. For information on instantiation\n    /// failures see [`Instance::new`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if any item used to instantiate `module` is not owned by\n    /// `store`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// linker.func_wrap(\"host\", \"double\", |x: i32| x * 2)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"double\" (func (param i32) (result i32)))\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn instantiate(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n    ) -> Result<Instance> {\n        self.instantiate_pre(&mut store, module)?.instantiate(store)\n    }\n\n    /// Attempts to instantiate the `module` provided. This is the same as\n    /// [`Linker::instantiate`], except for async `Store`s.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn instantiate_async(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n    ) -> Result<Instance>\n    where\n        T: Send,\n    {\n        self.instantiate_pre(&mut store, module)?\n            .instantiate_async(store)\n            .await\n    }\n\n    /// Performs all checks necessary for instantiating `module` with this\n    /// linker within `store`, except that instantiation doesn't actually\n    /// finish.\n    ///\n    /// This method is used for front-loading type-checking information as well\n    /// as collecting the imports to use to instantiate a module with. The\n    /// returned [`InstancePre`] represents a ready-to-be-instantiated module,\n    /// which can also be instantiated multiple times if desired.\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if any item defined in this linker used by\n    /// `module` is not owned by `store`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// linker.func_wrap(\"host\", \"double\", |x: i32| x * 2)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"double\" (func (param i32) (result i32)))\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance_pre = linker.instantiate_pre(&mut store, &module)?;\n    ///\n    /// // Finish instantiation after the type-checking has all completed...\n    /// let instance = instance_pre.instantiate(&mut store)?;\n    ///\n    /// // ... and we can even continue to keep instantiating if desired!\n    /// instance_pre.instantiate(&mut store)?;\n    /// instance_pre.instantiate(&mut store)?;\n    ///\n    /// // Note that functions defined in a linker with `func_wrap` and similar\n    /// // constructors are not owned by any particular `Store`, so we can also\n    /// // instantiate our `instance_pre` in other stores because no imports\n    /// // belong to the original store.\n    /// let mut new_store = Store::new(&engine, ());\n    /// instance_pre.instantiate(&mut new_store)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn instantiate_pre(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n    ) -> Result<InstancePre<T>> {\n        let store = store.as_context_mut().0;\n        let imports = module\n            .imports()\n            .map(|import| {\n                self._get_by_import(&import)\n                    .ok_or_else(|| self.link_error(&import))\n            })\n            .collect::<Result<_>>()?;\n        unsafe { InstancePre::new(store, module, imports) }\n    }\n\n    fn link_error(&self, import: &ImportType) -> Error {\n        let desc = match import.name() {\n            Some(name) => format!(\"{}::{}\", import.module(), name),\n            None => import.module().to_string(),\n        };\n        anyhow!(\"unknown import: `{}` has not been defined\", desc)\n    }\n\n    /// Returns an iterator over all items defined in this `Linker`, in\n    /// arbitrary order.\n    ///\n    /// The iterator returned will yield 3-tuples where the first two elements\n    /// are the module name and item name for the external item, and the third\n    /// item is the item itself that is defined.\n    ///\n    /// Note that multiple `Extern` items may be defined for the same\n    /// module/name pair.\n    pub fn iter<'a: 'p, 'p>(\n        &'a self,\n        mut store: impl AsContextMut<Data = T> + 'p,\n    ) -> impl Iterator<Item = (&str, &str, Extern)> + 'p {\n        self.map.iter().map(move |(key, item)| {\n            let store = store.as_context_mut();\n            (\n                &*self.strings[key.module],\n                &*self.strings[key.name],\n                // Should be safe since `T` is connecting the linker and store\n                unsafe { item.to_extern(store.0) },\n            )\n        })\n    }\n\n    /// Looks up a previously defined value in this [`Linker`], identified by\n    /// the names provided.\n    ///\n    /// Returns `None` if this name was not previously defined in this\n    /// [`Linker`].\n    pub fn get(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &str,\n        name: Option<&str>,\n    ) -> Option<Extern> {\n        let store = store.as_context_mut().0;\n        // Should be safe since `T` is connecting the linker and store\n        Some(unsafe { self._get(module, name)?.to_extern(store) })\n    }\n\n    fn _get(&self, module: &str, name: Option<&str>) -> Option<&Definition> {\n        let key = ImportKey {\n            module: *self.string2idx.get(module)?,\n            name: match name {\n                Some(name) => *self.string2idx.get(name)?,\n                None => usize::max_value(),\n            },\n        };\n        self.map.get(&key)\n    }\n\n    /// Looks up a value in this `Linker` which matches the `import` type\n    /// provided.\n    ///\n    /// Returns `None` if no match was found.\n    pub fn get_by_import(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        import: &ImportType,\n    ) -> Option<Extern> {\n        let store = store.as_context_mut().0;\n        // Should be safe since `T` is connecting the linker and store\n        Some(unsafe { self._get_by_import(import)?.to_extern(store) })\n    }\n\n    fn _get_by_import(&self, import: &ImportType) -> Option<Definition> {\n        if let Some(item) = self._get(import.module(), import.name()) {\n            return Some(item.clone());\n        }\n\n        if import.name().is_some() {\n            return None;\n        }\n\n        if let ExternType::Instance(t) = import.ty() {\n            // This is a key location where the module linking proposal is\n            // implemented. This logic allows single-level imports of an instance to\n            // get satisfied by multiple definitions of items within this `Linker`.\n            //\n            // The instance being import is iterated over to load the names from\n            // this `Linker` (recursively calling `get`). If anything isn't defined\n            // we return `None` since the entire value isn't defined. Otherwise when\n            // all values are loaded it's assembled into an `Instance` and\n            // returned`.\n            //\n            // Note that this isn't exactly the speediest implementation in the\n            // world. Ideally we would pre-create the `Instance` instead of creating\n            // it each time a module is instantiated. For now though while the\n            // module linking proposal is under development this should hopefully\n            // suffice.\n            let mut map = indexmap::IndexMap::new();\n            for export in t.exports() {\n                let item = self._get(import.module(), Some(export.name()))?;\n                map.insert(export.name().to_string(), item.clone());\n            }\n            return Some(Definition::Instance(Arc::new(map)));\n        }\n\n        None\n    }\n\n    /// Returns the \"default export\" of a module.\n    ///\n    /// An export with an empty string is considered to be a \"default export\".\n    /// \"_start\" is also recognized for compatibility.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the default function found is not owned by `store`.\n    pub fn get_default(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &str,\n    ) -> Result<Func> {\n        if let Some(external) = self.get(&mut store, module, Some(\"\")) {\n            if let Extern::Func(func) = external {\n                return Ok(func.clone());\n            }\n            bail!(\"default export in '{}' is not a function\", module);\n        }\n\n        // For compatibility, also recognize \"_start\".\n        if let Some(external) = self.get(&mut store, module, Some(\"_start\")) {\n            if let Extern::Func(func) = external {\n                return Ok(func.clone());\n            }\n            bail!(\"`_start` in '{}' is not a function\", module);\n        }\n\n        // Otherwise return a no-op function.\n        Ok(Func::wrap(store, || {}))\n    }\n}\n\nimpl<T> Default for Linker<T> {\n    fn default() -> Linker<T> {\n        Linker::new(&Engine::default())\n    }\n}\n\nimpl Definition {\n    /// Note the unsafety here is due to calling `HostFunc::to_func`. The\n    /// requirement here is that the `T` that was originally used to create the\n    /// `HostFunc` matches the `T` on the store.\n    pub(crate) unsafe fn to_extern(&self, store: &mut StoreOpaque) -> Extern {\n        match self {\n            Definition::Extern(e) => e.clone(),\n            Definition::HostFunc(func) => func.to_func(store).into(),\n            Definition::Instance(i) => {\n                let items = Arc::new(\n                    i.iter()\n                        .map(|(name, item)| (name.clone(), item.to_extern(store)))\n                        .collect(),\n                );\n                Instance::from_wasmtime(InstanceData::Synthetic(items), store).into()\n            }\n        }\n    }\n\n    pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {\n        match self {\n            Definition::Extern(e) => e.comes_from_same_store(store),\n            Definition::HostFunc(_func) => true,\n            Definition::Instance(i) => i.values().all(|e| e.comes_from_same_store(store)),\n        }\n    }\n}\n\n/// Modules can be interpreted either as Commands or Reactors.\nenum ModuleKind {\n    /// The instance is a Command, meaning an instance is created for each\n    /// exported function and lives for the duration of the function call.\n    Command,\n\n    /// The instance is a Reactor, meaning one instance is created which\n    /// may live across multiple calls.\n    Reactor,\n}\n\nimpl ModuleKind {\n    /// Determine whether the given module is a Command or a Reactor.\n    fn categorize(module: &Module) -> Result<ModuleKind> {\n        let command_start = module.get_export(\"_start\");\n        let reactor_start = module.get_export(\"_initialize\");\n        match (command_start, reactor_start) {\n            (Some(command_start), None) => {\n                if let Some(_) = command_start.func() {\n                    Ok(ModuleKind::Command)\n                } else {\n                    bail!(\"`_start` must be a function\")\n                }\n            }\n            (None, Some(reactor_start)) => {\n                if let Some(_) = reactor_start.func() {\n                    Ok(ModuleKind::Reactor)\n                } else {\n                    bail!(\"`_initialize` must be a function\")\n                }\n            }\n            (None, None) => {\n                // Module declares neither of the recognized functions, so treat\n                // it as a reactor with no initialization function.\n                Ok(ModuleKind::Reactor)\n            }\n            (Some(_), Some(_)) => {\n                // Module declares itself to be both a Command and a Reactor.\n                bail!(\"Program cannot be both a Command and a Reactor\")\n            }\n        }\n    }\n}\n", "use anyhow::Result;\nuse std::cell::Cell;\nuse std::rc::Rc;\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse std::sync::Arc;\nuse wasmtime::*;\n\n#[test]\nfn link_undefined() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let linker = Linker::new(store.engine());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (func)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (global i32)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (memory 1)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (import \"\" \"\" (table 1 funcref)))\"#,\n    )?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    Ok(())\n}\n\n#[test]\nfn link_twice_bad() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::<()>::new(store.engine());\n\n    // functions\n    linker.func_wrap(\"f\", \"\", || {})?;\n    assert!(linker.func_wrap(\"f\", \"\", || {}).is_err());\n    assert!(linker\n        .func_wrap(\"f\", \"\", || -> Result<(), Trap> { loop {} })\n        .is_err());\n\n    // globals\n    let ty = GlobalType::new(ValType::I32, Mutability::Const);\n    let global = Global::new(&mut store, ty, Val::I32(0))?;\n    linker.define(\"g\", \"1\", global.clone())?;\n    assert!(linker.define(\"g\", \"1\", global.clone()).is_err());\n\n    let ty = GlobalType::new(ValType::I32, Mutability::Var);\n    let global = Global::new(&mut store, ty, Val::I32(0))?;\n    linker.define(\"g\", \"2\", global.clone())?;\n    assert!(linker.define(\"g\", \"2\", global.clone()).is_err());\n\n    let ty = GlobalType::new(ValType::I64, Mutability::Const);\n    let global = Global::new(&mut store, ty, Val::I64(0))?;\n    linker.define(\"g\", \"3\", global.clone())?;\n    assert!(linker.define(\"g\", \"3\", global.clone()).is_err());\n\n    // memories\n    let ty = MemoryType::new(1, None);\n    let memory = Memory::new(&mut store, ty)?;\n    linker.define(\"m\", \"\", memory.clone())?;\n    assert!(linker.define(\"m\", \"\", memory.clone()).is_err());\n    let ty = MemoryType::new(2, None);\n    let memory = Memory::new(&mut store, ty)?;\n    assert!(linker.define(\"m\", \"\", memory.clone()).is_err());\n\n    // tables\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None))?;\n    linker.define(\"t\", \"\", table.clone())?;\n    assert!(linker.define(\"t\", \"\", table.clone()).is_err());\n    let ty = TableType::new(ValType::FuncRef, 2, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None))?;\n    assert!(linker.define(\"t\", \"\", table.clone()).is_err());\n    Ok(())\n}\n\n#[test]\nfn function_interposition() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    linker.allow_shadowing(true);\n    let mut module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"green\") (result i32) (i32.const 7)))\"#,\n    )?;\n    for _ in 0..4 {\n        let instance = linker.instantiate(&mut store, &module)?;\n        linker.define(\n            \"red\",\n            \"green\",\n            instance.get_export(&mut store, \"green\").unwrap().clone(),\n        )?;\n        module = Module::new(\n            store.engine(),\n            r#\"(module\n                (import \"red\" \"green\" (func (result i32)))\n                (func (export \"green\") (result i32) (i32.mul (call 0) (i32.const 2)))\n            )\"#,\n        )?;\n    }\n    let instance = linker.instantiate(&mut store, &module)?;\n    let func = instance\n        .get_export(&mut store, \"green\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    let func = func.typed::<(), i32, _>(&store)?;\n    assert_eq!(func.call(&mut store, ())?, 112);\n    Ok(())\n}\n\n// Same as `function_interposition`, but the linker's name for the function\n// differs from the module's name.\n#[test]\nfn function_interposition_renamed() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    linker.allow_shadowing(true);\n    let mut module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"export\") (result i32) (i32.const 7)))\"#,\n    )?;\n    for _ in 0..4 {\n        let instance = linker.instantiate(&mut store, &module)?;\n        linker.define(\n            \"red\",\n            \"green\",\n            instance.get_export(&mut store, \"export\").unwrap().clone(),\n        )?;\n        module = Module::new(\n            store.engine(),\n            r#\"(module\n                (import \"red\" \"green\" (func (result i32)))\n                (func (export \"export\") (result i32) (i32.mul (call 0) (i32.const 2)))\n            )\"#,\n        )?;\n    }\n    let instance = linker.instantiate(&mut store, &module)?;\n    let func = instance.get_func(&mut store, \"export\").unwrap();\n    let func = func.typed::<(), i32, _>(&store)?;\n    assert_eq!(func.call(&mut store, ())?, 112);\n    Ok(())\n}\n\n// Similar to `function_interposition`, but use `Linker::instance` instead of\n// `Linker::define`.\n#[test]\nfn module_interposition() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    linker.allow_shadowing(true);\n    let mut module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"export\") (result i32) (i32.const 7)))\"#,\n    )?;\n    for _ in 0..4 {\n        let instance = linker.instantiate(&mut store, &module)?;\n        linker.instance(&mut store, \"instance\", instance)?;\n        module = Module::new(\n            store.engine(),\n            r#\"(module\n                (import \"instance\" \"export\" (func (result i32)))\n                (func (export \"export\") (result i32) (i32.mul (call 0) (i32.const 2)))\n            )\"#,\n        )?;\n    }\n    let instance = linker.instantiate(&mut store, &module)?;\n    let func = instance\n        .get_export(&mut store, \"export\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    let func = func.typed::<(), i32, _>(&store)?;\n    assert_eq!(func.call(&mut store, ())?, 112);\n    Ok(())\n}\n\n#[test]\nfn allow_unknown_exports() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"_start\")) (global (export \"g\") i32 (i32.const 0)))\"#,\n    )?;\n\n    assert!(linker.module(&mut store, \"module\", &module).is_err());\n\n    let mut linker = Linker::new(store.engine());\n    linker.allow_unknown_exports(true);\n    linker.module(&mut store, \"module\", &module)?;\n\n    Ok(())\n}\n\n#[test]\nfn no_leak() -> Result<()> {\n    struct DropMe(Rc<Cell<bool>>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.set(true);\n        }\n    }\n\n    let flag = Rc::new(Cell::new(false));\n    {\n        let mut store = Store::new(&Engine::default(), DropMe(flag.clone()));\n        let mut linker = Linker::new(store.engine());\n        let module = Module::new(\n            store.engine(),\n            r#\"\n                (module\n                    (func (export \"_start\"))\n                )\n            \"#,\n        )?;\n        linker.module(&mut store, \"a\", &module)?;\n    }\n    assert!(flag.get(), \"store was leaked\");\n    Ok(())\n}\n\n#[test]\nfn no_leak_with_imports() -> Result<()> {\n    struct DropMe(Arc<AtomicUsize>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n\n    let flag = Arc::new(AtomicUsize::new(0));\n    {\n        let mut store = Store::new(&Engine::default(), DropMe(flag.clone()));\n        let mut linker = Linker::new(store.engine());\n        let drop_me = DropMe(flag.clone());\n        linker.func_wrap(\"\", \"\", move || drop(&drop_me))?;\n        let module = Module::new(\n            store.engine(),\n            r#\"\n                (module\n                    (import \"\" \"\" (func))\n                    (func (export \"_start\"))\n                )\n            \"#,\n        )?;\n        linker.module(&mut store, \"a\", &module)?;\n    }\n    assert!(flag.load(SeqCst) == 2, \"something was leaked\");\n    Ok(())\n}\n\n#[test]\nfn get_host_function() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (import \"mod\" \"f1\" (func)))\"#)?;\n\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\"mod\", \"f1\", || {})?;\n    let mut store = Store::<()>::default();\n    assert!(linker\n        .get_by_import(&mut store, &module.imports().nth(0).unwrap())\n        .is_some());\n\n    Ok(())\n}\n\n#[test]\nfn funcs_live_on_to_fight_another_day() -> Result<()> {\n    struct DropMe(Arc<AtomicUsize>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n\n    let flag = Arc::new(AtomicUsize::new(0));\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    let drop_me = DropMe(flag.clone());\n    linker.func_wrap(\"\", \"\", move || drop(&drop_me))?;\n    assert_eq!(flag.load(SeqCst), 0);\n\n    let get_and_call = || -> Result<()> {\n        assert_eq!(flag.load(SeqCst), 0);\n        let mut store = Store::new(&engine, ());\n        let func = linker.get(&mut store, \"\", Some(\"\")).unwrap();\n        func.into_func().unwrap().call(&mut store, &[])?;\n        assert_eq!(flag.load(SeqCst), 0);\n        Ok(())\n    };\n\n    get_and_call()?;\n    get_and_call()?;\n    drop(linker);\n    assert_eq!(flag.load(SeqCst), 1);\n    Ok(())\n}\n\n#[test]\nfn alias_one() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    assert!(linker.alias(\"a\", \"b\", \"c\", \"d\").is_err());\n    linker.func_wrap(\"a\", \"b\", || {})?;\n    assert!(linker.alias(\"a\", \"b\", \"c\", \"d\").is_ok());\n    assert!(linker.get(&mut store, \"a\", Some(\"b\")).is_some());\n    assert!(linker.get(&mut store, \"c\", Some(\"d\")).is_some());\n    Ok(())\n}\n\n#[test]\nfn instance_pre() -> Result<()> {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\"\", \"\", || {})?;\n\n    let module = Module::new(&engine, r#\"(module (import \"\" \"\" (func)))\"#)?;\n    let instance_pre = linker.instantiate_pre(&mut Store::new(&engine, ()), &module)?;\n    instance_pre.instantiate(&mut Store::new(&engine, ()))?;\n    instance_pre.instantiate(&mut Store::new(&engine, ()))?;\n\n    let mut store = Store::new(&engine, ());\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Const),\n        1.into(),\n    )?;\n    linker.define(\"\", \"g\", global)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module\n            (import \"\" \"\" (func))\n            (import \"\" \"g\" (global i32))\n        )\"#,\n    )?;\n    let instance_pre = linker.instantiate_pre(&mut store, &module)?;\n    instance_pre.instantiate(&mut store)?;\n    instance_pre.instantiate(&mut store)?;\n    Ok(())\n}\n"], "fixing_code": ["use crate::store::{StoreData, StoreOpaque, Stored};\nuse crate::{\n    AsContext, AsContextMut, CallHook, Engine, Extern, FuncType, Instance, InterruptHandle,\n    StoreContext, StoreContextMut, Trap, Val, ValType,\n};\nuse anyhow::{bail, Context as _, Result};\nuse std::cmp::max;\nuse std::error::Error;\nuse std::fmt;\nuse std::future::Future;\nuse std::mem;\nuse std::panic::{self, AssertUnwindSafe};\nuse std::pin::Pin;\nuse std::ptr::NonNull;\nuse std::sync::atomic::Ordering::Relaxed;\nuse std::sync::Arc;\nuse wasmtime_environ::{EntityIndex, FuncIndex};\nuse wasmtime_runtime::{\n    raise_user_trap, ExportFunction, InstanceAllocator, InstanceHandle, OnDemandInstanceAllocator,\n    VMCallerCheckedAnyfunc, VMContext, VMFunctionBody, VMFunctionImport, VMSharedSignatureIndex,\n    VMTrampoline,\n};\n\n/// A WebAssembly function which can be called.\n///\n/// This type can represent either an exported function from a WebAssembly\n/// module or a host-defined function which can be used to satisfy an import of\n/// a module. [`Func`] and can be used to both instantiate an [`Instance`] as\n/// well as be extracted from an [`Instance`].\n///\n/// [`Instance`]: crate::Instance\n///\n/// A [`Func`] \"belongs\" to the store that it was originally created within.\n/// Operations on a [`Func`] only work with the store it belongs to, and if\n/// another store is passed in by accident then methods will panic.\n///\n/// # `Func` and `async`\n///\n/// Functions from the perspective of WebAssembly are always synchronous. You\n/// might have an `async` function in Rust, however, which you'd like to make\n/// available from WebAssembly. Wasmtime supports asynchronously calling\n/// WebAssembly through native stack switching. You can get some more\n/// information about [asynchronous configs](crate::Config::async_support), but\n/// from the perspective of `Func` it's important to know that whether or not\n/// your [`Store`](crate::Store) is asynchronous will dictate whether you call\n/// functions through [`Func::call`] or [`Func::call_async`] (or the typed\n/// wrappers such as [`TypedFunc::call`] vs [`TypedFunc::call_async`]).\n///\n/// # To `Func::call` or to `Func::typed().call()`\n///\n/// There's a 2x2 matrix of methods to call [`Func`]. Invocations can either be\n/// asynchronous or synchronous. They can also be statically typed or not.\n/// Whether or not an invocation is asynchronous is indicated via the method\n/// being `async` and [`call_async`](Func::call_async) being the entry point.\n/// Otherwise for statically typed or not your options are:\n///\n/// * Dynamically typed - if you don't statically know the signature of the\n///   function that you're calling you'll be using [`Func::call`] or\n///   [`Func::call_async`]. These functions take a variable-length slice of\n///   \"boxed\" arguments in their [`Val`] representation. Additionally the\n///   results are returned as an owned slice of [`Val`]. These methods are not\n///   optimized due to the dynamic type checks that must occur, in addition to\n///   some dynamic allocations for where to put all the arguments. While this\n///   allows you to call all possible wasm function signatures, if you're\n///   looking for a speedier alternative you can also use...\n///\n/// * Statically typed - if you statically know the type signature of the wasm\n///   function you're calling, then you'll want to use the [`Func::typed`]\n///   method to acquire an instance of [`TypedFunc`]. This structure is static proof\n///   that the underlying wasm function has the ascripted type, and type\n///   validation is only done once up-front. The [`TypedFunc::call`] and\n///   [`TypedFunc::call_async`] methods are much more efficient than [`Func::call`]\n///   and [`Func::call_async`] because the type signature is statically known.\n///   This eschews runtime checks as much as possible to get into wasm as fast\n///   as possible.\n///\n/// # Examples\n///\n/// One way to get a `Func` is from an [`Instance`] after you've instantiated\n/// it:\n///\n/// ```\n/// # use wasmtime::*;\n/// # fn main() -> anyhow::Result<()> {\n/// let engine = Engine::default();\n/// let module = Module::new(&engine, r#\"(module (func (export \"foo\")))\"#)?;\n/// let mut store = Store::new(&engine, ());\n/// let instance = Instance::new(&mut store, &module, &[])?;\n/// let foo = instance.get_func(&mut store, \"foo\").expect(\"export wasn't a function\");\n///\n/// // Work with `foo` as a `Func` at this point, such as calling it\n/// // dynamically...\n/// match foo.call(&mut store, &[]) {\n///     Ok(result) => { /* ... */ }\n///     Err(trap) => {\n///         panic!(\"execution of `foo` resulted in a wasm trap: {}\", trap);\n///     }\n/// }\n/// foo.call(&mut store, &[])?;\n///\n/// // ... or we can make a static assertion about its signature and call it.\n/// // Our first call here can fail if the signatures don't match, and then the\n/// // second call can fail if the function traps (like the `match` above).\n/// let foo = foo.typed::<(), (), _>(&store)?;\n/// foo.call(&mut store, ())?;\n/// # Ok(())\n/// # }\n/// ```\n///\n/// You can also use the [`wrap` function](Func::wrap) to create a\n/// `Func`\n///\n/// ```\n/// # use wasmtime::*;\n/// # fn main() -> anyhow::Result<()> {\n/// let mut store = Store::<()>::default();\n///\n/// // Create a custom `Func` which can execute arbitrary code inside of the\n/// // closure.\n/// let add = Func::wrap(&mut store, |a: i32, b: i32| -> i32 { a + b });\n///\n/// // Next we can hook that up to a wasm module which uses it.\n/// let module = Module::new(\n///     store.engine(),\n///     r#\"\n///         (module\n///             (import \"\" \"\" (func $add (param i32 i32) (result i32)))\n///             (func (export \"call_add_twice\") (result i32)\n///                 i32.const 1\n///                 i32.const 2\n///                 call $add\n///                 i32.const 3\n///                 i32.const 4\n///                 call $add\n///                 i32.add))\n///     \"#,\n/// )?;\n/// let instance = Instance::new(&mut store, &module, &[add.into()])?;\n/// let call_add_twice = instance.get_typed_func::<(), i32, _>(&mut store, \"call_add_twice\")?;\n///\n/// assert_eq!(call_add_twice.call(&mut store, ())?, 10);\n/// # Ok(())\n/// # }\n/// ```\n///\n/// Or you could also create an entirely dynamic `Func`!\n///\n/// ```\n/// # use wasmtime::*;\n/// # fn main() -> anyhow::Result<()> {\n/// let mut store = Store::<()>::default();\n///\n/// // Here we need to define the type signature of our `Double` function and\n/// // then wrap it up in a `Func`\n/// let double_type = wasmtime::FuncType::new(\n///     [wasmtime::ValType::I32].iter().cloned(),\n///     [wasmtime::ValType::I32].iter().cloned(),\n/// );\n/// let double = Func::new(&mut store, double_type, |_, params, results| {\n///     let mut value = params[0].unwrap_i32();\n///     value *= 2;\n///     results[0] = value.into();\n///     Ok(())\n/// });\n///\n/// let module = Module::new(\n///     store.engine(),\n///     r#\"\n///         (module\n///             (import \"\" \"\" (func $double (param i32) (result i32)))\n///             (func $start\n///                 i32.const 1\n///                 call $double\n///                 drop)\n///             (start $start))\n///     \"#,\n/// )?;\n/// let instance = Instance::new(&mut store, &module, &[double.into()])?;\n/// // .. work with `instance` if necessary\n/// # Ok(())\n/// # }\n/// ```\n#[derive(Copy, Clone, Debug)]\n#[repr(transparent)] // here for the C API\npub struct Func(Stored<FuncData>);\n\n/// The three ways that a function can be created and referenced from within a\n/// store.\npub(crate) enum FuncData {\n    /// A function already owned by the store via some other means. This is\n    /// used, for example, when creating a `Func` from an instance's exported\n    /// function. The instance's `InstanceHandle` is already owned by the store\n    /// and we just have some pointers into that which represent how to call the\n    /// function.\n    StoreOwned {\n        trampoline: VMTrampoline,\n        export: ExportFunction,\n    },\n\n    /// A function is shared across possibly other stores, hence the `Arc`. This\n    /// variant happens when a `Linker`-defined function is instantiated within\n    /// a `Store` (e.g. via `Linker::get` or similar APIs). The `Arc` here\n    /// indicates that there's some number of other stores holding this function\n    /// too, so dropping this may not deallocate the underlying\n    /// `InstanceHandle`.\n    SharedHost(Arc<HostFunc>),\n\n    /// A uniquely-owned host function within a `Store`. This comes about with\n    /// `Func::new` or similar APIs. The `HostFunc` internally owns the\n    /// `InstanceHandle` and that will get dropped when this `HostFunc` itself\n    /// is dropped.\n    Host(HostFunc),\n}\n\nmacro_rules! for_each_function_signature {\n    ($mac:ident) => {\n        $mac!(0);\n        $mac!(1 A1);\n        $mac!(2 A1 A2);\n        $mac!(3 A1 A2 A3);\n        $mac!(4 A1 A2 A3 A4);\n        $mac!(5 A1 A2 A3 A4 A5);\n        $mac!(6 A1 A2 A3 A4 A5 A6);\n        $mac!(7 A1 A2 A3 A4 A5 A6 A7);\n        $mac!(8 A1 A2 A3 A4 A5 A6 A7 A8);\n        $mac!(9 A1 A2 A3 A4 A5 A6 A7 A8 A9);\n        $mac!(10 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10);\n        $mac!(11 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11);\n        $mac!(12 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12);\n        $mac!(13 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13);\n        $mac!(14 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14);\n        $mac!(15 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15);\n        $mac!(16 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16);\n    };\n}\n\nmod typed;\npub use typed::*;\n\nmacro_rules! generate_wrap_async_func {\n    ($num:tt $($args:ident)*) => (paste::paste!{\n        /// Same as [`Func::wrap`], except the closure asynchronously produces\n        /// its result. For more information see the [`Func`] documentation.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if called with a non-asynchronous store.\n        #[allow(non_snake_case)]\n        #[cfg(feature = \"async\")]\n        #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n        pub fn [<wrap $num _async>]<T, $($args,)* R>(\n            store: impl AsContextMut<Data = T>,\n            func: impl for<'a> Fn(Caller<'a, T>, $($args),*) -> Box<dyn Future<Output = R> + Send + 'a> + Send + Sync + 'static,\n        ) -> Func\n        where\n            $($args: WasmTy,)*\n            R: WasmRet,\n        {\n            assert!(store.as_context().async_support(), concat!(\"cannot use `wrap\", $num, \"_async` without enabling async support on the config\"));\n            Func::wrap(store, move |mut caller: Caller<'_, T>, $($args: $args),*| {\n                let async_cx = caller.store.as_context_mut().0.async_cx();\n                let mut future = Pin::from(func(caller, $($args),*));\n                match unsafe { async_cx.block_on(future.as_mut()) } {\n                    Ok(ret) => ret.into_fallible(),\n                    Err(e) => R::fallible_from_trap(e),\n                }\n            })\n        }\n    })\n}\n\nimpl Func {\n    /// Creates a new `Func` with the given arguments, typically to create a\n    /// host-defined function to pass as an import to a module.\n    ///\n    /// * `store` - the store in which to create this [`Func`], which will own\n    ///   the return value.\n    ///\n    /// * `ty` - the signature of this function, used to indicate what the\n    ///   inputs and outputs are.\n    ///\n    /// * `func` - the native code invoked whenever this `Func` will be called.\n    ///   This closure is provided a [`Caller`] as its first argument to learn\n    ///   information about the caller, and then it's passed a list of\n    ///   parameters as a slice along with a mutable slice of where to write\n    ///   results.\n    ///\n    /// Note that the implementation of `func` must adhere to the `ty` signature\n    /// given, error or traps may occur if it does not respect the `ty`\n    /// signature. For example if the function type declares that it returns one\n    /// i32 but the `func` closures does not write anything into the results\n    /// slice then a trap may be generated.\n    ///\n    /// Additionally note that this is quite a dynamic function since signatures\n    /// are not statically known. For a more performant and ergonomic `Func`\n    /// it's recommended to use [`Func::wrap`] if you can because with\n    /// statically known signatures Wasmtime can optimize the implementation\n    /// much more.\n    ///\n    /// For more information about `Send + Sync + 'static` requirements on the\n    /// `func`, see [`Func::wrap`](#why-send--sync--static).\n    #[cfg(compiler)]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"cranelift\")))] // see build.rs\n    pub fn new<T>(\n        mut store: impl AsContextMut<Data = T>,\n        ty: FuncType,\n        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,\n    ) -> Self {\n        let store = store.as_context_mut().0;\n\n        // part of this unsafety is about matching the `T` to a `Store<T>`,\n        // which is done through the `AsContextMut` bound above.\n        unsafe {\n            let host = HostFunc::new(store.engine(), ty, func);\n            host.into_func(store)\n        }\n    }\n\n    /// Creates a new host-defined WebAssembly function which, when called,\n    /// will run the asynchronous computation defined by `func` to completion\n    /// and then return the result to WebAssembly.\n    ///\n    /// This function is the asynchronous analogue of [`Func::new`] and much of\n    /// that documentation applies to this as well. The key difference is that\n    /// `func` returns a future instead of simply a `Result`. Note that the\n    /// returned future can close over any of the arguments, but it cannot close\n    /// over the state of the closure itself. It's recommended to store any\n    /// necessary async state in the `T` of the [`Store<T>`](crate::Store) which\n    /// can be accessed through [`Caller::data`] or [`Caller::data_mut`].\n    ///\n    /// For more information on `Send + Sync + 'static`, see\n    /// [`Func::wrap`](#why-send--sync--static).\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `store` is not associated with an [async\n    /// config](crate::Config::async_support).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// // Simulate some application-specific state as well as asynchronous\n    /// // functions to query that state.\n    /// struct MyDatabase {\n    ///     // ...\n    /// }\n    ///\n    /// impl MyDatabase {\n    ///     async fn get_row_count(&self) -> u32 {\n    ///         // ...\n    /// #       100\n    ///     }\n    /// }\n    ///\n    /// let my_database = MyDatabase {\n    ///     // ...\n    /// };\n    ///\n    /// // Using `new_async` we can hook up into calling our async\n    /// // `get_row_count` function.\n    /// let engine = Engine::new(Config::new().async_support(true))?;\n    /// let mut store = Store::new(&engine, MyDatabase {\n    ///     // ...\n    /// });\n    /// let get_row_count_type = wasmtime::FuncType::new(\n    ///     None,\n    ///     Some(wasmtime::ValType::I32),\n    /// );\n    /// let get = Func::new_async(&mut store, get_row_count_type, |caller, _params, results| {\n    ///     Box::new(async move {\n    ///         let count = caller.data().get_row_count().await;\n    ///         results[0] = Val::I32(count as i32);\n    ///         Ok(())\n    ///     })\n    /// });\n    /// // ...\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[cfg(all(feature = \"async\", feature = \"cranelift\"))]\n    #[cfg_attr(nightlydoc, doc(cfg(all(feature = \"async\", feature = \"cranelift\"))))]\n    pub fn new_async<T, F>(store: impl AsContextMut<Data = T>, ty: FuncType, func: F) -> Func\n    where\n        F: for<'a> Fn(\n                Caller<'a, T>,\n                &'a [Val],\n                &'a mut [Val],\n            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>\n            + Send\n            + Sync\n            + 'static,\n    {\n        assert!(\n            store.as_context().async_support(),\n            \"cannot use `new_async` without enabling async support in the config\"\n        );\n        Func::new(store, ty, move |mut caller, params, results| {\n            let async_cx = caller.store.as_context_mut().0.async_cx();\n            let mut future = Pin::from(func(caller, params, results));\n            match unsafe { async_cx.block_on(future.as_mut()) } {\n                Ok(Ok(())) => Ok(()),\n                Ok(Err(trap)) | Err(trap) => Err(trap),\n            }\n        })\n    }\n\n    pub(crate) unsafe fn from_caller_checked_anyfunc(\n        store: &mut StoreOpaque,\n        anyfunc: *mut VMCallerCheckedAnyfunc,\n    ) -> Option<Self> {\n        let anyfunc = NonNull::new(anyfunc)?;\n        debug_assert!(anyfunc.as_ref().type_index != VMSharedSignatureIndex::default());\n        let export = ExportFunction { anyfunc };\n        Some(Func::from_wasmtime_function(export, store))\n    }\n\n    /// Creates a new `Func` from the given Rust closure.\n    ///\n    /// This function will create a new `Func` which, when called, will\n    /// execute the given Rust closure. Unlike [`Func::new`] the target\n    /// function being called is known statically so the type signature can\n    /// be inferred. Rust types will map to WebAssembly types as follows:\n    ///\n    /// | Rust Argument Type  | WebAssembly Type |\n    /// |---------------------|------------------|\n    /// | `i32`               | `i32`            |\n    /// | `u32`               | `i32`            |\n    /// | `i64`               | `i64`            |\n    /// | `u64`               | `i64`            |\n    /// | `f32`               | `f32`            |\n    /// | `f64`               | `f64`            |\n    /// | (not supported)     | `v128`           |\n    /// | `Option<Func>`      | `funcref`        |\n    /// | `Option<ExternRef>` | `externref`      |\n    ///\n    /// Any of the Rust types can be returned from the closure as well, in\n    /// addition to some extra types\n    ///\n    /// | Rust Return Type  | WebAssembly Return Type | Meaning               |\n    /// |-------------------|-------------------------|-----------------------|\n    /// | `()`              | nothing                 | no return value       |\n    /// | `T`               | `T`                     | a single return value |\n    /// | `(T1, T2, ...)`   | `T1 T2 ...`             | multiple returns      |\n    ///\n    /// Note that all return types can also be wrapped in `Result<_, Trap>` to\n    /// indicate that the host function can generate a trap as well as possibly\n    /// returning a value.\n    ///\n    /// Finally you can also optionally take [`Caller`] as the first argument of\n    /// your closure. If inserted then you're able to inspect the caller's\n    /// state, for example the [`Memory`](crate::Memory) it has exported so you\n    /// can read what pointers point to.\n    ///\n    /// Note that when using this API, the intention is to create as thin of a\n    /// layer as possible for when WebAssembly calls the function provided. With\n    /// sufficient inlining and optimization the WebAssembly will call straight\n    /// into `func` provided, with no extra fluff entailed.\n    ///\n    /// # Why `Send + Sync + 'static`?\n    ///\n    /// All host functions defined in a [`Store`](crate::Store) (including\n    /// those from [`Func::new`] and other constructors) require that the\n    /// `func` provided is `Send + Sync + 'static`. Additionally host functions\n    /// always are `Fn` as opposed to `FnMut` or `FnOnce`. This can at-a-glance\n    /// feel restrictive since the closure cannot close over as many types as\n    /// before. The reason for this, though, is to ensure that\n    /// [`Store<T>`](crate::Store) can implement both the `Send` and `Sync`\n    /// traits.\n    ///\n    /// Fear not, however, because this isn't as restrictive as it seems! Host\n    /// functions are provided a [`Caller<'_, T>`](crate::Caller) argument which\n    /// allows access to the host-defined data within the\n    /// [`Store`](crate::Store). The `T` type is not required to be any of\n    /// `Send`, `Sync`, or `'static`! This means that you can store whatever\n    /// you'd like in `T` and have it accessible by all host functions.\n    /// Additionally mutable access to `T` is allowed through\n    /// [`Caller::data_mut`].\n    ///\n    /// Most host-defined [`Func`] values provide closures that end up not\n    /// actually closing over any values. These zero-sized types will use the\n    /// context from [`Caller`] for host-defined information.\n    ///\n    /// # Examples\n    ///\n    /// First up we can see how simple wasm imports can be implemented, such\n    /// as a function that adds its two arguments and returns the result.\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::<()>::default();\n    /// let add = Func::wrap(&mut store, |a: i32, b: i32| a + b);\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $add (param i32 i32) (result i32)))\n    ///             (func (export \"foo\") (param i32 i32) (result i32)\n    ///                 local.get 0\n    ///                 local.get 1\n    ///                 call $add))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[add.into()])?;\n    /// let foo = instance.get_typed_func::<(i32, i32), i32, _>(&mut store, \"foo\")?;\n    /// assert_eq!(foo.call(&mut store, (1, 2))?, 3);\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// We can also do the same thing, but generate a trap if the addition\n    /// overflows:\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::<()>::default();\n    /// let add = Func::wrap(&mut store, |a: i32, b: i32| {\n    ///     match a.checked_add(b) {\n    ///         Some(i) => Ok(i),\n    ///         None => Err(Trap::new(\"overflow\")),\n    ///     }\n    /// });\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $add (param i32 i32) (result i32)))\n    ///             (func (export \"foo\") (param i32 i32) (result i32)\n    ///                 local.get 0\n    ///                 local.get 1\n    ///                 call $add))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[add.into()])?;\n    /// let foo = instance.get_typed_func::<(i32, i32), i32, _>(&mut store, \"foo\")?;\n    /// assert_eq!(foo.call(&mut store, (1, 2))?, 3);\n    /// assert!(foo.call(&mut store, (i32::max_value(), 1)).is_err());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// And don't forget all the wasm types are supported!\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::<()>::default();\n    /// let debug = Func::wrap(&mut store, |a: i32, b: u32, c: f32, d: i64, e: u64, f: f64| {\n    ///\n    ///     println!(\"a={}\", a);\n    ///     println!(\"b={}\", b);\n    ///     println!(\"c={}\", c);\n    ///     println!(\"d={}\", d);\n    ///     println!(\"e={}\", e);\n    ///     println!(\"f={}\", f);\n    /// });\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $debug (param i32 i32 f32 i64 i64 f64)))\n    ///             (func (export \"foo\")\n    ///                 i32.const -1\n    ///                 i32.const 1\n    ///                 f32.const 2\n    ///                 i64.const -3\n    ///                 i64.const 3\n    ///                 f64.const 4\n    ///                 call $debug))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[debug.into()])?;\n    /// let foo = instance.get_typed_func::<(), (), _>(&mut store, \"foo\")?;\n    /// foo.call(&mut store, ())?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// Finally if you want to get really fancy you can also implement\n    /// imports that read/write wasm module's memory\n    ///\n    /// ```\n    /// use std::str;\n    ///\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let mut store = Store::default();\n    /// let log_str = Func::wrap(&mut store, |mut caller: Caller<'_, ()>, ptr: i32, len: i32| {\n    ///     let mem = match caller.get_export(\"memory\") {\n    ///         Some(Extern::Memory(mem)) => mem,\n    ///         _ => return Err(Trap::new(\"failed to find host memory\")),\n    ///     };\n    ///     let data = mem.data(&caller)\n    ///         .get(ptr as u32 as usize..)\n    ///         .and_then(|arr| arr.get(..len as u32 as usize));\n    ///     let string = match data {\n    ///         Some(data) => match str::from_utf8(data) {\n    ///             Ok(s) => s,\n    ///             Err(_) => return Err(Trap::new(\"invalid utf-8\")),\n    ///         },\n    ///         None => return Err(Trap::new(\"pointer/length out of bounds\")),\n    ///     };\n    ///     assert_eq!(string, \"Hello, world!\");\n    ///     println!(\"{}\", string);\n    ///     Ok(())\n    /// });\n    /// let module = Module::new(\n    ///     store.engine(),\n    ///     r#\"\n    ///         (module\n    ///             (import \"\" \"\" (func $log_str (param i32 i32)))\n    ///             (func (export \"foo\")\n    ///                 i32.const 4   ;; ptr\n    ///                 i32.const 13  ;; len\n    ///                 call $log_str)\n    ///             (memory (export \"memory\") 1)\n    ///             (data (i32.const 4) \"Hello, world!\"))\n    ///     \"#,\n    /// )?;\n    /// let instance = Instance::new(&mut store, &module, &[log_str.into()])?;\n    /// let foo = instance.get_typed_func::<(), (), _>(&mut store, \"foo\")?;\n    /// foo.call(&mut store, ())?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn wrap<T, Params, Results>(\n        mut store: impl AsContextMut<Data = T>,\n        func: impl IntoFunc<T, Params, Results>,\n    ) -> Func {\n        let store = store.as_context_mut().0;\n        // part of this unsafety is about matching the `T` to a `Store<T>`,\n        // which is done through the `AsContextMut` bound above.\n        unsafe {\n            let host = HostFunc::wrap(store.engine(), func);\n            host.into_func(store)\n        }\n    }\n\n    for_each_function_signature!(generate_wrap_async_func);\n\n    /// Returns the underlying wasm type that this `Func` has.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this function.\n    pub fn ty(&self, store: impl AsContext) -> FuncType {\n        // Signatures should always be registered in the engine's registry of\n        // shared signatures, so we should be able to unwrap safely here.\n        let store = store.as_context();\n        let sig_index = unsafe { store[self.0].export().anyfunc.as_ref().type_index };\n        FuncType::from_wasm_func_type(\n            store\n                .engine()\n                .signatures()\n                .lookup_type(sig_index)\n                .expect(\"signature should be registered\"),\n        )\n    }\n\n    pub(crate) fn sig_index(&self, data: &StoreData) -> VMSharedSignatureIndex {\n        unsafe { data[self.0].export().anyfunc.as_ref().type_index }\n    }\n\n    /// Invokes this function with the `params` given, returning the results and\n    /// any trap, if one occurs.\n    ///\n    /// The `params` here must match the type signature of this `Func`, or a\n    /// trap will occur. If a trap occurs while executing this function, then a\n    /// trap will also be returned.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if called on a function belonging to an async\n    /// store. Asynchronous stores must always use `call_async`.\n    /// initiates a panic. Also panics if `store` does not own this function.\n    pub fn call(&self, mut store: impl AsContextMut, params: &[Val]) -> Result<Box<[Val]>> {\n        assert!(\n            !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        let my_ty = self.ty(&store);\n        self.call_impl(&mut store.as_context_mut(), my_ty, params)\n    }\n\n    /// Invokes this function with the `params` given, returning the results\n    /// asynchronously.\n    ///\n    /// This function is the same as [`Func::call`] except that it is\n    /// asynchronous. This is only compatible with stores associated with an\n    /// [asynchronous config](crate::Config::async_support).\n    ///\n    /// It's important to note that the execution of WebAssembly will happen\n    /// synchronously in the `poll` method of the future returned from this\n    /// function. Wasmtime does not manage its own thread pool or similar to\n    /// execute WebAssembly in. Future `poll` methods are generally expected to\n    /// resolve quickly, so it's recommended that you run or poll this future\n    /// in a \"blocking context\".\n    ///\n    /// For more information see the documentation on [asynchronous\n    /// configs](crate::Config::async_support).\n    ///\n    /// # Panics\n    ///\n    /// Panics if this is called on a function in a synchronous store. This\n    /// only works with functions defined within an asynchronous store. Also\n    /// panics if `store` does not own this function.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn call_async<T>(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        params: &[Val],\n    ) -> Result<Box<[Val]>>\n    where\n        T: Send,\n    {\n        let mut store = store.as_context_mut();\n        assert!(\n            store.0.async_support(),\n            \"cannot use `call_async` without enabling async support in the config\",\n        );\n        let my_ty = self.ty(&store);\n        let result = store\n            .on_fiber(|store| self.call_impl(store, my_ty, params))\n            .await??;\n        Ok(result)\n    }\n\n    fn call_impl<T>(\n        &self,\n        store: &mut StoreContextMut<'_, T>,\n        my_ty: FuncType,\n        params: &[Val],\n    ) -> Result<Box<[Val]>> {\n        let mut values_vec = write_params(store.0, &my_ty, params)?;\n\n        // Call the trampoline.\n        unsafe {\n            let data = &store.0.store_data()[self.0];\n            let trampoline = data.trampoline();\n            let anyfunc = data.export().anyfunc;\n            invoke_wasm_and_catch_traps(store, |callee| {\n                trampoline(\n                    (*anyfunc.as_ptr()).vmctx,\n                    callee,\n                    (*anyfunc.as_ptr()).func_ptr.as_ptr(),\n                    values_vec.as_mut_ptr(),\n                )\n            })?;\n        }\n\n        return Ok(read_results(store.0, &my_ty, &values_vec));\n\n        fn write_params(\n            store: &mut StoreOpaque,\n            ty: &FuncType,\n            params: &[Val],\n        ) -> Result<Vec<u128>> {\n            // We need to perform a dynamic check that the arguments given to us\n            // match the signature of this function and are appropriate to pass to\n            // this function. This involves checking to make sure we have the right\n            // number and types of arguments as well as making sure everything is\n            // from the same `Store`.\n            if ty.params().len() != params.len() {\n                bail!(\n                    \"expected {} arguments, got {}\",\n                    ty.params().len(),\n                    params.len()\n                );\n            }\n\n            let mut values_vec = vec![0; max(params.len(), ty.results().len())];\n\n            // Whenever we pass `externref`s from host code to Wasm code, they\n            // go into the `VMExternRefActivationsTable`. But the table might be\n            // at capacity already, so check for that. If it is at capacity\n            // (unlikely) then do a GC to free up space. This is necessary\n            // because otherwise we would either keep filling up the bump chunk\n            // and making it larger and larger or we would always take the slow\n            // path when inserting references into the table.\n            if ty.as_wasm_func_type().externref_params_count()\n                > store\n                    .externref_activations_table()\n                    .bump_capacity_remaining()\n            {\n                store.gc();\n            }\n\n            // Store the argument values into `values_vec`.\n            let param_tys = ty.params();\n            for ((arg, slot), ty) in params.iter().cloned().zip(&mut values_vec).zip(param_tys) {\n                if arg.ty() != ty {\n                    bail!(\n                        \"argument type mismatch: found {} but expected {}\",\n                        arg.ty(),\n                        ty\n                    );\n                }\n                if !arg.comes_from_same_store(store) {\n                    bail!(\"cross-`Store` values are not currently supported\");\n                }\n                unsafe {\n                    arg.write_value_without_gc(store, slot);\n                }\n            }\n\n            Ok(values_vec)\n        }\n\n        fn read_results(store: &mut StoreOpaque, ty: &FuncType, values_vec: &[u128]) -> Box<[Val]> {\n            let mut results = Vec::with_capacity(ty.results().len());\n            for (index, ty) in ty.results().enumerate() {\n                unsafe {\n                    let ptr = &values_vec[index];\n                    results.push(Val::read_value_from(store, ptr, ty));\n                }\n            }\n            results.into()\n        }\n    }\n\n    #[inline]\n    pub(crate) fn caller_checked_anyfunc(\n        &self,\n        store: &StoreOpaque,\n    ) -> NonNull<VMCallerCheckedAnyfunc> {\n        store.store_data()[self.0].export().anyfunc\n    }\n\n    pub(crate) unsafe fn from_wasmtime_function(\n        export: ExportFunction,\n        store: &mut StoreOpaque,\n    ) -> Self {\n        let anyfunc = export.anyfunc.as_ref();\n        let trampoline = store.lookup_trampoline(&*anyfunc);\n        let data = FuncData::StoreOwned { trampoline, export };\n        Func(store.store_data_mut().insert(data))\n    }\n\n    pub(crate) fn vmimport(&self, store: &mut StoreOpaque) -> VMFunctionImport {\n        unsafe {\n            let f = self.caller_checked_anyfunc(store);\n            VMFunctionImport {\n                body: f.as_ref().func_ptr,\n                vmctx: f.as_ref().vmctx,\n            }\n        }\n    }\n\n    pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {\n        store.store_data().contains(self.0)\n    }\n\n    fn invoke<T>(\n        mut caller: Caller<'_, T>,\n        ty: &FuncType,\n        values_vec: *mut u128,\n        func: &dyn Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap>,\n    ) -> Result<(), Trap> {\n        caller.store.0.call_hook(CallHook::CallingHost)?;\n\n        // Translate the raw JIT arguments in `values_vec` into a `Val` which\n        // we'll be passing as a slice. The storage for our slice-of-`Val` we'll\n        // be taking from the `Store`. We preserve our slice back into the\n        // `Store` after the hostcall, ideally amortizing the cost of allocating\n        // the storage across wasm->host calls.\n        //\n        // Note that we have a dynamic guarantee that `values_vec` is the\n        // appropriate length to both read all arguments from as well as store\n        // all results into.\n        let mut val_vec = caller.store.0.take_hostcall_val_storage();\n        debug_assert!(val_vec.is_empty());\n        let nparams = ty.params().len();\n        val_vec.reserve(nparams + ty.results().len());\n        for (i, ty) in ty.params().enumerate() {\n            unsafe {\n                let val = Val::read_value_from(caller.store.0, values_vec.add(i), ty);\n                val_vec.push(val);\n            }\n        }\n\n        val_vec.extend((0..ty.results().len()).map(|_| Val::null()));\n        let (params, results) = val_vec.split_at_mut(nparams);\n        func(caller.sub_caller(), params, results)?;\n\n        // See the comment in `Func::call_impl`'s `write_params` function.\n        if ty.as_wasm_func_type().externref_returns_count()\n            > caller\n                .store\n                .0\n                .externref_activations_table()\n                .bump_capacity_remaining()\n        {\n            caller.store.gc();\n        }\n\n        // Unlike our arguments we need to dynamically check that the return\n        // values produced are correct. There could be a bug in `func` that\n        // produces the wrong number, wrong types, or wrong stores of\n        // values, and we need to catch that here.\n        for (i, (ret, ty)) in results.iter().zip(ty.results()).enumerate() {\n            if ret.ty() != ty {\n                return Err(Trap::new(\n                    \"function attempted to return an incompatible value\",\n                ));\n            }\n            if !ret.comes_from_same_store(caller.store.0) {\n                return Err(Trap::new(\n                    \"cross-`Store` values are not currently supported\",\n                ));\n            }\n            unsafe {\n                ret.write_value_without_gc(caller.store.0, values_vec.add(i));\n            }\n        }\n\n        // Restore our `val_vec` back into the store so it's usable for the next\n        // hostcall to reuse our own storage.\n        val_vec.truncate(0);\n        caller.store.0.save_hostcall_val_storage(val_vec);\n        caller.store.0.call_hook(CallHook::ReturningFromHost)?;\n        Ok(())\n    }\n\n    /// Attempts to extract a typed object from this `Func` through which the\n    /// function can be called.\n    ///\n    /// This function serves as an alternative to [`Func::call`] and\n    /// [`Func::call_async`]. This method performs a static type check (using\n    /// the `Params` and `Results` type parameters on the underlying wasm\n    /// function. If the type check passes then a `TypedFunc` object is returned,\n    /// otherwise an error is returned describing the typecheck failure.\n    ///\n    /// The purpose of this relative to [`Func::call`] is that it's much more\n    /// efficient when used to invoke WebAssembly functions. With the types\n    /// statically known far less setup/teardown is required when invoking\n    /// WebAssembly. If speed is desired then this function is recommended to be\n    /// used instead of [`Func::call`] (which is more general, hence its\n    /// slowdown).\n    ///\n    /// The `Params` type parameter is used to describe the parameters of the\n    /// WebAssembly function. This can either be a single type (like `i32`), or\n    /// a tuple of types representing the list of parameters (like `(i32, f32,\n    /// f64)`). Additionally you can use `()` to represent that the function has\n    /// no parameters.\n    ///\n    /// The `Results` type parameter is used to describe the results of the\n    /// function. This behaves the same way as `Params`, but just for the\n    /// results of the function.\n    ///\n    /// The `S` type parameter represents the method of passing in the store\n    /// context, and can typically be specified as simply `_` when calling this\n    /// function.\n    ///\n    /// Translation between Rust types and WebAssembly types looks like:\n    ///\n    /// | WebAssembly | Rust                |\n    /// |-------------|---------------------|\n    /// | `i32`       | `i32` or `u32`      |\n    /// | `i64`       | `i64` or `u64`      |\n    /// | `f32`       | `f32`               |\n    /// | `f64`       | `f64`               |\n    /// | `externref` | `Option<ExternRef>` |\n    /// | `funcref`   | `Option<Func>`      |\n    /// | `v128`      | not supported       |\n    ///\n    /// (note that this mapping is the same as that of [`Func::wrap`]).\n    ///\n    /// Note that once the [`TypedFunc`] return value is acquired you'll use either\n    /// [`TypedFunc::call`] or [`TypedFunc::call_async`] as necessary to actually invoke\n    /// the function. This method does not invoke any WebAssembly code, it\n    /// simply performs a typecheck before returning the [`TypedFunc`] value.\n    ///\n    /// This method also has a convenience wrapper as\n    /// [`Instance::get_typed_func`](crate::Instance::get_typed_func) to\n    /// directly get a typed function value from an\n    /// [`Instance`](crate::Instance).\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `Params` or `Results` does not\n    /// match the native type of this WebAssembly function.\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if `store` does not own this function.\n    ///\n    /// # Examples\n    ///\n    /// An end-to-end example of calling a function which takes no parameters\n    /// and has no results:\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// let engine = Engine::default();\n    /// let mut store = Store::new(&engine, ());\n    /// let module = Module::new(&engine, r#\"(module (func (export \"foo\")))\"#)?;\n    /// let instance = Instance::new(&mut store, &module, &[])?;\n    /// let foo = instance.get_func(&mut store, \"foo\").expect(\"export wasn't a function\");\n    ///\n    /// // Note that this call can fail due to the typecheck not passing, but\n    /// // in our case we statically know the module so we know this should\n    /// // pass.\n    /// let typed = foo.typed::<(), (), _>(&store)?;\n    ///\n    /// // Note that this can fail if the wasm traps at runtime.\n    /// typed.call(&mut store, ())?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// You can also pass in multiple parameters and get a result back\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn foo(add: &Func, mut store: Store<()>) -> anyhow::Result<()> {\n    /// let typed = add.typed::<(i32, i64), f32, _>(&store)?;\n    /// assert_eq!(typed.call(&mut store, (1, 2))?, 3.0);\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// and similarly if a function has multiple results you can bind that too\n    ///\n    /// ```\n    /// # #[cfg(not(feature = \"old-x86-backend\"))]\n    /// # use wasmtime::*;\n    /// # #[cfg(not(feature = \"old-x86-backend\"))]\n    /// # fn foo(add_with_overflow: &Func, mut store: Store<()>) -> anyhow::Result<()> {\n    /// let typed = add_with_overflow.typed::<(u32, u32), (u32, i32), _>(&store)?;\n    /// let (result, overflow) = typed.call(&mut store, (u32::max_value(), 2))?;\n    /// assert_eq!(result, 1);\n    /// assert_eq!(overflow, 1);\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn typed<Params, Results, S>(&self, store: S) -> Result<TypedFunc<Params, Results>>\n    where\n        Params: WasmParams,\n        Results: WasmResults,\n        S: AsContext,\n    {\n        // Type-check that the params/results are all valid\n        let ty = self.ty(store);\n        Params::typecheck(ty.params()).context(\"type mismatch with parameters\")?;\n        Results::typecheck(ty.results()).context(\"type mismatch with results\")?;\n\n        // and then we can construct the typed version of this function\n        // (unsafely), which should be safe since we just did the type check above.\n        unsafe { Ok(TypedFunc::new_unchecked(*self)) }\n    }\n}\n\n/// Prepares for entrance into WebAssembly.\n///\n/// This function will set up context such that `closure` is allowed to call a\n/// raw trampoline or a raw WebAssembly function. This *must* be called to do\n/// things like catch traps and set up GC properly.\n///\n/// The `closure` provided receives a default \"callee\" `VMContext` parameter it\n/// can pass to the called wasm function, if desired.\npub(crate) fn invoke_wasm_and_catch_traps<T>(\n    store: &mut StoreContextMut<'_, T>,\n    closure: impl FnMut(*mut VMContext),\n) -> Result<(), Trap> {\n    unsafe {\n        let exit = enter_wasm(store)?;\n\n        if let Err(trap) = store.0.call_hook(CallHook::CallingWasm) {\n            exit_wasm(store, exit);\n            return Err(trap);\n        }\n        let result = wasmtime_runtime::catch_traps(\n            store.0.vminterrupts(),\n            store.0.signal_handler(),\n            store.0.default_callee(),\n            closure,\n        );\n        exit_wasm(store, exit);\n        store.0.call_hook(CallHook::ReturningFromWasm)?;\n        result.map_err(Trap::from_runtime_box)\n    }\n}\n\n/// This function is called to register state within `Store` whenever\n/// WebAssembly is entered within the `Store`.\n///\n/// This function sets up various limits such as:\n///\n/// * The stack limit. This is what ensures that we limit the stack space\n///   allocated by WebAssembly code and it's relative to the initial stack\n///   pointer that called into wasm.\n///\n/// * Stack canaries for externref gc tracing. Currently the implementation\n///   relies on walking frames but the stack walker isn't always 100% reliable,\n///   so a canary is used to ensure that if the canary is seen then it's\n///   guaranteed all wasm frames have been walked.\n///\n/// This function may fail if the the stack limit can't be set because an\n/// interrupt already happened.\nfn enter_wasm<T>(store: &mut StoreContextMut<'_, T>) -> Result<Option<usize>, Trap> {\n    // If this is a recursive call, e.g. our stack canary is already set, then\n    // we may be able to skip this function.\n    //\n    // For synchronous stores there's nothing else to do because all wasm calls\n    // happen synchronously and on the same stack. This means that the previous\n    // stack limit will suffice for the next recursive call.\n    //\n    // For asynchronous stores then each call happens on a separate native\n    // stack. This means that the previous stack limit is no longer relevant\n    // because we're on a separate stack. In this situation we need to\n    // update the stack limit, but we don't need to update the gc stack canary\n    // in this situation.\n    if store\n        .0\n        .externref_activations_table()\n        .stack_canary()\n        .is_some()\n        && !store.0.async_support()\n    {\n        return Ok(None);\n    }\n\n    let stack_pointer = psm::stack_pointer() as usize;\n\n    // Determine the stack pointer where, after which, any wasm code will\n    // immediately trap. This is checked on the entry to all wasm functions.\n    //\n    // Note that this isn't 100% precise. We are requested to give wasm\n    // `max_wasm_stack` bytes, but what we're actually doing is giving wasm\n    // probably a little less than `max_wasm_stack` because we're\n    // calculating the limit relative to this function's approximate stack\n    // pointer. Wasm will be executed on a frame beneath this one (or next\n    // to it). In any case it's expected to be at most a few hundred bytes\n    // of slop one way or another. When wasm is typically given a MB or so\n    // (a million bytes) the slop shouldn't matter too much.\n    //\n    // After we've got the stack limit then we store it into the `stack_limit`\n    // variable. Note that the store is an atomic swap to ensure that we can\n    // consume any previously-sent interrupt requests. If we found that wasm was\n    // previously interrupted then we immediately return a trap (after resetting\n    // the stack limit). Otherwise we're good to keep on going.\n    //\n    // Note the usage of `Relaxed` memory orderings here. This is specifically\n    // an optimization in the `Drop` below where a `Relaxed` store is speedier\n    // than a `SeqCst` store. The rationale for `Relaxed` here is that the\n    // atomic orderings here aren't actually protecting any memory, we're just\n    // trying to be atomic with respect to this one location in memory (for when\n    // `InterruptHandle` sends us a signal). Due to the lack of needing to\n    // synchronize with any other memory it's hoped that the choice of `Relaxed`\n    // here should be correct for our use case.\n    let wasm_stack_limit = stack_pointer - store.engine().config().max_wasm_stack;\n    let interrupts = store.0.interrupts();\n    let prev_stack = match interrupts.stack_limit.swap(wasm_stack_limit, Relaxed) {\n        wasmtime_environ::INTERRUPTED => {\n            // This means that an interrupt happened before we actually\n            // called this function, which means that we're now\n            // considered interrupted.\n            interrupts.stack_limit.store(usize::max_value(), Relaxed);\n            return Err(Trap::new_wasm(\n                None,\n                wasmtime_environ::TrapCode::Interrupt,\n                backtrace::Backtrace::new_unresolved(),\n            ));\n        }\n        n => n,\n    };\n\n    // The `usize::max_value()` sentinel is present on recursive calls to\n    // asynchronous stores here. In that situation we don't want to keep\n    // updating the stack canary, so only execute this once at the top.\n    if prev_stack == usize::max_value() {\n        debug_assert!(store\n            .0\n            .externref_activations_table()\n            .stack_canary()\n            .is_none());\n        store\n            .0\n            .externref_activations_table()\n            .set_stack_canary(Some(stack_pointer));\n    }\n\n    Ok(Some(prev_stack))\n}\n\nfn exit_wasm<T>(store: &mut StoreContextMut<'_, T>, prev_stack: Option<usize>) {\n    // If we don't have a previous stack pointer to restore, then there's no\n    // cleanup we need to perform here.\n    let prev_stack = match prev_stack {\n        Some(stack) => stack,\n        None => return,\n    };\n\n    // Only if we're restoring a top-level value do we clear the stack canary\n    // value. Otherwise our purpose here might be restoring a recursive stack\n    // limit but leaving the active canary in place.\n    if prev_stack == usize::max_value() {\n        store.0.externref_activations_table().set_stack_canary(None);\n    }\n\n    // see docs above for why this uses `Relaxed`\n    store.0.interrupts().stack_limit.store(prev_stack, Relaxed);\n}\n\n/// A trait implemented for types which can be returned from closures passed to\n/// [`Func::wrap`] and friends.\n///\n/// This trait should not be implemented by user types. This trait may change at\n/// any time internally. The types which implement this trait, however, are\n/// stable over time.\n///\n/// For more information see [`Func::wrap`]\npub unsafe trait WasmRet {\n    // Same as `WasmTy::Abi`.\n    #[doc(hidden)]\n    type Abi: Copy;\n    #[doc(hidden)]\n    type Retptr: Copy;\n\n    // Same as `WasmTy::compatible_with_store`.\n    #[doc(hidden)]\n    fn compatible_with_store(&self, store: &StoreOpaque) -> bool;\n\n    // Similar to `WasmTy::into_abi_for_arg` but used when host code is\n    // returning a value into Wasm, rather than host code passing an argument to\n    // a Wasm call. Unlike `into_abi_for_arg`, implementors of this method can\n    // raise traps, which means that callers must ensure that\n    // `invoke_wasm_and_catch_traps` is on the stack, and therefore this method\n    // is unsafe.\n    #[doc(hidden)]\n    unsafe fn into_abi_for_ret(\n        self,\n        store: &mut StoreOpaque,\n        ptr: Self::Retptr,\n    ) -> Result<Self::Abi, Trap>;\n\n    #[doc(hidden)]\n    fn func_type(params: impl Iterator<Item = ValType>) -> FuncType;\n\n    #[doc(hidden)]\n    unsafe fn wrap_trampoline(ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi);\n\n    // Utilities used to convert an instance of this type to a `Result`\n    // explicitly, used when wrapping async functions which always bottom-out\n    // in a function that returns a trap because futures can be cancelled.\n    #[doc(hidden)]\n    type Fallible: WasmRet<Abi = Self::Abi, Retptr = Self::Retptr>;\n    #[doc(hidden)]\n    fn into_fallible(self) -> Self::Fallible;\n    #[doc(hidden)]\n    fn fallible_from_trap(trap: Trap) -> Self::Fallible;\n}\n\nunsafe impl<T> WasmRet for T\nwhere\n    T: WasmTy,\n{\n    type Abi = <T as WasmTy>::Abi;\n    type Retptr = ();\n    type Fallible = Result<T, Trap>;\n\n    fn compatible_with_store(&self, store: &StoreOpaque) -> bool {\n        <Self as WasmTy>::compatible_with_store(self, store)\n    }\n\n    unsafe fn into_abi_for_ret(\n        self,\n        store: &mut StoreOpaque,\n        _retptr: (),\n    ) -> Result<Self::Abi, Trap> {\n        Ok(<Self as WasmTy>::into_abi(self, store))\n    }\n\n    fn func_type(params: impl Iterator<Item = ValType>) -> FuncType {\n        FuncType::new(params, Some(<Self as WasmTy>::valtype()))\n    }\n\n    unsafe fn wrap_trampoline(ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi) {\n        *ptr.cast::<Self::Abi>() = f(());\n    }\n\n    fn into_fallible(self) -> Result<T, Trap> {\n        Ok(self)\n    }\n\n    fn fallible_from_trap(trap: Trap) -> Result<T, Trap> {\n        Err(trap)\n    }\n}\n\nunsafe impl<T> WasmRet for Result<T, Trap>\nwhere\n    T: WasmRet,\n{\n    type Abi = <T as WasmRet>::Abi;\n    type Retptr = <T as WasmRet>::Retptr;\n    type Fallible = Self;\n\n    fn compatible_with_store(&self, store: &StoreOpaque) -> bool {\n        match self {\n            Ok(x) => <T as WasmRet>::compatible_with_store(x, store),\n            Err(_) => true,\n        }\n    }\n\n    unsafe fn into_abi_for_ret(\n        self,\n        store: &mut StoreOpaque,\n        retptr: Self::Retptr,\n    ) -> Result<Self::Abi, Trap> {\n        self.and_then(|val| val.into_abi_for_ret(store, retptr))\n    }\n\n    fn func_type(params: impl Iterator<Item = ValType>) -> FuncType {\n        T::func_type(params)\n    }\n\n    unsafe fn wrap_trampoline(ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi) {\n        T::wrap_trampoline(ptr, f)\n    }\n\n    fn into_fallible(self) -> Result<T, Trap> {\n        self\n    }\n\n    fn fallible_from_trap(trap: Trap) -> Result<T, Trap> {\n        Err(trap)\n    }\n}\n\nmacro_rules! impl_wasm_host_results {\n    ($n:tt $($t:ident)*) => (\n        #[allow(non_snake_case)]\n        unsafe impl<$($t),*> WasmRet for ($($t,)*)\n        where\n            $($t: WasmTy,)*\n            ($($t::Abi,)*): HostAbi,\n        {\n            type Abi = <($($t::Abi,)*) as HostAbi>::Abi;\n            type Retptr = <($($t::Abi,)*) as HostAbi>::Retptr;\n            type Fallible = Result<Self, Trap>;\n\n            #[inline]\n            fn compatible_with_store(&self, _store: &StoreOpaque) -> bool {\n                let ($($t,)*) = self;\n                $( $t.compatible_with_store(_store) && )* true\n            }\n\n            #[inline]\n            unsafe fn into_abi_for_ret(self, _store: &mut StoreOpaque, ptr: Self::Retptr) -> Result<Self::Abi, Trap> {\n                let ($($t,)*) = self;\n                let abi = ($($t.into_abi(_store),)*);\n                Ok(<($($t::Abi,)*) as HostAbi>::into_abi(abi, ptr))\n            }\n\n            fn func_type(params: impl Iterator<Item = ValType>) -> FuncType {\n                FuncType::new(\n                    params,\n                    std::array::IntoIter::new([$($t::valtype(),)*]),\n                )\n            }\n\n            #[allow(unused_assignments)]\n            unsafe fn wrap_trampoline(mut _ptr: *mut u128, f: impl FnOnce(Self::Retptr) -> Self::Abi) {\n                let ($($t,)*) = <($($t::Abi,)*) as HostAbi>::call(f);\n                $(\n                    *_ptr.cast() = $t;\n                    _ptr = _ptr.add(1);\n                )*\n            }\n\n            #[inline]\n            fn into_fallible(self) -> Result<Self, Trap> {\n                Ok(self)\n            }\n\n            #[inline]\n            fn fallible_from_trap(trap: Trap) -> Result<Self, Trap> {\n                Err(trap)\n            }\n        }\n    )\n}\n\nfor_each_function_signature!(impl_wasm_host_results);\n\n// Internal trait representing how to communicate tuples of return values across\n// an ABI boundary. This internally corresponds to the \"wasmtime\" ABI inside of\n// cranelift itself. Notably the first element of each tuple is returned via the\n// typical system ABI (e.g. systemv or fastcall depending on platform) and all\n// other values are returned packed via the stack.\n//\n// This trait helps to encapsulate all the details of that.\n#[doc(hidden)]\npub trait HostAbi {\n    // A value returned from native functions which return `Self`\n    type Abi: Copy;\n    // A return pointer, added to the end of the argument list, for native\n    // functions that return `Self`. Note that a 0-sized type here should get\n    // elided at the ABI level.\n    type Retptr: Copy;\n\n    // Converts a value of `self` into its components. Stores necessary values\n    // into `ptr` and then returns whatever needs to be returned from the\n    // function.\n    unsafe fn into_abi(self, ptr: Self::Retptr) -> Self::Abi;\n\n    // Calls `f` with a suitably sized return area and requires `f` to return\n    // the raw abi value of the first element of our tuple. This will then\n    // unpack the `Retptr` and assemble it with `Self::Abi` to return an\n    // instance of the whole tuple.\n    unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self;\n}\n\nmacro_rules! impl_host_abi {\n    // Base case, everything is `()`\n    (0) => {\n        impl HostAbi for () {\n            type Abi = ();\n            type Retptr = ();\n\n            #[inline]\n            unsafe fn into_abi(self, _ptr: Self::Retptr) -> Self::Abi {}\n\n            #[inline]\n            unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self {\n                f(())\n            }\n        }\n    };\n\n    // In the 1-case the retptr is not present, so it's a 0-sized value.\n    (1 $a:ident) => {\n        impl<$a: Copy> HostAbi for ($a,) {\n            type Abi = $a;\n            type Retptr = ();\n\n            unsafe fn into_abi(self, _ptr: Self::Retptr) -> Self::Abi {\n                self.0\n            }\n\n            unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self {\n                (f(()),)\n            }\n        }\n    };\n\n    // This is where the more interesting case happens. The first element of the\n    // tuple is returned via `Abi` and all other elements are returned via\n    // `Retptr`. We create a `TupleRetNN` structure to represent all of the\n    // return values here.\n    //\n    // Also note that this isn't implemented for the old backend right now due\n    // to the original author not really being sure how to implement this in the\n    // old backend.\n    ($n:tt $t:ident $($u:ident)*) => {paste::paste!{\n        #[doc(hidden)]\n        #[allow(non_snake_case)]\n        #[repr(C)]\n        #[cfg(not(feature = \"old-x86-backend\"))]\n        pub struct [<TupleRet $n>]<$($u,)*> {\n            $($u: $u,)*\n        }\n\n        #[cfg(not(feature = \"old-x86-backend\"))]\n        #[allow(non_snake_case, unused_assignments)]\n        impl<$t: Copy, $($u: Copy,)*> HostAbi for ($t, $($u,)*) {\n            type Abi = $t;\n            type Retptr = *mut [<TupleRet $n>]<$($u,)*>;\n\n            unsafe fn into_abi(self, ptr: Self::Retptr) -> Self::Abi {\n                let ($t, $($u,)*) = self;\n                // Store the tail of our tuple into the return pointer...\n                $((*ptr).$u = $u;)*\n                // ... and return the head raw.\n                $t\n            }\n\n            unsafe fn call(f: impl FnOnce(Self::Retptr) -> Self::Abi) -> Self {\n                // Create space to store all the return values and then invoke\n                // the function.\n                let mut space = std::mem::MaybeUninit::uninit();\n                let t = f(space.as_mut_ptr());\n                let space = space.assume_init();\n\n                // Use the return value as the head of the tuple and unpack our\n                // return area to get the rest of the tuple.\n                (t, $(space.$u,)*)\n            }\n        }\n    }};\n}\n\nfor_each_function_signature!(impl_host_abi);\n\n/// Internal trait implemented for all arguments that can be passed to\n/// [`Func::wrap`] and [`Linker::func_wrap`](crate::Linker::func_wrap).\n///\n/// This trait should not be implemented by external users, it's only intended\n/// as an implementation detail of this crate.\npub trait IntoFunc<T, Params, Results>: Send + Sync + 'static {\n    #[doc(hidden)]\n    fn into_func(self, engine: &Engine) -> (InstanceHandle, VMTrampoline);\n}\n\n/// A structure representing the caller's context when creating a function\n/// via [`Func::wrap`].\n///\n/// This structure can be taken as the first parameter of a closure passed to\n/// [`Func::wrap`] or other constructors, and serves two purposes:\n///\n/// * First consumers can use [`Caller<'_, T>`](crate::Caller) to get access to\n///   [`StoreContextMut<'_, T>`](crate::StoreContextMut) and/or get access to\n///   `T` itself. This means that the [`Caller`] type can serve as a proxy to\n///   the original [`Store`](crate::Store) itself and is used to satisfy\n///   [`AsContext`] and [`AsContextMut`] bounds.\n///\n/// * Second a [`Caller`] can be used as the name implies, learning about the\n///   caller's context, namely it's exported memory and exported functions. This\n///   allows functions which take pointers as arguments to easily read the\n///   memory the pointers point into, or if a function is expected to call\n///   malloc in the wasm module to reserve space for the output you can do that.\n///\n/// Host functions which want access to [`Store`](crate::Store)-level state are\n/// recommended to use this type.\npub struct Caller<'a, T> {\n    pub(crate) store: StoreContextMut<'a, T>,\n    caller: &'a InstanceHandle,\n}\n\nimpl<T> Caller<'_, T> {\n    unsafe fn with<R>(caller: *mut VMContext, f: impl FnOnce(Caller<'_, T>) -> R) -> R {\n        assert!(!caller.is_null());\n        let instance = InstanceHandle::from_vmctx(caller);\n        let store = StoreContextMut::from_raw(instance.store());\n        f(Caller {\n            store,\n            caller: &instance,\n        })\n    }\n\n    fn sub_caller(&mut self) -> Caller<'_, T> {\n        Caller {\n            store: self.store.as_context_mut(),\n            caller: self.caller,\n        }\n    }\n\n    /// Looks up an export from the caller's module by the `name` given.\n    ///\n    /// Note that this function is only implemented for the `Extern::Memory`\n    /// and the `Extern::Func` types currently. No other exported structures\n    /// can be acquired through this method.\n    ///\n    /// Note that when accessing and calling exported functions, one should\n    /// adhere to the guidelines of the interface types proposal.  This method\n    /// is a temporary mechanism for accessing the caller's information until\n    /// interface types has been fully standardized and implemented. The\n    /// interface types proposal will obsolete this type and this will be\n    /// removed in the future at some point after interface types is\n    /// implemented. If you're relying on this method type it's recommended to\n    /// become familiar with interface types to ensure that your use case is\n    /// covered by the proposal.\n    ///\n    /// # Return\n    ///\n    /// If a memory or function export with the `name` provided was found, then it is\n    /// returned as a `Memory`. There are a number of situations, however, where\n    /// the memory or function may not be available:\n    ///\n    /// * The caller instance may not have an export named `name`\n    /// * The export named `name` may not be an exported memory\n    /// * There may not be a caller available, for example if `Func` was called\n    ///   directly from host code.\n    ///\n    /// It's recommended to take care when calling this API and gracefully\n    /// handling a `None` return value.\n    pub fn get_export(&mut self, name: &str) -> Option<Extern> {\n        // All instances created have a `host_state` with a pointer pointing\n        // back to themselves. If this caller doesn't have that `host_state`\n        // then it probably means it was a host-created object like `Func::new`\n        // which doesn't have any exports we want to return anyway.\n        match self\n            .caller\n            .host_state()\n            .downcast_ref::<Instance>()?\n            .get_export(&mut self.store, name)?\n        {\n            Extern::Func(f) => Some(Extern::Func(f)),\n            Extern::Memory(f) => Some(Extern::Memory(f)),\n            // Intentionally ignore other Extern items here since this API is\n            // supposed to be a temporary stop-gap until interface types.\n            _ => None,\n        }\n    }\n\n    /// Access the underlying data owned by this `Store`.\n    ///\n    /// Same as [`Store::data`](crate::Store::data)\n    pub fn data(&self) -> &T {\n        self.store.data()\n    }\n\n    /// Access the underlying data owned by this `Store`.\n    ///\n    /// Same as [`Store::data_mut`](crate::Store::data_mut)\n    pub fn data_mut(&mut self) -> &mut T {\n        self.store.data_mut()\n    }\n\n    /// Returns the underlying [`Engine`] this store is connected to.\n    pub fn engine(&self) -> &Engine {\n        self.store.engine()\n    }\n\n    /// Returns an [`InterruptHandle`] to interrupt wasm execution.\n    ///\n    /// See [`Store::interrupt_handle`](crate::Store::interrupt_handle) for more\n    /// information.\n    pub fn interrupt_handle(&self) -> Result<InterruptHandle> {\n        self.store.interrupt_handle()\n    }\n\n    /// Perform garbage collection of `ExternRef`s.\n    ///\n    /// Same as [`Store::gc`](crate::Store::gc).\n    pub fn gc(&mut self) {\n        self.store.gc()\n    }\n\n    /// Returns the fuel consumed by this store.\n    ///\n    /// For more information see [`Store::fuel_consumed`](crate::Store::fuel_consumed)\n    pub fn fuel_consumed(&self) -> Option<u64> {\n        self.store.fuel_consumed()\n    }\n\n    /// Inject more fuel into this store to be consumed when executing wasm code.\n    ///\n    /// For more information see [`Store::add_fuel`](crate::Store::add_fuel)\n    pub fn add_fuel(&mut self, fuel: u64) -> Result<()> {\n        self.store.add_fuel(fuel)\n    }\n\n    /// Synthetically consumes fuel from the store.\n    ///\n    /// For more information see [`Store::consume_fuel`](crate::Store::consume_fuel)\n    pub fn consume_fuel(&mut self, fuel: u64) -> Result<u64> {\n        self.store.consume_fuel(fuel)\n    }\n\n    /// Configures this `Store` to trap whenever fuel runs out.\n    ///\n    /// For more information see\n    /// [`Store::out_of_fuel_trap`](crate::Store::out_of_fuel_trap)\n    pub fn out_of_fuel_trap(&mut self) {\n        self.store.out_of_fuel_trap()\n    }\n\n    /// Configures this `Store` to yield while executing futures whenever fuel\n    /// runs out.\n    ///\n    /// For more information see\n    /// [`Store::out_of_fuel_async_yield`](crate::Store::out_of_fuel_async_yield)\n    pub fn out_of_fuel_async_yield(&mut self, injection_count: u64, fuel_to_inject: u64) {\n        self.store\n            .out_of_fuel_async_yield(injection_count, fuel_to_inject)\n    }\n}\n\nimpl<T> AsContext for Caller<'_, T> {\n    type Data = T;\n    fn as_context(&self) -> StoreContext<'_, T> {\n        self.store.as_context()\n    }\n}\n\nimpl<T> AsContextMut for Caller<'_, T> {\n    fn as_context_mut(&mut self) -> StoreContextMut<'_, T> {\n        self.store.as_context_mut()\n    }\n}\n\nfn cross_store_trap() -> Box<dyn Error + Send + Sync> {\n    #[derive(Debug)]\n    struct CrossStoreError;\n\n    impl Error for CrossStoreError {}\n\n    impl fmt::Display for CrossStoreError {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(\n                f,\n                \"host function attempted to return cross-`Store` \\\n                 value to Wasm\",\n            )\n        }\n    }\n\n    Box::new(CrossStoreError)\n}\n\nmacro_rules! impl_into_func {\n    ($num:tt $($args:ident)*) => {\n        // Implement for functions without a leading `&Caller` parameter,\n        // delegating to the implementation below which does have the leading\n        // `Caller` parameter.\n        #[allow(non_snake_case)]\n        impl<T, F, $($args,)* R> IntoFunc<T, ($($args,)*), R> for F\n        where\n            F: Fn($($args),*) -> R + Send + Sync + 'static,\n            $($args: WasmTy,)*\n            R: WasmRet,\n        {\n            fn into_func(self, engine: &Engine) -> (InstanceHandle, VMTrampoline) {\n                let f = move |_: Caller<'_, T>, $($args:$args),*| {\n                    self($($args),*)\n                };\n\n                f.into_func(engine)\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<T, F, $($args,)* R> IntoFunc<T, (Caller<'_, T>, $($args,)*), R> for F\n        where\n            F: Fn(Caller<'_, T>, $($args),*) -> R + Send + Sync + 'static,\n            $($args: WasmTy,)*\n            R: WasmRet,\n        {\n            fn into_func(self, engine: &Engine) -> (InstanceHandle, VMTrampoline) {\n                /// This shim is called by Wasm code, constructs a `Caller`,\n                /// calls the wrapped host function, and returns the translated\n                /// result back to Wasm.\n                ///\n                /// Note that this shim's ABI must *exactly* match that expected\n                /// by Cranelift, since Cranelift is generating raw function\n                /// calls directly to this function.\n                unsafe extern \"C\" fn wasm_to_host_shim<T, F, $($args,)* R>(\n                    vmctx: *mut VMContext,\n                    caller_vmctx: *mut VMContext,\n                    $( $args: $args::Abi, )*\n                    retptr: R::Retptr,\n                ) -> R::Abi\n                where\n                    F: Fn(Caller<'_, T>, $( $args ),*) -> R + 'static,\n                    $( $args: WasmTy, )*\n                    R: WasmRet,\n                {\n                    enum CallResult<U> {\n                        Ok(U),\n                        Trap(Box<dyn Error + Send + Sync>),\n                        Panic(Box<dyn std::any::Any + Send>),\n                    }\n\n                    // Note that this `result` is intentionally scoped into a\n                    // separate block. Handling traps and panics will involve\n                    // longjmp-ing from this function which means we won't run\n                    // destructors. As a result anything requiring a destructor\n                    // should be part of this block, and the long-jmp-ing\n                    // happens after the block in handling `CallResult`.\n                    let result = Caller::with(caller_vmctx, |mut caller| {\n                        let state = (*vmctx).host_state();\n                        // Double-check ourselves in debug mode, but we control\n                        // the `Any` here so an unsafe downcast should also\n                        // work.\n                        debug_assert!(state.is::<F>());\n                        let func = &*(state as *const _ as *const F);\n\n                        let ret = {\n                            panic::catch_unwind(AssertUnwindSafe(|| {\n                                if let Err(trap) = caller.store.0.call_hook(CallHook::CallingHost) {\n                                    return R::fallible_from_trap(trap);\n                                }\n                                $(let $args = $args::from_abi($args, caller.store.0);)*\n                                let r = func(\n                                    caller.sub_caller(),\n                                    $( $args, )*\n                                );\n                                if let Err(trap) = caller.store.0.call_hook(CallHook::ReturningFromHost) {\n                                    return R::fallible_from_trap(trap);\n                                }\n                                r.into_fallible()\n                            }))\n                        };\n\n                        // Note that we need to be careful when dealing with traps\n                        // here. Traps are implemented with longjmp/setjmp meaning\n                        // that it's not unwinding and consequently no Rust\n                        // destructors are run. We need to be careful to ensure that\n                        // nothing on the stack needs a destructor when we exit\n                        // abnormally from this `match`, e.g. on `Err`, on\n                        // cross-store-issues, or if `Ok(Err)` is raised.\n                        match ret {\n                            Err(panic) => CallResult::Panic(panic),\n                            Ok(ret) => {\n                                // Because the wrapped function is not `unsafe`, we\n                                // can't assume it returned a value that is\n                                // compatible with this store.\n                                if !ret.compatible_with_store(caller.store.0) {\n                                    CallResult::Trap(cross_store_trap())\n                                } else {\n                                    match ret.into_abi_for_ret(caller.store.0, retptr) {\n                                        Ok(val) => CallResult::Ok(val),\n                                        Err(trap) => CallResult::Trap(trap.into()),\n                                    }\n                                }\n\n                            }\n                        }\n                    });\n\n                    match result {\n                        CallResult::Ok(val) => val,\n                        CallResult::Trap(trap) => raise_user_trap(trap),\n                        CallResult::Panic(panic) => wasmtime_runtime::resume_panic(panic),\n                    }\n                }\n\n                /// This trampoline allows host code to indirectly call the\n                /// wrapped function (e.g. via `Func::call` on a `funcref` that\n                /// happens to reference our wrapped function).\n                ///\n                /// It reads the arguments out of the incoming `args` array,\n                /// calls the given function pointer, and then stores the result\n                /// back into the `args` array.\n                unsafe extern \"C\" fn host_trampoline<$($args,)* R>(\n                    callee_vmctx: *mut VMContext,\n                    caller_vmctx: *mut VMContext,\n                    ptr: *const VMFunctionBody,\n                    args: *mut u128,\n                )\n                where\n                    $($args: WasmTy,)*\n                    R: WasmRet,\n                {\n                    let ptr = mem::transmute::<\n                        *const VMFunctionBody,\n                        unsafe extern \"C\" fn(\n                            *mut VMContext,\n                            *mut VMContext,\n                            $( $args::Abi, )*\n                            R::Retptr,\n                        ) -> R::Abi,\n                    >(ptr);\n\n                    let mut _n = 0;\n                    $(\n                        let $args = *args.add(_n).cast::<$args::Abi>();\n                        _n += 1;\n                    )*\n                    R::wrap_trampoline(args, |retptr| {\n                        ptr(callee_vmctx, caller_vmctx, $( $args, )* retptr)\n                    });\n                }\n\n                let ty = R::func_type(\n                    None::<ValType>.into_iter()\n                        $(.chain(Some($args::valtype())))*\n                );\n\n                let shared_signature_id = engine.signatures().register(ty.as_wasm_func_type());\n\n                let trampoline = host_trampoline::<$($args,)* R>;\n\n\n                let instance = unsafe {\n                    crate::trampoline::create_raw_function(\n                        std::slice::from_raw_parts_mut(\n                            wasm_to_host_shim::<T, F, $($args,)* R> as *mut _,\n                            0,\n                        ),\n                        shared_signature_id,\n                        Box::new(self),\n                    )\n                    .expect(\"failed to create raw function\")\n                };\n\n                (instance, trampoline)\n            }\n        }\n    }\n}\n\nfor_each_function_signature!(impl_into_func);\n\n/// Representation of a host-defined function.\n///\n/// This is used for `Func::new` but also for `Linker`-defined functions. For\n/// `Func::new` this is stored within a `Store`, and for `Linker`-defined\n/// functions they wrap this up in `Arc` to enable shared ownership of this\n/// across many stores.\n///\n/// Technically this structure needs a `<T>` type parameter to connect to the\n/// `Store<T>` itself, but that's an unsafe contract of using this for now\n/// rather than part of the struct type (to avoid `Func<T>` in the API).\npub(crate) struct HostFunc {\n    // Owned `*mut VMContext` allocation. Deallocated when this `HostFunc` is\n    // dropped.\n    instance: InstanceHandle,\n    // Trampoline to enter this function from Rust.\n    trampoline: VMTrampoline,\n    // The loaded `ExportFunction` from the above `InstanceHandle` which has raw\n    // pointers and information about how to actually call this function (e.g.\n    // the actual address in JIT code and the vm shared function index).\n    export: ExportFunction,\n    // Stored to unregister this function's signature with the engine when this\n    // is dropped.\n    engine: Engine,\n}\n\nimpl HostFunc {\n    /// Analog of [`Func::new`]\n    #[cfg(compiler)]\n    pub fn new<T>(\n        engine: &Engine,\n        ty: FuncType,\n        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,\n    ) -> Self {\n        let ty_clone = ty.clone();\n\n        // Create a trampoline that converts raw u128 values to `Val`\n        let func = move |caller_vmctx, values_vec: *mut u128| unsafe {\n            Caller::with(caller_vmctx, |caller| {\n                Func::invoke(caller, &ty_clone, values_vec, &func)\n            })\n        };\n\n        let (instance, trampoline) = crate::trampoline::create_function(&ty, func, engine)\n            .expect(\"failed to create function\");\n        HostFunc::_new(engine, instance, trampoline)\n    }\n\n    /// Analog of [`Func::wrap`]\n    pub fn wrap<T, Params, Results>(\n        engine: &Engine,\n        func: impl IntoFunc<T, Params, Results>,\n    ) -> Self {\n        let (instance, trampoline) = func.into_func(engine);\n        HostFunc::_new(engine, instance, trampoline)\n    }\n\n    /// Requires that this function's signature is already registered within\n    /// `Engine`. This happens automatically during the above two constructors.\n    fn _new(engine: &Engine, instance: InstanceHandle, trampoline: VMTrampoline) -> Self {\n        let idx = EntityIndex::Function(FuncIndex::from_u32(0));\n        let export = match instance.lookup_by_declaration(&idx) {\n            wasmtime_runtime::Export::Function(f) => f,\n            _ => unreachable!(),\n        };\n\n        HostFunc {\n            instance,\n            trampoline,\n            export,\n            engine: engine.clone(),\n        }\n    }\n\n    /// Inserts this `HostFunc` into a `Store`, returning the `Func` pointing to\n    /// it.\n    ///\n    /// # Unsafety\n    ///\n    /// Can only be inserted into stores with a matching `T` relative to when\n    /// this `HostFunc` was first created.\n    pub unsafe fn to_func(self: &Arc<Self>, store: &mut StoreOpaque) -> Func {\n        self.register_trampoline(store);\n        let me = self.clone();\n        Func(store.store_data_mut().insert(FuncData::SharedHost(me)))\n    }\n\n    /// Same as [`HostFunc::to_func`], different ownership.\n    unsafe fn into_func(self, store: &mut StoreOpaque) -> Func {\n        self.register_trampoline(store);\n        Func(store.store_data_mut().insert(FuncData::Host(self)))\n    }\n\n    unsafe fn register_trampoline(&self, store: &mut StoreOpaque) {\n        // This assert is required to ensure that we can indeed safely insert\n        // `self` into the `store` provided, otherwise the type information we\n        // have listed won't be correct. This is possible to hit with the public\n        // API of Wasmtime, and should be documented in relevant functions.\n        assert!(\n            Engine::same(&self.engine, store.engine()),\n            \"cannot use a store with a different engine than a linker was created with\",\n        );\n        let idx = self.export.anyfunc.as_ref().type_index;\n        store.register_host_trampoline(idx, self.trampoline);\n    }\n\n    pub(crate) fn sig_index(&self) -> VMSharedSignatureIndex {\n        unsafe { self.export.anyfunc.as_ref().type_index }\n    }\n}\n\nimpl Drop for HostFunc {\n    fn drop(&mut self) {\n        unsafe {\n            self.engine\n                .signatures()\n                .unregister(self.export.anyfunc.as_ref().type_index);\n\n            // Host functions are always allocated with the default (on-demand)\n            // allocator\n            OnDemandInstanceAllocator::default().deallocate(&self.instance);\n        }\n    }\n}\n\nimpl FuncData {\n    fn trampoline(&self) -> VMTrampoline {\n        match self {\n            FuncData::StoreOwned { trampoline, .. } => *trampoline,\n            FuncData::SharedHost(host) => host.trampoline,\n            FuncData::Host(host) => host.trampoline,\n        }\n    }\n\n    #[inline]\n    fn export(&self) -> &ExportFunction {\n        match self {\n            FuncData::StoreOwned { export, .. } => export,\n            FuncData::SharedHost(host) => &host.export,\n            FuncData::Host(host) => &host.export,\n        }\n    }\n}\n", "use crate::linker::Definition;\nuse crate::signatures::SignatureCollection;\nuse crate::store::{InstanceId, StoreData, StoreOpaque, Stored};\nuse crate::types::matching;\nuse crate::{\n    AsContext, AsContextMut, Engine, Export, Extern, ExternType, Func, Global, InstanceType,\n    Memory, Module, StoreContextMut, Table, Trap, TypedFunc,\n};\nuse anyhow::{anyhow, bail, Context, Error, Result};\nuse std::mem;\nuse std::sync::Arc;\nuse wasmtime_environ::{\n    EntityIndex, EntityType, FuncIndex, GlobalIndex, Initializer, InstanceIndex, MemoryIndex,\n    ModuleIndex, PrimaryMap, TableIndex,\n};\nuse wasmtime_jit::TypeTables;\nuse wasmtime_runtime::{\n    Imports, InstanceAllocationRequest, InstantiationError, VMContext, VMFunctionBody,\n    VMFunctionImport, VMGlobalImport, VMMemoryImport, VMTableImport,\n};\n\n/// An instantiated WebAssembly module.\n///\n/// This type represents the instantiation of a [`Module`]. Once instantiated\n/// you can access the [`exports`](Instance::exports) which are of type\n/// [`Extern`] and provide the ability to call functions, set globals, read\n/// memory, etc. When interacting with any wasm code you'll want to make an\n/// [`Instance`] to call any code or execute anything.\n///\n/// Instances are owned by a [`Store`](crate::Store) which is passed in at\n/// creation time. It's recommended to create instances with\n/// [`Linker::instantiate`](crate::Linker::instantiate) or similar\n/// [`Linker`](crate::Linker) methods, but a more low-level constructor is also\n/// available as [`Instance::new`].\n#[derive(Copy, Clone, Debug)]\n#[repr(transparent)]\npub struct Instance(Stored<InstanceData>);\n\npub(crate) enum InstanceData {\n    /// This variant is used for instances created through instantiation of a\n    /// module, e.g. `Instance::new` or various linker methods.\n    Instantiated {\n        /// The id of the instance within the store, used to find the original\n        /// `InstanceHandle`.\n        id: InstanceId,\n        /// A lazily-populated list of exports of this instance. The order of\n        /// exports here matches the order of the exports in the the original\n        /// module.\n        exports: Vec<Option<Extern>>,\n        /// The type information of the module that this was instantiated with.\n        types: Arc<TypeTables>,\n        signatures: Arc<SignatureCollection>,\n    },\n\n    /// This variant is used for synthetically created instances via `Linker`\n    /// APIs. This is only used for the module linking proposal at this time.\n    Synthetic(Arc<indexmap::IndexMap<String, Extern>>),\n}\n\nimpl Instance {\n    /// Creates a new [`Instance`] from the previously compiled [`Module`] and\n    /// list of `imports` specified.\n    ///\n    /// This method instantiates the `module` provided with the `imports`,\n    /// following the procedure in the [core specification][inst] to\n    /// instantiate. Instantiation can fail for a number of reasons (many\n    /// specified below), but if successful the `start` function will be\n    /// automatically run (if specified in the `module`) and then the\n    /// [`Instance`] will be returned.\n    ///\n    /// Per the WebAssembly spec, instantiation includes running the module's\n    /// start function, if it has one (not to be confused with the `_start`\n    /// function, which is not run).\n    ///\n    /// Note that this is a low-level function that just performs an\n    /// instantiation. See the [`Linker`](crate::Linker) struct for an API which\n    /// provides a convenient way to link imports and provides automatic Command\n    /// and Reactor behavior.\n    ///\n    /// ## Providing Imports\n    ///\n    /// The entries in the list of `imports` are intended to correspond 1:1\n    /// with the list of imports returned by [`Module::imports`]. Before\n    /// calling [`Instance::new`] you'll want to inspect the return value of\n    /// [`Module::imports`] and, for each import type, create an [`Extern`]\n    /// which corresponds to that type.  These [`Extern`] values are all then\n    /// collected into a list and passed to this function.\n    ///\n    /// Note that this function is intentionally relatively low level. For an\n    /// easier time passing imports by doing name-based resolution it's\n    /// recommended to instead use the [`Linker`](crate::Linker) type.\n    ///\n    /// ## Errors\n    ///\n    /// This function can fail for a number of reasons, including, but not\n    /// limited to:\n    ///\n    /// * The number of `imports` provided doesn't match the number of imports\n    ///   returned by the `module`'s [`Module::imports`] method.\n    /// * The type of any [`Extern`] doesn't match the corresponding\n    ///   [`ExternType`] entry that it maps to.\n    /// * The `start` function in the instance, if present, traps.\n    /// * Module/instance resource limits are exceeded.\n    ///\n    /// When instantiation fails it's recommended to inspect the return value to\n    /// see why it failed, or bubble it upwards. If you'd like to specifically\n    /// check for trap errors, you can use `error.downcast::<Trap>()`.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if called with a store associated with a\n    /// [`asynchronous config`](crate::Config::async_support). This function\n    /// will also panic if any [`Extern`] supplied is not owned by `store`.\n    ///\n    /// [inst]: https://webassembly.github.io/spec/core/exec/modules.html#exec-instantiation\n    /// [`ExternType`]: crate::ExternType\n    pub fn new(\n        mut store: impl AsContextMut,\n        module: &Module,\n        imports: &[Extern],\n    ) -> Result<Instance, Error> {\n        // This unsafety comes from `Instantiator::new` where we must typecheck\n        // first, which we are sure to do here.\n        let mut store = store.as_context_mut();\n        let mut i = unsafe {\n            typecheck_externs(store.0, module, imports)?;\n            Instantiator::new(store.0, module, ImportSource::Externs(imports))?\n        };\n        i.run(&mut store)\n    }\n\n    /// Same as [`Instance::new`], except for usage in [asynchronous stores].\n    ///\n    /// For more details about this function see the documentation on\n    /// [`Instance::new`]. The only difference between these two methods is that\n    /// this one will asynchronously invoke the wasm start function in case it\n    /// calls any imported function which is an asynchronous host function (e.g.\n    /// created with [`Func::new_async`](crate::Func::new_async).\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if called with a store associated with a\n    /// [`synchronous config`](crate::Config::new). This is only compatible with\n    /// stores associated with an [`asynchronous\n    /// config`](crate::Config::async_support).\n    ///\n    /// This function will also panic, like [`Instance::new`], if any [`Extern`]\n    /// specified does not belong to `store`.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn new_async<T>(\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n        imports: &[Extern],\n    ) -> Result<Instance, Error>\n    where\n        T: Send,\n    {\n        // See `new` for unsafety comments\n        let mut store = store.as_context_mut();\n        let mut i = unsafe {\n            typecheck_externs(store.0, module, imports)?;\n            Instantiator::new(store.0, module, ImportSource::Externs(imports))?\n        };\n        i.run_async(&mut store).await\n    }\n\n    pub(crate) fn from_wasmtime(handle: InstanceData, store: &mut StoreOpaque) -> Instance {\n        Instance(store.store_data_mut().insert(handle))\n    }\n\n    /// Returns the type signature of this instance.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn ty(&self, store: impl AsContext) -> InstanceType {\n        let store = store.as_context();\n        let mut ty = InstanceType::new();\n        match &store[self.0] {\n            InstanceData::Synthetic(items) => {\n                for (name, item) in items.iter() {\n                    ty.add_named_export(name, item.ty(&store));\n                }\n            }\n            InstanceData::Instantiated { id, types, .. } => {\n                let module = store.0.instance(*id).module();\n                for (name, idx) in module.exports.iter() {\n                    let export_ty = module.type_of(*idx);\n                    ty.add_named_export(name, ExternType::from_wasmtime(types, &export_ty));\n                }\n            }\n        }\n        ty\n    }\n\n    pub(crate) fn data<'a>(&self, store: &'a StoreData) -> &'a InstanceData {\n        &store[self.0]\n    }\n\n    pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {\n        store.store_data().contains(self.0)\n    }\n\n    /// Returns the list of exported items from this [`Instance`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn exports<'a, T: 'a>(\n        &'a self,\n        store: impl Into<StoreContextMut<'a, T>>,\n    ) -> impl ExactSizeIterator<Item = Export<'a>> + 'a {\n        self._exports(store.into().0)\n    }\n\n    fn _exports<'a>(\n        &'a self,\n        store: &'a mut StoreOpaque,\n    ) -> impl ExactSizeIterator<Item = Export<'a>> + 'a {\n        // If this is an `Instantiated` instance then all the `exports` may not\n        // be filled in. Fill them all in now if that's the case.\n        if let InstanceData::Instantiated { exports, id, .. } = &store[self.0] {\n            if exports.iter().any(|e| e.is_none()) {\n                let module = Arc::clone(store.instance(*id).module());\n                for name in module.exports.keys() {\n                    self._get_export(store, name);\n                }\n            }\n        }\n\n        return match &store.store_data()[self.0] {\n            InstanceData::Synthetic(names) => {\n                Either::A(names.iter().map(|(k, v)| Export::new(k, v.clone())))\n            }\n            InstanceData::Instantiated { exports, id, .. } => {\n                let module = store.instance(*id).module();\n                Either::B(\n                    module\n                        .exports\n                        .iter()\n                        .zip(exports)\n                        .map(|((name, _), export)| Export::new(name, export.clone().unwrap())),\n                )\n            }\n        };\n\n        enum Either<A, B> {\n            A(A),\n            B(B),\n        }\n\n        impl<A, B> Iterator for Either<A, B>\n        where\n            A: Iterator,\n            B: Iterator<Item = A::Item>,\n        {\n            type Item = A::Item;\n\n            fn next(&mut self) -> Option<A::Item> {\n                match self {\n                    Either::A(a) => a.next(),\n                    Either::B(b) => b.next(),\n                }\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                match self {\n                    Either::A(a) => a.size_hint(),\n                    Either::B(b) => b.size_hint(),\n                }\n            }\n        }\n\n        impl<A, B> ExactSizeIterator for Either<A, B>\n        where\n            A: ExactSizeIterator,\n            B: ExactSizeIterator<Item = A::Item>,\n        {\n            fn len(&self) -> usize {\n                match self {\n                    Either::A(a) => a.len(),\n                    Either::B(b) => b.len(),\n                }\n            }\n        }\n    }\n\n    /// Looks up an exported [`Extern`] value by name.\n    ///\n    /// This method will search the module for an export named `name` and return\n    /// the value, if found.\n    ///\n    /// Returns `None` if there was no export named `name`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    ///\n    /// # Why does `get_export` take a mutable context?\n    ///\n    /// This method requires a mutable context because an instance's exports are\n    /// lazily populated, and we cache them as they are accessed. This makes\n    /// instantiating a module faster, but also means this method requires a\n    /// mutable context.\n    pub fn get_export(&self, mut store: impl AsContextMut, name: &str) -> Option<Extern> {\n        self._get_export(store.as_context_mut().0, name)\n    }\n\n    fn _get_export(&self, store: &mut StoreOpaque, name: &str) -> Option<Extern> {\n        match &store[self.0] {\n            // Synthetic instances always have their entire list of exports\n            // already specified.\n            InstanceData::Synthetic(names) => names.get(name).cloned(),\n\n            // Instantiated instances will lazily fill in exports, so we process\n            // all that lazy logic here.\n            InstanceData::Instantiated { id, exports, .. } => {\n                let instance = store.instance(*id);\n                let (i, _, index) = instance.module().exports.get_full(name)?;\n                if let Some(export) = &exports[i] {\n                    return Some(export.clone());\n                }\n                let item = unsafe {\n                    Extern::from_wasmtime_export(instance.lookup_by_declaration(index), store)\n                };\n                let exports = match &mut store[self.0] {\n                    InstanceData::Instantiated { exports, .. } => exports,\n                    _ => unreachable!(),\n                };\n                exports[i] = Some(item.clone());\n                Some(item)\n            }\n        }\n    }\n\n    /// Looks up an exported [`Func`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a function.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_func(&self, store: impl AsContextMut, name: &str) -> Option<Func> {\n        self.get_export(store, name)?.into_func()\n    }\n\n    /// Looks up an exported [`Func`] value by name and with its type.\n    ///\n    /// This function is a convenience wrapper over [`Instance::get_func`] and\n    /// [`Func::typed`]. For more information see the linked documentation.\n    ///\n    /// Returns an error if `name` isn't a function export or if the export's\n    /// type did not match `Params` or `Results`\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_typed_func<Params, Results, S>(\n        &self,\n        mut store: S,\n        name: &str,\n    ) -> Result<TypedFunc<Params, Results>>\n    where\n        Params: crate::WasmParams,\n        Results: crate::WasmResults,\n        S: AsContextMut,\n    {\n        let f = self\n            .get_export(store.as_context_mut(), name)\n            .and_then(|f| f.into_func())\n            .ok_or_else(|| anyhow!(\"failed to find function export `{}`\", name))?;\n        Ok(f.typed::<Params, Results, _>(store)\n            .with_context(|| format!(\"failed to convert function `{}` to given type\", name))?)\n    }\n\n    /// Looks up an exported [`Table`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a table.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_table(&self, store: impl AsContextMut, name: &str) -> Option<Table> {\n        self.get_export(store, name)?.into_table()\n    }\n\n    /// Looks up an exported [`Memory`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a memory.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_memory(&self, store: impl AsContextMut, name: &str) -> Option<Memory> {\n        self.get_export(store, name)?.into_memory()\n    }\n\n    /// Looks up an exported [`Global`] value by name.\n    ///\n    /// Returns `None` if there was no export named `name`, or if there was but\n    /// it wasn't a global.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `store` does not own this instance.\n    pub fn get_global(&self, store: impl AsContextMut, name: &str) -> Option<Global> {\n        self.get_export(store, name)?.into_global()\n    }\n}\n\nstruct Instantiator<'a> {\n    in_progress: Vec<ImportsBuilder<'a>>,\n    cur: ImportsBuilder<'a>,\n}\n\nstruct ImportsBuilder<'a> {\n    src: ImportSource<'a>,\n    functions: PrimaryMap<FuncIndex, VMFunctionImport>,\n    tables: PrimaryMap<TableIndex, VMTableImport>,\n    memories: PrimaryMap<MemoryIndex, VMMemoryImport>,\n    globals: PrimaryMap<GlobalIndex, VMGlobalImport>,\n    instances: PrimaryMap<InstanceIndex, Instance>,\n    modules: PrimaryMap<ModuleIndex, Module>,\n    initializer: usize,\n    module: Module,\n}\n\nenum ImportSource<'a> {\n    Externs(&'a [Extern]),\n    Definitions(&'a [Definition]),\n    Outer { initializer: usize },\n}\n\nimpl<'a> Instantiator<'a> {\n    /// Creates a new instantiation context used to process all the initializer\n    /// directives of a module.\n    ///\n    /// This doesn't do much work itself beyond setting things up.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe for a few reasons:\n    ///\n    /// * This assumes that `imports` has already been typechecked and is of the\n    ///   appropriate length. It is memory unsafe if the types of `imports` are\n    ///   not what `module` expects.\n    ///\n    /// * The `imports` must be safely able to get inserted into `store`. This\n    ///   only applies if `ImportSource::Definitions` is used because this will\n    ///   internally call `Definition::to_extern` which requires that any\n    ///   host functions in the list were created with an original `T` as the\n    ///   store that's being inserted into.\n    ///\n    /// * The `imports` must all come from the `store` specified.\n    unsafe fn new(\n        store: &StoreOpaque,\n        module: &Module,\n        imports: ImportSource<'a>,\n    ) -> Result<Instantiator<'a>> {\n        if !Engine::same(store.engine(), module.engine()) {\n            bail!(\"cross-`Engine` instantiation is not currently supported\");\n        }\n\n        Ok(Instantiator {\n            in_progress: Vec::new(),\n            cur: ImportsBuilder::new(module, imports),\n        })\n    }\n\n    fn run<T>(&mut self, store: &mut StoreContextMut<'_, T>) -> Result<Instance, Error> {\n        assert!(\n            !store.0.async_support(),\n            \"cannot use `new` when async support is enabled on the config\"\n        );\n\n        // NB: this is the same code as `run_async`. It's intentionally\n        // small but should be kept in sync (modulo the async bits).\n        loop {\n            if let Some((instance, start, toplevel)) = self.step(store.0)? {\n                if let Some(start) = start {\n                    Instantiator::start_raw(store, instance, start)?;\n                }\n                if toplevel {\n                    break Ok(instance);\n                }\n            }\n        }\n    }\n\n    #[cfg(feature = \"async\")]\n    async fn run_async<T>(&mut self, store: &mut StoreContextMut<'_, T>) -> Result<Instance, Error>\n    where\n        T: Send,\n    {\n        assert!(\n            store.0.async_support(),\n            \"cannot use `new_async` without enabling async support on the config\"\n        );\n\n        // NB: this is the same code as `run`. It's intentionally\n        // small but should be kept in sync (modulo the async bits).\n        loop {\n            let step = self.step(store.0)?;\n            if let Some((instance, start, toplevel)) = step {\n                if let Some(start) = start {\n                    store\n                        .on_fiber(|store| Instantiator::start_raw(store, instance, start))\n                        .await??;\n                }\n                if toplevel {\n                    break Ok(instance);\n                }\n            }\n        }\n    }\n\n    /// Processes the next initializer for the next instance being created\n    /// without running any wasm code.\n    ///\n    /// This function will process module initializers, handling recursive\n    /// instantiations of modules for module linking if necessary as well. This\n    /// does not actually execute any WebAssembly code, which means that it\n    /// will return whenever an instance is created (because its `start`\n    /// function may need to be executed).\n    ///\n    /// If this function returns `None`, then it simply needs to be called\n    /// again to execute the next initializer. Otherwise this function has two\n    /// return values:\n    ///\n    /// * The first is the raw handle to the instance that was just created.\n    ///   This instance must have its start function executed by the caller.\n    /// * The second is an optional list of items to get wrapped up in an\n    ///   `Instance`. This is only `Some` for the outermost instance that was\n    ///   created. If this is `None` callers need to keep calling this function\n    ///   since the instance created was simply for a recursive instance\n    ///   defined here.\n    fn step(\n        &mut self,\n        store: &mut StoreOpaque,\n    ) -> Result<Option<(Instance, Option<FuncIndex>, bool)>> {\n        if self.cur.initializer == 0 {\n            store.bump_resource_counts(&self.cur.module)?;\n        }\n\n        // Read the current module's initializer and move forward the\n        // initializer pointer as well.\n        self.cur.initializer += 1;\n        match self\n            .cur\n            .module\n            .env_module()\n            .initializers\n            .get(self.cur.initializer - 1)\n        {\n            Some(Initializer::Import { name, field, .. }) => {\n                match &mut self.cur.src {\n                    // If imports are coming from the runtime-provided list\n                    // (e.g. the root module being instantiated) then we\n                    // need to typecheck each item here before recording it.\n                    //\n                    // Note the `unwrap` here should be ok given the validation\n                    // above in `Instantiation::new`.\n                    ImportSource::Externs(list) => {\n                        let (head, remaining) = list.split_first().unwrap();\n                        *list = remaining;\n                        self.cur.push(head.clone(), store);\n                    }\n                    ImportSource::Definitions(list) => {\n                        let (head, remaining) = list.split_first().unwrap();\n                        *list = remaining;\n                        // This unsafety is encapsulated with\n                        // `Instantiator::new`, documented above.\n                        self.cur.push(unsafe { head.to_extern(store) }, store);\n                    }\n\n                    // Otherwise if arguments are coming from our outer\n                    // instance due to a recursive instantiation then we\n                    // look in the previous initializer's mapping of\n                    // arguments to figure out where to load the item from.\n                    // Note that no typechecking is necessary here due to\n                    // validation.\n                    ImportSource::Outer { initializer } => {\n                        debug_assert!(field.is_none());\n                        let outer = self.in_progress.last().unwrap();\n                        let args = match &outer.module.env_module().initializers[*initializer] {\n                            Initializer::Instantiate { args, .. } => args,\n                            _ => unreachable!(),\n                        };\n                        let index = args.get(name).expect(\"should be present after validation\");\n                        match *index {\n                            EntityIndex::Global(i) => {\n                                self.cur.globals.push(outer.globals[i]);\n                            }\n                            EntityIndex::Function(i) => {\n                                self.cur.functions.push(outer.functions[i]);\n                            }\n                            EntityIndex::Table(i) => {\n                                self.cur.tables.push(outer.tables[i]);\n                            }\n                            EntityIndex::Memory(i) => {\n                                self.cur.memories.push(outer.memories[i]);\n                            }\n                            EntityIndex::Module(i) => {\n                                self.cur.modules.push(outer.modules[i].clone());\n                            }\n                            EntityIndex::Instance(i) => {\n                                self.cur.instances.push(outer.instances[i].clone());\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Here we lookup our instance handle, find the right export,\n            // and then push that item into our own index space. We eschew\n            // type-checking since only valid modules should reach this point.\n            Some(Initializer::AliasInstanceExport { instance, export }) => {\n                let instance = self.cur.instances[*instance];\n                let export = instance._get_export(store, export).unwrap();\n                self.cur.push(export, store);\n            }\n\n            // A recursive instantiation of an instance.\n            //\n            // The `module` argument is used to create an import builder\n            // object, and we specify that the source of imports for the builder is\n            // this initializer's position so we can look at the `args` payload\n            // later.\n            //\n            // Once that's set up we save off `self.cur` into\n            // `self.in_progress` and start the instantiation of the child\n            // instance on the next execution of this function.\n            Some(Initializer::Instantiate { module, args: _ }) => {\n                let module = &self.cur.modules[*module];\n                let imports = ImportsBuilder::new(\n                    module,\n                    ImportSource::Outer {\n                        initializer: self.cur.initializer - 1,\n                    },\n                );\n                let prev = mem::replace(&mut self.cur, imports);\n                self.in_progress.push(prev);\n            }\n\n            // A new module is being defined, and the source of this module is\n            // our module's list of closed-over-modules.\n            //\n            // This is used for outer aliases.\n            Some(Initializer::DefineModule(upvar_index)) => {\n                self.cur\n                    .modules\n                    .push(self.cur.module.module_upvar(*upvar_index).clone());\n            }\n\n            // A new module is defined, created from a set of compiled\n            // artifacts. The new module value will be created with the\n            // specified artifacts being closed over as well as the specified\n            // set of module values in our index/upvar index spaces being closed\n            // over.\n            //\n            // This is used for defining submodules.\n            Some(Initializer::CreateModule {\n                artifact_index,\n                artifacts,\n                modules,\n            }) => {\n                let submodule = self.cur.module.create_submodule(\n                    *artifact_index,\n                    artifacts,\n                    modules,\n                    &self.cur.modules,\n                );\n                self.cur.modules.push(submodule);\n            }\n\n            // All initializers have been processed, which means we're ready to\n            // perform the actual raw instantiation with the raw import values.\n            // Once that's done if there's an in-progress module we record the\n            // instance in the index space. Otherwise this is the final module\n            // and we return the items out.\n            //\n            // Note that in all cases we return the raw instance handle to get\n            // the start function executed by the outer context.\n            None => {\n                let (instance, start) = self.instantiate_raw(store)?;\n                let toplevel = match self.in_progress.pop() {\n                    Some(imports) => {\n                        self.cur = imports;\n                        self.cur.instances.push(instance);\n                        false\n                    }\n                    None => true,\n                };\n                return Ok(Some((instance, start, toplevel)));\n            }\n        }\n\n        Ok(None)\n    }\n\n    fn instantiate_raw(\n        &mut self,\n        store: &mut StoreOpaque,\n    ) -> Result<(Instance, Option<FuncIndex>)> {\n        let compiled_module = self.cur.module.compiled_module();\n\n        // Register the module just before instantiation to ensure we keep the module\n        // properly referenced while in use by the store.\n        store.modules_mut().register(&self.cur.module);\n\n        unsafe {\n            // The first thing we do is issue an instance allocation request\n            // to the instance allocator. This, on success, will give us an\n            // instance handle.\n            //\n            // Note that the `host_state` here is a pointer back to the\n            // `Instance` we'll be returning from this function. This is a\n            // circular reference so we can't construct it before we construct\n            // this instance, so we determine what the ID is and then assert\n            // it's the same later when we do actually insert it.\n            let instance_to_be = store.store_data().next_id::<InstanceData>();\n            let mut instance_handle =\n                store\n                    .engine()\n                    .allocator()\n                    .allocate(InstanceAllocationRequest {\n                        module: compiled_module.module().clone(),\n                        image_base: compiled_module.code().as_ptr() as usize,\n                        functions: compiled_module.functions(),\n                        imports: self.cur.build(),\n                        shared_signatures: self.cur.module.signatures().as_module_map().into(),\n                        host_state: Box::new(Instance(instance_to_be)),\n                        store: Some(store.traitobj()),\n                        wasm_data: compiled_module.wasm_data(),\n                    })?;\n\n            // The instance still has lots of setup, for example\n            // data/elements/start/etc. This can all fail, but even on failure\n            // the instance may persist some state via previous successful\n            // initialization. For this reason once we have an instance handle\n            // we immediately insert it into the store to keep it alive.\n            //\n            // Note that we `clone` the instance handle just to make easier\n            // working the the borrow checker here easier. Technically the `&mut\n            // instance` has somewhat of a borrow on `store` (which\n            // conflicts with the borrow on `store.engine`) but this doesn't\n            // matter in practice since initialization isn't even running any\n            // code here anyway.\n            let id = store.add_instance(instance_handle.clone(), false);\n\n            // Additionally, before we start doing fallible instantiation, we\n            // do one more step which is to insert an `InstanceData`\n            // corresponding to this instance. This `InstanceData` can be used\n            // via `Caller::get_export` if our instance's state \"leaks\" into\n            // other instances, even if we don't return successfully from this\n            // function.\n            //\n            // We don't actually load all exports from the instance at this\n            // time, instead preferring to lazily load them as they're demanded.\n            // For module/instance exports, though, those aren't actually\n            // stored in the instance handle so we need to immediately handle\n            // those here.\n            let instance = {\n                let exports = compiled_module\n                    .module()\n                    .exports\n                    .values()\n                    .map(|index| {\n                        // Note that instances and modules are not handled by\n                        // `wasmtime_runtime`, they're handled by us in this crate. That\n                        // means we need to handle that here, otherwise we defer to the\n                        // instance to load the values.\n                        match *index {\n                            EntityIndex::Instance(i) => {\n                                Some(Extern::Instance(self.cur.instances[i].clone()))\n                            }\n                            EntityIndex::Module(i) => {\n                                Some(Extern::Module(self.cur.modules[i].clone()))\n                            }\n                            _ => None,\n                        }\n                    })\n                    .collect();\n                let data = InstanceData::Instantiated {\n                    id,\n                    exports,\n                    types: Arc::clone(self.cur.module.types()),\n                    signatures: Arc::clone(self.cur.module.signatures()),\n                };\n                Instance::from_wasmtime(data, store)\n            };\n\n            // double-check our guess of what the new instance's ID would be\n            // was actually correct.\n            assert_eq!(instance.0, instance_to_be);\n\n            // Now that we've recorded all information we need to about this\n            // instance within a `Store` we can start performing fallible\n            // initialization. Note that we still defer the `start` function to\n            // later since that may need to run asynchronously.\n            //\n            // If this returns an error (or if the start function traps) then\n            // any other initialization which may have succeeded which placed\n            // items from this instance into other instances should be ok when\n            // those items are loaded and run we'll have all the metadata to\n            // look at them.\n            store\n                .engine()\n                .allocator()\n                .initialize(\n                    &mut instance_handle,\n                    compiled_module.module(),\n                    store.engine().config().features.bulk_memory,\n                )\n                .map_err(|e| -> Error {\n                    match e {\n                        InstantiationError::Trap(trap) => Trap::from_runtime(trap).into(),\n                        other => other.into(),\n                    }\n                })?;\n\n            Ok((instance, compiled_module.module().start_func))\n        }\n    }\n\n    fn start_raw<T>(\n        store: &mut StoreContextMut<'_, T>,\n        instance: Instance,\n        start: FuncIndex,\n    ) -> Result<()> {\n        let id = match &store.0.store_data()[instance.0] {\n            InstanceData::Instantiated { id, .. } => *id,\n            InstanceData::Synthetic(_) => return Ok(()),\n        };\n        // If a start function is present, invoke it. Make sure we use all the\n        // trap-handling configuration in `store` as well.\n        let instance = store.0.instance(id);\n        let f = match instance.lookup_by_declaration(&EntityIndex::Function(start)) {\n            wasmtime_runtime::Export::Function(f) => f,\n            _ => unreachable!(), // valid modules shouldn't hit this\n        };\n        let vmctx = instance.vmctx_ptr();\n        unsafe {\n            super::func::invoke_wasm_and_catch_traps(store, |_default_callee| {\n                mem::transmute::<\n                    *const VMFunctionBody,\n                    unsafe extern \"C\" fn(*mut VMContext, *mut VMContext),\n                >(f.anyfunc.as_ref().func_ptr.as_ptr())(\n                    f.anyfunc.as_ref().vmctx, vmctx\n                )\n            })?;\n        }\n        Ok(())\n    }\n}\n\nimpl<'a> ImportsBuilder<'a> {\n    fn new(module: &Module, src: ImportSource<'a>) -> ImportsBuilder<'a> {\n        let raw = module.compiled_module().module();\n        ImportsBuilder {\n            src,\n            functions: PrimaryMap::with_capacity(raw.num_imported_funcs),\n            tables: PrimaryMap::with_capacity(raw.num_imported_tables),\n            memories: PrimaryMap::with_capacity(raw.num_imported_memories),\n            globals: PrimaryMap::with_capacity(raw.num_imported_globals),\n            instances: PrimaryMap::with_capacity(raw.instances.len()),\n            modules: PrimaryMap::with_capacity(raw.modules.len()),\n            module: module.clone(),\n            initializer: 0,\n        }\n    }\n\n    fn push(&mut self, item: Extern, store: &mut StoreOpaque) {\n        match item {\n            Extern::Func(i) => {\n                self.functions.push(i.vmimport(store));\n            }\n            Extern::Global(i) => {\n                self.globals.push(i.vmimport(store));\n            }\n            Extern::Table(i) => {\n                self.tables.push(i.vmimport(store));\n            }\n            Extern::Memory(i) => {\n                self.memories.push(i.vmimport(store));\n            }\n            Extern::Instance(i) => {\n                self.instances.push(i);\n            }\n            Extern::Module(m) => {\n                self.modules.push(m);\n            }\n        }\n    }\n\n    fn build(&self) -> Imports<'_> {\n        Imports {\n            tables: self.tables.values().as_slice(),\n            globals: self.globals.values().as_slice(),\n            memories: self.memories.values().as_slice(),\n            functions: self.functions.values().as_slice(),\n        }\n    }\n}\n\n/// An instance, pre-instantiation, that is ready to be instantiated.\n///\n/// This structure represents an instance *just before* it was instantiated,\n/// after all type-checking and imports have been resolved. The only thing left\n/// to do for this instance is to actually run the process of instantiation.\n///\n/// Note that an `InstancePre` may not be tied to any particular [`Store`] if\n/// none of the imports it closed over are tied to any particular [`Store`].\n///\n/// This structure is created through the [`Linker::instantiate_pre`] method,\n/// which also has some more information and examples.\n///\n/// [`Store`]: crate::Store\n/// [`Linker::instantiate_pre`]: crate::Linker::instantiate_pre\npub struct InstancePre<T> {\n    module: Module,\n    items: Vec<Definition>,\n    _marker: std::marker::PhantomData<fn() -> T>,\n}\n\nimpl<T> InstancePre<T> {\n    pub(crate) unsafe fn new(\n        store: &mut StoreOpaque,\n        module: &Module,\n        items: Vec<Definition>,\n    ) -> Result<InstancePre<T>> {\n        typecheck_defs(store, module, &items)?;\n        Ok(InstancePre {\n            module: module.clone(),\n            items,\n            _marker: std::marker::PhantomData,\n        })\n    }\n\n    /// Instantiates this instance, creating a new instance within the provided\n    /// `store`.\n    ///\n    /// This function will run the actual process of instantiation to\n    /// completion. This will use all of the previously-closed-over items as\n    /// imports to instantiate the module that this was originally created with.\n    ///\n    /// For more information about instantiation see [`Instance::new`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if any import closed over by this [`InstancePre`] isn't owned by\n    /// `store`, or if `store` has async support enabled. Additionally this\n    /// function will panic if the `store` provided comes from a different\n    /// [`Engine`] than the [`InstancePre`] originally came from.\n    pub fn instantiate(&self, mut store: impl AsContextMut<Data = T>) -> Result<Instance> {\n        // For the unsafety here the typecheck happened at creation time of this\n        // structure and then othrewise the `T` of `InstancePre<T>` connects any\n        // host functions we have in our definition list to the `store` that was\n        // passed in.\n        let mut store = store.as_context_mut();\n        let mut instantiator = unsafe {\n            self.ensure_comes_from_same_store(&store.0)?;\n            Instantiator::new(\n                store.0,\n                &self.module,\n                ImportSource::Definitions(&self.items),\n            )?\n        };\n        instantiator.run(&mut store)\n    }\n\n    /// Creates a new instance, running the start function asynchronously\n    /// instead of inline.\n    ///\n    /// For more information about asynchronous instantiation see the\n    /// documentation on [`Instance::new_async`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if any import closed over by this [`InstancePre`] isn't owned by\n    /// `store`, or if `store` does not have async support enabled.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn instantiate_async(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n    ) -> Result<Instance>\n    where\n        T: Send,\n    {\n        // For the unsafety here see above\n        let mut store = store.as_context_mut();\n        let mut i = unsafe {\n            self.ensure_comes_from_same_store(&store.0)?;\n            Instantiator::new(\n                store.0,\n                &self.module,\n                ImportSource::Definitions(&self.items),\n            )?\n        };\n        i.run_async(&mut store.as_context_mut()).await\n    }\n\n    fn ensure_comes_from_same_store(&self, store: &StoreOpaque) -> Result<()> {\n        for import in self.items.iter() {\n            if !import.comes_from_same_store(store) {\n                bail!(\"cross-`Store` instantiation is not currently supported\");\n            }\n        }\n        Ok(())\n    }\n}\n\nfn typecheck_externs(store: &mut StoreOpaque, module: &Module, imports: &[Extern]) -> Result<()> {\n    for import in imports {\n        if !import.comes_from_same_store(store) {\n            bail!(\"cross-`Store` instantiation is not currently supported\");\n        }\n    }\n    typecheck(store, module, imports, |cx, ty, item| cx.extern_(ty, item))\n}\n\nfn typecheck_defs(store: &mut StoreOpaque, module: &Module, imports: &[Definition]) -> Result<()> {\n    for import in imports {\n        if !import.comes_from_same_store(store) {\n            bail!(\"cross-`Store` instantiation is not currently supported\");\n        }\n    }\n    typecheck(store, module, imports, |cx, ty, item| {\n        cx.definition(ty, item)\n    })\n}\n\nfn typecheck<I>(\n    store: &mut StoreOpaque,\n    module: &Module,\n    imports: &[I],\n    check: impl Fn(&matching::MatchCx<'_>, &EntityType, &I) -> Result<()>,\n) -> Result<()> {\n    let env_module = module.compiled_module().module();\n    let expected = env_module.imports().count();\n    if expected != imports.len() {\n        bail!(\"expected {} imports, found {}\", expected, imports.len());\n    }\n    let cx = matching::MatchCx {\n        signatures: module.signatures(),\n        types: module.types(),\n        store: store,\n        engine: store.engine(),\n    };\n    for ((name, field, expected_ty), actual) in env_module.imports().zip(imports) {\n        check(&cx, &expected_ty, actual).with_context(|| {\n            let extra = match field {\n                Some(name) => format!(\"::{}\", name),\n                None => String::new(),\n            };\n            format!(\"incompatible import type for `{}{}`\", name, extra)\n        })?;\n    }\n    Ok(())\n}\n", "use crate::func::HostFunc;\nuse crate::instance::{InstanceData, InstancePre};\nuse crate::store::StoreOpaque;\nuse crate::{\n    AsContextMut, Caller, Engine, Extern, ExternType, Func, FuncType, ImportType, Instance,\n    IntoFunc, Module, StoreContextMut, Trap, Val,\n};\nuse anyhow::{anyhow, bail, Context, Error, Result};\nuse log::warn;\nuse std::collections::hash_map::{Entry, HashMap};\n#[cfg(feature = \"async\")]\nuse std::future::Future;\nuse std::marker;\n#[cfg(feature = \"async\")]\nuse std::pin::Pin;\nuse std::sync::Arc;\n\n/// Structure used to link wasm modules/instances together.\n///\n/// This structure is used to assist in instantiating a [`Module`]. A [`Linker`]\n/// is a way of performing name resolution to make instantiating a module easier\n/// than specifying positional imports to [`Instance::new`]. [`Linker`] is a\n/// name-based resolver where names are dynamically defined and then used to\n/// instantiate a [`Module`].\n///\n/// An important method is [`Linker::instantiate`] which takes a module to\n/// instantiate into the provided store. This method will automatically select\n/// all the right imports for the [`Module`] to be instantiated, and will\n/// otherwise return an error if an import isn't satisfied.\n///\n/// ## Name Resolution\n///\n/// As mentioned previously, `Linker` is a form of name resolver. It will be\n/// using the string-based names of imports on a module to attempt to select a\n/// matching item to hook up to it. This name resolution has two-levels of\n/// namespaces, a module level and a name level. Each item is defined within a\n/// module and then has its own name. This basically follows the wasm standard\n/// for modularization.\n///\n/// Names in a `Linker` cannot be defined twice, but allowing duplicates by\n/// shadowing the previous definition can be controlled with the\n/// [`Linker::allow_shadowing`] method.\n///\n/// ## Commands and Reactors\n///\n/// The [`Linker`] type provides conveniences for working with WASI Commands and\n/// Reactors through the [`Linker::module`] method. This will automatically\n/// handle instantiation and calling `_start` and such as appropriate\n/// depending on the inferred type of module.\n///\n/// ## Type parameter `T`\n///\n/// It's worth pointing out that the type parameter `T` on [`Linker<T>`] does\n/// not represent that `T` is stored within a [`Linker`]. Rather the `T` is used\n/// to ensure that linker-defined functions and stores instantiated into all use\n/// the same matching `T` as host state.\n///\n/// ## Multiple `Store`s\n///\n/// The [`Linker`] type is designed to be compatible, in some scenarios, with\n/// instantiation in multiple [`Store`]s. Specifically host-defined functions\n/// created in [`Linker`] with [`Linker::func_new`], [`Linker::func_wrap`], and\n/// their async versions are compatible to instantiate into any [`Store`]. This\n/// enables programs which want to instantiate lots of modules to create one\n/// [`Linker`] value at program start up and use that continuously for each\n/// [`Store`] created over the lifetime of the program.\n///\n/// Note that once [`Store`]-owned items, such as [`Global`], are defined witin\n/// a [`Linker`] then it is no longer compatible with any [`Store`]. At that\n/// point only the [`Store`] that owns the [`Global`] can be used to instantiate\n/// modules.\n///\n/// ## Multiple `Engine`s\n///\n/// The [`Linker`] type is not compatible with usage between multiple [`Engine`]\n/// values. An [`Engine`] is provided when a [`Linker`] is created and only\n/// stores and items which originate from that [`Engine`] can be used with this\n/// [`Linker`]. If more than one [`Engine`] is used with a [`Linker`] then that\n/// may cause a panic at runtime, similar to how if a [`Func`] is used with the\n/// wrong [`Store`] that can also panic at runtime.\n///\n/// [`Store`]: crate::Store\n/// [`Global`]: crate::Global\npub struct Linker<T> {\n    engine: Engine,\n    string2idx: HashMap<Arc<str>, usize>,\n    strings: Vec<Arc<str>>,\n    map: HashMap<ImportKey, Definition>,\n    allow_shadowing: bool,\n    allow_unknown_exports: bool,\n    _marker: marker::PhantomData<fn() -> T>,\n}\n\nimpl<T> Clone for Linker<T> {\n    fn clone(&self) -> Linker<T> {\n        Linker {\n            engine: self.engine.clone(),\n            string2idx: self.string2idx.clone(),\n            strings: self.strings.clone(),\n            map: self.map.clone(),\n            allow_shadowing: self.allow_shadowing,\n            allow_unknown_exports: self.allow_unknown_exports,\n            _marker: self._marker,\n        }\n    }\n}\n\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\nstruct ImportKey {\n    name: usize,\n    module: usize,\n}\n\n#[derive(Clone)]\npub(crate) enum Definition {\n    Extern(Extern),\n    HostFunc(Arc<HostFunc>),\n    Instance(Arc<indexmap::IndexMap<String, Definition>>),\n}\n\nmacro_rules! generate_wrap_async_func {\n    ($num:tt $($args:ident)*) => (paste::paste!{\n        /// Asynchronous analog of [`Linker::func_wrap`].\n        ///\n        /// For more information also see\n        /// [`Func::wrapN_async`](crate::Func::wrap1_async).\n        #[allow(non_snake_case)]\n        #[cfg(feature = \"async\")]\n        #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n        pub fn [<func_wrap $num _async>]<$($args,)* R>(\n            &mut self,\n            module: &str,\n            name: &str,\n            func: impl for<'a> Fn(Caller<'a, T>, $($args),*) -> Box<dyn Future<Output = R> + Send + 'a> + Send + Sync + 'static,\n        ) -> Result<&mut Self>\n        where\n            $($args: crate::WasmTy,)*\n            R: crate::WasmRet,\n        {\n            assert!(\n                self.engine.config().async_support,\n                concat!(\n                    \"cannot use `func_wrap\",\n                    $num,\n                    \"_async` without enabling async support on the config\",\n                ),\n            );\n            self.func_wrap(module, name, move |mut caller: Caller<'_, T>, $($args: $args),*| {\n                let async_cx = caller.store.as_context_mut().0.async_cx();\n                let mut future = Pin::from(func(caller, $($args),*));\n                match unsafe { async_cx.block_on(future.as_mut()) } {\n                    Ok(ret) => ret.into_fallible(),\n                    Err(e) => R::fallible_from_trap(e),\n                }\n            })\n        }\n    })\n}\n\nimpl<T> Linker<T> {\n    /// Creates a new [`Linker`].\n    ///\n    /// The linker will define functions within the context of the `engine`\n    /// provided and can only instantiate modules for a [`Store`] that is also\n    /// defined within the same [`Engine`]. Usage of stores with different\n    /// [`Engine`]s may cause a panic when used with this [`Linker`].\n    pub fn new(engine: &Engine) -> Linker<T> {\n        Linker {\n            engine: engine.clone(),\n            map: HashMap::new(),\n            string2idx: HashMap::new(),\n            strings: Vec::new(),\n            allow_shadowing: false,\n            allow_unknown_exports: false,\n            _marker: marker::PhantomData,\n        }\n    }\n\n    /// Returns the [`Engine`] this is connected to.\n    pub fn engine(&self) -> &Engine {\n        &self.engine\n    }\n\n    /// Configures whether this [`Linker`] will shadow previous duplicate\n    /// definitions of the same signature.\n    ///\n    /// By default a [`Linker`] will disallow duplicate definitions of the same\n    /// signature. This method, however, can be used to instead allow duplicates\n    /// and have the latest definition take precedence when linking modules.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// let mut linker = Linker::<()>::new(&engine);\n    /// linker.func_wrap(\"\", \"\", || {})?;\n    ///\n    /// // by default, duplicates are disallowed\n    /// assert!(linker.func_wrap(\"\", \"\", || {}).is_err());\n    ///\n    /// // but shadowing can be configured to be allowed as well\n    /// linker.allow_shadowing(true);\n    /// linker.func_wrap(\"\", \"\", || {})?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn allow_shadowing(&mut self, allow: bool) -> &mut Self {\n        self.allow_shadowing = allow;\n        self\n    }\n\n    /// Configures whether this [`Linker`] will allow unknown exports from\n    /// command modules.\n    ///\n    /// By default a [`Linker`] will error when unknown exports are encountered\n    /// in a command module while using [`Linker::module`].\n    ///\n    /// This method can be used to allow unknown exports from command modules.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let module = Module::new(&engine, \"(module)\")?;\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// linker.allow_unknown_exports(true);\n    /// linker.module(&mut store, \"mod\", &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn allow_unknown_exports(&mut self, allow: bool) -> &mut Self {\n        self.allow_unknown_exports = allow;\n        self\n    }\n\n    /// Defines a new item in this [`Linker`].\n    ///\n    /// This method will add a new definition, by name, to this instance of\n    /// [`Linker`]. The `module` and `name` provided are what to name the\n    /// `item`.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the `module` and `name` already identify an item\n    /// of the same type as the `item` provided and if shadowing is disallowed.\n    /// For more information see the documentation on [`Linker`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// let ty = GlobalType::new(ValType::I32, Mutability::Const);\n    /// let global = Global::new(&mut store, ty, Val::I32(0x1234))?;\n    /// linker.define(\"host\", \"offset\", global)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"offset\" (global i32))\n    ///         (memory 1)\n    ///         (data (global.get 0) \"foo\")\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn define(\n        &mut self,\n        module: &str,\n        name: &str,\n        item: impl Into<Extern>,\n    ) -> Result<&mut Self> {\n        let key = self.import_key(module, Some(name));\n        self.insert(key, Definition::Extern(item.into()))?;\n        Ok(self)\n    }\n\n    /// Same as [`Linker::define`], except only the name of the import is\n    /// provided, not a module name as well.\n    ///\n    /// This is only relevant when working with the module linking proposal\n    /// where one-level names are allowed (in addition to two-level names).\n    /// Otherwise this method need not be used.\n    pub fn define_name(&mut self, name: &str, item: impl Into<Extern>) -> Result<&mut Self> {\n        let key = self.import_key(name, None);\n        self.insert(key, Definition::Extern(item.into()))?;\n        Ok(self)\n    }\n\n    /// Creates a [`Func::new`]-style function named in this linker.\n    ///\n    /// For more information see [`Linker::func_wrap`].\n    #[cfg(compiler)]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"cranelift\")))] // see build.rs\n    pub fn func_new(\n        &mut self,\n        module: &str,\n        name: &str,\n        ty: FuncType,\n        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,\n    ) -> Result<&mut Self> {\n        let func = HostFunc::new(&self.engine, ty, func);\n        let key = self.import_key(module, Some(name));\n        self.insert(key, Definition::HostFunc(Arc::new(func)))?;\n        Ok(self)\n    }\n\n    /// Creates a [`Func::new_async`]-style function named in this linker.\n    ///\n    /// For more information see [`Linker::func_wrap`].\n    #[cfg(all(feature = \"async\", feature = \"cranelift\"))]\n    #[cfg_attr(nightlydoc, doc(cfg(all(feature = \"async\", feature = \"cranelift\"))))]\n    pub fn func_new_async<F>(\n        &mut self,\n        module: &str,\n        name: &str,\n        ty: FuncType,\n        func: F,\n    ) -> Result<&mut Self>\n    where\n        F: for<'a> Fn(\n                Caller<'a, T>,\n                &'a [Val],\n                &'a mut [Val],\n            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>\n            + Send\n            + Sync\n            + 'static,\n    {\n        assert!(\n            self.engine.config().async_support,\n            \"cannot use `func_new_async` without enabling async support in the config\"\n        );\n        self.func_new(module, name, ty, move |mut caller, params, results| {\n            let async_cx = caller.store.as_context_mut().0.async_cx();\n            let mut future = Pin::from(func(caller, params, results));\n            match unsafe { async_cx.block_on(future.as_mut()) } {\n                Ok(Ok(())) => Ok(()),\n                Ok(Err(trap)) | Err(trap) => Err(trap),\n            }\n        })\n    }\n\n    /// Define a host function within this linker.\n    ///\n    /// For information about how the host function operates, see\n    /// [`Func::wrap`]. That includes information about translating Rust types\n    /// to WebAssembly native types.\n    ///\n    /// This method creates a host-provided function in this linker under the\n    /// provided name. This method is distinct in its capability to create a\n    /// [`Store`](crate::Store)-independent function. This means that the\n    /// function defined here can be used to instantiate instances in multiple\n    /// different stores, or in other words the function can be loaded into\n    /// different stores.\n    ///\n    /// Note that the capability mentioned here applies to all other\n    /// host-function-defining-methods on [`Linker`] as well. All of them can be\n    /// used to create instances of [`Func`] within multiple stores. In a\n    /// multithreaded program, for example, this means that the host functions\n    /// could be called concurrently if different stores are executing on\n    /// different threads.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the `module` and `name` already identify an item\n    /// of the same type as the `item` provided and if shadowing is disallowed.\n    /// For more information see the documentation on [`Linker`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// let mut linker = Linker::new(&engine);\n    /// linker.func_wrap(\"host\", \"double\", |x: i32| x * 2)?;\n    /// linker.func_wrap(\"host\", \"log_i32\", |x: i32| println!(\"{}\", x))?;\n    /// linker.func_wrap(\"host\", \"log_str\", |caller: Caller<'_, ()>, ptr: i32, len: i32| {\n    ///     // ...\n    /// })?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"double\" (func (param i32) (result i32)))\n    ///         (import \"host\" \"log_i32\" (func (param i32)))\n    ///         (import \"host\" \"log_str\" (func (param i32 i32)))\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    ///\n    /// // instantiate in multiple different stores\n    /// for _ in 0..10 {\n    ///     let mut store = Store::new(&engine, ());\n    ///     linker.instantiate(&mut store, &module)?;\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn func_wrap<Params, Args>(\n        &mut self,\n        module: &str,\n        name: &str,\n        func: impl IntoFunc<T, Params, Args>,\n    ) -> Result<&mut Self> {\n        let func = HostFunc::wrap(&self.engine, func);\n        let key = self.import_key(module, Some(name));\n        self.insert(key, Definition::HostFunc(Arc::new(func)))?;\n        Ok(self)\n    }\n\n    for_each_function_signature!(generate_wrap_async_func);\n\n    /// Convenience wrapper to define an entire [`Instance`] in this linker.\n    ///\n    /// This function is a convenience wrapper around [`Linker::define`] which\n    /// will define all exports on `instance` into this linker. The module name\n    /// for each export is `module_name`, and the name for each export is the\n    /// name in the instance itself.\n    ///\n    /// Note that when this API is used the [`Linker`] is no longer compatible\n    /// with multi-[`Store` ] instantiation because the items defined within\n    /// this store will belong to the `store` provided, and only the `store`\n    /// provided.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the any item is redefined twice in this linker (for\n    /// example the same `module_name` was already defined) and shadowing is\n    /// disallowed, or if `instance` comes from a different\n    /// [`Store`](crate::Store) than this [`Linker`] originally was created\n    /// with.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `instance` does not belong to `store`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    ///\n    /// // Instantiate a small instance...\n    /// let wat = r#\"(module (func (export \"run\") ))\"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance = linker.instantiate(&mut store, &module)?;\n    ///\n    /// // ... and inform the linker that the name of this instance is\n    /// // `instance1`. This defines the `instance1::run` name for our next\n    /// // module to use.\n    /// linker.instance(&mut store, \"instance1\", instance)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"instance1\" \"run\" (func $instance1_run))\n    ///         (func (export \"run\")\n    ///             call $instance1_run\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance = linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn instance(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        instance: Instance,\n    ) -> Result<&mut Self> {\n        for export in instance.exports(store.as_context_mut()) {\n            let key = self.import_key(module_name, Some(export.name()));\n            self.insert(key, Definition::Extern(export.into_extern()))?;\n        }\n        Ok(self)\n    }\n\n    /// Define automatic instantiations of a [`Module`] in this linker.\n    ///\n    /// This automatically handles [Commands and Reactors] instantiation and\n    /// initialization.\n    ///\n    /// Exported functions of a Command module may be called directly, however\n    /// instead of having a single instance which is reused for each call,\n    /// each call creates a new instance, which lives for the duration of the\n    /// call. The imports of the Command are resolved once, and reused for\n    /// each instantiation, so all dependencies need to be present at the time\n    /// when `Linker::module` is called.\n    ///\n    /// For Reactors, a single instance is created, and an initialization\n    /// function is called, and then its exports may be called.\n    ///\n    /// Ordinary modules which don't declare themselves to be either Commands\n    /// or Reactors are treated as Reactors without any initialization calls.\n    ///\n    /// [Commands and Reactors]: https://github.com/WebAssembly/WASI/blob/master/design/application-abi.md#current-unstable-abi\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the any item is redefined twice in this linker (for\n    /// example the same `module_name` was already defined) and shadowing is\n    /// disallowed, if `instance` comes from a different\n    /// [`Store`](crate::Store) than this [`Linker`] originally was created\n    /// with, or if a Reactor initialization function traps.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any item used to instantiate the provided [`Module`] is not\n    /// owned by `store`, or if the `store` provided comes from a different\n    /// [`Engine`] than this [`Linker`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    ///\n    /// // Instantiate a small instance and inform the linker that the name of\n    /// // this instance is `instance1`. This defines the `instance1::run` name\n    /// // for our next module to use.\n    /// let wat = r#\"(module (func (export \"run\") ))\"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.module(&mut store, \"instance1\", &module)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"instance1\" \"run\" (func $instance1_run))\n    ///         (func (export \"run\")\n    ///             call $instance1_run\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance = linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// For a Command, a new instance is created for each call.\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    ///\n    /// // Create a Command that attempts to count the number of times it is run, but is\n    /// // foiled by each call getting a new instance.\n    /// let wat = r#\"\n    ///     (module\n    ///         (global $counter (mut i32) (i32.const 0))\n    ///         (func (export \"_start\")\n    ///             (global.set $counter (i32.add (global.get $counter) (i32.const 1)))\n    ///         )\n    ///         (func (export \"read_counter\") (result i32)\n    ///             (global.get $counter)\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.module(&mut store, \"commander\", &module)?;\n    /// let run = linker.get_default(&mut store, \"\")?\n    ///     .typed::<(), (), _>(&store)?\n    ///     .clone();\n    /// run.call(&mut store, ())?;\n    /// run.call(&mut store, ())?;\n    /// run.call(&mut store, ())?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"commander\" \"_start\" (func $commander_start))\n    ///         (import \"commander\" \"read_counter\" (func $commander_read_counter (result i32)))\n    ///         (func (export \"run\") (result i32)\n    ///             call $commander_start\n    ///             call $commander_start\n    ///             call $commander_start\n    ///             call $commander_read_counter\n    ///         )\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.module(&mut store, \"\", &module)?;\n    /// let run = linker.get(&mut store, \"\", Some(\"run\")).unwrap().into_func().unwrap();\n    /// let count = run.typed::<(), i32, _>(&store)?.call(&mut store, ())?;\n    /// assert_eq!(count, 0, \"a Command should get a fresh instance on each invocation\");\n    ///\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[cfg(compiler)]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"cranelift\")))] // see build.rs\n    pub fn module(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        module: &Module,\n    ) -> Result<&mut Self>\n    where\n        T: 'static,\n    {\n        // NB: this is intended to function the same as `Linker::module_async`,\n        // they should be kept in sync.\n\n        // This assert isn't strictly necessary since it'll bottom out in the\n        // `HostFunc::to_func` method anyway. This is placed earlier for this\n        // function though to prevent the functions created here from delaying\n        // the panic until they're called.\n        assert!(\n            Engine::same(&self.engine, store.as_context().engine()),\n            \"different engines for this linker and the store provided\"\n        );\n        match ModuleKind::categorize(module)? {\n            ModuleKind::Command => {\n                self.command(\n                    store,\n                    module_name,\n                    module,\n                    |store, func_ty, export_name, instance_pre| {\n                        Func::new(\n                            store,\n                            func_ty.clone(),\n                            move |mut caller, params, results| {\n                                // Create a new instance for this command execution.\n                                let instance = instance_pre.instantiate(&mut caller)?;\n\n                                // `unwrap()` everything here because we know the instance contains a\n                                // function export with the given name and signature because we're\n                                // iterating over the module it was instantiated from.\n                                let command_results = instance\n                                    .get_export(&mut caller, &export_name)\n                                    .unwrap()\n                                    .into_func()\n                                    .unwrap()\n                                    .call(&mut caller, params)\n                                    .map_err(|error| error.downcast::<Trap>().unwrap())?;\n\n                                // Copy the return values into the output slice.\n                                for (result, command_result) in\n                                    results.iter_mut().zip(command_results.into_vec())\n                                {\n                                    *result = command_result;\n                                }\n\n                                Ok(())\n                            },\n                        )\n                    },\n                )\n            }\n            ModuleKind::Reactor => {\n                let instance = self.instantiate(&mut store, &module)?;\n\n                if let Some(export) = instance.get_export(&mut store, \"_initialize\") {\n                    if let Extern::Func(func) = export {\n                        func.typed::<(), (), _>(&store)\n                            .and_then(|f| f.call(&mut store, ()).map_err(Into::into))\n                            .context(\"calling the Reactor initialization function\")?;\n                    }\n                }\n\n                self.instance(store, module_name, instance)\n            }\n        }\n    }\n\n    /// Define automatic instantiations of a [`Module`] in this linker.\n    ///\n    /// This is the same as [`Linker::module`], except for async `Store`s.\n    #[cfg(all(feature = \"async\", feature = \"cranelift\"))]\n    #[cfg_attr(nightlydoc, doc(cfg(all(feature = \"async\", feature = \"cranelift\"))))]\n    pub async fn module_async(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        module: &Module,\n    ) -> Result<&mut Self>\n    where\n        T: Send + 'static,\n    {\n        // NB: this is intended to function the same as `Linker::module`, they\n        // should be kept in sync.\n        assert!(\n            Engine::same(&self.engine, store.as_context().engine()),\n            \"different engines for this linker and the store provided\"\n        );\n        match ModuleKind::categorize(module)? {\n            ModuleKind::Command => self.command(\n                store,\n                module_name,\n                module,\n                |store, func_ty, export_name, instance_pre| {\n                    let upvars = Arc::new((instance_pre, export_name));\n                    Func::new_async(\n                        store,\n                        func_ty.clone(),\n                        move |mut caller, params, results| {\n                            let upvars = upvars.clone();\n                            Box::new(async move {\n                                let (instance_pre, export_name) = &*upvars;\n                                let instance = instance_pre.instantiate_async(&mut caller).await?;\n\n                                let command_results = instance\n                                    .get_export(&mut caller, &export_name)\n                                    .unwrap()\n                                    .into_func()\n                                    .unwrap()\n                                    .call_async(&mut caller, params)\n                                    .await\n                                    .map_err(|error| error.downcast::<Trap>().unwrap())?;\n\n                                for (result, command_result) in\n                                    results.iter_mut().zip(command_results.into_vec())\n                                {\n                                    *result = command_result;\n                                }\n                                Ok(())\n                            })\n                        },\n                    )\n                },\n            ),\n            ModuleKind::Reactor => {\n                let instance = self.instantiate_async(&mut store, &module).await?;\n\n                if let Some(export) = instance.get_export(&mut store, \"_initialize\") {\n                    if let Extern::Func(func) = export {\n                        let func = func\n                            .typed::<(), (), _>(&store)\n                            .context(\"loading the Reactor initialization function\")?;\n                        func.call_async(&mut store, ())\n                            .await\n                            .context(\"calling the Reactor initialization function\")?;\n                    }\n                }\n\n                self.instance(store, module_name, instance)\n            }\n        }\n    }\n\n    fn command(\n        &mut self,\n        mut store: impl AsContextMut<Data = T>,\n        module_name: &str,\n        module: &Module,\n        mk_func: impl Fn(&mut StoreContextMut<T>, &FuncType, String, InstancePre<T>) -> Func,\n    ) -> Result<&mut Self>\n    where\n        T: 'static,\n    {\n        let mut store = store.as_context_mut();\n        for export in module.exports() {\n            if let Some(func_ty) = export.ty().func() {\n                let instance_pre = self.instantiate_pre(&mut store, module)?;\n                let export_name = export.name().to_owned();\n                let func = mk_func(&mut store, func_ty, export_name, instance_pre);\n                let key = self.import_key(module_name, Some(export.name()));\n                self.insert(key, Definition::Extern(func.into()))?;\n            } else if export.name() == \"memory\" && export.ty().memory().is_some() {\n                // Allow an exported \"memory\" memory for now.\n            } else if export.name() == \"__indirect_function_table\" && export.ty().table().is_some()\n            {\n                // Allow an exported \"__indirect_function_table\" table for now.\n            } else if export.name() == \"table\" && export.ty().table().is_some() {\n                // Allow an exported \"table\" table for now.\n            } else if export.name() == \"__data_end\" && export.ty().global().is_some() {\n                // Allow an exported \"__data_end\" memory for compatibility with toolchains\n                // which use --export-dynamic, which unfortunately doesn't work the way\n                // we want it to.\n                warn!(\"command module exporting '__data_end' is deprecated\");\n            } else if export.name() == \"__heap_base\" && export.ty().global().is_some() {\n                // Allow an exported \"__data_end\" memory for compatibility with toolchains\n                // which use --export-dynamic, which unfortunately doesn't work the way\n                // we want it to.\n                warn!(\"command module exporting '__heap_base' is deprecated\");\n            } else if export.name() == \"__dso_handle\" && export.ty().global().is_some() {\n                // Allow an exported \"__dso_handle\" memory for compatibility with toolchains\n                // which use --export-dynamic, which unfortunately doesn't work the way\n                // we want it to.\n                warn!(\"command module exporting '__dso_handle' is deprecated\")\n            } else if export.name() == \"__rtti_base\" && export.ty().global().is_some() {\n                // Allow an exported \"__rtti_base\" memory for compatibility with\n                // AssemblyScript.\n                warn!(\"command module exporting '__rtti_base' is deprecated; pass `--runtime half` to the AssemblyScript compiler\");\n            } else if !self.allow_unknown_exports {\n                bail!(\"command export '{}' is not a function\", export.name());\n            }\n        }\n\n        Ok(self)\n    }\n\n    /// Aliases one item's name as another.\n    ///\n    /// This method will alias an item with the specified `module` and `name`\n    /// under a new name of `as_module` and `as_name`.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if any shadowing violations happen while defining new\n    /// items, or if the original item wasn't defined.\n    pub fn alias(\n        &mut self,\n        module: &str,\n        name: &str,\n        as_module: &str,\n        as_name: &str,\n    ) -> Result<&mut Self> {\n        let src = self.import_key(module, Some(name));\n        let dst = self.import_key(as_module, Some(as_name));\n        match self.map.get(&src).cloned() {\n            Some(item) => self.insert(dst, item)?,\n            None => bail!(\"no item named `{}::{}` defined\", module, name),\n        }\n        Ok(self)\n    }\n\n    /// Aliases one module's name as another.\n    ///\n    /// This method will alias all currently defined under `module` to also be\n    /// defined under the name `as_module` too.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if any shadowing violations happen while defining new\n    /// items.\n    pub fn alias_module(&mut self, module: &str, as_module: &str) -> Result<()> {\n        let module = self.intern_str(module);\n        let as_module = self.intern_str(as_module);\n        let items = self\n            .map\n            .iter()\n            .filter(|(key, _def)| key.module == module)\n            .map(|(key, def)| (key.name, def.clone()))\n            .collect::<Vec<_>>();\n        for (name, item) in items {\n            self.insert(\n                ImportKey {\n                    module: as_module,\n                    name,\n                },\n                item,\n            )?;\n        }\n        Ok(())\n    }\n\n    fn insert(&mut self, key: ImportKey, item: Definition) -> Result<()> {\n        match self.map.entry(key) {\n            Entry::Occupied(_) if !self.allow_shadowing => {\n                let module = &self.strings[key.module];\n                let desc = match self.strings.get(key.name) {\n                    Some(name) => format!(\"{}::{}\", module, name),\n                    None => module.to_string(),\n                };\n                bail!(\"import of `{}` defined twice\", desc)\n            }\n            Entry::Occupied(mut o) => {\n                o.insert(item);\n            }\n            Entry::Vacant(v) => {\n                v.insert(item);\n            }\n        }\n        Ok(())\n    }\n\n    fn import_key(&mut self, module: &str, name: Option<&str>) -> ImportKey {\n        ImportKey {\n            module: self.intern_str(module),\n            name: name\n                .map(|name| self.intern_str(name))\n                .unwrap_or(usize::max_value()),\n        }\n    }\n\n    fn intern_str(&mut self, string: &str) -> usize {\n        if let Some(idx) = self.string2idx.get(string) {\n            return *idx;\n        }\n        let string: Arc<str> = string.into();\n        let idx = self.strings.len();\n        self.strings.push(string.clone());\n        self.string2idx.insert(string, idx);\n        idx\n    }\n\n    /// Attempts to instantiate the `module` provided.\n    ///\n    /// This method will attempt to assemble a list of imports that correspond\n    /// to the imports required by the [`Module`] provided. This list\n    /// of imports is then passed to [`Instance::new`] to continue the\n    /// instantiation process.\n    ///\n    /// Each import of `module` will be looked up in this [`Linker`] and must\n    /// have previously been defined. If it was previously defined with an\n    /// incorrect signature or if it was not previously defined then an error\n    /// will be returned because the import can not be satisfied.\n    ///\n    /// Per the WebAssembly spec, instantiation includes running the module's\n    /// start function, if it has one (not to be confused with the `_start`\n    /// function, which is not run).\n    ///\n    /// # Errors\n    ///\n    /// This method can fail because an import may not be found, or because\n    /// instantiation itself may fail. For information on instantiation\n    /// failures see [`Instance::new`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if any item used to instantiate `module` is not owned by\n    /// `store`. Additionally this will panic if the [`Engine`] that the `store`\n    /// belongs to is different than this [`Linker`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// linker.func_wrap(\"host\", \"double\", |x: i32| x * 2)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"double\" (func (param i32) (result i32)))\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// linker.instantiate(&mut store, &module)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn instantiate(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n    ) -> Result<Instance> {\n        self.instantiate_pre(&mut store, module)?.instantiate(store)\n    }\n\n    /// Attempts to instantiate the `module` provided. This is the same as\n    /// [`Linker::instantiate`], except for async `Store`s.\n    #[cfg(feature = \"async\")]\n    #[cfg_attr(nightlydoc, doc(cfg(feature = \"async\")))]\n    pub async fn instantiate_async(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n    ) -> Result<Instance>\n    where\n        T: Send,\n    {\n        self.instantiate_pre(&mut store, module)?\n            .instantiate_async(store)\n            .await\n    }\n\n    /// Performs all checks necessary for instantiating `module` with this\n    /// linker within `store`, except that instantiation doesn't actually\n    /// finish.\n    ///\n    /// This method is used for front-loading type-checking information as well\n    /// as collecting the imports to use to instantiate a module with. The\n    /// returned [`InstancePre`] represents a ready-to-be-instantiated module,\n    /// which can also be instantiated multiple times if desired.\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if any item defined in this linker used by\n    /// `module` is not owned by `store`. Additionally this will panic if the\n    /// [`Engine`] that the `store` belongs to is different than this\n    /// [`Linker`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use wasmtime::*;\n    /// # fn main() -> anyhow::Result<()> {\n    /// # let engine = Engine::default();\n    /// # let mut store = Store::new(&engine, ());\n    /// let mut linker = Linker::new(&engine);\n    /// linker.func_wrap(\"host\", \"double\", |x: i32| x * 2)?;\n    ///\n    /// let wat = r#\"\n    ///     (module\n    ///         (import \"host\" \"double\" (func (param i32) (result i32)))\n    ///     )\n    /// \"#;\n    /// let module = Module::new(&engine, wat)?;\n    /// let instance_pre = linker.instantiate_pre(&mut store, &module)?;\n    ///\n    /// // Finish instantiation after the type-checking has all completed...\n    /// let instance = instance_pre.instantiate(&mut store)?;\n    ///\n    /// // ... and we can even continue to keep instantiating if desired!\n    /// instance_pre.instantiate(&mut store)?;\n    /// instance_pre.instantiate(&mut store)?;\n    ///\n    /// // Note that functions defined in a linker with `func_wrap` and similar\n    /// // constructors are not owned by any particular `Store`, so we can also\n    /// // instantiate our `instance_pre` in other stores because no imports\n    /// // belong to the original store.\n    /// let mut new_store = Store::new(&engine, ());\n    /// instance_pre.instantiate(&mut new_store)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn instantiate_pre(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &Module,\n    ) -> Result<InstancePre<T>> {\n        let store = store.as_context_mut().0;\n        let imports = module\n            .imports()\n            .map(|import| {\n                self._get_by_import(&import)\n                    .ok_or_else(|| self.link_error(&import))\n            })\n            .collect::<Result<_>>()?;\n        unsafe { InstancePre::new(store, module, imports) }\n    }\n\n    fn link_error(&self, import: &ImportType) -> Error {\n        let desc = match import.name() {\n            Some(name) => format!(\"{}::{}\", import.module(), name),\n            None => import.module().to_string(),\n        };\n        anyhow!(\"unknown import: `{}` has not been defined\", desc)\n    }\n\n    /// Returns an iterator over all items defined in this `Linker`, in\n    /// arbitrary order.\n    ///\n    /// The iterator returned will yield 3-tuples where the first two elements\n    /// are the module name and item name for the external item, and the third\n    /// item is the item itself that is defined.\n    ///\n    /// Note that multiple `Extern` items may be defined for the same\n    /// module/name pair.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the `store` provided does not come from the\n    /// same [`Engine`] that this linker was created with.\n    pub fn iter<'a: 'p, 'p>(\n        &'a self,\n        mut store: impl AsContextMut<Data = T> + 'p,\n    ) -> impl Iterator<Item = (&str, &str, Extern)> + 'p {\n        self.map.iter().map(move |(key, item)| {\n            let store = store.as_context_mut();\n            (\n                &*self.strings[key.module],\n                &*self.strings[key.name],\n                // Should be safe since `T` is connecting the linker and store\n                unsafe { item.to_extern(store.0) },\n            )\n        })\n    }\n\n    /// Looks up a previously defined value in this [`Linker`], identified by\n    /// the names provided.\n    ///\n    /// Returns `None` if this name was not previously defined in this\n    /// [`Linker`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the `store` provided does not come from the\n    /// same [`Engine`] that this linker was created with.\n    pub fn get(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &str,\n        name: Option<&str>,\n    ) -> Option<Extern> {\n        let store = store.as_context_mut().0;\n        // Should be safe since `T` is connecting the linker and store\n        Some(unsafe { self._get(module, name)?.to_extern(store) })\n    }\n\n    fn _get(&self, module: &str, name: Option<&str>) -> Option<&Definition> {\n        let key = ImportKey {\n            module: *self.string2idx.get(module)?,\n            name: match name {\n                Some(name) => *self.string2idx.get(name)?,\n                None => usize::max_value(),\n            },\n        };\n        self.map.get(&key)\n    }\n\n    /// Looks up a value in this `Linker` which matches the `import` type\n    /// provided.\n    ///\n    /// Returns `None` if no match was found.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the `store` provided does not come from the\n    /// same [`Engine`] that this linker was created with.\n    pub fn get_by_import(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        import: &ImportType,\n    ) -> Option<Extern> {\n        let store = store.as_context_mut().0;\n        // Should be safe since `T` is connecting the linker and store\n        Some(unsafe { self._get_by_import(import)?.to_extern(store) })\n    }\n\n    fn _get_by_import(&self, import: &ImportType) -> Option<Definition> {\n        if let Some(item) = self._get(import.module(), import.name()) {\n            return Some(item.clone());\n        }\n\n        if import.name().is_some() {\n            return None;\n        }\n\n        if let ExternType::Instance(t) = import.ty() {\n            // This is a key location where the module linking proposal is\n            // implemented. This logic allows single-level imports of an instance to\n            // get satisfied by multiple definitions of items within this `Linker`.\n            //\n            // The instance being import is iterated over to load the names from\n            // this `Linker` (recursively calling `get`). If anything isn't defined\n            // we return `None` since the entire value isn't defined. Otherwise when\n            // all values are loaded it's assembled into an `Instance` and\n            // returned`.\n            //\n            // Note that this isn't exactly the speediest implementation in the\n            // world. Ideally we would pre-create the `Instance` instead of creating\n            // it each time a module is instantiated. For now though while the\n            // module linking proposal is under development this should hopefully\n            // suffice.\n            let mut map = indexmap::IndexMap::new();\n            for export in t.exports() {\n                let item = self._get(import.module(), Some(export.name()))?;\n                map.insert(export.name().to_string(), item.clone());\n            }\n            return Some(Definition::Instance(Arc::new(map)));\n        }\n\n        None\n    }\n\n    /// Returns the \"default export\" of a module.\n    ///\n    /// An export with an empty string is considered to be a \"default export\".\n    /// \"_start\" is also recognized for compatibility.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the default function found is not owned by `store`. This\n    /// function will also panic if the `store` provided does not come from the\n    /// same [`Engine`] that this linker was created with.\n    pub fn get_default(\n        &self,\n        mut store: impl AsContextMut<Data = T>,\n        module: &str,\n    ) -> Result<Func> {\n        if let Some(external) = self.get(&mut store, module, Some(\"\")) {\n            if let Extern::Func(func) = external {\n                return Ok(func.clone());\n            }\n            bail!(\"default export in '{}' is not a function\", module);\n        }\n\n        // For compatibility, also recognize \"_start\".\n        if let Some(external) = self.get(&mut store, module, Some(\"_start\")) {\n            if let Extern::Func(func) = external {\n                return Ok(func.clone());\n            }\n            bail!(\"`_start` in '{}' is not a function\", module);\n        }\n\n        // Otherwise return a no-op function.\n        Ok(Func::wrap(store, || {}))\n    }\n}\n\nimpl<T> Default for Linker<T> {\n    fn default() -> Linker<T> {\n        Linker::new(&Engine::default())\n    }\n}\n\nimpl Definition {\n    /// Note the unsafety here is due to calling `HostFunc::to_func`. The\n    /// requirement here is that the `T` that was originally used to create the\n    /// `HostFunc` matches the `T` on the store.\n    pub(crate) unsafe fn to_extern(&self, store: &mut StoreOpaque) -> Extern {\n        match self {\n            Definition::Extern(e) => e.clone(),\n            Definition::HostFunc(func) => func.to_func(store).into(),\n            Definition::Instance(i) => {\n                let items = Arc::new(\n                    i.iter()\n                        .map(|(name, item)| (name.clone(), item.to_extern(store)))\n                        .collect(),\n                );\n                Instance::from_wasmtime(InstanceData::Synthetic(items), store).into()\n            }\n        }\n    }\n\n    pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {\n        match self {\n            Definition::Extern(e) => e.comes_from_same_store(store),\n            Definition::HostFunc(_func) => true,\n            Definition::Instance(i) => i.values().all(|e| e.comes_from_same_store(store)),\n        }\n    }\n}\n\n/// Modules can be interpreted either as Commands or Reactors.\nenum ModuleKind {\n    /// The instance is a Command, meaning an instance is created for each\n    /// exported function and lives for the duration of the function call.\n    Command,\n\n    /// The instance is a Reactor, meaning one instance is created which\n    /// may live across multiple calls.\n    Reactor,\n}\n\nimpl ModuleKind {\n    /// Determine whether the given module is a Command or a Reactor.\n    fn categorize(module: &Module) -> Result<ModuleKind> {\n        let command_start = module.get_export(\"_start\");\n        let reactor_start = module.get_export(\"_initialize\");\n        match (command_start, reactor_start) {\n            (Some(command_start), None) => {\n                if let Some(_) = command_start.func() {\n                    Ok(ModuleKind::Command)\n                } else {\n                    bail!(\"`_start` must be a function\")\n                }\n            }\n            (None, Some(reactor_start)) => {\n                if let Some(_) = reactor_start.func() {\n                    Ok(ModuleKind::Reactor)\n                } else {\n                    bail!(\"`_initialize` must be a function\")\n                }\n            }\n            (None, None) => {\n                // Module declares neither of the recognized functions, so treat\n                // it as a reactor with no initialization function.\n                Ok(ModuleKind::Reactor)\n            }\n            (Some(_), Some(_)) => {\n                // Module declares itself to be both a Command and a Reactor.\n                bail!(\"Program cannot be both a Command and a Reactor\")\n            }\n        }\n    }\n}\n", "use anyhow::Result;\nuse std::cell::Cell;\nuse std::rc::Rc;\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse std::sync::Arc;\nuse wasmtime::*;\n\n#[test]\nfn link_undefined() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let linker = Linker::new(store.engine());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (func)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (global i32)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (memory 1)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (import \"\" \"\" (table 1 funcref)))\"#,\n    )?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    Ok(())\n}\n\n#[test]\nfn link_twice_bad() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::<()>::new(store.engine());\n\n    // functions\n    linker.func_wrap(\"f\", \"\", || {})?;\n    assert!(linker.func_wrap(\"f\", \"\", || {}).is_err());\n    assert!(linker\n        .func_wrap(\"f\", \"\", || -> Result<(), Trap> { loop {} })\n        .is_err());\n\n    // globals\n    let ty = GlobalType::new(ValType::I32, Mutability::Const);\n    let global = Global::new(&mut store, ty, Val::I32(0))?;\n    linker.define(\"g\", \"1\", global.clone())?;\n    assert!(linker.define(\"g\", \"1\", global.clone()).is_err());\n\n    let ty = GlobalType::new(ValType::I32, Mutability::Var);\n    let global = Global::new(&mut store, ty, Val::I32(0))?;\n    linker.define(\"g\", \"2\", global.clone())?;\n    assert!(linker.define(\"g\", \"2\", global.clone()).is_err());\n\n    let ty = GlobalType::new(ValType::I64, Mutability::Const);\n    let global = Global::new(&mut store, ty, Val::I64(0))?;\n    linker.define(\"g\", \"3\", global.clone())?;\n    assert!(linker.define(\"g\", \"3\", global.clone()).is_err());\n\n    // memories\n    let ty = MemoryType::new(1, None);\n    let memory = Memory::new(&mut store, ty)?;\n    linker.define(\"m\", \"\", memory.clone())?;\n    assert!(linker.define(\"m\", \"\", memory.clone()).is_err());\n    let ty = MemoryType::new(2, None);\n    let memory = Memory::new(&mut store, ty)?;\n    assert!(linker.define(\"m\", \"\", memory.clone()).is_err());\n\n    // tables\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None))?;\n    linker.define(\"t\", \"\", table.clone())?;\n    assert!(linker.define(\"t\", \"\", table.clone()).is_err());\n    let ty = TableType::new(ValType::FuncRef, 2, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None))?;\n    assert!(linker.define(\"t\", \"\", table.clone()).is_err());\n    Ok(())\n}\n\n#[test]\nfn function_interposition() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    linker.allow_shadowing(true);\n    let mut module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"green\") (result i32) (i32.const 7)))\"#,\n    )?;\n    for _ in 0..4 {\n        let instance = linker.instantiate(&mut store, &module)?;\n        linker.define(\n            \"red\",\n            \"green\",\n            instance.get_export(&mut store, \"green\").unwrap().clone(),\n        )?;\n        module = Module::new(\n            store.engine(),\n            r#\"(module\n                (import \"red\" \"green\" (func (result i32)))\n                (func (export \"green\") (result i32) (i32.mul (call 0) (i32.const 2)))\n            )\"#,\n        )?;\n    }\n    let instance = linker.instantiate(&mut store, &module)?;\n    let func = instance\n        .get_export(&mut store, \"green\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    let func = func.typed::<(), i32, _>(&store)?;\n    assert_eq!(func.call(&mut store, ())?, 112);\n    Ok(())\n}\n\n// Same as `function_interposition`, but the linker's name for the function\n// differs from the module's name.\n#[test]\nfn function_interposition_renamed() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    linker.allow_shadowing(true);\n    let mut module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"export\") (result i32) (i32.const 7)))\"#,\n    )?;\n    for _ in 0..4 {\n        let instance = linker.instantiate(&mut store, &module)?;\n        linker.define(\n            \"red\",\n            \"green\",\n            instance.get_export(&mut store, \"export\").unwrap().clone(),\n        )?;\n        module = Module::new(\n            store.engine(),\n            r#\"(module\n                (import \"red\" \"green\" (func (result i32)))\n                (func (export \"export\") (result i32) (i32.mul (call 0) (i32.const 2)))\n            )\"#,\n        )?;\n    }\n    let instance = linker.instantiate(&mut store, &module)?;\n    let func = instance.get_func(&mut store, \"export\").unwrap();\n    let func = func.typed::<(), i32, _>(&store)?;\n    assert_eq!(func.call(&mut store, ())?, 112);\n    Ok(())\n}\n\n// Similar to `function_interposition`, but use `Linker::instance` instead of\n// `Linker::define`.\n#[test]\nfn module_interposition() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    linker.allow_shadowing(true);\n    let mut module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"export\") (result i32) (i32.const 7)))\"#,\n    )?;\n    for _ in 0..4 {\n        let instance = linker.instantiate(&mut store, &module)?;\n        linker.instance(&mut store, \"instance\", instance)?;\n        module = Module::new(\n            store.engine(),\n            r#\"(module\n                (import \"instance\" \"export\" (func (result i32)))\n                (func (export \"export\") (result i32) (i32.mul (call 0) (i32.const 2)))\n            )\"#,\n        )?;\n    }\n    let instance = linker.instantiate(&mut store, &module)?;\n    let func = instance\n        .get_export(&mut store, \"export\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    let func = func.typed::<(), i32, _>(&store)?;\n    assert_eq!(func.call(&mut store, ())?, 112);\n    Ok(())\n}\n\n#[test]\nfn allow_unknown_exports() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"_start\")) (global (export \"g\") i32 (i32.const 0)))\"#,\n    )?;\n\n    assert!(linker.module(&mut store, \"module\", &module).is_err());\n\n    let mut linker = Linker::new(store.engine());\n    linker.allow_unknown_exports(true);\n    linker.module(&mut store, \"module\", &module)?;\n\n    Ok(())\n}\n\n#[test]\nfn no_leak() -> Result<()> {\n    struct DropMe(Rc<Cell<bool>>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.set(true);\n        }\n    }\n\n    let flag = Rc::new(Cell::new(false));\n    {\n        let mut store = Store::new(&Engine::default(), DropMe(flag.clone()));\n        let mut linker = Linker::new(store.engine());\n        let module = Module::new(\n            store.engine(),\n            r#\"\n                (module\n                    (func (export \"_start\"))\n                )\n            \"#,\n        )?;\n        linker.module(&mut store, \"a\", &module)?;\n    }\n    assert!(flag.get(), \"store was leaked\");\n    Ok(())\n}\n\n#[test]\nfn no_leak_with_imports() -> Result<()> {\n    struct DropMe(Arc<AtomicUsize>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n\n    let flag = Arc::new(AtomicUsize::new(0));\n    {\n        let mut store = Store::new(&Engine::default(), DropMe(flag.clone()));\n        let mut linker = Linker::new(store.engine());\n        let drop_me = DropMe(flag.clone());\n        linker.func_wrap(\"\", \"\", move || drop(&drop_me))?;\n        let module = Module::new(\n            store.engine(),\n            r#\"\n                (module\n                    (import \"\" \"\" (func))\n                    (func (export \"_start\"))\n                )\n            \"#,\n        )?;\n        linker.module(&mut store, \"a\", &module)?;\n    }\n    assert!(flag.load(SeqCst) == 2, \"something was leaked\");\n    Ok(())\n}\n\n#[test]\nfn get_host_function() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (import \"mod\" \"f1\" (func)))\"#)?;\n\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\"mod\", \"f1\", || {})?;\n    let mut store = Store::new(&engine, ());\n    assert!(linker\n        .get_by_import(&mut store, &module.imports().nth(0).unwrap())\n        .is_some());\n\n    Ok(())\n}\n\n#[test]\nfn funcs_live_on_to_fight_another_day() -> Result<()> {\n    struct DropMe(Arc<AtomicUsize>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n\n    let flag = Arc::new(AtomicUsize::new(0));\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    let drop_me = DropMe(flag.clone());\n    linker.func_wrap(\"\", \"\", move || drop(&drop_me))?;\n    assert_eq!(flag.load(SeqCst), 0);\n\n    let get_and_call = || -> Result<()> {\n        assert_eq!(flag.load(SeqCst), 0);\n        let mut store = Store::new(&engine, ());\n        let func = linker.get(&mut store, \"\", Some(\"\")).unwrap();\n        func.into_func().unwrap().call(&mut store, &[])?;\n        assert_eq!(flag.load(SeqCst), 0);\n        Ok(())\n    };\n\n    get_and_call()?;\n    get_and_call()?;\n    drop(linker);\n    assert_eq!(flag.load(SeqCst), 1);\n    Ok(())\n}\n\n#[test]\nfn alias_one() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    assert!(linker.alias(\"a\", \"b\", \"c\", \"d\").is_err());\n    linker.func_wrap(\"a\", \"b\", || {})?;\n    assert!(linker.alias(\"a\", \"b\", \"c\", \"d\").is_ok());\n    assert!(linker.get(&mut store, \"a\", Some(\"b\")).is_some());\n    assert!(linker.get(&mut store, \"c\", Some(\"d\")).is_some());\n    Ok(())\n}\n\n#[test]\nfn instance_pre() -> Result<()> {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\"\", \"\", || {})?;\n\n    let module = Module::new(&engine, r#\"(module (import \"\" \"\" (func)))\"#)?;\n    let instance_pre = linker.instantiate_pre(&mut Store::new(&engine, ()), &module)?;\n    instance_pre.instantiate(&mut Store::new(&engine, ()))?;\n    instance_pre.instantiate(&mut Store::new(&engine, ()))?;\n\n    let mut store = Store::new(&engine, ());\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Const),\n        1.into(),\n    )?;\n    linker.define(\"\", \"g\", global)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module\n            (import \"\" \"\" (func))\n            (import \"\" \"g\" (global i32))\n        )\"#,\n    )?;\n    let instance_pre = linker.instantiate_pre(&mut store, &module)?;\n    instance_pre.instantiate(&mut store)?;\n    instance_pre.instantiate(&mut store)?;\n    Ok(())\n}\n"], "filenames": ["crates/wasmtime/src/func.rs", "crates/wasmtime/src/instance.rs", "crates/wasmtime/src/linker.rs", "tests/all/linker.rs"], "buggy_code_start_loc": [1984, 956, 71, 259], "buggy_code_end_loc": [1984, 957, 1130, 260], "fixing_code_start_loc": [1985, 956, 72, 259], "fixing_code_end_loc": [1993, 959, 1180, 260], "type": "CWE-843", "message": "Wasmtime is an open source runtime for WebAssembly & WASI. Wasmtime before version 0.30.0 is affected by a type confusion vulnerability. As a Rust library the `wasmtime` crate clearly marks which functions are safe and which are `unsafe`, guaranteeing that if consumers never use `unsafe` then it should not be possible to have memory unsafety issues in their embeddings of Wasmtime. An issue was discovered in the safe API of `Linker::func_*` APIs. These APIs were previously not sound when one `Engine` was used to create the `Linker` and then a different `Engine` was used to create a `Store` and then the `Linker` was used to instantiate a module into that `Store`. Cross-`Engine` usage of functions is not supported in Wasmtime and this can result in type confusion of function pointers, resulting in being able to safely call a function with the wrong type. Triggering this bug requires using at least two `Engine` values in an embedding and then additionally using two different values with a `Linker` (one at the creation time of the `Linker` and another when instantiating a module with the `Linker`). It's expected that usage of more-than-one `Engine` in an embedding is relatively rare since an `Engine` is intended to be a globally shared resource, so the expectation is that the impact of this issue is relatively small. The fix implemented is to change this behavior to `panic!()` in Rust instead of silently allowing it. Using different `Engine` instances with a `Linker` is a programmer bug that `wasmtime` catches at runtime. This bug has been patched and users should upgrade to Wasmtime version 0.30.0. If you cannot upgrade Wasmtime and are using more than one `Engine` in your embedding it's recommended to instead use only one `Engine` for the entire program if possible. An `Engine` is designed to be a globally shared resource that is suitable to have only one for the lifetime of an entire process. If using multiple `Engine`s is required then code should be audited to ensure that `Linker` is only used with one `Engine`.", "other": {"cve": {"id": "CVE-2021-39219", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-17T20:15:07.763", "lastModified": "2021-12-21T14:09:30.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wasmtime is an open source runtime for WebAssembly & WASI. Wasmtime before version 0.30.0 is affected by a type confusion vulnerability. As a Rust library the `wasmtime` crate clearly marks which functions are safe and which are `unsafe`, guaranteeing that if consumers never use `unsafe` then it should not be possible to have memory unsafety issues in their embeddings of Wasmtime. An issue was discovered in the safe API of `Linker::func_*` APIs. These APIs were previously not sound when one `Engine` was used to create the `Linker` and then a different `Engine` was used to create a `Store` and then the `Linker` was used to instantiate a module into that `Store`. Cross-`Engine` usage of functions is not supported in Wasmtime and this can result in type confusion of function pointers, resulting in being able to safely call a function with the wrong type. Triggering this bug requires using at least two `Engine` values in an embedding and then additionally using two different values with a `Linker` (one at the creation time of the `Linker` and another when instantiating a module with the `Linker`). It's expected that usage of more-than-one `Engine` in an embedding is relatively rare since an `Engine` is intended to be a globally shared resource, so the expectation is that the impact of this issue is relatively small. The fix implemented is to change this behavior to `panic!()` in Rust instead of silently allowing it. Using different `Engine` instances with a `Linker` is a programmer bug that `wasmtime` catches at runtime. This bug has been patched and users should upgrade to Wasmtime version 0.30.0. If you cannot upgrade Wasmtime and are using more than one `Engine` in your embedding it's recommended to instead use only one `Engine` for the entire program if possible. An `Engine` is designed to be a globally shared resource that is suitable to have only one for the lifetime of an entire process. If using multiple `Engine`s is required then code should be audited to ensure that `Linker` is only used with one `Engine`."}, {"lang": "es", "value": "Wasmtime es un tiempo de ejecuci\u00f3n de c\u00f3digo abierto para WebAssembly y WASI. Wasmtime versiones anteriores a 0.30.0, est\u00e1 afectado por una vulnerabilidad de confusi\u00f3n de tipo. Como librer\u00eda de Rust, la caja \"wasmtime\" marca claramente qu\u00e9 funciones son seguras y cu\u00e1les son \"unsafe\", garantizando que si los consumidores nunca usan \"unsafe\" no deber\u00eda ser posible tener problemas de inseguridad de memoria en sus inserciones de Wasmtime. Se ha detectado un problema en la API segura de las APIs \"Linker::func_*\". Estas APIs no eran seguras cuando un \"Engine\" era usado para crear el \"Linker\" y luego otro \"Engine\" era usado para crear un \"Store\" y luego el \"Linker\" era usado para instanciar un m\u00f3dulo en ese \"Store\". Un uso cruzado de funciones de \"Engine\" no est\u00e1 soportado en Wasmtime y esto puede resultar en una confusi\u00f3n de tipo de los punteros de las funciones, resultando en poder llamar de forma segura a una funci\u00f3n con el tipo equivocado. Desencadenar este bug requiere el uso de al menos dos valores de \"Engine\" en una inserci\u00f3n y, adem\u00e1s, el uso de dos valores diferentes con un \"Linker\" (uno en el momento de la creaci\u00f3n del \"Linker\" y otro cuando se instancie un m\u00f3dulo con el \"Linker\"). Se espera que el uso de m\u00e1s de un \"Engine\" en una inserci\u00f3n sea relativamente raro ya que un \"Engine\" est\u00e1 destinado a ser un recurso compartido globalmente, por lo que se espera que el impacto de este problema sea relativamente peque\u00f1o. La correcci\u00f3n implementada es cambiar este comportamiento a \"panic!()\" en Rust en lugar de permitirlo silenciosamente. El uso de diferentes instancias de \"Engine\" con un \"Linker\" es un error de programaci\u00f3n que \"wasmtime\" detecta en tiempo de ejecuci\u00f3n. Este bug ha sido parcheado y los usuarios deber\u00edan actualizar a la versi\u00f3n 0.30.0 de Wasmtime. Si no puedes actualizar Wasmtime y est\u00e1s usando m\u00e1s de un \"Engine\" en tu inserci\u00f3n, se recomienda usar s\u00f3lo un \"Engine\" para todo el programa si es posible. Un \"Engine\" est\u00e1 dise\u00f1ado para ser un recurso globalmente compartido que es adecuado para tener s\u00f3lo uno durante el tiempo de vida de un proceso entero. Si se requiere el uso de m\u00faltiples \"Engines\" entonces el c\u00f3digo debe ser auditado para asegurar que el \"Linker\" s\u00f3lo se usa con un \"Engine\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.30.0", "matchCriteriaId": "929B6668-A9D9-473E-A19C-EBBEC27393A0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://crates.io/crates/wasmtime", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/bytecodealliance/wasmtime/commit/b39f087414f27ae40c44449ed5d1154e03449bff", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bytecodealliance/wasmtime/commit/b39f087414f27ae40c44449ed5d1154e03449bff"}}