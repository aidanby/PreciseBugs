{"buggy_code": ["# Copyright (C) Dominik Picheta. All rights reserved.\n# BSD License. Look at license.txt for more info.\n\nimport parseutils, os, osproc, strutils, tables, pegs, uri\nimport packageinfo, packageparser, version, tools, common, options, cli\nfrom algorithm import SortOrder, sorted\nfrom sequtils import toSeq, filterIt, map\n\ntype\n  DownloadMethod* {.pure.} = enum\n    git = \"git\", hg = \"hg\"\n\nproc getSpecificDir(meth: DownloadMethod): string {.used.} =\n  case meth\n  of DownloadMethod.git:\n    \".git\"\n  of DownloadMethod.hg:\n    \".hg\"\n\nproc doCheckout(meth: DownloadMethod, downloadDir, branch: string) =\n  case meth\n  of DownloadMethod.git:\n    cd downloadDir:\n      # Force is used here because local changes may appear straight after a\n      # clone has happened. Like in the case of git on Windows where it\n      # messes up the damn line endings.\n      doCmd(\"git checkout --force \" & branch)\n      doCmd(\"git submodule update --recursive --depth 1\")\n  of DownloadMethod.hg:\n    cd downloadDir:\n      doCmd(\"hg checkout \" & branch)\n\nproc doPull(meth: DownloadMethod, downloadDir: string) {.used.} =\n  case meth\n  of DownloadMethod.git:\n    doCheckout(meth, downloadDir, \"\")\n    cd downloadDir:\n      doCmd(\"git pull\")\n      if fileExists(\".gitmodules\"):\n        doCmd(\"git submodule update --recursive --depth 1\")\n  of DownloadMethod.hg:\n    doCheckout(meth, downloadDir, \"default\")\n    cd downloadDir:\n      doCmd(\"hg pull\")\n\nproc doClone(meth: DownloadMethod, url, downloadDir: string, branch = \"\",\n             onlyTip = true) =\n  case meth\n  of DownloadMethod.git:\n    let\n      depthArg = if onlyTip: \"--depth 1 \" else: \"\"\n      branchArg = if branch == \"\": \"\" else: \"-b \" & branch & \" \"\n    doCmd(\"git clone --recursive --shallow-submodules \" & depthArg & branchArg &\n          url & \" \" & downloadDir)\n  of DownloadMethod.hg:\n    let\n      tipArg = if onlyTip: \"-r tip \" else: \"\"\n      branchArg = if branch == \"\": \"\" else: \"-b \" & branch & \" \"\n    doCmd(\"hg clone \" & tipArg & branchArg & url & \" \" & downloadDir)\n\nproc getTagsList(dir: string, meth: DownloadMethod): seq[string] =\n  cd dir:\n    var output = execProcess(\"git tag\")\n    case meth\n    of DownloadMethod.git:\n      output = execProcess(\"git tag\")\n    of DownloadMethod.hg:\n      output = execProcess(\"hg tags\")\n  if output.len > 0:\n    case meth\n    of DownloadMethod.git:\n      result = @[]\n      for i in output.splitLines():\n        if i == \"\": continue\n        result.add(i)\n    of DownloadMethod.hg:\n      result = @[]\n      for i in output.splitLines():\n        if i == \"\": continue\n        var tag = \"\"\n        discard parseUntil(i, tag, ' ')\n        if tag != \"tip\":\n          result.add(tag)\n  else:\n    result = @[]\n\nproc getTagsListRemote*(url: string, meth: DownloadMethod): seq[string] =\n  result = @[]\n  case meth\n  of DownloadMethod.git:\n    var (output, exitCode) = doCmdEx(\"git ls-remote --tags \" & url)\n    if exitCode != QuitSuccess:\n      raise newException(OSError, \"Unable to query remote tags for \" & url &\n          \". Git returned: \" & output)\n    for i in output.splitLines():\n      let refStart = i.find(\"refs/tags/\")\n      # git outputs warnings, empty lines, etc\n      if refStart == -1: continue\n      let start = refStart+\"refs/tags/\".len\n      let tag = i[start .. i.len-1]\n      if not tag.endswith(\"^{}\"): result.add(tag)\n\n  of DownloadMethod.hg:\n    # http://stackoverflow.com/questions/2039150/show-tags-for-remote-hg-repository\n    raise newException(ValueError, \"Hg doesn't support remote tag querying.\")\n\nproc getVersionList*(tags: seq[string]): OrderedTable[Version, string] =\n  ## Return an ordered table of Version -> git tag label.  Ordering is\n  ## in descending order with the most recent version first.\n  let taggedVers: seq[tuple[ver: Version, tag: string]] =\n    tags\n      .filterIt(it != \"\")\n      .map(proc(s: string): tuple[ver: Version, tag: string] =\n        # skip any chars before the version\n        let i = skipUntil(s, Digits)\n        # TODO: Better checking, tags can have any\n        # names. Add warnings and such.\n        result = (newVersion(s[i .. s.len-1]), s))\n      .sorted(proc(a, b: (Version, string)): int = cmp(a[0], b[0]),\n              SortOrder.Descending)\n  result = toOrderedTable[Version, string](taggedVers)\n\nproc getDownloadMethod*(meth: string): DownloadMethod =\n  case meth\n  of \"git\": return DownloadMethod.git\n  of \"hg\", \"mercurial\": return DownloadMethod.hg\n  else:\n    raise newException(NimbleError, \"Invalid download method: \" & meth)\n\nproc getHeadName*(meth: DownloadMethod): Version =\n  ## Returns the name of the download method specific head. i.e. for git\n  ## it's ``head`` for hg it's ``tip``.\n  case meth\n  of DownloadMethod.git: newVersion(\"#head\")\n  of DownloadMethod.hg: newVersion(\"#tip\")\n\nproc checkUrlType*(url: string): DownloadMethod =\n  ## Determines the download method based on the URL.\n  if doCmdEx(\"git ls-remote \" & url).exitCode == QuitSuccess:\n    return DownloadMethod.git\n  elif doCmdEx(\"hg identify \" & url).exitCode == QuitSuccess:\n    return DownloadMethod.hg\n  else:\n    raise newException(NimbleError, \"Unable to identify url: \" & url)\n\nproc getUrlData*(url: string): (string, Table[string, string]) =\n  var uri = parseUri(url)\n  # TODO: use uri.parseQuery once it lands... this code is quick and dirty.\n  var subdir = \"\"\n  if uri.query.startsWith(\"subdir=\"):\n    subdir = uri.query[7 .. ^1]\n\n  uri.query = \"\"\n  return ($uri, {\"subdir\": subdir}.toTable())\n\nproc isURL*(name: string): bool =\n  name.startsWith(peg\" @'://' \")\n\nproc doDownload(url: string, downloadDir: string, verRange: VersionRange,\n                 downMethod: DownloadMethod,\n                 options: Options): Version =\n  ## Downloads the repository specified by ``url`` using the specified download\n  ## method.\n  ##\n  ## Returns the version of the repository which has been downloaded.\n  template getLatestByTag(meth: untyped) {.dirty.} =\n    # Find latest version that fits our ``verRange``.\n    var latest = findLatest(verRange, versions)\n    ## Note: HEAD is not used when verRange.kind is verAny. This is\n    ## intended behaviour, the latest tagged version will be used in this case.\n\n    # If no tagged versions satisfy our range latest.tag will be \"\".\n    # We still clone in that scenario because we want to try HEAD in that case.\n    # https://github.com/nim-lang/nimble/issues/22\n    meth\n    if $latest.ver != \"\":\n      result = latest.ver\n\n  removeDir(downloadDir)\n  if verRange.kind == verSpecial:\n    # We want a specific commit/branch/tag here.\n    if verRange.spe == getHeadName(downMethod):\n       # Grab HEAD.\n      doClone(downMethod, url, downloadDir, onlyTip = not options.forceFullClone)\n    else:\n      # Grab the full repo.\n      doClone(downMethod, url, downloadDir, onlyTip = false)\n      # Then perform a checkout operation to get the specified branch/commit.\n      # `spe` starts with '#', trim it.\n      doAssert(($verRange.spe)[0] == '#')\n      doCheckout(downMethod, downloadDir, substr($verRange.spe, 1))\n    result = verRange.spe\n  else:\n    case downMethod\n    of DownloadMethod.git:\n      # For Git we have to query the repo remotely for its tags. This is\n      # necessary as cloning with a --depth of 1 removes all tag info.\n      result = getHeadName(downMethod)\n      let versions = getTagsListRemote(url, downMethod).getVersionList()\n      if versions.len > 0:\n        getLatestByTag:\n          display(\"Cloning\", \"latest tagged version: \" & latest.tag,\n                  priority = MediumPriority)\n          doClone(downMethod, url, downloadDir, latest.tag,\n                  onlyTip = not options.forceFullClone)\n      else:\n        # If no commits have been tagged on the repo we just clone HEAD.\n        doClone(downMethod, url, downloadDir) # Grab HEAD.\n    of DownloadMethod.hg:\n      doClone(downMethod, url, downloadDir, onlyTip = not options.forceFullClone)\n      result = getHeadName(downMethod)\n      let versions = getTagsList(downloadDir, downMethod).getVersionList()\n\n      if versions.len > 0:\n        getLatestByTag:\n          display(\"Switching\", \"to latest tagged version: \" & latest.tag,\n                  priority = MediumPriority)\n          doCheckout(downMethod, downloadDir, latest.tag)\n\nproc downloadPkg*(url: string, verRange: VersionRange,\n                 downMethod: DownloadMethod,\n                 subdir: string,\n                 options: Options,\n                 downloadPath = \"\"): (string, Version) =\n  ## Downloads the repository as specified by ``url`` and ``verRange`` using\n  ## the download method specified.\n  ##\n  ## If `downloadPath` isn't specified a location in /tmp/ will be used.\n  ##\n  ## Returns the directory where it was downloaded (subdir is appended) and\n  ## the concrete version  which was downloaded.\n  let downloadDir =\n    if downloadPath == \"\":\n      (getNimbleTempDir() / getDownloadDirName(url, verRange))\n    else:\n      downloadPath\n\n  createDir(downloadDir)\n  var modUrl =\n    if url.startsWith(\"git://\") and options.config.cloneUsingHttps:\n      \"https://\" & url[6 .. ^1]\n    else: url\n\n  # Fixes issue #204\n  # github + https + trailing url slash causes a\n  # checkout/ls-remote to fail with Repository not found\n  if modUrl.contains(\"github.com\") and modUrl.endswith(\"/\"):\n    modUrl = modUrl[0 .. ^2]\n\n  if subdir.len > 0:\n    display(\"Downloading\", \"$1 using $2 (subdir is '$3')\" %\n                           [modUrl, $downMethod, subdir],\n            priority = HighPriority)\n  else:\n    display(\"Downloading\", \"$1 using $2\" % [modUrl, $downMethod],\n            priority = HighPriority)\n  result = (\n    downloadDir / subdir,\n    doDownload(modUrl, downloadDir, verRange, downMethod, options)\n  )\n\n  if verRange.kind != verSpecial:\n    ## Makes sure that the downloaded package's version satisfies the requested\n    ## version range.\n    let pkginfo = getPkgInfo(result[0], options)\n    if pkginfo.version.newVersion notin verRange:\n      raise newException(NimbleError,\n        \"Downloaded package's version does not satisfy requested version \" &\n        \"range: wanted $1 got $2.\" %\n        [$verRange, $pkginfo.version])\n\nproc echoPackageVersions*(pkg: Package) =\n  let downMethod = pkg.downloadMethod.getDownloadMethod()\n  case downMethod\n  of DownloadMethod.git:\n    try:\n      let versions = getTagsListRemote(pkg.url, downMethod).getVersionList()\n      if versions.len > 0:\n        let sortedVersions = toSeq(values(versions))\n        echo(\"  versions:    \" & join(sortedVersions, \", \"))\n      else:\n        echo(\"  versions:    (No versions tagged in the remote repository)\")\n    except OSError:\n      echo(getCurrentExceptionMsg())\n  of DownloadMethod.hg:\n    echo(\"  versions:    (Remote tag retrieval not supported by \" &\n        pkg.downloadMethod & \")\")\n\nwhen isMainModule:\n  # Test version sorting\n  block:\n    let data = @[\"v9.0.0-taeyeon\", \"v9.0.1-jessica\", \"v9.2.0-sunny\",\n                 \"v9.4.0-tiffany\", \"v9.4.2-hyoyeon\"]\n    let expected = toOrderedTable[Version, string]({\n      newVersion(\"9.4.2-hyoyeon\"): \"v9.4.2-hyoyeon\",\n      newVersion(\"9.4.0-tiffany\"): \"v9.4.0-tiffany\",\n      newVersion(\"9.2.0-sunny\"): \"v9.2.0-sunny\",\n      newVersion(\"9.0.1-jessica\"): \"v9.0.1-jessica\",\n      newVersion(\"9.0.0-taeyeon\"): \"v9.0.0-taeyeon\"\n    })\n    doAssert expected == getVersionList(data)\n\n\n  block:\n    let data2 = @[\"v0.1.0\", \"v0.1.1\", \"v0.2.0\",\n                 \"0.4.0\", \"v0.4.2\"]\n    let expected2 = toOrderedTable[Version, string]({\n      newVersion(\"0.4.2\"): \"v0.4.2\",\n      newVersion(\"0.4.0\"): \"0.4.0\",\n      newVersion(\"0.2.0\"): \"v0.2.0\",\n      newVersion(\"0.1.1\"): \"v0.1.1\",\n      newVersion(\"0.1.0\"): \"v0.1.0\",\n    })\n    doAssert expected2 == getVersionList(data2)\n\n  echo(\"Everything works!\")\n"], "fixing_code": ["# Copyright (C) Dominik Picheta. All rights reserved.\n# BSD License. Look at license.txt for more info.\n\nimport parseutils, os, osproc, strutils, tables, pegs, uri\nimport packageinfo, packageparser, version, tools, common, options, cli\nfrom algorithm import SortOrder, sorted\nfrom sequtils import toSeq, filterIt, map\n\ntype\n  DownloadMethod* {.pure.} = enum\n    git = \"git\", hg = \"hg\"\n\nproc getSpecificDir(meth: DownloadMethod): string {.used.} =\n  case meth\n  of DownloadMethod.git:\n    \".git\"\n  of DownloadMethod.hg:\n    \".hg\"\n\nproc doCheckout(meth: DownloadMethod, downloadDir, branch: string) =\n  case meth\n  of DownloadMethod.git:\n    cd downloadDir:\n      # Force is used here because local changes may appear straight after a\n      # clone has happened. Like in the case of git on Windows where it\n      # messes up the damn line endings.\n      doCmd(\"git checkout --force \" & branch)\n      doCmd(\"git submodule update --recursive --depth 1\")\n  of DownloadMethod.hg:\n    cd downloadDir:\n      doCmd(\"hg checkout \" & branch)\n\nproc doPull(meth: DownloadMethod, downloadDir: string) {.used.} =\n  case meth\n  of DownloadMethod.git:\n    doCheckout(meth, downloadDir, \"\")\n    cd downloadDir:\n      doCmd(\"git pull\")\n      if fileExists(\".gitmodules\"):\n        doCmd(\"git submodule update --recursive --depth 1\")\n  of DownloadMethod.hg:\n    doCheckout(meth, downloadDir, \"default\")\n    cd downloadDir:\n      doCmd(\"hg pull\")\n\nproc doClone(meth: DownloadMethod, url, downloadDir: string, branch = \"\",\n             onlyTip = true) =\n  case meth\n  of DownloadMethod.git:\n    let\n      depthArg = if onlyTip: \"--depth 1 \" else: \"\"\n      branchArg = if branch == \"\": \"\" else: \"-b \" & branch & \" \"\n    doCmd(\"git clone --recursive --shallow-submodules \" & depthArg & branchArg &\n          url & \" \" & downloadDir)\n  of DownloadMethod.hg:\n    let\n      tipArg = if onlyTip: \"-r tip \" else: \"\"\n      branchArg = if branch == \"\": \"\" else: \"-b \" & branch & \" \"\n    doCmd(\"hg clone \" & tipArg & branchArg & url & \" \" & downloadDir)\n\nproc getTagsList(dir: string, meth: DownloadMethod): seq[string] =\n  cd dir:\n    var output = execProcess(\"git tag\")\n    case meth\n    of DownloadMethod.git:\n      output = execProcess(\"git tag\")\n    of DownloadMethod.hg:\n      output = execProcess(\"hg tags\")\n  if output.len > 0:\n    case meth\n    of DownloadMethod.git:\n      result = @[]\n      for i in output.splitLines():\n        if i == \"\": continue\n        result.add(i)\n    of DownloadMethod.hg:\n      result = @[]\n      for i in output.splitLines():\n        if i == \"\": continue\n        var tag = \"\"\n        discard parseUntil(i, tag, ' ')\n        if tag != \"tip\":\n          result.add(tag)\n  else:\n    result = @[]\n\nproc getTagsListRemote*(url: string, meth: DownloadMethod): seq[string] =\n  result = @[]\n  case meth\n  of DownloadMethod.git:\n    var (output, exitCode) = doCmdEx(\"git ls-remote --tags \" & url.quoteShell())\n    if exitCode != QuitSuccess:\n      raise newException(OSError, \"Unable to query remote tags for \" & url &\n          \". Git returned: \" & output)\n    for i in output.splitLines():\n      let refStart = i.find(\"refs/tags/\")\n      # git outputs warnings, empty lines, etc\n      if refStart == -1: continue\n      let start = refStart+\"refs/tags/\".len\n      let tag = i[start .. i.len-1]\n      if not tag.endswith(\"^{}\"): result.add(tag)\n\n  of DownloadMethod.hg:\n    # http://stackoverflow.com/questions/2039150/show-tags-for-remote-hg-repository\n    raise newException(ValueError, \"Hg doesn't support remote tag querying.\")\n\nproc getVersionList*(tags: seq[string]): OrderedTable[Version, string] =\n  ## Return an ordered table of Version -> git tag label.  Ordering is\n  ## in descending order with the most recent version first.\n  let taggedVers: seq[tuple[ver: Version, tag: string]] =\n    tags\n      .filterIt(it != \"\")\n      .map(proc(s: string): tuple[ver: Version, tag: string] =\n        # skip any chars before the version\n        let i = skipUntil(s, Digits)\n        # TODO: Better checking, tags can have any\n        # names. Add warnings and such.\n        result = (newVersion(s[i .. s.len-1]), s))\n      .sorted(proc(a, b: (Version, string)): int = cmp(a[0], b[0]),\n              SortOrder.Descending)\n  result = toOrderedTable[Version, string](taggedVers)\n\nproc getDownloadMethod*(meth: string): DownloadMethod =\n  case meth\n  of \"git\": return DownloadMethod.git\n  of \"hg\", \"mercurial\": return DownloadMethod.hg\n  else:\n    raise newException(NimbleError, \"Invalid download method: \" & meth)\n\nproc getHeadName*(meth: DownloadMethod): Version =\n  ## Returns the name of the download method specific head. i.e. for git\n  ## it's ``head`` for hg it's ``tip``.\n  case meth\n  of DownloadMethod.git: newVersion(\"#head\")\n  of DownloadMethod.hg: newVersion(\"#tip\")\n\nproc checkUrlType*(url: string): DownloadMethod =\n  ## Determines the download method based on the URL.\n  if doCmdEx(\"git ls-remote \" & url.quoteShell()).exitCode == QuitSuccess:\n    return DownloadMethod.git\n  elif doCmdEx(\"hg identify \" & url.quoteShell()).exitCode == QuitSuccess:\n    return DownloadMethod.hg\n  else:\n    raise newException(NimbleError, \"Unable to identify url: \" & url)\n\nproc getUrlData*(url: string): (string, Table[string, string]) =\n  var uri = parseUri(url)\n  # TODO: use uri.parseQuery once it lands... this code is quick and dirty.\n  var subdir = \"\"\n  if uri.query.startsWith(\"subdir=\"):\n    subdir = uri.query[7 .. ^1]\n\n  uri.query = \"\"\n  return ($uri, {\"subdir\": subdir}.toTable())\n\nproc isURL*(name: string): bool =\n  name.startsWith(peg\" @'://' \")\n\nproc doDownload(url: string, downloadDir: string, verRange: VersionRange,\n                 downMethod: DownloadMethod,\n                 options: Options): Version =\n  ## Downloads the repository specified by ``url`` using the specified download\n  ## method.\n  ##\n  ## Returns the version of the repository which has been downloaded.\n  template getLatestByTag(meth: untyped) {.dirty.} =\n    # Find latest version that fits our ``verRange``.\n    var latest = findLatest(verRange, versions)\n    ## Note: HEAD is not used when verRange.kind is verAny. This is\n    ## intended behaviour, the latest tagged version will be used in this case.\n\n    # If no tagged versions satisfy our range latest.tag will be \"\".\n    # We still clone in that scenario because we want to try HEAD in that case.\n    # https://github.com/nim-lang/nimble/issues/22\n    meth\n    if $latest.ver != \"\":\n      result = latest.ver\n\n  removeDir(downloadDir)\n  if verRange.kind == verSpecial:\n    # We want a specific commit/branch/tag here.\n    if verRange.spe == getHeadName(downMethod):\n       # Grab HEAD.\n      doClone(downMethod, url, downloadDir, onlyTip = not options.forceFullClone)\n    else:\n      # Grab the full repo.\n      doClone(downMethod, url, downloadDir, onlyTip = false)\n      # Then perform a checkout operation to get the specified branch/commit.\n      # `spe` starts with '#', trim it.\n      doAssert(($verRange.spe)[0] == '#')\n      doCheckout(downMethod, downloadDir, substr($verRange.spe, 1))\n    result = verRange.spe\n  else:\n    case downMethod\n    of DownloadMethod.git:\n      # For Git we have to query the repo remotely for its tags. This is\n      # necessary as cloning with a --depth of 1 removes all tag info.\n      result = getHeadName(downMethod)\n      let versions = getTagsListRemote(url, downMethod).getVersionList()\n      if versions.len > 0:\n        getLatestByTag:\n          display(\"Cloning\", \"latest tagged version: \" & latest.tag,\n                  priority = MediumPriority)\n          doClone(downMethod, url, downloadDir, latest.tag,\n                  onlyTip = not options.forceFullClone)\n      else:\n        # If no commits have been tagged on the repo we just clone HEAD.\n        doClone(downMethod, url, downloadDir) # Grab HEAD.\n    of DownloadMethod.hg:\n      doClone(downMethod, url, downloadDir, onlyTip = not options.forceFullClone)\n      result = getHeadName(downMethod)\n      let versions = getTagsList(downloadDir, downMethod).getVersionList()\n\n      if versions.len > 0:\n        getLatestByTag:\n          display(\"Switching\", \"to latest tagged version: \" & latest.tag,\n                  priority = MediumPriority)\n          doCheckout(downMethod, downloadDir, latest.tag)\n\nproc downloadPkg*(url: string, verRange: VersionRange,\n                 downMethod: DownloadMethod,\n                 subdir: string,\n                 options: Options,\n                 downloadPath = \"\"): (string, Version) =\n  ## Downloads the repository as specified by ``url`` and ``verRange`` using\n  ## the download method specified.\n  ##\n  ## If `downloadPath` isn't specified a location in /tmp/ will be used.\n  ##\n  ## Returns the directory where it was downloaded (subdir is appended) and\n  ## the concrete version  which was downloaded.\n  let downloadDir =\n    if downloadPath == \"\":\n      (getNimbleTempDir() / getDownloadDirName(url, verRange))\n    else:\n      downloadPath\n\n  createDir(downloadDir)\n  var modUrl =\n    if url.startsWith(\"git://\") and options.config.cloneUsingHttps:\n      \"https://\" & url[6 .. ^1]\n    else: url\n\n  # Fixes issue #204\n  # github + https + trailing url slash causes a\n  # checkout/ls-remote to fail with Repository not found\n  if modUrl.contains(\"github.com\") and modUrl.endswith(\"/\"):\n    modUrl = modUrl[0 .. ^2]\n\n  if subdir.len > 0:\n    display(\"Downloading\", \"$1 using $2 (subdir is '$3')\" %\n                           [modUrl, $downMethod, subdir],\n            priority = HighPriority)\n  else:\n    display(\"Downloading\", \"$1 using $2\" % [modUrl, $downMethod],\n            priority = HighPriority)\n  result = (\n    downloadDir / subdir,\n    doDownload(modUrl, downloadDir, verRange, downMethod, options)\n  )\n\n  if verRange.kind != verSpecial:\n    ## Makes sure that the downloaded package's version satisfies the requested\n    ## version range.\n    let pkginfo = getPkgInfo(result[0], options)\n    if pkginfo.version.newVersion notin verRange:\n      raise newException(NimbleError,\n        \"Downloaded package's version does not satisfy requested version \" &\n        \"range: wanted $1 got $2.\" %\n        [$verRange, $pkginfo.version])\n\nproc echoPackageVersions*(pkg: Package) =\n  let downMethod = pkg.downloadMethod.getDownloadMethod()\n  case downMethod\n  of DownloadMethod.git:\n    try:\n      let versions = getTagsListRemote(pkg.url, downMethod).getVersionList()\n      if versions.len > 0:\n        let sortedVersions = toSeq(values(versions))\n        echo(\"  versions:    \" & join(sortedVersions, \", \"))\n      else:\n        echo(\"  versions:    (No versions tagged in the remote repository)\")\n    except OSError:\n      echo(getCurrentExceptionMsg())\n  of DownloadMethod.hg:\n    echo(\"  versions:    (Remote tag retrieval not supported by \" &\n        pkg.downloadMethod & \")\")\n\nwhen isMainModule:\n  # Test version sorting\n  block:\n    let data = @[\"v9.0.0-taeyeon\", \"v9.0.1-jessica\", \"v9.2.0-sunny\",\n                 \"v9.4.0-tiffany\", \"v9.4.2-hyoyeon\"]\n    let expected = toOrderedTable[Version, string]({\n      newVersion(\"9.4.2-hyoyeon\"): \"v9.4.2-hyoyeon\",\n      newVersion(\"9.4.0-tiffany\"): \"v9.4.0-tiffany\",\n      newVersion(\"9.2.0-sunny\"): \"v9.2.0-sunny\",\n      newVersion(\"9.0.1-jessica\"): \"v9.0.1-jessica\",\n      newVersion(\"9.0.0-taeyeon\"): \"v9.0.0-taeyeon\"\n    })\n    doAssert expected == getVersionList(data)\n\n\n  block:\n    let data2 = @[\"v0.1.0\", \"v0.1.1\", \"v0.2.0\",\n                 \"0.4.0\", \"v0.4.2\"]\n    let expected2 = toOrderedTable[Version, string]({\n      newVersion(\"0.4.2\"): \"v0.4.2\",\n      newVersion(\"0.4.0\"): \"0.4.0\",\n      newVersion(\"0.2.0\"): \"v0.2.0\",\n      newVersion(\"0.1.1\"): \"v0.1.1\",\n      newVersion(\"0.1.0\"): \"v0.1.0\",\n    })\n    doAssert expected2 == getVersionList(data2)\n\n  echo(\"Everything works!\")\n"], "filenames": ["src/nimblepkg/download.nim"], "buggy_code_start_loc": [91], "buggy_code_end_loc": [142], "fixing_code_start_loc": [91], "fixing_code_end_loc": [142], "type": "CWE-78", "message": "Nimble is a package manager for the Nim programming language. In Nim release version before versions 1.2.10 and 1.4.4, Nimble doCmd is used in different places and can be leveraged to execute arbitrary commands. An attacker can craft a malicious entry in the packages.json package list to trigger code execution.", "other": {"cve": {"id": "CVE-2021-21372", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-26T22:15:12.697", "lastModified": "2022-10-24T17:14:16.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nimble is a package manager for the Nim programming language. In Nim release version before versions 1.2.10 and 1.4.4, Nimble doCmd is used in different places and can be leveraged to execute arbitrary commands. An attacker can craft a malicious entry in the packages.json package list to trigger code execution."}, {"lang": "es", "value": "Nimble es un administrador de paquetes para el lenguaje de programaci\u00f3n Nim.&#xa0;En la versi\u00f3n de lanzamiento de Nim versiones anteriores a 1.2.10 y 1.4.4, Nimble doCmd es usado en diferentes lugares y puede ser aprovechado para ejecutar comandos arbitrarios.&#xa0;Un atacante puede crear una entrada maliciosa en la lista de paquetes packages.json para desencadenar una ejecuci\u00f3n del c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nim-lang:nim:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.10", "matchCriteriaId": "895C273A-28A1-4592-8A50-9A8FAAD7D98C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nim-lang:nim:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.4.0", "versionEndExcluding": "1.4.4", "matchCriteriaId": "FBDDF104-9FC9-4CED-9F87-26CF1DA2EF4E"}]}]}], "references": [{"url": "https://consensys.net/diligence/vulnerabilities/nim-insecure-ssl-tls-defaults-remote-code-execution/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/nim-lang/nimble/blob/master/changelog.markdown#0130", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/nim-lang/nimble/commit/7bd63d504a4157b8ed61a51af47fb086ee818c37", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nim-lang/security/security/advisories/GHSA-rg9f-w24h-962p", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nim-lang/nimble/commit/7bd63d504a4157b8ed61a51af47fb086ee818c37"}}