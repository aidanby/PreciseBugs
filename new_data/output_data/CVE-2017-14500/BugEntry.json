{"buggy_code": ["#include <pb_controller.h>\n#include <pb_view.h>\n#include <poddlthread.h>\n#include <config.h>\n#include <utils.h>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <cstdlib>\n#include <thread>\n#include <signal.h>\n#include <unistd.h>\n\n#include <keymap.h>\n#include <configcontainer.h>\n#include <colormanager.h>\n#include <exceptions.h>\n#include <queueloader.h>\n#include <logger.h>\n\nusing namespace newsbeuter;\n\nstatic std::string lock_file = \"pb-lock.pid\";\n\nstatic void ctrl_c_action(int sig) {\n\tLOG(LOG_DEBUG,\"caugh signal %d\",sig);\n\tstfl::reset();\n\tutils::remove_fs_lock(lock_file);\n\t::exit(EXIT_FAILURE);\n}\n\nnamespace podbeuter {\n\n#define LOCK_SUFFIX \".lock\"\n\n/**\n * \\brief Try to setup XDG style dirs.\n *\n * returns false, if that fails\n */\nbool pb_controller::setup_dirs_xdg(const char *env_home) {\n\tconst char *env_xdg_config;\n\tconst char *env_xdg_data;\n\tstd::string xdg_config_dir;\n\tstd::string xdg_data_dir;\n\n\tenv_xdg_config = ::getenv(\"XDG_CONFIG_HOME\");\n\tif (env_xdg_config) {\n\t\txdg_config_dir = env_xdg_config;\n\t} else {\n\t\txdg_config_dir = env_home;\n\t\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_config_dir.append(\".config\");\n\t}\n\n\tenv_xdg_data = ::getenv(\"XDG_DATA_HOME\");\n\tif (env_xdg_data) {\n\t\txdg_data_dir = env_xdg_data;\n\t} else {\n\t\txdg_data_dir = env_home;\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\".local\");\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\"share\");\n\t}\n\n\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_config_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_data_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\tif (access(xdg_config_dir.c_str(), R_OK | X_OK) != 0) {\n\t\tstd::cout << utils::strprintf(_(\"XDG: configuration directory '%s' not accessible, using '%s' instead.\"), xdg_config_dir.c_str(), config_dir.c_str()) << std::endl;\n\t\treturn false;\n\t}\n\tif (access(xdg_data_dir.c_str(), R_OK | X_OK | W_OK) != 0) {\n\t\tstd::cout << utils::strprintf(_(\"XDG: data directory '%s' not accessible, using '%s' instead.\"), xdg_data_dir.c_str(), config_dir.c_str()) << std::endl;\n\t\treturn false;\n\t}\n\n\tconfig_dir = xdg_config_dir;\n\n\t/* in config */\n\turl_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + url_file;\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\n\t/* in data */\n\tcache_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + cache_file;\n\tlock_file = cache_file + LOCK_SUFFIX;\n\tqueue_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\tsearchfile = utils::strprintf(\"%s%shistory.search\", xdg_data_dir.c_str(), NEWSBEUTER_PATH_SEP);\n\tcmdlinefile = utils::strprintf(\"%s%shistory.cmdline\", xdg_data_dir.c_str(), NEWSBEUTER_PATH_SEP);\n\n\treturn true;\n}\n\npb_controller::pb_controller() : v(0), config_file(\"config\"), queue_file(\"queue\"), cfg(0), view_update_(true),  max_dls(1), ql(0) {\n\tchar * cfgdir;\n\tif (!(cfgdir = ::getenv(\"HOME\"))) {\n\t\tstruct passwd * spw = ::getpwuid(::getuid());\n\t\tif (spw) {\n\t\t\tcfgdir = spw->pw_dir;\n\t\t} else {\n\t\t\tstd::cout << _(\"Fatal error: couldn't determine home directory!\") << std::endl;\n\t\t\tstd::cout << utils::strprintf(_(\"Please set the HOME environment variable or add a valid user for UID %u!\"), ::getuid()) << std::endl;\n\t\t\t::exit(EXIT_FAILURE);\n\t\t}\n\t}\n\tconfig_dir = cfgdir;\n\n\tif (setup_dirs_xdg(cfgdir))\n\t\treturn;\n\n\tconfig_dir.append(NEWSBEUTER_PATH_SEP);\n\tconfig_dir.append(NEWSBEUTER_CONFIG_SUBDIR);\n\t::mkdir(config_dir.c_str(),0700); // create configuration directory if it doesn't exist\n\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\tqueue_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\tlock_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + lock_file;\n}\n\npb_controller::~pb_controller() {\n\tdelete cfg;\n}\n\nvoid pb_controller::run(int argc, char * argv[]) {\n\tint c;\n\tbool automatic_dl = false;\n\n\t::signal(SIGINT, ctrl_c_action);\n\n\tdo {\n\t\tif ((c = ::getopt(argc, argv, \"C:q:d:l:ha\")) < 0)\n\t\t\tcontinue;\n\n\t\tswitch (c) {\n\t\tcase ':':\n\t\tcase '?':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfig_file = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tqueue_file = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tautomatic_dl = true;\n\t\t\tbreak;\n\t\tcase 'd': // this is an undocumented debug commandline option!\n\t\t\tlogger::getInstance().set_logfile(optarg);\n\t\t\tbreak;\n\t\tcase 'l': { // this is an undocumented debug commandline option!\n\t\t\tloglevel level = static_cast<loglevel>(atoi(optarg));\n\t\t\tif (level > LOG_NONE && level <= LOG_DEBUG)\n\t\t\t\tlogger::getInstance().set_loglevel(level);\n\t\t}\n\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cout << utils::strprintf(_(\"%s: unknown option - %c\"), argv[0], static_cast<char>(c)) << std::endl;\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t} while (c != -1);\n\n\tstd::cout << utils::strprintf(_(\"Starting %s %s...\"), \"podbeuter\", PROGRAM_VERSION) << std::endl;\n\n\tpid_t pid;\n\tif (!utils::try_fs_lock(lock_file, pid)) {\n\t\tstd::cout << utils::strprintf(_(\"Error: an instance of %s is already running (PID: %u)\"), \"podbeuter\", pid) << std::endl;\n\t\treturn;\n\t}\n\n\tstd::cout << _(\"Loading configuration...\");\n\tstd::cout.flush();\n\n\tconfigparser cfgparser;\n\tcfg = new configcontainer();\n\tcfg->register_commands(cfgparser);\n\tcolormanager * colorman = new colormanager();\n\tcolorman->register_commands(cfgparser);\n\n\tkeymap keys(KM_PODBEUTER);\n\tcfgparser.register_handler(\"bind-key\", &keys);\n\tcfgparser.register_handler(\"unbind-key\", &keys);\n\n\tnull_config_action_handler null_cah;\n\tcfgparser.register_handler(\"macro\", &null_cah);\n\tcfgparser.register_handler(\"ignore-article\", &null_cah);\n\tcfgparser.register_handler(\"always-download\", &null_cah);\n\tcfgparser.register_handler(\"define-filter\", &null_cah);\n\tcfgparser.register_handler(\"highlight\", &null_cah);\n\tcfgparser.register_handler(\"highlight-article\", &null_cah);\n\tcfgparser.register_handler(\"reset-unread-on-update\", &null_cah);\n\n\ttry {\n\t\tcfgparser.parse(\"/etc/newsbeuter/config\");\n\t\tcfgparser.parse(config_file);\n\t} catch (const configexception& ex) {\n\t\tstd::cout << ex.what() << std::endl;\n\t\tdelete colorman;\n\t\treturn;\n\t}\n\n\tif (colorman->colors_loaded())\n\t\tcolorman->set_pb_colors(v);\n\tdelete colorman;\n\n\tmax_dls = cfg->get_configvalue_as_int(\"max-downloads\");\n\n\tstd::cout << _(\"done.\") << std::endl;\n\n\tql = new queueloader(queue_file, this);\n\tql->reload(downloads_);\n\n\tv->set_keymap(&keys);\n\n\tv->run(automatic_dl);\n\n\tstfl::reset();\n\n\tstd::cout <<  _(\"Cleaning up queue...\");\n\tstd::cout.flush();\n\n\tql->reload(downloads_);\n\tdelete ql;\n\n\tstd::cout << _(\"done.\") << std::endl;\n\n\tutils::remove_fs_lock(lock_file);\n}\n\nvoid pb_controller::usage(const char * argv0) {\n\tstd::cout << utils::strprintf(_(\"%s %s\\nusage %s [-C <file>] [-q <file>] [-h]\\n\"\n\t                                \"-C <configfile> read configuration from <configfile>\\n\"\n\t                                \"-q <queuefile>  use <queuefile> as queue file\\n\"\n\t                                \"-a              start download on startup\\n\"\n\t                                \"-h              this help\\n\"), \"podbeuter\", PROGRAM_VERSION, argv0);\n\t::exit(EXIT_FAILURE);\n}\n\nstd::string pb_controller::get_dlpath() {\n\treturn cfg->get_configvalue(\"download-path\");\n}\n\nunsigned int pb_controller::downloads_in_progress() {\n\tunsigned int count = 0;\n\tfor (auto dl : downloads_) {\n\t\tif (dl.status() == DL_DOWNLOADING)\n\t\t\t++count;\n\t}\n\treturn count;\n}\n\nunsigned int pb_controller::get_maxdownloads() {\n\treturn max_dls;\n}\n\nvoid pb_controller::reload_queue(bool remove_unplayed) {\n\tif (ql) {\n\t\tql->reload(downloads_, remove_unplayed);\n\t}\n}\n\ndouble pb_controller::get_total_kbps() {\n\tdouble result = 0.0;\n\tfor (auto dl : downloads_) {\n\t\tif (dl.status() == DL_DOWNLOADING) {\n\t\t\tresult += dl.kbps();\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid pb_controller::start_downloads() {\n\tint dl2start = get_maxdownloads() - downloads_in_progress();\n\tfor (auto it=downloads_.begin(); dl2start > 0 && it!=downloads_.end(); ++it) {\n\t\tif (it->status() == DL_QUEUED) {\n\t\t\tstd::thread t {poddlthread(&(*it), cfg)};\n\t\t\t--dl2start;\n\t\t}\n\t}\n}\n\nvoid pb_controller::increase_parallel_downloads() {\n\t++max_dls;\n}\n\nvoid pb_controller::decrease_parallel_downloads() {\n\tif (max_dls > 1)\n\t\t--max_dls;\n}\n\nvoid pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}\n\n\n} // namespace\n", "#include <stflpp.h>\n#include <utils.h>\n#include <queueloader.h>\n#include <cstdlib>\n#include <logger.h>\n#include <fstream>\n#include <cstring>\n#include <config.h>\n#include <libgen.h>\n\n#include <unistd.h>\n\nusing namespace newsbeuter;\n\nnamespace podbeuter {\n\nqueueloader::queueloader(const std::string& file, pb_controller * c) : queuefile(file), ctrl(c) {\n}\n\nvoid queueloader::reload(std::vector<download>& downloads, bool remove_unplayed) {\n\tstd::vector<download> dltemp;\n\tstd::fstream f;\n\n\tfor (auto dl : downloads) {\n\t\tif (dl.status() == DL_DOWNLOADING) { // we are not allowed to reload if a download is in progress!\n\t\t\tLOG(LOG_INFO, \"queueloader::reload: aborting reload due to DL_DOWNLOADING status\");\n\t\t\treturn;\n\t\t}\n\t\tswitch (dl.status()) {\n\t\tcase DL_QUEUED:\n\t\tcase DL_CANCELLED:\n\t\tcase DL_FAILED:\n\t\tcase DL_ALREADY_DOWNLOADED:\n\t\tcase DL_READY:\n\t\t\tLOG(LOG_DEBUG, \"queueloader::reload: storing %s to new vector\", dl.url());\n\t\t\tdltemp.push_back(dl);\n\t\t\tbreak;\n\t\tcase DL_PLAYED:\n\t\tcase DL_FINISHED:\n\t\t\tif (!remove_unplayed) {\n\t\t\t\tLOG(LOG_DEBUG, \"queueloader::reload: storing %s to new vector\", dl.url());\n\t\t\t\tdltemp.push_back(dl);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tf.open(queuefile.c_str(), std::fstream::in);\n\tif (f.is_open()) {\n\t\tstd::string line;\n\t\tdo {\n\t\t\tgetline(f, line);\n\t\t\tif (!f.eof() && line.length() > 0) {\n\t\t\t\tLOG(LOG_DEBUG, \"queueloader::reload: loaded `%s' from queue file\", line.c_str());\n\t\t\t\tstd::vector<std::string> fields = utils::tokenize_quoted(line);\n\t\t\t\tbool url_found = false;\n\n\t\t\t\tfor (auto dl : dltemp) {\n\t\t\t\t\tif (fields[0] == dl.url()) {\n\t\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' in old vector\", fields[0].c_str());\n\t\t\t\t\t\turl_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (auto dl : downloads) {\n\t\t\t\t\tif (fields[0] == dl.url()) {\n\t\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' in new vector\", line.c_str());\n\t\t\t\t\t\turl_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!url_found) {\n\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' nowhere -> storing to new vector\", line.c_str());\n\t\t\t\t\tdownload d(ctrl);\n\t\t\t\t\tstd::string fn;\n\t\t\t\t\tif (fields.size() == 1)\n\t\t\t\t\t\tfn = get_filename(fields[0]);\n\t\t\t\t\telse\n\t\t\t\t\t\tfn = fields[1];\n\t\t\t\t\td.set_filename(fn);\n\t\t\t\t\tif (access(fn.c_str(), F_OK)==0) {\n\t\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' on file system -> mark as already downloaded\", fn.c_str());\n\t\t\t\t\t\tif (fields.size() >= 3) {\n\t\t\t\t\t\t\tif (fields[2] == \"downloaded\")\n\t\t\t\t\t\t\t\td.set_status(DL_READY);\n\t\t\t\t\t\t\tif (fields[2] == \"played\")\n\t\t\t\t\t\t\t\td.set_status(DL_PLAYED);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\td.set_status(DL_ALREADY_DOWNLOADED); // TODO: scrap DL_ALREADY_DOWNLOADED state\n\t\t\t\t\t}\n\t\t\t\t\td.set_url(fields[0]);\n\t\t\t\t\tdltemp.push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!f.eof());\n\t\tf.close();\n\t}\n\n\tf.open(queuefile.c_str(), std::fstream::out);\n\tif (f.is_open()) {\n\t\tfor (auto dl : dltemp) {\n\t\t\tf << dl.url() << \" \" << stfl::quote(dl.filename());\n\t\t\tif (dl.status() == DL_READY)\n\t\t\t\tf << \" downloaded\";\n\t\t\tif (dl.status() == DL_PLAYED)\n\t\t\t\tf << \" played\";\n\t\t\tf << std::endl;\n\t\t}\n\t\tf.close();\n\t}\n\n\tdownloads = dltemp;\n}\n\nstd::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}\n\n}\n"], "fixing_code": ["#include <pb_controller.h>\n#include <pb_view.h>\n#include <poddlthread.h>\n#include <config.h>\n#include <utils.h>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <cstdlib>\n#include <thread>\n#include <signal.h>\n#include <unistd.h>\n\n#include <keymap.h>\n#include <configcontainer.h>\n#include <colormanager.h>\n#include <exceptions.h>\n#include <queueloader.h>\n#include <logger.h>\n\nusing namespace newsbeuter;\n\nstatic std::string lock_file = \"pb-lock.pid\";\n\nstatic void ctrl_c_action(int sig) {\n\tLOG(LOG_DEBUG,\"caugh signal %d\",sig);\n\tstfl::reset();\n\tutils::remove_fs_lock(lock_file);\n\t::exit(EXIT_FAILURE);\n}\n\nnamespace podbeuter {\n\n#define LOCK_SUFFIX \".lock\"\n\n/**\n * \\brief Try to setup XDG style dirs.\n *\n * returns false, if that fails\n */\nbool pb_controller::setup_dirs_xdg(const char *env_home) {\n\tconst char *env_xdg_config;\n\tconst char *env_xdg_data;\n\tstd::string xdg_config_dir;\n\tstd::string xdg_data_dir;\n\n\tenv_xdg_config = ::getenv(\"XDG_CONFIG_HOME\");\n\tif (env_xdg_config) {\n\t\txdg_config_dir = env_xdg_config;\n\t} else {\n\t\txdg_config_dir = env_home;\n\t\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_config_dir.append(\".config\");\n\t}\n\n\tenv_xdg_data = ::getenv(\"XDG_DATA_HOME\");\n\tif (env_xdg_data) {\n\t\txdg_data_dir = env_xdg_data;\n\t} else {\n\t\txdg_data_dir = env_home;\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\".local\");\n\t\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\t\txdg_data_dir.append(\"share\");\n\t}\n\n\txdg_config_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_config_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\txdg_data_dir.append(NEWSBEUTER_PATH_SEP);\n\txdg_data_dir.append(NEWSBEUTER_SUBDIR_XDG);\n\n\tif (access(xdg_config_dir.c_str(), R_OK | X_OK) != 0) {\n\t\tstd::cout << utils::strprintf(_(\"XDG: configuration directory '%s' not accessible, using '%s' instead.\"), xdg_config_dir.c_str(), config_dir.c_str()) << std::endl;\n\t\treturn false;\n\t}\n\tif (access(xdg_data_dir.c_str(), R_OK | X_OK | W_OK) != 0) {\n\t\tstd::cout << utils::strprintf(_(\"XDG: data directory '%s' not accessible, using '%s' instead.\"), xdg_data_dir.c_str(), config_dir.c_str()) << std::endl;\n\t\treturn false;\n\t}\n\n\tconfig_dir = xdg_config_dir;\n\n\t/* in config */\n\turl_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + url_file;\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\n\t/* in data */\n\tcache_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + cache_file;\n\tlock_file = cache_file + LOCK_SUFFIX;\n\tqueue_file = xdg_data_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\tsearchfile = utils::strprintf(\"%s%shistory.search\", xdg_data_dir.c_str(), NEWSBEUTER_PATH_SEP);\n\tcmdlinefile = utils::strprintf(\"%s%shistory.cmdline\", xdg_data_dir.c_str(), NEWSBEUTER_PATH_SEP);\n\n\treturn true;\n}\n\npb_controller::pb_controller() : v(0), config_file(\"config\"), queue_file(\"queue\"), cfg(0), view_update_(true),  max_dls(1), ql(0) {\n\tchar * cfgdir;\n\tif (!(cfgdir = ::getenv(\"HOME\"))) {\n\t\tstruct passwd * spw = ::getpwuid(::getuid());\n\t\tif (spw) {\n\t\t\tcfgdir = spw->pw_dir;\n\t\t} else {\n\t\t\tstd::cout << _(\"Fatal error: couldn't determine home directory!\") << std::endl;\n\t\t\tstd::cout << utils::strprintf(_(\"Please set the HOME environment variable or add a valid user for UID %u!\"), ::getuid()) << std::endl;\n\t\t\t::exit(EXIT_FAILURE);\n\t\t}\n\t}\n\tconfig_dir = cfgdir;\n\n\tif (setup_dirs_xdg(cfgdir))\n\t\treturn;\n\n\tconfig_dir.append(NEWSBEUTER_PATH_SEP);\n\tconfig_dir.append(NEWSBEUTER_CONFIG_SUBDIR);\n\t::mkdir(config_dir.c_str(),0700); // create configuration directory if it doesn't exist\n\n\tconfig_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + config_file;\n\tqueue_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + queue_file;\n\tlock_file = config_dir + std::string(NEWSBEUTER_PATH_SEP) + lock_file;\n}\n\npb_controller::~pb_controller() {\n\tdelete cfg;\n}\n\nvoid pb_controller::run(int argc, char * argv[]) {\n\tint c;\n\tbool automatic_dl = false;\n\n\t::signal(SIGINT, ctrl_c_action);\n\n\tdo {\n\t\tif ((c = ::getopt(argc, argv, \"C:q:d:l:ha\")) < 0)\n\t\t\tcontinue;\n\n\t\tswitch (c) {\n\t\tcase ':':\n\t\tcase '?':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfig_file = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tqueue_file = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tautomatic_dl = true;\n\t\t\tbreak;\n\t\tcase 'd': // this is an undocumented debug commandline option!\n\t\t\tlogger::getInstance().set_logfile(optarg);\n\t\t\tbreak;\n\t\tcase 'l': { // this is an undocumented debug commandline option!\n\t\t\tloglevel level = static_cast<loglevel>(atoi(optarg));\n\t\t\tif (level > LOG_NONE && level <= LOG_DEBUG)\n\t\t\t\tlogger::getInstance().set_loglevel(level);\n\t\t}\n\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cout << utils::strprintf(_(\"%s: unknown option - %c\"), argv[0], static_cast<char>(c)) << std::endl;\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t} while (c != -1);\n\n\tstd::cout << utils::strprintf(_(\"Starting %s %s...\"), \"podbeuter\", PROGRAM_VERSION) << std::endl;\n\n\tpid_t pid;\n\tif (!utils::try_fs_lock(lock_file, pid)) {\n\t\tstd::cout << utils::strprintf(_(\"Error: an instance of %s is already running (PID: %u)\"), \"podbeuter\", pid) << std::endl;\n\t\treturn;\n\t}\n\n\tstd::cout << _(\"Loading configuration...\");\n\tstd::cout.flush();\n\n\tconfigparser cfgparser;\n\tcfg = new configcontainer();\n\tcfg->register_commands(cfgparser);\n\tcolormanager * colorman = new colormanager();\n\tcolorman->register_commands(cfgparser);\n\n\tkeymap keys(KM_PODBEUTER);\n\tcfgparser.register_handler(\"bind-key\", &keys);\n\tcfgparser.register_handler(\"unbind-key\", &keys);\n\n\tnull_config_action_handler null_cah;\n\tcfgparser.register_handler(\"macro\", &null_cah);\n\tcfgparser.register_handler(\"ignore-article\", &null_cah);\n\tcfgparser.register_handler(\"always-download\", &null_cah);\n\tcfgparser.register_handler(\"define-filter\", &null_cah);\n\tcfgparser.register_handler(\"highlight\", &null_cah);\n\tcfgparser.register_handler(\"highlight-article\", &null_cah);\n\tcfgparser.register_handler(\"reset-unread-on-update\", &null_cah);\n\n\ttry {\n\t\tcfgparser.parse(\"/etc/newsbeuter/config\");\n\t\tcfgparser.parse(config_file);\n\t} catch (const configexception& ex) {\n\t\tstd::cout << ex.what() << std::endl;\n\t\tdelete colorman;\n\t\treturn;\n\t}\n\n\tif (colorman->colors_loaded())\n\t\tcolorman->set_pb_colors(v);\n\tdelete colorman;\n\n\tmax_dls = cfg->get_configvalue_as_int(\"max-downloads\");\n\n\tstd::cout << _(\"done.\") << std::endl;\n\n\tql = new queueloader(queue_file, this);\n\tql->reload(downloads_);\n\n\tv->set_keymap(&keys);\n\n\tv->run(automatic_dl);\n\n\tstfl::reset();\n\n\tstd::cout <<  _(\"Cleaning up queue...\");\n\tstd::cout.flush();\n\n\tql->reload(downloads_);\n\tdelete ql;\n\n\tstd::cout << _(\"done.\") << std::endl;\n\n\tutils::remove_fs_lock(lock_file);\n}\n\nvoid pb_controller::usage(const char * argv0) {\n\tstd::cout << utils::strprintf(_(\"%s %s\\nusage %s [-C <file>] [-q <file>] [-h]\\n\"\n\t                                \"-C <configfile> read configuration from <configfile>\\n\"\n\t                                \"-q <queuefile>  use <queuefile> as queue file\\n\"\n\t                                \"-a              start download on startup\\n\"\n\t                                \"-h              this help\\n\"), \"podbeuter\", PROGRAM_VERSION, argv0);\n\t::exit(EXIT_FAILURE);\n}\n\nstd::string pb_controller::get_dlpath() {\n\treturn cfg->get_configvalue(\"download-path\");\n}\n\nunsigned int pb_controller::downloads_in_progress() {\n\tunsigned int count = 0;\n\tfor (auto dl : downloads_) {\n\t\tif (dl.status() == DL_DOWNLOADING)\n\t\t\t++count;\n\t}\n\treturn count;\n}\n\nunsigned int pb_controller::get_maxdownloads() {\n\treturn max_dls;\n}\n\nvoid pb_controller::reload_queue(bool remove_unplayed) {\n\tif (ql) {\n\t\tql->reload(downloads_, remove_unplayed);\n\t}\n}\n\ndouble pb_controller::get_total_kbps() {\n\tdouble result = 0.0;\n\tfor (auto dl : downloads_) {\n\t\tif (dl.status() == DL_DOWNLOADING) {\n\t\t\tresult += dl.kbps();\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid pb_controller::start_downloads() {\n\tint dl2start = get_maxdownloads() - downloads_in_progress();\n\tfor (auto it=downloads_.begin(); dl2start > 0 && it!=downloads_.end(); ++it) {\n\t\tif (it->status() == DL_QUEUED) {\n\t\t\tstd::thread t {poddlthread(&(*it), cfg)};\n\t\t\t--dl2start;\n\t\t}\n\t}\n}\n\nvoid pb_controller::increase_parallel_downloads() {\n\t++max_dls;\n}\n\nvoid pb_controller::decrease_parallel_downloads() {\n\tif (max_dls > 1)\n\t\t--max_dls;\n}\n\nvoid pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\'\");\n\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));\n\tcmdline.append(\"\\'\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}\n\n\n} // namespace\n", "#include <stflpp.h>\n#include <utils.h>\n#include <queueloader.h>\n#include <cstdlib>\n#include <logger.h>\n#include <fstream>\n#include <cstring>\n#include <config.h>\n#include <libgen.h>\n\n#include <unistd.h>\n\nusing namespace newsbeuter;\n\nnamespace podbeuter {\n\nqueueloader::queueloader(const std::string& file, pb_controller * c) : queuefile(file), ctrl(c) {\n}\n\nvoid queueloader::reload(std::vector<download>& downloads, bool remove_unplayed) {\n\tstd::vector<download> dltemp;\n\tstd::fstream f;\n\n\tfor (auto dl : downloads) {\n\t\tif (dl.status() == DL_DOWNLOADING) { // we are not allowed to reload if a download is in progress!\n\t\t\tLOG(LOG_INFO, \"queueloader::reload: aborting reload due to DL_DOWNLOADING status\");\n\t\t\treturn;\n\t\t}\n\t\tswitch (dl.status()) {\n\t\tcase DL_QUEUED:\n\t\tcase DL_CANCELLED:\n\t\tcase DL_FAILED:\n\t\tcase DL_ALREADY_DOWNLOADED:\n\t\tcase DL_READY:\n\t\t\tLOG(LOG_DEBUG, \"queueloader::reload: storing %s to new vector\", dl.url());\n\t\t\tdltemp.push_back(dl);\n\t\t\tbreak;\n\t\tcase DL_PLAYED:\n\t\tcase DL_FINISHED:\n\t\t\tif (!remove_unplayed) {\n\t\t\t\tLOG(LOG_DEBUG, \"queueloader::reload: storing %s to new vector\", dl.url());\n\t\t\t\tdltemp.push_back(dl);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tf.open(queuefile.c_str(), std::fstream::in);\n\tif (f.is_open()) {\n\t\tstd::string line;\n\t\tdo {\n\t\t\tgetline(f, line);\n\t\t\tif (!f.eof() && line.length() > 0) {\n\t\t\t\tLOG(LOG_DEBUG, \"queueloader::reload: loaded `%s' from queue file\", line.c_str());\n\t\t\t\tstd::vector<std::string> fields = utils::tokenize_quoted(line);\n\t\t\t\tbool url_found = false;\n\n\t\t\t\tfor (auto dl : dltemp) {\n\t\t\t\t\tif (fields[0] == dl.url()) {\n\t\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' in old vector\", fields[0].c_str());\n\t\t\t\t\t\turl_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (auto dl : downloads) {\n\t\t\t\t\tif (fields[0] == dl.url()) {\n\t\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' in new vector\", line.c_str());\n\t\t\t\t\t\turl_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!url_found) {\n\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' nowhere -> storing to new vector\", line.c_str());\n\t\t\t\t\tdownload d(ctrl);\n\t\t\t\t\tstd::string fn;\n\t\t\t\t\tif (fields.size() == 1)\n\t\t\t\t\t\tfn = get_filename(fields[0]);\n\t\t\t\t\telse\n\t\t\t\t\t\tfn = fields[1];\n\t\t\t\t\td.set_filename(fn);\n\t\t\t\t\tif (access(fn.c_str(), F_OK)==0) {\n\t\t\t\t\t\tLOG(LOG_INFO, \"queueloader::reload: found `%s' on file system -> mark as already downloaded\", fn.c_str());\n\t\t\t\t\t\tif (fields.size() >= 3) {\n\t\t\t\t\t\t\tif (fields[2] == \"downloaded\")\n\t\t\t\t\t\t\t\td.set_status(DL_READY);\n\t\t\t\t\t\t\tif (fields[2] == \"played\")\n\t\t\t\t\t\t\t\td.set_status(DL_PLAYED);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\td.set_status(DL_ALREADY_DOWNLOADED); // TODO: scrap DL_ALREADY_DOWNLOADED state\n\t\t\t\t\t}\n\t\t\t\t\td.set_url(fields[0]);\n\t\t\t\t\tdltemp.push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!f.eof());\n\t\tf.close();\n\t}\n\n\tf.open(queuefile.c_str(), std::fstream::out);\n\tif (f.is_open()) {\n\t\tfor (auto dl : dltemp) {\n\t\t\tf << dl.url() << \" \" << stfl::quote(dl.filename());\n\t\t\tif (dl.status() == DL_READY)\n\t\t\t\tf << \" downloaded\";\n\t\t\tif (dl.status() == DL_PLAYED)\n\t\t\t\tf << \" played\";\n\t\t\tf << std::endl;\n\t\t}\n\t\tf.close();\n\t}\n\n\tdownloads = dltemp;\n}\n\nstd::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(utils::replace_all(base, \"'\", \"%27\"));\n\t}\n\treturn fn;\n}\n\n}\n"], "filenames": ["src/pb_controller.cpp", "src/queueloader.cpp"], "buggy_code_start_loc": [309, 133], "buggy_code_end_loc": [312, 134], "fixing_code_start_loc": [309, 133], "fixing_code_end_loc": [312, 134], "type": "CWE-78", "message": "Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904.", "other": {"cve": {"id": "CVE-2017-14500", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-17T05:29:00.193", "lastModified": "2020-10-21T20:15:13.257", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904."}, {"lang": "es", "value": "No se neutralizan correctamente los elementos especiales utilizados en un comando de sistema operativo en la funci\u00f3n de reproducci\u00f3n de podcasts de Podbeuter en Newsbeuter de la versi\u00f3n 0.3 a la 2.9. Esto permite a atacantes remotos ejecutar c\u00f3digo proporcionado por el usuario manipulando un elemento RSS con un adjunto audiovisual (es decir, un archivo podcast) que incluye metacaracteres shell en su nombre de archivo. Esto est\u00e1 relacionado con pb_controller.cpp y queueloader.cpp. Esta vulnerabilidad es distinta a CVE-2017-12904."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "4AF4978C-4EBF-41ED-962F-0890E5BDC071"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.4:*:*:*:*:*:*:*", "matchCriteriaId": "DCDA3939-74B1-4A44-955D-1BA1D2A23C0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "B242B9F1-3B5B-41EE-8CFF-BCC3008B785A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "733B891C-63E6-45A2-AE6D-32A4C860A07D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "684B7199-9344-4DBA-90AD-DEDEC056F213"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.8:*:*:*:*:*:*:*", "matchCriteriaId": "45CD698E-70A1-43A0-B828-3DBD519DDDF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "379E21B5-D427-45EC-B674-9BCC8A47CA76"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "EB0B1B93-8E8C-4A77-98F8-CE5BFED550DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "1C907407-E178-43BF-A433-9BC73EB7FD5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "DB3A20C1-1FB7-43C8-A78E-FBEBB4E888AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "A3F963DE-447B-4D6C-A508-C4449C67F1C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B7BAF663-30D1-4584-A0B0-CF02D2646877"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "50AD4B86-FED2-4469-BBD7-B698A7C1B4AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "62E8E19D-024A-4F73-B66F-87741325BC35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "5A34C699-1E62-4A54-B929-0C187299ABD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.1:*:*:*:*:*:*:*", "matchCriteriaId": "F5E5E120-42BD-4846-9C6B-D51804C902A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.2:*:*:*:*:*:*:*", "matchCriteriaId": "BFC168D9-75AB-43DD-A1F6-103F14AD9995"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9FA4C1C6-33AD-420C-ABA3-F7254A51BDDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "2EC3FE66-8689-4F61-9035-00DAD02A1527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.5:*:*:*:*:*:*:*", "matchCriteriaId": "0FADF671-B5B0-4634-AA18-15551363293B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.6:*:*:*:*:*:*:*", "matchCriteriaId": "8E8DC0AC-DA20-4A93-9561-C2D906D0D1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.7:*:*:*:*:*:*:*", "matchCriteriaId": "DD6A06A3-2A06-4DDC-851A-6B27B7BB7F24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.8:*:*:*:*:*:*:*", "matchCriteriaId": "A5CDB422-35D4-42E5-A897-3C12C6E16E51"}, {"vulnerable": true, "criteria": "cpe:2.3:a:newsbeuter:newsbeuter:2.9:*:*:*:*:*:*:*", "matchCriteriaId": "8ECF398D-94EA-4628-99A2-35B698579B96"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/09/16/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3977", "source": "cve@mitre.org"}, {"url": "https://github.com/akrennmair/newsbeuter/commit/26f5a4350f3ab5507bb8727051c87bb04660f333", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/akrennmair/newsbeuter/commit/c8fea2f60c18ed30bdd1bb6f798e994e51a58260", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/akrennmair/newsbeuter/issues/598", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/4585-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/akrennmair/newsbeuter/commit/26f5a4350f3ab5507bb8727051c87bb04660f333"}}