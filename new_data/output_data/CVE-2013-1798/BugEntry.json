{"buggy_code": ["/*\n *  Copyright (C) 2001  MandrakeSoft S.A.\n *  Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n *    MandrakeSoft S.A.\n *    43, rue d'Aboukir\n *    75002 Paris - France\n *    http://www.linux-mandrake.com/\n *    http://www.mandrakesoft.com/\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *  Yunhong Jiang <yunhong.jiang@intel.com>\n *  Yaozu (Eddie) Dong <eddie.dong@intel.com>\n *  Based on Xen 3.1 code.\n */\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/smp.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/current.h>\n#include <trace/events/kvm.h>\n\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"irq.h\"\n\n#if 0\n#define ioapic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg)\n#else\n#define ioapic_debug(fmt, arg...)\n#endif\nstatic int ioapic_deliver(struct kvm_ioapic *vioapic, int irq);\n\nstatic unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, unsigned int idx)\n{\n\tunion kvm_ioapic_redirect_entry *pent;\n\tint injected = -1;\n\n\tpent = &ioapic->redirtbl[idx];\n\n\tif (!pent->fields.mask) {\n\t\tinjected = ioapic_deliver(ioapic, idx);\n\t\tif (injected && pent->fields.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\t\tpent->fields.remote_irr = 1;\n\t}\n\n\treturn injected;\n}\n\nstatic void update_handled_vectors(struct kvm_ioapic *ioapic)\n{\n\tDECLARE_BITMAP(handled_vectors, 256);\n\tint i;\n\n\tmemset(handled_vectors, 0, sizeof(handled_vectors));\n\tfor (i = 0; i < IOAPIC_NUM_PINS; ++i)\n\t\t__set_bit(ioapic->redirtbl[i].fields.vector, handled_vectors);\n\tmemcpy(ioapic->handled_vectors, handled_vectors,\n\t       sizeof(handled_vectors));\n\tsmp_wmb();\n}\n\nvoid kvm_ioapic_calculate_eoi_exitmap(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 *eoi_exit_bitmap)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\tstruct kvm_lapic_irq irqe;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\t/* traverse ioapic entry to set eoi exit bitmap*/\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (!e->fields.mask &&\n\t\t\t(e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t\t kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC,\n\t\t\t\t index))) {\n\t\t\tirqe.dest_id = e->fields.dest_id;\n\t\t\tirqe.vector = e->fields.vector;\n\t\t\tirqe.dest_mode = e->fields.dest_mode;\n\t\t\tirqe.delivery_mode = e->fields.delivery_mode << 8;\n\t\t\tkvm_calculate_eoi_exitmap(vcpu, &irqe, eoi_exit_bitmap);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}\nEXPORT_SYMBOL_GPL(kvm_ioapic_calculate_eoi_exitmap);\n\nvoid kvm_ioapic_make_eoibitmap_request(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!kvm_apic_vid_enabled(kvm) || !ioapic)\n\t\treturn;\n\tkvm_make_update_eoibitmap_request(kvm);\n}\n\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tioapic_debug(\"change redir index %x val %x\\n\", index, val);\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t\te->fields.remote_irr = 0;\n\t\t}\n\t\tupdate_handled_vectors(ioapic);\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index);\n\t\tkvm_ioapic_make_eoibitmap_request(ioapic->kvm);\n\t\tbreak;\n\t}\n}\n\nstatic int ioapic_deliver(struct kvm_ioapic *ioapic, int irq)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\n\treturn kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe);\n}\n\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level)\n{\n\tu32 old_irr;\n\tu32 mask = 1 << irq;\n\tunion kvm_ioapic_redirect_entry entry;\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\told_irr = ioapic->irr;\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tentry = ioapic->redirtbl[irq];\n\tirq_level ^= entry.fields.polarity;\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t} else {\n\t\tint edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\t\tioapic->irr |= mask;\n\t\tif ((edge && old_irr != ioapic->irr) ||\n\t\t    (!edge && !entry.fields.remote_irr))\n\t\t\tret = ioapic_service(ioapic, irq);\n\t\telse\n\t\t\tret = 0; /* report coalesced interrupt */\n\t}\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}\n\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}\n\nstatic void __kvm_ioapic_update_eoi(struct kvm_ioapic *ioapic, int vector,\n\t\t\t\t     int trigger_mode)\n{\n\tint i;\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are dropping lock while calling ack notifiers because ack\n\t\t * notifier callbacks for assigned devices call into IOAPIC\n\t\t * recursively. Since remote_irr is cleared only after call\n\t\t * to notifiers if the same vector will be delivered while lock\n\t\t * is dropped it will be put into irr and will be delivered\n\t\t * after ack notifier returns.\n\t\t */\n\t\tspin_unlock(&ioapic->lock);\n\t\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);\n\t\tspin_lock(&ioapic->lock);\n\n\t\tif (trigger_mode != IOAPIC_LEVEL_TRIG)\n\t\t\tcontinue;\n\n\t\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\t\tent->fields.remote_irr = 0;\n\t\tif (!ent->fields.mask && (ioapic->irr & (1 << i)))\n\t\t\tioapic_service(ioapic, i);\n\t}\n}\n\nbool kvm_ioapic_handles_vector(struct kvm *kvm, int vector)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\tsmp_rmb();\n\treturn test_bit(vector, ioapic->handled_vectors);\n}\n\nvoid kvm_ioapic_update_eoi(struct kvm *kvm, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}\n\nstatic int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t    void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}\n\nstatic int ioapic_mmio_write(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t     const void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 data;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"ioapic_mmio_write addr=%p len=%d val=%p\\n\",\n\t\t     (void*)addr, len, val);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\tswitch (len) {\n\tcase 8:\n\tcase 4:\n\t\tdata = *(u32 *) val;\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *) val;\n\t\tbreak;\n\tcase 1:\n\t\tdata = *(u8  *) val;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: Unsupported size %d\\n\", len);\n\t\treturn 0;\n\t}\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tioapic->ioregsel = data & 0xFF; /* 8-bit register */\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tioapic_write_indirect(ioapic, data);\n\t\tbreak;\n#ifdef\tCONFIG_IA64\n\tcase IOAPIC_REG_EOI:\n\t\t__kvm_ioapic_update_eoi(ioapic, data, IOAPIC_LEVEL_TRIG);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n\nvoid kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->id = 0;\n\tupdate_handled_vectors(ioapic);\n}\n\nstatic const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};\n\nint kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t}\n\n\treturn ret;\n}\n\nvoid kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (ioapic) {\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t}\n}\n\nint kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n\nint kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tupdate_handled_vectors(ioapic);\n\tkvm_ioapic_make_eoibitmap_request(kvm);\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n"], "fixing_code": ["/*\n *  Copyright (C) 2001  MandrakeSoft S.A.\n *  Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n *    MandrakeSoft S.A.\n *    43, rue d'Aboukir\n *    75002 Paris - France\n *    http://www.linux-mandrake.com/\n *    http://www.mandrakesoft.com/\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *  Yunhong Jiang <yunhong.jiang@intel.com>\n *  Yaozu (Eddie) Dong <eddie.dong@intel.com>\n *  Based on Xen 3.1 code.\n */\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/smp.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/current.h>\n#include <trace/events/kvm.h>\n\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"irq.h\"\n\n#if 0\n#define ioapic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg)\n#else\n#define ioapic_debug(fmt, arg...)\n#endif\nstatic int ioapic_deliver(struct kvm_ioapic *vioapic, int irq);\n\nstatic unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n\t\t\t\tredir_content =\n\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n\t\t\telse\n\t\t\t\tredir_content = ~0ULL;\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, unsigned int idx)\n{\n\tunion kvm_ioapic_redirect_entry *pent;\n\tint injected = -1;\n\n\tpent = &ioapic->redirtbl[idx];\n\n\tif (!pent->fields.mask) {\n\t\tinjected = ioapic_deliver(ioapic, idx);\n\t\tif (injected && pent->fields.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\t\tpent->fields.remote_irr = 1;\n\t}\n\n\treturn injected;\n}\n\nstatic void update_handled_vectors(struct kvm_ioapic *ioapic)\n{\n\tDECLARE_BITMAP(handled_vectors, 256);\n\tint i;\n\n\tmemset(handled_vectors, 0, sizeof(handled_vectors));\n\tfor (i = 0; i < IOAPIC_NUM_PINS; ++i)\n\t\t__set_bit(ioapic->redirtbl[i].fields.vector, handled_vectors);\n\tmemcpy(ioapic->handled_vectors, handled_vectors,\n\t       sizeof(handled_vectors));\n\tsmp_wmb();\n}\n\nvoid kvm_ioapic_calculate_eoi_exitmap(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 *eoi_exit_bitmap)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\tstruct kvm_lapic_irq irqe;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\t/* traverse ioapic entry to set eoi exit bitmap*/\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (!e->fields.mask &&\n\t\t\t(e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t\t kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC,\n\t\t\t\t index))) {\n\t\t\tirqe.dest_id = e->fields.dest_id;\n\t\t\tirqe.vector = e->fields.vector;\n\t\t\tirqe.dest_mode = e->fields.dest_mode;\n\t\t\tirqe.delivery_mode = e->fields.delivery_mode << 8;\n\t\t\tkvm_calculate_eoi_exitmap(vcpu, &irqe, eoi_exit_bitmap);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}\nEXPORT_SYMBOL_GPL(kvm_ioapic_calculate_eoi_exitmap);\n\nvoid kvm_ioapic_make_eoibitmap_request(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!kvm_apic_vid_enabled(kvm) || !ioapic)\n\t\treturn;\n\tkvm_make_update_eoibitmap_request(kvm);\n}\n\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tioapic_debug(\"change redir index %x val %x\\n\", index, val);\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t\te->fields.remote_irr = 0;\n\t\t}\n\t\tupdate_handled_vectors(ioapic);\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index);\n\t\tkvm_ioapic_make_eoibitmap_request(ioapic->kvm);\n\t\tbreak;\n\t}\n}\n\nstatic int ioapic_deliver(struct kvm_ioapic *ioapic, int irq)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\n\treturn kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe);\n}\n\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level)\n{\n\tu32 old_irr;\n\tu32 mask = 1 << irq;\n\tunion kvm_ioapic_redirect_entry entry;\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\told_irr = ioapic->irr;\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tentry = ioapic->redirtbl[irq];\n\tirq_level ^= entry.fields.polarity;\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t} else {\n\t\tint edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\t\tioapic->irr |= mask;\n\t\tif ((edge && old_irr != ioapic->irr) ||\n\t\t    (!edge && !entry.fields.remote_irr))\n\t\t\tret = ioapic_service(ioapic, irq);\n\t\telse\n\t\t\tret = 0; /* report coalesced interrupt */\n\t}\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}\n\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}\n\nstatic void __kvm_ioapic_update_eoi(struct kvm_ioapic *ioapic, int vector,\n\t\t\t\t     int trigger_mode)\n{\n\tint i;\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are dropping lock while calling ack notifiers because ack\n\t\t * notifier callbacks for assigned devices call into IOAPIC\n\t\t * recursively. Since remote_irr is cleared only after call\n\t\t * to notifiers if the same vector will be delivered while lock\n\t\t * is dropped it will be put into irr and will be delivered\n\t\t * after ack notifier returns.\n\t\t */\n\t\tspin_unlock(&ioapic->lock);\n\t\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);\n\t\tspin_lock(&ioapic->lock);\n\n\t\tif (trigger_mode != IOAPIC_LEVEL_TRIG)\n\t\t\tcontinue;\n\n\t\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\t\tent->fields.remote_irr = 0;\n\t\tif (!ent->fields.mask && (ioapic->irr & (1 << i)))\n\t\t\tioapic_service(ioapic, i);\n\t}\n}\n\nbool kvm_ioapic_handles_vector(struct kvm *kvm, int vector)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\tsmp_rmb();\n\treturn test_bit(vector, ioapic->handled_vectors);\n}\n\nvoid kvm_ioapic_update_eoi(struct kvm *kvm, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}\n\nstatic int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t    void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}\n\nstatic int ioapic_mmio_write(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t     const void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 data;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"ioapic_mmio_write addr=%p len=%d val=%p\\n\",\n\t\t     (void*)addr, len, val);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\tswitch (len) {\n\tcase 8:\n\tcase 4:\n\t\tdata = *(u32 *) val;\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *) val;\n\t\tbreak;\n\tcase 1:\n\t\tdata = *(u8  *) val;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: Unsupported size %d\\n\", len);\n\t\treturn 0;\n\t}\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tioapic->ioregsel = data & 0xFF; /* 8-bit register */\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tioapic_write_indirect(ioapic, data);\n\t\tbreak;\n#ifdef\tCONFIG_IA64\n\tcase IOAPIC_REG_EOI:\n\t\t__kvm_ioapic_update_eoi(ioapic, data, IOAPIC_LEVEL_TRIG);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n\nvoid kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->id = 0;\n\tupdate_handled_vectors(ioapic);\n}\n\nstatic const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};\n\nint kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t}\n\n\treturn ret;\n}\n\nvoid kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (ioapic) {\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t}\n}\n\nint kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n\nint kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tupdate_handled_vectors(ioapic);\n\tkvm_ioapic_make_eoibitmap_request(kvm);\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n"], "filenames": ["virt/kvm/ioapic.c"], "buggy_code_start_loc": [77], "buggy_code_end_loc": [80], "fixing_code_start_loc": [77], "fixing_code_end_loc": [83], "type": "CWE-20", "message": "The ioapic_read_indirect function in virt/kvm/ioapic.c in the Linux kernel through 3.8.4 does not properly handle a certain combination of invalid IOAPIC_REG_SELECT and IOAPIC_REG_WINDOW operations, which allows guest OS users to obtain sensitive information from host OS memory or cause a denial of service (host OS OOPS) via a crafted application.", "other": {"cve": {"id": "CVE-2013-1798", "sourceIdentifier": "secalert@redhat.com", "published": "2013-03-22T11:59:11.587", "lastModified": "2023-02-13T04:41:15.800", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ioapic_read_indirect function in virt/kvm/ioapic.c in the Linux kernel through 3.8.4 does not properly handle a certain combination of invalid IOAPIC_REG_SELECT and IOAPIC_REG_WINDOW operations, which allows guest OS users to obtain sensitive information from host OS memory or cause a denial of service (host OS OOPS) via a crafted application."}, {"lang": "es", "value": "La funci\u00f3n ioapic_read_indirect virt/kvm/ioapic.c en el kernel de Linux hasta v3.8.4 no controla correctamente una determinada combinaci\u00f3n de IOAPIC_REG_SELECT inv\u00e1lida y operaciones IOAPIC_REG_WINDOW, permitiendo a usuarios invitados del SO obtener informaci\u00f3n confidencial de la memoria principal o causar una denegaci\u00f3n de servicio a trav\u00e9s de una aplicaci\u00f3n dise\u00f1ada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:H/Au:N/C:C/I:N/A:C", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.2, "impactScore": 9.2, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.4", "matchCriteriaId": "0D272EF6-C70C-4FC5-98C4-3240045414FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=a2c118bfab8bc6b8bb213abfc35201e441693d55", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-05/msg00018.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-06/msg00005.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-07/msg00018.html", "source": "secalert@redhat.com"}, {"url": "http://packetstormsecurity.com/files/157233/Kernel-Live-Patch-Security-Notice-LSN-0065-1.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0727.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0744.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0746.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0928.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1026.html", "source": "secalert@redhat.com"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:176", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/20/9", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1809-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1812-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1813-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=917017", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/a2c118bfab8bc6b8bb213abfc35201e441693d55", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a2c118bfab8bc6b8bb213abfc35201e441693d55"}}