{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                  M   M   AAA   TTTTT  L       AAA   BBBB                    %\n%                  MM MM  A   A    T    L      A   A  B   B                   %\n%                  M M M  AAAAA    T    L      AAAAA  BBBB                    %\n%                  M   M  A   A    T    L      A   A  B   B                   %\n%                  M   M  A   A    T    LLLLL  A   A  BBBB                    %\n%                                                                             %\n%                                                                             %\n%                        Read MATLAB Image Format                             %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                2001-2008                                    %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n #include \"zlib.h\"\n#endif\n\f\n/*\n  Forward declaration.\n*/\nstatic MagickBooleanType\n  WriteMATImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n\n/* Auto coloring method, sorry this creates some artefact inside data\nMinReal+j*MaxComplex = red  MaxReal+j*MaxComplex = black\nMinReal+j*0 = white          MaxReal+j*0 = black\nMinReal+j*MinComplex = blue  MaxReal+j*MinComplex = black\n*/\n\ntypedef struct\n{\n  char identific[124];\n  unsigned short Version;\n  char EndianIndicator[2];\n  unsigned long DataType;\n  unsigned long ObjectSize;\n  unsigned long unknown1;\n  unsigned long unknown2;\n\n  unsigned short unknown5;\n  unsigned char StructureFlag;\n  unsigned char StructureClass;\n  unsigned long unknown3;\n  unsigned long unknown4;\n  unsigned long DimFlag;\n\n  unsigned long SizeX;\n  unsigned long SizeY;\n  unsigned short Flag1;\n  unsigned short NameFlag;\n}\nMATHeader;\n\nstatic const char *MonthsTab[12]={\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nstatic const char *DayOfWTab[7]={\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"};\nstatic const char *OsDesc=\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    \"PCWIN\";\n#else\n #ifdef __APPLE__\n    \"MAC\";\n #else\n    \"LNX86\";\n #endif\n#endif\n\ntypedef enum\n  {\n    miINT8 = 1,      /* 8 bit signed */\n    miUINT8,      /* 8 bit unsigned */\n    miINT16,      /* 16 bit signed */\n    miUINT16,      /* 16 bit unsigned */\n    miINT32,      /* 32 bit signed */\n    miUINT32,      /* 32 bit unsigned */\n    miSINGLE,      /* IEEE 754 single precision float */\n    miRESERVE1,\n    miDOUBLE,      /* IEEE 754 double precision float */\n    miRESERVE2,\n    miRESERVE3,\n    miINT64,      /* 64 bit signed */\n    miUINT64,      /* 64 bit unsigned */\n    miMATRIX,            /* MATLAB array */\n    miCOMPRESSED,          /* Compressed Data */\n    miUTF8,            /* Unicode UTF-8 Encoded Character Data */\n    miUTF16,            /* Unicode UTF-16 Encoded Character Data */\n    miUTF32      /* Unicode UTF-32 Encoded Character Data */\n  } mat5_data_type;\n\ntypedef enum\n  {\n    mxCELL_CLASS=1,    /* cell array */\n    mxSTRUCT_CLASS,    /* structure */\n    mxOBJECT_CLASS,    /* object */\n    mxCHAR_CLASS,    /* character array */\n    mxSPARSE_CLASS,    /* sparse array */\n    mxDOUBLE_CLASS,    /* double precision array */\n    mxSINGLE_CLASS,    /* single precision floating point */\n    mxINT8_CLASS,    /* 8 bit signed integer */\n    mxUINT8_CLASS,    /* 8 bit unsigned integer */\n    mxINT16_CLASS,    /* 16 bit signed integer */\n    mxUINT16_CLASS,    /* 16 bit unsigned integer */\n    mxINT32_CLASS,    /* 32 bit signed integer */\n    mxUINT32_CLASS,    /* 32 bit unsigned integer */\n    mxINT64_CLASS,    /* 64 bit signed integer */\n    mxUINT64_CLASS,    /* 64 bit unsigned integer */\n    mxFUNCTION_CLASS            /* Function handle */\n  } arrayclasstype;\n\n#define FLAG_COMPLEX 0x8\n#define FLAG_GLOBAL  0x4\n#define FLAG_LOGICAL 0x2\n\nstatic const QuantumType z2qtype[4] = {GrayQuantum, BlueQuantum, GreenQuantum, RedQuantum};\n\n\nstatic void InsertComplexDoubleRow(Image *image,double *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f + GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelBlue(image,q));\n      if (f+GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelRed(image,0,q);\n          SetPixelGreen(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q+=GetPixelChannels(image);\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\nstatic void InsertComplexFloatRow(Image *image,float *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q = QueueAuthenticPixels(image, 0, y, image->columns, 1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f+GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange - GetPixelBlue(image,q));\n      if (f + GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+\n          (int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelRed(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q++;\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\n/************** READERS ******************/\n\n/* This function reads one block of floats*/\nstatic void ReadBlobFloatsLSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobFloatsMSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* This function reads one block of doubles*/\nstatic void ReadBlobDoublesLSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobDoublesMSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* Calculate minimum and maximum from a given block of data */\nstatic void CalcMinMax(Image *image, int endian_indicator, int SizeX, int SizeY, size_t CellType, unsigned ldblk, void *BImgBuff, double *Min, double *Max)\n{\nMagickOffsetType filepos;\nint i, x;\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\ndouble *dblrow;\nfloat *fltrow;\n\n  if (endian_indicator == LSBEndian)\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n  }\n  else    /* MI */\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n  }\n\n  filepos = TellBlob(image);     /* Please note that file seeking occurs only in the case of doubles */\n  for (i = 0; i < SizeY; i++)\n  {\n    if (CellType==miDOUBLE)\n    {\n      ReadBlobDoublesXXX(image, ldblk, (double *)BImgBuff);\n      dblrow = (double *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *dblrow;\n      }\n      for (x = 0; x < SizeX; x++)\n      {\n        if (*Min > *dblrow)\n          *Min = *dblrow;\n        if (*Max < *dblrow)\n          *Max = *dblrow;\n        dblrow++;\n      }\n    }\n    if (CellType==miSINGLE)\n    {\n      ReadBlobFloatsXXX(image, ldblk, (float *)BImgBuff);\n      fltrow = (float *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *fltrow;\n      }\n    for (x = 0; x < (ssize_t) SizeX; x++)\n      {\n        if (*Min > *fltrow)\n          *Min = *fltrow;\n        if (*Max < *fltrow)\n          *Max = *fltrow;\n        fltrow++;\n      }\n    }\n  }\n  (void) SeekBlob(image, filepos, SEEK_SET);\n}\n\n\nstatic void FixSignedValues(const Image *image,Quantum *q, int y)\n{\n  while(y-->0)\n  {\n     /* Please note that negative values will overflow\n        Q=8; QuantumRange=255: <0;127> + 127+1 = <128; 255>\n           <-1;-128> + 127+1 = <0; 127> */\n    SetPixelRed(image,GetPixelRed(image,q)+QuantumRange/2+1,q);\n    SetPixelGreen(image,GetPixelGreen(image,q)+QuantumRange/2+1,q);\n    SetPixelBlue(image,GetPixelBlue(image,q)+QuantumRange/2+1,q);\n    q++;\n  }\n}\n\n\n/** Fix whole row of logical/binary data. It means pack it. */\nstatic void FixLogical(unsigned char *Buff,int ldblk)\n{\nunsigned char mask=128;\nunsigned char *BuffL = Buff;\nunsigned char val = 0;\n\n  while(ldblk-->0)\n  {\n    if(*Buff++ != 0)\n      val |= mask;\n\n    mask >>= 1;\n    if(mask==0)\n    {\n      *BuffL++ = val;\n      val = 0;\n      mask = 128;\n    }\n\n  }\n  *BuffL = val;\n}\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nstatic voidpf AcquireZIPMemory(voidpf context,unsigned int items,\n  unsigned int size)\n{\n  (void) context;\n  return((voidpf) AcquireQuantumMemory(items,size));\n}\n\nstatic void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n#endif\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n/** This procedure decompreses an image block for a new MATLAB format. */\nstatic Image *DecompressBlock(Image *orig, MagickOffsetType Size, ImageInfo *clone_info, ExceptionInfo *exception)\n{\n\nImage *image2;\nvoid *CacheBlock, *DecompressBlock;\nz_stream zip_info;\nFILE *mat_file;\nsize_t magick_size;\nsize_t extent;\nint file;\n\nint status;\nint zip_status;\n\n  if(clone_info==NULL) return NULL;\n  if(clone_info->file)    /* Close file opened from previous transaction. */\n  {\n    fclose(clone_info->file);\n    clone_info->file = NULL;\n    (void) remove_utf8(clone_info->filename);\n  }\n\n  CacheBlock = AcquireQuantumMemory((size_t)((Size<16384)?Size:16384),sizeof(unsigned char *));\n  if(CacheBlock==NULL) return NULL;\n  DecompressBlock = AcquireQuantumMemory((size_t)(4096),sizeof(unsigned char *));\n  if(DecompressBlock==NULL)\n  {\n    RelinquishMagickMemory(CacheBlock);\n    return NULL;\n  }\n\n  mat_file=0;\n  file = AcquireUniqueFileResource(clone_info->filename);\n  if (file != -1)\n    mat_file = fdopen(file,\"w\");\n  if(!mat_file)\n  {\n    RelinquishMagickMemory(CacheBlock);\n    RelinquishMagickMemory(DecompressBlock);\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Cannot create file stream for decompressed image\");\n    return NULL;\n  }\n\n  zip_info.zalloc=AcquireZIPMemory;\n  zip_info.zfree=RelinquishZIPMemory;\n  zip_info.opaque = (voidpf) NULL;\n  zip_status = inflateInit(&zip_info);\n  if (zip_status != Z_OK)\n    {\n      RelinquishMagickMemory(CacheBlock);\n      RelinquishMagickMemory(DecompressBlock);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnableToUncompressImage\",\"`%s'\",clone_info->filename);\n      (void) fclose(mat_file);\n      RelinquishUniqueFileResource(clone_info->filename);\n      return NULL;\n    }\n  /* zip_info.next_out = 8*4;*/\n\n  zip_info.avail_in = 0;\n  zip_info.total_out = 0;\n  while(Size>0 && !EOFBlob(orig))\n  {\n    magick_size = ReadBlob(orig, (Size<16384)?Size:16384, (unsigned char *) CacheBlock);\n    zip_info.next_in = (Bytef *) CacheBlock;\n    zip_info.avail_in = (uInt) magick_size;\n\n    while(zip_info.avail_in>0)\n    {\n      zip_info.avail_out = 4096;\n      zip_info.next_out = (Bytef *) DecompressBlock;\n      zip_status = inflate(&zip_info,Z_NO_FLUSH);\n      if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n        break;\n      extent=fwrite(DecompressBlock, 4096-zip_info.avail_out, 1, mat_file);\n      (void) extent;\n\n      if(zip_status == Z_STREAM_END) goto DblBreak;\n    }\n    if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n      break;\n\n    Size -= magick_size;\n  }\nDblBreak:\n\n  inflateEnd(&zip_info);\n  (void)fclose(mat_file);\n  RelinquishMagickMemory(CacheBlock);\n  RelinquishMagickMemory(DecompressBlock);\n\n  if((clone_info->file=fopen(clone_info->filename,\"rb\"))==NULL) goto UnlinkFile;\n  if( (image2 = AcquireImage(clone_info,exception))==NULL ) goto EraseFile;\n  status = OpenBlob(clone_info,image2,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    DeleteImageFromList(&image2);\nEraseFile:\n    fclose(clone_info->file);\n    clone_info->file = NULL;\nUnlinkFile:\n    RelinquishUniqueFileResource(clone_info->filename);\n    return NULL;\n  }\n\n  return image2;\n}\n#endif\n\nstatic Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return((Image *) NULL);\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    SetImageColorspace(image,GRAYColorspace,exception);\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      int\n        status;\n\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterMATImage adds attributes for the MAT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMATImage method is:\n%\n%      size_t RegisterMATImage(void)\n%\n*/\nModuleExport size_t RegisterMATImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAT\",\"MAT\",\"MATLAB level 5 image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMATImage;\n  entry->encoder=(EncodeImageHandler *) WriteMATImage;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterMATImage removes format registrations made by the\n%  MAT module from the list of supported formats.\n%\n%  The format of the UnregisterMATImage method is:\n%\n%      UnregisterMATImage(void)\n%\n*/\nModuleExport void UnregisterMATImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A T L A B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Function WriteMATImage writes an Matlab matrix to a file.\n%\n%  The format of the WriteMATImage method is:\n%\n%      MagickBooleanType WriteMATImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o image:  A pointer to an Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMATImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  ssize_t y;\n  unsigned z;\n  register const Quantum *p;\n\n  unsigned int status;\n  int logging;\n  size_t DataSize;\n  char padding;\n  char MATLAB_HDR[0x80];\n  time_t current_time;\n  struct tm local_time;\n  unsigned char *pixels;\n  int is_gray;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"enter MAT\");\n  (void) logging;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->depth=8;\n\n  current_time=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&current_time,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&current_time),sizeof(local_time));\n#endif\n  (void) memset(MATLAB_HDR,' ',MagickMin(sizeof(MATLAB_HDR),124));\n  FormatLocaleString(MATLAB_HDR,sizeof(MATLAB_HDR),\n    \"MATLAB 5.0 MAT-file, Platform: %s, Created on: %s %s %2d %2d:%2d:%2d %d\",\n    OsDesc,DayOfWTab[local_time.tm_wday],MonthsTab[local_time.tm_mon],\n    local_time.tm_mday,local_time.tm_hour,local_time.tm_min,\n    local_time.tm_sec,local_time.tm_year+1900);\n  MATLAB_HDR[0x7C]=0;\n  MATLAB_HDR[0x7D]=1;\n  MATLAB_HDR[0x7E]='I';\n  MATLAB_HDR[0x7F]='M';\n  (void) WriteBlob(image,sizeof(MATLAB_HDR),(unsigned char *) MATLAB_HDR);\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    is_gray = SetImageGray(image,exception);\n    z = is_gray ? 0 : 3;\n\n    /*\n      Store MAT header.\n    */\n    DataSize = image->rows /*Y*/ * image->columns /*X*/;\n    if(!is_gray) DataSize *= 3 /*Z*/;\n    padding=((unsigned char)(DataSize-1) & 0x7) ^ 0x7;\n\n    (void) WriteBlobLSBLong(image, miMATRIX);\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize+padding+(is_gray ? 48 : 56));\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x88 */\n    (void) WriteBlobLSBLong(image, 0x8); /* 0x8C */\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x90 */\n    (void) WriteBlobLSBLong(image, 0);\n    (void) WriteBlobLSBLong(image, 0x5); /* 0x98 */\n    (void) WriteBlobLSBLong(image, is_gray ? 0x8 : 0xC); /* 0x9C - DimFlag */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->rows);    /* x: 0xA0 */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->columns); /* y: 0xA4 */\n    if(!is_gray)\n    {\n      (void) WriteBlobLSBLong(image, 3); /* z: 0xA8 */\n      (void) WriteBlobLSBLong(image, 0);\n    }\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB0 */\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB2 */\n    (void) WriteBlobLSBLong(image, 'M'); /* 0xB4 */\n    (void) WriteBlobLSBLong(image, 0x2); /* 0xB8 */\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize); /* 0xBC */\n\n    /*\n      Store image data.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    do\n    {\n      for (y=0; y < (ssize_t)image->columns; y++)\n      {\n        p=GetVirtualPixels(image,y,0,1,image->rows,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          z2qtype[z],pixels,exception);\n        (void) WriteBlob(image,image->rows,pixels);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    } while(z-- >= 2);\n    while(padding-->0) (void) WriteBlobByte(image,0);\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                  M   M   AAA   TTTTT  L       AAA   BBBB                    %\n%                  MM MM  A   A    T    L      A   A  B   B                   %\n%                  M M M  AAAAA    T    L      AAAAA  BBBB                    %\n%                  M   M  A   A    T    L      A   A  B   B                   %\n%                  M   M  A   A    T    LLLLL  A   A  BBBB                    %\n%                                                                             %\n%                                                                             %\n%                        Read MATLAB Image Format                             %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                2001-2008                                    %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n #include \"zlib.h\"\n#endif\n\f\n/*\n  Forward declaration.\n*/\nstatic MagickBooleanType\n  WriteMATImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n\n/* Auto coloring method, sorry this creates some artefact inside data\nMinReal+j*MaxComplex = red  MaxReal+j*MaxComplex = black\nMinReal+j*0 = white          MaxReal+j*0 = black\nMinReal+j*MinComplex = blue  MaxReal+j*MinComplex = black\n*/\n\ntypedef struct\n{\n  char identific[124];\n  unsigned short Version;\n  char EndianIndicator[2];\n  unsigned long DataType;\n  unsigned long ObjectSize;\n  unsigned long unknown1;\n  unsigned long unknown2;\n\n  unsigned short unknown5;\n  unsigned char StructureFlag;\n  unsigned char StructureClass;\n  unsigned long unknown3;\n  unsigned long unknown4;\n  unsigned long DimFlag;\n\n  unsigned long SizeX;\n  unsigned long SizeY;\n  unsigned short Flag1;\n  unsigned short NameFlag;\n}\nMATHeader;\n\nstatic const char *MonthsTab[12]={\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nstatic const char *DayOfWTab[7]={\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"};\nstatic const char *OsDesc=\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    \"PCWIN\";\n#else\n #ifdef __APPLE__\n    \"MAC\";\n #else\n    \"LNX86\";\n #endif\n#endif\n\ntypedef enum\n  {\n    miINT8 = 1,      /* 8 bit signed */\n    miUINT8,      /* 8 bit unsigned */\n    miINT16,      /* 16 bit signed */\n    miUINT16,      /* 16 bit unsigned */\n    miINT32,      /* 32 bit signed */\n    miUINT32,      /* 32 bit unsigned */\n    miSINGLE,      /* IEEE 754 single precision float */\n    miRESERVE1,\n    miDOUBLE,      /* IEEE 754 double precision float */\n    miRESERVE2,\n    miRESERVE3,\n    miINT64,      /* 64 bit signed */\n    miUINT64,      /* 64 bit unsigned */\n    miMATRIX,            /* MATLAB array */\n    miCOMPRESSED,          /* Compressed Data */\n    miUTF8,            /* Unicode UTF-8 Encoded Character Data */\n    miUTF16,            /* Unicode UTF-16 Encoded Character Data */\n    miUTF32      /* Unicode UTF-32 Encoded Character Data */\n  } mat5_data_type;\n\ntypedef enum\n  {\n    mxCELL_CLASS=1,    /* cell array */\n    mxSTRUCT_CLASS,    /* structure */\n    mxOBJECT_CLASS,    /* object */\n    mxCHAR_CLASS,    /* character array */\n    mxSPARSE_CLASS,    /* sparse array */\n    mxDOUBLE_CLASS,    /* double precision array */\n    mxSINGLE_CLASS,    /* single precision floating point */\n    mxINT8_CLASS,    /* 8 bit signed integer */\n    mxUINT8_CLASS,    /* 8 bit unsigned integer */\n    mxINT16_CLASS,    /* 16 bit signed integer */\n    mxUINT16_CLASS,    /* 16 bit unsigned integer */\n    mxINT32_CLASS,    /* 32 bit signed integer */\n    mxUINT32_CLASS,    /* 32 bit unsigned integer */\n    mxINT64_CLASS,    /* 64 bit signed integer */\n    mxUINT64_CLASS,    /* 64 bit unsigned integer */\n    mxFUNCTION_CLASS            /* Function handle */\n  } arrayclasstype;\n\n#define FLAG_COMPLEX 0x8\n#define FLAG_GLOBAL  0x4\n#define FLAG_LOGICAL 0x2\n\nstatic const QuantumType z2qtype[4] = {GrayQuantum, BlueQuantum, GreenQuantum, RedQuantum};\n\n\nstatic void InsertComplexDoubleRow(Image *image,double *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f + GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelBlue(image,q));\n      if (f+GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelRed(image,0,q);\n          SetPixelGreen(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q+=GetPixelChannels(image);\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\nstatic void InsertComplexFloatRow(Image *image,float *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q = QueueAuthenticPixels(image, 0, y, image->columns, 1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f+GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange - GetPixelBlue(image,q));\n      if (f + GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+\n          (int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelRed(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q++;\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\n/************** READERS ******************/\n\n/* This function reads one block of floats*/\nstatic void ReadBlobFloatsLSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobFloatsMSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* This function reads one block of doubles*/\nstatic void ReadBlobDoublesLSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobDoublesMSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* Calculate minimum and maximum from a given block of data */\nstatic void CalcMinMax(Image *image, int endian_indicator, int SizeX, int SizeY, size_t CellType, unsigned ldblk, void *BImgBuff, double *Min, double *Max)\n{\nMagickOffsetType filepos;\nint i, x;\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\ndouble *dblrow;\nfloat *fltrow;\n\n  if (endian_indicator == LSBEndian)\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n  }\n  else    /* MI */\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n  }\n\n  filepos = TellBlob(image);     /* Please note that file seeking occurs only in the case of doubles */\n  for (i = 0; i < SizeY; i++)\n  {\n    if (CellType==miDOUBLE)\n    {\n      ReadBlobDoublesXXX(image, ldblk, (double *)BImgBuff);\n      dblrow = (double *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *dblrow;\n      }\n      for (x = 0; x < SizeX; x++)\n      {\n        if (*Min > *dblrow)\n          *Min = *dblrow;\n        if (*Max < *dblrow)\n          *Max = *dblrow;\n        dblrow++;\n      }\n    }\n    if (CellType==miSINGLE)\n    {\n      ReadBlobFloatsXXX(image, ldblk, (float *)BImgBuff);\n      fltrow = (float *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *fltrow;\n      }\n    for (x = 0; x < (ssize_t) SizeX; x++)\n      {\n        if (*Min > *fltrow)\n          *Min = *fltrow;\n        if (*Max < *fltrow)\n          *Max = *fltrow;\n        fltrow++;\n      }\n    }\n  }\n  (void) SeekBlob(image, filepos, SEEK_SET);\n}\n\n\nstatic void FixSignedValues(const Image *image,Quantum *q, int y)\n{\n  while(y-->0)\n  {\n     /* Please note that negative values will overflow\n        Q=8; QuantumRange=255: <0;127> + 127+1 = <128; 255>\n           <-1;-128> + 127+1 = <0; 127> */\n    SetPixelRed(image,GetPixelRed(image,q)+QuantumRange/2+1,q);\n    SetPixelGreen(image,GetPixelGreen(image,q)+QuantumRange/2+1,q);\n    SetPixelBlue(image,GetPixelBlue(image,q)+QuantumRange/2+1,q);\n    q++;\n  }\n}\n\n\n/** Fix whole row of logical/binary data. It means pack it. */\nstatic void FixLogical(unsigned char *Buff,int ldblk)\n{\nunsigned char mask=128;\nunsigned char *BuffL = Buff;\nunsigned char val = 0;\n\n  while(ldblk-->0)\n  {\n    if(*Buff++ != 0)\n      val |= mask;\n\n    mask >>= 1;\n    if(mask==0)\n    {\n      *BuffL++ = val;\n      val = 0;\n      mask = 128;\n    }\n\n  }\n  *BuffL = val;\n}\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nstatic voidpf AcquireZIPMemory(voidpf context,unsigned int items,\n  unsigned int size)\n{\n  (void) context;\n  return((voidpf) AcquireQuantumMemory(items,size));\n}\n\nstatic void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n#endif\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n/** This procedure decompreses an image block for a new MATLAB format. */\nstatic Image *DecompressBlock(Image *orig, MagickOffsetType Size, ImageInfo *clone_info, ExceptionInfo *exception)\n{\n\nImage *image2;\nvoid *CacheBlock, *DecompressBlock;\nz_stream zip_info;\nFILE *mat_file;\nsize_t magick_size;\nsize_t extent;\nint file;\n\nint status;\nint zip_status;\n\n  if(clone_info==NULL) return NULL;\n  if(clone_info->file)    /* Close file opened from previous transaction. */\n  {\n    fclose(clone_info->file);\n    clone_info->file = NULL;\n    (void) remove_utf8(clone_info->filename);\n  }\n\n  CacheBlock = AcquireQuantumMemory((size_t)((Size<16384)?Size:16384),sizeof(unsigned char *));\n  if(CacheBlock==NULL) return NULL;\n  DecompressBlock = AcquireQuantumMemory((size_t)(4096),sizeof(unsigned char *));\n  if(DecompressBlock==NULL)\n  {\n    RelinquishMagickMemory(CacheBlock);\n    return NULL;\n  }\n\n  mat_file=0;\n  file = AcquireUniqueFileResource(clone_info->filename);\n  if (file != -1)\n    mat_file = fdopen(file,\"w\");\n  if(!mat_file)\n  {\n    RelinquishMagickMemory(CacheBlock);\n    RelinquishMagickMemory(DecompressBlock);\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Cannot create file stream for decompressed image\");\n    return NULL;\n  }\n\n  zip_info.zalloc=AcquireZIPMemory;\n  zip_info.zfree=RelinquishZIPMemory;\n  zip_info.opaque = (voidpf) NULL;\n  zip_status = inflateInit(&zip_info);\n  if (zip_status != Z_OK)\n    {\n      RelinquishMagickMemory(CacheBlock);\n      RelinquishMagickMemory(DecompressBlock);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnableToUncompressImage\",\"`%s'\",clone_info->filename);\n      (void) fclose(mat_file);\n      RelinquishUniqueFileResource(clone_info->filename);\n      return NULL;\n    }\n  /* zip_info.next_out = 8*4;*/\n\n  zip_info.avail_in = 0;\n  zip_info.total_out = 0;\n  while(Size>0 && !EOFBlob(orig))\n  {\n    magick_size = ReadBlob(orig, (Size<16384)?Size:16384, (unsigned char *) CacheBlock);\n    zip_info.next_in = (Bytef *) CacheBlock;\n    zip_info.avail_in = (uInt) magick_size;\n\n    while(zip_info.avail_in>0)\n    {\n      zip_info.avail_out = 4096;\n      zip_info.next_out = (Bytef *) DecompressBlock;\n      zip_status = inflate(&zip_info,Z_NO_FLUSH);\n      if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n        break;\n      extent=fwrite(DecompressBlock, 4096-zip_info.avail_out, 1, mat_file);\n      (void) extent;\n\n      if(zip_status == Z_STREAM_END) goto DblBreak;\n    }\n    if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n      break;\n\n    Size -= magick_size;\n  }\nDblBreak:\n\n  inflateEnd(&zip_info);\n  (void)fclose(mat_file);\n  RelinquishMagickMemory(CacheBlock);\n  RelinquishMagickMemory(DecompressBlock);\n\n  if((clone_info->file=fopen(clone_info->filename,\"rb\"))==NULL) goto UnlinkFile;\n  if( (image2 = AcquireImage(clone_info,exception))==NULL ) goto EraseFile;\n  status = OpenBlob(clone_info,image2,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    DeleteImageFromList(&image2);\nEraseFile:\n    fclose(clone_info->file);\n    clone_info->file = NULL;\nUnlinkFile:\n    RelinquishUniqueFileResource(clone_info->filename);\n    return NULL;\n  }\n\n  return image2;\n}\n#endif\n\nstatic Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return((Image *) NULL);\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    SetImageColorspace(image,GRAYColorspace,exception);\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      int\n        status;\n\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterMATImage adds attributes for the MAT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMATImage method is:\n%\n%      size_t RegisterMATImage(void)\n%\n*/\nModuleExport size_t RegisterMATImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAT\",\"MAT\",\"MATLAB level 5 image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMATImage;\n  entry->encoder=(EncodeImageHandler *) WriteMATImage;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterMATImage removes format registrations made by the\n%  MAT module from the list of supported formats.\n%\n%  The format of the UnregisterMATImage method is:\n%\n%      UnregisterMATImage(void)\n%\n*/\nModuleExport void UnregisterMATImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A T L A B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Function WriteMATImage writes an Matlab matrix to a file.\n%\n%  The format of the WriteMATImage method is:\n%\n%      MagickBooleanType WriteMATImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o image:  A pointer to an Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMATImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  ssize_t y;\n  unsigned z;\n  register const Quantum *p;\n\n  unsigned int status;\n  int logging;\n  size_t DataSize;\n  char padding;\n  char MATLAB_HDR[0x80];\n  time_t current_time;\n  struct tm local_time;\n  unsigned char *pixels;\n  int is_gray;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"enter MAT\");\n  (void) logging;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->depth=8;\n\n  current_time=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&current_time,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&current_time),sizeof(local_time));\n#endif\n  (void) memset(MATLAB_HDR,' ',MagickMin(sizeof(MATLAB_HDR),124));\n  FormatLocaleString(MATLAB_HDR,sizeof(MATLAB_HDR),\n    \"MATLAB 5.0 MAT-file, Platform: %s, Created on: %s %s %2d %2d:%2d:%2d %d\",\n    OsDesc,DayOfWTab[local_time.tm_wday],MonthsTab[local_time.tm_mon],\n    local_time.tm_mday,local_time.tm_hour,local_time.tm_min,\n    local_time.tm_sec,local_time.tm_year+1900);\n  MATLAB_HDR[0x7C]=0;\n  MATLAB_HDR[0x7D]=1;\n  MATLAB_HDR[0x7E]='I';\n  MATLAB_HDR[0x7F]='M';\n  (void) WriteBlob(image,sizeof(MATLAB_HDR),(unsigned char *) MATLAB_HDR);\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    is_gray = SetImageGray(image,exception);\n    z = is_gray ? 0 : 3;\n\n    /*\n      Store MAT header.\n    */\n    DataSize = image->rows /*Y*/ * image->columns /*X*/;\n    if(!is_gray) DataSize *= 3 /*Z*/;\n    padding=((unsigned char)(DataSize-1) & 0x7) ^ 0x7;\n\n    (void) WriteBlobLSBLong(image, miMATRIX);\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize+padding+(is_gray ? 48 : 56));\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x88 */\n    (void) WriteBlobLSBLong(image, 0x8); /* 0x8C */\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x90 */\n    (void) WriteBlobLSBLong(image, 0);\n    (void) WriteBlobLSBLong(image, 0x5); /* 0x98 */\n    (void) WriteBlobLSBLong(image, is_gray ? 0x8 : 0xC); /* 0x9C - DimFlag */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->rows);    /* x: 0xA0 */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->columns); /* y: 0xA4 */\n    if(!is_gray)\n    {\n      (void) WriteBlobLSBLong(image, 3); /* z: 0xA8 */\n      (void) WriteBlobLSBLong(image, 0);\n    }\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB0 */\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB2 */\n    (void) WriteBlobLSBLong(image, 'M'); /* 0xB4 */\n    (void) WriteBlobLSBLong(image, 0x2); /* 0xB8 */\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize); /* 0xBC */\n\n    /*\n      Store image data.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    do\n    {\n      for (y=0; y < (ssize_t)image->columns; y++)\n      {\n        p=GetVirtualPixels(image,y,0,1,image->rows,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          z2qtype[z],pixels,exception);\n        (void) WriteBlob(image,image->rows,pixels);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    } while(z-- >= 2);\n    while(padding-->0) (void) WriteBlobByte(image,0);\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/mat.c"], "buggy_code_start_loc": [1128], "buggy_code_end_loc": [1128], "fixing_code_start_loc": [1129], "fixing_code_end_loc": [1130], "type": "CWE-200", "message": "In ImageMagick before 6.9.7-6 and 7.x before 7.0.4-6, the ReadMATImage function in coders/mat.c uses uninitialized data, which might allow remote attackers to obtain sensitive information from process memory.", "other": {"cve": {"id": "CVE-2017-13143", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-23T06:29:00.340", "lastModified": "2018-06-14T01:29:26.180", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In ImageMagick before 6.9.7-6 and 7.x before 7.0.4-6, the ReadMATImage function in coders/mat.c uses uninitialized data, which might allow remote attackers to obtain sensitive information from process memory."}, {"lang": "es", "value": "En ImageMagick en versiones anteriores a la 6.9.7-6 y 7.x en versiones anteriores a la 7.0.4-6, la funci\u00f3n ReadMATImage en coders/mat.c emplea datos sin inicializar, lo que podr\u00eda permitir que atacantes remotos obtengan informaci\u00f3n sensible de la memoria de proceso."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.7-5", "matchCriteriaId": "EBF81B46-43DA-40F9-9F40-061B613895FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-6:*:*:*:*:*:*:*", "matchCriteriaId": "E396985D-BE6A-4F4C-B294-FE69724534EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-7:*:*:*:*:*:*:*", "matchCriteriaId": "D1D84944-322C-4B5D-9B1C-587301747A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-9:*:*:*:*:*:*:*", "matchCriteriaId": "84C11EC2-C798-4C3B-8E00-9C70C3499B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-10:*:*:*:*:*:*:*", "matchCriteriaId": "D30A3BD6-5903-42D6-A1E3-C6D2FE468A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-0:*:*:*:*:*:*:*", "matchCriteriaId": "441F9FAE-11FA-4976-8BB3-4A3A79B57663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-1:*:*:*:*:*:*:*", "matchCriteriaId": "F4389D4A-8AD4-421E-AD4D-6761F45B7F6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-2:*:*:*:*:*:*:*", "matchCriteriaId": "1620AF57-49AF-4487-80A1-07627F50F817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-3:*:*:*:*:*:*:*", "matchCriteriaId": "DF373D13-0AB1-4518-AFFE-D09A5F56E992"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-4:*:*:*:*:*:*:*", "matchCriteriaId": "86483865-BFC3-4845-80DE-A6AC632A92A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-5:*:*:*:*:*:*:*", "matchCriteriaId": "2A147E12-E5D4-400E-9432-BB5BCF2352CE"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870012", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/51b0ae01709adc1e4a9245e158ef17b85a110960", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/362", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201711-07", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2017/dsa-4019", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4204", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/51b0ae01709adc1e4a9245e158ef17b85a110960"}}