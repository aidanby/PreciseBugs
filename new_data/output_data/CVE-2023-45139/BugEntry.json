{"buggy_code": ["from __future__ import annotations\n\nimport re\nfrom functools import lru_cache\nfrom itertools import chain, count\nfrom typing import Dict, Iterable, Iterator, List, Optional, Set, Tuple\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    # lxml is required for subsetting SVG, but we prefer to delay the import error\n    # until subset_glyphs() is called (i.e. if font to subset has an 'SVG ' table)\n    etree = None\n\nfrom fontTools import ttLib\nfrom fontTools.subset.util import _add_method\nfrom fontTools.ttLib.tables.S_V_G_ import SVGDocument\n\n\n__all__ = [\"subset_glyphs\"]\n\n\nGID_RE = re.compile(r\"^glyph(\\d+)$\")\n\nNAMESPACES = {\n    \"svg\": \"http://www.w3.org/2000/svg\",\n    \"xlink\": \"http://www.w3.org/1999/xlink\",\n}\nXLINK_HREF = f'{{{NAMESPACES[\"xlink\"]}}}href'\n\n\n# TODO(antrotype): Replace with functools.cache once we are 3.9+\n@lru_cache(maxsize=None)\ndef xpath(path):\n    # compile XPath upfront, caching result to reuse on multiple elements\n    return etree.XPath(path, namespaces=NAMESPACES)\n\n\ndef group_elements_by_id(tree: etree.Element) -> Dict[str, etree.Element]:\n    # select all svg elements with 'id' attribute no matter where they are\n    # including the root element itself:\n    # https://github.com/fonttools/fonttools/issues/2548\n    return {el.attrib[\"id\"]: el for el in xpath(\"//svg:*[@id]\")(tree)}\n\n\ndef parse_css_declarations(style_attr: str) -> Dict[str, str]:\n    # https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/style\n    # https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax#css_declarations\n    result = {}\n    for declaration in style_attr.split(\";\"):\n        if declaration.count(\":\") == 1:\n            property_name, value = declaration.split(\":\")\n            property_name = property_name.strip()\n            result[property_name] = value.strip()\n        elif declaration.strip():\n            raise ValueError(f\"Invalid CSS declaration syntax: {declaration}\")\n    return result\n\n\ndef iter_referenced_ids(tree: etree.Element) -> Iterator[str]:\n    # Yield all the ids that can be reached via references from this element tree.\n    # We currently support xlink:href (as used by <use> and gradient templates),\n    # and local url(#...) links found in fill or clip-path attributes\n    # TODO(anthrotype): Check we aren't missing other supported kinds of reference\n    find_svg_elements_with_references = xpath(\n        \".//svg:*[ \"\n        \"starts-with(@xlink:href, '#') \"\n        \"or starts-with(@fill, 'url(#') \"\n        \"or starts-with(@clip-path, 'url(#') \"\n        \"or contains(@style, ':url(#') \"\n        \"]\",\n    )\n    for el in chain([tree], find_svg_elements_with_references(tree)):\n        ref_id = href_local_target(el)\n        if ref_id is not None:\n            yield ref_id\n\n        attrs = el.attrib\n        if \"style\" in attrs:\n            attrs = {**dict(attrs), **parse_css_declarations(el.attrib[\"style\"])}\n        for attr in (\"fill\", \"clip-path\"):\n            if attr in attrs:\n                value = attrs[attr]\n                if value.startswith(\"url(#\") and value.endswith(\")\"):\n                    ref_id = value[5:-1]\n                    assert ref_id\n                    yield ref_id\n\n\ndef closure_element_ids(\n    elements: Dict[str, etree.Element], element_ids: Set[str]\n) -> None:\n    # Expand the initial subset of element ids to include ids that can be reached\n    # via references from the initial set.\n    unvisited = element_ids\n    while unvisited:\n        referenced: Set[str] = set()\n        for el_id in unvisited:\n            if el_id not in elements:\n                # ignore dangling reference; not our job to validate svg\n                continue\n            referenced.update(iter_referenced_ids(elements[el_id]))\n        referenced -= element_ids\n        element_ids.update(referenced)\n        unvisited = referenced\n\n\ndef subset_elements(el: etree.Element, retained_ids: Set[str]) -> bool:\n    # Keep elements if their id is in the subset, or any of their children's id is.\n    # Drop elements whose id is not in the subset, and either have no children,\n    # or all their children are being dropped.\n    if el.attrib.get(\"id\") in retained_ids:\n        # if id is in the set, don't recurse; keep whole subtree\n        return True\n    # recursively subset all the children; we use a list comprehension instead\n    # of a parentheses-less generator expression because we don't want any() to\n    # short-circuit, as our function has a side effect of dropping empty elements.\n    if any([subset_elements(e, retained_ids) for e in el]):\n        return True\n    assert len(el) == 0\n    parent = el.getparent()\n    if parent is not None:\n        parent.remove(el)\n    return False\n\n\ndef remap_glyph_ids(\n    svg: etree.Element, glyph_index_map: Dict[int, int]\n) -> Dict[str, str]:\n    # Given {old_gid: new_gid} map, rename all elements containing id=\"glyph{gid}\"\n    # special attributes\n    elements = group_elements_by_id(svg)\n    id_map = {}\n    for el_id, el in elements.items():\n        m = GID_RE.match(el_id)\n        if not m:\n            continue\n        old_index = int(m.group(1))\n        new_index = glyph_index_map.get(old_index)\n        if new_index is not None:\n            if old_index == new_index:\n                continue\n            new_id = f\"glyph{new_index}\"\n        else:\n            # If the old index is missing, the element correspond to a glyph that was\n            # excluded from the font's subset.\n            # We rename it to avoid clashes with the new GIDs or other element ids.\n            new_id = f\".{el_id}\"\n            n = count(1)\n            while new_id in elements:\n                new_id = f\"{new_id}.{next(n)}\"\n\n        id_map[el_id] = new_id\n        el.attrib[\"id\"] = new_id\n\n    return id_map\n\n\ndef href_local_target(el: etree.Element) -> Optional[str]:\n    if XLINK_HREF in el.attrib:\n        href = el.attrib[XLINK_HREF]\n        if href.startswith(\"#\") and len(href) > 1:\n            return href[1:]  # drop the leading #\n    return None\n\n\ndef update_glyph_href_links(svg: etree.Element, id_map: Dict[str, str]) -> None:\n    # update all xlink:href=\"#glyph...\" attributes to point to the new glyph ids\n    for el in xpath(\".//svg:*[starts-with(@xlink:href, '#glyph')]\")(svg):\n        old_id = href_local_target(el)\n        assert old_id is not None\n        if old_id in id_map:\n            new_id = id_map[old_id]\n            el.attrib[XLINK_HREF] = f\"#{new_id}\"\n\n\ndef ranges(ints: Iterable[int]) -> Iterator[Tuple[int, int]]:\n    # Yield sorted, non-overlapping (min, max) ranges of consecutive integers\n    sorted_ints = iter(sorted(set(ints)))\n    try:\n        start = end = next(sorted_ints)\n    except StopIteration:\n        return\n    for v in sorted_ints:\n        if v - 1 == end:\n            end = v\n        else:\n            yield (start, end)\n            start = end = v\n    yield (start, end)\n\n\n@_add_method(ttLib.getTableClass(\"SVG \"))\ndef subset_glyphs(self, s) -> bool:\n    if etree is None:\n        raise ImportError(\"No module named 'lxml', required to subset SVG\")\n\n    # glyph names (before subsetting)\n    glyph_order: List[str] = s.orig_glyph_order\n    # map from glyph names to original glyph indices\n    rev_orig_glyph_map: Dict[str, int] = s.reverseOrigGlyphMap\n    # map from original to new glyph indices (after subsetting)\n    glyph_index_map: Dict[int, int] = s.glyph_index_map\n\n    new_docs: List[SVGDocument] = []\n    for doc in self.docList:\n\n        glyphs = {\n            glyph_order[i] for i in range(doc.startGlyphID, doc.endGlyphID + 1)\n        }.intersection(s.glyphs)\n        if not glyphs:\n            # no intersection: we can drop the whole record\n            continue\n\n        svg = etree.fromstring(\n            # encode because fromstring dislikes xml encoding decl if input is str.\n            # SVG xml encoding must be utf-8 as per OT spec.\n            doc.data.encode(\"utf-8\"),\n            parser=etree.XMLParser(\n                # Disable libxml2 security restrictions to support very deep trees.\n                # Without this we would get an error like this:\n                # `lxml.etree.XMLSyntaxError: internal error: Huge input lookup`\n                # when parsing big fonts e.g. noto-emoji-picosvg.ttf.\n                huge_tree=True,\n                # ignore blank text as it's not meaningful in OT-SVG; it also prevents\n                # dangling tail text after removing an element when pretty_print=True\n                remove_blank_text=True,\n            ),\n        )\n\n        elements = group_elements_by_id(svg)\n        gids = {rev_orig_glyph_map[g] for g in glyphs}\n        element_ids = {f\"glyph{i}\" for i in gids}\n        closure_element_ids(elements, element_ids)\n\n        if not subset_elements(svg, element_ids):\n            continue\n\n        if not s.options.retain_gids:\n            id_map = remap_glyph_ids(svg, glyph_index_map)\n            update_glyph_href_links(svg, id_map)\n\n        new_doc = etree.tostring(svg, pretty_print=s.options.pretty_svg).decode(\"utf-8\")\n\n        new_gids = (glyph_index_map[i] for i in gids)\n        for start, end in ranges(new_gids):\n            new_docs.append(SVGDocument(new_doc, start, end, doc.compressed))\n\n    self.docList = new_docs\n\n    return bool(self.docList)\n"], "fixing_code": ["from __future__ import annotations\n\nimport re\nfrom functools import lru_cache\nfrom itertools import chain, count\nfrom typing import Dict, Iterable, Iterator, List, Optional, Set, Tuple\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    # lxml is required for subsetting SVG, but we prefer to delay the import error\n    # until subset_glyphs() is called (i.e. if font to subset has an 'SVG ' table)\n    etree = None\n\nfrom fontTools import ttLib\nfrom fontTools.subset.util import _add_method\nfrom fontTools.ttLib.tables.S_V_G_ import SVGDocument\n\n\n__all__ = [\"subset_glyphs\"]\n\n\nGID_RE = re.compile(r\"^glyph(\\d+)$\")\n\nNAMESPACES = {\n    \"svg\": \"http://www.w3.org/2000/svg\",\n    \"xlink\": \"http://www.w3.org/1999/xlink\",\n}\nXLINK_HREF = f'{{{NAMESPACES[\"xlink\"]}}}href'\n\n\n# TODO(antrotype): Replace with functools.cache once we are 3.9+\n@lru_cache(maxsize=None)\ndef xpath(path):\n    # compile XPath upfront, caching result to reuse on multiple elements\n    return etree.XPath(path, namespaces=NAMESPACES)\n\n\ndef group_elements_by_id(tree: etree.Element) -> Dict[str, etree.Element]:\n    # select all svg elements with 'id' attribute no matter where they are\n    # including the root element itself:\n    # https://github.com/fonttools/fonttools/issues/2548\n    return {el.attrib[\"id\"]: el for el in xpath(\"//svg:*[@id]\")(tree)}\n\n\ndef parse_css_declarations(style_attr: str) -> Dict[str, str]:\n    # https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/style\n    # https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax#css_declarations\n    result = {}\n    for declaration in style_attr.split(\";\"):\n        if declaration.count(\":\") == 1:\n            property_name, value = declaration.split(\":\")\n            property_name = property_name.strip()\n            result[property_name] = value.strip()\n        elif declaration.strip():\n            raise ValueError(f\"Invalid CSS declaration syntax: {declaration}\")\n    return result\n\n\ndef iter_referenced_ids(tree: etree.Element) -> Iterator[str]:\n    # Yield all the ids that can be reached via references from this element tree.\n    # We currently support xlink:href (as used by <use> and gradient templates),\n    # and local url(#...) links found in fill or clip-path attributes\n    # TODO(anthrotype): Check we aren't missing other supported kinds of reference\n    find_svg_elements_with_references = xpath(\n        \".//svg:*[ \"\n        \"starts-with(@xlink:href, '#') \"\n        \"or starts-with(@fill, 'url(#') \"\n        \"or starts-with(@clip-path, 'url(#') \"\n        \"or contains(@style, ':url(#') \"\n        \"]\",\n    )\n    for el in chain([tree], find_svg_elements_with_references(tree)):\n        ref_id = href_local_target(el)\n        if ref_id is not None:\n            yield ref_id\n\n        attrs = el.attrib\n        if \"style\" in attrs:\n            attrs = {**dict(attrs), **parse_css_declarations(el.attrib[\"style\"])}\n        for attr in (\"fill\", \"clip-path\"):\n            if attr in attrs:\n                value = attrs[attr]\n                if value.startswith(\"url(#\") and value.endswith(\")\"):\n                    ref_id = value[5:-1]\n                    assert ref_id\n                    yield ref_id\n\n\ndef closure_element_ids(\n    elements: Dict[str, etree.Element], element_ids: Set[str]\n) -> None:\n    # Expand the initial subset of element ids to include ids that can be reached\n    # via references from the initial set.\n    unvisited = element_ids\n    while unvisited:\n        referenced: Set[str] = set()\n        for el_id in unvisited:\n            if el_id not in elements:\n                # ignore dangling reference; not our job to validate svg\n                continue\n            referenced.update(iter_referenced_ids(elements[el_id]))\n        referenced -= element_ids\n        element_ids.update(referenced)\n        unvisited = referenced\n\n\ndef subset_elements(el: etree.Element, retained_ids: Set[str]) -> bool:\n    # Keep elements if their id is in the subset, or any of their children's id is.\n    # Drop elements whose id is not in the subset, and either have no children,\n    # or all their children are being dropped.\n    if el.attrib.get(\"id\") in retained_ids:\n        # if id is in the set, don't recurse; keep whole subtree\n        return True\n    # recursively subset all the children; we use a list comprehension instead\n    # of a parentheses-less generator expression because we don't want any() to\n    # short-circuit, as our function has a side effect of dropping empty elements.\n    if any([subset_elements(e, retained_ids) for e in el]):\n        return True\n    assert len(el) == 0\n    parent = el.getparent()\n    if parent is not None:\n        parent.remove(el)\n    return False\n\n\ndef remap_glyph_ids(\n    svg: etree.Element, glyph_index_map: Dict[int, int]\n) -> Dict[str, str]:\n    # Given {old_gid: new_gid} map, rename all elements containing id=\"glyph{gid}\"\n    # special attributes\n    elements = group_elements_by_id(svg)\n    id_map = {}\n    for el_id, el in elements.items():\n        m = GID_RE.match(el_id)\n        if not m:\n            continue\n        old_index = int(m.group(1))\n        new_index = glyph_index_map.get(old_index)\n        if new_index is not None:\n            if old_index == new_index:\n                continue\n            new_id = f\"glyph{new_index}\"\n        else:\n            # If the old index is missing, the element correspond to a glyph that was\n            # excluded from the font's subset.\n            # We rename it to avoid clashes with the new GIDs or other element ids.\n            new_id = f\".{el_id}\"\n            n = count(1)\n            while new_id in elements:\n                new_id = f\"{new_id}.{next(n)}\"\n\n        id_map[el_id] = new_id\n        el.attrib[\"id\"] = new_id\n\n    return id_map\n\n\ndef href_local_target(el: etree.Element) -> Optional[str]:\n    if XLINK_HREF in el.attrib:\n        href = el.attrib[XLINK_HREF]\n        if href.startswith(\"#\") and len(href) > 1:\n            return href[1:]  # drop the leading #\n    return None\n\n\ndef update_glyph_href_links(svg: etree.Element, id_map: Dict[str, str]) -> None:\n    # update all xlink:href=\"#glyph...\" attributes to point to the new glyph ids\n    for el in xpath(\".//svg:*[starts-with(@xlink:href, '#glyph')]\")(svg):\n        old_id = href_local_target(el)\n        assert old_id is not None\n        if old_id in id_map:\n            new_id = id_map[old_id]\n            el.attrib[XLINK_HREF] = f\"#{new_id}\"\n\n\ndef ranges(ints: Iterable[int]) -> Iterator[Tuple[int, int]]:\n    # Yield sorted, non-overlapping (min, max) ranges of consecutive integers\n    sorted_ints = iter(sorted(set(ints)))\n    try:\n        start = end = next(sorted_ints)\n    except StopIteration:\n        return\n    for v in sorted_ints:\n        if v - 1 == end:\n            end = v\n        else:\n            yield (start, end)\n            start = end = v\n    yield (start, end)\n\n\n@_add_method(ttLib.getTableClass(\"SVG \"))\ndef subset_glyphs(self, s) -> bool:\n    if etree is None:\n        raise ImportError(\"No module named 'lxml', required to subset SVG\")\n\n    # glyph names (before subsetting)\n    glyph_order: List[str] = s.orig_glyph_order\n    # map from glyph names to original glyph indices\n    rev_orig_glyph_map: Dict[str, int] = s.reverseOrigGlyphMap\n    # map from original to new glyph indices (after subsetting)\n    glyph_index_map: Dict[int, int] = s.glyph_index_map\n\n    new_docs: List[SVGDocument] = []\n    for doc in self.docList:\n\n        glyphs = {\n            glyph_order[i] for i in range(doc.startGlyphID, doc.endGlyphID + 1)\n        }.intersection(s.glyphs)\n        if not glyphs:\n            # no intersection: we can drop the whole record\n            continue\n\n        svg = etree.fromstring(\n            # encode because fromstring dislikes xml encoding decl if input is str.\n            # SVG xml encoding must be utf-8 as per OT spec.\n            doc.data.encode(\"utf-8\"),\n            parser=etree.XMLParser(\n                # Disable libxml2 security restrictions to support very deep trees.\n                # Without this we would get an error like this:\n                # `lxml.etree.XMLSyntaxError: internal error: Huge input lookup`\n                # when parsing big fonts e.g. noto-emoji-picosvg.ttf.\n                huge_tree=True,\n                # ignore blank text as it's not meaningful in OT-SVG; it also prevents\n                # dangling tail text after removing an element when pretty_print=True\n                remove_blank_text=True,\n                # don't replace entities; we don't expect any in OT-SVG and they may\n                # aboused for XXE attacks\n                resolve_entities=False,\n            ),\n        )\n\n        elements = group_elements_by_id(svg)\n        gids = {rev_orig_glyph_map[g] for g in glyphs}\n        element_ids = {f\"glyph{i}\" for i in gids}\n        closure_element_ids(elements, element_ids)\n\n        if not subset_elements(svg, element_ids):\n            continue\n\n        if not s.options.retain_gids:\n            id_map = remap_glyph_ids(svg, glyph_index_map)\n            update_glyph_href_links(svg, id_map)\n\n        new_doc = etree.tostring(svg, pretty_print=s.options.pretty_svg).decode(\"utf-8\")\n\n        new_gids = (glyph_index_map[i] for i in gids)\n        for start, end in ranges(new_gids):\n            new_docs.append(SVGDocument(new_doc, start, end, doc.compressed))\n\n    self.docList = new_docs\n\n    return bool(self.docList)\n"], "filenames": ["Lib/fontTools/subset/svg.py"], "buggy_code_start_loc": [227], "buggy_code_end_loc": [227], "fixing_code_start_loc": [228], "fixing_code_end_loc": [231], "type": "CWE-611", "message": "fontTools is a library for manipulating fonts, written in Python. The subsetting module has a XML External Entity Injection (XXE) vulnerability which allows an attacker to resolve arbitrary entities when a candidate font (OT-SVG fonts), which contains a SVG table, is parsed. This allows attackers to include arbitrary files from the filesystem fontTools is running on or make web requests from the host system. This vulnerability has been patched in version 4.43.0.", "other": {"cve": {"id": "CVE-2023-45139", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-10T16:15:46.767", "lastModified": "2024-01-25T02:15:52.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fontTools is a library for manipulating fonts, written in Python. The subsetting module has a XML External Entity Injection (XXE) vulnerability which allows an attacker to resolve arbitrary entities when a candidate font (OT-SVG fonts), which contains a SVG table, is parsed. This allows attackers to include arbitrary files from the filesystem fontTools is running on or make web requests from the host system. This vulnerability has been patched in version 4.43.0."}, {"lang": "es", "value": "fontTools es una librer\u00eda para manipular fuentes, escrita en Python. El m\u00f3dulo subsetting tiene una vulnerabilidad de inyecci\u00f3n de entidades externas XML (XXE) que permite a un atacante resolver entidades arbitrarias cuando se analiza una fuente candidata (fuentes OT-SVG), que contiene una tabla SVG. Esto permite a los atacantes incluir archivos arbitrarios del sistema de archivos en el que se ejecuta fontTools o realizar solicitudes web desde el sistema host. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 4.43.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fonttools:fonttools:*:*:*:*:*:python:*:*", "versionStartIncluding": "4.28.2", "versionEndExcluding": "4.43.0", "matchCriteriaId": "CA51147F-FB56-471F-AA46-967C55F0AE97"}]}]}], "references": [{"url": "https://github.com/fonttools/fonttools/commit/9f61271dc1ca82ed91f529b130fe5dc5c9bf1f4c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/fonttools/fonttools/releases/tag/4.43.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/fonttools/fonttools/security/advisories/GHSA-6673-4983-2vx5", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VY63B4SGY4QOQGUXMECRGD6K3YT3GJ75/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/fonttools/fonttools/commit/9f61271dc1ca82ed91f529b130fe5dc5c9bf1f4c"}}