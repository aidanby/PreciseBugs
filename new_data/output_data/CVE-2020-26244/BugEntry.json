{"buggy_code": ["import hashlib\nimport logging\nimport os\nimport warnings\nfrom base64 import b64encode\nfrom json import JSONDecodeError\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import Union\nfrom typing import cast\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlparse\n\nfrom jwkest import BadSyntax\nfrom jwkest import as_bytes\nfrom jwkest import jwe\nfrom jwkest import jws\nfrom jwkest import jwt\nfrom jwkest.jwe import JWE\nfrom requests import ConnectionError\n\nfrom oic import oauth2\nfrom oic import rndstr\nfrom oic.exception import AccessDenied\nfrom oic.exception import AuthnToOld\nfrom oic.exception import AuthzError\nfrom oic.exception import CommunicationError\nfrom oic.exception import MissingParameter\nfrom oic.exception import ParameterError\nfrom oic.exception import PyoidcError\nfrom oic.exception import RegistrationError\nfrom oic.exception import RequestError\nfrom oic.exception import SubMismatch\nfrom oic.oauth2 import HTTP_ARGS\nfrom oic.oauth2 import authz_error\nfrom oic.oauth2.consumer import ConfigurationError\nfrom oic.oauth2.exception import MissingRequiredAttribute\nfrom oic.oauth2.exception import OtherError\nfrom oic.oauth2.exception import ParseError\nfrom oic.oauth2.message import ErrorResponse\nfrom oic.oauth2.message import Message\nfrom oic.oauth2.message import MessageFactory\nfrom oic.oauth2.util import get_or_post\nfrom oic.oic.message import SCOPE2CLAIMS\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationErrorResponse\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import Claims\nfrom oic.oic.message import ClaimsRequest\nfrom oic.oic.message import ClientRegistrationErrorResponse\nfrom oic.oic.message import EndSessionRequest\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import JasonWebToken\nfrom oic.oic.message import OIDCMessageFactory\nfrom oic.oic.message import OpenIDRequest\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import RefreshSessionRequest\nfrom oic.oic.message import RegistrationRequest\nfrom oic.oic.message import RegistrationResponse\nfrom oic.oic.message import TokenErrorResponse\nfrom oic.oic.message import UserInfoErrorResponse\nfrom oic.oic.message import UserInfoRequest\nfrom oic.utils import time_util\nfrom oic.utils.http_util import Response\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.sanitize import sanitize\nfrom oic.utils.settings import OicClientSettings\nfrom oic.utils.settings import OicServerSettings\nfrom oic.utils.settings import PyoidcSettings\nfrom oic.utils.webfinger import OIC_ISSUER\nfrom oic.utils.webfinger import WebFinger\n\n__author__ = \"rohe0002\"\n\nlogger = logging.getLogger(__name__)\n\nENDPOINTS = [\n    \"authorization_endpoint\",\n    \"token_endpoint\",\n    \"userinfo_endpoint\",\n    \"refresh_session_endpoint\",\n    \"end_session_endpoint\",\n    \"registration_endpoint\",\n    \"check_id_endpoint\",\n]\n\nRESPONSE2ERROR: Dict[str, List] = {\n    \"AuthorizationResponse\": [AuthorizationErrorResponse, TokenErrorResponse],\n    \"AccessTokenResponse\": [TokenErrorResponse],\n    \"IdToken\": [ErrorResponse],\n    \"RegistrationResponse\": [ClientRegistrationErrorResponse],\n    \"OpenIDSchema\": [UserInfoErrorResponse],\n}\n\nREQUEST2ENDPOINT = {\n    \"AuthorizationRequest\": \"authorization_endpoint\",\n    \"OpenIDRequest\": \"authorization_endpoint\",\n    \"AccessTokenRequest\": \"token_endpoint\",\n    \"RefreshAccessTokenRequest\": \"token_endpoint\",\n    \"UserInfoRequest\": \"userinfo_endpoint\",\n    \"CheckSessionRequest\": \"check_session_endpoint\",\n    \"CheckIDRequest\": \"check_id_endpoint\",\n    \"EndSessionRequest\": \"end_session_endpoint\",\n    \"RefreshSessionRequest\": \"refresh_session_endpoint\",\n    \"RegistrationRequest\": \"registration_endpoint\",\n    \"RotateSecret\": \"registration_endpoint\",\n    # ---\n    \"ResourceRequest\": \"resource_endpoint\",\n    \"TokenIntrospectionRequest\": \"introspection_endpoint\",\n    \"TokenRevocationRequest\": \"revocation_endpoint\",\n    \"ROPCAccessTokenRequest\": \"token_endpoint\",\n}\n\n# -----------------------------------------------------------------------------\n\nJWT_BEARER = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\nSAML2_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:saml2-bearer\"\n\n# This should probably be part of the configuration\nMAX_AUTHENTICATION_AGE = 86400\nDEF_SIGN_ALG = {\n    \"id_token\": \"RS256\",\n    \"openid_request_object\": \"RS256\",\n    \"client_secret_jwt\": \"HS256\",\n    \"private_key_jwt\": \"RS256\",\n}\n\n# -----------------------------------------------------------------------------\nACR_LISTS = [[\"0\", \"1\", \"2\", \"3\", \"4\"]]\n\n\ndef verify_acr_level(req, level):\n    if req is None:\n        return level\n    elif \"values\" in req:\n        for _r in req[\"values\"]:\n            for alist in ACR_LISTS:\n                try:\n                    if alist.index(_r) <= alist.index(level):\n                        return level\n                except ValueError:\n                    pass\n    else:  # Required or Optional\n        return level\n\n    raise AccessDenied(\"\", req)\n\n\ndef deser_id_token(inst, txt=\"\"):\n    if not txt:\n        return None\n    else:\n        return IdToken().from_jwt(txt, keyjar=inst.keyjar)\n\n\n# -----------------------------------------------------------------------------\ndef make_openid_request(\n    arq,\n    keys=None,\n    userinfo_claims=None,\n    idtoken_claims=None,\n    request_object_signing_alg=None,\n    **kwargs,\n):\n    \"\"\"\n    Construct the specification of what I want returned.\n\n    The request will be signed.\n\n    :param arq: The Authorization request\n    :param keys: Keys to use for signing/encrypting\n    :param userinfo_claims: UserInfo claims\n    :param idtoken_claims: IdToken claims\n    :param request_object_signing_alg: Which signing algorithm to use\n    :return: JWT encoded OpenID request\n    \"\"\"\n    oir_args = {}\n    for prop in OpenIDRequest.c_param.keys():\n        try:\n            oir_args[prop] = arq[prop]\n        except KeyError:\n            pass\n\n    for attr in [\"scope\", \"response_type\"]:\n        if attr in oir_args:\n            oir_args[attr] = \" \".join(oir_args[attr])\n\n    c_args = {}\n    if userinfo_claims is not None:\n        # UserInfoClaims\n        c_args[\"userinfo\"] = Claims(**userinfo_claims)\n\n    if idtoken_claims is not None:\n        # IdTokenClaims\n        c_args[\"id_token\"] = Claims(**idtoken_claims)\n\n    if c_args:\n        oir_args[\"claims\"] = ClaimsRequest(**c_args)\n\n    oir = OpenIDRequest(**oir_args)\n\n    return oir.to_jwt(key=keys, algorithm=request_object_signing_alg)\n\n\nclass Token(oauth2.Token):\n    pass\n\n\nclass Grant(oauth2.Grant):\n    _authz_resp = AuthorizationResponse\n    _acc_resp = AccessTokenResponse\n    _token_class = Token\n\n    def add_token(self, resp):\n        tok = self._token_class(resp)\n        if tok.access_token:\n            self.tokens.append(tok)\n        else:\n            _tmp = getattr(tok, \"id_token\", None)\n            if _tmp:\n                self.tokens.append(tok)\n\n\nPREFERENCE2PROVIDER = {\n    \"request_object_signing_alg\": \"request_object_signing_alg_values_supported\",\n    \"request_object_encryption_alg\": \"request_object_encryption_alg_values_supported\",\n    \"request_object_encryption_enc\": \"request_object_encryption_enc_values_supported\",\n    \"userinfo_signed_response_alg\": \"userinfo_signing_alg_values_supported\",\n    \"userinfo_encrypted_response_alg\": \"userinfo_encryption_alg_values_supported\",\n    \"userinfo_encrypted_response_enc\": \"userinfo_encryption_enc_values_supported\",\n    \"id_token_signed_response_alg\": \"id_token_signing_alg_values_supported\",\n    \"id_token_encrypted_response_alg\": \"id_token_encryption_alg_values_supported\",\n    \"id_token_encrypted_response_enc\": \"id_token_encryption_enc_values_supported\",\n    \"default_acr_values\": \"acr_values_supported\",\n    \"subject_type\": \"subject_types_supported\",\n    \"token_endpoint_auth_method\": \"token_endpoint_auth_methods_supported\",\n    \"token_endpoint_auth_signing_alg\": \"token_endpoint_auth_signing_alg_values_supported\",\n    \"response_types\": \"response_types_supported\",\n    \"grant_types\": \"grant_types_supported\",\n}\n\nPROVIDER2PREFERENCE = dict([(v, k) for k, v in PREFERENCE2PROVIDER.items()])\n\nPROVIDER_DEFAULT = {\n    \"token_endpoint_auth_method\": \"client_secret_basic\",\n    \"id_token_signed_response_alg\": \"RS256\",\n}\n\nPARAMMAP = {\n    \"sign\": \"%s_signed_response_alg\",\n    \"alg\": \"%s_encrypted_response_alg\",\n    \"enc\": \"%s_encrypted_response_enc\",\n}\n\nrt2gt = {\n    \"code\": [\"authorization_code\"],\n    \"id_token\": [\"implicit\"],\n    \"id_token token\": [\"implicit\"],\n    \"code id_token\": [\"authorization_code\", \"implicit\"],\n    \"code token\": [\"authorization_code\", \"implicit\"],\n    \"code id_token token\": [\"authorization_code\", \"implicit\"],\n}\n\n\ndef response_types_to_grant_types(resp_types, **kwargs):\n    _res = set()\n\n    if \"grant_types\" in kwargs:\n        _res.update(set(kwargs[\"grant_types\"]))\n\n    for response_type in resp_types:\n        _rt = response_type.split(\" \")\n        _rt.sort()\n        try:\n            _gt = rt2gt[\" \".join(_rt)]\n        except KeyError:\n            raise ValueError(\"No such response type combination: {}\".format(resp_types))\n        else:\n            _res.update(set(_gt))\n\n    return list(_res)\n\n\ndef claims_match(value, claimspec):\n    \"\"\"\n    Implement matching according to section 5.5.1 of http://openid.net/specs/openid-connect-core-1_0.html.\n\n    The lack of value is not checked here.\n    Also the text doesn't prohibit having both 'value' and 'values'.\n\n    :param value: single value or list of values\n    :param claimspec: None or dictionary with 'essential', 'value' or 'values'\n    as key\n    :return: Boolean\n    \"\"\"\n    if claimspec is None:  # match anything\n        return True\n\n    matched = False\n    for key, val in claimspec.items():\n        if key == \"value\":\n            if value == val:\n                matched = True\n        elif key == \"values\":\n            if value in val:\n                matched = True\n        elif key == \"essential\":\n            # Whether it's essential or not doesn't change anything here\n            continue\n\n        if matched:\n            break\n\n    if matched is False:\n        if list(claimspec.keys()) == [\"essential\"]:\n            return True\n\n    return matched\n\n\nclass Client(oauth2.Client):\n    _endpoints = ENDPOINTS\n\n    def __init__(\n        self,\n        client_id=None,\n        client_prefs=None,\n        client_authn_method=None,\n        keyjar=None,\n        verify_ssl=None,\n        config=None,\n        client_cert=None,\n        requests_dir=\"requests\",\n        message_factory: Type[MessageFactory] = OIDCMessageFactory,\n        settings: PyoidcSettings = None,\n    ):\n        \"\"\"\n        Initialize the instance.\n\n        Keyword Args:\n            settings\n                Instance of :class:`OauthClientSettings` with configuration options.\n                Currently used settings are:\n                 - verify_ssl\n                 - client_cert\n                 - timeout\n        \"\"\"\n        self.settings = settings or OicClientSettings()\n        if verify_ssl is not None:\n            warnings.warn(\n                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.verify_ssl = verify_ssl\n        if client_cert is not None:\n            warnings.warn(\n                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.client_cert = client_cert\n        oauth2.Client.__init__(\n            self,\n            client_id,\n            client_authn_method=client_authn_method,\n            keyjar=keyjar,\n            config=config,\n            message_factory=message_factory,\n            settings=self.settings,\n        )\n\n        self.file_store = \"./file/\"\n        self.file_uri = \"http://localhost/\"\n        self.base_url = \"\"\n\n        # OpenID connect specific endpoints\n        for endpoint in ENDPOINTS:\n            setattr(self, endpoint, \"\")\n\n        self.id_token: Dict[str, Token] = {}\n        self.log = None\n\n        self.request2endpoint = REQUEST2ENDPOINT\n        self.response2error = RESPONSE2ERROR\n\n        self.grant_class = Grant\n        self.token_class = Token\n        self.provider_info = Message()\n        self.registration_response: RegistrationResponse = RegistrationResponse()\n        self.client_prefs = client_prefs or {}\n\n        self.behaviour: Dict[str, Any] = {}\n        self.scope = [\"openid\"]\n\n        self.wf = WebFinger(OIC_ISSUER)\n        self.wf.httpd = self\n        self.allow = {}\n        self.post_logout_redirect_uris: List[str] = []\n        self.registration_expires = 0\n        self.registration_access_token = None\n        self.id_token_max_age = 0\n\n        # Default key by kid for different key types\n        # For instance {'sig': {\"RSA\":\"abc\"}}\n        self.kid = {\"sig\": {}, \"enc\": {}}\n        self.requests_dir = requests_dir\n\n    def _get_id_token(self, **kwargs):\n        try:\n            return kwargs[\"id_token\"]\n        except KeyError:\n            grant = self.get_grant(**kwargs)\n\n        if grant:\n            try:\n                _scope = kwargs[\"scope\"]\n            except KeyError:\n                _scope = None\n\n            for token in grant.tokens:\n                if token.scope and _scope:\n                    flag = True\n                    for item in _scope:\n                        if item not in token.scope:\n                            flag = False\n                            break\n                    if not flag:\n                        break\n                if token.id_token:\n                    return token.id_token.jwt\n\n        return None\n\n    def request_object_encryption(self, msg, **kwargs):\n        try:\n            encalg = kwargs[\"request_object_encryption_alg\"]\n        except KeyError:\n            try:\n                encalg = self.behaviour[\"request_object_encryption_alg\"]\n            except KeyError:\n                return msg\n\n        try:\n            encenc = kwargs[\"request_object_encryption_enc\"]\n        except KeyError:\n            try:\n                encenc = self.behaviour[\"request_object_encryption_enc\"]\n            except KeyError:\n                raise MissingRequiredAttribute(\n                    \"No request_object_encryption_enc specified\"\n                )\n\n        _jwe = JWE(msg, alg=encalg, enc=encenc)\n        _kty = jwe.alg2keytype(encalg)\n\n        try:\n            _kid = kwargs[\"enc_kid\"]\n        except KeyError:\n            _kid = \"\"\n\n        if \"target\" not in kwargs:\n            raise MissingRequiredAttribute(\"No target specified\")\n\n        if _kid:\n            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"], kid=_kid)\n            _jwe[\"kid\"] = _kid\n        else:\n            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"])\n\n        return _jwe.encrypt(_keys)\n\n    @staticmethod\n    def construct_redirect_uri(**kwargs):\n        _filedir = kwargs[\"local_dir\"]\n        if not os.path.isdir(_filedir):\n            os.makedirs(_filedir)\n        _webpath = kwargs[\"base_path\"]\n        _name = rndstr(10) + \".jwt\"\n        filename = os.path.join(_filedir, _name)\n        while os.path.exists(filename):\n            _name = rndstr(10)\n            filename = os.path.join(_filedir, _name)\n        _webname = \"%s%s\" % (_webpath, _name)\n        return filename, _webname\n\n    def filename_from_webname(self, webname):\n        _filedir = self.requests_dir\n        if not os.path.isdir(_filedir):\n            os.makedirs(_filedir)\n\n        if webname.startswith(self.base_url):\n            return webname[len(self.base_url) :]\n        else:\n            raise ValueError(\"Invalid webname, must start with base_url\")\n\n    def construct_AuthorizationRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n\n        if request_args is not None:\n            if \"nonce\" not in request_args:\n                _rt = request_args[\"response_type\"]\n                if \"token\" in _rt or \"id_token\" in _rt:\n                    request_args[\"nonce\"] = rndstr(32)\n        elif \"response_type\" in kwargs:\n            if \"token\" in kwargs[\"response_type\"]:\n                request_args = {\"nonce\": rndstr(32)}\n        else:  # Never wrong to specify a nonce\n            request_args = {\"nonce\": rndstr(32)}\n\n        request_param = kwargs.get(\"request_param\")\n        if \"request_method\" in kwargs:\n            if kwargs[\"request_method\"] == \"file\":\n                request_param = \"request_uri\"\n            else:\n                request_param = \"request\"\n            del kwargs[\"request_method\"]\n\n        areq = super().construct_AuthorizationRequest(\n            request=request, request_args=request_args, extra_args=extra_args, **kwargs\n        )\n\n        if request_param:\n            alg = None\n            for arg in [\"request_object_signing_alg\", \"algorithm\"]:\n                try:  # Trumps everything\n                    alg = kwargs[arg]\n                except KeyError:\n                    pass\n                else:\n                    break\n\n            if not alg:\n                try:\n                    alg = self.behaviour[\"request_object_signing_alg\"]\n                except KeyError:\n                    alg = \"none\"\n\n            kwargs[\"request_object_signing_alg\"] = alg\n\n            if \"keys\" not in kwargs and alg and alg != \"none\":\n                _kty = jws.alg2keytype(alg)\n                try:\n                    _kid = kwargs[\"sig_kid\"]\n                except KeyError:\n                    _kid = self.kid[\"sig\"].get(_kty, None)\n\n                kwargs[\"keys\"] = self.keyjar.get_signing_key(_kty, kid=_kid)\n\n            _req = make_openid_request(areq, **kwargs)\n\n            # Should the request be encrypted\n            _req = self.request_object_encryption(_req, **kwargs)\n\n            if request_param == \"request\":\n                areq[\"request\"] = _req\n            else:\n                try:\n                    _webname = self.registration_response[\"request_uris\"][0]\n                    filename = self.filename_from_webname(_webname)\n                except KeyError:\n                    filename, _webname = self.construct_redirect_uri(**kwargs)\n                with open(filename, mode=\"w\") as fid:\n                    fid.write(_req)\n                areq[\"request_uri\"] = _webname\n\n        return areq\n\n    def construct_UserInfoRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n\n        if request is None:\n            request = self.message_factory.get_request_type(\"userinfo_endpoint\")\n        if request_args is None:\n            request_args = {}\n\n        if \"access_token\" in request_args:\n            pass\n        else:\n            if \"scope\" not in kwargs:\n                kwargs[\"scope\"] = \"openid\"\n            token = self.get_token(**kwargs)\n            if token is None:\n                raise MissingParameter(\"No valid token available\")\n\n            request_args[\"access_token\"] = token.access_token\n\n        return self.construct_request(request, request_args, extra_args)\n\n    def construct_RegistrationRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"registration_endpoint\")\n        return self.construct_request(request, request_args, extra_args)\n\n    def construct_RefreshSessionRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"refreshsession_endpoint\")\n        return self.construct_request(request, request_args, extra_args)\n\n    def _id_token_based(self, request, request_args=None, extra_args=None, **kwargs):\n\n        if request_args is None:\n            request_args = {}\n\n        try:\n            _prop = kwargs[\"prop\"]\n        except KeyError:\n            _prop = \"id_token\"\n\n        if _prop in request_args:\n            pass\n        else:\n            raw_id_token = self._get_id_token(**kwargs)\n            if raw_id_token is None:\n                raise MissingParameter(\"No valid id token available\")\n\n            request_args[_prop] = raw_id_token\n\n        return self.construct_request(request, request_args, extra_args)\n\n    def construct_CheckSessionRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"checksession_endpoint\")\n\n        return self._id_token_based(request, request_args, extra_args, **kwargs)\n\n    def construct_CheckIDRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"checkid_endpoint\")\n        # access_token is where the id_token will be placed\n        return self._id_token_based(\n            request, request_args, extra_args, prop=\"access_token\", **kwargs\n        )\n\n    def construct_EndSessionRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n\n        if request is None:\n            request = self.message_factory.get_request_type(\"endsession_endpoint\")\n        if request_args is None:\n            request_args = {}\n\n        if \"state\" in request_args and \"state\" not in kwargs:\n            kwargs[\"state\"] = request_args[\"state\"]\n\n        return self._id_token_based(request, request_args, extra_args, **kwargs)\n\n    def do_authorization_request(\n        self,\n        state=\"\",\n        body_type=\"\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n        **kwargs,\n    ):\n        algs = self.sign_enc_algs(\"id_token\")\n\n        if \"code_challenge\" in self.config:\n            _args, code_verifier = self.add_code_challenge()\n            request_args.update(_args)\n\n        return super().do_authorization_request(\n            state=state,\n            body_type=body_type,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            http_args=http_args,\n            algs=algs,\n        )\n\n    def do_access_token_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"POST\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n        authn_method=\"client_secret_basic\",\n        **kwargs,\n    ):\n        atr = super().do_access_token_request(\n            scope=scope,\n            state=state,\n            body_type=body_type,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            http_args=http_args,\n            authn_method=authn_method,\n            **kwargs,\n        )\n        try:\n            _idt = atr[\"id_token\"]\n        except KeyError:\n            pass\n        else:\n            try:\n                if self.state2nonce[state] != _idt[\"nonce\"]:\n                    raise ParameterError('Someone has messed with \"nonce\"')\n            except KeyError:\n                pass\n        return atr\n\n    def do_registration_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"POST\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n        request = self.message_factory.get_request_type(\"registration_endpoint\")\n        url, body, ht_args, csi = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        response_cls = self.message_factory.get_response_type(\"registration_endpoint\")\n        response = self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n        return response\n\n    def do_check_session_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n\n        request = self.message_factory.get_request_type(\"checksession_endpoint\")\n        response_cls = self.message_factory.get_response_type(\"checksession_endpoint\")\n\n        url, body, ht_args, csi = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        return self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n\n    def do_check_id_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n        request = self.message_factory.get_request_type(\"checkid_endpoint\")\n        response_cls = self.message_factory.get_response_type(\"checkid_endpoint\")\n\n        url, body, ht_args, csi = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        return self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n\n    def do_end_session_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n        request = self.message_factory.get_request_type(\"endsession_endpoint\")\n        response_cls = self.message_factory.get_response_type(\"endsession_endpoint\")\n        url, body, ht_args, _ = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        return self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n\n    def user_info_request(self, method=\"GET\", state=\"\", scope=\"\", **kwargs):\n        uir = self.message_factory.get_request_type(\"userinfo_endpoint\")()\n        logger.debug(\"[user_info_request]: kwargs:%s\" % (sanitize(kwargs),))\n        token: Optional[Token] = None\n        if \"token\" in kwargs:\n            if kwargs[\"token\"]:\n                uir[\"access_token\"] = kwargs[\"token\"]\n                token = Token()\n                token.token_type = \"Bearer\"\n                token.access_token = kwargs[\"token\"]\n                kwargs[\"behavior\"] = \"use_authorization_header\"\n            else:\n                # What to do ? Need a callback\n                pass\n        elif \"access_token\" in kwargs and kwargs[\"access_token\"]:\n            uir[\"access_token\"] = kwargs[\"access_token\"]\n            del kwargs[\"access_token\"]\n        elif state:\n            token = self.grant[state].get_token(scope)\n            if token is None:\n                raise AccessDenied(\"invalid_token\")\n            if token.is_valid():\n                uir[\"access_token\"] = token.access_token\n                if (\n                    token.token_type\n                    and token.token_type.lower() == \"bearer\"\n                    and method == \"GET\"\n                ):\n                    kwargs[\"behavior\"] = \"use_authorization_header\"\n            else:\n                # raise oauth2.OldAccessToken\n                if self.log:\n                    self.log.info(\"do access token refresh\")\n                try:\n                    self.do_access_token_refresh(token=token, state=state)\n                    token = cast(Token, self.grant[state].get_token(scope))\n                    uir[\"access_token\"] = token.access_token\n                except Exception:\n                    raise\n\n        uri = self._endpoint(\"userinfo_endpoint\", **kwargs)\n        # If access token is a bearer token it might be sent in the\n        # authorization header\n        # 4 ways of sending the access_token:\n        # - POST with token in authorization header\n        # - POST with token in message body\n        # - GET with token in authorization header\n        # - GET with token as query parameter\n        if \"behavior\" in kwargs:\n            _behav = kwargs[\"behavior\"]\n            _token = uir[\"access_token\"]\n            _ttype = \"\"\n            try:\n                _ttype = kwargs[\"token_type\"]\n            except KeyError:\n                if token:\n                    try:\n                        _ttype = cast(str, token.token_type)\n                    except AttributeError:\n                        raise MissingParameter(\"Unspecified token type\")\n\n            if \"as_query_parameter\" == _behav:\n                method = \"GET\"\n            elif token:\n                # use_authorization_header, token_in_message_body\n                if \"use_authorization_header\" in _behav:\n                    token_header = \"{type} {token}\".format(\n                        type=_ttype.capitalize(), token=_token\n                    )\n                    if \"headers\" in kwargs:\n                        kwargs[\"headers\"].update({\"Authorization\": token_header})\n                    else:\n                        kwargs[\"headers\"] = {\"Authorization\": token_header}\n\n                if \"token_in_message_body\" not in _behav:\n                    # remove the token from the request\n                    del uir[\"access_token\"]\n\n        path, body, kwargs = get_or_post(uri, method, uir, **kwargs)\n\n        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])\n\n        return path, body, method, h_args\n\n    def do_user_info_request(\n        self, method=\"POST\", state=\"\", scope=\"openid\", request=\"openid\", **kwargs\n    ):\n\n        kwargs[\"request\"] = request\n        path, body, method, h_args = self.user_info_request(\n            method, state, scope, **kwargs\n        )\n\n        logger.debug(\n            \"[do_user_info_request] PATH:%s BODY:%s H_ARGS: %s\"\n            % (sanitize(path), sanitize(body), sanitize(h_args))\n        )\n\n        if self.events:\n            self.events.store(\"Request\", {\"body\": body})\n            self.events.store(\"request_url\", path)\n            self.events.store(\"request_http_args\", h_args)\n\n        try:\n            resp = self.http_request(path, method, data=body, **h_args)\n        except oauth2.exception.MissingRequiredAttribute:\n            raise\n\n        if resp.status_code == 200:\n            if \"application/json\" in resp.headers[\"content-type\"]:\n                sformat = \"json\"\n            elif \"application/jwt\" in resp.headers[\"content-type\"]:\n                sformat = \"jwt\"\n            else:\n                raise PyoidcError(\n                    \"ERROR: Unexpected content-type: %s\" % resp.headers[\"content-type\"]\n                )\n        elif resp.status_code == 500:\n            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)\n        elif resp.status_code == 405:\n            # Method not allowed error\n            allowed_methods = [x.strip() for x in resp.headers[\"allow\"].split(\",\")]\n            raise CommunicationError(\n                \"Server responded with HTTP Error Code 405\", \"\", allowed_methods\n            )\n        elif 400 <= resp.status_code < 500:\n            # the response text might be a OIDC message\n            try:\n                res = ErrorResponse().from_json(resp.text)\n            except Exception:\n                raise RequestError(resp.text)\n            else:\n                self.store_response(res, resp.text)\n                return res\n        else:\n            raise PyoidcError(\n                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)\n            )\n\n        try:\n            _schema = kwargs[\"user_info_schema\"]\n        except KeyError:\n            _schema = OpenIDSchema\n\n        logger.debug(\"Reponse text: '%s'\" % sanitize(resp.text))\n\n        _txt = resp.text\n        if sformat == \"json\":\n            res = _schema().from_json(txt=_txt)\n        else:\n            verify = kwargs.get(\"verify\", True)\n            res = _schema().from_jwt(\n                _txt,\n                keyjar=self.keyjar,\n                sender=self.provider_info[\"issuer\"],\n                verify=verify,\n            )\n\n        if \"error\" in res:  # Error response\n            res = UserInfoErrorResponse(**res.to_dict())\n\n        if state:\n            # Verify userinfo sub claim against what's returned in the ID Token\n            idt = self.grant[state].get_id_token()\n            if idt:\n                if idt[\"sub\"] != res[\"sub\"]:\n                    raise SubMismatch(\n                        \"Sub identifier not the same in userinfo and Id Token\"\n                    )\n\n        self.store_response(res, _txt)\n\n        return res\n\n    def get_userinfo_claims(\n        self, access_token, endpoint, method=\"POST\", schema_class=OpenIDSchema, **kwargs\n    ):\n\n        uir = UserInfoRequest(access_token=access_token)\n\n        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])\n\n        if \"authn_method\" in kwargs:\n            http_args = self.init_authentication_method(**kwargs)\n        else:\n            # If nothing defined this is the default\n            http_args = self.init_authentication_method(uir, \"bearer_header\", **kwargs)\n\n        h_args.update(http_args)\n        path, body, kwargs = get_or_post(endpoint, method, uir, **kwargs)\n\n        try:\n            resp = self.http_request(path, method, data=body, **h_args)\n        except MissingRequiredAttribute:\n            raise\n\n        if resp.status_code == 200:\n            # FIXME: Could this also encounter application/jwt for encrypted userinfo\n            #        the do_userinfo_request method already handles it\n            if \"application/json\" not in resp.headers[\"content-type\"]:\n                raise PyoidcError(\n                    \"ERROR: content-type in response unexpected: %s\"\n                    % resp.headers[\"content-type\"]\n                )\n        elif resp.status_code == 500:\n            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)\n        else:\n            raise PyoidcError(\n                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)\n            )\n\n        res = schema_class().from_json(txt=resp.text)\n        self.store_response(res, resp.text)\n        return res\n\n    def unpack_aggregated_claims(self, userinfo):\n        if userinfo[\"_claim_sources\"]:\n            for csrc, spec in userinfo[\"_claim_sources\"].items():\n                if \"JWT\" in spec:\n                    aggregated_claims = Message().from_jwt(\n                        spec[\"JWT\"].encode(\"utf-8\"), keyjar=self.keyjar, sender=csrc\n                    )\n                    claims = [\n                        value\n                        for value, src in userinfo[\"_claim_names\"].items()\n                        if src == csrc\n                    ]\n\n                    if set(claims) != set(list(aggregated_claims.keys())):\n                        logger.warning(\n                            \"Claims from claim source doesn't match what's in \"\n                            \"the userinfo\"\n                        )\n\n                    for key, vals in aggregated_claims.items():\n                        userinfo[key] = vals\n\n        return userinfo\n\n    def fetch_distributed_claims(self, userinfo, callback=None):\n        for csrc, spec in userinfo[\"_claim_sources\"].items():\n            if \"endpoint\" in spec:\n                if not spec[\"endpoint\"].startswith(\"https://\"):\n                    logger.warning(\n                        \"Fetching distributed claims from an untrusted source: %s\",\n                        spec[\"endpoint\"],\n                    )\n                if \"access_token\" in spec:\n                    _uinfo = self.do_user_info_request(\n                        method=\"GET\",\n                        token=spec[\"access_token\"],\n                        userinfo_endpoint=spec[\"endpoint\"],\n                        verify=False,\n                    )\n                else:\n                    if callback:\n                        _uinfo = self.do_user_info_request(\n                            method=\"GET\",\n                            token=callback(spec[\"endpoint\"]),\n                            userinfo_endpoint=spec[\"endpoint\"],\n                            verify=False,\n                        )\n                    else:\n                        _uinfo = self.do_user_info_request(\n                            method=\"GET\",\n                            userinfo_endpoint=spec[\"endpoint\"],\n                            verify=False,\n                        )\n\n                claims = [\n                    value\n                    for value, src in userinfo[\"_claim_names\"].items()\n                    if src == csrc\n                ]\n\n                if set(claims) != set(list(_uinfo.keys())):\n                    logger.warning(\n                        \"Claims from claim source doesn't match what's in \"\n                        \"the userinfo\"\n                    )\n\n                for key, vals in _uinfo.items():\n                    userinfo[key] = vals\n\n        # Remove the `_claim_sources` and `_claim_names` from userinfo and better be safe than sorry\n        if \"_claim_sources\" in userinfo:\n            del userinfo[\"_claim_sources\"]\n        if \"_claim_names\" in userinfo:\n            del userinfo[\"_claim_names\"]\n        return userinfo\n\n    def verify_alg_support(self, alg, usage, other):\n        \"\"\"\n        Verify that the algorithm to be used are supported by the other side.\n\n        :param alg: The algorithm specification\n        :param usage: In which context the 'alg' will be used.\n            The following values are supported:\n            - userinfo\n            - id_token\n            - request_object\n            - token_endpoint_auth\n        :param other: The identifier for the other side\n        :return: True or False\n        \"\"\"\n        try:\n            _pcr = self.provider_info\n            supported = _pcr[\"%s_algs_supported\" % usage]\n        except KeyError:\n            try:\n                supported = getattr(self, \"%s_algs_supported\" % usage)\n            except AttributeError:\n                supported = None\n\n        if supported is None:\n            return True\n        else:\n            if alg in supported:\n                return True\n            else:\n                return False\n\n    def match_preferences(self, pcr=None, issuer=None):\n        \"\"\"\n        Match the clients preferences against what the provider can do.\n\n        :param pcr: Provider configuration response if available\n        :param issuer: The issuer identifier\n        \"\"\"\n        if not pcr:\n            pcr = self.provider_info\n\n        regreq = self.message_factory.get_request_type(\"registration_endpoint\")\n\n        for _pref, _prov in PREFERENCE2PROVIDER.items():\n            try:\n                vals = self.client_prefs[_pref]\n            except KeyError:\n                continue\n\n            try:\n                _pvals = pcr[_prov]\n            except KeyError:\n                try:\n                    self.behaviour[_pref] = PROVIDER_DEFAULT[_pref]\n                except KeyError:\n                    if isinstance(pcr.c_param[_prov][0], list):\n                        self.behaviour[_pref] = []\n                    else:\n                        self.behaviour[_pref] = None\n                continue\n\n            if isinstance(vals, str):\n                if vals in _pvals:\n                    self.behaviour[_pref] = vals\n            else:\n                vtyp = regreq.c_param[_pref]\n\n                if isinstance(vtyp[0], list):\n                    self.behaviour[_pref] = []\n                    for val in vals:\n                        if val in _pvals:\n                            self.behaviour[_pref].append(val)\n                else:\n                    for val in vals:\n                        if val in _pvals:\n                            self.behaviour[_pref] = val\n                            break\n\n            if _pref not in self.behaviour:\n                raise ConfigurationError(\"OP couldn't match preference:%s\" % _pref, pcr)\n\n        for key, val in self.client_prefs.items():\n            if key in self.behaviour:\n                continue\n\n            try:\n                vtyp = regreq.c_param[key]\n                if isinstance(vtyp[0], list):\n                    pass\n                elif isinstance(val, list) and not isinstance(val, str):\n                    val = val[0]\n            except KeyError:\n                pass\n            if key not in PREFERENCE2PROVIDER:\n                self.behaviour[key] = val\n\n    def store_registration_info(self, reginfo):\n        self.registration_response = reginfo\n        if \"token_endpoint_auth_method\" not in self.registration_response:\n            self.registration_response[\n                \"token_endpoint_auth_method\"  # nosec\n            ] = \"client_secret_basic\"\n        self.client_id = reginfo[\"client_id\"]\n        try:\n            self.client_secret = reginfo[\"client_secret\"]\n        except KeyError:  # Not required\n            pass\n        else:\n            try:\n                self.registration_expires = reginfo[\"client_secret_expires_at\"]\n            except KeyError:\n                pass\n        try:\n            self.registration_access_token = reginfo[\"registration_access_token\"]\n        except KeyError:\n            pass\n\n    def handle_registration_info(self, response):\n        err_msg = \"Got error response: {}\"\n        unk_msg = \"Unknown response: {}\"\n        if response.status_code in [200, 201]:\n            resp = self.message_factory.get_response_type(\n                \"registration_endpoint\"\n            )().deserialize(response.text, \"json\")\n            # Some implementations sends back a 200 with an error message inside\n            try:\n                resp.verify()\n            except oauth2.message.MissingRequiredAttribute as err:\n                logger.error(err)\n                raise RegistrationError(err)\n            except Exception:\n                resp = ErrorResponse().deserialize(response.text, \"json\")\n                if resp.verify():\n                    logger.error(err_msg.format(sanitize(resp.to_json())))\n                    if self.events:\n                        self.events.store(\"protocol response\", resp)\n                    raise RegistrationError(resp.to_dict())\n                else:  # Something else\n                    logger.error(unk_msg.format(sanitize(response.text)))\n                    raise RegistrationError(response.text)\n            else:\n                # got a proper registration response\n                self.store_response(resp, response.text)\n                self.store_registration_info(resp)\n        elif 400 <= response.status_code <= 499:\n            try:\n                resp = ErrorResponse().deserialize(response.text, \"json\")\n            except JSONDecodeError:\n                logger.error(unk_msg.format(sanitize(response.text)))\n                raise RegistrationError(response.text)\n\n            if resp.verify():\n                logger.error(err_msg.format(sanitize(resp.to_json())))\n                if self.events:\n                    self.events.store(\"protocol response\", resp)\n                raise RegistrationError(resp.to_dict())\n            else:  # Something else\n                logger.error(unk_msg.format(sanitize(response.text)))\n                raise RegistrationError(response.text)\n        else:\n            raise RegistrationError(response.text)\n\n        return resp\n\n    def registration_read(self, url=\"\", registration_access_token=None):\n        \"\"\"\n        Read the client registration info from the given url.\n\n        :raises RegistrationError: If an error happend\n        :return: RegistrationResponse\n        \"\"\"\n        if not url:\n            url = self.registration_response[\"registration_client_uri\"]\n\n        if not registration_access_token:\n            registration_access_token = self.registration_access_token\n\n        headers = {\"Authorization\": \"Bearer %s\" % registration_access_token}\n        rsp = self.http_request(url, \"GET\", headers=headers)\n\n        return self.handle_registration_info(rsp)\n\n    def generate_request_uris(self, request_dir):\n        \"\"\"\n        Need to generate a path that is unique for the OP combo.\n\n        :return: A list of uris\n        \"\"\"\n        m = hashlib.sha256()\n        m.update(as_bytes(self.provider_info[\"issuer\"]))\n        m.update(as_bytes(self.base_url))\n        return \"{}{}/{}\".format(self.base_url, request_dir, m.hexdigest())\n\n    def create_registration_request(self, **kwargs):\n        \"\"\"\n        Create a registration request.\n\n        :param kwargs: parameters to the registration request\n        :return:\n        \"\"\"\n        req = self.message_factory.get_request_type(\"registration_endpoint\")()\n\n        for prop in req.parameters():\n            try:\n                req[prop] = kwargs[prop]\n            except KeyError:\n                try:\n                    req[prop] = self.behaviour[prop]\n                except KeyError:\n                    pass\n\n        if \"post_logout_redirect_uris\" not in req:\n            try:\n                req[\"post_logout_redirect_uris\"] = self.post_logout_redirect_uris\n            except AttributeError:\n                pass\n\n        if \"redirect_uris\" not in req:\n            try:\n                req[\"redirect_uris\"] = self.redirect_uris\n            except AttributeError:\n                raise MissingRequiredAttribute(\"redirect_uris\", req)\n\n        try:\n            if self.provider_info[\"require_request_uri_registration\"] is True:\n                req[\"request_uris\"] = self.generate_request_uris(self.requests_dir)\n        except KeyError:\n            pass\n\n        if \"response_types\" in req:\n            req[\"grant_types\"] = response_types_to_grant_types(\n                req[\"response_types\"], **kwargs\n            )\n\n        return req\n\n    def register(self, url, registration_token=None, **kwargs):\n        \"\"\"\n        Register the client at an OP.\n\n        :param url: The OPs registration endpoint\n        :param registration_token: Initial Access Token for registration endpoint\n        :param kwargs: parameters to the registration request\n        :return:\n        \"\"\"\n        req = self.create_registration_request(**kwargs)\n\n        logger.debug(\"[registration_request]: kwargs:%s\" % (sanitize(kwargs),))\n\n        if self.events:\n            self.events.store(\"Protocol request\", req)\n\n        headers = {\"content-type\": \"application/json\"}\n        if registration_token is not None:\n            try:\n                token = jwt.JWT()\n                token.unpack(registration_token)\n            except BadSyntax:\n                # no JWT\n                registration_token = b64encode(registration_token.encode()).decode()\n            finally:\n                headers[\"Authorization\"] = \"Bearer \" + registration_token\n\n        rsp = self.http_request(url, \"POST\", data=req.to_json(), headers=headers)\n\n        return self.handle_registration_info(rsp)\n\n    def normalization(self, principal, idtype=\"mail\"):\n        if idtype == \"mail\":\n            (_, domain) = principal.split(\"@\")\n            subject = \"acct:%s\" % principal\n        elif idtype == \"url\":\n            p = urlparse(principal)\n            domain = p.netloc\n            subject = principal\n        else:\n            domain = \"\"\n            subject = principal\n\n        return subject, domain\n\n    def discover(self, principal, host=None):\n        return self.wf.discovery_query(principal, host=host)\n\n    def sign_enc_algs(self, typ):\n        resp = {}\n        for key, val in PARAMMAP.items():\n            try:\n                resp[key] = self.registration_response[val % typ]\n            except (TypeError, KeyError):\n                if key == \"sign\":\n                    resp[key] = DEF_SIGN_ALG[\"id_token\"]\n        return resp\n\n    def _verify_id_token(\n        self, id_token, nonce=\"\", acr_values=None, auth_time=0, max_age=0\n    ):\n        \"\"\"\n        Verify IdToken.\n\n        If the JWT alg Header Parameter uses a MAC based algorithm such as\n        HS256, HS384, or HS512, the octets of the UTF-8 representation of the\n        client_secret corresponding to the client_id contained in the aud\n        (audience) Claim are used as the key to validate the signature. For MAC\n        based algorithms, the behavior is unspecified if the aud is\n        multi-valued or if an azp value is present that is different than the\n        aud value.\n\n        :param id_token: The ID Token tp check\n        :param nonce: The nonce specified in the authorization request\n        :param acr_values: Asked for acr values\n        :param auth_time: An auth_time claim\n        :param max_age: Max age of authentication\n        \"\"\"\n        if self.provider_info[\"issuer\"] != id_token[\"iss\"]:\n            raise OtherError(\"issuer != iss\")\n\n        if self.client_id not in id_token[\"aud\"]:\n            raise OtherError(\"not intended for me\")\n        if len(id_token[\"aud\"]) > 1:\n            if \"azp\" not in id_token or id_token[\"azp\"] != self.client_id:\n                raise OtherError(\"not intended for me\")\n\n        _now = time_util.utc_time_sans_frac()\n\n        if _now > id_token[\"exp\"]:\n            raise OtherError(\"Passed best before date\")\n\n        if (\n            self.id_token_max_age\n            and _now > int(id_token[\"iat\"]) + self.id_token_max_age\n        ):\n            raise OtherError(\"I think this ID token is to old\")\n\n        if nonce and nonce != id_token[\"nonce\"]:\n            raise OtherError(\"nonce mismatch\")\n\n        if acr_values and id_token[\"acr\"] not in acr_values:\n            raise OtherError(\"acr mismatch\")\n\n        if max_age and _now > int(id_token[\"auth_time\"] + max_age):\n            raise AuthnToOld(\"To old authentication\")\n\n        if auth_time:\n            if not claims_match(id_token[\"auth_time\"], {\"auth_time\": auth_time}):\n                raise AuthnToOld(\"To old authentication\")\n\n    def verify_id_token(self, id_token, authn_req):\n        kwa = {}\n        try:\n            kwa[\"nonce\"] = authn_req[\"nonce\"]\n        except KeyError:\n            pass\n\n        for param in [\"acr_values\", \"max_age\"]:\n            try:\n                kwa[param] = authn_req[param]\n            except KeyError:\n                pass\n\n        self._verify_id_token(id_token, **kwa)\n\n\nclass Server(oauth2.Server):\n    \"\"\"OIC Server class.\"\"\"\n\n    def __init__(\n        self,\n        verify_ssl: bool = None,\n        keyjar: KeyJar = None,\n        client_cert: Union[str, Tuple[str, str]] = None,\n        timeout: float = None,\n        message_factory: Type[MessageFactory] = OIDCMessageFactory,\n        settings: PyoidcSettings = None,\n    ):\n        \"\"\"Initialize the server.\"\"\"\n        self.settings = settings or OicServerSettings()\n        if verify_ssl is not None:\n            warnings.warn(\n                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.verify_ssl = verify_ssl\n        if client_cert is not None:\n            warnings.warn(\n                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.client_cert = client_cert\n        if timeout is not None:\n            warnings.warn(\n                \"`timeout` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.timeout = timeout\n\n        super().__init__(\n            keyjar=keyjar,\n            message_factory=message_factory,\n            settings=self.settings,\n        )\n\n    @staticmethod\n    def _parse_urlencoded(url=None, query=None):\n        if url:\n            parts = urlparse(url)\n            scheme, netloc, path, params, query, fragment = parts[:6]\n\n        return parse_qs(query)\n\n    def handle_request_uri(self, request_uri, verify=True, sender=\"\"):\n        \"\"\"\n        Handle request URI.\n\n        :param request_uri: URL pointing to where the signed request should be fetched from.\n        :param verify: Whether the signature on the request should be verified.\n        Don't use anything but the default unless you REALLY know what you're doing\n        :param sender: The issuer of the request JWT.\n        :return:\n        \"\"\"\n        # Do a HTTP get\n        logger.debug(\"Get request from request_uri: {}\".format(request_uri))\n        try:\n            http_req = self.http_request(request_uri)\n        except ConnectionError:\n            logger.error(\"Connection Error\")\n            return authz_error(\"invalid_request_uri\")\n\n        if not http_req:\n            logger.error(\"Nothing returned\")\n            return authz_error(\"invalid_request_uri\")\n        elif http_req.status_code >= 400:\n            logger.error(\"HTTP error {}:{}\".format(http_req.status_code, http_req.text))\n            raise AuthzError(\"invalid_request\")\n\n        # http_req.text is a signed JWT\n        try:\n            logger.debug(\"request txt: {}\".format(http_req.text))\n            req = self.parse_jwt_request(\n                txt=http_req.text, verify=verify, sender=sender\n            )\n        except Exception as err:\n            logger.error(\n                \"{}:{} encountered while parsing fetched request\".format(\n                    err.__class__, err\n                )\n            )\n            raise AuthzError(\"invalid_openid_request_object\")\n\n        logger.debug(\"Fetched request: {}\".format(req))\n        return req\n\n    def parse_authorization_request(\n        self, request=AuthorizationRequest, url=None, query=None, keys=None\n    ):\n        if url:\n            parts = urlparse(url)\n            scheme, netloc, path, params, query, fragment = parts[:6]\n\n        if isinstance(query, dict):\n            sformat = \"dict\"\n        else:\n            sformat = \"urlencoded\"\n\n        _req = self._parse_request(request, query, sformat, verify=False)\n\n        if self.events:\n            self.events.store(\"Request\", _req)\n\n        _req_req: Union[Message, Dict[str, Any]] = {}\n        try:\n            _request = _req[\"request\"]\n        except KeyError:\n            try:\n                _url = _req[\"request_uri\"]\n            except KeyError:\n                pass\n            else:\n                _req_req = self.handle_request_uri(\n                    _url, verify=False, sender=_req[\"client_id\"]\n                )\n        else:\n            if isinstance(_request, Message):\n                _req_req = _request\n            else:\n                try:\n                    _req_req = self.parse_jwt_request(\n                        request, txt=_request, verify=False\n                    )\n                except Exception:\n                    _req_req = self._parse_request(\n                        request, _request, \"urlencoded\", verify=False\n                    )\n                else:  # remove JWT attributes\n                    for attr in JasonWebToken.c_param:\n                        try:\n                            del _req_req[attr]\n                        except KeyError:\n                            pass\n\n        if isinstance(_req_req, Response):\n            return _req_req\n\n        if _req_req:\n            if self.events:\n                self.events.store(\"Signed Request\", _req_req)\n\n            for key, val in _req.items():\n                if key in [\"request\", \"request_uri\"]:\n                    continue\n                if key not in _req_req:\n                    _req_req[key] = val\n            _req = _req_req\n\n        if self.events:\n            self.events.store(\"Combined Request\", _req)\n\n        try:\n            _req.verify(keyjar=self.keyjar)\n        except Exception as err:\n            if self.events:\n                self.events.store(\"Exception\", err)\n            logger.error(err)\n            raise\n\n        return _req\n\n    def parse_jwt_request(\n        self,\n        request=AuthorizationRequest,\n        txt=\"\",\n        keyjar=None,\n        verify=True,\n        sender=\"\",\n        **kwargs,\n    ):\n        \"\"\"Overridden to use OIC Message type.\"\"\"\n        if \"keys\" in kwargs:\n            keyjar = kwargs[\"keys\"]\n            warnings.warn(\n                \"`keys` was renamed to `keyjar`, please update your code.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        return super().parse_jwt_request(\n            request=request, txt=txt, keyjar=keyjar, verify=verify, sender=sender\n        )\n\n    def parse_check_session_request(self, url=None, query=None):\n        param = self._parse_urlencoded(url, query)\n        assert \"id_token\" in param  # nosec, ignore the rest\n        return deser_id_token(self, param[\"id_token\"][0])\n\n    def parse_check_id_request(self, url=None, query=None):\n        param = self._parse_urlencoded(url, query)\n        assert \"access_token\" in param  # nosec, ignore the rest\n        return deser_id_token(self, param[\"access_token\"][0])\n\n    def _parse_request(self, request_cls, data, sformat, client_id=None, verify=True):\n        if sformat == \"json\":\n            request = request_cls().from_json(data)\n        elif sformat == \"jwt\":\n            request = request_cls().from_jwt(data, keyjar=self.keyjar, sender=client_id)\n        elif sformat == \"urlencoded\":\n            if \"?\" in data:\n                parts = urlparse(data)\n                scheme, netloc, path, params, query, fragment = parts[:6]\n            else:\n                query = data\n            request = request_cls().from_urlencoded(query)\n        elif sformat == \"dict\":\n            request = request_cls(**data)\n        else:\n            raise ParseError(\n                \"Unknown package format: '{}'\".format(sformat), request_cls\n            )\n\n        # get the verification keys\n        if client_id:\n            keys = self.keyjar.verify_keys(client_id)\n            sender = client_id\n        else:\n            try:\n                keys = self.keyjar.verify_keys(request[\"client_id\"])\n                sender = request[\"client_id\"]\n            except KeyError:\n                keys = None\n                sender = \"\"\n\n        logger.debug(\"Found {} verify keys\".format(len(keys or \"\")))\n        if verify:\n            request.verify(key=keys, keyjar=self.keyjar, sender=sender)\n        return request\n\n    def parse_open_id_request(self, data, sformat=\"urlencoded\", client_id=None):\n        return self._parse_request(OpenIDRequest, data, sformat, client_id)\n\n    def parse_user_info_request(self, data, sformat=\"urlencoded\"):\n        return self._parse_request(UserInfoRequest, data, sformat)\n\n    def parse_userinfo_request(self, data, sformat=\"urlencoded\"):\n        return self._parse_request(UserInfoRequest, data, sformat)\n\n    def parse_refresh_session_request(self, url=None, query=None):\n        if url:\n            parts = urlparse(url)\n            query = parts.query\n        return RefreshSessionRequest().from_urlencoded(query)\n\n    def parse_registration_request(self, data, sformat=\"urlencoded\"):\n        return self._parse_request(RegistrationRequest, data, sformat)\n\n    def parse_end_session_request(self, query, sformat=\"urlencoded\"):\n        esr = self._parse_request(EndSessionRequest, query, sformat)\n        # if there is a id_token in there it is as a string\n        esr[\"id_token\"] = deser_id_token(self, esr[\"id_token\"])\n        return esr\n\n    @staticmethod\n    def update_claims(session, where, about, old_claims=None):\n        \"\"\"\n        Update claims dictionary.\n\n        :param session:\n        :param where: Which request\n        :param about: userinfo or id_token\n        :param old_claims:\n        :return: claims or None\n        \"\"\"\n        if old_claims is None:\n            old_claims = {}\n\n        req = None\n        if where == \"oidreq\":\n            try:\n                req = OpenIDRequest().deserialize(session[where], \"json\")\n            except KeyError:\n                pass\n        else:  # where == \"authzreq\"\n            try:\n                req = AuthorizationRequest().deserialize(session[where], \"json\")\n            except KeyError:\n                pass\n\n        if req:\n            logger.debug(\"%s: %s\" % (where, sanitize(req.to_dict())))\n            try:\n                _claims = req[\"claims\"][about]\n                if _claims:\n                    # update with old claims, do not overwrite\n                    for key, val in old_claims.items():\n                        if key not in _claims:\n                            _claims[key] = val\n                    return _claims\n            except KeyError:\n                pass\n\n        return old_claims\n\n    def id_token_claims(self, session):\n        \"\"\"\n        Pick the IdToken claims from the request.\n\n        :param session: Session information\n        :return: The IdToken claims\n        \"\"\"\n        itc: Dict[str, str] = {}\n        itc = self.update_claims(session, \"authzreq\", \"id_token\", itc)\n        itc = self.update_claims(session, \"oidreq\", \"id_token\", itc)\n        return itc\n\n    def make_id_token(\n        self,\n        session,\n        loa=\"2\",\n        issuer=\"\",\n        alg=\"RS256\",\n        code=None,\n        access_token=None,\n        user_info=None,\n        auth_time=0,\n        exp=None,\n        extra_claims=None,\n    ):\n        \"\"\"\n        Create ID Token.\n\n        :param session: Session information\n        :param loa: Level of Assurance/Authentication context\n        :param issuer: My identifier\n        :param alg: Which signing algorithm to use for the IdToken\n        :param code: Access grant\n        :param access_token: Access Token\n        :param user_info: If user info are to be part of the IdToken\n        :return: IDToken instance\n        \"\"\"\n        # defaults\n        if exp is None:\n            inawhile = {\"days\": 1}\n        else:\n            inawhile = exp\n        # Handle the idtoken_claims\n        extra = {}\n        itc = self.id_token_claims(session)\n        if itc.keys():\n            try:\n                inawhile = {\"seconds\": itc[\"max_age\"]}\n            except KeyError:\n                pass\n            for key, val in itc.items():\n                if key == \"auth_time\":\n                    extra[\"auth_time\"] = auth_time\n                elif key == \"acr\":\n                    extra[\"acr\"] = verify_acr_level(val, loa)\n        else:\n            if auth_time:\n                extra[\"auth_time\"] = auth_time\n            if loa:\n                extra[\"acr\"] = loa\n\n        if not user_info:\n            _args: Dict[str, str] = {}\n        else:\n            try:\n                _args = user_info.to_dict()\n            except AttributeError:\n                _args = user_info\n\n        # Make sure that there are no name clashes\n        for key in [\"iss\", \"sub\", \"aud\", \"exp\", \"acr\", \"nonce\", \"auth_time\"]:\n            try:\n                del _args[key]\n            except KeyError:\n                pass\n\n        halg = \"HS%s\" % alg[-3:]\n\n        if extra_claims is not None:\n            _args.update(extra_claims)\n        if code:\n            _args[\"c_hash\"] = jws.left_hash(code.encode(\"utf-8\"), halg)\n        if access_token:\n            _args[\"at_hash\"] = jws.left_hash(access_token.encode(\"utf-8\"), halg)\n\n        idt = IdToken(\n            iss=issuer,\n            sub=session[\"sub\"],\n            aud=session[\"client_id\"],\n            exp=time_util.epoch_in_a_while(**inawhile),\n            acr=loa,\n            iat=time_util.utc_time_sans_frac(),\n            **_args,\n        )\n\n        for key, val in extra.items():\n            idt[key] = val\n\n        if \"nonce\" in session:\n            idt[\"nonce\"] = session[\"nonce\"]\n\n        return idt\n\n\ndef scope2claims(scopes, extra_scope_dict=None):\n    res: Dict[str, None] = {}\n    # Construct the scope translation map\n    trans_map: Dict[str, Any] = SCOPE2CLAIMS.copy()\n    if extra_scope_dict is not None:\n        trans_map.update(extra_scope_dict)\n    for scope in scopes:\n        try:\n            claims = dict([(name, None) for name in trans_map[scope]])\n            res.update(claims)\n        except KeyError:\n            continue\n    return res\n", "import logging\nimport os.path\nimport warnings\nfrom typing import Dict\nfrom typing import Optional\n\nfrom oic import rndstr\nfrom oic.exception import AuthzError\nfrom oic.exception import MessageException\nfrom oic.exception import NotForMe\nfrom oic.exception import PyoidcError\nfrom oic.oauth2 import Grant\nfrom oic.oauth2.consumer import TokenError\nfrom oic.oauth2.consumer import UnknownState\nfrom oic.oauth2.consumer import stateID\nfrom oic.oauth2.message import ErrorResponse\nfrom oic.oic import ENDPOINTS\nfrom oic.oic import Client\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import BackChannelLogoutRequest\nfrom oic.oic.message import Claims\nfrom oic.oic.message import ClaimsRequest\nfrom oic.utils import http_util\nfrom oic.utils.sanitize import sanitize\nfrom oic.utils.sdb import DictSessionBackend\nfrom oic.utils.sdb import SessionBackend\nfrom oic.utils.sdb import session_extended_get\nfrom oic.utils.sdb import session_get\nfrom oic.utils.sdb import session_update\n\n__author__ = \"rohe0002\"\n\nlogger = logging.getLogger(__name__)\n\n\ndef factory(kaka, sdb, config):\n    \"\"\"\n    Return the right Consumer instance dependent on what's in the cookie.\n\n    :param kaka: The cookie\n    :param sdb: The session database\n    :param config: The common Consumer configuration\n    :return: Consumer instance or None\n    \"\"\"\n    part = http_util.cookie_parts(config[\"name\"], kaka)\n    if part is None:\n        return None\n\n    cons = Consumer(sdb, config)\n    cons.restore(part[0])\n    http_util.parse_cookie(config[\"name\"], cons.seed, kaka)\n    return cons\n\n\ndef build_userinfo_claims(claims, sformat=\"signed\", locale=\"us-en\"):\n    \"\"\"\n    Create userinfo request based on claims.\n\n    config example::\n\n        \"userinfo\":{\n            \"name\": {\"essential\": true},\n            \"nickname\": null,\n            \"email\": {\"essential\": true},\n            \"email_verified\": {\"essential\": true},\n            \"picture\": null\n        }\n    \"\"\"\n    return Claims(format=sformat, **claims)\n\n\ndef clean_response(aresp):\n    \"\"\"\n    Create a new instance with only the standard attributes.\n\n    :param aresp: The original AccessTokenResponse\n    :return: An AccessTokenResponse instance\n    \"\"\"\n    atr = AccessTokenResponse()\n    for prop in atr.parameters():\n        try:\n            atr[prop] = aresp[prop]\n        except KeyError:\n            pass\n\n    return atr\n\n\nIGNORE = [\n    \"request2endpoint\",\n    \"response2error\",\n    \"grant_class\",\n    \"token_class\",\n    \"sdb\",\n    \"wf\",\n    \"events\",\n    \"message_factory\",\n]\n\nCONSUMER_PREF_ARGS = [\n    \"token_endpoint_auth_method\",\n    \"subject_type\",\n    \"require_signed_request_object\",\n    \"userinfo_signed_response_algs\",\n    \"userinfo_encrypted_response_alg\",\n    \"userinfo_encrypted_response_enc\",\n    \"userinfo_encrypted_response_int\",\n    \"id_token_signed_response_algs\",\n    \"id_token_encrypted_response_alg\",\n    \"id_token_encrypted_response_enc\",\n    \"id_token_encrypted_response_int\",\n    \"request_object_signing_alg\",\n    \"request_object_encryption_alg\",\n    \"request_object_encryption_enc\",\n    \"default_max_age\",\n    \"require_auth_time\",\n    \"default_acr_values\",\n]\n\n\nclass Consumer(Client):\n    \"\"\"An OpenID Connect consumer implementation.\"\"\"\n\n    def __init__(\n        self,\n        session_db,\n        consumer_config,\n        client_config=None,\n        server_info=None,\n        debug=False,\n        client_prefs=None,\n        sso_db=None,\n    ):\n        \"\"\"\n        Initialize a Consumer instance.\n\n        :param session_db: Where info are kept about sessions\n        :param config: Configuration of the consumer\n        :param client_config: Client configuration\n        :param server_info: Information about the server\n        :param client_prefs: Run time preferences, which are chosen depends\n        on what the server can do.\n        \"\"\"\n        if client_config is None:\n            client_config = {}\n\n        Client.__init__(self, **client_config)\n\n        self.consumer_config = consumer_config\n        if consumer_config:\n            try:\n                self.debug = consumer_config[\"debug\"]\n            except KeyError:\n                self.debug = 0\n\n        if server_info:\n            for endpoint in ENDPOINTS:\n                try:\n                    setattr(self, endpoint, server_info[endpoint])\n                except KeyError:\n                    setattr(self, endpoint, \"\")\n\n        if not isinstance(session_db, SessionBackend):\n            warnings.warn(\n                \"Please use `SessionBackend` to ensure proper API for the database.\",\n                DeprecationWarning,\n            )\n        self.sdb = session_db\n\n        if sso_db is not None:\n            if not isinstance(sso_db, SessionBackend):\n                warnings.warn(\n                    \"Please use `SessionBackend` to ensure proper API for the database.\",\n                    DeprecationWarning,\n                )\n            self.sso_db: SessionBackend = sso_db\n        else:\n            self.sso_db = DictSessionBackend()\n\n        self.debug = debug\n        self.seed = \"\"\n        self.nonce = \"\"\n        self.request_filename = \"\"\n        self.request_uri = \"\"\n        self.user_info = None\n        self.registration_expires_at = 0\n        self.secret_type = \"Bearer\"\n\n    def update(self, sid):\n        \"\"\"\n        Update the instance variables from something stored in the session database.\n\n        Will not overwrite something that's already there.\n        Except for the grant dictionary !!\n\n        :param sid: Session identifier\n        \"\"\"\n        for key, val in self.sdb[sid].items():\n            try:\n                _val = getattr(self, key)\n            except AttributeError:\n                continue\n\n            if not _val and val:\n                setattr(self, key, val)\n            elif key == \"grant\" and val:\n                # val is a Grant instance\n                val.update(_val)\n                setattr(self, key, val)\n\n    def restore(self, sid):\n        \"\"\"\n        Restore the instance variables from something stored in the session database.\n\n        :param sid: Session identifier\n        \"\"\"\n        for key, val in self.sdb[sid].items():\n            setattr(self, key, val)\n\n    def dictionary(self):\n        return dict([(k, v) for k, v in self.__dict__.items() if k not in IGNORE])\n\n    def _backup(self, sid):\n        \"\"\"\n        Store instance variable values in the session store under a session identifier.\n\n        :param sid: Session identifier\n        \"\"\"\n        self.sdb[sid] = self.dictionary()\n\n    def begin(self, scope=\"\", response_type=\"\", use_nonce=False, path=\"\", **kwargs):\n        \"\"\"\n        Begin the OIDC flow.\n\n        :param scope: Defines which user info claims is wanted\n        :param response_type: Controls the parameters returned in the response from the Authorization Endpoint\n        :param use_nonce: If not implicit flow nonce is optional. This defines if it should be used anyway.\n        :param path: The path part of the redirect URL\n        :return: A 2-tuple, session identifier and URL to which the user should be redirected\n        \"\"\"\n        _log_info = logger.info\n\n        if self.debug:\n            _log_info(\"- begin -\")\n\n        _page = self.consumer_config[\"authz_page\"]\n        if not path.endswith(\"/\"):\n            if _page.startswith(\"/\"):\n                self.redirect_uris = [path + _page]\n            else:\n                self.redirect_uris = [\"%s/%s\" % (path, _page)]\n        else:\n            if _page.startswith(\"/\"):\n                self.redirect_uris = [path + _page[1:]]\n            else:\n                self.redirect_uris = [\"%s/%s\" % (path, _page)]\n\n        # Put myself in the dictionary of sessions, keyed on session-id\n        if not self.seed:\n            self.seed = rndstr()\n\n        if not scope:\n            scope = self.consumer_config[\"scope\"]\n        if not response_type:\n            response_type = self.consumer_config[\"response_type\"]\n\n        sid = stateID(path, self.seed)\n        self.grant[sid] = Grant(seed=self.seed)\n\n        self._backup(sid)\n        self.sdb[\"seed:%s\" % self.seed] = sid\n        self.sso_db[sid] = {}\n\n        args = {\n            \"client_id\": self.client_id,\n            \"state\": sid,\n            \"response_type\": response_type,\n            \"scope\": scope,\n        }\n\n        # nonce is REQUIRED in implicit flow,\n        # OPTIONAL on code flow.\n        if \"token\" in response_type or use_nonce:\n            args[\"nonce\"] = rndstr(12)\n            self.state2nonce[sid] = args[\"nonce\"]\n\n        if \"max_age\" in self.consumer_config:\n            args[\"max_age\"] = self.consumer_config[\"max_age\"]\n\n        _claims = None\n        if \"user_info\" in self.consumer_config:\n            _claims = ClaimsRequest(\n                userinfo=Claims(**self.consumer_config[\"user_info\"])\n            )\n        if \"id_token\" in self.consumer_config:\n            if _claims:\n                _claims[\"id_token\"] = Claims(**self.consumer_config[\"id_token\"])\n            else:\n                _claims = ClaimsRequest(\n                    id_token=Claims(**self.consumer_config[\"id_token\"])\n                )\n\n        if _claims:\n            args[\"claims\"] = _claims\n\n        if \"request_method\" in self.consumer_config:\n            areq = self.construct_AuthorizationRequest(\n                request_args=args, extra_args=None, request_param=\"request\"\n            )\n\n            if self.consumer_config[\"request_method\"] == \"file\":\n                id_request = areq[\"request\"]\n                del areq[\"request\"]\n                _filedir = self.consumer_config[\"temp_dir\"]\n                _webpath = self.consumer_config[\"temp_path\"]\n                _name = rndstr(10)\n                filename = os.path.join(_filedir, _name)\n                while os.path.exists(filename):\n                    _name = rndstr(10)\n                    filename = os.path.join(_filedir, _name)\n                fid = open(filename, mode=\"w\")\n                fid.write(id_request)\n                fid.close()\n                _webname = \"%s%s/%s\" % (path, _webpath, _name)\n                areq[\"request_uri\"] = _webname\n                self.request_uri = _webname\n                self._backup(sid)\n        else:\n            if \"userinfo_claims\" in args:  # can only be carried in an IDRequest\n                raise PyoidcError(\"Need a request method\")\n\n            areq = self.construct_AuthorizationRequest(\n                AuthorizationRequest, request_args=args\n            )\n\n        location = areq.request(self.authorization_endpoint)\n\n        if self.debug:\n            _log_info(\"Redirecting to: %s\" % location)\n\n        return sid, location\n\n    def _parse_authz(self, query=\"\", **kwargs):\n        _log_info = logger.info\n        # Might be an error response\n        _log_info(\"Expect Authorization Response\")\n        aresp = self.parse_response(\n            AuthorizationResponse, info=query, sformat=\"urlencoded\", keyjar=self.keyjar\n        )\n        if isinstance(aresp, ErrorResponse):\n            _log_info(\"ErrorResponse: %s\" % sanitize(aresp))\n            raise AuthzError(aresp.get(\"error\"), aresp)\n\n        _log_info(\"Aresp: %s\" % sanitize(aresp))\n\n        _state = aresp[\"state\"]\n        try:\n            self.update(_state)\n        except KeyError:\n            raise UnknownState(_state, aresp)\n\n        self.redirect_uris = [self.sdb[_state][\"redirect_uris\"]]\n        return aresp, _state\n\n    def parse_authz(self, query=\"\", **kwargs):\n        \"\"\"\n        Parse authorization response from server.\n\n        Couple of cases\n        [\"code\"]\n        [\"code\", \"token\"]\n        [\"code\", \"id_token\", \"token\"]\n        [\"id_token\"]\n        [\"id_token\", \"token\"]\n        [\"token\"]\n\n        :return: A AccessTokenResponse instance\n        \"\"\"\n        _log_info = logger.info\n        logger.debug(\"- authorization -\")\n\n        if not query:\n            return http_util.BadRequest(\"Missing query\")\n\n        _log_info(\"response: %s\" % sanitize(query))\n\n        if \"code\" in self.consumer_config[\"response_type\"]:\n            aresp, _state = self._parse_authz(query, **kwargs)\n\n            # May have token and id_token information too\n            if \"access_token\" in aresp:\n                atr = clean_response(aresp)\n                self.access_token = atr\n                # update the grant object\n                self.get_grant(state=_state).add_token(atr)\n            else:\n                atr = None\n\n            self._backup(_state)\n\n            try:\n                idt = aresp[\"id_token\"]\n            except KeyError:\n                idt = None\n            else:\n                try:\n                    session_update(self.sdb, idt[\"sid\"], \"smid\", _state)\n                except KeyError:\n                    pass\n\n            return aresp, atr, idt\n        elif \"token\" in self.consumer_config[\"response_type\"]:  # implicit flow\n            _log_info(\"Expect Access Token Response\")\n            atr = self.parse_response(\n                AccessTokenResponse,\n                info=query,\n                sformat=\"urlencoded\",\n                keyjar=self.keyjar,\n                **kwargs,\n            )\n            if isinstance(atr, ErrorResponse):\n                raise TokenError(atr.get(\"error\"), atr)\n\n            idt = None\n            return None, atr, idt\n        else:  # only id_token\n            aresp, _state = self._parse_authz(query, **kwargs)\n\n            try:\n                idt = aresp[\"id_token\"]\n            except KeyError:\n                idt = None\n            else:\n                try:\n                    session_update(self.sso_db, _state, \"smid\", idt[\"sid\"])\n                except KeyError:\n                    pass\n\n            return None, None, idt\n\n    def complete(self, state):\n        \"\"\"\n        Do the access token request, the last step in a code flow.\n\n        If Implicit flow was used then this method is never used.\n        \"\"\"\n        args = {\"redirect_uri\": self.redirect_uris[0]}\n        if \"password\" in self.consumer_config and self.consumer_config[\"password\"]:\n            logger.info(\"basic auth\")\n            http_args = {\"password\": self.consumer_config[\"password\"]}\n        elif self.client_secret:\n            logger.info(\"request_body auth\")\n            http_args = {}\n            args.update(\n                {\n                    \"client_secret\": self.client_secret,\n                    \"client_id\": self.client_id,\n                    \"secret_type\": self.secret_type,\n                }\n            )\n        else:\n            raise PyoidcError(\"Nothing to authenticate with\")\n\n        resp = self.do_access_token_request(\n            state=state, request_args=args, http_args=http_args\n        )\n\n        logger.info(\"Access Token Response: %s\" % sanitize(resp))\n\n        if resp.type() == \"ErrorResponse\":\n            raise TokenError(resp.error, resp)\n\n        self._backup(state)\n\n        return resp\n\n    def refresh_token(self):\n        pass\n\n    def get_user_info(self, state):\n        uinfo = self.do_user_info_request(state=state, schema=\"openid\")\n\n        if uinfo.type() == \"ErrorResponse\":\n            raise TokenError(uinfo.error, uinfo)\n\n        self.user_info = uinfo\n        self._backup(state)\n\n        return uinfo\n\n    def refresh_session(self):\n        pass\n\n    def check_session(self):\n        \"\"\"\n        Check session endpoint.\n\n        With python you could use PyQuery to get the onclick attribute of each\n        anchor tag, parse that with a regular expression to get the placeId,\n        build the /places/duplicates.jsp?inPID= URL yourself, use requests to\n        load the content at that URL, then PyQuery again on the content to get\n        the data you need.\n\n        for iframe in mosoup(\"iframe\"):\n            mosoup.iframe.extract()\n\n        It accepts postMessage requests from the relevant RP iframe and uses\n        postMessage to post back the login status of the End-User at the OP.\n\n        :return:\n        \"\"\"\n        pass\n\n    def end_session(self):\n        pass\n\n    # LOGOUT related\n\n    def backchannel_logout(\n        self, request: Optional[str] = None, request_args: Optional[Dict] = None\n    ) -> str:\n        \"\"\"\n        Receives a back channel logout request.\n\n        :param request: A urlencoded request\n        :param request_args: The request as a dictionary\n        :return: A Session Identifier\n        \"\"\"\n        if request:\n            req = BackChannelLogoutRequest().from_urlencoded(request)\n        elif request_args is not None:\n            req = BackChannelLogoutRequest(**request_args)\n        else:\n            raise ValueError(\"Missing request specification\")\n\n        kwargs = {\"aud\": self.client_id, \"iss\": self.issuer, \"keyjar\": self.keyjar}\n\n        try:\n            req.verify(**kwargs)\n        except (MessageException, ValueError, NotForMe) as err:\n            raise MessageException(\"Bogus logout request: {}\".format(err))\n\n        # Find the subject through 'sid' or 'sub'\n\n        try:\n            sub = req[\"logout_token\"][\"sub\"]\n        except KeyError:\n            # verify has guaranteed that there will be a sid if sub is missing\n            sm_id = req[\"logout_token\"][\"sid\"]\n            _sid = session_get(self.sso_db, \"smid\", sm_id)\n        else:\n            _sid = session_extended_get(\n                self.sso_db, sub, \"issuer\", req[\"logout_token\"][\"iss\"]\n            )\n\n        return _sid\n", "import inspect\nimport json\nimport logging\nimport sys\nimport time\nimport warnings\nfrom typing import Dict\nfrom typing import List\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlparse\n\nfrom jwkest import jws\nfrom jwkest.jwe import JWEException\nfrom jwkest.jwe import factory as JWE_factory\nfrom jwkest.jwt import JWT\n\nfrom oic.exception import InvalidRequest\nfrom oic.exception import IssuerMismatch\nfrom oic.exception import MessageException\nfrom oic.exception import NotForMe\nfrom oic.exception import PyoidcError\nfrom oic.oauth2 import message\nfrom oic.oauth2.exception import VerificationError\nfrom oic.oauth2.message import OPTIONAL_LIST_OF_SP_SEP_STRINGS\nfrom oic.oauth2.message import OPTIONAL_LIST_OF_STRINGS\nfrom oic.oauth2.message import REQUIRED_LIST_OF_SP_SEP_STRINGS\nfrom oic.oauth2.message import REQUIRED_LIST_OF_STRINGS\nfrom oic.oauth2.message import SINGLE_OPTIONAL_INT\nfrom oic.oauth2.message import SINGLE_OPTIONAL_JSON\nfrom oic.oauth2.message import SINGLE_OPTIONAL_STRING\nfrom oic.oauth2.message import SINGLE_REQUIRED_STRING\nfrom oic.oauth2.message import Message\nfrom oic.oauth2.message import MessageFactory\nfrom oic.oauth2.message import MessageTuple\nfrom oic.oauth2.message import MissingRequiredAttribute\nfrom oic.oauth2.message import MissingRequiredValue\nfrom oic.oauth2.message import NotAllowedValue\nfrom oic.oauth2.message import ParamDefinition\nfrom oic.oauth2.message import SchemeError\nfrom oic.utils import time_util\nfrom oic.utils.time_util import utc_time_sans_frac\n\n__author__ = \"rohe0002\"\n\nlogger = logging.getLogger(__name__)\n\nNONCE_STORAGE_TIME = 4 * 3600\n\n\nclass AtHashError(VerificationError):\n    pass\n\n\nclass CHashError(VerificationError):\n    pass\n\n\nclass EXPError(VerificationError):\n    pass\n\n\nclass IATError(VerificationError):\n    pass\n\n\ndef json_ser(val, sformat=None, lev=0):\n    return json.dumps(val)\n\n\ndef json_deser(val, sformat=None, lev=0):\n    return json.loads(val)\n\n\ndef json_conv(val, sformat=None, lev=0):\n    if isinstance(val, dict):\n        for key, _val in val.items():\n            if _val is None:\n                val[key] = \"none\"\n            elif _val is True:\n                val[key] = \"true\"\n            elif _val is False:\n                val[key] = \"false\"\n\n    return val\n\n\ndef json_rest(val, sformat=None, lev=0):\n    if isinstance(val, dict):\n        for key, _val in val.items():\n            if _val == \"none\":\n                val[key] = None\n            elif _val == \"true\":\n                val[key] = True\n            elif _val == \"false\":\n                val[key] = False\n\n    return val\n\n\n# value type, required, serializer, deserializer, null value allowed\nSINGLE_OPTIONAL_BOOLEAN = ParamDefinition(bool, False, None, None, False)\nSINGLE_OPTIONAL_JSON_WN = ParamDefinition(dict, False, json_ser, json_deser, True)\nSINGLE_OPTIONAL_JSON_CONV = ParamDefinition(dict, False, json_conv, json_rest, True)\nSINGLE_REQUIRED_INT = ParamDefinition(int, True, None, None, False)\n\n\ndef idtoken_deser(val, sformat=\"urlencoded\"):\n    # id_token are always serialized as a JWT\n    return IdToken().deserialize(val, \"jwt\")\n\n\ndef address_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n        elif sformat == \"dict\":\n            sformat = \"json\"\n    return AddressClaim().deserialize(val, sformat)\n\n\ndef claims_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return Claims().deserialize(val, sformat)\n\n\ndef message_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return Message().deserialize(val, sformat)\n\n\ndef msg_ser(inst, sformat, lev=0):\n    if sformat in [\"urlencoded\", \"json\"]:\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        else:\n            res = inst\n    elif sformat == \"dict\":\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        elif isinstance(inst, dict):\n            res = inst\n        elif isinstance(inst, str):  # Iff ID Token\n            res = inst\n        else:\n            raise MessageException(\"Wrong type: %s\" % type(inst))\n    else:\n        raise PyoidcError(\"Unknown sformat\", inst)\n\n    return res\n\n\ndef msg_ser_json(inst, sformat=\"json\", lev=0):\n    # sformat = \"json\" always except when dict\n    if lev:\n        sformat = \"dict\"\n\n    if sformat == \"dict\":\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        elif isinstance(inst, dict):\n            res = inst\n        else:\n            raise MessageException(\"Wrong type: %s\" % type(inst))\n    else:\n        sformat = \"json\"\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        else:\n            res = inst\n\n    return res\n\n\ndef msg_list_ser(insts, sformat, lev=0):\n    return [msg_ser(inst, sformat, lev) for inst in insts]\n\n\ndef claims_ser(val, sformat=\"urlencoded\", lev=0):\n    # everything in c_extension\n    if isinstance(val, str):\n        item = val\n    elif isinstance(val, list):\n        item = val[0]\n    else:\n        item = val\n\n    if isinstance(item, Message):\n        return item.serialize(method=sformat, lev=lev + 1)\n\n    if sformat == \"urlencoded\":\n        assert isinstance(  # nosec\n            item, dict\n        )  # We cannot urlencode anything else than Mapping\n        res = urlencode(item)\n    elif sformat == \"json\":\n        if lev:\n            res = item\n        else:\n            res = json.dumps(item)\n    elif sformat == \"dict\":\n        if isinstance(item, dict):\n            res = item\n        else:\n            raise MessageException(\"Wrong type: %s\" % type(item))\n    else:\n        raise PyoidcError(\"Unknown sformat: %s\" % sformat, val)\n\n    return res\n\n\ndef registration_request_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return RegistrationRequest().deserialize(val, sformat)\n\n\ndef claims_request_deser(val, sformat=\"json\"):\n    # never 'urlencoded'\n    if sformat == \"urlencoded\":\n        sformat = \"json\"\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return ClaimsRequest().deserialize(val, sformat)\n\n\nOPTIONAL_ADDRESS = ParamDefinition(Message, False, msg_ser, address_deser, False)\nOPTIONAL_LOGICAL = ParamDefinition(bool, False, None, None, False)\nOPTIONAL_MULTIPLE_Claims = ParamDefinition(\n    Message, False, claims_ser, claims_deser, False\n)\n\nSINGLE_OPTIONAL_IDTOKEN = ParamDefinition(str, False, msg_ser, None, False)\n\nSINGLE_OPTIONAL_REGISTRATION_REQUEST = ParamDefinition(\n    Message, False, msg_ser, registration_request_deser, False\n)\nSINGLE_OPTIONAL_CLAIMSREQ = ParamDefinition(\n    Message, False, msg_ser_json, claims_request_deser, False\n)\n\nOPTIONAL_MESSAGE = ParamDefinition(Message, False, msg_ser, message_deser, False)\nREQUIRED_MESSAGE = ParamDefinition(Message, True, msg_ser, message_deser, False)\n\n# ----------------------------------------------------------------------------\n\n\nSCOPE_CHARSET = []\nfor char in [\"\\x21\", (\"\\x23\", \"\\x5b\"), (\"\\x5d\", \"\\x7E\")]:\n    if isinstance(char, tuple):\n        c = char[0]\n        while c <= char[1]:\n            SCOPE_CHARSET.append(c)\n            c = chr(ord(c) + 1)\n    else:\n        SCOPE_CHARSET.append(set)\n\n\ndef check_char_set(string, allowed):\n    for c in string:\n        if c not in allowed:\n            raise NotAllowedValue(\"'%c' not in the allowed character set\" % c)\n\n\nTOKEN_VERIFY_ARGS = [\"key\", \"keyjar\", \"algs\", \"sender\"]\n\n\ndef verify_id_token(instance, check_hash=False, **kwargs):\n    # Try to decode the JWT, checks the signature\n    args = {}\n    for arg in TOKEN_VERIFY_ARGS:\n        try:\n            args[arg] = kwargs[arg]\n        except KeyError:\n            pass\n\n    _jws = str(instance[\"id_token\"])\n\n    # It can be encrypted, so try to decrypt first\n    _jwe = JWE_factory(_jws)\n    if _jwe is not None:\n        try:\n            _jws = _jwe.decrypt(keys=kwargs[\"keyjar\"].get_decrypt_key())\n        except JWEException as err:\n            raise VerificationError(\"Could not decrypt id_token\", err)\n    _packer = JWT()\n    _body = _packer.unpack(_jws).payload()\n\n    if \"keyjar\" in kwargs:\n        try:\n            if _body[\"iss\"] not in kwargs[\"keyjar\"]:\n                raise ValueError(\"Unknown issuer\")\n        except KeyError:\n            raise MissingRequiredAttribute(\"iss\")\n\n    if _jwe is not None:\n        # Use the original encrypted token to set correct headers\n        idt = IdToken().from_jwt(str(instance[\"id_token\"]), **args)\n    else:\n        idt = IdToken().from_jwt(_jws, **args)\n    if not idt.verify(**kwargs):\n        raise VerificationError(\"Could not verify id_token\", idt)\n\n    if check_hash:\n        _alg = idt.jws_header[\"alg\"]\n        # What if _alg == 'none'\n\n        hfunc = \"HS\" + _alg[-3:]\n\n        if \"access_token\" in instance:\n            if \"at_hash\" not in idt:\n                raise MissingRequiredAttribute(\"Missing at_hash property\", idt)\n            if idt[\"at_hash\"] != jws.left_hash(instance[\"access_token\"], hfunc):\n                raise AtHashError(\"Failed to verify access_token hash\", idt)\n\n        if \"code\" in instance:\n            if \"c_hash\" not in idt:\n                raise MissingRequiredAttribute(\"Missing c_hash property\", idt)\n            if idt[\"c_hash\"] != jws.left_hash(instance[\"code\"], hfunc):\n                raise CHashError(\"Failed to verify code hash\", idt)\n\n    return idt\n\n\n# -----------------------------------------------------------------------------\n\n\nclass RefreshAccessTokenRequest(message.RefreshAccessTokenRequest):\n    pass\n\n\nclass TokenErrorResponse(message.TokenErrorResponse):\n    pass\n\n\nclass AccessTokenResponse(message.AccessTokenResponse):\n    c_param = message.AccessTokenResponse.c_param.copy()\n    c_param.update({\"id_token\": SINGLE_OPTIONAL_STRING})\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n        if \"id_token\" in self:\n            # replace the JWT with the verified IdToken instance\n            self[\"id_token\"] = verify_id_token(self, **kwargs)\n\n        return True\n\n\nclass UserInfoRequest(Message):\n    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}\n\n\nclass AuthorizationResponse(message.AuthorizationResponse, message.AccessTokenResponse):\n    c_param = message.AuthorizationResponse.c_param.copy()\n    c_param.update(message.AccessTokenResponse.c_param)\n    c_param.update(\n        {\n            \"code\": SINGLE_OPTIONAL_STRING,\n            \"access_token\": SINGLE_OPTIONAL_STRING,\n            \"token_type\": SINGLE_OPTIONAL_STRING,\n            \"id_token\": SINGLE_OPTIONAL_IDTOKEN,\n        }\n    )\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"aud\" in self:\n            if \"client_id\" in kwargs:\n                # check that it's for me\n                if kwargs[\"client_id\"] not in self[\"aud\"]:\n                    return False\n\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n        if \"access_token\" in self:\n            if \"token_type\" not in self:\n                raise MissingRequiredValue(\"Missing token_type parameter\", self)\n\n        return True\n\n\nclass AuthorizationErrorResponse(message.AuthorizationErrorResponse):\n    c_allowed_values = message.AuthorizationErrorResponse.c_allowed_values.copy()\n    c_allowed_values[\"error\"].extend(\n        [\n            \"interaction_required\",\n            \"login_required\",\n            \"session_selection_required\",\n            \"consent_required\",\n            \"invalid_request_uri\",\n            \"invalid_request_object\",\n            \"registration_not_supported\",\n            \"request_not_supported\",\n            \"request_uri_not_supported\",\n        ]\n    )\n\n\nclass AuthorizationRequest(message.AuthorizationRequest):\n    c_param = message.AuthorizationRequest.c_param.copy()\n    c_param.update(\n        {\n            \"scope\": REQUIRED_LIST_OF_SP_SEP_STRINGS,\n            \"redirect_uri\": SINGLE_REQUIRED_STRING,\n            \"nonce\": SINGLE_OPTIONAL_STRING,\n            \"display\": SINGLE_OPTIONAL_STRING,\n            \"prompt\": OPTIONAL_LIST_OF_STRINGS,\n            \"max_age\": SINGLE_OPTIONAL_INT,\n            \"ui_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,\n            \"claims_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,\n            \"id_token_hint\": SINGLE_OPTIONAL_STRING,\n            \"login_hint\": SINGLE_OPTIONAL_STRING,\n            \"acr_values\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,\n            \"claims\": SINGLE_OPTIONAL_CLAIMSREQ,\n            \"registration\": SINGLE_OPTIONAL_JSON,\n            \"request\": SINGLE_OPTIONAL_STRING,\n            \"request_uri\": SINGLE_OPTIONAL_STRING,\n            \"response_mode\": SINGLE_OPTIONAL_STRING,\n        }\n    )\n    c_allowed_values = message.AuthorizationRequest.c_allowed_values.copy()\n    c_allowed_values.update(\n        {\n            \"display\": [\"page\", \"popup\", \"touch\", \"wap\"],\n            \"prompt\": [\"none\", \"login\", \"consent\", \"select_account\"],\n        }\n    )\n\n    def verify(self, **kwargs):\n        \"\"\"\n        Check that the request is valid.\n\n        Authorization Request parameters that are OPTIONAL in the OAuth 2.0\n        specification MAY be included in the OpenID Request Object without also\n        passing them as OAuth 2.0 Authorization Request parameters, with one\n        exception: The scope parameter MUST always be present in OAuth 2.0\n        Authorization Request parameters.\n        All parameter values that are present both in the OAuth 2.0\n        Authorization Request and in the OpenID Request Object MUST exactly match.\n        \"\"\"\n        super().verify(**kwargs)\n\n        args = {}\n        for arg in [\"key\", \"keyjar\", \"opponent_id\", \"sender\"]:\n            try:\n                args[arg] = kwargs[arg]\n            except KeyError:\n                pass\n\n        if \"opponent_id\" not in kwargs:\n            args[\"opponent_id\"] = self[\"client_id\"]\n\n        if \"request\" in self:\n            if isinstance(self[\"request\"], str):\n                # Try to decode the JWT, checks the signature\n                oidr = OpenIDRequest().from_jwt(str(self[\"request\"]), **args)\n\n                # verify that nothing is change in the original message\n                for key, val in oidr.items():\n                    if key in self and self[key] != val:\n                        raise AssertionError()\n\n                # replace the JWT with the parsed and verified instance\n                self[\"request\"] = oidr\n\n        if \"id_token_hint\" in self:\n            if isinstance(self[\"id_token_hint\"], str):\n                idt = IdToken().from_jwt(str(self[\"id_token_hint\"]), **args)\n                self[\"id_token_hint\"] = idt\n\n        if \"response_type\" not in self:\n            raise MissingRequiredAttribute(\"response_type missing\", self)\n\n        _rt = self[\"response_type\"]\n        if \"token\" in _rt or \"id_token\" in _rt:\n            if \"nonce\" not in self:\n                raise MissingRequiredAttribute(\"Nonce missing\", self)\n\n        if \"openid\" not in self.get(\"scope\", []):\n            raise MissingRequiredValue(\"openid not in scope\", self)\n\n        if \"offline_access\" in self.get(\"scope\", []):\n            if \"prompt\" not in self or \"consent\" not in self[\"prompt\"]:\n                raise MissingRequiredValue(\"consent in prompt\", self)\n\n        if \"prompt\" in self:\n            if \"none\" in self[\"prompt\"] and len(self[\"prompt\"]) > 1:\n                raise InvalidRequest(\"prompt none combined with other value\", self)\n\n        return True\n\n\nclass AccessTokenRequest(message.AccessTokenRequest):\n    c_param = message.AccessTokenRequest.c_param.copy()\n    c_param.update(\n        {\n            \"client_assertion_type\": SINGLE_OPTIONAL_STRING,\n            \"client_assertion\": SINGLE_OPTIONAL_STRING,\n        }\n    )\n    c_default = {\"grant_type\": \"authorization_code\"}\n    c_allowed_values = {\n        \"client_assertion_type\": [\n            \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n        ]\n    }\n\n\nclass AddressClaim(Message):\n    c_param = {\n        \"formatted\": SINGLE_OPTIONAL_STRING,\n        \"street_address\": SINGLE_OPTIONAL_STRING,\n        \"locality\": SINGLE_OPTIONAL_STRING,\n        \"region\": SINGLE_OPTIONAL_STRING,\n        \"postal_code\": SINGLE_OPTIONAL_STRING,\n        \"country\": SINGLE_OPTIONAL_STRING,\n    }\n\n\nclass OpenIDSchema(Message):\n    c_param = {\n        \"sub\": SINGLE_REQUIRED_STRING,\n        \"name\": SINGLE_OPTIONAL_STRING,\n        \"given_name\": SINGLE_OPTIONAL_STRING,\n        \"family_name\": SINGLE_OPTIONAL_STRING,\n        \"middle_name\": SINGLE_OPTIONAL_STRING,\n        \"nickname\": SINGLE_OPTIONAL_STRING,\n        \"preferred_username\": SINGLE_OPTIONAL_STRING,\n        \"profile\": SINGLE_OPTIONAL_STRING,\n        \"picture\": SINGLE_OPTIONAL_STRING,\n        \"website\": SINGLE_OPTIONAL_STRING,\n        \"email\": SINGLE_OPTIONAL_STRING,\n        \"email_verified\": SINGLE_OPTIONAL_BOOLEAN,\n        \"gender\": SINGLE_OPTIONAL_STRING,\n        \"birthdate\": SINGLE_OPTIONAL_STRING,\n        \"zoneinfo\": SINGLE_OPTIONAL_STRING,\n        \"locale\": SINGLE_OPTIONAL_STRING,\n        \"phone_number\": SINGLE_OPTIONAL_STRING,\n        \"phone_number_verified\": SINGLE_OPTIONAL_BOOLEAN,\n        \"address\": OPTIONAL_ADDRESS,\n        \"updated_at\": SINGLE_OPTIONAL_INT,\n        \"_claim_names\": OPTIONAL_MESSAGE,\n        \"_claim_sources\": OPTIONAL_MESSAGE,\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"birthdate\" in self:\n            # Either YYYY-MM-DD or just YYYY or 0000-MM-DD\n            try:\n                time.strptime(self[\"birthdate\"], \"%Y-%m-%d\")\n            except ValueError:\n                try:\n                    time.strptime(self[\"birthdate\"], \"%Y\")\n                except ValueError:\n                    try:\n                        time.strptime(self[\"birthdate\"], \"0000-%m-%d\")\n                    except ValueError:\n                        raise VerificationError(\"Birthdate format error\", self)\n\n        if any(val is None for val in self.values()):\n            return False\n\n        return True\n\n\nclass RegistrationRequest(Message):\n    c_param = {\n        \"redirect_uris\": REQUIRED_LIST_OF_STRINGS,\n        \"response_types\": OPTIONAL_LIST_OF_STRINGS,\n        \"grant_types\": OPTIONAL_LIST_OF_STRINGS,\n        \"application_type\": SINGLE_OPTIONAL_STRING,\n        \"contacts\": OPTIONAL_LIST_OF_STRINGS,\n        \"client_name\": SINGLE_OPTIONAL_STRING,\n        \"logo_uri\": SINGLE_OPTIONAL_STRING,\n        \"client_uri\": SINGLE_OPTIONAL_STRING,\n        \"policy_uri\": SINGLE_OPTIONAL_STRING,\n        \"tos_uri\": SINGLE_OPTIONAL_STRING,\n        \"jwks\": SINGLE_OPTIONAL_STRING,\n        \"jwks_uri\": SINGLE_OPTIONAL_STRING,\n        \"sector_identifier_uri\": SINGLE_OPTIONAL_STRING,\n        \"subject_type\": SINGLE_OPTIONAL_STRING,\n        \"id_token_signed_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"id_token_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"id_token_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_signed_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,\n        \"request_object_signing_alg\": SINGLE_OPTIONAL_STRING,\n        \"request_object_encryption_alg\": SINGLE_OPTIONAL_STRING,\n        \"request_object_encryption_enc\": SINGLE_OPTIONAL_STRING,\n        \"token_endpoint_auth_method\": SINGLE_OPTIONAL_STRING,\n        \"token_endpoint_auth_signing_alg\": SINGLE_OPTIONAL_STRING,\n        \"default_max_age\": SINGLE_OPTIONAL_INT,\n        \"require_auth_time\": OPTIONAL_LOGICAL,\n        \"default_acr_values\": OPTIONAL_LIST_OF_STRINGS,\n        \"initiate_login_uri\": SINGLE_OPTIONAL_STRING,\n        \"request_uris\": OPTIONAL_LIST_OF_STRINGS,\n        \"post_logout_redirect_uris\": OPTIONAL_LIST_OF_STRINGS,\n        \"frontchannel_logout_uri\": SINGLE_OPTIONAL_STRING,\n        \"frontchannel_logout_session_required\": OPTIONAL_LOGICAL,\n        \"backchannel_logout_uri\": SINGLE_OPTIONAL_STRING,\n        \"backchannel_logout_session_required\": OPTIONAL_LOGICAL,\n    }\n    c_default = {\"application_type\": \"web\", \"response_types\": [\"code\"]}\n    c_allowed_values = {\n        \"application_type\": [\"native\", \"web\"],\n        \"subject_type\": [\"public\", \"pairwise\"],\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"initiate_login_uri\" in self and not self[\"initiate_login_uri\"].startswith(\n            \"https:\"\n        ):\n            raise AssertionError()\n\n        for param in [\n            \"request_object_encryption\",\n            \"id_token_encrypted_response\",\n            \"userinfo_encrypted_response\",\n        ]:\n            alg_param = \"%s_alg\" % param\n            enc_param = \"%s_enc\" % param\n            if alg_param in self:\n                if enc_param not in self:\n                    self[enc_param] = \"A128CBC-HS256\"\n\n            # both or none\n            if enc_param in self and alg_param not in self:\n                raise AssertionError()\n\n        if (\n            \"token_endpoint_auth_signing_alg\" in self\n            and self[\"token_endpoint_auth_signing_alg\"] == \"none\"\n        ):\n            raise AssertionError()\n\n        return True\n\n\nclass RegistrationResponse(Message):\n    \"\"\"Response to client_register registration requests.\"\"\"\n\n    c_param = {\n        \"client_id\": SINGLE_REQUIRED_STRING,\n        \"client_secret\": SINGLE_OPTIONAL_STRING,\n        \"registration_access_token\": SINGLE_OPTIONAL_STRING,\n        \"registration_client_uri\": SINGLE_OPTIONAL_STRING,\n        \"client_id_issued_at\": SINGLE_OPTIONAL_INT,\n        \"client_secret_expires_at\": SINGLE_OPTIONAL_INT,\n    }\n    c_param.update(RegistrationRequest.c_param)\n\n    def verify(self, **kwargs):\n        \"\"\"\n        Verify that the response is valid.\n\n        Implementations MUST either return both a Client Configuration Endpoint\n        and a Registration Access Token or neither of them.\n        :param kwargs:\n        :return: True if the message is OK otherwise False\n        \"\"\"\n        super(RegistrationResponse, self).verify(**kwargs)\n\n        has_reg_uri = \"registration_client_uri\" in self\n        has_reg_at = \"registration_access_token\" in self\n        if has_reg_uri != has_reg_at:\n            raise VerificationError(\n                (\n                    \"Only one of registration_client_uri\"\n                    \" and registration_access_token present\"\n                ),\n                self,\n            )\n\n        return True\n\n\nclass ClientRegistrationErrorResponse(message.ErrorResponse):\n    c_allowed_values = {\n        \"error\": [\n            \"invalid_redirect_uri\",\n            \"invalid_client_metadata\",\n            \"invalid_configuration_parameter\",\n        ]\n    }\n\n\nclass IdToken(OpenIDSchema):\n    c_param = OpenIDSchema.c_param.copy()\n    c_param.update(\n        {\n            \"iss\": SINGLE_REQUIRED_STRING,\n            \"sub\": SINGLE_REQUIRED_STRING,\n            \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string\n            \"exp\": SINGLE_REQUIRED_INT,\n            \"iat\": SINGLE_REQUIRED_INT,\n            \"auth_time\": SINGLE_OPTIONAL_INT,\n            \"nonce\": SINGLE_OPTIONAL_STRING,\n            \"at_hash\": SINGLE_OPTIONAL_STRING,\n            \"c_hash\": SINGLE_OPTIONAL_STRING,\n            \"acr\": SINGLE_OPTIONAL_STRING,\n            \"amr\": OPTIONAL_LIST_OF_STRINGS,\n            \"azp\": SINGLE_OPTIONAL_STRING,\n            \"sub_jwk\": SINGLE_OPTIONAL_STRING,\n        }\n    )\n\n    def verify(self, **kwargs):\n        super(IdToken, self).verify(**kwargs)\n\n        try:\n            if kwargs[\"iss\"] != self[\"iss\"]:\n                raise IssuerMismatch(\"{} != {}\".format(kwargs[\"iss\"], self[\"iss\"]))\n        except KeyError:\n            pass\n\n        if \"aud\" in self:\n            if \"client_id\" in kwargs:\n                # check that I'm among the recipients\n                if kwargs[\"client_id\"] not in self[\"aud\"]:\n                    raise NotForMe(\n                        \"{} not in aud:{}\".format(kwargs[\"client_id\"], self[\"aud\"]),\n                        self,\n                    )\n\n            # Then azp has to be present and be one of the aud values\n            if len(self[\"aud\"]) > 1:\n                if \"azp\" not in self:\n                    raise VerificationError(\"azp missing\", self)\n                if self[\"azp\"] not in self[\"aud\"]:\n                    raise VerificationError(\"Mismatch between azp and aud claims\", self)\n\n        if \"azp\" in self:\n            if \"client_id\" in kwargs:\n                if kwargs[\"client_id\"] != self[\"azp\"]:\n                    raise NotForMe(\n                        \"{} != azp:{}\".format(kwargs[\"client_id\"], self[\"azp\"]), self\n                    )\n\n        _now = time_util.utc_time_sans_frac()\n\n        try:\n            _skew = kwargs[\"skew\"]\n        except KeyError:\n            _skew = 0\n\n        try:\n            _exp = self[\"exp\"]\n        except KeyError:\n            raise MissingRequiredAttribute(\"exp\")\n        else:\n            if (_now - _skew) > _exp:\n                raise EXPError(\"Invalid expiration time\")\n\n        try:\n            _storage_time = kwargs[\"nonce_storage_time\"]\n        except KeyError:\n            _storage_time = NONCE_STORAGE_TIME\n\n        try:\n            _iat = self[\"iat\"]\n        except KeyError:\n            raise MissingRequiredAttribute(\"iat\")\n        else:\n            if (_iat + _storage_time) < (_now - _skew):\n                raise IATError(\"Issued too long ago\")\n\n        return True\n\n\nclass StateFullMessage(Message):\n    c_param = {\"state\": SINGLE_REQUIRED_STRING}\n\n\nclass RefreshSessionRequest(StateFullMessage):\n    c_param = StateFullMessage.c_param.copy()\n    c_param.update(\n        {\"id_token\": SINGLE_REQUIRED_STRING, \"redirect_url\": SINGLE_REQUIRED_STRING}\n    )\n\n    def verify(self, **kwargs):\n        super(RefreshSessionRequest, self).verify(**kwargs)\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n\nclass RefreshSessionResponse(StateFullMessage):\n    c_param = StateFullMessage.c_param.copy()\n    c_param.update({\"id_token\": SINGLE_REQUIRED_STRING})\n\n    def verify(self, **kwargs):\n        super(RefreshSessionResponse, self).verify(**kwargs)\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n\nclass CheckSessionRequest(Message):\n    c_param = {\"id_token\": SINGLE_REQUIRED_STRING}\n\n    def verify(self, **kwargs):\n        super(CheckSessionRequest, self).verify(**kwargs)\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n\nclass CheckIDRequest(Message):\n    c_param = {\"access_token\": SINGLE_REQUIRED_STRING}\n\n\nclass EndSessionRequest(Message):\n    c_param = {\n        \"id_token_hint\": SINGLE_OPTIONAL_STRING,\n        \"post_logout_redirect_uri\": SINGLE_OPTIONAL_STRING,\n        \"state\": SINGLE_OPTIONAL_STRING,\n    }\n\n\nclass EndSessionResponse(Message):\n    c_param = {\"state\": SINGLE_OPTIONAL_STRING}\n\n\nclass Claims(Message):\n    pass\n\n\nclass ClaimsRequest(Message):\n    c_param = {\n        \"userinfo\": OPTIONAL_MULTIPLE_Claims,\n        \"id_token\": OPTIONAL_MULTIPLE_Claims,\n    }\n\n\nclass OpenIDRequest(AuthorizationRequest):\n    pass\n\n\nclass ProviderConfigurationResponse(Message):\n    c_param = {\n        \"issuer\": SINGLE_REQUIRED_STRING,\n        \"authorization_endpoint\": SINGLE_REQUIRED_STRING,\n        \"token_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"jwks_uri\": SINGLE_REQUIRED_STRING,\n        \"registration_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"scopes_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"response_types_supported\": REQUIRED_LIST_OF_STRINGS,\n        \"response_modes_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"grant_types_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"acr_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"subject_types_supported\": REQUIRED_LIST_OF_STRINGS,\n        \"id_token_signing_alg_values_supported\": REQUIRED_LIST_OF_STRINGS,\n        \"id_token_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"id_token_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"userinfo_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"userinfo_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"userinfo_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"request_object_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"request_object_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"request_object_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"token_endpoint_auth_methods_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"token_endpoint_auth_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"display_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"claim_types_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"claims_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"service_documentation\": SINGLE_OPTIONAL_STRING,\n        \"claims_locales_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"ui_locales_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"claims_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"request_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"request_uri_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"require_request_uri_registration\": SINGLE_OPTIONAL_BOOLEAN,\n        \"op_policy_uri\": SINGLE_OPTIONAL_STRING,\n        \"op_tos_uri\": SINGLE_OPTIONAL_STRING,\n        \"check_session_iframe\": SINGLE_OPTIONAL_STRING,\n        \"end_session_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"frontchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"frontchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"backchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"backchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,\n    }\n    c_default = {\n        \"version\": \"3.0\",\n        \"token_endpoint_auth_methods_supported\": [\"client_secret_basic\"],\n        \"claims_parameter_supported\": False,\n        \"request_parameter_supported\": False,\n        \"request_uri_parameter_supported\": True,\n        \"require_request_uri_registration\": False,\n        \"grant_types_supported\": [\"authorization_code\", \"implicit\"],\n        \"frontchannel_logout_supported\": False,\n        \"frontchannel_logout_session_supported\": False,\n        \"backchannel_logout_supported\": False,\n        \"backchannel_logout_session_supported\": False,\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"scopes_supported\" in self:\n            if \"openid\" not in self[\"scopes_supported\"]:\n                raise AssertionError()\n            for scope in self[\"scopes_supported\"]:\n                check_char_set(scope, SCOPE_CHARSET)\n\n        parts = urlparse(self[\"issuer\"])\n        if parts.scheme != \"https\":\n            raise SchemeError(\"Not HTTPS\")\n\n        if parts.query or parts.fragment:\n            raise AssertionError()\n\n        if (\n            any(\"code\" in rt for rt in self[\"response_types_supported\"])\n            and \"token_endpoint\" not in self\n        ):\n            raise MissingRequiredAttribute(\"token_endpoint\")\n\n        return True\n\n\nclass AuthnToken(Message):\n    c_param = {\n        \"iss\": SINGLE_REQUIRED_STRING,\n        \"sub\": SINGLE_REQUIRED_STRING,\n        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string\n        \"jti\": SINGLE_REQUIRED_STRING,\n        \"exp\": SINGLE_REQUIRED_INT,\n        \"iat\": SINGLE_OPTIONAL_INT,\n    }\n\n\n# According to RFC 7519 all claims are optional\nclass JasonWebToken(Message):\n    c_param = {\n        \"iss\": SINGLE_OPTIONAL_STRING,\n        \"sub\": SINGLE_OPTIONAL_STRING,\n        \"aud\": OPTIONAL_LIST_OF_STRINGS,  # Array of strings or string\n        \"exp\": SINGLE_OPTIONAL_INT,\n        \"nbf\": SINGLE_OPTIONAL_INT,\n        \"iat\": SINGLE_OPTIONAL_INT,\n        \"jti\": SINGLE_OPTIONAL_STRING,\n    }\n\n\ndef jwt_deser(val, sformat=\"json\"):\n    if sformat == \"urlencoded\":\n        sformat = \"json\"\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return JasonWebToken().deserialize(val, sformat)\n\n\nSINGLE_OPTIONAL_JWT = ParamDefinition(Message, False, msg_ser, jwt_deser, False)\n\n\nclass UserInfoErrorResponse(message.ErrorResponse):\n    c_allowed_values = {\n        \"error\": [\n            \"invalid_schema\",\n            \"invalid_request\",\n            \"invalid_token\",\n            \"insufficient_scope\",\n        ]\n    }\n\n\nclass DiscoveryRequest(Message):\n    c_param = {\"principal\": SINGLE_REQUIRED_STRING, \"service\": SINGLE_REQUIRED_STRING}\n\n\nclass DiscoveryResponse(Message):\n    c_param = {\"locations\": REQUIRED_LIST_OF_STRINGS}\n\n\nclass ResourceRequest(Message):\n    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}\n\n\nSCOPE2CLAIMS: Dict[str, List[str]] = {\n    \"openid\": [\"sub\"],\n    \"profile\": [\n        \"name\",\n        \"given_name\",\n        \"family_name\",\n        \"middle_name\",\n        \"nickname\",\n        \"profile\",\n        \"picture\",\n        \"website\",\n        \"gender\",\n        \"birthdate\",\n        \"zoneinfo\",\n        \"locale\",\n        \"updated_at\",\n        \"preferred_username\",\n    ],\n    \"email\": [\"email\", \"email_verified\"],\n    \"address\": [\"address\"],\n    \"phone\": [\"phone_number\", \"phone_number_verified\"],\n    \"offline_access\": [],\n}\n\n# LOGOUT related messages\n\nSINGLE_OPTIONAL_JSON = ParamDefinition(dict, False, json_ser, json_deser, False)\nSINGLE_REQUIRED_JSON = ParamDefinition(dict, True, json_ser, json_deser, False)\n\nBACK_CHANNEL_LOGOUT_EVENT = \"http://schemas.openid.net/event/backchannel-logout\"\n\n\nclass LogoutToken(Message):\n    \"\"\"Defined in https://openid.net/specs/openid-connect-backchannel-1_0.html#LogoutToken .\"\"\"\n\n    c_param = {\n        \"iss\": SINGLE_REQUIRED_STRING,\n        \"sub\": SINGLE_OPTIONAL_STRING,\n        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string\n        \"iat\": SINGLE_REQUIRED_INT,\n        \"jti\": SINGLE_REQUIRED_STRING,\n        \"events\": SINGLE_REQUIRED_JSON,\n        \"sid\": SINGLE_OPTIONAL_STRING,\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"nonce\" in self:\n            raise MessageException(\n                '\"nonce\" is prohibited from appearing in a LogoutToken.'\n            )\n\n        # Check the 'events' JSON\n        _keys = list(self[\"events\"].keys())\n        if len(_keys) != 1:\n            raise ValueError('Must only be one member in \"events\"')\n        if _keys[0] != BACK_CHANNEL_LOGOUT_EVENT:\n            raise ValueError('Wrong member in \"events\"')\n        if self[\"events\"][_keys[0]] != {}:\n            raise ValueError('Wrong member value in \"events\"')\n\n        # There must be either a 'sub' or a 'sid', and may contain both\n        if not (\"sub\" in self or \"sid\" in self):\n            raise ValueError('There MUST be either a \"sub\" or a \"sid\"')\n\n        try:\n            if kwargs[\"aud\"] not in self[\"aud\"]:\n                raise NotForMe(\"Not among intended audience\")\n        except KeyError:\n            pass\n\n        try:\n            if kwargs[\"iss\"] != self[\"iss\"]:\n                raise NotForMe(\"Wrong issuer\")\n        except KeyError:\n            pass\n\n        _now = utc_time_sans_frac()\n\n        _skew = kwargs.get(\"skew\", 0)\n        _iat = self.get(\"iat\", 0)\n\n        if _iat and _iat > (_now + _skew):\n            raise ValueError(\"Invalid issued_at time\")\n\n        return True\n\n\nID_TOKEN_VERIFY_ARGS = [\n    \"keyjar\",\n    \"verify\",\n    \"encalg\",\n    \"encenc\",\n    \"sigalg\",\n    \"issuer\",\n    \"allow_missing_kid\",\n    \"no_kid_issuer\",\n    \"trusting\",\n    \"skew\",\n    \"nonce_storage_time\",\n    \"client_id\",\n]\n\n\nclass BackChannelLogoutRequest(Message):\n    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-backchannel-1_0.html .\"\"\"\n\n    c_param = {\"logout_token\": SINGLE_REQUIRED_STRING}\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        args = {arg: kwargs[arg] for arg in TOKEN_VERIFY_ARGS if arg in kwargs}\n\n        logout_token = LogoutToken().from_jwt(str(self[\"logout_token\"]), **args)\n        logout_token.verify(**kwargs)\n\n        self[\"logout_token\"] = logout_token\n        logger.info(\"Verified Logout Token: {}\".format(logout_token.to_dict()))\n\n        return True\n\n\nclass FrontChannelLogoutRequest(Message):\n    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-frontchannel-1_0.html .\"\"\"\n\n    c_param = {\"iss\": SINGLE_OPTIONAL_STRING, \"sid\": SINGLE_OPTIONAL_STRING}\n\n\nMSG = {\n    \"RefreshAccessTokenRequest\": RefreshAccessTokenRequest,\n    \"TokenErrorResponse\": TokenErrorResponse,\n    \"AccessTokenResponse\": AccessTokenResponse,\n    \"UserInfoRequest\": UserInfoRequest,\n    \"AuthorizationResponse\": AuthorizationResponse,\n    \"AuthorizationErrorResponse\": AuthorizationErrorResponse,\n    \"AuthorizationRequest\": AuthorizationRequest,\n    \"AccessTokenRequest\": AccessTokenRequest,\n    \"AddressClaim\": AddressClaim,\n    \"OpenIDSchema\": OpenIDSchema,\n    \"RegistrationRequest\": RegistrationRequest,\n    \"RegistrationResponse\": RegistrationResponse,\n    \"ClientRegistrationErrorResponse\": ClientRegistrationErrorResponse,\n    \"IdToken\": IdToken,\n    \"RefreshSessionRequest\": RefreshSessionRequest,\n    \"RefreshSessionResponse\": RefreshSessionResponse,\n    \"CheckSessionRequest\": CheckSessionRequest,\n    \"CheckIDRequest\": CheckIDRequest,\n    \"EndSessionRequest\": EndSessionRequest,\n    \"EndSessionResponse\": EndSessionResponse,\n    \"Claims\": Claims,\n    \"OpenIDRequest\": OpenIDRequest,\n    \"ProviderConfigurationResponse\": ProviderConfigurationResponse,\n    \"AuthnToken\": AuthnToken,\n    \"UserInfoErrorResponse\": UserInfoErrorResponse,\n    \"DiscoveryRequest\": DiscoveryRequest,\n    \"DiscoveryResponse\": DiscoveryResponse,\n    \"ResourceRequest\": ResourceRequest,\n    # LOGOUT messages\n    \"LogoutToken\": LogoutToken,\n    \"BackChannelLogoutRequest\": BackChannelLogoutRequest,\n    \"FrontChannelLogoutRequest\": FrontChannelLogoutRequest,\n}\n\n\ndef factory(msgtype):\n    warnings.warn(\n        \"`factory` is deprecated. Use `OIDCMessageFactory` instead.\", DeprecationWarning\n    )\n    for _, obj in inspect.getmembers(sys.modules[__name__]):\n        if inspect.isclass(obj) and issubclass(obj, Message):\n            try:\n                if obj.__name__ == msgtype:\n                    return obj\n            except AttributeError:\n                pass\n\n    # Fall back to basic OAuth2 messages\n    return message.factory(msgtype)\n\n\nclass OIDCMessageFactory(MessageFactory):\n    \"\"\"Factory that knows OIDC message types.\"\"\"\n\n    authorization_endpoint = MessageTuple(AuthorizationRequest, AuthorizationResponse)\n    token_endpoint = MessageTuple(AccessTokenRequest, AccessTokenResponse)\n    refresh_endpoint = MessageTuple(RefreshAccessTokenRequest, AccessTokenResponse)\n    resource_endpoint = MessageTuple(ResourceRequest, Message)\n    configuration_endpoint = MessageTuple(Message, ProviderConfigurationResponse)\n\n    userinfo_endpoint = MessageTuple(UserInfoRequest, Message)\n    registration_endpoint = MessageTuple(RegistrationRequest, RegistrationResponse)\n    endsession_endpoint = MessageTuple(EndSessionRequest, EndSessionResponse)\n    checkid_endpoint = MessageTuple(CheckIDRequest, IdToken)\n    checksession_endpoint = MessageTuple(CheckSessionRequest, IdToken)\n    refreshsession_endpoint = MessageTuple(\n        RefreshSessionRequest, RefreshSessionResponse\n    )\n    discovery_endpoint = MessageTuple(DiscoveryRequest, DiscoveryResponse)\n", "import json\nimport os\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlparse\n\nimport pytest\nimport responses\nfrom freezegun import freeze_time\nfrom jwkest import BadSignature\nfrom jwkest.jwk import SYMKey\n\nfrom oic.oauth2.message import MissingSigningKey\nfrom oic.oic import DEF_SIGN_ALG\nfrom oic.oic import Server\nfrom oic.oic import response_types_to_grant_types\nfrom oic.oic.consumer import IGNORE\nfrom oic.oic.consumer import Consumer\nfrom oic.oic.consumer import clean_response\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import ProviderConfigurationResponse\nfrom oic.oic.message import RegistrationResponse\nfrom oic.utils.authn.client import CLIENT_AUTHN_METHOD\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.keyio import keybundle_from_local_file\nfrom oic.utils.sdb import DictSessionBackend\nfrom oic.utils.sdb import session_get\nfrom oic.utils.time_util import utc_time_sans_frac\n\n__author__ = \"rohe0002\"\n\nKC_SYM_VS = KeyBundle({\"kty\": \"oct\", \"key\": \"abcdefghijklmnop\", \"use\": \"ver\"})\nKC_SYM_S = KeyBundle({\"kty\": \"oct\", \"key\": \"abcdefghijklmnop\", \"use\": \"sig\"})\n\nBASE_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), \"data/keys\"))\nKC_RSA = keybundle_from_local_file(\n    os.path.join(BASE_PATH, \"rsa.key\"), \"rsa\", [\"ver\", \"sig\"]\n)\n\nSRVKEYS = KeyJar()\nSRVKEYS[\"\"] = [KC_RSA]\nSRVKEYS[\"client_1\"] = [KC_SYM_VS, KC_RSA]\n\nCLIKEYS = KeyJar()\nCLIKEYS[\"http://localhost:8088\"] = [KC_RSA]\nCLIKEYS[\"\"] = [KC_RSA, KC_SYM_VS]\nCLIKEYS[\"https://example.com\"] = [KC_RSA]\n\nSERVER_INFO = {\n    \"version\": \"3.0\",\n    \"issuer\": \"https://localhost:8088\",\n    \"authorization_endpoint\": \"http://localhost:8088/authorization\",\n    \"token_endpoint\": \"http://localhost:8088/token\",\n    \"userinfo_endpoint\": \"http://localhost:8088/userinfo\",\n    \"flows_supported\": [\"code\", \"token\"],\n}\n\nCONFIG = {\n    \"authz_page\": \"authz\",\n    \"scope\": [\"openid\"],\n    \"response_type\": \"code\",\n    \"request_method\": \"parameter\",\n    \"password\": \"hemligt\",\n    \"max_age\": 3600,\n    \"user_info\": {\"name\": None},\n}\n\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\ndef test_response_types_to_grant_types():\n    req_args = [\"code\"]\n    assert set(response_types_to_grant_types(req_args)) == {\"authorization_code\"}\n    req_args = [\"code\", \"code id_token\"]\n    assert set(response_types_to_grant_types(req_args)) == {\n        \"authorization_code\",\n        \"implicit\",\n    }\n    req_args = [\"code\", \"id_token code\", \"code token id_token\"]\n    assert set(response_types_to_grant_types(req_args)) == {\n        \"authorization_code\",\n        \"implicit\",\n    }\n\n    req_args = [\"code\", \"id_token code\", \"code token id_token\"]\n    kwargs = {\"grant_types\": [\"refresh_token\", \"authorization_code\"]}\n    assert set(response_types_to_grant_types(req_args, **kwargs)) == {\n        \"authorization_code\",\n        \"implicit\",\n        \"refresh_token\",\n    }\n    with pytest.raises(ValueError):\n        response_types_to_grant_types([\"foobar openid\"])\n\n\ndef test_clean_response():\n    atr = AccessTokenResponse(\n        access_token=\"access_token\",\n        token_type=\"bearer\",\n        expires_in=600,\n        refresh_token=\"refresh\",\n        steps=39,\n        stalls=\"yes\",\n    )\n\n    catr = clean_response(atr)\n    atr_keys = atr.keys()\n    catr_keys = catr.keys()\n    assert _eq(\n        atr_keys,\n        [\n            \"token_type\",\n            \"access_token\",\n            \"expires_in\",\n            \"refresh_token\",\n            \"steps\",\n            \"stalls\",\n        ],\n    )\n    assert _eq(catr_keys, [\"token_type\", \"access_token\", \"expires_in\", \"refresh_token\"])\n\n\nclass TestOICConsumer:\n    @pytest.fixture(autouse=True)\n    def setup_consumer(self, session_db_factory):\n        client_id = \"client_1\"\n        client_config = {\n            \"client_id\": client_id,\n            \"client_authn_method\": CLIENT_AUTHN_METHOD,\n        }\n\n        self.consumer = Consumer(\n            DictSessionBackend(), CONFIG, client_config, SERVER_INFO\n        )\n        self.consumer.behaviour = {\n            \"request_object_signing_alg\": DEF_SIGN_ALG[\"openid_request_object\"]\n        }\n        self.consumer.keyjar = CLIKEYS\n        self.consumer.redirect_uris = [\"https://example.com/cb\"]\n        self.consumer.authorization_endpoint = \"https://example.com/authorization\"\n        self.consumer.token_endpoint = \"https://example.com/token\"\n        self.consumer.userinfo_endpoint = \"https://example.com/userinfo\"  # type: ignore\n        self.consumer.client_secret = \"hemlig\"\n        self.consumer.secret_type = \"basic\"\n\n    def test_backup_keys(self):\n        keys = self.consumer.__dict__.keys()\n        _dict = self.consumer.dictionary()\n        dkeys = [key for key in keys if key not in _dict.keys()]\n        assert _eq(dkeys, IGNORE)\n\n    def test_backup_restore(self):\n        authz_org_url = \"http://example.org/authorization\"\n\n        _dict = sorted(list(self.consumer.__dict__.items()))\n\n        self.consumer._backup(\"sid\")\n        self.consumer.restore(\"sid\")\n        assert sorted(_dict) == sorted(list(self.consumer.__dict__.items()))\n\n        self.consumer.authorization_endpoint = authz_org_url\n        assert _dict != sorted(list(self.consumer.__dict__.items()))\n\n        self.consumer.restore(\"sid\")\n        assert _dict == sorted(list(self.consumer.__dict__.items()))\n\n    def test_backup_restore_update(self):\n        authz_org_url = \"http://example.org/authorization\"\n\n        self.consumer._backup(\"sid\")\n\n        self.consumer.authorization_endpoint = authz_org_url\n        self.consumer.token_endpoint = \"https://example.org/token\"\n        self.consumer.userinfo_endpoint = \"\"  # type: ignore\n\n        assert self.consumer.authorization_endpoint == authz_org_url\n        assert self.consumer.token_endpoint == \"https://example.org/token\"\n        assert self.consumer.userinfo_endpoint == \"\"  # type: ignore\n\n        self.consumer.update(\"sid\")\n\n        assert self.consumer.authorization_endpoint == authz_org_url\n        assert self.consumer.token_endpoint == \"https://example.org/token\"\n        assert (\n            self.consumer.userinfo_endpoint  # type: ignore\n            == \"https://example.com/userinfo\"\n        )\n\n    def test_begin(self):\n        srv = Server()\n        srv.keyjar = SRVKEYS\n        sid, location = self.consumer.begin(\"openid\", \"code\")\n        authreq = srv.parse_authorization_request(url=location)\n        assert _eq(\n            list(authreq.keys()),\n            [\n                \"state\",\n                \"max_age\",\n                \"claims\",\n                \"response_type\",\n                \"client_id\",\n                \"scope\",\n                \"redirect_uri\",\n            ],\n        )\n\n        assert authreq[\"state\"] == sid\n        assert authreq[\"scope\"] == self.consumer.consumer_config[\"scope\"]\n        assert authreq[\"client_id\"] == self.consumer.client_id\n\n    def test_begin_file(self, tmpdir):\n        path = tmpdir.strpath\n        external_path = \"/exported\"\n        self.consumer.consumer_config[\"request_method\"] = \"file\"\n        self.consumer.consumer_config[\"temp_dir\"] = path\n        self.consumer.consumer_config[\"temp_path\"] = external_path\n        self.consumer.consumer_config[\"authz_page\"] = \"/authz\"\n        srv = Server()\n        srv.keyjar = SRVKEYS\n\n        sid, location = self.consumer.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n\n        with responses.RequestsMock() as rsps:\n            p = urlparse(self.consumer.request_uri)\n            assert p.netloc == \"localhost:8087\"\n            # Map the URL path to the local path\n            relative_path = os.path.relpath(p.path, external_path)\n            file_path = os.path.join(path, relative_path)\n\n            with open(file_path) as f:\n                rsps.add(\n                    rsps.GET,\n                    self.consumer.request_uri,\n                    body=f.read(),\n                    status=200,\n                    content_type=\"application/urlencoded\",\n                )\n\n            authreq = srv.parse_authorization_request(url=location)\n            assert _eq(\n                list(authreq.keys()),\n                [\n                    \"max_age\",\n                    \"state\",\n                    \"redirect_uri\",\n                    \"response_type\",\n                    \"client_id\",\n                    \"scope\",\n                    \"claims\",\n                ],\n            )\n\n            assert authreq[\"state\"] == sid\n            assert authreq[\"scope\"] == self.consumer.consumer_config[\"scope\"]\n            assert authreq[\"client_id\"] == self.consumer.client_id\n            assert authreq[\"redirect_uri\"].startswith(\"http://localhost:8087/authz\")\n\n    def test_complete(self):\n        _state = \"state0\"\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            resp = self.consumer.complete(_state)\n        assert isinstance(resp, AccessTokenResponse)\n        assert _eq(resp.keys(), [\"token_type\", \"state\", \"access_token\", \"scope\"])\n\n        assert resp[\"state\"] == _state\n\n    def test_parse_authz(self):\n        _state = \"state0\"\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n        self.consumer._backup(_state)\n\n        part = self.consumer.parse_authz(query=result.headers[\"location\"])\n        atr = part[0]\n        assert part[1] is None\n        assert part[2] is None\n\n        assert isinstance(atr, AuthorizationResponse)\n        assert atr[\"state\"] == _state\n        assert \"code\" in atr\n\n    def test_parse_authz_implicit(self):\n        self.consumer.consumer_config[\"response_type\"] = [\"token\"]\n        _state = \"statxxx\"\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"implicit\",\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"https://example.com/cb\",\n        }\n\n        location = (\n            \"https://example.com/cb?access_token=token&token_type=bearer&state=statxxx\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n\n        part = self.consumer.parse_authz(query=result.headers[\"location\"])\n        assert part[0] is None\n        atr = part[1]\n        assert part[2] is None\n\n        assert isinstance(atr, AccessTokenResponse)\n        assert atr[\"state\"] == _state\n        assert \"access_token\" in atr\n\n    def test_complete_secret_auth(self):\n        _state = \"state0\"\n        del self.consumer.consumer_config[\"password\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            resp = self.consumer.complete(_state)\n        assert isinstance(resp, AccessTokenResponse)\n        assert _eq(resp.keys(), [\"token_type\", \"state\", \"access_token\", \"scope\"])\n\n        assert resp[\"state\"] == _state\n\n    def test_complete_auth_token(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"code\", \"token\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n\n        location = (\n            \"https://example.com/cb?code=some_code&state=state0&access_token=token&token_type=bearer\"\n            \"&client_id=client_1&scope=openid\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n        self.consumer._backup(\"state0\")\n\n        parsed = urlparse(result.headers[\"location\"])\n        part = self.consumer.parse_authz(query=parsed.query)\n        auth = part[0]\n        acc = part[1]\n        assert part[2] is None\n\n        assert isinstance(auth, AuthorizationResponse)\n        assert isinstance(acc, AccessTokenResponse)\n        assert _eq(\n            auth.keys(),\n            [\"code\", \"access_token\", \"token_type\", \"state\", \"client_id\", \"scope\"],\n        )\n        assert _eq(acc.keys(), [\"token_type\", \"state\", \"access_token\", \"scope\"])\n\n    def test_complete_auth_token_idtoken(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\", \"token\"]\n        self.consumer.registration_response = RegistrationResponse(\n            id_token_signed_response_alg=\"RS256\"\n        )\n        self.consumer.provider_info = ProviderConfigurationResponse(\n            issuer=\"https://example.com\"\n        )  # abs min\n        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n        token = IdToken(\n            iss=\"https://example.com\",\n            aud=\"client_1\",\n            sub=\"some_sub\",\n            exp=1565348600,\n            iat=1565348300,\n            nonce=\"nonce\",\n        )\n        location = (\n            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n            \"scope=openid&id_token={}\".format(\n                token.to_jwt(key=KC_RSA.keys(), algorithm=\"RS256\")\n            )\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            query = parse_qs(urlparse(result.request.url).query)\n            assert query[\"client_id\"] == [\"client_1\"]\n            assert query[\"scope\"] == [\"openid\"]\n            assert query[\"response_type\"] == [\"id_token token\"]\n            assert query[\"state\"] == [\"state0\"]\n            assert query[\"nonce\"] == [\"nonce\"]\n            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n\n        parsed = urlparse(result.headers[\"location\"])\n\n        with freeze_time(\"2019-08-09 11:00:00\"):\n            part = self.consumer.parse_authz(\n                query=parsed.query, algs=self.consumer.sign_enc_algs(\"id_token\")\n            )\n        auth = part[0]\n        atr = part[1]\n        assert part[2] is None\n\n        assert auth is None\n        assert isinstance(atr, AccessTokenResponse)\n        assert _eq(\n            atr.keys(), [\"access_token\", \"id_token\", \"token_type\", \"state\", \"scope\"]\n        )\n\n        with freeze_time(\"2019-08-09 11:00:00\"):\n            self.consumer.verify_id_token(\n                atr[\"id_token\"], self.consumer.authz_req[atr[\"state\"]]\n            )\n\n    def test_userinfo(self):\n        _state = \"state0\"\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/userinfo\",\n                content_type=\"application/json\",\n                json={\n                    \"name\": \"Ilja\",\n                    \"sub\": \"some_sub\",\n                    \"email\": \"ilja@example.com\",\n                    \"nickname\": \"Ilja\",\n                    \"verified\": True,\n                },\n            )\n\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            self.consumer.complete(_state)\n\n            result = self.consumer.get_user_info(_state)\n        assert isinstance(result, OpenIDSchema)\n        assert _eq(result.keys(), [\"name\", \"email\", \"verified\", \"nickname\", \"sub\"])\n\n    def test_sign_userinfo(self):\n        _state = \"state0\"\n        self.consumer.client_prefs = {\"userinfo_signed_response_alg\": \"RS256\"}\n        del self.consumer.consumer_config[\"request_method\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/userinfo\",\n                content_type=\"application/json\",\n                json={\n                    \"name\": \"Ilja\",\n                    \"sub\": \"some_sub\",\n                    \"email\": \"ilja@example.com\",\n                    \"nickname\": \"Ilja\",\n                    \"verified\": True,\n                },\n            )\n            self.consumer.begin(\"openid\", \"code\")\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            self.consumer.complete(_state)\n\n            result = self.consumer.get_user_info(_state)\n        assert isinstance(result, OpenIDSchema)\n        assert _eq(result.keys(), [\"name\", \"email\", \"verified\", \"nickname\", \"sub\"])\n\n    def test_get_userinfo_claims(self):\n        _state = \"state0\"\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/userinfo\",\n                content_type=\"application/json\",\n                json={\n                    \"name\": \"Ilja\",\n                    \"sub\": \"some_sub\",\n                    \"email\": \"ilja@example.com\",\n                    \"nickname\": \"Ilja\",\n                    \"verified\": True,\n                },\n            )\n\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n            response = self.consumer.complete(_state)\n            result = self.consumer.get_userinfo_claims(\n                response[\"access_token\"],\n                self.consumer.userinfo_endpoint,  # type: ignore\n            )\n        assert isinstance(result, OpenIDSchema)\n        assert _eq(result.keys(), [\"name\", \"email\", \"verified\", \"nickname\", \"sub\"])\n\n    def real_test_discover(self):\n        c = Consumer(None, None)\n        principal = \"nav@connect-op.heroku.com\"\n        res = c.discover(principal)\n        assert isinstance(res, ProviderConfigurationResponse)\n        assert _eq(\n            res.keys(),\n            [\n                \"registration_endpoint\",\n                \"scopes_supported\",\n                \"identifiers_supported\",\n                \"token_endpoint\",\n                \"flows_supported\",\n                \"version\",\n                \"userinfo_endpoint\",\n                \"authorization_endpoint\",\n                \"x509_url\",\n                \"issuer\",\n            ],\n        )\n        assert res.version == \"3.0\"  # type: ignore\n        assert _eq(\n            res.flows_supported,  # type: ignore\n            [\n                \"code\",\n                \"token\",\n                \"id_token\",\n                \"code token\",\n                \"code id_token\",\n                \"id_token token\",\n            ],\n        )\n\n    def test_discover(self):\n        c = Consumer(None, None)\n        webfinger = {\n            \"subject\": \"acct:foo@example.com\",\n            \"links\": [\n                {\n                    \"rel\": \"http://openid.net/specs/connect/1.0/issuer\",\n                    \"href\": \"https://localhost:8088/\",\n                }\n            ],\n        }\n        principal = \"foo@example.com\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/.well-known/webfinger\"\n                \"?resource=acct%3Afoo%40example.com&rel=http%3A%2F%2Fopenid.net%2Fspecs%2Fconnect%2F1.0%2Fissuer\",\n                json=webfinger,\n            )\n            res = c.discover(principal)\n        assert res == \"https://localhost:8088/\"\n\n    def test_client_register(self):\n        c = Consumer(None, None)\n        c.redirect_uris = [\"https://example.com/authz\"]\n        reg_resp = {\n            \"client_id\": \"some_client\",\n            \"client_secret\": \"super_secret\",\n            \"client_secret_expires_at\": 123456789,\n            \"redirect_uris\": [\"https://example.com/authz\"],\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(responses.POST, \"https://example.com/register/\", json=reg_resp)\n            c.register(\"https://example.com/register/\")\n            assert json.loads(rsps.calls[0].request.body) == {\n                \"application_type\": \"web\",\n                \"response_types\": [\"code\"],\n                \"redirect_uris\": [\"https://example.com/authz\"],\n                \"grant_types\": [\"authorization_code\"],\n            }\n        assert c.client_id == \"some_client\"\n        assert c.client_secret == \"super_secret\"\n        assert c.registration_expires == 123456789\n\n    def test_client_register_token(self):\n        c = Consumer(None, None)\n\n        c.redirect_uris = [\"https://example.com/authz\"]\n\n        client_info = {\n            \"client_id\": \"clientid\",\n            \"redirect_uris\": [\"https://example.com/authz\"],\n        }\n\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                rsps.POST,\n                \"https://provider.example.com/registration/\",\n                json=client_info,\n            )\n            c.register(\n                \"https://provider.example.com/registration/\",\n                registration_token=\"initial_registration_token\",\n            )\n            header = rsps.calls[0].request.headers[\"Authorization\"]\n            assert header == \"Bearer aW5pdGlhbF9yZWdpc3RyYXRpb25fdG9rZW4=\"\n\n    def test_client_register_token_b64(self):\n        c = Consumer(None, None)\n\n        c.redirect_uris = [\"https://example.com/authz\"]\n\n        client_info = {\n            \"client_id\": \"clientid\",\n            \"redirect_uris\": [\"https://example.com/authz\"],\n        }\n        registration_token = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6IC\"\n            \"JlYjc1N2M3Yy00MWRlLTRmZDYtOTkwNy1hNGFiMDY1ZjEzMmEifQ.eyJqdGkiOiI2ZWY0MDZi\"\n            \"MC02YzA3LTQ0NzctOWU1YS1hY2FiZjNiMWNiMjgiLCJleHAiOjAsIm5iZiI6MCwiaWF0Ijox\"\n            \"NTczNzMxNjg5LCJpc3MiOiJodHRwczovL29wZW5pZC1wcm92aWRlci5leGFtcGxlLmNvbS9h\"\n            \"dXRoL3JlYWxtcy9tYXN0ZXIiLCJhdWQiOiJodHRwczovL29wZW5pZC1wcm92aWRlci5leGFt\"\n            \"cGxlLmNvbS9hdXRoL3JlYWxtcy9tYXN0ZXIiLCJ0eXAiOiJJbml0aWFsQWNjZXNzVG9rZW4i\"\n            \"fQ.0XTlit_JcxPZeIy8A4BzrHn1NvegVP7ws8KI0ySFex8\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                rsps.POST,\n                \"https://provider.example.com/registration/\",\n                json=client_info,\n            )\n            c.register(\n                \"https://provider.example.com/registration/\",\n                registration_token=registration_token,\n            )\n            header = rsps.calls[0].request.headers[\"Authorization\"]\n            assert header == \"Bearer \" + registration_token\n\n    def _faulty_id_token(self):\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://alpha.cloud.nds.rub.de\",\n            \"exp\": 1420823073,\n            \"iat\": 1420822473,\n            \"aud\": \"TestClient\",\n        }\n        idts = IdToken(**idval)\n\n        _signed_jwt = idts.to_jwt(key=[SYMKey(key=\"TestPassword\")], algorithm=\"HS256\")\n\n        # Mess with the signed id_token\n        p = _signed_jwt.split(\".\")\n        p[2] = \"aaa\"\n\n        return \".\".join(p)\n\n    def test_faulty_id_token(self):\n        _faulty_signed_jwt = self._faulty_id_token()\n\n        with pytest.raises(BadSignature):\n            IdToken().from_jwt(_faulty_signed_jwt, key=[SYMKey(key=\"TestPassword\")])\n\n        # What if no verification key is given ?\n        # Should also result in an exception\n        with pytest.raises(MissingSigningKey):\n            IdToken().from_jwt(_faulty_signed_jwt)\n\n    def test_faulty_id_token_in_access_token_response(self):\n        c = Consumer(None, None)\n        c.keyjar.add_symmetric(\"\", \"TestPassword\", [\"sig\"])\n\n        _info = {\n            \"access_token\": \"accessTok\",\n            \"id_token\": self._faulty_id_token(),\n            \"token_type\": \"Bearer\",\n        }\n\n        _json = json.dumps(_info)\n        with pytest.raises(ValueError):\n            c.parse_response(AccessTokenResponse, _json, sformat=\"json\")\n\n    def test_faulty_idtoken_from_accesstoken_endpoint(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n        }\n\n        location = (\n            \"https://example.com/cb?state=state0&id_token=eyJhbGciOiJSUzI1NiJ9\"\n            \".eyJpc3MiOiAiaHR0cDovL2xvY2FsaG9zdDo4MDg4IiwgInN1YiI6ICJhNWRkMjRiMmYwOGE2ODZmZDM4NmMyMmM\"\n            \"zZmY4ZWUyODFlZjJmYmZmMWZkZTcwMDg2NjhjZGEzZGVjZmE0NjY5IiwgImF1ZCI6IFsiY2xpZW50XzEiXSwgImV\"\n            \"4cCI6IDE1NzIwOTk5NjAsICJhY3IiOiAiMiIsICJpYXQiOiAxNTcyMDEzNTYwLCAibm9uY2UiOiAibmdFTGZVdmN\"\n            \"PMWoyaXNWcXkwQWNwM0NOYlZnMGdFRDEifQ.aaa\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n        self.consumer._backup(\"state0\")\n\n        assert result.status_code == 302\n        query = urlparse(result.headers[\"location\"]).query\n        with pytest.raises(BadSignature):\n            self.consumer.parse_authz(query=query)\n\n    def test_get_session_management_id(self):\n        now = utc_time_sans_frac()\n        smid = \"session_management_id\"\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://example.com\",\n            \"exp\": now + 3600,\n            \"iat\": now,\n            \"aud\": self.consumer.client_id,\n            \"sid\": smid,\n        }\n        idts = IdToken(**idval)\n\n        _signed_jwt = idts.to_jwt(key=KC_RSA.keys(), algorithm=\"RS256\")\n\n        _state = \"state\"\n        self.consumer.sdb[_state] = {\"redirect_uris\": [\"https://example.org/cb\"]}\n        resp = AuthorizationResponse(id_token=_signed_jwt, state=_state)\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\"]\n        self.consumer.parse_authz(resp.to_urlencoded())\n        assert self.consumer.sso_db[\"state\"][\"smid\"] == smid\n        assert session_get(self.consumer.sso_db, \"smid\", smid) == [_state]\n", "import os\nfrom time import time\n\nimport pytest\n\nfrom oic import rndstr\nfrom oic.exception import MessageException\nfrom oic.oic import AccessTokenResponse\nfrom oic.oic.consumer import Consumer\nfrom oic.oic.message import BACK_CHANNEL_LOGOUT_EVENT\nfrom oic.oic.message import AccessTokenRequest\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import BackChannelLogoutRequest\nfrom oic.oic.message import LogoutToken\nfrom oic.oic.provider import Provider\nfrom oic.utils.authn.authn_context import AuthnBroker\nfrom oic.utils.authn.client import CLIENT_AUTHN_METHOD\nfrom oic.utils.authn.client import verify_client\nfrom oic.utils.authn.user import UserAuthnMethod\nfrom oic.utils.authz import AuthzHandling\nfrom oic.utils.jwt import JWT\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.keyio import keybundle_from_local_file\nfrom oic.utils.sdb import session_update\nfrom oic.utils.session_backend import DictSessionBackend\nfrom oic.utils.userinfo import UserInfo\n\n# -- CLIENT INFO ----\n\nCLIENT_ID = \"client_1\"\nISSUER_ID = \"https://example.org\"\n\nKC_SYM_S = KeyBundle({\"kty\": \"oct\", \"key\": \"abcdefghijklmnop\", \"use\": \"sig\"})\n\nBASE_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), \"data/keys\"))\nKC_RSA = keybundle_from_local_file(\n    os.path.join(BASE_PATH, \"rsa.key\"), \"rsa\", [\"ver\", \"sig\"]\n)\n\nCLIKEYS = KeyJar()\nCLIKEYS[\"\"] = [KC_RSA, KC_SYM_S]\nCLIKEYS[CLIENT_ID] = [KC_RSA, KC_SYM_S]\nCLIKEYS[ISSUER_ID] = [KC_RSA]\n\nCONFIG = {\n    \"authz_page\": \"authz\",\n    \"scope\": [\"openid\"],\n    \"response_type\": \"code\",\n    \"password\": \"hemligt\",\n    \"max_age\": 3600,\n}\n\n# Provider information\n\nSERVER_INFO = {\n    \"version\": \"3.0\",\n    \"issuer\": ISSUER_ID,\n    \"authorization_endpoint\": \"https://example.org/authorization\",\n    \"token_endpoint\": \"https://example.org/token\",\n    \"flows_supported\": [\"code\", \"token\", \"code token\"],\n}\n\nSRVKEYS = KeyJar()\nSRVKEYS[\"\"] = [KC_RSA]\nSRVKEYS[CLIENT_ID] = [KC_SYM_S, KC_RSA]\nSRVKEYS[ISSUER_ID] = [KC_SYM_S, KC_RSA]\n\nCDB = {\n    CLIENT_ID: {\n        \"password\": \"hemligt\",\n        \"client_secret\": \"drickyoughurt\",\n        \"redirect_uris\": [(\"https://example.com/authz\", None)],\n        \"post_logout_redirect_uris\": [(\"https://example.com/post_logout\", None)],\n        \"client_salt\": \"salted\",\n        \"response_types\": [\"code\"],\n    }\n}\n\nUSERDB = {\n    \"username\": {\n        \"name\": \"Linda Lindgren\",\n        \"nickname\": \"Linda\",\n        \"email\": \"linda@example.com\",\n        \"verified\": True,\n        \"sub\": \"username\",\n        \"extra_claim\": \"extra_claim_value\",\n    }\n}\n\nURLMAP = {CLIENT_ID: [\"https://example.com/authz\"]}\n\n\nclass DummyAuthn(UserAuthnMethod):\n    def __init__(self, srv, user):\n        UserAuthnMethod.__init__(self, srv)\n        self.user = user\n\n    def authenticated_as(self, cookie=None, **kwargs):\n        if cookie == \"FAIL\":\n            return None, 0\n        else:\n            return {\"uid\": self.user}, time()\n\n\nAUTHN_BROKER = AuthnBroker()\nAUTHN_BROKER.add(\"UNDEFINED\", DummyAuthn(None, \"username\"))\n\n# dealing with authorization\nAUTHZ = AuthzHandling()\nSYMKEY = rndstr(16)  # symmetric key used to encrypt cookie info\nUSERINFO = UserInfo(USERDB)\n\n# AUTHZ request\n\nAREQ = AuthorizationRequest(\n    response_type=\"code\",\n    client_id=CLIENT_ID,\n    redirect_uri=\"https://example.com/authz\",\n    scope=[\"openid\"],\n    state=\"state000\",\n)\n\n\nclass TestOICConsumerLogout:\n    @pytest.fixture(autouse=True)\n    def setup_consumer(self, session_db_factory):\n        client_config = {\n            \"client_id\": CLIENT_ID,\n            \"client_authn_method\": CLIENT_AUTHN_METHOD,\n        }\n\n        self.consumer = Consumer(\n            DictSessionBackend(), CONFIG, client_config, SERVER_INFO\n        )\n        self.consumer.keyjar = CLIKEYS\n        self.consumer.redirect_uris = [\"https://example.com/authz\"]\n        self.consumer.client_secret = \"hemlig\"\n        self.consumer.secret_type = \"basic\"\n        self.consumer.issuer = ISSUER_ID\n\n        self.provider = Provider(\n            ISSUER_ID,\n            session_db_factory(ISSUER_ID),\n            CDB,\n            AUTHN_BROKER,\n            USERINFO,\n            AUTHZ,\n            verify_client,\n            SYMKEY,\n            urlmap=URLMAP,\n            keyjar=SRVKEYS,\n        )\n        self.provider.baseurl = self.provider.name\n\n    def test_logout_with_sub(self):\n        # Simulate an authorization\n        sid, request_location = self.consumer.begin(\n            \"openid\", \"code\", path=\"https://example.com\"\n        )\n        resp = self.provider.authorization_endpoint(request=request_location)\n        aresp = self.consumer.parse_authz(resp.message)\n\n        assert self.consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n\n        # Simulate an accesstoken request\n        areq = AccessTokenRequest(\n            code=aresp[0][\"code\"],\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=self.consumer.client_secret,\n            grant_type=\"authorization_code\",\n        )\n        token_resp = self.provider.code_grant_type(areq)\n        tresp = self.consumer.parse_response(\n            AccessTokenResponse, token_resp.message, sformat=\"json\"\n        )\n\n        # Now, for the backchannel logout. This happens on the OP\n        logout_info = {\n            \"sub\": tresp[\"id_token\"][\"sub\"],\n            \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}},\n        }\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        _sid = self.consumer.backchannel_logout(request_args=request.to_dict())\n\n        assert _sid == sid\n\n        # Test other coding\n        _sid = self.consumer.backchannel_logout(request=request.to_urlencoded())\n        assert _sid == sid\n\n    def test_not_for_me(self):\n        _sub = \"sub\"\n\n        logout_info = {\"sub\": _sub, \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}}}\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=\"someone\", **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        with pytest.raises(MessageException):\n            self.consumer.backchannel_logout(request_args=request.to_dict())\n\n    def test_logout_without_sub(self):\n        # Simulate an authorization\n        sid, request_location = self.consumer.begin(\n            \"openid\", \"code\", path=\"https://example.com\"\n        )\n        resp = self.provider.authorization_endpoint(request=request_location)\n        aresp = self.consumer.parse_authz(resp.message)\n\n        assert self.consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n\n        # Simulate an accesstoken request\n        areq = AccessTokenRequest(\n            code=aresp[0][\"code\"],\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=self.consumer.client_secret,\n            grant_type=\"authorization_code\",\n        )\n        token_resp = self.provider.code_grant_type(areq)\n        self.consumer.parse_response(\n            AccessTokenResponse, token_resp.message, sformat=\"json\"\n        )\n        # Have to fake this until the provider changes are in place\n        _smid = \"session_management_id\"\n        self.consumer.sso_db.update(sid, \"smid\", _smid)\n\n        # Now, for the backchannel logout. This happens on the OP\n        logout_info = {\"sid\": _smid, \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}}}\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        _sid = self.consumer.backchannel_logout(request_args=request.to_dict())\n\n        assert _sid == [sid]\n\n    def test_logout_with_none(self):\n        # Now for the backchannel logout. This happens on the OP\n\n        logout_info = LogoutToken(events={BACK_CHANNEL_LOGOUT_EVENT: {}})\n\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        with pytest.raises(MessageException):\n            self.consumer.backchannel_logout(request_args=request.to_dict())\n\n    def test_sso_db_dict(self):\n        client_config = {\n            \"client_id\": CLIENT_ID,\n            \"client_authn_method\": CLIENT_AUTHN_METHOD,\n        }\n\n        _consumer = Consumer({}, CONFIG, client_config, SERVER_INFO, sso_db={})\n        _consumer.keyjar = CLIKEYS\n        _consumer.redirect_uris = [\"https://example.com/authz\"]\n        _consumer.client_secret = \"hemlig\"\n        _consumer.secret_type = \"basic\"\n        _consumer.issuer = ISSUER_ID\n\n        # Simulate an authorization\n        sid, request_location = _consumer.begin(\n            \"openid\", \"code\", path=\"https://example.com\"\n        )\n        resp = self.provider.authorization_endpoint(request=request_location)\n        aresp = _consumer.parse_authz(resp.message)\n\n        assert _consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n\n        # Simulate an accesstoken request\n        areq = AccessTokenRequest(\n            code=aresp[0][\"code\"],\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=_consumer.client_secret,\n            grant_type=\"authorization_code\",\n        )\n        token_resp = self.provider.code_grant_type(areq)\n        tresp = _consumer.parse_response(\n            AccessTokenResponse, token_resp.message, sformat=\"json\"\n        )\n\n        # Now, for the backchannel logout. This happens on the OP\n        logout_info = {\n            \"sub\": tresp[\"id_token\"][\"sub\"],\n            \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}},\n        }\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        _sid = _consumer.backchannel_logout(request_args=request.to_dict())\n        assert _sid == sid\n\n    def test_attribute_error(self):\n        self.consumer.sdb.update(\"sid\", \"foo\", \"bar\")\n        self.consumer.update(\"sid\")\n\n        with pytest.raises(AttributeError):\n            getattr(self.consumer, \"foo\")\n\n\ndef test_session_update():\n    with pytest.raises(KeyError):\n        session_update({}, \"session_id\", \"attr\", \"val\")\n", "import json\nimport os\nimport sys\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom jwkest import BadSignature\nfrom jwkest.jwk import SYMKey\nfrom jwkest.jws import left_hash\n\nfrom oic import rndstr\nfrom oic.exception import MessageException\nfrom oic.exception import NotForMe\nfrom oic.oauth2.message import MissingRequiredAttribute\nfrom oic.oauth2.message import MissingRequiredValue\nfrom oic.oauth2.message import WrongSigningAlgorithm\nfrom oic.oic.message import BACK_CHANNEL_LOGOUT_EVENT\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AddressClaim\nfrom oic.oic.message import AtHashError\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import BackChannelLogoutRequest\nfrom oic.oic.message import CHashError\nfrom oic.oic.message import Claims\nfrom oic.oic.message import FrontChannelLogoutRequest\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import LogoutToken\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import ProviderConfigurationResponse\nfrom oic.oic.message import RegistrationRequest\nfrom oic.oic.message import RegistrationResponse\nfrom oic.oic.message import VerificationError\nfrom oic.oic.message import address_deser\nfrom oic.oic.message import claims_deser\nfrom oic.oic.message import claims_ser\nfrom oic.oic.message import msg_ser\nfrom oic.oic.message import verify_id_token\nfrom oic.utils import time_util\nfrom oic.utils.jwt import JWT\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.time_util import utc_time_sans_frac\n\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\")))\n\n__author__ = \"rohe0002\"\n\n\ndef query_string_compare(query_str1, query_str2):\n    return parse_qs(query_str1) == parse_qs(query_str2)\n\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\ndef test_openidschema():\n    inp = '{\"middle_name\":null, \"updated_at\":\"20170328081544\", \"sub\":\"abc\"}'\n    ois = OpenIDSchema().from_json(inp)\n    assert ois.verify() is False\n\n\n@pytest.mark.parametrize(\n    \"json_param\",\n    [\n        '{\"middle_name\":\"fo\", \"updated_at\":\"20170328081544Z\", \"sub\":\"abc\"}',\n        '{\"middle_name\":true, \"updated_at\":\"20170328081544\", \"sub\":\"abc\"}',\n        '{\"middle_name\":\"fo\", \"updated_at\":false, \"sub\":\"abc\"}',\n        '{\"middle_name\":\"fo\", \"updated_at\":\"20170328081544Z\", \"sub\":true}',\n    ],\n)\ndef test_openidschema_from_json(json_param):\n    with pytest.raises(MessageException):\n        OpenIDSchema().from_json(json_param)\n\n\n@pytest.mark.parametrize(\n    \"json_param\",\n    [\n        '{\"email_verified\":false, \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"email_verified\":true, \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"phone_number_verified\":false, \"phone_number\":\"+1 555 200000\", '\n        '\"sub\":\"abc\"}',\n        '{\"phone_number_verified\":true, \"phone_number\":\"+1 555 20000\", ' '\"sub\":\"abc\"}',\n    ],\n)\ndef test_claim_booleans(json_param):\n    assert OpenIDSchema().from_json(json_param)\n\n\n@pytest.mark.parametrize(\n    \"json_param\",\n    [\n        '{\"email_verified\":\"Not\", \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"email_verified\":\"Sure\", \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"phone_number_verified\":\"Not\", \"phone_number\":\"+1 555 200000\", '\n        '\"sub\":\"abc\"}',\n        '{\"phone_number_verified\":\"Sure\", \"phone_number\":\"+1 555 20000\", '\n        '\"sub\":\"abc\"}',\n    ],\n)\ndef test_claim_not_booleans(json_param):\n    with pytest.raises(MessageException):\n        OpenIDSchema().from_json(json_param)\n\n\ndef test_claims_deser():\n    _dic = {\n        \"userinfo\": {\n            \"given_name\": {\"essential\": True},\n            \"nickname\": None,\n            \"email\": {\"essential\": True},\n            \"email_verified\": {\"essential\": True},\n            \"picture\": None,\n            \"http://example.info/claims/groups\": None,\n        },\n        \"id_token\": {\n            \"auth_time\": {\"essential\": True},\n            \"acr\": {\"values\": [\"urn:mace:incommon:iap:silver\"]},\n        },\n    }\n\n    claims = claims_deser(json.dumps(_dic), sformat=\"json\")\n    assert _eq(claims.keys(), [\"userinfo\", \"id_token\"])\n\n\ndef test_claims_deser_dict():\n    pre = Claims(\n        name={\"essential\": True},\n        nickname=None,\n        email={\"essential\": True},\n        email_verified={\"essential\": True},\n        picture=None,\n    )\n\n    claims = claims_deser(pre.to_json(), sformat=\"json\")\n    assert _eq(\n        claims.keys(), [\"name\", \"nickname\", \"email\", \"email_verified\", \"picture\"]\n    )\n\n    claims = claims_deser(pre.to_dict(), sformat=\"dict\")\n    assert _eq(\n        claims.keys(), [\"name\", \"nickname\", \"email\", \"email_verified\", \"picture\"]\n    )\n\n\ndef test_address_deser():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    adc = address_deser(pre.to_json(), sformat=\"json\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n    adc = address_deser(pre.to_dict(), sformat=\"json\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_json():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    ser = msg_ser(pre, \"json\")\n\n    adc = address_deser(ser, \"json\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_urlencoded():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    ser = msg_ser(pre, \"urlencoded\")\n\n    adc = address_deser(ser, \"urlencoded\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_dict():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    ser = msg_ser(pre, \"dict\")\n\n    adc = address_deser(ser, \"dict\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_from_dict():\n    pre = {\"street_address\": \"Kasamark 114\", \"locality\": \"Umea\", \"country\": \"Sweden\"}\n\n    ser = msg_ser(pre, \"dict\")\n\n    adc = address_deser(ser, \"dict\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_claims_ser_json():\n    claims = Claims(\n        name={\"essential\": True},\n        nickname=None,\n        email={\"essential\": True},\n        email_verified={\"essential\": True},\n        picture=None,\n    )\n    claims = claims_deser(claims_ser(claims, \"json\"), sformat=\"json\")\n    assert _eq(\n        claims.keys(), [\"name\", \"nickname\", \"email\", \"email_verified\", \"picture\"]\n    )\n\n\nclass TestProviderConfigurationResponse(object):\n    def test_deserialize(self):\n        resp = {\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"issuer\": \"https://server.example.com\",\n            \"token_endpoint\": \"https://server.example.com/connect/token\",\n            \"token_endpoint_auth_methods_supported\": [\n                \"client_secret_basic\",\n                \"private_key_jwt\",\n            ],\n            \"userinfo_endpoint\": \"https://server.example.com/connect/user\",\n            \"check_id_endpoint\": \"https://server.example.com/connect/check_id\",\n            \"refresh_session_endpoint\": \"https://server.example.com/connect/refresh_session\",\n            \"end_session_endpoint\": \"https://server.example.com/connect/end_session\",\n            \"jwk_url\": \"https://server.example.com/jwk.json\",\n            \"registration_endpoint\": \"https://server.example.com/connect/register\",\n            \"scopes_supported\": [\"openid\", \"profile\", \"email\", \"address\", \"phone\"],\n            \"response_types_supported\": [\"code\", \"code id_token\", \"token id_token\"],\n            \"acrs_supported\": [\"1\", \"2\", \"http://id.incommon.org/assurance/bronze\"],\n            \"user_id_types_supported\": [\"public\", \"pairwise\"],\n            \"userinfo_algs_supported\": [\n                \"HS256\",\n                \"RS256\",\n                \"A128CBC\",\n                \"A128KW\",\n                \"RSA1_5\",\n            ],\n            \"id_token_algs_supported\": [\n                \"HS256\",\n                \"RS256\",\n                \"A128CBC\",\n                \"A128KW\",\n                \"RSA1_5\",\n            ],\n            \"request_object_algs_supported\": [\n                \"HS256\",\n                \"RS256\",\n                \"A128CBC\",\n                \"A128KW\",\n                \"RSA1_5\",\n            ],\n        }\n\n        pcr = ProviderConfigurationResponse().deserialize(json.dumps(resp), \"json\")\n\n        assert _eq(pcr[\"user_id_types_supported\"], [\"public\", \"pairwise\"])\n        assert _eq(\n            pcr[\"acrs_supported\"], [\"1\", \"2\", \"http://id.incommon.org/assurance/bronze\"]\n        )\n\n    def test_example_response(self):\n        resp = {\n            \"version\": \"3.0\",\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"token_endpoint\": \"https://server.example.com/connect/token\",\n            \"token_endpoint_auth_methods_supported\": [\n                \"client_secret_basic\",\n                \"private_key_jwt\",\n            ],\n            \"token_endpoint_alg_values_supported\": [\"RS256\", \"ES256\"],\n            \"userinfo_endpoint\": \"https://server.example.com/connect/userinfo\",\n            \"check_session_iframe\": \"https://server.example.com/connect/check_session\",\n            \"end_session_endpoint\": \"https://server.example.com/connect/end_session\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"registration_endpoint\": \"https://server.example.com/connect/register\",\n            \"scopes_supported\": [\n                \"openid\",\n                \"profile\",\n                \"email\",\n                \"address\",\n                \"phone\",\n                \"offline_access\",\n            ],\n            \"response_types_supported\": [\n                \"code\",\n                \"code id_token\",\n                \"id_token\",\n                \"token id_token\",\n            ],\n            \"acr_values_supported\": [\n                \"urn:mace:incommon:iap:silver\",\n                \"urn:mace:incommon:iap:bronze\",\n            ],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"userinfo_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n            \"userinfo_encryption_alg_values_supported\": [\"RSA1_5\", \"A128KW\"],\n            \"userinfo_encryption_enc_values_supported\": [\"A128CBC+HS256\", \"A128GCM\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n            \"id_token_encryption_alg_values_supported\": [\"RSA1_5\", \"A128KW\"],\n            \"id_token_encryption_enc_values_supported\": [\"A128CBC+HS256\", \"A128GCM\"],\n            \"request_object_signing_alg_values_supported\": [\"none\", \"RS256\", \"ES256\"],\n            \"display_values_supported\": [\"page\", \"popup\"],\n            \"claim_types_supported\": [\"normal\", \"distributed\"],\n            \"claims_supported\": [\n                \"sub\",\n                \"iss\",\n                \"auth_time\",\n                \"acr\",\n                \"name\",\n                \"given_name\",\n                \"family_name\",\n                \"nickname\",\n                \"profile\",\n                \"picture\",\n                \"website\",\n                \"email\",\n                \"email_verified\",\n                \"locale\",\n                \"zoneinfo\",\n                \"http://example.info/claims/groups\",\n            ],\n            \"claims_parameter_supported\": True,\n            \"service_documentation\": \"http://server.example.com/connect/service_documentation.html\",\n            \"ui_locales_supported\": [\"en-US\", \"en-GB\", \"en-CA\", \"fr-FR\", \"fr-CA\"],\n        }\n\n        pcr = ProviderConfigurationResponse().deserialize(json.dumps(resp), \"json\")\n        rk = list(resp.keys())\n        # parameters with default value if missing\n        rk.extend(\n            [\n                \"grant_types_supported\",\n                \"request_parameter_supported\",\n                \"request_uri_parameter_supported\",\n                \"require_request_uri_registration\",\n                \"frontchannel_logout_supported\",\n                \"frontchannel_logout_session_supported\",\n                \"backchannel_logout_supported\",\n                \"backchannel_logout_session_supported\",\n            ]\n        )\n        assert set(rk) == set(pcr.keys())\n\n    @pytest.mark.parametrize(\n        \"required_param\",\n        [\n            \"issuer\",\n            \"authorization_endpoint\",\n            \"jwks_uri\",\n            \"response_types_supported\",\n            \"subject_types_supported\",\n            \"id_token_signing_alg_values_supported\",\n        ],\n    )\n    def test_required_parameters(self, required_param):\n        provider_config = {\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"response_types_supported\": [\n                \"code\",\n                \"code id_token\",\n                \"id_token\",\n                \"token id_token\",\n            ],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n        }\n\n        del provider_config[required_param]\n        with pytest.raises(MissingRequiredAttribute):\n            ProviderConfigurationResponse(**provider_config).verify()\n\n    def test_token_endpoint_is_not_required_for_implicit_flow_only(self):\n        provider_config = {\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"response_types_supported\": [\"id_token\", \"token id_token\"],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n        }\n\n        # should not raise an exception\n        assert ProviderConfigurationResponse(**provider_config).verify()\n\n    def test_token_endpoint_is_required_for_other_than_implicit_flow_only(self):\n        provider_config = {\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"response_types_supported\": [\"code\", \"id_token\"],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n        }\n\n        with pytest.raises(MissingRequiredAttribute):\n            ProviderConfigurationResponse(**provider_config).verify()\n\n\nclass TestRegistrationRequest(object):\n    def test_deserialize(self):\n        msg = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\n                \"https://client.example.org/callback\",\n                \"https://client.example.org/callback2\",\n            ],\n            \"client_name\": \"My Example\",\n            \"client_name#ja-Jpan-JP\": \"\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u540d\",\n            \"logo_uri\": \"https://client.example.org/logo.png\",\n            \"subject_type\": \"pairwise\",\n            \"sector_identifier_uri\": \"https://other.example.net/file_of_redirect_uris.json\",\n            \"token_endpoint_auth_method\": \"client_secret_basic\",\n            \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n            \"userinfo_encrypted_response_alg\": \"RSA1_5\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC+HS256\",\n            \"contacts\": [\"ve7jtb@example.org\", \"mary@example.org\"],\n            \"request_uris\": [\n                \"https://client.example.org/rf.txt\"\n                \"#qpXaRLh_n93TTR9F252ValdatUQvQiJi5BDub2BeznA\"\n            ],\n        }\n\n        reg = RegistrationRequest().deserialize(json.dumps(msg), \"json\")\n        assert _eq(list(msg.keys()) + [\"response_types\"], reg.keys())\n\n    def test_registration_request(self):\n        req = RegistrationRequest(\n            operation=\"register\",\n            default_max_age=10,\n            require_auth_time=True,\n            default_acr=\"foo\",\n            application_type=\"web\",\n            redirect_uris=[\"https://example.com/authz_cb\"],\n        )\n        js = req.to_json()\n        js_obj = json.loads(js)\n        expected_js_obj = {\n            \"redirect_uris\": [\"https://example.com/authz_cb\"],\n            \"application_type\": \"web\",\n            \"default_acr\": \"foo\",\n            \"require_auth_time\": True,\n            \"operation\": \"register\",\n            \"default_max_age\": 10,\n            \"response_types\": [\"code\"],\n        }\n        assert js_obj == expected_js_obj\n\n        flattened_list_dict = {\n            k: v[0] if isinstance(v, list) else v for k, v in expected_js_obj.items()\n        }\n        assert query_string_compare(req.to_urlencoded(), urlencode(flattened_list_dict))\n\n    @pytest.mark.parametrize(\n        \"enc_param\",\n        [\n            \"request_object_encryption_enc\",\n            \"id_token_encrypted_response_enc\",\n            \"userinfo_encrypted_response_enc\",\n        ],\n    )\n    def test_registration_request_with_coupled_encryption_params(self, enc_param):\n        registration_params = {\n            \"redirect_uris\": [\"https://example.com/authz_cb\"],\n            enc_param: \"RS25asdasd6\",\n        }\n        registration_req = RegistrationRequest(**registration_params)\n        with pytest.raises(AssertionError):\n            registration_req.verify()\n\n\nclass TestRegistrationResponse(object):\n    def test_deserialize(self):\n        msg = {\n            \"client_id\": \"s6BhdRkqt3\",\n            \"client_secret\": \"ZJYCqe3GGRvdrudKyZS0XhGv_Z45DuKhCUk0gBR1vZk\",\n            \"client_secret_expires_at\": 1577858400,\n            \"registration_access_token\": \"this.is.an.access.token.value.ffx83\",\n            \"registration_client_uri\": \"https://server.example.com/connect/register?client_id\"\n            \"=s6BhdRkqt3\",\n            \"token_endpoint_auth_method\": \"client_secret_basic\",\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\n                \"https://client.example.org/callback\",\n                \"https://client.example.org/callback2\",\n            ],\n            \"client_name\": \"My Example\",\n            \"client_name#ja-Jpan-JP\": \"\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u540d\",\n            \"logo_uri\": \"https://client.example.org/logo.png\",\n            \"subject_type\": \"pairwise\",\n            \"sector_identifier_uri\": \"https://other.example.net/file_of_redirect_uris.json\",\n            \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n            \"userinfo_encrypted_response_alg\": \"RSA1_5\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC+HS256\",\n            \"contacts\": [\"ve7jtb@example.org\", \"mary@example.org\"],\n            \"request_uris\": [\n                \"https://client.example.org/rf.txt\"\n                \"#qpXaRLh_n93TTR9F252ValdatUQvQiJi5BDub2BeznA\"\n            ],\n        }\n\n        resp = RegistrationResponse().deserialize(json.dumps(msg), \"json\")\n        assert _eq(msg.keys(), resp.keys())\n\n\nclass TestAuthorizationRequest(object):\n    def test_deserialize(self):\n        query = (\n            \"response_type=token%20id_token&client_id=0acf77d4-b486-4c99\"\n            \"-bd76-074ed6a64ddf&redirect_uri=https%3A%2F%2Fclient.example\"\n            \".com%2Fcb&scope=openid%20profile&state=af0ifjsldkj&nonce=n\"\n            \"-0S6_WzA2Mj\"\n        )\n\n        req = AuthorizationRequest().deserialize(query, \"urlencoded\")\n\n        assert _eq(\n            req.keys(),\n            [\"nonce\", \"state\", \"redirect_uri\", \"response_type\", \"client_id\", \"scope\"],\n        )\n\n        assert req[\"response_type\"] == [\"token\", \"id_token\"]\n        assert req[\"scope\"] == [\"openid\", \"profile\"]\n\n    def test_verify_no_scopes(self):\n        args = {\n            \"client_id\": \"foobar\",\n            \"redirect_uri\": \"http://foobar.example.com/oaclient\",\n            \"response_type\": \"code\",\n        }\n        ar = AuthorizationRequest(**args)\n        with pytest.raises(MissingRequiredAttribute):\n            ar.verify()\n\n\nclass TestAuthorizationResponse(object):\n    def test_verify_token_type(self):\n        args = {\"access_token\": \"foobar\", \"token_type\": \"bearer\"}\n        ar = AuthorizationResponse(**args)\n        ar.verify()\n\n        args = {\"access_token\": \"foobar\"}\n        ar = AuthorizationResponse(**args)\n        with pytest.raises(MissingRequiredValue):\n            ar.verify()\n\n\nclass TestAccessTokenResponse(object):\n    def test_faulty_idtoken(self):\n        _now = time_util.utc_time_sans_frac()\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://alpha.cloud.nds.rub.de\",\n            \"exp\": _now + 3600,\n            \"iat\": _now,\n            \"aud\": \"TestClient\",\n        }\n        idts = IdToken(**idval)\n        key = SYMKey(key=\"TestPassword\")\n        _signed_jwt = idts.to_jwt(key=[key], algorithm=\"HS256\")\n\n        # Mess with the signed id_token\n        p = _signed_jwt.split(\".\")\n        p[2] = \"aaa\"\n        _faulty_signed_jwt = \".\".join(p)\n\n        _info = {\n            \"access_token\": \"accessTok\",\n            \"id_token\": _faulty_signed_jwt,\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600,\n        }\n\n        at = AccessTokenResponse(**_info)\n        with pytest.raises(BadSignature):\n            at.verify(key=[key])\n\n    def test_wrong_alg(self):\n        _now = time_util.utc_time_sans_frac()\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://alpha.cloud.nds.rub.de\",\n            \"exp\": _now + 3600,\n            \"iat\": _now,\n            \"aud\": \"TestClient\",\n        }\n        idts = IdToken(**idval)\n        key = SYMKey(key=\"TestPassword\")\n        _signed_jwt = idts.to_jwt(key=[key], algorithm=\"HS256\")\n\n        _info = {\n            \"access_token\": \"accessTok\",\n            \"id_token\": _signed_jwt,\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600,\n        }\n\n        at = AccessTokenResponse(**_info)\n        with pytest.raises(WrongSigningAlgorithm):\n            at.verify(key=[key], algs={\"sign\": \"HS512\"})\n\n    def test_token_type(self):\n        # lacks required token_type parameter\n        _info = {\"access_token\": \"accessTok\", \"id_token\": \"blabla\"}\n        at = AccessTokenResponse(**_info)\n        with pytest.raises(MissingRequiredAttribute):\n            at.verify()\n\n\ndef test_id_token():\n    _now = time_util.utc_time_sans_frac()\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n            \"iat\": _now,\n            \"exp\": _now + 3600,\n            \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        }\n    )\n\n    idt.verify()\n\n\ndef test_verify_id_token():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    vidt = verify_id_token(\n        msg,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n    assert vidt\n\n\ndef test_verify_id_token_wrong_issuer():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", iss=\"https://example.com/as\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_wrong_aud():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", iss=\"https://example.com/as\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"aaaaaaaaaaaaaaaaaaaa\",\n        )\n\n\ndef test_verify_id_token_mismatch_aud_azp():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"aaaaaaaaaaaaaaaaaaaa\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", iss=\"https://example.com/as\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"aaaaaaaaaaaaaaaaaaaa\",\n        )\n\n\ndef test_verify_id_token_c_hash():\n    code = \"AccessCode1\"\n    lhsh = left_hash(code)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"c_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(code=code, id_token=_jws)\n    verify_id_token(\n        msg,\n        check_hash=True,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n\n\ndef test_verify_id_token_c_hash_fail():\n    code = \"AccessCode1\"\n    lhsh = left_hash(code)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"c_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(code=\"AccessCode289\", id_token=_jws)\n    with pytest.raises(CHashError):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_at_hash():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n    lhsh = left_hash(token)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token, id_token=_jws)\n    verify_id_token(\n        msg,\n        check_hash=True,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n\n\ndef test_verify_id_token_at_hash_fail():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n    token2 = \"ACompletelyOtherAccessToken\"\n    lhsh = left_hash(token)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token2, id_token=_jws)\n    with pytest.raises(AtHashError):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_missing_at_hash():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token, id_token=_jws)\n    with pytest.raises(MissingRequiredAttribute):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_missing_c_hash():\n    code = \"AccessCode1\"\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(code=code, id_token=_jws)\n    with pytest.raises(MissingRequiredAttribute):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_at_hash_and_chash():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n    at_hash = left_hash(token)\n    code = \"AccessCode1\"\n    c_hash = left_hash(code)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": at_hash,\n            \"c_hash\": c_hash,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token, id_token=_jws, code=code)\n    verify_id_token(\n        msg,\n        check_hash=True,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n\n\ndef test_verify_id_token_missing_iss():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(MissingRequiredAttribute):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_iss_not_in_keyjar():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", lifetime=3600, iss=\"https://example.com/op\")\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_token_encrypted():\n    idt = IdToken(\n        sub=\"553df2bcf909104751cfd8b2\",\n        aud=[\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n        auth_time=1441364872,\n        azp=\"554295ce3770612820620000\",\n    )\n    kj = KeyJar()\n    kb = KeyBundle()\n    kb.do_local_der(\n        os.path.join(os.path.dirname(__file__), \"data\", \"keys\", \"cert.key\"),\n        \"some\",\n        [\"enc\", \"sig\"],\n    )\n    kj.add_kb(\"\", kb)\n    kj.add_kb(\"https://sso.qa.7pass.ctf.prosiebensat1.com\", kb)\n\n    packer = JWT(\n        kj,\n        lifetime=3600,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        encrypt=True,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    vidt = verify_id_token(\n        msg,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n    assert vidt\n    assert vidt.jwe_header == {\"enc\": \"A128CBC-HS256\", \"alg\": \"RSA1_5\", \"cty\": \"JWT\"}\n\n\ndef test_verify_token_encrypted_no_key():\n    idt = IdToken(\n        sub=\"553df2bcf909104751cfd8b2\",\n        aud=[\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n        auth_time=1441364872,\n        azp=\"554295ce3770612820620000\",\n    )\n    kj = KeyJar()\n    kb = KeyBundle()\n    kb.do_local_der(\n        os.path.join(os.path.dirname(__file__), \"data\", \"keys\", \"cert.key\"),\n        \"some\",\n        [\"enc\", \"sig\"],\n    )\n    kj.add_kb(\"\", kb)\n    kj.add_kb(\"https://sso.qa.7pass.ctf.prosiebensat1.com\", kb)\n\n    packer = JWT(\n        kj,\n        lifetime=3600,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        encrypt=True,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    # Do not pass they keyjar with keys\n    with pytest.raises(VerificationError):\n        verify_id_token(\n            msg,\n            keyjar=KeyJar(),\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\nclass TestLogoutToken:\n    def test_with_sub(self):\n        # All the required claims. Note there must be a sub, a sid or both\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        assert lt.verify()\n\n    def test_with_sid(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sid=rndstr(),\n        )\n\n        assert lt.verify()\n\n    def test_with_sub_and_sid(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n            sid=rndstr(),\n        )\n\n        assert lt.verify()\n\n    def test_no_sub_or_sid(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_with_nonce(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            nonce=rndstr(16),\n        )\n\n        with pytest.raises(MessageException):\n            lt.verify()\n\n    def test_extra_event(self):\n        # more the one event\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={\n                BACK_CHANNEL_LOGOUT_EVENT: {},\n                \"http://schemas.openid.net/event/other}\": {},\n            },\n            jti=rndstr(16),\n            iat=utc_time_sans_frac(),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_wrong_event(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={\"http://schemas.openid.net/event/other}\": {}},\n            jti=rndstr(16),\n            iat=utc_time_sans_frac(),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_wrong_event_content(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {\"foo\": \"bar\"}},\n            jti=rndstr(16),\n            iat=utc_time_sans_frac(),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_wrong_aud(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(NotForMe):\n            lt.verify(aud=\"https://example.com\")\n\n    def test_wrong_iss(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(NotForMe):\n            lt.verify(iss=\"https://rp.example.org\")\n\n    def test_wrong_iat(self):\n        # Issued sometime in the future\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac() + 86400,\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n\nclass TestBackchannelLogout(object):\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        self.kj = KeyJar()\n        self.kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n        self.key = self.kj.get_signing_key(\"oct\")\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        self.signed_jwt = lt.to_jwt(key=self.key, algorithm=\"HS256\")\n\n    def test_verify_with_keyjar(self):\n        bclr = BackChannelLogoutRequest(logout_token=self.signed_jwt)\n        assert bclr.verify(keyjar=self.kj)\n\n        # The signed JWT is replaced by a dictionary with all the verified values\n        assert bclr[\"logout_token\"][\"iss\"] == \"https://example.com\"\n\n    def test_verify_with_key(self):\n        bclr = BackChannelLogoutRequest(logout_token=self.signed_jwt)\n        assert bclr.verify(key=self.key)\n\n        # The signed JWT is replaced by a dictionary with all the verified values\n        assert bclr[\"logout_token\"][\"iss\"] == \"https://example.com\"\n\n    def test_bogus_logout_token(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            nonce=rndstr(16),\n        )\n        signed_jwt = lt.to_jwt(key=self.key, algorithm=\"HS256\")\n        bclr = BackChannelLogoutRequest(logout_token=signed_jwt)\n\n        with pytest.raises(MessageException):\n            bclr.verify(key=self.key)\n\n\nclass TestFrontchannelLogout(object):\n    def test_verify_request(self):\n        # May be completely empty\n        fclr = FrontChannelLogoutRequest()\n\n        assert fclr.verify()\n", "import datetime\nimport json\nimport logging\nimport os\nfrom http.cookies import SimpleCookie\nfrom time import time\nfrom typing import Any\nfrom typing import Dict\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlparse\n\nimport pytest\nimport responses\nfrom freezegun import freeze_time\nfrom jwkest.jwe import JWEException\nfrom jwkest.jwe import JWEnc\nfrom requests import ConnectionError\nfrom requests.exceptions import MissingSchema\nfrom testfixtures import LogCapture\n\nfrom oic import rndstr\nfrom oic.exception import FailedAuthentication\nfrom oic.exception import InvalidRequest\nfrom oic.exception import RedirectURIError\nfrom oic.oauth2.message import ErrorResponse\nfrom oic.oic import DEF_SIGN_ALG\nfrom oic.oic import make_openid_request\nfrom oic.oic.consumer import Consumer\nfrom oic.oic.message import AccessTokenRequest\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import CheckSessionRequest\nfrom oic.oic.message import Claims\nfrom oic.oic.message import ClaimsRequest\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import Message\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import RefreshAccessTokenRequest\nfrom oic.oic.message import RegistrationRequest\nfrom oic.oic.message import RegistrationResponse\nfrom oic.oic.message import TokenErrorResponse\nfrom oic.oic.message import UserInfoRequest\nfrom oic.oic.provider import InvalidRedirectURIError\nfrom oic.oic.provider import InvalidSectorIdentifier\nfrom oic.oic.provider import Provider\nfrom oic.utils.authn.authn_context import AuthnBroker\nfrom oic.utils.authn.client import verify_client\nfrom oic.utils.authn.user import UserAuthnMethod\nfrom oic.utils.authz import AuthzHandling\nfrom oic.utils.http_util import CookieDealer\nfrom oic.utils.http_util import Response\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.keyio import ec_init\nfrom oic.utils.keyio import keybundle_from_local_file\nfrom oic.utils.sdb import AuthnEvent\nfrom oic.utils.session_backend import DictSessionBackend\nfrom oic.utils.time_util import epoch_in_a_while\nfrom oic.utils.userinfo import UserInfo\n\n__author__ = \"rohe0002\"\n\nCONSUMER_CONFIG = {\n    \"authz_page\": \"/authz\",\n    \"scope\": [\"openid\"],\n    \"response_type\": [\"code\"],\n    \"user_info\": {\"name\": None, \"email\": None, \"nickname\": None},\n    \"request_method\": \"param\",\n}\n\nSERVER_INFO = {\n    \"version\": \"3.0\",\n    \"issuer\": \"https://connect-op.heroku.com\",\n    \"authorization_endpoint\": \"http://localhost:8088/authorization\",\n    \"token_endpoint\": \"http://localhost:8088/token\",\n    \"flows_supported\": [\"code\", \"token\", \"code token\"],\n}\n\nCLIENT_CONFIG = {\"client_id\": \"number5\", \"config\": {\"issuer\": SERVER_INFO[\"issuer\"]}}\n\nCLIENT_CONFIG_2 = {\"client_id\": \"client0\", \"config\": {\"issuer\": SERVER_INFO[\"issuer\"]}}\n\nCLIENT_SECRET = \"abcdefghijklmnop\"\nCLIENT_ID = \"client_1\"\n\nKC_SYM = KeyBundle(\n    [\n        {\"kty\": \"oct\", \"key\": CLIENT_SECRET, \"use\": \"ver\"},\n        {\"kty\": \"oct\", \"key\": CLIENT_SECRET, \"use\": \"sig\"},\n    ]\n)\nKC_SYM2 = KeyBundle(\n    [\n        {\"kty\": \"oct\", \"key\": \"drickyoughurt\", \"use\": \"sig\"},\n        {\"kty\": \"oct\", \"key\": \"drickyoughurt\", \"use\": \"ver\"},\n    ]\n)\n\nBASE_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), \"data/keys\"))\nKC_RSA = keybundle_from_local_file(\n    os.path.join(BASE_PATH, \"rsa.key\"), \"RSA\", [\"ver\", \"sig\"]\n)\n\nKEYJAR = KeyJar()\nKEYJAR[CLIENT_ID] = [KC_SYM, KC_RSA]\nKEYJAR[\"number5\"] = [KC_SYM2, KC_RSA]\nKEYJAR[\"\"] = KC_RSA\nKEYJAR[\"https://connect-op.heroku.com\"] = KC_RSA\n\nCDB: Dict[str, Dict[str, Any]] = {\n    \"number5\": {\n        \"password\": \"hemligt\",\n        \"client_secret\": \"drickyoughurt\",\n        \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n        \"post_logout_redirect_uris\": [(\"https://example.com/post_logout\", None)],\n        \"client_salt\": \"salted\",\n        \"response_types\": [\n            \"code\",\n            \"token\",\n            \"code id_token\",\n            \"none\",\n            \"code token\",\n            \"id_token\",\n        ],\n    },\n    \"a1b2c3\": {\n        \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n        \"client_salt\": \"salted\",\n        \"client_secret\": \"very_secret\",\n        \"response_types\": [\"code\", \"token\", \"code id_token\"],\n    },\n    \"client0\": {\n        \"redirect_uris\": [(\"http://www.example.org/authz\", None)],\n        \"client_secret\": \"very_secret\",\n        \"post_logout_redirect_uris\": [(\"https://www.example.org/post_logout\", None)],\n        \"client_salt\": \"salted\",\n        \"response_types\": [\"code\", \"token\", \"code id_token\"],\n    },\n    CLIENT_ID: {\n        \"client_secret\": CLIENT_SECRET,\n        \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n        \"client_salt\": \"salted\",\n        \"token_endpoint_auth_method\": \"client_secret_post\",\n        \"response_types\": [\"code\", \"token\", \"code id_token\"],\n    },\n}\n\nUSERDB = {\n    \"user\": {\n        \"name\": \"Hans Granberg\",\n        \"nickname\": \"Hasse\",\n        \"email\": \"hans@example.org\",\n        \"verified\": False,\n        \"sub\": \"user\",\n    },\n    \"username\": {\n        \"name\": \"Linda Lindgren\",\n        \"nickname\": \"Linda\",\n        \"email\": \"linda@example.com\",\n        \"verified\": True,\n        \"sub\": \"username\",\n        \"extra_claim\": \"extra_claim_value\",\n    },\n}\n\nURLMAP = {CLIENT_ID: [\"https://example.com/authz\"]}\n\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\nclass DummyAuthn(UserAuthnMethod):\n    def __init__(self, srv, user):\n        UserAuthnMethod.__init__(self, srv)\n        self.user = user\n\n    def authenticated_as(self, cookie=None, **kwargs):\n        if cookie == \"FAIL\":\n            return None, 0\n        else:\n            return {\"uid\": self.user}, time()\n\n\nAUTHN_BROKER = AuthnBroker()\nAUTHN_BROKER.add(\"UNDEFINED\", DummyAuthn(None, \"username\"))\n\n# dealing with authorization\nAUTHZ = AuthzHandling()\nSYMKEY = rndstr(16)  # symmetric key used to encrypt cookie info\nUSERINFO = UserInfo(USERDB)\n\n\nclass TestProvider(object):\n    @pytest.fixture(autouse=True)\n    def create_provider(self, session_db_factory):\n        self.provider = Provider(\n            SERVER_INFO[\"issuer\"],\n            session_db_factory(SERVER_INFO[\"issuer\"]),\n            CDB,\n            AUTHN_BROKER,\n            USERINFO,\n            AUTHZ,\n            verify_client,\n            SYMKEY,\n            urlmap=URLMAP,\n            keyjar=KEYJAR,\n        )\n        self.provider.baseurl = self.provider.name\n\n        self.cons = Consumer(\n            DictSessionBackend(),\n            CONSUMER_CONFIG.copy(),\n            CLIENT_CONFIG,\n            server_info=SERVER_INFO,\n        )\n        self.cons.behaviour = {\n            \"request_object_signing_alg\": DEF_SIGN_ALG[\"openid_request_object\"]\n        }\n        self.cons.keyjar[\"\"] = KC_RSA\n        self.cons.keyjar.import_jwks(\n            self.provider.keyjar.export_jwks(), self.cons.issuer\n        )\n\n        self.cons2 = Consumer(\n            {}, CONSUMER_CONFIG.copy(), CLIENT_CONFIG_2, server_info=SERVER_INFO\n        )\n        self.cons2.behaviour = {\n            \"request_object_signing_alg\": DEF_SIGN_ALG[\"openid_request_object\"]\n        }\n        self.cons2.keyjar[\"\"] = KC_RSA\n\n    def test_authorization_endpoint(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\"],\n            \"client_id\": \"a1b2c3\",\n            \"nonce\": \"Nonce\",\n        }\n\n        arq = AuthorizationRequest(**bib)\n\n        resp = self.provider.authorization_endpoint(request=arq.to_urlencoded())\n        parsed = parse_qs(urlparse(resp.message).query)\n        assert parsed[\"scope\"] == [\"openid\"]\n        assert parsed[\"state\"][0] == \"id-6da9ca0cc23959f5f33e8becd9b08cae\"\n        assert \"code\" in parsed\n\n    def test_provider_features_extra_claims(self):\n        self.provider.extra_claims = [\"claim_1\", \"claim_2\"]\n        features = self.provider.provider_features()\n        assert \"claim_1\" in features[\"claims_supported\"]\n        assert \"claim_2\" in features[\"claims_supported\"]\n\n    def test_provider_features_extra_scopes(self):\n        self.provider.extra_scope_dict = {\"my_scope\": [\"claim_1\", \"claim_2\"]}\n        features = self.provider.provider_features()\n        assert \"my_scope\" in features[\"scopes_supported\"]\n        assert \"claim_1\" in features[\"claims_supported\"]\n        assert \"claim_2\" in features[\"claims_supported\"]\n\n    def test_authorization_endpoint_request(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\", \"id_token\"],\n            \"client_id\": \"a1b2c3\",\n            \"nonce\": \"Nonce\",\n            \"prompt\": [\"none\"],\n        }\n\n        req = AuthorizationRequest(**bib)\n        # want to be someone else !\n        ic = {\"sub\": {\"value\": \"userX\"}}\n        _keys = self.provider.keyjar.get_signing_key(key_type=\"RSA\")\n        req[\"request\"] = make_openid_request(\n            req, _keys, idtoken_claims=ic, request_object_signing_alg=\"RS256\"\n        )\n\n        with pytest.raises(FailedAuthentication):\n            self.provider.authorization_endpoint(request=req.to_urlencoded())\n\n    def test_authorization_endpoint_id_token(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\", \"id_token\"],\n            \"client_id\": \"a1b2c3\",\n            \"nonce\": \"Nonce\",\n            \"prompt\": [\"none\"],\n        }\n\n        req = AuthorizationRequest(**bib)\n        areq = AuthorizationRequest(\n            response_type=\"code\",\n            client_id=\"client_1\",\n            redirect_uri=\"http://example.com/authz\",\n            scope=[\"openid\"],\n            state=\"state000\",\n        )\n\n        sdb = self.provider.sdb\n        ae = AuthnEvent(\"userX\", \"salt\")\n        sid = sdb.create_authz_session(ae, areq)\n        sdb.do_sub(sid, \"client_salt\")\n        _info = sdb[sid]\n        # All this is jut removed when the id_token is constructed\n        # The proper information comes from the session information\n        _user_info = IdToken(\n            iss=\"https://foo.example.om\",\n            sub=\"foo\",\n            aud=bib[\"client_id\"],\n            exp=epoch_in_a_while(minutes=10),\n            acr=\"2\",\n            nonce=bib[\"nonce\"],\n        )\n\n        idt = self.provider.id_token_as_signed_jwt(\n            _info, access_token=\"access_token\", user_info=_user_info\n        )\n\n        req[\"id_token\"] = idt\n        query_string = req.to_urlencoded()\n\n        # client_id not in id_token[\"aud\"] so login required\n        resp = self.provider.authorization_endpoint(request=query_string, cookie=\"FAIL\")\n        parsed_resp = parse_qs(urlparse(resp.message).fragment)\n        assert parsed_resp[\"error\"][0] == \"login_required\"\n\n        req[\"client_id\"] = \"client_1\"\n        query_string = req.to_urlencoded()\n\n        # client_id is in id_token[\"aud\"] so no login required\n        resp = self.provider.authorization_endpoint(request=query_string, cookie=\"FAIL\")\n\n        assert resp.message.startswith(\"http://localhost:8087/authz\")\n\n    def test_authorization_endpoint_bad_scope(self):\n        bib = {\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\"],\n            \"client_id\": \"a1b2c3\",\n        }\n\n        arq = AuthorizationRequest(**bib)\n        resp = self.provider.authorization_endpoint(request=arq.to_urlencoded())\n        assert resp.status_code == 303\n        parsed = parse_qs(urlparse(resp.message).query)\n        assert parsed[\"error\"][0] == \"invalid_request\"\n        assert parsed[\"error_description\"][0] == \"consent in prompt\"\n\n    def test_authenticated(self):\n        _state, location = self.cons.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        parsed = urlparse(resp.message)\n        assert (\n            \"{}://{}{}\".format(parsed.scheme, parsed.netloc, parsed.path)\n            == \"http://localhost:8087/authz\"\n        )\n\n        part = self.cons.parse_authz(query=resp.message)\n\n        aresp = part[0]\n        assert part[1] is None\n        assert part[2] is None\n\n        assert isinstance(aresp, AuthorizationResponse)\n        assert _eq(aresp.keys(), [\"code\", \"state\", \"scope\", \"client_id\", \"iss\"])\n\n        assert _eq(\n            self.cons.grant[_state].keys(),\n            [\"code\", \"tokens\", \"id_token\", \"exp_in\", \"seed\", \"grant_expiration_time\"],\n        )\n\n    def test_authenticated_url(self):\n        state, location = self.cons.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        aresp = self.cons.parse_response(\n            AuthorizationResponse, resp.message, sformat=\"urlencoded\"\n        )\n\n        assert isinstance(aresp, AuthorizationResponse)\n        assert _eq(aresp.keys(), [\"code\", \"state\", \"scope\", \"client_id\", \"iss\"])\n\n    def test_authenticated_hybrid(self):\n        _state, location = self.cons.begin(\n            scope=\"openid email claims_in_id_token\",\n            response_type=\"code id_token\",\n            path=\"http://localhost:8087\",\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        part = self.cons.parse_authz(resp.message)\n\n        aresp = part[0]\n        assert part[1] is None\n        assert part[2] is not None\n\n        assert isinstance(aresp, AuthorizationResponse)\n        assert _eq(aresp.keys(), [\"scope\", \"state\", \"id_token\", \"client_id\", \"code\"])\n\n        assert _eq(\n            self.cons.grant[_state].keys(),\n            [\"code\", \"id_token\", \"tokens\", \"exp_in\", \"grant_expiration_time\", \"seed\"],\n        )\n        id_token = part[2]\n        assert isinstance(id_token, IdToken)\n        assert _eq(\n            id_token.keys(),\n            [\"nonce\", \"c_hash\", \"sub\", \"iss\", \"acr\", \"exp\", \"auth_time\", \"iat\", \"aud\"],\n        )\n\n    def test_authenticated_token(self):\n        _state, location = self.cons.begin(\n            \"openid\", response_type=\"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n        parsed = parse_qs(urlparse(resp.message).fragment)\n        assert parsed[\"token_type\"][0] == \"Bearer\"\n        assert \"access_token\" in parsed\n\n    def test_authenticated_none(self):\n        _state, location = self.cons.begin(\n            \"openid\", response_type=\"none\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n        parsed = urlparse(resp.message)\n        assert (\n            \"{}://{}{}\".format(parsed.scheme, parsed.netloc, parsed.path)\n            == \"http://localhost:8087/authz\"\n        )\n        assert \"state\" in parse_qs(parsed.query)\n\n    def test_code_grant_type_ok(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert _eq(atr.keys(), [\"token_type\", \"id_token\", \"access_token\", \"scope\"])\n\n    def test_code_grant_type_missing_code(self):\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Missing code\"\n\n    def test_code_grant_type_revoked(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"revoked\": True,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Token is revoked\"\n\n    def test_code_grant_type_no_session(self):\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=\"some grant\",\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Code is invalid\"\n\n    def test_code_grant_type_missing_redirect_uri(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Missing redirect_uri\"\n\n    def test_code_grant_type_used(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": True,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"access_denied\"\n        assert atr[\"error_description\"] == \"Access Code already used\"\n\n    def test_code_grant_type_refresh(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid offline_access\"],\n            prompt=\"consent\",\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert _eq(\n            atr.keys(),\n            [\"token_type\", \"id_token\", \"access_token\", \"scope\", \"refresh_token\"],\n        )\n\n    def test_code_grant_type_id_token_claims(self):\n        id_token_claims = Claims(name={\"essential\": True})\n        claims_req = ClaimsRequest(id_token=id_token_claims)\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n            claims=claims_req,\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert _eq(atr.keys(), [\"token_type\", \"id_token\", \"access_token\", \"scope\"])\n        assert atr.verify(keyjar=KEYJAR)\n        assert \"name\" in atr[\"id_token\"]\n\n    def test_client_credentials_grant_type(self):\n        resp = self.provider.client_credentials_grant_type(Message())\n        parsed = ErrorResponse().from_json(resp.message)\n        assert parsed[\"error\"] == \"unsupported_grant_type\"\n        assert parsed[\"error_description\"] == \"Unsupported grant_type\"\n\n    def test_password_grant_type(self):\n        resp = self.provider.password_grant_type(Message())\n        parsed = ErrorResponse().from_json(resp.message)\n        assert parsed[\"error\"] == \"unsupported_grant_type\"\n        assert parsed[\"error_description\"] == \"Unsupported grant_type\"\n\n    def test_authz_endpoint(self):\n        _state, location = self.cons.begin(\n            \"openid\", response_type=[\"code\", \"token\"], path=\"http://localhost:8087\"\n        )\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        parsed = parse_qs(urlparse(resp.message).fragment)\n        assert parsed[\"token_type\"][0] == \"Bearer\"\n        assert \"code\" in parsed\n\n    def test_idtoken(self):\n        AREQ = AuthorizationRequest(\n            response_type=\"code\",\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            scope=[\"openid\"],\n            state=\"state000\",\n        )\n\n        ae = AuthnEvent(\"sub\", \"salt\")\n        sid = self.provider.sdb.create_authz_session(ae, AREQ)\n        self.provider.sdb.do_sub(sid, \"client_salt\")\n        session = self.provider.sdb[sid]\n\n        id_token = self.provider.id_token_as_signed_jwt(session)\n        assert len(id_token.split(\".\")) == 3\n\n    def test_idtoken_with_extra_claims(self):\n        areq = AuthorizationRequest(\n            response_type=\"code\",\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            scope=[\"openid\"],\n            state=\"state000\",\n        )\n        aevent = AuthnEvent(\"sub\", \"salt\")\n        sid = self.provider.sdb.create_authz_session(aevent, areq)\n        self.provider.sdb.do_sub(sid, \"client_salt\")\n        session = self.provider.sdb[sid]\n\n        claims = {\"k1\": \"v1\", \"k2\": 32}\n\n        id_token = self.provider.id_token_as_signed_jwt(session, extra_claims=claims)\n        parsed = IdToken().from_jwt(id_token, keyjar=self.provider.keyjar)\n\n        for key, value in claims.items():\n            assert parsed[key] == value\n\n    def test_userinfo_endpoint(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"nickname\", \"sub\", \"name\", \"email\"])\n\n    def test_userinfo_endpoint_expired(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        initial_datetime = datetime.datetime(2018, 2, 5, 10, 0, 0, 0)\n        final_datetime = datetime.datetime(2018, 2, 9, 10, 0, 0, 0)\n        with freeze_time(initial_datetime) as frozen:\n            resp = self.provider.authorization_endpoint(\n                request=urlparse(location).query\n            )\n\n            # redirect\n            atr = AuthorizationResponse().deserialize(\n                urlparse(resp.message).fragment, \"urlencoded\"\n            )\n            frozen.move_to(final_datetime)\n\n            uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n            resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n\n        message = json.loads(resp.message)\n        assert message[\"error\"] == \"invalid_token\"\n        assert message[\"error_description\"] == \"Token is expired\"\n\n    def test_userinfo_endpoint_extra_claim(self):\n        # We have to recreate the cache again\n        self.provider.extra_claims = [\"extra_claim\"]\n        self.provider.capabilities = self.provider.provider_features()\n\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        # Request the extra claim\n        self.cons.consumer_config[\"user_info\"] = {\"extra_claim\": None}\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\", \"extra_claim\"])\n\n    def test_userinfo_endpoint_unknown_claim(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        # Request the extra claim\n        self.cons.consumer_config[\"user_info\"] = {\"extra_claim\": None}\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\"])\n\n    def test_userinfo_endpoint_extra_scopes(self):\n        # We have to recreate the cache again\n        self.provider.extra_scope_dict = {\"extra_scope\": [\"extra_claim\"]}\n        self.provider.capabilities = self.provider.provider_features()\n\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.consumer_config[\"user_info\"] = {\"extra_claim\": None}\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        # Request the extra scope\n        state, location = self.cons.begin(\n            \"openid extra_scope\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\", \"extra_claim\"])\n\n    def test_userinfo_endpoint_authn(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(\n            request=uir.to_urlencoded(), authn=\"Bearer \" + atr[\"access_token\"]\n        )\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"nickname\", \"sub\", \"name\", \"email\"])\n\n    def test_userinfo_endpoint_missing_client(self):\n        self.provider.cdb[\"unknownclient\"] = {\n            \"client_secret\": \"unknownclient\",\n            \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n            \"post_logout_redirect_uris\": [(\"https://example.com/post_logout\", None)],\n            \"client_salt\": \"salted\",\n            \"response_types\": [\n                \"code\",\n                \"token\",\n                \"code id_token\",\n                \"none\",\n                \"code token\",\n                \"id_token\",\n            ],\n        }\n        self.cons.client_id = \"unknownclient\"\n        self.cons.client_secret = \"unknownclient\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(schema=\"openid\")\n\n        del self.provider.cdb[\"unknownclient\"]\n        resp = self.provider.userinfo_endpoint(\n            request=uir.to_urlencoded(), authn=\"Bearer \" + atr[\"access_token\"]\n        )\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert ident[\"error\"] == \"unauthorized_client\"\n\n    def test_userinfo_endpoint_malformed(self):\n        uir = UserInfoRequest(schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(\n            request=uir.to_urlencoded(), authn=\"Not a token\"\n        )\n\n        assert json.loads(resp.message) == {\n            \"error_description\": \"Token is malformed\",\n            \"error\": \"invalid_request\",\n        }\n\n    def test_userinfo_endpoint_mising_authn(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        # authn_event is missing - this can happen for offline requests\n        _sdb[sid] = {\n            \"sub\": \"my_sub\",\n            \"oauth_state\": \"authz\",\n            \"uid\": \"user\",\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n\n        uir = UserInfoRequest(access_token=access_grant, schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\"])\n\n    def test_check_session_endpoint(self):\n        session = {\"sub\": \"UserID\", \"client_id\": \"number5\"}\n        idtoken = self.provider.id_token_as_signed_jwt(session)\n        csr = CheckSessionRequest(id_token=idtoken)\n\n        info = self.provider.check_session_endpoint(request=csr.to_urlencoded())\n        idt = IdToken().deserialize(info.message, \"json\")\n        assert _eq(idt.keys(), [\"sub\", \"aud\", \"iss\", \"acr\", \"exp\", \"iat\"])\n        assert idt[\"iss\"] == self.provider.name\n\n    def test_response_mode_fragment(self):\n        areq = {\"response_mode\": \"fragment\"}\n        assert self.provider.response_mode(areq, True) is None\n        with pytest.raises(InvalidRequest):\n            self.provider.response_mode(areq, False)\n\n    def test_response_mode_query(self):\n        areq = {\"response_mode\": \"query\"}\n        assert self.provider.response_mode(areq, False) is None\n        with pytest.raises(InvalidRequest):\n            self.provider.response_mode(areq, True)\n\n    def test_response_mode_form_post(self):\n        areq = {\"response_mode\": \"form_post\"}\n        aresp = AuthorizationResponse()\n        aresp[\"state\"] = \"state\"\n        response = self.provider.response_mode(\n            areq, False, redirect_uri=\"http://example.com\", aresp=aresp, headers=\"\"\n        )\n        assert \"Submit This Form\" in response.message\n        assert \"http://example.com\" in response.message\n        assert '<input type=\"hidden\" name=\"state\" value=\"state\"/>' in response.message\n\n    def test_auth_init_invalid(self):\n        areq = {\n            \"response_mode\": \"unknown\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"client_id\": \"number5\",\n            \"scope\": \"openid\",\n            \"response_type\": \"code\",\n            \"client_secret\": \"drickyoghurt\",\n        }\n        response = self.provider.auth_init(areq)\n\n        assert isinstance(response, Response)\n        assert response.status_code == 400\n        assert json.loads(response.message) == {\n            \"error\": \"invalid_request\",\n            \"error_description\": \"Contains unsupported response mode\",\n        }\n\n    @patch(\"oic.oic.provider.utc_time_sans_frac\", Mock(return_value=123456))\n    def test_client_secret_expiration_time(self):\n        exp_time = self.provider.client_secret_expiration_time()\n        assert exp_time == 209856\n\n    def test_registration_endpoint_post(self):\n        req = RegistrationRequest()\n\n        req[\"application_type\"] = \"web\"\n        req[\"client_name\"] = \"My super service\"\n        req[\"redirect_uris\"] = [\"http://example.com/authz\"]\n        req[\"contacts\"] = [\"foo@example.com\"]\n        req[\"response_types\"] = [\"code\"]\n\n        resp = self.provider.registration_endpoint(request=req.to_json())\n\n        regresp = RegistrationResponse().deserialize(resp.message, \"json\")\n        assert _eq(\n            regresp.keys(),\n            [\n                \"redirect_uris\",\n                \"contacts\",\n                \"application_type\",\n                \"client_name\",\n                \"registration_client_uri\",\n                \"client_secret_expires_at\",\n                \"registration_access_token\",\n                \"client_id\",\n                \"client_secret\",\n                \"client_id_issued_at\",\n                \"response_types\",\n            ],\n        )\n\n    def test_registration_endpoint_post_unicode(self):\n        data = (\n            \"application_type=web&client_name=M%C3%A1+supe%C5%99+service&\"\n            \"redirect_uris=http%3A%2F%2Fexample.com%2Fauthz&response_types=code\"\n        )\n        resp = self.provider.registration_endpoint(request=data)\n\n        regresp = RegistrationResponse().deserialize(resp.message, \"json\")\n        assert _eq(\n            regresp.keys(),\n            [\n                \"redirect_uris\",\n                \"application_type\",\n                \"client_name\",\n                \"registration_client_uri\",\n                \"client_secret_expires_at\",\n                \"registration_access_token\",\n                \"client_id\",\n                \"client_secret\",\n                \"client_id_issued_at\",\n                \"response_types\",\n            ],\n        )\n\n    def test_registration_endpoint_get(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", regresp[\"registration_access_token\"]])\n        query = \"=\".join([\"client_id\", regresp[\"client_id\"]])\n        resp = self.provider.registration_endpoint(\n            request=query, authn=authn, method=\"GET\"\n        )\n\n        assert json.loads(resp.message) == regresp.to_dict()\n\n    def test_registration_endpoint_delete(self):\n        resp = self.provider.registration_endpoint(request=\"\", method=\"PUT\")\n        assert json.loads(resp.message) == {\n            \"error\": \"Unsupported operation\",\n            \"error_description\": \"Altering of the registration is not supported\",\n        }\n\n    def test_registration_endpoint_put(self):\n        resp = self.provider.registration_endpoint(request=\"\", method=\"DELETE\")\n        assert json.loads(resp.message) == {\n            \"error\": \"Unsupported operation\",\n            \"error_description\": \"Deletion of the registration is not supported\",\n        }\n\n    def test_registration_endpoint_unsupported(self):\n        resp = self.provider.registration_endpoint(request=\"\", method=\"HEAD\")\n        assert json.loads(resp.message) == {\n            \"error\": \"Unsupported method\",\n            \"error_description\": \"Unsupported HTTP method\",\n        }\n\n    def test_do_client_registration_invalid_sector_uri(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            sector_identifier_uri=\"https://example.com\",\n            redirect_uris=[\"http://example.com/changed\"],\n        )\n        redirects = [\"http://example.com/present\"]\n        with responses.RequestsMock() as rsps:\n            rsps.add(rsps.GET, \"https://example.com\", body=json.dumps(redirects))\n            resp = self.provider.do_client_registration(rr, \"client0\")\n\n        assert resp.status_code == 400\n        error = json.loads(resp.message)\n        assert error[\"error\"] == \"invalid_configuration_parameter\"\n\n    def test_registration_endpoint_with_non_https_redirect_uri_implicit_flow(self):\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\"http://example.com/authz\"],\n            \"response_types\": [\"id_token\", \"token\"],\n        }\n        req = RegistrationRequest(**params)\n        resp = self.provider.registration_endpoint(request=req.to_json())\n\n        assert resp.status_code == 400\n        error = json.loads(resp.message)\n        assert error[\"error\"] == \"invalid_redirect_uri\"\n\n    def test_verify_redirect_uris_with_https_code_flow(self):\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\"http://example.com/authz\"],\n            \"response_types\": [\"code\"],\n        }\n        request = RegistrationRequest(**params)\n        verified_uris = self.provider.verify_redirect_uris(request)\n        assert verified_uris == [(\"http://example.com/authz\", None)]\n\n    def test_verify_redirect_uris_with_non_https_redirect_uri_implicit_flow(self):\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\"http://example.com/authz\"],\n            \"response_types\": [\"id_token\", \"token\"],\n        }\n        request = RegistrationRequest(**params)\n\n        with pytest.raises(InvalidRedirectURIError) as exc_info:\n            self.provider.verify_redirect_uris(request)\n\n        assert str(exc_info.value) == \"None https redirect_uri not allowed\"\n\n    def test_verify_redirect_uris_unicode(self):\n        url = \"http://example.com/a\\xc5\\xaf\\xc5\\xa5h\\xc5\\xbe\"\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [url],\n            \"response_types\": [\"code\"],\n        }\n        request = RegistrationRequest(**params)\n        verified_uris = self.provider.verify_redirect_uris(request)\n        assert verified_uris == [(url, None)]\n\n    def test_provider_key_setup(self, tmpdir, session_db_factory):\n        path = tmpdir.strpath\n\n        # Path is actually just a random name we turn into a subpath of\n        # our current directory, that doesn't work with drive letters on\n        # windows, so we throw them away and add a '.' for a local path.\n        path = \".\" + os.path.splitdrive(path)[1].replace(os.path.sep, \"/\")\n\n        provider = Provider(\n            \"pyoicserv\",\n            session_db_factory(SERVER_INFO[\"issuer\"]),\n            {},\n            None,\n            None,\n            None,\n            None,\n            None,\n        )\n        provider.baseurl = \"http://www.example.com\"\n        provider.key_setup(path, path, sig={\"format\": \"jwk\", \"alg\": \"RSA\"})\n\n        keys = provider.keyjar.get_signing_key(\"RSA\")\n\n        assert len(keys) == 1\n        assert provider.jwks_uri == \"http://www.example.com/{}/jwks\".format(path)\n\n    @pytest.mark.parametrize(\n        \"uri\",\n        [\n            \"http://example.org/foo\",\n            \"http://example.com/cb\",\n            \"http://example.org/cb?got=you\",\n            \"http://example.org/cb/foo?got=you\",\n        ],\n    )\n    def test_verify_redirect_uri_faulty_without_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        with pytest.raises(RedirectURIError):\n            self.provider._verify_redirect_uri(areq)\n\n    @pytest.mark.parametrize(\n        \"uri\",\n        [\n            \"http://example.org/foo\",\n            \"http://example.com/cb\",\n            \"http://example.org/cb?got=you\",\n            \"http://example.org/cb?test=fail\",\n            \"http://example.org/cb/foo?got=you\",\n        ],\n    )\n    def test_verify_redirect_uri_faulty_with_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb?test=test\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        with pytest.raises(RedirectURIError):\n            self.provider._verify_redirect_uri(areq)\n\n    @pytest.mark.parametrize(\"uri\", [\"http://example.org/cb\"])\n    def test_verify_redirect_uri_correct_without_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        self.provider._verify_redirect_uri(areq)\n\n    @pytest.mark.parametrize(\n        \"uri\", [\"http://example.org/cb\", \"http://example.org/cb?test=test\"]\n    )\n    def test_verify_redirect_uri_correct_with_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb\", \"http://example.org/cb?test=test\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        self.provider._verify_redirect_uri(areq)\n\n    def test_verify_sector_identifier_no_scheme(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"example.com\"\n        )\n        with LogCapture(level=logging.DEBUG) as logcap:\n            message = \"Couldn't open sector_identifier_uri\"\n            with pytest.raises(InvalidSectorIdentifier, match=message):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 2\n        # First log record is from server...\n        assert isinstance(logcap.records[1].msg, MissingSchema)\n        error = (\n            \"Invalid URL 'example.com': No schema supplied. Perhaps you meant \"\n            \"http://example.com?\"\n        )\n        assert str(logcap.records[1].msg) == error\n\n    def test_verify_sector_identifier_nonreachable(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", status=404)\n            message = \"Couldn't open sector_identifier_uri\"\n            with pytest.raises(InvalidSectorIdentifier, match=message):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 0\n\n    def test_verify_sector_identifier_error(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        error = ConnectionError(\"broken connection\")\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=error)\n            with pytest.raises(\n                InvalidSectorIdentifier, match=\"Couldn't open sector_identifier_uri\"\n            ):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 2\n        # First log record is from server...\n        assert logcap.records[1].msg == error\n\n    def test_verify_sector_identifier_malformed(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        body = \"This is not the JSON you are looking for\"\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=body)\n            with pytest.raises(\n                InvalidSectorIdentifier,\n                match=\"Error deserializing sector_identifier_uri content\",\n            ):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 1\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == (body,)\n\n    def test_verify_sector_identifier_ru_missing_in_si(self):\n        \"\"\"Redirect_uris is not present in the sector_identifier_uri content.\"\"\"\n        rr = RegistrationRequest(\n            operation=\"register\",\n            sector_identifier_uri=\"https://example.com\",\n            redirect_uris=[\"http://example.com/missing\"],\n        )\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(\n                rsps.GET,\n                \"https://example.com\",\n                body=json.dumps([\"http://example.com/present\"]),\n            )\n            with pytest.raises(\n                InvalidSectorIdentifier,\n                match=\"redirect_uri missing from sector_identifiers\",\n            ):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 2\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == ('[\"http://example.com/present\"]',)\n        assert logcap.records[1].msg == \"redirect_uris: %s\"\n        assert logcap.records[1].args == ([\"http://example.com/missing\"],)\n\n    def test_verify_sector_identifier_ru_missing(self):\n        \"\"\"Redirect_uris is not present in the request.\"\"\"\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        redirects = [\"http://example.com/present\"]\n\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=json.dumps(redirects))\n            si_redirects, si_url = self.provider._verify_sector_identifier(rr)\n\n        assert si_url == \"https://example.com\"\n        assert si_redirects == redirects\n        assert len(logcap.records) == 1\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == ('[\"http://example.com/present\"]',)\n\n    def test_verify_sector_identifier_ru_ok(self):\n        \"\"\"Redirect_uris is present in the sector_identifier_uri content.\"\"\"\n        rr = RegistrationRequest(\n            operation=\"register\",\n            sector_identifier_uri=\"https://example.com\",\n            redirect_uris=[\"http://example.com/present\"],\n        )\n        redirects = [\"http://example.com/present\"]\n\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=json.dumps(redirects))\n            si_redirects, si_url = self.provider._verify_sector_identifier(rr)\n\n        assert si_url == \"https://example.com\"\n        assert si_redirects == redirects\n        assert len(logcap.records) == 2\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == ('[\"http://example.com/present\"]',)\n        assert logcap.records[1].msg == \"redirect_uris: %s\"\n        assert logcap.records[1].args == ([\"http://example.com/present\"],)\n\n    @pytest.mark.parametrize(\n        \"uri\",\n        [\n            \"http://example.org/cb\",\n            \"http://example.org/cb?got=you\",\n            \"http://example.org/cb?foo=you\" \"http://example.org/cb?foo=bar&got=you\",\n            \"http://example.org/cb?foo=you&foo=bar\",\n        ],\n    )\n    def test_registered_redirect_uri_faulty_with_query_component(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb?foo=bar\"],\n            response_types=[\"code\"],\n        )\n\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, scope=\"openid\", response_type=\"code\"\n        )\n\n        with pytest.raises(RedirectURIError):\n            self.provider._verify_redirect_uri(areq)\n\n    def test_registered_redirect_uri_correct_with_query_component(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb?foo=bar\"],\n            response_types=[\"code\"],\n        )\n\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=\"http://example.org/cb?foo=bar\",\n            client_id=cid,\n            scope=\"openid\",\n            response_type=\"code\",\n        )\n\n        self.provider._verify_redirect_uri(areq)\n\n    def test_verify_redirect_uri_native_http_localhost(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"http://localhost/cb\"], application_type=\"native\"\n        )\n\n        self.provider.verify_redirect_uris(areq)\n\n    def test_verify_redirect_uri_native_loopback(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"http://127.0.0.1/cb\"], application_type=\"native\"\n        )\n\n        self.provider.verify_redirect_uris(areq)\n\n    def test_verify_redirect_uri_native_http_non_localhost(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"http://example.org/cb\"], application_type=\"native\"\n        )\n\n        try:\n            self.provider.verify_redirect_uris(areq)\n        except InvalidRedirectURIError:\n            assert True\n\n    def test_verify_redirect_uri_native_custom(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"com.example.app:/oauth2redirect\"], application_type=\"native\"\n        )\n\n        self.provider.verify_redirect_uris(areq)\n\n    def test_verify_redirect_uri_native_https(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"https://example.org/cb\"], application_type=\"native\"\n        )\n\n        try:\n            self.provider.verify_redirect_uris(areq)\n        except InvalidRedirectURIError:\n            assert True\n\n    def test_read_registration(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", regresp[\"registration_access_token\"]])\n        query = \"=\".join([\"client_id\", regresp[\"client_id\"]])\n        resp = self.provider.read_registration(authn, query)\n\n        assert json.loads(resp.message) == regresp.to_dict()\n\n    def test_read_registration_malformed_authn(self):\n        resp = self.provider.read_registration(\"wrong string\", \"request\")\n        assert resp.status_code == 400\n        assert json.loads(resp.message) == {\n            \"error\": \"invalid_request\",\n            \"error_description\": None,\n        }\n\n    def test_read_registration_missing_clientid(self):\n        resp = self.provider.read_registration(\"Bearer wrong string\", \"request\")\n        assert resp.status_code == 401\n\n    def test_read_registration_wrong_cid(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", regresp[\"registration_access_token\"]])\n        query = \"=\".join([\"client_id\", \"123456789012\"])\n        resp = self.provider.read_registration(authn, query)\n\n        assert resp.status_code == 401\n\n    def test_read_registration_wrong_rat(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", \"registration_access_token\"])\n        query = \"=\".join([\"client_id\", regresp[\"client_id\"]])\n        resp = self.provider.read_registration(authn, query)\n\n        assert resp.status_code == 401\n\n    def test_key_rollover(self):\n        provider2 = Provider(\"FOOP\", {}, {}, None, None, None, None, None)\n        provider2.keyjar = KEYJAR\n        # Number of KeyBundles\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 1\n        kb = ec_init({\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"sig\"]})\n        provider2.do_key_rollover(json.loads(kb.jwks()), \"b%d\")\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 2\n        kb = ec_init({\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"sig\"]})\n        provider2.do_key_rollover(json.loads(kb.jwks()), \"b%d\")\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 3\n        provider2.remove_inactive_keys(-1)\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 2\n\n    def test_end_session_endpoint(self):\n        # End session not allowed if no cookie and no id_token_hint is sent\n        # (can't determine session)\n        resp = self.provider.end_session_endpoint(\"\", cookie=\"FAIL\")\n        assert resp.status_code == 400\n\n    def _create_cookie(self, user, client_id, c_type=\"sso\"):\n        cd = CookieDealer(self.provider)\n        set_cookie = cd.create_cookie(\n            \"{}][{}\".format(user, client_id), c_type, self.provider.sso_cookie_name\n        )\n        cookies_string = set_cookie[1]\n        all_cookies: SimpleCookie = SimpleCookie()\n\n        try:\n            cookies_string = cookies_string.decode()\n        except (AttributeError, UnicodeDecodeError):\n            pass\n\n        all_cookies.load(cookies_string)\n\n        return all_cookies\n\n    def _code_auth(self):\n        state, location = self.cons.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n        return self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n\n    def _code_auth2(self):\n        state, location = self.cons2.begin(\n            \"openid\", \"code\", path=\"http://www.example.org\"\n        )\n        return self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n\n    def test_session_state_in_auth_req_for_session_support(self, session_db_factory):\n        provider = Provider(\n            SERVER_INFO[\"issuer\"],\n            session_db_factory(SERVER_INFO[\"issuer\"]),\n            CDB,\n            AUTHN_BROKER,\n            USERINFO,\n            AUTHZ,\n            verify_client,\n            SYMKEY,\n            urlmap=URLMAP,\n            keyjar=KEYJAR,\n        )\n\n        provider.capabilities.update(\n            {\"check_session_iframe\": \"https://op.example.com/check_session\"}\n        )\n\n        req_args = {\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\"],\n            \"client_id\": \"number5\",\n        }\n        areq = AuthorizationRequest(**req_args)\n        resp = provider.authorization_endpoint(request=areq.to_urlencoded())\n        aresp = self.cons.parse_response(\n            AuthorizationResponse, resp.message, sformat=\"urlencoded\"\n        )\n        assert \"session_state\" in aresp\n\n    def _assert_cookies_expired(self, http_headers):\n        cookies_string = \";\".join([c[1] for c in http_headers if c[0] == \"Set-Cookie\"])\n        all_cookies: SimpleCookie = SimpleCookie()\n\n        all_cookies.load(cookies_string)\n\n        now = datetime.datetime.utcnow()\n        for c in [self.provider.cookie_name, self.provider.session_cookie_name]:\n            dt = datetime.datetime.strptime(\n                all_cookies[c][\"expires\"], \"%a, %d-%b-%Y %H:%M:%S GMT\"\n            )\n            assert dt < now  # make sure the cookies have expired to be cleared\n\n    def _auth_with_id_token(self):\n        state, location = self.cons.begin(\n            \"openid\", \"id_token\", path=\"http://localhost:8087\"\n        )\n        resp = self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n        aresp = self.cons.parse_response(\n            AuthorizationResponse, resp.message, sformat=\"urlencoded\"\n        )\n        return aresp[\"id_token\"]\n\n    def test_id_token_RS512_sign(self):\n        self.provider.capabilities[\"id_token_signing_alg_values_supported\"] = [\"RS512\"]\n        self.provider.build_jwx_def()\n        id_token = self._auth_with_id_token()\n        assert id_token.jws_header[\"alg\"] == \"RS512\"\n\n    def test_refresh_token_grant_type_ok(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n        info = _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        rareq = RefreshAccessTokenRequest(\n            grant_type=\"refresh_token\",\n            refresh_token=info[\"refresh_token\"],\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            scope=[\"openid\"],\n        )\n\n        resp = self.provider.refresh_token_grant_type(rareq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert atr[\"refresh_token\"] is not None\n        assert atr[\"token_type\"] == \"Bearer\"\n\n    def test_refresh_token_grant_type_wrong_token(self):\n        rareq = RefreshAccessTokenRequest(\n            grant_type=\"refresh_token\",\n            refresh_token=\"some_other_refresh_token\",\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            scope=[\"openid\"],\n        )\n\n        resp = self.provider.refresh_token_grant_type(rareq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Not a refresh token\"\n\n    def test_refresh_token_grant_type_expired(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n        with freeze_time(\"2000-01-01\"):\n            info = _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        rareq = RefreshAccessTokenRequest(\n            grant_type=\"refresh_token\",\n            refresh_token=info[\"refresh_token\"],\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            scope=[\"openid\"],\n        )\n\n        resp = self.provider.refresh_token_grant_type(rareq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Refresh token is expired\"\n\n    def test_authorization_endpoint_faulty_request_uri(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"request_uri\": \"https://some-non-resolving.hostname.com/request_uri#1234\",\n            # faulty request_uri\n            \"response_type\": [\"code\"],\n            \"client_id\": \"a1b2c3\",\n        }\n\n        arq = AuthorizationRequest(**bib)\n        resp = self.provider.authorization_endpoint(request=arq.to_urlencoded())\n        assert resp.status_code == 400\n        msg = json.loads(resp.message)\n        assert msg[\"error\"] == \"invalid_request_uri\"\n\n    def test_encrypt_missing_info(self):\n        payload = self.provider.encrypt(\"payload\", {}, \"some_client\")\n        assert payload == \"payload\"\n\n    def test_encrypt_missing_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks_uri\": \"http://example.com/key\",\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://example.com/key\",\n                body=key,\n                content_type=\"application/json\",\n            )\n            payload = self.provider.encrypt(\"payload\", info, \"some_client\")\n        token = JWEnc().unpack(payload)\n        headers = json.loads(token.protected_header().decode())\n        assert headers[\"alg\"] == \"A128KW\"\n        assert headers[\"enc\"] == \"A128CBC-HS256\"\n\n    def test_encrypt_missing_not_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        info = {\n            \"id_token_encrypted_response_alg\": \"RSA1_5\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n        }\n        with pytest.raises(JWEException):\n            self.provider.encrypt(\"payload\", info, \"some_client\")\n\n    def test_encrypt_userinfo_missing_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"userinfo_encrypted_response_alg\": \"A128KW\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks_uri\": \"http://example.com/key\",\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://example.com/key\",\n                body=key,\n                content_type=\"application/json\",\n            )\n            payload = self.provider.encrypt(\n                \"payload\", info, \"some_client\", val_type=\"userinfo\"\n            )\n        token = JWEnc().unpack(payload)\n        headers = json.loads(token.protected_header().decode())\n        assert headers[\"alg\"] == \"A128KW\"\n        assert headers[\"enc\"] == \"A128CBC-HS256\"\n\n    def test_encrypt_missing_userinfo_not_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        info = {\n            \"userinfo_encrypted_response_alg\": \"RSA1_5\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n        }\n        with pytest.raises(JWEException):\n            self.provider.encrypt(\"payload\", info, \"some_client\", val_type=\"userinfo\")\n\n    def test_recuperate_jwks(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks\": json.loads(key),\n        }\n        self.provider.recuperate_keys(\"some_client\", info)\n        assert len(self.provider.keyjar.get_issuer_keys(\"some_client\")) == 3\n\n    def test_recuperate_jwks_uri(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks_uri\": \"http://example.com/key\",\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://example.com/key\",\n                body=key,\n                content_type=\"application/json\",\n            )\n            self.provider.recuperate_keys(\"some_client\", info)\n            assert len(self.provider.keyjar.get_issuer_keys(\"some_client\")) == 3\n\n    def test_recuperate_none(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n        }\n        self.provider.recuperate_keys(\"some_client\", info)\n        assert len(self.provider.keyjar.get_issuer_keys(\"some_client\")) == 2\n\n    def test_get_by(self):\n        _sdb = self.provider.sdb\n\n        # First authn\n        authreq_1 = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq_1)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq_1.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n        _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        # Second authn\n        authreq_2 = AuthorizationRequest(\n            state=\"next_state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n        )\n\n        sid_2 = _sdb.access_token.key(user=\"sub\", areq=authreq_2)\n        access_grant = _sdb.access_token(sid=sid_2)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid_2] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq_1.to_json(),\n            \"client_id\": \"2ndClient\",\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid_2, \"client_salt\")\n        _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        sub = _sdb[sid_2][\"sub\"]\n        assert self.provider.sdb.get_uid_by_sub(sub) == \"user\"\n        assert self.provider.sdb.get_uid_by_sid(sid_2) == \"user\"\n\n        assert self.provider.get_by_sub_and_(sub, \"client_id\", \"2ndClient\") == sid_2\n        assert self.provider.get_by_sub_and_(sub, \"client_id\", CLIENT_ID) == sid\n\n        # Error cases\n        assert self.provider.get_by_sub_and_(sub, \"client_id\", \"unknown\") is None\n        assert self.provider.get_by_sub_and_(\"who\", \"client_id\", CLIENT_ID) is None\n        assert self.provider.get_by_sub_and_(sub, \"foo\", \"bar\") is None\n"], "fixing_code": ["import hashlib\nimport logging\nimport os\nimport warnings\nfrom base64 import b64encode\nfrom json import JSONDecodeError\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import Union\nfrom typing import cast\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlparse\n\nfrom jwkest import BadSyntax\nfrom jwkest import as_bytes\nfrom jwkest import jwe\nfrom jwkest import jws\nfrom jwkest import jwt\nfrom jwkest.jwe import JWE\nfrom requests import ConnectionError\n\nfrom oic import oauth2\nfrom oic import rndstr\nfrom oic.exception import AccessDenied\nfrom oic.exception import AuthnToOld\nfrom oic.exception import AuthzError\nfrom oic.exception import CommunicationError\nfrom oic.exception import MissingParameter\nfrom oic.exception import ParameterError\nfrom oic.exception import PyoidcError\nfrom oic.exception import RegistrationError\nfrom oic.exception import RequestError\nfrom oic.exception import SubMismatch\nfrom oic.oauth2 import HTTP_ARGS\nfrom oic.oauth2 import authz_error\nfrom oic.oauth2.consumer import ConfigurationError\nfrom oic.oauth2.exception import MissingRequiredAttribute\nfrom oic.oauth2.exception import OtherError\nfrom oic.oauth2.exception import ParseError\nfrom oic.oauth2.message import ErrorResponse\nfrom oic.oauth2.message import Message\nfrom oic.oauth2.message import MessageFactory\nfrom oic.oauth2.message import WrongSigningAlgorithm\nfrom oic.oauth2.util import get_or_post\nfrom oic.oic.message import SCOPE2CLAIMS\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationErrorResponse\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import Claims\nfrom oic.oic.message import ClaimsRequest\nfrom oic.oic.message import ClientRegistrationErrorResponse\nfrom oic.oic.message import EndSessionRequest\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import JasonWebToken\nfrom oic.oic.message import OIDCMessageFactory\nfrom oic.oic.message import OpenIDRequest\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import RefreshSessionRequest\nfrom oic.oic.message import RegistrationRequest\nfrom oic.oic.message import RegistrationResponse\nfrom oic.oic.message import TokenErrorResponse\nfrom oic.oic.message import UserInfoErrorResponse\nfrom oic.oic.message import UserInfoRequest\nfrom oic.utils import time_util\nfrom oic.utils.http_util import Response\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.sanitize import sanitize\nfrom oic.utils.settings import OicClientSettings\nfrom oic.utils.settings import OicServerSettings\nfrom oic.utils.settings import PyoidcSettings\nfrom oic.utils.webfinger import OIC_ISSUER\nfrom oic.utils.webfinger import WebFinger\n\n__author__ = \"rohe0002\"\n\nlogger = logging.getLogger(__name__)\n\nENDPOINTS = [\n    \"authorization_endpoint\",\n    \"token_endpoint\",\n    \"userinfo_endpoint\",\n    \"refresh_session_endpoint\",\n    \"end_session_endpoint\",\n    \"registration_endpoint\",\n    \"check_id_endpoint\",\n]\n\nRESPONSE2ERROR: Dict[str, List] = {\n    \"AuthorizationResponse\": [AuthorizationErrorResponse, TokenErrorResponse],\n    \"AccessTokenResponse\": [TokenErrorResponse],\n    \"IdToken\": [ErrorResponse],\n    \"RegistrationResponse\": [ClientRegistrationErrorResponse],\n    \"OpenIDSchema\": [UserInfoErrorResponse],\n}\n\nREQUEST2ENDPOINT = {\n    \"AuthorizationRequest\": \"authorization_endpoint\",\n    \"OpenIDRequest\": \"authorization_endpoint\",\n    \"AccessTokenRequest\": \"token_endpoint\",\n    \"RefreshAccessTokenRequest\": \"token_endpoint\",\n    \"UserInfoRequest\": \"userinfo_endpoint\",\n    \"CheckSessionRequest\": \"check_session_endpoint\",\n    \"CheckIDRequest\": \"check_id_endpoint\",\n    \"EndSessionRequest\": \"end_session_endpoint\",\n    \"RefreshSessionRequest\": \"refresh_session_endpoint\",\n    \"RegistrationRequest\": \"registration_endpoint\",\n    \"RotateSecret\": \"registration_endpoint\",\n    # ---\n    \"ResourceRequest\": \"resource_endpoint\",\n    \"TokenIntrospectionRequest\": \"introspection_endpoint\",\n    \"TokenRevocationRequest\": \"revocation_endpoint\",\n    \"ROPCAccessTokenRequest\": \"token_endpoint\",\n}\n\n# -----------------------------------------------------------------------------\n\nJWT_BEARER = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\nSAML2_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:saml2-bearer\"\n\n# This should probably be part of the configuration\nMAX_AUTHENTICATION_AGE = 86400\nDEF_SIGN_ALG = {\n    \"id_token\": \"RS256\",\n    \"openid_request_object\": \"RS256\",\n    \"client_secret_jwt\": \"HS256\",\n    \"private_key_jwt\": \"RS256\",\n}\n\n# -----------------------------------------------------------------------------\nACR_LISTS = [[\"0\", \"1\", \"2\", \"3\", \"4\"]]\n\n\ndef verify_acr_level(req, level):\n    if req is None:\n        return level\n    elif \"values\" in req:\n        for _r in req[\"values\"]:\n            for alist in ACR_LISTS:\n                try:\n                    if alist.index(_r) <= alist.index(level):\n                        return level\n                except ValueError:\n                    pass\n    else:  # Required or Optional\n        return level\n\n    raise AccessDenied(\"\", req)\n\n\ndef deser_id_token(inst, txt=\"\"):\n    if not txt:\n        return None\n    else:\n        return IdToken().from_jwt(txt, keyjar=inst.keyjar)\n\n\n# -----------------------------------------------------------------------------\ndef make_openid_request(\n    arq,\n    keys=None,\n    userinfo_claims=None,\n    idtoken_claims=None,\n    request_object_signing_alg=None,\n    **kwargs,\n):\n    \"\"\"\n    Construct the specification of what I want returned.\n\n    The request will be signed.\n\n    :param arq: The Authorization request\n    :param keys: Keys to use for signing/encrypting\n    :param userinfo_claims: UserInfo claims\n    :param idtoken_claims: IdToken claims\n    :param request_object_signing_alg: Which signing algorithm to use\n    :return: JWT encoded OpenID request\n    \"\"\"\n    oir_args = {}\n    for prop in OpenIDRequest.c_param.keys():\n        try:\n            oir_args[prop] = arq[prop]\n        except KeyError:\n            pass\n\n    for attr in [\"scope\", \"response_type\"]:\n        if attr in oir_args:\n            oir_args[attr] = \" \".join(oir_args[attr])\n\n    c_args = {}\n    if userinfo_claims is not None:\n        # UserInfoClaims\n        c_args[\"userinfo\"] = Claims(**userinfo_claims)\n\n    if idtoken_claims is not None:\n        # IdTokenClaims\n        c_args[\"id_token\"] = Claims(**idtoken_claims)\n\n    if c_args:\n        oir_args[\"claims\"] = ClaimsRequest(**c_args)\n\n    oir = OpenIDRequest(**oir_args)\n\n    return oir.to_jwt(key=keys, algorithm=request_object_signing_alg)\n\n\nclass Token(oauth2.Token):\n    pass\n\n\nclass Grant(oauth2.Grant):\n    _authz_resp = AuthorizationResponse\n    _acc_resp = AccessTokenResponse\n    _token_class = Token\n\n    def add_token(self, resp):\n        tok = self._token_class(resp)\n        if tok.access_token:\n            self.tokens.append(tok)\n        else:\n            _tmp = getattr(tok, \"id_token\", None)\n            if _tmp:\n                self.tokens.append(tok)\n\n\nPREFERENCE2PROVIDER = {\n    \"request_object_signing_alg\": \"request_object_signing_alg_values_supported\",\n    \"request_object_encryption_alg\": \"request_object_encryption_alg_values_supported\",\n    \"request_object_encryption_enc\": \"request_object_encryption_enc_values_supported\",\n    \"userinfo_signed_response_alg\": \"userinfo_signing_alg_values_supported\",\n    \"userinfo_encrypted_response_alg\": \"userinfo_encryption_alg_values_supported\",\n    \"userinfo_encrypted_response_enc\": \"userinfo_encryption_enc_values_supported\",\n    \"id_token_signed_response_alg\": \"id_token_signing_alg_values_supported\",\n    \"id_token_encrypted_response_alg\": \"id_token_encryption_alg_values_supported\",\n    \"id_token_encrypted_response_enc\": \"id_token_encryption_enc_values_supported\",\n    \"default_acr_values\": \"acr_values_supported\",\n    \"subject_type\": \"subject_types_supported\",\n    \"token_endpoint_auth_method\": \"token_endpoint_auth_methods_supported\",\n    \"token_endpoint_auth_signing_alg\": \"token_endpoint_auth_signing_alg_values_supported\",\n    \"response_types\": \"response_types_supported\",\n    \"grant_types\": \"grant_types_supported\",\n}\n\nPROVIDER2PREFERENCE = dict([(v, k) for k, v in PREFERENCE2PROVIDER.items()])\n\nPROVIDER_DEFAULT = {\n    \"token_endpoint_auth_method\": \"client_secret_basic\",\n    \"id_token_signed_response_alg\": \"RS256\",\n}\n\nPARAMMAP = {\n    \"sign\": \"%s_signed_response_alg\",\n    \"alg\": \"%s_encrypted_response_alg\",\n    \"enc\": \"%s_encrypted_response_enc\",\n}\n\nrt2gt = {\n    \"code\": [\"authorization_code\"],\n    \"id_token\": [\"implicit\"],\n    \"id_token token\": [\"implicit\"],\n    \"code id_token\": [\"authorization_code\", \"implicit\"],\n    \"code token\": [\"authorization_code\", \"implicit\"],\n    \"code id_token token\": [\"authorization_code\", \"implicit\"],\n}\n\n\ndef response_types_to_grant_types(resp_types, **kwargs):\n    _res = set()\n\n    if \"grant_types\" in kwargs:\n        _res.update(set(kwargs[\"grant_types\"]))\n\n    for response_type in resp_types:\n        _rt = response_type.split(\" \")\n        _rt.sort()\n        try:\n            _gt = rt2gt[\" \".join(_rt)]\n        except KeyError:\n            raise ValueError(\"No such response type combination: {}\".format(resp_types))\n        else:\n            _res.update(set(_gt))\n\n    return list(_res)\n\n\ndef claims_match(value, claimspec):\n    \"\"\"\n    Implement matching according to section 5.5.1 of http://openid.net/specs/openid-connect-core-1_0.html.\n\n    The lack of value is not checked here.\n    Also the text doesn't prohibit having both 'value' and 'values'.\n\n    :param value: single value or list of values\n    :param claimspec: None or dictionary with 'essential', 'value' or 'values'\n    as key\n    :return: Boolean\n    \"\"\"\n    if claimspec is None:  # match anything\n        return True\n\n    matched = False\n    for key, val in claimspec.items():\n        if key == \"value\":\n            if value == val:\n                matched = True\n        elif key == \"values\":\n            if value in val:\n                matched = True\n        elif key == \"essential\":\n            # Whether it's essential or not doesn't change anything here\n            continue\n\n        if matched:\n            break\n\n    if matched is False:\n        if list(claimspec.keys()) == [\"essential\"]:\n            return True\n\n    return matched\n\n\nclass Client(oauth2.Client):\n    _endpoints = ENDPOINTS\n\n    def __init__(\n        self,\n        client_id=None,\n        client_prefs=None,\n        client_authn_method=None,\n        keyjar=None,\n        verify_ssl=None,\n        config=None,\n        client_cert=None,\n        requests_dir=\"requests\",\n        message_factory: Type[MessageFactory] = OIDCMessageFactory,\n        settings: PyoidcSettings = None,\n    ):\n        \"\"\"\n        Initialize the instance.\n\n        Keyword Args:\n            settings\n                Instance of :class:`OauthClientSettings` with configuration options.\n                Currently used settings are:\n                 - verify_ssl\n                 - client_cert\n                 - timeout\n        \"\"\"\n        self.settings = settings or OicClientSettings()\n        if verify_ssl is not None:\n            warnings.warn(\n                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.verify_ssl = verify_ssl\n        if client_cert is not None:\n            warnings.warn(\n                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.client_cert = client_cert\n        oauth2.Client.__init__(\n            self,\n            client_id,\n            client_authn_method=client_authn_method,\n            keyjar=keyjar,\n            config=config,\n            message_factory=message_factory,\n            settings=self.settings,\n        )\n\n        self.file_store = \"./file/\"\n        self.file_uri = \"http://localhost/\"\n        self.base_url = \"\"\n\n        # OpenID connect specific endpoints\n        for endpoint in ENDPOINTS:\n            setattr(self, endpoint, \"\")\n\n        self.id_token: Dict[str, Token] = {}\n        self.log = None\n\n        self.request2endpoint = REQUEST2ENDPOINT\n        self.response2error = RESPONSE2ERROR\n\n        self.grant_class = Grant\n        self.token_class = Token\n        self.provider_info = Message()\n        self.registration_response: RegistrationResponse = RegistrationResponse()\n        self.client_prefs = client_prefs or {}\n\n        self.behaviour: Dict[str, Any] = {}\n        self.scope = [\"openid\"]\n\n        self.wf = WebFinger(OIC_ISSUER)\n        self.wf.httpd = self\n        self.allow = {}\n        self.post_logout_redirect_uris: List[str] = []\n        self.registration_expires = 0\n        self.registration_access_token = None\n        self.id_token_max_age = 0\n\n        # Default key by kid for different key types\n        # For instance {'sig': {\"RSA\":\"abc\"}}\n        self.kid = {\"sig\": {}, \"enc\": {}}\n        self.requests_dir = requests_dir\n\n    def _get_id_token(self, **kwargs):\n        try:\n            return kwargs[\"id_token\"]\n        except KeyError:\n            grant = self.get_grant(**kwargs)\n\n        if grant:\n            try:\n                _scope = kwargs[\"scope\"]\n            except KeyError:\n                _scope = None\n\n            for token in grant.tokens:\n                if token.scope and _scope:\n                    flag = True\n                    for item in _scope:\n                        if item not in token.scope:\n                            flag = False\n                            break\n                    if not flag:\n                        break\n                if token.id_token:\n                    return token.id_token.jwt\n\n        return None\n\n    def request_object_encryption(self, msg, **kwargs):\n        try:\n            encalg = kwargs[\"request_object_encryption_alg\"]\n        except KeyError:\n            try:\n                encalg = self.behaviour[\"request_object_encryption_alg\"]\n            except KeyError:\n                return msg\n\n        try:\n            encenc = kwargs[\"request_object_encryption_enc\"]\n        except KeyError:\n            try:\n                encenc = self.behaviour[\"request_object_encryption_enc\"]\n            except KeyError:\n                raise MissingRequiredAttribute(\n                    \"No request_object_encryption_enc specified\"\n                )\n\n        _jwe = JWE(msg, alg=encalg, enc=encenc)\n        _kty = jwe.alg2keytype(encalg)\n\n        try:\n            _kid = kwargs[\"enc_kid\"]\n        except KeyError:\n            _kid = \"\"\n\n        if \"target\" not in kwargs:\n            raise MissingRequiredAttribute(\"No target specified\")\n\n        if _kid:\n            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"], kid=_kid)\n            _jwe[\"kid\"] = _kid\n        else:\n            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"])\n\n        return _jwe.encrypt(_keys)\n\n    @staticmethod\n    def construct_redirect_uri(**kwargs):\n        _filedir = kwargs[\"local_dir\"]\n        if not os.path.isdir(_filedir):\n            os.makedirs(_filedir)\n        _webpath = kwargs[\"base_path\"]\n        _name = rndstr(10) + \".jwt\"\n        filename = os.path.join(_filedir, _name)\n        while os.path.exists(filename):\n            _name = rndstr(10)\n            filename = os.path.join(_filedir, _name)\n        _webname = \"%s%s\" % (_webpath, _name)\n        return filename, _webname\n\n    def filename_from_webname(self, webname):\n        _filedir = self.requests_dir\n        if not os.path.isdir(_filedir):\n            os.makedirs(_filedir)\n\n        if webname.startswith(self.base_url):\n            return webname[len(self.base_url) :]\n        else:\n            raise ValueError(\"Invalid webname, must start with base_url\")\n\n    def construct_AuthorizationRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n\n        if request_args is not None:\n            if \"nonce\" not in request_args:\n                _rt = request_args[\"response_type\"]\n                if \"token\" in _rt or \"id_token\" in _rt:\n                    request_args[\"nonce\"] = rndstr(32)\n        elif \"response_type\" in kwargs:\n            if \"token\" in kwargs[\"response_type\"]:\n                request_args = {\"nonce\": rndstr(32)}\n        else:  # Never wrong to specify a nonce\n            request_args = {\"nonce\": rndstr(32)}\n\n        request_param = kwargs.get(\"request_param\")\n        if \"request_method\" in kwargs:\n            if kwargs[\"request_method\"] == \"file\":\n                request_param = \"request_uri\"\n            else:\n                request_param = \"request\"\n            del kwargs[\"request_method\"]\n\n        areq = super().construct_AuthorizationRequest(\n            request=request, request_args=request_args, extra_args=extra_args, **kwargs\n        )\n\n        if request_param:\n            alg = None\n            for arg in [\"request_object_signing_alg\", \"algorithm\"]:\n                try:  # Trumps everything\n                    alg = kwargs[arg]\n                except KeyError:\n                    pass\n                else:\n                    break\n\n            if not alg:\n                try:\n                    alg = self.behaviour[\"request_object_signing_alg\"]\n                except KeyError:\n                    alg = \"none\"\n\n            kwargs[\"request_object_signing_alg\"] = alg\n\n            if \"keys\" not in kwargs and alg and alg != \"none\":\n                _kty = jws.alg2keytype(alg)\n                try:\n                    _kid = kwargs[\"sig_kid\"]\n                except KeyError:\n                    _kid = self.kid[\"sig\"].get(_kty, None)\n\n                kwargs[\"keys\"] = self.keyjar.get_signing_key(_kty, kid=_kid)\n\n            _req = make_openid_request(areq, **kwargs)\n\n            # Should the request be encrypted\n            _req = self.request_object_encryption(_req, **kwargs)\n\n            if request_param == \"request\":\n                areq[\"request\"] = _req\n            else:\n                try:\n                    _webname = self.registration_response[\"request_uris\"][0]\n                    filename = self.filename_from_webname(_webname)\n                except KeyError:\n                    filename, _webname = self.construct_redirect_uri(**kwargs)\n                with open(filename, mode=\"w\") as fid:\n                    fid.write(_req)\n                areq[\"request_uri\"] = _webname\n\n        return areq\n\n    def construct_UserInfoRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n\n        if request is None:\n            request = self.message_factory.get_request_type(\"userinfo_endpoint\")\n        if request_args is None:\n            request_args = {}\n\n        if \"access_token\" in request_args:\n            pass\n        else:\n            if \"scope\" not in kwargs:\n                kwargs[\"scope\"] = \"openid\"\n            token = self.get_token(**kwargs)\n            if token is None:\n                raise MissingParameter(\"No valid token available\")\n\n            request_args[\"access_token\"] = token.access_token\n\n        return self.construct_request(request, request_args, extra_args)\n\n    def construct_RegistrationRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"registration_endpoint\")\n        return self.construct_request(request, request_args, extra_args)\n\n    def construct_RefreshSessionRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"refreshsession_endpoint\")\n        return self.construct_request(request, request_args, extra_args)\n\n    def _id_token_based(self, request, request_args=None, extra_args=None, **kwargs):\n\n        if request_args is None:\n            request_args = {}\n\n        try:\n            _prop = kwargs[\"prop\"]\n        except KeyError:\n            _prop = \"id_token\"\n\n        if _prop in request_args:\n            pass\n        else:\n            raw_id_token = self._get_id_token(**kwargs)\n            if raw_id_token is None:\n                raise MissingParameter(\"No valid id token available\")\n\n            request_args[_prop] = raw_id_token\n\n        return self.construct_request(request, request_args, extra_args)\n\n    def construct_CheckSessionRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"checksession_endpoint\")\n\n        return self._id_token_based(request, request_args, extra_args, **kwargs)\n\n    def construct_CheckIDRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n        if request is None:\n            request = self.message_factory.get_request_type(\"checkid_endpoint\")\n        # access_token is where the id_token will be placed\n        return self._id_token_based(\n            request, request_args, extra_args, prop=\"access_token\", **kwargs\n        )\n\n    def construct_EndSessionRequest(\n        self, request=None, request_args=None, extra_args=None, **kwargs\n    ):\n\n        if request is None:\n            request = self.message_factory.get_request_type(\"endsession_endpoint\")\n        if request_args is None:\n            request_args = {}\n\n        if \"state\" in request_args and \"state\" not in kwargs:\n            kwargs[\"state\"] = request_args[\"state\"]\n\n        return self._id_token_based(request, request_args, extra_args, **kwargs)\n\n    def do_authorization_request(\n        self,\n        state=\"\",\n        body_type=\"\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n        **kwargs,\n    ):\n        algs = self.sign_enc_algs(\"id_token\")\n\n        if \"code_challenge\" in self.config:\n            _args, code_verifier = self.add_code_challenge()\n            request_args.update(_args)\n\n        return super().do_authorization_request(\n            state=state,\n            body_type=body_type,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            http_args=http_args,\n            algs=algs,\n        )\n\n    def do_access_token_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"POST\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n        authn_method=\"client_secret_basic\",\n        **kwargs,\n    ):\n        atr = super().do_access_token_request(\n            scope=scope,\n            state=state,\n            body_type=body_type,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            http_args=http_args,\n            authn_method=authn_method,\n            **kwargs,\n        )\n        try:\n            _idt = atr[\"id_token\"]\n        except KeyError:\n            pass\n        else:\n            try:\n                if self.state2nonce[state] != _idt[\"nonce\"]:\n                    raise ParameterError('Someone has messed with \"nonce\"')\n            except KeyError:\n                pass\n        return atr\n\n    def do_registration_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"POST\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n        request = self.message_factory.get_request_type(\"registration_endpoint\")\n        url, body, ht_args, csi = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        response_cls = self.message_factory.get_response_type(\"registration_endpoint\")\n        response = self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n        return response\n\n    def do_check_session_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n\n        request = self.message_factory.get_request_type(\"checksession_endpoint\")\n        response_cls = self.message_factory.get_response_type(\"checksession_endpoint\")\n\n        url, body, ht_args, csi = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        return self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n\n    def do_check_id_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"json\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n        request = self.message_factory.get_request_type(\"checkid_endpoint\")\n        response_cls = self.message_factory.get_response_type(\"checkid_endpoint\")\n\n        url, body, ht_args, csi = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        return self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n\n    def do_end_session_request(\n        self,\n        scope=\"\",\n        state=\"\",\n        body_type=\"\",\n        method=\"GET\",\n        request_args=None,\n        extra_args=None,\n        http_args=None,\n    ):\n        request = self.message_factory.get_request_type(\"endsession_endpoint\")\n        response_cls = self.message_factory.get_response_type(\"endsession_endpoint\")\n        url, body, ht_args, _ = self.request_info(\n            request,\n            method=method,\n            request_args=request_args,\n            extra_args=extra_args,\n            scope=scope,\n            state=state,\n        )\n\n        if http_args is None:\n            http_args = ht_args\n        else:\n            http_args.update(http_args)\n\n        return self.request_and_return(\n            url, response_cls, method, body, body_type, state=state, http_args=http_args\n        )\n\n    def user_info_request(self, method=\"GET\", state=\"\", scope=\"\", **kwargs):\n        uir = self.message_factory.get_request_type(\"userinfo_endpoint\")()\n        logger.debug(\"[user_info_request]: kwargs:%s\" % (sanitize(kwargs),))\n        token: Optional[Token] = None\n        if \"token\" in kwargs:\n            if kwargs[\"token\"]:\n                uir[\"access_token\"] = kwargs[\"token\"]\n                token = Token()\n                token.token_type = \"Bearer\"\n                token.access_token = kwargs[\"token\"]\n                kwargs[\"behavior\"] = \"use_authorization_header\"\n            else:\n                # What to do ? Need a callback\n                pass\n        elif \"access_token\" in kwargs and kwargs[\"access_token\"]:\n            uir[\"access_token\"] = kwargs[\"access_token\"]\n            del kwargs[\"access_token\"]\n        elif state:\n            token = self.grant[state].get_token(scope)\n            if token is None:\n                raise AccessDenied(\"invalid_token\")\n            if token.is_valid():\n                uir[\"access_token\"] = token.access_token\n                if (\n                    token.token_type\n                    and token.token_type.lower() == \"bearer\"\n                    and method == \"GET\"\n                ):\n                    kwargs[\"behavior\"] = \"use_authorization_header\"\n            else:\n                # raise oauth2.OldAccessToken\n                if self.log:\n                    self.log.info(\"do access token refresh\")\n                try:\n                    self.do_access_token_refresh(token=token, state=state)\n                    token = cast(Token, self.grant[state].get_token(scope))\n                    uir[\"access_token\"] = token.access_token\n                except Exception:\n                    raise\n\n        uri = self._endpoint(\"userinfo_endpoint\", **kwargs)\n        # If access token is a bearer token it might be sent in the\n        # authorization header\n        # 4 ways of sending the access_token:\n        # - POST with token in authorization header\n        # - POST with token in message body\n        # - GET with token in authorization header\n        # - GET with token as query parameter\n        if \"behavior\" in kwargs:\n            _behav = kwargs[\"behavior\"]\n            _token = uir[\"access_token\"]\n            _ttype = \"\"\n            try:\n                _ttype = kwargs[\"token_type\"]\n            except KeyError:\n                if token:\n                    try:\n                        _ttype = cast(str, token.token_type)\n                    except AttributeError:\n                        raise MissingParameter(\"Unspecified token type\")\n\n            if \"as_query_parameter\" == _behav:\n                method = \"GET\"\n            elif token:\n                # use_authorization_header, token_in_message_body\n                if \"use_authorization_header\" in _behav:\n                    token_header = \"{type} {token}\".format(\n                        type=_ttype.capitalize(), token=_token\n                    )\n                    if \"headers\" in kwargs:\n                        kwargs[\"headers\"].update({\"Authorization\": token_header})\n                    else:\n                        kwargs[\"headers\"] = {\"Authorization\": token_header}\n\n                if \"token_in_message_body\" not in _behav:\n                    # remove the token from the request\n                    del uir[\"access_token\"]\n\n        path, body, kwargs = get_or_post(uri, method, uir, **kwargs)\n\n        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])\n\n        return path, body, method, h_args\n\n    def do_user_info_request(\n        self, method=\"POST\", state=\"\", scope=\"openid\", request=\"openid\", **kwargs\n    ):\n\n        kwargs[\"request\"] = request\n        path, body, method, h_args = self.user_info_request(\n            method, state, scope, **kwargs\n        )\n\n        logger.debug(\n            \"[do_user_info_request] PATH:%s BODY:%s H_ARGS: %s\"\n            % (sanitize(path), sanitize(body), sanitize(h_args))\n        )\n\n        if self.events:\n            self.events.store(\"Request\", {\"body\": body})\n            self.events.store(\"request_url\", path)\n            self.events.store(\"request_http_args\", h_args)\n\n        try:\n            resp = self.http_request(path, method, data=body, **h_args)\n        except oauth2.exception.MissingRequiredAttribute:\n            raise\n\n        if resp.status_code == 200:\n            if \"application/json\" in resp.headers[\"content-type\"]:\n                sformat = \"json\"\n            elif \"application/jwt\" in resp.headers[\"content-type\"]:\n                sformat = \"jwt\"\n            else:\n                raise PyoidcError(\n                    \"ERROR: Unexpected content-type: %s\" % resp.headers[\"content-type\"]\n                )\n        elif resp.status_code == 500:\n            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)\n        elif resp.status_code == 405:\n            # Method not allowed error\n            allowed_methods = [x.strip() for x in resp.headers[\"allow\"].split(\",\")]\n            raise CommunicationError(\n                \"Server responded with HTTP Error Code 405\", \"\", allowed_methods\n            )\n        elif 400 <= resp.status_code < 500:\n            # the response text might be a OIDC message\n            try:\n                res = ErrorResponse().from_json(resp.text)\n            except Exception:\n                raise RequestError(resp.text)\n            else:\n                self.store_response(res, resp.text)\n                return res\n        else:\n            raise PyoidcError(\n                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)\n            )\n\n        try:\n            _schema = kwargs[\"user_info_schema\"]\n        except KeyError:\n            _schema = OpenIDSchema\n\n        logger.debug(\"Reponse text: '%s'\" % sanitize(resp.text))\n\n        _txt = resp.text\n        if sformat == \"json\":\n            res = _schema().from_json(txt=_txt)\n        else:\n            verify = kwargs.get(\"verify\", True)\n            res = _schema().from_jwt(\n                _txt,\n                keyjar=self.keyjar,\n                sender=self.provider_info[\"issuer\"],\n                verify=verify,\n            )\n\n        if \"error\" in res:  # Error response\n            res = UserInfoErrorResponse(**res.to_dict())\n\n        if state:\n            # Verify userinfo sub claim against what's returned in the ID Token\n            idt = self.grant[state].get_id_token()\n            if idt:\n                if idt[\"sub\"] != res[\"sub\"]:\n                    raise SubMismatch(\n                        \"Sub identifier not the same in userinfo and Id Token\"\n                    )\n\n        self.store_response(res, _txt)\n\n        return res\n\n    def get_userinfo_claims(\n        self, access_token, endpoint, method=\"POST\", schema_class=OpenIDSchema, **kwargs\n    ):\n\n        uir = UserInfoRequest(access_token=access_token)\n\n        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])\n\n        if \"authn_method\" in kwargs:\n            http_args = self.init_authentication_method(**kwargs)\n        else:\n            # If nothing defined this is the default\n            http_args = self.init_authentication_method(uir, \"bearer_header\", **kwargs)\n\n        h_args.update(http_args)\n        path, body, kwargs = get_or_post(endpoint, method, uir, **kwargs)\n\n        try:\n            resp = self.http_request(path, method, data=body, **h_args)\n        except MissingRequiredAttribute:\n            raise\n\n        if resp.status_code == 200:\n            # FIXME: Could this also encounter application/jwt for encrypted userinfo\n            #        the do_userinfo_request method already handles it\n            if \"application/json\" not in resp.headers[\"content-type\"]:\n                raise PyoidcError(\n                    \"ERROR: content-type in response unexpected: %s\"\n                    % resp.headers[\"content-type\"]\n                )\n        elif resp.status_code == 500:\n            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)\n        else:\n            raise PyoidcError(\n                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)\n            )\n\n        res = schema_class().from_json(txt=resp.text)\n        self.store_response(res, resp.text)\n        return res\n\n    def unpack_aggregated_claims(self, userinfo):\n        if userinfo[\"_claim_sources\"]:\n            for csrc, spec in userinfo[\"_claim_sources\"].items():\n                if \"JWT\" in spec:\n                    aggregated_claims = Message().from_jwt(\n                        spec[\"JWT\"].encode(\"utf-8\"), keyjar=self.keyjar, sender=csrc\n                    )\n                    claims = [\n                        value\n                        for value, src in userinfo[\"_claim_names\"].items()\n                        if src == csrc\n                    ]\n\n                    if set(claims) != set(list(aggregated_claims.keys())):\n                        logger.warning(\n                            \"Claims from claim source doesn't match what's in \"\n                            \"the userinfo\"\n                        )\n\n                    for key, vals in aggregated_claims.items():\n                        userinfo[key] = vals\n\n        return userinfo\n\n    def fetch_distributed_claims(self, userinfo, callback=None):\n        for csrc, spec in userinfo[\"_claim_sources\"].items():\n            if \"endpoint\" in spec:\n                if not spec[\"endpoint\"].startswith(\"https://\"):\n                    logger.warning(\n                        \"Fetching distributed claims from an untrusted source: %s\",\n                        spec[\"endpoint\"],\n                    )\n                if \"access_token\" in spec:\n                    _uinfo = self.do_user_info_request(\n                        method=\"GET\",\n                        token=spec[\"access_token\"],\n                        userinfo_endpoint=spec[\"endpoint\"],\n                        verify=False,\n                    )\n                else:\n                    if callback:\n                        _uinfo = self.do_user_info_request(\n                            method=\"GET\",\n                            token=callback(spec[\"endpoint\"]),\n                            userinfo_endpoint=spec[\"endpoint\"],\n                            verify=False,\n                        )\n                    else:\n                        _uinfo = self.do_user_info_request(\n                            method=\"GET\",\n                            userinfo_endpoint=spec[\"endpoint\"],\n                            verify=False,\n                        )\n\n                claims = [\n                    value\n                    for value, src in userinfo[\"_claim_names\"].items()\n                    if src == csrc\n                ]\n\n                if set(claims) != set(list(_uinfo.keys())):\n                    logger.warning(\n                        \"Claims from claim source doesn't match what's in \"\n                        \"the userinfo\"\n                    )\n\n                for key, vals in _uinfo.items():\n                    userinfo[key] = vals\n\n        # Remove the `_claim_sources` and `_claim_names` from userinfo and better be safe than sorry\n        if \"_claim_sources\" in userinfo:\n            del userinfo[\"_claim_sources\"]\n        if \"_claim_names\" in userinfo:\n            del userinfo[\"_claim_names\"]\n        return userinfo\n\n    def verify_alg_support(self, alg, usage, other):\n        \"\"\"\n        Verify that the algorithm to be used are supported by the other side.\n\n        :param alg: The algorithm specification\n        :param usage: In which context the 'alg' will be used.\n            The following values are supported:\n            - userinfo\n            - id_token\n            - request_object\n            - token_endpoint_auth\n        :param other: The identifier for the other side\n        :return: True or False\n        \"\"\"\n        try:\n            _pcr = self.provider_info\n            supported = _pcr[\"%s_algs_supported\" % usage]\n        except KeyError:\n            try:\n                supported = getattr(self, \"%s_algs_supported\" % usage)\n            except AttributeError:\n                supported = None\n\n        if supported is None:\n            return True\n        else:\n            if alg in supported:\n                return True\n            else:\n                return False\n\n    def match_preferences(self, pcr=None, issuer=None):\n        \"\"\"\n        Match the clients preferences against what the provider can do.\n\n        :param pcr: Provider configuration response if available\n        :param issuer: The issuer identifier\n        \"\"\"\n        if not pcr:\n            pcr = self.provider_info\n\n        regreq = self.message_factory.get_request_type(\"registration_endpoint\")\n\n        for _pref, _prov in PREFERENCE2PROVIDER.items():\n            try:\n                vals = self.client_prefs[_pref]\n            except KeyError:\n                continue\n\n            try:\n                _pvals = pcr[_prov]\n            except KeyError:\n                try:\n                    self.behaviour[_pref] = PROVIDER_DEFAULT[_pref]\n                except KeyError:\n                    if isinstance(pcr.c_param[_prov][0], list):\n                        self.behaviour[_pref] = []\n                    else:\n                        self.behaviour[_pref] = None\n                continue\n\n            if isinstance(vals, str):\n                if vals in _pvals:\n                    self.behaviour[_pref] = vals\n            else:\n                vtyp = regreq.c_param[_pref]\n\n                if isinstance(vtyp[0], list):\n                    self.behaviour[_pref] = []\n                    for val in vals:\n                        if val in _pvals:\n                            self.behaviour[_pref].append(val)\n                else:\n                    for val in vals:\n                        if val in _pvals:\n                            self.behaviour[_pref] = val\n                            break\n\n            if _pref not in self.behaviour:\n                raise ConfigurationError(\"OP couldn't match preference:%s\" % _pref, pcr)\n\n        for key, val in self.client_prefs.items():\n            if key in self.behaviour:\n                continue\n\n            try:\n                vtyp = regreq.c_param[key]\n                if isinstance(vtyp[0], list):\n                    pass\n                elif isinstance(val, list) and not isinstance(val, str):\n                    val = val[0]\n            except KeyError:\n                pass\n            if key not in PREFERENCE2PROVIDER:\n                self.behaviour[key] = val\n\n    def store_registration_info(self, reginfo):\n        self.registration_response = reginfo\n        if \"token_endpoint_auth_method\" not in self.registration_response:\n            self.registration_response[\n                \"token_endpoint_auth_method\"  # nosec\n            ] = \"client_secret_basic\"\n        self.client_id = reginfo[\"client_id\"]\n        try:\n            self.client_secret = reginfo[\"client_secret\"]\n        except KeyError:  # Not required\n            pass\n        else:\n            try:\n                self.registration_expires = reginfo[\"client_secret_expires_at\"]\n            except KeyError:\n                pass\n        try:\n            self.registration_access_token = reginfo[\"registration_access_token\"]\n        except KeyError:\n            pass\n\n    def handle_registration_info(self, response):\n        err_msg = \"Got error response: {}\"\n        unk_msg = \"Unknown response: {}\"\n        if response.status_code in [200, 201]:\n            resp = self.message_factory.get_response_type(\n                \"registration_endpoint\"\n            )().deserialize(response.text, \"json\")\n            # Some implementations sends back a 200 with an error message inside\n            try:\n                resp.verify()\n            except oauth2.message.MissingRequiredAttribute as err:\n                logger.error(err)\n                raise RegistrationError(err)\n            except Exception:\n                resp = ErrorResponse().deserialize(response.text, \"json\")\n                if resp.verify():\n                    logger.error(err_msg.format(sanitize(resp.to_json())))\n                    if self.events:\n                        self.events.store(\"protocol response\", resp)\n                    raise RegistrationError(resp.to_dict())\n                else:  # Something else\n                    logger.error(unk_msg.format(sanitize(response.text)))\n                    raise RegistrationError(response.text)\n            else:\n                # got a proper registration response\n                self.store_response(resp, response.text)\n                self.store_registration_info(resp)\n        elif 400 <= response.status_code <= 499:\n            try:\n                resp = ErrorResponse().deserialize(response.text, \"json\")\n            except JSONDecodeError:\n                logger.error(unk_msg.format(sanitize(response.text)))\n                raise RegistrationError(response.text)\n\n            if resp.verify():\n                logger.error(err_msg.format(sanitize(resp.to_json())))\n                if self.events:\n                    self.events.store(\"protocol response\", resp)\n                raise RegistrationError(resp.to_dict())\n            else:  # Something else\n                logger.error(unk_msg.format(sanitize(response.text)))\n                raise RegistrationError(response.text)\n        else:\n            raise RegistrationError(response.text)\n\n        return resp\n\n    def registration_read(self, url=\"\", registration_access_token=None):\n        \"\"\"\n        Read the client registration info from the given url.\n\n        :raises RegistrationError: If an error happend\n        :return: RegistrationResponse\n        \"\"\"\n        if not url:\n            url = self.registration_response[\"registration_client_uri\"]\n\n        if not registration_access_token:\n            registration_access_token = self.registration_access_token\n\n        headers = {\"Authorization\": \"Bearer %s\" % registration_access_token}\n        rsp = self.http_request(url, \"GET\", headers=headers)\n\n        return self.handle_registration_info(rsp)\n\n    def generate_request_uris(self, request_dir):\n        \"\"\"\n        Need to generate a path that is unique for the OP combo.\n\n        :return: A list of uris\n        \"\"\"\n        m = hashlib.sha256()\n        m.update(as_bytes(self.provider_info[\"issuer\"]))\n        m.update(as_bytes(self.base_url))\n        return \"{}{}/{}\".format(self.base_url, request_dir, m.hexdigest())\n\n    def create_registration_request(self, **kwargs):\n        \"\"\"\n        Create a registration request.\n\n        :param kwargs: parameters to the registration request\n        :return:\n        \"\"\"\n        req = self.message_factory.get_request_type(\"registration_endpoint\")()\n\n        for prop in req.parameters():\n            try:\n                req[prop] = kwargs[prop]\n            except KeyError:\n                try:\n                    req[prop] = self.behaviour[prop]\n                except KeyError:\n                    pass\n\n        if \"post_logout_redirect_uris\" not in req:\n            try:\n                req[\"post_logout_redirect_uris\"] = self.post_logout_redirect_uris\n            except AttributeError:\n                pass\n\n        if \"redirect_uris\" not in req:\n            try:\n                req[\"redirect_uris\"] = self.redirect_uris\n            except AttributeError:\n                raise MissingRequiredAttribute(\"redirect_uris\", req)\n\n        try:\n            if self.provider_info[\"require_request_uri_registration\"] is True:\n                req[\"request_uris\"] = self.generate_request_uris(self.requests_dir)\n        except KeyError:\n            pass\n\n        if \"response_types\" in req:\n            req[\"grant_types\"] = response_types_to_grant_types(\n                req[\"response_types\"], **kwargs\n            )\n\n        return req\n\n    def register(self, url, registration_token=None, **kwargs):\n        \"\"\"\n        Register the client at an OP.\n\n        :param url: The OPs registration endpoint\n        :param registration_token: Initial Access Token for registration endpoint\n        :param kwargs: parameters to the registration request\n        :return:\n        \"\"\"\n        req = self.create_registration_request(**kwargs)\n\n        logger.debug(\"[registration_request]: kwargs:%s\" % (sanitize(kwargs),))\n\n        if self.events:\n            self.events.store(\"Protocol request\", req)\n\n        headers = {\"content-type\": \"application/json\"}\n        if registration_token is not None:\n            try:\n                token = jwt.JWT()\n                token.unpack(registration_token)\n            except BadSyntax:\n                # no JWT\n                registration_token = b64encode(registration_token.encode()).decode()\n            finally:\n                headers[\"Authorization\"] = \"Bearer \" + registration_token\n\n        rsp = self.http_request(url, \"POST\", data=req.to_json(), headers=headers)\n\n        return self.handle_registration_info(rsp)\n\n    def normalization(self, principal, idtype=\"mail\"):\n        if idtype == \"mail\":\n            (_, domain) = principal.split(\"@\")\n            subject = \"acct:%s\" % principal\n        elif idtype == \"url\":\n            p = urlparse(principal)\n            domain = p.netloc\n            subject = principal\n        else:\n            domain = \"\"\n            subject = principal\n\n        return subject, domain\n\n    def discover(self, principal, host=None):\n        return self.wf.discovery_query(principal, host=host)\n\n    def sign_enc_algs(self, typ):\n        resp = {}\n        for key, val in PARAMMAP.items():\n            try:\n                resp[key] = self.registration_response[val % typ]\n            except (TypeError, KeyError):\n                if key == \"sign\":\n                    resp[key] = DEF_SIGN_ALG[\"id_token\"]\n        return resp\n\n    def _verify_id_token(\n        self,\n        id_token,\n        nonce=\"\",\n        acr_values=None,\n        auth_time=0,\n        max_age=0,\n        response_type=\"\",\n    ):\n        \"\"\"\n        Verify IdToken.\n\n        If the JWT alg Header Parameter uses a MAC based algorithm such as\n        HS256, HS384, or HS512, the octets of the UTF-8 representation of the\n        client_secret corresponding to the client_id contained in the aud\n        (audience) Claim are used as the key to validate the signature. For MAC\n        based algorithms, the behavior is unspecified if the aud is\n        multi-valued or if an azp value is present that is different than the\n        aud value.\n\n        :param id_token: The ID Token tp check\n        :param nonce: The nonce specified in the authorization request\n        :param acr_values: Asked for acr values\n        :param auth_time: An auth_time claim\n        :param max_age: Max age of authentication\n        \"\"\"\n        if self.provider_info[\"issuer\"] != id_token[\"iss\"]:\n            raise OtherError(\"issuer != iss\")\n\n        if self.client_id not in id_token[\"aud\"]:\n            raise OtherError(\"not intended for me\")\n        if len(id_token[\"aud\"]) > 1:\n            if \"azp\" not in id_token or id_token[\"azp\"] != self.client_id:\n                raise OtherError(\"not intended for me\")\n\n        _now = time_util.utc_time_sans_frac()\n\n        if _now > id_token[\"exp\"]:\n            raise OtherError(\"Passed best before date\")\n\n        if response_type != [\"code\"] and id_token.jws_header[\"alg\"] == \"none\":\n            raise WrongSigningAlgorithm(\n                \"none is not allowed outside Authorization Flow.\"\n            )\n\n        if (\n            self.id_token_max_age\n            and _now > int(id_token[\"iat\"]) + self.id_token_max_age\n        ):\n            raise OtherError(\"I think this ID token is to old\")\n\n        if nonce and nonce != id_token[\"nonce\"]:\n            raise OtherError(\"nonce mismatch\")\n\n        if acr_values and id_token[\"acr\"] not in acr_values:\n            raise OtherError(\"acr mismatch\")\n\n        if max_age and _now > int(id_token[\"auth_time\"] + max_age):\n            raise AuthnToOld(\"To old authentication\")\n\n        if auth_time:\n            if not claims_match(id_token[\"auth_time\"], {\"auth_time\": auth_time}):\n                raise AuthnToOld(\"To old authentication\")\n\n    def verify_id_token(self, id_token, authn_req):\n        kwa = {}\n        try:\n            kwa[\"nonce\"] = authn_req[\"nonce\"]\n        except KeyError:\n            pass\n\n        for param in [\"acr_values\", \"max_age\", \"response_type\"]:\n            try:\n                kwa[param] = authn_req[param]\n            except KeyError:\n                pass\n\n        self._verify_id_token(id_token, **kwa)\n\n\nclass Server(oauth2.Server):\n    \"\"\"OIC Server class.\"\"\"\n\n    def __init__(\n        self,\n        verify_ssl: bool = None,\n        keyjar: KeyJar = None,\n        client_cert: Union[str, Tuple[str, str]] = None,\n        timeout: float = None,\n        message_factory: Type[MessageFactory] = OIDCMessageFactory,\n        settings: PyoidcSettings = None,\n    ):\n        \"\"\"Initialize the server.\"\"\"\n        self.settings = settings or OicServerSettings()\n        if verify_ssl is not None:\n            warnings.warn(\n                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.verify_ssl = verify_ssl\n        if client_cert is not None:\n            warnings.warn(\n                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.client_cert = client_cert\n        if timeout is not None:\n            warnings.warn(\n                \"`timeout` is deprecated, please use `settings` instead if you need to set a non-default value.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.settings.timeout = timeout\n\n        super().__init__(\n            keyjar=keyjar,\n            message_factory=message_factory,\n            settings=self.settings,\n        )\n\n    @staticmethod\n    def _parse_urlencoded(url=None, query=None):\n        if url:\n            parts = urlparse(url)\n            scheme, netloc, path, params, query, fragment = parts[:6]\n\n        return parse_qs(query)\n\n    def handle_request_uri(self, request_uri, verify=True, sender=\"\"):\n        \"\"\"\n        Handle request URI.\n\n        :param request_uri: URL pointing to where the signed request should be fetched from.\n        :param verify: Whether the signature on the request should be verified.\n        Don't use anything but the default unless you REALLY know what you're doing\n        :param sender: The issuer of the request JWT.\n        :return:\n        \"\"\"\n        # Do a HTTP get\n        logger.debug(\"Get request from request_uri: {}\".format(request_uri))\n        try:\n            http_req = self.http_request(request_uri)\n        except ConnectionError:\n            logger.error(\"Connection Error\")\n            return authz_error(\"invalid_request_uri\")\n\n        if not http_req:\n            logger.error(\"Nothing returned\")\n            return authz_error(\"invalid_request_uri\")\n        elif http_req.status_code >= 400:\n            logger.error(\"HTTP error {}:{}\".format(http_req.status_code, http_req.text))\n            raise AuthzError(\"invalid_request\")\n\n        # http_req.text is a signed JWT\n        try:\n            logger.debug(\"request txt: {}\".format(http_req.text))\n            req = self.parse_jwt_request(\n                txt=http_req.text, verify=verify, sender=sender\n            )\n        except Exception as err:\n            logger.error(\n                \"{}:{} encountered while parsing fetched request\".format(\n                    err.__class__, err\n                )\n            )\n            raise AuthzError(\"invalid_openid_request_object\")\n\n        logger.debug(\"Fetched request: {}\".format(req))\n        return req\n\n    def parse_authorization_request(\n        self, request=AuthorizationRequest, url=None, query=None, keys=None\n    ):\n        if url:\n            parts = urlparse(url)\n            scheme, netloc, path, params, query, fragment = parts[:6]\n\n        if isinstance(query, dict):\n            sformat = \"dict\"\n        else:\n            sformat = \"urlencoded\"\n\n        _req = self._parse_request(request, query, sformat, verify=False)\n\n        if self.events:\n            self.events.store(\"Request\", _req)\n\n        _req_req: Union[Message, Dict[str, Any]] = {}\n        try:\n            _request = _req[\"request\"]\n        except KeyError:\n            try:\n                _url = _req[\"request_uri\"]\n            except KeyError:\n                pass\n            else:\n                _req_req = self.handle_request_uri(\n                    _url, verify=False, sender=_req[\"client_id\"]\n                )\n        else:\n            if isinstance(_request, Message):\n                _req_req = _request\n            else:\n                try:\n                    _req_req = self.parse_jwt_request(\n                        request, txt=_request, verify=False\n                    )\n                except Exception:\n                    _req_req = self._parse_request(\n                        request, _request, \"urlencoded\", verify=False\n                    )\n                else:  # remove JWT attributes\n                    for attr in JasonWebToken.c_param:\n                        try:\n                            del _req_req[attr]\n                        except KeyError:\n                            pass\n\n        if isinstance(_req_req, Response):\n            return _req_req\n\n        if _req_req:\n            if self.events:\n                self.events.store(\"Signed Request\", _req_req)\n\n            for key, val in _req.items():\n                if key in [\"request\", \"request_uri\"]:\n                    continue\n                if key not in _req_req:\n                    _req_req[key] = val\n            _req = _req_req\n\n        if self.events:\n            self.events.store(\"Combined Request\", _req)\n\n        try:\n            _req.verify(keyjar=self.keyjar)\n        except Exception as err:\n            if self.events:\n                self.events.store(\"Exception\", err)\n            logger.error(err)\n            raise\n\n        return _req\n\n    def parse_jwt_request(\n        self,\n        request=AuthorizationRequest,\n        txt=\"\",\n        keyjar=None,\n        verify=True,\n        sender=\"\",\n        **kwargs,\n    ):\n        \"\"\"Overridden to use OIC Message type.\"\"\"\n        if \"keys\" in kwargs:\n            keyjar = kwargs[\"keys\"]\n            warnings.warn(\n                \"`keys` was renamed to `keyjar`, please update your code.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        return super().parse_jwt_request(\n            request=request, txt=txt, keyjar=keyjar, verify=verify, sender=sender\n        )\n\n    def parse_check_session_request(self, url=None, query=None):\n        param = self._parse_urlencoded(url, query)\n        assert \"id_token\" in param  # nosec, ignore the rest\n        return deser_id_token(self, param[\"id_token\"][0])\n\n    def parse_check_id_request(self, url=None, query=None):\n        param = self._parse_urlencoded(url, query)\n        assert \"access_token\" in param  # nosec, ignore the rest\n        return deser_id_token(self, param[\"access_token\"][0])\n\n    def _parse_request(self, request_cls, data, sformat, client_id=None, verify=True):\n        if sformat == \"json\":\n            request = request_cls().from_json(data)\n        elif sformat == \"jwt\":\n            request = request_cls().from_jwt(data, keyjar=self.keyjar, sender=client_id)\n        elif sformat == \"urlencoded\":\n            if \"?\" in data:\n                parts = urlparse(data)\n                scheme, netloc, path, params, query, fragment = parts[:6]\n            else:\n                query = data\n            request = request_cls().from_urlencoded(query)\n        elif sformat == \"dict\":\n            request = request_cls(**data)\n        else:\n            raise ParseError(\n                \"Unknown package format: '{}'\".format(sformat), request_cls\n            )\n\n        # get the verification keys\n        if client_id:\n            keys = self.keyjar.verify_keys(client_id)\n            sender = client_id\n        else:\n            try:\n                keys = self.keyjar.verify_keys(request[\"client_id\"])\n                sender = request[\"client_id\"]\n            except KeyError:\n                keys = None\n                sender = \"\"\n\n        logger.debug(\"Found {} verify keys\".format(len(keys or \"\")))\n        if verify:\n            request.verify(key=keys, keyjar=self.keyjar, sender=sender)\n        return request\n\n    def parse_open_id_request(self, data, sformat=\"urlencoded\", client_id=None):\n        return self._parse_request(OpenIDRequest, data, sformat, client_id)\n\n    def parse_user_info_request(self, data, sformat=\"urlencoded\"):\n        return self._parse_request(UserInfoRequest, data, sformat)\n\n    def parse_userinfo_request(self, data, sformat=\"urlencoded\"):\n        return self._parse_request(UserInfoRequest, data, sformat)\n\n    def parse_refresh_session_request(self, url=None, query=None):\n        if url:\n            parts = urlparse(url)\n            query = parts.query\n        return RefreshSessionRequest().from_urlencoded(query)\n\n    def parse_registration_request(self, data, sformat=\"urlencoded\"):\n        return self._parse_request(RegistrationRequest, data, sformat)\n\n    def parse_end_session_request(self, query, sformat=\"urlencoded\"):\n        esr = self._parse_request(EndSessionRequest, query, sformat)\n        # if there is a id_token in there it is as a string\n        esr[\"id_token\"] = deser_id_token(self, esr[\"id_token\"])\n        return esr\n\n    @staticmethod\n    def update_claims(session, where, about, old_claims=None):\n        \"\"\"\n        Update claims dictionary.\n\n        :param session:\n        :param where: Which request\n        :param about: userinfo or id_token\n        :param old_claims:\n        :return: claims or None\n        \"\"\"\n        if old_claims is None:\n            old_claims = {}\n\n        req = None\n        if where == \"oidreq\":\n            try:\n                req = OpenIDRequest().deserialize(session[where], \"json\")\n            except KeyError:\n                pass\n        else:  # where == \"authzreq\"\n            try:\n                req = AuthorizationRequest().deserialize(session[where], \"json\")\n            except KeyError:\n                pass\n\n        if req:\n            logger.debug(\"%s: %s\" % (where, sanitize(req.to_dict())))\n            try:\n                _claims = req[\"claims\"][about]\n                if _claims:\n                    # update with old claims, do not overwrite\n                    for key, val in old_claims.items():\n                        if key not in _claims:\n                            _claims[key] = val\n                    return _claims\n            except KeyError:\n                pass\n\n        return old_claims\n\n    def id_token_claims(self, session):\n        \"\"\"\n        Pick the IdToken claims from the request.\n\n        :param session: Session information\n        :return: The IdToken claims\n        \"\"\"\n        itc: Dict[str, str] = {}\n        itc = self.update_claims(session, \"authzreq\", \"id_token\", itc)\n        itc = self.update_claims(session, \"oidreq\", \"id_token\", itc)\n        return itc\n\n    def make_id_token(\n        self,\n        session,\n        loa=\"2\",\n        issuer=\"\",\n        alg=\"RS256\",\n        code=None,\n        access_token=None,\n        user_info=None,\n        auth_time=0,\n        exp=None,\n        extra_claims=None,\n    ):\n        \"\"\"\n        Create ID Token.\n\n        :param session: Session information\n        :param loa: Level of Assurance/Authentication context\n        :param issuer: My identifier\n        :param alg: Which signing algorithm to use for the IdToken\n        :param code: Access grant\n        :param access_token: Access Token\n        :param user_info: If user info are to be part of the IdToken\n        :return: IDToken instance\n        \"\"\"\n        # defaults\n        if exp is None:\n            inawhile = {\"days\": 1}\n        else:\n            inawhile = exp\n        # Handle the idtoken_claims\n        extra = {}\n        itc = self.id_token_claims(session)\n        if itc.keys():\n            try:\n                inawhile = {\"seconds\": itc[\"max_age\"]}\n            except KeyError:\n                pass\n            for key, val in itc.items():\n                if key == \"auth_time\":\n                    extra[\"auth_time\"] = auth_time\n                elif key == \"acr\":\n                    extra[\"acr\"] = verify_acr_level(val, loa)\n        else:\n            if auth_time:\n                extra[\"auth_time\"] = auth_time\n            if loa:\n                extra[\"acr\"] = loa\n\n        if not user_info:\n            _args: Dict[str, str] = {}\n        else:\n            try:\n                _args = user_info.to_dict()\n            except AttributeError:\n                _args = user_info\n\n        # Make sure that there are no name clashes\n        for key in [\"iss\", \"sub\", \"aud\", \"exp\", \"acr\", \"nonce\", \"auth_time\"]:\n            try:\n                del _args[key]\n            except KeyError:\n                pass\n\n        halg = \"HS%s\" % alg[-3:]\n\n        if extra_claims is not None:\n            _args.update(extra_claims)\n        if code:\n            _args[\"c_hash\"] = jws.left_hash(code.encode(\"utf-8\"), halg)\n        if access_token:\n            _args[\"at_hash\"] = jws.left_hash(access_token.encode(\"utf-8\"), halg)\n\n        idt = IdToken(\n            iss=issuer,\n            sub=session[\"sub\"],\n            aud=session[\"client_id\"],\n            exp=time_util.epoch_in_a_while(**inawhile),\n            acr=loa,\n            iat=time_util.utc_time_sans_frac(),\n            **_args,\n        )\n\n        for key, val in extra.items():\n            idt[key] = val\n\n        if \"nonce\" in session:\n            idt[\"nonce\"] = session[\"nonce\"]\n\n        return idt\n\n\ndef scope2claims(scopes, extra_scope_dict=None):\n    res: Dict[str, None] = {}\n    # Construct the scope translation map\n    trans_map: Dict[str, Any] = SCOPE2CLAIMS.copy()\n    if extra_scope_dict is not None:\n        trans_map.update(extra_scope_dict)\n    for scope in scopes:\n        try:\n            claims = dict([(name, None) for name in trans_map[scope]])\n            res.update(claims)\n        except KeyError:\n            continue\n    return res\n", "import logging\nimport os.path\nimport warnings\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n\nfrom oic import rndstr\nfrom oic.exception import AuthzError\nfrom oic.exception import MessageException\nfrom oic.exception import NotForMe\nfrom oic.exception import PyoidcError\nfrom oic.oauth2 import Grant\nfrom oic.oauth2.consumer import TokenError\nfrom oic.oauth2.consumer import UnknownState\nfrom oic.oauth2.consumer import stateID\nfrom oic.oauth2.message import ErrorResponse\nfrom oic.oic import ENDPOINTS\nfrom oic.oic import Client\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import BackChannelLogoutRequest\nfrom oic.oic.message import Claims\nfrom oic.oic.message import ClaimsRequest\nfrom oic.oic.message import IdToken\nfrom oic.utils import http_util\nfrom oic.utils.sanitize import sanitize\nfrom oic.utils.sdb import DictSessionBackend\nfrom oic.utils.sdb import SessionBackend\nfrom oic.utils.sdb import session_extended_get\nfrom oic.utils.sdb import session_get\nfrom oic.utils.sdb import session_update\n\n__author__ = \"rohe0002\"\n\nlogger = logging.getLogger(__name__)\n\n\ndef factory(kaka, sdb, config):\n    \"\"\"\n    Return the right Consumer instance dependent on what's in the cookie.\n\n    :param kaka: The cookie\n    :param sdb: The session database\n    :param config: The common Consumer configuration\n    :return: Consumer instance or None\n    \"\"\"\n    part = http_util.cookie_parts(config[\"name\"], kaka)\n    if part is None:\n        return None\n\n    cons = Consumer(sdb, config)\n    cons.restore(part[0])\n    http_util.parse_cookie(config[\"name\"], cons.seed, kaka)\n    return cons\n\n\ndef build_userinfo_claims(claims, sformat=\"signed\", locale=\"us-en\"):\n    \"\"\"\n    Create userinfo request based on claims.\n\n    config example::\n\n        \"userinfo\":{\n            \"name\": {\"essential\": true},\n            \"nickname\": null,\n            \"email\": {\"essential\": true},\n            \"email_verified\": {\"essential\": true},\n            \"picture\": null\n        }\n    \"\"\"\n    return Claims(format=sformat, **claims)\n\n\ndef clean_response(aresp):\n    \"\"\"\n    Create a new instance with only the standard attributes.\n\n    :param aresp: The original AccessTokenResponse\n    :return: An AccessTokenResponse instance\n    \"\"\"\n    atr = AccessTokenResponse()\n    for prop in atr.parameters():\n        try:\n            atr[prop] = aresp[prop]\n        except KeyError:\n            pass\n\n    return atr\n\n\nIGNORE = [\n    \"request2endpoint\",\n    \"response2error\",\n    \"grant_class\",\n    \"token_class\",\n    \"sdb\",\n    \"wf\",\n    \"events\",\n    \"message_factory\",\n]\n\nCONSUMER_PREF_ARGS = [\n    \"token_endpoint_auth_method\",\n    \"subject_type\",\n    \"require_signed_request_object\",\n    \"userinfo_signed_response_algs\",\n    \"userinfo_encrypted_response_alg\",\n    \"userinfo_encrypted_response_enc\",\n    \"userinfo_encrypted_response_int\",\n    \"id_token_signed_response_algs\",\n    \"id_token_encrypted_response_alg\",\n    \"id_token_encrypted_response_enc\",\n    \"id_token_encrypted_response_int\",\n    \"request_object_signing_alg\",\n    \"request_object_encryption_alg\",\n    \"request_object_encryption_enc\",\n    \"default_max_age\",\n    \"require_auth_time\",\n    \"default_acr_values\",\n]\n\n\nclass Consumer(Client):\n    \"\"\"An OpenID Connect consumer implementation.\"\"\"\n\n    def __init__(\n        self,\n        session_db,\n        consumer_config,\n        client_config=None,\n        server_info=None,\n        debug=False,\n        client_prefs=None,\n        sso_db=None,\n    ):\n        \"\"\"\n        Initialize a Consumer instance.\n\n        :param session_db: Where info are kept about sessions\n        :param config: Configuration of the consumer\n        :param client_config: Client configuration\n        :param server_info: Information about the server\n        :param client_prefs: Run time preferences, which are chosen depends\n        on what the server can do.\n        \"\"\"\n        if client_config is None:\n            client_config = {}\n\n        Client.__init__(self, **client_config)\n\n        self.consumer_config = consumer_config\n        if consumer_config:\n            try:\n                self.debug = consumer_config[\"debug\"]\n            except KeyError:\n                self.debug = 0\n\n        if server_info:\n            for endpoint in ENDPOINTS:\n                try:\n                    setattr(self, endpoint, server_info[endpoint])\n                except KeyError:\n                    setattr(self, endpoint, \"\")\n\n        if not isinstance(session_db, SessionBackend):\n            warnings.warn(\n                \"Please use `SessionBackend` to ensure proper API for the database.\",\n                DeprecationWarning,\n            )\n        self.sdb = session_db\n\n        if sso_db is not None:\n            if not isinstance(sso_db, SessionBackend):\n                warnings.warn(\n                    \"Please use `SessionBackend` to ensure proper API for the database.\",\n                    DeprecationWarning,\n                )\n            self.sso_db: SessionBackend = sso_db\n        else:\n            self.sso_db = DictSessionBackend()\n\n        self.debug = debug\n        self.seed = \"\"\n        self.nonce = \"\"\n        self.request_filename = \"\"\n        self.request_uri = \"\"\n        self.user_info = None\n        self.registration_expires_at = 0\n        self.secret_type = \"Bearer\"\n\n    def update(self, sid):\n        \"\"\"\n        Update the instance variables from something stored in the session database.\n\n        Will not overwrite something that's already there.\n        Except for the grant dictionary !!\n\n        :param sid: Session identifier\n        \"\"\"\n        for key, val in self.sdb[sid].items():\n            try:\n                _val = getattr(self, key)\n            except AttributeError:\n                continue\n\n            if not _val and val:\n                setattr(self, key, val)\n            elif key == \"grant\" and val:\n                # val is a Grant instance\n                val.update(_val)\n                setattr(self, key, val)\n\n    def restore(self, sid):\n        \"\"\"\n        Restore the instance variables from something stored in the session database.\n\n        :param sid: Session identifier\n        \"\"\"\n        for key, val in self.sdb[sid].items():\n            setattr(self, key, val)\n\n    def dictionary(self):\n        return dict([(k, v) for k, v in self.__dict__.items() if k not in IGNORE])\n\n    def _backup(self, sid):\n        \"\"\"\n        Store instance variable values in the session store under a session identifier.\n\n        :param sid: Session identifier\n        \"\"\"\n        self.sdb[sid] = self.dictionary()\n\n    def begin(self, scope=\"\", response_type=\"\", use_nonce=False, path=\"\", **kwargs):\n        \"\"\"\n        Begin the OIDC flow.\n\n        :param scope: Defines which user info claims is wanted\n        :param response_type: Controls the parameters returned in the response from the Authorization Endpoint\n        :param use_nonce: If not implicit flow nonce is optional. This defines if it should be used anyway.\n        :param path: The path part of the redirect URL\n        :return: A 2-tuple, session identifier and URL to which the user should be redirected\n        \"\"\"\n        _log_info = logger.info\n\n        if self.debug:\n            _log_info(\"- begin -\")\n\n        _page = self.consumer_config[\"authz_page\"]\n        if not path.endswith(\"/\"):\n            if _page.startswith(\"/\"):\n                self.redirect_uris = [path + _page]\n            else:\n                self.redirect_uris = [\"%s/%s\" % (path, _page)]\n        else:\n            if _page.startswith(\"/\"):\n                self.redirect_uris = [path + _page[1:]]\n            else:\n                self.redirect_uris = [\"%s/%s\" % (path, _page)]\n\n        # Put myself in the dictionary of sessions, keyed on session-id\n        if not self.seed:\n            self.seed = rndstr()\n\n        if not scope:\n            scope = self.consumer_config[\"scope\"]\n        if not response_type:\n            response_type = self.consumer_config[\"response_type\"]\n\n        sid = stateID(path, self.seed)\n        self.grant[sid] = Grant(seed=self.seed)\n\n        self._backup(sid)\n        self.sdb[\"seed:%s\" % self.seed] = sid\n        self.sso_db[sid] = {}\n\n        args = {\n            \"client_id\": self.client_id,\n            \"state\": sid,\n            \"response_type\": response_type,\n            \"scope\": scope,\n        }\n\n        # nonce is REQUIRED in implicit flow,\n        # OPTIONAL on code flow.\n        if \"token\" in response_type or use_nonce:\n            args[\"nonce\"] = rndstr(12)\n            self.state2nonce[sid] = args[\"nonce\"]\n\n        if \"max_age\" in self.consumer_config:\n            args[\"max_age\"] = self.consumer_config[\"max_age\"]\n\n        _claims = None\n        if \"user_info\" in self.consumer_config:\n            _claims = ClaimsRequest(\n                userinfo=Claims(**self.consumer_config[\"user_info\"])\n            )\n        if \"id_token\" in self.consumer_config:\n            if _claims:\n                _claims[\"id_token\"] = Claims(**self.consumer_config[\"id_token\"])\n            else:\n                _claims = ClaimsRequest(\n                    id_token=Claims(**self.consumer_config[\"id_token\"])\n                )\n\n        if _claims:\n            args[\"claims\"] = _claims\n\n        if \"request_method\" in self.consumer_config:\n            areq = self.construct_AuthorizationRequest(\n                request_args=args, extra_args=None, request_param=\"request\"\n            )\n\n            if self.consumer_config[\"request_method\"] == \"file\":\n                id_request = areq[\"request\"]\n                del areq[\"request\"]\n                _filedir = self.consumer_config[\"temp_dir\"]\n                _webpath = self.consumer_config[\"temp_path\"]\n                _name = rndstr(10)\n                filename = os.path.join(_filedir, _name)\n                while os.path.exists(filename):\n                    _name = rndstr(10)\n                    filename = os.path.join(_filedir, _name)\n                fid = open(filename, mode=\"w\")\n                fid.write(id_request)\n                fid.close()\n                _webname = \"%s%s/%s\" % (path, _webpath, _name)\n                areq[\"request_uri\"] = _webname\n                self.request_uri = _webname\n                self._backup(sid)\n        else:\n            if \"userinfo_claims\" in args:  # can only be carried in an IDRequest\n                raise PyoidcError(\"Need a request method\")\n\n            areq = self.construct_AuthorizationRequest(\n                AuthorizationRequest, request_args=args\n            )\n\n        location = areq.request(self.authorization_endpoint)\n\n        if self.debug:\n            _log_info(\"Redirecting to: %s\" % location)\n\n        self.authz_req[areq[\"state\"]] = areq\n        return sid, location\n\n    def _parse_authz(self, query=\"\", **kwargs):\n        _log_info = logger.info\n        # Might be an error response\n        _log_info(\"Expect Authorization Response\")\n        aresp = self.parse_response(\n            AuthorizationResponse, info=query, sformat=\"urlencoded\", keyjar=self.keyjar\n        )\n        if isinstance(aresp, ErrorResponse):\n            _log_info(\"ErrorResponse: %s\" % sanitize(aresp))\n            raise AuthzError(aresp.get(\"error\"), aresp)\n\n        _log_info(\"Aresp: %s\" % sanitize(aresp))\n\n        _state = aresp[\"state\"]\n        try:\n            self.update(_state)\n        except KeyError:\n            raise UnknownState(_state, aresp)\n\n        self.redirect_uris = [self.sdb[_state][\"redirect_uris\"]]\n        return aresp, _state\n\n    def parse_authz(\n        self, query=\"\", **kwargs\n    ) -> Union[\n        http_util.BadRequest,\n        Tuple[\n            Optional[AuthorizationResponse],\n            Optional[AccessTokenResponse],\n            Optional[IdToken],\n        ],\n    ]:\n        \"\"\"\n        Parse authorization response from server.\n\n        Couple of cases\n        [\"code\"]\n        [\"code\", \"token\"]\n        [\"code\", \"id_token\", \"token\"]\n        [\"id_token\"]\n        [\"id_token\", \"token\"]\n        [\"token\"]\n        \"\"\"\n        _log_info = logger.info\n        logger.debug(\"- authorization -\")\n\n        # FIXME: This shouldn't be here... We should rather raise a sepcific Client error\n        # That would simplify the return value of this function\n        # and drop bunch of assertions from tests added in this commit.\n        if not query:\n            return http_util.BadRequest(\"Missing query\")\n\n        _log_info(\"response: %s\" % sanitize(query))\n\n        if \"algs\" not in kwargs:\n            kwargs[\"algs\"] = self.sign_enc_algs(\"id_token\")\n        if \"code\" in self.consumer_config[\"response_type\"]:\n            aresp, _state = self._parse_authz(query, **kwargs)\n\n            # May have token and id_token information too\n            if \"access_token\" in aresp:\n                atr = clean_response(aresp)\n                self.access_token = atr\n                # update the grant object\n                self.get_grant(state=_state).add_token(atr)\n            else:\n                atr = None\n\n            self._backup(_state)\n\n            try:\n                idt = aresp[\"id_token\"]\n            except KeyError:\n                idt = None\n            else:\n                try:\n                    session_update(self.sdb, idt[\"sid\"], \"smid\", _state)\n                except KeyError:\n                    pass\n\n        elif \"token\" in self.consumer_config[\"response_type\"]:  # implicit flow\n            _log_info(\"Expect Access Token Response\")\n            aresp = None\n            _state = None\n            atr = self.parse_response(\n                AccessTokenResponse,\n                info=query,\n                sformat=\"urlencoded\",\n                keyjar=self.keyjar,\n                **kwargs,\n            )\n            if isinstance(atr, ErrorResponse):\n                raise TokenError(atr.get(\"error\"), atr)\n\n            idt = atr.get(\"id_token\")\n\n        else:  # only id_token\n            aresp, _state = self._parse_authz(query, **kwargs)\n\n            try:\n                idt = aresp[\"id_token\"]\n            except KeyError:\n                idt = None\n            else:\n                try:\n                    session_update(self.sso_db, _state, \"smid\", idt[\"sid\"])\n                except KeyError:\n                    pass\n            # Null the aresp as only id_token should be returned\n            aresp = atr = None\n\n        # Verify the IdToken if it was present\n        if idt is not None:\n            self.verify_id_token(idt, self.authz_req.get(_state or atr[\"state\"]))\n        return aresp, atr, idt\n\n    def complete(self, state):\n        \"\"\"\n        Do the access token request, the last step in a code flow.\n\n        If Implicit flow was used then this method is never used.\n        \"\"\"\n        args = {\"redirect_uri\": self.redirect_uris[0]}\n        if \"password\" in self.consumer_config and self.consumer_config[\"password\"]:\n            logger.info(\"basic auth\")\n            http_args = {\"password\": self.consumer_config[\"password\"]}\n        elif self.client_secret:\n            logger.info(\"request_body auth\")\n            http_args = {}\n            args.update(\n                {\n                    \"client_secret\": self.client_secret,\n                    \"client_id\": self.client_id,\n                    \"secret_type\": self.secret_type,\n                }\n            )\n        else:\n            raise PyoidcError(\"Nothing to authenticate with\")\n\n        resp = self.do_access_token_request(\n            state=state, request_args=args, http_args=http_args\n        )\n\n        logger.info(\"Access Token Response: %s\" % sanitize(resp))\n\n        if resp.type() == \"ErrorResponse\":\n            raise TokenError(resp.error, resp)\n\n        self._backup(state)\n\n        return resp\n\n    def refresh_token(self):\n        pass\n\n    def get_user_info(self, state):\n        uinfo = self.do_user_info_request(state=state, schema=\"openid\")\n\n        if uinfo.type() == \"ErrorResponse\":\n            raise TokenError(uinfo.error, uinfo)\n\n        self.user_info = uinfo\n        self._backup(state)\n\n        return uinfo\n\n    def refresh_session(self):\n        pass\n\n    def check_session(self):\n        \"\"\"\n        Check session endpoint.\n\n        With python you could use PyQuery to get the onclick attribute of each\n        anchor tag, parse that with a regular expression to get the placeId,\n        build the /places/duplicates.jsp?inPID= URL yourself, use requests to\n        load the content at that URL, then PyQuery again on the content to get\n        the data you need.\n\n        for iframe in mosoup(\"iframe\"):\n            mosoup.iframe.extract()\n\n        It accepts postMessage requests from the relevant RP iframe and uses\n        postMessage to post back the login status of the End-User at the OP.\n\n        :return:\n        \"\"\"\n        pass\n\n    def end_session(self):\n        pass\n\n    # LOGOUT related\n\n    def backchannel_logout(\n        self, request: Optional[str] = None, request_args: Optional[Dict] = None\n    ) -> str:\n        \"\"\"\n        Receives a back channel logout request.\n\n        :param request: A urlencoded request\n        :param request_args: The request as a dictionary\n        :return: A Session Identifier\n        \"\"\"\n        if request:\n            req = BackChannelLogoutRequest().from_urlencoded(request)\n        elif request_args is not None:\n            req = BackChannelLogoutRequest(**request_args)\n        else:\n            raise ValueError(\"Missing request specification\")\n\n        kwargs = {\"aud\": self.client_id, \"iss\": self.issuer, \"keyjar\": self.keyjar}\n\n        try:\n            req.verify(**kwargs)\n        except (MessageException, ValueError, NotForMe) as err:\n            raise MessageException(\"Bogus logout request: {}\".format(err))\n\n        # Find the subject through 'sid' or 'sub'\n\n        try:\n            sub = req[\"logout_token\"][\"sub\"]\n        except KeyError:\n            # verify has guaranteed that there will be a sid if sub is missing\n            sm_id = req[\"logout_token\"][\"sid\"]\n            _sid = session_get(self.sso_db, \"smid\", sm_id)\n        else:\n            _sid = session_extended_get(\n                self.sso_db, sub, \"issuer\", req[\"logout_token\"][\"iss\"]\n            )\n\n        return _sid\n", "import inspect\nimport json\nimport logging\nimport sys\nimport time\nimport warnings\nfrom typing import Dict\nfrom typing import List\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlparse\n\nfrom jwkest import jws\nfrom jwkest.jwe import JWEException\nfrom jwkest.jwe import factory as JWE_factory\nfrom jwkest.jwt import JWT\n\nfrom oic.exception import InvalidRequest\nfrom oic.exception import IssuerMismatch\nfrom oic.exception import MessageException\nfrom oic.exception import NotForMe\nfrom oic.exception import PyoidcError\nfrom oic.oauth2 import message\nfrom oic.oauth2.exception import VerificationError\nfrom oic.oauth2.message import OPTIONAL_LIST_OF_SP_SEP_STRINGS\nfrom oic.oauth2.message import OPTIONAL_LIST_OF_STRINGS\nfrom oic.oauth2.message import REQUIRED_LIST_OF_SP_SEP_STRINGS\nfrom oic.oauth2.message import REQUIRED_LIST_OF_STRINGS\nfrom oic.oauth2.message import SINGLE_OPTIONAL_INT\nfrom oic.oauth2.message import SINGLE_OPTIONAL_JSON\nfrom oic.oauth2.message import SINGLE_OPTIONAL_STRING\nfrom oic.oauth2.message import SINGLE_REQUIRED_STRING\nfrom oic.oauth2.message import Message\nfrom oic.oauth2.message import MessageFactory\nfrom oic.oauth2.message import MessageTuple\nfrom oic.oauth2.message import MissingRequiredAttribute\nfrom oic.oauth2.message import MissingRequiredValue\nfrom oic.oauth2.message import NotAllowedValue\nfrom oic.oauth2.message import ParamDefinition\nfrom oic.oauth2.message import SchemeError\nfrom oic.utils import time_util\nfrom oic.utils.time_util import utc_time_sans_frac\n\n__author__ = \"rohe0002\"\n\nlogger = logging.getLogger(__name__)\n\nNONCE_STORAGE_TIME = 4 * 3600\n\n\nclass AtHashError(VerificationError):\n    pass\n\n\nclass CHashError(VerificationError):\n    pass\n\n\nclass EXPError(VerificationError):\n    pass\n\n\nclass IATError(VerificationError):\n    pass\n\n\ndef json_ser(val, sformat=None, lev=0):\n    return json.dumps(val)\n\n\ndef json_deser(val, sformat=None, lev=0):\n    return json.loads(val)\n\n\ndef json_conv(val, sformat=None, lev=0):\n    if isinstance(val, dict):\n        for key, _val in val.items():\n            if _val is None:\n                val[key] = \"none\"\n            elif _val is True:\n                val[key] = \"true\"\n            elif _val is False:\n                val[key] = \"false\"\n\n    return val\n\n\ndef json_rest(val, sformat=None, lev=0):\n    if isinstance(val, dict):\n        for key, _val in val.items():\n            if _val == \"none\":\n                val[key] = None\n            elif _val == \"true\":\n                val[key] = True\n            elif _val == \"false\":\n                val[key] = False\n\n    return val\n\n\n# value type, required, serializer, deserializer, null value allowed\nSINGLE_OPTIONAL_BOOLEAN = ParamDefinition(bool, False, None, None, False)\nSINGLE_OPTIONAL_JSON_WN = ParamDefinition(dict, False, json_ser, json_deser, True)\nSINGLE_OPTIONAL_JSON_CONV = ParamDefinition(dict, False, json_conv, json_rest, True)\nSINGLE_REQUIRED_INT = ParamDefinition(int, True, None, None, False)\n\n\ndef idtoken_deser(val, sformat=\"urlencoded\"):\n    # id_token are always serialized as a JWT\n    return IdToken().deserialize(val, \"jwt\")\n\n\ndef address_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n        elif sformat == \"dict\":\n            sformat = \"json\"\n    return AddressClaim().deserialize(val, sformat)\n\n\ndef claims_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return Claims().deserialize(val, sformat)\n\n\ndef message_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return Message().deserialize(val, sformat)\n\n\ndef msg_ser(inst, sformat, lev=0):\n    if sformat in [\"urlencoded\", \"json\"]:\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        else:\n            res = inst\n    elif sformat == \"dict\":\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        elif isinstance(inst, dict):\n            res = inst\n        elif isinstance(inst, str):  # Iff ID Token\n            res = inst\n        else:\n            raise MessageException(\"Wrong type: %s\" % type(inst))\n    else:\n        raise PyoidcError(\"Unknown sformat\", inst)\n\n    return res\n\n\ndef msg_ser_json(inst, sformat=\"json\", lev=0):\n    # sformat = \"json\" always except when dict\n    if lev:\n        sformat = \"dict\"\n\n    if sformat == \"dict\":\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        elif isinstance(inst, dict):\n            res = inst\n        else:\n            raise MessageException(\"Wrong type: %s\" % type(inst))\n    else:\n        sformat = \"json\"\n        if isinstance(inst, Message):\n            res = inst.serialize(sformat, lev)\n        else:\n            res = inst\n\n    return res\n\n\ndef msg_list_ser(insts, sformat, lev=0):\n    return [msg_ser(inst, sformat, lev) for inst in insts]\n\n\ndef claims_ser(val, sformat=\"urlencoded\", lev=0):\n    # everything in c_extension\n    if isinstance(val, str):\n        item = val\n    elif isinstance(val, list):\n        item = val[0]\n    else:\n        item = val\n\n    if isinstance(item, Message):\n        return item.serialize(method=sformat, lev=lev + 1)\n\n    if sformat == \"urlencoded\":\n        assert isinstance(  # nosec\n            item, dict\n        )  # We cannot urlencode anything else than Mapping\n        res = urlencode(item)\n    elif sformat == \"json\":\n        if lev:\n            res = item\n        else:\n            res = json.dumps(item)\n    elif sformat == \"dict\":\n        if isinstance(item, dict):\n            res = item\n        else:\n            raise MessageException(\"Wrong type: %s\" % type(item))\n    else:\n        raise PyoidcError(\"Unknown sformat: %s\" % sformat, val)\n\n    return res\n\n\ndef registration_request_deser(val, sformat=\"urlencoded\"):\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return RegistrationRequest().deserialize(val, sformat)\n\n\ndef claims_request_deser(val, sformat=\"json\"):\n    # never 'urlencoded'\n    if sformat == \"urlencoded\":\n        sformat = \"json\"\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return ClaimsRequest().deserialize(val, sformat)\n\n\nOPTIONAL_ADDRESS = ParamDefinition(Message, False, msg_ser, address_deser, False)\nOPTIONAL_LOGICAL = ParamDefinition(bool, False, None, None, False)\nOPTIONAL_MULTIPLE_Claims = ParamDefinition(\n    Message, False, claims_ser, claims_deser, False\n)\n\nSINGLE_OPTIONAL_IDTOKEN = ParamDefinition(str, False, msg_ser, None, False)\n\nSINGLE_OPTIONAL_REGISTRATION_REQUEST = ParamDefinition(\n    Message, False, msg_ser, registration_request_deser, False\n)\nSINGLE_OPTIONAL_CLAIMSREQ = ParamDefinition(\n    Message, False, msg_ser_json, claims_request_deser, False\n)\n\nOPTIONAL_MESSAGE = ParamDefinition(Message, False, msg_ser, message_deser, False)\nREQUIRED_MESSAGE = ParamDefinition(Message, True, msg_ser, message_deser, False)\n\n# ----------------------------------------------------------------------------\n\n\nSCOPE_CHARSET = []\nfor char in [\"\\x21\", (\"\\x23\", \"\\x5b\"), (\"\\x5d\", \"\\x7E\")]:\n    if isinstance(char, tuple):\n        c = char[0]\n        while c <= char[1]:\n            SCOPE_CHARSET.append(c)\n            c = chr(ord(c) + 1)\n    else:\n        SCOPE_CHARSET.append(set)\n\n\ndef check_char_set(string, allowed):\n    for c in string:\n        if c not in allowed:\n            raise NotAllowedValue(\"'%c' not in the allowed character set\" % c)\n\n\nTOKEN_VERIFY_ARGS = [\"key\", \"keyjar\", \"algs\", \"sender\"]\n\n\ndef verify_id_token(instance, check_hash=False, **kwargs):\n    # Try to decode the JWT, checks the signature\n    args = {}\n    for arg in TOKEN_VERIFY_ARGS:\n        try:\n            args[arg] = kwargs[arg]\n        except KeyError:\n            pass\n\n    _jws = str(instance[\"id_token\"])\n\n    # It can be encrypted, so try to decrypt first\n    _jwe = JWE_factory(_jws)\n    if _jwe is not None:\n        try:\n            _jws = _jwe.decrypt(keys=kwargs[\"keyjar\"].get_decrypt_key())\n        except JWEException as err:\n            raise VerificationError(\"Could not decrypt id_token\", err)\n    _packer = JWT()\n    _body = _packer.unpack(_jws).payload()\n\n    if \"keyjar\" in kwargs:\n        try:\n            if _body[\"iss\"] not in kwargs[\"keyjar\"]:\n                raise ValueError(\"Unknown issuer\")\n        except KeyError:\n            raise MissingRequiredAttribute(\"iss\")\n\n    if _jwe is not None:\n        # Use the original encrypted token to set correct headers\n        idt = IdToken().from_jwt(str(instance[\"id_token\"]), **args)\n    else:\n        idt = IdToken().from_jwt(_jws, **args)\n    if not idt.verify(**kwargs):\n        raise VerificationError(\"Could not verify id_token\", idt)\n\n    if check_hash:\n        _alg = idt.jws_header[\"alg\"]\n        if _alg != \"none\":\n            hfunc = \"HS\" + _alg[-3:]\n        else:\n            # This is allowed only for `code` and it needs to be checked by a Client\n            hfunc = None\n\n        if \"access_token\" in instance and hfunc is not None:\n            if \"at_hash\" not in idt:\n                raise MissingRequiredAttribute(\"Missing at_hash property\", idt)\n            if idt[\"at_hash\"] != jws.left_hash(instance[\"access_token\"], hfunc):\n                raise AtHashError(\"Failed to verify access_token hash\", idt)\n\n        if \"code\" in instance and hfunc is not None:\n            if \"c_hash\" not in idt:\n                raise MissingRequiredAttribute(\"Missing c_hash property\", idt)\n            if idt[\"c_hash\"] != jws.left_hash(instance[\"code\"], hfunc):\n                raise CHashError(\"Failed to verify code hash\", idt)\n\n    return idt\n\n\n# -----------------------------------------------------------------------------\n\n\nclass RefreshAccessTokenRequest(message.RefreshAccessTokenRequest):\n    pass\n\n\nclass TokenErrorResponse(message.TokenErrorResponse):\n    pass\n\n\nclass AccessTokenResponse(message.AccessTokenResponse):\n    c_param = message.AccessTokenResponse.c_param.copy()\n    c_param.update({\"id_token\": SINGLE_OPTIONAL_STRING})\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n        if \"id_token\" in self:\n            # replace the JWT with the verified IdToken instance\n            self[\"id_token\"] = verify_id_token(self, **kwargs)\n\n        return True\n\n\nclass UserInfoRequest(Message):\n    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}\n\n\nclass AuthorizationResponse(message.AuthorizationResponse, message.AccessTokenResponse):\n    c_param = message.AuthorizationResponse.c_param.copy()\n    c_param.update(message.AccessTokenResponse.c_param)\n    c_param.update(\n        {\n            \"code\": SINGLE_OPTIONAL_STRING,\n            \"access_token\": SINGLE_OPTIONAL_STRING,\n            \"token_type\": SINGLE_OPTIONAL_STRING,\n            \"id_token\": SINGLE_OPTIONAL_IDTOKEN,\n        }\n    )\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"aud\" in self:\n            if \"client_id\" in kwargs:\n                # check that it's for me\n                if kwargs[\"client_id\"] not in self[\"aud\"]:\n                    return False\n\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n        if \"access_token\" in self:\n            if \"token_type\" not in self:\n                raise MissingRequiredValue(\"Missing token_type parameter\", self)\n\n        return True\n\n\nclass AuthorizationErrorResponse(message.AuthorizationErrorResponse):\n    c_allowed_values = message.AuthorizationErrorResponse.c_allowed_values.copy()\n    c_allowed_values[\"error\"].extend(\n        [\n            \"interaction_required\",\n            \"login_required\",\n            \"session_selection_required\",\n            \"consent_required\",\n            \"invalid_request_uri\",\n            \"invalid_request_object\",\n            \"registration_not_supported\",\n            \"request_not_supported\",\n            \"request_uri_not_supported\",\n        ]\n    )\n\n\nclass AuthorizationRequest(message.AuthorizationRequest):\n    c_param = message.AuthorizationRequest.c_param.copy()\n    c_param.update(\n        {\n            \"scope\": REQUIRED_LIST_OF_SP_SEP_STRINGS,\n            \"redirect_uri\": SINGLE_REQUIRED_STRING,\n            \"nonce\": SINGLE_OPTIONAL_STRING,\n            \"display\": SINGLE_OPTIONAL_STRING,\n            \"prompt\": OPTIONAL_LIST_OF_STRINGS,\n            \"max_age\": SINGLE_OPTIONAL_INT,\n            \"ui_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,\n            \"claims_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,\n            \"id_token_hint\": SINGLE_OPTIONAL_STRING,\n            \"login_hint\": SINGLE_OPTIONAL_STRING,\n            \"acr_values\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,\n            \"claims\": SINGLE_OPTIONAL_CLAIMSREQ,\n            \"registration\": SINGLE_OPTIONAL_JSON,\n            \"request\": SINGLE_OPTIONAL_STRING,\n            \"request_uri\": SINGLE_OPTIONAL_STRING,\n            \"response_mode\": SINGLE_OPTIONAL_STRING,\n        }\n    )\n    c_allowed_values = message.AuthorizationRequest.c_allowed_values.copy()\n    c_allowed_values.update(\n        {\n            \"display\": [\"page\", \"popup\", \"touch\", \"wap\"],\n            \"prompt\": [\"none\", \"login\", \"consent\", \"select_account\"],\n        }\n    )\n\n    def verify(self, **kwargs):\n        \"\"\"\n        Check that the request is valid.\n\n        Authorization Request parameters that are OPTIONAL in the OAuth 2.0\n        specification MAY be included in the OpenID Request Object without also\n        passing them as OAuth 2.0 Authorization Request parameters, with one\n        exception: The scope parameter MUST always be present in OAuth 2.0\n        Authorization Request parameters.\n        All parameter values that are present both in the OAuth 2.0\n        Authorization Request and in the OpenID Request Object MUST exactly match.\n        \"\"\"\n        super().verify(**kwargs)\n\n        args = {}\n        for arg in [\"key\", \"keyjar\", \"opponent_id\", \"sender\"]:\n            try:\n                args[arg] = kwargs[arg]\n            except KeyError:\n                pass\n\n        if \"opponent_id\" not in kwargs:\n            args[\"opponent_id\"] = self[\"client_id\"]\n\n        if \"request\" in self:\n            if isinstance(self[\"request\"], str):\n                # Try to decode the JWT, checks the signature\n                oidr = OpenIDRequest().from_jwt(str(self[\"request\"]), **args)\n\n                # verify that nothing is change in the original message\n                for key, val in oidr.items():\n                    if key in self and self[key] != val:\n                        raise AssertionError()\n\n                # replace the JWT with the parsed and verified instance\n                self[\"request\"] = oidr\n\n        if \"id_token_hint\" in self:\n            if isinstance(self[\"id_token_hint\"], str):\n                idt = IdToken().from_jwt(str(self[\"id_token_hint\"]), **args)\n                self[\"id_token_hint\"] = idt\n\n        if \"response_type\" not in self:\n            raise MissingRequiredAttribute(\"response_type missing\", self)\n\n        _rt = self[\"response_type\"]\n        if \"token\" in _rt or \"id_token\" in _rt:\n            if \"nonce\" not in self:\n                raise MissingRequiredAttribute(\"Nonce missing\", self)\n\n        if \"openid\" not in self.get(\"scope\", []):\n            raise MissingRequiredValue(\"openid not in scope\", self)\n\n        if \"offline_access\" in self.get(\"scope\", []):\n            if \"prompt\" not in self or \"consent\" not in self[\"prompt\"]:\n                raise MissingRequiredValue(\"consent in prompt\", self)\n\n        if \"prompt\" in self:\n            if \"none\" in self[\"prompt\"] and len(self[\"prompt\"]) > 1:\n                raise InvalidRequest(\"prompt none combined with other value\", self)\n\n        return True\n\n\nclass AccessTokenRequest(message.AccessTokenRequest):\n    c_param = message.AccessTokenRequest.c_param.copy()\n    c_param.update(\n        {\n            \"client_assertion_type\": SINGLE_OPTIONAL_STRING,\n            \"client_assertion\": SINGLE_OPTIONAL_STRING,\n        }\n    )\n    c_default = {\"grant_type\": \"authorization_code\"}\n    c_allowed_values = {\n        \"client_assertion_type\": [\n            \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n        ]\n    }\n\n\nclass AddressClaim(Message):\n    c_param = {\n        \"formatted\": SINGLE_OPTIONAL_STRING,\n        \"street_address\": SINGLE_OPTIONAL_STRING,\n        \"locality\": SINGLE_OPTIONAL_STRING,\n        \"region\": SINGLE_OPTIONAL_STRING,\n        \"postal_code\": SINGLE_OPTIONAL_STRING,\n        \"country\": SINGLE_OPTIONAL_STRING,\n    }\n\n\nclass OpenIDSchema(Message):\n    c_param = {\n        \"sub\": SINGLE_REQUIRED_STRING,\n        \"name\": SINGLE_OPTIONAL_STRING,\n        \"given_name\": SINGLE_OPTIONAL_STRING,\n        \"family_name\": SINGLE_OPTIONAL_STRING,\n        \"middle_name\": SINGLE_OPTIONAL_STRING,\n        \"nickname\": SINGLE_OPTIONAL_STRING,\n        \"preferred_username\": SINGLE_OPTIONAL_STRING,\n        \"profile\": SINGLE_OPTIONAL_STRING,\n        \"picture\": SINGLE_OPTIONAL_STRING,\n        \"website\": SINGLE_OPTIONAL_STRING,\n        \"email\": SINGLE_OPTIONAL_STRING,\n        \"email_verified\": SINGLE_OPTIONAL_BOOLEAN,\n        \"gender\": SINGLE_OPTIONAL_STRING,\n        \"birthdate\": SINGLE_OPTIONAL_STRING,\n        \"zoneinfo\": SINGLE_OPTIONAL_STRING,\n        \"locale\": SINGLE_OPTIONAL_STRING,\n        \"phone_number\": SINGLE_OPTIONAL_STRING,\n        \"phone_number_verified\": SINGLE_OPTIONAL_BOOLEAN,\n        \"address\": OPTIONAL_ADDRESS,\n        \"updated_at\": SINGLE_OPTIONAL_INT,\n        \"_claim_names\": OPTIONAL_MESSAGE,\n        \"_claim_sources\": OPTIONAL_MESSAGE,\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"birthdate\" in self:\n            # Either YYYY-MM-DD or just YYYY or 0000-MM-DD\n            try:\n                time.strptime(self[\"birthdate\"], \"%Y-%m-%d\")\n            except ValueError:\n                try:\n                    time.strptime(self[\"birthdate\"], \"%Y\")\n                except ValueError:\n                    try:\n                        time.strptime(self[\"birthdate\"], \"0000-%m-%d\")\n                    except ValueError:\n                        raise VerificationError(\"Birthdate format error\", self)\n\n        if any(val is None for val in self.values()):\n            return False\n\n        return True\n\n\nclass RegistrationRequest(Message):\n    c_param = {\n        \"redirect_uris\": REQUIRED_LIST_OF_STRINGS,\n        \"response_types\": OPTIONAL_LIST_OF_STRINGS,\n        \"grant_types\": OPTIONAL_LIST_OF_STRINGS,\n        \"application_type\": SINGLE_OPTIONAL_STRING,\n        \"contacts\": OPTIONAL_LIST_OF_STRINGS,\n        \"client_name\": SINGLE_OPTIONAL_STRING,\n        \"logo_uri\": SINGLE_OPTIONAL_STRING,\n        \"client_uri\": SINGLE_OPTIONAL_STRING,\n        \"policy_uri\": SINGLE_OPTIONAL_STRING,\n        \"tos_uri\": SINGLE_OPTIONAL_STRING,\n        \"jwks\": SINGLE_OPTIONAL_STRING,\n        \"jwks_uri\": SINGLE_OPTIONAL_STRING,\n        \"sector_identifier_uri\": SINGLE_OPTIONAL_STRING,\n        \"subject_type\": SINGLE_OPTIONAL_STRING,\n        \"id_token_signed_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"id_token_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"id_token_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_signed_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,\n        \"request_object_signing_alg\": SINGLE_OPTIONAL_STRING,\n        \"request_object_encryption_alg\": SINGLE_OPTIONAL_STRING,\n        \"request_object_encryption_enc\": SINGLE_OPTIONAL_STRING,\n        \"token_endpoint_auth_method\": SINGLE_OPTIONAL_STRING,\n        \"token_endpoint_auth_signing_alg\": SINGLE_OPTIONAL_STRING,\n        \"default_max_age\": SINGLE_OPTIONAL_INT,\n        \"require_auth_time\": OPTIONAL_LOGICAL,\n        \"default_acr_values\": OPTIONAL_LIST_OF_STRINGS,\n        \"initiate_login_uri\": SINGLE_OPTIONAL_STRING,\n        \"request_uris\": OPTIONAL_LIST_OF_STRINGS,\n        \"post_logout_redirect_uris\": OPTIONAL_LIST_OF_STRINGS,\n        \"frontchannel_logout_uri\": SINGLE_OPTIONAL_STRING,\n        \"frontchannel_logout_session_required\": OPTIONAL_LOGICAL,\n        \"backchannel_logout_uri\": SINGLE_OPTIONAL_STRING,\n        \"backchannel_logout_session_required\": OPTIONAL_LOGICAL,\n    }\n    c_default = {\"application_type\": \"web\", \"response_types\": [\"code\"]}\n    c_allowed_values = {\n        \"application_type\": [\"native\", \"web\"],\n        \"subject_type\": [\"public\", \"pairwise\"],\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"initiate_login_uri\" in self and not self[\"initiate_login_uri\"].startswith(\n            \"https:\"\n        ):\n            raise AssertionError()\n\n        for param in [\n            \"request_object_encryption\",\n            \"id_token_encrypted_response\",\n            \"userinfo_encrypted_response\",\n        ]:\n            alg_param = \"%s_alg\" % param\n            enc_param = \"%s_enc\" % param\n            if alg_param in self:\n                if enc_param not in self:\n                    self[enc_param] = \"A128CBC-HS256\"\n\n            # both or none\n            if enc_param in self and alg_param not in self:\n                raise AssertionError()\n\n        if (\n            \"token_endpoint_auth_signing_alg\" in self\n            and self[\"token_endpoint_auth_signing_alg\"] == \"none\"\n        ):\n            raise AssertionError()\n\n        return True\n\n\nclass RegistrationResponse(Message):\n    \"\"\"Response to client_register registration requests.\"\"\"\n\n    c_param = {\n        \"client_id\": SINGLE_REQUIRED_STRING,\n        \"client_secret\": SINGLE_OPTIONAL_STRING,\n        \"registration_access_token\": SINGLE_OPTIONAL_STRING,\n        \"registration_client_uri\": SINGLE_OPTIONAL_STRING,\n        \"client_id_issued_at\": SINGLE_OPTIONAL_INT,\n        \"client_secret_expires_at\": SINGLE_OPTIONAL_INT,\n    }\n    c_param.update(RegistrationRequest.c_param)\n\n    def verify(self, **kwargs):\n        \"\"\"\n        Verify that the response is valid.\n\n        Implementations MUST either return both a Client Configuration Endpoint\n        and a Registration Access Token or neither of them.\n        :param kwargs:\n        :return: True if the message is OK otherwise False\n        \"\"\"\n        super(RegistrationResponse, self).verify(**kwargs)\n\n        has_reg_uri = \"registration_client_uri\" in self\n        has_reg_at = \"registration_access_token\" in self\n        if has_reg_uri != has_reg_at:\n            raise VerificationError(\n                (\n                    \"Only one of registration_client_uri\"\n                    \" and registration_access_token present\"\n                ),\n                self,\n            )\n\n        return True\n\n\nclass ClientRegistrationErrorResponse(message.ErrorResponse):\n    c_allowed_values = {\n        \"error\": [\n            \"invalid_redirect_uri\",\n            \"invalid_client_metadata\",\n            \"invalid_configuration_parameter\",\n        ]\n    }\n\n\nclass IdToken(OpenIDSchema):\n    c_param = OpenIDSchema.c_param.copy()\n    c_param.update(\n        {\n            \"iss\": SINGLE_REQUIRED_STRING,\n            \"sub\": SINGLE_REQUIRED_STRING,\n            \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string\n            \"exp\": SINGLE_REQUIRED_INT,\n            \"iat\": SINGLE_REQUIRED_INT,\n            \"auth_time\": SINGLE_OPTIONAL_INT,\n            \"nonce\": SINGLE_OPTIONAL_STRING,\n            \"at_hash\": SINGLE_OPTIONAL_STRING,\n            \"c_hash\": SINGLE_OPTIONAL_STRING,\n            \"acr\": SINGLE_OPTIONAL_STRING,\n            \"amr\": OPTIONAL_LIST_OF_STRINGS,\n            \"azp\": SINGLE_OPTIONAL_STRING,\n            \"sub_jwk\": SINGLE_OPTIONAL_STRING,\n        }\n    )\n\n    def verify(self, **kwargs):\n        super(IdToken, self).verify(**kwargs)\n\n        try:\n            if kwargs[\"iss\"] != self[\"iss\"]:\n                raise IssuerMismatch(\"{} != {}\".format(kwargs[\"iss\"], self[\"iss\"]))\n        except KeyError:\n            pass\n\n        if \"aud\" in self:\n            if \"client_id\" in kwargs:\n                # check that I'm among the recipients\n                if kwargs[\"client_id\"] not in self[\"aud\"]:\n                    raise NotForMe(\n                        \"{} not in aud:{}\".format(kwargs[\"client_id\"], self[\"aud\"]),\n                        self,\n                    )\n\n            # Then azp has to be present and be one of the aud values\n            if len(self[\"aud\"]) > 1:\n                if \"azp\" not in self:\n                    raise VerificationError(\"azp missing\", self)\n                if self[\"azp\"] not in self[\"aud\"]:\n                    raise VerificationError(\"Mismatch between azp and aud claims\", self)\n\n        if \"azp\" in self:\n            if \"client_id\" in kwargs:\n                if kwargs[\"client_id\"] != self[\"azp\"]:\n                    raise NotForMe(\n                        \"{} != azp:{}\".format(kwargs[\"client_id\"], self[\"azp\"]), self\n                    )\n\n        _now = time_util.utc_time_sans_frac()\n\n        try:\n            _skew = kwargs[\"skew\"]\n        except KeyError:\n            _skew = 0\n\n        try:\n            _exp = self[\"exp\"]\n        except KeyError:\n            raise MissingRequiredAttribute(\"exp\")\n        else:\n            if (_now - _skew) > _exp:\n                raise EXPError(\"Invalid expiration time\")\n\n        try:\n            _storage_time = kwargs[\"nonce_storage_time\"]\n        except KeyError:\n            _storage_time = NONCE_STORAGE_TIME\n\n        try:\n            _iat = self[\"iat\"]\n        except KeyError:\n            raise MissingRequiredAttribute(\"iat\")\n        else:\n            if (_iat + _storage_time) < (_now - _skew):\n                raise IATError(\"Issued too long ago\")\n            if _now < (_iat - _skew):\n                raise IATError(\"Issued in the future\")\n\n        if _exp < _iat:\n            raise EXPError(\"Invalid expiration time\")\n\n        return True\n\n\nclass StateFullMessage(Message):\n    c_param = {\"state\": SINGLE_REQUIRED_STRING}\n\n\nclass RefreshSessionRequest(StateFullMessage):\n    c_param = StateFullMessage.c_param.copy()\n    c_param.update(\n        {\"id_token\": SINGLE_REQUIRED_STRING, \"redirect_url\": SINGLE_REQUIRED_STRING}\n    )\n\n    def verify(self, **kwargs):\n        super(RefreshSessionRequest, self).verify(**kwargs)\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n\nclass RefreshSessionResponse(StateFullMessage):\n    c_param = StateFullMessage.c_param.copy()\n    c_param.update({\"id_token\": SINGLE_REQUIRED_STRING})\n\n    def verify(self, **kwargs):\n        super(RefreshSessionResponse, self).verify(**kwargs)\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n\nclass CheckSessionRequest(Message):\n    c_param = {\"id_token\": SINGLE_REQUIRED_STRING}\n\n    def verify(self, **kwargs):\n        super(CheckSessionRequest, self).verify(**kwargs)\n        if \"id_token\" in self:\n            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)\n\n\nclass CheckIDRequest(Message):\n    c_param = {\"access_token\": SINGLE_REQUIRED_STRING}\n\n\nclass EndSessionRequest(Message):\n    c_param = {\n        \"id_token_hint\": SINGLE_OPTIONAL_STRING,\n        \"post_logout_redirect_uri\": SINGLE_OPTIONAL_STRING,\n        \"state\": SINGLE_OPTIONAL_STRING,\n    }\n\n\nclass EndSessionResponse(Message):\n    c_param = {\"state\": SINGLE_OPTIONAL_STRING}\n\n\nclass Claims(Message):\n    pass\n\n\nclass ClaimsRequest(Message):\n    c_param = {\n        \"userinfo\": OPTIONAL_MULTIPLE_Claims,\n        \"id_token\": OPTIONAL_MULTIPLE_Claims,\n    }\n\n\nclass OpenIDRequest(AuthorizationRequest):\n    pass\n\n\nclass ProviderConfigurationResponse(Message):\n    c_param = {\n        \"issuer\": SINGLE_REQUIRED_STRING,\n        \"authorization_endpoint\": SINGLE_REQUIRED_STRING,\n        \"token_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"userinfo_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"jwks_uri\": SINGLE_REQUIRED_STRING,\n        \"registration_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"scopes_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"response_types_supported\": REQUIRED_LIST_OF_STRINGS,\n        \"response_modes_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"grant_types_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"acr_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"subject_types_supported\": REQUIRED_LIST_OF_STRINGS,\n        \"id_token_signing_alg_values_supported\": REQUIRED_LIST_OF_STRINGS,\n        \"id_token_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"id_token_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"userinfo_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"userinfo_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"userinfo_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"request_object_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"request_object_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"request_object_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"token_endpoint_auth_methods_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"token_endpoint_auth_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"display_values_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"claim_types_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"claims_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"service_documentation\": SINGLE_OPTIONAL_STRING,\n        \"claims_locales_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"ui_locales_supported\": OPTIONAL_LIST_OF_STRINGS,\n        \"claims_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"request_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"request_uri_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"require_request_uri_registration\": SINGLE_OPTIONAL_BOOLEAN,\n        \"op_policy_uri\": SINGLE_OPTIONAL_STRING,\n        \"op_tos_uri\": SINGLE_OPTIONAL_STRING,\n        \"check_session_iframe\": SINGLE_OPTIONAL_STRING,\n        \"end_session_endpoint\": SINGLE_OPTIONAL_STRING,\n        \"frontchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"frontchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"backchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,\n        \"backchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,\n    }\n    c_default = {\n        \"version\": \"3.0\",\n        \"token_endpoint_auth_methods_supported\": [\"client_secret_basic\"],\n        \"claims_parameter_supported\": False,\n        \"request_parameter_supported\": False,\n        \"request_uri_parameter_supported\": True,\n        \"require_request_uri_registration\": False,\n        \"grant_types_supported\": [\"authorization_code\", \"implicit\"],\n        \"frontchannel_logout_supported\": False,\n        \"frontchannel_logout_session_supported\": False,\n        \"backchannel_logout_supported\": False,\n        \"backchannel_logout_session_supported\": False,\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"scopes_supported\" in self:\n            if \"openid\" not in self[\"scopes_supported\"]:\n                raise AssertionError()\n            for scope in self[\"scopes_supported\"]:\n                check_char_set(scope, SCOPE_CHARSET)\n\n        parts = urlparse(self[\"issuer\"])\n        if parts.scheme != \"https\":\n            raise SchemeError(\"Not HTTPS\")\n\n        if parts.query or parts.fragment:\n            raise AssertionError()\n\n        if (\n            any(\"code\" in rt for rt in self[\"response_types_supported\"])\n            and \"token_endpoint\" not in self\n        ):\n            raise MissingRequiredAttribute(\"token_endpoint\")\n\n        return True\n\n\nclass AuthnToken(Message):\n    c_param = {\n        \"iss\": SINGLE_REQUIRED_STRING,\n        \"sub\": SINGLE_REQUIRED_STRING,\n        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string\n        \"jti\": SINGLE_REQUIRED_STRING,\n        \"exp\": SINGLE_REQUIRED_INT,\n        \"iat\": SINGLE_OPTIONAL_INT,\n    }\n\n\n# According to RFC 7519 all claims are optional\nclass JasonWebToken(Message):\n    c_param = {\n        \"iss\": SINGLE_OPTIONAL_STRING,\n        \"sub\": SINGLE_OPTIONAL_STRING,\n        \"aud\": OPTIONAL_LIST_OF_STRINGS,  # Array of strings or string\n        \"exp\": SINGLE_OPTIONAL_INT,\n        \"nbf\": SINGLE_OPTIONAL_INT,\n        \"iat\": SINGLE_OPTIONAL_INT,\n        \"jti\": SINGLE_OPTIONAL_STRING,\n    }\n\n\ndef jwt_deser(val, sformat=\"json\"):\n    if sformat == \"urlencoded\":\n        sformat = \"json\"\n    if sformat in [\"dict\", \"json\"]:\n        if not isinstance(val, str):\n            val = json.dumps(val)\n            sformat = \"json\"\n    return JasonWebToken().deserialize(val, sformat)\n\n\nSINGLE_OPTIONAL_JWT = ParamDefinition(Message, False, msg_ser, jwt_deser, False)\n\n\nclass UserInfoErrorResponse(message.ErrorResponse):\n    c_allowed_values = {\n        \"error\": [\n            \"invalid_schema\",\n            \"invalid_request\",\n            \"invalid_token\",\n            \"insufficient_scope\",\n        ]\n    }\n\n\nclass DiscoveryRequest(Message):\n    c_param = {\"principal\": SINGLE_REQUIRED_STRING, \"service\": SINGLE_REQUIRED_STRING}\n\n\nclass DiscoveryResponse(Message):\n    c_param = {\"locations\": REQUIRED_LIST_OF_STRINGS}\n\n\nclass ResourceRequest(Message):\n    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}\n\n\nSCOPE2CLAIMS: Dict[str, List[str]] = {\n    \"openid\": [\"sub\"],\n    \"profile\": [\n        \"name\",\n        \"given_name\",\n        \"family_name\",\n        \"middle_name\",\n        \"nickname\",\n        \"profile\",\n        \"picture\",\n        \"website\",\n        \"gender\",\n        \"birthdate\",\n        \"zoneinfo\",\n        \"locale\",\n        \"updated_at\",\n        \"preferred_username\",\n    ],\n    \"email\": [\"email\", \"email_verified\"],\n    \"address\": [\"address\"],\n    \"phone\": [\"phone_number\", \"phone_number_verified\"],\n    \"offline_access\": [],\n}\n\n# LOGOUT related messages\n\nSINGLE_OPTIONAL_JSON = ParamDefinition(dict, False, json_ser, json_deser, False)\nSINGLE_REQUIRED_JSON = ParamDefinition(dict, True, json_ser, json_deser, False)\n\nBACK_CHANNEL_LOGOUT_EVENT = \"http://schemas.openid.net/event/backchannel-logout\"\n\n\nclass LogoutToken(Message):\n    \"\"\"Defined in https://openid.net/specs/openid-connect-backchannel-1_0.html#LogoutToken .\"\"\"\n\n    c_param = {\n        \"iss\": SINGLE_REQUIRED_STRING,\n        \"sub\": SINGLE_OPTIONAL_STRING,\n        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string\n        \"iat\": SINGLE_REQUIRED_INT,\n        \"jti\": SINGLE_REQUIRED_STRING,\n        \"events\": SINGLE_REQUIRED_JSON,\n        \"sid\": SINGLE_OPTIONAL_STRING,\n    }\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        if \"nonce\" in self:\n            raise MessageException(\n                '\"nonce\" is prohibited from appearing in a LogoutToken.'\n            )\n\n        # Check the 'events' JSON\n        _keys = list(self[\"events\"].keys())\n        if len(_keys) != 1:\n            raise ValueError('Must only be one member in \"events\"')\n        if _keys[0] != BACK_CHANNEL_LOGOUT_EVENT:\n            raise ValueError('Wrong member in \"events\"')\n        if self[\"events\"][_keys[0]] != {}:\n            raise ValueError('Wrong member value in \"events\"')\n\n        # There must be either a 'sub' or a 'sid', and may contain both\n        if not (\"sub\" in self or \"sid\" in self):\n            raise ValueError('There MUST be either a \"sub\" or a \"sid\"')\n\n        try:\n            if kwargs[\"aud\"] not in self[\"aud\"]:\n                raise NotForMe(\"Not among intended audience\")\n        except KeyError:\n            pass\n\n        try:\n            if kwargs[\"iss\"] != self[\"iss\"]:\n                raise NotForMe(\"Wrong issuer\")\n        except KeyError:\n            pass\n\n        _now = utc_time_sans_frac()\n\n        _skew = kwargs.get(\"skew\", 0)\n        _iat = self.get(\"iat\", 0)\n\n        if _iat and _iat > (_now + _skew):\n            raise ValueError(\"Invalid issued_at time\")\n\n        return True\n\n\nID_TOKEN_VERIFY_ARGS = [\n    \"keyjar\",\n    \"verify\",\n    \"encalg\",\n    \"encenc\",\n    \"sigalg\",\n    \"issuer\",\n    \"allow_missing_kid\",\n    \"no_kid_issuer\",\n    \"trusting\",\n    \"skew\",\n    \"nonce_storage_time\",\n    \"client_id\",\n]\n\n\nclass BackChannelLogoutRequest(Message):\n    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-backchannel-1_0.html .\"\"\"\n\n    c_param = {\"logout_token\": SINGLE_REQUIRED_STRING}\n\n    def verify(self, **kwargs):\n        super().verify(**kwargs)\n\n        args = {arg: kwargs[arg] for arg in TOKEN_VERIFY_ARGS if arg in kwargs}\n\n        logout_token = LogoutToken().from_jwt(str(self[\"logout_token\"]), **args)\n        logout_token.verify(**kwargs)\n\n        self[\"logout_token\"] = logout_token\n        logger.info(\"Verified Logout Token: {}\".format(logout_token.to_dict()))\n\n        return True\n\n\nclass FrontChannelLogoutRequest(Message):\n    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-frontchannel-1_0.html .\"\"\"\n\n    c_param = {\"iss\": SINGLE_OPTIONAL_STRING, \"sid\": SINGLE_OPTIONAL_STRING}\n\n\nMSG = {\n    \"RefreshAccessTokenRequest\": RefreshAccessTokenRequest,\n    \"TokenErrorResponse\": TokenErrorResponse,\n    \"AccessTokenResponse\": AccessTokenResponse,\n    \"UserInfoRequest\": UserInfoRequest,\n    \"AuthorizationResponse\": AuthorizationResponse,\n    \"AuthorizationErrorResponse\": AuthorizationErrorResponse,\n    \"AuthorizationRequest\": AuthorizationRequest,\n    \"AccessTokenRequest\": AccessTokenRequest,\n    \"AddressClaim\": AddressClaim,\n    \"OpenIDSchema\": OpenIDSchema,\n    \"RegistrationRequest\": RegistrationRequest,\n    \"RegistrationResponse\": RegistrationResponse,\n    \"ClientRegistrationErrorResponse\": ClientRegistrationErrorResponse,\n    \"IdToken\": IdToken,\n    \"RefreshSessionRequest\": RefreshSessionRequest,\n    \"RefreshSessionResponse\": RefreshSessionResponse,\n    \"CheckSessionRequest\": CheckSessionRequest,\n    \"CheckIDRequest\": CheckIDRequest,\n    \"EndSessionRequest\": EndSessionRequest,\n    \"EndSessionResponse\": EndSessionResponse,\n    \"Claims\": Claims,\n    \"OpenIDRequest\": OpenIDRequest,\n    \"ProviderConfigurationResponse\": ProviderConfigurationResponse,\n    \"AuthnToken\": AuthnToken,\n    \"UserInfoErrorResponse\": UserInfoErrorResponse,\n    \"DiscoveryRequest\": DiscoveryRequest,\n    \"DiscoveryResponse\": DiscoveryResponse,\n    \"ResourceRequest\": ResourceRequest,\n    # LOGOUT messages\n    \"LogoutToken\": LogoutToken,\n    \"BackChannelLogoutRequest\": BackChannelLogoutRequest,\n    \"FrontChannelLogoutRequest\": FrontChannelLogoutRequest,\n}\n\n\ndef factory(msgtype):\n    warnings.warn(\n        \"`factory` is deprecated. Use `OIDCMessageFactory` instead.\", DeprecationWarning\n    )\n    for _, obj in inspect.getmembers(sys.modules[__name__]):\n        if inspect.isclass(obj) and issubclass(obj, Message):\n            try:\n                if obj.__name__ == msgtype:\n                    return obj\n            except AttributeError:\n                pass\n\n    # Fall back to basic OAuth2 messages\n    return message.factory(msgtype)\n\n\nclass OIDCMessageFactory(MessageFactory):\n    \"\"\"Factory that knows OIDC message types.\"\"\"\n\n    authorization_endpoint = MessageTuple(AuthorizationRequest, AuthorizationResponse)\n    token_endpoint = MessageTuple(AccessTokenRequest, AccessTokenResponse)\n    refresh_endpoint = MessageTuple(RefreshAccessTokenRequest, AccessTokenResponse)\n    resource_endpoint = MessageTuple(ResourceRequest, Message)\n    configuration_endpoint = MessageTuple(Message, ProviderConfigurationResponse)\n\n    userinfo_endpoint = MessageTuple(UserInfoRequest, Message)\n    registration_endpoint = MessageTuple(RegistrationRequest, RegistrationResponse)\n    endsession_endpoint = MessageTuple(EndSessionRequest, EndSessionResponse)\n    checkid_endpoint = MessageTuple(CheckIDRequest, IdToken)\n    checksession_endpoint = MessageTuple(CheckSessionRequest, IdToken)\n    refreshsession_endpoint = MessageTuple(\n        RefreshSessionRequest, RefreshSessionResponse\n    )\n    discovery_endpoint = MessageTuple(DiscoveryRequest, DiscoveryResponse)\n", "import json\nimport os\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlparse\n\nimport pytest\nimport responses\nfrom freezegun import freeze_time\nfrom jwkest import BadSignature\nfrom jwkest.jwk import SYMKey\n\nfrom oic.oauth2.message import MissingSigningKey\nfrom oic.oauth2.message import WrongSigningAlgorithm\nfrom oic.oic import DEF_SIGN_ALG\nfrom oic.oic import Server\nfrom oic.oic import response_types_to_grant_types\nfrom oic.oic.consumer import IGNORE\nfrom oic.oic.consumer import Consumer\nfrom oic.oic.consumer import clean_response\nfrom oic.oic.message import AccessTokenRequest\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import ProviderConfigurationResponse\nfrom oic.oic.message import RegistrationResponse\nfrom oic.utils.authn.client import CLIENT_AUTHN_METHOD\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.keyio import keybundle_from_local_file\nfrom oic.utils.sdb import DictSessionBackend\nfrom oic.utils.sdb import session_get\nfrom oic.utils.time_util import utc_time_sans_frac\n\n__author__ = \"rohe0002\"\n\nKC_SYM_VS = KeyBundle({\"kty\": \"oct\", \"key\": \"abcdefghijklmnop\", \"use\": \"ver\"})\nKC_SYM_S = KeyBundle({\"kty\": \"oct\", \"key\": \"abcdefghijklmnop\", \"use\": \"sig\"})\n\nBASE_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), \"data/keys\"))\nKC_RSA = keybundle_from_local_file(\n    os.path.join(BASE_PATH, \"rsa.key\"), \"rsa\", [\"ver\", \"sig\"]\n)\n\nSRVKEYS = KeyJar()\nSRVKEYS[\"\"] = [KC_RSA]\nSRVKEYS[\"client_1\"] = [KC_SYM_VS, KC_RSA]\n\nCLIKEYS = KeyJar()\nCLIKEYS[\"http://localhost:8088\"] = [KC_RSA]\nCLIKEYS[\"\"] = [KC_RSA, KC_SYM_VS]\nCLIKEYS[\"https://example.com\"] = [KC_RSA]\n\nSERVER_INFO = {\n    \"version\": \"3.0\",\n    \"issuer\": \"https://localhost:8088\",\n    \"authorization_endpoint\": \"http://localhost:8088/authorization\",\n    \"token_endpoint\": \"http://localhost:8088/token\",\n    \"userinfo_endpoint\": \"http://localhost:8088/userinfo\",\n    \"flows_supported\": [\"code\", \"token\"],\n}\n\nCONFIG = {\n    \"authz_page\": \"authz\",\n    \"scope\": [\"openid\"],\n    \"response_type\": \"code\",\n    \"request_method\": \"parameter\",\n    \"password\": \"hemligt\",\n    \"max_age\": 3600,\n    \"user_info\": {\"name\": None},\n}\n\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\ndef test_response_types_to_grant_types():\n    req_args = [\"code\"]\n    assert set(response_types_to_grant_types(req_args)) == {\"authorization_code\"}\n    req_args = [\"code\", \"code id_token\"]\n    assert set(response_types_to_grant_types(req_args)) == {\n        \"authorization_code\",\n        \"implicit\",\n    }\n    req_args = [\"code\", \"id_token code\", \"code token id_token\"]\n    assert set(response_types_to_grant_types(req_args)) == {\n        \"authorization_code\",\n        \"implicit\",\n    }\n\n    req_args = [\"code\", \"id_token code\", \"code token id_token\"]\n    kwargs = {\"grant_types\": [\"refresh_token\", \"authorization_code\"]}\n    assert set(response_types_to_grant_types(req_args, **kwargs)) == {\n        \"authorization_code\",\n        \"implicit\",\n        \"refresh_token\",\n    }\n    with pytest.raises(ValueError):\n        response_types_to_grant_types([\"foobar openid\"])\n\n\ndef test_clean_response():\n    atr = AccessTokenResponse(\n        access_token=\"access_token\",\n        token_type=\"bearer\",\n        expires_in=600,\n        refresh_token=\"refresh\",\n        steps=39,\n        stalls=\"yes\",\n    )\n\n    catr = clean_response(atr)\n    atr_keys = atr.keys()\n    catr_keys = catr.keys()\n    assert _eq(\n        atr_keys,\n        [\n            \"token_type\",\n            \"access_token\",\n            \"expires_in\",\n            \"refresh_token\",\n            \"steps\",\n            \"stalls\",\n        ],\n    )\n    assert _eq(catr_keys, [\"token_type\", \"access_token\", \"expires_in\", \"refresh_token\"])\n\n\nclass TestOICConsumer:\n    @pytest.fixture(autouse=True)\n    def setup_consumer(self, session_db_factory):\n        client_id = \"client_1\"\n        client_config = {\n            \"client_id\": client_id,\n            \"client_authn_method\": CLIENT_AUTHN_METHOD,\n        }\n\n        self.consumer = Consumer(\n            DictSessionBackend(), CONFIG, client_config, SERVER_INFO\n        )\n        self.consumer.behaviour = {\n            \"request_object_signing_alg\": DEF_SIGN_ALG[\"openid_request_object\"]\n        }\n        self.consumer.keyjar = CLIKEYS\n        self.consumer.redirect_uris = [\"https://example.com/cb\"]\n        self.consumer.authorization_endpoint = \"https://example.com/authorization\"\n        self.consumer.token_endpoint = \"https://example.com/token\"\n        self.consumer.userinfo_endpoint = \"https://example.com/userinfo\"  # type: ignore\n        self.consumer.client_secret = \"hemlig\"\n        self.consumer.secret_type = \"basic\"\n        self.consumer.provider_info = ProviderConfigurationResponse(\n            issuer=\"https://example.com\"\n        )  # abs min\n\n    def test_backup_keys(self):\n        keys = self.consumer.__dict__.keys()\n        _dict = self.consumer.dictionary()\n        dkeys = [key for key in keys if key not in _dict.keys()]\n        assert _eq(dkeys, IGNORE)\n\n    def test_backup_restore(self):\n        authz_org_url = \"http://example.org/authorization\"\n\n        _dict = sorted(list(self.consumer.__dict__.items()))\n\n        self.consumer._backup(\"sid\")\n        self.consumer.restore(\"sid\")\n        assert sorted(_dict) == sorted(list(self.consumer.__dict__.items()))\n\n        self.consumer.authorization_endpoint = authz_org_url\n        assert _dict != sorted(list(self.consumer.__dict__.items()))\n\n        self.consumer.restore(\"sid\")\n        assert _dict == sorted(list(self.consumer.__dict__.items()))\n\n    def test_backup_restore_update(self):\n        authz_org_url = \"http://example.org/authorization\"\n\n        self.consumer._backup(\"sid\")\n\n        self.consumer.authorization_endpoint = authz_org_url\n        self.consumer.token_endpoint = \"https://example.org/token\"\n        self.consumer.userinfo_endpoint = \"\"  # type: ignore\n\n        assert self.consumer.authorization_endpoint == authz_org_url\n        assert self.consumer.token_endpoint == \"https://example.org/token\"\n        assert self.consumer.userinfo_endpoint == \"\"  # type: ignore\n\n        self.consumer.update(\"sid\")\n\n        assert self.consumer.authorization_endpoint == authz_org_url\n        assert self.consumer.token_endpoint == \"https://example.org/token\"\n        assert (\n            self.consumer.userinfo_endpoint  # type: ignore\n            == \"https://example.com/userinfo\"\n        )\n\n    def test_begin(self):\n        srv = Server()\n        srv.keyjar = SRVKEYS\n        sid, location = self.consumer.begin(\"openid\", \"code\")\n        authreq = srv.parse_authorization_request(url=location)\n        assert _eq(\n            list(authreq.keys()),\n            [\n                \"state\",\n                \"max_age\",\n                \"claims\",\n                \"response_type\",\n                \"client_id\",\n                \"scope\",\n                \"redirect_uri\",\n            ],\n        )\n\n        assert authreq[\"state\"] == sid\n        assert authreq[\"scope\"] == self.consumer.consumer_config[\"scope\"]\n        assert authreq[\"client_id\"] == self.consumer.client_id\n\n    def test_begin_file(self, tmpdir):\n        path = tmpdir.strpath\n        external_path = \"/exported\"\n        self.consumer.consumer_config[\"request_method\"] = \"file\"\n        self.consumer.consumer_config[\"temp_dir\"] = path\n        self.consumer.consumer_config[\"temp_path\"] = external_path\n        self.consumer.consumer_config[\"authz_page\"] = \"/authz\"\n        srv = Server()\n        srv.keyjar = SRVKEYS\n\n        sid, location = self.consumer.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n\n        with responses.RequestsMock() as rsps:\n            p = urlparse(self.consumer.request_uri)\n            assert p.netloc == \"localhost:8087\"\n            # Map the URL path to the local path\n            relative_path = os.path.relpath(p.path, external_path)\n            file_path = os.path.join(path, relative_path)\n\n            with open(file_path) as f:\n                rsps.add(\n                    rsps.GET,\n                    self.consumer.request_uri,\n                    body=f.read(),\n                    status=200,\n                    content_type=\"application/urlencoded\",\n                )\n\n            authreq = srv.parse_authorization_request(url=location)\n            assert _eq(\n                list(authreq.keys()),\n                [\n                    \"max_age\",\n                    \"state\",\n                    \"redirect_uri\",\n                    \"response_type\",\n                    \"client_id\",\n                    \"scope\",\n                    \"claims\",\n                ],\n            )\n\n            assert authreq[\"state\"] == sid\n            assert authreq[\"scope\"] == self.consumer.consumer_config[\"scope\"]\n            assert authreq[\"client_id\"] == self.consumer.client_id\n            assert authreq[\"redirect_uri\"].startswith(\"http://localhost:8087/authz\")\n\n    def test_complete(self):\n        _state = \"state0\"\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            resp = self.consumer.complete(_state)\n        assert isinstance(resp, AccessTokenResponse)\n        assert _eq(resp.keys(), [\"token_type\", \"state\", \"access_token\", \"scope\"])\n\n        assert resp[\"state\"] == _state\n\n    def test_parse_authz(self):\n        _state = \"state0\"\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n        self.consumer._backup(_state)\n\n        part = self.consumer.parse_authz(query=result.headers[\"location\"])\n        assert isinstance(part, tuple)\n        atr = part[0]\n        assert part[1] is None\n        assert part[2] is None\n\n        assert isinstance(atr, AuthorizationResponse)\n        assert atr[\"state\"] == _state\n        assert \"code\" in atr\n\n    def test_parse_authz_implicit(self):\n        self.consumer.consumer_config[\"response_type\"] = [\"token\"]\n        _state = \"statxxx\"\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"implicit\",\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"https://example.com/cb\",\n        }\n\n        location = (\n            \"https://example.com/cb?access_token=token&token_type=bearer&state=statxxx\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n\n        part = self.consumer.parse_authz(query=result.headers[\"location\"])\n        assert isinstance(part, tuple)\n        assert part[0] is None\n        atr = part[1]\n        assert part[2] is None\n\n        assert isinstance(atr, AccessTokenResponse)\n        assert atr[\"state\"] == _state\n        assert \"access_token\" in atr\n\n    def test_complete_secret_auth(self):\n        _state = \"state0\"\n        del self.consumer.consumer_config[\"password\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            resp = self.consumer.complete(_state)\n        assert isinstance(resp, AccessTokenResponse)\n        assert _eq(resp.keys(), [\"token_type\", \"state\", \"access_token\", \"scope\"])\n\n        assert resp[\"state\"] == _state\n\n    def test_complete_auth_token(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"code\", \"token\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n\n        location = (\n            \"https://example.com/cb?code=some_code&state=state0&access_token=token&token_type=bearer\"\n            \"&client_id=client_1&scope=openid\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n        self.consumer._backup(\"state0\")\n\n        parsed = urlparse(result.headers[\"location\"])\n        part = self.consumer.parse_authz(query=parsed.query)\n        assert isinstance(part, tuple)\n        auth = part[0]\n        acc = part[1]\n        assert part[2] is None\n\n        assert isinstance(auth, AuthorizationResponse)\n        assert isinstance(acc, AccessTokenResponse)\n        assert _eq(\n            auth.keys(),\n            [\"code\", \"access_token\", \"token_type\", \"state\", \"client_id\", \"scope\"],\n        )\n        assert _eq(acc.keys(), [\"token_type\", \"state\", \"access_token\", \"scope\"])\n\n    def test_complete_auth_token_idtoken(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\", \"token\"]\n        self.consumer.registration_response = RegistrationResponse(\n            id_token_signed_response_alg=\"HS256\"\n        )\n        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n        token = IdToken(\n            iss=\"https://example.com\",\n            aud=\"client_1\",\n            sub=\"some_sub\",\n            exp=1565348600,\n            iat=1565348300,\n            nonce=\"nonce\",\n        )\n        location = (\n            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n            \"scope=openid&id_token={}\".format(\n                token.to_jwt(key=[SYMKey(key=\"hemlig\")], algorithm=\"HS256\")\n            )\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            query = parse_qs(urlparse(result.request.url).query)\n            assert query[\"client_id\"] == [\"client_1\"]\n            assert query[\"scope\"] == [\"openid\"]\n            assert query[\"response_type\"] == [\"id_token token\"]\n            assert query[\"state\"] == [\"state0\"]\n            assert query[\"nonce\"] == [\"nonce\"]\n            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n\n        parsed = urlparse(result.headers[\"location\"])\n\n        with freeze_time(\"2019-08-09 11:00:00\"):\n            part = self.consumer.parse_authz(query=parsed.query)\n        assert isinstance(part, tuple)\n        auth = part[0]\n        atr = part[1]\n        idt = part[2]\n\n        assert auth is None\n        assert isinstance(atr, AccessTokenResponse)\n        assert _eq(\n            atr.keys(), [\"access_token\", \"id_token\", \"token_type\", \"state\", \"scope\"]\n        )\n        assert isinstance(idt, IdToken)\n\n    def test_complete_auth_token_idtoken_no_alg_config(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\", \"token\"]\n        self.consumer.provider_info = ProviderConfigurationResponse(\n            issuer=\"https://example.com\"\n        )  # abs min\n        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n        token = IdToken(\n            iss=\"https://example.com\",\n            aud=\"client_1\",\n            sub=\"some_sub\",\n            exp=1565348600,\n            iat=1565348300,\n            nonce=\"nonce\",\n        )\n        location = (\n            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n            \"scope=openid&id_token={}\".format(\n                token.to_jwt(key=[SYMKey(key=\"hemlig\")], algorithm=\"HS256\")\n            )\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            query = parse_qs(urlparse(result.request.url).query)\n            assert query[\"client_id\"] == [\"client_1\"]\n            assert query[\"scope\"] == [\"openid\"]\n            assert query[\"response_type\"] == [\"id_token token\"]\n            assert query[\"state\"] == [\"state0\"]\n            assert query[\"nonce\"] == [\"nonce\"]\n            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n\n        parsed = urlparse(result.headers[\"location\"])\n\n        with freeze_time(\"2019-08-09 11:00:00\"):\n            part = self.consumer.parse_authz(query=parsed.query, algs={\"sign\": \"HS256\"})\n        assert isinstance(part, tuple)\n        auth = part[0]\n        atr = part[1]\n        idt = part[2]\n\n        assert auth is None\n        assert isinstance(atr, AccessTokenResponse)\n        assert _eq(\n            atr.keys(), [\"access_token\", \"id_token\", \"token_type\", \"state\", \"scope\"]\n        )\n        assert isinstance(idt, IdToken)\n\n    def test_complete_auth_token_idtoken_none_cipher_code(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"code\"]\n        self.consumer.registration_response = RegistrationResponse(\n            id_token_signed_response_alg=\"none\"\n        )\n        self.consumer.provider_info = ProviderConfigurationResponse(\n            issuer=\"https://example.com\"\n        )  # abs min\n        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n        self.consumer.sdb[_state] = {\"redirect_uris\": []}\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n        token = IdToken(\n            iss=\"https://example.com\",\n            aud=\"client_1\",\n            sub=\"some_sub\",\n            exp=1565348600,\n            iat=1565348300,\n            nonce=\"nonce\",\n            at_hash=\"aaa\",\n        )\n        # Downgrade the algorithm to `none`\n        location = (\n            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n            \"scope=openid&id_token={}\".format(\n                token.to_jwt(key=KC_RSA.keys(), algorithm=\"none\")\n            )\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            query = parse_qs(urlparse(result.request.url).query)\n            assert query[\"client_id\"] == [\"client_1\"]\n            assert query[\"scope\"] == [\"openid\"]\n            assert query[\"response_type\"] == [\"code\"]\n            assert query[\"state\"] == [\"state0\"]\n            assert query[\"nonce\"] == [\"nonce\"]\n            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n\n        parsed = urlparse(result.headers[\"location\"])\n\n        with freeze_time(\"2019-08-09 11:00:00\"):\n            part = self.consumer.parse_authz(query=parsed.query)\n        assert isinstance(part, tuple)\n        auth = part[0]\n        atr = part[1]\n        idt = part[2]\n\n        assert isinstance(auth, AuthorizationResponse)\n        assert isinstance(atr, AccessTokenResponse)\n        assert _eq(\n            atr.keys(), [\"access_token\", \"id_token\", \"token_type\", \"state\", \"scope\"]\n        )\n        assert isinstance(idt, IdToken)\n\n    def test_complete_auth_token_idtoken_none_cipher_token(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"token\"]\n        self.consumer.registration_response = RegistrationResponse(\n            id_token_signed_response_alg=\"none\"\n        )\n        self.consumer.provider_info = ProviderConfigurationResponse(\n            issuer=\"https://example.com\"\n        )  # abs min\n        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n        self.consumer.sdb[_state] = {\"redirect_uris\": []}\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n        token = IdToken(\n            iss=\"https://example.com\",\n            aud=\"client_1\",\n            sub=\"some_sub\",\n            exp=1565348600,\n            iat=1565348300,\n            nonce=\"nonce\",\n        )\n        # Downgrade the algorithm to `none`\n        location = (\n            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n            \"scope=openid&id_token={}\".format(\n                token.to_jwt(key=KC_RSA.keys(), algorithm=\"none\")\n            )\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            query = parse_qs(urlparse(result.request.url).query)\n            assert query[\"client_id\"] == [\"client_1\"]\n            assert query[\"scope\"] == [\"openid\"]\n            assert query[\"response_type\"] == [\"token\"]\n            assert query[\"state\"] == [\"state0\"]\n            assert query[\"nonce\"] == [\"nonce\"]\n            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n\n        parsed = urlparse(result.headers[\"location\"])\n\n        with freeze_time(\"2019-08-09 11:00:00\"):\n            with pytest.raises(WrongSigningAlgorithm):\n                self.consumer.parse_authz(query=parsed.query)\n\n    def test_complete_auth_token_idtoken_cipher_downgrade(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\", \"token\"]\n        self.consumer.provider_info = ProviderConfigurationResponse(\n            issuer=\"https://example.com\"\n        )  # abs min\n        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n            \"nonce\": \"nonce\",\n        }\n        token = IdToken(\n            iss=\"https://example.com\",\n            aud=\"client_1\",\n            sub=\"some_sub\",\n            exp=1565348600,\n            iat=1565348300,\n            nonce=\"nonce\",\n        )\n        # Downgrade the algorithm to `none`\n        location = (\n            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n            \"scope=openid&id_token={}\".format(\n                token.to_jwt(key=KC_RSA.keys(), algorithm=\"none\")\n            )\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            query = parse_qs(urlparse(result.request.url).query)\n            assert query[\"client_id\"] == [\"client_1\"]\n            assert query[\"scope\"] == [\"openid\"]\n            assert query[\"response_type\"] == [\"id_token token\"]\n            assert query[\"state\"] == [\"state0\"]\n            assert query[\"nonce\"] == [\"nonce\"]\n            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n\n        parsed = urlparse(result.headers[\"location\"])\n\n        with freeze_time(\"2019-08-09 11:00:00\"):\n            with pytest.raises(WrongSigningAlgorithm):\n                self.consumer.parse_authz(query=parsed.query)\n\n    def test_userinfo(self):\n        _state = \"state0\"\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/userinfo\",\n                content_type=\"application/json\",\n                json={\n                    \"name\": \"Ilja\",\n                    \"sub\": \"some_sub\",\n                    \"email\": \"ilja@example.com\",\n                    \"nickname\": \"Ilja\",\n                    \"verified\": True,\n                },\n            )\n\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            self.consumer.complete(_state)\n\n            result = self.consumer.get_user_info(_state)\n        assert isinstance(result, OpenIDSchema)\n        assert _eq(result.keys(), [\"name\", \"email\", \"verified\", \"nickname\", \"sub\"])\n\n    def test_sign_userinfo(self):\n        _state = \"state0\"\n        self.consumer.client_prefs = {\"userinfo_signed_response_alg\": \"RS256\"}\n        del self.consumer.consumer_config[\"request_method\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/userinfo\",\n                content_type=\"application/json\",\n                json={\n                    \"name\": \"Ilja\",\n                    \"sub\": \"some_sub\",\n                    \"email\": \"ilja@example.com\",\n                    \"nickname\": \"Ilja\",\n                    \"verified\": True,\n                },\n            )\n            self.consumer.begin(\"openid\", \"code\")\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n\n            self.consumer.complete(_state)\n\n            result = self.consumer.get_user_info(_state)\n        assert isinstance(result, OpenIDSchema)\n        assert _eq(result.keys(), [\"name\", \"email\", \"verified\", \"nickname\", \"sub\"])\n\n    def test_get_userinfo_claims(self):\n        _state = \"state0\"\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": \"code\",\n            \"scope\": [\"openid\"],\n        }\n\n        location = \"https://example.com/cb?code=code&state=state0\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/token\",\n                content_type=\"application/json\",\n                json={\n                    \"access_token\": \"some_token\",\n                    \"token_type\": \"bearer\",\n                    \"state\": \"state0\",\n                    \"scope\": \"openid\",\n                },\n            )\n            rsps.add(\n                responses.POST,\n                \"https://example.com/userinfo\",\n                content_type=\"application/json\",\n                json={\n                    \"name\": \"Ilja\",\n                    \"sub\": \"some_sub\",\n                    \"email\": \"ilja@example.com\",\n                    \"nickname\": \"Ilja\",\n                    \"verified\": True,\n                },\n            )\n\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n            parsed = urlparse(result.headers[\"location\"])\n            self.consumer.parse_response(\n                AuthorizationResponse, info=parsed.query, sformat=\"urlencoded\"\n            )\n            response = self.consumer.complete(_state)\n            result = self.consumer.get_userinfo_claims(\n                response[\"access_token\"],\n                self.consumer.userinfo_endpoint,  # type: ignore\n            )\n        assert isinstance(result, OpenIDSchema)\n        assert _eq(result.keys(), [\"name\", \"email\", \"verified\", \"nickname\", \"sub\"])\n\n    def real_test_discover(self):\n        c = Consumer(None, None)\n        principal = \"nav@connect-op.heroku.com\"\n        res = c.discover(principal)\n        assert isinstance(res, ProviderConfigurationResponse)\n        assert _eq(\n            res.keys(),\n            [\n                \"registration_endpoint\",\n                \"scopes_supported\",\n                \"identifiers_supported\",\n                \"token_endpoint\",\n                \"flows_supported\",\n                \"version\",\n                \"userinfo_endpoint\",\n                \"authorization_endpoint\",\n                \"x509_url\",\n                \"issuer\",\n            ],\n        )\n        assert res.version == \"3.0\"  # type: ignore\n        assert _eq(\n            res.flows_supported,  # type: ignore\n            [\n                \"code\",\n                \"token\",\n                \"id_token\",\n                \"code token\",\n                \"code id_token\",\n                \"id_token token\",\n            ],\n        )\n\n    def test_discover(self):\n        c = Consumer(None, None)\n        webfinger = {\n            \"subject\": \"acct:foo@example.com\",\n            \"links\": [\n                {\n                    \"rel\": \"http://openid.net/specs/connect/1.0/issuer\",\n                    \"href\": \"https://localhost:8088/\",\n                }\n            ],\n        }\n        principal = \"foo@example.com\"\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/.well-known/webfinger\"\n                \"?resource=acct%3Afoo%40example.com&rel=http%3A%2F%2Fopenid.net%2Fspecs%2Fconnect%2F1.0%2Fissuer\",\n                json=webfinger,\n            )\n            res = c.discover(principal)\n        assert res == \"https://localhost:8088/\"\n\n    def test_client_register(self):\n        c = Consumer(None, None)\n        c.redirect_uris = [\"https://example.com/authz\"]\n        reg_resp = {\n            \"client_id\": \"some_client\",\n            \"client_secret\": \"super_secret\",\n            \"client_secret_expires_at\": 123456789,\n            \"redirect_uris\": [\"https://example.com/authz\"],\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(responses.POST, \"https://example.com/register/\", json=reg_resp)\n            c.register(\"https://example.com/register/\")\n            assert json.loads(rsps.calls[0].request.body) == {\n                \"application_type\": \"web\",\n                \"response_types\": [\"code\"],\n                \"redirect_uris\": [\"https://example.com/authz\"],\n                \"grant_types\": [\"authorization_code\"],\n            }\n        assert c.client_id == \"some_client\"\n        assert c.client_secret == \"super_secret\"\n        assert c.registration_expires == 123456789\n\n    def test_client_register_token(self):\n        c = Consumer(None, None)\n\n        c.redirect_uris = [\"https://example.com/authz\"]\n\n        client_info = {\n            \"client_id\": \"clientid\",\n            \"redirect_uris\": [\"https://example.com/authz\"],\n        }\n\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                rsps.POST,\n                \"https://provider.example.com/registration/\",\n                json=client_info,\n            )\n            c.register(\n                \"https://provider.example.com/registration/\",\n                registration_token=\"initial_registration_token\",\n            )\n            header = rsps.calls[0].request.headers[\"Authorization\"]\n            assert header == \"Bearer aW5pdGlhbF9yZWdpc3RyYXRpb25fdG9rZW4=\"\n\n    def test_client_register_token_b64(self):\n        c = Consumer(None, None)\n\n        c.redirect_uris = [\"https://example.com/authz\"]\n\n        client_info = {\n            \"client_id\": \"clientid\",\n            \"redirect_uris\": [\"https://example.com/authz\"],\n        }\n        registration_token = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6IC\"\n            \"JlYjc1N2M3Yy00MWRlLTRmZDYtOTkwNy1hNGFiMDY1ZjEzMmEifQ.eyJqdGkiOiI2ZWY0MDZi\"\n            \"MC02YzA3LTQ0NzctOWU1YS1hY2FiZjNiMWNiMjgiLCJleHAiOjAsIm5iZiI6MCwiaWF0Ijox\"\n            \"NTczNzMxNjg5LCJpc3MiOiJodHRwczovL29wZW5pZC1wcm92aWRlci5leGFtcGxlLmNvbS9h\"\n            \"dXRoL3JlYWxtcy9tYXN0ZXIiLCJhdWQiOiJodHRwczovL29wZW5pZC1wcm92aWRlci5leGFt\"\n            \"cGxlLmNvbS9hdXRoL3JlYWxtcy9tYXN0ZXIiLCJ0eXAiOiJJbml0aWFsQWNjZXNzVG9rZW4i\"\n            \"fQ.0XTlit_JcxPZeIy8A4BzrHn1NvegVP7ws8KI0ySFex8\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                rsps.POST,\n                \"https://provider.example.com/registration/\",\n                json=client_info,\n            )\n            c.register(\n                \"https://provider.example.com/registration/\",\n                registration_token=registration_token,\n            )\n            header = rsps.calls[0].request.headers[\"Authorization\"]\n            assert header == \"Bearer \" + registration_token\n\n    def _faulty_id_token(self):\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://alpha.cloud.nds.rub.de\",\n            \"exp\": 1420823073,\n            \"iat\": 1420822473,\n            \"aud\": \"TestClient\",\n        }\n        idts = IdToken(**idval)\n\n        _signed_jwt = idts.to_jwt(key=[SYMKey(key=\"TestPassword\")], algorithm=\"HS256\")\n\n        # Mess with the signed id_token\n        p = _signed_jwt.split(\".\")\n        p[2] = \"aaa\"\n\n        return \".\".join(p)\n\n    def test_faulty_id_token(self):\n        _faulty_signed_jwt = self._faulty_id_token()\n\n        with pytest.raises(BadSignature):\n            IdToken().from_jwt(_faulty_signed_jwt, key=[SYMKey(key=\"TestPassword\")])\n\n        # What if no verification key is given ?\n        # Should also result in an exception\n        with pytest.raises(MissingSigningKey):\n            IdToken().from_jwt(_faulty_signed_jwt)\n\n    def test_faulty_id_token_in_access_token_response(self):\n        c = Consumer(None, None)\n        c.keyjar.add_symmetric(\"\", \"TestPassword\", [\"sig\"])\n\n        _info = {\n            \"access_token\": \"accessTok\",\n            \"id_token\": self._faulty_id_token(),\n            \"token_type\": \"Bearer\",\n        }\n\n        _json = json.dumps(_info)\n        with pytest.raises(ValueError):\n            c.parse_response(AccessTokenResponse, _json, sformat=\"json\")\n\n    def test_faulty_idtoken_from_accesstoken_endpoint(self):\n        _state = \"state0\"\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\"]\n\n        args = {\n            \"client_id\": self.consumer.client_id,\n            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n            \"scope\": [\"openid\"],\n        }\n\n        location = (\n            \"https://example.com/cb?state=state0&id_token=eyJhbGciOiJSUzI1NiJ9\"\n            \".eyJpc3MiOiAiaHR0cDovL2xvY2FsaG9zdDo4MDg4IiwgInN1YiI6ICJhNWRkMjRiMmYwOGE2ODZmZDM4NmMyMmM\"\n            \"zZmY4ZWUyODFlZjJmYmZmMWZkZTcwMDg2NjhjZGEzZGVjZmE0NjY5IiwgImF1ZCI6IFsiY2xpZW50XzEiXSwgImV\"\n            \"4cCI6IDE1NzIwOTk5NjAsICJhY3IiOiAiMiIsICJpYXQiOiAxNTcyMDEzNTYwLCAibm9uY2UiOiAibmdFTGZVdmN\"\n            \"PMWoyaXNWcXkwQWNwM0NOYlZnMGdFRDEifQ.aaa\"\n        )\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"https://example.com/authorization\",\n                status=302,\n                headers={\"location\": location},\n            )\n            result = self.consumer.do_authorization_request(\n                state=_state, request_args=args\n            )\n        self.consumer._backup(\"state0\")\n\n        assert result.status_code == 302\n        query = urlparse(result.headers[\"location\"]).query\n        with pytest.raises(BadSignature):\n            self.consumer.parse_authz(query=query)\n\n    def test_get_session_management_id(self):\n        now = utc_time_sans_frac()\n        smid = \"session_management_id\"\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://example.com\",\n            \"exp\": now + 3600,\n            \"iat\": now,\n            \"aud\": self.consumer.client_id,\n            \"sid\": smid,\n        }\n        idts = IdToken(**idval)\n\n        _signed_jwt = idts.to_jwt(key=KC_RSA.keys(), algorithm=\"RS256\")\n\n        _state = \"state\"\n        self.consumer.sdb[_state] = {\"redirect_uris\": [\"https://example.org/cb\"]}\n        resp = AuthorizationResponse(id_token=_signed_jwt, state=_state)\n        self.consumer.consumer_config[\"response_type\"] = [\"id_token\"]\n        self.consumer.authz_req[_state] = AccessTokenRequest(nonce=\"KUEYfRM2VzKDaaKD\")\n        self.consumer.parse_authz(resp.to_urlencoded())\n        assert self.consumer.sso_db[\"state\"][\"smid\"] == smid\n        assert session_get(self.consumer.sso_db, \"smid\", smid) == [_state]\n", "import os\nfrom time import time\n\nimport pytest\n\nfrom oic import rndstr\nfrom oic.exception import MessageException\nfrom oic.oic import AccessTokenResponse\nfrom oic.oic.consumer import Consumer\nfrom oic.oic.message import BACK_CHANNEL_LOGOUT_EVENT\nfrom oic.oic.message import AccessTokenRequest\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import BackChannelLogoutRequest\nfrom oic.oic.message import LogoutToken\nfrom oic.oic.provider import Provider\nfrom oic.utils.authn.authn_context import AuthnBroker\nfrom oic.utils.authn.client import CLIENT_AUTHN_METHOD\nfrom oic.utils.authn.client import verify_client\nfrom oic.utils.authn.user import UserAuthnMethod\nfrom oic.utils.authz import AuthzHandling\nfrom oic.utils.jwt import JWT\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.keyio import keybundle_from_local_file\nfrom oic.utils.sdb import session_update\nfrom oic.utils.session_backend import DictSessionBackend\nfrom oic.utils.userinfo import UserInfo\n\n# -- CLIENT INFO ----\n\nCLIENT_ID = \"client_1\"\nISSUER_ID = \"https://example.org\"\n\nKC_SYM_S = KeyBundle({\"kty\": \"oct\", \"key\": \"abcdefghijklmnop\", \"use\": \"sig\"})\n\nBASE_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), \"data/keys\"))\nKC_RSA = keybundle_from_local_file(\n    os.path.join(BASE_PATH, \"rsa.key\"), \"rsa\", [\"ver\", \"sig\"]\n)\n\nCLIKEYS = KeyJar()\nCLIKEYS[\"\"] = [KC_RSA, KC_SYM_S]\nCLIKEYS[CLIENT_ID] = [KC_RSA, KC_SYM_S]\nCLIKEYS[ISSUER_ID] = [KC_RSA]\n\nCONFIG = {\n    \"authz_page\": \"authz\",\n    \"scope\": [\"openid\"],\n    \"response_type\": \"code\",\n    \"password\": \"hemligt\",\n    \"max_age\": 3600,\n}\n\n# Provider information\n\nSERVER_INFO = {\n    \"version\": \"3.0\",\n    \"issuer\": ISSUER_ID,\n    \"authorization_endpoint\": \"https://example.org/authorization\",\n    \"token_endpoint\": \"https://example.org/token\",\n    \"flows_supported\": [\"code\", \"token\", \"code token\"],\n}\n\nSRVKEYS = KeyJar()\nSRVKEYS[\"\"] = [KC_RSA]\nSRVKEYS[CLIENT_ID] = [KC_SYM_S, KC_RSA]\nSRVKEYS[ISSUER_ID] = [KC_SYM_S, KC_RSA]\n\nCDB = {\n    CLIENT_ID: {\n        \"password\": \"hemligt\",\n        \"client_secret\": \"drickyoughurt\",\n        \"redirect_uris\": [(\"https://example.com/authz\", None)],\n        \"post_logout_redirect_uris\": [(\"https://example.com/post_logout\", None)],\n        \"client_salt\": \"salted\",\n        \"response_types\": [\"code\"],\n    }\n}\n\nUSERDB = {\n    \"username\": {\n        \"name\": \"Linda Lindgren\",\n        \"nickname\": \"Linda\",\n        \"email\": \"linda@example.com\",\n        \"verified\": True,\n        \"sub\": \"username\",\n        \"extra_claim\": \"extra_claim_value\",\n    }\n}\n\nURLMAP = {CLIENT_ID: [\"https://example.com/authz\"]}\n\n\nclass DummyAuthn(UserAuthnMethod):\n    def __init__(self, srv, user):\n        UserAuthnMethod.__init__(self, srv)\n        self.user = user\n\n    def authenticated_as(self, cookie=None, **kwargs):\n        if cookie == \"FAIL\":\n            return None, 0\n        else:\n            return {\"uid\": self.user}, time()\n\n\nAUTHN_BROKER = AuthnBroker()\nAUTHN_BROKER.add(\"UNDEFINED\", DummyAuthn(None, \"username\"))\n\n# dealing with authorization\nAUTHZ = AuthzHandling()\nSYMKEY = rndstr(16)  # symmetric key used to encrypt cookie info\nUSERINFO = UserInfo(USERDB)\n\n# AUTHZ request\n\nAREQ = AuthorizationRequest(\n    response_type=\"code\",\n    client_id=CLIENT_ID,\n    redirect_uri=\"https://example.com/authz\",\n    scope=[\"openid\"],\n    state=\"state000\",\n)\n\n\nclass TestOICConsumerLogout:\n    @pytest.fixture(autouse=True)\n    def setup_consumer(self, session_db_factory):\n        client_config = {\n            \"client_id\": CLIENT_ID,\n            \"client_authn_method\": CLIENT_AUTHN_METHOD,\n        }\n\n        self.consumer = Consumer(\n            DictSessionBackend(), CONFIG, client_config, SERVER_INFO\n        )\n        self.consumer.keyjar = CLIKEYS\n        self.consumer.redirect_uris = [\"https://example.com/authz\"]\n        self.consumer.client_secret = \"hemlig\"\n        self.consumer.secret_type = \"basic\"\n        self.consumer.issuer = ISSUER_ID\n\n        self.provider = Provider(\n            ISSUER_ID,\n            session_db_factory(ISSUER_ID),\n            CDB,\n            AUTHN_BROKER,\n            USERINFO,\n            AUTHZ,\n            verify_client,\n            SYMKEY,\n            urlmap=URLMAP,\n            keyjar=SRVKEYS,\n        )\n        self.provider.baseurl = self.provider.name\n\n    def test_logout_with_sub(self):\n        # Simulate an authorization\n        sid, request_location = self.consumer.begin(\n            \"openid\", \"code\", path=\"https://example.com\"\n        )\n        resp = self.provider.authorization_endpoint(request=request_location)\n        part = self.consumer.parse_authz(resp.message)\n        assert isinstance(part, tuple)\n        aresp = part[0]\n        assert aresp\n\n        assert self.consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n\n        # Simulate an accesstoken request\n        areq = AccessTokenRequest(\n            code=aresp[\"code\"],\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=self.consumer.client_secret,\n            grant_type=\"authorization_code\",\n        )\n        token_resp = self.provider.code_grant_type(areq)\n        tresp = self.consumer.parse_response(\n            AccessTokenResponse, token_resp.message, sformat=\"json\"\n        )\n\n        # Now, for the backchannel logout. This happens on the OP\n        logout_info = {\n            \"sub\": tresp[\"id_token\"][\"sub\"],\n            \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}},\n        }\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        _sid = self.consumer.backchannel_logout(request_args=request.to_dict())\n\n        assert _sid == sid\n\n        # Test other coding\n        _sid = self.consumer.backchannel_logout(request=request.to_urlencoded())\n        assert _sid == sid\n\n    def test_not_for_me(self):\n        _sub = \"sub\"\n\n        logout_info = {\"sub\": _sub, \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}}}\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=\"someone\", **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        with pytest.raises(MessageException):\n            self.consumer.backchannel_logout(request_args=request.to_dict())\n\n    def test_logout_without_sub(self):\n        # Simulate an authorization\n        sid, request_location = self.consumer.begin(\n            \"openid\", \"code\", path=\"https://example.com\"\n        )\n        resp = self.provider.authorization_endpoint(request=request_location)\n        part = self.consumer.parse_authz(resp.message)\n        assert isinstance(part, tuple)\n        aresp = part[0]\n        assert aresp\n\n        assert self.consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n\n        # Simulate an accesstoken request\n        areq = AccessTokenRequest(\n            code=aresp[\"code\"],\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=self.consumer.client_secret,\n            grant_type=\"authorization_code\",\n        )\n        token_resp = self.provider.code_grant_type(areq)\n        self.consumer.parse_response(\n            AccessTokenResponse, token_resp.message, sformat=\"json\"\n        )\n        # Have to fake this until the provider changes are in place\n        _smid = \"session_management_id\"\n        self.consumer.sso_db.update(sid, \"smid\", _smid)\n\n        # Now, for the backchannel logout. This happens on the OP\n        logout_info = {\"sid\": _smid, \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}}}\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        _sid = self.consumer.backchannel_logout(request_args=request.to_dict())\n\n        assert _sid == [sid]\n\n    def test_logout_with_none(self):\n        # Now for the backchannel logout. This happens on the OP\n\n        logout_info = LogoutToken(events={BACK_CHANNEL_LOGOUT_EVENT: {}})\n\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        with pytest.raises(MessageException):\n            self.consumer.backchannel_logout(request_args=request.to_dict())\n\n    def test_sso_db_dict(self):\n        client_config = {\n            \"client_id\": CLIENT_ID,\n            \"client_authn_method\": CLIENT_AUTHN_METHOD,\n        }\n\n        _consumer = Consumer({}, CONFIG, client_config, SERVER_INFO, sso_db={})\n        _consumer.keyjar = CLIKEYS\n        _consumer.redirect_uris = [\"https://example.com/authz\"]\n        _consumer.client_secret = \"hemlig\"\n        _consumer.secret_type = \"basic\"\n        _consumer.issuer = ISSUER_ID\n\n        # Simulate an authorization\n        sid, request_location = _consumer.begin(\n            \"openid\", \"code\", path=\"https://example.com\"\n        )\n        resp = self.provider.authorization_endpoint(request=request_location)\n        part = _consumer.parse_authz(resp.message)\n        assert isinstance(part, tuple)\n        aresp = part[0]\n        assert aresp\n\n        assert _consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n\n        # Simulate an accesstoken request\n        areq = AccessTokenRequest(\n            code=aresp[\"code\"],\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=_consumer.client_secret,\n            grant_type=\"authorization_code\",\n        )\n        token_resp = self.provider.code_grant_type(areq)\n        tresp = _consumer.parse_response(\n            AccessTokenResponse, token_resp.message, sformat=\"json\"\n        )\n\n        # Now, for the backchannel logout. This happens on the OP\n        logout_info = {\n            \"sub\": tresp[\"id_token\"][\"sub\"],\n            \"events\": {BACK_CHANNEL_LOGOUT_EVENT: {}},\n        }\n        alg = \"RS256\"\n        _jws = JWT(\n            self.provider.keyjar,\n            iss=self.provider.baseurl,\n            lifetime=86400,\n            sign_alg=alg,\n        )\n        logout_token = _jws.pack(aud=CLIENT_ID, **logout_info)\n\n        # The logout request that gets sent to the RP\n        request = BackChannelLogoutRequest(logout_token=logout_token)\n\n        # The RP evaluates the request. If everything is OK a session ID (== original state\n        # value) is returned.\n        _sid = _consumer.backchannel_logout(request_args=request.to_dict())\n        assert _sid == sid\n\n    def test_attribute_error(self):\n        self.consumer.sdb.update(\"sid\", \"foo\", \"bar\")\n        self.consumer.update(\"sid\")\n\n        with pytest.raises(AttributeError):\n            getattr(self.consumer, \"foo\")\n\n\ndef test_session_update():\n    with pytest.raises(KeyError):\n        session_update({}, \"session_id\", \"attr\", \"val\")\n", "import json\nimport os\nimport sys\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom freezegun import freeze_time\nfrom jwkest import BadSignature\nfrom jwkest.jwk import SYMKey\nfrom jwkest.jws import left_hash\n\nfrom oic import rndstr\nfrom oic.exception import MessageException\nfrom oic.exception import NotForMe\nfrom oic.oauth2.message import MissingRequiredAttribute\nfrom oic.oauth2.message import MissingRequiredValue\nfrom oic.oauth2.message import WrongSigningAlgorithm\nfrom oic.oic.message import BACK_CHANNEL_LOGOUT_EVENT\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AddressClaim\nfrom oic.oic.message import AtHashError\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import BackChannelLogoutRequest\nfrom oic.oic.message import CHashError\nfrom oic.oic.message import Claims\nfrom oic.oic.message import EXPError\nfrom oic.oic.message import FrontChannelLogoutRequest\nfrom oic.oic.message import IATError\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import LogoutToken\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import ProviderConfigurationResponse\nfrom oic.oic.message import RegistrationRequest\nfrom oic.oic.message import RegistrationResponse\nfrom oic.oic.message import VerificationError\nfrom oic.oic.message import address_deser\nfrom oic.oic.message import claims_deser\nfrom oic.oic.message import claims_ser\nfrom oic.oic.message import msg_ser\nfrom oic.oic.message import verify_id_token\nfrom oic.utils import time_util\nfrom oic.utils.jwt import JWT\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.time_util import utc_time_sans_frac\n\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\")))\n\n__author__ = \"rohe0002\"\n\n\ndef query_string_compare(query_str1, query_str2):\n    return parse_qs(query_str1) == parse_qs(query_str2)\n\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\ndef test_openidschema():\n    inp = '{\"middle_name\":null, \"updated_at\":\"20170328081544\", \"sub\":\"abc\"}'\n    ois = OpenIDSchema().from_json(inp)\n    assert ois.verify() is False\n\n\n@pytest.mark.parametrize(\n    \"json_param\",\n    [\n        '{\"middle_name\":\"fo\", \"updated_at\":\"20170328081544Z\", \"sub\":\"abc\"}',\n        '{\"middle_name\":true, \"updated_at\":\"20170328081544\", \"sub\":\"abc\"}',\n        '{\"middle_name\":\"fo\", \"updated_at\":false, \"sub\":\"abc\"}',\n        '{\"middle_name\":\"fo\", \"updated_at\":\"20170328081544Z\", \"sub\":true}',\n    ],\n)\ndef test_openidschema_from_json(json_param):\n    with pytest.raises(MessageException):\n        OpenIDSchema().from_json(json_param)\n\n\n@pytest.mark.parametrize(\n    \"json_param\",\n    [\n        '{\"email_verified\":false, \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"email_verified\":true, \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"phone_number_verified\":false, \"phone_number\":\"+1 555 200000\", '\n        '\"sub\":\"abc\"}',\n        '{\"phone_number_verified\":true, \"phone_number\":\"+1 555 20000\", ' '\"sub\":\"abc\"}',\n    ],\n)\ndef test_claim_booleans(json_param):\n    assert OpenIDSchema().from_json(json_param)\n\n\n@pytest.mark.parametrize(\n    \"json_param\",\n    [\n        '{\"email_verified\":\"Not\", \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"email_verified\":\"Sure\", \"email\":\"foo@example.com\", \"sub\":\"abc\"}',\n        '{\"phone_number_verified\":\"Not\", \"phone_number\":\"+1 555 200000\", '\n        '\"sub\":\"abc\"}',\n        '{\"phone_number_verified\":\"Sure\", \"phone_number\":\"+1 555 20000\", '\n        '\"sub\":\"abc\"}',\n    ],\n)\ndef test_claim_not_booleans(json_param):\n    with pytest.raises(MessageException):\n        OpenIDSchema().from_json(json_param)\n\n\ndef test_claims_deser():\n    _dic = {\n        \"userinfo\": {\n            \"given_name\": {\"essential\": True},\n            \"nickname\": None,\n            \"email\": {\"essential\": True},\n            \"email_verified\": {\"essential\": True},\n            \"picture\": None,\n            \"http://example.info/claims/groups\": None,\n        },\n        \"id_token\": {\n            \"auth_time\": {\"essential\": True},\n            \"acr\": {\"values\": [\"urn:mace:incommon:iap:silver\"]},\n        },\n    }\n\n    claims = claims_deser(json.dumps(_dic), sformat=\"json\")\n    assert _eq(claims.keys(), [\"userinfo\", \"id_token\"])\n\n\ndef test_claims_deser_dict():\n    pre = Claims(\n        name={\"essential\": True},\n        nickname=None,\n        email={\"essential\": True},\n        email_verified={\"essential\": True},\n        picture=None,\n    )\n\n    claims = claims_deser(pre.to_json(), sformat=\"json\")\n    assert _eq(\n        claims.keys(), [\"name\", \"nickname\", \"email\", \"email_verified\", \"picture\"]\n    )\n\n    claims = claims_deser(pre.to_dict(), sformat=\"dict\")\n    assert _eq(\n        claims.keys(), [\"name\", \"nickname\", \"email\", \"email_verified\", \"picture\"]\n    )\n\n\ndef test_address_deser():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    adc = address_deser(pre.to_json(), sformat=\"json\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n    adc = address_deser(pre.to_dict(), sformat=\"json\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_json():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    ser = msg_ser(pre, \"json\")\n\n    adc = address_deser(ser, \"json\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_urlencoded():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    ser = msg_ser(pre, \"urlencoded\")\n\n    adc = address_deser(ser, \"urlencoded\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_dict():\n    pre = AddressClaim(street_address=\"Kasamark 114\", locality=\"Umea\", country=\"Sweden\")\n\n    ser = msg_ser(pre, \"dict\")\n\n    adc = address_deser(ser, \"dict\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_msg_ser_from_dict():\n    pre = {\"street_address\": \"Kasamark 114\", \"locality\": \"Umea\", \"country\": \"Sweden\"}\n\n    ser = msg_ser(pre, \"dict\")\n\n    adc = address_deser(ser, \"dict\")\n    assert _eq(adc.keys(), [\"street_address\", \"locality\", \"country\"])\n\n\ndef test_claims_ser_json():\n    claims = Claims(\n        name={\"essential\": True},\n        nickname=None,\n        email={\"essential\": True},\n        email_verified={\"essential\": True},\n        picture=None,\n    )\n    claims = claims_deser(claims_ser(claims, \"json\"), sformat=\"json\")\n    assert _eq(\n        claims.keys(), [\"name\", \"nickname\", \"email\", \"email_verified\", \"picture\"]\n    )\n\n\nclass TestProviderConfigurationResponse(object):\n    def test_deserialize(self):\n        resp = {\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"issuer\": \"https://server.example.com\",\n            \"token_endpoint\": \"https://server.example.com/connect/token\",\n            \"token_endpoint_auth_methods_supported\": [\n                \"client_secret_basic\",\n                \"private_key_jwt\",\n            ],\n            \"userinfo_endpoint\": \"https://server.example.com/connect/user\",\n            \"check_id_endpoint\": \"https://server.example.com/connect/check_id\",\n            \"refresh_session_endpoint\": \"https://server.example.com/connect/refresh_session\",\n            \"end_session_endpoint\": \"https://server.example.com/connect/end_session\",\n            \"jwk_url\": \"https://server.example.com/jwk.json\",\n            \"registration_endpoint\": \"https://server.example.com/connect/register\",\n            \"scopes_supported\": [\"openid\", \"profile\", \"email\", \"address\", \"phone\"],\n            \"response_types_supported\": [\"code\", \"code id_token\", \"token id_token\"],\n            \"acrs_supported\": [\"1\", \"2\", \"http://id.incommon.org/assurance/bronze\"],\n            \"user_id_types_supported\": [\"public\", \"pairwise\"],\n            \"userinfo_algs_supported\": [\n                \"HS256\",\n                \"RS256\",\n                \"A128CBC\",\n                \"A128KW\",\n                \"RSA1_5\",\n            ],\n            \"id_token_algs_supported\": [\n                \"HS256\",\n                \"RS256\",\n                \"A128CBC\",\n                \"A128KW\",\n                \"RSA1_5\",\n            ],\n            \"request_object_algs_supported\": [\n                \"HS256\",\n                \"RS256\",\n                \"A128CBC\",\n                \"A128KW\",\n                \"RSA1_5\",\n            ],\n        }\n\n        pcr = ProviderConfigurationResponse().deserialize(json.dumps(resp), \"json\")\n\n        assert _eq(pcr[\"user_id_types_supported\"], [\"public\", \"pairwise\"])\n        assert _eq(\n            pcr[\"acrs_supported\"], [\"1\", \"2\", \"http://id.incommon.org/assurance/bronze\"]\n        )\n\n    def test_example_response(self):\n        resp = {\n            \"version\": \"3.0\",\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"token_endpoint\": \"https://server.example.com/connect/token\",\n            \"token_endpoint_auth_methods_supported\": [\n                \"client_secret_basic\",\n                \"private_key_jwt\",\n            ],\n            \"token_endpoint_alg_values_supported\": [\"RS256\", \"ES256\"],\n            \"userinfo_endpoint\": \"https://server.example.com/connect/userinfo\",\n            \"check_session_iframe\": \"https://server.example.com/connect/check_session\",\n            \"end_session_endpoint\": \"https://server.example.com/connect/end_session\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"registration_endpoint\": \"https://server.example.com/connect/register\",\n            \"scopes_supported\": [\n                \"openid\",\n                \"profile\",\n                \"email\",\n                \"address\",\n                \"phone\",\n                \"offline_access\",\n            ],\n            \"response_types_supported\": [\n                \"code\",\n                \"code id_token\",\n                \"id_token\",\n                \"token id_token\",\n            ],\n            \"acr_values_supported\": [\n                \"urn:mace:incommon:iap:silver\",\n                \"urn:mace:incommon:iap:bronze\",\n            ],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"userinfo_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n            \"userinfo_encryption_alg_values_supported\": [\"RSA1_5\", \"A128KW\"],\n            \"userinfo_encryption_enc_values_supported\": [\"A128CBC+HS256\", \"A128GCM\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n            \"id_token_encryption_alg_values_supported\": [\"RSA1_5\", \"A128KW\"],\n            \"id_token_encryption_enc_values_supported\": [\"A128CBC+HS256\", \"A128GCM\"],\n            \"request_object_signing_alg_values_supported\": [\"none\", \"RS256\", \"ES256\"],\n            \"display_values_supported\": [\"page\", \"popup\"],\n            \"claim_types_supported\": [\"normal\", \"distributed\"],\n            \"claims_supported\": [\n                \"sub\",\n                \"iss\",\n                \"auth_time\",\n                \"acr\",\n                \"name\",\n                \"given_name\",\n                \"family_name\",\n                \"nickname\",\n                \"profile\",\n                \"picture\",\n                \"website\",\n                \"email\",\n                \"email_verified\",\n                \"locale\",\n                \"zoneinfo\",\n                \"http://example.info/claims/groups\",\n            ],\n            \"claims_parameter_supported\": True,\n            \"service_documentation\": \"http://server.example.com/connect/service_documentation.html\",\n            \"ui_locales_supported\": [\"en-US\", \"en-GB\", \"en-CA\", \"fr-FR\", \"fr-CA\"],\n        }\n\n        pcr = ProviderConfigurationResponse().deserialize(json.dumps(resp), \"json\")\n        rk = list(resp.keys())\n        # parameters with default value if missing\n        rk.extend(\n            [\n                \"grant_types_supported\",\n                \"request_parameter_supported\",\n                \"request_uri_parameter_supported\",\n                \"require_request_uri_registration\",\n                \"frontchannel_logout_supported\",\n                \"frontchannel_logout_session_supported\",\n                \"backchannel_logout_supported\",\n                \"backchannel_logout_session_supported\",\n            ]\n        )\n        assert set(rk) == set(pcr.keys())\n\n    @pytest.mark.parametrize(\n        \"required_param\",\n        [\n            \"issuer\",\n            \"authorization_endpoint\",\n            \"jwks_uri\",\n            \"response_types_supported\",\n            \"subject_types_supported\",\n            \"id_token_signing_alg_values_supported\",\n        ],\n    )\n    def test_required_parameters(self, required_param):\n        provider_config = {\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"response_types_supported\": [\n                \"code\",\n                \"code id_token\",\n                \"id_token\",\n                \"token id_token\",\n            ],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n        }\n\n        del provider_config[required_param]\n        with pytest.raises(MissingRequiredAttribute):\n            ProviderConfigurationResponse(**provider_config).verify()\n\n    def test_token_endpoint_is_not_required_for_implicit_flow_only(self):\n        provider_config = {\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"response_types_supported\": [\"id_token\", \"token id_token\"],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n        }\n\n        # should not raise an exception\n        assert ProviderConfigurationResponse(**provider_config).verify()\n\n    def test_token_endpoint_is_required_for_other_than_implicit_flow_only(self):\n        provider_config = {\n            \"issuer\": \"https://server.example.com\",\n            \"authorization_endpoint\": \"https://server.example.com/connect/authorize\",\n            \"jwks_uri\": \"https://server.example.com/jwks.json\",\n            \"response_types_supported\": [\"code\", \"id_token\"],\n            \"subject_types_supported\": [\"public\", \"pairwise\"],\n            \"id_token_signing_alg_values_supported\": [\"RS256\", \"ES256\", \"HS256\"],\n        }\n\n        with pytest.raises(MissingRequiredAttribute):\n            ProviderConfigurationResponse(**provider_config).verify()\n\n\nclass TestRegistrationRequest(object):\n    def test_deserialize(self):\n        msg = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\n                \"https://client.example.org/callback\",\n                \"https://client.example.org/callback2\",\n            ],\n            \"client_name\": \"My Example\",\n            \"client_name#ja-Jpan-JP\": \"\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u540d\",\n            \"logo_uri\": \"https://client.example.org/logo.png\",\n            \"subject_type\": \"pairwise\",\n            \"sector_identifier_uri\": \"https://other.example.net/file_of_redirect_uris.json\",\n            \"token_endpoint_auth_method\": \"client_secret_basic\",\n            \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n            \"userinfo_encrypted_response_alg\": \"RSA1_5\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC+HS256\",\n            \"contacts\": [\"ve7jtb@example.org\", \"mary@example.org\"],\n            \"request_uris\": [\n                \"https://client.example.org/rf.txt\"\n                \"#qpXaRLh_n93TTR9F252ValdatUQvQiJi5BDub2BeznA\"\n            ],\n        }\n\n        reg = RegistrationRequest().deserialize(json.dumps(msg), \"json\")\n        assert _eq(list(msg.keys()) + [\"response_types\"], reg.keys())\n\n    def test_registration_request(self):\n        req = RegistrationRequest(\n            operation=\"register\",\n            default_max_age=10,\n            require_auth_time=True,\n            default_acr=\"foo\",\n            application_type=\"web\",\n            redirect_uris=[\"https://example.com/authz_cb\"],\n        )\n        js = req.to_json()\n        js_obj = json.loads(js)\n        expected_js_obj = {\n            \"redirect_uris\": [\"https://example.com/authz_cb\"],\n            \"application_type\": \"web\",\n            \"default_acr\": \"foo\",\n            \"require_auth_time\": True,\n            \"operation\": \"register\",\n            \"default_max_age\": 10,\n            \"response_types\": [\"code\"],\n        }\n        assert js_obj == expected_js_obj\n\n        flattened_list_dict = {\n            k: v[0] if isinstance(v, list) else v for k, v in expected_js_obj.items()\n        }\n        assert query_string_compare(req.to_urlencoded(), urlencode(flattened_list_dict))\n\n    @pytest.mark.parametrize(\n        \"enc_param\",\n        [\n            \"request_object_encryption_enc\",\n            \"id_token_encrypted_response_enc\",\n            \"userinfo_encrypted_response_enc\",\n        ],\n    )\n    def test_registration_request_with_coupled_encryption_params(self, enc_param):\n        registration_params = {\n            \"redirect_uris\": [\"https://example.com/authz_cb\"],\n            enc_param: \"RS25asdasd6\",\n        }\n        registration_req = RegistrationRequest(**registration_params)\n        with pytest.raises(AssertionError):\n            registration_req.verify()\n\n\nclass TestRegistrationResponse(object):\n    def test_deserialize(self):\n        msg = {\n            \"client_id\": \"s6BhdRkqt3\",\n            \"client_secret\": \"ZJYCqe3GGRvdrudKyZS0XhGv_Z45DuKhCUk0gBR1vZk\",\n            \"client_secret_expires_at\": 1577858400,\n            \"registration_access_token\": \"this.is.an.access.token.value.ffx83\",\n            \"registration_client_uri\": \"https://server.example.com/connect/register?client_id\"\n            \"=s6BhdRkqt3\",\n            \"token_endpoint_auth_method\": \"client_secret_basic\",\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\n                \"https://client.example.org/callback\",\n                \"https://client.example.org/callback2\",\n            ],\n            \"client_name\": \"My Example\",\n            \"client_name#ja-Jpan-JP\": \"\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u540d\",\n            \"logo_uri\": \"https://client.example.org/logo.png\",\n            \"subject_type\": \"pairwise\",\n            \"sector_identifier_uri\": \"https://other.example.net/file_of_redirect_uris.json\",\n            \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n            \"userinfo_encrypted_response_alg\": \"RSA1_5\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC+HS256\",\n            \"contacts\": [\"ve7jtb@example.org\", \"mary@example.org\"],\n            \"request_uris\": [\n                \"https://client.example.org/rf.txt\"\n                \"#qpXaRLh_n93TTR9F252ValdatUQvQiJi5BDub2BeznA\"\n            ],\n        }\n\n        resp = RegistrationResponse().deserialize(json.dumps(msg), \"json\")\n        assert _eq(msg.keys(), resp.keys())\n\n\nclass TestAuthorizationRequest(object):\n    def test_deserialize(self):\n        query = (\n            \"response_type=token%20id_token&client_id=0acf77d4-b486-4c99\"\n            \"-bd76-074ed6a64ddf&redirect_uri=https%3A%2F%2Fclient.example\"\n            \".com%2Fcb&scope=openid%20profile&state=af0ifjsldkj&nonce=n\"\n            \"-0S6_WzA2Mj\"\n        )\n\n        req = AuthorizationRequest().deserialize(query, \"urlencoded\")\n\n        assert _eq(\n            req.keys(),\n            [\"nonce\", \"state\", \"redirect_uri\", \"response_type\", \"client_id\", \"scope\"],\n        )\n\n        assert req[\"response_type\"] == [\"token\", \"id_token\"]\n        assert req[\"scope\"] == [\"openid\", \"profile\"]\n\n    def test_verify_no_scopes(self):\n        args = {\n            \"client_id\": \"foobar\",\n            \"redirect_uri\": \"http://foobar.example.com/oaclient\",\n            \"response_type\": \"code\",\n        }\n        ar = AuthorizationRequest(**args)\n        with pytest.raises(MissingRequiredAttribute):\n            ar.verify()\n\n\nclass TestAuthorizationResponse(object):\n    def test_verify_token_type(self):\n        args = {\"access_token\": \"foobar\", \"token_type\": \"bearer\"}\n        ar = AuthorizationResponse(**args)\n        ar.verify()\n\n        args = {\"access_token\": \"foobar\"}\n        ar = AuthorizationResponse(**args)\n        with pytest.raises(MissingRequiredValue):\n            ar.verify()\n\n\nclass TestAccessTokenResponse(object):\n    def test_faulty_idtoken(self):\n        _now = time_util.utc_time_sans_frac()\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://alpha.cloud.nds.rub.de\",\n            \"exp\": _now + 3600,\n            \"iat\": _now,\n            \"aud\": \"TestClient\",\n        }\n        idts = IdToken(**idval)\n        key = SYMKey(key=\"TestPassword\")\n        _signed_jwt = idts.to_jwt(key=[key], algorithm=\"HS256\")\n\n        # Mess with the signed id_token\n        p = _signed_jwt.split(\".\")\n        p[2] = \"aaa\"\n        _faulty_signed_jwt = \".\".join(p)\n\n        _info = {\n            \"access_token\": \"accessTok\",\n            \"id_token\": _faulty_signed_jwt,\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600,\n        }\n\n        at = AccessTokenResponse(**_info)\n        with pytest.raises(BadSignature):\n            at.verify(key=[key])\n\n    def test_wrong_alg(self):\n        _now = time_util.utc_time_sans_frac()\n        idval = {\n            \"nonce\": \"KUEYfRM2VzKDaaKD\",\n            \"sub\": \"EndUserSubject\",\n            \"iss\": \"https://alpha.cloud.nds.rub.de\",\n            \"exp\": _now + 3600,\n            \"iat\": _now,\n            \"aud\": \"TestClient\",\n        }\n        idts = IdToken(**idval)\n        key = SYMKey(key=\"TestPassword\")\n        _signed_jwt = idts.to_jwt(key=[key], algorithm=\"HS256\")\n\n        _info = {\n            \"access_token\": \"accessTok\",\n            \"id_token\": _signed_jwt,\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600,\n        }\n\n        at = AccessTokenResponse(**_info)\n        with pytest.raises(WrongSigningAlgorithm):\n            at.verify(key=[key], algs={\"sign\": \"HS512\"})\n\n    def test_token_type(self):\n        # lacks required token_type parameter\n        _info = {\"access_token\": \"accessTok\", \"id_token\": \"blabla\"}\n        at = AccessTokenResponse(**_info)\n        with pytest.raises(MissingRequiredAttribute):\n            at.verify()\n\n\nclass TestIdToken(object):\n    \"\"\"Unittests for IdToken class.\"\"\"\n\n    @freeze_time(\"2020-01-01 11:00:00\")\n    def test_verify_iat_in_future(self):\n        now = time_util.utc_time_sans_frac()\n\n        idt = IdToken(\n            **{\n                \"sub\": \"553df2bcf909104751cfd8b2\",\n                \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n                \"auth_time\": 1441364872,\n                \"azp\": \"554295ce3770612820620000\",\n                \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n                \"iat\": now + 7200,\n                \"exp\": now + 3600,\n                \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            }\n        )\n\n        with pytest.raises(IATError):\n            idt.verify()\n\n    @freeze_time(\"2020-01-01 11:00:00\")\n    def test_verify_iat_in_future_expired(self):\n        now = time_util.utc_time_sans_frac()\n\n        idt = IdToken(\n            **{\n                \"sub\": \"553df2bcf909104751cfd8b2\",\n                \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n                \"auth_time\": 1441364872,\n                \"azp\": \"554295ce3770612820620000\",\n                \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n                \"iat\": now + 3600,\n                \"exp\": now,\n                \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            }\n        )\n\n        with pytest.raises(EXPError):\n            idt.verify(skew=7200)\n\n    @freeze_time(\"2020-01-01 11:00:00\")\n    def test_verify_iat_in_future_skew(self):\n        now = time_util.utc_time_sans_frac()\n\n        idt = IdToken(\n            **{\n                \"sub\": \"553df2bcf909104751cfd8b2\",\n                \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n                \"auth_time\": 1441364872,\n                \"azp\": \"554295ce3770612820620000\",\n                \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n                \"iat\": now + 7200,\n                \"exp\": now + 7600,\n                \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            }\n        )\n\n        idt.verify(skew=7200)\n\n\ndef test_id_token():\n    _now = time_util.utc_time_sans_frac()\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n            \"iat\": _now,\n            \"exp\": _now + 3600,\n            \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        }\n    )\n\n    idt.verify()\n\n\ndef test_verify_id_token():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    vidt = verify_id_token(\n        msg,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n    assert vidt\n\n\ndef test_verify_id_token_wrong_issuer():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", iss=\"https://example.com/as\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_wrong_aud():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", iss=\"https://example.com/as\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"aaaaaaaaaaaaaaaaaaaa\",\n        )\n\n\ndef test_verify_id_token_mismatch_aud_azp():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"aaaaaaaaaaaaaaaaaaaa\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", iss=\"https://example.com/as\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"aaaaaaaaaaaaaaaaaaaa\",\n        )\n\n\ndef test_verify_id_token_c_hash():\n    code = \"AccessCode1\"\n    lhsh = left_hash(code)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"c_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(code=code, id_token=_jws)\n    verify_id_token(\n        msg,\n        check_hash=True,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n\n\ndef test_verify_id_token_c_hash_fail():\n    code = \"AccessCode1\"\n    lhsh = left_hash(code)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"c_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(code=\"AccessCode289\", id_token=_jws)\n    with pytest.raises(CHashError):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_at_hash():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n    lhsh = left_hash(token)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token, id_token=_jws)\n    verify_id_token(\n        msg,\n        check_hash=True,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n\n\ndef test_verify_id_token_at_hash_fail():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n    token2 = \"ACompletelyOtherAccessToken\"\n    lhsh = left_hash(token)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": lhsh,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token2, id_token=_jws)\n    with pytest.raises(AtHashError):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_missing_at_hash():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token, id_token=_jws)\n    with pytest.raises(MissingRequiredAttribute):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_missing_c_hash():\n    code = \"AccessCode1\"\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(code=code, id_token=_jws)\n    with pytest.raises(MissingRequiredAttribute):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_at_hash_and_chash():\n    token = \"AccessTokenWhichCouldBeASignedJWT\"\n    at_hash = left_hash(token)\n    code = \"AccessCode1\"\n    c_hash = left_hash(code)\n\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n            \"at_hash\": at_hash,\n            \"c_hash\": c_hash,\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(\n        kj,\n        sign_alg=\"HS256\",\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        lifetime=3600,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(access_token=token, id_token=_jws, code=code)\n    verify_id_token(\n        msg,\n        check_hash=True,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n\n\ndef test_verify_id_token_missing_iss():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", lifetime=3600)\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(MissingRequiredAttribute):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_id_token_iss_not_in_keyjar():\n    idt = IdToken(\n        **{\n            \"sub\": \"553df2bcf909104751cfd8b2\",\n            \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n            \"auth_time\": 1441364872,\n            \"azp\": \"554295ce3770612820620000\",\n        }\n    )\n\n    kj = KeyJar()\n    kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n    kj.add_symmetric(\n        \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\",\n        [\"sig\"],\n    )\n    packer = JWT(kj, sign_alg=\"HS256\", lifetime=3600, iss=\"https://example.com/op\")\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    with pytest.raises(ValueError):\n        verify_id_token(\n            msg,\n            check_hash=True,\n            keyjar=kj,\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\ndef test_verify_token_encrypted():\n    idt = IdToken(\n        sub=\"553df2bcf909104751cfd8b2\",\n        aud=[\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n        auth_time=1441364872,\n        azp=\"554295ce3770612820620000\",\n    )\n    kj = KeyJar()\n    kb = KeyBundle()\n    kb.do_local_der(\n        os.path.join(os.path.dirname(__file__), \"data\", \"keys\", \"cert.key\"),\n        \"some\",\n        [\"enc\", \"sig\"],\n    )\n    kj.add_kb(\"\", kb)\n    kj.add_kb(\"https://sso.qa.7pass.ctf.prosiebensat1.com\", kb)\n\n    packer = JWT(\n        kj,\n        lifetime=3600,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        encrypt=True,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    vidt = verify_id_token(\n        msg,\n        keyjar=kj,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        client_id=\"554295ce3770612820620000\",\n    )\n    assert vidt\n    assert vidt.jwe_header == {\"enc\": \"A128CBC-HS256\", \"alg\": \"RSA1_5\", \"cty\": \"JWT\"}\n\n\ndef test_verify_token_encrypted_no_key():\n    idt = IdToken(\n        sub=\"553df2bcf909104751cfd8b2\",\n        aud=[\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n        auth_time=1441364872,\n        azp=\"554295ce3770612820620000\",\n    )\n    kj = KeyJar()\n    kb = KeyBundle()\n    kb.do_local_der(\n        os.path.join(os.path.dirname(__file__), \"data\", \"keys\", \"cert.key\"),\n        \"some\",\n        [\"enc\", \"sig\"],\n    )\n    kj.add_kb(\"\", kb)\n    kj.add_kb(\"https://sso.qa.7pass.ctf.prosiebensat1.com\", kb)\n\n    packer = JWT(\n        kj,\n        lifetime=3600,\n        iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n        encrypt=True,\n    )\n    _jws = packer.pack(**idt.to_dict())\n    msg = AuthorizationResponse(id_token=_jws)\n    # Do not pass they keyjar with keys\n    with pytest.raises(VerificationError):\n        verify_id_token(\n            msg,\n            keyjar=KeyJar(),\n            iss=\"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n            client_id=\"554295ce3770612820620000\",\n        )\n\n\nclass TestLogoutToken:\n    def test_with_sub(self):\n        # All the required claims. Note there must be a sub, a sid or both\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        assert lt.verify()\n\n    def test_with_sid(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sid=rndstr(),\n        )\n\n        assert lt.verify()\n\n    def test_with_sub_and_sid(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n            sid=rndstr(),\n        )\n\n        assert lt.verify()\n\n    def test_no_sub_or_sid(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_with_nonce(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            nonce=rndstr(16),\n        )\n\n        with pytest.raises(MessageException):\n            lt.verify()\n\n    def test_extra_event(self):\n        # more the one event\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={\n                BACK_CHANNEL_LOGOUT_EVENT: {},\n                \"http://schemas.openid.net/event/other}\": {},\n            },\n            jti=rndstr(16),\n            iat=utc_time_sans_frac(),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_wrong_event(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={\"http://schemas.openid.net/event/other}\": {}},\n            jti=rndstr(16),\n            iat=utc_time_sans_frac(),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_wrong_event_content(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {\"foo\": \"bar\"}},\n            jti=rndstr(16),\n            iat=utc_time_sans_frac(),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n    def test_wrong_aud(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(NotForMe):\n            lt.verify(aud=\"https://example.com\")\n\n    def test_wrong_iss(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(NotForMe):\n            lt.verify(iss=\"https://rp.example.org\")\n\n    def test_wrong_iat(self):\n        # Issued sometime in the future\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac() + 86400,\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        with pytest.raises(ValueError):\n            lt.verify()\n\n\nclass TestBackchannelLogout(object):\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        self.kj = KeyJar()\n        self.kj.add_symmetric(\"\", \"dYMmrcQksKaPkhdgRNYk3zzh5l7ewdDJ\", [\"sig\"])\n        self.key = self.kj.get_signing_key(\"oct\")\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            sub=\"https://example.com/sub\",\n        )\n\n        self.signed_jwt = lt.to_jwt(key=self.key, algorithm=\"HS256\")\n\n    def test_verify_with_keyjar(self):\n        bclr = BackChannelLogoutRequest(logout_token=self.signed_jwt)\n        assert bclr.verify(keyjar=self.kj)\n\n        # The signed JWT is replaced by a dictionary with all the verified values\n        assert bclr[\"logout_token\"][\"iss\"] == \"https://example.com\"\n\n    def test_verify_with_key(self):\n        bclr = BackChannelLogoutRequest(logout_token=self.signed_jwt)\n        assert bclr.verify(key=self.key)\n\n        # The signed JWT is replaced by a dictionary with all the verified values\n        assert bclr[\"logout_token\"][\"iss\"] == \"https://example.com\"\n\n    def test_bogus_logout_token(self):\n        lt = LogoutToken(\n            iss=\"https://example.com\",\n            aud=[\"https://rp.example.org\"],\n            events={BACK_CHANNEL_LOGOUT_EVENT: {}},\n            iat=utc_time_sans_frac(),\n            jti=rndstr(16),\n            nonce=rndstr(16),\n        )\n        signed_jwt = lt.to_jwt(key=self.key, algorithm=\"HS256\")\n        bclr = BackChannelLogoutRequest(logout_token=signed_jwt)\n\n        with pytest.raises(MessageException):\n            bclr.verify(key=self.key)\n\n\nclass TestFrontchannelLogout(object):\n    def test_verify_request(self):\n        # May be completely empty\n        fclr = FrontChannelLogoutRequest()\n\n        assert fclr.verify()\n", "import datetime\nimport json\nimport logging\nimport os\nfrom http.cookies import SimpleCookie\nfrom time import time\nfrom typing import Any\nfrom typing import Dict\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nfrom urllib.parse import parse_qs\nfrom urllib.parse import urlparse\n\nimport pytest\nimport responses\nfrom freezegun import freeze_time\nfrom jwkest.jwe import JWEException\nfrom jwkest.jwe import JWEnc\nfrom requests import ConnectionError\nfrom requests.exceptions import MissingSchema\nfrom testfixtures import LogCapture\n\nfrom oic import rndstr\nfrom oic.exception import FailedAuthentication\nfrom oic.exception import InvalidRequest\nfrom oic.exception import RedirectURIError\nfrom oic.oauth2.message import ErrorResponse\nfrom oic.oic import DEF_SIGN_ALG\nfrom oic.oic import make_openid_request\nfrom oic.oic.consumer import Consumer\nfrom oic.oic.message import AccessTokenRequest\nfrom oic.oic.message import AccessTokenResponse\nfrom oic.oic.message import AuthorizationRequest\nfrom oic.oic.message import AuthorizationResponse\nfrom oic.oic.message import CheckSessionRequest\nfrom oic.oic.message import Claims\nfrom oic.oic.message import ClaimsRequest\nfrom oic.oic.message import IdToken\nfrom oic.oic.message import Message\nfrom oic.oic.message import OpenIDSchema\nfrom oic.oic.message import ProviderConfigurationResponse\nfrom oic.oic.message import RefreshAccessTokenRequest\nfrom oic.oic.message import RegistrationRequest\nfrom oic.oic.message import RegistrationResponse\nfrom oic.oic.message import TokenErrorResponse\nfrom oic.oic.message import UserInfoRequest\nfrom oic.oic.provider import InvalidRedirectURIError\nfrom oic.oic.provider import InvalidSectorIdentifier\nfrom oic.oic.provider import Provider\nfrom oic.utils.authn.authn_context import AuthnBroker\nfrom oic.utils.authn.client import verify_client\nfrom oic.utils.authn.user import UserAuthnMethod\nfrom oic.utils.authz import AuthzHandling\nfrom oic.utils.http_util import CookieDealer\nfrom oic.utils.http_util import Response\nfrom oic.utils.keyio import KeyBundle\nfrom oic.utils.keyio import KeyJar\nfrom oic.utils.keyio import ec_init\nfrom oic.utils.keyio import keybundle_from_local_file\nfrom oic.utils.sdb import AuthnEvent\nfrom oic.utils.session_backend import DictSessionBackend\nfrom oic.utils.time_util import epoch_in_a_while\nfrom oic.utils.userinfo import UserInfo\n\n__author__ = \"rohe0002\"\n\nCONSUMER_CONFIG = {\n    \"authz_page\": \"/authz\",\n    \"scope\": [\"openid\"],\n    \"response_type\": [\"code\"],\n    \"user_info\": {\"name\": None, \"email\": None, \"nickname\": None},\n    \"request_method\": \"param\",\n}\n\nSERVER_INFO = {\n    \"version\": \"3.0\",\n    \"issuer\": \"https://connect-op.heroku.com\",\n    \"authorization_endpoint\": \"http://localhost:8088/authorization\",\n    \"token_endpoint\": \"http://localhost:8088/token\",\n    \"flows_supported\": [\"code\", \"token\", \"code token\"],\n}\n\nCLIENT_CONFIG = {\"client_id\": \"number5\", \"config\": {\"issuer\": SERVER_INFO[\"issuer\"]}}\n\nCLIENT_CONFIG_2 = {\"client_id\": \"client0\", \"config\": {\"issuer\": SERVER_INFO[\"issuer\"]}}\n\nCLIENT_SECRET = \"abcdefghijklmnop\"\nCLIENT_ID = \"client_1\"\n\nKC_SYM = KeyBundle(\n    [\n        {\"kty\": \"oct\", \"key\": CLIENT_SECRET, \"use\": \"ver\"},\n        {\"kty\": \"oct\", \"key\": CLIENT_SECRET, \"use\": \"sig\"},\n    ]\n)\nKC_SYM2 = KeyBundle(\n    [\n        {\"kty\": \"oct\", \"key\": \"drickyoughurt\", \"use\": \"sig\"},\n        {\"kty\": \"oct\", \"key\": \"drickyoughurt\", \"use\": \"ver\"},\n    ]\n)\n\nBASE_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), \"data/keys\"))\nKC_RSA = keybundle_from_local_file(\n    os.path.join(BASE_PATH, \"rsa.key\"), \"RSA\", [\"ver\", \"sig\"]\n)\n\nKEYJAR = KeyJar()\nKEYJAR[CLIENT_ID] = [KC_SYM, KC_RSA]\nKEYJAR[\"number5\"] = [KC_SYM2, KC_RSA]\nKEYJAR[\"\"] = KC_RSA\nKEYJAR[\"https://connect-op.heroku.com\"] = KC_RSA\n\nCDB: Dict[str, Dict[str, Any]] = {\n    \"number5\": {\n        \"password\": \"hemligt\",\n        \"client_secret\": \"drickyoughurt\",\n        \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n        \"post_logout_redirect_uris\": [(\"https://example.com/post_logout\", None)],\n        \"client_salt\": \"salted\",\n        \"response_types\": [\n            \"code\",\n            \"token\",\n            \"code id_token\",\n            \"none\",\n            \"code token\",\n            \"id_token\",\n        ],\n    },\n    \"a1b2c3\": {\n        \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n        \"client_salt\": \"salted\",\n        \"client_secret\": \"very_secret\",\n        \"response_types\": [\"code\", \"token\", \"code id_token\"],\n    },\n    \"client0\": {\n        \"redirect_uris\": [(\"http://www.example.org/authz\", None)],\n        \"client_secret\": \"very_secret\",\n        \"post_logout_redirect_uris\": [(\"https://www.example.org/post_logout\", None)],\n        \"client_salt\": \"salted\",\n        \"response_types\": [\"code\", \"token\", \"code id_token\"],\n    },\n    CLIENT_ID: {\n        \"client_secret\": CLIENT_SECRET,\n        \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n        \"client_salt\": \"salted\",\n        \"token_endpoint_auth_method\": \"client_secret_post\",\n        \"response_types\": [\"code\", \"token\", \"code id_token\"],\n    },\n}\n\nUSERDB = {\n    \"user\": {\n        \"name\": \"Hans Granberg\",\n        \"nickname\": \"Hasse\",\n        \"email\": \"hans@example.org\",\n        \"verified\": False,\n        \"sub\": \"user\",\n    },\n    \"username\": {\n        \"name\": \"Linda Lindgren\",\n        \"nickname\": \"Linda\",\n        \"email\": \"linda@example.com\",\n        \"verified\": True,\n        \"sub\": \"username\",\n        \"extra_claim\": \"extra_claim_value\",\n    },\n}\n\nURLMAP = {CLIENT_ID: [\"https://example.com/authz\"]}\n\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\nclass DummyAuthn(UserAuthnMethod):\n    def __init__(self, srv, user):\n        UserAuthnMethod.__init__(self, srv)\n        self.user = user\n\n    def authenticated_as(self, cookie=None, **kwargs):\n        if cookie == \"FAIL\":\n            return None, 0\n        else:\n            return {\"uid\": self.user}, time()\n\n\nAUTHN_BROKER = AuthnBroker()\nAUTHN_BROKER.add(\"UNDEFINED\", DummyAuthn(None, \"username\"))\n\n# dealing with authorization\nAUTHZ = AuthzHandling()\nSYMKEY = rndstr(16)  # symmetric key used to encrypt cookie info\nUSERINFO = UserInfo(USERDB)\n\n\nclass TestProvider(object):\n    @pytest.fixture(autouse=True)\n    def create_provider(self, session_db_factory):\n        self.provider = Provider(\n            SERVER_INFO[\"issuer\"],\n            session_db_factory(SERVER_INFO[\"issuer\"]),\n            CDB,\n            AUTHN_BROKER,\n            USERINFO,\n            AUTHZ,\n            verify_client,\n            SYMKEY,\n            urlmap=URLMAP,\n            keyjar=KEYJAR,\n        )\n        self.provider.baseurl = self.provider.name\n\n        self.cons = Consumer(\n            DictSessionBackend(),\n            CONSUMER_CONFIG.copy(),\n            CLIENT_CONFIG,\n            server_info=SERVER_INFO,\n        )\n        self.cons.behaviour = {\n            \"request_object_signing_alg\": DEF_SIGN_ALG[\"openid_request_object\"]\n        }\n        self.cons.keyjar[\"\"] = KC_RSA\n        self.cons.keyjar.import_jwks(\n            self.provider.keyjar.export_jwks(), self.cons.issuer\n        )\n        self.cons.provider_info = ProviderConfigurationResponse(\n            issuer=SERVER_INFO[\"issuer\"]\n        )\n\n        self.cons2 = Consumer(\n            {}, CONSUMER_CONFIG.copy(), CLIENT_CONFIG_2, server_info=SERVER_INFO\n        )\n        self.cons2.behaviour = {\n            \"request_object_signing_alg\": DEF_SIGN_ALG[\"openid_request_object\"]\n        }\n        self.cons2.keyjar[\"\"] = KC_RSA\n\n    def test_authorization_endpoint(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\"],\n            \"client_id\": \"a1b2c3\",\n            \"nonce\": \"Nonce\",\n        }\n\n        arq = AuthorizationRequest(**bib)\n\n        resp = self.provider.authorization_endpoint(request=arq.to_urlencoded())\n        parsed = parse_qs(urlparse(resp.message).query)\n        assert parsed[\"scope\"] == [\"openid\"]\n        assert parsed[\"state\"][0] == \"id-6da9ca0cc23959f5f33e8becd9b08cae\"\n        assert \"code\" in parsed\n\n    def test_provider_features_extra_claims(self):\n        self.provider.extra_claims = [\"claim_1\", \"claim_2\"]\n        features = self.provider.provider_features()\n        assert \"claim_1\" in features[\"claims_supported\"]\n        assert \"claim_2\" in features[\"claims_supported\"]\n\n    def test_provider_features_extra_scopes(self):\n        self.provider.extra_scope_dict = {\"my_scope\": [\"claim_1\", \"claim_2\"]}\n        features = self.provider.provider_features()\n        assert \"my_scope\" in features[\"scopes_supported\"]\n        assert \"claim_1\" in features[\"claims_supported\"]\n        assert \"claim_2\" in features[\"claims_supported\"]\n\n    def test_authorization_endpoint_request(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\", \"id_token\"],\n            \"client_id\": \"a1b2c3\",\n            \"nonce\": \"Nonce\",\n            \"prompt\": [\"none\"],\n        }\n\n        req = AuthorizationRequest(**bib)\n        # want to be someone else !\n        ic = {\"sub\": {\"value\": \"userX\"}}\n        _keys = self.provider.keyjar.get_signing_key(key_type=\"RSA\")\n        req[\"request\"] = make_openid_request(\n            req, _keys, idtoken_claims=ic, request_object_signing_alg=\"RS256\"\n        )\n\n        with pytest.raises(FailedAuthentication):\n            self.provider.authorization_endpoint(request=req.to_urlencoded())\n\n    def test_authorization_endpoint_id_token(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\", \"id_token\"],\n            \"client_id\": \"a1b2c3\",\n            \"nonce\": \"Nonce\",\n            \"prompt\": [\"none\"],\n        }\n\n        req = AuthorizationRequest(**bib)\n        areq = AuthorizationRequest(\n            response_type=\"code\",\n            client_id=\"client_1\",\n            redirect_uri=\"http://example.com/authz\",\n            scope=[\"openid\"],\n            state=\"state000\",\n        )\n\n        sdb = self.provider.sdb\n        ae = AuthnEvent(\"userX\", \"salt\")\n        sid = sdb.create_authz_session(ae, areq)\n        sdb.do_sub(sid, \"client_salt\")\n        _info = sdb[sid]\n        # All this is jut removed when the id_token is constructed\n        # The proper information comes from the session information\n        _user_info = IdToken(\n            iss=\"https://foo.example.om\",\n            sub=\"foo\",\n            aud=bib[\"client_id\"],\n            exp=epoch_in_a_while(minutes=10),\n            acr=\"2\",\n            nonce=bib[\"nonce\"],\n        )\n\n        idt = self.provider.id_token_as_signed_jwt(\n            _info, access_token=\"access_token\", user_info=_user_info\n        )\n\n        req[\"id_token\"] = idt\n        query_string = req.to_urlencoded()\n\n        # client_id not in id_token[\"aud\"] so login required\n        resp = self.provider.authorization_endpoint(request=query_string, cookie=\"FAIL\")\n        parsed_resp = parse_qs(urlparse(resp.message).fragment)\n        assert parsed_resp[\"error\"][0] == \"login_required\"\n\n        req[\"client_id\"] = \"client_1\"\n        query_string = req.to_urlencoded()\n\n        # client_id is in id_token[\"aud\"] so no login required\n        resp = self.provider.authorization_endpoint(request=query_string, cookie=\"FAIL\")\n\n        assert resp.message.startswith(\"http://localhost:8087/authz\")\n\n    def test_authorization_endpoint_bad_scope(self):\n        bib = {\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\"],\n            \"client_id\": \"a1b2c3\",\n        }\n\n        arq = AuthorizationRequest(**bib)\n        resp = self.provider.authorization_endpoint(request=arq.to_urlencoded())\n        assert resp.status_code == 303\n        parsed = parse_qs(urlparse(resp.message).query)\n        assert parsed[\"error\"][0] == \"invalid_request\"\n        assert parsed[\"error_description\"][0] == \"consent in prompt\"\n\n    def test_authenticated(self):\n        _state, location = self.cons.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        parsed = urlparse(resp.message)\n        assert (\n            \"{}://{}{}\".format(parsed.scheme, parsed.netloc, parsed.path)\n            == \"http://localhost:8087/authz\"\n        )\n\n        part = self.cons.parse_authz(query=resp.message)\n\n        assert isinstance(part, tuple)\n        aresp = part[0]\n        assert part[1] is None\n        assert part[2] is None\n\n        assert isinstance(aresp, AuthorizationResponse)\n        assert _eq(aresp.keys(), [\"code\", \"state\", \"scope\", \"client_id\", \"iss\"])\n\n        assert _eq(\n            self.cons.grant[_state].keys(),\n            [\"code\", \"tokens\", \"id_token\", \"exp_in\", \"seed\", \"grant_expiration_time\"],\n        )\n\n    def test_authenticated_url(self):\n        state, location = self.cons.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        aresp = self.cons.parse_response(\n            AuthorizationResponse, resp.message, sformat=\"urlencoded\"\n        )\n\n        assert isinstance(aresp, AuthorizationResponse)\n        assert _eq(aresp.keys(), [\"code\", \"state\", \"scope\", \"client_id\", \"iss\"])\n\n    def test_authenticated_hybrid(self):\n        _state, location = self.cons.begin(\n            scope=\"openid email claims_in_id_token\",\n            response_type=\"code id_token\",\n            path=\"http://localhost:8087\",\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        part = self.cons.parse_authz(resp.message)\n\n        assert isinstance(part, tuple)\n        aresp = part[0]\n        assert part[1] is None\n        id_token = part[2]\n\n        assert isinstance(aresp, AuthorizationResponse)\n        assert _eq(aresp.keys(), [\"scope\", \"state\", \"id_token\", \"client_id\", \"code\"])\n\n        assert _eq(\n            self.cons.grant[_state].keys(),\n            [\"code\", \"id_token\", \"tokens\", \"exp_in\", \"grant_expiration_time\", \"seed\"],\n        )\n        assert isinstance(id_token, IdToken)\n        assert _eq(\n            id_token.keys(),\n            [\"nonce\", \"c_hash\", \"sub\", \"iss\", \"acr\", \"exp\", \"auth_time\", \"iat\", \"aud\"],\n        )\n\n    def test_authenticated_token(self):\n        _state, location = self.cons.begin(\n            \"openid\", response_type=\"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n        parsed = parse_qs(urlparse(resp.message).fragment)\n        assert parsed[\"token_type\"][0] == \"Bearer\"\n        assert \"access_token\" in parsed\n\n    def test_authenticated_none(self):\n        _state, location = self.cons.begin(\n            \"openid\", response_type=\"none\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n        parsed = urlparse(resp.message)\n        assert (\n            \"{}://{}{}\".format(parsed.scheme, parsed.netloc, parsed.path)\n            == \"http://localhost:8087/authz\"\n        )\n        assert \"state\" in parse_qs(parsed.query)\n\n    def test_code_grant_type_ok(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert _eq(atr.keys(), [\"token_type\", \"id_token\", \"access_token\", \"scope\"])\n\n    def test_code_grant_type_missing_code(self):\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Missing code\"\n\n    def test_code_grant_type_revoked(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"revoked\": True,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Token is revoked\"\n\n    def test_code_grant_type_no_session(self):\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=\"some grant\",\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Code is invalid\"\n\n    def test_code_grant_type_missing_redirect_uri(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Missing redirect_uri\"\n\n    def test_code_grant_type_used(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": True,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"access_denied\"\n        assert atr[\"error_description\"] == \"Access Code already used\"\n\n    def test_code_grant_type_refresh(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid offline_access\"],\n            prompt=\"consent\",\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert _eq(\n            atr.keys(),\n            [\"token_type\", \"id_token\", \"access_token\", \"scope\", \"refresh_token\"],\n        )\n\n    def test_code_grant_type_id_token_claims(self):\n        id_token_claims = Claims(name={\"essential\": True})\n        claims_req = ClaimsRequest(id_token=id_token_claims)\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\"],\n            claims=claims_req,\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n\n        # Construct Access token request\n        areq = AccessTokenRequest(\n            code=access_grant,\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            client_secret=CLIENT_SECRET,\n            grant_type=\"authorization_code\",\n        )\n        resp = self.provider.code_grant_type(areq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert _eq(atr.keys(), [\"token_type\", \"id_token\", \"access_token\", \"scope\"])\n        assert atr.verify(keyjar=KEYJAR)\n        assert \"name\" in atr[\"id_token\"]\n\n    def test_client_credentials_grant_type(self):\n        resp = self.provider.client_credentials_grant_type(Message())\n        parsed = ErrorResponse().from_json(resp.message)\n        assert parsed[\"error\"] == \"unsupported_grant_type\"\n        assert parsed[\"error_description\"] == \"Unsupported grant_type\"\n\n    def test_password_grant_type(self):\n        resp = self.provider.password_grant_type(Message())\n        parsed = ErrorResponse().from_json(resp.message)\n        assert parsed[\"error\"] == \"unsupported_grant_type\"\n        assert parsed[\"error_description\"] == \"Unsupported grant_type\"\n\n    def test_authz_endpoint(self):\n        _state, location = self.cons.begin(\n            \"openid\", response_type=[\"code\", \"token\"], path=\"http://localhost:8087\"\n        )\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        parsed = parse_qs(urlparse(resp.message).fragment)\n        assert parsed[\"token_type\"][0] == \"Bearer\"\n        assert \"code\" in parsed\n\n    def test_idtoken(self):\n        AREQ = AuthorizationRequest(\n            response_type=\"code\",\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            scope=[\"openid\"],\n            state=\"state000\",\n        )\n\n        ae = AuthnEvent(\"sub\", \"salt\")\n        sid = self.provider.sdb.create_authz_session(ae, AREQ)\n        self.provider.sdb.do_sub(sid, \"client_salt\")\n        session = self.provider.sdb[sid]\n\n        id_token = self.provider.id_token_as_signed_jwt(session)\n        assert len(id_token.split(\".\")) == 3\n\n    def test_idtoken_with_extra_claims(self):\n        areq = AuthorizationRequest(\n            response_type=\"code\",\n            client_id=CLIENT_ID,\n            redirect_uri=\"http://example.com/authz\",\n            scope=[\"openid\"],\n            state=\"state000\",\n        )\n        aevent = AuthnEvent(\"sub\", \"salt\")\n        sid = self.provider.sdb.create_authz_session(aevent, areq)\n        self.provider.sdb.do_sub(sid, \"client_salt\")\n        session = self.provider.sdb[sid]\n\n        claims = {\"k1\": \"v1\", \"k2\": 32}\n\n        id_token = self.provider.id_token_as_signed_jwt(session, extra_claims=claims)\n        parsed = IdToken().from_jwt(id_token, keyjar=self.provider.keyjar)\n\n        for key, value in claims.items():\n            assert parsed[key] == value\n\n    def test_userinfo_endpoint(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"nickname\", \"sub\", \"name\", \"email\"])\n\n    def test_userinfo_endpoint_expired(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        initial_datetime = datetime.datetime(2018, 2, 5, 10, 0, 0, 0)\n        final_datetime = datetime.datetime(2018, 2, 9, 10, 0, 0, 0)\n        with freeze_time(initial_datetime) as frozen:\n            resp = self.provider.authorization_endpoint(\n                request=urlparse(location).query\n            )\n\n            # redirect\n            atr = AuthorizationResponse().deserialize(\n                urlparse(resp.message).fragment, \"urlencoded\"\n            )\n            frozen.move_to(final_datetime)\n\n            uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n            resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n\n        message = json.loads(resp.message)\n        assert message[\"error\"] == \"invalid_token\"\n        assert message[\"error_description\"] == \"Token is expired\"\n\n    def test_userinfo_endpoint_extra_claim(self):\n        # We have to recreate the cache again\n        self.provider.extra_claims = [\"extra_claim\"]\n        self.provider.capabilities = self.provider.provider_features()\n\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        # Request the extra claim\n        self.cons.consumer_config[\"user_info\"] = {\"extra_claim\": None}\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\", \"extra_claim\"])\n\n    def test_userinfo_endpoint_unknown_claim(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        # Request the extra claim\n        self.cons.consumer_config[\"user_info\"] = {\"extra_claim\": None}\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\"])\n\n    def test_userinfo_endpoint_extra_scopes(self):\n        # We have to recreate the cache again\n        self.provider.extra_scope_dict = {\"extra_scope\": [\"extra_claim\"]}\n        self.provider.capabilities = self.provider.provider_features()\n\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.consumer_config[\"user_info\"] = {\"extra_claim\": None}\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        # Request the extra scope\n        state, location = self.cons.begin(\n            \"openid extra_scope\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(access_token=atr[\"access_token\"], schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\", \"extra_claim\"])\n\n    def test_userinfo_endpoint_authn(self):\n        self.cons.client_secret = \"drickyoughurt\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(\n            request=uir.to_urlencoded(), authn=\"Bearer \" + atr[\"access_token\"]\n        )\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"nickname\", \"sub\", \"name\", \"email\"])\n\n    def test_userinfo_endpoint_missing_client(self):\n        self.provider.cdb[\"unknownclient\"] = {\n            \"client_secret\": \"unknownclient\",\n            \"redirect_uris\": [(\"http://localhost:8087/authz\", None)],\n            \"post_logout_redirect_uris\": [(\"https://example.com/post_logout\", None)],\n            \"client_salt\": \"salted\",\n            \"response_types\": [\n                \"code\",\n                \"token\",\n                \"code id_token\",\n                \"none\",\n                \"code token\",\n                \"id_token\",\n            ],\n        }\n        self.cons.client_id = \"unknownclient\"\n        self.cons.client_secret = \"unknownclient\"\n        self.cons.config[\"response_type\"] = [\"token\"]\n        self.cons.config[\"request_method\"] = \"parameter\"\n        state, location = self.cons.begin(\n            \"openid\", \"token\", path=\"http://localhost:8087\"\n        )\n\n        resp = self.provider.authorization_endpoint(request=urlparse(location).query)\n\n        # redirect\n        atr = AuthorizationResponse().deserialize(\n            urlparse(resp.message).fragment, \"urlencoded\"\n        )\n\n        uir = UserInfoRequest(schema=\"openid\")\n\n        del self.provider.cdb[\"unknownclient\"]\n        resp = self.provider.userinfo_endpoint(\n            request=uir.to_urlencoded(), authn=\"Bearer \" + atr[\"access_token\"]\n        )\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert ident[\"error\"] == \"unauthorized_client\"\n\n    def test_userinfo_endpoint_malformed(self):\n        uir = UserInfoRequest(schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(\n            request=uir.to_urlencoded(), authn=\"Not a token\"\n        )\n\n        assert json.loads(resp.message) == {\n            \"error_description\": \"Token is malformed\",\n            \"error\": \"invalid_request\",\n        }\n\n    def test_userinfo_endpoint_mising_authn(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        # authn_event is missing - this can happen for offline requests\n        _sdb[sid] = {\n            \"sub\": \"my_sub\",\n            \"oauth_state\": \"authz\",\n            \"uid\": \"user\",\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n\n        uir = UserInfoRequest(access_token=access_grant, schema=\"openid\")\n\n        resp = self.provider.userinfo_endpoint(request=uir.to_urlencoded())\n        ident = OpenIDSchema().deserialize(resp.message, \"json\")\n        assert _eq(ident.keys(), [\"sub\"])\n\n    def test_check_session_endpoint(self):\n        session = {\"sub\": \"UserID\", \"client_id\": \"number5\"}\n        idtoken = self.provider.id_token_as_signed_jwt(session)\n        csr = CheckSessionRequest(id_token=idtoken)\n\n        info = self.provider.check_session_endpoint(request=csr.to_urlencoded())\n        idt = IdToken().deserialize(info.message, \"json\")\n        assert _eq(idt.keys(), [\"sub\", \"aud\", \"iss\", \"acr\", \"exp\", \"iat\"])\n        assert idt[\"iss\"] == self.provider.name\n\n    def test_response_mode_fragment(self):\n        areq = {\"response_mode\": \"fragment\"}\n        assert self.provider.response_mode(areq, True) is None\n        with pytest.raises(InvalidRequest):\n            self.provider.response_mode(areq, False)\n\n    def test_response_mode_query(self):\n        areq = {\"response_mode\": \"query\"}\n        assert self.provider.response_mode(areq, False) is None\n        with pytest.raises(InvalidRequest):\n            self.provider.response_mode(areq, True)\n\n    def test_response_mode_form_post(self):\n        areq = {\"response_mode\": \"form_post\"}\n        aresp = AuthorizationResponse()\n        aresp[\"state\"] = \"state\"\n        response = self.provider.response_mode(\n            areq, False, redirect_uri=\"http://example.com\", aresp=aresp, headers=\"\"\n        )\n        assert \"Submit This Form\" in response.message\n        assert \"http://example.com\" in response.message\n        assert '<input type=\"hidden\" name=\"state\" value=\"state\"/>' in response.message\n\n    def test_auth_init_invalid(self):\n        areq = {\n            \"response_mode\": \"unknown\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"client_id\": \"number5\",\n            \"scope\": \"openid\",\n            \"response_type\": \"code\",\n            \"client_secret\": \"drickyoghurt\",\n        }\n        response = self.provider.auth_init(areq)\n\n        assert isinstance(response, Response)\n        assert response.status_code == 400\n        assert json.loads(response.message) == {\n            \"error\": \"invalid_request\",\n            \"error_description\": \"Contains unsupported response mode\",\n        }\n\n    @patch(\"oic.oic.provider.utc_time_sans_frac\", Mock(return_value=123456))\n    def test_client_secret_expiration_time(self):\n        exp_time = self.provider.client_secret_expiration_time()\n        assert exp_time == 209856\n\n    def test_registration_endpoint_post(self):\n        req = RegistrationRequest()\n\n        req[\"application_type\"] = \"web\"\n        req[\"client_name\"] = \"My super service\"\n        req[\"redirect_uris\"] = [\"http://example.com/authz\"]\n        req[\"contacts\"] = [\"foo@example.com\"]\n        req[\"response_types\"] = [\"code\"]\n\n        resp = self.provider.registration_endpoint(request=req.to_json())\n\n        regresp = RegistrationResponse().deserialize(resp.message, \"json\")\n        assert _eq(\n            regresp.keys(),\n            [\n                \"redirect_uris\",\n                \"contacts\",\n                \"application_type\",\n                \"client_name\",\n                \"registration_client_uri\",\n                \"client_secret_expires_at\",\n                \"registration_access_token\",\n                \"client_id\",\n                \"client_secret\",\n                \"client_id_issued_at\",\n                \"response_types\",\n            ],\n        )\n\n    def test_registration_endpoint_post_unicode(self):\n        data = (\n            \"application_type=web&client_name=M%C3%A1+supe%C5%99+service&\"\n            \"redirect_uris=http%3A%2F%2Fexample.com%2Fauthz&response_types=code\"\n        )\n        resp = self.provider.registration_endpoint(request=data)\n\n        regresp = RegistrationResponse().deserialize(resp.message, \"json\")\n        assert _eq(\n            regresp.keys(),\n            [\n                \"redirect_uris\",\n                \"application_type\",\n                \"client_name\",\n                \"registration_client_uri\",\n                \"client_secret_expires_at\",\n                \"registration_access_token\",\n                \"client_id\",\n                \"client_secret\",\n                \"client_id_issued_at\",\n                \"response_types\",\n            ],\n        )\n\n    def test_registration_endpoint_get(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", regresp[\"registration_access_token\"]])\n        query = \"=\".join([\"client_id\", regresp[\"client_id\"]])\n        resp = self.provider.registration_endpoint(\n            request=query, authn=authn, method=\"GET\"\n        )\n\n        assert json.loads(resp.message) == regresp.to_dict()\n\n    def test_registration_endpoint_delete(self):\n        resp = self.provider.registration_endpoint(request=\"\", method=\"PUT\")\n        assert json.loads(resp.message) == {\n            \"error\": \"Unsupported operation\",\n            \"error_description\": \"Altering of the registration is not supported\",\n        }\n\n    def test_registration_endpoint_put(self):\n        resp = self.provider.registration_endpoint(request=\"\", method=\"DELETE\")\n        assert json.loads(resp.message) == {\n            \"error\": \"Unsupported operation\",\n            \"error_description\": \"Deletion of the registration is not supported\",\n        }\n\n    def test_registration_endpoint_unsupported(self):\n        resp = self.provider.registration_endpoint(request=\"\", method=\"HEAD\")\n        assert json.loads(resp.message) == {\n            \"error\": \"Unsupported method\",\n            \"error_description\": \"Unsupported HTTP method\",\n        }\n\n    def test_do_client_registration_invalid_sector_uri(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            sector_identifier_uri=\"https://example.com\",\n            redirect_uris=[\"http://example.com/changed\"],\n        )\n        redirects = [\"http://example.com/present\"]\n        with responses.RequestsMock() as rsps:\n            rsps.add(rsps.GET, \"https://example.com\", body=json.dumps(redirects))\n            resp = self.provider.do_client_registration(rr, \"client0\")\n\n        assert resp.status_code == 400\n        error = json.loads(resp.message)\n        assert error[\"error\"] == \"invalid_configuration_parameter\"\n\n    def test_registration_endpoint_with_non_https_redirect_uri_implicit_flow(self):\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\"http://example.com/authz\"],\n            \"response_types\": [\"id_token\", \"token\"],\n        }\n        req = RegistrationRequest(**params)\n        resp = self.provider.registration_endpoint(request=req.to_json())\n\n        assert resp.status_code == 400\n        error = json.loads(resp.message)\n        assert error[\"error\"] == \"invalid_redirect_uri\"\n\n    def test_verify_redirect_uris_with_https_code_flow(self):\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\"http://example.com/authz\"],\n            \"response_types\": [\"code\"],\n        }\n        request = RegistrationRequest(**params)\n        verified_uris = self.provider.verify_redirect_uris(request)\n        assert verified_uris == [(\"http://example.com/authz\", None)]\n\n    def test_verify_redirect_uris_with_non_https_redirect_uri_implicit_flow(self):\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [\"http://example.com/authz\"],\n            \"response_types\": [\"id_token\", \"token\"],\n        }\n        request = RegistrationRequest(**params)\n\n        with pytest.raises(InvalidRedirectURIError) as exc_info:\n            self.provider.verify_redirect_uris(request)\n\n        assert str(exc_info.value) == \"None https redirect_uri not allowed\"\n\n    def test_verify_redirect_uris_unicode(self):\n        url = \"http://example.com/a\\xc5\\xaf\\xc5\\xa5h\\xc5\\xbe\"\n        params = {\n            \"application_type\": \"web\",\n            \"redirect_uris\": [url],\n            \"response_types\": [\"code\"],\n        }\n        request = RegistrationRequest(**params)\n        verified_uris = self.provider.verify_redirect_uris(request)\n        assert verified_uris == [(url, None)]\n\n    def test_provider_key_setup(self, tmpdir, session_db_factory):\n        path = tmpdir.strpath\n\n        # Path is actually just a random name we turn into a subpath of\n        # our current directory, that doesn't work with drive letters on\n        # windows, so we throw them away and add a '.' for a local path.\n        path = \".\" + os.path.splitdrive(path)[1].replace(os.path.sep, \"/\")\n\n        provider = Provider(\n            \"pyoicserv\",\n            session_db_factory(SERVER_INFO[\"issuer\"]),\n            {},\n            None,\n            None,\n            None,\n            None,\n            None,\n        )\n        provider.baseurl = \"http://www.example.com\"\n        provider.key_setup(path, path, sig={\"format\": \"jwk\", \"alg\": \"RSA\"})\n\n        keys = provider.keyjar.get_signing_key(\"RSA\")\n\n        assert len(keys) == 1\n        assert provider.jwks_uri == \"http://www.example.com/{}/jwks\".format(path)\n\n    @pytest.mark.parametrize(\n        \"uri\",\n        [\n            \"http://example.org/foo\",\n            \"http://example.com/cb\",\n            \"http://example.org/cb?got=you\",\n            \"http://example.org/cb/foo?got=you\",\n        ],\n    )\n    def test_verify_redirect_uri_faulty_without_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        with pytest.raises(RedirectURIError):\n            self.provider._verify_redirect_uri(areq)\n\n    @pytest.mark.parametrize(\n        \"uri\",\n        [\n            \"http://example.org/foo\",\n            \"http://example.com/cb\",\n            \"http://example.org/cb?got=you\",\n            \"http://example.org/cb?test=fail\",\n            \"http://example.org/cb/foo?got=you\",\n        ],\n    )\n    def test_verify_redirect_uri_faulty_with_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb?test=test\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        with pytest.raises(RedirectURIError):\n            self.provider._verify_redirect_uri(areq)\n\n    @pytest.mark.parametrize(\"uri\", [\"http://example.org/cb\"])\n    def test_verify_redirect_uri_correct_without_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        self.provider._verify_redirect_uri(areq)\n\n    @pytest.mark.parametrize(\n        \"uri\", [\"http://example.org/cb\", \"http://example.org/cb?test=test\"]\n    )\n    def test_verify_redirect_uri_correct_with_query(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb\", \"http://example.org/cb?test=test\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, response_type=\"code\", scope=\"openid\"\n        )\n\n        self.provider._verify_redirect_uri(areq)\n\n    def test_verify_sector_identifier_no_scheme(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"example.com\"\n        )\n        with LogCapture(level=logging.DEBUG) as logcap:\n            message = \"Couldn't open sector_identifier_uri\"\n            with pytest.raises(InvalidSectorIdentifier, match=message):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 2\n        # First log record is from server...\n        assert isinstance(logcap.records[1].msg, MissingSchema)\n        error = (\n            \"Invalid URL 'example.com': No schema supplied. Perhaps you meant \"\n            \"http://example.com?\"\n        )\n        assert str(logcap.records[1].msg) == error\n\n    def test_verify_sector_identifier_nonreachable(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", status=404)\n            message = \"Couldn't open sector_identifier_uri\"\n            with pytest.raises(InvalidSectorIdentifier, match=message):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 0\n\n    def test_verify_sector_identifier_error(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        error = ConnectionError(\"broken connection\")\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=error)\n            with pytest.raises(\n                InvalidSectorIdentifier, match=\"Couldn't open sector_identifier_uri\"\n            ):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 2\n        # First log record is from server...\n        assert logcap.records[1].msg == error\n\n    def test_verify_sector_identifier_malformed(self):\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        body = \"This is not the JSON you are looking for\"\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=body)\n            with pytest.raises(\n                InvalidSectorIdentifier,\n                match=\"Error deserializing sector_identifier_uri content\",\n            ):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 1\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == (body,)\n\n    def test_verify_sector_identifier_ru_missing_in_si(self):\n        \"\"\"Redirect_uris is not present in the sector_identifier_uri content.\"\"\"\n        rr = RegistrationRequest(\n            operation=\"register\",\n            sector_identifier_uri=\"https://example.com\",\n            redirect_uris=[\"http://example.com/missing\"],\n        )\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(\n                rsps.GET,\n                \"https://example.com\",\n                body=json.dumps([\"http://example.com/present\"]),\n            )\n            with pytest.raises(\n                InvalidSectorIdentifier,\n                match=\"redirect_uri missing from sector_identifiers\",\n            ):\n                self.provider._verify_sector_identifier(rr)\n\n        assert len(logcap.records) == 2\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == ('[\"http://example.com/present\"]',)\n        assert logcap.records[1].msg == \"redirect_uris: %s\"\n        assert logcap.records[1].args == ([\"http://example.com/missing\"],)\n\n    def test_verify_sector_identifier_ru_missing(self):\n        \"\"\"Redirect_uris is not present in the request.\"\"\"\n        rr = RegistrationRequest(\n            operation=\"register\", sector_identifier_uri=\"https://example.com\"\n        )\n        redirects = [\"http://example.com/present\"]\n\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=json.dumps(redirects))\n            si_redirects, si_url = self.provider._verify_sector_identifier(rr)\n\n        assert si_url == \"https://example.com\"\n        assert si_redirects == redirects\n        assert len(logcap.records) == 1\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == ('[\"http://example.com/present\"]',)\n\n    def test_verify_sector_identifier_ru_ok(self):\n        \"\"\"Redirect_uris is present in the sector_identifier_uri content.\"\"\"\n        rr = RegistrationRequest(\n            operation=\"register\",\n            sector_identifier_uri=\"https://example.com\",\n            redirect_uris=[\"http://example.com/present\"],\n        )\n        redirects = [\"http://example.com/present\"]\n\n        with responses.RequestsMock() as rsps, LogCapture(\n            level=logging.DEBUG\n        ) as logcap:\n            rsps.add(rsps.GET, \"https://example.com\", body=json.dumps(redirects))\n            si_redirects, si_url = self.provider._verify_sector_identifier(rr)\n\n        assert si_url == \"https://example.com\"\n        assert si_redirects == redirects\n        assert len(logcap.records) == 2\n        assert logcap.records[0].msg == \"sector_identifier_uri => %s\"\n        assert logcap.records[0].args == ('[\"http://example.com/present\"]',)\n        assert logcap.records[1].msg == \"redirect_uris: %s\"\n        assert logcap.records[1].args == ([\"http://example.com/present\"],)\n\n    @pytest.mark.parametrize(\n        \"uri\",\n        [\n            \"http://example.org/cb\",\n            \"http://example.org/cb?got=you\",\n            \"http://example.org/cb?foo=you\" \"http://example.org/cb?foo=bar&got=you\",\n            \"http://example.org/cb?foo=you&foo=bar\",\n        ],\n    )\n    def test_registered_redirect_uri_faulty_with_query_component(self, uri):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb?foo=bar\"],\n            response_types=[\"code\"],\n        )\n\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=uri, client_id=cid, scope=\"openid\", response_type=\"code\"\n        )\n\n        with pytest.raises(RedirectURIError):\n            self.provider._verify_redirect_uri(areq)\n\n    def test_registered_redirect_uri_correct_with_query_component(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/cb?foo=bar\"],\n            response_types=[\"code\"],\n        )\n\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n        cid = regresp[\"client_id\"]\n\n        areq = AuthorizationRequest(\n            redirect_uri=\"http://example.org/cb?foo=bar\",\n            client_id=cid,\n            scope=\"openid\",\n            response_type=\"code\",\n        )\n\n        self.provider._verify_redirect_uri(areq)\n\n    def test_verify_redirect_uri_native_http_localhost(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"http://localhost/cb\"], application_type=\"native\"\n        )\n\n        self.provider.verify_redirect_uris(areq)\n\n    def test_verify_redirect_uri_native_loopback(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"http://127.0.0.1/cb\"], application_type=\"native\"\n        )\n\n        self.provider.verify_redirect_uris(areq)\n\n    def test_verify_redirect_uri_native_http_non_localhost(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"http://example.org/cb\"], application_type=\"native\"\n        )\n\n        try:\n            self.provider.verify_redirect_uris(areq)\n        except InvalidRedirectURIError:\n            assert True\n\n    def test_verify_redirect_uri_native_custom(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"com.example.app:/oauth2redirect\"], application_type=\"native\"\n        )\n\n        self.provider.verify_redirect_uris(areq)\n\n    def test_verify_redirect_uri_native_https(self):\n        areq = RegistrationRequest(\n            redirect_uris=[\"https://example.org/cb\"], application_type=\"native\"\n        )\n\n        try:\n            self.provider.verify_redirect_uris(areq)\n        except InvalidRedirectURIError:\n            assert True\n\n    def test_read_registration(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", regresp[\"registration_access_token\"]])\n        query = \"=\".join([\"client_id\", regresp[\"client_id\"]])\n        resp = self.provider.read_registration(authn, query)\n\n        assert json.loads(resp.message) == regresp.to_dict()\n\n    def test_read_registration_malformed_authn(self):\n        resp = self.provider.read_registration(\"wrong string\", \"request\")\n        assert resp.status_code == 400\n        assert json.loads(resp.message) == {\n            \"error\": \"invalid_request\",\n            \"error_description\": None,\n        }\n\n    def test_read_registration_missing_clientid(self):\n        resp = self.provider.read_registration(\"Bearer wrong string\", \"request\")\n        assert resp.status_code == 401\n\n    def test_read_registration_wrong_cid(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", regresp[\"registration_access_token\"]])\n        query = \"=\".join([\"client_id\", \"123456789012\"])\n        resp = self.provider.read_registration(authn, query)\n\n        assert resp.status_code == 401\n\n    def test_read_registration_wrong_rat(self):\n        rr = RegistrationRequest(\n            operation=\"register\",\n            redirect_uris=[\"http://example.org/new\"],\n            response_types=[\"code\"],\n        )\n        registration_req = rr.to_json()\n        resp = self.provider.registration_endpoint(request=registration_req)\n        regresp = RegistrationResponse().from_json(resp.message)\n\n        authn = \" \".join([\"Bearer\", \"registration_access_token\"])\n        query = \"=\".join([\"client_id\", regresp[\"client_id\"]])\n        resp = self.provider.read_registration(authn, query)\n\n        assert resp.status_code == 401\n\n    def test_key_rollover(self):\n        provider2 = Provider(\"FOOP\", {}, {}, None, None, None, None, None)\n        provider2.keyjar = KEYJAR\n        # Number of KeyBundles\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 1\n        kb = ec_init({\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"sig\"]})\n        provider2.do_key_rollover(json.loads(kb.jwks()), \"b%d\")\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 2\n        kb = ec_init({\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"sig\"]})\n        provider2.do_key_rollover(json.loads(kb.jwks()), \"b%d\")\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 3\n        provider2.remove_inactive_keys(-1)\n        assert len(provider2.keyjar.issuer_keys[\"\"]) == 2\n\n    def test_end_session_endpoint(self):\n        # End session not allowed if no cookie and no id_token_hint is sent\n        # (can't determine session)\n        resp = self.provider.end_session_endpoint(\"\", cookie=\"FAIL\")\n        assert resp.status_code == 400\n\n    def _create_cookie(self, user, client_id, c_type=\"sso\"):\n        cd = CookieDealer(self.provider)\n        set_cookie = cd.create_cookie(\n            \"{}][{}\".format(user, client_id), c_type, self.provider.sso_cookie_name\n        )\n        cookies_string = set_cookie[1]\n        all_cookies: SimpleCookie = SimpleCookie()\n\n        try:\n            cookies_string = cookies_string.decode()\n        except (AttributeError, UnicodeDecodeError):\n            pass\n\n        all_cookies.load(cookies_string)\n\n        return all_cookies\n\n    def _code_auth(self):\n        state, location = self.cons.begin(\n            \"openid\", \"code\", path=\"http://localhost:8087\"\n        )\n        return self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n\n    def _code_auth2(self):\n        state, location = self.cons2.begin(\n            \"openid\", \"code\", path=\"http://www.example.org\"\n        )\n        return self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n\n    def test_session_state_in_auth_req_for_session_support(self, session_db_factory):\n        provider = Provider(\n            SERVER_INFO[\"issuer\"],\n            session_db_factory(SERVER_INFO[\"issuer\"]),\n            CDB,\n            AUTHN_BROKER,\n            USERINFO,\n            AUTHZ,\n            verify_client,\n            SYMKEY,\n            urlmap=URLMAP,\n            keyjar=KEYJAR,\n        )\n\n        provider.capabilities.update(\n            {\"check_session_iframe\": \"https://op.example.com/check_session\"}\n        )\n\n        req_args = {\n            \"scope\": [\"openid\"],\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"response_type\": [\"code\"],\n            \"client_id\": \"number5\",\n        }\n        areq = AuthorizationRequest(**req_args)\n        resp = provider.authorization_endpoint(request=areq.to_urlencoded())\n        aresp = self.cons.parse_response(\n            AuthorizationResponse, resp.message, sformat=\"urlencoded\"\n        )\n        assert \"session_state\" in aresp\n\n    def _assert_cookies_expired(self, http_headers):\n        cookies_string = \";\".join([c[1] for c in http_headers if c[0] == \"Set-Cookie\"])\n        all_cookies: SimpleCookie = SimpleCookie()\n\n        all_cookies.load(cookies_string)\n\n        now = datetime.datetime.utcnow()\n        for c in [self.provider.cookie_name, self.provider.session_cookie_name]:\n            dt = datetime.datetime.strptime(\n                all_cookies[c][\"expires\"], \"%a, %d-%b-%Y %H:%M:%S GMT\"\n            )\n            assert dt < now  # make sure the cookies have expired to be cleared\n\n    def _auth_with_id_token(self):\n        state, location = self.cons.begin(\n            \"openid\", \"id_token\", path=\"http://localhost:8087\"\n        )\n        resp = self.provider.authorization_endpoint(request=location.split(\"?\")[1])\n        aresp = self.cons.parse_response(\n            AuthorizationResponse, resp.message, sformat=\"urlencoded\"\n        )\n        return aresp[\"id_token\"]\n\n    def test_id_token_RS512_sign(self):\n        self.provider.capabilities[\"id_token_signing_alg_values_supported\"] = [\"RS512\"]\n        self.provider.build_jwx_def()\n        id_token = self._auth_with_id_token()\n        assert id_token.jws_header[\"alg\"] == \"RS512\"\n\n    def test_refresh_token_grant_type_ok(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n        info = _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        rareq = RefreshAccessTokenRequest(\n            grant_type=\"refresh_token\",\n            refresh_token=info[\"refresh_token\"],\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            scope=[\"openid\"],\n        )\n\n        resp = self.provider.refresh_token_grant_type(rareq)\n        atr = AccessTokenResponse().deserialize(resp.message, \"json\")\n        assert atr[\"refresh_token\"] is not None\n        assert atr[\"token_type\"] == \"Bearer\"\n\n    def test_refresh_token_grant_type_wrong_token(self):\n        rareq = RefreshAccessTokenRequest(\n            grant_type=\"refresh_token\",\n            refresh_token=\"some_other_refresh_token\",\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            scope=[\"openid\"],\n        )\n\n        resp = self.provider.refresh_token_grant_type(rareq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Not a refresh token\"\n\n    def test_refresh_token_grant_type_expired(self):\n        authreq = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n\n        _sdb = self.provider.sdb\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n        with freeze_time(\"2000-01-01\"):\n            info = _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        rareq = RefreshAccessTokenRequest(\n            grant_type=\"refresh_token\",\n            refresh_token=info[\"refresh_token\"],\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            scope=[\"openid\"],\n        )\n\n        resp = self.provider.refresh_token_grant_type(rareq)\n        atr = TokenErrorResponse().deserialize(resp.message, \"json\")\n        assert atr[\"error\"] == \"invalid_request\"\n        assert atr[\"error_description\"] == \"Refresh token is expired\"\n\n    def test_authorization_endpoint_faulty_request_uri(self):\n        bib = {\n            \"scope\": [\"openid\"],\n            \"state\": \"id-6da9ca0cc23959f5f33e8becd9b08cae\",\n            \"redirect_uri\": \"http://localhost:8087/authz\",\n            \"request_uri\": \"https://some-non-resolving.hostname.com/request_uri#1234\",\n            # faulty request_uri\n            \"response_type\": [\"code\"],\n            \"client_id\": \"a1b2c3\",\n        }\n\n        arq = AuthorizationRequest(**bib)\n        resp = self.provider.authorization_endpoint(request=arq.to_urlencoded())\n        assert resp.status_code == 400\n        msg = json.loads(resp.message)\n        assert msg[\"error\"] == \"invalid_request_uri\"\n\n    def test_encrypt_missing_info(self):\n        payload = self.provider.encrypt(\"payload\", {}, \"some_client\")\n        assert payload == \"payload\"\n\n    def test_encrypt_missing_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks_uri\": \"http://example.com/key\",\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://example.com/key\",\n                body=key,\n                content_type=\"application/json\",\n            )\n            payload = self.provider.encrypt(\"payload\", info, \"some_client\")\n        token = JWEnc().unpack(payload)\n        headers = json.loads(token.protected_header().decode())\n        assert headers[\"alg\"] == \"A128KW\"\n        assert headers[\"enc\"] == \"A128CBC-HS256\"\n\n    def test_encrypt_missing_not_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        info = {\n            \"id_token_encrypted_response_alg\": \"RSA1_5\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n        }\n        with pytest.raises(JWEException):\n            self.provider.encrypt(\"payload\", info, \"some_client\")\n\n    def test_encrypt_userinfo_missing_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"userinfo_encrypted_response_alg\": \"A128KW\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks_uri\": \"http://example.com/key\",\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://example.com/key\",\n                body=key,\n                content_type=\"application/json\",\n            )\n            payload = self.provider.encrypt(\n                \"payload\", info, \"some_client\", val_type=\"userinfo\"\n            )\n        token = JWEnc().unpack(payload)\n        headers = json.loads(token.protected_header().decode())\n        assert headers[\"alg\"] == \"A128KW\"\n        assert headers[\"enc\"] == \"A128CBC-HS256\"\n\n    def test_encrypt_missing_userinfo_not_recuperated(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        info = {\n            \"userinfo_encrypted_response_alg\": \"RSA1_5\",\n            \"userinfo_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n        }\n        with pytest.raises(JWEException):\n            self.provider.encrypt(\"payload\", info, \"some_client\", val_type=\"userinfo\")\n\n    def test_recuperate_jwks(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks\": json.loads(key),\n        }\n        self.provider.recuperate_keys(\"some_client\", info)\n        assert len(self.provider.keyjar.get_issuer_keys(\"some_client\")) == 3\n\n    def test_recuperate_jwks_uri(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        with open(os.path.join(BASE_PATH, \"jwk_enc.json\")) as keyf:\n            key = keyf.read()\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n            \"jwks_uri\": \"http://example.com/key\",\n        }\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://example.com/key\",\n                body=key,\n                content_type=\"application/json\",\n            )\n            self.provider.recuperate_keys(\"some_client\", info)\n            assert len(self.provider.keyjar.get_issuer_keys(\"some_client\")) == 3\n\n    def test_recuperate_none(self):\n        self.provider.keyjar = KeyJar()  # Empty keyjar, all keys are lost\n        info = {\n            \"id_token_encrypted_response_alg\": \"A128KW\",\n            \"id_token_encrypted_response_enc\": \"A128CBC-HS256\",\n            \"client_secret\": \"some_secret\",\n        }\n        self.provider.recuperate_keys(\"some_client\", info)\n        assert len(self.provider.keyjar.get_issuer_keys(\"some_client\")) == 2\n\n    def test_get_by(self):\n        _sdb = self.provider.sdb\n\n        # First authn\n        authreq_1 = AuthorizationRequest(\n            state=\"state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n            prompt=\"consent\",\n        )\n\n        sid = _sdb.access_token.key(user=\"sub\", areq=authreq_1)\n        access_grant = _sdb.access_token(sid=sid)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq_1.to_json(),\n            \"client_id\": CLIENT_ID,\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid, \"client_salt\")\n        _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        # Second authn\n        authreq_2 = AuthorizationRequest(\n            state=\"next_state\",\n            redirect_uri=\"http://example.com/authz\",\n            client_id=CLIENT_ID,\n            response_type=\"code\",\n            scope=[\"openid\", \"offline_access\"],\n        )\n\n        sid_2 = _sdb.access_token.key(user=\"sub\", areq=authreq_2)\n        access_grant = _sdb.access_token(sid=sid_2)\n        ae = AuthnEvent(\"user\", \"salt\")\n        _sdb[sid_2] = {\n            \"oauth_state\": \"authz\",\n            \"authn_event\": ae.to_json(),\n            \"authzreq\": authreq_1.to_json(),\n            \"client_id\": \"2ndClient\",\n            \"code\": access_grant,\n            \"code_used\": False,\n            \"scope\": [\"openid\", \"offline_access\"],\n            \"redirect_uri\": \"http://example.com/authz\",\n        }\n        _sdb.do_sub(sid_2, \"client_salt\")\n        _sdb.upgrade_to_token(access_grant, issue_refresh=True)\n\n        sub = _sdb[sid_2][\"sub\"]\n        assert self.provider.sdb.get_uid_by_sub(sub) == \"user\"\n        assert self.provider.sdb.get_uid_by_sid(sid_2) == \"user\"\n\n        assert self.provider.get_by_sub_and_(sub, \"client_id\", \"2ndClient\") == sid_2\n        assert self.provider.get_by_sub_and_(sub, \"client_id\", CLIENT_ID) == sid\n\n        # Error cases\n        assert self.provider.get_by_sub_and_(sub, \"client_id\", \"unknown\") is None\n        assert self.provider.get_by_sub_and_(\"who\", \"client_id\", CLIENT_ID) is None\n        assert self.provider.get_by_sub_and_(sub, \"foo\", \"bar\") is None\n"], "filenames": ["src/oic/oic/__init__.py", "src/oic/oic/consumer.py", "src/oic/oic/message.py", "tests/test_oic_consumer.py", "tests/test_oic_consumer_logout.py", "tests/test_oic_message.py", "tests/test_oic_provider.py"], "buggy_code_start_loc": [46, 5, 316, 12, 162, 7, 40], "buggy_code_end_loc": [1495, 442, 782, 922, 318, 611, 425], "fixing_code_start_loc": [47, 6, 316, 13, 162, 8, 41], "fixing_code_end_loc": [1507, 464, 790, 1164, 327, 678, 429], "type": "CWE-347", "message": "Python oic is a Python OpenID Connect implementation. In Python oic before version 1.2.1, there are several related cryptographic issues affecting client implementations that use the library. The issues are: 1) The IdToken signature algorithm was not checked automatically, but only if the expected algorithm was passed in as a kwarg. 2) JWA `none` algorithm was allowed in all flows. 3) oic.consumer.Consumer.parse_authz returns an unverified IdToken. The verification of the token was left to the discretion of the implementator. 4) iat claim was not checked for sanity (i.e. it could be in the future). These issues are patched in version 1.2.1.", "other": {"cve": {"id": "CVE-2020-26244", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-02T20:15:13.430", "lastModified": "2020-12-08T02:37:03.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Python oic is a Python OpenID Connect implementation. In Python oic before version 1.2.1, there are several related cryptographic issues affecting client implementations that use the library. The issues are: 1) The IdToken signature algorithm was not checked automatically, but only if the expected algorithm was passed in as a kwarg. 2) JWA `none` algorithm was allowed in all flows. 3) oic.consumer.Consumer.parse_authz returns an unverified IdToken. The verification of the token was left to the discretion of the implementator. 4) iat claim was not checked for sanity (i.e. it could be in the future). These issues are patched in version 1.2.1."}, {"lang": "es", "value": "Python oic es una implementaci\u00f3n de Python OpenID Connect.&#xa0;En Python oic versiones anteriores a 1.2.1, se presentan varios problemas criptogr\u00e1ficos relacionados que afectan las implementaciones de los clientes que usan la biblioteca.&#xa0;Los problemas son: 1) El algoritmo de firma IdToken no se comprob\u00f3 autom\u00e1ticamente, sino solo si el algoritmo esperado era pasado como un kwarg.&#xa0;2) Se permiti\u00f3 el algoritmo JWA \"none\" en todos los flujos.&#xa0;3) oic.consumer.Consumer.parse_authz devuelve un IdToken no verificado.&#xa0;La comprobaci\u00f3n del token se dej\u00f3 a discreci\u00f3n del implementador.&#xa0;4) el reclamo de iat no se comprob\u00f3 por sanidad (es decir, podr\u00eda ser en el futuro).&#xa0;Estos problemas est\u00e1n parcheados en la versi\u00f3n 1.2.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-325"}, {"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:python_openid_connect_project:python_openid_connect:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.1", "matchCriteriaId": "453CE2D9-9AE1-4502-8386-C5E018BA8EAC"}]}]}], "references": [{"url": "https://github.com/OpenIDC/pyoidc/commit/62f8d753fa17c8b1f29f8be639cf0b33afb02498", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenIDC/pyoidc/releases/tag/1.2.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/OpenIDC/pyoidc/security/advisories/GHSA-4fjv-pmhg-3rfg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/oic/", "source": "security-advisories@github.com", "tags": ["Product", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenIDC/pyoidc/commit/62f8d753fa17c8b1f29f8be639cf0b33afb02498"}}