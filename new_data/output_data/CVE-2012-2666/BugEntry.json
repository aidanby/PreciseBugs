{"buggy_code": ["// Copyright 2009 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gosym\n\nimport (\n\t\"debug/elf\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar pclinetestBinary string\n\nfunc dotest() bool {\n\t// For now, only works on ELF platforms.\n\tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n\t\treturn false\n\t}\n\tif pclinetestBinary != \"\" {\n\t\treturn true\n\t}\n\t// This command builds pclinetest from pclinetest.asm;\n\t// the resulting binary looks like it was built from pclinetest.s,\n\t// but we have renamed it to keep it away from the go tool.\n\tpclinetestBinary = os.TempDir() + \"/pclinetest\"\n\tcommand := fmt.Sprintf(\"go tool 6a -o %s.6 pclinetest.asm && go tool 6l -E main -o %s %s.6\",\n\t\tpclinetestBinary, pclinetestBinary, pclinetestBinary)\n\tcmd := exec.Command(\"sh\", \"-c\", command)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn true\n}\n\nfunc getTable(t *testing.T) *Table {\n\tf, tab := crack(os.Args[0], t)\n\tf.Close()\n\treturn tab\n}\n\nfunc crack(file string, t *testing.T) (*elf.File, *Table) {\n\t// Open self\n\tf, err := elf.Open(file)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn parse(file, f, t)\n}\n\nfunc parse(file string, f *elf.File, t *testing.T) (*elf.File, *Table) {\n\tsymdat, err := f.Section(\".gosymtab\").Data()\n\tif err != nil {\n\t\tf.Close()\n\t\tt.Fatalf(\"reading %s gosymtab: %v\", file, err)\n\t}\n\tpclndat, err := f.Section(\".gopclntab\").Data()\n\tif err != nil {\n\t\tf.Close()\n\t\tt.Fatalf(\"reading %s gopclntab: %v\", file, err)\n\t}\n\n\tpcln := NewLineTable(pclndat, f.Section(\".text\").Addr)\n\ttab, err := NewTable(symdat, pcln)\n\tif err != nil {\n\t\tf.Close()\n\t\tt.Fatalf(\"parsing %s gosymtab: %v\", file, err)\n\t}\n\n\treturn f, tab\n}\n\nvar goarch = os.Getenv(\"O\")\n\nfunc TestLineFromAline(t *testing.T) {\n\tif !dotest() {\n\t\treturn\n\t}\n\n\ttab := getTable(t)\n\n\t// Find the sym package\n\tpkg := tab.LookupFunc(\"debug/gosym.TestLineFromAline\").Obj\n\tif pkg == nil {\n\t\tt.Fatalf(\"nil pkg\")\n\t}\n\n\t// Walk every absolute line and ensure that we hit every\n\t// source line monotonically\n\tlastline := make(map[string]int)\n\tfinal := -1\n\tfor i := 0; i < 10000; i++ {\n\t\tpath, line := pkg.lineFromAline(i)\n\t\t// Check for end of object\n\t\tif path == \"\" {\n\t\t\tif final == -1 {\n\t\t\t\tfinal = i - 1\n\t\t\t}\n\t\t\tcontinue\n\t\t} else if final != -1 {\n\t\t\tt.Fatalf(\"reached end of package at absolute line %d, but absolute line %d mapped to %s:%d\", final, i, path, line)\n\t\t}\n\t\t// It's okay to see files multiple times (e.g., sys.a)\n\t\tif line == 1 {\n\t\t\tlastline[path] = 1\n\t\t\tcontinue\n\t\t}\n\t\t// Check that the is the next line in path\n\t\tll, ok := lastline[path]\n\t\tif !ok {\n\t\t\tt.Errorf(\"file %s starts on line %d\", path, line)\n\t\t} else if line != ll+1 {\n\t\t\tt.Errorf(\"expected next line of file %s to be %d, got %d\", path, ll+1, line)\n\t\t}\n\t\tlastline[path] = line\n\t}\n\tif final == -1 {\n\t\tt.Errorf(\"never reached end of object\")\n\t}\n}\n\nfunc TestLineAline(t *testing.T) {\n\tif !dotest() {\n\t\treturn\n\t}\n\n\ttab := getTable(t)\n\n\tfor _, o := range tab.Files {\n\t\t// A source file can appear multiple times in a\n\t\t// object.  alineFromLine will always return alines in\n\t\t// the first file, so track which lines we've seen.\n\t\tfound := make(map[string]int)\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tpath, line := o.lineFromAline(i)\n\t\t\tif path == \"\" {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// cgo files are full of 'Z' symbols, which we don't handle\n\t\t\tif len(path) > 4 && path[len(path)-4:] == \".cgo\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif minline, ok := found[path]; path != \"\" && ok {\n\t\t\t\tif minline >= line {\n\t\t\t\t\t// We've already covered this file\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound[path] = line\n\n\t\t\ta, err := o.alineFromLine(path, line)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"absolute line %d in object %s maps to %s:%d, but mapping that back gives error %s\", i, o.Paths[0].Name, path, line, err)\n\t\t\t} else if a != i {\n\t\t\t\tt.Errorf(\"absolute line %d in object %s maps to %s:%d, which maps back to absolute line %d\\n\", i, o.Paths[0].Name, path, line, a)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPCLine(t *testing.T) {\n\tif !dotest() {\n\t\treturn\n\t}\n\n\tf, tab := crack(pclinetestBinary, t)\n\ttext := f.Section(\".text\")\n\ttextdat, err := text.Data()\n\tif err != nil {\n\t\tt.Fatalf(\"reading .text: %v\", err)\n\t}\n\n\t// Test PCToLine\n\tsym := tab.LookupFunc(\"linefrompc\")\n\twantLine := 0\n\tfor pc := sym.Entry; pc < sym.End; pc++ {\n\t\tfile, line, fn := tab.PCToLine(pc)\n\t\toff := pc - text.Addr // TODO(rsc): should not need off; bug in 8g\n\t\twantLine += int(textdat[off])\n\t\tt.Logf(\"off is %d\", off)\n\t\tif fn == nil {\n\t\t\tt.Errorf(\"failed to get line of PC %#x\", pc)\n\t\t} else if !strings.HasSuffix(file, \"pclinetest.asm\") {\n\t\t\tt.Errorf(\"expected %s (%s) at PC %#x, got %s (%s)\", \"pclinetest.asm\", sym.Name, pc, file, fn.Name)\n\t\t} else if line != wantLine || fn != sym {\n\t\t\tt.Errorf(\"expected :%d (%s) at PC %#x, got :%d (%s)\", wantLine, sym.Name, pc, line, fn.Name)\n\t\t}\n\t}\n\n\t// Test LineToPC\n\tsym = tab.LookupFunc(\"pcfromline\")\n\tlookupline := -1\n\twantLine = 0\n\toff := uint64(0) // TODO(rsc): should not need off; bug in 8g\n\tfor pc := sym.Value; pc < sym.End; pc += 2 + uint64(textdat[off]) {\n\t\tfile, line, fn := tab.PCToLine(pc)\n\t\toff = pc - text.Addr\n\t\twantLine += int(textdat[off])\n\t\tif line != wantLine {\n\t\t\tt.Errorf(\"expected line %d at PC %#x in pcfromline, got %d\", wantLine, pc, line)\n\t\t\toff = pc + 1 - text.Addr\n\t\t\tcontinue\n\t\t}\n\t\tif lookupline == -1 {\n\t\t\tlookupline = line\n\t\t}\n\t\tfor ; lookupline <= line; lookupline++ {\n\t\t\tpc2, fn2, err := tab.LineToPC(file, lookupline)\n\t\t\tif lookupline != line {\n\t\t\t\t// Should be nothing on this line\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected no PC at line %d, got %#x (%s)\", lookupline, pc2, fn2.Name)\n\t\t\t\t}\n\t\t\t} else if err != nil {\n\t\t\t\tt.Errorf(\"failed to get PC of line %d: %s\", lookupline, err)\n\t\t\t} else if pc != pc2 {\n\t\t\t\tt.Errorf(\"expected PC %#x (%s) at line %d, got PC %#x (%s)\", pc, fn.Name, line, pc2, fn2.Name)\n\t\t\t}\n\t\t}\n\t\toff = pc + 1 - text.Addr\n\t}\n}\n"], "fixing_code": ["// Copyright 2009 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gosym\n\nimport (\n\t\"debug/elf\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar (\n\tpclineTempDir    string\n\tpclinetestBinary string\n)\n\nfunc dotest() bool {\n\t// For now, only works on ELF platforms.\n\tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n\t\treturn false\n\t}\n\tif pclinetestBinary != \"\" {\n\t\treturn true\n\t}\n\tvar err error\n\tpclineTempDir, err = ioutil.TempDir(\"\", \"pclinetest\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif strings.Contains(pclineTempDir, \" \") {\n\t\tpanic(\"unexpected space in tempdir\")\n\t}\n\t// This command builds pclinetest from pclinetest.asm;\n\t// the resulting binary looks like it was built from pclinetest.s,\n\t// but we have renamed it to keep it away from the go tool.\n\tpclinetestBinary = filepath.Join(pclineTempDir, \"pclinetest\")\n\tcommand := fmt.Sprintf(\"go tool 6a -o %s.6 pclinetest.asm && go tool 6l -E main -o %s %s.6\",\n\t\tpclinetestBinary, pclinetestBinary, pclinetestBinary)\n\tcmd := exec.Command(\"sh\", \"-c\", command)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn true\n}\n\nfunc getTable(t *testing.T) *Table {\n\tf, tab := crack(os.Args[0], t)\n\tf.Close()\n\treturn tab\n}\n\nfunc crack(file string, t *testing.T) (*elf.File, *Table) {\n\t// Open self\n\tf, err := elf.Open(file)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn parse(file, f, t)\n}\n\nfunc parse(file string, f *elf.File, t *testing.T) (*elf.File, *Table) {\n\tsymdat, err := f.Section(\".gosymtab\").Data()\n\tif err != nil {\n\t\tf.Close()\n\t\tt.Fatalf(\"reading %s gosymtab: %v\", file, err)\n\t}\n\tpclndat, err := f.Section(\".gopclntab\").Data()\n\tif err != nil {\n\t\tf.Close()\n\t\tt.Fatalf(\"reading %s gopclntab: %v\", file, err)\n\t}\n\n\tpcln := NewLineTable(pclndat, f.Section(\".text\").Addr)\n\ttab, err := NewTable(symdat, pcln)\n\tif err != nil {\n\t\tf.Close()\n\t\tt.Fatalf(\"parsing %s gosymtab: %v\", file, err)\n\t}\n\n\treturn f, tab\n}\n\nvar goarch = os.Getenv(\"O\")\n\nfunc TestLineFromAline(t *testing.T) {\n\tif !dotest() {\n\t\treturn\n\t}\n\n\ttab := getTable(t)\n\n\t// Find the sym package\n\tpkg := tab.LookupFunc(\"debug/gosym.TestLineFromAline\").Obj\n\tif pkg == nil {\n\t\tt.Fatalf(\"nil pkg\")\n\t}\n\n\t// Walk every absolute line and ensure that we hit every\n\t// source line monotonically\n\tlastline := make(map[string]int)\n\tfinal := -1\n\tfor i := 0; i < 10000; i++ {\n\t\tpath, line := pkg.lineFromAline(i)\n\t\t// Check for end of object\n\t\tif path == \"\" {\n\t\t\tif final == -1 {\n\t\t\t\tfinal = i - 1\n\t\t\t}\n\t\t\tcontinue\n\t\t} else if final != -1 {\n\t\t\tt.Fatalf(\"reached end of package at absolute line %d, but absolute line %d mapped to %s:%d\", final, i, path, line)\n\t\t}\n\t\t// It's okay to see files multiple times (e.g., sys.a)\n\t\tif line == 1 {\n\t\t\tlastline[path] = 1\n\t\t\tcontinue\n\t\t}\n\t\t// Check that the is the next line in path\n\t\tll, ok := lastline[path]\n\t\tif !ok {\n\t\t\tt.Errorf(\"file %s starts on line %d\", path, line)\n\t\t} else if line != ll+1 {\n\t\t\tt.Errorf(\"expected next line of file %s to be %d, got %d\", path, ll+1, line)\n\t\t}\n\t\tlastline[path] = line\n\t}\n\tif final == -1 {\n\t\tt.Errorf(\"never reached end of object\")\n\t}\n}\n\nfunc TestLineAline(t *testing.T) {\n\tif !dotest() {\n\t\treturn\n\t}\n\n\ttab := getTable(t)\n\n\tfor _, o := range tab.Files {\n\t\t// A source file can appear multiple times in a\n\t\t// object.  alineFromLine will always return alines in\n\t\t// the first file, so track which lines we've seen.\n\t\tfound := make(map[string]int)\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tpath, line := o.lineFromAline(i)\n\t\t\tif path == \"\" {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// cgo files are full of 'Z' symbols, which we don't handle\n\t\t\tif len(path) > 4 && path[len(path)-4:] == \".cgo\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif minline, ok := found[path]; path != \"\" && ok {\n\t\t\t\tif minline >= line {\n\t\t\t\t\t// We've already covered this file\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound[path] = line\n\n\t\t\ta, err := o.alineFromLine(path, line)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"absolute line %d in object %s maps to %s:%d, but mapping that back gives error %s\", i, o.Paths[0].Name, path, line, err)\n\t\t\t} else if a != i {\n\t\t\t\tt.Errorf(\"absolute line %d in object %s maps to %s:%d, which maps back to absolute line %d\\n\", i, o.Paths[0].Name, path, line, a)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPCLine(t *testing.T) {\n\tif !dotest() {\n\t\treturn\n\t}\n\tdefer os.RemoveAll(pclineTempDir)\n\n\tf, tab := crack(pclinetestBinary, t)\n\ttext := f.Section(\".text\")\n\ttextdat, err := text.Data()\n\tif err != nil {\n\t\tt.Fatalf(\"reading .text: %v\", err)\n\t}\n\n\t// Test PCToLine\n\tsym := tab.LookupFunc(\"linefrompc\")\n\twantLine := 0\n\tfor pc := sym.Entry; pc < sym.End; pc++ {\n\t\tfile, line, fn := tab.PCToLine(pc)\n\t\toff := pc - text.Addr // TODO(rsc): should not need off; bug in 8g\n\t\twantLine += int(textdat[off])\n\t\tt.Logf(\"off is %d\", off)\n\t\tif fn == nil {\n\t\t\tt.Errorf(\"failed to get line of PC %#x\", pc)\n\t\t} else if !strings.HasSuffix(file, \"pclinetest.asm\") {\n\t\t\tt.Errorf(\"expected %s (%s) at PC %#x, got %s (%s)\", \"pclinetest.asm\", sym.Name, pc, file, fn.Name)\n\t\t} else if line != wantLine || fn != sym {\n\t\t\tt.Errorf(\"expected :%d (%s) at PC %#x, got :%d (%s)\", wantLine, sym.Name, pc, line, fn.Name)\n\t\t}\n\t}\n\n\t// Test LineToPC\n\tsym = tab.LookupFunc(\"pcfromline\")\n\tlookupline := -1\n\twantLine = 0\n\toff := uint64(0) // TODO(rsc): should not need off; bug in 8g\n\tfor pc := sym.Value; pc < sym.End; pc += 2 + uint64(textdat[off]) {\n\t\tfile, line, fn := tab.PCToLine(pc)\n\t\toff = pc - text.Addr\n\t\twantLine += int(textdat[off])\n\t\tif line != wantLine {\n\t\t\tt.Errorf(\"expected line %d at PC %#x in pcfromline, got %d\", wantLine, pc, line)\n\t\t\toff = pc + 1 - text.Addr\n\t\t\tcontinue\n\t\t}\n\t\tif lookupline == -1 {\n\t\t\tlookupline = line\n\t\t}\n\t\tfor ; lookupline <= line; lookupline++ {\n\t\t\tpc2, fn2, err := tab.LineToPC(file, lookupline)\n\t\t\tif lookupline != line {\n\t\t\t\t// Should be nothing on this line\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected no PC at line %d, got %#x (%s)\", lookupline, pc2, fn2.Name)\n\t\t\t\t}\n\t\t\t} else if err != nil {\n\t\t\t\tt.Errorf(\"failed to get PC of line %d: %s\", lookupline, err)\n\t\t\t} else if pc != pc2 {\n\t\t\t\tt.Errorf(\"expected PC %#x (%s) at line %d, got PC %#x (%s)\", pc, fn.Name, line, pc2, fn2.Name)\n\t\t\t}\n\t\t}\n\t\toff = pc + 1 - text.Addr\n\t}\n}\n"], "filenames": ["src/pkg/debug/gosym/pclntab_test.go"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [172], "fixing_code_start_loc": [10], "fixing_code_end_loc": [187], "type": "CWE-377", "message": "golang/go in 1.0.2 fixes all.bash on shared machines. dotest() in src/pkg/debug/gosym/pclntab_test.go creates a temporary file with predicable name and executes it as shell script.", "other": {"cve": {"id": "CVE-2012-2666", "sourceIdentifier": "secalert@redhat.com", "published": "2021-07-09T11:15:07.750", "lastModified": "2021-10-18T12:54:21.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "golang/go in 1.0.2 fixes all.bash on shared machines. dotest() in src/pkg/debug/gosym/pclntab_test.go creates a temporary file with predicable name and executes it as shell script."}, {"lang": "es", "value": "golang/go en versi\u00f3n 1.0.2 corrige all.bash en m\u00e1quinas compartidas. La funci\u00f3n dotest() en el archivo src/pkg/debug/gosym/pclntab_test.go crea un archivo temporal con nombre predecible y lo ejecuta como script de shell"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-377"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:golang:go:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "307FDC4E-62B5-447B-B2CB-6BA717CDFA3B"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=765455", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://codereview.appspot.com/5992078", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/golang/go/commit/8ac275bb01588a8c0e6c0fe2de7fd11f08feccdd", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0009/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2012-2666", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/golang/go/commit/8ac275bb01588a8c0e6c0fe2de7fd11f08feccdd"}}