{"buggy_code": ["# Copyright 2012, Piston Cloud Computing, Inc.\n# Copyright 2012, OpenStack LLC.\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport netaddr\n\nfrom nova.compute import api as compute\nfrom nova.scheduler import filters\n\n\nclass AffinityFilter(filters.BaseHostFilter):\n    def __init__(self):\n        self.compute_api = compute.API()\n\n    def _affinity_host(self, context, instance_id):\n        return self.compute_api.get(context, instance_id)['host']\n\n\nclass DifferentHostFilter(AffinityFilter):\n    '''Schedule the instance on a different host from a set of instances.'''\n\n    def host_passes(self, host_state, filter_properties):\n        context = filter_properties['context']\n        scheduler_hints = filter_properties.get('scheduler_hints') or {}\n        me = host_state.host\n\n        affinity_uuids = scheduler_hints.get('different_host', [])\n        if isinstance(affinity_uuids, basestring):\n            affinity_uuids = [affinity_uuids]\n        if affinity_uuids:\n            return not any([i for i in affinity_uuids\n                              if self._affinity_host(context, i) == me])\n        # With no different_host key\n        return True\n\n\nclass SameHostFilter(AffinityFilter):\n    '''Schedule the instance on the same host as another instance in a set of\n    of instances.\n    '''\n\n    def host_passes(self, host_state, filter_properties):\n        context = filter_properties['context']\n        scheduler_hints = filter_properties.get('scheduler_hints') or {}\n        me = host_state.host\n\n        affinity_uuids = scheduler_hints.get('same_host', [])\n        if isinstance(affinity_uuids, basestring):\n            affinity_uuids = [affinity_uuids]\n        if affinity_uuids:\n            return any([i for i\n                          in affinity_uuids\n                          if self._affinity_host(context, i) == me])\n        # With no same_host key\n        return True\n\n\nclass SimpleCIDRAffinityFilter(AffinityFilter):\n    def host_passes(self, host_state, filter_properties):\n        scheduler_hints = filter_properties.get('scheduler_hints') or {}\n\n        affinity_cidr = scheduler_hints.get('cidr', '/24')\n        affinity_host_addr = scheduler_hints.get('build_near_host_ip')\n        host_ip = host_state.capabilities.get('host_ip')\n        if affinity_host_addr:\n            affinity_net = netaddr.IPNetwork(str.join('', (affinity_host_addr,\n                                                           affinity_cidr)))\n\n            return netaddr.IPAddress(host_ip) in affinity_net\n\n        # We don't have an affinity host address.\n        return True\n"], "fixing_code": ["# Copyright 2012, Piston Cloud Computing, Inc.\n# Copyright 2012, OpenStack LLC.\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport netaddr\n\nfrom nova.compute import api as compute\nfrom nova.scheduler import filters\n\n\nclass AffinityFilter(filters.BaseHostFilter):\n    def __init__(self):\n        self.compute_api = compute.API()\n\n    def _all_hosts(self, context):\n        all_hosts = {}\n        for instance in self.compute_api.get_all(context):\n            all_hosts[instance['uuid']] = instance['host']\n        return all_hosts\n\n\nclass DifferentHostFilter(AffinityFilter):\n    '''Schedule the instance on a different host from a set of instances.'''\n\n    def host_passes(self, host_state, filter_properties):\n        context = filter_properties['context']\n        scheduler_hints = filter_properties.get('scheduler_hints') or {}\n        me = host_state.host\n\n        affinity_uuids = scheduler_hints.get('different_host', [])\n        if isinstance(affinity_uuids, basestring):\n            affinity_uuids = [affinity_uuids]\n        if affinity_uuids:\n            all_hosts = self._all_hosts(context)\n            return not any([i for i in affinity_uuids\n                              if all_hosts.get(i) == me])\n        # With no different_host key\n        return True\n\n\nclass SameHostFilter(AffinityFilter):\n    '''Schedule the instance on the same host as another instance in a set of\n    of instances.\n    '''\n\n    def host_passes(self, host_state, filter_properties):\n        context = filter_properties['context']\n        scheduler_hints = filter_properties.get('scheduler_hints') or {}\n        me = host_state.host\n\n        affinity_uuids = scheduler_hints.get('same_host', [])\n        if isinstance(affinity_uuids, basestring):\n            affinity_uuids = [affinity_uuids]\n        if affinity_uuids:\n            all_hosts = self._all_hosts(context)\n            return any([i for i\n                          in affinity_uuids\n                          if all_hosts.get(i) == me])\n        # With no same_host key\n        return True\n\n\nclass SimpleCIDRAffinityFilter(AffinityFilter):\n    def host_passes(self, host_state, filter_properties):\n        scheduler_hints = filter_properties.get('scheduler_hints') or {}\n\n        affinity_cidr = scheduler_hints.get('cidr', '/24')\n        affinity_host_addr = scheduler_hints.get('build_near_host_ip')\n        host_ip = host_state.capabilities.get('host_ip')\n        if affinity_host_addr:\n            affinity_net = netaddr.IPNetwork(str.join('', (affinity_host_addr,\n                                                           affinity_cidr)))\n\n            return netaddr.IPAddress(host_ip) in affinity_net\n\n        # We don't have an affinity host address.\n        return True\n"], "filenames": ["nova/scheduler/filters/affinity_filter.py"], "buggy_code_start_loc": [28], "buggy_code_end_loc": [67], "fixing_code_start_loc": [28], "fixing_code_end_loc": [72], "type": "CWE-20", "message": "The Nova scheduler in OpenStack Compute (Nova) Folsom (2012.2) and Essex (2012.1), when DifferentHostFilter or SameHostFilter is enabled, allows remote authenticated users to cause a denial of service (excessive database lookup calls and server hang) via a request with many repeated IDs in the os:scheduler_hints section.", "other": {"cve": {"id": "CVE-2012-3371", "sourceIdentifier": "secalert@redhat.com", "published": "2012-07-17T21:55:02.350", "lastModified": "2012-08-24T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Nova scheduler in OpenStack Compute (Nova) Folsom (2012.2) and Essex (2012.1), when DifferentHostFilter or SameHostFilter is enabled, allows remote authenticated users to cause a denial of service (excessive database lookup calls and server hang) via a request with many repeated IDs in the os:scheduler_hints section."}, {"lang": "es", "value": "El planificador Nova en OpenStack Compute (Nova) Folsom (2012.2) y Essex (2012.1), cuando DifferentHostFilter o SameHostFilter est\u00e1n activados, permite a usuarios remotos autenticados provocar una denegaci\u00f3n de servicio (exceso de llamadas de b\u00fasqueda de base de datos y el servidor se bloquea) a trav\u00e9s de una solicitud con muchos identificadores repetidos en el sistema operativo: Secci\u00f3n scheduler_hints."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:compute:2012.2:*:*:*:*:*:*:*", "matchCriteriaId": "0E9D8029-F7DD-435D-B4F4-D3DABDB7333B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:essex:2012.1:*:*:*:*:*:*:*", "matchCriteriaId": "E5FDB43F-B315-4F68-9D86-B644F2D4DF9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:folsom:2012.2:*:*:*:*:*:*:*", "matchCriteriaId": "E76B76AB-D744-4163-8615-7BA18ABB1347"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2012/07/11/13", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/54388", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1501-1", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/nova/+bug/1017795", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "https://github.com/openstack/nova/commit/034762e8060dcf0a11cb039b9d426b0d0bb1801d", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://lists.launchpad.net/openstack/msg14452.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/openstack/nova/commit/034762e8060dcf0a11cb039b9d426b0d0bb1801d"}}