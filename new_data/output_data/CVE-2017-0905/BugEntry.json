{"buggy_code": ["module Recurly\n  # The API class handles all requests to the Recurly API. While most of its\n  # functionality is leveraged by the Resource class, it can be used directly,\n  # as well.\n  #\n  # Requests are made with methods named after the four main HTTP verbs\n  # recognized by the Recurly API.\n  #\n  # @example\n  #   Recurly::API.get 'accounts'             # => #<Net::HTTPOK ...>\n  #   Recurly::API.post 'accounts', xml_body  # => #<Net::HTTPCreated ...>\n  #   Recurly::API.put 'accounts/1', xml_body # => #<Net::HTTPOK ...>\n  #   Recurly::API.delete 'accounts/1'        # => #<Net::HTTPNoContent ...>\n  class API\n    require 'recurly/api/errors'\n\n    @@base_uri = \"https://api.recurly.com/v2/\"\n\n    RECURLY_API_VERSION = '2.8'\n\n    FORMATS = Helper.hash_with_indifferent_read_access(\n      'pdf' => 'application/pdf',\n      'xml' => 'application/xml'\n    )\n\n    class << self\n      # Additional HTTP headers sent with each API call\n      # @return [Hash{String => String}]\n      def headers\n        @headers ||= { 'Accept' => accept, 'User-Agent' => user_agent, 'X-Api-Version' => RECURLY_API_VERSION }\n      end\n\n      # @return [String, nil] Accept-Language header value\n      def accept_language\n        headers['Accept-Language']\n      end\n\n      # @param [String] language Accept-Language header value\n      def accept_language=(language)\n        headers['Accept-Language'] = language\n      end\n\n      # @return [Net::HTTPOK, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def head uri, params = {}, options = {}\n        request :head, uri, { :params => params || {} }.merge(options)\n      end\n\n      # @return [Net::HTTPOK, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def get uri, params = {}, options = {}\n        request :get, uri, { :params => params || {} }.merge(options)\n      end\n\n      # @return [Net::HTTPCreated, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def post uri, body = nil, options = {}\n        request :post, uri, { :body => body.to_s }.merge(options)\n      end\n\n      # @return [Net::HTTPOK, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def put uri, body = nil, options = {}\n        request :put, uri, { :body => body.to_s }.merge(options)\n      end\n\n      # @return [Net::HTTPNoContent, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def delete uri, body = nil, options = {}\n        request :delete, uri, options\n      end\n\n      # @return [URI::Generic]\n      def base_uri\n        URI.parse @@base_uri.sub('api', Recurly.subdomain)\n      end\n\n      # @return [String]\n      def user_agent\n        \"Recurly/#{Version}; #{RUBY_DESCRIPTION}\"\n      end\n\n      private\n\n      def accept\n        FORMATS['xml']\n      end\n      alias content_type accept\n    end\n  end\nend\n\nrequire 'recurly/api/net_http_adapter'\n", "require 'cgi'\nrequire 'net/https'\n\nmodule Recurly\n  class API\n    module Net\n      module HTTPAdapter\n        # A hash of Net::HTTP settings configured before the request.\n        #\n        # @return [Hash]\n        def net_http\n          @net_http ||= {}\n        end\n\n        # Used to store any Net::HTTP settings.\n        #\n        # @example\n        #   Recurly::API.net_http = {\n        #     :verify_mode => OpenSSL::SSL::VERIFY_PEER,\n        #     :ca_path     => \"/etc/ssl/certs\",\n        #     :ca_file     => \"/opt/local/share/curl/curl-ca-bundle.crt\"\n        #   }\n        attr_writer :net_http\n\n        private\n\n        METHODS = {\n          :head   => ::Net::HTTP::Head,\n          :get    => ::Net::HTTP::Get,\n          :post   => ::Net::HTTP::Post,\n          :put    => ::Net::HTTP::Put,\n          :delete => ::Net::HTTP::Delete\n        }\n\n        def request method, uri, options = {}\n          head = headers.dup\n          head.update options[:head] if options[:head]\n          head.delete_if { |_, value| value.nil? }\n          uri = base_uri + uri\n          if options[:params] && !options[:params].empty?\n            pairs = options[:params].map { |key, value|\n              \"#{CGI.escape key.to_s}=#{CGI.escape value.to_s}\"\n            }\n            uri += \"?#{pairs.join '&'}\"\n          end\n          request = METHODS[method].new uri.request_uri, head\n          request.basic_auth(*[Recurly.api_key, nil].flatten[0, 2])\n          if options[:body]\n            request['Content-Type'] = content_type\n            request.body = options[:body]\n          end\n          if options[:etag]\n            request['If-None-Match'] = options[:etag]\n          end\n          if options[:format]\n            request['Accept'] = FORMATS[options[:format]]\n          end\n          if options[:locale]\n            request['Accept-Language'] = options[:locale]\n          end\n          http = ::Net::HTTP.new uri.host, uri.port\n          http.use_ssl = uri.scheme == 'https'\n          net_http.each_pair { |key, value| http.send \"#{key}=\", value }\n\n          if Recurly.logger\n            Recurly.log :info, \"===> %s %s\" % [request.method, uri]\n            headers = request.to_hash\n            headers['authorization'] &&= ['Basic [FILTERED]']\n            Recurly.log :debug, headers.inspect\n            if request.body && !request.body.empty?\n              Recurly.log :debug, XML.filter(request.body)\n            end\n            start_time = Time.now\n          end\n\n          response = http.start { http.request request }\n          code = response.code.to_i\n\n          if Recurly.logger\n            latency = (Time.now - start_time) * 1_000\n            level = case code\n              when 200...300 then :info\n              when 300...400 then :warn\n              when 400...500 then :error\n              else                :fatal\n            end\n            Recurly.log level, \"<=== %d %s (%.1fms)\" % [\n              code,\n              response.class.name[9, response.class.name.length].gsub(\n                /([a-z])([A-Z])/, '\\1 \\2'\n              ),\n              latency\n            ]\n            Recurly.log :debug, response.to_hash.inspect\n            Recurly.log :debug, response.body if response.body\n          end\n\n          case code\n            when 200...300 then response\n            else                raise ERRORS[code].new request, response\n          end\n        rescue Errno::ECONNREFUSED => e\n          raise Error, e.message\n        end\n      end\n    end\n\n    extend Net::HTTPAdapter\n  end\nend\n", "require 'date'\nrequire 'erb'\n\nmodule Recurly\n  # The base class for all Recurly resources (e.g. {Account}, {Subscription},\n  # {Transaction}).\n  #\n  # Resources behave much like\n  # {ActiveModel}[http://rubydoc.info/gems/activemodel] classes, especially\n  # like {ActiveRecord}[http://rubydoc.info/gems/activerecord].\n  #\n  # == Life Cycle\n  #\n  # To take you through the typical life cycle of a resource, we'll use\n  # {Recurly::Account} as an example.\n  #\n  # === Creating a Record\n  #\n  # You can instantiate a record before attempting to save it.\n  #\n  #   account = Recurly::Account.new :first_name => 'Walter'\n  #\n  # Once instantiated, you can assign and reassign any attribute.\n  #\n  #   account.first_name = 'Walt'\n  #   account.last_name = 'White'\n  #\n  # When you're ready to save, do so.\n  #\n  #   account.save # => false\n  #\n  # If save returns +false+, validation likely failed. You can check the record\n  # for errors.\n  #\n  #   account.errors # => {\"account_code\"=>[\"can't be blank\"]}\n  #\n  # Once the errors are fixed, you can try again.\n  #\n  #   account.account_code = 'heisenberg'\n  #   account.save # => true\n  #\n  # The object will be updated with any information provided by the server\n  # (including any UUIDs set).\n  #\n  #   account.created_at # => 2011-04-30 07:13:35 -0700\n  #\n  # You can also create accounts in one fell swoop.\n  #\n  #   Recurly::Account.create(\n  #     :first_name   => 'Jesse'\n  #     :last_name    => 'Pinkman'\n  #     :account_code => 'capn_cook'\n  #   )\n  #   # => #<Recurly::Account account_code: \"capn_cook\" ...>\n  #\n  # You can use alternative \"bang\" methods for exception control. If the record\n  # fails to save, a Recurly::Resource::Invalid exception will be raised.\n  #\n  #   begin\n  #     account = Recurly::Account.new :first_name => 'Junior'\n  #     account.save!\n  #   rescue Recurly::Resource::Invalid\n  #     p account.errors\n  #   end\n  #\n  # You can access the invalid record from the exception itself (if, for\n  # example, you use the <tt>create!</tt> method).\n  #\n  #   begin\n  #     Recurly::Account.create! :first_name => 'Skylar', :last_name => 'White'\n  #   rescue Recurly::Resource::Invalid => e\n  #     p e.record.errors\n  #   end\n  #\n  # === Fetching a Record\n  #\n  # Records are fetched by their unique identifiers.\n  #\n  #   account = Recurly::Account.find 'better_call_saul'\n  #   # => #<Recurly::Account account_code: \"better_call_saul\" ...>\n  #\n  # If the record doesn't exist, a Recurly::Resource::NotFound exception will\n  # be raised.\n  #\n  # === Updating a Record\n  #\n  # Once fetched, a record can be updated with a hash of attributes.\n  #\n  #   account.update_attributes :first_name => 'Saul', :last_name => 'Goodman'\n  #   # => true\n  #\n  # (A bang method, update_attributes!, will raise Recurly::Resource::Invalid.)\n  #\n  # You can also update a record by setting attributes and calling save.\n  #\n  #   account.last_name = 'McGill'\n  #   account.save # Alternatively, call save!\n  #\n  # === Deleting a Record\n  #\n  # To delete (deactivate, close, etc.) a fetched record, merely call destroy\n  # on it.\n  #\n  #   account.destroy # => true\n  #\n  # === Fetching a List of Records\n  #\n  # If you want to iterate over a list of accounts, you can use a Pager.\n  #\n  #   pager = Account.paginate :per_page => 50\n  #\n  # If you want to iterate over _every_ record, a convenience method will\n  # automatically paginate:\n  #\n  #   Account.find_each { |account| p account }\n  class Resource\n    require 'recurly/resource/errors'\n    require 'recurly/resource/pager'\n    require 'recurly/resource/association'\n\n    # Raised when a record cannot be found.\n    #\n    # @example\n    #   begin\n    #     Recurly::Account.find 'tortuga'\n    #   rescue Recurly::Resource::NotFound => e\n    #     e.message # => \"Can't find Account with account_code = tortuga\"\n    #   end\n    class NotFound < API::NotFound\n      def initialize(message)\n        set_message message\n      end\n    end\n\n    # Raised when a record is invalid.\n    #\n    # @example\n    #   begin\n    #     Recurly::Account.create! :first_name => \"Flynn\"\n    #   rescue Recurly::Resource::Invalid => e\n    #     e.record.errors # => errors: {\"account_code\"=>[\"can't be blank\"]}>\n    #   end\n    class Invalid < Error\n      # @return [Resource, nil] The invalid record.\n      attr_reader :record\n\n      def initialize(message)\n        if message.is_a? Resource\n          @record = message\n          set_message(record_to_message)\n        else\n          set_message(message)\n        end\n      end\n\n      private\n\n      def record_to_message\n        @record.errors.map do |k, v|\n          message = v.join(', ')\n          k == 'base' ? message : \"#{k} #{message}\"\n        end.join('; ')\n      end\n    end\n\n    class << self\n      # @return [String] The demodulized name of the resource class.\n      # @example\n      #   Recurly::Account.name # => \"Account\"\n      def resource_name\n        Helper.demodulize name\n      end\n\n      # @return [String] The underscored, pluralized name of the resource\n      #   class.\n      # @example\n      #   Recurly::Account.collection_name # => \"accounts\"\n      def collection_name\n        Helper.pluralize Helper.underscore(resource_name)\n      end\n      alias collection_path collection_name\n\n      # @return [String] The underscored name of the resource class.\n      # @example\n      #   Recurly::Account.member_name # => \"account\"\n      def member_name\n        Helper.underscore resource_name\n      end\n\n      # @return [String] The relative path to a resource's identifier from the\n      #   API's base URI.\n      # @param uuid [String, nil]\n      # @example\n      #   Recurly::Account.member_path \"code\" # => \"accounts/code\"\n      #   Recurly::Account.member_path nil    # => \"accounts\"\n      def member_path(uuid)\n        uuid = ERB::Util.url_encode(uuid) if uuid\n        [collection_path, uuid].compact.join '/'\n      end\n\n      # @return [Array] Per attribute, defines readers, writers, boolean and\n      #   change-tracking methods.\n      # @param attribute_names [Array] An array of attribute names.\n      # @example\n      #   class Account < Resource\n      #     define_attribute_methods [:name]\n      #   end\n      #\n      #   a = Account.new\n      #   a.name?            # => false\n      #   a.name             # => nil\n      #   a.name = \"Stephen\"\n      #   a.name?            # => true\n      #   a.name             # => \"Stephen\"\n      #   a.name_changed?    # => true\n      #   a.name_was         # => nil\n      #   a.name_change      # => [nil, \"Stephen\"]\n      def define_attribute_methods(attribute_names)\n        @attribute_names = attribute_names.map! { |m| m.to_s }.sort!.freeze\n        remove_const :AttributeMethods if constants.include? :AttributeMethods\n        include const_set :AttributeMethods, Module.new {\n          attribute_names.each do |name|\n            define_method(name) { self[name] }                       # Get.\n            define_method(\"#{name}=\") { |value| self[name] = value } # Set.\n            define_method(\"#{name}?\") { !!self[name] }               # Present.\n            define_method(\"#{name}_change\") { changes[name] }        # Dirt...\n            define_method(\"#{name}_changed?\") { changed_attributes.key? name }\n            define_method(\"#{name}_was\") { changed_attributes[name] }\n            define_method(\"#{name}_previously_changed?\") {\n              previous_changes.key? name\n            }\n            define_method(\"#{name}_previously_was\") {\n              previous_changes[name].first if previous_changes.key? name\n            }\n          end\n        }\n      end\n\n      # @return [Array, nil] The list of attribute names defined for the\n      #   resource class.\n      attr_reader :attribute_names\n\n      # @return [Pager] A pager with an iterable collection of records\n      # @param options [Hash] A hash of pagination options\n      # @option options [Integer] :per_page The number of records returned per\n      #   page\n      # @option options [DateTime, Time, Integer] :cursor A timestamp that the\n      #   pager will skim back to and return records created before it\n      # @option options [String] :etag When set, will raise\n      #   {Recurly::API::NotModified} if the pager's loaded page content has\n      #   not changed\n      # @example Fetch 50 records and iterate over them\n      #   Recurly::Account.paginate(:per_page => 50).each { |a| p a }\n      # @example Fetch records before January 1, 2011\n      #   Recurly::Account.paginate(:cursor => Time.new(2011, 1, 1))\n      def paginate(options = {})\n        Pager.new self, options\n      end\n      alias scoped paginate\n      alias where  paginate\n\n      def all(options = {})\n        paginate(options).to_a\n      end\n\n      # @return [Hash] Defined scopes per resource.\n      def scopes\n        @scopes ||= Recurly::Helper.hash_with_indifferent_read_access\n      end\n\n      # @return [Module] Module of scopes methods.\n      def scopes_helper\n        @scopes_helper ||= Module.new.tap { |helper| extend helper }\n      end\n\n      # Defines a new resource scope.\n      #\n      # @return [Proc]\n      # @param [Symbol] name the scope name\n      # @param [Hash] params the scope params\n      def scope(name, params = {})\n        scopes[name = name.to_s] = params\n        scopes_helper.send(:define_method, name) { paginate scopes[name] }\n      end\n\n      # Iterates through every record by automatically paging.\n      #\n      # @return [nil]\n      # @param [Integer] per_page The number of records returned per request.\n      # @yield [record]\n      # @see Pager#find_each\n      # @example\n      #   Recurly::Account.find_each { |a| p a }\n      def find_each(per_page = 50, &block)\n        paginate(:per_page => per_page).find_each(&block)\n      end\n\n      # @return [Integer] The total record count of the resource in question.\n      # @see Pager#count\n      # @example\n      #   Recurly::Account.count # => 42\n      def count\n        paginate.count\n      end\n\n      # @api internal\n      # @return [Resource, nil]\n      def first\n        paginate(:per_page => 1).first\n      end\n\n      # @return [Resource] A record matching the designated unique identifier.\n      # @param [String] uuid The unique identifier of the resource to be\n      #   retrieved.\n      # @param [Hash] options A hash of options.\n      # @option options [String] :etag When set, will raise {API::NotModified}\n      #   if the record content has not changed.\n      # @raise [Error] If the resource has no identifier (and thus cannot be\n      #   retrieved).\n      # @raise [NotFound] If no resource can be found for the supplied\n      #   identifier (or the supplied identifier is +nil+).\n      # @raise [API::NotModified] If the <tt>:etag</tt> option is set and\n      #   matches the server's.\n      # @example\n      #   Recurly::Account.find \"heisenberg\"\n      #   # => #<Recurly::Account account_code: \"heisenberg\", ...>\n      #   Use the following identifiers for these types of objects:\n      #     for accounts use account_code\n      #     for plans use plan_code\n      #     for invoices use invoice_number\n      #     for subscriptions use uuid\n      #     for transactions use uuid\n      def find(uuid, options = {})\n        if uuid.nil? || uuid.to_s.empty?\n          raise NotFound, \"can't find a record with nil identifier\"\n        end\n\n        uri = uuid =~ /^http/ ? uuid : member_path(uuid)\n        begin\n          from_response API.get(uri, {}, options)\n        rescue API::NotFound => e\n          raise NotFound, e.description\n        end\n      end\n\n      # Instantiates and attempts to save a record.\n      #\n      # @return [Resource] The record.\n      # @raise [Transaction::Error] A monetary transaction failed.\n      # @see create!\n      def create(attributes = {})\n        new(attributes) { |record| record.save }\n      end\n\n      # Instantiates and attempts to save a record.\n      #\n      # @return [Resource] The saved record.\n      # @raise [Invalid] The record is invalid.\n      # @raise [Transaction::Error] A monetary transaction failed.\n      # @see create\n      def create!(attributes = {})\n        new(attributes) { |record| record.save! }\n      end\n\n      # Instantiates a record from an HTTP response, setting the record's\n      # response attribute in the process.\n      #\n      # @return [Resource]\n      # @param response [Net::HTTPResponse]\n      def from_response(response)\n        content_type = response['Content-Type']\n\n        case content_type\n        when %r{application/pdf}\n          response.body\n        when %r{application/xml}\n          record = from_xml response.body\n          record.instance_eval { @etag, @response = response['ETag'], response }\n          record\n        else\n          raise Recurly::Error, \"Content-Type \\\"#{content_type}\\\" is not accepted\"\n        end\n      end\n\n      # Instantiates a record from an XML blob: either a String or XML element.\n      #\n      # Assuming the record is from an API response, the record is flagged as\n      # persisted.\n      #\n      # @return [Resource]\n      # @param xml [String, REXML::Element, Nokogiri::XML::Node]\n      # @see from_response\n      def from_xml(xml)\n        xml = XML.new xml\n\n        if self != Resource || xml.name == member_name\n          record = new\n        elsif Recurly.const_defined?(class_name = Helper.classify(xml.name), false)\n          klass = Recurly.const_get class_name, false\n          record = klass.send :new\n        elsif root = xml.root and root.elements.empty?\n          return XML.cast root\n        else\n          record = {}\n        end\n        klass ||= self\n\n        xml.root.attributes.each do |name, value|\n          record.instance_variable_set \"@#{name}\", value.to_s\n        end\n\n        xml.each_element do |el|\n          # skip this element if it's an xml comment\n          next if defined?(Nokogiri::XML::Node::TEXT_NODE) && el.is_a?(Nokogiri::XML::Comment)\n\n          if el.name == 'a'\n            record.links[el.attribute('name').value] = {\n              :method => el.attribute('method').to_s,\n              :href => el.attribute('href').value\n            }\n            next\n          end\n\n          # Nokogiri on Jruby-1.7.19 likes to throw NullPointer exceptions\n          # if you try to run certian operations like el.attribute(''). Since\n          # we dont care about text nodes, let's just skip them\n          next if defined?(Nokogiri::XML::Node::TEXT_NODE) && el.node_type == Nokogiri::XML::Node::TEXT_NODE\n\n          if el.children.empty? && href = el.attribute('href')\n            klass_name = Helper.classify(klass.association_class_name(el.name) ||\n                                         el.attribute('type') ||\n                                         el.name)\n\n            next unless Recurly.const_defined?(klass_name)\n\n            resource_class = Recurly.const_get(klass_name, false)\n\n            case el.name\n            when *klass.associations_for_relation(:has_many)\n              record[el.name] = Pager.new(\n                resource_class, :uri => href.value, :parent => record\n              )\n            when *(klass.associations_for_relation(:has_one) + klass.associations_for_relation(:belongs_to))\n              record.links[el.name] = {\n                :resource_class => resource_class,\n                :method => :get,\n                :href => href.value\n              }\n            end\n          else\n            # TODO name tax_type conflicts with the TaxType\n            # class so if we get to this point was can assume\n            # it's the string. Will need to refactor this\n            if el.name == 'tax_type'\n              record[el.name] = el.text\n            else\n              val = XML.cast(el)\n\n              # TODO we have to clear changed attributes after\n              # parsing here or else it always serializes. Need\n              # a better way of handling changed attributes\n              if el.name == 'address' && val.kind_of?(Hash)\n                address = Address.new(val)\n                address.instance_variable_set(:@changed_attributes, {})\n                record[el.name] = address\n              else\n                record[el.name] = val\n              end\n            end\n          end\n        end\n\n        record.persist! if record.respond_to? :persist!\n        record\n      end\n\n      # @return [Array] A list of associations for the current class.\n      def associations\n        @associations ||= []\n      end\n\n      # @return [Array] A list of associated resource classes with\n      # the relation [:has_many, :has_one, :belongs_to] for the current class.\n      def associations_for_relation(relation)\n        associations.select{ |a| a.relation == relation }.map(&:resource_class)\n      end\n\n      # @return [String, nil] The actual associated resource class name\n      # for the current class if the resource class does not match the\n      # actual class.\n      def association_class_name(resource_class)\n        association = find_association(resource_class)\n        association.class_name if association\n      end\n\n      # @return [Association, nil] Find association for the current class\n      #                            with resource class name.\n      def find_association(resource_class)\n        associations.find{ |a| a.resource_class.to_s == resource_class.to_s }\n      end\n\n      def associations_helper\n        @associations_helper ||= Module.new.tap { |helper| include helper }\n      end\n\n      # Establishes a has_many association.\n      #\n      # @return [Proc, nil]\n      # @param collection_name [Symbol] Association name.\n      # @param options [Hash] A hash of association options.\n      # @option options [true, false] :readonly Don't define a setter.\n      #                 [String] :class_name Actual associated resource class name\n      #                                      if not same as collection_name.\n      def has_many(collection_name, options = {})\n        associations << Association.new(:has_many, collection_name.to_s, options)\n        associations_helper.module_eval do\n          define_method collection_name do\n            if self[collection_name]\n              self[collection_name]\n            else\n              attributes[collection_name] = []\n            end\n          end\n          if options.key?(:readonly) && options[:readonly] == false\n            define_method \"#{collection_name}=\" do |collection|\n              self[collection_name] = collection\n            end\n          end\n        end\n      end\n\n      # Establishes a has_one association.\n      #\n      # @return [Proc, nil]\n      # @param member_name [Symbol] Association name.\n      # @param options [Hash] A hash of association options.\n      # @option options [true, false] :readonly Don't define a setter.\n      #                 [String] :class_name Actual associated resource class name\n      #                                      if not same as member_name.\n      def has_one(member_name, options = {})\n        associations << Association.new(:has_one, member_name.to_s, options)\n        associations_helper.module_eval do\n          define_method(member_name) { self[member_name] }\n          if options.key?(:readonly) && options[:readonly] == false\n            associated = Recurly.const_get Helper.classify(member_name), false\n            define_method \"#{member_name}=\" do |member|\n              associated_uri = \"#{path}/#{member_name}\"\n              self[member_name] = case member\n              when Hash\n                associated.send :new, member.merge(:uri => associated_uri)\n              when associated\n                member.uri = associated_uri and member\n              else\n                raise ArgumentError, \"expected #{associated}\"\n              end\n            end\n            define_method \"build_#{member_name}\" do |*args|\n              attributes = args.shift || {}\n              self[member_name] = associated.send(\n                :new, attributes.merge(:uri => \"#{path}/#{member_name}\")\n              ).tap { |child| child.attributes[self.class.member_name] = self }\n            end\n            define_method \"create_#{member_name}\" do |*args|\n              send(\"build_#{member_name}\", *args).tap { |child| child.save }\n            end\n          end\n        end\n      end\n\n      # Establishes a belongs_to association.\n      #\n      # @return [Proc]\n      # @param parent_name [Symbol] Association name.\n      # @param options [Hash] A hash of association options.\n      # @option options [true, false] :readonly Don't define a setter.\n      #                 [String] :class_name Actual associated resource class name\n      #                                      if not same as parent_name.\n      def belongs_to(parent_name, options = {})\n        associations << Association.new(:belongs_to, parent_name.to_s, options)\n        associations_helper.module_eval do\n          define_method(parent_name) { self[parent_name] }\n          if options.key?(:readonly) && options[:readonly] == false\n            define_method \"#{parent_name}=\" do |parent|\n              self[parent_name] = parent\n            end\n          end\n        end\n      end\n\n      # @return [:has_many, :has_one, :belongs_to, nil] An association type.\n      def reflect_on_association(name)\n        a = find_association(name)\n        a.relation if a\n      end\n\n      def embedded!(root_index = false)\n        protected :initialize\n        private_class_method(*%w(create create!))\n        unless root_index\n          private_class_method(*%w(all find_each first paginate scoped where))\n        end\n      end\n    end\n\n    # @return [Hash] The raw hash of record attributes.\n    attr_reader :attributes\n\n    # @return [Net::HTTPResponse, nil] The most recent response object for the\n    #   record (updated during {#save} and {#destroy}).\n    attr_reader :response\n\n    # @return [String, nil] An ETag for the current record.\n    attr_reader :etag\n\n    # @return [String, nil] A writer to override the URI the record saves to.\n    attr_writer :uri\n\n    # @return [Resource] A new resource instance.\n    # @param attributes [Hash] A hash of attributes.\n    def initialize(attributes = {})\n      if instance_of? Resource\n        raise Error,\n          \"#{self.class} is an abstract class and cannot be instantiated\"\n      end\n\n      @attributes, @new_record, @destroyed, @uri, @href = {}, true, false\n      self.attributes = attributes\n      yield self if block_given?\n    end\n\n    # @return [self] Reloads the record from the server.\n    def reload(response = nil)\n      if response\n        return if response.body.to_s.length.zero?\n        fresh = self.class.from_response response\n      else\n        fresh = self.class.find(\n          @href || to_param, :etag => (etag unless changed?)\n        )\n      end\n      fresh and copy_from fresh\n      persist! true\n      self\n    rescue API::NotModified\n      self\n    end\n\n    # @return [Hash] Hash of changed attributes.\n    # @see #changes\n    def changed_attributes\n      @changed_attributes ||= {}\n    end\n\n    # @return [Array] A list of changed attribute keys.\n    def changed\n      changed_attributes.keys\n    end\n\n    # Do any attributes have unsaved changes?\n    # @return [true, false]\n    def changed?\n      !changed_attributes.empty?\n    end\n\n    # @return [Hash] Map of changed attributes to original value and new value.\n    def changes\n      changed_attributes.inject({}) { |changes, (key, original_value)|\n        changes[key] = [original_value, self[key]] and changes\n      }\n    end\n\n    # @return [Hash] Previously-changed attributes.\n    # @see #changes\n    def previous_changes\n      @previous_changes ||= {}\n    end\n\n    # Is the record new (i.e., not saved on Recurly's servers)?\n    #\n    # @return [true, false]\n    # @see #persisted?\n    # @see #destroyed?\n    def new_record?\n      @new_record\n    end\n\n    # Has the record been destroyed? (Set +true+ after a successful destroy.)\n    # @return [true, false]\n    # @see #new_record?\n    # @see #persisted?\n    def destroyed?\n      @destroyed\n    end\n\n    # Has the record persisted (i.e., saved on Recurly's servers)?\n    #\n    # @return [true, false]\n    # @see #new_record?\n    # @see #destroyed?\n    def persisted?\n      !(new_record? || destroyed?)\n    end\n\n    # The value of a specified attribute, lazily fetching any defined\n    # association.\n    #\n    # @param key [Symbol, String] The name of the attribute to be fetched.\n    # @example\n    #   account.read_attribute :first_name # => \"Ted\"\n    #   account[:last_name]                # => \"Beneke\"\n    # @see #write_attribute\n    def read_attribute(key)\n      key = key.to_s\n      if attributes.key? key\n        value = attributes[key]\n      elsif links.key?(key) && self.class.reflect_on_association(key)\n        value = attributes[key] = follow_link key\n      end\n      value\n    end\n    alias [] read_attribute\n\n    # Sets the value of a specified attribute.\n    #\n    # @param key [Symbol, String] The name of the attribute to be set.\n    # @param value [Object] The value the attribute will be set to.\n    # @example\n    #   account.write_attribute :first_name, 'Gus'\n    #   account[:company_name] = 'Los Pollos Hermanos'\n    # @see #read_attribute\n    def write_attribute(key, value)\n      if changed_attributes.key?(key = key.to_s)\n        changed_attributes.delete key if changed_attributes[key] == value\n      elsif self[key] != value\n        changed_attributes[key] = self[key]\n      end\n\n      association = self.class.find_association(key)\n      if association\n        value = fetch_associated(key, value)\n      # FIXME: More explicit; less magic.\n      elsif value && key.end_with?('_in_cents') && !respond_to?(:currency)\n        value = Money.new(value, self, key) unless value.is_a?(Money)\n      end\n\n      attributes[key] = value\n    end\n    alias []= write_attribute\n\n    # Apply a given hash of attributes to a record.\n    #\n    # @return [Hash]\n    # @param attributes [Hash] A hash of attributes.\n    def attributes=(attributes = {})\n      attributes.each_pair { |k, v|\n        respond_to?(name = \"#{k}=\") and send(name, v) or self[k] = v\n      }\n    end\n\n    def as_json(options = nil)\n      attributes.reject { |k, v| v.is_a?(Recurly::Resource::Pager) }\n    end\n\n    # @return [Hash] The raw hash of record href links.\n    def links\n      @links ||= {}\n    end\n\n    # Whether a record has a link with the given name.\n    #\n    # @param key [Symbol, String] The name of the link to check for.\n    # @example\n    #   account.link? :billing_info # => true\n    def link?(key)\n      links.key?(key.to_s)\n    end\n\n    # Fetch the value of a link by following the associated href.\n    #\n    # @param key [Symbol, String] The name of the link to be followed.\n    # @param options [Hash] A hash of API options.\n    # @example\n    #   account.read_link :billing_info # => <Recurly::BillingInfo>\n    def follow_link(key, options = {})\n      if link = links[key = key.to_s]\n        response = API.send link[:method], link[:href], options[:body], options\n        if resource_class = link[:resource_class]\n          response = resource_class.from_response response\n          response.attributes[self.class.member_name] = self\n        end\n        response\n      end\n    rescue Recurly::API::NotFound\n      raise unless resource_class\n    end\n\n    # Serializes the record to XML.\n    #\n    # @return [String] An XML string.\n    # @param options [Hash] A hash of XML options.\n    # @example\n    #   Recurly::Account.new(:account_code => 'code').to_xml\n    #   # => \"<account><account_code>code</account_code></account>\"\n    def to_xml(options = {})\n      builder = options[:builder] || XML.new(\"<#{self.class.member_name}/>\")\n      xml_keys.each { |key|\n        value = respond_to?(key) ? send(key) : self[key]\n        node = builder.add_element key\n\n        # Duck-typing here is problematic because of ActiveSupport's #to_xml.\n        case value\n        when Resource, Subscription::AddOns\n          value.to_xml options.merge(:builder => node)\n        when Array\n          value.each do |e|\n            if e.is_a? Recurly::Resource\n              # create a node to hold this resource\n              e_node = node.add_element Helper.singularize(key)\n              # serialize the resource into this node\n              e.to_xml(options.merge(builder: e_node))\n            else\n              # it's just a primitive value\n              node.add_element(Helper.singularize(key), e)\n            end\n          end\n        when Hash, Recurly::Money\n          value.each_pair { |k, v| node.add_element k.to_s, v }\n        else\n          node.text = value\n        end\n      }\n      builder.to_s\n    end\n\n    # Attempts to save the record, returning the success of the request.\n    #\n    # @return [true, false]\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Recurly::Account.new\n    #   account.save # => false\n    #   account.account_code = 'account_code'\n    #   account.save # => true\n    # @see #save!\n    def save\n      if new_record? || changed?\n        clear_errors\n        @response = API.send(\n          persisted? ? :put : :post, path, to_xml\n        )\n        reload response\n        persist! true\n      end\n      true\n    rescue API::UnprocessableEntity => e\n      apply_errors e\n      Transaction::Error.validate! e, (self if is_a?(Transaction))\n      false\n    end\n\n    # Attempts to save the record, returning +true+ if the record was saved and\n    # raising {Invalid} otherwise.\n    #\n    # @return [true]\n    # @raise [Invalid] The record was invalid.\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Recurly::Account.new\n    #   account.save! # raises Recurly::Resource::Invalid\n    #   account.account_code = 'account_code'\n    #   account.save! # => true\n    # @see #save\n    def save!\n      save || raise(Invalid.new(self))\n    end\n\n    # @return [true, false, nil] The validity of the record: +true+ if the\n    #   record was successfully saved (or persisted and unchanged), +false+ if\n    #   the record was not successfully saved, or +nil+ for a record with an\n    #   unknown state (i.e.  (i.e. new records that haven't been saved and\n    #   persisted records with changed attributes).\n    # @example\n    #   account = Recurly::Account.new\n    #   account.valid? # => nil\n    #   account.save   # => false\n    #   account.valid? # => false\n    #   account.account_code = 'account_code'\n    #   account.save   # => true\n    #   account.valid? # => true\n    def valid?\n      return true if persisted? && !changed?\n      errors_empty = errors.values.flatten.empty?\n      return if errors_empty && changed?\n      errors_empty\n    end\n\n    # Update a record with a given hash of attributes.\n    #\n    # @return [true, false] The success of the update.\n    # @param attributes [Hash] A hash of attributes.\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Account.find 'junior'\n    #   account.update_attributes :account_code => 'flynn' # => true\n    # @see #update_attributes!\n    def update_attributes(attributes = {})\n      self.attributes = attributes and save\n    end\n\n    # Update a record with a given hash of attributes.\n    #\n    # @return [true] The update was successful.\n    # @param attributes [Hash] A hash of attributes.\n    # @raise [Invalid] The record was invalid.\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Account.find 'gale_boetticher'\n    #   account.update_attributes! :account_code => nil # Raises an exception.\n    # @see #update_attributes\n    def update_attributes!(attributes = {})\n      self.attributes = attributes and save!\n    end\n\n    # @return [Hash] A hash with indifferent read access containing any\n    #   validation errors where the key is the attribute name and the value is\n    #   an array of error messages.\n    # @example\n    #   account.errors                # => {\"account_code\"=>[\"can't be blank\"]}\n    #   account.errors[:account_code] # => [\"can't be blank\"]\n    def errors\n      @errors ||= Errors.new { |h, k| h[k] = [] }\n    end\n\n    # Marks a record as persisted, i.e. not a new or deleted record, resetting\n    # any tracked attribute changes in the process. (This is an internal method\n    # and should probably not be called unless you know what you're doing.)\n    #\n    # @api internal\n    # @return [true]\n    def persist!(saved = false)\n      @new_record, @uri = false\n      if changed?\n        @previous_changes = changes if saved\n        changed_attributes.clear\n      end\n      true\n    end\n\n    # @return [String, nil] The unique resource identifier (URI) of the record\n    #   (if persisted).\n    # @example\n    #   Recurly::Account.new(:account_code => \"account_code\").uri # => nil\n    #   Recurly::Account.find(\"account_code\").uri\n    #   # => \"https://api.recurly.com/v2/accounts/account_code\"\n    def uri\n      @href ||= ((API.base_uri + path).to_s if persisted?)\n    end\n\n    # Attempts to destroy the record.\n    #\n    # @return [true, false] +true+ if successful, +false+ if unable to destroy\n    # (if the record does not persist on Recurly).\n    # @raise [NotFound] The record cannot be found.\n    # @example\n    #   account = Recurly::Account.find account_code\n    #   race_condition = Recurly::Account.find account_code\n    #   account.destroy        # => true\n    #   account.destroy        # => false (already destroyed)\n    #   race_condition.destroy # raises Recurly::Resource::NotFound\n    def destroy\n      return false unless persisted?\n      @response = API.delete uri\n      @destroyed = true\n    rescue API::NotFound => e\n      raise NotFound, e.description\n    end\n\n    def signable_attributes\n      Hash[xml_keys.map { |key| [key, self[key]] }]\n    end\n\n    def ==(other)\n      other.is_a?(self.class) && other.to_s == to_s\n    end\n\n    def marshal_dump\n      [\n        @attributes.reject { |k, v| v.is_a?(Proc) },\n        @new_record,\n        @destroyed,\n        @uri,\n        @href,\n        changed_attributes,\n        previous_changes,\n        response,\n        etag,\n        links\n      ]\n    end\n\n    def marshal_load(serialization)\n      @attributes,\n        @new_record,\n        @destroyed,\n        @uri,\n        @href,\n        @changed_attributes,\n        @previous_changes,\n        @response,\n        @etag,\n        @links = serialization\n    end\n\n    # @return [String]\n    def inspect(attributes = self.class.attribute_names.to_a)\n      string = \"#<#{self.class}\"\n      string << \"##@type\" if instance_variable_defined? :@type\n      attributes += %w(errors) if errors.any?\n      string << \" %s\" % attributes.map { |k|\n        \"#{k}: #{self.send(k).inspect}\"\n      }.join(', ')\n      string << '>'\n    end\n    alias to_s inspect\n\n    def apply_errors(exception)\n      @response = exception.response\n      document = XML.new exception.response.body\n      document.each_element 'error' do |el|\n        attribute_path = el.attribute('field').value.split '.'\n        invalid! attribute_path[1, attribute_path.length], el.text\n      end\n    end\n\n    protected\n\n    def path\n      @href or @uri or if persisted?\n        self.class.member_path to_param\n      else\n        self.class.collection_path\n      end\n    end\n\n    def invalid!(attribute_path, error)\n      if attribute_path.length == 1\n        errors[attribute_path[0]] << error\n      else\n        child, k, v = attribute_path.shift.scan(/[^\\[\\]=]+/)\n        if c = k ? self[child].find { |d| d[k] == v } : self[child]\n          c.invalid! attribute_path, error\n          e = errors[child] << 'is invalid' and e.uniq!\n        end\n      end\n    end\n\n    def clear_errors\n      errors.clear\n      self.class.associations do |association|\n        next unless respond_to? \"#{association}=\" # Clear writable only.\n        [*self[association]].each do |associated|\n          associated.clear_errors if associated.respond_to? :clear_errors\n        end\n      end\n    end\n\n    def copy_from(other)\n      other.instance_variables.each do |ivar|\n        instance_variable_set ivar, other.instance_variable_get(ivar)\n      end\n    end\n\n    private\n\n    def fetch_associated(name, value, options = {})\n      case value\n      when Array\n        value.map do |v|\n          fetch_associated(Helper.singularize(name), v, association_name: name)\n        end\n      when Hash\n        association_name = options[:association_name] || name\n        associated_class_name = self.class.find_association(association_name).class_name\n        associated_class_name ||= Helper.classify(name)\n        Recurly.const_get(associated_class_name, false).send(:new, value)\n      when Proc, Resource, Resource::Pager, nil\n        value\n      else\n        raise \"unexpected association #{name.inspect}=#{value.inspect}\"\n      end\n    end\n\n    def xml_keys\n      changed_attributes.keys.sort\n    end\n  end\nend\n"], "fixing_code": ["module Recurly\n  # The API class handles all requests to the Recurly API. While most of its\n  # functionality is leveraged by the Resource class, it can be used directly,\n  # as well.\n  #\n  # Requests are made with methods named after the four main HTTP verbs\n  # recognized by the Recurly API.\n  #\n  # @example\n  #   Recurly::API.get 'accounts'             # => #<Net::HTTPOK ...>\n  #   Recurly::API.post 'accounts', xml_body  # => #<Net::HTTPCreated ...>\n  #   Recurly::API.put 'accounts/1', xml_body # => #<Net::HTTPOK ...>\n  #   Recurly::API.delete 'accounts/1'        # => #<Net::HTTPNoContent ...>\n  class API\n    require 'recurly/api/errors'\n\n    @@base_uri = \"https://api.recurly.com/v2/\"\n    @@valid_domains = [\".recurly.com\"]\n\n    RECURLY_API_VERSION = '2.8'\n\n    FORMATS = Helper.hash_with_indifferent_read_access(\n      'pdf' => 'application/pdf',\n      'xml' => 'application/xml'\n    )\n\n    class << self\n      # Additional HTTP headers sent with each API call\n      # @return [Hash{String => String}]\n      def headers\n        @headers ||= { 'Accept' => accept, 'User-Agent' => user_agent, 'X-Api-Version' => RECURLY_API_VERSION }\n      end\n\n      # @return [String, nil] Accept-Language header value\n      def accept_language\n        headers['Accept-Language']\n      end\n\n      # @param [String] language Accept-Language header value\n      def accept_language=(language)\n        headers['Accept-Language'] = language\n      end\n\n      # @return [Net::HTTPOK, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def head uri, params = {}, options = {}\n        request :head, uri, { :params => params || {} }.merge(options)\n      end\n\n      # @return [Net::HTTPOK, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def get uri, params = {}, options = {}\n        request :get, uri, { :params => params || {} }.merge(options)\n      end\n\n      # @return [Net::HTTPCreated, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def post uri, body = nil, options = {}\n        request :post, uri, { :body => body.to_s }.merge(options)\n      end\n\n      # @return [Net::HTTPOK, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def put uri, body = nil, options = {}\n        request :put, uri, { :body => body.to_s }.merge(options)\n      end\n\n      # @return [Net::HTTPNoContent, Net::HTTPResponse]\n      # @raise [ResponseError] With a non-2xx status code.\n      def delete uri, body = nil, options = {}\n        request :delete, uri, options\n      end\n\n      # @return [URI::Generic]\n      def base_uri\n        URI.parse @@base_uri.sub('api', Recurly.subdomain)\n      end\n\n      def validate_uri!(uri)\n        domain = @@valid_domains.detect { |d| uri.host.end_with?(d) }\n        unless domain\n          raise ArgumentError, \"URI #{uri} is invalid. You may only make requests to a Recurly domain.\"\n        end\n      end\n\n      # @return [String]\n      def user_agent\n        \"Recurly/#{Version}; #{RUBY_DESCRIPTION}\"\n      end\n\n      private\n\n      def accept\n        FORMATS['xml']\n      end\n      alias content_type accept\n    end\n  end\nend\n\nrequire 'recurly/api/net_http_adapter'\n", "require 'cgi'\nrequire 'net/https'\n\nmodule Recurly\n  class API\n    module Net\n      module HTTPAdapter\n        # A hash of Net::HTTP settings configured before the request.\n        #\n        # @return [Hash]\n        def net_http\n          @net_http ||= {}\n        end\n\n        # Used to store any Net::HTTP settings.\n        #\n        # @example\n        #   Recurly::API.net_http = {\n        #     :verify_mode => OpenSSL::SSL::VERIFY_PEER,\n        #     :ca_path     => \"/etc/ssl/certs\",\n        #     :ca_file     => \"/opt/local/share/curl/curl-ca-bundle.crt\"\n        #   }\n        attr_writer :net_http\n\n        private\n\n        METHODS = {\n          :head   => ::Net::HTTP::Head,\n          :get    => ::Net::HTTP::Get,\n          :post   => ::Net::HTTP::Post,\n          :put    => ::Net::HTTP::Put,\n          :delete => ::Net::HTTP::Delete\n        }\n\n        def request method, uri, options = {}\n          head = headers.dup\n          head.update options[:head] if options[:head]\n          head.delete_if { |_, value| value.nil? }\n          uri = base_uri + uri\n          if options[:params] && !options[:params].empty?\n            pairs = options[:params].map { |key, value|\n              \"#{CGI.escape key.to_s}=#{CGI.escape value.to_s}\"\n            }\n            uri += \"?#{pairs.join '&'}\"\n          end\n          self.validate_uri!(uri)\n          request = METHODS[method].new uri.request_uri, head\n          request.basic_auth(*[Recurly.api_key, nil].flatten[0, 2])\n          if options[:body]\n            request['Content-Type'] = content_type\n            request.body = options[:body]\n          end\n          if options[:etag]\n            request['If-None-Match'] = options[:etag]\n          end\n          if options[:format]\n            request['Accept'] = FORMATS[options[:format]]\n          end\n          if options[:locale]\n            request['Accept-Language'] = options[:locale]\n          end\n          http = ::Net::HTTP.new uri.host, uri.port\n          http.use_ssl = uri.scheme == 'https'\n          net_http.each_pair { |key, value| http.send \"#{key}=\", value }\n\n          if Recurly.logger\n            Recurly.log :info, \"===> %s %s\" % [request.method, uri]\n            headers = request.to_hash\n            headers['authorization'] &&= ['Basic [FILTERED]']\n            Recurly.log :debug, headers.inspect\n            if request.body && !request.body.empty?\n              Recurly.log :debug, XML.filter(request.body)\n            end\n            start_time = Time.now\n          end\n\n          response = http.start { http.request request }\n          code = response.code.to_i\n\n          if Recurly.logger\n            latency = (Time.now - start_time) * 1_000\n            level = case code\n              when 200...300 then :info\n              when 300...400 then :warn\n              when 400...500 then :error\n              else                :fatal\n            end\n            Recurly.log level, \"<=== %d %s (%.1fms)\" % [\n              code,\n              response.class.name[9, response.class.name.length].gsub(\n                /([a-z])([A-Z])/, '\\1 \\2'\n              ),\n              latency\n            ]\n            Recurly.log :debug, response.to_hash.inspect\n            Recurly.log :debug, response.body if response.body\n          end\n\n          case code\n            when 200...300 then response\n            else                raise ERRORS[code].new request, response\n          end\n        rescue Errno::ECONNREFUSED => e\n          raise Error, e.message\n        end\n      end\n    end\n\n    extend Net::HTTPAdapter\n  end\nend\n", "require 'date'\nrequire 'erb'\n\nmodule Recurly\n  # The base class for all Recurly resources (e.g. {Account}, {Subscription},\n  # {Transaction}).\n  #\n  # Resources behave much like\n  # {ActiveModel}[http://rubydoc.info/gems/activemodel] classes, especially\n  # like {ActiveRecord}[http://rubydoc.info/gems/activerecord].\n  #\n  # == Life Cycle\n  #\n  # To take you through the typical life cycle of a resource, we'll use\n  # {Recurly::Account} as an example.\n  #\n  # === Creating a Record\n  #\n  # You can instantiate a record before attempting to save it.\n  #\n  #   account = Recurly::Account.new :first_name => 'Walter'\n  #\n  # Once instantiated, you can assign and reassign any attribute.\n  #\n  #   account.first_name = 'Walt'\n  #   account.last_name = 'White'\n  #\n  # When you're ready to save, do so.\n  #\n  #   account.save # => false\n  #\n  # If save returns +false+, validation likely failed. You can check the record\n  # for errors.\n  #\n  #   account.errors # => {\"account_code\"=>[\"can't be blank\"]}\n  #\n  # Once the errors are fixed, you can try again.\n  #\n  #   account.account_code = 'heisenberg'\n  #   account.save # => true\n  #\n  # The object will be updated with any information provided by the server\n  # (including any UUIDs set).\n  #\n  #   account.created_at # => 2011-04-30 07:13:35 -0700\n  #\n  # You can also create accounts in one fell swoop.\n  #\n  #   Recurly::Account.create(\n  #     :first_name   => 'Jesse'\n  #     :last_name    => 'Pinkman'\n  #     :account_code => 'capn_cook'\n  #   )\n  #   # => #<Recurly::Account account_code: \"capn_cook\" ...>\n  #\n  # You can use alternative \"bang\" methods for exception control. If the record\n  # fails to save, a Recurly::Resource::Invalid exception will be raised.\n  #\n  #   begin\n  #     account = Recurly::Account.new :first_name => 'Junior'\n  #     account.save!\n  #   rescue Recurly::Resource::Invalid\n  #     p account.errors\n  #   end\n  #\n  # You can access the invalid record from the exception itself (if, for\n  # example, you use the <tt>create!</tt> method).\n  #\n  #   begin\n  #     Recurly::Account.create! :first_name => 'Skylar', :last_name => 'White'\n  #   rescue Recurly::Resource::Invalid => e\n  #     p e.record.errors\n  #   end\n  #\n  # === Fetching a Record\n  #\n  # Records are fetched by their unique identifiers.\n  #\n  #   account = Recurly::Account.find 'better_call_saul'\n  #   # => #<Recurly::Account account_code: \"better_call_saul\" ...>\n  #\n  # If the record doesn't exist, a Recurly::Resource::NotFound exception will\n  # be raised.\n  #\n  # === Updating a Record\n  #\n  # Once fetched, a record can be updated with a hash of attributes.\n  #\n  #   account.update_attributes :first_name => 'Saul', :last_name => 'Goodman'\n  #   # => true\n  #\n  # (A bang method, update_attributes!, will raise Recurly::Resource::Invalid.)\n  #\n  # You can also update a record by setting attributes and calling save.\n  #\n  #   account.last_name = 'McGill'\n  #   account.save # Alternatively, call save!\n  #\n  # === Deleting a Record\n  #\n  # To delete (deactivate, close, etc.) a fetched record, merely call destroy\n  # on it.\n  #\n  #   account.destroy # => true\n  #\n  # === Fetching a List of Records\n  #\n  # If you want to iterate over a list of accounts, you can use a Pager.\n  #\n  #   pager = Account.paginate :per_page => 50\n  #\n  # If you want to iterate over _every_ record, a convenience method will\n  # automatically paginate:\n  #\n  #   Account.find_each { |account| p account }\n  class Resource\n    require 'recurly/resource/errors'\n    require 'recurly/resource/pager'\n    require 'recurly/resource/association'\n\n    # Raised when a record cannot be found.\n    #\n    # @example\n    #   begin\n    #     Recurly::Account.find 'tortuga'\n    #   rescue Recurly::Resource::NotFound => e\n    #     e.message # => \"Can't find Account with account_code = tortuga\"\n    #   end\n    class NotFound < API::NotFound\n      def initialize(message)\n        set_message message\n      end\n    end\n\n    # Raised when a record is invalid.\n    #\n    # @example\n    #   begin\n    #     Recurly::Account.create! :first_name => \"Flynn\"\n    #   rescue Recurly::Resource::Invalid => e\n    #     e.record.errors # => errors: {\"account_code\"=>[\"can't be blank\"]}>\n    #   end\n    class Invalid < Error\n      # @return [Resource, nil] The invalid record.\n      attr_reader :record\n\n      def initialize(message)\n        if message.is_a? Resource\n          @record = message\n          set_message(record_to_message)\n        else\n          set_message(message)\n        end\n      end\n\n      private\n\n      def record_to_message\n        @record.errors.map do |k, v|\n          message = v.join(', ')\n          k == 'base' ? message : \"#{k} #{message}\"\n        end.join('; ')\n      end\n    end\n\n    class << self\n      # @return [String] The demodulized name of the resource class.\n      # @example\n      #   Recurly::Account.name # => \"Account\"\n      def resource_name\n        Helper.demodulize name\n      end\n\n      # @return [String] The underscored, pluralized name of the resource\n      #   class.\n      # @example\n      #   Recurly::Account.collection_name # => \"accounts\"\n      def collection_name\n        Helper.pluralize Helper.underscore(resource_name)\n      end\n      alias collection_path collection_name\n\n      # @return [String] The underscored name of the resource class.\n      # @example\n      #   Recurly::Account.member_name # => \"account\"\n      def member_name\n        Helper.underscore resource_name\n      end\n\n      # @return [String] The relative path to a resource's identifier from the\n      #   API's base URI.\n      # @param uuid [String, nil]\n      # @example\n      #   Recurly::Account.member_path \"code\" # => \"accounts/code\"\n      #   Recurly::Account.member_path nil    # => \"accounts\"\n      def member_path(uuid)\n        uuid = ERB::Util.url_encode(uuid) if uuid\n        [collection_path, uuid].compact.join '/'\n      end\n\n      # @return [Array] Per attribute, defines readers, writers, boolean and\n      #   change-tracking methods.\n      # @param attribute_names [Array] An array of attribute names.\n      # @example\n      #   class Account < Resource\n      #     define_attribute_methods [:name]\n      #   end\n      #\n      #   a = Account.new\n      #   a.name?            # => false\n      #   a.name             # => nil\n      #   a.name = \"Stephen\"\n      #   a.name?            # => true\n      #   a.name             # => \"Stephen\"\n      #   a.name_changed?    # => true\n      #   a.name_was         # => nil\n      #   a.name_change      # => [nil, \"Stephen\"]\n      def define_attribute_methods(attribute_names)\n        @attribute_names = attribute_names.map! { |m| m.to_s }.sort!.freeze\n        remove_const :AttributeMethods if constants.include? :AttributeMethods\n        include const_set :AttributeMethods, Module.new {\n          attribute_names.each do |name|\n            define_method(name) { self[name] }                       # Get.\n            define_method(\"#{name}=\") { |value| self[name] = value } # Set.\n            define_method(\"#{name}?\") { !!self[name] }               # Present.\n            define_method(\"#{name}_change\") { changes[name] }        # Dirt...\n            define_method(\"#{name}_changed?\") { changed_attributes.key? name }\n            define_method(\"#{name}_was\") { changed_attributes[name] }\n            define_method(\"#{name}_previously_changed?\") {\n              previous_changes.key? name\n            }\n            define_method(\"#{name}_previously_was\") {\n              previous_changes[name].first if previous_changes.key? name\n            }\n          end\n        }\n      end\n\n      # @return [Array, nil] The list of attribute names defined for the\n      #   resource class.\n      attr_reader :attribute_names\n\n      # @return [Pager] A pager with an iterable collection of records\n      # @param options [Hash] A hash of pagination options\n      # @option options [Integer] :per_page The number of records returned per\n      #   page\n      # @option options [DateTime, Time, Integer] :cursor A timestamp that the\n      #   pager will skim back to and return records created before it\n      # @option options [String] :etag When set, will raise\n      #   {Recurly::API::NotModified} if the pager's loaded page content has\n      #   not changed\n      # @example Fetch 50 records and iterate over them\n      #   Recurly::Account.paginate(:per_page => 50).each { |a| p a }\n      # @example Fetch records before January 1, 2011\n      #   Recurly::Account.paginate(:cursor => Time.new(2011, 1, 1))\n      def paginate(options = {})\n        Pager.new self, options\n      end\n      alias scoped paginate\n      alias where  paginate\n\n      def all(options = {})\n        paginate(options).to_a\n      end\n\n      # @return [Hash] Defined scopes per resource.\n      def scopes\n        @scopes ||= Recurly::Helper.hash_with_indifferent_read_access\n      end\n\n      # @return [Module] Module of scopes methods.\n      def scopes_helper\n        @scopes_helper ||= Module.new.tap { |helper| extend helper }\n      end\n\n      # Defines a new resource scope.\n      #\n      # @return [Proc]\n      # @param [Symbol] name the scope name\n      # @param [Hash] params the scope params\n      def scope(name, params = {})\n        scopes[name = name.to_s] = params\n        scopes_helper.send(:define_method, name) { paginate scopes[name] }\n      end\n\n      # Iterates through every record by automatically paging.\n      #\n      # @return [nil]\n      # @param [Integer] per_page The number of records returned per request.\n      # @yield [record]\n      # @see Pager#find_each\n      # @example\n      #   Recurly::Account.find_each { |a| p a }\n      def find_each(per_page = 50, &block)\n        paginate(:per_page => per_page).find_each(&block)\n      end\n\n      # @return [Integer] The total record count of the resource in question.\n      # @see Pager#count\n      # @example\n      #   Recurly::Account.count # => 42\n      def count\n        paginate.count\n      end\n\n      # @api internal\n      # @return [Resource, nil]\n      def first\n        paginate(:per_page => 1).first\n      end\n\n      # @return [Resource] A record matching the designated unique identifier.\n      # @param [String] uuid The unique identifier of the resource to be\n      #   retrieved.\n      # @param [Hash] options A hash of options.\n      # @option options [String] :etag When set, will raise {API::NotModified}\n      #   if the record content has not changed.\n      # @raise [Error] If the resource has no identifier (and thus cannot be\n      #   retrieved).\n      # @raise [NotFound] If no resource can be found for the supplied\n      #   identifier (or the supplied identifier is +nil+).\n      # @raise [API::NotModified] If the <tt>:etag</tt> option is set and\n      #   matches the server's.\n      # @example\n      #   Recurly::Account.find \"heisenberg\"\n      #   # => #<Recurly::Account account_code: \"heisenberg\", ...>\n      #   Use the following identifiers for these types of objects:\n      #     for accounts use account_code\n      #     for plans use plan_code\n      #     for invoices use invoice_number\n      #     for subscriptions use uuid\n      #     for transactions use uuid\n      def find(uuid, options = {})\n        if uuid.nil? || uuid.to_s.empty?\n          raise NotFound, \"can't find a record with nil identifier\"\n        end\n\n        begin\n          from_response API.get(member_path(uuid), {}, options)\n        rescue API::NotFound => e\n          raise NotFound, e.description\n        end\n      end\n\n      # Instantiates and attempts to save a record.\n      #\n      # @return [Resource] The record.\n      # @raise [Transaction::Error] A monetary transaction failed.\n      # @see create!\n      def create(attributes = {})\n        new(attributes) { |record| record.save }\n      end\n\n      # Instantiates and attempts to save a record.\n      #\n      # @return [Resource] The saved record.\n      # @raise [Invalid] The record is invalid.\n      # @raise [Transaction::Error] A monetary transaction failed.\n      # @see create\n      def create!(attributes = {})\n        new(attributes) { |record| record.save! }\n      end\n\n      # Instantiates a record from an HTTP response, setting the record's\n      # response attribute in the process.\n      #\n      # @return [Resource]\n      # @param response [Net::HTTPResponse]\n      def from_response(response)\n        content_type = response['Content-Type']\n\n        case content_type\n        when %r{application/pdf}\n          response.body\n        when %r{application/xml}\n          record = from_xml response.body\n          record.instance_eval { @etag, @response = response['ETag'], response }\n          record\n        else\n          raise Recurly::Error, \"Content-Type \\\"#{content_type}\\\" is not accepted\"\n        end\n      end\n\n      # Instantiates a record from an XML blob: either a String or XML element.\n      #\n      # Assuming the record is from an API response, the record is flagged as\n      # persisted.\n      #\n      # @return [Resource]\n      # @param xml [String, REXML::Element, Nokogiri::XML::Node]\n      # @see from_response\n      def from_xml(xml)\n        xml = XML.new xml\n\n        if self != Resource || xml.name == member_name\n          record = new\n        elsif Recurly.const_defined?(class_name = Helper.classify(xml.name), false)\n          klass = Recurly.const_get class_name, false\n          record = klass.send :new\n        elsif root = xml.root and root.elements.empty?\n          return XML.cast root\n        else\n          record = {}\n        end\n        klass ||= self\n\n        xml.root.attributes.each do |name, value|\n          record.instance_variable_set \"@#{name}\", value.to_s\n        end\n\n        xml.each_element do |el|\n          # skip this element if it's an xml comment\n          next if defined?(Nokogiri::XML::Node::TEXT_NODE) && el.is_a?(Nokogiri::XML::Comment)\n\n          if el.name == 'a'\n            record.links[el.attribute('name').value] = {\n              :method => el.attribute('method').to_s,\n              :href => el.attribute('href').value\n            }\n            next\n          end\n\n          # Nokogiri on Jruby-1.7.19 likes to throw NullPointer exceptions\n          # if you try to run certian operations like el.attribute(''). Since\n          # we dont care about text nodes, let's just skip them\n          next if defined?(Nokogiri::XML::Node::TEXT_NODE) && el.node_type == Nokogiri::XML::Node::TEXT_NODE\n\n          if el.children.empty? && href = el.attribute('href')\n            klass_name = Helper.classify(klass.association_class_name(el.name) ||\n                                         el.attribute('type') ||\n                                         el.name)\n\n            next unless Recurly.const_defined?(klass_name)\n\n            resource_class = Recurly.const_get(klass_name, false)\n\n            case el.name\n            when *klass.associations_for_relation(:has_many)\n              record[el.name] = Pager.new(\n                resource_class, :uri => href.value, :parent => record\n              )\n            when *(klass.associations_for_relation(:has_one) + klass.associations_for_relation(:belongs_to))\n              record.links[el.name] = {\n                :resource_class => resource_class,\n                :method => :get,\n                :href => href.value\n              }\n            end\n          else\n            # TODO name tax_type conflicts with the TaxType\n            # class so if we get to this point was can assume\n            # it's the string. Will need to refactor this\n            if el.name == 'tax_type'\n              record[el.name] = el.text\n            else\n              val = XML.cast(el)\n\n              # TODO we have to clear changed attributes after\n              # parsing here or else it always serializes. Need\n              # a better way of handling changed attributes\n              if el.name == 'address' && val.kind_of?(Hash)\n                address = Address.new(val)\n                address.instance_variable_set(:@changed_attributes, {})\n                record[el.name] = address\n              else\n                record[el.name] = val\n              end\n            end\n          end\n        end\n\n        record.persist! if record.respond_to? :persist!\n        record\n      end\n\n      # @return [Array] A list of associations for the current class.\n      def associations\n        @associations ||= []\n      end\n\n      # @return [Array] A list of associated resource classes with\n      # the relation [:has_many, :has_one, :belongs_to] for the current class.\n      def associations_for_relation(relation)\n        associations.select{ |a| a.relation == relation }.map(&:resource_class)\n      end\n\n      # @return [String, nil] The actual associated resource class name\n      # for the current class if the resource class does not match the\n      # actual class.\n      def association_class_name(resource_class)\n        association = find_association(resource_class)\n        association.class_name if association\n      end\n\n      # @return [Association, nil] Find association for the current class\n      #                            with resource class name.\n      def find_association(resource_class)\n        associations.find{ |a| a.resource_class.to_s == resource_class.to_s }\n      end\n\n      def associations_helper\n        @associations_helper ||= Module.new.tap { |helper| include helper }\n      end\n\n      # Establishes a has_many association.\n      #\n      # @return [Proc, nil]\n      # @param collection_name [Symbol] Association name.\n      # @param options [Hash] A hash of association options.\n      # @option options [true, false] :readonly Don't define a setter.\n      #                 [String] :class_name Actual associated resource class name\n      #                                      if not same as collection_name.\n      def has_many(collection_name, options = {})\n        associations << Association.new(:has_many, collection_name.to_s, options)\n        associations_helper.module_eval do\n          define_method collection_name do\n            if self[collection_name]\n              self[collection_name]\n            else\n              attributes[collection_name] = []\n            end\n          end\n          if options.key?(:readonly) && options[:readonly] == false\n            define_method \"#{collection_name}=\" do |collection|\n              self[collection_name] = collection\n            end\n          end\n        end\n      end\n\n      # Establishes a has_one association.\n      #\n      # @return [Proc, nil]\n      # @param member_name [Symbol] Association name.\n      # @param options [Hash] A hash of association options.\n      # @option options [true, false] :readonly Don't define a setter.\n      #                 [String] :class_name Actual associated resource class name\n      #                                      if not same as member_name.\n      def has_one(member_name, options = {})\n        associations << Association.new(:has_one, member_name.to_s, options)\n        associations_helper.module_eval do\n          define_method(member_name) { self[member_name] }\n          if options.key?(:readonly) && options[:readonly] == false\n            associated = Recurly.const_get Helper.classify(member_name), false\n            define_method \"#{member_name}=\" do |member|\n              associated_uri = \"#{path}/#{member_name}\"\n              self[member_name] = case member\n              when Hash\n                associated.send :new, member.merge(:uri => associated_uri)\n              when associated\n                member.uri = associated_uri and member\n              else\n                raise ArgumentError, \"expected #{associated}\"\n              end\n            end\n            define_method \"build_#{member_name}\" do |*args|\n              attributes = args.shift || {}\n              self[member_name] = associated.send(\n                :new, attributes.merge(:uri => \"#{path}/#{member_name}\")\n              ).tap { |child| child.attributes[self.class.member_name] = self }\n            end\n            define_method \"create_#{member_name}\" do |*args|\n              send(\"build_#{member_name}\", *args).tap { |child| child.save }\n            end\n          end\n        end\n      end\n\n      # Establishes a belongs_to association.\n      #\n      # @return [Proc]\n      # @param parent_name [Symbol] Association name.\n      # @param options [Hash] A hash of association options.\n      # @option options [true, false] :readonly Don't define a setter.\n      #                 [String] :class_name Actual associated resource class name\n      #                                      if not same as parent_name.\n      def belongs_to(parent_name, options = {})\n        associations << Association.new(:belongs_to, parent_name.to_s, options)\n        associations_helper.module_eval do\n          define_method(parent_name) { self[parent_name] }\n          if options.key?(:readonly) && options[:readonly] == false\n            define_method \"#{parent_name}=\" do |parent|\n              self[parent_name] = parent\n            end\n          end\n        end\n      end\n\n      # @return [:has_many, :has_one, :belongs_to, nil] An association type.\n      def reflect_on_association(name)\n        a = find_association(name)\n        a.relation if a\n      end\n\n      def embedded!(root_index = false)\n        protected :initialize\n        private_class_method(*%w(create create!))\n        unless root_index\n          private_class_method(*%w(all find_each first paginate scoped where))\n        end\n      end\n    end\n\n    # @return [Hash] The raw hash of record attributes.\n    attr_reader :attributes\n\n    # @return [Net::HTTPResponse, nil] The most recent response object for the\n    #   record (updated during {#save} and {#destroy}).\n    attr_reader :response\n\n    # @return [String, nil] An ETag for the current record.\n    attr_reader :etag\n\n    # @return [String, nil] A writer to override the URI the record saves to.\n    attr_writer :uri\n\n    # @return [Resource] A new resource instance.\n    # @param attributes [Hash] A hash of attributes.\n    def initialize(attributes = {})\n      if instance_of? Resource\n        raise Error,\n          \"#{self.class} is an abstract class and cannot be instantiated\"\n      end\n\n      @attributes, @new_record, @destroyed, @uri, @href = {}, true, false\n      self.attributes = attributes\n      yield self if block_given?\n    end\n\n    # @return [self] Reloads the record from the server.\n    def reload(response = nil)\n      if response\n        return if response.body.to_s.length.zero?\n        fresh = self.class.from_response response\n      else\n        fresh = self.class.find(\n          @href || to_param, :etag => (etag unless changed?)\n        )\n      end\n      fresh and copy_from fresh\n      persist! true\n      self\n    rescue API::NotModified\n      self\n    end\n\n    # @return [Hash] Hash of changed attributes.\n    # @see #changes\n    def changed_attributes\n      @changed_attributes ||= {}\n    end\n\n    # @return [Array] A list of changed attribute keys.\n    def changed\n      changed_attributes.keys\n    end\n\n    # Do any attributes have unsaved changes?\n    # @return [true, false]\n    def changed?\n      !changed_attributes.empty?\n    end\n\n    # @return [Hash] Map of changed attributes to original value and new value.\n    def changes\n      changed_attributes.inject({}) { |changes, (key, original_value)|\n        changes[key] = [original_value, self[key]] and changes\n      }\n    end\n\n    # @return [Hash] Previously-changed attributes.\n    # @see #changes\n    def previous_changes\n      @previous_changes ||= {}\n    end\n\n    # Is the record new (i.e., not saved on Recurly's servers)?\n    #\n    # @return [true, false]\n    # @see #persisted?\n    # @see #destroyed?\n    def new_record?\n      @new_record\n    end\n\n    # Has the record been destroyed? (Set +true+ after a successful destroy.)\n    # @return [true, false]\n    # @see #new_record?\n    # @see #persisted?\n    def destroyed?\n      @destroyed\n    end\n\n    # Has the record persisted (i.e., saved on Recurly's servers)?\n    #\n    # @return [true, false]\n    # @see #new_record?\n    # @see #destroyed?\n    def persisted?\n      !(new_record? || destroyed?)\n    end\n\n    # The value of a specified attribute, lazily fetching any defined\n    # association.\n    #\n    # @param key [Symbol, String] The name of the attribute to be fetched.\n    # @example\n    #   account.read_attribute :first_name # => \"Ted\"\n    #   account[:last_name]                # => \"Beneke\"\n    # @see #write_attribute\n    def read_attribute(key)\n      key = key.to_s\n      if attributes.key? key\n        value = attributes[key]\n      elsif links.key?(key) && self.class.reflect_on_association(key)\n        value = attributes[key] = follow_link key\n      end\n      value\n    end\n    alias [] read_attribute\n\n    # Sets the value of a specified attribute.\n    #\n    # @param key [Symbol, String] The name of the attribute to be set.\n    # @param value [Object] The value the attribute will be set to.\n    # @example\n    #   account.write_attribute :first_name, 'Gus'\n    #   account[:company_name] = 'Los Pollos Hermanos'\n    # @see #read_attribute\n    def write_attribute(key, value)\n      if changed_attributes.key?(key = key.to_s)\n        changed_attributes.delete key if changed_attributes[key] == value\n      elsif self[key] != value\n        changed_attributes[key] = self[key]\n      end\n\n      association = self.class.find_association(key)\n      if association\n        value = fetch_associated(key, value)\n      # FIXME: More explicit; less magic.\n      elsif value && key.end_with?('_in_cents') && !respond_to?(:currency)\n        value = Money.new(value, self, key) unless value.is_a?(Money)\n      end\n\n      attributes[key] = value\n    end\n    alias []= write_attribute\n\n    # Apply a given hash of attributes to a record.\n    #\n    # @return [Hash]\n    # @param attributes [Hash] A hash of attributes.\n    def attributes=(attributes = {})\n      attributes.each_pair { |k, v|\n        respond_to?(name = \"#{k}=\") and send(name, v) or self[k] = v\n      }\n    end\n\n    def as_json(options = nil)\n      attributes.reject { |k, v| v.is_a?(Recurly::Resource::Pager) }\n    end\n\n    # @return [Hash] The raw hash of record href links.\n    def links\n      @links ||= {}\n    end\n\n    # Whether a record has a link with the given name.\n    #\n    # @param key [Symbol, String] The name of the link to check for.\n    # @example\n    #   account.link? :billing_info # => true\n    def link?(key)\n      links.key?(key.to_s)\n    end\n\n    # Fetch the value of a link by following the associated href.\n    #\n    # @param key [Symbol, String] The name of the link to be followed.\n    # @param options [Hash] A hash of API options.\n    # @example\n    #   account.read_link :billing_info # => <Recurly::BillingInfo>\n    def follow_link(key, options = {})\n      if link = links[key = key.to_s]\n        response = API.send link[:method], link[:href], options[:body], options\n        if resource_class = link[:resource_class]\n          response = resource_class.from_response response\n          response.attributes[self.class.member_name] = self\n        end\n        response\n      end\n    rescue Recurly::API::NotFound\n      raise unless resource_class\n    end\n\n    # Serializes the record to XML.\n    #\n    # @return [String] An XML string.\n    # @param options [Hash] A hash of XML options.\n    # @example\n    #   Recurly::Account.new(:account_code => 'code').to_xml\n    #   # => \"<account><account_code>code</account_code></account>\"\n    def to_xml(options = {})\n      builder = options[:builder] || XML.new(\"<#{self.class.member_name}/>\")\n      xml_keys.each { |key|\n        value = respond_to?(key) ? send(key) : self[key]\n        node = builder.add_element key\n\n        # Duck-typing here is problematic because of ActiveSupport's #to_xml.\n        case value\n        when Resource, Subscription::AddOns\n          value.to_xml options.merge(:builder => node)\n        when Array\n          value.each do |e|\n            if e.is_a? Recurly::Resource\n              # create a node to hold this resource\n              e_node = node.add_element Helper.singularize(key)\n              # serialize the resource into this node\n              e.to_xml(options.merge(builder: e_node))\n            else\n              # it's just a primitive value\n              node.add_element(Helper.singularize(key), e)\n            end\n          end\n        when Hash, Recurly::Money\n          value.each_pair { |k, v| node.add_element k.to_s, v }\n        else\n          node.text = value\n        end\n      }\n      builder.to_s\n    end\n\n    # Attempts to save the record, returning the success of the request.\n    #\n    # @return [true, false]\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Recurly::Account.new\n    #   account.save # => false\n    #   account.account_code = 'account_code'\n    #   account.save # => true\n    # @see #save!\n    def save\n      if new_record? || changed?\n        clear_errors\n        @response = API.send(\n          persisted? ? :put : :post, path, to_xml\n        )\n        reload response\n        persist! true\n      end\n      true\n    rescue API::UnprocessableEntity => e\n      apply_errors e\n      Transaction::Error.validate! e, (self if is_a?(Transaction))\n      false\n    end\n\n    # Attempts to save the record, returning +true+ if the record was saved and\n    # raising {Invalid} otherwise.\n    #\n    # @return [true]\n    # @raise [Invalid] The record was invalid.\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Recurly::Account.new\n    #   account.save! # raises Recurly::Resource::Invalid\n    #   account.account_code = 'account_code'\n    #   account.save! # => true\n    # @see #save\n    def save!\n      save || raise(Invalid.new(self))\n    end\n\n    # @return [true, false, nil] The validity of the record: +true+ if the\n    #   record was successfully saved (or persisted and unchanged), +false+ if\n    #   the record was not successfully saved, or +nil+ for a record with an\n    #   unknown state (i.e.  (i.e. new records that haven't been saved and\n    #   persisted records with changed attributes).\n    # @example\n    #   account = Recurly::Account.new\n    #   account.valid? # => nil\n    #   account.save   # => false\n    #   account.valid? # => false\n    #   account.account_code = 'account_code'\n    #   account.save   # => true\n    #   account.valid? # => true\n    def valid?\n      return true if persisted? && !changed?\n      errors_empty = errors.values.flatten.empty?\n      return if errors_empty && changed?\n      errors_empty\n    end\n\n    # Update a record with a given hash of attributes.\n    #\n    # @return [true, false] The success of the update.\n    # @param attributes [Hash] A hash of attributes.\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Account.find 'junior'\n    #   account.update_attributes :account_code => 'flynn' # => true\n    # @see #update_attributes!\n    def update_attributes(attributes = {})\n      self.attributes = attributes and save\n    end\n\n    # Update a record with a given hash of attributes.\n    #\n    # @return [true] The update was successful.\n    # @param attributes [Hash] A hash of attributes.\n    # @raise [Invalid] The record was invalid.\n    # @raise [Transaction::Error] A monetary transaction failed.\n    # @example\n    #   account = Account.find 'gale_boetticher'\n    #   account.update_attributes! :account_code => nil # Raises an exception.\n    # @see #update_attributes\n    def update_attributes!(attributes = {})\n      self.attributes = attributes and save!\n    end\n\n    # @return [Hash] A hash with indifferent read access containing any\n    #   validation errors where the key is the attribute name and the value is\n    #   an array of error messages.\n    # @example\n    #   account.errors                # => {\"account_code\"=>[\"can't be blank\"]}\n    #   account.errors[:account_code] # => [\"can't be blank\"]\n    def errors\n      @errors ||= Errors.new { |h, k| h[k] = [] }\n    end\n\n    # Marks a record as persisted, i.e. not a new or deleted record, resetting\n    # any tracked attribute changes in the process. (This is an internal method\n    # and should probably not be called unless you know what you're doing.)\n    #\n    # @api internal\n    # @return [true]\n    def persist!(saved = false)\n      @new_record, @uri = false\n      if changed?\n        @previous_changes = changes if saved\n        changed_attributes.clear\n      end\n      true\n    end\n\n    # @return [String, nil] The unique resource identifier (URI) of the record\n    #   (if persisted).\n    # @example\n    #   Recurly::Account.new(:account_code => \"account_code\").uri # => nil\n    #   Recurly::Account.find(\"account_code\").uri\n    #   # => \"https://api.recurly.com/v2/accounts/account_code\"\n    def uri\n      @href ||= ((API.base_uri + path).to_s if persisted?)\n    end\n\n    # Attempts to destroy the record.\n    #\n    # @return [true, false] +true+ if successful, +false+ if unable to destroy\n    # (if the record does not persist on Recurly).\n    # @raise [NotFound] The record cannot be found.\n    # @example\n    #   account = Recurly::Account.find account_code\n    #   race_condition = Recurly::Account.find account_code\n    #   account.destroy        # => true\n    #   account.destroy        # => false (already destroyed)\n    #   race_condition.destroy # raises Recurly::Resource::NotFound\n    def destroy\n      return false unless persisted?\n      @response = API.delete uri\n      @destroyed = true\n    rescue API::NotFound => e\n      raise NotFound, e.description\n    end\n\n    def signable_attributes\n      Hash[xml_keys.map { |key| [key, self[key]] }]\n    end\n\n    def ==(other)\n      other.is_a?(self.class) && other.to_s == to_s\n    end\n\n    def marshal_dump\n      [\n        @attributes.reject { |k, v| v.is_a?(Proc) },\n        @new_record,\n        @destroyed,\n        @uri,\n        @href,\n        changed_attributes,\n        previous_changes,\n        response,\n        etag,\n        links\n      ]\n    end\n\n    def marshal_load(serialization)\n      @attributes,\n        @new_record,\n        @destroyed,\n        @uri,\n        @href,\n        @changed_attributes,\n        @previous_changes,\n        @response,\n        @etag,\n        @links = serialization\n    end\n\n    # @return [String]\n    def inspect(attributes = self.class.attribute_names.to_a)\n      string = \"#<#{self.class}\"\n      string << \"##@type\" if instance_variable_defined? :@type\n      attributes += %w(errors) if errors.any?\n      string << \" %s\" % attributes.map { |k|\n        \"#{k}: #{self.send(k).inspect}\"\n      }.join(', ')\n      string << '>'\n    end\n    alias to_s inspect\n\n    def apply_errors(exception)\n      @response = exception.response\n      document = XML.new exception.response.body\n      document.each_element 'error' do |el|\n        attribute_path = el.attribute('field').value.split '.'\n        invalid! attribute_path[1, attribute_path.length], el.text\n      end\n    end\n\n    protected\n\n    def path\n      @href or @uri or if persisted?\n        self.class.member_path to_param\n      else\n        self.class.collection_path\n      end\n    end\n\n    def invalid!(attribute_path, error)\n      if attribute_path.length == 1\n        errors[attribute_path[0]] << error\n      else\n        child, k, v = attribute_path.shift.scan(/[^\\[\\]=]+/)\n        if c = k ? self[child].find { |d| d[k] == v } : self[child]\n          c.invalid! attribute_path, error\n          e = errors[child] << 'is invalid' and e.uniq!\n        end\n      end\n    end\n\n    def clear_errors\n      errors.clear\n      self.class.associations do |association|\n        next unless respond_to? \"#{association}=\" # Clear writable only.\n        [*self[association]].each do |associated|\n          associated.clear_errors if associated.respond_to? :clear_errors\n        end\n      end\n    end\n\n    def copy_from(other)\n      other.instance_variables.each do |ivar|\n        instance_variable_set ivar, other.instance_variable_get(ivar)\n      end\n    end\n\n    private\n\n    def fetch_associated(name, value, options = {})\n      case value\n      when Array\n        value.map do |v|\n          fetch_associated(Helper.singularize(name), v, association_name: name)\n        end\n      when Hash\n        association_name = options[:association_name] || name\n        associated_class_name = self.class.find_association(association_name).class_name\n        associated_class_name ||= Helper.classify(name)\n        Recurly.const_get(associated_class_name, false).send(:new, value)\n      when Proc, Resource, Resource::Pager, nil\n        value\n      else\n        raise \"unexpected association #{name.inspect}=#{value.inspect}\"\n      end\n    end\n\n    def xml_keys\n      changed_attributes.keys.sort\n    end\n  end\nend\n"], "filenames": ["lib/recurly/api.rb", "lib/recurly/api/net_http_adapter.rb", "lib/recurly/resource.rb"], "buggy_code_start_loc": [17, 45, 338], "buggy_code_end_loc": [77, 45, 341], "fixing_code_start_loc": [18, 46, 337], "fixing_code_end_loc": [86, 47, 340], "type": "CWE-918", "message": "The Recurly Client Ruby Library before 2.0.13, 2.1.11, 2.2.5, 2.3.10, 2.4.11, 2.5.4, 2.6.3, 2.7.8, 2.8.2, 2.9.2, 2.10.4, 2.11.3 is vulnerable to a Server-Side Request Forgery vulnerability in the \"Resource#find\" method that could result in compromise of API keys or other critical resources.", "other": {"cve": {"id": "CVE-2017-0905", "sourceIdentifier": "support@hackerone.com", "published": "2017-11-13T17:29:00.427", "lastModified": "2019-10-09T23:21:11.040", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Recurly Client Ruby Library before 2.0.13, 2.1.11, 2.2.5, 2.3.10, 2.4.11, 2.5.4, 2.6.3, 2.7.8, 2.8.2, 2.9.2, 2.10.4, 2.11.3 is vulnerable to a Server-Side Request Forgery vulnerability in the \"Resource#find\" method that could result in compromise of API keys or other critical resources."}, {"lang": "es", "value": "La biblioteca de Ruby Recurly Client en versiones anteriores a la 2.0.13, 2.1.11, 2.2.5, 2.3.10, 2.4.11, 2.5.4, 2.6.3, 2.7.8, 2.8.2, 2.9.2, 2.10.4 y 2.11.3 es vulnerable a Server-Side Request Forgery en el m\u00e9todo \"Resource#find\" que podr\u00eda conllevar el compromiso de las claves API o de otros recursos cr\u00edticos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D2111C93-1F01-4B79-B731-14E639037521"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "BE0E6539-B427-4F49-8F7D-9D7778E2174B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "D1DCAD09-8071-4965-88B6-64D83F9FEDB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "BE1A049E-4B43-4FF8-9AFC-803A85ABF7AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "6C1515F4-4B33-4A04-8448-A2E4397B1581"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "5215C59F-D763-41F4-9673-77B64481DF16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "667CAF6A-2F8D-498A-9797-CEB2C457F967"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "78812028-9678-48FF-83B4-C6BA0DA5ED95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "3BC2ABD2-E685-45E4-A423-909DF3C8FABE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "1169885A-59C3-40B8-AC53-625A20A40295"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "B660902B-353C-4917-A607-3DEBB076B130"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "8CE4D650-30B2-461C-BB58-E56112B21E16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "429B0B74-B230-428A-BF7D-FDE45FACBA7E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "62D6ED01-8289-4F93-ADC6-0E5C5E8BD348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.0:c:*:*:*:*:*:*", "matchCriteriaId": "13ABB028-6997-40DC-B61E-27238BEF99A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "3746FE6C-CE9F-4267-871D-D585CD404305"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "F725D5E4-E81F-4DB7-AE22-F9A36872CC75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "29351445-7C64-4409-9B5E-5AEBB96FC4C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "8516A98B-AE81-48A9-BBBA-9F050FE0AD60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B6F5715-A3D5-4CCC-9645-AFB56E26FD5E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "3FD7D5EB-4C42-4966-ACAA-185DA5ECB72A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "4C65414F-75FC-4C15-8265-F73E9BFAB067"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "16944240-53F2-4F7D-9C29-DF2B0CA5C763"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "ED1A64D2-F06A-490B-8D59-B6F9B83E9152"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "58881236-C96F-461C-BFE0-5880039C1203"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "DC547D0F-E1FB-4C19-A3D0-D3FC48E4EDB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "99AFBA9B-BFA3-494C-90B9-55F3D18604DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "066D3983-6BF1-4416-B87E-725122DF82EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "A9FBEB10-5B34-47F6-85BC-8995CE77AC05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "869018B3-4286-4D34-B69F-4749A61DC1A5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "95919D64-1B0F-4005-BDF8-C390DBA181E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "0F8A6E88-C153-440B-AEC6-EBA2BFD3E2E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "2F8F03AC-BD84-4D2A-B6DC-94BF509C3C67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "E288DC42-7D2E-404D-85FF-CA02CFD16164"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E53C11E-E506-4113-95D8-C526E70A2AAA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5BC2A4D-D523-4B82-872C-EF2D1F70992D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33692513-74D9-472C-B3D3-54F06C835832"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "09210851-79D4-49B5-994E-07E40C489D16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "8021F44A-CD23-4D15-9411-20F0E28C7D25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A9C5ADAE-E620-4440-8C3D-D071A279FB2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.3.9:*:*:*:*:*:*:*", "matchCriteriaId": "A810DF15-CCDF-4D5E-A3A2-4DF852D9CBF4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "8D427209-016F-4115-9447-7F96875A7D86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "36D5AD56-959D-4990-9B43-170D9083CDF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "78789F09-77A2-4A86-882D-DEA4E52ED6C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "0737A57D-411D-4BB5-83FC-15900B0D9150"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "633161B1-1E51-40E9-8EE2-9EDCDDA653D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "9E2CC4EA-8D08-42D8-A822-78042CD7946D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "91083CF3-8A5C-4178-A91A-BB6DE3C2BAF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "D9BC8E96-C437-4016-8A22-F402BF6B8E19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "A9E8AD18-59DF-45BD-AB25-F62CAEC223FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2BDD100-4A8E-4700-9377-22AB1483E76C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "1E580467-9DC2-43CC-8C00-92BCFC4DA49A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "01596D40-6039-4626-AF32-FE4C217EE120"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "ED738A23-EB6C-4BAF-9CDF-209C6EF8E70D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "26315E34-0869-4A18-B9E7-4E3306FAB4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "881A7D1C-769C-4B10-9034-E017CD300280"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4775539-0309-4FEA-BE79-2D45FE4E0B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "7E684118-BCA4-4A8F-A49C-87B06294523F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24E0F3B-EA8D-4D67-B16E-244E8954155F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEF8F56B-BEF3-4276-9B38-C8C1A0867B00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "6A41F7A0-B271-4060-80F2-8E6B2B6051E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "FE24079A-61D1-411E-BAA7-6B75251CAAC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "81EFB16F-267E-417A-AF3E-E20E674FC59D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "7E3C6786-1E84-4906-BE56-938FEC02E7FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "928F451E-6416-455C-8F3E-56FC918A3AC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E3C38ACD-05EB-4EDE-8BDC-CDEA4EDF4C78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "0148307A-7F03-4B83-BAC5-A090B534DD9B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "665A2524-FA33-4BF1-B496-160964DB71D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "5F4373D8-DBC3-4B3C-A911-2EEC94668694"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.8.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "50F53821-6B2E-47B5-898A-72BA03DE9889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "429C418A-A716-4A8D-A8FD-5A895F4BBA11"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "5EE4E79E-5DD5-48D7-8254-14CF61EEAA8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "CF88DD8B-3243-484E-9ED5-BF5C99D69D25"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "9FD6D773-CF96-4E8C-82FC-187116AEE584"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "2FA30686-C9AA-4031-B2F9-C5779B34D8DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B8FFF737-4974-43C8-8C2F-475BFB05CA9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "5BACB549-4C65-4B09-8C0F-ABC662B52016"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "1607963B-FBC3-4A32-A2D8-9ACBAFD97962"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "002E6140-C28B-4CDE-8EFF-90CB4768F4CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_ruby:2.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "9C509480-F8E5-4A7D-ADA7-235D5F2C8A94"}]}]}], "references": [{"url": "https://dev.recurly.com/page/ruby-updates", "source": "support@hackerone.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/recurly/recurly-client-ruby/commit/1bb0284d6e668b8b3d31167790ed6db1f6ccc4be", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/288635", "source": "support@hackerone.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/recurly/recurly-client-ruby/commit/1bb0284d6e668b8b3d31167790ed6db1f6ccc4be"}}