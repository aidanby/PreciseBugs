{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\n * Copyright Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright Alan Cox GW4PTS (alan@lxorguk.ukuu.org.uk)\n * Copyright Darryl Miles G7LED (dlm@g7led.demon.co.uk)\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/stat.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t/* For TIOCINQ/OUTQ */\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <net/netrom.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/ip.h>\n#include <net/tcp_states.h>\n#include <net/arp.h>\n#include <linux/init.h>\n\nstatic int nr_ndevs = 4;\n\nint sysctl_netrom_default_path_quality            = NR_DEFAULT_QUAL;\nint sysctl_netrom_obsolescence_count_initialiser  = NR_DEFAULT_OBS;\nint sysctl_netrom_network_ttl_initialiser         = NR_DEFAULT_TTL;\nint sysctl_netrom_transport_timeout               = NR_DEFAULT_T1;\nint sysctl_netrom_transport_maximum_tries         = NR_DEFAULT_N2;\nint sysctl_netrom_transport_acknowledge_delay     = NR_DEFAULT_T2;\nint sysctl_netrom_transport_busy_delay            = NR_DEFAULT_T4;\nint sysctl_netrom_transport_requested_window_size = NR_DEFAULT_WINDOW;\nint sysctl_netrom_transport_no_activity_timeout   = NR_DEFAULT_IDLE;\nint sysctl_netrom_routing_control                 = NR_DEFAULT_ROUTING;\nint sysctl_netrom_link_fails_count                = NR_DEFAULT_FAILS;\nint sysctl_netrom_reset_circuit                   = NR_DEFAULT_RESET;\n\nstatic unsigned short circuit = 0x101;\n\nstatic HLIST_HEAD(nr_list);\nstatic DEFINE_SPINLOCK(nr_list_lock);\n\nstatic const struct proto_ops nr_proto_ops;\n\n/*\n * NETROM network devices are virtual network devices encapsulating NETROM\n * frames into AX.25 which will be sent through an AX.25 device, so form a\n * special \"super class\" of normal net devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key nr_netdev_xmit_lock_key;\nstatic struct lock_class_key nr_netdev_addr_lock_key;\n\nstatic void nr_set_lockdep_one(struct net_device *dev,\n\t\t\t       struct netdev_queue *txq,\n\t\t\t       void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &nr_netdev_xmit_lock_key);\n}\n\nstatic void nr_set_lockdep_key(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &nr_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, nr_set_lockdep_one, NULL);\n}\n\n/*\n *\tSocket removal during an interrupt is now safe.\n */\nstatic void nr_remove_socket(struct sock *sk)\n{\n\tspin_lock_bh(&nr_list_lock);\n\tsk_del_node_init(sk);\n\tspin_unlock_bh(&nr_list_lock);\n}\n\n/*\n *\tKill all bound sockets on a dropped device.\n */\nstatic void nr_kill_by_device(struct net_device *dev)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list)\n\t\tif (nr_sk(s)->device == dev)\n\t\t\tnr_disconnect(s, ENETUNREACH);\n\tspin_unlock_bh(&nr_list_lock);\n}\n\n/*\n *\tHandle device status changes.\n */\nstatic int nr_device_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tnr_kill_by_device(dev);\n\tnr_rt_device_down(dev);\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n *\tAdd a socket to the bound sockets list.\n */\nstatic void nr_insert_socket(struct sock *sk)\n{\n\tspin_lock_bh(&nr_list_lock);\n\tsk_add_node(sk, &nr_list);\n\tspin_unlock_bh(&nr_list_lock);\n}\n\n/*\n *\tFind a socket that wants to accept the Connect Request we just\n *\treceived.\n */\nstatic struct sock *nr_find_listener(ax25_address *addr)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list)\n\t\tif (!ax25cmp(&nr_sk(s)->source_addr, addr) &&\n\t\t    s->sk_state == TCP_LISTEN) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&nr_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a connected NET/ROM socket given my circuit IDs.\n */\nstatic struct sock *nr_find_socket(unsigned char index, unsigned char id)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list) {\n\t\tstruct nr_sock *nr = nr_sk(s);\n\n\t\tif (nr->my_index == index && nr->my_id == id) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&nr_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a connected NET/ROM socket given their circuit IDs.\n */\nstatic struct sock *nr_find_peer(unsigned char index, unsigned char id,\n\tax25_address *dest)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list) {\n\t\tstruct nr_sock *nr = nr_sk(s);\n\n\t\tif (nr->your_index == index && nr->your_id == id &&\n\t\t    !ax25cmp(&nr->dest_addr, dest)) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&nr_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind next free circuit ID.\n */\nstatic unsigned short nr_find_next_circuit(void)\n{\n\tunsigned short id = circuit;\n\tunsigned char i, j;\n\tstruct sock *sk;\n\n\tfor (;;) {\n\t\ti = id / 256;\n\t\tj = id % 256;\n\n\t\tif (i != 0 && j != 0) {\n\t\t\tif ((sk=nr_find_socket(i, j)) == NULL)\n\t\t\t\tbreak;\n\t\t\tsock_put(sk);\n\t\t}\n\n\t\tid++;\n\t}\n\n\treturn id;\n}\n\n/*\n *\tDeferred destroy.\n */\nvoid nr_destroy_socket(struct sock *);\n\n/*\n *\tHandler for deferred kills.\n */\nstatic void nr_destroy_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tnr_destroy_socket(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n/*\n *\tThis is called from user mode and the timers. Thus it protects itself\n *\tagainst interrupt users but doesn't worry about being called during\n *\twork. Once it is removed from the queue no interrupt or bottom half\n *\twill touch it and we are (fairly 8-) ) safe.\n */\nvoid nr_destroy_socket(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\tnr_remove_socket(sk);\n\n\tnr_stop_heartbeat(sk);\n\tnr_stop_t1timer(sk);\n\tnr_stop_t2timer(sk);\n\tnr_stop_t4timer(sk);\n\tnr_stop_idletimer(sk);\n\n\tnr_clear_queues(sk);\t\t/* Flush the queues */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (skb->sk != sk) { /* A pending connection */\n\t\t\t/* Queue the unaccepted socket for death */\n\t\t\tsock_set_flag(skb->sk, SOCK_DEAD);\n\t\t\tnr_start_heartbeat(skb->sk);\n\t\t\tnr_sk(skb->sk)->state = NR_STATE_0;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\tif (sk_has_allocations(sk)) {\n\t\t/* Defer: outstanding buffers */\n\t\tsk->sk_timer.function = nr_destroy_timer;\n\t\tsk->sk_timer.expires  = jiffies + 2 * HZ;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n/*\n *\tHandling for system calls applied via the various interfaces to a\n *\tNET/ROM socket object.\n */\n\nstatic int nr_setsockopt(struct socket *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tunsigned int opt;\n\n\tif (level != SOL_NETROM)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase NETROM_T1:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t1 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_T2:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t2 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_N2:\n\t\tif (opt < 1 || opt > 31)\n\t\t\treturn -EINVAL;\n\t\tnr->n2 = opt;\n\t\treturn 0;\n\n\tcase NETROM_T4:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t4 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_IDLE:\n\t\tif (opt > UINT_MAX / (60 * HZ))\n\t\t\treturn -EINVAL;\n\t\tnr->idle = opt * 60 * HZ;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int nr_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tint val = 0;\n\tint len;\n\n\tif (level != SOL_NETROM)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase NETROM_T1:\n\t\tval = nr->t1 / HZ;\n\t\tbreak;\n\n\tcase NETROM_T2:\n\t\tval = nr->t2 / HZ;\n\t\tbreak;\n\n\tcase NETROM_N2:\n\t\tval = nr->n2;\n\t\tbreak;\n\n\tcase NETROM_T4:\n\t\tval = nr->t4 / HZ;\n\t\tbreak;\n\n\tcase NETROM_IDLE:\n\t\tval = nr->idle / (60 * HZ);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\n}\n\nstatic int nr_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct proto nr_proto = {\n\t.name\t  = \"NETROM\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct nr_sock),\n};\n\nstatic int nr_create(struct net *net, struct socket *sock, int protocol,\n\t\t     int kern)\n{\n\tstruct sock *sk;\n\tstruct nr_sock *nr;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (sock->type != SOCK_SEQPACKET || protocol != 0)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_NETROM, GFP_ATOMIC, &nr_proto, kern);\n\tif (sk  == NULL)\n\t\treturn -ENOMEM;\n\n\tnr = nr_sk(sk);\n\n\tsock_init_data(sock, sk);\n\n\tsock->ops    = &nr_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tskb_queue_head_init(&nr->ack_queue);\n\tskb_queue_head_init(&nr->reseq_queue);\n\tskb_queue_head_init(&nr->frag_queue);\n\n\tnr_init_timers(sk);\n\n\tnr->t1     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_timeout);\n\tnr->t2     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_acknowledge_delay);\n\tnr->n2     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_maximum_tries);\n\tnr->t4     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_busy_delay);\n\tnr->idle   =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_no_activity_timeout);\n\tnr->window = sysctl_netrom_transport_requested_window_size;\n\n\tnr->bpqext = 1;\n\tnr->state  = NR_STATE_0;\n\n\treturn 0;\n}\n\nstatic struct sock *nr_make_new(struct sock *osk)\n{\n\tstruct sock *sk;\n\tstruct nr_sock *nr, *onr;\n\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\treturn NULL;\n\n\tsk = sk_alloc(sock_net(osk), PF_NETROM, GFP_ATOMIC, osk->sk_prot, 0);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\tnr = nr_sk(sk);\n\n\tsock_init_data(NULL, sk);\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\tskb_queue_head_init(&nr->ack_queue);\n\tskb_queue_head_init(&nr->reseq_queue);\n\tskb_queue_head_init(&nr->frag_queue);\n\n\tnr_init_timers(sk);\n\n\tonr = nr_sk(osk);\n\n\tnr->t1      = onr->t1;\n\tnr->t2      = onr->t2;\n\tnr->n2      = onr->n2;\n\tnr->t4      = onr->t4;\n\tnr->idle    = onr->idle;\n\tnr->window  = onr->window;\n\n\tnr->device  = onr->device;\n\tnr->bpqext  = onr->bpqext;\n\n\treturn sk;\n}\n\nstatic int nr_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr;\n\n\tif (sk == NULL) return 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\tnr = nr_sk(sk);\n\n\tswitch (nr->state) {\n\tcase NR_STATE_0:\n\tcase NR_STATE_1:\n\tcase NR_STATE_2:\n\t\tnr_disconnect(sk, 0);\n\t\tnr_destroy_socket(sk);\n\t\tbreak;\n\n\tcase NR_STATE_3:\n\t\tnr_clear_queues(sk);\n\t\tnr->n2count = 0;\n\t\tnr_write_internal(sk, NR_DISCREQ);\n\t\tnr_start_t1timer(sk);\n\t\tnr_stop_t2timer(sk);\n\t\tnr_stop_t4timer(sk);\n\t\tnr_stop_idletimer(sk);\n\t\tnr->state    = NR_STATE_2;\n\t\tsk->sk_state    = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int nr_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct net_device *dev;\n\tax25_uid_assoc *user;\n\tax25_address *source;\n\n\tlock_sock(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (addr_len < sizeof(struct sockaddr_ax25) || addr_len > sizeof(struct full_sockaddr_ax25)) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (addr_len < (addr->fsa_ax25.sax25_ndigis * sizeof(ax25_address) + sizeof(struct sockaddr_ax25))) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (addr->fsa_ax25.sax25_family != AF_NETROM) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif ((dev = nr_dev_get(&addr->fsa_ax25.sax25_call)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/*\n\t * Only the super user can set an arbitrary user callsign.\n\t */\n\tif (addr->fsa_ax25.sax25_ndigis == 1) {\n\t\tif (!capable(CAP_NET_BIND_SERVICE)) {\n\t\t\tdev_put(dev);\n\t\t\trelease_sock(sk);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tnr->user_addr   = addr->fsa_digipeater[0];\n\t\tnr->source_addr = addr->fsa_ax25.sax25_call;\n\t} else {\n\t\tsource = &addr->fsa_ax25.sax25_call;\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (user) {\n\t\t\tnr->user_addr   = user->call;\n\t\t\tax25_uid_put(user);\n\t\t} else {\n\t\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tdev_put(dev);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t\tnr->user_addr   = *source;\n\t\t}\n\n\t\tnr->source_addr = *source;\n\t}\n\n\tnr->device = dev;\n\tnr_insert_socket(sk);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tdev_put(dev);\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\nstatic int nr_connect(struct socket *sock, struct sockaddr *uaddr,\n\tint addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct sockaddr_ax25 *addr = (struct sockaddr_ax25 *)uaddr;\n\tconst ax25_address *source = NULL;\n\tax25_uid_assoc *user;\n\tstruct net_device *dev;\n\tint err = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out_release;\t/* Connect completed during a ERESTARTSYS event */\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = -ECONNREFUSED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\terr = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tif (addr_len != sizeof(struct sockaddr_ax25) && addr_len != sizeof(struct full_sockaddr_ax25)) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\tif (addr->sax25_family != AF_NETROM) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\t/* Must bind first - autobinding in this may or may not work */\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\t\tif ((dev = nr_dev_first()) == NULL) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\t\tsource = (const ax25_address *)dev->dev_addr;\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (user) {\n\t\t\tnr->user_addr   = user->call;\n\t\t\tax25_uid_put(user);\n\t\t} else {\n\t\t\tif (ax25_uid_policy && !capable(CAP_NET_ADMIN)) {\n\t\t\t\tdev_put(dev);\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto out_release;\n\t\t\t}\n\t\t\tnr->user_addr   = *source;\n\t\t}\n\n\t\tnr->source_addr = *source;\n\t\tnr->device      = dev;\n\n\t\tdev_put(dev);\n\t\tnr_insert_socket(sk);\t\t/* Finish the bind */\n\t}\n\n\tnr->dest_addr = addr->sax25_call;\n\n\trelease_sock(sk);\n\tcircuit = nr_find_next_circuit();\n\tlock_sock(sk);\n\n\tnr->my_index = circuit / 256;\n\tnr->my_id    = circuit % 256;\n\n\tcircuit++;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state  = SS_CONNECTING;\n\tsk->sk_state = TCP_SYN_SENT;\n\n\tnr_establish_data_link(sk);\n\n\tnr->state = NR_STATE_1;\n\n\tnr_start_heartbeat(sk);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * A Connect Ack with Choke or timeout or failed routing will go to\n\t * closed.\n\t */\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int nr_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t     bool kern)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t *\tThe write queue this time is holding sockets ready to use\n\t *\thooked into the SABM we saved\n\t */\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (err)\n\t\tgoto out_release;\n\n\tnewsk = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t/* Now attach up the new socket */\n\tkfree_skb(skb);\n\tsk_acceptq_removed(sk);\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tint uaddr_len;\n\n\tmemset(&sax->fsa_ax25, 0, sizeof(struct sockaddr_ax25));\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tmemset(sax->fsa_digipeater, 0, sizeof(sax->fsa_digipeater));\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\tuaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\tuaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn uaddr_len;\n}\n\nint nr_rx_frame(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct nr_sock *nr_make;\n\tax25_address *src, *dest, *user;\n\tunsigned short circuit_index, circuit_id;\n\tunsigned short peer_circuit_index, peer_circuit_id;\n\tunsigned short frametype, flags, window, timeout;\n\tint ret;\n\n\tskb_orphan(skb);\n\n\t/*\n\t *\tskb->data points to the netrom frame start\n\t */\n\n\tsrc  = (ax25_address *)(skb->data + 0);\n\tdest = (ax25_address *)(skb->data + 7);\n\n\tcircuit_index      = skb->data[15];\n\tcircuit_id         = skb->data[16];\n\tpeer_circuit_index = skb->data[17];\n\tpeer_circuit_id    = skb->data[18];\n\tframetype          = skb->data[19] & 0x0F;\n\tflags              = skb->data[19] & 0xF0;\n\n\t/*\n\t * Check for an incoming IP over NET/ROM frame.\n\t */\n\tif (frametype == NR_PROTOEXT &&\n\t    circuit_index == NR_PROTO_IP && circuit_id == NR_PROTO_IP) {\n\t\tskb_pull(skb, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\n\t\tskb_reset_transport_header(skb);\n\n\t\treturn nr_rx_ip(skb, dev);\n\t}\n\n\t/*\n\t * Find an existing socket connection, based on circuit ID, if it's\n\t * a Connect Request base it on their circuit ID.\n\t *\n\t * Circuit ID 0/0 is not valid but it could still be a \"reset\" for a\n\t * circuit that no longer exists at the other end ...\n\t */\n\n\tsk = NULL;\n\n\tif (circuit_index == 0 && circuit_id == 0) {\n\t\tif (frametype == NR_CONNACK && flags == NR_CHOKE_FLAG)\n\t\t\tsk = nr_find_peer(peer_circuit_index, peer_circuit_id, src);\n\t} else {\n\t\tif (frametype == NR_CONNREQ)\n\t\t\tsk = nr_find_peer(circuit_index, circuit_id, src);\n\t\telse\n\t\t\tsk = nr_find_socket(circuit_index, circuit_id);\n\t}\n\n\tif (sk != NULL) {\n\t\tbh_lock_sock(sk);\n\t\tskb_reset_transport_header(skb);\n\n\t\tif (frametype == NR_CONNACK && skb->len == 22)\n\t\t\tnr_sk(sk)->bpqext = 1;\n\t\telse\n\t\t\tnr_sk(sk)->bpqext = 0;\n\n\t\tret = nr_process_rx_frame(sk, skb);\n\t\tbh_unlock_sock(sk);\n\t\tsock_put(sk);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now it should be a CONNREQ.\n\t */\n\tif (frametype != NR_CONNREQ) {\n\t\t/*\n\t\t * Here it would be nice to be able to send a reset but\n\t\t * NET/ROM doesn't have one.  We've tried to extend the protocol\n\t\t * by sending NR_CONNACK | NR_CHOKE_FLAGS replies but that\n\t\t * apparently kills BPQ boxes... :-(\n\t\t * So now we try to follow the established behaviour of\n\t\t * G8PZT's Xrouter which is sending packets with command type 7\n\t\t * as an extension of the protocol.\n\t\t */\n\t\tif (sysctl_netrom_reset_circuit &&\n\t\t    (frametype != NR_RESET || flags != 0))\n\t\t\tnr_transmit_reset(skb, 1);\n\n\t\treturn 0;\n\t}\n\n\tsk = nr_find_listener(dest);\n\n\tuser = (ax25_address *)(skb->data + 21);\n\n\tif (sk == NULL || sk_acceptq_is_full(sk) ||\n\t    (make = nr_make_new(sk)) == NULL) {\n\t\tnr_transmit_refusal(skb, 0);\n\t\tif (sk)\n\t\t\tsock_put(sk);\n\t\treturn 0;\n\t}\n\n\tbh_lock_sock(sk);\n\n\twindow = skb->data[20];\n\n\tsock_hold(make);\n\tskb->sk             = make;\n\tskb->destructor     = sock_efree;\n\tmake->sk_state\t    = TCP_ESTABLISHED;\n\n\t/* Fill in his circuit details */\n\tnr_make = nr_sk(make);\n\tnr_make->source_addr = *dest;\n\tnr_make->dest_addr   = *src;\n\tnr_make->user_addr   = *user;\n\n\tnr_make->your_index  = circuit_index;\n\tnr_make->your_id     = circuit_id;\n\n\tbh_unlock_sock(sk);\n\tcircuit = nr_find_next_circuit();\n\tbh_lock_sock(sk);\n\n\tnr_make->my_index    = circuit / 256;\n\tnr_make->my_id       = circuit % 256;\n\n\tcircuit++;\n\n\t/* Window negotiation */\n\tif (window < nr_make->window)\n\t\tnr_make->window = window;\n\n\t/* L4 timeout negotiation */\n\tif (skb->len == 37) {\n\t\ttimeout = skb->data[36] * 256 + skb->data[35];\n\t\tif (timeout * HZ < nr_make->t1)\n\t\t\tnr_make->t1 = timeout * HZ;\n\t\tnr_make->bpqext = 1;\n\t} else {\n\t\tnr_make->bpqext = 0;\n\t}\n\n\tnr_write_internal(make, NR_CONNACK);\n\n\tnr_make->condition = 0x00;\n\tnr_make->vs        = 0;\n\tnr_make->va        = 0;\n\tnr_make->vr        = 0;\n\tnr_make->vl        = 0;\n\tnr_make->state     = NR_STATE_3;\n\tsk_acceptq_added(sk);\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\n\tnr_insert_socket(make);\n\n\tnr_start_heartbeat(make);\n\tnr_start_idletimer(make);\n\n\treturn 1;\n}\n\nstatic int nr_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, usax, msg->msg_name);\n\tint err;\n\tstruct sockaddr_ax25 sax;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint size;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (nr->device == NULL) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tif (usax) {\n\t\tif (msg->msg_namelen < sizeof(sax)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tsax = *usax;\n\t\tif (ax25cmp(&nr->dest_addr, &sax.sax25_call) != 0) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sax.sax25_family != AF_NETROM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsax.sax25_family = AF_NETROM;\n\t\tsax.sax25_call   = nr->dest_addr;\n\t}\n\n\t/* Build a packet - the conventional user limit is 236 bytes. We can\n\t   do ludicrously large NetROM frames but must not overflow */\n\tif (len > 65536) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tsize = len + NR_NETWORK_LEN + NR_TRANSPORT_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\tgoto out;\n\n\tskb_reserve(skb, size - len);\n\tskb_reset_transport_header(skb);\n\n\t/*\n\t *\tPush down the NET/ROM header\n\t */\n\n\tasmptr = skb_push(skb, NR_TRANSPORT_LEN);\n\n\t/* Build a NET/ROM Transport header */\n\n\t*asmptr++ = nr->your_index;\n\t*asmptr++ = nr->your_id;\n\t*asmptr++ = 0;\t\t/* To be filled in later */\n\t*asmptr++ = 0;\t\t/*      Ditto            */\n\t*asmptr++ = NR_INFO;\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tskb_put(skb, len);\n\n\t/* User data follows immediately after the NET/ROM transport header */\n\tif (memcpy_from_msg(skb_transport_header(skb), msg, len)) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tnr_output(sk, skb);\t/* Shove it onto the queue */\n\n\terr = len;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int nr_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t      int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, sax, msg->msg_name);\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tskb = skb_recv_datagram(sk, flags, &er);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}\n\n\nstatic int nr_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tlock_sock(sk);\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trelease_sock(sk);\n\t\treturn put_user(amount, (int __user *)argp);\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\n\t\tlock_sock(sk);\n\t\t/* These two are safe on a single CPU system as only user tasks fiddle here */\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\trelease_sock(sk);\n\t\treturn put_user(amount, (int __user *)argp);\n\t}\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\treturn -EINVAL;\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCNRDECOBS:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn nr_rt_ioctl(cmd, argp);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *nr_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(&nr_list_lock)\n{\n\tspin_lock_bh(&nr_list_lock);\n\treturn seq_hlist_start_head(&nr_list, *pos);\n}\n\nstatic void *nr_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &nr_list, pos);\n}\n\nstatic void nr_info_stop(struct seq_file *seq, void *v)\n\t__releases(&nr_list_lock)\n{\n\tspin_unlock_bh(&nr_list_lock);\n}\n\nstatic int nr_info_show(struct seq_file *seq, void *v)\n{\n\tstruct sock *s = sk_entry(v);\n\tstruct net_device *dev;\n\tstruct nr_sock *nr;\n\tconst char *devname;\n\tchar buf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\"user_addr dest_node src_node  dev    my  your  st  vs  vr  va    t1     t2     t4      idle   n2  wnd Snd-Q Rcv-Q inode\\n\");\n\n\telse {\n\n\t\tbh_lock_sock(s);\n\t\tnr = nr_sk(s);\n\n\t\tif ((dev = nr->device) == NULL)\n\t\t\tdevname = \"???\";\n\t\telse\n\t\t\tdevname = dev->name;\n\n\t\tseq_printf(seq, \"%-9s \", ax2asc(buf, &nr->user_addr));\n\t\tseq_printf(seq, \"%-9s \", ax2asc(buf, &nr->dest_addr));\n\t\tseq_printf(seq,\n\"%-9s %-3s  %02X/%02X %02X/%02X %2d %3d %3d %3d %3lu/%03lu %2lu/%02lu %3lu/%03lu %3lu/%03lu %2d/%02d %3d %5d %5d %ld\\n\",\n\t\t\tax2asc(buf, &nr->source_addr),\n\t\t\tdevname,\n\t\t\tnr->my_index,\n\t\t\tnr->my_id,\n\t\t\tnr->your_index,\n\t\t\tnr->your_id,\n\t\t\tnr->state,\n\t\t\tnr->vs,\n\t\t\tnr->vr,\n\t\t\tnr->va,\n\t\t\tax25_display_timer(&nr->t1timer) / HZ,\n\t\t\tnr->t1 / HZ,\n\t\t\tax25_display_timer(&nr->t2timer) / HZ,\n\t\t\tnr->t2 / HZ,\n\t\t\tax25_display_timer(&nr->t4timer) / HZ,\n\t\t\tnr->t4 / HZ,\n\t\t\tax25_display_timer(&nr->idletimer) / (60 * HZ),\n\t\t\tnr->idle / (60 * HZ),\n\t\t\tnr->n2count,\n\t\t\tnr->n2,\n\t\t\tnr->window,\n\t\t\tsk_wmem_alloc_get(s),\n\t\t\tsk_rmem_alloc_get(s),\n\t\t\ts->sk_socket ? SOCK_INODE(s->sk_socket)->i_ino : 0L);\n\n\t\tbh_unlock_sock(s);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations nr_info_seqops = {\n\t.start = nr_info_start,\n\t.next = nr_info_next,\n\t.stop = nr_info_stop,\n\t.show = nr_info_show,\n};\n#endif\t/* CONFIG_PROC_FS */\n\nstatic const struct net_proto_family nr_family_ops = {\n\t.family\t\t=\tPF_NETROM,\n\t.create\t\t=\tnr_create,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops nr_proto_ops = {\n\t.family\t\t=\tPF_NETROM,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.release\t=\tnr_release,\n\t.bind\t\t=\tnr_bind,\n\t.connect\t=\tnr_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\tnr_accept,\n\t.getname\t=\tnr_getname,\n\t.poll\t\t=\tdatagram_poll,\n\t.ioctl\t\t=\tnr_ioctl,\n\t.gettstamp\t=\tsock_gettstamp,\n\t.listen\t\t=\tnr_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.setsockopt\t=\tnr_setsockopt,\n\t.getsockopt\t=\tnr_getsockopt,\n\t.sendmsg\t=\tnr_sendmsg,\n\t.recvmsg\t=\tnr_recvmsg,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n};\n\nstatic struct notifier_block nr_dev_notifier = {\n\t.notifier_call\t=\tnr_device_event,\n};\n\nstatic struct net_device **dev_nr;\n\nstatic struct ax25_protocol nr_pid = {\n\t.pid\t= AX25_P_NETROM,\n\t.func\t= nr_route_frame\n};\n\nstatic struct ax25_linkfail nr_linkfail_notifier = {\n\t.func\t= nr_link_failed,\n};\n\nstatic int __init nr_proto_init(void)\n{\n\tint i;\n\tint rc = proto_register(&nr_proto, 0);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (nr_ndevs > 0x7fffffff/sizeof(struct net_device *)) {\n\t\tpr_err(\"NET/ROM: %s - nr_ndevs parameter too large\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto unregister_proto;\n\t}\n\n\tdev_nr = kcalloc(nr_ndevs, sizeof(struct net_device *), GFP_KERNEL);\n\tif (!dev_nr) {\n\t\tpr_err(\"NET/ROM: %s - unable to allocate device array\\n\",\n\t\t       __func__);\n\t\trc = -ENOMEM;\n\t\tgoto unregister_proto;\n\t}\n\n\tfor (i = 0; i < nr_ndevs; i++) {\n\t\tchar name[IFNAMSIZ];\n\t\tstruct net_device *dev;\n\n\t\tsprintf(name, \"nr%d\", i);\n\t\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, nr_setup);\n\t\tif (!dev) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdev->base_addr = i;\n\t\trc = register_netdev(dev);\n\t\tif (rc) {\n\t\t\tfree_netdev(dev);\n\t\t\tgoto fail;\n\t\t}\n\t\tnr_set_lockdep_key(dev);\n\t\tdev_nr[i] = dev;\n\t}\n\n\trc = sock_register(&nr_family_ops);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = register_netdevice_notifier(&nr_dev_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\n\tax25_register_pid(&nr_pid);\n\tax25_linkfail_register(&nr_linkfail_notifier);\n\n#ifdef CONFIG_SYSCTL\n\trc = nr_register_sysctl();\n\tif (rc)\n\t\tgoto out_sysctl;\n#endif\n\n\tnr_loopback_init();\n\n\trc = -ENOMEM;\n\tif (!proc_create_seq(\"nr\", 0444, init_net.proc_net, &nr_info_seqops))\n\t\tgoto proc_remove1;\n\tif (!proc_create_seq(\"nr_neigh\", 0444, init_net.proc_net,\n\t\t\t     &nr_neigh_seqops))\n\t\tgoto proc_remove2;\n\tif (!proc_create_seq(\"nr_nodes\", 0444, init_net.proc_net,\n\t\t\t     &nr_node_seqops))\n\t\tgoto proc_remove3;\n\n\treturn 0;\n\nproc_remove3:\n\tremove_proc_entry(\"nr_neigh\", init_net.proc_net);\nproc_remove2:\n\tremove_proc_entry(\"nr\", init_net.proc_net);\nproc_remove1:\n\n\tnr_loopback_clear();\n\tnr_rt_free();\n\n#ifdef CONFIG_SYSCTL\n\tnr_unregister_sysctl();\nout_sysctl:\n#endif\n\tax25_linkfail_release(&nr_linkfail_notifier);\n\tax25_protocol_release(AX25_P_NETROM);\n\tunregister_netdevice_notifier(&nr_dev_notifier);\nout_sock:\n\tsock_unregister(PF_NETROM);\nfail:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(dev_nr[i]);\n\t\tfree_netdev(dev_nr[i]);\n\t}\n\tkfree(dev_nr);\nunregister_proto:\n\tproto_unregister(&nr_proto);\n\treturn rc;\n}\n\nmodule_init(nr_proto_init);\n\nmodule_param(nr_ndevs, int, 0);\nMODULE_PARM_DESC(nr_ndevs, \"number of NET/ROM devices\");\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio NET/ROM network and transport layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_NETROM);\n\nstatic void __exit nr_exit(void)\n{\n\tint i;\n\n\tremove_proc_entry(\"nr\", init_net.proc_net);\n\tremove_proc_entry(\"nr_neigh\", init_net.proc_net);\n\tremove_proc_entry(\"nr_nodes\", init_net.proc_net);\n\tnr_loopback_clear();\n\n\tnr_rt_free();\n\n#ifdef CONFIG_SYSCTL\n\tnr_unregister_sysctl();\n#endif\n\n\tax25_linkfail_release(&nr_linkfail_notifier);\n\tax25_protocol_release(AX25_P_NETROM);\n\n\tunregister_netdevice_notifier(&nr_dev_notifier);\n\n\tsock_unregister(PF_NETROM);\n\n\tfor (i = 0; i < nr_ndevs; i++) {\n\t\tstruct net_device *dev = dev_nr[i];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\tkfree(dev_nr);\n\tproto_unregister(&nr_proto);\n}\nmodule_exit(nr_exit);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\n * Copyright Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright Alan Cox GW4PTS (alan@lxorguk.ukuu.org.uk)\n * Copyright Darryl Miles G7LED (dlm@g7led.demon.co.uk)\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/stat.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t/* For TIOCINQ/OUTQ */\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <net/netrom.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/ip.h>\n#include <net/tcp_states.h>\n#include <net/arp.h>\n#include <linux/init.h>\n\nstatic int nr_ndevs = 4;\n\nint sysctl_netrom_default_path_quality            = NR_DEFAULT_QUAL;\nint sysctl_netrom_obsolescence_count_initialiser  = NR_DEFAULT_OBS;\nint sysctl_netrom_network_ttl_initialiser         = NR_DEFAULT_TTL;\nint sysctl_netrom_transport_timeout               = NR_DEFAULT_T1;\nint sysctl_netrom_transport_maximum_tries         = NR_DEFAULT_N2;\nint sysctl_netrom_transport_acknowledge_delay     = NR_DEFAULT_T2;\nint sysctl_netrom_transport_busy_delay            = NR_DEFAULT_T4;\nint sysctl_netrom_transport_requested_window_size = NR_DEFAULT_WINDOW;\nint sysctl_netrom_transport_no_activity_timeout   = NR_DEFAULT_IDLE;\nint sysctl_netrom_routing_control                 = NR_DEFAULT_ROUTING;\nint sysctl_netrom_link_fails_count                = NR_DEFAULT_FAILS;\nint sysctl_netrom_reset_circuit                   = NR_DEFAULT_RESET;\n\nstatic unsigned short circuit = 0x101;\n\nstatic HLIST_HEAD(nr_list);\nstatic DEFINE_SPINLOCK(nr_list_lock);\n\nstatic const struct proto_ops nr_proto_ops;\n\n/*\n * NETROM network devices are virtual network devices encapsulating NETROM\n * frames into AX.25 which will be sent through an AX.25 device, so form a\n * special \"super class\" of normal net devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key nr_netdev_xmit_lock_key;\nstatic struct lock_class_key nr_netdev_addr_lock_key;\n\nstatic void nr_set_lockdep_one(struct net_device *dev,\n\t\t\t       struct netdev_queue *txq,\n\t\t\t       void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &nr_netdev_xmit_lock_key);\n}\n\nstatic void nr_set_lockdep_key(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &nr_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, nr_set_lockdep_one, NULL);\n}\n\n/*\n *\tSocket removal during an interrupt is now safe.\n */\nstatic void nr_remove_socket(struct sock *sk)\n{\n\tspin_lock_bh(&nr_list_lock);\n\tsk_del_node_init(sk);\n\tspin_unlock_bh(&nr_list_lock);\n}\n\n/*\n *\tKill all bound sockets on a dropped device.\n */\nstatic void nr_kill_by_device(struct net_device *dev)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list)\n\t\tif (nr_sk(s)->device == dev)\n\t\t\tnr_disconnect(s, ENETUNREACH);\n\tspin_unlock_bh(&nr_list_lock);\n}\n\n/*\n *\tHandle device status changes.\n */\nstatic int nr_device_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tnr_kill_by_device(dev);\n\tnr_rt_device_down(dev);\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n *\tAdd a socket to the bound sockets list.\n */\nstatic void nr_insert_socket(struct sock *sk)\n{\n\tspin_lock_bh(&nr_list_lock);\n\tsk_add_node(sk, &nr_list);\n\tspin_unlock_bh(&nr_list_lock);\n}\n\n/*\n *\tFind a socket that wants to accept the Connect Request we just\n *\treceived.\n */\nstatic struct sock *nr_find_listener(ax25_address *addr)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list)\n\t\tif (!ax25cmp(&nr_sk(s)->source_addr, addr) &&\n\t\t    s->sk_state == TCP_LISTEN) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&nr_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a connected NET/ROM socket given my circuit IDs.\n */\nstatic struct sock *nr_find_socket(unsigned char index, unsigned char id)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list) {\n\t\tstruct nr_sock *nr = nr_sk(s);\n\n\t\tif (nr->my_index == index && nr->my_id == id) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&nr_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a connected NET/ROM socket given their circuit IDs.\n */\nstatic struct sock *nr_find_peer(unsigned char index, unsigned char id,\n\tax25_address *dest)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&nr_list_lock);\n\tsk_for_each(s, &nr_list) {\n\t\tstruct nr_sock *nr = nr_sk(s);\n\n\t\tif (nr->your_index == index && nr->your_id == id &&\n\t\t    !ax25cmp(&nr->dest_addr, dest)) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&nr_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind next free circuit ID.\n */\nstatic unsigned short nr_find_next_circuit(void)\n{\n\tunsigned short id = circuit;\n\tunsigned char i, j;\n\tstruct sock *sk;\n\n\tfor (;;) {\n\t\ti = id / 256;\n\t\tj = id % 256;\n\n\t\tif (i != 0 && j != 0) {\n\t\t\tif ((sk=nr_find_socket(i, j)) == NULL)\n\t\t\t\tbreak;\n\t\t\tsock_put(sk);\n\t\t}\n\n\t\tid++;\n\t}\n\n\treturn id;\n}\n\n/*\n *\tDeferred destroy.\n */\nvoid nr_destroy_socket(struct sock *);\n\n/*\n *\tHandler for deferred kills.\n */\nstatic void nr_destroy_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tnr_destroy_socket(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n/*\n *\tThis is called from user mode and the timers. Thus it protects itself\n *\tagainst interrupt users but doesn't worry about being called during\n *\twork. Once it is removed from the queue no interrupt or bottom half\n *\twill touch it and we are (fairly 8-) ) safe.\n */\nvoid nr_destroy_socket(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\tnr_remove_socket(sk);\n\n\tnr_stop_heartbeat(sk);\n\tnr_stop_t1timer(sk);\n\tnr_stop_t2timer(sk);\n\tnr_stop_t4timer(sk);\n\tnr_stop_idletimer(sk);\n\n\tnr_clear_queues(sk);\t\t/* Flush the queues */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (skb->sk != sk) { /* A pending connection */\n\t\t\t/* Queue the unaccepted socket for death */\n\t\t\tsock_set_flag(skb->sk, SOCK_DEAD);\n\t\t\tnr_start_heartbeat(skb->sk);\n\t\t\tnr_sk(skb->sk)->state = NR_STATE_0;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\tif (sk_has_allocations(sk)) {\n\t\t/* Defer: outstanding buffers */\n\t\tsk->sk_timer.function = nr_destroy_timer;\n\t\tsk->sk_timer.expires  = jiffies + 2 * HZ;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n/*\n *\tHandling for system calls applied via the various interfaces to a\n *\tNET/ROM socket object.\n */\n\nstatic int nr_setsockopt(struct socket *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tunsigned int opt;\n\n\tif (level != SOL_NETROM)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase NETROM_T1:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t1 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_T2:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t2 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_N2:\n\t\tif (opt < 1 || opt > 31)\n\t\t\treturn -EINVAL;\n\t\tnr->n2 = opt;\n\t\treturn 0;\n\n\tcase NETROM_T4:\n\t\tif (opt < 1 || opt > UINT_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t4 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_IDLE:\n\t\tif (opt > UINT_MAX / (60 * HZ))\n\t\t\treturn -EINVAL;\n\t\tnr->idle = opt * 60 * HZ;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int nr_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tint val = 0;\n\tint len;\n\n\tif (level != SOL_NETROM)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase NETROM_T1:\n\t\tval = nr->t1 / HZ;\n\t\tbreak;\n\n\tcase NETROM_T2:\n\t\tval = nr->t2 / HZ;\n\t\tbreak;\n\n\tcase NETROM_N2:\n\t\tval = nr->n2;\n\t\tbreak;\n\n\tcase NETROM_T4:\n\t\tval = nr->t4 / HZ;\n\t\tbreak;\n\n\tcase NETROM_IDLE:\n\t\tval = nr->idle / (60 * HZ);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\n}\n\nstatic int nr_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct proto nr_proto = {\n\t.name\t  = \"NETROM\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct nr_sock),\n};\n\nstatic int nr_create(struct net *net, struct socket *sock, int protocol,\n\t\t     int kern)\n{\n\tstruct sock *sk;\n\tstruct nr_sock *nr;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (sock->type != SOCK_SEQPACKET || protocol != 0)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_NETROM, GFP_ATOMIC, &nr_proto, kern);\n\tif (sk  == NULL)\n\t\treturn -ENOMEM;\n\n\tnr = nr_sk(sk);\n\n\tsock_init_data(sock, sk);\n\n\tsock->ops    = &nr_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tskb_queue_head_init(&nr->ack_queue);\n\tskb_queue_head_init(&nr->reseq_queue);\n\tskb_queue_head_init(&nr->frag_queue);\n\n\tnr_init_timers(sk);\n\n\tnr->t1     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_timeout);\n\tnr->t2     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_acknowledge_delay);\n\tnr->n2     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_maximum_tries);\n\tnr->t4     =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_busy_delay);\n\tnr->idle   =\n\t\tmsecs_to_jiffies(sysctl_netrom_transport_no_activity_timeout);\n\tnr->window = sysctl_netrom_transport_requested_window_size;\n\n\tnr->bpqext = 1;\n\tnr->state  = NR_STATE_0;\n\n\treturn 0;\n}\n\nstatic struct sock *nr_make_new(struct sock *osk)\n{\n\tstruct sock *sk;\n\tstruct nr_sock *nr, *onr;\n\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\treturn NULL;\n\n\tsk = sk_alloc(sock_net(osk), PF_NETROM, GFP_ATOMIC, osk->sk_prot, 0);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\tnr = nr_sk(sk);\n\n\tsock_init_data(NULL, sk);\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\tskb_queue_head_init(&nr->ack_queue);\n\tskb_queue_head_init(&nr->reseq_queue);\n\tskb_queue_head_init(&nr->frag_queue);\n\n\tnr_init_timers(sk);\n\n\tonr = nr_sk(osk);\n\n\tnr->t1      = onr->t1;\n\tnr->t2      = onr->t2;\n\tnr->n2      = onr->n2;\n\tnr->t4      = onr->t4;\n\tnr->idle    = onr->idle;\n\tnr->window  = onr->window;\n\n\tnr->device  = onr->device;\n\tnr->bpqext  = onr->bpqext;\n\n\treturn sk;\n}\n\nstatic int nr_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr;\n\n\tif (sk == NULL) return 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\tnr = nr_sk(sk);\n\n\tswitch (nr->state) {\n\tcase NR_STATE_0:\n\tcase NR_STATE_1:\n\tcase NR_STATE_2:\n\t\tnr_disconnect(sk, 0);\n\t\tnr_destroy_socket(sk);\n\t\tbreak;\n\n\tcase NR_STATE_3:\n\t\tnr_clear_queues(sk);\n\t\tnr->n2count = 0;\n\t\tnr_write_internal(sk, NR_DISCREQ);\n\t\tnr_start_t1timer(sk);\n\t\tnr_stop_t2timer(sk);\n\t\tnr_stop_t4timer(sk);\n\t\tnr_stop_idletimer(sk);\n\t\tnr->state    = NR_STATE_2;\n\t\tsk->sk_state    = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int nr_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct net_device *dev;\n\tax25_uid_assoc *user;\n\tax25_address *source;\n\n\tlock_sock(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (addr_len < sizeof(struct sockaddr_ax25) || addr_len > sizeof(struct full_sockaddr_ax25)) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (addr_len < (addr->fsa_ax25.sax25_ndigis * sizeof(ax25_address) + sizeof(struct sockaddr_ax25))) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (addr->fsa_ax25.sax25_family != AF_NETROM) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif ((dev = nr_dev_get(&addr->fsa_ax25.sax25_call)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/*\n\t * Only the super user can set an arbitrary user callsign.\n\t */\n\tif (addr->fsa_ax25.sax25_ndigis == 1) {\n\t\tif (!capable(CAP_NET_BIND_SERVICE)) {\n\t\t\tdev_put(dev);\n\t\t\trelease_sock(sk);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tnr->user_addr   = addr->fsa_digipeater[0];\n\t\tnr->source_addr = addr->fsa_ax25.sax25_call;\n\t} else {\n\t\tsource = &addr->fsa_ax25.sax25_call;\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (user) {\n\t\t\tnr->user_addr   = user->call;\n\t\t\tax25_uid_put(user);\n\t\t} else {\n\t\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tdev_put(dev);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t\tnr->user_addr   = *source;\n\t\t}\n\n\t\tnr->source_addr = *source;\n\t}\n\n\tnr->device = dev;\n\tnr_insert_socket(sk);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tdev_put(dev);\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\nstatic int nr_connect(struct socket *sock, struct sockaddr *uaddr,\n\tint addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct sockaddr_ax25 *addr = (struct sockaddr_ax25 *)uaddr;\n\tconst ax25_address *source = NULL;\n\tax25_uid_assoc *user;\n\tstruct net_device *dev;\n\tint err = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out_release;\t/* Connect completed during a ERESTARTSYS event */\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = -ECONNREFUSED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\terr = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tif (addr_len != sizeof(struct sockaddr_ax25) && addr_len != sizeof(struct full_sockaddr_ax25)) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\tif (addr->sax25_family != AF_NETROM) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\t/* Must bind first - autobinding in this may or may not work */\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\t\tif ((dev = nr_dev_first()) == NULL) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\t\tsource = (const ax25_address *)dev->dev_addr;\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (user) {\n\t\t\tnr->user_addr   = user->call;\n\t\t\tax25_uid_put(user);\n\t\t} else {\n\t\t\tif (ax25_uid_policy && !capable(CAP_NET_ADMIN)) {\n\t\t\t\tdev_put(dev);\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto out_release;\n\t\t\t}\n\t\t\tnr->user_addr   = *source;\n\t\t}\n\n\t\tnr->source_addr = *source;\n\t\tnr->device      = dev;\n\n\t\tdev_put(dev);\n\t\tnr_insert_socket(sk);\t\t/* Finish the bind */\n\t}\n\n\tnr->dest_addr = addr->sax25_call;\n\n\trelease_sock(sk);\n\tcircuit = nr_find_next_circuit();\n\tlock_sock(sk);\n\n\tnr->my_index = circuit / 256;\n\tnr->my_id    = circuit % 256;\n\n\tcircuit++;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state  = SS_CONNECTING;\n\tsk->sk_state = TCP_SYN_SENT;\n\n\tnr_establish_data_link(sk);\n\n\tnr->state = NR_STATE_1;\n\n\tnr_start_heartbeat(sk);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * A Connect Ack with Choke or timeout or failed routing will go to\n\t * closed.\n\t */\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int nr_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t     bool kern)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t *\tThe write queue this time is holding sockets ready to use\n\t *\thooked into the SABM we saved\n\t */\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (err)\n\t\tgoto out_release;\n\n\tnewsk = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t/* Now attach up the new socket */\n\tkfree_skb(skb);\n\tsk_acceptq_removed(sk);\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tint uaddr_len;\n\n\tmemset(&sax->fsa_ax25, 0, sizeof(struct sockaddr_ax25));\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tmemset(sax->fsa_digipeater, 0, sizeof(sax->fsa_digipeater));\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\tuaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\tuaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn uaddr_len;\n}\n\nint nr_rx_frame(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct nr_sock *nr_make;\n\tax25_address *src, *dest, *user;\n\tunsigned short circuit_index, circuit_id;\n\tunsigned short peer_circuit_index, peer_circuit_id;\n\tunsigned short frametype, flags, window, timeout;\n\tint ret;\n\n\tskb_orphan(skb);\n\n\t/*\n\t *\tskb->data points to the netrom frame start\n\t */\n\n\tsrc  = (ax25_address *)(skb->data + 0);\n\tdest = (ax25_address *)(skb->data + 7);\n\n\tcircuit_index      = skb->data[15];\n\tcircuit_id         = skb->data[16];\n\tpeer_circuit_index = skb->data[17];\n\tpeer_circuit_id    = skb->data[18];\n\tframetype          = skb->data[19] & 0x0F;\n\tflags              = skb->data[19] & 0xF0;\n\n\t/*\n\t * Check for an incoming IP over NET/ROM frame.\n\t */\n\tif (frametype == NR_PROTOEXT &&\n\t    circuit_index == NR_PROTO_IP && circuit_id == NR_PROTO_IP) {\n\t\tskb_pull(skb, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\n\t\tskb_reset_transport_header(skb);\n\n\t\treturn nr_rx_ip(skb, dev);\n\t}\n\n\t/*\n\t * Find an existing socket connection, based on circuit ID, if it's\n\t * a Connect Request base it on their circuit ID.\n\t *\n\t * Circuit ID 0/0 is not valid but it could still be a \"reset\" for a\n\t * circuit that no longer exists at the other end ...\n\t */\n\n\tsk = NULL;\n\n\tif (circuit_index == 0 && circuit_id == 0) {\n\t\tif (frametype == NR_CONNACK && flags == NR_CHOKE_FLAG)\n\t\t\tsk = nr_find_peer(peer_circuit_index, peer_circuit_id, src);\n\t} else {\n\t\tif (frametype == NR_CONNREQ)\n\t\t\tsk = nr_find_peer(circuit_index, circuit_id, src);\n\t\telse\n\t\t\tsk = nr_find_socket(circuit_index, circuit_id);\n\t}\n\n\tif (sk != NULL) {\n\t\tbh_lock_sock(sk);\n\t\tskb_reset_transport_header(skb);\n\n\t\tif (frametype == NR_CONNACK && skb->len == 22)\n\t\t\tnr_sk(sk)->bpqext = 1;\n\t\telse\n\t\t\tnr_sk(sk)->bpqext = 0;\n\n\t\tret = nr_process_rx_frame(sk, skb);\n\t\tbh_unlock_sock(sk);\n\t\tsock_put(sk);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now it should be a CONNREQ.\n\t */\n\tif (frametype != NR_CONNREQ) {\n\t\t/*\n\t\t * Here it would be nice to be able to send a reset but\n\t\t * NET/ROM doesn't have one.  We've tried to extend the protocol\n\t\t * by sending NR_CONNACK | NR_CHOKE_FLAGS replies but that\n\t\t * apparently kills BPQ boxes... :-(\n\t\t * So now we try to follow the established behaviour of\n\t\t * G8PZT's Xrouter which is sending packets with command type 7\n\t\t * as an extension of the protocol.\n\t\t */\n\t\tif (sysctl_netrom_reset_circuit &&\n\t\t    (frametype != NR_RESET || flags != 0))\n\t\t\tnr_transmit_reset(skb, 1);\n\n\t\treturn 0;\n\t}\n\n\tsk = nr_find_listener(dest);\n\n\tuser = (ax25_address *)(skb->data + 21);\n\n\tif (sk == NULL || sk_acceptq_is_full(sk) ||\n\t    (make = nr_make_new(sk)) == NULL) {\n\t\tnr_transmit_refusal(skb, 0);\n\t\tif (sk)\n\t\t\tsock_put(sk);\n\t\treturn 0;\n\t}\n\n\tbh_lock_sock(sk);\n\n\twindow = skb->data[20];\n\n\tsock_hold(make);\n\tskb->sk             = make;\n\tskb->destructor     = sock_efree;\n\tmake->sk_state\t    = TCP_ESTABLISHED;\n\n\t/* Fill in his circuit details */\n\tnr_make = nr_sk(make);\n\tnr_make->source_addr = *dest;\n\tnr_make->dest_addr   = *src;\n\tnr_make->user_addr   = *user;\n\n\tnr_make->your_index  = circuit_index;\n\tnr_make->your_id     = circuit_id;\n\n\tbh_unlock_sock(sk);\n\tcircuit = nr_find_next_circuit();\n\tbh_lock_sock(sk);\n\n\tnr_make->my_index    = circuit / 256;\n\tnr_make->my_id       = circuit % 256;\n\n\tcircuit++;\n\n\t/* Window negotiation */\n\tif (window < nr_make->window)\n\t\tnr_make->window = window;\n\n\t/* L4 timeout negotiation */\n\tif (skb->len == 37) {\n\t\ttimeout = skb->data[36] * 256 + skb->data[35];\n\t\tif (timeout * HZ < nr_make->t1)\n\t\t\tnr_make->t1 = timeout * HZ;\n\t\tnr_make->bpqext = 1;\n\t} else {\n\t\tnr_make->bpqext = 0;\n\t}\n\n\tnr_write_internal(make, NR_CONNACK);\n\n\tnr_make->condition = 0x00;\n\tnr_make->vs        = 0;\n\tnr_make->va        = 0;\n\tnr_make->vr        = 0;\n\tnr_make->vl        = 0;\n\tnr_make->state     = NR_STATE_3;\n\tsk_acceptq_added(sk);\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\n\tnr_insert_socket(make);\n\n\tnr_start_heartbeat(make);\n\tnr_start_idletimer(make);\n\n\treturn 1;\n}\n\nstatic int nr_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, usax, msg->msg_name);\n\tint err;\n\tstruct sockaddr_ax25 sax;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint size;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (nr->device == NULL) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tif (usax) {\n\t\tif (msg->msg_namelen < sizeof(sax)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tsax = *usax;\n\t\tif (ax25cmp(&nr->dest_addr, &sax.sax25_call) != 0) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sax.sax25_family != AF_NETROM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsax.sax25_family = AF_NETROM;\n\t\tsax.sax25_call   = nr->dest_addr;\n\t}\n\n\t/* Build a packet - the conventional user limit is 236 bytes. We can\n\t   do ludicrously large NetROM frames but must not overflow */\n\tif (len > 65536) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tsize = len + NR_NETWORK_LEN + NR_TRANSPORT_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\tgoto out;\n\n\tskb_reserve(skb, size - len);\n\tskb_reset_transport_header(skb);\n\n\t/*\n\t *\tPush down the NET/ROM header\n\t */\n\n\tasmptr = skb_push(skb, NR_TRANSPORT_LEN);\n\n\t/* Build a NET/ROM Transport header */\n\n\t*asmptr++ = nr->your_index;\n\t*asmptr++ = nr->your_id;\n\t*asmptr++ = 0;\t\t/* To be filled in later */\n\t*asmptr++ = 0;\t\t/*      Ditto            */\n\t*asmptr++ = NR_INFO;\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tskb_put(skb, len);\n\n\t/* User data follows immediately after the NET/ROM transport header */\n\tif (memcpy_from_msg(skb_transport_header(skb), msg, len)) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tnr_output(sk, skb);\t/* Shove it onto the queue */\n\n\terr = len;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int nr_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t      int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tDECLARE_SOCKADDR(struct sockaddr_ax25 *, sax, msg->msg_name);\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tskb = skb_recv_datagram(sk, flags, &er);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}\n\n\nstatic int nr_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tlock_sock(sk);\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trelease_sock(sk);\n\t\treturn put_user(amount, (int __user *)argp);\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\n\t\tlock_sock(sk);\n\t\t/* These two are safe on a single CPU system as only user tasks fiddle here */\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\trelease_sock(sk);\n\t\treturn put_user(amount, (int __user *)argp);\n\t}\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\treturn -EINVAL;\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCNRDECOBS:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn nr_rt_ioctl(cmd, argp);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *nr_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(&nr_list_lock)\n{\n\tspin_lock_bh(&nr_list_lock);\n\treturn seq_hlist_start_head(&nr_list, *pos);\n}\n\nstatic void *nr_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &nr_list, pos);\n}\n\nstatic void nr_info_stop(struct seq_file *seq, void *v)\n\t__releases(&nr_list_lock)\n{\n\tspin_unlock_bh(&nr_list_lock);\n}\n\nstatic int nr_info_show(struct seq_file *seq, void *v)\n{\n\tstruct sock *s = sk_entry(v);\n\tstruct net_device *dev;\n\tstruct nr_sock *nr;\n\tconst char *devname;\n\tchar buf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\"user_addr dest_node src_node  dev    my  your  st  vs  vr  va    t1     t2     t4      idle   n2  wnd Snd-Q Rcv-Q inode\\n\");\n\n\telse {\n\n\t\tbh_lock_sock(s);\n\t\tnr = nr_sk(s);\n\n\t\tif ((dev = nr->device) == NULL)\n\t\t\tdevname = \"???\";\n\t\telse\n\t\t\tdevname = dev->name;\n\n\t\tseq_printf(seq, \"%-9s \", ax2asc(buf, &nr->user_addr));\n\t\tseq_printf(seq, \"%-9s \", ax2asc(buf, &nr->dest_addr));\n\t\tseq_printf(seq,\n\"%-9s %-3s  %02X/%02X %02X/%02X %2d %3d %3d %3d %3lu/%03lu %2lu/%02lu %3lu/%03lu %3lu/%03lu %2d/%02d %3d %5d %5d %ld\\n\",\n\t\t\tax2asc(buf, &nr->source_addr),\n\t\t\tdevname,\n\t\t\tnr->my_index,\n\t\t\tnr->my_id,\n\t\t\tnr->your_index,\n\t\t\tnr->your_id,\n\t\t\tnr->state,\n\t\t\tnr->vs,\n\t\t\tnr->vr,\n\t\t\tnr->va,\n\t\t\tax25_display_timer(&nr->t1timer) / HZ,\n\t\t\tnr->t1 / HZ,\n\t\t\tax25_display_timer(&nr->t2timer) / HZ,\n\t\t\tnr->t2 / HZ,\n\t\t\tax25_display_timer(&nr->t4timer) / HZ,\n\t\t\tnr->t4 / HZ,\n\t\t\tax25_display_timer(&nr->idletimer) / (60 * HZ),\n\t\t\tnr->idle / (60 * HZ),\n\t\t\tnr->n2count,\n\t\t\tnr->n2,\n\t\t\tnr->window,\n\t\t\tsk_wmem_alloc_get(s),\n\t\t\tsk_rmem_alloc_get(s),\n\t\t\ts->sk_socket ? SOCK_INODE(s->sk_socket)->i_ino : 0L);\n\n\t\tbh_unlock_sock(s);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations nr_info_seqops = {\n\t.start = nr_info_start,\n\t.next = nr_info_next,\n\t.stop = nr_info_stop,\n\t.show = nr_info_show,\n};\n#endif\t/* CONFIG_PROC_FS */\n\nstatic const struct net_proto_family nr_family_ops = {\n\t.family\t\t=\tPF_NETROM,\n\t.create\t\t=\tnr_create,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops nr_proto_ops = {\n\t.family\t\t=\tPF_NETROM,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.release\t=\tnr_release,\n\t.bind\t\t=\tnr_bind,\n\t.connect\t=\tnr_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\tnr_accept,\n\t.getname\t=\tnr_getname,\n\t.poll\t\t=\tdatagram_poll,\n\t.ioctl\t\t=\tnr_ioctl,\n\t.gettstamp\t=\tsock_gettstamp,\n\t.listen\t\t=\tnr_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.setsockopt\t=\tnr_setsockopt,\n\t.getsockopt\t=\tnr_getsockopt,\n\t.sendmsg\t=\tnr_sendmsg,\n\t.recvmsg\t=\tnr_recvmsg,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n};\n\nstatic struct notifier_block nr_dev_notifier = {\n\t.notifier_call\t=\tnr_device_event,\n};\n\nstatic struct net_device **dev_nr;\n\nstatic struct ax25_protocol nr_pid = {\n\t.pid\t= AX25_P_NETROM,\n\t.func\t= nr_route_frame\n};\n\nstatic struct ax25_linkfail nr_linkfail_notifier = {\n\t.func\t= nr_link_failed,\n};\n\nstatic int __init nr_proto_init(void)\n{\n\tint i;\n\tint rc = proto_register(&nr_proto, 0);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (nr_ndevs > 0x7fffffff/sizeof(struct net_device *)) {\n\t\tpr_err(\"NET/ROM: %s - nr_ndevs parameter too large\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto unregister_proto;\n\t}\n\n\tdev_nr = kcalloc(nr_ndevs, sizeof(struct net_device *), GFP_KERNEL);\n\tif (!dev_nr) {\n\t\tpr_err(\"NET/ROM: %s - unable to allocate device array\\n\",\n\t\t       __func__);\n\t\trc = -ENOMEM;\n\t\tgoto unregister_proto;\n\t}\n\n\tfor (i = 0; i < nr_ndevs; i++) {\n\t\tchar name[IFNAMSIZ];\n\t\tstruct net_device *dev;\n\n\t\tsprintf(name, \"nr%d\", i);\n\t\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, nr_setup);\n\t\tif (!dev) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdev->base_addr = i;\n\t\trc = register_netdev(dev);\n\t\tif (rc) {\n\t\t\tfree_netdev(dev);\n\t\t\tgoto fail;\n\t\t}\n\t\tnr_set_lockdep_key(dev);\n\t\tdev_nr[i] = dev;\n\t}\n\n\trc = sock_register(&nr_family_ops);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = register_netdevice_notifier(&nr_dev_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\n\tax25_register_pid(&nr_pid);\n\tax25_linkfail_register(&nr_linkfail_notifier);\n\n#ifdef CONFIG_SYSCTL\n\trc = nr_register_sysctl();\n\tif (rc)\n\t\tgoto out_sysctl;\n#endif\n\n\tnr_loopback_init();\n\n\trc = -ENOMEM;\n\tif (!proc_create_seq(\"nr\", 0444, init_net.proc_net, &nr_info_seqops))\n\t\tgoto proc_remove1;\n\tif (!proc_create_seq(\"nr_neigh\", 0444, init_net.proc_net,\n\t\t\t     &nr_neigh_seqops))\n\t\tgoto proc_remove2;\n\tif (!proc_create_seq(\"nr_nodes\", 0444, init_net.proc_net,\n\t\t\t     &nr_node_seqops))\n\t\tgoto proc_remove3;\n\n\treturn 0;\n\nproc_remove3:\n\tremove_proc_entry(\"nr_neigh\", init_net.proc_net);\nproc_remove2:\n\tremove_proc_entry(\"nr\", init_net.proc_net);\nproc_remove1:\n\n\tnr_loopback_clear();\n\tnr_rt_free();\n\n#ifdef CONFIG_SYSCTL\n\tnr_unregister_sysctl();\nout_sysctl:\n#endif\n\tax25_linkfail_release(&nr_linkfail_notifier);\n\tax25_protocol_release(AX25_P_NETROM);\n\tunregister_netdevice_notifier(&nr_dev_notifier);\nout_sock:\n\tsock_unregister(PF_NETROM);\nfail:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(dev_nr[i]);\n\t\tfree_netdev(dev_nr[i]);\n\t}\n\tkfree(dev_nr);\nunregister_proto:\n\tproto_unregister(&nr_proto);\n\treturn rc;\n}\n\nmodule_init(nr_proto_init);\n\nmodule_param(nr_ndevs, int, 0);\nMODULE_PARM_DESC(nr_ndevs, \"number of NET/ROM devices\");\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio NET/ROM network and transport layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_NETROM);\n\nstatic void __exit nr_exit(void)\n{\n\tint i;\n\n\tremove_proc_entry(\"nr\", init_net.proc_net);\n\tremove_proc_entry(\"nr_neigh\", init_net.proc_net);\n\tremove_proc_entry(\"nr_nodes\", init_net.proc_net);\n\tnr_loopback_clear();\n\n\tnr_rt_free();\n\n#ifdef CONFIG_SYSCTL\n\tnr_unregister_sysctl();\n#endif\n\n\tax25_linkfail_release(&nr_linkfail_notifier);\n\tax25_protocol_release(AX25_P_NETROM);\n\n\tunregister_netdevice_notifier(&nr_dev_notifier);\n\n\tsock_unregister(PF_NETROM);\n\n\tfor (i = 0; i < nr_ndevs; i++) {\n\t\tstruct net_device *dev = dev_nr[i];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\tkfree(dev_nr);\n\tproto_unregister(&nr_proto);\n}\nmodule_exit(nr_exit);\n"], "filenames": ["net/netrom/af_netrom.c"], "buggy_code_start_loc": [402], "buggy_code_end_loc": [402], "fixing_code_start_loc": [403], "fixing_code_end_loc": [408], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c, there is a use-after-free because accept is also allowed for a successfully connected AF_NETROM socket. However, in order for an attacker to exploit this, the system must have netrom routing configured or the attacker must have the CAP_NET_ADMIN capability.", "other": {"cve": {"id": "CVE-2023-32269", "sourceIdentifier": "cve@mitre.org", "published": "2023-05-05T17:15:09.623", "lastModified": "2023-05-11T23:04:37.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c, there is a use-after-free because accept is also allowed for a successfully connected AF_NETROM socket. However, in order for an attacker to exploit this, the system must have netrom routing configured or the attacker must have the CAP_NET_ADMIN capability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1.11", "matchCriteriaId": "345F000B-5A9F-41D4-831B-E85C394DDAE4"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.1.11", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/611792920925fb088ddccbe2783c7f92fdfb6b64", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/611792920925fb088ddccbe2783c7f92fdfb6b64"}}