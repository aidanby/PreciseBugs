{"buggy_code": ["/*\n * Copyright (c) 2008-2017 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <netinet/icmp6.h>\n#include <stdlib.h>\n#include \"bitmap.h\"\n#include \"bundle.h\"\n#include \"byte-order.h\"\n#include \"classifier.h\"\n#include \"learn.h\"\n#include \"multipath.h\"\n#include \"netdev.h\"\n#include \"nx-match.h\"\n#include \"id-pool.h\"\n#include \"openflow/netronome-ext.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"openvswitch/meta-flow.h\"\n#include \"openvswitch/ofp-actions.h\"\n#include \"openvswitch/ofp-errors.h\"\n#include \"openvswitch/ofp-msgs.h\"\n#include \"openvswitch/ofp-print.h\"\n#include \"openvswitch/ofp-prop.h\"\n#include \"openvswitch/ofp-util.h\"\n#include \"openvswitch/ofpbuf.h\"\n#include \"openvswitch/type-props.h\"\n#include \"openvswitch/vlog.h\"\n#include \"openflow/intel-ext.h\"\n#include \"packets.h\"\n#include \"random.h\"\n#include \"tun-metadata.h\"\n#include \"unaligned.h\"\n#include \"util.h\"\n#include \"uuid.h\"\n\nVLOG_DEFINE_THIS_MODULE(ofp_util);\n\n/* Rate limit for OpenFlow message parse errors.  These always indicate a bug\n * in the peer and so there's not much point in showing a lot of them. */\nstatic struct vlog_rate_limit bad_ofmsg_rl = VLOG_RATE_LIMIT_INIT(1, 5);\n\nstatic enum ofputil_table_vacancy ofputil_decode_table_vacancy(\n    ovs_be32 config, enum ofp_version);\nstatic enum ofputil_table_eviction ofputil_decode_table_eviction(\n    ovs_be32 config, enum ofp_version);\nstatic ovs_be32 ofputil_encode_table_config(enum ofputil_table_miss,\n                                            enum ofputil_table_eviction,\n                                            enum ofputil_table_vacancy,\n                                            enum ofp_version);\n\n/* Given the wildcard bit count in the least-significant 6 of 'wcbits', returns\n * an IP netmask with a 1 in each bit that must match and a 0 in each bit that\n * is wildcarded.\n *\n * The bits in 'wcbits' are in the format used in enum ofp_flow_wildcards: 0\n * is exact match, 1 ignores the LSB, 2 ignores the 2 least-significant bits,\n * ..., 32 and higher wildcard the entire field.  This is the *opposite* of the\n * usual convention where e.g. /24 indicates that 8 bits (not 24 bits) are\n * wildcarded. */\novs_be32\nofputil_wcbits_to_netmask(int wcbits)\n{\n    wcbits &= 0x3f;\n    return wcbits < 32 ? htonl(~((1u << wcbits) - 1)) : 0;\n}\n\n/* Given the IP netmask 'netmask', returns the number of bits of the IP address\n * that it wildcards, that is, the number of 0-bits in 'netmask', a number\n * between 0 and 32 inclusive.\n *\n * If 'netmask' is not a CIDR netmask (see ip_is_cidr()), the return value will\n * still be in the valid range but isn't otherwise meaningful. */\nint\nofputil_netmask_to_wcbits(ovs_be32 netmask)\n{\n    return 32 - ip_count_cidr_bits(netmask);\n}\n\n/* Converts the OpenFlow 1.0 wildcards in 'ofpfw' (OFPFW10_*) into a\n * flow_wildcards in 'wc' for use in struct match.  It is the caller's\n * responsibility to handle the special case where the flow match's dl_vlan is\n * set to OFP_VLAN_NONE. */\nvoid\nofputil_wildcard_from_ofpfw10(uint32_t ofpfw, struct flow_wildcards *wc)\n{\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 36);\n\n    /* Initialize most of wc. */\n    flow_wildcards_init_catchall(wc);\n\n    if (!(ofpfw & OFPFW10_IN_PORT)) {\n        wc->masks.in_port.ofp_port = u16_to_ofp(UINT16_MAX);\n    }\n\n    if (!(ofpfw & OFPFW10_NW_TOS)) {\n        wc->masks.nw_tos |= IP_DSCP_MASK;\n    }\n\n    if (!(ofpfw & OFPFW10_NW_PROTO)) {\n        wc->masks.nw_proto = UINT8_MAX;\n    }\n    wc->masks.nw_src = ofputil_wcbits_to_netmask(ofpfw\n                                                 >> OFPFW10_NW_SRC_SHIFT);\n    wc->masks.nw_dst = ofputil_wcbits_to_netmask(ofpfw\n                                                 >> OFPFW10_NW_DST_SHIFT);\n\n    if (!(ofpfw & OFPFW10_TP_SRC)) {\n        wc->masks.tp_src = OVS_BE16_MAX;\n    }\n    if (!(ofpfw & OFPFW10_TP_DST)) {\n        wc->masks.tp_dst = OVS_BE16_MAX;\n    }\n\n    if (!(ofpfw & OFPFW10_DL_SRC)) {\n        WC_MASK_FIELD(wc, dl_src);\n    }\n    if (!(ofpfw & OFPFW10_DL_DST)) {\n        WC_MASK_FIELD(wc, dl_dst);\n    }\n    if (!(ofpfw & OFPFW10_DL_TYPE)) {\n        wc->masks.dl_type = OVS_BE16_MAX;\n    }\n\n    /* VLAN TCI mask. */\n    if (!(ofpfw & OFPFW10_DL_VLAN_PCP)) {\n        wc->masks.vlan_tci |= htons(VLAN_PCP_MASK | VLAN_CFI);\n    }\n    if (!(ofpfw & OFPFW10_DL_VLAN)) {\n        wc->masks.vlan_tci |= htons(VLAN_VID_MASK | VLAN_CFI);\n    }\n}\n\n/* Converts the ofp10_match in 'ofmatch' into a struct match in 'match'. */\nvoid\nofputil_match_from_ofp10_match(const struct ofp10_match *ofmatch,\n                               struct match *match)\n{\n    uint32_t ofpfw = ntohl(ofmatch->wildcards) & OFPFW10_ALL;\n\n    /* Initialize match->wc. */\n    memset(&match->flow, 0, sizeof match->flow);\n    ofputil_wildcard_from_ofpfw10(ofpfw, &match->wc);\n    memset(&match->tun_md, 0, sizeof match->tun_md);\n\n    /* Initialize most of match->flow. */\n    match->flow.nw_src = ofmatch->nw_src;\n    match->flow.nw_dst = ofmatch->nw_dst;\n    match->flow.in_port.ofp_port = u16_to_ofp(ntohs(ofmatch->in_port));\n    match->flow.dl_type = ofputil_dl_type_from_openflow(ofmatch->dl_type);\n    match->flow.tp_src = ofmatch->tp_src;\n    match->flow.tp_dst = ofmatch->tp_dst;\n    match->flow.dl_src = ofmatch->dl_src;\n    match->flow.dl_dst = ofmatch->dl_dst;\n    match->flow.nw_tos = ofmatch->nw_tos & IP_DSCP_MASK;\n    match->flow.nw_proto = ofmatch->nw_proto;\n\n    /* Translate VLANs. */\n    if (!(ofpfw & OFPFW10_DL_VLAN) &&\n        ofmatch->dl_vlan == htons(OFP10_VLAN_NONE)) {\n        /* Match only packets without 802.1Q header.\n         *\n         * When OFPFW10_DL_VLAN_PCP is wildcarded, this is obviously correct.\n         *\n         * If OFPFW10_DL_VLAN_PCP is matched, the flow match is contradictory,\n         * because we can't have a specific PCP without an 802.1Q header.\n         * However, older versions of OVS treated this as matching packets\n         * withut an 802.1Q header, so we do here too. */\n        match->flow.vlan_tci = htons(0);\n        match->wc.masks.vlan_tci = htons(0xffff);\n    } else {\n        ovs_be16 vid, pcp, tci;\n        uint16_t hpcp;\n\n        vid = ofmatch->dl_vlan & htons(VLAN_VID_MASK);\n        hpcp = (ofmatch->dl_vlan_pcp << VLAN_PCP_SHIFT) & VLAN_PCP_MASK;\n        pcp = htons(hpcp);\n        tci = vid | pcp | htons(VLAN_CFI);\n        match->flow.vlan_tci = tci & match->wc.masks.vlan_tci;\n    }\n\n    /* Clean up. */\n    match_zero_wildcarded_fields(match);\n}\n\n/* Convert 'match' into the OpenFlow 1.0 match structure 'ofmatch'. */\nvoid\nofputil_match_to_ofp10_match(const struct match *match,\n                             struct ofp10_match *ofmatch)\n{\n    const struct flow_wildcards *wc = &match->wc;\n    uint32_t ofpfw;\n\n    /* Figure out most OpenFlow wildcards. */\n    ofpfw = 0;\n    if (!wc->masks.in_port.ofp_port) {\n        ofpfw |= OFPFW10_IN_PORT;\n    }\n    if (!wc->masks.dl_type) {\n        ofpfw |= OFPFW10_DL_TYPE;\n    }\n    if (!wc->masks.nw_proto) {\n        ofpfw |= OFPFW10_NW_PROTO;\n    }\n    ofpfw |= (ofputil_netmask_to_wcbits(wc->masks.nw_src)\n              << OFPFW10_NW_SRC_SHIFT);\n    ofpfw |= (ofputil_netmask_to_wcbits(wc->masks.nw_dst)\n              << OFPFW10_NW_DST_SHIFT);\n    if (!(wc->masks.nw_tos & IP_DSCP_MASK)) {\n        ofpfw |= OFPFW10_NW_TOS;\n    }\n    if (!wc->masks.tp_src) {\n        ofpfw |= OFPFW10_TP_SRC;\n    }\n    if (!wc->masks.tp_dst) {\n        ofpfw |= OFPFW10_TP_DST;\n    }\n    if (eth_addr_is_zero(wc->masks.dl_src)) {\n        ofpfw |= OFPFW10_DL_SRC;\n    }\n    if (eth_addr_is_zero(wc->masks.dl_dst)) {\n        ofpfw |= OFPFW10_DL_DST;\n    }\n\n    /* Translate VLANs. */\n    ofmatch->dl_vlan = htons(0);\n    ofmatch->dl_vlan_pcp = 0;\n    if (match->wc.masks.vlan_tci == htons(0)) {\n        ofpfw |= OFPFW10_DL_VLAN | OFPFW10_DL_VLAN_PCP;\n    } else if (match->wc.masks.vlan_tci & htons(VLAN_CFI)\n               && !(match->flow.vlan_tci & htons(VLAN_CFI))) {\n        ofmatch->dl_vlan = htons(OFP10_VLAN_NONE);\n    } else {\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_VID_MASK))) {\n            ofpfw |= OFPFW10_DL_VLAN;\n        } else {\n            ofmatch->dl_vlan = htons(vlan_tci_to_vid(match->flow.vlan_tci));\n        }\n\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_PCP_MASK))) {\n            ofpfw |= OFPFW10_DL_VLAN_PCP;\n        } else {\n            ofmatch->dl_vlan_pcp = vlan_tci_to_pcp(match->flow.vlan_tci);\n        }\n    }\n\n    /* Compose most of the match structure. */\n    ofmatch->wildcards = htonl(ofpfw);\n    ofmatch->in_port = htons(ofp_to_u16(match->flow.in_port.ofp_port));\n    ofmatch->dl_src = match->flow.dl_src;\n    ofmatch->dl_dst = match->flow.dl_dst;\n    ofmatch->dl_type = ofputil_dl_type_to_openflow(match->flow.dl_type);\n    ofmatch->nw_src = match->flow.nw_src;\n    ofmatch->nw_dst = match->flow.nw_dst;\n    ofmatch->nw_tos = match->flow.nw_tos & IP_DSCP_MASK;\n    ofmatch->nw_proto = match->flow.nw_proto;\n    ofmatch->tp_src = match->flow.tp_src;\n    ofmatch->tp_dst = match->flow.tp_dst;\n    memset(ofmatch->pad1, '\\0', sizeof ofmatch->pad1);\n    memset(ofmatch->pad2, '\\0', sizeof ofmatch->pad2);\n}\n\nenum ofperr\nofputil_pull_ofp11_match(struct ofpbuf *buf, const struct tun_table *tun_table,\n                         const struct vl_mff_map *vl_mff_map,\n                         struct match *match, uint16_t *padded_match_len)\n{\n    struct ofp11_match_header *omh = buf->data;\n    uint16_t match_len;\n\n    if (buf->size < sizeof *omh) {\n        return OFPERR_OFPBMC_BAD_LEN;\n    }\n\n    match_len = ntohs(omh->length);\n\n    switch (ntohs(omh->type)) {\n    case OFPMT_STANDARD: {\n        struct ofp11_match *om;\n\n        if (match_len != sizeof *om || buf->size < sizeof *om) {\n            return OFPERR_OFPBMC_BAD_LEN;\n        }\n        om = ofpbuf_pull(buf, sizeof *om);\n        if (padded_match_len) {\n            *padded_match_len = match_len;\n        }\n        return ofputil_match_from_ofp11_match(om, match);\n    }\n\n    case OFPMT_OXM:\n        if (padded_match_len) {\n            *padded_match_len = ROUND_UP(match_len, 8);\n        }\n        return oxm_pull_match(buf, tun_table, vl_mff_map, match);\n\n    default:\n        return OFPERR_OFPBMC_BAD_TYPE;\n    }\n}\n\n/* Converts the ofp11_match in 'ofmatch' into a struct match in 'match'.\n * Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_match_from_ofp11_match(const struct ofp11_match *ofmatch,\n                               struct match *match)\n{\n    uint16_t wc = ntohl(ofmatch->wildcards);\n    bool ipv4, arp, rarp;\n\n    match_init_catchall(match);\n\n    if (!(wc & OFPFW11_IN_PORT)) {\n        ofp_port_t ofp_port;\n        enum ofperr error;\n\n        error = ofputil_port_from_ofp11(ofmatch->in_port, &ofp_port);\n        if (error) {\n            return OFPERR_OFPBMC_BAD_VALUE;\n        }\n        match_set_in_port(match, ofp_port);\n    }\n\n    match_set_dl_src_masked(match, ofmatch->dl_src,\n                            eth_addr_invert(ofmatch->dl_src_mask));\n    match_set_dl_dst_masked(match, ofmatch->dl_dst,\n                            eth_addr_invert(ofmatch->dl_dst_mask));\n\n    if (!(wc & OFPFW11_DL_VLAN)) {\n        if (ofmatch->dl_vlan == htons(OFPVID11_NONE)) {\n            /* Match only packets without a VLAN tag. */\n            match->flow.vlan_tci = htons(0);\n            match->wc.masks.vlan_tci = OVS_BE16_MAX;\n        } else {\n            if (ofmatch->dl_vlan == htons(OFPVID11_ANY)) {\n                /* Match any packet with a VLAN tag regardless of VID. */\n                match->flow.vlan_tci = htons(VLAN_CFI);\n                match->wc.masks.vlan_tci = htons(VLAN_CFI);\n            } else if (ntohs(ofmatch->dl_vlan) < 4096) {\n                /* Match only packets with the specified VLAN VID. */\n                match->flow.vlan_tci = htons(VLAN_CFI) | ofmatch->dl_vlan;\n                match->wc.masks.vlan_tci = htons(VLAN_CFI | VLAN_VID_MASK);\n            } else {\n                /* Invalid VID. */\n                return OFPERR_OFPBMC_BAD_VALUE;\n            }\n\n            if (!(wc & OFPFW11_DL_VLAN_PCP)) {\n                if (ofmatch->dl_vlan_pcp <= 7) {\n                    match->flow.vlan_tci |= htons(ofmatch->dl_vlan_pcp\n                                                  << VLAN_PCP_SHIFT);\n                    match->wc.masks.vlan_tci |= htons(VLAN_PCP_MASK);\n                } else {\n                    /* Invalid PCP. */\n                    return OFPERR_OFPBMC_BAD_VALUE;\n                }\n            }\n        }\n    }\n\n    if (!(wc & OFPFW11_DL_TYPE)) {\n        match_set_dl_type(match,\n                          ofputil_dl_type_from_openflow(ofmatch->dl_type));\n    }\n\n    ipv4 = match->flow.dl_type == htons(ETH_TYPE_IP);\n    arp = match->flow.dl_type == htons(ETH_TYPE_ARP);\n    rarp = match->flow.dl_type == htons(ETH_TYPE_RARP);\n\n    if (ipv4 && !(wc & OFPFW11_NW_TOS)) {\n        if (ofmatch->nw_tos & ~IP_DSCP_MASK) {\n            /* Invalid TOS. */\n            return OFPERR_OFPBMC_BAD_VALUE;\n        }\n\n        match_set_nw_dscp(match, ofmatch->nw_tos);\n    }\n\n    if (ipv4 || arp || rarp) {\n        if (!(wc & OFPFW11_NW_PROTO)) {\n            match_set_nw_proto(match, ofmatch->nw_proto);\n        }\n        match_set_nw_src_masked(match, ofmatch->nw_src, ~ofmatch->nw_src_mask);\n        match_set_nw_dst_masked(match, ofmatch->nw_dst, ~ofmatch->nw_dst_mask);\n    }\n\n#define OFPFW11_TP_ALL (OFPFW11_TP_SRC | OFPFW11_TP_DST)\n    if (ipv4 && (wc & OFPFW11_TP_ALL) != OFPFW11_TP_ALL) {\n        switch (match->flow.nw_proto) {\n        case IPPROTO_ICMP:\n            /* \"A.2.3 Flow Match Structures\" in OF1.1 says:\n             *\n             *    The tp_src and tp_dst fields will be ignored unless the\n             *    network protocol specified is as TCP, UDP or SCTP.\n             *\n             * but I'm pretty sure we should support ICMP too, otherwise\n             * that's a regression from OF1.0. */\n            if (!(wc & OFPFW11_TP_SRC)) {\n                uint16_t icmp_type = ntohs(ofmatch->tp_src);\n                if (icmp_type < 0x100) {\n                    match_set_icmp_type(match, icmp_type);\n                } else {\n                    return OFPERR_OFPBMC_BAD_FIELD;\n                }\n            }\n            if (!(wc & OFPFW11_TP_DST)) {\n                uint16_t icmp_code = ntohs(ofmatch->tp_dst);\n                if (icmp_code < 0x100) {\n                    match_set_icmp_code(match, icmp_code);\n                } else {\n                    return OFPERR_OFPBMC_BAD_FIELD;\n                }\n            }\n            break;\n\n        case IPPROTO_TCP:\n        case IPPROTO_UDP:\n        case IPPROTO_SCTP:\n            if (!(wc & (OFPFW11_TP_SRC))) {\n                match_set_tp_src(match, ofmatch->tp_src);\n            }\n            if (!(wc & (OFPFW11_TP_DST))) {\n                match_set_tp_dst(match, ofmatch->tp_dst);\n            }\n            break;\n\n        default:\n            /* OF1.1 says explicitly to ignore this. */\n            break;\n        }\n    }\n\n    if (eth_type_mpls(match->flow.dl_type)) {\n        if (!(wc & OFPFW11_MPLS_LABEL)) {\n            match_set_mpls_label(match, 0, ofmatch->mpls_label);\n        }\n        if (!(wc & OFPFW11_MPLS_TC)) {\n            match_set_mpls_tc(match, 0, ofmatch->mpls_tc);\n        }\n    }\n\n    match_set_metadata_masked(match, ofmatch->metadata,\n                              ~ofmatch->metadata_mask);\n\n    return 0;\n}\n\n/* Convert 'match' into the OpenFlow 1.1 match structure 'ofmatch'. */\nvoid\nofputil_match_to_ofp11_match(const struct match *match,\n                             struct ofp11_match *ofmatch)\n{\n    uint32_t wc = 0;\n\n    memset(ofmatch, 0, sizeof *ofmatch);\n    ofmatch->omh.type = htons(OFPMT_STANDARD);\n    ofmatch->omh.length = htons(OFPMT11_STANDARD_LENGTH);\n\n    if (!match->wc.masks.in_port.ofp_port) {\n        wc |= OFPFW11_IN_PORT;\n    } else {\n        ofmatch->in_port = ofputil_port_to_ofp11(match->flow.in_port.ofp_port);\n    }\n\n    ofmatch->dl_src = match->flow.dl_src;\n    ofmatch->dl_src_mask = eth_addr_invert(match->wc.masks.dl_src);\n    ofmatch->dl_dst = match->flow.dl_dst;\n    ofmatch->dl_dst_mask = eth_addr_invert(match->wc.masks.dl_dst);\n\n    if (match->wc.masks.vlan_tci == htons(0)) {\n        wc |= OFPFW11_DL_VLAN | OFPFW11_DL_VLAN_PCP;\n    } else if (match->wc.masks.vlan_tci & htons(VLAN_CFI)\n               && !(match->flow.vlan_tci & htons(VLAN_CFI))) {\n        ofmatch->dl_vlan = htons(OFPVID11_NONE);\n        wc |= OFPFW11_DL_VLAN_PCP;\n    } else {\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_VID_MASK))) {\n            ofmatch->dl_vlan = htons(OFPVID11_ANY);\n        } else {\n            ofmatch->dl_vlan = htons(vlan_tci_to_vid(match->flow.vlan_tci));\n        }\n\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_PCP_MASK))) {\n            wc |= OFPFW11_DL_VLAN_PCP;\n        } else {\n            ofmatch->dl_vlan_pcp = vlan_tci_to_pcp(match->flow.vlan_tci);\n        }\n    }\n\n    if (!match->wc.masks.dl_type) {\n        wc |= OFPFW11_DL_TYPE;\n    } else {\n        ofmatch->dl_type = ofputil_dl_type_to_openflow(match->flow.dl_type);\n    }\n\n    if (!(match->wc.masks.nw_tos & IP_DSCP_MASK)) {\n        wc |= OFPFW11_NW_TOS;\n    } else {\n        ofmatch->nw_tos = match->flow.nw_tos & IP_DSCP_MASK;\n    }\n\n    if (!match->wc.masks.nw_proto) {\n        wc |= OFPFW11_NW_PROTO;\n    } else {\n        ofmatch->nw_proto = match->flow.nw_proto;\n    }\n\n    ofmatch->nw_src = match->flow.nw_src;\n    ofmatch->nw_src_mask = ~match->wc.masks.nw_src;\n    ofmatch->nw_dst = match->flow.nw_dst;\n    ofmatch->nw_dst_mask = ~match->wc.masks.nw_dst;\n\n    if (!match->wc.masks.tp_src) {\n        wc |= OFPFW11_TP_SRC;\n    } else {\n        ofmatch->tp_src = match->flow.tp_src;\n    }\n\n    if (!match->wc.masks.tp_dst) {\n        wc |= OFPFW11_TP_DST;\n    } else {\n        ofmatch->tp_dst = match->flow.tp_dst;\n    }\n\n    if (!(match->wc.masks.mpls_lse[0] & htonl(MPLS_LABEL_MASK))) {\n        wc |= OFPFW11_MPLS_LABEL;\n    } else {\n        ofmatch->mpls_label = htonl(mpls_lse_to_label(\n                                        match->flow.mpls_lse[0]));\n    }\n\n    if (!(match->wc.masks.mpls_lse[0] & htonl(MPLS_TC_MASK))) {\n        wc |= OFPFW11_MPLS_TC;\n    } else {\n        ofmatch->mpls_tc = mpls_lse_to_tc(match->flow.mpls_lse[0]);\n    }\n\n    ofmatch->metadata = match->flow.metadata;\n    ofmatch->metadata_mask = ~match->wc.masks.metadata;\n\n    ofmatch->wildcards = htonl(wc);\n}\n\n/* Returns the \"typical\" length of a match for 'protocol', for use in\n * estimating space to preallocate. */\nint\nofputil_match_typical_len(enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n        return sizeof(struct ofp10_match);\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return NXM_TYPICAL_LEN;\n\n    case OFPUTIL_P_OF11_STD:\n        return sizeof(struct ofp11_match);\n\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM:\n        return NXM_TYPICAL_LEN;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Appends to 'b' an struct ofp11_match_header followed by a match that\n * expresses 'match' properly for 'protocol', plus enough zero bytes to pad the\n * data appended out to a multiple of 8.  'protocol' must be one that is usable\n * in OpenFlow 1.1 or later.\n *\n * This function can cause 'b''s data to be reallocated.\n *\n * Returns the number of bytes appended to 'b', excluding the padding.  Never\n * returns zero. */\nint\nofputil_put_ofp11_match(struct ofpbuf *b, const struct match *match,\n                        enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        OVS_NOT_REACHED();\n\n    case OFPUTIL_P_OF11_STD: {\n        struct ofp11_match *om;\n\n        /* Make sure that no padding is needed. */\n        BUILD_ASSERT_DECL(sizeof *om % 8 == 0);\n\n        om = ofpbuf_put_uninit(b, sizeof *om);\n        ofputil_match_to_ofp11_match(match, om);\n        return sizeof *om;\n    }\n\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM:\n        return oxm_put_match(b, match,\n                             ofputil_protocol_to_ofp_version(protocol));\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Given a 'dl_type' value in the format used in struct flow, returns the\n * corresponding 'dl_type' value for use in an ofp10_match or ofp11_match\n * structure. */\novs_be16\nofputil_dl_type_to_openflow(ovs_be16 flow_dl_type)\n{\n    return (flow_dl_type == htons(FLOW_DL_TYPE_NONE)\n            ? htons(OFP_DL_TYPE_NOT_ETH_TYPE)\n            : flow_dl_type);\n}\n\n/* Given a 'dl_type' value in the format used in an ofp10_match or ofp11_match\n * structure, returns the corresponding 'dl_type' value for use in struct\n * flow. */\novs_be16\nofputil_dl_type_from_openflow(ovs_be16 ofp_dl_type)\n{\n    return (ofp_dl_type == htons(OFP_DL_TYPE_NOT_ETH_TYPE)\n            ? htons(FLOW_DL_TYPE_NONE)\n            : ofp_dl_type);\n}\n\f\n/* Protocols. */\n\nstruct proto_abbrev {\n    enum ofputil_protocol protocol;\n    const char *name;\n};\n\n/* Most users really don't care about some of the differences between\n * protocols.  These abbreviations help with that. */\nstatic const struct proto_abbrev proto_abbrevs[] = {\n    { OFPUTIL_P_ANY,          \"any\" },\n    { OFPUTIL_P_OF10_STD_ANY, \"OpenFlow10\" },\n    { OFPUTIL_P_OF10_NXM_ANY, \"NXM\" },\n    { OFPUTIL_P_ANY_OXM,      \"OXM\" },\n};\n#define N_PROTO_ABBREVS ARRAY_SIZE(proto_abbrevs)\n\nenum ofputil_protocol ofputil_flow_dump_protocols[] = {\n    OFPUTIL_P_OF16_OXM,\n    OFPUTIL_P_OF15_OXM,\n    OFPUTIL_P_OF14_OXM,\n    OFPUTIL_P_OF13_OXM,\n    OFPUTIL_P_OF12_OXM,\n    OFPUTIL_P_OF11_STD,\n    OFPUTIL_P_OF10_NXM,\n    OFPUTIL_P_OF10_STD,\n};\nsize_t ofputil_n_flow_dump_protocols = ARRAY_SIZE(ofputil_flow_dump_protocols);\n\n/* Returns the set of ofputil_protocols that are supported with the given\n * OpenFlow 'version'.  'version' should normally be an 8-bit OpenFlow version\n * identifier (e.g. 0x01 for OpenFlow 1.0, 0x02 for OpenFlow 1.1).  Returns 0\n * if 'version' is not supported or outside the valid range.  */\nenum ofputil_protocol\nofputil_protocols_from_ofp_version(enum ofp_version version)\n{\n    switch (version) {\n    case OFP10_VERSION:\n        return OFPUTIL_P_OF10_STD_ANY | OFPUTIL_P_OF10_NXM_ANY;\n    case OFP11_VERSION:\n        return OFPUTIL_P_OF11_STD;\n    case OFP12_VERSION:\n        return OFPUTIL_P_OF12_OXM;\n    case OFP13_VERSION:\n        return OFPUTIL_P_OF13_OXM;\n    case OFP14_VERSION:\n        return OFPUTIL_P_OF14_OXM;\n    case OFP15_VERSION:\n        return OFPUTIL_P_OF15_OXM;\n    case OFP16_VERSION:\n        return OFPUTIL_P_OF16_OXM;\n    default:\n        return 0;\n    }\n}\n\n/* Returns the ofputil_protocol that is initially in effect on an OpenFlow\n * connection that has negotiated the given 'version'.  'version' should\n * normally be an 8-bit OpenFlow version identifier (e.g. 0x01 for OpenFlow\n * 1.0, 0x02 for OpenFlow 1.1).  Returns 0 if 'version' is not supported or\n * outside the valid range.  */\nenum ofputil_protocol\nofputil_protocol_from_ofp_version(enum ofp_version version)\n{\n    return rightmost_1bit(ofputil_protocols_from_ofp_version(version));\n}\n\n/* Returns the OpenFlow protocol version number (e.g. OFP10_VERSION,\n * etc.) that corresponds to 'protocol'. */\nenum ofp_version\nofputil_protocol_to_ofp_version(enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return OFP10_VERSION;\n    case OFPUTIL_P_OF11_STD:\n        return OFP11_VERSION;\n    case OFPUTIL_P_OF12_OXM:\n        return OFP12_VERSION;\n    case OFPUTIL_P_OF13_OXM:\n        return OFP13_VERSION;\n    case OFPUTIL_P_OF14_OXM:\n        return OFP14_VERSION;\n    case OFPUTIL_P_OF15_OXM:\n        return OFP15_VERSION;\n    case OFPUTIL_P_OF16_OXM:\n        return OFP16_VERSION;\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Returns a bitmap of OpenFlow versions that are supported by at\n * least one of the 'protocols'. */\nuint32_t\nofputil_protocols_to_version_bitmap(enum ofputil_protocol protocols)\n{\n    uint32_t bitmap = 0;\n\n    for (; protocols; protocols = zero_rightmost_1bit(protocols)) {\n        enum ofputil_protocol protocol = rightmost_1bit(protocols);\n\n        bitmap |= 1u << ofputil_protocol_to_ofp_version(protocol);\n    }\n\n    return bitmap;\n}\n\n/* Returns the set of protocols that are supported on top of the\n * OpenFlow versions included in 'bitmap'. */\nenum ofputil_protocol\nofputil_protocols_from_version_bitmap(uint32_t bitmap)\n{\n    enum ofputil_protocol protocols = 0;\n\n    for (; bitmap; bitmap = zero_rightmost_1bit(bitmap)) {\n        enum ofp_version version = rightmost_1bit_idx(bitmap);\n\n        protocols |= ofputil_protocols_from_ofp_version(version);\n    }\n\n    return protocols;\n}\n\n/* Returns true if 'protocol' is a single OFPUTIL_P_* value, false\n * otherwise. */\nbool\nofputil_protocol_is_valid(enum ofputil_protocol protocol)\n{\n    return protocol & OFPUTIL_P_ANY && is_pow2(protocol);\n}\n\n/* Returns the equivalent of 'protocol' with the Nicira flow_mod_table_id\n * extension turned on or off if 'enable' is true or false, respectively.\n *\n * This extension is only useful for protocols whose \"standard\" version does\n * not allow specific tables to be modified.  In particular, this is true of\n * OpenFlow 1.0.  In later versions of OpenFlow, a flow_mod request always\n * specifies a table ID and so there is no need for such an extension.  When\n * 'protocol' is such a protocol that doesn't need a flow_mod_table_id\n * extension, this function just returns its 'protocol' argument unchanged\n * regardless of the value of 'enable'.  */\nenum ofputil_protocol\nofputil_protocol_set_tid(enum ofputil_protocol protocol, bool enable)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n        return enable ? OFPUTIL_P_OF10_STD_TID : OFPUTIL_P_OF10_STD;\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return enable ? OFPUTIL_P_OF10_NXM_TID : OFPUTIL_P_OF10_NXM;\n\n    case OFPUTIL_P_OF11_STD:\n        return OFPUTIL_P_OF11_STD;\n\n    case OFPUTIL_P_OF12_OXM:\n        return OFPUTIL_P_OF12_OXM;\n\n    case OFPUTIL_P_OF13_OXM:\n        return OFPUTIL_P_OF13_OXM;\n\n    case OFPUTIL_P_OF14_OXM:\n        return OFPUTIL_P_OF14_OXM;\n\n    case OFPUTIL_P_OF15_OXM:\n        return OFPUTIL_P_OF15_OXM;\n\n    case OFPUTIL_P_OF16_OXM:\n        return OFPUTIL_P_OF16_OXM;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Returns the \"base\" version of 'protocol'.  That is, if 'protocol' includes\n * some extension to a standard protocol version, the return value is the\n * standard version of that protocol without any extension.  If 'protocol' is a\n * standard protocol version, returns 'protocol' unchanged. */\nenum ofputil_protocol\nofputil_protocol_to_base(enum ofputil_protocol protocol)\n{\n    return ofputil_protocol_set_tid(protocol, false);\n}\n\n/* Returns 'new_base' with any extensions taken from 'cur'. */\nenum ofputil_protocol\nofputil_protocol_set_base(enum ofputil_protocol cur,\n                          enum ofputil_protocol new_base)\n{\n    bool tid = (cur & OFPUTIL_P_TID) != 0;\n\n    switch (new_base) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF10_STD, tid);\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF10_NXM, tid);\n\n    case OFPUTIL_P_OF11_STD:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF11_STD, tid);\n\n    case OFPUTIL_P_OF12_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF12_OXM, tid);\n\n    case OFPUTIL_P_OF13_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF13_OXM, tid);\n\n    case OFPUTIL_P_OF14_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF14_OXM, tid);\n\n    case OFPUTIL_P_OF15_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF15_OXM, tid);\n\n    case OFPUTIL_P_OF16_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF16_OXM, tid);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Returns a string form of 'protocol', if a simple form exists (that is, if\n * 'protocol' is either a single protocol or it is a combination of protocols\n * that have a single abbreviation).  Otherwise, returns NULL. */\nconst char *\nofputil_protocol_to_string(enum ofputil_protocol protocol)\n{\n    const struct proto_abbrev *p;\n\n    /* Use a \"switch\" statement for single-bit names so that we get a compiler\n     * warning if we forget any. */\n    switch (protocol) {\n    case OFPUTIL_P_OF10_NXM:\n        return \"NXM-table_id\";\n\n    case OFPUTIL_P_OF10_NXM_TID:\n        return \"NXM+table_id\";\n\n    case OFPUTIL_P_OF10_STD:\n        return \"OpenFlow10-table_id\";\n\n    case OFPUTIL_P_OF10_STD_TID:\n        return \"OpenFlow10+table_id\";\n\n    case OFPUTIL_P_OF11_STD:\n        return \"OpenFlow11\";\n\n    case OFPUTIL_P_OF12_OXM:\n        return \"OXM-OpenFlow12\";\n\n    case OFPUTIL_P_OF13_OXM:\n        return \"OXM-OpenFlow13\";\n\n    case OFPUTIL_P_OF14_OXM:\n        return \"OXM-OpenFlow14\";\n\n    case OFPUTIL_P_OF15_OXM:\n        return \"OXM-OpenFlow15\";\n\n    case OFPUTIL_P_OF16_OXM:\n        return \"OXM-OpenFlow16\";\n    }\n\n    /* Check abbreviations. */\n    for (p = proto_abbrevs; p < &proto_abbrevs[N_PROTO_ABBREVS]; p++) {\n        if (protocol == p->protocol) {\n            return p->name;\n        }\n    }\n\n    return NULL;\n}\n\n/* Returns a string that represents 'protocols'.  The return value might be a\n * comma-separated list if 'protocols' doesn't have a simple name.  The return\n * value is \"none\" if 'protocols' is 0.\n *\n * The caller must free the returned string (with free()). */\nchar *\nofputil_protocols_to_string(enum ofputil_protocol protocols)\n{\n    struct ds s;\n\n    ovs_assert(!(protocols & ~OFPUTIL_P_ANY));\n    if (protocols == 0) {\n        return xstrdup(\"none\");\n    }\n\n    ds_init(&s);\n    while (protocols) {\n        const struct proto_abbrev *p;\n        int i;\n\n        if (s.length) {\n            ds_put_char(&s, ',');\n        }\n\n        for (p = proto_abbrevs; p < &proto_abbrevs[N_PROTO_ABBREVS]; p++) {\n            if ((protocols & p->protocol) == p->protocol) {\n                ds_put_cstr(&s, p->name);\n                protocols &= ~p->protocol;\n                goto match;\n            }\n        }\n\n        for (i = 0; i < CHAR_BIT * sizeof(enum ofputil_protocol); i++) {\n            enum ofputil_protocol bit = 1u << i;\n\n            if (protocols & bit) {\n                ds_put_cstr(&s, ofputil_protocol_to_string(bit));\n                protocols &= ~bit;\n                goto match;\n            }\n        }\n        OVS_NOT_REACHED();\n\n    match: ;\n    }\n    return ds_steal_cstr(&s);\n}\n\nstatic enum ofputil_protocol\nofputil_protocol_from_string__(const char *s, size_t n)\n{\n    const struct proto_abbrev *p;\n    int i;\n\n    for (i = 0; i < CHAR_BIT * sizeof(enum ofputil_protocol); i++) {\n        enum ofputil_protocol bit = 1u << i;\n        const char *name = ofputil_protocol_to_string(bit);\n\n        if (name && n == strlen(name) && !strncasecmp(s, name, n)) {\n            return bit;\n        }\n    }\n\n    for (p = proto_abbrevs; p < &proto_abbrevs[N_PROTO_ABBREVS]; p++) {\n        if (n == strlen(p->name) && !strncasecmp(s, p->name, n)) {\n            return p->protocol;\n        }\n    }\n\n    return 0;\n}\n\n/* Returns the nonempty set of protocols represented by 's', which can be a\n * single protocol name or abbreviation or a comma-separated list of them.\n *\n * Aborts the program with an error message if 's' is invalid. */\nenum ofputil_protocol\nofputil_protocols_from_string(const char *s)\n{\n    const char *orig_s = s;\n    enum ofputil_protocol protocols;\n\n    protocols = 0;\n    while (*s) {\n        enum ofputil_protocol p;\n        size_t n;\n\n        n = strcspn(s, \",\");\n        if (n == 0) {\n            s++;\n            continue;\n        }\n\n        p = ofputil_protocol_from_string__(s, n);\n        if (!p) {\n            ovs_fatal(0, \"%.*s: unknown flow protocol\", (int) n, s);\n        }\n        protocols |= p;\n\n        s += n;\n    }\n\n    if (!protocols) {\n        ovs_fatal(0, \"%s: no flow protocol specified\", orig_s);\n    }\n    return protocols;\n}\n\nenum ofp_version\nofputil_version_from_string(const char *s)\n{\n    if (!strcasecmp(s, \"OpenFlow10\")) {\n        return OFP10_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow11\")) {\n        return OFP11_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow12\")) {\n        return OFP12_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow13\")) {\n        return OFP13_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow14\")) {\n        return OFP14_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow15\")) {\n        return OFP15_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow16\")) {\n        return OFP16_VERSION;\n    }\n    return 0;\n}\n\nstatic bool\nis_delimiter(unsigned char c)\n{\n    return isspace(c) || c == ',';\n}\n\nuint32_t\nofputil_versions_from_string(const char *s)\n{\n    size_t i = 0;\n    uint32_t bitmap = 0;\n\n    while (s[i]) {\n        size_t j;\n        int version;\n        char *key;\n\n        if (is_delimiter(s[i])) {\n            i++;\n            continue;\n        }\n        j = 0;\n        while (s[i + j] && !is_delimiter(s[i + j])) {\n            j++;\n        }\n        key = xmemdup0(s + i, j);\n        version = ofputil_version_from_string(key);\n        if (!version) {\n            VLOG_FATAL(\"Unknown OpenFlow version: \\\"%s\\\"\", key);\n        }\n        free(key);\n        bitmap |= 1u << version;\n        i += j;\n    }\n\n    return bitmap;\n}\n\nuint32_t\nofputil_versions_from_strings(char ** const s, size_t count)\n{\n    uint32_t bitmap = 0;\n\n    while (count--) {\n        int version = ofputil_version_from_string(s[count]);\n        if (!version) {\n            VLOG_WARN(\"Unknown OpenFlow version: \\\"%s\\\"\", s[count]);\n        } else {\n            bitmap |= 1u << version;\n        }\n    }\n\n    return bitmap;\n}\n\nconst char *\nofputil_version_to_string(enum ofp_version ofp_version)\n{\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        return \"OpenFlow10\";\n    case OFP11_VERSION:\n        return \"OpenFlow11\";\n    case OFP12_VERSION:\n        return \"OpenFlow12\";\n    case OFP13_VERSION:\n        return \"OpenFlow13\";\n    case OFP14_VERSION:\n        return \"OpenFlow14\";\n    case OFP15_VERSION:\n        return \"OpenFlow15\";\n    case OFP16_VERSION:\n        return \"OpenFlow16\";\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nbool\nofputil_packet_in_format_is_valid(enum nx_packet_in_format packet_in_format)\n{\n    switch (packet_in_format) {\n    case NXPIF_STANDARD:\n    case NXPIF_NXT_PACKET_IN:\n    case NXPIF_NXT_PACKET_IN2:\n        return true;\n    }\n\n    return false;\n}\n\nconst char *\nofputil_packet_in_format_to_string(enum nx_packet_in_format packet_in_format)\n{\n    switch (packet_in_format) {\n    case NXPIF_STANDARD:\n        return \"standard\";\n    case NXPIF_NXT_PACKET_IN:\n        return \"nxt_packet_in\";\n    case NXPIF_NXT_PACKET_IN2:\n        return \"nxt_packet_in2\";\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nint\nofputil_packet_in_format_from_string(const char *s)\n{\n    return (!strcmp(s, \"standard\") || !strcmp(s, \"openflow10\")\n            ? NXPIF_STANDARD\n            : !strcmp(s, \"nxt_packet_in\") || !strcmp(s, \"nxm\")\n            ? NXPIF_NXT_PACKET_IN\n            : !strcmp(s, \"nxt_packet_in2\")\n            ? NXPIF_NXT_PACKET_IN2\n            : -1);\n}\n\nvoid\nofputil_format_version(struct ds *msg, enum ofp_version version)\n{\n    ds_put_format(msg, \"0x%02x\", version);\n}\n\nvoid\nofputil_format_version_name(struct ds *msg, enum ofp_version version)\n{\n    ds_put_cstr(msg, ofputil_version_to_string(version));\n}\n\nstatic void\nofputil_format_version_bitmap__(struct ds *msg, uint32_t bitmap,\n                                void (*format_version)(struct ds *msg,\n                                                       enum ofp_version))\n{\n    while (bitmap) {\n        format_version(msg, raw_ctz(bitmap));\n        bitmap = zero_rightmost_1bit(bitmap);\n        if (bitmap) {\n            ds_put_cstr(msg, \", \");\n        }\n    }\n}\n\nvoid\nofputil_format_version_bitmap(struct ds *msg, uint32_t bitmap)\n{\n    ofputil_format_version_bitmap__(msg, bitmap, ofputil_format_version);\n}\n\nvoid\nofputil_format_version_bitmap_names(struct ds *msg, uint32_t bitmap)\n{\n    ofputil_format_version_bitmap__(msg, bitmap, ofputil_format_version_name);\n}\n\nstatic bool\nofputil_decode_hello_bitmap(const struct ofp_hello_elem_header *oheh,\n                            uint32_t *allowed_versionsp)\n{\n    uint16_t bitmap_len = ntohs(oheh->length) - sizeof *oheh;\n    const ovs_be32 *bitmap = ALIGNED_CAST(const ovs_be32 *, oheh + 1);\n    uint32_t allowed_versions;\n\n    if (!bitmap_len || bitmap_len % sizeof *bitmap) {\n        return false;\n    }\n\n    /* Only use the first 32-bit element of the bitmap as that is all the\n     * current implementation supports.  Subsequent elements are ignored which\n     * should have no effect on session negotiation until Open vSwitch supports\n     * wire-protocol versions greater than 31.\n     */\n    allowed_versions = ntohl(bitmap[0]);\n\n    if (allowed_versions & 1) {\n        /* There's no OpenFlow version 0. */\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"peer claims to support invalid OpenFlow \"\n                     \"version 0x00\");\n        allowed_versions &= ~1u;\n    }\n\n    if (!allowed_versions) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"peer does not support any OpenFlow \"\n                     \"version (between 0x01 and 0x1f)\");\n        return false;\n    }\n\n    *allowed_versionsp = allowed_versions;\n    return true;\n}\n\nstatic uint32_t\nversion_bitmap_from_version(uint8_t ofp_version)\n{\n    return ((ofp_version < 32 ? 1u << ofp_version : 0) - 1) << 1;\n}\n\n/* Decodes OpenFlow OFPT_HELLO message 'oh', storing into '*allowed_versions'\n * the set of OpenFlow versions for which 'oh' announces support.\n *\n * Because of how OpenFlow defines OFPT_HELLO messages, this function is always\n * successful, and thus '*allowed_versions' is always initialized.  However, it\n * returns false if 'oh' contains some data that could not be fully understood,\n * true if 'oh' was completely parsed. */\nbool\nofputil_decode_hello(const struct ofp_header *oh, uint32_t *allowed_versions)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpbuf_pull(&msg, sizeof *oh);\n\n    *allowed_versions = version_bitmap_from_version(oh->version);\n\n    bool ok = true;\n    while (msg.size) {\n        const struct ofp_hello_elem_header *oheh;\n        unsigned int len;\n\n        if (msg.size < sizeof *oheh) {\n            return false;\n        }\n\n        oheh = msg.data;\n        len = ntohs(oheh->length);\n        if (len < sizeof *oheh || !ofpbuf_try_pull(&msg, ROUND_UP(len, 8))) {\n            return false;\n        }\n\n        if (oheh->type != htons(OFPHET_VERSIONBITMAP)\n            || !ofputil_decode_hello_bitmap(oheh, allowed_versions)) {\n            ok = false;\n        }\n    }\n\n    return ok;\n}\n\n/* Returns true if 'allowed_versions' needs to be accompanied by a version\n * bitmap to be correctly expressed in an OFPT_HELLO message. */\nstatic bool\nshould_send_version_bitmap(uint32_t allowed_versions)\n{\n    return !is_pow2((allowed_versions >> 1) + 1);\n}\n\n/* Create an OFPT_HELLO message that expresses support for the OpenFlow\n * versions in the 'allowed_versions' bitmaps and returns the message. */\nstruct ofpbuf *\nofputil_encode_hello(uint32_t allowed_versions)\n{\n    enum ofp_version ofp_version;\n    struct ofpbuf *msg;\n\n    ofp_version = leftmost_1bit_idx(allowed_versions);\n    msg = ofpraw_alloc(OFPRAW_OFPT_HELLO, ofp_version, 0);\n\n    if (should_send_version_bitmap(allowed_versions)) {\n        struct ofp_hello_elem_header *oheh;\n        uint16_t map_len;\n\n        map_len = sizeof allowed_versions;\n        oheh = ofpbuf_put_zeros(msg, ROUND_UP(map_len + sizeof *oheh, 8));\n        oheh->type = htons(OFPHET_VERSIONBITMAP);\n        oheh->length = htons(map_len + sizeof *oheh);\n        *ALIGNED_CAST(ovs_be32 *, oheh + 1) = htonl(allowed_versions);\n\n        ofpmsg_update_length(msg);\n    }\n\n    return msg;\n}\n\n/* Returns an OpenFlow message that, sent on an OpenFlow connection whose\n * protocol is 'current', at least partly transitions the protocol to 'want'.\n * Stores in '*next' the protocol that will be in effect on the OpenFlow\n * connection if the switch processes the returned message correctly.  (If\n * '*next != want' then the caller will have to iterate.)\n *\n * If 'current == want', or if it is not possible to transition from 'current'\n * to 'want' (because, for example, 'current' and 'want' use different OpenFlow\n * protocol versions), returns NULL and stores 'current' in '*next'. */\nstruct ofpbuf *\nofputil_encode_set_protocol(enum ofputil_protocol current,\n                            enum ofputil_protocol want,\n                            enum ofputil_protocol *next)\n{\n    enum ofp_version cur_version, want_version;\n    enum ofputil_protocol cur_base, want_base;\n    bool cur_tid, want_tid;\n\n    cur_version = ofputil_protocol_to_ofp_version(current);\n    want_version = ofputil_protocol_to_ofp_version(want);\n    if (cur_version != want_version) {\n        *next = current;\n        return NULL;\n    }\n\n    cur_base = ofputil_protocol_to_base(current);\n    want_base = ofputil_protocol_to_base(want);\n    if (cur_base != want_base) {\n        *next = ofputil_protocol_set_base(current, want_base);\n\n        switch (want_base) {\n        case OFPUTIL_P_OF10_NXM:\n            return ofputil_encode_nx_set_flow_format(NXFF_NXM);\n\n        case OFPUTIL_P_OF10_STD:\n            return ofputil_encode_nx_set_flow_format(NXFF_OPENFLOW10);\n\n        case OFPUTIL_P_OF11_STD:\n        case OFPUTIL_P_OF12_OXM:\n        case OFPUTIL_P_OF13_OXM:\n        case OFPUTIL_P_OF14_OXM:\n        case OFPUTIL_P_OF15_OXM:\n        case OFPUTIL_P_OF16_OXM:\n            /* There is only one variant of each OpenFlow 1.1+ protocol, and we\n             * verified above that we're not trying to change versions. */\n            OVS_NOT_REACHED();\n\n        case OFPUTIL_P_OF10_STD_TID:\n        case OFPUTIL_P_OF10_NXM_TID:\n            OVS_NOT_REACHED();\n        }\n    }\n\n    cur_tid = (current & OFPUTIL_P_TID) != 0;\n    want_tid = (want & OFPUTIL_P_TID) != 0;\n    if (cur_tid != want_tid) {\n        *next = ofputil_protocol_set_tid(current, want_tid);\n        return ofputil_make_flow_mod_table_id(want_tid);\n    }\n\n    ovs_assert(current == want);\n\n    *next = current;\n    return NULL;\n}\n\n/* Returns an NXT_SET_FLOW_FORMAT message that can be used to set the flow\n * format to 'nxff'.  */\nstruct ofpbuf *\nofputil_encode_nx_set_flow_format(enum nx_flow_format nxff)\n{\n    struct nx_set_flow_format *sff;\n    struct ofpbuf *msg;\n\n    ovs_assert(ofputil_nx_flow_format_is_valid(nxff));\n\n    msg = ofpraw_alloc(OFPRAW_NXT_SET_FLOW_FORMAT, OFP10_VERSION, 0);\n    sff = ofpbuf_put_zeros(msg, sizeof *sff);\n    sff->format = htonl(nxff);\n\n    return msg;\n}\n\n/* Returns the base protocol if 'flow_format' is a valid NXFF_* value, false\n * otherwise. */\nenum ofputil_protocol\nofputil_nx_flow_format_to_protocol(enum nx_flow_format flow_format)\n{\n    switch (flow_format) {\n    case NXFF_OPENFLOW10:\n        return OFPUTIL_P_OF10_STD;\n\n    case NXFF_NXM:\n        return OFPUTIL_P_OF10_NXM;\n\n    default:\n        return 0;\n    }\n}\n\n/* Returns true if 'flow_format' is a valid NXFF_* value, false otherwise. */\nbool\nofputil_nx_flow_format_is_valid(enum nx_flow_format flow_format)\n{\n    return ofputil_nx_flow_format_to_protocol(flow_format) != 0;\n}\n\n/* Returns a string version of 'flow_format', which must be a valid NXFF_*\n * value. */\nconst char *\nofputil_nx_flow_format_to_string(enum nx_flow_format flow_format)\n{\n    switch (flow_format) {\n    case NXFF_OPENFLOW10:\n        return \"openflow10\";\n    case NXFF_NXM:\n        return \"nxm\";\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstruct ofpbuf *\nofputil_make_set_packet_in_format(enum ofp_version ofp_version,\n                                  enum nx_packet_in_format packet_in_format)\n{\n    struct nx_set_packet_in_format *spif;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc(OFPRAW_NXT_SET_PACKET_IN_FORMAT, ofp_version, 0);\n    spif = ofpbuf_put_zeros(msg, sizeof *spif);\n    spif->format = htonl(packet_in_format);\n\n    return msg;\n}\n\n/* Returns an OpenFlow message that can be used to turn the flow_mod_table_id\n * extension on or off (according to 'flow_mod_table_id'). */\nstruct ofpbuf *\nofputil_make_flow_mod_table_id(bool flow_mod_table_id)\n{\n    struct nx_flow_mod_table_id *nfmti;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc(OFPRAW_NXT_FLOW_MOD_TABLE_ID, OFP10_VERSION, 0);\n    nfmti = ofpbuf_put_zeros(msg, sizeof *nfmti);\n    nfmti->set = flow_mod_table_id;\n    return msg;\n}\n\nstruct ofputil_flow_mod_flag {\n    uint16_t raw_flag;\n    enum ofp_version min_version, max_version;\n    enum ofputil_flow_mod_flags flag;\n};\n\nstatic const struct ofputil_flow_mod_flag ofputil_flow_mod_flags[] = {\n    { OFPFF_SEND_FLOW_REM,   OFP10_VERSION, 0, OFPUTIL_FF_SEND_FLOW_REM },\n    { OFPFF_CHECK_OVERLAP,   OFP10_VERSION, 0, OFPUTIL_FF_CHECK_OVERLAP },\n    { OFPFF10_EMERG,         OFP10_VERSION, OFP10_VERSION,\n      OFPUTIL_FF_EMERG },\n    { OFPFF12_RESET_COUNTS,  OFP12_VERSION, 0, OFPUTIL_FF_RESET_COUNTS },\n    { OFPFF13_NO_PKT_COUNTS, OFP13_VERSION, 0, OFPUTIL_FF_NO_PKT_COUNTS },\n    { OFPFF13_NO_BYT_COUNTS, OFP13_VERSION, 0, OFPUTIL_FF_NO_BYT_COUNTS },\n    { 0, 0, 0, 0 },\n};\n\nstatic enum ofperr\nofputil_decode_flow_mod_flags(ovs_be16 raw_flags_,\n                              enum ofp_flow_mod_command command,\n                              enum ofp_version version,\n                              enum ofputil_flow_mod_flags *flagsp)\n{\n    uint16_t raw_flags = ntohs(raw_flags_);\n    const struct ofputil_flow_mod_flag *f;\n\n    *flagsp = 0;\n    for (f = ofputil_flow_mod_flags; f->raw_flag; f++) {\n        if (raw_flags & f->raw_flag\n            && version >= f->min_version\n            && (!f->max_version || version <= f->max_version)) {\n            raw_flags &= ~f->raw_flag;\n            *flagsp |= f->flag;\n        }\n    }\n\n    /* In OF1.0 and OF1.1, \"add\" always resets counters, and other commands\n     * never do.\n     *\n     * In OF1.2 and later, OFPFF12_RESET_COUNTS controls whether each command\n     * resets counters. */\n    if ((version == OFP10_VERSION || version == OFP11_VERSION)\n        && command == OFPFC_ADD) {\n        *flagsp |= OFPUTIL_FF_RESET_COUNTS;\n    }\n\n    return raw_flags ? OFPERR_OFPFMFC_BAD_FLAGS : 0;\n}\n\nstatic ovs_be16\nofputil_encode_flow_mod_flags(enum ofputil_flow_mod_flags flags,\n                              enum ofp_version version)\n{\n    const struct ofputil_flow_mod_flag *f;\n    uint16_t raw_flags;\n\n    raw_flags = 0;\n    for (f = ofputil_flow_mod_flags; f->raw_flag; f++) {\n        if (f->flag & flags\n            && version >= f->min_version\n            && (!f->max_version || version <= f->max_version)) {\n            raw_flags |= f->raw_flag;\n        }\n    }\n\n    return htons(raw_flags);\n}\n\n/* Converts an OFPT_FLOW_MOD or NXT_FLOW_MOD message 'oh' into an abstract\n * flow_mod in 'fm'.  Returns 0 if successful, otherwise an OpenFlow error\n * code.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of 'oh''s actions.\n * The caller must initialize 'ofpacts' and retains ownership of it.\n * 'fm->ofpacts' will point into the 'ofpacts' buffer.\n *\n * Does not validate the flow_mod actions.  The caller should do that, with\n * ofpacts_check(). */\nenum ofperr\nofputil_decode_flow_mod(struct ofputil_flow_mod *fm,\n                        const struct ofp_header *oh,\n                        enum ofputil_protocol protocol,\n                        const struct tun_table *tun_table,\n                        const struct vl_mff_map *vl_mff_map,\n                        struct ofpbuf *ofpacts,\n                        ofp_port_t max_port, uint8_t max_table)\n{\n    ovs_be16 raw_flags;\n    enum ofperr error;\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT11_FLOW_MOD) {\n        /* Standard OpenFlow 1.1+ flow_mod. */\n        const struct ofp11_flow_mod *ofm;\n\n        ofm = ofpbuf_pull(&b, sizeof *ofm);\n\n        error = ofputil_pull_ofp11_match(&b, tun_table, vl_mff_map, &fm->match,\n                                         NULL);\n        if (error) {\n            return error;\n        }\n\n        /* Translate the message. */\n        fm->priority = ntohs(ofm->priority);\n        if (ofm->command == OFPFC_ADD\n            || (oh->version == OFP11_VERSION\n                && (ofm->command == OFPFC_MODIFY ||\n                    ofm->command == OFPFC_MODIFY_STRICT)\n                && ofm->cookie_mask == htonll(0))) {\n            /* In OpenFlow 1.1 only, a \"modify\" or \"modify-strict\" that does\n             * not match on the cookie is treated as an \"add\" if there is no\n             * match. */\n            fm->cookie = htonll(0);\n            fm->cookie_mask = htonll(0);\n            fm->new_cookie = ofm->cookie;\n        } else {\n            fm->cookie = ofm->cookie;\n            fm->cookie_mask = ofm->cookie_mask;\n            fm->new_cookie = OVS_BE64_MAX;\n        }\n        fm->modify_cookie = false;\n        fm->command = ofm->command;\n\n        /* Get table ID.\n         *\n         * OF1.1 entirely forbids table_id == OFPTT_ALL.\n         * OF1.2+ allows table_id == OFPTT_ALL only for deletes. */\n        fm->table_id = ofm->table_id;\n        if (fm->table_id == OFPTT_ALL\n            && (oh->version == OFP11_VERSION\n                || (ofm->command != OFPFC_DELETE &&\n                    ofm->command != OFPFC_DELETE_STRICT))) {\n            return OFPERR_OFPFMFC_BAD_TABLE_ID;\n        }\n\n        fm->idle_timeout = ntohs(ofm->idle_timeout);\n        fm->hard_timeout = ntohs(ofm->hard_timeout);\n        if (oh->version >= OFP14_VERSION && ofm->command == OFPFC_ADD) {\n            fm->importance = ntohs(ofm->importance);\n        } else {\n            fm->importance = 0;\n        }\n        fm->buffer_id = ntohl(ofm->buffer_id);\n        error = ofputil_port_from_ofp11(ofm->out_port, &fm->out_port);\n        if (error) {\n            return error;\n        }\n\n        fm->out_group = (ofm->command == OFPFC_DELETE ||\n                         ofm->command == OFPFC_DELETE_STRICT\n                         ? ntohl(ofm->out_group)\n                         : OFPG_ANY);\n        raw_flags = ofm->flags;\n    } else {\n        uint16_t command;\n\n        if (raw == OFPRAW_OFPT10_FLOW_MOD) {\n            /* Standard OpenFlow 1.0 flow_mod. */\n            const struct ofp10_flow_mod *ofm;\n\n            /* Get the ofp10_flow_mod. */\n            ofm = ofpbuf_pull(&b, sizeof *ofm);\n\n            /* Translate the rule. */\n            ofputil_match_from_ofp10_match(&ofm->match, &fm->match);\n            ofputil_normalize_match(&fm->match);\n\n            /* OpenFlow 1.0 says that exact-match rules have to have the\n             * highest possible priority. */\n            fm->priority = (ofm->match.wildcards & htonl(OFPFW10_ALL)\n                            ? ntohs(ofm->priority)\n                            : UINT16_MAX);\n\n            /* Translate the message. */\n            command = ntohs(ofm->command);\n            fm->cookie = htonll(0);\n            fm->cookie_mask = htonll(0);\n            fm->new_cookie = ofm->cookie;\n            fm->idle_timeout = ntohs(ofm->idle_timeout);\n            fm->hard_timeout = ntohs(ofm->hard_timeout);\n            fm->importance = 0;\n            fm->buffer_id = ntohl(ofm->buffer_id);\n            fm->out_port = u16_to_ofp(ntohs(ofm->out_port));\n            fm->out_group = OFPG_ANY;\n            raw_flags = ofm->flags;\n        } else if (raw == OFPRAW_NXT_FLOW_MOD) {\n            /* Nicira extended flow_mod. */\n            const struct nx_flow_mod *nfm;\n\n            /* Dissect the message. */\n            nfm = ofpbuf_pull(&b, sizeof *nfm);\n            error = nx_pull_match(&b, ntohs(nfm->match_len),\n                                  &fm->match, &fm->cookie, &fm->cookie_mask,\n                                  tun_table, vl_mff_map);\n            if (error) {\n                return error;\n            }\n\n            /* Translate the message. */\n            command = ntohs(nfm->command);\n            if ((command & 0xff) == OFPFC_ADD && fm->cookie_mask) {\n                /* Flow additions may only set a new cookie, not match an\n                 * existing cookie. */\n                return OFPERR_NXBRC_NXM_INVALID;\n            }\n            fm->priority = ntohs(nfm->priority);\n            fm->new_cookie = nfm->cookie;\n            fm->idle_timeout = ntohs(nfm->idle_timeout);\n            fm->hard_timeout = ntohs(nfm->hard_timeout);\n            fm->importance = 0;\n            fm->buffer_id = ntohl(nfm->buffer_id);\n            fm->out_port = u16_to_ofp(ntohs(nfm->out_port));\n            fm->out_group = OFPG_ANY;\n            raw_flags = nfm->flags;\n        } else {\n            OVS_NOT_REACHED();\n        }\n\n        fm->modify_cookie = fm->new_cookie != OVS_BE64_MAX;\n        if (protocol & OFPUTIL_P_TID) {\n            fm->command = command & 0xff;\n            fm->table_id = command >> 8;\n        } else {\n            if (command > 0xff) {\n                VLOG_WARN_RL(&bad_ofmsg_rl, \"flow_mod has explicit table_id \"\n                             \"but flow_mod_table_id extension is not enabled\");\n            }\n            fm->command = command;\n            fm->table_id = 0xff;\n        }\n    }\n\n    if (fm->command > OFPFC_DELETE_STRICT) {\n        return OFPERR_OFPFMFC_BAD_COMMAND;\n    }\n\n    fm->ofpacts_tlv_bitmap = 0;\n    error = ofpacts_pull_openflow_instructions(&b, b.size, oh->version,\n                                               vl_mff_map,\n                                               &fm->ofpacts_tlv_bitmap,\n                                               ofpacts);\n    if (error) {\n        return error;\n    }\n    fm->ofpacts = ofpacts->data;\n    fm->ofpacts_len = ofpacts->size;\n\n    error = ofputil_decode_flow_mod_flags(raw_flags, fm->command,\n                                          oh->version, &fm->flags);\n    if (error) {\n        return error;\n    }\n\n    if (fm->flags & OFPUTIL_FF_EMERG) {\n        /* We do not support the OpenFlow 1.0 emergency flow cache, which\n         * is not required in OpenFlow 1.0.1 and removed from OpenFlow 1.1.\n         *\n         * OpenFlow 1.0 specifies the error code to use when idle_timeout\n         * or hard_timeout is nonzero.  Otherwise, there is no good error\n         * code, so just state that the flow table is full. */\n        return (fm->hard_timeout || fm->idle_timeout\n                ? OFPERR_OFPFMFC_BAD_EMERG_TIMEOUT\n                : OFPERR_OFPFMFC_TABLE_FULL);\n    }\n\n    return ofpacts_check_consistency(fm->ofpacts, fm->ofpacts_len,\n                                     &fm->match.flow, max_port,\n                                     fm->table_id, max_table, protocol);\n}\n\nstatic enum ofperr\nofputil_pull_bands(struct ofpbuf *msg, size_t len, uint16_t *n_bands,\n                   struct ofpbuf *bands)\n{\n    const struct ofp13_meter_band_header *ombh;\n    struct ofputil_meter_band *mb;\n    uint16_t n = 0;\n\n    ombh = ofpbuf_try_pull(msg, len);\n    if (!ombh) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    while (len >= sizeof (struct ofp13_meter_band_drop)) {\n        size_t ombh_len = ntohs(ombh->len);\n        /* All supported band types have the same length. */\n        if (ombh_len != sizeof (struct ofp13_meter_band_drop)) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        mb = ofpbuf_put_uninit(bands, sizeof *mb);\n        mb->type = ntohs(ombh->type);\n        if (mb->type != OFPMBT13_DROP && mb->type != OFPMBT13_DSCP_REMARK) {\n            return OFPERR_OFPMMFC_BAD_BAND;\n        }\n        mb->rate = ntohl(ombh->rate);\n        mb->burst_size = ntohl(ombh->burst_size);\n        mb->prec_level = (mb->type == OFPMBT13_DSCP_REMARK) ?\n            ((struct ofp13_meter_band_dscp_remark *)ombh)->prec_level : 0;\n        n++;\n        len -= ombh_len;\n        ombh = ALIGNED_CAST(struct ofp13_meter_band_header *,\n                            (char *) ombh + ombh_len);\n    }\n    if (len) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    *n_bands = n;\n    return 0;\n}\n\nenum ofperr\nofputil_decode_meter_mod(const struct ofp_header *oh,\n                         struct ofputil_meter_mod *mm,\n                         struct ofpbuf *bands)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n    const struct ofp13_meter_mod *omm = ofpbuf_pull(&b, sizeof *omm);\n\n    /* Translate the message. */\n    mm->command = ntohs(omm->command);\n    if (mm->command != OFPMC13_ADD &&\n        mm->command != OFPMC13_MODIFY &&\n        mm->command != OFPMC13_DELETE) {\n        return OFPERR_OFPMMFC_BAD_COMMAND;\n    }\n    mm->meter.meter_id = ntohl(omm->meter_id);\n\n    if (mm->command == OFPMC13_DELETE) {\n        mm->meter.flags = 0;\n        mm->meter.n_bands = 0;\n        mm->meter.bands = NULL;\n    } else {\n        enum ofperr error;\n\n        mm->meter.flags = ntohs(omm->flags);\n        if (mm->meter.flags & OFPMF13_KBPS &&\n            mm->meter.flags & OFPMF13_PKTPS) {\n            return OFPERR_OFPMMFC_BAD_FLAGS;\n        }\n\n        error = ofputil_pull_bands(&b, b.size, &mm->meter.n_bands, bands);\n        if (error) {\n            return error;\n        }\n        mm->meter.bands = bands->data;\n    }\n    return 0;\n}\n\nvoid\nofputil_decode_meter_request(const struct ofp_header *oh, uint32_t *meter_id)\n{\n    const struct ofp13_meter_multipart_request *omr = ofpmsg_body(oh);\n    *meter_id = ntohl(omr->meter_id);\n}\n\nstruct ofpbuf *\nofputil_encode_meter_request(enum ofp_version ofp_version,\n                             enum ofputil_meter_request_type type,\n                             uint32_t meter_id)\n{\n    struct ofpbuf *msg;\n\n    enum ofpraw raw;\n\n    switch (type) {\n    case OFPUTIL_METER_CONFIG:\n        raw = OFPRAW_OFPST13_METER_CONFIG_REQUEST;\n        break;\n    case OFPUTIL_METER_STATS:\n        raw = OFPRAW_OFPST13_METER_REQUEST;\n        break;\n    default:\n    case OFPUTIL_METER_FEATURES:\n        raw = OFPRAW_OFPST13_METER_FEATURES_REQUEST;\n        break;\n    }\n\n    msg = ofpraw_alloc(raw, ofp_version, 0);\n\n    if (type != OFPUTIL_METER_FEATURES) {\n        struct ofp13_meter_multipart_request *omr;\n        omr = ofpbuf_put_zeros(msg, sizeof *omr);\n        omr->meter_id = htonl(meter_id);\n    }\n    return msg;\n}\n\nstatic void\nofputil_put_bands(uint16_t n_bands, const struct ofputil_meter_band *mb,\n                  struct ofpbuf *msg)\n{\n    uint16_t n = 0;\n\n    for (n = 0; n < n_bands; ++n) {\n        /* Currently all band types have same size. */\n        struct ofp13_meter_band_dscp_remark *ombh;\n        size_t ombh_len = sizeof *ombh;\n\n        ombh = ofpbuf_put_zeros(msg, ombh_len);\n\n        ombh->type = htons(mb->type);\n        ombh->len = htons(ombh_len);\n        ombh->rate = htonl(mb->rate);\n        ombh->burst_size = htonl(mb->burst_size);\n        ombh->prec_level = mb->prec_level;\n\n        mb++;\n    }\n}\n\n/* Encode a meter stat for 'mc' and append it to 'replies'. */\nvoid\nofputil_append_meter_config(struct ovs_list *replies,\n                            const struct ofputil_meter_config *mc)\n{\n    struct ofpbuf *msg = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = msg->size;\n    struct ofp13_meter_config *reply;\n\n    ofpbuf_put_uninit(msg, sizeof *reply);\n    ofputil_put_bands(mc->n_bands, mc->bands, msg);\n\n    reply = ofpbuf_at_assert(msg, start_ofs, sizeof *reply);\n    reply->flags = htons(mc->flags);\n    reply->meter_id = htonl(mc->meter_id);\n    reply->length = htons(msg->size - start_ofs);\n\n    ofpmp_postappend(replies, start_ofs);\n}\n\n/* Encode a meter stat for 'ms' and append it to 'replies'. */\nvoid\nofputil_append_meter_stats(struct ovs_list *replies,\n                           const struct ofputil_meter_stats *ms)\n{\n    struct ofp13_meter_stats *reply;\n    uint16_t n = 0;\n    uint16_t len;\n\n    len = sizeof *reply + ms->n_bands * sizeof(struct ofp13_meter_band_stats);\n    reply = ofpmp_append(replies, len);\n\n    reply->meter_id = htonl(ms->meter_id);\n    reply->len = htons(len);\n    memset(reply->pad, 0, sizeof reply->pad);\n    reply->flow_count = htonl(ms->flow_count);\n    reply->packet_in_count = htonll(ms->packet_in_count);\n    reply->byte_in_count = htonll(ms->byte_in_count);\n    reply->duration_sec = htonl(ms->duration_sec);\n    reply->duration_nsec = htonl(ms->duration_nsec);\n\n    for (n = 0; n < ms->n_bands; ++n) {\n        const struct ofputil_meter_band_stats *src = &ms->bands[n];\n        struct ofp13_meter_band_stats *dst = &reply->band_stats[n];\n\n        dst->packet_band_count = htonll(src->packet_count);\n        dst->byte_band_count = htonll(src->byte_count);\n    }\n}\n\n/* Converts an OFPMP_METER_CONFIG reply in 'msg' into an abstract\n * ofputil_meter_config in 'mc', with mc->bands pointing to bands decoded into\n * 'bands'.  The caller must have initialized 'bands' and retains ownership of\n * it across the call.\n *\n * Multiple OFPST13_METER_CONFIG replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  'bands' is cleared for each reply.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_meter_config(struct ofpbuf *msg,\n                            struct ofputil_meter_config *mc,\n                            struct ofpbuf *bands)\n{\n    const struct ofp13_meter_config *omc;\n    enum ofperr err;\n\n    /* Pull OpenFlow headers for the first call. */\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    omc = ofpbuf_try_pull(msg, sizeof *omc);\n    if (!omc) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"OFPMP_METER_CONFIG reply has %\"PRIu32\" leftover bytes at end\",\n                     msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    ofpbuf_clear(bands);\n    err = ofputil_pull_bands(msg, ntohs(omc->length) - sizeof *omc,\n                             &mc->n_bands, bands);\n    if (err) {\n        return err;\n    }\n    mc->meter_id = ntohl(omc->meter_id);\n    mc->flags = ntohs(omc->flags);\n    mc->bands = bands->data;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_pull_band_stats(struct ofpbuf *msg, size_t len, uint16_t *n_bands,\n                        struct ofpbuf *bands)\n{\n    const struct ofp13_meter_band_stats *ombs;\n    struct ofputil_meter_band_stats *mbs;\n    uint16_t n, i;\n\n    ombs = ofpbuf_try_pull(msg, len);\n    if (!ombs) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    n = len / sizeof *ombs;\n    if (len != n * sizeof *ombs) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    mbs = ofpbuf_put_uninit(bands, len);\n\n    for (i = 0; i < n; ++i) {\n        mbs[i].packet_count = ntohll(ombs[i].packet_band_count);\n        mbs[i].byte_count = ntohll(ombs[i].byte_band_count);\n    }\n    *n_bands = n;\n    return 0;\n}\n\n/* Converts an OFPMP_METER reply in 'msg' into an abstract\n * ofputil_meter_stats in 'ms', with ms->bands pointing to band stats\n * decoded into 'bands'.\n *\n * Multiple OFPMP_METER replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  'bands' is cleared for each reply.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_meter_stats(struct ofpbuf *msg,\n                           struct ofputil_meter_stats *ms,\n                           struct ofpbuf *bands)\n{\n    const struct ofp13_meter_stats *oms;\n    enum ofperr err;\n\n    /* Pull OpenFlow headers for the first call. */\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    oms = ofpbuf_try_pull(msg, sizeof *oms);\n    if (!oms) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"OFPMP_METER reply has %\"PRIu32\" leftover bytes at end\",\n                     msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    ofpbuf_clear(bands);\n    err = ofputil_pull_band_stats(msg, ntohs(oms->len) - sizeof *oms,\n                                  &ms->n_bands, bands);\n    if (err) {\n        return err;\n    }\n    ms->meter_id = ntohl(oms->meter_id);\n    ms->flow_count = ntohl(oms->flow_count);\n    ms->packet_in_count = ntohll(oms->packet_in_count);\n    ms->byte_in_count = ntohll(oms->byte_in_count);\n    ms->duration_sec = ntohl(oms->duration_sec);\n    ms->duration_nsec = ntohl(oms->duration_nsec);\n    ms->bands = bands->data;\n\n    return 0;\n}\n\nvoid\nofputil_decode_meter_features(const struct ofp_header *oh,\n                              struct ofputil_meter_features *mf)\n{\n    const struct ofp13_meter_features *omf = ofpmsg_body(oh);\n\n    mf->max_meters = ntohl(omf->max_meter);\n    mf->band_types = ntohl(omf->band_types);\n    mf->capabilities = ntohl(omf->capabilities);\n    mf->max_bands = omf->max_bands;\n    mf->max_color = omf->max_color;\n}\n\nstruct ofpbuf *\nofputil_encode_meter_features_reply(const struct ofputil_meter_features *mf,\n                                    const struct ofp_header *request)\n{\n    struct ofpbuf *reply;\n    struct ofp13_meter_features *omf;\n\n    reply = ofpraw_alloc_stats_reply(request, 0);\n    omf = ofpbuf_put_zeros(reply, sizeof *omf);\n\n    omf->max_meter = htonl(mf->max_meters);\n    omf->band_types = htonl(mf->band_types);\n    omf->capabilities = htonl(mf->capabilities);\n    omf->max_bands = mf->max_bands;\n    omf->max_color = mf->max_color;\n\n    return reply;\n}\n\nstruct ofpbuf *\nofputil_encode_meter_mod(enum ofp_version ofp_version,\n                         const struct ofputil_meter_mod *mm)\n{\n    struct ofpbuf *msg;\n\n    struct ofp13_meter_mod *omm;\n\n    msg = ofpraw_alloc(OFPRAW_OFPT13_METER_MOD, ofp_version,\n                       NXM_TYPICAL_LEN + mm->meter.n_bands * 16);\n    omm = ofpbuf_put_zeros(msg, sizeof *omm);\n    omm->command = htons(mm->command);\n    if (mm->command != OFPMC13_DELETE) {\n        omm->flags = htons(mm->meter.flags);\n    }\n    omm->meter_id = htonl(mm->meter.meter_id);\n\n    ofputil_put_bands(mm->meter.n_bands, mm->meter.bands, msg);\n\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic ovs_be16\nofputil_tid_command(const struct ofputil_flow_mod *fm,\n                    enum ofputil_protocol protocol)\n{\n    return htons(protocol & OFPUTIL_P_TID\n                 ? (fm->command & 0xff) | (fm->table_id << 8)\n                 : fm->command);\n}\n\n/* Converts 'fm' into an OFPT_FLOW_MOD or NXT_FLOW_MOD message according to\n * 'protocol' and returns the message. */\nstruct ofpbuf *\nofputil_encode_flow_mod(const struct ofputil_flow_mod *fm,\n                        enum ofputil_protocol protocol)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n    ovs_be16 raw_flags = ofputil_encode_flow_mod_flags(fm->flags, version);\n    struct ofpbuf *msg;\n\n    switch (protocol) {\n    case OFPUTIL_P_OF11_STD:\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM: {\n        struct ofp11_flow_mod *ofm;\n        int tailroom;\n\n        tailroom = ofputil_match_typical_len(protocol) + fm->ofpacts_len;\n        msg = ofpraw_alloc(OFPRAW_OFPT11_FLOW_MOD, version, tailroom);\n        ofm = ofpbuf_put_zeros(msg, sizeof *ofm);\n        if ((protocol == OFPUTIL_P_OF11_STD\n             && (fm->command == OFPFC_MODIFY ||\n                 fm->command == OFPFC_MODIFY_STRICT)\n             && fm->cookie_mask == htonll(0))\n            || fm->command == OFPFC_ADD) {\n            ofm->cookie = fm->new_cookie;\n        } else {\n            ofm->cookie = fm->cookie & fm->cookie_mask;\n        }\n        ofm->cookie_mask = fm->cookie_mask;\n        if (fm->table_id != OFPTT_ALL\n            || (protocol != OFPUTIL_P_OF11_STD\n                && (fm->command == OFPFC_DELETE ||\n                    fm->command == OFPFC_DELETE_STRICT))) {\n            ofm->table_id = fm->table_id;\n        } else {\n            ofm->table_id = 0;\n        }\n        ofm->command = fm->command;\n        ofm->idle_timeout = htons(fm->idle_timeout);\n        ofm->hard_timeout = htons(fm->hard_timeout);\n        ofm->priority = htons(fm->priority);\n        ofm->buffer_id = htonl(fm->buffer_id);\n        ofm->out_port = ofputil_port_to_ofp11(fm->out_port);\n        ofm->out_group = htonl(fm->out_group);\n        ofm->flags = raw_flags;\n        if (version >= OFP14_VERSION && fm->command == OFPFC_ADD) {\n            ofm->importance = htons(fm->importance);\n        } else {\n            ofm->importance = 0;\n        }\n        ofputil_put_ofp11_match(msg, &fm->match, protocol);\n        ofpacts_put_openflow_instructions(fm->ofpacts, fm->ofpacts_len, msg,\n                                          version);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID: {\n        struct ofp10_flow_mod *ofm;\n\n        msg = ofpraw_alloc(OFPRAW_OFPT10_FLOW_MOD, OFP10_VERSION,\n                           fm->ofpacts_len);\n        ofm = ofpbuf_put_zeros(msg, sizeof *ofm);\n        ofputil_match_to_ofp10_match(&fm->match, &ofm->match);\n        ofm->cookie = fm->new_cookie;\n        ofm->command = ofputil_tid_command(fm, protocol);\n        ofm->idle_timeout = htons(fm->idle_timeout);\n        ofm->hard_timeout = htons(fm->hard_timeout);\n        ofm->priority = htons(fm->priority);\n        ofm->buffer_id = htonl(fm->buffer_id);\n        ofm->out_port = htons(ofp_to_u16(fm->out_port));\n        ofm->flags = raw_flags;\n        ofpacts_put_openflow_actions(fm->ofpacts, fm->ofpacts_len, msg,\n                                     version);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID: {\n        struct nx_flow_mod *nfm;\n        int match_len;\n\n        msg = ofpraw_alloc(OFPRAW_NXT_FLOW_MOD, OFP10_VERSION,\n                           NXM_TYPICAL_LEN + fm->ofpacts_len);\n        nfm = ofpbuf_put_zeros(msg, sizeof *nfm);\n        nfm->command = ofputil_tid_command(fm, protocol);\n        nfm->cookie = fm->new_cookie;\n        match_len = nx_put_match(msg, &fm->match, fm->cookie, fm->cookie_mask);\n        nfm = msg->msg;\n        nfm->idle_timeout = htons(fm->idle_timeout);\n        nfm->hard_timeout = htons(fm->hard_timeout);\n        nfm->priority = htons(fm->priority);\n        nfm->buffer_id = htonl(fm->buffer_id);\n        nfm->out_port = htons(ofp_to_u16(fm->out_port));\n        nfm->flags = raw_flags;\n        nfm->match_len = htons(match_len);\n        ofpacts_put_openflow_actions(fm->ofpacts, fm->ofpacts_len, msg,\n                                     version);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic enum ofperr\nofputil_decode_ofpst10_flow_request(struct ofputil_flow_stats_request *fsr,\n                                    const struct ofp10_flow_stats_request *ofsr,\n                                    bool aggregate)\n{\n    fsr->aggregate = aggregate;\n    ofputil_match_from_ofp10_match(&ofsr->match, &fsr->match);\n    fsr->out_port = u16_to_ofp(ntohs(ofsr->out_port));\n    fsr->out_group = OFPG_ANY;\n    fsr->table_id = ofsr->table_id;\n    fsr->cookie = fsr->cookie_mask = htonll(0);\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_decode_ofpst11_flow_request(struct ofputil_flow_stats_request *fsr,\n                                    struct ofpbuf *b, bool aggregate,\n                                    const struct tun_table *tun_table,\n                                    const struct vl_mff_map *vl_mff_map)\n{\n    const struct ofp11_flow_stats_request *ofsr;\n    enum ofperr error;\n\n    ofsr = ofpbuf_pull(b, sizeof *ofsr);\n    fsr->aggregate = aggregate;\n    fsr->table_id = ofsr->table_id;\n    error = ofputil_port_from_ofp11(ofsr->out_port, &fsr->out_port);\n    if (error) {\n        return error;\n    }\n    fsr->out_group = ntohl(ofsr->out_group);\n    fsr->cookie = ofsr->cookie;\n    fsr->cookie_mask = ofsr->cookie_mask;\n    error = ofputil_pull_ofp11_match(b, tun_table, vl_mff_map, &fsr->match,\n                                     NULL);\n    if (error) {\n        return error;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,\n                                 struct ofpbuf *b, bool aggregate,\n                                 const struct tun_table *tun_table,\n                                 const struct vl_mff_map *vl_mff_map)\n{\n    const struct nx_flow_stats_request *nfsr;\n    enum ofperr error;\n\n    nfsr = ofpbuf_pull(b, sizeof *nfsr);\n    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,\n                          &fsr->cookie, &fsr->cookie_mask, tun_table,\n                          vl_mff_map);\n    if (error) {\n        return error;\n    }\n    if (b->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    fsr->aggregate = aggregate;\n    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));\n    fsr->out_group = OFPG_ANY;\n    fsr->table_id = nfsr->table_id;\n\n    return 0;\n}\n\n/* Constructs and returns an OFPT_QUEUE_GET_CONFIG request for the specified\n * 'port' and 'queue', suitable for OpenFlow version 'version'.\n *\n * 'queue' is honored only for OpenFlow 1.4 and later; older versions always\n * request all queues. */\nstruct ofpbuf *\nofputil_encode_queue_get_config_request(enum ofp_version version,\n                                        ofp_port_t port,\n                                        uint32_t queue)\n{\n    struct ofpbuf *request;\n\n    if (version == OFP10_VERSION) {\n        struct ofp10_queue_get_config_request *qgcr10;\n\n        request = ofpraw_alloc(OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST,\n                               version, 0);\n        qgcr10 = ofpbuf_put_zeros(request, sizeof *qgcr10);\n        qgcr10->port = htons(ofp_to_u16(port));\n    } else if (version < OFP14_VERSION) {\n        struct ofp11_queue_get_config_request *qgcr11;\n\n        request = ofpraw_alloc(OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST,\n                               version, 0);\n        qgcr11 = ofpbuf_put_zeros(request, sizeof *qgcr11);\n        qgcr11->port = ofputil_port_to_ofp11(port);\n    } else {\n        struct ofp14_queue_desc_request *qdr14;\n\n        request = ofpraw_alloc(OFPRAW_OFPST14_QUEUE_DESC_REQUEST,\n                               version, 0);\n        qdr14 = ofpbuf_put_zeros(request, sizeof *qdr14);\n        qdr14->port = ofputil_port_to_ofp11(port);\n        qdr14->queue = htonl(queue);\n    }\n\n    return request;\n}\n\n/* Parses OFPT_QUEUE_GET_CONFIG request 'oh', storing the port specified by the\n * request into '*port'.  Returns 0 if successful, otherwise an OpenFlow error\n * code. */\nenum ofperr\nofputil_decode_queue_get_config_request(const struct ofp_header *oh,\n                                        ofp_port_t *port, uint32_t *queue)\n{\n    const struct ofp10_queue_get_config_request *qgcr10;\n    const struct ofp11_queue_get_config_request *qgcr11;\n    const struct ofp14_queue_desc_request *qdr14;\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    switch ((int) raw) {\n    case OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST:\n        qgcr10 = b.data;\n        *port = u16_to_ofp(ntohs(qgcr10->port));\n        *queue = OFPQ_ALL;\n        break;\n\n    case OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST:\n        qgcr11 = b.data;\n        *queue = OFPQ_ALL;\n        enum ofperr error = ofputil_port_from_ofp11(qgcr11->port, port);\n        if (error || *port == OFPP_ANY) {\n            return error;\n        }\n        break;\n\n    case OFPRAW_OFPST14_QUEUE_DESC_REQUEST:\n        qdr14 = b.data;\n        *queue = ntohl(qdr14->queue);\n        return ofputil_port_from_ofp11(qdr14->port, port);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return (ofp_to_u16(*port) < ofp_to_u16(OFPP_MAX)\n            ? 0\n            : OFPERR_OFPQOFC_BAD_PORT);\n}\n\n/* Constructs and returns the beginning of a reply to\n * OFPT_QUEUE_GET_CONFIG_REQUEST or OFPMP_QUEUE_DESC request 'oh'.  The caller\n * may append information about individual queues with\n * ofputil_append_queue_get_config_reply(). */\nvoid\nofputil_start_queue_get_config_reply(const struct ofp_header *request,\n                                     struct ovs_list *replies)\n{\n    struct ofpbuf *reply;\n    enum ofperr error;\n    ofp_port_t port;\n    uint32_t queue;\n\n    error = ofputil_decode_queue_get_config_request(request, &port, &queue);\n    ovs_assert(!error);\n\n    enum ofpraw raw = ofpraw_decode_assert(request);\n    switch ((int) raw) {\n    case OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST:\n        reply = ofpraw_alloc_reply(OFPRAW_OFPT10_QUEUE_GET_CONFIG_REPLY,\n                                   request, 0);\n        struct ofp10_queue_get_config_reply *qgcr10\n            = ofpbuf_put_zeros(reply, sizeof *qgcr10);\n        qgcr10->port = htons(ofp_to_u16(port));\n        break;\n\n    case OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST:\n        reply = ofpraw_alloc_reply(OFPRAW_OFPT11_QUEUE_GET_CONFIG_REPLY,\n                                   request, 0);\n        struct ofp11_queue_get_config_reply *qgcr11\n            = ofpbuf_put_zeros(reply, sizeof *qgcr11);\n        qgcr11->port = ofputil_port_to_ofp11(port);\n        break;\n\n    case OFPRAW_OFPST14_QUEUE_DESC_REQUEST:\n        reply = ofpraw_alloc_stats_reply(request, 0);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ovs_list_init(replies);\n    ovs_list_push_back(replies, &reply->list_node);\n}\n\nstatic void\nput_ofp10_queue_rate(struct ofpbuf *reply,\n                     enum ofp10_queue_properties property, uint16_t rate)\n{\n    if (rate != UINT16_MAX) {\n        struct ofp10_queue_prop_rate *oqpr;\n\n        oqpr = ofpbuf_put_zeros(reply, sizeof *oqpr);\n        oqpr->prop_header.property = htons(property);\n        oqpr->prop_header.len = htons(sizeof *oqpr);\n        oqpr->rate = htons(rate);\n    }\n}\n\nstatic void\nput_ofp14_queue_rate(struct ofpbuf *reply,\n                     enum ofp14_queue_desc_prop_type type, uint16_t rate)\n{\n    if (rate != UINT16_MAX) {\n        ofpprop_put_u16(reply, type, rate);\n    }\n}\n\nvoid\nofputil_append_queue_get_config_reply(const struct ofputil_queue_config *qc,\n                                      struct ovs_list *replies)\n{\n    enum ofp_version ofp_version = ofpmp_version(replies);\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = reply->size;\n    size_t len_ofs;\n    ovs_be16 *len;\n\n    if (ofp_version < OFP14_VERSION) {\n        if (ofp_version < OFP12_VERSION) {\n            struct ofp10_packet_queue *opq10;\n\n            opq10 = ofpbuf_put_zeros(reply, sizeof *opq10);\n            opq10->queue_id = htonl(qc->queue);\n            len_ofs = (char *) &opq10->len - (char *) reply->data;\n        } else {\n            struct ofp12_packet_queue *opq12;\n\n            opq12 = ofpbuf_put_zeros(reply, sizeof *opq12);\n            opq12->port = ofputil_port_to_ofp11(qc->port);\n            opq12->queue_id = htonl(qc->queue);\n            len_ofs = (char *) &opq12->len - (char *) reply->data;\n        }\n\n        put_ofp10_queue_rate(reply, OFPQT10_MIN_RATE, qc->min_rate);\n        put_ofp10_queue_rate(reply, OFPQT11_MAX_RATE, qc->max_rate);\n    } else {\n        struct ofp14_queue_desc *oqd = ofpbuf_put_zeros(reply, sizeof *oqd);\n        oqd->port_no = ofputil_port_to_ofp11(qc->port);\n        oqd->queue_id = htonl(qc->queue);\n        len_ofs = (char *) &oqd->len - (char *) reply->data;\n        put_ofp14_queue_rate(reply, OFPQDPT14_MIN_RATE, qc->min_rate);\n        put_ofp14_queue_rate(reply, OFPQDPT14_MAX_RATE, qc->max_rate);\n    }\n\n    len = ofpbuf_at(reply, len_ofs, sizeof *len);\n    *len = htons(reply->size - start_ofs);\n\n    if (ofp_version >= OFP14_VERSION) {\n        ofpmp_postappend(replies, start_ofs);\n    }\n}\n\nstatic enum ofperr\nparse_ofp10_queue_rate(const struct ofp10_queue_prop_header *hdr,\n                       uint16_t *rate)\n{\n    const struct ofp10_queue_prop_rate *oqpr;\n\n    if (hdr->len == htons(sizeof *oqpr)) {\n        oqpr = (const struct ofp10_queue_prop_rate *) hdr;\n        *rate = ntohs(oqpr->rate);\n        return 0;\n    } else {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n}\n\nstatic int\nofputil_pull_queue_get_config_reply10(struct ofpbuf *msg,\n                                      struct ofputil_queue_config *queue)\n{\n    const struct ofp_header *oh = msg->header;\n    unsigned int opq_len;       /* Length of protocol-specific queue header. */\n    unsigned int len;           /* Total length of queue + properties. */\n\n    /* Obtain the port number from the message header. */\n    if (oh->version == OFP10_VERSION) {\n        const struct ofp10_queue_get_config_reply *oqgcr10 = msg->msg;\n        queue->port = u16_to_ofp(ntohs(oqgcr10->port));\n    } else {\n        const struct ofp11_queue_get_config_reply *oqgcr11 = msg->msg;\n        enum ofperr error = ofputil_port_from_ofp11(oqgcr11->port,\n                                                    &queue->port);\n        if (error) {\n            return error;\n        }\n    }\n\n    /* Pull off the queue header and get the queue number and length. */\n    if (oh->version < OFP12_VERSION) {\n        const struct ofp10_packet_queue *opq10;\n        opq10 = ofpbuf_try_pull(msg, sizeof *opq10);\n        if (!opq10) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        queue->queue = ntohl(opq10->queue_id);\n        len = ntohs(opq10->len);\n        opq_len = sizeof *opq10;\n    } else {\n        const struct ofp12_packet_queue *opq12;\n        opq12 = ofpbuf_try_pull(msg, sizeof *opq12);\n        if (!opq12) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        queue->queue = ntohl(opq12->queue_id);\n        len = ntohs(opq12->len);\n        opq_len = sizeof *opq12;\n    }\n\n    /* Length check. */\n    if (len < opq_len || len > msg->size + opq_len || len % 8) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= opq_len;\n\n    /* Pull properties.  The format of these properties differs from used in\n     * OF1.4+ so we can't use the common property functions. */\n    while (len > 0) {\n        const struct ofp10_queue_prop_header *hdr;\n        unsigned int property;\n        unsigned int prop_len;\n        enum ofperr error = 0;\n\n        hdr = ofpbuf_at_assert(msg, 0, sizeof *hdr);\n        prop_len = ntohs(hdr->len);\n        if (prop_len < sizeof *hdr || prop_len > len || prop_len % 8) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        property = ntohs(hdr->property);\n        switch (property) {\n        case OFPQT10_MIN_RATE:\n            error = parse_ofp10_queue_rate(hdr, &queue->min_rate);\n            break;\n\n        case OFPQT11_MAX_RATE:\n            error = parse_ofp10_queue_rate(hdr, &queue->max_rate);\n            break;\n\n        default:\n            VLOG_INFO_RL(&bad_ofmsg_rl, \"unknown queue property %u\", property);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n\n        ofpbuf_pull(msg, prop_len);\n        len -= prop_len;\n    }\n    return 0;\n}\n\nstatic int\nofputil_pull_queue_get_config_reply14(struct ofpbuf *msg,\n                                      struct ofputil_queue_config *queue)\n{\n    struct ofp14_queue_desc *oqd14 = ofpbuf_try_pull(msg, sizeof *oqd14);\n    if (!oqd14) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    enum ofperr error = ofputil_port_from_ofp11(oqd14->port_no, &queue->port);\n    if (error) {\n        return error;\n    }\n    queue->queue = ntohl(oqd14->queue_id);\n\n    /* Length check. */\n    unsigned int len = ntohs(oqd14->len);\n    if (len < sizeof *oqd14 || len > msg->size + sizeof *oqd14 || len % 8) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= sizeof *oqd14;\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPQDPT14_MIN_RATE:\n            error = ofpprop_parse_u16(&payload, &queue->min_rate);\n            break;\n\n        case OFPQDPT14_MAX_RATE:\n            error = ofpprop_parse_u16(&payload, &queue->max_rate);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(true, \"queue desc\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\n/* Decodes information about a queue from the OFPT_QUEUE_GET_CONFIG_REPLY in\n * 'reply' and stores it in '*queue'.  ofputil_decode_queue_get_config_reply()\n * must already have pulled off the main header.\n *\n * This function returns EOF if the last queue has already been decoded, 0 if a\n * queue was successfully decoded into '*queue', or an ofperr if there was a\n * problem decoding 'reply'. */\nint\nofputil_pull_queue_get_config_reply(struct ofpbuf *msg,\n                                    struct ofputil_queue_config *queue)\n{\n    enum ofpraw raw;\n    if (!msg->header) {\n        /* Pull OpenFlow header. */\n        raw = ofpraw_pull_assert(msg);\n\n        /* Pull protocol-specific ofp_queue_get_config_reply header (OF1.4\n         * doesn't have one at all). */\n        if (raw == OFPRAW_OFPT10_QUEUE_GET_CONFIG_REPLY) {\n            ofpbuf_pull(msg, sizeof(struct ofp10_queue_get_config_reply));\n        } else if (raw == OFPRAW_OFPT11_QUEUE_GET_CONFIG_REPLY) {\n            ofpbuf_pull(msg, sizeof(struct ofp11_queue_get_config_reply));\n        } else {\n            ovs_assert(raw == OFPRAW_OFPST14_QUEUE_DESC_REPLY);\n        }\n    } else {\n        raw = ofpraw_decode_assert(msg->header);\n    }\n\n    queue->min_rate = UINT16_MAX;\n    queue->max_rate = UINT16_MAX;\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_QUEUE_DESC_REPLY) {\n        return ofputil_pull_queue_get_config_reply14(msg, queue);\n    } else {\n        return ofputil_pull_queue_get_config_reply10(msg, queue);\n    }\n}\n\n/* Converts an OFPST_FLOW, OFPST_AGGREGATE, NXST_FLOW, or NXST_AGGREGATE\n * request 'oh', into an abstract flow_stats_request in 'fsr'.  Returns 0 if\n * successful, otherwise an OpenFlow error code.\n *\n * 'vl_mff_map' is an optional parameter that is used to validate the length\n * of variable length mf_fields in 'match'. If it is not provided, the\n * default mf_fields with maximum length will be used. */\nenum ofperr\nofputil_decode_flow_stats_request(struct ofputil_flow_stats_request *fsr,\n                                  const struct ofp_header *oh,\n                                  const struct tun_table *tun_table,\n                                  const struct vl_mff_map *vl_mff_map)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    switch ((int) raw) {\n    case OFPRAW_OFPST10_FLOW_REQUEST:\n        return ofputil_decode_ofpst10_flow_request(fsr, b.data, false);\n\n    case OFPRAW_OFPST10_AGGREGATE_REQUEST:\n        return ofputil_decode_ofpst10_flow_request(fsr, b.data, true);\n\n    case OFPRAW_OFPST11_FLOW_REQUEST:\n        return ofputil_decode_ofpst11_flow_request(fsr, &b, false, tun_table,\n                                                   vl_mff_map);\n\n    case OFPRAW_OFPST11_AGGREGATE_REQUEST:\n        return ofputil_decode_ofpst11_flow_request(fsr, &b, true, tun_table,\n                                                   vl_mff_map);\n\n    case OFPRAW_NXST_FLOW_REQUEST:\n        return ofputil_decode_nxst_flow_request(fsr, &b, false, tun_table,\n                                                vl_mff_map);\n\n    case OFPRAW_NXST_AGGREGATE_REQUEST:\n        return ofputil_decode_nxst_flow_request(fsr, &b, true, tun_table,\n                                                vl_mff_map);\n\n    default:\n        /* Hey, the caller lied. */\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Converts abstract flow_stats_request 'fsr' into an OFPST_FLOW,\n * OFPST_AGGREGATE, NXST_FLOW, or NXST_AGGREGATE request 'oh' according to\n * 'protocol', and returns the message. */\nstruct ofpbuf *\nofputil_encode_flow_stats_request(const struct ofputil_flow_stats_request *fsr,\n                                  enum ofputil_protocol protocol)\n{\n    struct ofpbuf *msg;\n    enum ofpraw raw;\n\n    switch (protocol) {\n    case OFPUTIL_P_OF11_STD:\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM: {\n        struct ofp11_flow_stats_request *ofsr;\n\n        raw = (fsr->aggregate\n               ? OFPRAW_OFPST11_AGGREGATE_REQUEST\n               : OFPRAW_OFPST11_FLOW_REQUEST);\n        msg = ofpraw_alloc(raw, ofputil_protocol_to_ofp_version(protocol),\n                           ofputil_match_typical_len(protocol));\n        ofsr = ofpbuf_put_zeros(msg, sizeof *ofsr);\n        ofsr->table_id = fsr->table_id;\n        ofsr->out_port = ofputil_port_to_ofp11(fsr->out_port);\n        ofsr->out_group = htonl(fsr->out_group);\n        ofsr->cookie = fsr->cookie;\n        ofsr->cookie_mask = fsr->cookie_mask;\n        ofputil_put_ofp11_match(msg, &fsr->match, protocol);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID: {\n        struct ofp10_flow_stats_request *ofsr;\n\n        raw = (fsr->aggregate\n               ? OFPRAW_OFPST10_AGGREGATE_REQUEST\n               : OFPRAW_OFPST10_FLOW_REQUEST);\n        msg = ofpraw_alloc(raw, OFP10_VERSION, 0);\n        ofsr = ofpbuf_put_zeros(msg, sizeof *ofsr);\n        ofputil_match_to_ofp10_match(&fsr->match, &ofsr->match);\n        ofsr->table_id = fsr->table_id;\n        ofsr->out_port = htons(ofp_to_u16(fsr->out_port));\n        break;\n    }\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID: {\n        struct nx_flow_stats_request *nfsr;\n        int match_len;\n\n        raw = (fsr->aggregate\n               ? OFPRAW_NXST_AGGREGATE_REQUEST\n               : OFPRAW_NXST_FLOW_REQUEST);\n        msg = ofpraw_alloc(raw, OFP10_VERSION, NXM_TYPICAL_LEN);\n        ofpbuf_put_zeros(msg, sizeof *nfsr);\n        match_len = nx_put_match(msg, &fsr->match,\n                                 fsr->cookie, fsr->cookie_mask);\n\n        nfsr = msg->msg;\n        nfsr->out_port = htons(ofp_to_u16(fsr->out_port));\n        nfsr->match_len = htons(match_len);\n        nfsr->table_id = fsr->table_id;\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return msg;\n}\n\n/* Converts an OFPST_FLOW or NXST_FLOW reply in 'msg' into an abstract\n * ofputil_flow_stats in 'fs'.\n *\n * Multiple OFPST_FLOW or NXST_FLOW replies can be packed into a single\n * OpenFlow message.  Calling this function multiple times for a single 'msg'\n * iterates through the replies.  The caller must initially leave 'msg''s layer\n * pointers null and not modify them between calls.\n *\n * Most switches don't send the values needed to populate fs->idle_age and\n * fs->hard_age, so those members will usually be set to 0.  If the switch from\n * which 'msg' originated is known to implement NXT_FLOW_AGE, then pass\n * 'flow_age_extension' as true so that the contents of 'msg' determine the\n * 'idle_age' and 'hard_age' members in 'fs'.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of the flow stats\n * reply's actions.  The caller must initialize 'ofpacts' and retains ownership\n * of it.  'fs->ofpacts' will point into the 'ofpacts' buffer.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_flow_stats_reply(struct ofputil_flow_stats *fs,\n                                struct ofpbuf *msg,\n                                bool flow_age_extension,\n                                struct ofpbuf *ofpacts)\n{\n    const struct ofp_header *oh;\n    size_t instructions_len;\n    enum ofperr error;\n    enum ofpraw raw;\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n    oh = msg->header;\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST11_FLOW_REPLY\n               || raw == OFPRAW_OFPST13_FLOW_REPLY) {\n        const struct ofp11_flow_stats *ofs;\n        size_t length;\n        uint16_t padded_match_len;\n\n        ofs = ofpbuf_try_pull(msg, sizeof *ofs);\n        if (!ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(ofs->length);\n        if (length < sizeof *ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply claims invalid \"\n                         \"length %\"PRIuSIZE, length);\n            return EINVAL;\n        }\n\n        if (ofputil_pull_ofp11_match(msg, NULL, NULL, &fs->match,\n                                     &padded_match_len)) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply bad match\");\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *ofs - padded_match_len;\n\n        fs->priority = ntohs(ofs->priority);\n        fs->table_id = ofs->table_id;\n        fs->duration_sec = ntohl(ofs->duration_sec);\n        fs->duration_nsec = ntohl(ofs->duration_nsec);\n        fs->idle_timeout = ntohs(ofs->idle_timeout);\n        fs->hard_timeout = ntohs(ofs->hard_timeout);\n        if (oh->version >= OFP14_VERSION) {\n            fs->importance = ntohs(ofs->importance);\n        } else {\n            fs->importance = 0;\n        }\n        if (raw == OFPRAW_OFPST13_FLOW_REPLY) {\n            error = ofputil_decode_flow_mod_flags(ofs->flags, -1, oh->version,\n                                                  &fs->flags);\n            if (error) {\n                return error;\n            }\n        } else {\n            fs->flags = 0;\n        }\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        fs->cookie = ofs->cookie;\n        fs->packet_count = ntohll(ofs->packet_count);\n        fs->byte_count = ntohll(ofs->byte_count);\n    } else if (raw == OFPRAW_OFPST10_FLOW_REPLY) {\n        const struct ofp10_flow_stats *ofs;\n        size_t length;\n\n        ofs = ofpbuf_try_pull(msg, sizeof *ofs);\n        if (!ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(ofs->length);\n        if (length < sizeof *ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply claims invalid \"\n                         \"length %\"PRIuSIZE, length);\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *ofs;\n\n        fs->cookie = get_32aligned_be64(&ofs->cookie);\n        ofputil_match_from_ofp10_match(&ofs->match, &fs->match);\n        fs->priority = ntohs(ofs->priority);\n        fs->table_id = ofs->table_id;\n        fs->duration_sec = ntohl(ofs->duration_sec);\n        fs->duration_nsec = ntohl(ofs->duration_nsec);\n        fs->idle_timeout = ntohs(ofs->idle_timeout);\n        fs->hard_timeout = ntohs(ofs->hard_timeout);\n        fs->importance = 0;\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        fs->packet_count = ntohll(get_32aligned_be64(&ofs->packet_count));\n        fs->byte_count = ntohll(get_32aligned_be64(&ofs->byte_count));\n        fs->flags = 0;\n    } else if (raw == OFPRAW_NXST_FLOW_REPLY) {\n        const struct nx_flow_stats *nfs;\n        size_t match_len, length;\n\n        nfs = ofpbuf_try_pull(msg, sizeof *nfs);\n        if (!nfs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(nfs->length);\n        match_len = ntohs(nfs->match_len);\n        if (length < sizeof *nfs + ROUND_UP(match_len, 8)) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW reply with match_len=%\"PRIuSIZE\" \"\n                         \"claims invalid length %\"PRIuSIZE, match_len, length);\n            return EINVAL;\n        }\n        if (nx_pull_match(msg, match_len, &fs->match, NULL, NULL, NULL,\n                          NULL)) {\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *nfs - ROUND_UP(match_len, 8);\n\n        fs->cookie = nfs->cookie;\n        fs->table_id = nfs->table_id;\n        fs->duration_sec = ntohl(nfs->duration_sec);\n        fs->duration_nsec = ntohl(nfs->duration_nsec);\n        fs->priority = ntohs(nfs->priority);\n        fs->idle_timeout = ntohs(nfs->idle_timeout);\n        fs->hard_timeout = ntohs(nfs->hard_timeout);\n        fs->importance = 0;\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        if (flow_age_extension) {\n            if (nfs->idle_age) {\n                fs->idle_age = ntohs(nfs->idle_age) - 1;\n            }\n            if (nfs->hard_age) {\n                fs->hard_age = ntohs(nfs->hard_age) - 1;\n            }\n        }\n        fs->packet_count = ntohll(nfs->packet_count);\n        fs->byte_count = ntohll(nfs->byte_count);\n        fs->flags = 0;\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (ofpacts_pull_openflow_instructions(msg, instructions_len, oh->version,\n                                           NULL, NULL, ofpacts)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply bad instructions\");\n        return EINVAL;\n    }\n    fs->ofpacts = ofpacts->data;\n    fs->ofpacts_len = ofpacts->size;\n\n    return 0;\n}\n\n/* Returns 'count' unchanged except that UINT64_MAX becomes 0.\n *\n * We use this in situations where OVS internally uses UINT64_MAX to mean\n * \"value unknown\" but OpenFlow 1.0 does not define any unknown value. */\nstatic uint64_t\nunknown_to_zero(uint64_t count)\n{\n    return count != UINT64_MAX ? count : 0;\n}\n\n/* Appends an OFPST_FLOW or NXST_FLOW reply that contains the data in 'fs' to\n * those already present in the list of ofpbufs in 'replies'.  'replies' should\n * have been initialized with ofpmp_init(). */\nvoid\nofputil_append_flow_stats_reply(const struct ofputil_flow_stats *fs,\n                                struct ovs_list *replies,\n                                const struct tun_table *tun_table)\n{\n    struct ofputil_flow_stats *fs_ = CONST_CAST(struct ofputil_flow_stats *,\n                                                fs);\n    const struct tun_table *orig_tun_table;\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = reply->size;\n    enum ofp_version version = ofpmp_version(replies);\n    enum ofpraw raw = ofpmp_decode_raw(replies);\n\n    orig_tun_table = fs->match.flow.tunnel.metadata.tab;\n    fs_->match.flow.tunnel.metadata.tab = tun_table;\n\n    if (raw == OFPRAW_OFPST11_FLOW_REPLY || raw == OFPRAW_OFPST13_FLOW_REPLY) {\n        struct ofp11_flow_stats *ofs;\n\n        ofpbuf_put_uninit(reply, sizeof *ofs);\n        oxm_put_match(reply, &fs->match, version);\n        ofpacts_put_openflow_instructions(fs->ofpacts, fs->ofpacts_len, reply,\n                                          version);\n\n        ofs = ofpbuf_at_assert(reply, start_ofs, sizeof *ofs);\n        ofs->length = htons(reply->size - start_ofs);\n        ofs->table_id = fs->table_id;\n        ofs->pad = 0;\n        ofs->duration_sec = htonl(fs->duration_sec);\n        ofs->duration_nsec = htonl(fs->duration_nsec);\n        ofs->priority = htons(fs->priority);\n        ofs->idle_timeout = htons(fs->idle_timeout);\n        ofs->hard_timeout = htons(fs->hard_timeout);\n        if (version >= OFP14_VERSION) {\n            ofs->importance = htons(fs->importance);\n        } else {\n            ofs->importance = 0;\n        }\n        if (raw == OFPRAW_OFPST13_FLOW_REPLY) {\n            ofs->flags = ofputil_encode_flow_mod_flags(fs->flags, version);\n        } else {\n            ofs->flags = 0;\n        }\n        memset(ofs->pad2, 0, sizeof ofs->pad2);\n        ofs->cookie = fs->cookie;\n        ofs->packet_count = htonll(unknown_to_zero(fs->packet_count));\n        ofs->byte_count = htonll(unknown_to_zero(fs->byte_count));\n    } else if (raw == OFPRAW_OFPST10_FLOW_REPLY) {\n        struct ofp10_flow_stats *ofs;\n\n        ofpbuf_put_uninit(reply, sizeof *ofs);\n        ofpacts_put_openflow_actions(fs->ofpacts, fs->ofpacts_len, reply,\n                                     version);\n        ofs = ofpbuf_at_assert(reply, start_ofs, sizeof *ofs);\n        ofs->length = htons(reply->size - start_ofs);\n        ofs->table_id = fs->table_id;\n        ofs->pad = 0;\n        ofputil_match_to_ofp10_match(&fs->match, &ofs->match);\n        ofs->duration_sec = htonl(fs->duration_sec);\n        ofs->duration_nsec = htonl(fs->duration_nsec);\n        ofs->priority = htons(fs->priority);\n        ofs->idle_timeout = htons(fs->idle_timeout);\n        ofs->hard_timeout = htons(fs->hard_timeout);\n        memset(ofs->pad2, 0, sizeof ofs->pad2);\n        put_32aligned_be64(&ofs->cookie, fs->cookie);\n        put_32aligned_be64(&ofs->packet_count,\n                           htonll(unknown_to_zero(fs->packet_count)));\n        put_32aligned_be64(&ofs->byte_count,\n                           htonll(unknown_to_zero(fs->byte_count)));\n    } else if (raw == OFPRAW_NXST_FLOW_REPLY) {\n        struct nx_flow_stats *nfs;\n        int match_len;\n\n        ofpbuf_put_uninit(reply, sizeof *nfs);\n        match_len = nx_put_match(reply, &fs->match, 0, 0);\n        ofpacts_put_openflow_actions(fs->ofpacts, fs->ofpacts_len, reply,\n                                     version);\n        nfs = ofpbuf_at_assert(reply, start_ofs, sizeof *nfs);\n        nfs->length = htons(reply->size - start_ofs);\n        nfs->table_id = fs->table_id;\n        nfs->pad = 0;\n        nfs->duration_sec = htonl(fs->duration_sec);\n        nfs->duration_nsec = htonl(fs->duration_nsec);\n        nfs->priority = htons(fs->priority);\n        nfs->idle_timeout = htons(fs->idle_timeout);\n        nfs->hard_timeout = htons(fs->hard_timeout);\n        nfs->idle_age = htons(fs->idle_age < 0 ? 0\n                              : fs->idle_age < UINT16_MAX ? fs->idle_age + 1\n                              : UINT16_MAX);\n        nfs->hard_age = htons(fs->hard_age < 0 ? 0\n                              : fs->hard_age < UINT16_MAX ? fs->hard_age + 1\n                              : UINT16_MAX);\n        nfs->match_len = htons(match_len);\n        nfs->cookie = fs->cookie;\n        nfs->packet_count = htonll(fs->packet_count);\n        nfs->byte_count = htonll(fs->byte_count);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    ofpmp_postappend(replies, start_ofs);\n    fs_->match.flow.tunnel.metadata.tab = orig_tun_table;\n}\n\n/* Converts abstract ofputil_aggregate_stats 'stats' into an OFPST_AGGREGATE or\n * NXST_AGGREGATE reply matching 'request', and returns the message. */\nstruct ofpbuf *\nofputil_encode_aggregate_stats_reply(\n    const struct ofputil_aggregate_stats *stats,\n    const struct ofp_header *request)\n{\n    struct ofp_aggregate_stats_reply *asr;\n    uint64_t packet_count;\n    uint64_t byte_count;\n    struct ofpbuf *msg;\n    enum ofpraw raw;\n\n    ofpraw_decode(&raw, request);\n    if (raw == OFPRAW_OFPST10_AGGREGATE_REQUEST) {\n        packet_count = unknown_to_zero(stats->packet_count);\n        byte_count = unknown_to_zero(stats->byte_count);\n    } else {\n        packet_count = stats->packet_count;\n        byte_count = stats->byte_count;\n    }\n\n    msg = ofpraw_alloc_stats_reply(request, 0);\n    asr = ofpbuf_put_zeros(msg, sizeof *asr);\n    put_32aligned_be64(&asr->packet_count, htonll(packet_count));\n    put_32aligned_be64(&asr->byte_count, htonll(byte_count));\n    asr->flow_count = htonl(stats->flow_count);\n\n    return msg;\n}\n\nenum ofperr\nofputil_decode_aggregate_stats_reply(struct ofputil_aggregate_stats *stats,\n                                     const struct ofp_header *reply)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(reply, ntohs(reply->length));\n    ofpraw_pull_assert(&msg);\n\n    struct ofp_aggregate_stats_reply *asr = msg.msg;\n    stats->packet_count = ntohll(get_32aligned_be64(&asr->packet_count));\n    stats->byte_count = ntohll(get_32aligned_be64(&asr->byte_count));\n    stats->flow_count = ntohl(asr->flow_count);\n\n    return 0;\n}\n\n/* Converts an OFPT_FLOW_REMOVED or NXT_FLOW_REMOVED message 'oh' into an\n * abstract ofputil_flow_removed in 'fr'.  Returns 0 if successful, otherwise\n * an OpenFlow error code. */\nenum ofperr\nofputil_decode_flow_removed(struct ofputil_flow_removed *fr,\n                            const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT11_FLOW_REMOVED) {\n        const struct ofp12_flow_removed *ofr;\n        enum ofperr error;\n\n        ofr = ofpbuf_pull(&b, sizeof *ofr);\n\n        error = ofputil_pull_ofp11_match(&b, NULL, NULL, &fr->match, NULL);\n        if (error) {\n            return error;\n        }\n\n        fr->priority = ntohs(ofr->priority);\n        fr->cookie = ofr->cookie;\n        fr->reason = ofr->reason;\n        fr->table_id = ofr->table_id;\n        fr->duration_sec = ntohl(ofr->duration_sec);\n        fr->duration_nsec = ntohl(ofr->duration_nsec);\n        fr->idle_timeout = ntohs(ofr->idle_timeout);\n        fr->hard_timeout = ntohs(ofr->hard_timeout);\n        fr->packet_count = ntohll(ofr->packet_count);\n        fr->byte_count = ntohll(ofr->byte_count);\n    } else if (raw == OFPRAW_OFPT10_FLOW_REMOVED) {\n        const struct ofp10_flow_removed *ofr;\n\n        ofr = ofpbuf_pull(&b, sizeof *ofr);\n\n        ofputil_match_from_ofp10_match(&ofr->match, &fr->match);\n        fr->priority = ntohs(ofr->priority);\n        fr->cookie = ofr->cookie;\n        fr->reason = ofr->reason;\n        fr->table_id = 255;\n        fr->duration_sec = ntohl(ofr->duration_sec);\n        fr->duration_nsec = ntohl(ofr->duration_nsec);\n        fr->idle_timeout = ntohs(ofr->idle_timeout);\n        fr->hard_timeout = 0;\n        fr->packet_count = ntohll(ofr->packet_count);\n        fr->byte_count = ntohll(ofr->byte_count);\n    } else if (raw == OFPRAW_NXT_FLOW_REMOVED) {\n        struct nx_flow_removed *nfr;\n        enum ofperr error;\n\n        nfr = ofpbuf_pull(&b, sizeof *nfr);\n        error = nx_pull_match(&b, ntohs(nfr->match_len), &fr->match, NULL,\n                              NULL, NULL, NULL);\n        if (error) {\n            return error;\n        }\n        if (b.size) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        fr->priority = ntohs(nfr->priority);\n        fr->cookie = nfr->cookie;\n        fr->reason = nfr->reason;\n        fr->table_id = nfr->table_id ? nfr->table_id - 1 : 255;\n        fr->duration_sec = ntohl(nfr->duration_sec);\n        fr->duration_nsec = ntohl(nfr->duration_nsec);\n        fr->idle_timeout = ntohs(nfr->idle_timeout);\n        fr->hard_timeout = 0;\n        fr->packet_count = ntohll(nfr->packet_count);\n        fr->byte_count = ntohll(nfr->byte_count);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    return 0;\n}\n\n/* Converts abstract ofputil_flow_removed 'fr' into an OFPT_FLOW_REMOVED or\n * NXT_FLOW_REMOVED message 'oh' according to 'protocol', and returns the\n * message. */\nstruct ofpbuf *\nofputil_encode_flow_removed(const struct ofputil_flow_removed *fr,\n                            enum ofputil_protocol protocol)\n{\n    struct ofpbuf *msg;\n    enum ofp_flow_removed_reason reason = fr->reason;\n\n    if (reason == OFPRR_METER_DELETE && !(protocol & OFPUTIL_P_OF14_UP)) {\n        reason = OFPRR_DELETE;\n    }\n\n    switch (protocol) {\n    case OFPUTIL_P_OF11_STD:\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM: {\n        struct ofp12_flow_removed *ofr;\n\n        msg = ofpraw_alloc_xid(OFPRAW_OFPT11_FLOW_REMOVED,\n                               ofputil_protocol_to_ofp_version(protocol),\n                               htonl(0),\n                               ofputil_match_typical_len(protocol));\n        ofr = ofpbuf_put_zeros(msg, sizeof *ofr);\n        ofr->cookie = fr->cookie;\n        ofr->priority = htons(fr->priority);\n        ofr->reason = reason;\n        ofr->table_id = fr->table_id;\n        ofr->duration_sec = htonl(fr->duration_sec);\n        ofr->duration_nsec = htonl(fr->duration_nsec);\n        ofr->idle_timeout = htons(fr->idle_timeout);\n        ofr->hard_timeout = htons(fr->hard_timeout);\n        ofr->packet_count = htonll(fr->packet_count);\n        ofr->byte_count = htonll(fr->byte_count);\n        ofputil_put_ofp11_match(msg, &fr->match, protocol);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID: {\n        struct ofp10_flow_removed *ofr;\n\n        msg = ofpraw_alloc_xid(OFPRAW_OFPT10_FLOW_REMOVED, OFP10_VERSION,\n                               htonl(0), 0);\n        ofr = ofpbuf_put_zeros(msg, sizeof *ofr);\n        ofputil_match_to_ofp10_match(&fr->match, &ofr->match);\n        ofr->cookie = fr->cookie;\n        ofr->priority = htons(fr->priority);\n        ofr->reason = reason;\n        ofr->duration_sec = htonl(fr->duration_sec);\n        ofr->duration_nsec = htonl(fr->duration_nsec);\n        ofr->idle_timeout = htons(fr->idle_timeout);\n        ofr->packet_count = htonll(unknown_to_zero(fr->packet_count));\n        ofr->byte_count = htonll(unknown_to_zero(fr->byte_count));\n        break;\n    }\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID: {\n        struct nx_flow_removed *nfr;\n        int match_len;\n\n        msg = ofpraw_alloc_xid(OFPRAW_NXT_FLOW_REMOVED, OFP10_VERSION,\n                               htonl(0), NXM_TYPICAL_LEN);\n        ofpbuf_put_zeros(msg, sizeof *nfr);\n        match_len = nx_put_match(msg, &fr->match, 0, 0);\n\n        nfr = msg->msg;\n        nfr->cookie = fr->cookie;\n        nfr->priority = htons(fr->priority);\n        nfr->reason = reason;\n        nfr->table_id = fr->table_id + 1;\n        nfr->duration_sec = htonl(fr->duration_sec);\n        nfr->duration_nsec = htonl(fr->duration_nsec);\n        nfr->idle_timeout = htons(fr->idle_timeout);\n        nfr->match_len = htons(match_len);\n        nfr->packet_count = htonll(fr->packet_count);\n        nfr->byte_count = htonll(fr->byte_count);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return msg;\n}\n\n/* The caller has done basic initialization of '*pin'; the other output\n * arguments needs to be initialized. */\nstatic enum ofperr\ndecode_nx_packet_in2(const struct ofp_header *oh, bool loose,\n                     const struct tun_table *tun_table,\n                     const struct vl_mff_map *vl_mff_map,\n                     struct ofputil_packet_in *pin,\n                     size_t *total_len, uint32_t *buffer_id,\n                     struct ofpbuf *continuation)\n{\n    *total_len = 0;\n    *buffer_id = UINT32_MAX;\n\n    struct ofpbuf properties;\n    ofpbuf_use_const(&properties, oh, ntohs(oh->length));\n    ofpraw_pull_assert(&properties);\n\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        enum ofperr error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case NXPINT_PACKET:\n            pin->packet = payload.msg;\n            pin->packet_len = ofpbuf_msgsize(&payload);\n            break;\n\n        case NXPINT_FULL_LEN: {\n            uint32_t u32;\n            error = ofpprop_parse_u32(&payload, &u32);\n            *total_len = u32;\n            break;\n        }\n\n        case NXPINT_BUFFER_ID:\n            error = ofpprop_parse_u32(&payload, buffer_id);\n            break;\n\n        case NXPINT_TABLE_ID:\n            error = ofpprop_parse_u8(&payload, &pin->table_id);\n            break;\n\n        case NXPINT_COOKIE:\n            error = ofpprop_parse_be64(&payload, &pin->cookie);\n            break;\n\n        case NXPINT_REASON: {\n            uint8_t reason;\n            error = ofpprop_parse_u8(&payload, &reason);\n            pin->reason = reason;\n            break;\n        }\n\n        case NXPINT_METADATA:\n            error = oxm_decode_match(payload.msg, ofpbuf_msgsize(&payload),\n                                     loose, tun_table, vl_mff_map,\n                                     &pin->flow_metadata);\n            break;\n\n        case NXPINT_USERDATA:\n            pin->userdata = payload.msg;\n            pin->userdata_len = ofpbuf_msgsize(&payload);\n            break;\n\n        case NXPINT_CONTINUATION:\n            if (continuation) {\n                error = ofpprop_parse_nested(&payload, continuation);\n            }\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(loose, \"NX_PACKET_IN2\", type);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n    }\n\n    if (!pin->packet_len) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXT_PACKET_IN2 lacks packet\");\n        return OFPERR_OFPBRC_BAD_LEN;\n    } else if (!*total_len) {\n        *total_len = pin->packet_len;\n    } else if (*total_len < pin->packet_len) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXT_PACKET_IN2 claimed full_len < len\");\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    return 0;\n}\n\n/* Decodes the packet-in message starting at 'oh' into '*pin'.  Populates\n * 'pin->packet' and 'pin->packet_len' with the part of the packet actually\n * included in the message.  If 'total_lenp' is nonnull, populates\n * '*total_lenp' with the original length of the packet (which is larger than\n * 'packet->len' if only part of the packet was included).  If 'buffer_idp' is\n * nonnull, stores the packet's buffer ID in '*buffer_idp' (UINT32_MAX if it\n * was not buffered).\n *\n * Populates 'continuation', if nonnull, with the continuation data from the\n * packet-in (an empty buffer, if 'oh' did not contain continuation data).  The\n * format of this data is supposed to be opaque to anything other than\n * ovs-vswitchd, so that in any other process the only reasonable use of this\n * data is to be copied into an NXT_RESUME message via ofputil_encode_resume().\n *\n * This function points 'pin->packet' into 'oh', so the caller should not free\n * it separately from the original OpenFlow message.  This is also true for\n * 'pin->userdata' (which could also end up NULL if there is no userdata).\n *\n * 'vl_mff_map' is an optional parameter that is used to validate the length\n * of variable length mf_fields in 'match'. If it is not provided, the\n * default mf_fields with maximum length will be used.\n *\n * Returns 0 if successful, otherwise an OpenFlow error code. */\nenum ofperr\nofputil_decode_packet_in(const struct ofp_header *oh, bool loose,\n                         const struct tun_table *tun_table,\n                         const struct vl_mff_map *vl_mff_map,\n                         struct ofputil_packet_in *pin,\n                         size_t *total_lenp, uint32_t *buffer_idp,\n                         struct ofpbuf *continuation)\n{\n    uint32_t buffer_id;\n    size_t total_len;\n\n    memset(pin, 0, sizeof *pin);\n    pin->cookie = OVS_BE64_MAX;\n    if (continuation) {\n        ofpbuf_use_const(continuation, NULL, 0);\n    }\n\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT13_PACKET_IN || raw == OFPRAW_OFPT12_PACKET_IN) {\n        const struct ofp12_packet_in *opi = ofpbuf_pull(&b, sizeof *opi);\n        const ovs_be64 *cookie = (raw == OFPRAW_OFPT13_PACKET_IN\n                                  ? ofpbuf_pull(&b, sizeof *cookie)\n                                  : NULL);\n        enum ofperr error = oxm_pull_match_loose(&b, tun_table,\n                                                 &pin->flow_metadata);\n        if (error) {\n            return error;\n        }\n\n        if (!ofpbuf_try_pull(&b, 2)) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        pin->reason = opi->reason;\n        pin->table_id = opi->table_id;\n        buffer_id = ntohl(opi->buffer_id);\n        total_len = ntohs(opi->total_len);\n        if (cookie) {\n            pin->cookie = *cookie;\n        }\n\n        pin->packet = b.data;\n        pin->packet_len = b.size;\n    } else if (raw == OFPRAW_OFPT10_PACKET_IN) {\n        const struct ofp10_packet_in *opi;\n\n        opi = ofpbuf_pull(&b, offsetof(struct ofp10_packet_in, data));\n\n        pin->packet = CONST_CAST(uint8_t *, opi->data);\n        pin->packet_len = b.size;\n\n        match_init_catchall(&pin->flow_metadata);\n        match_set_in_port(&pin->flow_metadata,\n                          u16_to_ofp(ntohs(opi->in_port)));\n        pin->reason = opi->reason;\n        buffer_id = ntohl(opi->buffer_id);\n        total_len = ntohs(opi->total_len);\n    } else if (raw == OFPRAW_OFPT11_PACKET_IN) {\n        const struct ofp11_packet_in *opi;\n        ofp_port_t in_port;\n        enum ofperr error;\n\n        opi = ofpbuf_pull(&b, sizeof *opi);\n\n        pin->packet = b.data;\n        pin->packet_len = b.size;\n\n        buffer_id = ntohl(opi->buffer_id);\n        error = ofputil_port_from_ofp11(opi->in_port, &in_port);\n        if (error) {\n            return error;\n        }\n        match_init_catchall(&pin->flow_metadata);\n        match_set_in_port(&pin->flow_metadata, in_port);\n        total_len = ntohs(opi->total_len);\n        pin->reason = opi->reason;\n        pin->table_id = opi->table_id;\n    } else if (raw == OFPRAW_NXT_PACKET_IN) {\n        const struct nx_packet_in *npi;\n        int error;\n\n        npi = ofpbuf_pull(&b, sizeof *npi);\n        error = nx_pull_match_loose(&b, ntohs(npi->match_len),\n                                    &pin->flow_metadata, NULL, NULL, NULL);\n        if (error) {\n            return error;\n        }\n\n        if (!ofpbuf_try_pull(&b, 2)) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        pin->reason = npi->reason;\n        pin->table_id = npi->table_id;\n        pin->cookie = npi->cookie;\n\n        buffer_id = ntohl(npi->buffer_id);\n        total_len = ntohs(npi->total_len);\n\n        pin->packet = b.data;\n        pin->packet_len = b.size;\n    } else if (raw == OFPRAW_NXT_PACKET_IN2 || raw == OFPRAW_NXT_RESUME) {\n        enum ofperr error = decode_nx_packet_in2(oh, loose, tun_table,\n                                                 vl_mff_map, pin, &total_len,\n                                                 &buffer_id, continuation);\n        if (error) {\n            return error;\n        }\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (total_lenp) {\n        *total_lenp = total_len;\n    }\n    if (buffer_idp) {\n        *buffer_idp = buffer_id;\n    }\n\n    return 0;\n}\n\nstatic int\nencode_packet_in_reason(enum ofp_packet_in_reason reason,\n                        enum ofp_version version)\n{\n    switch (reason) {\n    case OFPR_NO_MATCH:\n    case OFPR_ACTION:\n    case OFPR_INVALID_TTL:\n        return reason;\n\n    case OFPR_ACTION_SET:\n    case OFPR_GROUP:\n    case OFPR_PACKET_OUT:\n        return version < OFP14_VERSION ? OFPR_ACTION : reason;\n\n    case OFPR_EXPLICIT_MISS:\n        return version < OFP13_VERSION ? OFPR_ACTION : OFPR_NO_MATCH;\n\n    case OFPR_IMPLICIT_MISS:\n        return OFPR_NO_MATCH;\n\n    case OFPR_N_REASONS:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Only NXT_PACKET_IN2 (not NXT_RESUME) should include NXCPT_USERDATA, so this\n * function omits it.  The caller can add it itself if desired. */\nstatic void\nofputil_put_packet_in(const struct ofputil_packet_in *pin,\n                      enum ofp_version version, size_t include_bytes,\n                      struct ofpbuf *msg)\n{\n    /* Add packet properties. */\n    ofpprop_put(msg, NXPINT_PACKET, pin->packet, include_bytes);\n    if (include_bytes != pin->packet_len) {\n        ofpprop_put_u32(msg, NXPINT_FULL_LEN, pin->packet_len);\n    }\n\n    /* Add flow properties. */\n    ofpprop_put_u8(msg, NXPINT_TABLE_ID, pin->table_id);\n    if (pin->cookie != OVS_BE64_MAX) {\n        ofpprop_put_be64(msg, NXPINT_COOKIE, pin->cookie);\n    }\n\n    /* Add other properties. */\n    ofpprop_put_u8(msg, NXPINT_REASON,\n                   encode_packet_in_reason(pin->reason, version));\n\n    size_t start = ofpprop_start(msg, NXPINT_METADATA);\n    oxm_put_raw(msg, &pin->flow_metadata, version);\n    ofpprop_end(msg, start);\n}\n\nstatic void\nput_actions_property(struct ofpbuf *msg, uint64_t prop_type,\n                     enum ofp_version version,\n                     const struct ofpact *actions, size_t actions_len)\n{\n    if (actions_len) {\n        size_t start = ofpprop_start_nested(msg, prop_type);\n        ofpacts_put_openflow_actions(actions, actions_len, msg, version);\n        ofpprop_end(msg, start);\n    }\n}\n\nenum nx_continuation_prop_type {\n    NXCPT_BRIDGE = 0x8000,\n    NXCPT_STACK,\n    NXCPT_MIRRORS,\n    NXCPT_CONNTRACKED,\n    NXCPT_TABLE_ID,\n    NXCPT_COOKIE,\n    NXCPT_ACTIONS,\n    NXCPT_ACTION_SET,\n};\n\n/* Only NXT_PACKET_IN2 (not NXT_RESUME) should include NXCPT_USERDATA, so this\n * function omits it.  The caller can add it itself if desired. */\nstatic void\nofputil_put_packet_in_private(const struct ofputil_packet_in_private *pin,\n                              enum ofp_version version, size_t include_bytes,\n                              struct ofpbuf *msg)\n{\n    ofputil_put_packet_in(&pin->public, version, include_bytes, msg);\n\n    size_t continuation_ofs = ofpprop_start_nested(msg, NXPINT_CONTINUATION);\n    size_t inner_ofs = msg->size;\n\n    if (!uuid_is_zero(&pin->bridge)) {\n        ofpprop_put_uuid(msg, NXCPT_BRIDGE, &pin->bridge);\n    }\n\n    struct ofpbuf pin_stack;\n    ofpbuf_use_const(&pin_stack, pin->stack, pin->stack_size);\n\n    while (pin_stack.size) {\n        uint8_t len;\n        uint8_t *val = nx_stack_pop(&pin_stack, &len);\n        ofpprop_put(msg, NXCPT_STACK, val, len);\n    }\n\n    if (pin->mirrors) {\n        ofpprop_put_u32(msg, NXCPT_MIRRORS, pin->mirrors);\n    }\n\n    if (pin->conntracked) {\n        ofpprop_put_flag(msg, NXCPT_CONNTRACKED);\n    }\n\n    if (pin->actions_len) {\n        /* Divide 'pin->actions' into groups that begins with an\n         * unroll_xlate action.  For each group, emit a NXCPT_TABLE_ID and\n         * NXCPT_COOKIE property (if either has changed; each is initially\n         * assumed 0), then a NXCPT_ACTIONS property with the grouped\n         * actions.\n         *\n         * The alternative is to make OFPACT_UNROLL_XLATE public.  We can\n         * always do that later, since this is a private property. */\n        const struct ofpact *const end = ofpact_end(pin->actions,\n                                                    pin->actions_len);\n        const struct ofpact_unroll_xlate *unroll = NULL;\n        uint8_t table_id = 0;\n        ovs_be64 cookie = 0;\n\n        const struct ofpact *a;\n        for (a = pin->actions; ; a = ofpact_next(a)) {\n            if (a == end || a->type == OFPACT_UNROLL_XLATE) {\n                if (unroll) {\n                    if (table_id != unroll->rule_table_id) {\n                        ofpprop_put_u8(msg, NXCPT_TABLE_ID,\n                                       unroll->rule_table_id);\n                        table_id = unroll->rule_table_id;\n                    }\n                    if (cookie != unroll->rule_cookie) {\n                        ofpprop_put_be64(msg, NXCPT_COOKIE,\n                                         unroll->rule_cookie);\n                        cookie = unroll->rule_cookie;\n                    }\n                }\n\n                const struct ofpact *start\n                    = unroll ? ofpact_next(&unroll->ofpact) : pin->actions;\n                put_actions_property(msg, NXCPT_ACTIONS, version,\n                                     start, (a - start) * sizeof *a);\n\n                if (a == end) {\n                    break;\n                }\n                unroll = ofpact_get_UNROLL_XLATE(a);\n            }\n        }\n    }\n\n    if (pin->action_set_len) {\n        size_t start = ofpprop_start_nested(msg, NXCPT_ACTION_SET);\n        ofpacts_put_openflow_actions(pin->action_set,\n                                     pin->action_set_len, msg, version);\n        ofpprop_end(msg, start);\n    }\n\n    if (msg->size > inner_ofs) {\n        ofpprop_end(msg, continuation_ofs);\n    } else {\n        msg->size = continuation_ofs;\n    }\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp10_packet_in(const struct ofputil_packet_in *pin)\n{\n    struct ofp10_packet_in *opi;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc_xid(OFPRAW_OFPT10_PACKET_IN, OFP10_VERSION,\n                           htonl(0), pin->packet_len);\n    opi = ofpbuf_put_zeros(msg, offsetof(struct ofp10_packet_in, data));\n    opi->total_len = htons(pin->packet_len);\n    opi->in_port = htons(ofp_to_u16(pin->flow_metadata.flow.in_port.ofp_port));\n    opi->reason = encode_packet_in_reason(pin->reason, OFP10_VERSION);\n    opi->buffer_id = htonl(UINT32_MAX);\n\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_nx_packet_in(const struct ofputil_packet_in *pin,\n                            enum ofp_version version)\n{\n    struct nx_packet_in *npi;\n    struct ofpbuf *msg;\n    size_t match_len;\n\n    /* The final argument is just an estimate of the space required. */\n    msg = ofpraw_alloc_xid(OFPRAW_NXT_PACKET_IN, version,\n                           htonl(0), NXM_TYPICAL_LEN + 2 + pin->packet_len);\n    ofpbuf_put_zeros(msg, sizeof *npi);\n    match_len = nx_put_match(msg, &pin->flow_metadata, 0, 0);\n    ofpbuf_put_zeros(msg, 2);\n\n    npi = msg->msg;\n    npi->buffer_id = htonl(UINT32_MAX);\n    npi->total_len = htons(pin->packet_len);\n    npi->reason = encode_packet_in_reason(pin->reason, version);\n    npi->table_id = pin->table_id;\n    npi->cookie = pin->cookie;\n    npi->match_len = htons(match_len);\n\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_nx_packet_in2(const struct ofputil_packet_in_private *pin,\n                             enum ofp_version version, size_t include_bytes)\n{\n    /* 'extra' is just an estimate of the space required. */\n    size_t extra = (pin->public.packet_len\n                    + NXM_TYPICAL_LEN   /* flow_metadata */\n                    + pin->stack_size * 4\n                    + pin->actions_len\n                    + pin->action_set_len\n                    + 256);     /* fudge factor */\n    struct ofpbuf *msg = ofpraw_alloc_xid(OFPRAW_NXT_PACKET_IN2, version,\n                                          htonl(0), extra);\n\n    ofputil_put_packet_in_private(pin, version, include_bytes, msg);\n    if (pin->public.userdata_len) {\n        ofpprop_put(msg, NXPINT_USERDATA, pin->public.userdata,\n                    pin->public.userdata_len);\n    }\n\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp11_packet_in(const struct ofputil_packet_in *pin)\n{\n    struct ofp11_packet_in *opi;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc_xid(OFPRAW_OFPT11_PACKET_IN, OFP11_VERSION,\n                           htonl(0), pin->packet_len);\n    opi = ofpbuf_put_zeros(msg, sizeof *opi);\n    opi->buffer_id = htonl(UINT32_MAX);\n    opi->in_port = ofputil_port_to_ofp11(\n        pin->flow_metadata.flow.in_port.ofp_port);\n    opi->in_phy_port = opi->in_port;\n    opi->total_len = htons(pin->packet_len);\n    opi->reason = encode_packet_in_reason(pin->reason, OFP11_VERSION);\n    opi->table_id = pin->table_id;\n\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp12_packet_in(const struct ofputil_packet_in *pin,\n                               enum ofp_version version)\n{\n    enum ofpraw raw = (version >= OFP13_VERSION\n                       ? OFPRAW_OFPT13_PACKET_IN\n                       : OFPRAW_OFPT12_PACKET_IN);\n    struct ofpbuf *msg;\n\n    /* The final argument is just an estimate of the space required. */\n    msg = ofpraw_alloc_xid(raw, version,\n                           htonl(0), NXM_TYPICAL_LEN + 2 + pin->packet_len);\n\n    struct ofp12_packet_in *opi = ofpbuf_put_zeros(msg, sizeof *opi);\n    opi->buffer_id = htonl(UINT32_MAX);\n    opi->total_len = htons(pin->packet_len);\n    opi->reason = encode_packet_in_reason(pin->reason, version);\n    opi->table_id = pin->table_id;\n\n    if (version >= OFP13_VERSION) {\n        ovs_be64 cookie = pin->cookie;\n        ofpbuf_put(msg, &cookie, sizeof cookie);\n    }\n\n    oxm_put_match(msg, &pin->flow_metadata, version);\n    ofpbuf_put_zeros(msg, 2);\n\n    return msg;\n}\n\n/* Converts abstract ofputil_packet_in_private 'pin' into a PACKET_IN message\n * for 'protocol', using the packet-in format specified by 'packet_in_format'.\n *\n * This function is really meant only for use by ovs-vswitchd.  To any other\n * code, the \"continuation\" data, i.e. the data that is in struct\n * ofputil_packet_in_private but not in struct ofputil_packet_in, is supposed\n * to be opaque (and it might change from one OVS version to another).  Thus,\n * if any other code wants to encode a packet-in, it should use a non-\"private\"\n * version of this function.  (Such a version doesn't currently exist because\n * only ovs-vswitchd currently wants to encode packet-ins.  If you need one,\n * write it...) */\nstruct ofpbuf *\nofputil_encode_packet_in_private(const struct ofputil_packet_in_private *pin,\n                                 enum ofputil_protocol protocol,\n                                 enum nx_packet_in_format packet_in_format)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n\n    struct ofpbuf *msg;\n    switch (packet_in_format) {\n    case NXPIF_STANDARD:\n        switch (protocol) {\n        case OFPUTIL_P_OF10_STD:\n        case OFPUTIL_P_OF10_STD_TID:\n        case OFPUTIL_P_OF10_NXM:\n        case OFPUTIL_P_OF10_NXM_TID:\n            msg = ofputil_encode_ofp10_packet_in(&pin->public);\n            break;\n\n        case OFPUTIL_P_OF11_STD:\n            msg = ofputil_encode_ofp11_packet_in(&pin->public);\n            break;\n\n        case OFPUTIL_P_OF12_OXM:\n        case OFPUTIL_P_OF13_OXM:\n        case OFPUTIL_P_OF14_OXM:\n        case OFPUTIL_P_OF15_OXM:\n        case OFPUTIL_P_OF16_OXM:\n            msg = ofputil_encode_ofp12_packet_in(&pin->public, version);\n            break;\n\n        default:\n            OVS_NOT_REACHED();\n        }\n        break;\n\n    case NXPIF_NXT_PACKET_IN:\n        msg = ofputil_encode_nx_packet_in(&pin->public, version);\n        break;\n\n    case NXPIF_NXT_PACKET_IN2:\n        return ofputil_encode_nx_packet_in2(pin, version,\n                                            pin->public.packet_len);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ofpbuf_put(msg, pin->public.packet, pin->public.packet_len);\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\n/* Returns a string form of 'reason'.  The return value is either a statically\n * allocated constant string or the 'bufsize'-byte buffer 'reasonbuf'.\n * 'bufsize' should be at least OFPUTIL_PACKET_IN_REASON_BUFSIZE. */\nconst char *\nofputil_packet_in_reason_to_string(enum ofp_packet_in_reason reason,\n                                   char *reasonbuf, size_t bufsize)\n{\n    switch (reason) {\n    case OFPR_NO_MATCH:\n        return \"no_match\";\n    case OFPR_ACTION:\n        return \"action\";\n    case OFPR_INVALID_TTL:\n        return \"invalid_ttl\";\n    case OFPR_ACTION_SET:\n        return \"action_set\";\n    case OFPR_GROUP:\n        return \"group\";\n    case OFPR_PACKET_OUT:\n        return \"packet_out\";\n    case OFPR_EXPLICIT_MISS:\n    case OFPR_IMPLICIT_MISS:\n        return \"\";\n\n    case OFPR_N_REASONS:\n    default:\n        snprintf(reasonbuf, bufsize, \"%d\", (int) reason);\n        return reasonbuf;\n    }\n}\n\nbool\nofputil_packet_in_reason_from_string(const char *s,\n                                     enum ofp_packet_in_reason *reason)\n{\n    int i;\n\n    for (i = 0; i < OFPR_N_REASONS; i++) {\n        char reasonbuf[OFPUTIL_PACKET_IN_REASON_BUFSIZE];\n        const char *reason_s;\n\n        reason_s = ofputil_packet_in_reason_to_string(i, reasonbuf,\n                                                      sizeof reasonbuf);\n        if (!strcasecmp(s, reason_s)) {\n            *reason = i;\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Returns a newly allocated NXT_RESUME message for 'pin', with the given\n * 'continuation', for 'protocol'.  This message is suitable for resuming the\n * pipeline traveral of the packet represented by 'pin', if sent to the switch\n * from which 'pin' was received. */\nstruct ofpbuf *\nofputil_encode_resume(const struct ofputil_packet_in *pin,\n                      const struct ofpbuf *continuation,\n                      enum ofputil_protocol protocol)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n    size_t extra = pin->packet_len + NXM_TYPICAL_LEN + continuation->size;\n    struct ofpbuf *msg = ofpraw_alloc_xid(OFPRAW_NXT_RESUME, version,\n                                          0, extra);\n    ofputil_put_packet_in(pin, version, pin->packet_len, msg);\n    ofpprop_put_nested(msg, NXPINT_CONTINUATION, continuation);\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic enum ofperr\nparse_stack_prop(const struct ofpbuf *property, struct ofpbuf *stack)\n{\n    unsigned int len = ofpbuf_msgsize(property);\n    if (len > sizeof(union mf_subvalue)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXCPT_STACK property has bad length %u\",\n                     len);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n    nx_stack_push_bottom(stack, property->msg, len);\n    return 0;\n}\n\nstatic enum ofperr\nparse_actions_property(struct ofpbuf *property, enum ofp_version version,\n                       struct ofpbuf *ofpacts)\n{\n    if (!ofpbuf_try_pull(property, ROUND_UP(ofpbuf_headersize(property), 8))) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"actions property has bad length %\"PRIu32,\n                     property->size);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    return ofpacts_pull_openflow_actions(property, property->size,\n                                         version, NULL, NULL, ofpacts);\n}\n\n/* This is like ofputil_decode_packet_in(), except that it decodes the\n * continuation data into 'pin'.  The format of this data is supposed to be\n * opaque to any process other than ovs-vswitchd, so this function should not\n * be used outside ovs-vswitchd.\n *\n * 'vl_mff_map' is an optional parameter that is used to validate the length\n * of variable length mf_fields in 'match'. If it is not provided, the\n * default mf_fields with maximum length will be used.\n *\n * When successful, 'pin' contains some dynamically allocated data.  Call\n * ofputil_packet_in_private_destroy() to free this data. */\nenum ofperr\nofputil_decode_packet_in_private(const struct ofp_header *oh, bool loose,\n                                 const struct tun_table *tun_table,\n                                 const struct vl_mff_map *vl_mff_map,\n                                 struct ofputil_packet_in_private *pin,\n                                 size_t *total_len, uint32_t *buffer_id)\n{\n    memset(pin, 0, sizeof *pin);\n\n    struct ofpbuf continuation;\n    enum ofperr error;\n    error = ofputil_decode_packet_in(oh, loose, tun_table, vl_mff_map,\n                                     &pin->public, total_len, buffer_id,\n                                     &continuation);\n    if (error) {\n        return error;\n    }\n\n    struct ofpbuf actions, action_set;\n    ofpbuf_init(&actions, 0);\n    ofpbuf_init(&action_set, 0);\n\n    uint8_t table_id = 0;\n    ovs_be64 cookie = 0;\n\n    struct ofpbuf stack;\n    ofpbuf_init(&stack, 0);\n\n    while (continuation.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        error = ofpprop_pull(&continuation, &payload, &type);\n        if (error) {\n            break;\n        }\n\n        switch (type) {\n        case NXCPT_BRIDGE:\n            error = ofpprop_parse_uuid(&payload, &pin->bridge);\n            break;\n\n        case NXCPT_STACK:\n            error = parse_stack_prop(&payload, &stack);\n            break;\n\n        case NXCPT_MIRRORS:\n            error = ofpprop_parse_u32(&payload, &pin->mirrors);\n            break;\n\n        case NXCPT_CONNTRACKED:\n            pin->conntracked = true;\n            break;\n\n        case NXCPT_TABLE_ID:\n            error = ofpprop_parse_u8(&payload, &table_id);\n            break;\n\n        case NXCPT_COOKIE:\n            error = ofpprop_parse_be64(&payload, &cookie);\n            break;\n\n        case NXCPT_ACTIONS: {\n            struct ofpact_unroll_xlate *unroll\n                = ofpact_put_UNROLL_XLATE(&actions);\n            unroll->rule_table_id = table_id;\n            unroll->rule_cookie = cookie;\n            error = parse_actions_property(&payload, oh->version, &actions);\n            break;\n        }\n\n        case NXCPT_ACTION_SET:\n            error = parse_actions_property(&payload, oh->version, &action_set);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(loose, \"continuation\", type);\n            break;\n        }\n        if (error) {\n            break;\n        }\n    }\n\n    pin->actions_len = actions.size;\n    pin->actions = ofpbuf_steal_data(&actions);\n    pin->action_set_len = action_set.size;\n    pin->action_set = ofpbuf_steal_data(&action_set);\n    pin->stack_size = stack.size;\n    pin->stack = ofpbuf_steal_data(&stack);\n\n    if (error) {\n        ofputil_packet_in_private_destroy(pin);\n    }\n\n    return error;\n}\n\n/* Frees data in 'pin' that is dynamically allocated by\n * ofputil_decode_packet_in_private().\n *\n * 'pin->public' contains some pointer members that\n * ofputil_decode_packet_in_private() doesn't initialize to newly allocated\n * data, so this function doesn't free those. */\nvoid\nofputil_packet_in_private_destroy(struct ofputil_packet_in_private *pin)\n{\n    if (pin) {\n        free(pin->stack);\n        free(pin->actions);\n        free(pin->action_set);\n    }\n}\n\n/* Converts an OFPT_PACKET_OUT in 'opo' into an abstract ofputil_packet_out in\n * 'po'.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of the packet out\n * message's actions.  The caller must initialize 'ofpacts' and retains\n * ownership of it.  'po->ofpacts' will point into the 'ofpacts' buffer.\n *\n * 'po->packet' refers to the packet data in 'oh', so the buffer containing\n * 'oh' must not be destroyed while 'po' is being used.\n *\n * Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_packet_out(struct ofputil_packet_out *po,\n                          const struct ofp_header *oh,\n                          struct ofpbuf *ofpacts)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    ofpbuf_clear(ofpacts);\n    if (raw == OFPRAW_OFPT11_PACKET_OUT) {\n        enum ofperr error;\n        const struct ofp11_packet_out *opo = ofpbuf_pull(&b, sizeof *opo);\n\n        po->buffer_id = ntohl(opo->buffer_id);\n        error = ofputil_port_from_ofp11(opo->in_port, &po->in_port);\n        if (error) {\n            return error;\n        }\n\n        error = ofpacts_pull_openflow_actions(&b, ntohs(opo->actions_len),\n                                              oh->version, NULL, NULL,\n                                              ofpacts);\n        if (error) {\n            return error;\n        }\n    } else if (raw == OFPRAW_OFPT10_PACKET_OUT) {\n        enum ofperr error;\n        const struct ofp10_packet_out *opo = ofpbuf_pull(&b, sizeof *opo);\n\n        po->buffer_id = ntohl(opo->buffer_id);\n        po->in_port = u16_to_ofp(ntohs(opo->in_port));\n\n        error = ofpacts_pull_openflow_actions(&b, ntohs(opo->actions_len),\n                                              oh->version, NULL, NULL,\n                                              ofpacts);\n        if (error) {\n            return error;\n        }\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (ofp_to_u16(po->in_port) >= ofp_to_u16(OFPP_MAX)\n        && po->in_port != OFPP_LOCAL\n        && po->in_port != OFPP_NONE && po->in_port != OFPP_CONTROLLER) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"packet-out has bad input port %#\"PRIx32,\n                     po->in_port);\n        return OFPERR_OFPBRC_BAD_PORT;\n    }\n\n    po->ofpacts = ofpacts->data;\n    po->ofpacts_len = ofpacts->size;\n\n    if (po->buffer_id == UINT32_MAX) {\n        po->packet = b.data;\n        po->packet_len = b.size;\n    } else {\n        po->packet = NULL;\n        po->packet_len = 0;\n    }\n\n    return 0;\n}\n\f\n/* ofputil_phy_port */\n\n/* NETDEV_F_* to and from OFPPF_* and OFPPF10_*. */\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_HD    == OFPPF_10MB_HD);  /* bit 0 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_FD    == OFPPF_10MB_FD);  /* bit 1 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_HD   == OFPPF_100MB_HD); /* bit 2 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_FD   == OFPPF_100MB_FD); /* bit 3 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_HD     == OFPPF_1GB_HD);   /* bit 4 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_FD     == OFPPF_1GB_FD);   /* bit 5 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10GB_FD    == OFPPF_10GB_FD);  /* bit 6 */\n\n/* NETDEV_F_ bits 11...15 are OFPPF10_ bits 7...11: */\nBUILD_ASSERT_DECL((int) NETDEV_F_COPPER == (OFPPF10_COPPER << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_FIBER == (OFPPF10_FIBER << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_AUTONEG == (OFPPF10_AUTONEG << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE == (OFPPF10_PAUSE << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE_ASYM == (OFPPF10_PAUSE_ASYM << 4));\n\nstatic enum netdev_features\nnetdev_port_features_from_ofp10(ovs_be32 ofp10_)\n{\n    uint32_t ofp10 = ntohl(ofp10_);\n    return (ofp10 & 0x7f) | ((ofp10 & 0xf80) << 4);\n}\n\nstatic ovs_be32\nnetdev_port_features_to_ofp10(enum netdev_features features)\n{\n    return htonl((features & 0x7f) | ((features & 0xf800) >> 4));\n}\n\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_HD    == OFPPF_10MB_HD);     /* bit 0 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_FD    == OFPPF_10MB_FD);     /* bit 1 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_HD   == OFPPF_100MB_HD);    /* bit 2 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_FD   == OFPPF_100MB_FD);    /* bit 3 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_HD     == OFPPF_1GB_HD);      /* bit 4 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_FD     == OFPPF_1GB_FD);      /* bit 5 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10GB_FD    == OFPPF_10GB_FD);     /* bit 6 */\nBUILD_ASSERT_DECL((int) NETDEV_F_40GB_FD    == OFPPF11_40GB_FD);   /* bit 7 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100GB_FD   == OFPPF11_100GB_FD);  /* bit 8 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1TB_FD     == OFPPF11_1TB_FD);    /* bit 9 */\nBUILD_ASSERT_DECL((int) NETDEV_F_OTHER      == OFPPF11_OTHER);     /* bit 10 */\nBUILD_ASSERT_DECL((int) NETDEV_F_COPPER     == OFPPF11_COPPER);    /* bit 11 */\nBUILD_ASSERT_DECL((int) NETDEV_F_FIBER      == OFPPF11_FIBER);     /* bit 12 */\nBUILD_ASSERT_DECL((int) NETDEV_F_AUTONEG    == OFPPF11_AUTONEG);   /* bit 13 */\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE      == OFPPF11_PAUSE);     /* bit 14 */\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE_ASYM == OFPPF11_PAUSE_ASYM);/* bit 15 */\n\nstatic enum netdev_features\nnetdev_port_features_from_ofp11(ovs_be32 ofp11)\n{\n    return ntohl(ofp11) & 0xffff;\n}\n\nstatic ovs_be32\nnetdev_port_features_to_ofp11(enum netdev_features features)\n{\n    return htonl(features & 0xffff);\n}\n\nstatic enum ofperr\nofputil_decode_ofp10_phy_port(struct ofputil_phy_port *pp,\n                              const struct ofp10_phy_port *opp)\n{\n    pp->port_no = u16_to_ofp(ntohs(opp->port_no));\n    pp->hw_addr = opp->hw_addr;\n    ovs_strlcpy(pp->name, opp->name, OFP_MAX_PORT_NAME_LEN);\n\n    pp->config = ntohl(opp->config) & OFPPC10_ALL;\n    pp->state = ntohl(opp->state) & OFPPS10_ALL;\n\n    pp->curr = netdev_port_features_from_ofp10(opp->curr);\n    pp->advertised = netdev_port_features_from_ofp10(opp->advertised);\n    pp->supported = netdev_port_features_from_ofp10(opp->supported);\n    pp->peer = netdev_port_features_from_ofp10(opp->peer);\n\n    pp->curr_speed = netdev_features_to_bps(pp->curr, 0) / 1000;\n    pp->max_speed = netdev_features_to_bps(pp->supported, 0) / 1000;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_decode_ofp11_port(struct ofputil_phy_port *pp,\n                          const struct ofp11_port *op)\n{\n    enum ofperr error;\n\n    error = ofputil_port_from_ofp11(op->port_no, &pp->port_no);\n    if (error) {\n        return error;\n    }\n    pp->hw_addr = op->hw_addr;\n    ovs_strlcpy(pp->name, op->name, OFP_MAX_PORT_NAME_LEN);\n\n    pp->config = ntohl(op->config) & OFPPC11_ALL;\n    pp->state = ntohl(op->state) & OFPPS11_ALL;\n\n    pp->curr = netdev_port_features_from_ofp11(op->curr);\n    pp->advertised = netdev_port_features_from_ofp11(op->advertised);\n    pp->supported = netdev_port_features_from_ofp11(op->supported);\n    pp->peer = netdev_port_features_from_ofp11(op->peer);\n\n    pp->curr_speed = ntohl(op->curr_speed);\n    pp->max_speed = ntohl(op->max_speed);\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_ofp14_port_ethernet_property(const struct ofpbuf *payload,\n                                   struct ofputil_phy_port *pp)\n{\n    struct ofp14_port_desc_prop_ethernet *eth = payload->data;\n\n    if (payload->size != sizeof *eth) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    pp->curr = netdev_port_features_from_ofp11(eth->curr);\n    pp->advertised = netdev_port_features_from_ofp11(eth->advertised);\n    pp->supported = netdev_port_features_from_ofp11(eth->supported);\n    pp->peer = netdev_port_features_from_ofp11(eth->peer);\n\n    pp->curr_speed = ntohl(eth->curr_speed);\n    pp->max_speed = ntohl(eth->max_speed);\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_pull_ofp14_port(struct ofputil_phy_port *pp, struct ofpbuf *msg)\n{\n    struct ofp14_port *op = ofpbuf_try_pull(msg, sizeof *op);\n    if (!op) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    size_t len = ntohs(op->length);\n    if (len < sizeof *op || len - sizeof *op > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= sizeof *op;\n\n    enum ofperr error = ofputil_port_from_ofp11(op->port_no, &pp->port_no);\n    if (error) {\n        return error;\n    }\n    pp->hw_addr = op->hw_addr;\n    ovs_strlcpy(pp->name, op->name, OFP_MAX_PORT_NAME_LEN);\n\n    pp->config = ntohl(op->config) & OFPPC11_ALL;\n    pp->state = ntohl(op->state) & OFPPS11_ALL;\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPPDPT14_ETHERNET:\n            error = parse_ofp14_port_ethernet_property(&payload, pp);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(true, \"port\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\nstatic void\nofputil_encode_ofp10_phy_port(const struct ofputil_phy_port *pp,\n                              struct ofp10_phy_port *opp)\n{\n    memset(opp, 0, sizeof *opp);\n\n    opp->port_no = htons(ofp_to_u16(pp->port_no));\n    opp->hw_addr = pp->hw_addr;\n    ovs_strlcpy(opp->name, pp->name, OFP_MAX_PORT_NAME_LEN);\n\n    opp->config = htonl(pp->config & OFPPC10_ALL);\n    opp->state = htonl(pp->state & OFPPS10_ALL);\n\n    opp->curr = netdev_port_features_to_ofp10(pp->curr);\n    opp->advertised = netdev_port_features_to_ofp10(pp->advertised);\n    opp->supported = netdev_port_features_to_ofp10(pp->supported);\n    opp->peer = netdev_port_features_to_ofp10(pp->peer);\n}\n\nstatic void\nofputil_encode_ofp11_port(const struct ofputil_phy_port *pp,\n                          struct ofp11_port *op)\n{\n    memset(op, 0, sizeof *op);\n\n    op->port_no = ofputil_port_to_ofp11(pp->port_no);\n    op->hw_addr = pp->hw_addr;\n    ovs_strlcpy(op->name, pp->name, OFP_MAX_PORT_NAME_LEN);\n\n    op->config = htonl(pp->config & OFPPC11_ALL);\n    op->state = htonl(pp->state & OFPPS11_ALL);\n\n    op->curr = netdev_port_features_to_ofp11(pp->curr);\n    op->advertised = netdev_port_features_to_ofp11(pp->advertised);\n    op->supported = netdev_port_features_to_ofp11(pp->supported);\n    op->peer = netdev_port_features_to_ofp11(pp->peer);\n\n    op->curr_speed = htonl(pp->curr_speed);\n    op->max_speed = htonl(pp->max_speed);\n}\n\nstatic void\nofputil_put_ofp14_port(const struct ofputil_phy_port *pp,\n                       struct ofpbuf *b)\n{\n    struct ofp14_port *op;\n    struct ofp14_port_desc_prop_ethernet *eth;\n\n    ofpbuf_prealloc_tailroom(b, sizeof *op + sizeof *eth);\n\n    op = ofpbuf_put_zeros(b, sizeof *op);\n    op->port_no = ofputil_port_to_ofp11(pp->port_no);\n    op->length = htons(sizeof *op + sizeof *eth);\n    op->hw_addr = pp->hw_addr;\n    ovs_strlcpy(op->name, pp->name, sizeof op->name);\n    op->config = htonl(pp->config & OFPPC11_ALL);\n    op->state = htonl(pp->state & OFPPS11_ALL);\n\n    eth = ofpprop_put_zeros(b, OFPPDPT14_ETHERNET, sizeof *eth);\n    eth->curr = netdev_port_features_to_ofp11(pp->curr);\n    eth->advertised = netdev_port_features_to_ofp11(pp->advertised);\n    eth->supported = netdev_port_features_to_ofp11(pp->supported);\n    eth->peer = netdev_port_features_to_ofp11(pp->peer);\n    eth->curr_speed = htonl(pp->curr_speed);\n    eth->max_speed = htonl(pp->max_speed);\n}\n\nstatic void\nofputil_put_phy_port(enum ofp_version ofp_version,\n                     const struct ofputil_phy_port *pp, struct ofpbuf *b)\n{\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_phy_port *opp = ofpbuf_put_uninit(b, sizeof *opp);\n        ofputil_encode_ofp10_phy_port(pp, opp);\n        break;\n    }\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        struct ofp11_port *op = ofpbuf_put_uninit(b, sizeof *op);\n        ofputil_encode_ofp11_port(pp, op);\n        break;\n    }\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_put_ofp14_port(pp, b);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nenum ofperr\nofputil_decode_port_desc_stats_request(const struct ofp_header *request,\n                                       ofp_port_t *port)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(request,\n                                               ntohs(request->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPST10_PORT_DESC_REQUEST) {\n        *port = OFPP_ANY;\n        return 0;\n    } else if (raw == OFPRAW_OFPST15_PORT_DESC_REQUEST) {\n        ovs_be32 *ofp11_port;\n\n        ofp11_port = ofpbuf_pull(&b, sizeof *ofp11_port);\n        return ofputil_port_from_ofp11(*ofp11_port, port);\n    } else {\n        OVS_NOT_REACHED();\n    }\n}\n\nstruct ofpbuf *\nofputil_encode_port_desc_stats_request(enum ofp_version ofp_version,\n                                       ofp_port_t port)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST10_PORT_DESC_REQUEST,\n                               ofp_version, 0);\n        break;\n    case OFP15_VERSION:\n    case OFP16_VERSION:{\n        struct ofp15_port_desc_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST15_PORT_DESC_REQUEST,\n                               ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = ofputil_port_to_ofp11(port);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nvoid\nofputil_append_port_desc_stats_reply(const struct ofputil_phy_port *pp,\n                                     struct ovs_list *replies)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = reply->size;\n\n    ofputil_put_phy_port(ofpmp_version(replies), pp, reply);\n    ofpmp_postappend(replies, start_ofs);\n}\n\f\n/* ofputil_switch_config */\n\n/* Decodes 'oh', which must be an OFPT_GET_CONFIG_REPLY or OFPT_SET_CONFIG\n * message, into 'config'.  Returns false if 'oh' contained any flags that\n * aren't specified in its version of OpenFlow, true otherwise. */\nstatic bool\nofputil_decode_switch_config(const struct ofp_header *oh,\n                             struct ofputil_switch_config *config)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    const struct ofp_switch_config *osc = ofpbuf_pull(&b, sizeof *osc);\n    config->frag = ntohs(osc->flags) & OFPC_FRAG_MASK;\n    config->miss_send_len = ntohs(osc->miss_send_len);\n\n    ovs_be16 valid_mask = htons(OFPC_FRAG_MASK);\n    if (oh->version < OFP13_VERSION) {\n        const ovs_be16 ttl_bit = htons(OFPC_INVALID_TTL_TO_CONTROLLER);\n        valid_mask |= ttl_bit;\n        config->invalid_ttl_to_controller = (osc->flags & ttl_bit) != 0;\n    } else {\n        config->invalid_ttl_to_controller = -1;\n    }\n\n    return !(osc->flags & ~valid_mask);\n}\n\nvoid\nofputil_decode_get_config_reply(const struct ofp_header *oh,\n                                struct ofputil_switch_config *config)\n{\n    ofputil_decode_switch_config(oh, config);\n}\n\nenum ofperr\nofputil_decode_set_config(const struct ofp_header *oh,\n                          struct ofputil_switch_config *config)\n{\n    return (ofputil_decode_switch_config(oh, config)\n            ? 0\n            : OFPERR_OFPSCFC_BAD_FLAGS);\n}\n\nstatic struct ofpbuf *\nofputil_put_switch_config(const struct ofputil_switch_config *config,\n                          struct ofpbuf *b)\n{\n    const struct ofp_header *oh = b->data;\n    struct ofp_switch_config *osc = ofpbuf_put_zeros(b, sizeof *osc);\n    osc->flags = htons(config->frag);\n    if (config->invalid_ttl_to_controller > 0 && oh->version < OFP13_VERSION) {\n        osc->flags |= htons(OFPC_INVALID_TTL_TO_CONTROLLER);\n    }\n    osc->miss_send_len = htons(config->miss_send_len);\n    return b;\n}\n\nstruct ofpbuf *\nofputil_encode_get_config_reply(const struct ofp_header *request,\n                                const struct ofputil_switch_config *config)\n{\n    struct ofpbuf *b = ofpraw_alloc_reply(OFPRAW_OFPT_GET_CONFIG_REPLY,\n                                          request, 0);\n    return ofputil_put_switch_config(config, b);\n}\n\nstruct ofpbuf *\nofputil_encode_set_config(const struct ofputil_switch_config *config,\n                          enum ofp_version version)\n{\n    struct ofpbuf *b = ofpraw_alloc(OFPRAW_OFPT_SET_CONFIG, version, 0);\n    return ofputil_put_switch_config(config, b);\n}\n\f\n/* ofputil_switch_features */\n\n#define OFPC_COMMON (OFPC_FLOW_STATS | OFPC_TABLE_STATS | OFPC_PORT_STATS | \\\n                     OFPC_IP_REASM | OFPC_QUEUE_STATS)\nBUILD_ASSERT_DECL((int) OFPUTIL_C_FLOW_STATS == OFPC_FLOW_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_TABLE_STATS == OFPC_TABLE_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_PORT_STATS == OFPC_PORT_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_IP_REASM == OFPC_IP_REASM);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_QUEUE_STATS == OFPC_QUEUE_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_ARP_MATCH_IP == OFPC_ARP_MATCH_IP);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_PORT_BLOCKED == OFPC12_PORT_BLOCKED);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_BUNDLES == OFPC14_BUNDLES);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_FLOW_MONITORING == OFPC14_FLOW_MONITORING);\n\nstatic uint32_t\nofputil_capabilities_mask(enum ofp_version ofp_version)\n{\n    /* Handle capabilities whose bit is unique for all OpenFlow versions */\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n        return OFPC_COMMON | OFPC_ARP_MATCH_IP;\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n        return OFPC_COMMON | OFPC12_PORT_BLOCKED;\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return OFPC_COMMON | OFPC12_PORT_BLOCKED | OFPC14_BUNDLES\n            | OFPC14_FLOW_MONITORING;\n    default:\n        /* Caller needs to check osf->header.version itself */\n        return 0;\n    }\n}\n\n/* Pulls an OpenFlow \"switch_features\" structure from 'b' and decodes it into\n * an abstract representation in '*features', readying 'b' to iterate over the\n * OpenFlow port structures following 'osf' with later calls to\n * ofputil_pull_phy_port().  Returns 0 if successful, otherwise an OFPERR_*\n * value.  */\nenum ofperr\nofputil_pull_switch_features(struct ofpbuf *b,\n                             struct ofputil_switch_features *features)\n{\n    const struct ofp_header *oh = b->data;\n    enum ofpraw raw = ofpraw_pull_assert(b);\n    const struct ofp_switch_features *osf = ofpbuf_pull(b, sizeof *osf);\n    features->datapath_id = ntohll(osf->datapath_id);\n    features->n_buffers = ntohl(osf->n_buffers);\n    features->n_tables = osf->n_tables;\n    features->auxiliary_id = 0;\n\n    features->capabilities = ntohl(osf->capabilities) &\n        ofputil_capabilities_mask(oh->version);\n\n    if (raw == OFPRAW_OFPT10_FEATURES_REPLY) {\n        if (osf->capabilities & htonl(OFPC10_STP)) {\n            features->capabilities |= OFPUTIL_C_STP;\n        }\n        features->ofpacts = ofpact_bitmap_from_openflow(osf->actions,\n                                                        OFP10_VERSION);\n    } else if (raw == OFPRAW_OFPT11_FEATURES_REPLY\n               || raw == OFPRAW_OFPT13_FEATURES_REPLY) {\n        if (osf->capabilities & htonl(OFPC11_GROUP_STATS)) {\n            features->capabilities |= OFPUTIL_C_GROUP_STATS;\n        }\n        features->ofpacts = 0;\n        if (raw == OFPRAW_OFPT13_FEATURES_REPLY) {\n            features->auxiliary_id = osf->auxiliary_id;\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n\n    return 0;\n}\n\n/* In OpenFlow 1.0, 1.1, and 1.2, an OFPT_FEATURES_REPLY message lists all the\n * switch's ports, unless there are too many to fit.  In OpenFlow 1.3 and\n * later, an OFPT_FEATURES_REPLY does not list ports at all.\n *\n * Given a buffer 'b' that contains a Features Reply message, this message\n * checks if it contains a complete list of the switch's ports.  Returns true,\n * if so.  Returns false if the list is missing (OF1.3+) or incomplete\n * (OF1.0/1.1/1.2), and in the latter case removes all of the ports from the\n * message.\n *\n * When this function returns false, the caller should send an OFPST_PORT_DESC\n * stats request to get the ports. */\nbool\nofputil_switch_features_has_ports(struct ofpbuf *b)\n{\n    struct ofp_header *oh = b->data;\n    size_t phy_port_size;\n\n    if (oh->version >= OFP13_VERSION) {\n        /* OpenFlow 1.3+ never has ports in the feature reply. */\n        return false;\n    }\n\n    phy_port_size = (oh->version == OFP10_VERSION\n                     ? sizeof(struct ofp10_phy_port)\n                     : sizeof(struct ofp11_port));\n    if (ntohs(oh->length) + phy_port_size <= UINT16_MAX) {\n        /* There's room for additional ports in the feature reply.\n         * Assume that the list is complete. */\n        return true;\n    }\n\n    /* The feature reply has no room for more ports.  Probably the list is\n     * truncated.  Drop the ports and tell the caller to retrieve them with\n     * OFPST_PORT_DESC. */\n    b->size = sizeof *oh + sizeof(struct ofp_switch_features);\n    ofpmsg_update_length(b);\n    return false;\n}\n\n/* Returns a buffer owned by the caller that encodes 'features' in the format\n * required by 'protocol' with the given 'xid'.  The caller should append port\n * information to the buffer with subsequent calls to\n * ofputil_put_switch_features_port(). */\nstruct ofpbuf *\nofputil_encode_switch_features(const struct ofputil_switch_features *features,\n                               enum ofputil_protocol protocol, ovs_be32 xid)\n{\n    struct ofp_switch_features *osf;\n    struct ofpbuf *b;\n    enum ofp_version version;\n    enum ofpraw raw;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    switch (version) {\n    case OFP10_VERSION:\n        raw = OFPRAW_OFPT10_FEATURES_REPLY;\n        break;\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        raw = OFPRAW_OFPT11_FEATURES_REPLY;\n        break;\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        raw = OFPRAW_OFPT13_FEATURES_REPLY;\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n    b = ofpraw_alloc_xid(raw, version, xid, 0);\n    osf = ofpbuf_put_zeros(b, sizeof *osf);\n    osf->datapath_id = htonll(features->datapath_id);\n    osf->n_buffers = htonl(features->n_buffers);\n    osf->n_tables = features->n_tables;\n\n    osf->capabilities = htonl(features->capabilities &\n                              ofputil_capabilities_mask(version));\n    switch (version) {\n    case OFP10_VERSION:\n        if (features->capabilities & OFPUTIL_C_STP) {\n            osf->capabilities |= htonl(OFPC10_STP);\n        }\n        osf->actions = ofpact_bitmap_to_openflow(features->ofpacts,\n                                                 OFP10_VERSION);\n        break;\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        osf->auxiliary_id = features->auxiliary_id;\n        /* fall through */\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        if (features->capabilities & OFPUTIL_C_GROUP_STATS) {\n            osf->capabilities |= htonl(OFPC11_GROUP_STATS);\n        }\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return b;\n}\n\n/* Encodes 'pp' into the format required by the switch_features message already\n * in 'b', which should have been returned by ofputil_encode_switch_features(),\n * and appends the encoded version to 'b'. */\nvoid\nofputil_put_switch_features_port(const struct ofputil_phy_port *pp,\n                                 struct ofpbuf *b)\n{\n    const struct ofp_header *oh = b->data;\n\n    if (oh->version < OFP13_VERSION) {\n        /* Try adding a port description to the message, but drop it again if\n         * the buffer overflows.  (This possibility for overflow is why\n         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */\n        size_t start_ofs = b->size;\n        ofputil_put_phy_port(oh->version, pp, b);\n        if (b->size > UINT16_MAX) {\n            b->size = start_ofs;\n        }\n    }\n}\n\f\n/* ofputil_port_status */\n\n/* Decodes the OpenFlow \"port status\" message in '*ops' into an abstract form\n * in '*ps'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_port_status(const struct ofp_header *oh,\n                           struct ofputil_port_status *ps)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    const struct ofp_port_status *ops = ofpbuf_pull(&b, sizeof *ops);\n    if (ops->reason != OFPPR_ADD &&\n        ops->reason != OFPPR_DELETE &&\n        ops->reason != OFPPR_MODIFY) {\n        return OFPERR_NXBRC_BAD_REASON;\n    }\n    ps->reason = ops->reason;\n\n    int retval = ofputil_pull_phy_port(oh->version, &b, &ps->desc);\n    ovs_assert(retval != EOF);\n    return retval;\n}\n\n/* Converts the abstract form of a \"port status\" message in '*ps' into an\n * OpenFlow message suitable for 'protocol', and returns that encoded form in\n * a buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_port_status(const struct ofputil_port_status *ps,\n                           enum ofputil_protocol protocol)\n{\n    struct ofp_port_status *ops;\n    struct ofpbuf *b;\n    enum ofp_version version;\n    enum ofpraw raw;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    switch (version) {\n    case OFP10_VERSION:\n        raw = OFPRAW_OFPT10_PORT_STATUS;\n        break;\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n        raw = OFPRAW_OFPT11_PORT_STATUS;\n        break;\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        raw = OFPRAW_OFPT14_PORT_STATUS;\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    b = ofpraw_alloc_xid(raw, version, htonl(0), 0);\n    ops = ofpbuf_put_zeros(b, sizeof *ops);\n    ops->reason = ps->reason;\n    ofputil_put_phy_port(version, &ps->desc, b);\n    ofpmsg_update_length(b);\n    return b;\n}\n\n/* ofputil_port_mod */\n\nstatic enum ofperr\nparse_port_mod_ethernet_property(struct ofpbuf *property,\n                                 struct ofputil_port_mod *pm)\n{\n    ovs_be32 advertise;\n    enum ofperr error;\n\n    error = ofpprop_parse_be32(property, &advertise);\n    if (!error) {\n        pm->advertise = netdev_port_features_from_ofp11(advertise);\n    }\n    return error;\n}\n\n/* Decodes the OpenFlow \"port mod\" message in '*oh' into an abstract form in\n * '*pm'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_port_mod(const struct ofp_header *oh,\n                        struct ofputil_port_mod *pm, bool loose)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT10_PORT_MOD) {\n        const struct ofp10_port_mod *opm = b.data;\n\n        pm->port_no = u16_to_ofp(ntohs(opm->port_no));\n        pm->hw_addr = opm->hw_addr;\n        pm->config = ntohl(opm->config) & OFPPC10_ALL;\n        pm->mask = ntohl(opm->mask) & OFPPC10_ALL;\n        pm->advertise = netdev_port_features_from_ofp10(opm->advertise);\n    } else if (raw == OFPRAW_OFPT11_PORT_MOD) {\n        const struct ofp11_port_mod *opm = b.data;\n        enum ofperr error;\n\n        error = ofputil_port_from_ofp11(opm->port_no, &pm->port_no);\n        if (error) {\n            return error;\n        }\n\n        pm->hw_addr = opm->hw_addr;\n        pm->config = ntohl(opm->config) & OFPPC11_ALL;\n        pm->mask = ntohl(opm->mask) & OFPPC11_ALL;\n        pm->advertise = netdev_port_features_from_ofp11(opm->advertise);\n    } else if (raw == OFPRAW_OFPT14_PORT_MOD) {\n        const struct ofp14_port_mod *opm = ofpbuf_pull(&b, sizeof *opm);\n        enum ofperr error;\n\n        memset(pm, 0, sizeof *pm);\n\n        error = ofputil_port_from_ofp11(opm->port_no, &pm->port_no);\n        if (error) {\n            return error;\n        }\n\n        pm->hw_addr = opm->hw_addr;\n        pm->config = ntohl(opm->config) & OFPPC11_ALL;\n        pm->mask = ntohl(opm->mask) & OFPPC11_ALL;\n\n        while (b.size > 0) {\n            struct ofpbuf property;\n            enum ofperr error;\n            uint64_t type;\n\n            error = ofpprop_pull(&b, &property, &type);\n            if (error) {\n                return error;\n            }\n\n            switch (type) {\n            case OFPPMPT14_ETHERNET:\n                error = parse_port_mod_ethernet_property(&property, pm);\n                break;\n\n            default:\n                error = OFPPROP_UNKNOWN(loose, \"port_mod\", type);\n                break;\n            }\n\n            if (error) {\n                return error;\n            }\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_TYPE;\n    }\n\n    pm->config &= pm->mask;\n    return 0;\n}\n\n/* Converts the abstract form of a \"port mod\" message in '*pm' into an OpenFlow\n * message suitable for 'protocol', and returns that encoded form in a buffer\n * owned by the caller. */\nstruct ofpbuf *\nofputil_encode_port_mod(const struct ofputil_port_mod *pm,\n                        enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *b;\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_port_mod *opm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT10_PORT_MOD, ofp_version, 0);\n        opm = ofpbuf_put_zeros(b, sizeof *opm);\n        opm->port_no = htons(ofp_to_u16(pm->port_no));\n        opm->hw_addr = pm->hw_addr;\n        opm->config = htonl(pm->config & OFPPC10_ALL);\n        opm->mask = htonl(pm->mask & OFPPC10_ALL);\n        opm->advertise = netdev_port_features_to_ofp10(pm->advertise);\n        break;\n    }\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        struct ofp11_port_mod *opm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT11_PORT_MOD, ofp_version, 0);\n        opm = ofpbuf_put_zeros(b, sizeof *opm);\n        opm->port_no = ofputil_port_to_ofp11(pm->port_no);\n        opm->hw_addr = pm->hw_addr;\n        opm->config = htonl(pm->config & OFPPC11_ALL);\n        opm->mask = htonl(pm->mask & OFPPC11_ALL);\n        opm->advertise = netdev_port_features_to_ofp11(pm->advertise);\n        break;\n    }\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp14_port_mod *opm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT14_PORT_MOD, ofp_version, 0);\n        opm = ofpbuf_put_zeros(b, sizeof *opm);\n        opm->port_no = ofputil_port_to_ofp11(pm->port_no);\n        opm->hw_addr = pm->hw_addr;\n        opm->config = htonl(pm->config & OFPPC11_ALL);\n        opm->mask = htonl(pm->mask & OFPPC11_ALL);\n\n        if (pm->advertise) {\n            ofpprop_put_be32(b, OFPPMPT14_ETHERNET,\n                             netdev_port_features_to_ofp11(pm->advertise));\n        }\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return b;\n}\n\f\n/* Table features. */\n\nstatic enum ofperr\npull_table_feature_property(struct ofpbuf *msg, struct ofpbuf *payload,\n                            uint64_t *typep)\n{\n    enum ofperr error;\n\n    error = ofpprop_pull(msg, payload, typep);\n    if (payload && !error) {\n        ofpbuf_pull(payload, (char *)payload->msg - (char *)payload->header);\n    }\n    return error;\n}\n\nstatic enum ofperr\nparse_action_bitmap(struct ofpbuf *payload, enum ofp_version ofp_version,\n                    uint64_t *ofpacts)\n{\n    uint32_t types = 0;\n\n    while (payload->size > 0) {\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &type);\n        if (error) {\n            return error;\n        }\n        if (type < CHAR_BIT * sizeof types) {\n            types |= 1u << type;\n        }\n    }\n\n    *ofpacts = ofpact_bitmap_from_openflow(htonl(types), ofp_version);\n    return 0;\n}\n\nstatic enum ofperr\nparse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)\n{\n    *insts = 0;\n    while (payload->size > 0) {\n        enum ovs_instruction_type inst;\n        enum ofperr error;\n        uint64_t ofpit;\n\n        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.\n         * It seems clear that they aren't padded to 8 bytes, though, because\n         * both standards say that \"non-experimenter instructions are 4 bytes\"\n         * and do not mention any padding before the first instruction ID.\n         * (There wouldn't be any point in padding to 8 bytes if the IDs were\n         * aligned on an odd 4-byte boundary.)\n         *\n         * Anyway, we just assume they're all glommed together on byte\n         * boundaries. */\n        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);\n        if (error) {\n            return error;\n        }\n\n        error = ovs_instruction_type_from_inst_type(&inst, ofpit);\n        if (!error) {\n            *insts |= 1u << inst;\n        } else if (!loose) {\n            return error;\n        }\n    }\n    return 0;\n}\n\nstatic enum ofperr\nparse_table_features_next_table(struct ofpbuf *payload,\n                                unsigned long int *next_tables)\n{\n    size_t i;\n\n    memset(next_tables, 0, bitmap_n_bytes(255));\n    for (i = 0; i < payload->size; i++) {\n        uint8_t id = ((const uint8_t *) payload->data)[i];\n        if (id >= 255) {\n            return OFPERR_OFPBPC_BAD_VALUE;\n        }\n        bitmap_set1(next_tables, id);\n    }\n    return 0;\n}\n\nstatic enum ofperr\nparse_oxms(struct ofpbuf *payload, bool loose,\n           struct mf_bitmap *exactp, struct mf_bitmap *maskedp)\n{\n    struct mf_bitmap exact = MF_BITMAP_INITIALIZER;\n    struct mf_bitmap masked = MF_BITMAP_INITIALIZER;\n\n    while (payload->size > 0) {\n        const struct mf_field *field;\n        enum ofperr error;\n        bool hasmask;\n\n        error = nx_pull_header(payload, NULL, &field, &hasmask);\n        if (!error) {\n            bitmap_set1(hasmask ? masked.bm : exact.bm, field->id);\n        } else if (error != OFPERR_OFPBMC_BAD_FIELD || !loose) {\n            return error;\n        }\n    }\n    if (exactp) {\n        *exactp = exact;\n    } else if (!bitmap_is_all_zeros(exact.bm, MFF_N_IDS)) {\n        return OFPERR_OFPBMC_BAD_MASK;\n    }\n    if (maskedp) {\n        *maskedp = masked;\n    } else if (!bitmap_is_all_zeros(masked.bm, MFF_N_IDS)) {\n        return OFPERR_OFPBMC_BAD_MASK;\n    }\n    return 0;\n}\n\n/* Converts an OFPMP_TABLE_FEATURES request or reply in 'msg' into an abstract\n * ofputil_table_features in 'tf'.\n *\n * If 'loose' is true, this function ignores properties and values that it does\n * not understand, as a controller would want to do when interpreting\n * capabilities provided by a switch.  If 'loose' is false, this function\n * treats unknown properties and values as an error, as a switch would want to\n * do when interpreting a configuration request made by a controller.\n *\n * A single OpenFlow message can specify features for multiple tables.  Calling\n * this function multiple times for a single 'msg' iterates through the tables\n * in the message.  The caller must initially leave 'msg''s layer pointers null\n * and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no tables were left in this 'msg', otherwise\n * a positive \"enum ofperr\" value. */\nint\nofputil_decode_table_features(struct ofpbuf *msg,\n                              struct ofputil_table_features *tf, bool loose)\n{\n    memset(tf, 0, sizeof *tf);\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    const struct ofp_header *oh = msg->header;\n    struct ofp13_table_features *otf = msg->data;\n    if (msg->size < sizeof *otf) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    unsigned int len = ntohs(otf->length);\n    if (len < sizeof *otf || len % 8 || len > msg->size) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    tf->table_id = otf->table_id;\n    if (tf->table_id == OFPTT_ALL) {\n        return OFPERR_OFPTFFC_BAD_TABLE;\n    }\n\n    ovs_strlcpy(tf->name, otf->name, OFP_MAX_TABLE_NAME_LEN);\n    tf->metadata_match = otf->metadata_match;\n    tf->metadata_write = otf->metadata_write;\n    tf->miss_config = OFPUTIL_TABLE_MISS_DEFAULT;\n    if (oh->version >= OFP14_VERSION) {\n        uint32_t caps = ntohl(otf->capabilities);\n        tf->supports_eviction = (caps & OFPTC14_EVICTION) != 0;\n        tf->supports_vacancy_events = (caps & OFPTC14_VACANCY_EVENTS) != 0;\n    } else {\n        tf->supports_eviction = -1;\n        tf->supports_vacancy_events = -1;\n    }\n    tf->max_entries = ntohl(otf->max_entries);\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    ofpbuf_pull(&properties, sizeof *otf);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = pull_table_feature_property(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch ((enum ofp13_table_feature_prop_type) type) {\n        case OFPTFPT13_INSTRUCTIONS:\n            error = parse_instruction_ids(&payload, loose,\n                                          &tf->nonmiss.instructions);\n            break;\n        case OFPTFPT13_INSTRUCTIONS_MISS:\n            error = parse_instruction_ids(&payload, loose,\n                                          &tf->miss.instructions);\n            break;\n\n        case OFPTFPT13_NEXT_TABLES:\n            error = parse_table_features_next_table(&payload,\n                                                    tf->nonmiss.next);\n            break;\n        case OFPTFPT13_NEXT_TABLES_MISS:\n            error = parse_table_features_next_table(&payload, tf->miss.next);\n            break;\n\n        case OFPTFPT13_WRITE_ACTIONS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->nonmiss.write.ofpacts);\n            break;\n        case OFPTFPT13_WRITE_ACTIONS_MISS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->miss.write.ofpacts);\n            break;\n\n        case OFPTFPT13_APPLY_ACTIONS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->nonmiss.apply.ofpacts);\n            break;\n        case OFPTFPT13_APPLY_ACTIONS_MISS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->miss.apply.ofpacts);\n            break;\n\n        case OFPTFPT13_MATCH:\n            error = parse_oxms(&payload, loose, &tf->match, &tf->mask);\n            break;\n        case OFPTFPT13_WILDCARDS:\n            error = parse_oxms(&payload, loose, &tf->wildcard, NULL);\n            break;\n\n        case OFPTFPT13_WRITE_SETFIELD:\n            error = parse_oxms(&payload, loose,\n                               &tf->nonmiss.write.set_fields, NULL);\n            break;\n        case OFPTFPT13_WRITE_SETFIELD_MISS:\n            error = parse_oxms(&payload, loose,\n                               &tf->miss.write.set_fields, NULL);\n            break;\n        case OFPTFPT13_APPLY_SETFIELD:\n            error = parse_oxms(&payload, loose,\n                               &tf->nonmiss.apply.set_fields, NULL);\n            break;\n        case OFPTFPT13_APPLY_SETFIELD_MISS:\n            error = parse_oxms(&payload, loose,\n                               &tf->miss.apply.set_fields, NULL);\n            break;\n\n        case OFPTFPT13_EXPERIMENTER:\n        case OFPTFPT13_EXPERIMENTER_MISS:\n        default:\n            error = OFPPROP_UNKNOWN(loose, \"table features\", type);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n    }\n\n    /* Fix inconsistencies:\n     *\n     *     - Turn on 'match' bits that are set in 'mask', because maskable\n     *       fields are matchable.\n     *\n     *     - Turn on 'wildcard' bits that are set in 'mask', because a field\n     *       that is arbitrarily maskable can be wildcarded entirely.\n     *\n     *     - Turn off 'wildcard' bits that are not in 'match', because a field\n     *       must be matchable for it to be meaningfully wildcarded. */\n    bitmap_or(tf->match.bm, tf->mask.bm, MFF_N_IDS);\n    bitmap_or(tf->wildcard.bm, tf->mask.bm, MFF_N_IDS);\n    bitmap_and(tf->wildcard.bm, tf->match.bm, MFF_N_IDS);\n\n    return 0;\n}\n\n/* Encodes and returns a request to obtain the table features of a switch.\n * The message is encoded for OpenFlow version 'ofp_version'. */\nstruct ofpbuf *\nofputil_encode_table_features_request(enum ofp_version ofp_version)\n{\n    struct ofpbuf *request = NULL;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        ovs_fatal(0, \"dump-table-features needs OpenFlow 1.3 or later \"\n                     \"(\\'-O OpenFlow13\\')\");\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST13_TABLE_FEATURES_REQUEST,\n                               ofp_version, 0);\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstatic void\nput_fields_property(struct ofpbuf *reply,\n                    const struct mf_bitmap *fields,\n                    const struct mf_bitmap *masks,\n                    enum ofp13_table_feature_prop_type property,\n                    enum ofp_version version)\n{\n    size_t start_ofs;\n    int field;\n\n    start_ofs = ofpprop_start(reply, property);\n    BITMAP_FOR_EACH_1 (field, MFF_N_IDS, fields->bm) {\n        nx_put_header(reply, field, version,\n                      masks && bitmap_is_set(masks->bm, field));\n    }\n    ofpprop_end(reply, start_ofs);\n}\n\nstatic void\nput_table_action_features(struct ofpbuf *reply,\n                          const struct ofputil_table_action_features *taf,\n                          enum ofp13_table_feature_prop_type actions_type,\n                          enum ofp13_table_feature_prop_type set_fields_type,\n                          int miss_offset, enum ofp_version version)\n{\n    ofpprop_put_bitmap(reply, actions_type + miss_offset,\n                       ntohl(ofpact_bitmap_to_openflow(taf->ofpacts,\n                                                       version)));\n    put_fields_property(reply, &taf->set_fields, NULL,\n                        set_fields_type + miss_offset, version);\n}\n\nstatic void\nput_table_instruction_features(\n    struct ofpbuf *reply, const struct ofputil_table_instruction_features *tif,\n    int miss_offset, enum ofp_version version)\n{\n    size_t start_ofs;\n    uint8_t table_id;\n\n    ofpprop_put_bitmap(reply, OFPTFPT13_INSTRUCTIONS + miss_offset,\n                       ntohl(ovsinst_bitmap_to_openflow(tif->instructions,\n                                                        version)));\n\n    start_ofs = ofpprop_start(reply, OFPTFPT13_NEXT_TABLES + miss_offset);\n    BITMAP_FOR_EACH_1 (table_id, 255, tif->next) {\n        ofpbuf_put(reply, &table_id, 1);\n    }\n    ofpprop_end(reply, start_ofs);\n\n    put_table_action_features(reply, &tif->write,\n                              OFPTFPT13_WRITE_ACTIONS,\n                              OFPTFPT13_WRITE_SETFIELD, miss_offset, version);\n    put_table_action_features(reply, &tif->apply,\n                              OFPTFPT13_APPLY_ACTIONS,\n                              OFPTFPT13_APPLY_SETFIELD, miss_offset, version);\n}\n\nvoid\nofputil_append_table_features_reply(const struct ofputil_table_features *tf,\n                                    struct ovs_list *replies)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    enum ofp_version version = ofpmp_version(replies);\n    size_t start_ofs = reply->size;\n    struct ofp13_table_features *otf;\n\n    otf = ofpbuf_put_zeros(reply, sizeof *otf);\n    otf->table_id = tf->table_id;\n    ovs_strlcpy(otf->name, tf->name, sizeof otf->name);\n    otf->metadata_match = tf->metadata_match;\n    otf->metadata_write = tf->metadata_write;\n    if (version >= OFP14_VERSION) {\n        if (tf->supports_eviction) {\n            otf->capabilities |= htonl(OFPTC14_EVICTION);\n        }\n        if (tf->supports_vacancy_events) {\n            otf->capabilities |= htonl(OFPTC14_VACANCY_EVENTS);\n        }\n    }\n    otf->max_entries = htonl(tf->max_entries);\n\n    put_table_instruction_features(reply, &tf->nonmiss, 0, version);\n    put_table_instruction_features(reply, &tf->miss, 1, version);\n\n    put_fields_property(reply, &tf->match, &tf->mask,\n                        OFPTFPT13_MATCH, version);\n    put_fields_property(reply, &tf->wildcard, NULL,\n                        OFPTFPT13_WILDCARDS, version);\n\n    otf = ofpbuf_at_assert(reply, start_ofs, sizeof *otf);\n    otf->length = htons(reply->size - start_ofs);\n    ofpmp_postappend(replies, start_ofs);\n}\n\nstatic enum ofperr\nparse_table_desc_vacancy_property(struct ofpbuf *property,\n                                  struct ofputil_table_desc *td)\n{\n    struct ofp14_table_mod_prop_vacancy *otv = property->data;\n\n    if (property->size != sizeof *otv) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    td->table_vacancy.vacancy_down = otv->vacancy_down;\n    td->table_vacancy.vacancy_up = otv->vacancy_up;\n    td->table_vacancy.vacancy = otv->vacancy;\n    return 0;\n}\n\n/* Decodes the next OpenFlow \"table desc\" message (of possibly several) from\n * 'msg' into an abstract form in '*td'.  Returns 0 if successful, EOF if the\n * last \"table desc\" in 'msg' was already decoded, otherwise an OFPERR_*\n * value. */\nint\nofputil_decode_table_desc(struct ofpbuf *msg,\n                          struct ofputil_table_desc *td,\n                          enum ofp_version version)\n{\n    memset(td, 0, sizeof *td);\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    struct ofp14_table_desc *otd = ofpbuf_try_pull(msg, sizeof *otd);\n    if (!otd) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFP14_TABLE_DESC reply has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    td->table_id = otd->table_id;\n    size_t length = ntohs(otd->length);\n    if (length < sizeof *otd || length - sizeof *otd > msg->size) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFP14_TABLE_DESC reply claims invalid \"\n                     \"length %\"PRIuSIZE, length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    length -= sizeof *otd;\n\n    td->eviction = ofputil_decode_table_eviction(otd->config, version);\n    td->vacancy = ofputil_decode_table_vacancy(otd->config, version);\n    td->eviction_flags = UINT32_MAX;\n\n    struct ofpbuf properties = ofpbuf_const_initializer(\n        ofpbuf_pull(msg, length), length);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPTMPT14_EVICTION:\n            error = ofpprop_parse_u32(&payload, &td->eviction_flags);\n            break;\n\n        case OFPTMPT14_VACANCY:\n            error = parse_table_desc_vacancy_property(&payload, td);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(true, \"table_desc\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\n/* Encodes and returns a request to obtain description of tables of a switch.\n * The message is encoded for OpenFlow version 'ofp_version'. */\nstruct ofpbuf *\nofputil_encode_table_desc_request(enum ofp_version ofp_version)\n{\n    struct ofpbuf *request = NULL;\n\n    if (ofp_version >= OFP14_VERSION) {\n        request = ofpraw_alloc(OFPRAW_OFPST14_TABLE_DESC_REQUEST,\n                               ofp_version, 0);\n    } else {\n        ovs_fatal(0, \"dump-table-desc needs OpenFlow 1.4 or later \"\n                  \"(\\'-O OpenFlow14\\')\");\n    }\n\n    return request;\n}\n\n/* Function to append Table desc information in a reply list. */\nvoid\nofputil_append_table_desc_reply(const struct ofputil_table_desc *td,\n                                struct ovs_list *replies,\n                                enum ofp_version version)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_otd;\n    struct ofp14_table_desc *otd;\n\n    start_otd = reply->size;\n    ofpbuf_put_zeros(reply, sizeof *otd);\n    if (td->eviction_flags != UINT32_MAX) {\n        ofpprop_put_u32(reply, OFPTMPT14_EVICTION, td->eviction_flags);\n    }\n    if (td->vacancy == OFPUTIL_TABLE_VACANCY_ON) {\n        struct ofp14_table_mod_prop_vacancy *otv;\n\n        otv = ofpprop_put_zeros(reply, OFPTMPT14_VACANCY, sizeof *otv);\n        otv->vacancy_down = td->table_vacancy.vacancy_down;\n        otv->vacancy_up = td->table_vacancy.vacancy_up;\n        otv->vacancy = td->table_vacancy.vacancy;\n    }\n\n    otd = ofpbuf_at_assert(reply, start_otd, sizeof *otd);\n    otd->length = htons(reply->size - start_otd);\n    otd->table_id = td->table_id;\n    otd->config = ofputil_encode_table_config(OFPUTIL_TABLE_MISS_DEFAULT,\n                                              td->eviction, td->vacancy,\n                                              version);\n    ofpmp_postappend(replies, start_otd);\n}\n\n/* This function parses Vacancy property, and decodes the\n * ofp14_table_mod_prop_vacancy in ofputil_table_mod.\n * Returns OFPERR_OFPBPC_BAD_VALUE error code when vacancy_down is\n * greater than vacancy_up and also when current vacancy has non-zero\n * value. Returns 0 on success. */\nstatic enum ofperr\nparse_table_mod_vacancy_property(struct ofpbuf *property,\n                                 struct ofputil_table_mod *tm)\n{\n    struct ofp14_table_mod_prop_vacancy *otv = property->data;\n\n    if (property->size != sizeof *otv) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n    tm->table_vacancy.vacancy_down = otv->vacancy_down;\n    tm->table_vacancy.vacancy_up = otv->vacancy_up;\n    if (tm->table_vacancy.vacancy_down > tm->table_vacancy.vacancy_up) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"Value of vacancy_down is greater than vacancy_up\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    if (tm->table_vacancy.vacancy_down > 100 ||\n        tm->table_vacancy.vacancy_up > 100) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"Vacancy threshold percentage \"\n                    \"should not be greater than 100\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    tm->table_vacancy.vacancy = otv->vacancy;\n    if (tm->table_vacancy.vacancy) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"Vacancy value should be zero for table-mod messages\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    return 0;\n}\n\n/* Given 'config', taken from an OpenFlow 'version' message that specifies\n * table configuration (a table mod, table stats, or table features message),\n * returns the table vacancy configuration that it specifies.\n *\n * Only OpenFlow 1.4 and later specify table vacancy configuration this way,\n * so for other 'version' this function always returns\n * OFPUTIL_TABLE_VACANCY_DEFAULT. */\nstatic enum ofputil_table_vacancy\nofputil_decode_table_vacancy(ovs_be32 config, enum ofp_version version)\n{\n    return (version < OFP14_VERSION ? OFPUTIL_TABLE_VACANCY_DEFAULT\n            : config & htonl(OFPTC14_VACANCY_EVENTS) ? OFPUTIL_TABLE_VACANCY_ON\n            : OFPUTIL_TABLE_VACANCY_OFF);\n}\n\n/* Given 'config', taken from an OpenFlow 'version' message that specifies\n * table configuration (a table mod, table stats, or table features message),\n * returns the table eviction configuration that it specifies.\n *\n * Only OpenFlow 1.4 and later specify table eviction configuration this way,\n * so for other 'version' values this function always returns\n * OFPUTIL_TABLE_EVICTION_DEFAULT. */\nstatic enum ofputil_table_eviction\nofputil_decode_table_eviction(ovs_be32 config, enum ofp_version version)\n{\n    return (version < OFP14_VERSION ? OFPUTIL_TABLE_EVICTION_DEFAULT\n            : config & htonl(OFPTC14_EVICTION) ? OFPUTIL_TABLE_EVICTION_ON\n            : OFPUTIL_TABLE_EVICTION_OFF);\n}\n\n/* Returns a bitmap of OFPTC* values suitable for 'config' fields in various\n * OpenFlow messages of the given 'version', based on the provided 'miss' and\n * 'eviction' values. */\nstatic ovs_be32\nofputil_encode_table_config(enum ofputil_table_miss miss,\n                            enum ofputil_table_eviction eviction,\n                            enum ofputil_table_vacancy vacancy,\n                            enum ofp_version version)\n{\n    uint32_t config = 0;\n    /* Search for \"OFPTC_* Table Configuration\" in the documentation for more\n     * information on the crazy evolution of this field. */\n    switch (version) {\n    case OFP10_VERSION:\n        /* OpenFlow 1.0 didn't have such a field, any value ought to do. */\n        return htonl(0);\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        /* OpenFlow 1.1 and 1.2 define only OFPTC11_TABLE_MISS_*. */\n        switch (miss) {\n        case OFPUTIL_TABLE_MISS_DEFAULT:\n            /* Really this shouldn't be used for encoding (the caller should\n             * provide a specific value) but I can't imagine that defaulting to\n             * the fall-through case here will hurt. */\n        case OFPUTIL_TABLE_MISS_CONTROLLER:\n        default:\n            return htonl(OFPTC11_TABLE_MISS_CONTROLLER);\n        case OFPUTIL_TABLE_MISS_CONTINUE:\n            return htonl(OFPTC11_TABLE_MISS_CONTINUE);\n        case OFPUTIL_TABLE_MISS_DROP:\n            return htonl(OFPTC11_TABLE_MISS_DROP);\n        }\n        OVS_NOT_REACHED();\n\n    case OFP13_VERSION:\n        /* OpenFlow 1.3 removed OFPTC11_TABLE_MISS_* and didn't define any new\n         * flags, so this is correct. */\n        return htonl(0);\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        /* OpenFlow 1.4 introduced OFPTC14_EVICTION and\n         * OFPTC14_VACANCY_EVENTS. */\n        if (eviction == OFPUTIL_TABLE_EVICTION_ON) {\n            config |= OFPTC14_EVICTION;\n        }\n        if (vacancy == OFPUTIL_TABLE_VACANCY_ON) {\n            config |= OFPTC14_VACANCY_EVENTS;\n        }\n        return htonl(config);\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Given 'config', taken from an OpenFlow 'version' message that specifies\n * table configuration (a table mod, table stats, or table features message),\n * returns the table miss configuration that it specifies.\n *\n * Only OpenFlow 1.1 and 1.2 specify table miss configurations this way, so for\n * other 'version' values this function always returns\n * OFPUTIL_TABLE_MISS_DEFAULT. */\nstatic enum ofputil_table_miss\nofputil_decode_table_miss(ovs_be32 config_, enum ofp_version version)\n{\n    uint32_t config = ntohl(config_);\n\n    if (version == OFP11_VERSION || version == OFP12_VERSION) {\n        switch (config & OFPTC11_TABLE_MISS_MASK) {\n        case OFPTC11_TABLE_MISS_CONTROLLER:\n            return OFPUTIL_TABLE_MISS_CONTROLLER;\n\n        case OFPTC11_TABLE_MISS_CONTINUE:\n            return OFPUTIL_TABLE_MISS_CONTINUE;\n\n        case OFPTC11_TABLE_MISS_DROP:\n            return OFPUTIL_TABLE_MISS_DROP;\n\n        default:\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"bad table miss config %d\", config);\n            return OFPUTIL_TABLE_MISS_CONTROLLER;\n        }\n    } else {\n        return OFPUTIL_TABLE_MISS_DEFAULT;\n    }\n}\n\n/* Decodes the OpenFlow \"table mod\" message in '*oh' into an abstract form in\n * '*pm'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_table_mod(const struct ofp_header *oh,\n                         struct ofputil_table_mod *pm)\n{\n    memset(pm, 0, sizeof *pm);\n    pm->miss = OFPUTIL_TABLE_MISS_DEFAULT;\n    pm->eviction = OFPUTIL_TABLE_EVICTION_DEFAULT;\n    pm->eviction_flags = UINT32_MAX;\n    pm->vacancy = OFPUTIL_TABLE_VACANCY_DEFAULT;\n\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT11_TABLE_MOD) {\n        const struct ofp11_table_mod *otm = b.data;\n\n        pm->table_id = otm->table_id;\n        pm->miss = ofputil_decode_table_miss(otm->config, oh->version);\n    } else if (raw == OFPRAW_OFPT14_TABLE_MOD) {\n        const struct ofp14_table_mod *otm = ofpbuf_pull(&b, sizeof *otm);\n\n        pm->table_id = otm->table_id;\n        pm->miss = ofputil_decode_table_miss(otm->config, oh->version);\n        pm->eviction = ofputil_decode_table_eviction(otm->config, oh->version);\n        pm->vacancy = ofputil_decode_table_vacancy(otm->config, oh->version);\n        while (b.size > 0) {\n            struct ofpbuf property;\n            enum ofperr error;\n            uint64_t type;\n\n            error = ofpprop_pull(&b, &property, &type);\n            if (error) {\n                return error;\n            }\n\n            switch (type) {\n            case OFPTMPT14_EVICTION:\n                error = ofpprop_parse_u32(&property, &pm->eviction);\n                break;\n\n            case OFPTMPT14_VACANCY:\n                error = parse_table_mod_vacancy_property(&property, pm);\n                break;\n\n            default:\n                error = OFPERR_OFPBRC_BAD_TYPE;\n                break;\n            }\n\n            if (error) {\n                return error;\n            }\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_TYPE;\n    }\n\n    return 0;\n}\n\n/* Converts the abstract form of a \"table mod\" message in '*tm' into an\n * OpenFlow message suitable for 'protocol', and returns that encoded form in a\n * buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_table_mod(const struct ofputil_table_mod *tm,\n                        enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *b;\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        ovs_fatal(0, \"table mod needs OpenFlow 1.1 or later \"\n                     \"(\\'-O OpenFlow11\\')\");\n        break;\n    }\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        struct ofp11_table_mod *otm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT11_TABLE_MOD, ofp_version, 0);\n        otm = ofpbuf_put_zeros(b, sizeof *otm);\n        otm->table_id = tm->table_id;\n        otm->config = ofputil_encode_table_config(tm->miss, tm->eviction,\n                                                  tm->vacancy, ofp_version);\n        break;\n    }\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp14_table_mod *otm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT14_TABLE_MOD, ofp_version, 0);\n        otm = ofpbuf_put_zeros(b, sizeof *otm);\n        otm->table_id = tm->table_id;\n        otm->config = ofputil_encode_table_config(tm->miss, tm->eviction,\n                                                  tm->vacancy, ofp_version);\n\n        if (tm->eviction_flags != UINT32_MAX) {\n            ofpprop_put_u32(b, OFPTMPT14_EVICTION, tm->eviction_flags);\n        }\n        if (tm->vacancy == OFPUTIL_TABLE_VACANCY_ON) {\n            struct ofp14_table_mod_prop_vacancy *otv;\n\n            otv = ofpprop_put_zeros(b, OFPTMPT14_VACANCY, sizeof *otv);\n            otv->vacancy_down = tm->table_vacancy.vacancy_down;\n            otv->vacancy_up = tm->table_vacancy.vacancy_up;\n        }\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return b;\n}\n\f\n/* ofputil_role_request */\n\n/* Decodes the OpenFlow \"role request\" or \"role reply\" message in '*oh' into\n * an abstract form in '*rr'.  Returns 0 if successful, otherwise an\n * OFPERR_* value. */\nenum ofperr\nofputil_decode_role_message(const struct ofp_header *oh,\n                            struct ofputil_role_request *rr)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT12_ROLE_REQUEST ||\n        raw == OFPRAW_OFPT12_ROLE_REPLY) {\n        const struct ofp12_role_request *orr = b.msg;\n\n        if (orr->role != htonl(OFPCR12_ROLE_NOCHANGE) &&\n            orr->role != htonl(OFPCR12_ROLE_EQUAL) &&\n            orr->role != htonl(OFPCR12_ROLE_MASTER) &&\n            orr->role != htonl(OFPCR12_ROLE_SLAVE)) {\n            return OFPERR_OFPRRFC_BAD_ROLE;\n        }\n\n        rr->role = ntohl(orr->role);\n        if (raw == OFPRAW_OFPT12_ROLE_REQUEST\n            ? orr->role == htonl(OFPCR12_ROLE_NOCHANGE)\n            : orr->generation_id == OVS_BE64_MAX) {\n            rr->have_generation_id = false;\n            rr->generation_id = 0;\n        } else {\n            rr->have_generation_id = true;\n            rr->generation_id = ntohll(orr->generation_id);\n        }\n    } else if (raw == OFPRAW_NXT_ROLE_REQUEST ||\n               raw == OFPRAW_NXT_ROLE_REPLY) {\n        const struct nx_role_request *nrr = b.msg;\n\n        BUILD_ASSERT(NX_ROLE_OTHER + 1 == OFPCR12_ROLE_EQUAL);\n        BUILD_ASSERT(NX_ROLE_MASTER + 1 == OFPCR12_ROLE_MASTER);\n        BUILD_ASSERT(NX_ROLE_SLAVE + 1 == OFPCR12_ROLE_SLAVE);\n\n        if (nrr->role != htonl(NX_ROLE_OTHER) &&\n            nrr->role != htonl(NX_ROLE_MASTER) &&\n            nrr->role != htonl(NX_ROLE_SLAVE)) {\n            return OFPERR_OFPRRFC_BAD_ROLE;\n        }\n\n        rr->role = ntohl(nrr->role) + 1;\n        rr->have_generation_id = false;\n        rr->generation_id = 0;\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    return 0;\n}\n\n/* Returns an encoded form of a role reply suitable for the \"request\" in a\n * buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_role_reply(const struct ofp_header *request,\n                          const struct ofputil_role_request *rr)\n{\n    struct ofpbuf *buf;\n    enum ofpraw raw;\n\n    raw = ofpraw_decode_assert(request);\n    if (raw == OFPRAW_OFPT12_ROLE_REQUEST) {\n        struct ofp12_role_request *orr;\n\n        buf = ofpraw_alloc_reply(OFPRAW_OFPT12_ROLE_REPLY, request, 0);\n        orr = ofpbuf_put_zeros(buf, sizeof *orr);\n\n        orr->role = htonl(rr->role);\n        orr->generation_id = htonll(rr->have_generation_id\n                                    ? rr->generation_id\n                                    : UINT64_MAX);\n    } else if (raw == OFPRAW_NXT_ROLE_REQUEST) {\n        struct nx_role_request *nrr;\n\n        BUILD_ASSERT(NX_ROLE_OTHER == OFPCR12_ROLE_EQUAL - 1);\n        BUILD_ASSERT(NX_ROLE_MASTER == OFPCR12_ROLE_MASTER - 1);\n        BUILD_ASSERT(NX_ROLE_SLAVE == OFPCR12_ROLE_SLAVE - 1);\n\n        buf = ofpraw_alloc_reply(OFPRAW_NXT_ROLE_REPLY, request, 0);\n        nrr = ofpbuf_put_zeros(buf, sizeof *nrr);\n        nrr->role = htonl(rr->role - 1);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    return buf;\n}\n\f\n/* Encodes \"role status\" message 'status' for sending in the given\n * 'protocol'.  Returns the role status message, if 'protocol' supports them,\n * otherwise a null pointer. */\nstruct ofpbuf *\nofputil_encode_role_status(const struct ofputil_role_status *status,\n                           enum ofputil_protocol protocol)\n{\n    enum ofp_version version;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    if (version >= OFP14_VERSION) {\n        struct ofp14_role_status *rstatus;\n        struct ofpbuf *buf;\n\n        buf = ofpraw_alloc_xid(OFPRAW_OFPT14_ROLE_STATUS, version, htonl(0),\n                               0);\n        rstatus = ofpbuf_put_zeros(buf, sizeof *rstatus);\n        rstatus->role = htonl(status->role);\n        rstatus->reason = status->reason;\n        rstatus->generation_id = htonll(status->generation_id);\n\n        return buf;\n    } else {\n        return NULL;\n    }\n}\n\nenum ofperr\nofputil_decode_role_status(const struct ofp_header *oh,\n                           struct ofputil_role_status *rs)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    ovs_assert(raw == OFPRAW_OFPT14_ROLE_STATUS);\n\n    const struct ofp14_role_status *r = b.msg;\n    if (r->role != htonl(OFPCR12_ROLE_NOCHANGE) &&\n        r->role != htonl(OFPCR12_ROLE_EQUAL) &&\n        r->role != htonl(OFPCR12_ROLE_MASTER) &&\n        r->role != htonl(OFPCR12_ROLE_SLAVE)) {\n        return OFPERR_OFPRRFC_BAD_ROLE;\n    }\n\n    rs->role = ntohl(r->role);\n    rs->generation_id = ntohll(r->generation_id);\n    rs->reason = r->reason;\n\n    return 0;\n}\n\n/* Encodes 'rf' according to 'protocol', and returns the encoded message.\n * 'protocol' must be for OpenFlow 1.4 or later. */\nstruct ofpbuf *\nofputil_encode_requestforward(const struct ofputil_requestforward *rf,\n                              enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *inner;\n\n    switch (rf->reason) {\n    case OFPRFR_GROUP_MOD:\n        inner = ofputil_encode_group_mod(ofp_version, rf->group_mod);\n        break;\n\n    case OFPRFR_METER_MOD:\n        inner = ofputil_encode_meter_mod(ofp_version, rf->meter_mod);\n        break;\n\n    case OFPRFR_N_REASONS:\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    struct ofp_header *inner_oh = inner->data;\n    inner_oh->xid = rf->xid;\n    inner_oh->length = htons(inner->size);\n\n    struct ofpbuf *outer = ofpraw_alloc_xid(OFPRAW_OFPT14_REQUESTFORWARD,\n                                            ofp_version, htonl(0),\n                                            inner->size);\n    ofpbuf_put(outer, inner->data, inner->size);\n    ofpbuf_delete(inner);\n\n    return outer;\n}\n\n/* Decodes OFPT_REQUESTFORWARD message 'outer'.  On success, puts the decoded\n * form into '*rf' and returns 0, and the caller is later responsible for\n * freeing the content of 'rf', with ofputil_destroy_requestforward(rf).  On\n * failure, returns an ofperr and '*rf' is indeterminate. */\nenum ofperr\nofputil_decode_requestforward(const struct ofp_header *outer,\n                              struct ofputil_requestforward *rf)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(outer, ntohs(outer->length));\n\n    /* Skip past outer message. */\n    enum ofpraw outer_raw = ofpraw_pull_assert(&b);\n    ovs_assert(outer_raw == OFPRAW_OFPT14_REQUESTFORWARD);\n\n    /* Validate inner message. */\n    if (b.size < sizeof(struct ofp_header)) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    const struct ofp_header *inner = b.data;\n    unsigned int inner_len = ntohs(inner->length);\n    if (inner_len < sizeof(struct ofp_header) || inner_len > b.size) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    if (inner->version != outer->version) {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n\n    /* Parse inner message. */\n    enum ofptype type;\n    enum ofperr error = ofptype_decode(&type, inner);\n    if (error) {\n        return error;\n    }\n\n    rf->xid = inner->xid;\n    if (type == OFPTYPE_GROUP_MOD) {\n        rf->reason = OFPRFR_GROUP_MOD;\n        rf->group_mod = xmalloc(sizeof *rf->group_mod);\n        error = ofputil_decode_group_mod(inner, rf->group_mod);\n        if (error) {\n            free(rf->group_mod);\n            return error;\n        }\n    } else if (type == OFPTYPE_METER_MOD) {\n        rf->reason = OFPRFR_METER_MOD;\n        rf->meter_mod = xmalloc(sizeof *rf->meter_mod);\n        ofpbuf_init(&rf->bands, 64);\n        error = ofputil_decode_meter_mod(inner, rf->meter_mod, &rf->bands);\n        if (error) {\n            free(rf->meter_mod);\n            ofpbuf_uninit(&rf->bands);\n            return error;\n        }\n    } else {\n        return OFPERR_OFPBFC_MSG_UNSUP;\n    }\n\n    return 0;\n}\n\n/* Frees the content of 'rf', which should have been initialized through a\n * successful call to ofputil_decode_requestforward(). */\nvoid\nofputil_destroy_requestforward(struct ofputil_requestforward *rf)\n{\n    if (!rf) {\n        return;\n    }\n\n    switch (rf->reason) {\n    case OFPRFR_GROUP_MOD:\n        ofputil_uninit_group_mod(rf->group_mod);\n        free(rf->group_mod);\n        break;\n\n    case OFPRFR_METER_MOD:\n        ofpbuf_uninit(&rf->bands);\n        free(rf->meter_mod);\n        break;\n\n    case OFPRFR_N_REASONS:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Table stats. */\n\n/* OpenFlow 1.0 and 1.1 don't distinguish between a field that cannot be\n * matched and a field that must be wildcarded.  This function returns a bitmap\n * that contains both kinds of fields. */\nstatic struct mf_bitmap\nwild_or_nonmatchable_fields(const struct ofputil_table_features *features)\n{\n    struct mf_bitmap wc = features->match;\n    bitmap_not(wc.bm, MFF_N_IDS);\n    bitmap_or(wc.bm, features->wildcard.bm, MFF_N_IDS);\n    return wc;\n}\n\nstruct ofp10_wc_map {\n    enum ofp10_flow_wildcards wc10;\n    enum mf_field_id mf;\n};\n\nstatic const struct ofp10_wc_map ofp10_wc_map[] = {\n    { OFPFW10_IN_PORT,     MFF_IN_PORT },\n    { OFPFW10_DL_VLAN,     MFF_VLAN_VID },\n    { OFPFW10_DL_SRC,      MFF_ETH_SRC },\n    { OFPFW10_DL_DST,      MFF_ETH_DST},\n    { OFPFW10_DL_TYPE,     MFF_ETH_TYPE },\n    { OFPFW10_NW_PROTO,    MFF_IP_PROTO },\n    { OFPFW10_TP_SRC,      MFF_TCP_SRC },\n    { OFPFW10_TP_DST,      MFF_TCP_DST },\n    { OFPFW10_NW_SRC_MASK, MFF_IPV4_SRC },\n    { OFPFW10_NW_DST_MASK, MFF_IPV4_DST },\n    { OFPFW10_DL_VLAN_PCP, MFF_VLAN_PCP },\n    { OFPFW10_NW_TOS,      MFF_IP_DSCP },\n};\n\nstatic ovs_be32\nmf_bitmap_to_of10(const struct mf_bitmap *fields)\n{\n    const struct ofp10_wc_map *p;\n    uint32_t wc10 = 0;\n\n    for (p = ofp10_wc_map; p < &ofp10_wc_map[ARRAY_SIZE(ofp10_wc_map)]; p++) {\n        if (bitmap_is_set(fields->bm, p->mf)) {\n            wc10 |= p->wc10;\n        }\n    }\n    return htonl(wc10);\n}\n\nstatic struct mf_bitmap\nmf_bitmap_from_of10(ovs_be32 wc10_)\n{\n    struct mf_bitmap fields = MF_BITMAP_INITIALIZER;\n    const struct ofp10_wc_map *p;\n    uint32_t wc10 = ntohl(wc10_);\n\n    for (p = ofp10_wc_map; p < &ofp10_wc_map[ARRAY_SIZE(ofp10_wc_map)]; p++) {\n        if (wc10 & p->wc10) {\n            bitmap_set1(fields.bm, p->mf);\n        }\n    }\n    return fields;\n}\n\nstatic void\nofputil_put_ofp10_table_stats(const struct ofputil_table_stats *stats,\n                              const struct ofputil_table_features *features,\n                              struct ofpbuf *buf)\n{\n    struct mf_bitmap wc = wild_or_nonmatchable_fields(features);\n    struct ofp10_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = features->table_id;\n    ovs_strlcpy(out->name, features->name, sizeof out->name);\n    out->wildcards = mf_bitmap_to_of10(&wc);\n    out->max_entries = htonl(features->max_entries);\n    out->active_count = htonl(stats->active_count);\n    put_32aligned_be64(&out->lookup_count, htonll(stats->lookup_count));\n    put_32aligned_be64(&out->matched_count, htonll(stats->matched_count));\n}\n\nstruct ofp11_wc_map {\n    enum ofp11_flow_match_fields wc11;\n    enum mf_field_id mf;\n};\n\nstatic const struct ofp11_wc_map ofp11_wc_map[] = {\n    { OFPFMF11_IN_PORT,     MFF_IN_PORT },\n    { OFPFMF11_DL_VLAN,     MFF_VLAN_VID },\n    { OFPFMF11_DL_VLAN_PCP, MFF_VLAN_PCP },\n    { OFPFMF11_DL_TYPE,     MFF_ETH_TYPE },\n    { OFPFMF11_NW_TOS,      MFF_IP_DSCP },\n    { OFPFMF11_NW_PROTO,    MFF_IP_PROTO },\n    { OFPFMF11_TP_SRC,      MFF_TCP_SRC },\n    { OFPFMF11_TP_DST,      MFF_TCP_DST },\n    { OFPFMF11_MPLS_LABEL,  MFF_MPLS_LABEL },\n    { OFPFMF11_MPLS_TC,     MFF_MPLS_TC },\n    /* I don't know what OFPFMF11_TYPE means. */\n    { OFPFMF11_DL_SRC,      MFF_ETH_SRC },\n    { OFPFMF11_DL_DST,      MFF_ETH_DST },\n    { OFPFMF11_NW_SRC,      MFF_IPV4_SRC },\n    { OFPFMF11_NW_DST,      MFF_IPV4_DST },\n    { OFPFMF11_METADATA,    MFF_METADATA },\n};\n\nstatic ovs_be32\nmf_bitmap_to_of11(const struct mf_bitmap *fields)\n{\n    const struct ofp11_wc_map *p;\n    uint32_t wc11 = 0;\n\n    for (p = ofp11_wc_map; p < &ofp11_wc_map[ARRAY_SIZE(ofp11_wc_map)]; p++) {\n        if (bitmap_is_set(fields->bm, p->mf)) {\n            wc11 |= p->wc11;\n        }\n    }\n    return htonl(wc11);\n}\n\nstatic struct mf_bitmap\nmf_bitmap_from_of11(ovs_be32 wc11_)\n{\n    struct mf_bitmap fields = MF_BITMAP_INITIALIZER;\n    const struct ofp11_wc_map *p;\n    uint32_t wc11 = ntohl(wc11_);\n\n    for (p = ofp11_wc_map; p < &ofp11_wc_map[ARRAY_SIZE(ofp11_wc_map)]; p++) {\n        if (wc11 & p->wc11) {\n            bitmap_set1(fields.bm, p->mf);\n        }\n    }\n    return fields;\n}\n\nstatic void\nofputil_put_ofp11_table_stats(const struct ofputil_table_stats *stats,\n                              const struct ofputil_table_features *features,\n                              struct ofpbuf *buf)\n{\n    struct mf_bitmap wc = wild_or_nonmatchable_fields(features);\n    struct ofp11_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = features->table_id;\n    ovs_strlcpy(out->name, features->name, sizeof out->name);\n    out->wildcards = mf_bitmap_to_of11(&wc);\n    out->match = mf_bitmap_to_of11(&features->match);\n    out->instructions = ovsinst_bitmap_to_openflow(\n        features->nonmiss.instructions, OFP11_VERSION);\n    out->write_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.write.ofpacts, OFP11_VERSION);\n    out->apply_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.apply.ofpacts, OFP11_VERSION);\n    out->config = htonl(features->miss_config);\n    out->max_entries = htonl(features->max_entries);\n    out->active_count = htonl(stats->active_count);\n    out->lookup_count = htonll(stats->lookup_count);\n    out->matched_count = htonll(stats->matched_count);\n}\n\nstatic void\nofputil_put_ofp12_table_stats(const struct ofputil_table_stats *stats,\n                              const struct ofputil_table_features *features,\n                              struct ofpbuf *buf)\n{\n    struct ofp12_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = features->table_id;\n    ovs_strlcpy(out->name, features->name, sizeof out->name);\n    out->match = oxm_bitmap_from_mf_bitmap(&features->match, OFP12_VERSION);\n    out->wildcards = oxm_bitmap_from_mf_bitmap(&features->wildcard,\n                                             OFP12_VERSION);\n    out->write_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.write.ofpacts, OFP12_VERSION);\n    out->apply_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.apply.ofpacts, OFP12_VERSION);\n    out->write_setfields = oxm_bitmap_from_mf_bitmap(\n        &features->nonmiss.write.set_fields, OFP12_VERSION);\n    out->apply_setfields = oxm_bitmap_from_mf_bitmap(\n        &features->nonmiss.apply.set_fields, OFP12_VERSION);\n    out->metadata_match = features->metadata_match;\n    out->metadata_write = features->metadata_write;\n    out->instructions = ovsinst_bitmap_to_openflow(\n        features->nonmiss.instructions, OFP12_VERSION);\n    out->config = ofputil_encode_table_config(features->miss_config,\n                                              OFPUTIL_TABLE_EVICTION_DEFAULT,\n                                              OFPUTIL_TABLE_VACANCY_DEFAULT,\n                                              OFP12_VERSION);\n    out->max_entries = htonl(features->max_entries);\n    out->active_count = htonl(stats->active_count);\n    out->lookup_count = htonll(stats->lookup_count);\n    out->matched_count = htonll(stats->matched_count);\n}\n\nstatic void\nofputil_put_ofp13_table_stats(const struct ofputil_table_stats *stats,\n                              struct ofpbuf *buf)\n{\n    struct ofp13_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = stats->table_id;\n    out->active_count = htonl(stats->active_count);\n    out->lookup_count = htonll(stats->lookup_count);\n    out->matched_count = htonll(stats->matched_count);\n}\n\nstruct ofpbuf *\nofputil_encode_table_stats_reply(const struct ofp_header *request)\n{\n    return ofpraw_alloc_stats_reply(request, 0);\n}\n\nvoid\nofputil_append_table_stats_reply(struct ofpbuf *reply,\n                                 const struct ofputil_table_stats *stats,\n                                 const struct ofputil_table_features *features)\n{\n    struct ofp_header *oh = reply->header;\n\n    ovs_assert(stats->table_id == features->table_id);\n\n    switch ((enum ofp_version) oh->version) {\n    case OFP10_VERSION:\n        ofputil_put_ofp10_table_stats(stats, features, reply);\n        break;\n\n    case OFP11_VERSION:\n        ofputil_put_ofp11_table_stats(stats, features, reply);\n        break;\n\n    case OFP12_VERSION:\n        ofputil_put_ofp12_table_stats(stats, features, reply);\n        break;\n\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_put_ofp13_table_stats(stats, reply);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic int\nofputil_decode_ofp10_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp10_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n    ovs_strlcpy(features->name, ots->name, sizeof features->name);\n    features->max_entries = ntohl(ots->max_entries);\n    features->match = features->wildcard = mf_bitmap_from_of10(ots->wildcards);\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(get_32aligned_be64(&ots->lookup_count));\n    stats->matched_count = ntohll(get_32aligned_be64(&ots->matched_count));\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp11_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp11_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n    ovs_strlcpy(features->name, ots->name, sizeof features->name);\n    features->max_entries = ntohl(ots->max_entries);\n    features->nonmiss.instructions = ovsinst_bitmap_from_openflow(\n        ots->instructions, OFP11_VERSION);\n    features->nonmiss.write.ofpacts = ofpact_bitmap_from_openflow(\n        ots->write_actions, OFP11_VERSION);\n    features->nonmiss.apply.ofpacts = ofpact_bitmap_from_openflow(\n        ots->write_actions, OFP11_VERSION);\n    features->miss = features->nonmiss;\n    features->miss_config = ofputil_decode_table_miss(ots->config,\n                                                      OFP11_VERSION);\n    features->match = mf_bitmap_from_of11(ots->match);\n    features->wildcard = mf_bitmap_from_of11(ots->wildcards);\n    bitmap_or(features->match.bm, features->wildcard.bm, MFF_N_IDS);\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp12_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp12_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n    ovs_strlcpy(features->name, ots->name, sizeof features->name);\n    features->metadata_match = ots->metadata_match;\n    features->metadata_write = ots->metadata_write;\n    features->miss_config = ofputil_decode_table_miss(ots->config,\n                                                      OFP12_VERSION);\n    features->max_entries = ntohl(ots->max_entries);\n\n    features->nonmiss.instructions = ovsinst_bitmap_from_openflow(\n        ots->instructions, OFP12_VERSION);\n    features->nonmiss.write.ofpacts = ofpact_bitmap_from_openflow(\n        ots->write_actions, OFP12_VERSION);\n    features->nonmiss.apply.ofpacts = ofpact_bitmap_from_openflow(\n        ots->apply_actions, OFP12_VERSION);\n    features->nonmiss.write.set_fields = oxm_bitmap_to_mf_bitmap(\n        ots->write_setfields, OFP12_VERSION);\n    features->nonmiss.apply.set_fields = oxm_bitmap_to_mf_bitmap(\n        ots->apply_setfields, OFP12_VERSION);\n    features->miss = features->nonmiss;\n\n    features->match = oxm_bitmap_to_mf_bitmap(ots->match, OFP12_VERSION);\n    features->wildcard = oxm_bitmap_to_mf_bitmap(ots->wildcards,\n                                                 OFP12_VERSION);\n    bitmap_or(features->match.bm, features->wildcard.bm, MFF_N_IDS);\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp13_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp13_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n\nint\nofputil_decode_table_stats_reply(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    const struct ofp_header *oh;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n    oh = msg->header;\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    memset(stats, 0, sizeof *stats);\n    memset(features, 0, sizeof *features);\n    features->supports_eviction = -1;\n    features->supports_vacancy_events = -1;\n\n    switch ((enum ofp_version) oh->version) {\n    case OFP10_VERSION:\n        return ofputil_decode_ofp10_table_stats(msg, stats, features);\n\n    case OFP11_VERSION:\n        return ofputil_decode_ofp11_table_stats(msg, stats, features);\n\n    case OFP12_VERSION:\n        return ofputil_decode_ofp12_table_stats(msg, stats, features);\n\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return ofputil_decode_ofp13_table_stats(msg, stats, features);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\f\n/* ofputil_flow_monitor_request */\n\n/* Converts an NXST_FLOW_MONITOR request in 'msg' into an abstract\n * ofputil_flow_monitor_request in 'rq'.\n *\n * Multiple NXST_FLOW_MONITOR requests can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the requests.  The caller must initially leave 'msg''s layer\n * pointers null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no requests were left in this 'msg',\n * otherwise an OFPERR_* value. */\nint\nofputil_decode_flow_monitor_request(struct ofputil_flow_monitor_request *rq,\n                                    struct ofpbuf *msg)\n{\n    struct nx_flow_monitor_request *nfmr;\n    uint16_t flags;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    nfmr = ofpbuf_try_pull(msg, sizeof *nfmr);\n    if (!nfmr) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW_MONITOR request has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    flags = ntohs(nfmr->flags);\n    if (!(flags & (NXFMF_ADD | NXFMF_DELETE | NXFMF_MODIFY))\n        || flags & ~(NXFMF_INITIAL | NXFMF_ADD | NXFMF_DELETE\n                     | NXFMF_MODIFY | NXFMF_ACTIONS | NXFMF_OWN)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW_MONITOR has bad flags %#\"PRIx16,\n                     flags);\n        return OFPERR_OFPMOFC_BAD_FLAGS;\n    }\n\n    if (!is_all_zeros(nfmr->zeros, sizeof nfmr->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    rq->id = ntohl(nfmr->id);\n    rq->flags = flags;\n    rq->out_port = u16_to_ofp(ntohs(nfmr->out_port));\n    rq->table_id = nfmr->table_id;\n\n    return nx_pull_match(msg, ntohs(nfmr->match_len), &rq->match, NULL,\n                         NULL, NULL, NULL);\n}\n\nvoid\nofputil_append_flow_monitor_request(\n    const struct ofputil_flow_monitor_request *rq, struct ofpbuf *msg)\n{\n    struct nx_flow_monitor_request *nfmr;\n    size_t start_ofs;\n    int match_len;\n\n    if (!msg->size) {\n        ofpraw_put(OFPRAW_NXST_FLOW_MONITOR_REQUEST, OFP10_VERSION, msg);\n    }\n\n    start_ofs = msg->size;\n    ofpbuf_put_zeros(msg, sizeof *nfmr);\n    match_len = nx_put_match(msg, &rq->match, htonll(0), htonll(0));\n\n    nfmr = ofpbuf_at_assert(msg, start_ofs, sizeof *nfmr);\n    nfmr->id = htonl(rq->id);\n    nfmr->flags = htons(rq->flags);\n    nfmr->out_port = htons(ofp_to_u16(rq->out_port));\n    nfmr->match_len = htons(match_len);\n    nfmr->table_id = rq->table_id;\n}\n\n/* Converts an NXST_FLOW_MONITOR reply (also known as a flow update) in 'msg'\n * into an abstract ofputil_flow_update in 'update'.  The caller must have\n * initialized update->match to point to space allocated for a match.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of the update's\n * actions (except for NXFME_ABBREV, which never includes actions).  The caller\n * must initialize 'ofpacts' and retains ownership of it.  'update->ofpacts'\n * will point into the 'ofpacts' buffer.\n *\n * Multiple flow updates can be packed into a single OpenFlow message.  Calling\n * this function multiple times for a single 'msg' iterates through the\n * updates.  The caller must initially leave 'msg''s layer pointers null and\n * not modify them between calls.\n *\n * Returns 0 if successful, EOF if no updates were left in this 'msg',\n * otherwise an OFPERR_* value. */\nint\nofputil_decode_flow_update(struct ofputil_flow_update *update,\n                           struct ofpbuf *msg, struct ofpbuf *ofpacts)\n{\n    struct nx_flow_update_header *nfuh;\n    unsigned int length;\n    struct ofp_header *oh;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    ofpbuf_clear(ofpacts);\n    if (!msg->size) {\n        return EOF;\n    }\n\n    if (msg->size < sizeof(struct nx_flow_update_header)) {\n        goto bad_len;\n    }\n\n    oh = msg->header;\n\n    nfuh = msg->data;\n    update->event = ntohs(nfuh->event);\n    length = ntohs(nfuh->length);\n    if (length > msg->size || length % 8) {\n        goto bad_len;\n    }\n\n    if (update->event == NXFME_ABBREV) {\n        struct nx_flow_update_abbrev *nfua;\n\n        if (length != sizeof *nfua) {\n            goto bad_len;\n        }\n\n        nfua = ofpbuf_pull(msg, sizeof *nfua);\n        update->xid = nfua->xid;\n        return 0;\n    } else if (update->event == NXFME_ADDED\n               || update->event == NXFME_DELETED\n               || update->event == NXFME_MODIFIED) {\n        struct nx_flow_update_full *nfuf;\n        unsigned int actions_len;\n        unsigned int match_len;\n        enum ofperr error;\n\n        if (length < sizeof *nfuf) {\n            goto bad_len;\n        }\n\n        nfuf = ofpbuf_pull(msg, sizeof *nfuf);\n        match_len = ntohs(nfuf->match_len);\n        if (sizeof *nfuf + match_len > length) {\n            goto bad_len;\n        }\n\n        update->reason = ntohs(nfuf->reason);\n        update->idle_timeout = ntohs(nfuf->idle_timeout);\n        update->hard_timeout = ntohs(nfuf->hard_timeout);\n        update->table_id = nfuf->table_id;\n        update->cookie = nfuf->cookie;\n        update->priority = ntohs(nfuf->priority);\n\n        error = nx_pull_match(msg, match_len, &update->match, NULL, NULL, NULL,\n                              NULL);\n        if (error) {\n            return error;\n        }\n\n        actions_len = length - sizeof *nfuf - ROUND_UP(match_len, 8);\n        error = ofpacts_pull_openflow_actions(msg, actions_len, oh->version,\n                                              NULL, NULL, ofpacts);\n        if (error) {\n            return error;\n        }\n\n        update->ofpacts = ofpacts->data;\n        update->ofpacts_len = ofpacts->size;\n        return 0;\n    } else {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"NXST_FLOW_MONITOR reply has bad event %\"PRIu16,\n                     ntohs(nfuh->event));\n        return OFPERR_NXBRC_FM_BAD_EVENT;\n    }\n\nbad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW_MONITOR reply has %\"PRIu32\" \"\n                 \"leftover bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n\nuint32_t\nofputil_decode_flow_monitor_cancel(const struct ofp_header *oh)\n{\n    const struct nx_flow_monitor_cancel *cancel = ofpmsg_body(oh);\n\n    return ntohl(cancel->id);\n}\n\nstruct ofpbuf *\nofputil_encode_flow_monitor_cancel(uint32_t id)\n{\n    struct nx_flow_monitor_cancel *nfmc;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc(OFPRAW_NXT_FLOW_MONITOR_CANCEL, OFP10_VERSION, 0);\n    nfmc = ofpbuf_put_uninit(msg, sizeof *nfmc);\n    nfmc->id = htonl(id);\n    return msg;\n}\n\nvoid\nofputil_start_flow_update(struct ovs_list *replies)\n{\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc_xid(OFPRAW_NXST_FLOW_MONITOR_REPLY, OFP10_VERSION,\n                           htonl(0), 1024);\n\n    ovs_list_init(replies);\n    ovs_list_push_back(replies, &msg->list_node);\n}\n\nvoid\nofputil_append_flow_update(const struct ofputil_flow_update *update,\n                           struct ovs_list *replies,\n                           const struct tun_table *tun_table)\n{\n    struct ofputil_flow_update *update_ =\n        CONST_CAST(struct ofputil_flow_update *, update);\n    const struct tun_table *orig_tun_table;\n    enum ofp_version version = ofpmp_version(replies);\n    struct nx_flow_update_header *nfuh;\n    struct ofpbuf *msg;\n    size_t start_ofs;\n\n    orig_tun_table = update->match.flow.tunnel.metadata.tab;\n    update_->match.flow.tunnel.metadata.tab = tun_table;\n\n    msg = ofpbuf_from_list(ovs_list_back(replies));\n    start_ofs = msg->size;\n\n    if (update->event == NXFME_ABBREV) {\n        struct nx_flow_update_abbrev *nfua;\n\n        nfua = ofpbuf_put_zeros(msg, sizeof *nfua);\n        nfua->xid = update->xid;\n    } else {\n        struct nx_flow_update_full *nfuf;\n        int match_len;\n\n        ofpbuf_put_zeros(msg, sizeof *nfuf);\n        match_len = nx_put_match(msg, &update->match, htonll(0), htonll(0));\n        ofpacts_put_openflow_actions(update->ofpacts, update->ofpacts_len, msg,\n                                     version);\n        nfuf = ofpbuf_at_assert(msg, start_ofs, sizeof *nfuf);\n        nfuf->reason = htons(update->reason);\n        nfuf->priority = htons(update->priority);\n        nfuf->idle_timeout = htons(update->idle_timeout);\n        nfuf->hard_timeout = htons(update->hard_timeout);\n        nfuf->match_len = htons(match_len);\n        nfuf->table_id = update->table_id;\n        nfuf->cookie = update->cookie;\n    }\n\n    nfuh = ofpbuf_at_assert(msg, start_ofs, sizeof *nfuh);\n    nfuh->length = htons(msg->size - start_ofs);\n    nfuh->event = htons(update->event);\n\n    ofpmp_postappend(replies, start_ofs);\n    update_->match.flow.tunnel.metadata.tab = orig_tun_table;\n}\n\f\nstruct ofpbuf *\nofputil_encode_packet_out(const struct ofputil_packet_out *po,\n                          enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *msg;\n    size_t size;\n\n    size = po->ofpacts_len;\n    if (po->buffer_id == UINT32_MAX) {\n        size += po->packet_len;\n    }\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_packet_out *opo;\n        size_t actions_ofs;\n\n        msg = ofpraw_alloc(OFPRAW_OFPT10_PACKET_OUT, OFP10_VERSION, size);\n        ofpbuf_put_zeros(msg, sizeof *opo);\n        actions_ofs = msg->size;\n        ofpacts_put_openflow_actions(po->ofpacts, po->ofpacts_len, msg,\n                                     ofp_version);\n\n        opo = msg->msg;\n        opo->buffer_id = htonl(po->buffer_id);\n        opo->in_port = htons(ofp_to_u16(po->in_port));\n        opo->actions_len = htons(msg->size - actions_ofs);\n        break;\n    }\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_packet_out *opo;\n        size_t len;\n\n        msg = ofpraw_alloc(OFPRAW_OFPT11_PACKET_OUT, ofp_version, size);\n        ofpbuf_put_zeros(msg, sizeof *opo);\n        len = ofpacts_put_openflow_actions(po->ofpacts, po->ofpacts_len, msg,\n                                           ofp_version);\n        opo = msg->msg;\n        opo->buffer_id = htonl(po->buffer_id);\n        opo->in_port = ofputil_port_to_ofp11(po->in_port);\n        opo->actions_len = htons(len);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (po->buffer_id == UINT32_MAX) {\n        ofpbuf_put(msg, po->packet, po->packet_len);\n    }\n\n    ofpmsg_update_length(msg);\n\n    return msg;\n}\n\f\n/* Creates and returns an OFPT_ECHO_REQUEST message with an empty payload. */\nstruct ofpbuf *\nmake_echo_request(enum ofp_version ofp_version)\n{\n    return ofpraw_alloc_xid(OFPRAW_OFPT_ECHO_REQUEST, ofp_version,\n                            htonl(0), 0);\n}\n\n/* Creates and returns an OFPT_ECHO_REPLY message matching the\n * OFPT_ECHO_REQUEST message in 'rq'. */\nstruct ofpbuf *\nmake_echo_reply(const struct ofp_header *rq)\n{\n    struct ofpbuf rq_buf = ofpbuf_const_initializer(rq, ntohs(rq->length));\n    ofpraw_pull_assert(&rq_buf);\n\n    struct ofpbuf *reply = ofpraw_alloc_reply(OFPRAW_OFPT_ECHO_REPLY,\n                                              rq, rq_buf.size);\n    ofpbuf_put(reply, rq_buf.data, rq_buf.size);\n    return reply;\n}\n\nstruct ofpbuf *\nofputil_encode_barrier_request(enum ofp_version ofp_version)\n{\n    enum ofpraw type;\n\n    switch (ofp_version) {\n    case OFP16_VERSION:\n    case OFP15_VERSION:\n    case OFP14_VERSION:\n    case OFP13_VERSION:\n    case OFP12_VERSION:\n    case OFP11_VERSION:\n        type = OFPRAW_OFPT11_BARRIER_REQUEST;\n        break;\n\n    case OFP10_VERSION:\n        type = OFPRAW_OFPT10_BARRIER_REQUEST;\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return ofpraw_alloc(type, ofp_version, 0);\n}\n\nconst char *\nofputil_frag_handling_to_string(enum ofputil_frag_handling frag)\n{\n    switch (frag) {\n    case OFPUTIL_FRAG_NORMAL:   return \"normal\";\n    case OFPUTIL_FRAG_DROP:     return \"drop\";\n    case OFPUTIL_FRAG_REASM:    return \"reassemble\";\n    case OFPUTIL_FRAG_NX_MATCH: return \"nx-match\";\n    }\n\n    OVS_NOT_REACHED();\n}\n\nbool\nofputil_frag_handling_from_string(const char *s,\n                                  enum ofputil_frag_handling *frag)\n{\n    if (!strcasecmp(s, \"normal\")) {\n        *frag = OFPUTIL_FRAG_NORMAL;\n    } else if (!strcasecmp(s, \"drop\")) {\n        *frag = OFPUTIL_FRAG_DROP;\n    } else if (!strcasecmp(s, \"reassemble\")) {\n        *frag = OFPUTIL_FRAG_REASM;\n    } else if (!strcasecmp(s, \"nx-match\")) {\n        *frag = OFPUTIL_FRAG_NX_MATCH;\n    } else {\n        return false;\n    }\n    return true;\n}\n\n/* Converts the OpenFlow 1.1+ port number 'ofp11_port' into an OpenFlow 1.0\n * port number and stores the latter in '*ofp10_port', for the purpose of\n * decoding OpenFlow 1.1+ protocol messages.  Returns 0 if successful,\n * otherwise an OFPERR_* number.  On error, stores OFPP_NONE in '*ofp10_port'.\n *\n * See the definition of OFP11_MAX for an explanation of the mapping. */\nenum ofperr\nofputil_port_from_ofp11(ovs_be32 ofp11_port, ofp_port_t *ofp10_port)\n{\n    uint32_t ofp11_port_h = ntohl(ofp11_port);\n\n    if (ofp11_port_h < ofp_to_u16(OFPP_MAX)) {\n        *ofp10_port = u16_to_ofp(ofp11_port_h);\n        return 0;\n    } else if (ofp11_port_h >= ofp11_to_u32(OFPP11_MAX)) {\n        *ofp10_port = u16_to_ofp(ofp11_port_h - OFPP11_OFFSET);\n        return 0;\n    } else {\n        *ofp10_port = OFPP_NONE;\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"port %\"PRIu32\" is outside the supported \"\n                     \"range 0 through %d or 0x%\"PRIx32\" through 0x%\"PRIx32,\n                     ofp11_port_h, ofp_to_u16(OFPP_MAX) - 1,\n                     ofp11_to_u32(OFPP11_MAX), UINT32_MAX);\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n}\n\n/* Returns the OpenFlow 1.1+ port number equivalent to the OpenFlow 1.0 port\n * number 'ofp10_port', for encoding OpenFlow 1.1+ protocol messages.\n *\n * See the definition of OFP11_MAX for an explanation of the mapping. */\novs_be32\nofputil_port_to_ofp11(ofp_port_t ofp10_port)\n{\n    return htonl(ofp_to_u16(ofp10_port) < ofp_to_u16(OFPP_MAX)\n                 ? ofp_to_u16(ofp10_port)\n                 : ofp_to_u16(ofp10_port) + OFPP11_OFFSET);\n}\n\n#define OFPUTIL_NAMED_PORTS                     \\\n        OFPUTIL_NAMED_PORT(IN_PORT)             \\\n        OFPUTIL_NAMED_PORT(TABLE)               \\\n        OFPUTIL_NAMED_PORT(NORMAL)              \\\n        OFPUTIL_NAMED_PORT(FLOOD)               \\\n        OFPUTIL_NAMED_PORT(ALL)                 \\\n        OFPUTIL_NAMED_PORT(CONTROLLER)          \\\n        OFPUTIL_NAMED_PORT(LOCAL)               \\\n        OFPUTIL_NAMED_PORT(ANY)                 \\\n        OFPUTIL_NAMED_PORT(UNSET)\n\n/* For backwards compatibility, so that \"none\" is recognized as OFPP_ANY */\n#define OFPUTIL_NAMED_PORTS_WITH_NONE           \\\n        OFPUTIL_NAMED_PORTS                     \\\n        OFPUTIL_NAMED_PORT(NONE)\n\n/* Stores the port number represented by 's' into '*portp'.  's' may be an\n * integer or, for reserved ports, the standard OpenFlow name for the port\n * (e.g. \"LOCAL\").\n *\n * Returns true if successful, false if 's' is not a valid OpenFlow port number\n * or name.  The caller should issue an error message in this case, because\n * this function usually does not.  (This gives the caller an opportunity to\n * look up the port name another way, e.g. by contacting the switch and listing\n * the names of all its ports).\n *\n * This function accepts OpenFlow 1.0 port numbers.  It also accepts a subset\n * of OpenFlow 1.1+ port numbers, mapping those port numbers into the 16-bit\n * range as described in include/openflow/openflow-1.1.h. */\nbool\nofputil_port_from_string(const char *s, ofp_port_t *portp)\n{\n    unsigned int port32; /* int is at least 32 bits wide. */\n\n    if (*s == '-') {\n        VLOG_WARN(\"Negative value %s is not a valid port number.\", s);\n        return false;\n    }\n    *portp = 0;\n    if (str_to_uint(s, 10, &port32)) {\n        if (port32 < ofp_to_u16(OFPP_MAX)) {\n            /* Pass. */\n        } else if (port32 < ofp_to_u16(OFPP_FIRST_RESV)) {\n            VLOG_WARN(\"port %u is a reserved OF1.0 port number that will \"\n                      \"be translated to %u when talking to an OF1.1 or \"\n                      \"later controller\", port32, port32 + OFPP11_OFFSET);\n        } else if (port32 <= ofp_to_u16(OFPP_LAST_RESV)) {\n            char name[OFP_MAX_PORT_NAME_LEN];\n\n            ofputil_port_to_string(u16_to_ofp(port32), name, sizeof name);\n            VLOG_WARN_ONCE(\"referring to port %s as %\"PRIu32\" is deprecated \"\n                           \"for compatibility with OpenFlow 1.1 and later\",\n                           name, port32);\n        } else if (port32 < ofp11_to_u32(OFPP11_MAX)) {\n            VLOG_WARN(\"port %u is outside the supported range 0 through \"\n                      \"%\"PRIx16\" or 0x%x through 0x%\"PRIx32, port32,\n                      UINT16_MAX, ofp11_to_u32(OFPP11_MAX), UINT32_MAX);\n            return false;\n        } else {\n            port32 -= OFPP11_OFFSET;\n        }\n\n        *portp = u16_to_ofp(port32);\n        return true;\n    } else {\n        struct pair {\n            const char *name;\n            ofp_port_t value;\n        };\n        static const struct pair pairs[] = {\n#define OFPUTIL_NAMED_PORT(NAME) {#NAME, OFPP_##NAME},\n            OFPUTIL_NAMED_PORTS_WITH_NONE\n#undef OFPUTIL_NAMED_PORT\n        };\n        const struct pair *p;\n\n        for (p = pairs; p < &pairs[ARRAY_SIZE(pairs)]; p++) {\n            if (!strcasecmp(s, p->name)) {\n                *portp = p->value;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/* Appends to 's' a string representation of the OpenFlow port number 'port'.\n * Most ports' string representation is just the port number, but for special\n * ports, e.g. OFPP_LOCAL, it is the name, e.g. \"LOCAL\". */\nvoid\nofputil_format_port(ofp_port_t port, struct ds *s)\n{\n    char name[OFP_MAX_PORT_NAME_LEN];\n\n    ofputil_port_to_string(port, name, sizeof name);\n    ds_put_cstr(s, name);\n}\n\n/* Puts in the 'bufsize' byte in 'namebuf' a null-terminated string\n * representation of OpenFlow port number 'port'.  Most ports are represented\n * as just the port number, but special ports, e.g. OFPP_LOCAL, are represented\n * by name, e.g. \"LOCAL\". */\nvoid\nofputil_port_to_string(ofp_port_t port,\n                       char namebuf[OFP_MAX_PORT_NAME_LEN], size_t bufsize)\n{\n    switch (port) {\n#define OFPUTIL_NAMED_PORT(NAME)                        \\\n        case OFPP_##NAME:                               \\\n            ovs_strlcpy(namebuf, #NAME, bufsize);       \\\n            break;\n        OFPUTIL_NAMED_PORTS\n#undef OFPUTIL_NAMED_PORT\n\n    default:\n        snprintf(namebuf, bufsize, \"%\"PRIu32, port);\n        break;\n    }\n}\n\n/* Stores the group id represented by 's' into '*group_idp'.  's' may be an\n * integer or, for reserved group IDs, the standard OpenFlow name for the group\n * (either \"ANY\" or \"ALL\").\n *\n * Returns true if successful, false if 's' is not a valid OpenFlow group ID or\n * name. */\nbool\nofputil_group_from_string(const char *s, uint32_t *group_idp)\n{\n    if (!strcasecmp(s, \"any\")) {\n        *group_idp = OFPG_ANY;\n    } else if (!strcasecmp(s, \"all\")) {\n        *group_idp = OFPG_ALL;\n    } else if (!str_to_uint(s, 10, group_idp)) {\n        VLOG_WARN(\"%s is not a valid group ID.  (Valid group IDs are \"\n                  \"32-bit nonnegative integers or the keywords ANY or \"\n                  \"ALL.)\", s);\n        return false;\n    }\n\n    return true;\n}\n\n/* Appends to 's' a string representation of the OpenFlow group ID 'group_id'.\n * Most groups' string representation is just the number, but for special\n * groups, e.g. OFPG_ALL, it is the name, e.g. \"ALL\". */\nvoid\nofputil_format_group(uint32_t group_id, struct ds *s)\n{\n    char name[MAX_GROUP_NAME_LEN];\n\n    ofputil_group_to_string(group_id, name, sizeof name);\n    ds_put_cstr(s, name);\n}\n\n\n/* Puts in the 'bufsize' byte in 'namebuf' a null-terminated string\n * representation of OpenFlow group ID 'group_id'.  Most group are represented\n * as just their number, but special groups, e.g. OFPG_ALL, are represented\n * by name, e.g. \"ALL\". */\nvoid\nofputil_group_to_string(uint32_t group_id,\n                        char namebuf[MAX_GROUP_NAME_LEN + 1], size_t bufsize)\n{\n    switch (group_id) {\n    case OFPG_ALL:\n        ovs_strlcpy(namebuf, \"ALL\", bufsize);\n        break;\n\n    case OFPG_ANY:\n        ovs_strlcpy(namebuf, \"ANY\", bufsize);\n        break;\n\n    default:\n        snprintf(namebuf, bufsize, \"%\"PRIu32, group_id);\n        break;\n    }\n}\n\n/* Given a buffer 'b' that contains an array of OpenFlow ports of type\n * 'ofp_version', tries to pull the first element from the array.  If\n * successful, initializes '*pp' with an abstract representation of the\n * port and returns 0.  If no ports remain to be decoded, returns EOF.\n * On an error, returns a positive OFPERR_* value. */\nint\nofputil_pull_phy_port(enum ofp_version ofp_version, struct ofpbuf *b,\n                      struct ofputil_phy_port *pp)\n{\n    memset(pp, 0, sizeof *pp);\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        const struct ofp10_phy_port *opp = ofpbuf_try_pull(b, sizeof *opp);\n        return opp ? ofputil_decode_ofp10_phy_port(pp, opp) : EOF;\n    }\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        const struct ofp11_port *op = ofpbuf_try_pull(b, sizeof *op);\n        return op ? ofputil_decode_ofp11_port(pp, op) : EOF;\n    }\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return b->size ? ofputil_pull_ofp14_port(pp, b) : EOF;\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic void\nofputil_normalize_match__(struct match *match, bool may_log)\n{\n    enum {\n        MAY_NW_ADDR     = 1 << 0, /* nw_src, nw_dst */\n        MAY_TP_ADDR     = 1 << 1, /* tp_src, tp_dst */\n        MAY_NW_PROTO    = 1 << 2, /* nw_proto */\n        MAY_IPVx        = 1 << 3, /* tos, frag, ttl */\n        MAY_ARP_SHA     = 1 << 4, /* arp_sha */\n        MAY_ARP_THA     = 1 << 5, /* arp_tha */\n        MAY_IPV6        = 1 << 6, /* ipv6_src, ipv6_dst, ipv6_label */\n        MAY_ND_TARGET   = 1 << 7, /* nd_target */\n        MAY_MPLS        = 1 << 8, /* mpls label and tc */\n    } may_match;\n\n    struct flow_wildcards wc;\n\n    /* Figure out what fields may be matched. */\n    if (match->flow.dl_type == htons(ETH_TYPE_IP)) {\n        may_match = MAY_NW_PROTO | MAY_IPVx | MAY_NW_ADDR;\n        if (match->flow.nw_proto == IPPROTO_TCP ||\n            match->flow.nw_proto == IPPROTO_UDP ||\n            match->flow.nw_proto == IPPROTO_SCTP ||\n            match->flow.nw_proto == IPPROTO_ICMP) {\n            may_match |= MAY_TP_ADDR;\n        }\n    } else if (match->flow.dl_type == htons(ETH_TYPE_IPV6)) {\n        may_match = MAY_NW_PROTO | MAY_IPVx | MAY_IPV6;\n        if (match->flow.nw_proto == IPPROTO_TCP ||\n            match->flow.nw_proto == IPPROTO_UDP ||\n            match->flow.nw_proto == IPPROTO_SCTP) {\n            may_match |= MAY_TP_ADDR;\n        } else if (match->flow.nw_proto == IPPROTO_ICMPV6) {\n            may_match |= MAY_TP_ADDR;\n            if (match->flow.tp_src == htons(ND_NEIGHBOR_SOLICIT)) {\n                may_match |= MAY_ND_TARGET | MAY_ARP_SHA;\n            } else if (match->flow.tp_src == htons(ND_NEIGHBOR_ADVERT)) {\n                may_match |= MAY_ND_TARGET | MAY_ARP_THA;\n            }\n        }\n    } else if (match->flow.dl_type == htons(ETH_TYPE_ARP) ||\n               match->flow.dl_type == htons(ETH_TYPE_RARP)) {\n        may_match = MAY_NW_PROTO | MAY_NW_ADDR | MAY_ARP_SHA | MAY_ARP_THA;\n    } else if (eth_type_mpls(match->flow.dl_type)) {\n        may_match = MAY_MPLS;\n    } else {\n        may_match = 0;\n    }\n\n    /* Clear the fields that may not be matched. */\n    wc = match->wc;\n    if (!(may_match & MAY_NW_ADDR)) {\n        wc.masks.nw_src = wc.masks.nw_dst = htonl(0);\n    }\n    if (!(may_match & MAY_TP_ADDR)) {\n        wc.masks.tp_src = wc.masks.tp_dst = htons(0);\n    }\n    if (!(may_match & MAY_NW_PROTO)) {\n        wc.masks.nw_proto = 0;\n    }\n    if (!(may_match & MAY_IPVx)) {\n        wc.masks.nw_tos = 0;\n        wc.masks.nw_ttl = 0;\n    }\n    if (!(may_match & MAY_ARP_SHA)) {\n        WC_UNMASK_FIELD(&wc, arp_sha);\n    }\n    if (!(may_match & MAY_ARP_THA)) {\n        WC_UNMASK_FIELD(&wc, arp_tha);\n    }\n    if (!(may_match & MAY_IPV6)) {\n        wc.masks.ipv6_src = wc.masks.ipv6_dst = in6addr_any;\n        wc.masks.ipv6_label = htonl(0);\n    }\n    if (!(may_match & MAY_ND_TARGET)) {\n        wc.masks.nd_target = in6addr_any;\n    }\n    if (!(may_match & MAY_MPLS)) {\n        memset(wc.masks.mpls_lse, 0, sizeof wc.masks.mpls_lse);\n    }\n\n    /* Log any changes. */\n    if (!flow_wildcards_equal(&wc, &match->wc)) {\n        bool log = may_log && !VLOG_DROP_INFO(&bad_ofmsg_rl);\n        char *pre = log ? match_to_string(match, OFP_DEFAULT_PRIORITY) : NULL;\n\n        match->wc = wc;\n        match_zero_wildcarded_fields(match);\n\n        if (log) {\n            char *post = match_to_string(match, OFP_DEFAULT_PRIORITY);\n            VLOG_INFO(\"normalization changed ofp_match, details:\");\n            VLOG_INFO(\" pre: %s\", pre);\n            VLOG_INFO(\"post: %s\", post);\n            free(pre);\n            free(post);\n        }\n    }\n}\n\n/* \"Normalizes\" the wildcards in 'match'.  That means:\n *\n *    1. If the type of level N is known, then only the valid fields for that\n *       level may be specified.  For example, ARP does not have a TOS field,\n *       so nw_tos must be wildcarded if 'match' specifies an ARP flow.\n *       Similarly, IPv4 does not have any IPv6 addresses, so ipv6_src and\n *       ipv6_dst (and other fields) must be wildcarded if 'match' specifies an\n *       IPv4 flow.\n *\n *    2. If the type of level N is not known (or not understood by Open\n *       vSwitch), then no fields at all for that level may be specified.  For\n *       example, Open vSwitch does not understand SCTP, an L4 protocol, so the\n *       L4 fields tp_src and tp_dst must be wildcarded if 'match' specifies an\n *       SCTP flow.\n *\n * If this function changes 'match', it logs a rate-limited informational\n * message. */\nvoid\nofputil_normalize_match(struct match *match)\n{\n    ofputil_normalize_match__(match, true);\n}\n\n/* Same as ofputil_normalize_match() without the logging.  Thus, this function\n * is suitable for a program's internal use, whereas ofputil_normalize_match()\n * sense for use on flows received from elsewhere (so that a bug in the program\n * that sent them can be reported and corrected). */\nvoid\nofputil_normalize_match_quiet(struct match *match)\n{\n    ofputil_normalize_match__(match, false);\n}\n\nstatic size_t\nparse_value(const char *s, const char *delimiters)\n{\n    size_t n = 0;\n\n    /* Iterate until we reach a delimiter.\n     *\n     * strchr(s, '\\0') returns s+strlen(s), so this test handles the null\n     * terminator at the end of 's'.  */\n    while (!strchr(delimiters, s[n])) {\n        if (s[n] == '(') {\n            int level = 0;\n            do {\n                switch (s[n]) {\n                case '\\0':\n                    return n;\n                case '(':\n                    level++;\n                    break;\n                case ')':\n                    level--;\n                    break;\n                }\n                n++;\n            } while (level > 0);\n        } else {\n            n++;\n        }\n    }\n    return n;\n}\n\n/* Parses a key or a key-value pair from '*stringp'.\n *\n * On success: Stores the key into '*keyp'.  Stores the value, if present, into\n * '*valuep', otherwise an empty string.  Advances '*stringp' past the end of\n * the key-value pair, preparing it for another call.  '*keyp' and '*valuep'\n * are substrings of '*stringp' created by replacing some of its bytes by null\n * terminators.  Returns true.\n *\n * If '*stringp' is just white space or commas, sets '*keyp' and '*valuep' to\n * NULL and returns false. */\nbool\nofputil_parse_key_value(char **stringp, char **keyp, char **valuep)\n{\n    /* Skip white space and delimiters.  If that brings us to the end of the\n     * input string, we are done and there are no more key-value pairs. */\n    *stringp += strspn(*stringp, \", \\t\\r\\n\");\n    if (**stringp == '\\0') {\n        *keyp = *valuep = NULL;\n        return false;\n    }\n\n    /* Extract the key and the delimiter that ends the key-value pair or begins\n     * the value.  Advance the input position past the key and delimiter. */\n    char *key = *stringp;\n    size_t key_len = strcspn(key, \":=(, \\t\\r\\n\");\n    char key_delim = key[key_len];\n    key[key_len] = '\\0';\n    *stringp += key_len + (key_delim != '\\0');\n\n    /* Figure out what delimiter ends the value:\n     *\n     *     - If key_delim is \":\" or \"=\", the value extends until white space\n     *       or a comma.\n     *\n     *     - If key_delim is \"(\", the value extends until \")\".\n     *\n     * If there is no value, we are done. */\n    const char *value_delims;\n    if (key_delim == ':' || key_delim == '=') {\n        value_delims = \", \\t\\r\\n\";\n    } else if (key_delim == '(') {\n        value_delims = \")\";\n    } else {\n        *keyp = key;\n        *valuep = key + key_len; /* Empty string. */\n        return true;\n    }\n\n    /* Extract the value.  Advance the input position past the value and\n     * delimiter. */\n    char *value = *stringp;\n    size_t value_len = parse_value(value, value_delims);\n    char value_delim = value[value_len];\n    value[value_len] = '\\0';\n    *stringp += value_len + (value_delim != '\\0');\n\n    *keyp = key;\n    *valuep = value;\n    return true;\n}\n\n/* Encode a dump ports request for 'port', the encoded message\n * will be for OpenFlow version 'ofp_version'. Returns message\n * as a struct ofpbuf. Returns encoded message on success, NULL on error */\nstruct ofpbuf *\nofputil_encode_dump_ports_request(enum ofp_version ofp_version, ofp_port_t port)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_port_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST10_PORT_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = htons(ofp_to_u16(port));\n        break;\n    }\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_port_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST11_PORT_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = ofputil_port_to_ofp11(port);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstatic void\nofputil_port_stats_to_ofp10(const struct ofputil_port_stats *ops,\n                            struct ofp10_port_stats *ps10)\n{\n    ps10->port_no = htons(ofp_to_u16(ops->port_no));\n    memset(ps10->pad, 0, sizeof ps10->pad);\n    put_32aligned_be64(&ps10->rx_packets, htonll(ops->stats.rx_packets));\n    put_32aligned_be64(&ps10->tx_packets, htonll(ops->stats.tx_packets));\n    put_32aligned_be64(&ps10->rx_bytes, htonll(ops->stats.rx_bytes));\n    put_32aligned_be64(&ps10->tx_bytes, htonll(ops->stats.tx_bytes));\n    put_32aligned_be64(&ps10->rx_dropped, htonll(ops->stats.rx_dropped));\n    put_32aligned_be64(&ps10->tx_dropped, htonll(ops->stats.tx_dropped));\n    put_32aligned_be64(&ps10->rx_errors, htonll(ops->stats.rx_errors));\n    put_32aligned_be64(&ps10->tx_errors, htonll(ops->stats.tx_errors));\n    put_32aligned_be64(&ps10->rx_frame_err, htonll(ops->stats.rx_frame_errors));\n    put_32aligned_be64(&ps10->rx_over_err, htonll(ops->stats.rx_over_errors));\n    put_32aligned_be64(&ps10->rx_crc_err, htonll(ops->stats.rx_crc_errors));\n    put_32aligned_be64(&ps10->collisions, htonll(ops->stats.collisions));\n}\n\nstatic void\nofputil_port_stats_to_ofp11(const struct ofputil_port_stats *ops,\n                            struct ofp11_port_stats *ps11)\n{\n    ps11->port_no = ofputil_port_to_ofp11(ops->port_no);\n    memset(ps11->pad, 0, sizeof ps11->pad);\n    ps11->rx_packets = htonll(ops->stats.rx_packets);\n    ps11->tx_packets = htonll(ops->stats.tx_packets);\n    ps11->rx_bytes = htonll(ops->stats.rx_bytes);\n    ps11->tx_bytes = htonll(ops->stats.tx_bytes);\n    ps11->rx_dropped = htonll(ops->stats.rx_dropped);\n    ps11->tx_dropped = htonll(ops->stats.tx_dropped);\n    ps11->rx_errors = htonll(ops->stats.rx_errors);\n    ps11->tx_errors = htonll(ops->stats.tx_errors);\n    ps11->rx_frame_err = htonll(ops->stats.rx_frame_errors);\n    ps11->rx_over_err = htonll(ops->stats.rx_over_errors);\n    ps11->rx_crc_err = htonll(ops->stats.rx_crc_errors);\n    ps11->collisions = htonll(ops->stats.collisions);\n}\n\nstatic void\nofputil_port_stats_to_ofp13(const struct ofputil_port_stats *ops,\n                            struct ofp13_port_stats *ps13)\n{\n    ofputil_port_stats_to_ofp11(ops, &ps13->ps);\n    ps13->duration_sec = htonl(ops->duration_sec);\n    ps13->duration_nsec = htonl(ops->duration_nsec);\n}\n\nstatic void\nofputil_append_ofp14_port_stats(const struct ofputil_port_stats *ops,\n                                struct ovs_list *replies)\n{\n    struct ofp14_port_stats_prop_ethernet *eth;\n    struct intel_port_stats_rfc2819 *stats_rfc2819;\n    struct ofp14_port_stats *ps14;\n    struct ofpbuf *reply;\n\n    reply = ofpmp_reserve(replies, sizeof *ps14 + sizeof *eth +\n                          sizeof *stats_rfc2819);\n\n    ps14 = ofpbuf_put_uninit(reply, sizeof *ps14);\n    ps14->length = htons(sizeof *ps14 + sizeof *eth +\n                         sizeof *stats_rfc2819);\n    memset(ps14->pad, 0, sizeof ps14->pad);\n    ps14->port_no = ofputil_port_to_ofp11(ops->port_no);\n    ps14->duration_sec = htonl(ops->duration_sec);\n    ps14->duration_nsec = htonl(ops->duration_nsec);\n    ps14->rx_packets = htonll(ops->stats.rx_packets);\n    ps14->tx_packets = htonll(ops->stats.tx_packets);\n    ps14->rx_bytes = htonll(ops->stats.rx_bytes);\n    ps14->tx_bytes = htonll(ops->stats.tx_bytes);\n    ps14->rx_dropped = htonll(ops->stats.rx_dropped);\n    ps14->tx_dropped = htonll(ops->stats.tx_dropped);\n    ps14->rx_errors = htonll(ops->stats.rx_errors);\n    ps14->tx_errors = htonll(ops->stats.tx_errors);\n\n    eth = ofpprop_put_zeros(reply, OFPPSPT14_ETHERNET, sizeof *eth);\n    eth->rx_frame_err = htonll(ops->stats.rx_frame_errors);\n    eth->rx_over_err = htonll(ops->stats.rx_over_errors);\n    eth->rx_crc_err = htonll(ops->stats.rx_crc_errors);\n    eth->collisions = htonll(ops->stats.collisions);\n\n    uint64_t prop_type = OFPPROP_EXP(INTEL_VENDOR_ID,\n                                     INTEL_PORT_STATS_RFC2819);\n\n    stats_rfc2819 = ofpprop_put_zeros(reply, prop_type,\n                                      sizeof *stats_rfc2819);\n\n    memset(stats_rfc2819->pad, 0, sizeof stats_rfc2819->pad);\n    stats_rfc2819->rx_1_to_64_packets = htonll(ops->stats.rx_1_to_64_packets);\n    stats_rfc2819->rx_65_to_127_packets =\n        htonll(ops->stats.rx_65_to_127_packets);\n    stats_rfc2819->rx_128_to_255_packets =\n        htonll(ops->stats.rx_128_to_255_packets);\n    stats_rfc2819->rx_256_to_511_packets =\n        htonll(ops->stats.rx_256_to_511_packets);\n    stats_rfc2819->rx_512_to_1023_packets =\n        htonll(ops->stats.rx_512_to_1023_packets);\n    stats_rfc2819->rx_1024_to_1522_packets =\n        htonll(ops->stats.rx_1024_to_1522_packets);\n    stats_rfc2819->rx_1523_to_max_packets =\n        htonll(ops->stats.rx_1523_to_max_packets);\n\n    stats_rfc2819->tx_1_to_64_packets = htonll(ops->stats.tx_1_to_64_packets);\n    stats_rfc2819->tx_65_to_127_packets =\n        htonll(ops->stats.tx_65_to_127_packets);\n    stats_rfc2819->tx_128_to_255_packets =\n        htonll(ops->stats.tx_128_to_255_packets);\n    stats_rfc2819->tx_256_to_511_packets =\n        htonll(ops->stats.tx_256_to_511_packets);\n    stats_rfc2819->tx_512_to_1023_packets =\n        htonll(ops->stats.tx_512_to_1023_packets);\n    stats_rfc2819->tx_1024_to_1522_packets =\n        htonll(ops->stats.tx_1024_to_1522_packets);\n    stats_rfc2819->tx_1523_to_max_packets =\n        htonll(ops->stats.tx_1523_to_max_packets);\n\n    stats_rfc2819->tx_multicast_packets =\n        htonll(ops->stats.tx_multicast_packets);\n    stats_rfc2819->rx_broadcast_packets =\n        htonll(ops->stats.rx_broadcast_packets);\n    stats_rfc2819->tx_broadcast_packets =\n        htonll(ops->stats.tx_broadcast_packets);\n    stats_rfc2819->rx_undersized_errors =\n        htonll(ops->stats.rx_undersized_errors);\n    stats_rfc2819->rx_oversize_errors =\n        htonll(ops->stats.rx_oversize_errors);\n    stats_rfc2819->rx_fragmented_errors =\n        htonll(ops->stats.rx_fragmented_errors);\n    stats_rfc2819->rx_jabber_errors =\n        htonll(ops->stats.rx_jabber_errors);\n}\n\n/* Encode a ports stat for 'ops' and append it to 'replies'. */\nvoid\nofputil_append_port_stat(struct ovs_list *replies,\n                         const struct ofputil_port_stats *ops)\n{\n    switch (ofpmp_version(replies)) {\n    case OFP13_VERSION: {\n        struct ofp13_port_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_port_stats_to_ofp13(ops, reply);\n        break;\n    }\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        struct ofp11_port_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_port_stats_to_ofp11(ops, reply);\n        break;\n    }\n\n    case OFP10_VERSION: {\n        struct ofp10_port_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_port_stats_to_ofp10(ops, reply);\n        break;\n    }\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_append_ofp14_port_stats(ops, replies);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic enum ofperr\nofputil_port_stats_from_ofp10(struct ofputil_port_stats *ops,\n                              const struct ofp10_port_stats *ps10)\n{\n\n    ops->port_no = u16_to_ofp(ntohs(ps10->port_no));\n    ops->stats.rx_packets = ntohll(get_32aligned_be64(&ps10->rx_packets));\n    ops->stats.tx_packets = ntohll(get_32aligned_be64(&ps10->tx_packets));\n    ops->stats.rx_bytes = ntohll(get_32aligned_be64(&ps10->rx_bytes));\n    ops->stats.tx_bytes = ntohll(get_32aligned_be64(&ps10->tx_bytes));\n    ops->stats.rx_dropped = ntohll(get_32aligned_be64(&ps10->rx_dropped));\n    ops->stats.tx_dropped = ntohll(get_32aligned_be64(&ps10->tx_dropped));\n    ops->stats.rx_errors = ntohll(get_32aligned_be64(&ps10->rx_errors));\n    ops->stats.tx_errors = ntohll(get_32aligned_be64(&ps10->tx_errors));\n    ops->stats.rx_frame_errors =\n        ntohll(get_32aligned_be64(&ps10->rx_frame_err));\n    ops->stats.rx_over_errors = ntohll(get_32aligned_be64(&ps10->rx_over_err));\n    ops->stats.rx_crc_errors = ntohll(get_32aligned_be64(&ps10->rx_crc_err));\n    ops->stats.collisions = ntohll(get_32aligned_be64(&ps10->collisions));\n    ops->duration_sec = ops->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_port_stats_from_ofp11(struct ofputil_port_stats *ops,\n                              const struct ofp11_port_stats *ps11)\n{\n    enum ofperr error;\n\n    error = ofputil_port_from_ofp11(ps11->port_no, &ops->port_no);\n    if (error) {\n        return error;\n    }\n\n    ops->stats.rx_packets = ntohll(ps11->rx_packets);\n    ops->stats.tx_packets = ntohll(ps11->tx_packets);\n    ops->stats.rx_bytes = ntohll(ps11->rx_bytes);\n    ops->stats.tx_bytes = ntohll(ps11->tx_bytes);\n    ops->stats.rx_dropped = ntohll(ps11->rx_dropped);\n    ops->stats.tx_dropped = ntohll(ps11->tx_dropped);\n    ops->stats.rx_errors = ntohll(ps11->rx_errors);\n    ops->stats.tx_errors = ntohll(ps11->tx_errors);\n    ops->stats.rx_frame_errors = ntohll(ps11->rx_frame_err);\n    ops->stats.rx_over_errors = ntohll(ps11->rx_over_err);\n    ops->stats.rx_crc_errors = ntohll(ps11->rx_crc_err);\n    ops->stats.collisions = ntohll(ps11->collisions);\n    ops->duration_sec = ops->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_port_stats_from_ofp13(struct ofputil_port_stats *ops,\n                              const struct ofp13_port_stats *ps13)\n{\n    enum ofperr error = ofputil_port_stats_from_ofp11(ops, &ps13->ps);\n    if (!error) {\n        ops->duration_sec = ntohl(ps13->duration_sec);\n        ops->duration_nsec = ntohl(ps13->duration_nsec);\n    }\n    return error;\n}\n\nstatic enum ofperr\nparse_ofp14_port_stats_ethernet_property(const struct ofpbuf *payload,\n                                         struct ofputil_port_stats *ops)\n{\n    const struct ofp14_port_stats_prop_ethernet *eth = payload->data;\n\n    if (payload->size != sizeof *eth) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    ops->stats.rx_frame_errors = ntohll(eth->rx_frame_err);\n    ops->stats.rx_over_errors = ntohll(eth->rx_over_err);\n    ops->stats.rx_crc_errors = ntohll(eth->rx_crc_err);\n    ops->stats.collisions = ntohll(eth->collisions);\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_intel_port_stats_rfc2819_property(const struct ofpbuf *payload,\n                                        struct ofputil_port_stats *ops)\n{\n    const struct intel_port_stats_rfc2819 *rfc2819 = payload->data;\n\n    if (payload->size != sizeof *rfc2819) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n    ops->stats.rx_1_to_64_packets = ntohll(rfc2819->rx_1_to_64_packets);\n    ops->stats.rx_65_to_127_packets = ntohll(rfc2819->rx_65_to_127_packets);\n    ops->stats.rx_128_to_255_packets = ntohll(rfc2819->rx_128_to_255_packets);\n    ops->stats.rx_256_to_511_packets = ntohll(rfc2819->rx_256_to_511_packets);\n    ops->stats.rx_512_to_1023_packets =\n        ntohll(rfc2819->rx_512_to_1023_packets);\n    ops->stats.rx_1024_to_1522_packets =\n        ntohll(rfc2819->rx_1024_to_1522_packets);\n    ops->stats.rx_1523_to_max_packets =\n        ntohll(rfc2819->rx_1523_to_max_packets);\n\n    ops->stats.tx_1_to_64_packets = ntohll(rfc2819->tx_1_to_64_packets);\n    ops->stats.tx_65_to_127_packets = ntohll(rfc2819->tx_65_to_127_packets);\n    ops->stats.tx_128_to_255_packets = ntohll(rfc2819->tx_128_to_255_packets);\n    ops->stats.tx_256_to_511_packets = ntohll(rfc2819->tx_256_to_511_packets);\n    ops->stats.tx_512_to_1023_packets =\n        ntohll(rfc2819->tx_512_to_1023_packets);\n    ops->stats.tx_1024_to_1522_packets =\n        ntohll(rfc2819->tx_1024_to_1522_packets);\n    ops->stats.tx_1523_to_max_packets =\n        ntohll(rfc2819->tx_1523_to_max_packets);\n\n    ops->stats.tx_multicast_packets = ntohll(rfc2819->tx_multicast_packets);\n    ops->stats.rx_broadcast_packets = ntohll(rfc2819->rx_broadcast_packets);\n    ops->stats.tx_broadcast_packets = ntohll(rfc2819->tx_broadcast_packets);\n    ops->stats.rx_undersized_errors = ntohll(rfc2819->rx_undersized_errors);\n\n    ops->stats.rx_oversize_errors = ntohll(rfc2819->rx_oversize_errors);\n    ops->stats.rx_fragmented_errors = ntohll(rfc2819->rx_fragmented_errors);\n    ops->stats.rx_jabber_errors = ntohll(rfc2819->rx_jabber_errors);\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_intel_port_stats_property(const struct ofpbuf *payload,\n                                uint32_t exp_type,\n                                struct ofputil_port_stats *ops)\n{\n    enum ofperr error;\n\n    switch (exp_type) {\n    case INTEL_PORT_STATS_RFC2819:\n        error = parse_intel_port_stats_rfc2819_property(payload, ops);\n        break;\n    default:\n        error = OFPERR_OFPBPC_BAD_EXP_TYPE;\n        break;\n    }\n\n    return error;\n}\n\nstatic enum ofperr\nofputil_pull_ofp14_port_stats(struct ofputil_port_stats *ops,\n                              struct ofpbuf *msg)\n{\n    const struct ofp14_port_stats *ps14 = ofpbuf_try_pull(msg, sizeof *ps14);\n    if (!ps14) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    size_t len = ntohs(ps14->length);\n    if (len < sizeof *ps14 || len - sizeof *ps14 > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= sizeof *ps14;\n\n    enum ofperr error = ofputil_port_from_ofp11(ps14->port_no, &ops->port_no);\n    if (error) {\n        return error;\n    }\n\n    ops->duration_sec = ntohl(ps14->duration_sec);\n    ops->duration_nsec = ntohl(ps14->duration_nsec);\n    ops->stats.rx_packets = ntohll(ps14->rx_packets);\n    ops->stats.tx_packets = ntohll(ps14->tx_packets);\n    ops->stats.rx_bytes = ntohll(ps14->rx_bytes);\n    ops->stats.tx_bytes = ntohll(ps14->tx_bytes);\n    ops->stats.rx_dropped = ntohll(ps14->rx_dropped);\n    ops->stats.tx_dropped = ntohll(ps14->tx_dropped);\n    ops->stats.rx_errors = ntohll(ps14->rx_errors);\n    ops->stats.tx_errors = ntohll(ps14->tx_errors);\n\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type = 0;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n        switch (type) {\n        case OFPPSPT14_ETHERNET:\n            error = parse_ofp14_port_stats_ethernet_property(&payload, ops);\n            break;\n        case OFPPROP_EXP(INTEL_VENDOR_ID, INTEL_PORT_STATS_RFC2819):\n            error = parse_intel_port_stats_property(&payload,\n                                                    INTEL_PORT_STATS_RFC2819,\n                                                    ops);\n            break;\n        default:\n            error = OFPPROP_UNKNOWN(true, \"port stats\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\n/* Returns the number of port stats elements in OFPTYPE_PORT_STATS_REPLY\n * message 'oh'. */\nsize_t\nofputil_count_port_stats(const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    for (size_t n = 0; ; n++) {\n        struct ofputil_port_stats ps;\n        if (ofputil_decode_port_stats(&ps, &b)) {\n            return n;\n        }\n    }\n}\n\n/* Converts an OFPST_PORT_STATS reply in 'msg' into an abstract\n * ofputil_port_stats in 'ps'.\n *\n * Multiple OFPST_PORT_STATS replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  The caller must initially leave 'msg''s layer pointers\n * null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_port_stats(struct ofputil_port_stats *ps, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    memset(&(ps->stats), 0xFF, sizeof (ps->stats));\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_PORT_REPLY) {\n        return ofputil_pull_ofp14_port_stats(ps, msg);\n    } else if (raw == OFPRAW_OFPST13_PORT_REPLY) {\n        const struct ofp13_port_stats *ps13;\n        ps13 = ofpbuf_try_pull(msg, sizeof *ps13);\n        if (!ps13) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp13(ps, ps13);\n    } else if (raw == OFPRAW_OFPST11_PORT_REPLY) {\n        const struct ofp11_port_stats *ps11;\n\n        ps11 = ofpbuf_try_pull(msg, sizeof *ps11);\n        if (!ps11) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp11(ps, ps11);\n    } else if (raw == OFPRAW_OFPST10_PORT_REPLY) {\n        const struct ofp10_port_stats *ps10;\n\n        ps10 = ofpbuf_try_pull(msg, sizeof *ps10);\n        if (!ps10) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp10(ps, ps10);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n bad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_PORT reply has %\"PRIu32\" leftover \"\n                 \"bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n\n/* Parse a port status request message into a 16 bit OpenFlow 1.0\n * port number and stores the latter in '*ofp10_port'.\n * Returns 0 if successful, otherwise an OFPERR_* number. */\nenum ofperr\nofputil_decode_port_stats_request(const struct ofp_header *request,\n                                  ofp_port_t *ofp10_port)\n{\n    switch ((enum ofp_version)request->version) {\n    case OFP16_VERSION:\n    case OFP15_VERSION:\n    case OFP14_VERSION:\n    case OFP13_VERSION:\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        const struct ofp11_port_stats_request *psr11 = ofpmsg_body(request);\n        return ofputil_port_from_ofp11(psr11->port_no, ofp10_port);\n    }\n\n    case OFP10_VERSION: {\n        const struct ofp10_port_stats_request *psr10 = ofpmsg_body(request);\n        *ofp10_port = u16_to_ofp(ntohs(psr10->port_no));\n        return 0;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic void\nofputil_ipfix_stats_to_reply(const struct ofputil_ipfix_stats *ois,\n                            struct nx_ipfix_stats_reply *reply)\n{\n    reply->collector_set_id = htonl(ois->collector_set_id);\n    reply->total_flows = htonll(ois->total_flows);\n    reply->current_flows = htonll(ois->current_flows);\n    reply->pkts = htonll(ois->pkts);\n    reply->ipv4_pkts = htonll(ois->ipv4_pkts);\n    reply->ipv6_pkts = htonll(ois->ipv6_pkts);\n    reply->error_pkts = htonll(ois->error_pkts);\n    reply->ipv4_error_pkts = htonll(ois->ipv4_error_pkts);\n    reply->ipv6_error_pkts = htonll(ois->ipv6_error_pkts);\n    reply->tx_pkts = htonll(ois->tx_pkts);\n    reply->tx_errors = htonll(ois->tx_errors);\n    memset(reply->pad, 0, sizeof reply->pad);\n}\n\n/* Encode a ipfix stat for 'ois' and append it to 'replies'. */\nvoid\nofputil_append_ipfix_stat(struct ovs_list *replies,\n                         const struct ofputil_ipfix_stats *ois)\n{\n    struct nx_ipfix_stats_reply *reply = ofpmp_append(replies, sizeof *reply);\n    ofputil_ipfix_stats_to_reply(ois, reply);\n}\n\nstatic enum ofperr\nofputil_ipfix_stats_from_nx(struct ofputil_ipfix_stats *is,\n                            const struct nx_ipfix_stats_reply *reply)\n{\n    is->collector_set_id = ntohl(reply->collector_set_id);\n    is->total_flows = ntohll(reply->total_flows);\n    is->current_flows = ntohll(reply->current_flows);\n    is->pkts = ntohll(reply->pkts);\n    is->ipv4_pkts = ntohll(reply->ipv4_pkts);\n    is->ipv6_pkts = ntohll(reply->ipv6_pkts);\n    is->error_pkts = ntohll(reply->error_pkts);\n    is->ipv4_error_pkts = ntohll(reply->ipv4_error_pkts);\n    is->ipv6_error_pkts = ntohll(reply->ipv6_error_pkts);\n    is->tx_pkts = ntohll(reply->tx_pkts);\n    is->tx_errors = ntohll(reply->tx_errors);\n\n    return 0;\n}\n\nint\nofputil_pull_ipfix_stats(struct ofputil_ipfix_stats *is, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    memset(is, 0xFF, sizeof (*is));\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_NXST_IPFIX_BRIDGE_REPLY ||\n               raw == OFPRAW_NXST_IPFIX_FLOW_REPLY) {\n        struct nx_ipfix_stats_reply *reply;\n\n        reply = ofpbuf_try_pull(msg, sizeof *reply);\n        return ofputil_ipfix_stats_from_nx(is, reply);\n    } else {\n        OVS_NOT_REACHED();\n    }\n}\n\n\n/* Returns the number of ipfix stats elements in\n * OFPTYPE_IPFIX_BRIDGE_STATS_REPLY or OFPTYPE_IPFIX_FLOW_STATS_REPLY\n * message 'oh'. */\nsize_t\nofputil_count_ipfix_stats(const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    return b.size / sizeof(struct ofputil_ipfix_stats);\n}\n\n/* Frees all of the \"struct ofputil_bucket\"s in the 'buckets' list. */\nvoid\nofputil_bucket_list_destroy(struct ovs_list *buckets)\n{\n    struct ofputil_bucket *bucket;\n\n    LIST_FOR_EACH_POP (bucket, list_node, buckets) {\n        free(bucket->ofpacts);\n        free(bucket);\n    }\n}\n\n/* Clones 'bucket' and its ofpacts data */\nstatic struct ofputil_bucket *\nofputil_bucket_clone_data(const struct ofputil_bucket *bucket)\n{\n    struct ofputil_bucket *new;\n\n    new = xmemdup(bucket, sizeof *bucket);\n    new->ofpacts = xmemdup(bucket->ofpacts, bucket->ofpacts_len);\n\n    return new;\n}\n\n/* Clones each of the buckets in the list 'src' appending them\n * in turn to 'dest' which should be an initialised list.\n * An exception is that if the pointer value of a bucket in 'src'\n * matches 'skip' then it is not cloned or appended to 'dest'.\n * This allows all of 'src' or 'all of 'src' except 'skip' to\n * be cloned and appended to 'dest'. */\nvoid\nofputil_bucket_clone_list(struct ovs_list *dest, const struct ovs_list *src,\n                          const struct ofputil_bucket *skip)\n{\n    struct ofputil_bucket *bucket;\n\n    LIST_FOR_EACH (bucket, list_node, src) {\n        struct ofputil_bucket *new_bucket;\n\n        if (bucket == skip) {\n            continue;\n        }\n\n        new_bucket = ofputil_bucket_clone_data(bucket);\n        ovs_list_push_back(dest, &new_bucket->list_node);\n    }\n}\n\n/* Find a bucket in the list 'buckets' whose bucket id is 'bucket_id'\n * Returns the first bucket found or NULL if no buckets are found. */\nstruct ofputil_bucket *\nofputil_bucket_find(const struct ovs_list *buckets, uint32_t bucket_id)\n{\n    struct ofputil_bucket *bucket;\n\n    if (bucket_id > OFPG15_BUCKET_MAX) {\n        return NULL;\n    }\n\n    LIST_FOR_EACH (bucket, list_node, buckets) {\n        if (bucket->bucket_id == bucket_id) {\n            return bucket;\n        }\n    }\n\n    return NULL;\n}\n\n/* Returns true if more than one bucket in the list 'buckets'\n * have the same bucket id. Returns false otherwise. */\nbool\nofputil_bucket_check_duplicate_id(const struct ovs_list *buckets)\n{\n    struct ofputil_bucket *i, *j;\n\n    LIST_FOR_EACH (i, list_node, buckets) {\n        LIST_FOR_EACH_REVERSE (j, list_node, buckets) {\n            if (i == j) {\n                break;\n            }\n            if (i->bucket_id == j->bucket_id) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/* Returns the bucket at the front of the list 'buckets'.\n * Undefined if 'buckets is empty. */\nstruct ofputil_bucket *\nofputil_bucket_list_front(const struct ovs_list *buckets)\n{\n    static struct ofputil_bucket *bucket;\n\n    ASSIGN_CONTAINER(bucket, ovs_list_front(buckets), list_node);\n\n    return bucket;\n}\n\n/* Returns the bucket at the back of the list 'buckets'.\n * Undefined if 'buckets is empty. */\nstruct ofputil_bucket *\nofputil_bucket_list_back(const struct ovs_list *buckets)\n{\n    static struct ofputil_bucket *bucket;\n\n    ASSIGN_CONTAINER(bucket, ovs_list_back(buckets), list_node);\n\n    return bucket;\n}\n\n/* Returns an OpenFlow group stats request for OpenFlow version 'ofp_version',\n * that requests stats for group 'group_id'.  (Use OFPG_ALL to request stats\n * for all groups.)\n *\n * Group statistics include packet and byte counts for each group. */\nstruct ofpbuf *\nofputil_encode_group_stats_request(enum ofp_version ofp_version,\n                                   uint32_t group_id)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        ovs_fatal(0, \"dump-group-stats needs OpenFlow 1.1 or later \"\n                     \"(\\'-O OpenFlow11\\')\");\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_group_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST11_GROUP_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->group_id = htonl(group_id);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nvoid\nofputil_uninit_group_desc(struct ofputil_group_desc *gd)\n{\n    ofputil_bucket_list_destroy(&gd->buckets);\n    ofputil_group_properties_destroy(&gd->props);\n}\n\n/* Decodes the OpenFlow group description request in 'oh', returning the group\n * whose description is requested, or OFPG_ALL if stats for all groups was\n * requested. */\nuint32_t\nofputil_decode_group_desc_request(const struct ofp_header *oh)\n{\n    struct ofpbuf request = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&request);\n    if (raw == OFPRAW_OFPST11_GROUP_DESC_REQUEST) {\n        return OFPG_ALL;\n    } else if (raw == OFPRAW_OFPST15_GROUP_DESC_REQUEST) {\n        ovs_be32 *group_id = ofpbuf_pull(&request, sizeof *group_id);\n        return ntohl(*group_id);\n    } else {\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Returns an OpenFlow group description request for OpenFlow version\n * 'ofp_version', that requests stats for group 'group_id'.  Use OFPG_ALL to\n * request stats for all groups (OpenFlow 1.4 and earlier always request all\n * groups).\n *\n * Group descriptions include the bucket and action configuration for each\n * group. */\nstruct ofpbuf *\nofputil_encode_group_desc_request(enum ofp_version ofp_version,\n                                  uint32_t group_id)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        ovs_fatal(0, \"dump-groups needs OpenFlow 1.1 or later \"\n                     \"(\\'-O OpenFlow11\\')\");\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST11_GROUP_DESC_REQUEST,\n                               ofp_version, 0);\n        break;\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp15_group_desc_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST15_GROUP_DESC_REQUEST,\n                               ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->group_id = htonl(group_id);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstatic void\nofputil_group_bucket_counters_to_ofp11(const struct ofputil_group_stats *gs,\n                                    struct ofp11_bucket_counter bucket_cnts[])\n{\n    int i;\n\n    for (i = 0; i < gs->n_buckets; i++) {\n       bucket_cnts[i].packet_count = htonll(gs->bucket_stats[i].packet_count);\n       bucket_cnts[i].byte_count = htonll(gs->bucket_stats[i].byte_count);\n    }\n}\n\nstatic void\nofputil_group_stats_to_ofp11(const struct ofputil_group_stats *gs,\n                             struct ofp11_group_stats *gs11, size_t length,\n                             struct ofp11_bucket_counter bucket_cnts[])\n{\n    memset(gs11, 0, sizeof *gs11);\n    gs11->length = htons(length);\n    gs11->group_id = htonl(gs->group_id);\n    gs11->ref_count = htonl(gs->ref_count);\n    gs11->packet_count = htonll(gs->packet_count);\n    gs11->byte_count = htonll(gs->byte_count);\n    ofputil_group_bucket_counters_to_ofp11(gs, bucket_cnts);\n}\n\nstatic void\nofputil_group_stats_to_ofp13(const struct ofputil_group_stats *gs,\n                             struct ofp13_group_stats *gs13, size_t length,\n                             struct ofp11_bucket_counter bucket_cnts[])\n{\n    ofputil_group_stats_to_ofp11(gs, &gs13->gs, length, bucket_cnts);\n    gs13->duration_sec = htonl(gs->duration_sec);\n    gs13->duration_nsec = htonl(gs->duration_nsec);\n\n}\n\n/* Encodes 'gs' properly for the format of the list of group statistics\n * replies already begun in 'replies' and appends it to the list.  'replies'\n * must have originally been initialized with ofpmp_init(). */\nvoid\nofputil_append_group_stats(struct ovs_list *replies,\n                           const struct ofputil_group_stats *gs)\n{\n    size_t bucket_counter_size;\n    struct ofp11_bucket_counter *bucket_counters;\n    size_t length;\n\n    bucket_counter_size = gs->n_buckets * sizeof(struct ofp11_bucket_counter);\n\n    switch (ofpmp_version(replies)) {\n    case OFP11_VERSION:\n    case OFP12_VERSION:{\n            struct ofp11_group_stats *gs11;\n\n            length = sizeof *gs11 + bucket_counter_size;\n            gs11 = ofpmp_append(replies, length);\n            bucket_counters = (struct ofp11_bucket_counter *)(gs11 + 1);\n            ofputil_group_stats_to_ofp11(gs, gs11, length, bucket_counters);\n            break;\n        }\n\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n            struct ofp13_group_stats *gs13;\n\n            length = sizeof *gs13 + bucket_counter_size;\n            gs13 = ofpmp_append(replies, length);\n            bucket_counters = (struct ofp11_bucket_counter *)(gs13 + 1);\n            ofputil_group_stats_to_ofp13(gs, gs13, length, bucket_counters);\n            break;\n        }\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n/* Returns an OpenFlow group features request for OpenFlow version\n * 'ofp_version'. */\nstruct ofpbuf *\nofputil_encode_group_features_request(enum ofp_version ofp_version)\n{\n    struct ofpbuf *request = NULL;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n        ovs_fatal(0, \"dump-group-features needs OpenFlow 1.2 or later \"\n                     \"(\\'-O OpenFlow12\\')\");\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST12_GROUP_FEATURES_REQUEST,\n                               ofp_version, 0);\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\n/* Returns a OpenFlow message that encodes 'features' properly as a reply to\n * group features request 'request'. */\nstruct ofpbuf *\nofputil_encode_group_features_reply(\n    const struct ofputil_group_features *features,\n    const struct ofp_header *request)\n{\n    struct ofp12_group_features_stats *ogf;\n    struct ofpbuf *reply;\n    int i;\n\n    reply = ofpraw_alloc_xid(OFPRAW_OFPST12_GROUP_FEATURES_REPLY,\n                             request->version, request->xid, 0);\n    ogf = ofpbuf_put_zeros(reply, sizeof *ogf);\n    ogf->types = htonl(features->types);\n    ogf->capabilities = htonl(features->capabilities);\n    for (i = 0; i < OFPGT12_N_TYPES; i++) {\n        ogf->max_groups[i] = htonl(features->max_groups[i]);\n        ogf->actions[i] = ofpact_bitmap_to_openflow(features->ofpacts[i],\n                                                    request->version);\n    }\n\n    return reply;\n}\n\n/* Decodes group features reply 'oh' into 'features'. */\nvoid\nofputil_decode_group_features_reply(const struct ofp_header *oh,\n                                    struct ofputil_group_features *features)\n{\n    const struct ofp12_group_features_stats *ogf = ofpmsg_body(oh);\n    int i;\n\n    features->types = ntohl(ogf->types);\n    features->capabilities = ntohl(ogf->capabilities);\n    for (i = 0; i < OFPGT12_N_TYPES; i++) {\n        features->max_groups[i] = ntohl(ogf->max_groups[i]);\n        features->ofpacts[i] = ofpact_bitmap_from_openflow(\n            ogf->actions[i], oh->version);\n    }\n}\n\n/* Parse a group status request message into a 32 bit OpenFlow 1.1\n * group ID and stores the latter in '*group_id'.\n * Returns 0 if successful, otherwise an OFPERR_* number. */\nenum ofperr\nofputil_decode_group_stats_request(const struct ofp_header *request,\n                                   uint32_t *group_id)\n{\n    const struct ofp11_group_stats_request *gsr11 = ofpmsg_body(request);\n    *group_id = ntohl(gsr11->group_id);\n    return 0;\n}\n\n/* Converts a group stats reply in 'msg' into an abstract ofputil_group_stats\n * in 'gs'.  Assigns freshly allocated memory to gs->bucket_stats for the\n * caller to eventually free.\n *\n * Multiple group stats replies can be packed into a single OpenFlow message.\n * Calling this function multiple times for a single 'msg' iterates through the\n * replies.  The caller must initially leave 'msg''s layer pointers null and\n * not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_group_stats_reply(struct ofpbuf *msg,\n                                 struct ofputil_group_stats *gs)\n{\n    struct ofp11_bucket_counter *obc;\n    struct ofp11_group_stats *ogs11;\n    enum ofpraw raw;\n    enum ofperr error;\n    size_t base_len;\n    size_t length;\n    size_t i;\n\n    gs->bucket_stats = NULL;\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    if (raw == OFPRAW_OFPST11_GROUP_REPLY) {\n        base_len = sizeof *ogs11;\n        ogs11 = ofpbuf_try_pull(msg, sizeof *ogs11);\n        gs->duration_sec = gs->duration_nsec = UINT32_MAX;\n    } else if (raw == OFPRAW_OFPST13_GROUP_REPLY) {\n        struct ofp13_group_stats *ogs13;\n\n        base_len = sizeof *ogs13;\n        ogs13 = ofpbuf_try_pull(msg, sizeof *ogs13);\n        if (ogs13) {\n            ogs11 = &ogs13->gs;\n            gs->duration_sec = ntohl(ogs13->duration_sec);\n            gs->duration_nsec = ntohl(ogs13->duration_nsec);\n        } else {\n            ogs11 = NULL;\n        }\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (!ogs11) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s reply has %\"PRIu32\" leftover bytes at end\",\n                     ofpraw_get_name(raw), msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    length = ntohs(ogs11->length);\n    if (length < sizeof base_len) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s reply claims invalid length %\"PRIuSIZE,\n                     ofpraw_get_name(raw), length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    gs->group_id = ntohl(ogs11->group_id);\n    gs->ref_count = ntohl(ogs11->ref_count);\n    gs->packet_count = ntohll(ogs11->packet_count);\n    gs->byte_count = ntohll(ogs11->byte_count);\n\n    gs->n_buckets = (length - base_len) / sizeof *obc;\n    obc = ofpbuf_try_pull(msg, gs->n_buckets * sizeof *obc);\n    if (!obc) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s reply has %\"PRIu32\" leftover bytes at end\",\n                     ofpraw_get_name(raw), msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    gs->bucket_stats = xmalloc(gs->n_buckets * sizeof *gs->bucket_stats);\n    for (i = 0; i < gs->n_buckets; i++) {\n        gs->bucket_stats[i].packet_count = ntohll(obc[i].packet_count);\n        gs->bucket_stats[i].byte_count = ntohll(obc[i].byte_count);\n    }\n\n    return 0;\n}\n\nstatic void\nofputil_put_ofp11_bucket(const struct ofputil_bucket *bucket,\n                         struct ofpbuf *openflow, enum ofp_version ofp_version)\n{\n    struct ofp11_bucket *ob;\n    size_t start;\n\n    start = openflow->size;\n    ofpbuf_put_zeros(openflow, sizeof *ob);\n    ofpacts_put_openflow_actions(bucket->ofpacts, bucket->ofpacts_len,\n                                openflow, ofp_version);\n    ob = ofpbuf_at_assert(openflow, start, sizeof *ob);\n    ob->len = htons(openflow->size - start);\n    ob->weight = htons(bucket->weight);\n    ob->watch_port = ofputil_port_to_ofp11(bucket->watch_port);\n    ob->watch_group = htonl(bucket->watch_group);\n}\n\nstatic void\nofputil_put_ofp15_bucket(const struct ofputil_bucket *bucket,\n                         uint32_t bucket_id, enum ofp11_group_type group_type,\n                         struct ofpbuf *openflow, enum ofp_version ofp_version)\n{\n    struct ofp15_bucket *ob;\n    size_t start, actions_start, actions_len;\n\n    start = openflow->size;\n    ofpbuf_put_zeros(openflow, sizeof *ob);\n\n    actions_start = openflow->size;\n    ofpacts_put_openflow_actions(bucket->ofpacts, bucket->ofpacts_len,\n                                 openflow, ofp_version);\n    actions_len = openflow->size - actions_start;\n\n    if (group_type == OFPGT11_SELECT) {\n        ofpprop_put_u16(openflow, OFPGBPT15_WEIGHT, bucket->weight);\n    }\n    if (bucket->watch_port != OFPP_ANY) {\n        ofpprop_put_be32(openflow, OFPGBPT15_WATCH_PORT,\n                         ofputil_port_to_ofp11(bucket->watch_port));\n    }\n    if (bucket->watch_group != OFPG_ANY) {\n        ofpprop_put_u32(openflow, OFPGBPT15_WATCH_GROUP, bucket->watch_group);\n    }\n\n    ob = ofpbuf_at_assert(openflow, start, sizeof *ob);\n    ob->len = htons(openflow->size - start);\n    ob->action_array_len = htons(actions_len);\n    ob->bucket_id = htonl(bucket_id);\n}\n\nstatic void\nofputil_put_group_prop_ntr_selection_method(enum ofp_version ofp_version,\n                                            const struct ofputil_group_props *gp,\n                                            struct ofpbuf *openflow)\n{\n    struct ntr_group_prop_selection_method *prop;\n    size_t start;\n\n    start = openflow->size;\n    ofpbuf_put_zeros(openflow, sizeof *prop);\n    oxm_put_field_array(openflow, &gp->fields, ofp_version);\n    prop = ofpbuf_at_assert(openflow, start, sizeof *prop);\n    prop->type = htons(OFPGPT15_EXPERIMENTER);\n    prop->experimenter = htonl(NTR_VENDOR_ID);\n    prop->exp_type = htonl(NTRT_SELECTION_METHOD);\n    strcpy(prop->selection_method, gp->selection_method);\n    prop->selection_method_param = htonll(gp->selection_method_param);\n    ofpprop_end(openflow, start);\n}\n\nstatic void\nofputil_append_ofp11_group_desc_reply(const struct ofputil_group_desc *gds,\n                                      const struct ovs_list *buckets,\n                                      struct ovs_list *replies,\n                                      enum ofp_version version)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    struct ofp11_group_desc_stats *ogds;\n    struct ofputil_bucket *bucket;\n    size_t start_ogds;\n\n    start_ogds = reply->size;\n    ofpbuf_put_zeros(reply, sizeof *ogds);\n    LIST_FOR_EACH (bucket, list_node, buckets) {\n        ofputil_put_ofp11_bucket(bucket, reply, version);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->length = htons(reply->size - start_ogds);\n    ogds->type = gds->type;\n    ogds->group_id = htonl(gds->group_id);\n\n    ofpmp_postappend(replies, start_ogds);\n}\n\nstatic void\nofputil_append_ofp15_group_desc_reply(const struct ofputil_group_desc *gds,\n                                      const struct ovs_list *buckets,\n                                      struct ovs_list *replies,\n                                      enum ofp_version version)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    struct ofp15_group_desc_stats *ogds;\n    struct ofputil_bucket *bucket;\n    size_t start_ogds, start_buckets;\n\n    start_ogds = reply->size;\n    ofpbuf_put_zeros(reply, sizeof *ogds);\n    start_buckets = reply->size;\n    LIST_FOR_EACH (bucket, list_node, buckets) {\n        ofputil_put_ofp15_bucket(bucket, bucket->bucket_id,\n                                 gds->type, reply, version);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->type = gds->type;\n    ogds->group_id = htonl(gds->group_id);\n    ogds->bucket_list_len =  htons(reply->size - start_buckets);\n\n    /* Add group properties */\n    if (gds->props.selection_method[0]) {\n        ofputil_put_group_prop_ntr_selection_method(version, &gds->props,\n                                                    reply);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->length = htons(reply->size - start_ogds);\n\n    ofpmp_postappend(replies, start_ogds);\n}\n\n/* Appends a group stats reply that contains the data in 'gds' to those already\n * present in the list of ofpbufs in 'replies'.  'replies' should have been\n * initialized with ofpmp_init(). */\nvoid\nofputil_append_group_desc_reply(const struct ofputil_group_desc *gds,\n                                const struct ovs_list *buckets,\n                                struct ovs_list *replies)\n{\n    enum ofp_version version = ofpmp_version(replies);\n\n    switch (version)\n    {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        ofputil_append_ofp11_group_desc_reply(gds, buckets, replies, version);\n        break;\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_append_ofp15_group_desc_reply(gds, buckets, replies, version);\n        break;\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic enum ofperr\nofputil_pull_ofp11_buckets(struct ofpbuf *msg, size_t buckets_length,\n                           enum ofp_version version, struct ovs_list *buckets)\n{\n    struct ofp11_bucket *ob;\n    uint32_t bucket_id = 0;\n\n    ovs_list_init(buckets);\n    while (buckets_length > 0) {\n        struct ofputil_bucket *bucket;\n        struct ofpbuf ofpacts;\n        enum ofperr error;\n        size_t ob_len;\n\n        ob = (buckets_length >= sizeof *ob\n              ? ofpbuf_try_pull(msg, sizeof *ob)\n              : NULL);\n        if (!ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"buckets end with %\"PRIuSIZE\" leftover bytes\",\n                         buckets_length);\n            ofputil_bucket_list_destroy(buckets);\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        }\n\n        ob_len = ntohs(ob->len);\n        if (ob_len < sizeof *ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" is not valid\", ob_len);\n            ofputil_bucket_list_destroy(buckets);\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        } else if (ob_len > buckets_length) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" exceeds remaining buckets data size %\"PRIuSIZE,\n                         ob_len, buckets_length);\n            ofputil_bucket_list_destroy(buckets);\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        }\n        buckets_length -= ob_len;\n\n        ofpbuf_init(&ofpacts, 0);\n        error = ofpacts_pull_openflow_actions(msg, ob_len - sizeof *ob,\n                                              version, NULL, NULL, &ofpacts);\n        if (error) {\n            ofpbuf_uninit(&ofpacts);\n            ofputil_bucket_list_destroy(buckets);\n            return error;\n        }\n\n        bucket = xzalloc(sizeof *bucket);\n        bucket->weight = ntohs(ob->weight);\n        error = ofputil_port_from_ofp11(ob->watch_port, &bucket->watch_port);\n        if (error) {\n            ofpbuf_uninit(&ofpacts);\n            ofputil_bucket_list_destroy(buckets);\n            free(bucket);\n            return OFPERR_OFPGMFC_BAD_WATCH;\n        }\n        bucket->watch_group = ntohl(ob->watch_group);\n        bucket->bucket_id = bucket_id++;\n\n        bucket->ofpacts = ofpbuf_steal_data(&ofpacts);\n        bucket->ofpacts_len = ofpacts.size;\n        ovs_list_push_back(buckets, &bucket->list_node);\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_pull_ofp15_buckets(struct ofpbuf *msg, size_t buckets_length,\n                           enum ofp_version version, uint8_t group_type,\n                           struct ovs_list *buckets)\n{\n    struct ofp15_bucket *ob;\n\n    ovs_list_init(buckets);\n    while (buckets_length > 0) {\n        struct ofputil_bucket *bucket = NULL;\n        struct ofpbuf ofpacts;\n        enum ofperr err = OFPERR_OFPGMFC_BAD_BUCKET;\n        size_t ob_len, actions_len, properties_len;\n        ovs_be32 watch_port = ofputil_port_to_ofp11(OFPP_ANY);\n        ovs_be32 watch_group = htonl(OFPG_ANY);\n        ovs_be16 weight = htons(group_type == OFPGT11_SELECT ? 1 : 0);\n\n        ofpbuf_init(&ofpacts, 0);\n\n        ob = ofpbuf_try_pull(msg, sizeof *ob);\n        if (!ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"buckets end with %\"PRIuSIZE\n                         \" leftover bytes\", buckets_length);\n            goto err;\n        }\n\n        ob_len = ntohs(ob->len);\n        actions_len = ntohs(ob->action_array_len);\n\n        if (ob_len < sizeof *ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" is not valid\", ob_len);\n            goto err;\n        } else if (ob_len > buckets_length) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" exceeds remaining buckets data size %\"\n                         PRIuSIZE, ob_len, buckets_length);\n            goto err;\n        } else if (actions_len > ob_len - sizeof *ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket actions \"\n                         \"length %\"PRIuSIZE\" exceeds remaining bucket \"\n                         \"data size %\"PRIuSIZE, actions_len,\n                         ob_len - sizeof *ob);\n            goto err;\n        }\n        buckets_length -= ob_len;\n\n        err = ofpacts_pull_openflow_actions(msg, actions_len, version,\n                                            NULL, NULL, &ofpacts);\n        if (err) {\n            goto err;\n        }\n\n        properties_len = ob_len - sizeof *ob - actions_len;\n        struct ofpbuf properties = ofpbuf_const_initializer(\n            ofpbuf_pull(msg, properties_len), properties_len);\n        while (properties.size > 0) {\n            struct ofpbuf payload;\n            uint64_t type;\n\n            err = ofpprop_pull(&properties, &payload, &type);\n            if (err) {\n                goto err;\n            }\n\n            switch (type) {\n            case OFPGBPT15_WEIGHT:\n                err = ofpprop_parse_be16(&payload, &weight);\n                break;\n\n            case OFPGBPT15_WATCH_PORT:\n                err = ofpprop_parse_be32(&payload, &watch_port);\n                break;\n\n            case OFPGBPT15_WATCH_GROUP:\n                err = ofpprop_parse_be32(&payload, &watch_group);\n                break;\n\n            default:\n                err = OFPPROP_UNKNOWN(false, \"group bucket\", type);\n                break;\n            }\n\n            if (err) {\n                goto err;\n            }\n        }\n\n        bucket = xzalloc(sizeof *bucket);\n\n        bucket->weight = ntohs(weight);\n        err = ofputil_port_from_ofp11(watch_port, &bucket->watch_port);\n        if (err) {\n            err = OFPERR_OFPGMFC_BAD_WATCH;\n            goto err;\n        }\n        bucket->watch_group = ntohl(watch_group);\n        bucket->bucket_id = ntohl(ob->bucket_id);\n        if (bucket->bucket_id > OFPG15_BUCKET_MAX) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"bucket id (%u) is out of range\",\n                         bucket->bucket_id);\n            err = OFPERR_OFPGMFC_BAD_BUCKET;\n            goto err;\n        }\n\n        bucket->ofpacts = ofpbuf_steal_data(&ofpacts);\n        bucket->ofpacts_len = ofpacts.size;\n        ovs_list_push_back(buckets, &bucket->list_node);\n\n        continue;\n\n    err:\n        free(bucket);\n        ofpbuf_uninit(&ofpacts);\n        ofputil_bucket_list_destroy(buckets);\n        return err;\n    }\n\n    if (ofputil_bucket_check_duplicate_id(buckets)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"Duplicate bucket id\");\n        ofputil_bucket_list_destroy(buckets);\n        return OFPERR_OFPGMFC_BAD_BUCKET;\n    }\n\n    return 0;\n}\n\nstatic void\nofputil_init_group_properties(struct ofputil_group_props *gp)\n{\n    memset(gp, 0, sizeof *gp);\n}\n\nvoid\nofputil_group_properties_copy(struct ofputil_group_props *to,\n                              const struct ofputil_group_props *from)\n{\n    *to = *from;\n    to->fields.values = xmemdup(from->fields.values, from->fields.values_size);\n}\n\nvoid\nofputil_group_properties_destroy(struct ofputil_group_props *gp)\n{\n    free(gp->fields.values);\n}\n\nstatic enum ofperr\nparse_group_prop_ntr_selection_method(struct ofpbuf *payload,\n                                      enum ofp11_group_type group_type,\n                                      enum ofp15_group_mod_command group_cmd,\n                                      struct ofputil_group_props *gp)\n{\n    struct ntr_group_prop_selection_method *prop = payload->data;\n    size_t fields_len, method_len;\n    enum ofperr error;\n\n    switch (group_type) {\n    case OFPGT11_SELECT:\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_INDIRECT:\n    case OFPGT11_FF:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                    \"only allowed for select groups\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    switch (group_cmd) {\n    case OFPGC15_ADD:\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n        break;\n    case OFPGC15_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n    case OFPGC15_REMOVE_BUCKET:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                    \"only allowed for add and delete group modifications\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (payload->size < sizeof *prop) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property \"\n                    \"length %u is not valid\", payload->size);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    method_len = strnlen(prop->selection_method, NTR_MAX_SELECTION_METHOD_LEN);\n\n    if (method_len == NTR_MAX_SELECTION_METHOD_LEN) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method is not null terminated\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    if (strcmp(\"hash\", prop->selection_method)\n        && strcmp(\"dp_hash\", prop->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method '%s' is not supported\",\n                    prop->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    /* 'method_len' is now non-zero. */\n\n    strcpy(gp->selection_method, prop->selection_method);\n    gp->selection_method_param = ntohll(prop->selection_method_param);\n\n    ofpbuf_pull(payload, sizeof *prop);\n\n    fields_len = ntohs(prop->length) - sizeof *prop;\n    if (fields_len && strcmp(\"hash\", gp->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method %s \"\n                    \"does not support fields\", gp->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    error = oxm_pull_field_array(payload->data, fields_len,\n                                 &gp->fields);\n    if (error) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method fields are invalid\");\n        return error;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_ofp15_group_properties(struct ofpbuf *msg,\n                             enum ofp11_group_type group_type,\n                             enum ofp15_group_mod_command group_cmd,\n                             struct ofputil_group_props *gp,\n                             size_t properties_len)\n{\n    struct ofpbuf properties = ofpbuf_const_initializer(\n        ofpbuf_pull(msg, properties_len), properties_len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPPROP_EXP(NTR_VENDOR_ID, NTRT_SELECTION_METHOD):\n        case OFPPROP_EXP(NTR_COMPAT_VENDOR_ID, NTRT_SELECTION_METHOD):\n            error = parse_group_prop_ntr_selection_method(&payload, group_type,\n                                                          group_cmd, gp);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(false, \"group\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp11_group_desc_reply(struct ofputil_group_desc *gd,\n                                      struct ofpbuf *msg,\n                                      enum ofp_version version)\n{\n    struct ofp11_group_desc_stats *ogds;\n    size_t length;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    ogds = ofpbuf_try_pull(msg, sizeof *ogds);\n    if (!ogds) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    gd->type = ogds->type;\n    gd->group_id = ntohl(ogds->group_id);\n\n    length = ntohs(ogds->length);\n    if (length < sizeof *ogds || length - sizeof *ogds > msg->size) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply claims invalid \"\n                     \"length %\"PRIuSIZE, length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    return ofputil_pull_ofp11_buckets(msg, length - sizeof *ogds, version,\n                                      &gd->buckets);\n}\n\nstatic int\nofputil_decode_ofp15_group_desc_reply(struct ofputil_group_desc *gd,\n                                      struct ofpbuf *msg,\n                                      enum ofp_version version)\n{\n    struct ofp15_group_desc_stats *ogds;\n    uint16_t length, bucket_list_len;\n    int error;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    ogds = ofpbuf_try_pull(msg, sizeof *ogds);\n    if (!ogds) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    gd->type = ogds->type;\n    gd->group_id = ntohl(ogds->group_id);\n\n    length = ntohs(ogds->length);\n    if (length < sizeof *ogds || length - sizeof *ogds > msg->size) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply claims invalid \"\n                     \"length %u\", length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    bucket_list_len = ntohs(ogds->bucket_list_len);\n    if (length < bucket_list_len + sizeof *ogds) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply claims invalid \"\n                     \"bucket list length %u\", bucket_list_len);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    error = ofputil_pull_ofp15_buckets(msg, bucket_list_len, version, gd->type,\n                                       &gd->buckets);\n    if (error) {\n        return error;\n    }\n\n    /* By definition group desc messages don't have a group mod command.\n     * However, parse_group_prop_ntr_selection_method() checks to make sure\n     * that the command is OFPGC15_ADD or OFPGC15_DELETE to guard\n     * against group mod messages with other commands supplying\n     * a NTR selection method group experimenter property.\n     * Such properties are valid for group desc replies so\n     * claim that the group mod command is OFPGC15_ADD to\n     * satisfy the check in parse_group_prop_ntr_selection_method() */\n    error = parse_ofp15_group_properties(\n        msg, gd->type, OFPGC15_ADD, &gd->props,\n        length - sizeof *ogds - bucket_list_len);\n    if (error) {\n        ofputil_bucket_list_destroy(&gd->buckets);\n    }\n    return error;\n}\n\n/* Converts a group description reply in 'msg' into an abstract\n * ofputil_group_desc in 'gd'.\n *\n * Multiple group description replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  The caller must initially leave 'msg''s layer pointers\n * null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_group_desc_reply(struct ofputil_group_desc *gd,\n                                struct ofpbuf *msg, enum ofp_version version)\n{\n    ofputil_init_group_properties(&gd->props);\n\n    switch (version)\n    {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        return ofputil_decode_ofp11_group_desc_reply(gd, msg, version);\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return ofputil_decode_ofp15_group_desc_reply(gd, msg, version);\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nvoid\nofputil_uninit_group_mod(struct ofputil_group_mod *gm)\n{\n    ofputil_bucket_list_destroy(&gm->buckets);\n    ofputil_group_properties_destroy(&gm->props);\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp11_group_mod(enum ofp_version ofp_version,\n                               const struct ofputil_group_mod *gm)\n{\n    struct ofpbuf *b;\n    struct ofp11_group_mod *ogm;\n    size_t start_ogm;\n    struct ofputil_bucket *bucket;\n\n    b = ofpraw_alloc(OFPRAW_OFPT11_GROUP_MOD, ofp_version, 0);\n    start_ogm = b->size;\n    ofpbuf_put_zeros(b, sizeof *ogm);\n\n    LIST_FOR_EACH (bucket, list_node, &gm->buckets) {\n        ofputil_put_ofp11_bucket(bucket, b, ofp_version);\n    }\n    ogm = ofpbuf_at_assert(b, start_ogm, sizeof *ogm);\n    ogm->command = htons(gm->command);\n    ogm->type = gm->type;\n    ogm->group_id = htonl(gm->group_id);\n\n    return b;\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp15_group_mod(enum ofp_version ofp_version,\n                               const struct ofputil_group_mod *gm)\n{\n    struct ofpbuf *b;\n    struct ofp15_group_mod *ogm;\n    size_t start_ogm;\n    struct ofputil_bucket *bucket;\n    struct id_pool *bucket_ids = NULL;\n\n    b = ofpraw_alloc(OFPRAW_OFPT15_GROUP_MOD, ofp_version, 0);\n    start_ogm = b->size;\n    ofpbuf_put_zeros(b, sizeof *ogm);\n\n    LIST_FOR_EACH (bucket, list_node, &gm->buckets) {\n        uint32_t bucket_id;\n\n        /* Generate a bucket id if none was supplied */\n        if (bucket->bucket_id > OFPG15_BUCKET_MAX) {\n            if (!bucket_ids) {\n                const struct ofputil_bucket *bkt;\n\n                bucket_ids = id_pool_create(0, OFPG15_BUCKET_MAX + 1);\n\n                /* Mark all bucket_ids that are present in gm\n                 * as used in the pool. */\n                LIST_FOR_EACH_REVERSE (bkt, list_node, &gm->buckets) {\n                    if (bkt == bucket) {\n                        break;\n                    }\n                    if (bkt->bucket_id <= OFPG15_BUCKET_MAX) {\n                        id_pool_add(bucket_ids, bkt->bucket_id);\n                    }\n                }\n            }\n\n            if (!id_pool_alloc_id(bucket_ids, &bucket_id)) {\n                OVS_NOT_REACHED();\n            }\n        } else {\n            bucket_id = bucket->bucket_id;\n        }\n\n        ofputil_put_ofp15_bucket(bucket, bucket_id, gm->type, b, ofp_version);\n    }\n    ogm = ofpbuf_at_assert(b, start_ogm, sizeof *ogm);\n    ogm->command = htons(gm->command);\n    ogm->type = gm->type;\n    ogm->group_id = htonl(gm->group_id);\n    ogm->command_bucket_id = htonl(gm->command_bucket_id);\n    ogm->bucket_array_len = htons(b->size - start_ogm - sizeof *ogm);\n\n    /* Add group properties */\n    if (gm->props.selection_method[0]) {\n        ofputil_put_group_prop_ntr_selection_method(ofp_version, &gm->props, b);\n    }\n\n    id_pool_destroy(bucket_ids);\n    return b;\n}\n\nstatic void\nbad_group_cmd(enum ofp15_group_mod_command cmd)\n{\n    const char *opt_version;\n    const char *version;\n    const char *cmd_str;\n\n    switch (cmd) {\n    case OFPGC15_ADD:\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n    case OFPGC15_DELETE:\n        version = \"1.1\";\n        opt_version = \"11\";\n        break;\n\n    case OFPGC15_INSERT_BUCKET:\n    case OFPGC15_REMOVE_BUCKET:\n        version = \"1.5\";\n        opt_version = \"15\";\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    switch (cmd) {\n    case OFPGC15_ADD:\n        cmd_str = \"add-group\";\n        break;\n\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n        cmd_str = \"mod-group\";\n        break;\n\n    case OFPGC15_DELETE:\n        cmd_str = \"del-group\";\n        break;\n\n    case OFPGC15_INSERT_BUCKET:\n        cmd_str = \"insert-bucket\";\n        break;\n\n    case OFPGC15_REMOVE_BUCKET:\n        cmd_str = \"remove-bucket\";\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ovs_fatal(0, \"%s needs OpenFlow %s or later (\\'-O OpenFlow%s\\')\",\n              cmd_str, version, opt_version);\n\n}\n\n/* Converts abstract group mod 'gm' into a message for OpenFlow version\n * 'ofp_version' and returns the message. */\nstruct ofpbuf *\nofputil_encode_group_mod(enum ofp_version ofp_version,\n                         const struct ofputil_group_mod *gm)\n{\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        bad_group_cmd(gm->command);\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        if (gm->command > OFPGC11_DELETE && gm->command != OFPGC11_ADD_OR_MOD) {\n            bad_group_cmd(gm->command);\n        }\n        return ofputil_encode_ofp11_group_mod(ofp_version, gm);\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return ofputil_encode_ofp15_group_mod(ofp_version, gm);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic enum ofperr\nofputil_pull_ofp11_group_mod(struct ofpbuf *msg, enum ofp_version ofp_version,\n                             struct ofputil_group_mod *gm)\n{\n    const struct ofp11_group_mod *ogm;\n    enum ofperr error;\n\n    ogm = ofpbuf_pull(msg, sizeof *ogm);\n    gm->command = ntohs(ogm->command);\n    gm->type = ogm->type;\n    gm->group_id = ntohl(ogm->group_id);\n    gm->command_bucket_id = OFPG15_BUCKET_ALL;\n\n    error = ofputil_pull_ofp11_buckets(msg, msg->size, ofp_version,\n                                       &gm->buckets);\n\n    /* OF1.3.5+ prescribes an error when an OFPGC_DELETE includes buckets. */\n    if (!error\n        && ofp_version >= OFP13_VERSION\n        && gm->command == OFPGC11_DELETE\n        && !ovs_list_is_empty(&gm->buckets)) {\n        error = OFPERR_OFPGMFC_INVALID_GROUP;\n        ofputil_bucket_list_destroy(&gm->buckets);\n    }\n\n    return error;\n}\n\nstatic enum ofperr\nofputil_pull_ofp15_group_mod(struct ofpbuf *msg, enum ofp_version ofp_version,\n                             struct ofputil_group_mod *gm)\n{\n    const struct ofp15_group_mod *ogm;\n    uint16_t bucket_list_len;\n    enum ofperr error = OFPERR_OFPGMFC_BAD_BUCKET;\n\n    ogm = ofpbuf_pull(msg, sizeof *ogm);\n    gm->command = ntohs(ogm->command);\n    gm->type = ogm->type;\n    gm->group_id = ntohl(ogm->group_id);\n\n    gm->command_bucket_id = ntohl(ogm->command_bucket_id);\n    switch (gm->command) {\n    case OFPGC15_REMOVE_BUCKET:\n        if (gm->command_bucket_id == OFPG15_BUCKET_ALL) {\n            error = 0;\n        }\n        /* Fall through */\n    case OFPGC15_INSERT_BUCKET:\n        if (gm->command_bucket_id <= OFPG15_BUCKET_MAX ||\n            gm->command_bucket_id == OFPG15_BUCKET_FIRST\n            || gm->command_bucket_id == OFPG15_BUCKET_LAST) {\n            error = 0;\n        }\n        break;\n\n    case OFPGC11_ADD:\n    case OFPGC11_MODIFY:\n    case OFPGC11_ADD_OR_MOD:\n    case OFPGC11_DELETE:\n    default:\n        if (gm->command_bucket_id == OFPG15_BUCKET_ALL) {\n            error = 0;\n        }\n        break;\n    }\n    if (error) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"group command bucket id (%u) is out of range\",\n                     gm->command_bucket_id);\n        return OFPERR_OFPGMFC_BAD_BUCKET;\n    }\n\n    bucket_list_len = ntohs(ogm->bucket_array_len);\n    if (bucket_list_len > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    error = ofputil_pull_ofp15_buckets(msg, bucket_list_len, ofp_version,\n                                       gm->type, &gm->buckets);\n    if (error) {\n        return error;\n    }\n\n    error = parse_ofp15_group_properties(msg, gm->type, gm->command,\n                                         &gm->props, msg->size);\n    if (error) {\n        ofputil_bucket_list_destroy(&gm->buckets);\n    }\n    return error;\n}\n\nstatic enum ofperr\nofputil_check_group_mod(const struct ofputil_group_mod *gm)\n{\n    switch (gm->type) {\n    case OFPGT11_INDIRECT:\n        if (gm->command != OFPGC11_DELETE\n            && !ovs_list_is_singleton(&gm->buckets) ) {\n            return OFPERR_OFPGMFC_INVALID_GROUP;\n        }\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_SELECT:\n    case OFPGT11_FF:\n        break;\n    default:\n        return OFPERR_OFPGMFC_BAD_TYPE;\n    }\n\n    switch (gm->command) {\n    case OFPGC11_ADD:\n    case OFPGC11_MODIFY:\n    case OFPGC11_ADD_OR_MOD:\n    case OFPGC11_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n        break;\n    case OFPGC15_REMOVE_BUCKET:\n        if (!ovs_list_is_empty(&gm->buckets)) {\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        }\n        break;\n    default:\n        return OFPERR_OFPGMFC_BAD_COMMAND;\n    }\n\n    struct ofputil_bucket *bucket;\n    LIST_FOR_EACH (bucket, list_node, &gm->buckets) {\n        if (bucket->weight && gm->type != OFPGT11_SELECT) {\n            return OFPERR_OFPGMFC_INVALID_GROUP;\n        }\n\n        switch (gm->type) {\n        case OFPGT11_ALL:\n        case OFPGT11_INDIRECT:\n            if (ofputil_bucket_has_liveness(bucket)) {\n                return OFPERR_OFPGMFC_WATCH_UNSUPPORTED;\n            }\n            break;\n        case OFPGT11_SELECT:\n            break;\n        case OFPGT11_FF:\n            if (!ofputil_bucket_has_liveness(bucket)) {\n                return OFPERR_OFPGMFC_INVALID_GROUP;\n            }\n            break;\n        default:\n            /* Returning BAD TYPE to be consistent\n             * though gm->type has been checked already. */\n            return OFPERR_OFPGMFC_BAD_TYPE;\n        }\n    }\n\n    return 0;\n}\n\n/* Converts OpenFlow group mod message 'oh' into an abstract group mod in\n * 'gm'.  Returns 0 if successful, otherwise an OpenFlow error code. */\nenum ofperr\nofputil_decode_group_mod(const struct ofp_header *oh,\n                         struct ofputil_group_mod *gm)\n{\n    ofputil_init_group_properties(&gm->props);\n\n    enum ofp_version ofp_version = oh->version;\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&msg);\n\n    enum ofperr err;\n    switch (ofp_version)\n    {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        err = ofputil_pull_ofp11_group_mod(&msg, ofp_version, gm);\n        break;\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        err = ofputil_pull_ofp15_group_mod(&msg, ofp_version, gm);\n        break;\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n    if (err) {\n        return err;\n    }\n\n    err = ofputil_check_group_mod(gm);\n    if (err) {\n        ofputil_uninit_group_mod(gm);\n    }\n    return err;\n}\n\n/* Destroys 'bms'. */\nvoid\nofputil_free_bundle_msgs(struct ofputil_bundle_msg *bms, size_t n_bms)\n{\n    for (size_t i = 0; i < n_bms; i++) {\n        switch ((int)bms[i].type) {\n        case OFPTYPE_FLOW_MOD:\n            free(CONST_CAST(struct ofpact *, bms[i].fm.ofpacts));\n            break;\n        case OFPTYPE_GROUP_MOD:\n            ofputil_uninit_group_mod(&bms[i].gm);\n            break;\n        case OFPTYPE_PACKET_OUT:\n            free(bms[i].po.ofpacts);\n            free(CONST_CAST(void *, bms[i].po.packet));\n            break;\n        default:\n            break;\n        }\n    }\n    free(bms);\n}\n\nvoid\nofputil_encode_bundle_msgs(const struct ofputil_bundle_msg *bms,\n                           size_t n_bms, struct ovs_list *requests,\n                           enum ofputil_protocol protocol)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n\n    for (size_t i = 0; i < n_bms; i++) {\n        struct ofpbuf *request = NULL;\n\n        switch ((int)bms[i].type) {\n        case OFPTYPE_FLOW_MOD:\n            request = ofputil_encode_flow_mod(&bms[i].fm, protocol);\n            break;\n        case OFPTYPE_GROUP_MOD:\n            request = ofputil_encode_group_mod(version, &bms[i].gm);\n            break;\n        case OFPTYPE_PACKET_OUT:\n            request = ofputil_encode_packet_out(&bms[i].po, protocol);\n            break;\n        default:\n            break;\n        }\n        if (request) {\n            ovs_list_push_back(requests, &request->list_node);\n        }\n    }\n}\n\n/* Parse a queue status request message into 'oqsr'.\n * Returns 0 if successful, otherwise an OFPERR_* number. */\nenum ofperr\nofputil_decode_queue_stats_request(const struct ofp_header *request,\n                                   struct ofputil_queue_stats_request *oqsr)\n{\n    switch ((enum ofp_version)request->version) {\n    case OFP16_VERSION:\n    case OFP15_VERSION:\n    case OFP14_VERSION:\n    case OFP13_VERSION:\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        const struct ofp11_queue_stats_request *qsr11 = ofpmsg_body(request);\n        oqsr->queue_id = ntohl(qsr11->queue_id);\n        return ofputil_port_from_ofp11(qsr11->port_no, &oqsr->port_no);\n    }\n\n    case OFP10_VERSION: {\n        const struct ofp10_queue_stats_request *qsr10 = ofpmsg_body(request);\n        oqsr->queue_id = ntohl(qsr10->queue_id);\n        oqsr->port_no = u16_to_ofp(ntohs(qsr10->port_no));\n        /* OF 1.0 uses OFPP_ALL for OFPP_ANY */\n        if (oqsr->port_no == OFPP_ALL) {\n            oqsr->port_no = OFPP_ANY;\n        }\n        return 0;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Encode a queue stats request for 'oqsr', the encoded message\n * will be for OpenFlow version 'ofp_version'. Returns message\n * as a struct ofpbuf. Returns encoded message on success, NULL on error. */\nstruct ofpbuf *\nofputil_encode_queue_stats_request(enum ofp_version ofp_version,\n                                   const struct ofputil_queue_stats_request *oqsr)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_queue_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST11_QUEUE_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = ofputil_port_to_ofp11(oqsr->port_no);\n        req->queue_id = htonl(oqsr->queue_id);\n        break;\n    }\n    case OFP10_VERSION: {\n        struct ofp10_queue_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST10_QUEUE_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        /* OpenFlow 1.0 needs OFPP_ALL instead of OFPP_ANY */\n        req->port_no = htons(ofp_to_u16(oqsr->port_no == OFPP_ANY\n                                        ? OFPP_ALL : oqsr->port_no));\n        req->queue_id = htonl(oqsr->queue_id);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\n/* Returns the number of queue stats elements in OFPTYPE_QUEUE_STATS_REPLY\n * message 'oh'. */\nsize_t\nofputil_count_queue_stats(const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    for (size_t n = 0; ; n++) {\n        struct ofputil_queue_stats qs;\n        if (ofputil_decode_queue_stats(&qs, &b)) {\n            return n;\n        }\n    }\n}\n\nstatic enum ofperr\nofputil_queue_stats_from_ofp10(struct ofputil_queue_stats *oqs,\n                               const struct ofp10_queue_stats *qs10)\n{\n    oqs->port_no = u16_to_ofp(ntohs(qs10->port_no));\n    oqs->queue_id = ntohl(qs10->queue_id);\n    oqs->tx_bytes = ntohll(get_32aligned_be64(&qs10->tx_bytes));\n    oqs->tx_packets = ntohll(get_32aligned_be64(&qs10->tx_packets));\n    oqs->tx_errors = ntohll(get_32aligned_be64(&qs10->tx_errors));\n    oqs->duration_sec = oqs->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_queue_stats_from_ofp11(struct ofputil_queue_stats *oqs,\n                               const struct ofp11_queue_stats *qs11)\n{\n    enum ofperr error;\n\n    error = ofputil_port_from_ofp11(qs11->port_no, &oqs->port_no);\n    if (error) {\n        return error;\n    }\n\n    oqs->queue_id = ntohl(qs11->queue_id);\n    oqs->tx_bytes = ntohll(qs11->tx_bytes);\n    oqs->tx_packets = ntohll(qs11->tx_packets);\n    oqs->tx_errors = ntohll(qs11->tx_errors);\n    oqs->duration_sec = oqs->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_queue_stats_from_ofp13(struct ofputil_queue_stats *oqs,\n                               const struct ofp13_queue_stats *qs13)\n{\n    enum ofperr error = ofputil_queue_stats_from_ofp11(oqs, &qs13->qs);\n    if (!error) {\n        oqs->duration_sec = ntohl(qs13->duration_sec);\n        oqs->duration_nsec = ntohl(qs13->duration_nsec);\n    }\n\n    return error;\n}\n\nstatic enum ofperr\nofputil_pull_ofp14_queue_stats(struct ofputil_queue_stats *oqs,\n                               struct ofpbuf *msg)\n{\n    const struct ofp14_queue_stats *qs14;\n    size_t len;\n\n    qs14 = ofpbuf_try_pull(msg, sizeof *qs14);\n    if (!qs14) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    len = ntohs(qs14->length);\n    if (len < sizeof *qs14 || len - sizeof *qs14 > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    ofpbuf_pull(msg, len - sizeof *qs14);\n\n    /* No properties yet defined, so ignore them for now. */\n\n    return ofputil_queue_stats_from_ofp13(oqs, &qs14->qs);\n}\n\n/* Converts an OFPST_QUEUE_STATS reply in 'msg' into an abstract\n * ofputil_queue_stats in 'qs'.\n *\n * Multiple OFPST_QUEUE_STATS replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  The caller must initially leave 'msg''s layer pointers\n * null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_queue_stats(struct ofputil_queue_stats *qs, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_QUEUE_REPLY) {\n        return ofputil_pull_ofp14_queue_stats(qs, msg);\n    } else if (raw == OFPRAW_OFPST13_QUEUE_REPLY) {\n        const struct ofp13_queue_stats *qs13;\n\n        qs13 = ofpbuf_try_pull(msg, sizeof *qs13);\n        if (!qs13) {\n            goto bad_len;\n        }\n        return ofputil_queue_stats_from_ofp13(qs, qs13);\n    } else if (raw == OFPRAW_OFPST11_QUEUE_REPLY) {\n        const struct ofp11_queue_stats *qs11;\n\n        qs11 = ofpbuf_try_pull(msg, sizeof *qs11);\n        if (!qs11) {\n            goto bad_len;\n        }\n        return ofputil_queue_stats_from_ofp11(qs, qs11);\n    } else if (raw == OFPRAW_OFPST10_QUEUE_REPLY) {\n        const struct ofp10_queue_stats *qs10;\n\n        qs10 = ofpbuf_try_pull(msg, sizeof *qs10);\n        if (!qs10) {\n            goto bad_len;\n        }\n        return ofputil_queue_stats_from_ofp10(qs, qs10);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n bad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_QUEUE reply has %\"PRIu32\" leftover \"\n                 \"bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n\nstatic void\nofputil_queue_stats_to_ofp10(const struct ofputil_queue_stats *oqs,\n                             struct ofp10_queue_stats *qs10)\n{\n    qs10->port_no = htons(ofp_to_u16(oqs->port_no));\n    memset(qs10->pad, 0, sizeof qs10->pad);\n    qs10->queue_id = htonl(oqs->queue_id);\n    put_32aligned_be64(&qs10->tx_bytes, htonll(oqs->tx_bytes));\n    put_32aligned_be64(&qs10->tx_packets, htonll(oqs->tx_packets));\n    put_32aligned_be64(&qs10->tx_errors, htonll(oqs->tx_errors));\n}\n\nstatic void\nofputil_queue_stats_to_ofp11(const struct ofputil_queue_stats *oqs,\n                             struct ofp11_queue_stats *qs11)\n{\n    qs11->port_no = ofputil_port_to_ofp11(oqs->port_no);\n    qs11->queue_id = htonl(oqs->queue_id);\n    qs11->tx_bytes = htonll(oqs->tx_bytes);\n    qs11->tx_packets = htonll(oqs->tx_packets);\n    qs11->tx_errors = htonll(oqs->tx_errors);\n}\n\nstatic void\nofputil_queue_stats_to_ofp13(const struct ofputil_queue_stats *oqs,\n                             struct ofp13_queue_stats *qs13)\n{\n    ofputil_queue_stats_to_ofp11(oqs, &qs13->qs);\n    if (oqs->duration_sec != UINT32_MAX) {\n        qs13->duration_sec = htonl(oqs->duration_sec);\n        qs13->duration_nsec = htonl(oqs->duration_nsec);\n    } else {\n        qs13->duration_sec = OVS_BE32_MAX;\n        qs13->duration_nsec = OVS_BE32_MAX;\n    }\n}\n\nstatic void\nofputil_queue_stats_to_ofp14(const struct ofputil_queue_stats *oqs,\n                             struct ofp14_queue_stats *qs14)\n{\n    qs14->length = htons(sizeof *qs14);\n    memset(qs14->pad, 0, sizeof qs14->pad);\n    ofputil_queue_stats_to_ofp13(oqs, &qs14->qs);\n}\n\n\n/* Encode a queue stat for 'oqs' and append it to 'replies'. */\nvoid\nofputil_append_queue_stat(struct ovs_list *replies,\n                          const struct ofputil_queue_stats *oqs)\n{\n    switch (ofpmp_version(replies)) {\n    case OFP13_VERSION: {\n        struct ofp13_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp13(oqs, reply);\n        break;\n    }\n\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        struct ofp11_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp11(oqs, reply);\n        break;\n    }\n\n    case OFP10_VERSION: {\n        struct ofp10_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp10(oqs, reply);\n        break;\n    }\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp14_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp14(oqs, reply);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nenum ofperr\nofputil_decode_bundle_ctrl(const struct ofp_header *oh,\n                           struct ofputil_bundle_ctrl_msg *msg)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    ovs_assert(raw == OFPRAW_OFPT14_BUNDLE_CONTROL\n               || raw == OFPRAW_ONFT13_BUNDLE_CONTROL);\n\n    const struct ofp14_bundle_ctrl_msg *m = b.msg;\n    msg->bundle_id = ntohl(m->bundle_id);\n    msg->type = ntohs(m->type);\n    msg->flags = ntohs(m->flags);\n\n    return 0;\n}\n\nstruct ofpbuf *\nofputil_encode_bundle_ctrl_request(enum ofp_version ofp_version,\n                                   struct ofputil_bundle_ctrl_msg *bc)\n{\n    struct ofpbuf *request;\n    struct ofp14_bundle_ctrl_msg *m;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        ovs_fatal(0, \"bundles need OpenFlow 1.3 or later \"\n                     \"(\\'-O OpenFlow14\\')\");\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        request = ofpraw_alloc(ofp_version == OFP13_VERSION\n                               ? OFPRAW_ONFT13_BUNDLE_CONTROL\n                               : OFPRAW_OFPT14_BUNDLE_CONTROL, ofp_version, 0);\n        m = ofpbuf_put_zeros(request, sizeof *m);\n\n        m->bundle_id = htonl(bc->bundle_id);\n        m->type = htons(bc->type);\n        m->flags = htons(bc->flags);\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstruct ofpbuf *\nofputil_encode_bundle_ctrl_reply(const struct ofp_header *oh,\n                                 struct ofputil_bundle_ctrl_msg *msg)\n{\n    struct ofpbuf *buf;\n    struct ofp14_bundle_ctrl_msg *m;\n\n    buf = ofpraw_alloc_reply(oh->version == OFP13_VERSION\n                             ? OFPRAW_ONFT13_BUNDLE_CONTROL\n                             : OFPRAW_OFPT14_BUNDLE_CONTROL, oh, 0);\n    m = ofpbuf_put_zeros(buf, sizeof *m);\n\n    m->bundle_id = htonl(msg->bundle_id);\n    m->type = htons(msg->type);\n    m->flags = htons(msg->flags);\n\n    return buf;\n}\n\n/* Return true for bundlable state change requests, false for other messages.\n */\nstatic bool\nofputil_is_bundlable(enum ofptype type)\n{\n    switch (type) {\n        /* Minimum required by OpenFlow 1.4. */\n    case OFPTYPE_PORT_MOD:\n    case OFPTYPE_FLOW_MOD:\n        /* Other supported types. */\n    case OFPTYPE_GROUP_MOD:\n    case OFPTYPE_PACKET_OUT:\n        return true;\n\n        /* Nice to have later. */\n    case OFPTYPE_FLOW_MOD_TABLE_ID:\n    case OFPTYPE_TABLE_MOD:\n    case OFPTYPE_METER_MOD:\n    case OFPTYPE_NXT_TLV_TABLE_MOD:\n\n        /* Not to be bundlable. */\n    case OFPTYPE_ECHO_REQUEST:\n    case OFPTYPE_FEATURES_REQUEST:\n    case OFPTYPE_GET_CONFIG_REQUEST:\n    case OFPTYPE_SET_CONFIG:\n    case OFPTYPE_BARRIER_REQUEST:\n    case OFPTYPE_ROLE_REQUEST:\n    case OFPTYPE_ECHO_REPLY:\n    case OFPTYPE_SET_FLOW_FORMAT:\n    case OFPTYPE_SET_PACKET_IN_FORMAT:\n    case OFPTYPE_SET_CONTROLLER_ID:\n    case OFPTYPE_FLOW_AGE:\n    case OFPTYPE_FLOW_MONITOR_CANCEL:\n    case OFPTYPE_SET_ASYNC_CONFIG:\n    case OFPTYPE_GET_ASYNC_REQUEST:\n    case OFPTYPE_DESC_STATS_REQUEST:\n    case OFPTYPE_FLOW_STATS_REQUEST:\n    case OFPTYPE_AGGREGATE_STATS_REQUEST:\n    case OFPTYPE_TABLE_STATS_REQUEST:\n    case OFPTYPE_TABLE_FEATURES_STATS_REQUEST:\n    case OFPTYPE_TABLE_DESC_REQUEST:\n    case OFPTYPE_PORT_STATS_REQUEST:\n    case OFPTYPE_QUEUE_STATS_REQUEST:\n    case OFPTYPE_PORT_DESC_STATS_REQUEST:\n    case OFPTYPE_FLOW_MONITOR_STATS_REQUEST:\n    case OFPTYPE_METER_STATS_REQUEST:\n    case OFPTYPE_METER_CONFIG_STATS_REQUEST:\n    case OFPTYPE_METER_FEATURES_STATS_REQUEST:\n    case OFPTYPE_GROUP_STATS_REQUEST:\n    case OFPTYPE_GROUP_DESC_STATS_REQUEST:\n    case OFPTYPE_GROUP_FEATURES_STATS_REQUEST:\n    case OFPTYPE_QUEUE_GET_CONFIG_REQUEST:\n    case OFPTYPE_BUNDLE_CONTROL:\n    case OFPTYPE_BUNDLE_ADD_MESSAGE:\n    case OFPTYPE_HELLO:\n    case OFPTYPE_ERROR:\n    case OFPTYPE_FEATURES_REPLY:\n    case OFPTYPE_GET_CONFIG_REPLY:\n    case OFPTYPE_PACKET_IN:\n    case OFPTYPE_FLOW_REMOVED:\n    case OFPTYPE_PORT_STATUS:\n    case OFPTYPE_BARRIER_REPLY:\n    case OFPTYPE_QUEUE_GET_CONFIG_REPLY:\n    case OFPTYPE_DESC_STATS_REPLY:\n    case OFPTYPE_FLOW_STATS_REPLY:\n    case OFPTYPE_QUEUE_STATS_REPLY:\n    case OFPTYPE_PORT_STATS_REPLY:\n    case OFPTYPE_TABLE_STATS_REPLY:\n    case OFPTYPE_AGGREGATE_STATS_REPLY:\n    case OFPTYPE_PORT_DESC_STATS_REPLY:\n    case OFPTYPE_ROLE_REPLY:\n    case OFPTYPE_FLOW_MONITOR_PAUSED:\n    case OFPTYPE_FLOW_MONITOR_RESUMED:\n    case OFPTYPE_FLOW_MONITOR_STATS_REPLY:\n    case OFPTYPE_GET_ASYNC_REPLY:\n    case OFPTYPE_GROUP_STATS_REPLY:\n    case OFPTYPE_GROUP_DESC_STATS_REPLY:\n    case OFPTYPE_GROUP_FEATURES_STATS_REPLY:\n    case OFPTYPE_METER_STATS_REPLY:\n    case OFPTYPE_METER_CONFIG_STATS_REPLY:\n    case OFPTYPE_METER_FEATURES_STATS_REPLY:\n    case OFPTYPE_TABLE_FEATURES_STATS_REPLY:\n    case OFPTYPE_TABLE_DESC_REPLY:\n    case OFPTYPE_ROLE_STATUS:\n    case OFPTYPE_REQUESTFORWARD:\n    case OFPTYPE_TABLE_STATUS:\n    case OFPTYPE_NXT_TLV_TABLE_REQUEST:\n    case OFPTYPE_NXT_TLV_TABLE_REPLY:\n    case OFPTYPE_NXT_RESUME:\n    case OFPTYPE_IPFIX_BRIDGE_STATS_REQUEST:\n    case OFPTYPE_IPFIX_BRIDGE_STATS_REPLY:\n    case OFPTYPE_IPFIX_FLOW_STATS_REQUEST:\n    case OFPTYPE_IPFIX_FLOW_STATS_REPLY:\n    case OFPTYPE_CT_FLUSH_ZONE:\n        break;\n    }\n\n    return false;\n}\n\nenum ofperr\nofputil_decode_bundle_add(const struct ofp_header *oh,\n                          struct ofputil_bundle_add_msg *msg,\n                          enum ofptype *typep)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n\n    /* Pull the outer ofp_header. */\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    ovs_assert(raw == OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE\n               || raw == OFPRAW_ONFT13_BUNDLE_ADD_MESSAGE);\n\n    /* Pull the bundle_ctrl header. */\n    const struct ofp14_bundle_ctrl_msg *m = ofpbuf_pull(&b, sizeof *m);\n    msg->bundle_id = ntohl(m->bundle_id);\n    msg->flags = ntohs(m->flags);\n\n    /* Pull the inner ofp_header. */\n    if (b.size < sizeof(struct ofp_header)) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    msg->msg = b.data;\n    if (msg->msg->version != oh->version) {\n        return OFPERR_OFPBFC_BAD_VERSION;\n    }\n    size_t inner_len = ntohs(msg->msg->length);\n    if (inner_len < sizeof(struct ofp_header) || inner_len > b.size) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    if (msg->msg->xid != oh->xid) {\n        return OFPERR_OFPBFC_MSG_BAD_XID;\n    }\n\n    /* Reject unbundlable messages. */\n    enum ofptype type;\n    enum ofperr error = ofptype_decode(&type, msg->msg);\n    if (error) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPT14_BUNDLE_ADD_MESSAGE contained \"\n                     \"message is unparsable (%s)\", ofperr_get_name(error));\n        return OFPERR_OFPBFC_MSG_UNSUP; /* 'error' would be confusing. */\n    }\n\n    if (!ofputil_is_bundlable(type)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s message not allowed inside \"\n                     \"OFPT14_BUNDLE_ADD_MESSAGE\", ofptype_get_name(type));\n        return OFPERR_OFPBFC_MSG_UNSUP;\n    }\n    if (typep) {\n        *typep = type;\n    }\n\n    return 0;\n}\n\nstruct ofpbuf *\nofputil_encode_bundle_add(enum ofp_version ofp_version,\n                          struct ofputil_bundle_add_msg *msg)\n{\n    struct ofpbuf *request;\n    struct ofp14_bundle_ctrl_msg *m;\n\n    /* Must use the same xid as the embedded message. */\n    request = ofpraw_alloc_xid(ofp_version == OFP13_VERSION\n                               ? OFPRAW_ONFT13_BUNDLE_ADD_MESSAGE\n                               : OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE, ofp_version,\n                               msg->msg->xid, ntohs(msg->msg->length));\n    m = ofpbuf_put_zeros(request, sizeof *m);\n\n    m->bundle_id = htonl(msg->bundle_id);\n    m->flags = htons(msg->flags);\n    ofpbuf_put(request, msg->msg, ntohs(msg->msg->length));\n\n    ofpmsg_update_length(request);\n    return request;\n}\n\nstatic void\nencode_tlv_table_mappings(struct ofpbuf *b, struct ovs_list *mappings)\n{\n    struct ofputil_tlv_map *map;\n\n    LIST_FOR_EACH (map, list_node, mappings) {\n        struct nx_tlv_map *nx_map;\n\n        nx_map = ofpbuf_put_zeros(b, sizeof *nx_map);\n        nx_map->option_class = htons(map->option_class);\n        nx_map->option_type = map->option_type;\n        nx_map->option_len = map->option_len;\n        nx_map->index = htons(map->index);\n    }\n}\n\nstruct ofpbuf *\nofputil_encode_tlv_table_mod(enum ofp_version ofp_version,\n                                struct ofputil_tlv_table_mod *ttm)\n{\n    struct ofpbuf *b;\n    struct nx_tlv_table_mod *nx_ttm;\n\n    b = ofpraw_alloc(OFPRAW_NXT_TLV_TABLE_MOD, ofp_version, 0);\n    nx_ttm = ofpbuf_put_zeros(b, sizeof *nx_ttm);\n    nx_ttm->command = htons(ttm->command);\n    encode_tlv_table_mappings(b, &ttm->mappings);\n\n    return b;\n}\n\nstatic enum ofperr\ndecode_tlv_table_mappings(struct ofpbuf *msg, unsigned int max_fields,\n                             struct ovs_list *mappings)\n{\n    ovs_list_init(mappings);\n\n    while (msg->size) {\n        struct nx_tlv_map *nx_map;\n        struct ofputil_tlv_map *map;\n\n        nx_map = ofpbuf_pull(msg, sizeof *nx_map);\n        map = xmalloc(sizeof *map);\n        ovs_list_push_back(mappings, &map->list_node);\n\n        map->option_class = ntohs(nx_map->option_class);\n        map->option_type = nx_map->option_type;\n\n        map->option_len = nx_map->option_len;\n        if (map->option_len % 4 || map->option_len > TLV_MAX_OPT_SIZE) {\n            VLOG_WARN_RL(&bad_ofmsg_rl,\n                         \"tlv table option length (%u) is not a valid option size\",\n                         map->option_len);\n            ofputil_uninit_tlv_table(mappings);\n            return OFPERR_NXTTMFC_BAD_OPT_LEN;\n        }\n\n        map->index = ntohs(nx_map->index);\n        if (map->index >= max_fields) {\n            VLOG_WARN_RL(&bad_ofmsg_rl,\n                         \"tlv table field index (%u) is too large (max %u)\",\n                         map->index, max_fields - 1);\n            ofputil_uninit_tlv_table(mappings);\n            return OFPERR_NXTTMFC_BAD_FIELD_IDX;\n        }\n    }\n\n    return 0;\n}\n\nenum ofperr\nofputil_decode_tlv_table_mod(const struct ofp_header *oh,\n                                struct ofputil_tlv_table_mod *ttm)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&msg);\n\n    struct nx_tlv_table_mod *nx_ttm = ofpbuf_pull(&msg, sizeof *nx_ttm);\n    ttm->command = ntohs(nx_ttm->command);\n    if (ttm->command > NXTTMC_CLEAR) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"tlv table mod command (%u) is out of range\",\n                     ttm->command);\n        return OFPERR_NXTTMFC_BAD_COMMAND;\n    }\n\n    return decode_tlv_table_mappings(&msg, TUN_METADATA_NUM_OPTS,\n                                        &ttm->mappings);\n}\n\nstruct ofpbuf *\nofputil_encode_tlv_table_reply(const struct ofp_header *oh,\n                                  struct ofputil_tlv_table_reply *ttr)\n{\n    struct ofpbuf *b;\n    struct nx_tlv_table_reply *nx_ttr;\n\n    b = ofpraw_alloc_reply(OFPRAW_NXT_TLV_TABLE_REPLY, oh, 0);\n    nx_ttr = ofpbuf_put_zeros(b, sizeof *nx_ttr);\n    nx_ttr->max_option_space = htonl(ttr->max_option_space);\n    nx_ttr->max_fields = htons(ttr->max_fields);\n\n    encode_tlv_table_mappings(b, &ttr->mappings);\n\n    return b;\n}\n\n/* Decodes the NXT_TLV_TABLE_REPLY message in 'oh' into '*ttr'.  Returns 0\n * if successful, otherwise an ofperr.\n *\n * The decoder verifies that the indexes in 'ttr->mappings' are less than\n * 'ttr->max_fields', but the caller must ensure, if necessary, that they are\n * less than TUN_METADATA_NUM_OPTS. */\nenum ofperr\nofputil_decode_tlv_table_reply(const struct ofp_header *oh,\n                                  struct ofputil_tlv_table_reply *ttr)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&msg);\n\n    struct nx_tlv_table_reply *nx_ttr = ofpbuf_pull(&msg, sizeof *nx_ttr);\n    ttr->max_option_space = ntohl(nx_ttr->max_option_space);\n    ttr->max_fields = ntohs(nx_ttr->max_fields);\n\n    return decode_tlv_table_mappings(&msg, ttr->max_fields, &ttr->mappings);\n}\n\nvoid\nofputil_uninit_tlv_table(struct ovs_list *mappings)\n{\n    struct ofputil_tlv_map *map;\n\n    LIST_FOR_EACH_POP (map, list_node, mappings) {\n        free(map);\n    }\n}\n\nconst char *\nofputil_async_msg_type_to_string(enum ofputil_async_msg_type type)\n{\n    switch (type) {\n    case OAM_PACKET_IN:      return \"PACKET_IN\";\n    case OAM_PORT_STATUS:    return \"PORT_STATUS\";\n    case OAM_FLOW_REMOVED:   return \"FLOW_REMOVED\";\n    case OAM_ROLE_STATUS:    return \"ROLE_STATUS\";\n    case OAM_TABLE_STATUS:   return \"TABLE_STATUS\";\n    case OAM_REQUESTFORWARD: return \"REQUESTFORWARD\";\n\n    case OAM_N_TYPES:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstruct ofp14_async_prop {\n    uint64_t prop_type;\n    enum ofputil_async_msg_type oam;\n    bool master;\n    uint32_t allowed10, allowed14;\n};\n\n#define AP_PAIR(SLAVE_PROP_TYPE, OAM, A10, A14) \\\n    { SLAVE_PROP_TYPE,       OAM, false, A10, (A14) ? (A14) : (A10) },  \\\n    { (SLAVE_PROP_TYPE + 1), OAM, true,  A10, (A14) ? (A14) : (A10) }\n\nstatic const struct ofp14_async_prop async_props[] = {\n    AP_PAIR( 0, OAM_PACKET_IN,      OFPR10_BITS, OFPR14_BITS),\n    AP_PAIR( 2, OAM_PORT_STATUS,    (1 << OFPPR_N_REASONS) - 1, 0),\n    AP_PAIR( 4, OAM_FLOW_REMOVED,   (1 << OVS_OFPRR_NONE) - 1, 0),\n    AP_PAIR( 6, OAM_ROLE_STATUS,    (1 << OFPCRR_N_REASONS) - 1, 0),\n    AP_PAIR( 8, OAM_TABLE_STATUS,   OFPTR_BITS, 0),\n    AP_PAIR(10, OAM_REQUESTFORWARD, (1 << OFPRFR_N_REASONS) - 1, 0),\n};\n\n#define FOR_EACH_ASYNC_PROP(VAR)                                \\\n    for (const struct ofp14_async_prop *VAR = async_props;      \\\n         VAR < &async_props[ARRAY_SIZE(async_props)]; VAR++)\n\nstatic const struct ofp14_async_prop *\nget_ofp14_async_config_prop_by_prop_type(uint64_t prop_type)\n{\n    FOR_EACH_ASYNC_PROP (ap) {\n        if (prop_type == ap->prop_type) {\n            return ap;\n        }\n    }\n    return NULL;\n}\n\nstatic const struct ofp14_async_prop *\nget_ofp14_async_config_prop_by_oam(enum ofputil_async_msg_type oam,\n                                   bool master)\n{\n    FOR_EACH_ASYNC_PROP (ap) {\n        if (ap->oam == oam && ap->master == master) {\n            return ap;\n        }\n    }\n    return NULL;\n}\n\nstatic uint32_t\nofp14_async_prop_allowed(const struct ofp14_async_prop *prop,\n                         enum ofp_version version)\n{\n    return version >= OFP14_VERSION ? prop->allowed14 : prop->allowed10;\n}\n\nstatic ovs_be32\nencode_async_mask(const struct ofputil_async_cfg *src,\n                  const struct ofp14_async_prop *ap,\n                  enum ofp_version version)\n{\n    uint32_t mask = ap->master ? src->master[ap->oam] : src->slave[ap->oam];\n    return htonl(mask & ofp14_async_prop_allowed(ap, version));\n}\n\nstatic enum ofperr\ndecode_async_mask(ovs_be32 src,\n                  const struct ofp14_async_prop *ap, enum ofp_version version,\n                  bool loose, struct ofputil_async_cfg *dst)\n{\n    uint32_t mask = ntohl(src);\n    uint32_t allowed = ofp14_async_prop_allowed(ap, version);\n    if (mask & ~allowed) {\n        OFPPROP_LOG(&bad_ofmsg_rl, loose,\n                    \"bad value %#x for %s (allowed mask %#x)\",\n                    mask, ofputil_async_msg_type_to_string(ap->oam),\n                    allowed);\n        mask &= allowed;\n        if (!loose) {\n            return OFPERR_OFPACFC_INVALID;\n        }\n    }\n\n    if (ap->oam == OAM_PACKET_IN) {\n        if (mask & (1u << OFPR_NO_MATCH)) {\n            mask |= 1u << OFPR_EXPLICIT_MISS;\n            if (version < OFP13_VERSION) {\n                mask |= 1u << OFPR_IMPLICIT_MISS;\n            }\n        }\n    }\n\n    uint32_t *array = ap->master ? dst->master : dst->slave;\n    array[ap->oam] = mask;\n    return 0;\n}\n\nstatic enum ofperr\nparse_async_tlv(const struct ofpbuf *property,\n                const struct ofp14_async_prop *ap,\n                struct ofputil_async_cfg *ac,\n                enum ofp_version version, bool loose)\n{\n    enum ofperr error;\n    ovs_be32 mask;\n\n    error  = ofpprop_parse_be32(property, &mask);\n    if (error) {\n        return error;\n    }\n\n    if (ofpprop_is_experimenter(ap->prop_type)) {\n        /* For experimenter properties, whether a property is for the master or\n         * slave role is indicated by both 'type' and 'exp_type' in struct\n         * ofp_prop_experimenter.  Check that these are consistent. */\n        const struct ofp_prop_experimenter *ope = property->data;\n        bool should_be_master = ope->type == htons(0xffff);\n        if (should_be_master != ap->master) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"async property type %#\"PRIx16\" \"\n                         \"indicates %s role but exp_type %\"PRIu32\" indicates \"\n                         \"%s role\",\n                         ntohs(ope->type),\n                         should_be_master ? \"master\" : \"slave\",\n                         ntohl(ope->exp_type),\n                         ap->master ? \"master\" : \"slave\");\n            return OFPERR_OFPBPC_BAD_EXP_TYPE;\n        }\n    }\n\n    return decode_async_mask(mask, ap, version, loose, ac);\n}\n\nstatic void\ndecode_legacy_async_masks(const ovs_be32 masks[2],\n                          enum ofputil_async_msg_type oam,\n                          enum ofp_version version,\n                          struct ofputil_async_cfg *dst)\n{\n    for (int i = 0; i < 2; i++) {\n        bool master = i == 0;\n        const struct ofp14_async_prop *ap\n            = get_ofp14_async_config_prop_by_oam(oam, master);\n        decode_async_mask(masks[i], ap, version, true, dst);\n    }\n}\n\n/* Decodes the OpenFlow \"set async config\" request and \"get async config\n * reply\" message in '*oh' into an abstract form in 'ac'.\n *\n * Some versions of the \"set async config\" request change only some of the\n * settings and leave the others alone.  This function uses 'basis' as the\n * initial state for decoding these.  Other versions of the request change all\n * the settings; this function ignores 'basis' when decoding these.\n *\n * If 'loose' is true, this function ignores properties and values that it does\n * not understand, as a controller would want to do when interpreting\n * capabilities provided by a switch.  If 'loose' is false, this function\n * treats unknown properties and values as an error, as a switch would want to\n * do when interpreting a configuration request made by a controller.\n *\n * Returns 0 if successful, otherwise an OFPERR_* value.\n *\n * Returns error code OFPERR_OFPACFC_INVALID if the value of mask is not in\n * the valid range of mask.\n *\n * Returns error code OFPERR_OFPACFC_UNSUPPORTED if the configuration is not\n * supported.*/\nenum ofperr\nofputil_decode_set_async_config(const struct ofp_header *oh, bool loose,\n                                const struct ofputil_async_cfg *basis,\n                                struct ofputil_async_cfg *ac)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    if (raw == OFPRAW_OFPT13_SET_ASYNC ||\n        raw == OFPRAW_NXT_SET_ASYNC_CONFIG ||\n        raw == OFPRAW_OFPT13_GET_ASYNC_REPLY) {\n        const struct nx_async_config *msg = ofpmsg_body(oh);\n\n        *ac = OFPUTIL_ASYNC_CFG_INIT;\n        decode_legacy_async_masks(msg->packet_in_mask, OAM_PACKET_IN,\n                                  oh->version, ac);\n        decode_legacy_async_masks(msg->port_status_mask, OAM_PORT_STATUS,\n                                  oh->version, ac);\n        decode_legacy_async_masks(msg->flow_removed_mask, OAM_FLOW_REMOVED,\n                                  oh->version, ac);\n    } else if (raw == OFPRAW_OFPT14_SET_ASYNC ||\n               raw == OFPRAW_OFPT14_GET_ASYNC_REPLY ||\n               raw == OFPRAW_NXT_SET_ASYNC_CONFIG2) {\n        *ac = *basis;\n        while (b.size > 0) {\n            struct ofpbuf property;\n            enum ofperr error;\n            uint64_t type;\n\n            error = ofpprop_pull__(&b, &property, 8, 0xfffe, &type);\n            if (error) {\n                return error;\n            }\n\n            const struct ofp14_async_prop *ap\n                = get_ofp14_async_config_prop_by_prop_type(type);\n            error = (ap\n                     ? parse_async_tlv(&property, ap, ac, oh->version, loose)\n                     : OFPPROP_UNKNOWN(loose, \"async config\", type));\n            if (error) {\n                /* Most messages use OFPBPC_BAD_TYPE but async has its own (who\n                 * knows why, it's OpenFlow. */\n                if (error == OFPERR_OFPBPC_BAD_TYPE) {\n                    error = OFPERR_OFPACFC_UNSUPPORTED;\n                }\n                return error;\n            }\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n    return 0;\n}\n\nstatic void\nencode_legacy_async_masks(const struct ofputil_async_cfg *ac,\n                          enum ofputil_async_msg_type oam,\n                          enum ofp_version version,\n                          ovs_be32 masks[2])\n{\n    for (int i = 0; i < 2; i++) {\n        bool master = i == 0;\n        const struct ofp14_async_prop *ap\n            = get_ofp14_async_config_prop_by_oam(oam, master);\n        masks[i] = encode_async_mask(ac, ap, version);\n    }\n}\n\nstatic void\nofputil_put_async_config__(const struct ofputil_async_cfg *ac,\n                           struct ofpbuf *buf, bool tlv,\n                           enum ofp_version version, uint32_t oams)\n{\n    if (!tlv) {\n        struct nx_async_config *msg = ofpbuf_put_zeros(buf, sizeof *msg);\n        encode_legacy_async_masks(ac, OAM_PACKET_IN, version,\n                                  msg->packet_in_mask);\n        encode_legacy_async_masks(ac, OAM_PORT_STATUS, version,\n                                  msg->port_status_mask);\n        encode_legacy_async_masks(ac, OAM_FLOW_REMOVED, version,\n                                  msg->flow_removed_mask);\n    } else {\n        FOR_EACH_ASYNC_PROP (ap) {\n            if (oams & (1u << ap->oam)) {\n                size_t ofs = buf->size;\n                ofpprop_put_be32(buf, ap->prop_type,\n                                 encode_async_mask(ac, ap, version));\n\n                /* For experimenter properties, we need to use type 0xfffe for\n                 * master and 0xffff for slaves. */\n                if (ofpprop_is_experimenter(ap->prop_type)) {\n                    struct ofp_prop_experimenter *ope\n                        = ofpbuf_at_assert(buf, ofs, sizeof *ope);\n                    ope->type = ap->master ? htons(0xffff) : htons(0xfffe);\n                }\n            }\n        }\n    }\n}\n\n/* Encodes and returns a reply to the OFPT_GET_ASYNC_REQUEST in 'oh' that\n * states that the asynchronous message configuration is 'ac'. */\nstruct ofpbuf *\nofputil_encode_get_async_reply(const struct ofp_header *oh,\n                               const struct ofputil_async_cfg *ac)\n{\n    struct ofpbuf *buf;\n\n    enum ofpraw raw = (oh->version < OFP14_VERSION\n                       ? OFPRAW_OFPT13_GET_ASYNC_REPLY\n                       : OFPRAW_OFPT14_GET_ASYNC_REPLY);\n    struct ofpbuf *reply = ofpraw_alloc_reply(raw, oh, 0);\n    ofputil_put_async_config__(ac, reply,\n                               raw == OFPRAW_OFPT14_GET_ASYNC_REPLY,\n                               oh->version, UINT32_MAX);\n    return reply;\n\n    return buf;\n}\n\n/* Encodes and returns a message, in a format appropriate for OpenFlow version\n * 'ofp_version', that sets the asynchronous message configuration to 'ac'.\n *\n * Specify 'oams' as a bitmap of OAM_* that indicate the asynchronous messages\n * to configure.  OF1.0 through OF1.3 can't natively configure a subset of\n * messages, so more messages than requested may be configured.  OF1.0 through\n * OF1.3 also can't configure OVS extension OAM_* values, so if 'oam' includes\n * any extensions then this function encodes an Open vSwitch extension message\n * that does support configuring OVS extension OAM_*. */\nstruct ofpbuf *\nofputil_encode_set_async_config(const struct ofputil_async_cfg *ac,\n                                uint32_t oams, enum ofp_version ofp_version)\n{\n    enum ofpraw raw = (ofp_version >= OFP14_VERSION ? OFPRAW_OFPT14_SET_ASYNC\n                       : oams & OAM_EXTENSIONS ? OFPRAW_NXT_SET_ASYNC_CONFIG2\n                       : ofp_version >= OFP13_VERSION ? OFPRAW_OFPT13_SET_ASYNC\n                       : OFPRAW_NXT_SET_ASYNC_CONFIG);\n    struct ofpbuf *request = ofpraw_alloc(raw, ofp_version, 0);\n    ofputil_put_async_config__(ac, request,\n                               (raw == OFPRAW_OFPT14_SET_ASYNC ||\n                                raw == OFPRAW_NXT_SET_ASYNC_CONFIG2),\n                               ofp_version, oams);\n    return request;\n}\n\nstruct ofputil_async_cfg\nofputil_async_cfg_default(enum ofp_version version)\n{\n    /* We enable all of the OF1.4 reasons regardless of 'version' because the\n     * reasons added in OF1.4 just are just refinements of the OFPR_ACTION\n     * introduced in OF1.0, breaking it into more specific categories.  When we\n     * encode these for earlier OpenFlow versions, we translate them into\n     * OFPR_ACTION.  */\n    uint32_t pin = OFPR14_BITS & ~(1u << OFPR_INVALID_TTL);\n    pin |= 1u << OFPR_EXPLICIT_MISS;\n    if (version <= OFP12_VERSION) {\n        pin |= 1u << OFPR_IMPLICIT_MISS;\n    }\n\n    return (struct ofputil_async_cfg) {\n        .master[OAM_PACKET_IN] = pin,\n\n        .master[OAM_FLOW_REMOVED]\n            = (version >= OFP14_VERSION ? OFPRR14_BITS : OFPRR10_BITS),\n\n        .master[OAM_PORT_STATUS] = OFPPR_BITS,\n        .slave[OAM_PORT_STATUS] = OFPPR_BITS,\n    };\n}\n\nstatic void\nofputil_put_ofp14_table_desc(const struct ofputil_table_desc *td,\n                             struct ofpbuf *b, enum ofp_version version)\n{\n    struct ofp14_table_desc *otd;\n    struct ofp14_table_mod_prop_vacancy *otv;\n    size_t start_otd;\n\n    start_otd = b->size;\n    ofpbuf_put_zeros(b, sizeof *otd);\n\n    ofpprop_put_u32(b, OFPTMPT14_EVICTION, td->eviction_flags);\n\n    otv = ofpbuf_put_zeros(b, sizeof *otv);\n    otv->type = htons(OFPTMPT14_VACANCY);\n    otv->length = htons(sizeof *otv);\n    otv->vacancy_down = td->table_vacancy.vacancy_down;\n    otv->vacancy_up = td->table_vacancy.vacancy_up;\n    otv->vacancy = td->table_vacancy.vacancy;\n\n    otd = ofpbuf_at_assert(b, start_otd, sizeof *otd);\n    otd->length = htons(b->size - start_otd);\n    otd->table_id = td->table_id;\n    otd->config = ofputil_encode_table_config(OFPUTIL_TABLE_MISS_DEFAULT,\n                                              td->eviction, td->vacancy,\n                                              version);\n}\n\n/* Converts the abstract form of a \"table status\" message in '*ts' into an\n * OpenFlow message suitable for 'protocol', and returns that encoded form in\n * a buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_table_status(const struct ofputil_table_status *ts,\n                            enum ofputil_protocol protocol)\n{\n    enum ofp_version version;\n    struct ofpbuf *b;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    if (version >= OFP14_VERSION) {\n        enum ofpraw raw;\n        struct ofp14_table_status *ots;\n\n        raw = OFPRAW_OFPT14_TABLE_STATUS;\n        b = ofpraw_alloc_xid(raw, version, htonl(0), 0);\n        ots = ofpbuf_put_zeros(b, sizeof *ots);\n        ots->reason = ts->reason;\n        ofputil_put_ofp14_table_desc(&ts->desc, b, version);\n        ofpmsg_update_length(b);\n        return b;\n    } else {\n        return NULL;\n    }\n}\n\n/* Decodes the OpenFlow \"table status\" message in '*ots' into an abstract form\n * in '*ts'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_table_status(const struct ofp_header *oh,\n                            struct ofputil_table_status *ts)\n{\n    const struct ofp14_table_status *ots;\n    struct ofpbuf b;\n    enum ofperr error;\n    enum ofpraw raw;\n\n    ofpbuf_use_const(&b, oh, ntohs(oh->length));\n    raw = ofpraw_pull_assert(&b);\n    ots = ofpbuf_pull(&b, sizeof *ots);\n\n    if (raw == OFPRAW_OFPT14_TABLE_STATUS) {\n        if (ots->reason != OFPTR_VACANCY_DOWN\n            && ots->reason != OFPTR_VACANCY_UP) {\n            return OFPERR_OFPBPC_BAD_VALUE;\n        }\n        ts->reason = ots->reason;\n\n        error = ofputil_decode_table_desc(&b, &ts->desc, oh->version);\n        return error;\n    } else {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2008-2017 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <netinet/icmp6.h>\n#include <stdlib.h>\n#include \"bitmap.h\"\n#include \"bundle.h\"\n#include \"byte-order.h\"\n#include \"classifier.h\"\n#include \"learn.h\"\n#include \"multipath.h\"\n#include \"netdev.h\"\n#include \"nx-match.h\"\n#include \"id-pool.h\"\n#include \"openflow/netronome-ext.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"openvswitch/meta-flow.h\"\n#include \"openvswitch/ofp-actions.h\"\n#include \"openvswitch/ofp-errors.h\"\n#include \"openvswitch/ofp-msgs.h\"\n#include \"openvswitch/ofp-print.h\"\n#include \"openvswitch/ofp-prop.h\"\n#include \"openvswitch/ofp-util.h\"\n#include \"openvswitch/ofpbuf.h\"\n#include \"openvswitch/type-props.h\"\n#include \"openvswitch/vlog.h\"\n#include \"openflow/intel-ext.h\"\n#include \"packets.h\"\n#include \"random.h\"\n#include \"tun-metadata.h\"\n#include \"unaligned.h\"\n#include \"util.h\"\n#include \"uuid.h\"\n\nVLOG_DEFINE_THIS_MODULE(ofp_util);\n\n/* Rate limit for OpenFlow message parse errors.  These always indicate a bug\n * in the peer and so there's not much point in showing a lot of them. */\nstatic struct vlog_rate_limit bad_ofmsg_rl = VLOG_RATE_LIMIT_INIT(1, 5);\n\nstatic enum ofputil_table_vacancy ofputil_decode_table_vacancy(\n    ovs_be32 config, enum ofp_version);\nstatic enum ofputil_table_eviction ofputil_decode_table_eviction(\n    ovs_be32 config, enum ofp_version);\nstatic ovs_be32 ofputil_encode_table_config(enum ofputil_table_miss,\n                                            enum ofputil_table_eviction,\n                                            enum ofputil_table_vacancy,\n                                            enum ofp_version);\n\n/* Given the wildcard bit count in the least-significant 6 of 'wcbits', returns\n * an IP netmask with a 1 in each bit that must match and a 0 in each bit that\n * is wildcarded.\n *\n * The bits in 'wcbits' are in the format used in enum ofp_flow_wildcards: 0\n * is exact match, 1 ignores the LSB, 2 ignores the 2 least-significant bits,\n * ..., 32 and higher wildcard the entire field.  This is the *opposite* of the\n * usual convention where e.g. /24 indicates that 8 bits (not 24 bits) are\n * wildcarded. */\novs_be32\nofputil_wcbits_to_netmask(int wcbits)\n{\n    wcbits &= 0x3f;\n    return wcbits < 32 ? htonl(~((1u << wcbits) - 1)) : 0;\n}\n\n/* Given the IP netmask 'netmask', returns the number of bits of the IP address\n * that it wildcards, that is, the number of 0-bits in 'netmask', a number\n * between 0 and 32 inclusive.\n *\n * If 'netmask' is not a CIDR netmask (see ip_is_cidr()), the return value will\n * still be in the valid range but isn't otherwise meaningful. */\nint\nofputil_netmask_to_wcbits(ovs_be32 netmask)\n{\n    return 32 - ip_count_cidr_bits(netmask);\n}\n\n/* Converts the OpenFlow 1.0 wildcards in 'ofpfw' (OFPFW10_*) into a\n * flow_wildcards in 'wc' for use in struct match.  It is the caller's\n * responsibility to handle the special case where the flow match's dl_vlan is\n * set to OFP_VLAN_NONE. */\nvoid\nofputil_wildcard_from_ofpfw10(uint32_t ofpfw, struct flow_wildcards *wc)\n{\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 36);\n\n    /* Initialize most of wc. */\n    flow_wildcards_init_catchall(wc);\n\n    if (!(ofpfw & OFPFW10_IN_PORT)) {\n        wc->masks.in_port.ofp_port = u16_to_ofp(UINT16_MAX);\n    }\n\n    if (!(ofpfw & OFPFW10_NW_TOS)) {\n        wc->masks.nw_tos |= IP_DSCP_MASK;\n    }\n\n    if (!(ofpfw & OFPFW10_NW_PROTO)) {\n        wc->masks.nw_proto = UINT8_MAX;\n    }\n    wc->masks.nw_src = ofputil_wcbits_to_netmask(ofpfw\n                                                 >> OFPFW10_NW_SRC_SHIFT);\n    wc->masks.nw_dst = ofputil_wcbits_to_netmask(ofpfw\n                                                 >> OFPFW10_NW_DST_SHIFT);\n\n    if (!(ofpfw & OFPFW10_TP_SRC)) {\n        wc->masks.tp_src = OVS_BE16_MAX;\n    }\n    if (!(ofpfw & OFPFW10_TP_DST)) {\n        wc->masks.tp_dst = OVS_BE16_MAX;\n    }\n\n    if (!(ofpfw & OFPFW10_DL_SRC)) {\n        WC_MASK_FIELD(wc, dl_src);\n    }\n    if (!(ofpfw & OFPFW10_DL_DST)) {\n        WC_MASK_FIELD(wc, dl_dst);\n    }\n    if (!(ofpfw & OFPFW10_DL_TYPE)) {\n        wc->masks.dl_type = OVS_BE16_MAX;\n    }\n\n    /* VLAN TCI mask. */\n    if (!(ofpfw & OFPFW10_DL_VLAN_PCP)) {\n        wc->masks.vlan_tci |= htons(VLAN_PCP_MASK | VLAN_CFI);\n    }\n    if (!(ofpfw & OFPFW10_DL_VLAN)) {\n        wc->masks.vlan_tci |= htons(VLAN_VID_MASK | VLAN_CFI);\n    }\n}\n\n/* Converts the ofp10_match in 'ofmatch' into a struct match in 'match'. */\nvoid\nofputil_match_from_ofp10_match(const struct ofp10_match *ofmatch,\n                               struct match *match)\n{\n    uint32_t ofpfw = ntohl(ofmatch->wildcards) & OFPFW10_ALL;\n\n    /* Initialize match->wc. */\n    memset(&match->flow, 0, sizeof match->flow);\n    ofputil_wildcard_from_ofpfw10(ofpfw, &match->wc);\n    memset(&match->tun_md, 0, sizeof match->tun_md);\n\n    /* Initialize most of match->flow. */\n    match->flow.nw_src = ofmatch->nw_src;\n    match->flow.nw_dst = ofmatch->nw_dst;\n    match->flow.in_port.ofp_port = u16_to_ofp(ntohs(ofmatch->in_port));\n    match->flow.dl_type = ofputil_dl_type_from_openflow(ofmatch->dl_type);\n    match->flow.tp_src = ofmatch->tp_src;\n    match->flow.tp_dst = ofmatch->tp_dst;\n    match->flow.dl_src = ofmatch->dl_src;\n    match->flow.dl_dst = ofmatch->dl_dst;\n    match->flow.nw_tos = ofmatch->nw_tos & IP_DSCP_MASK;\n    match->flow.nw_proto = ofmatch->nw_proto;\n\n    /* Translate VLANs. */\n    if (!(ofpfw & OFPFW10_DL_VLAN) &&\n        ofmatch->dl_vlan == htons(OFP10_VLAN_NONE)) {\n        /* Match only packets without 802.1Q header.\n         *\n         * When OFPFW10_DL_VLAN_PCP is wildcarded, this is obviously correct.\n         *\n         * If OFPFW10_DL_VLAN_PCP is matched, the flow match is contradictory,\n         * because we can't have a specific PCP without an 802.1Q header.\n         * However, older versions of OVS treated this as matching packets\n         * withut an 802.1Q header, so we do here too. */\n        match->flow.vlan_tci = htons(0);\n        match->wc.masks.vlan_tci = htons(0xffff);\n    } else {\n        ovs_be16 vid, pcp, tci;\n        uint16_t hpcp;\n\n        vid = ofmatch->dl_vlan & htons(VLAN_VID_MASK);\n        hpcp = (ofmatch->dl_vlan_pcp << VLAN_PCP_SHIFT) & VLAN_PCP_MASK;\n        pcp = htons(hpcp);\n        tci = vid | pcp | htons(VLAN_CFI);\n        match->flow.vlan_tci = tci & match->wc.masks.vlan_tci;\n    }\n\n    /* Clean up. */\n    match_zero_wildcarded_fields(match);\n}\n\n/* Convert 'match' into the OpenFlow 1.0 match structure 'ofmatch'. */\nvoid\nofputil_match_to_ofp10_match(const struct match *match,\n                             struct ofp10_match *ofmatch)\n{\n    const struct flow_wildcards *wc = &match->wc;\n    uint32_t ofpfw;\n\n    /* Figure out most OpenFlow wildcards. */\n    ofpfw = 0;\n    if (!wc->masks.in_port.ofp_port) {\n        ofpfw |= OFPFW10_IN_PORT;\n    }\n    if (!wc->masks.dl_type) {\n        ofpfw |= OFPFW10_DL_TYPE;\n    }\n    if (!wc->masks.nw_proto) {\n        ofpfw |= OFPFW10_NW_PROTO;\n    }\n    ofpfw |= (ofputil_netmask_to_wcbits(wc->masks.nw_src)\n              << OFPFW10_NW_SRC_SHIFT);\n    ofpfw |= (ofputil_netmask_to_wcbits(wc->masks.nw_dst)\n              << OFPFW10_NW_DST_SHIFT);\n    if (!(wc->masks.nw_tos & IP_DSCP_MASK)) {\n        ofpfw |= OFPFW10_NW_TOS;\n    }\n    if (!wc->masks.tp_src) {\n        ofpfw |= OFPFW10_TP_SRC;\n    }\n    if (!wc->masks.tp_dst) {\n        ofpfw |= OFPFW10_TP_DST;\n    }\n    if (eth_addr_is_zero(wc->masks.dl_src)) {\n        ofpfw |= OFPFW10_DL_SRC;\n    }\n    if (eth_addr_is_zero(wc->masks.dl_dst)) {\n        ofpfw |= OFPFW10_DL_DST;\n    }\n\n    /* Translate VLANs. */\n    ofmatch->dl_vlan = htons(0);\n    ofmatch->dl_vlan_pcp = 0;\n    if (match->wc.masks.vlan_tci == htons(0)) {\n        ofpfw |= OFPFW10_DL_VLAN | OFPFW10_DL_VLAN_PCP;\n    } else if (match->wc.masks.vlan_tci & htons(VLAN_CFI)\n               && !(match->flow.vlan_tci & htons(VLAN_CFI))) {\n        ofmatch->dl_vlan = htons(OFP10_VLAN_NONE);\n    } else {\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_VID_MASK))) {\n            ofpfw |= OFPFW10_DL_VLAN;\n        } else {\n            ofmatch->dl_vlan = htons(vlan_tci_to_vid(match->flow.vlan_tci));\n        }\n\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_PCP_MASK))) {\n            ofpfw |= OFPFW10_DL_VLAN_PCP;\n        } else {\n            ofmatch->dl_vlan_pcp = vlan_tci_to_pcp(match->flow.vlan_tci);\n        }\n    }\n\n    /* Compose most of the match structure. */\n    ofmatch->wildcards = htonl(ofpfw);\n    ofmatch->in_port = htons(ofp_to_u16(match->flow.in_port.ofp_port));\n    ofmatch->dl_src = match->flow.dl_src;\n    ofmatch->dl_dst = match->flow.dl_dst;\n    ofmatch->dl_type = ofputil_dl_type_to_openflow(match->flow.dl_type);\n    ofmatch->nw_src = match->flow.nw_src;\n    ofmatch->nw_dst = match->flow.nw_dst;\n    ofmatch->nw_tos = match->flow.nw_tos & IP_DSCP_MASK;\n    ofmatch->nw_proto = match->flow.nw_proto;\n    ofmatch->tp_src = match->flow.tp_src;\n    ofmatch->tp_dst = match->flow.tp_dst;\n    memset(ofmatch->pad1, '\\0', sizeof ofmatch->pad1);\n    memset(ofmatch->pad2, '\\0', sizeof ofmatch->pad2);\n}\n\nenum ofperr\nofputil_pull_ofp11_match(struct ofpbuf *buf, const struct tun_table *tun_table,\n                         const struct vl_mff_map *vl_mff_map,\n                         struct match *match, uint16_t *padded_match_len)\n{\n    struct ofp11_match_header *omh = buf->data;\n    uint16_t match_len;\n\n    if (buf->size < sizeof *omh) {\n        return OFPERR_OFPBMC_BAD_LEN;\n    }\n\n    match_len = ntohs(omh->length);\n\n    switch (ntohs(omh->type)) {\n    case OFPMT_STANDARD: {\n        struct ofp11_match *om;\n\n        if (match_len != sizeof *om || buf->size < sizeof *om) {\n            return OFPERR_OFPBMC_BAD_LEN;\n        }\n        om = ofpbuf_pull(buf, sizeof *om);\n        if (padded_match_len) {\n            *padded_match_len = match_len;\n        }\n        return ofputil_match_from_ofp11_match(om, match);\n    }\n\n    case OFPMT_OXM:\n        if (padded_match_len) {\n            *padded_match_len = ROUND_UP(match_len, 8);\n        }\n        return oxm_pull_match(buf, tun_table, vl_mff_map, match);\n\n    default:\n        return OFPERR_OFPBMC_BAD_TYPE;\n    }\n}\n\n/* Converts the ofp11_match in 'ofmatch' into a struct match in 'match'.\n * Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_match_from_ofp11_match(const struct ofp11_match *ofmatch,\n                               struct match *match)\n{\n    uint16_t wc = ntohl(ofmatch->wildcards);\n    bool ipv4, arp, rarp;\n\n    match_init_catchall(match);\n\n    if (!(wc & OFPFW11_IN_PORT)) {\n        ofp_port_t ofp_port;\n        enum ofperr error;\n\n        error = ofputil_port_from_ofp11(ofmatch->in_port, &ofp_port);\n        if (error) {\n            return OFPERR_OFPBMC_BAD_VALUE;\n        }\n        match_set_in_port(match, ofp_port);\n    }\n\n    match_set_dl_src_masked(match, ofmatch->dl_src,\n                            eth_addr_invert(ofmatch->dl_src_mask));\n    match_set_dl_dst_masked(match, ofmatch->dl_dst,\n                            eth_addr_invert(ofmatch->dl_dst_mask));\n\n    if (!(wc & OFPFW11_DL_VLAN)) {\n        if (ofmatch->dl_vlan == htons(OFPVID11_NONE)) {\n            /* Match only packets without a VLAN tag. */\n            match->flow.vlan_tci = htons(0);\n            match->wc.masks.vlan_tci = OVS_BE16_MAX;\n        } else {\n            if (ofmatch->dl_vlan == htons(OFPVID11_ANY)) {\n                /* Match any packet with a VLAN tag regardless of VID. */\n                match->flow.vlan_tci = htons(VLAN_CFI);\n                match->wc.masks.vlan_tci = htons(VLAN_CFI);\n            } else if (ntohs(ofmatch->dl_vlan) < 4096) {\n                /* Match only packets with the specified VLAN VID. */\n                match->flow.vlan_tci = htons(VLAN_CFI) | ofmatch->dl_vlan;\n                match->wc.masks.vlan_tci = htons(VLAN_CFI | VLAN_VID_MASK);\n            } else {\n                /* Invalid VID. */\n                return OFPERR_OFPBMC_BAD_VALUE;\n            }\n\n            if (!(wc & OFPFW11_DL_VLAN_PCP)) {\n                if (ofmatch->dl_vlan_pcp <= 7) {\n                    match->flow.vlan_tci |= htons(ofmatch->dl_vlan_pcp\n                                                  << VLAN_PCP_SHIFT);\n                    match->wc.masks.vlan_tci |= htons(VLAN_PCP_MASK);\n                } else {\n                    /* Invalid PCP. */\n                    return OFPERR_OFPBMC_BAD_VALUE;\n                }\n            }\n        }\n    }\n\n    if (!(wc & OFPFW11_DL_TYPE)) {\n        match_set_dl_type(match,\n                          ofputil_dl_type_from_openflow(ofmatch->dl_type));\n    }\n\n    ipv4 = match->flow.dl_type == htons(ETH_TYPE_IP);\n    arp = match->flow.dl_type == htons(ETH_TYPE_ARP);\n    rarp = match->flow.dl_type == htons(ETH_TYPE_RARP);\n\n    if (ipv4 && !(wc & OFPFW11_NW_TOS)) {\n        if (ofmatch->nw_tos & ~IP_DSCP_MASK) {\n            /* Invalid TOS. */\n            return OFPERR_OFPBMC_BAD_VALUE;\n        }\n\n        match_set_nw_dscp(match, ofmatch->nw_tos);\n    }\n\n    if (ipv4 || arp || rarp) {\n        if (!(wc & OFPFW11_NW_PROTO)) {\n            match_set_nw_proto(match, ofmatch->nw_proto);\n        }\n        match_set_nw_src_masked(match, ofmatch->nw_src, ~ofmatch->nw_src_mask);\n        match_set_nw_dst_masked(match, ofmatch->nw_dst, ~ofmatch->nw_dst_mask);\n    }\n\n#define OFPFW11_TP_ALL (OFPFW11_TP_SRC | OFPFW11_TP_DST)\n    if (ipv4 && (wc & OFPFW11_TP_ALL) != OFPFW11_TP_ALL) {\n        switch (match->flow.nw_proto) {\n        case IPPROTO_ICMP:\n            /* \"A.2.3 Flow Match Structures\" in OF1.1 says:\n             *\n             *    The tp_src and tp_dst fields will be ignored unless the\n             *    network protocol specified is as TCP, UDP or SCTP.\n             *\n             * but I'm pretty sure we should support ICMP too, otherwise\n             * that's a regression from OF1.0. */\n            if (!(wc & OFPFW11_TP_SRC)) {\n                uint16_t icmp_type = ntohs(ofmatch->tp_src);\n                if (icmp_type < 0x100) {\n                    match_set_icmp_type(match, icmp_type);\n                } else {\n                    return OFPERR_OFPBMC_BAD_FIELD;\n                }\n            }\n            if (!(wc & OFPFW11_TP_DST)) {\n                uint16_t icmp_code = ntohs(ofmatch->tp_dst);\n                if (icmp_code < 0x100) {\n                    match_set_icmp_code(match, icmp_code);\n                } else {\n                    return OFPERR_OFPBMC_BAD_FIELD;\n                }\n            }\n            break;\n\n        case IPPROTO_TCP:\n        case IPPROTO_UDP:\n        case IPPROTO_SCTP:\n            if (!(wc & (OFPFW11_TP_SRC))) {\n                match_set_tp_src(match, ofmatch->tp_src);\n            }\n            if (!(wc & (OFPFW11_TP_DST))) {\n                match_set_tp_dst(match, ofmatch->tp_dst);\n            }\n            break;\n\n        default:\n            /* OF1.1 says explicitly to ignore this. */\n            break;\n        }\n    }\n\n    if (eth_type_mpls(match->flow.dl_type)) {\n        if (!(wc & OFPFW11_MPLS_LABEL)) {\n            match_set_mpls_label(match, 0, ofmatch->mpls_label);\n        }\n        if (!(wc & OFPFW11_MPLS_TC)) {\n            match_set_mpls_tc(match, 0, ofmatch->mpls_tc);\n        }\n    }\n\n    match_set_metadata_masked(match, ofmatch->metadata,\n                              ~ofmatch->metadata_mask);\n\n    return 0;\n}\n\n/* Convert 'match' into the OpenFlow 1.1 match structure 'ofmatch'. */\nvoid\nofputil_match_to_ofp11_match(const struct match *match,\n                             struct ofp11_match *ofmatch)\n{\n    uint32_t wc = 0;\n\n    memset(ofmatch, 0, sizeof *ofmatch);\n    ofmatch->omh.type = htons(OFPMT_STANDARD);\n    ofmatch->omh.length = htons(OFPMT11_STANDARD_LENGTH);\n\n    if (!match->wc.masks.in_port.ofp_port) {\n        wc |= OFPFW11_IN_PORT;\n    } else {\n        ofmatch->in_port = ofputil_port_to_ofp11(match->flow.in_port.ofp_port);\n    }\n\n    ofmatch->dl_src = match->flow.dl_src;\n    ofmatch->dl_src_mask = eth_addr_invert(match->wc.masks.dl_src);\n    ofmatch->dl_dst = match->flow.dl_dst;\n    ofmatch->dl_dst_mask = eth_addr_invert(match->wc.masks.dl_dst);\n\n    if (match->wc.masks.vlan_tci == htons(0)) {\n        wc |= OFPFW11_DL_VLAN | OFPFW11_DL_VLAN_PCP;\n    } else if (match->wc.masks.vlan_tci & htons(VLAN_CFI)\n               && !(match->flow.vlan_tci & htons(VLAN_CFI))) {\n        ofmatch->dl_vlan = htons(OFPVID11_NONE);\n        wc |= OFPFW11_DL_VLAN_PCP;\n    } else {\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_VID_MASK))) {\n            ofmatch->dl_vlan = htons(OFPVID11_ANY);\n        } else {\n            ofmatch->dl_vlan = htons(vlan_tci_to_vid(match->flow.vlan_tci));\n        }\n\n        if (!(match->wc.masks.vlan_tci & htons(VLAN_PCP_MASK))) {\n            wc |= OFPFW11_DL_VLAN_PCP;\n        } else {\n            ofmatch->dl_vlan_pcp = vlan_tci_to_pcp(match->flow.vlan_tci);\n        }\n    }\n\n    if (!match->wc.masks.dl_type) {\n        wc |= OFPFW11_DL_TYPE;\n    } else {\n        ofmatch->dl_type = ofputil_dl_type_to_openflow(match->flow.dl_type);\n    }\n\n    if (!(match->wc.masks.nw_tos & IP_DSCP_MASK)) {\n        wc |= OFPFW11_NW_TOS;\n    } else {\n        ofmatch->nw_tos = match->flow.nw_tos & IP_DSCP_MASK;\n    }\n\n    if (!match->wc.masks.nw_proto) {\n        wc |= OFPFW11_NW_PROTO;\n    } else {\n        ofmatch->nw_proto = match->flow.nw_proto;\n    }\n\n    ofmatch->nw_src = match->flow.nw_src;\n    ofmatch->nw_src_mask = ~match->wc.masks.nw_src;\n    ofmatch->nw_dst = match->flow.nw_dst;\n    ofmatch->nw_dst_mask = ~match->wc.masks.nw_dst;\n\n    if (!match->wc.masks.tp_src) {\n        wc |= OFPFW11_TP_SRC;\n    } else {\n        ofmatch->tp_src = match->flow.tp_src;\n    }\n\n    if (!match->wc.masks.tp_dst) {\n        wc |= OFPFW11_TP_DST;\n    } else {\n        ofmatch->tp_dst = match->flow.tp_dst;\n    }\n\n    if (!(match->wc.masks.mpls_lse[0] & htonl(MPLS_LABEL_MASK))) {\n        wc |= OFPFW11_MPLS_LABEL;\n    } else {\n        ofmatch->mpls_label = htonl(mpls_lse_to_label(\n                                        match->flow.mpls_lse[0]));\n    }\n\n    if (!(match->wc.masks.mpls_lse[0] & htonl(MPLS_TC_MASK))) {\n        wc |= OFPFW11_MPLS_TC;\n    } else {\n        ofmatch->mpls_tc = mpls_lse_to_tc(match->flow.mpls_lse[0]);\n    }\n\n    ofmatch->metadata = match->flow.metadata;\n    ofmatch->metadata_mask = ~match->wc.masks.metadata;\n\n    ofmatch->wildcards = htonl(wc);\n}\n\n/* Returns the \"typical\" length of a match for 'protocol', for use in\n * estimating space to preallocate. */\nint\nofputil_match_typical_len(enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n        return sizeof(struct ofp10_match);\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return NXM_TYPICAL_LEN;\n\n    case OFPUTIL_P_OF11_STD:\n        return sizeof(struct ofp11_match);\n\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM:\n        return NXM_TYPICAL_LEN;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Appends to 'b' an struct ofp11_match_header followed by a match that\n * expresses 'match' properly for 'protocol', plus enough zero bytes to pad the\n * data appended out to a multiple of 8.  'protocol' must be one that is usable\n * in OpenFlow 1.1 or later.\n *\n * This function can cause 'b''s data to be reallocated.\n *\n * Returns the number of bytes appended to 'b', excluding the padding.  Never\n * returns zero. */\nint\nofputil_put_ofp11_match(struct ofpbuf *b, const struct match *match,\n                        enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        OVS_NOT_REACHED();\n\n    case OFPUTIL_P_OF11_STD: {\n        struct ofp11_match *om;\n\n        /* Make sure that no padding is needed. */\n        BUILD_ASSERT_DECL(sizeof *om % 8 == 0);\n\n        om = ofpbuf_put_uninit(b, sizeof *om);\n        ofputil_match_to_ofp11_match(match, om);\n        return sizeof *om;\n    }\n\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM:\n        return oxm_put_match(b, match,\n                             ofputil_protocol_to_ofp_version(protocol));\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Given a 'dl_type' value in the format used in struct flow, returns the\n * corresponding 'dl_type' value for use in an ofp10_match or ofp11_match\n * structure. */\novs_be16\nofputil_dl_type_to_openflow(ovs_be16 flow_dl_type)\n{\n    return (flow_dl_type == htons(FLOW_DL_TYPE_NONE)\n            ? htons(OFP_DL_TYPE_NOT_ETH_TYPE)\n            : flow_dl_type);\n}\n\n/* Given a 'dl_type' value in the format used in an ofp10_match or ofp11_match\n * structure, returns the corresponding 'dl_type' value for use in struct\n * flow. */\novs_be16\nofputil_dl_type_from_openflow(ovs_be16 ofp_dl_type)\n{\n    return (ofp_dl_type == htons(OFP_DL_TYPE_NOT_ETH_TYPE)\n            ? htons(FLOW_DL_TYPE_NONE)\n            : ofp_dl_type);\n}\n\f\n/* Protocols. */\n\nstruct proto_abbrev {\n    enum ofputil_protocol protocol;\n    const char *name;\n};\n\n/* Most users really don't care about some of the differences between\n * protocols.  These abbreviations help with that. */\nstatic const struct proto_abbrev proto_abbrevs[] = {\n    { OFPUTIL_P_ANY,          \"any\" },\n    { OFPUTIL_P_OF10_STD_ANY, \"OpenFlow10\" },\n    { OFPUTIL_P_OF10_NXM_ANY, \"NXM\" },\n    { OFPUTIL_P_ANY_OXM,      \"OXM\" },\n};\n#define N_PROTO_ABBREVS ARRAY_SIZE(proto_abbrevs)\n\nenum ofputil_protocol ofputil_flow_dump_protocols[] = {\n    OFPUTIL_P_OF16_OXM,\n    OFPUTIL_P_OF15_OXM,\n    OFPUTIL_P_OF14_OXM,\n    OFPUTIL_P_OF13_OXM,\n    OFPUTIL_P_OF12_OXM,\n    OFPUTIL_P_OF11_STD,\n    OFPUTIL_P_OF10_NXM,\n    OFPUTIL_P_OF10_STD,\n};\nsize_t ofputil_n_flow_dump_protocols = ARRAY_SIZE(ofputil_flow_dump_protocols);\n\n/* Returns the set of ofputil_protocols that are supported with the given\n * OpenFlow 'version'.  'version' should normally be an 8-bit OpenFlow version\n * identifier (e.g. 0x01 for OpenFlow 1.0, 0x02 for OpenFlow 1.1).  Returns 0\n * if 'version' is not supported or outside the valid range.  */\nenum ofputil_protocol\nofputil_protocols_from_ofp_version(enum ofp_version version)\n{\n    switch (version) {\n    case OFP10_VERSION:\n        return OFPUTIL_P_OF10_STD_ANY | OFPUTIL_P_OF10_NXM_ANY;\n    case OFP11_VERSION:\n        return OFPUTIL_P_OF11_STD;\n    case OFP12_VERSION:\n        return OFPUTIL_P_OF12_OXM;\n    case OFP13_VERSION:\n        return OFPUTIL_P_OF13_OXM;\n    case OFP14_VERSION:\n        return OFPUTIL_P_OF14_OXM;\n    case OFP15_VERSION:\n        return OFPUTIL_P_OF15_OXM;\n    case OFP16_VERSION:\n        return OFPUTIL_P_OF16_OXM;\n    default:\n        return 0;\n    }\n}\n\n/* Returns the ofputil_protocol that is initially in effect on an OpenFlow\n * connection that has negotiated the given 'version'.  'version' should\n * normally be an 8-bit OpenFlow version identifier (e.g. 0x01 for OpenFlow\n * 1.0, 0x02 for OpenFlow 1.1).  Returns 0 if 'version' is not supported or\n * outside the valid range.  */\nenum ofputil_protocol\nofputil_protocol_from_ofp_version(enum ofp_version version)\n{\n    return rightmost_1bit(ofputil_protocols_from_ofp_version(version));\n}\n\n/* Returns the OpenFlow protocol version number (e.g. OFP10_VERSION,\n * etc.) that corresponds to 'protocol'. */\nenum ofp_version\nofputil_protocol_to_ofp_version(enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return OFP10_VERSION;\n    case OFPUTIL_P_OF11_STD:\n        return OFP11_VERSION;\n    case OFPUTIL_P_OF12_OXM:\n        return OFP12_VERSION;\n    case OFPUTIL_P_OF13_OXM:\n        return OFP13_VERSION;\n    case OFPUTIL_P_OF14_OXM:\n        return OFP14_VERSION;\n    case OFPUTIL_P_OF15_OXM:\n        return OFP15_VERSION;\n    case OFPUTIL_P_OF16_OXM:\n        return OFP16_VERSION;\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Returns a bitmap of OpenFlow versions that are supported by at\n * least one of the 'protocols'. */\nuint32_t\nofputil_protocols_to_version_bitmap(enum ofputil_protocol protocols)\n{\n    uint32_t bitmap = 0;\n\n    for (; protocols; protocols = zero_rightmost_1bit(protocols)) {\n        enum ofputil_protocol protocol = rightmost_1bit(protocols);\n\n        bitmap |= 1u << ofputil_protocol_to_ofp_version(protocol);\n    }\n\n    return bitmap;\n}\n\n/* Returns the set of protocols that are supported on top of the\n * OpenFlow versions included in 'bitmap'. */\nenum ofputil_protocol\nofputil_protocols_from_version_bitmap(uint32_t bitmap)\n{\n    enum ofputil_protocol protocols = 0;\n\n    for (; bitmap; bitmap = zero_rightmost_1bit(bitmap)) {\n        enum ofp_version version = rightmost_1bit_idx(bitmap);\n\n        protocols |= ofputil_protocols_from_ofp_version(version);\n    }\n\n    return protocols;\n}\n\n/* Returns true if 'protocol' is a single OFPUTIL_P_* value, false\n * otherwise. */\nbool\nofputil_protocol_is_valid(enum ofputil_protocol protocol)\n{\n    return protocol & OFPUTIL_P_ANY && is_pow2(protocol);\n}\n\n/* Returns the equivalent of 'protocol' with the Nicira flow_mod_table_id\n * extension turned on or off if 'enable' is true or false, respectively.\n *\n * This extension is only useful for protocols whose \"standard\" version does\n * not allow specific tables to be modified.  In particular, this is true of\n * OpenFlow 1.0.  In later versions of OpenFlow, a flow_mod request always\n * specifies a table ID and so there is no need for such an extension.  When\n * 'protocol' is such a protocol that doesn't need a flow_mod_table_id\n * extension, this function just returns its 'protocol' argument unchanged\n * regardless of the value of 'enable'.  */\nenum ofputil_protocol\nofputil_protocol_set_tid(enum ofputil_protocol protocol, bool enable)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n        return enable ? OFPUTIL_P_OF10_STD_TID : OFPUTIL_P_OF10_STD;\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return enable ? OFPUTIL_P_OF10_NXM_TID : OFPUTIL_P_OF10_NXM;\n\n    case OFPUTIL_P_OF11_STD:\n        return OFPUTIL_P_OF11_STD;\n\n    case OFPUTIL_P_OF12_OXM:\n        return OFPUTIL_P_OF12_OXM;\n\n    case OFPUTIL_P_OF13_OXM:\n        return OFPUTIL_P_OF13_OXM;\n\n    case OFPUTIL_P_OF14_OXM:\n        return OFPUTIL_P_OF14_OXM;\n\n    case OFPUTIL_P_OF15_OXM:\n        return OFPUTIL_P_OF15_OXM;\n\n    case OFPUTIL_P_OF16_OXM:\n        return OFPUTIL_P_OF16_OXM;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Returns the \"base\" version of 'protocol'.  That is, if 'protocol' includes\n * some extension to a standard protocol version, the return value is the\n * standard version of that protocol without any extension.  If 'protocol' is a\n * standard protocol version, returns 'protocol' unchanged. */\nenum ofputil_protocol\nofputil_protocol_to_base(enum ofputil_protocol protocol)\n{\n    return ofputil_protocol_set_tid(protocol, false);\n}\n\n/* Returns 'new_base' with any extensions taken from 'cur'. */\nenum ofputil_protocol\nofputil_protocol_set_base(enum ofputil_protocol cur,\n                          enum ofputil_protocol new_base)\n{\n    bool tid = (cur & OFPUTIL_P_TID) != 0;\n\n    switch (new_base) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF10_STD, tid);\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF10_NXM, tid);\n\n    case OFPUTIL_P_OF11_STD:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF11_STD, tid);\n\n    case OFPUTIL_P_OF12_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF12_OXM, tid);\n\n    case OFPUTIL_P_OF13_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF13_OXM, tid);\n\n    case OFPUTIL_P_OF14_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF14_OXM, tid);\n\n    case OFPUTIL_P_OF15_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF15_OXM, tid);\n\n    case OFPUTIL_P_OF16_OXM:\n        return ofputil_protocol_set_tid(OFPUTIL_P_OF16_OXM, tid);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Returns a string form of 'protocol', if a simple form exists (that is, if\n * 'protocol' is either a single protocol or it is a combination of protocols\n * that have a single abbreviation).  Otherwise, returns NULL. */\nconst char *\nofputil_protocol_to_string(enum ofputil_protocol protocol)\n{\n    const struct proto_abbrev *p;\n\n    /* Use a \"switch\" statement for single-bit names so that we get a compiler\n     * warning if we forget any. */\n    switch (protocol) {\n    case OFPUTIL_P_OF10_NXM:\n        return \"NXM-table_id\";\n\n    case OFPUTIL_P_OF10_NXM_TID:\n        return \"NXM+table_id\";\n\n    case OFPUTIL_P_OF10_STD:\n        return \"OpenFlow10-table_id\";\n\n    case OFPUTIL_P_OF10_STD_TID:\n        return \"OpenFlow10+table_id\";\n\n    case OFPUTIL_P_OF11_STD:\n        return \"OpenFlow11\";\n\n    case OFPUTIL_P_OF12_OXM:\n        return \"OXM-OpenFlow12\";\n\n    case OFPUTIL_P_OF13_OXM:\n        return \"OXM-OpenFlow13\";\n\n    case OFPUTIL_P_OF14_OXM:\n        return \"OXM-OpenFlow14\";\n\n    case OFPUTIL_P_OF15_OXM:\n        return \"OXM-OpenFlow15\";\n\n    case OFPUTIL_P_OF16_OXM:\n        return \"OXM-OpenFlow16\";\n    }\n\n    /* Check abbreviations. */\n    for (p = proto_abbrevs; p < &proto_abbrevs[N_PROTO_ABBREVS]; p++) {\n        if (protocol == p->protocol) {\n            return p->name;\n        }\n    }\n\n    return NULL;\n}\n\n/* Returns a string that represents 'protocols'.  The return value might be a\n * comma-separated list if 'protocols' doesn't have a simple name.  The return\n * value is \"none\" if 'protocols' is 0.\n *\n * The caller must free the returned string (with free()). */\nchar *\nofputil_protocols_to_string(enum ofputil_protocol protocols)\n{\n    struct ds s;\n\n    ovs_assert(!(protocols & ~OFPUTIL_P_ANY));\n    if (protocols == 0) {\n        return xstrdup(\"none\");\n    }\n\n    ds_init(&s);\n    while (protocols) {\n        const struct proto_abbrev *p;\n        int i;\n\n        if (s.length) {\n            ds_put_char(&s, ',');\n        }\n\n        for (p = proto_abbrevs; p < &proto_abbrevs[N_PROTO_ABBREVS]; p++) {\n            if ((protocols & p->protocol) == p->protocol) {\n                ds_put_cstr(&s, p->name);\n                protocols &= ~p->protocol;\n                goto match;\n            }\n        }\n\n        for (i = 0; i < CHAR_BIT * sizeof(enum ofputil_protocol); i++) {\n            enum ofputil_protocol bit = 1u << i;\n\n            if (protocols & bit) {\n                ds_put_cstr(&s, ofputil_protocol_to_string(bit));\n                protocols &= ~bit;\n                goto match;\n            }\n        }\n        OVS_NOT_REACHED();\n\n    match: ;\n    }\n    return ds_steal_cstr(&s);\n}\n\nstatic enum ofputil_protocol\nofputil_protocol_from_string__(const char *s, size_t n)\n{\n    const struct proto_abbrev *p;\n    int i;\n\n    for (i = 0; i < CHAR_BIT * sizeof(enum ofputil_protocol); i++) {\n        enum ofputil_protocol bit = 1u << i;\n        const char *name = ofputil_protocol_to_string(bit);\n\n        if (name && n == strlen(name) && !strncasecmp(s, name, n)) {\n            return bit;\n        }\n    }\n\n    for (p = proto_abbrevs; p < &proto_abbrevs[N_PROTO_ABBREVS]; p++) {\n        if (n == strlen(p->name) && !strncasecmp(s, p->name, n)) {\n            return p->protocol;\n        }\n    }\n\n    return 0;\n}\n\n/* Returns the nonempty set of protocols represented by 's', which can be a\n * single protocol name or abbreviation or a comma-separated list of them.\n *\n * Aborts the program with an error message if 's' is invalid. */\nenum ofputil_protocol\nofputil_protocols_from_string(const char *s)\n{\n    const char *orig_s = s;\n    enum ofputil_protocol protocols;\n\n    protocols = 0;\n    while (*s) {\n        enum ofputil_protocol p;\n        size_t n;\n\n        n = strcspn(s, \",\");\n        if (n == 0) {\n            s++;\n            continue;\n        }\n\n        p = ofputil_protocol_from_string__(s, n);\n        if (!p) {\n            ovs_fatal(0, \"%.*s: unknown flow protocol\", (int) n, s);\n        }\n        protocols |= p;\n\n        s += n;\n    }\n\n    if (!protocols) {\n        ovs_fatal(0, \"%s: no flow protocol specified\", orig_s);\n    }\n    return protocols;\n}\n\nenum ofp_version\nofputil_version_from_string(const char *s)\n{\n    if (!strcasecmp(s, \"OpenFlow10\")) {\n        return OFP10_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow11\")) {\n        return OFP11_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow12\")) {\n        return OFP12_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow13\")) {\n        return OFP13_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow14\")) {\n        return OFP14_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow15\")) {\n        return OFP15_VERSION;\n    }\n    if (!strcasecmp(s, \"OpenFlow16\")) {\n        return OFP16_VERSION;\n    }\n    return 0;\n}\n\nstatic bool\nis_delimiter(unsigned char c)\n{\n    return isspace(c) || c == ',';\n}\n\nuint32_t\nofputil_versions_from_string(const char *s)\n{\n    size_t i = 0;\n    uint32_t bitmap = 0;\n\n    while (s[i]) {\n        size_t j;\n        int version;\n        char *key;\n\n        if (is_delimiter(s[i])) {\n            i++;\n            continue;\n        }\n        j = 0;\n        while (s[i + j] && !is_delimiter(s[i + j])) {\n            j++;\n        }\n        key = xmemdup0(s + i, j);\n        version = ofputil_version_from_string(key);\n        if (!version) {\n            VLOG_FATAL(\"Unknown OpenFlow version: \\\"%s\\\"\", key);\n        }\n        free(key);\n        bitmap |= 1u << version;\n        i += j;\n    }\n\n    return bitmap;\n}\n\nuint32_t\nofputil_versions_from_strings(char ** const s, size_t count)\n{\n    uint32_t bitmap = 0;\n\n    while (count--) {\n        int version = ofputil_version_from_string(s[count]);\n        if (!version) {\n            VLOG_WARN(\"Unknown OpenFlow version: \\\"%s\\\"\", s[count]);\n        } else {\n            bitmap |= 1u << version;\n        }\n    }\n\n    return bitmap;\n}\n\nconst char *\nofputil_version_to_string(enum ofp_version ofp_version)\n{\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        return \"OpenFlow10\";\n    case OFP11_VERSION:\n        return \"OpenFlow11\";\n    case OFP12_VERSION:\n        return \"OpenFlow12\";\n    case OFP13_VERSION:\n        return \"OpenFlow13\";\n    case OFP14_VERSION:\n        return \"OpenFlow14\";\n    case OFP15_VERSION:\n        return \"OpenFlow15\";\n    case OFP16_VERSION:\n        return \"OpenFlow16\";\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nbool\nofputil_packet_in_format_is_valid(enum nx_packet_in_format packet_in_format)\n{\n    switch (packet_in_format) {\n    case NXPIF_STANDARD:\n    case NXPIF_NXT_PACKET_IN:\n    case NXPIF_NXT_PACKET_IN2:\n        return true;\n    }\n\n    return false;\n}\n\nconst char *\nofputil_packet_in_format_to_string(enum nx_packet_in_format packet_in_format)\n{\n    switch (packet_in_format) {\n    case NXPIF_STANDARD:\n        return \"standard\";\n    case NXPIF_NXT_PACKET_IN:\n        return \"nxt_packet_in\";\n    case NXPIF_NXT_PACKET_IN2:\n        return \"nxt_packet_in2\";\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nint\nofputil_packet_in_format_from_string(const char *s)\n{\n    return (!strcmp(s, \"standard\") || !strcmp(s, \"openflow10\")\n            ? NXPIF_STANDARD\n            : !strcmp(s, \"nxt_packet_in\") || !strcmp(s, \"nxm\")\n            ? NXPIF_NXT_PACKET_IN\n            : !strcmp(s, \"nxt_packet_in2\")\n            ? NXPIF_NXT_PACKET_IN2\n            : -1);\n}\n\nvoid\nofputil_format_version(struct ds *msg, enum ofp_version version)\n{\n    ds_put_format(msg, \"0x%02x\", version);\n}\n\nvoid\nofputil_format_version_name(struct ds *msg, enum ofp_version version)\n{\n    ds_put_cstr(msg, ofputil_version_to_string(version));\n}\n\nstatic void\nofputil_format_version_bitmap__(struct ds *msg, uint32_t bitmap,\n                                void (*format_version)(struct ds *msg,\n                                                       enum ofp_version))\n{\n    while (bitmap) {\n        format_version(msg, raw_ctz(bitmap));\n        bitmap = zero_rightmost_1bit(bitmap);\n        if (bitmap) {\n            ds_put_cstr(msg, \", \");\n        }\n    }\n}\n\nvoid\nofputil_format_version_bitmap(struct ds *msg, uint32_t bitmap)\n{\n    ofputil_format_version_bitmap__(msg, bitmap, ofputil_format_version);\n}\n\nvoid\nofputil_format_version_bitmap_names(struct ds *msg, uint32_t bitmap)\n{\n    ofputil_format_version_bitmap__(msg, bitmap, ofputil_format_version_name);\n}\n\nstatic bool\nofputil_decode_hello_bitmap(const struct ofp_hello_elem_header *oheh,\n                            uint32_t *allowed_versionsp)\n{\n    uint16_t bitmap_len = ntohs(oheh->length) - sizeof *oheh;\n    const ovs_be32 *bitmap = ALIGNED_CAST(const ovs_be32 *, oheh + 1);\n    uint32_t allowed_versions;\n\n    if (!bitmap_len || bitmap_len % sizeof *bitmap) {\n        return false;\n    }\n\n    /* Only use the first 32-bit element of the bitmap as that is all the\n     * current implementation supports.  Subsequent elements are ignored which\n     * should have no effect on session negotiation until Open vSwitch supports\n     * wire-protocol versions greater than 31.\n     */\n    allowed_versions = ntohl(bitmap[0]);\n\n    if (allowed_versions & 1) {\n        /* There's no OpenFlow version 0. */\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"peer claims to support invalid OpenFlow \"\n                     \"version 0x00\");\n        allowed_versions &= ~1u;\n    }\n\n    if (!allowed_versions) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"peer does not support any OpenFlow \"\n                     \"version (between 0x01 and 0x1f)\");\n        return false;\n    }\n\n    *allowed_versionsp = allowed_versions;\n    return true;\n}\n\nstatic uint32_t\nversion_bitmap_from_version(uint8_t ofp_version)\n{\n    return ((ofp_version < 32 ? 1u << ofp_version : 0) - 1) << 1;\n}\n\n/* Decodes OpenFlow OFPT_HELLO message 'oh', storing into '*allowed_versions'\n * the set of OpenFlow versions for which 'oh' announces support.\n *\n * Because of how OpenFlow defines OFPT_HELLO messages, this function is always\n * successful, and thus '*allowed_versions' is always initialized.  However, it\n * returns false if 'oh' contains some data that could not be fully understood,\n * true if 'oh' was completely parsed. */\nbool\nofputil_decode_hello(const struct ofp_header *oh, uint32_t *allowed_versions)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpbuf_pull(&msg, sizeof *oh);\n\n    *allowed_versions = version_bitmap_from_version(oh->version);\n\n    bool ok = true;\n    while (msg.size) {\n        const struct ofp_hello_elem_header *oheh;\n        unsigned int len;\n\n        if (msg.size < sizeof *oheh) {\n            return false;\n        }\n\n        oheh = msg.data;\n        len = ntohs(oheh->length);\n        if (len < sizeof *oheh || !ofpbuf_try_pull(&msg, ROUND_UP(len, 8))) {\n            return false;\n        }\n\n        if (oheh->type != htons(OFPHET_VERSIONBITMAP)\n            || !ofputil_decode_hello_bitmap(oheh, allowed_versions)) {\n            ok = false;\n        }\n    }\n\n    return ok;\n}\n\n/* Returns true if 'allowed_versions' needs to be accompanied by a version\n * bitmap to be correctly expressed in an OFPT_HELLO message. */\nstatic bool\nshould_send_version_bitmap(uint32_t allowed_versions)\n{\n    return !is_pow2((allowed_versions >> 1) + 1);\n}\n\n/* Create an OFPT_HELLO message that expresses support for the OpenFlow\n * versions in the 'allowed_versions' bitmaps and returns the message. */\nstruct ofpbuf *\nofputil_encode_hello(uint32_t allowed_versions)\n{\n    enum ofp_version ofp_version;\n    struct ofpbuf *msg;\n\n    ofp_version = leftmost_1bit_idx(allowed_versions);\n    msg = ofpraw_alloc(OFPRAW_OFPT_HELLO, ofp_version, 0);\n\n    if (should_send_version_bitmap(allowed_versions)) {\n        struct ofp_hello_elem_header *oheh;\n        uint16_t map_len;\n\n        map_len = sizeof allowed_versions;\n        oheh = ofpbuf_put_zeros(msg, ROUND_UP(map_len + sizeof *oheh, 8));\n        oheh->type = htons(OFPHET_VERSIONBITMAP);\n        oheh->length = htons(map_len + sizeof *oheh);\n        *ALIGNED_CAST(ovs_be32 *, oheh + 1) = htonl(allowed_versions);\n\n        ofpmsg_update_length(msg);\n    }\n\n    return msg;\n}\n\n/* Returns an OpenFlow message that, sent on an OpenFlow connection whose\n * protocol is 'current', at least partly transitions the protocol to 'want'.\n * Stores in '*next' the protocol that will be in effect on the OpenFlow\n * connection if the switch processes the returned message correctly.  (If\n * '*next != want' then the caller will have to iterate.)\n *\n * If 'current == want', or if it is not possible to transition from 'current'\n * to 'want' (because, for example, 'current' and 'want' use different OpenFlow\n * protocol versions), returns NULL and stores 'current' in '*next'. */\nstruct ofpbuf *\nofputil_encode_set_protocol(enum ofputil_protocol current,\n                            enum ofputil_protocol want,\n                            enum ofputil_protocol *next)\n{\n    enum ofp_version cur_version, want_version;\n    enum ofputil_protocol cur_base, want_base;\n    bool cur_tid, want_tid;\n\n    cur_version = ofputil_protocol_to_ofp_version(current);\n    want_version = ofputil_protocol_to_ofp_version(want);\n    if (cur_version != want_version) {\n        *next = current;\n        return NULL;\n    }\n\n    cur_base = ofputil_protocol_to_base(current);\n    want_base = ofputil_protocol_to_base(want);\n    if (cur_base != want_base) {\n        *next = ofputil_protocol_set_base(current, want_base);\n\n        switch (want_base) {\n        case OFPUTIL_P_OF10_NXM:\n            return ofputil_encode_nx_set_flow_format(NXFF_NXM);\n\n        case OFPUTIL_P_OF10_STD:\n            return ofputil_encode_nx_set_flow_format(NXFF_OPENFLOW10);\n\n        case OFPUTIL_P_OF11_STD:\n        case OFPUTIL_P_OF12_OXM:\n        case OFPUTIL_P_OF13_OXM:\n        case OFPUTIL_P_OF14_OXM:\n        case OFPUTIL_P_OF15_OXM:\n        case OFPUTIL_P_OF16_OXM:\n            /* There is only one variant of each OpenFlow 1.1+ protocol, and we\n             * verified above that we're not trying to change versions. */\n            OVS_NOT_REACHED();\n\n        case OFPUTIL_P_OF10_STD_TID:\n        case OFPUTIL_P_OF10_NXM_TID:\n            OVS_NOT_REACHED();\n        }\n    }\n\n    cur_tid = (current & OFPUTIL_P_TID) != 0;\n    want_tid = (want & OFPUTIL_P_TID) != 0;\n    if (cur_tid != want_tid) {\n        *next = ofputil_protocol_set_tid(current, want_tid);\n        return ofputil_make_flow_mod_table_id(want_tid);\n    }\n\n    ovs_assert(current == want);\n\n    *next = current;\n    return NULL;\n}\n\n/* Returns an NXT_SET_FLOW_FORMAT message that can be used to set the flow\n * format to 'nxff'.  */\nstruct ofpbuf *\nofputil_encode_nx_set_flow_format(enum nx_flow_format nxff)\n{\n    struct nx_set_flow_format *sff;\n    struct ofpbuf *msg;\n\n    ovs_assert(ofputil_nx_flow_format_is_valid(nxff));\n\n    msg = ofpraw_alloc(OFPRAW_NXT_SET_FLOW_FORMAT, OFP10_VERSION, 0);\n    sff = ofpbuf_put_zeros(msg, sizeof *sff);\n    sff->format = htonl(nxff);\n\n    return msg;\n}\n\n/* Returns the base protocol if 'flow_format' is a valid NXFF_* value, false\n * otherwise. */\nenum ofputil_protocol\nofputil_nx_flow_format_to_protocol(enum nx_flow_format flow_format)\n{\n    switch (flow_format) {\n    case NXFF_OPENFLOW10:\n        return OFPUTIL_P_OF10_STD;\n\n    case NXFF_NXM:\n        return OFPUTIL_P_OF10_NXM;\n\n    default:\n        return 0;\n    }\n}\n\n/* Returns true if 'flow_format' is a valid NXFF_* value, false otherwise. */\nbool\nofputil_nx_flow_format_is_valid(enum nx_flow_format flow_format)\n{\n    return ofputil_nx_flow_format_to_protocol(flow_format) != 0;\n}\n\n/* Returns a string version of 'flow_format', which must be a valid NXFF_*\n * value. */\nconst char *\nofputil_nx_flow_format_to_string(enum nx_flow_format flow_format)\n{\n    switch (flow_format) {\n    case NXFF_OPENFLOW10:\n        return \"openflow10\";\n    case NXFF_NXM:\n        return \"nxm\";\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstruct ofpbuf *\nofputil_make_set_packet_in_format(enum ofp_version ofp_version,\n                                  enum nx_packet_in_format packet_in_format)\n{\n    struct nx_set_packet_in_format *spif;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc(OFPRAW_NXT_SET_PACKET_IN_FORMAT, ofp_version, 0);\n    spif = ofpbuf_put_zeros(msg, sizeof *spif);\n    spif->format = htonl(packet_in_format);\n\n    return msg;\n}\n\n/* Returns an OpenFlow message that can be used to turn the flow_mod_table_id\n * extension on or off (according to 'flow_mod_table_id'). */\nstruct ofpbuf *\nofputil_make_flow_mod_table_id(bool flow_mod_table_id)\n{\n    struct nx_flow_mod_table_id *nfmti;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc(OFPRAW_NXT_FLOW_MOD_TABLE_ID, OFP10_VERSION, 0);\n    nfmti = ofpbuf_put_zeros(msg, sizeof *nfmti);\n    nfmti->set = flow_mod_table_id;\n    return msg;\n}\n\nstruct ofputil_flow_mod_flag {\n    uint16_t raw_flag;\n    enum ofp_version min_version, max_version;\n    enum ofputil_flow_mod_flags flag;\n};\n\nstatic const struct ofputil_flow_mod_flag ofputil_flow_mod_flags[] = {\n    { OFPFF_SEND_FLOW_REM,   OFP10_VERSION, 0, OFPUTIL_FF_SEND_FLOW_REM },\n    { OFPFF_CHECK_OVERLAP,   OFP10_VERSION, 0, OFPUTIL_FF_CHECK_OVERLAP },\n    { OFPFF10_EMERG,         OFP10_VERSION, OFP10_VERSION,\n      OFPUTIL_FF_EMERG },\n    { OFPFF12_RESET_COUNTS,  OFP12_VERSION, 0, OFPUTIL_FF_RESET_COUNTS },\n    { OFPFF13_NO_PKT_COUNTS, OFP13_VERSION, 0, OFPUTIL_FF_NO_PKT_COUNTS },\n    { OFPFF13_NO_BYT_COUNTS, OFP13_VERSION, 0, OFPUTIL_FF_NO_BYT_COUNTS },\n    { 0, 0, 0, 0 },\n};\n\nstatic enum ofperr\nofputil_decode_flow_mod_flags(ovs_be16 raw_flags_,\n                              enum ofp_flow_mod_command command,\n                              enum ofp_version version,\n                              enum ofputil_flow_mod_flags *flagsp)\n{\n    uint16_t raw_flags = ntohs(raw_flags_);\n    const struct ofputil_flow_mod_flag *f;\n\n    *flagsp = 0;\n    for (f = ofputil_flow_mod_flags; f->raw_flag; f++) {\n        if (raw_flags & f->raw_flag\n            && version >= f->min_version\n            && (!f->max_version || version <= f->max_version)) {\n            raw_flags &= ~f->raw_flag;\n            *flagsp |= f->flag;\n        }\n    }\n\n    /* In OF1.0 and OF1.1, \"add\" always resets counters, and other commands\n     * never do.\n     *\n     * In OF1.2 and later, OFPFF12_RESET_COUNTS controls whether each command\n     * resets counters. */\n    if ((version == OFP10_VERSION || version == OFP11_VERSION)\n        && command == OFPFC_ADD) {\n        *flagsp |= OFPUTIL_FF_RESET_COUNTS;\n    }\n\n    return raw_flags ? OFPERR_OFPFMFC_BAD_FLAGS : 0;\n}\n\nstatic ovs_be16\nofputil_encode_flow_mod_flags(enum ofputil_flow_mod_flags flags,\n                              enum ofp_version version)\n{\n    const struct ofputil_flow_mod_flag *f;\n    uint16_t raw_flags;\n\n    raw_flags = 0;\n    for (f = ofputil_flow_mod_flags; f->raw_flag; f++) {\n        if (f->flag & flags\n            && version >= f->min_version\n            && (!f->max_version || version <= f->max_version)) {\n            raw_flags |= f->raw_flag;\n        }\n    }\n\n    return htons(raw_flags);\n}\n\n/* Converts an OFPT_FLOW_MOD or NXT_FLOW_MOD message 'oh' into an abstract\n * flow_mod in 'fm'.  Returns 0 if successful, otherwise an OpenFlow error\n * code.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of 'oh''s actions.\n * The caller must initialize 'ofpacts' and retains ownership of it.\n * 'fm->ofpacts' will point into the 'ofpacts' buffer.\n *\n * Does not validate the flow_mod actions.  The caller should do that, with\n * ofpacts_check(). */\nenum ofperr\nofputil_decode_flow_mod(struct ofputil_flow_mod *fm,\n                        const struct ofp_header *oh,\n                        enum ofputil_protocol protocol,\n                        const struct tun_table *tun_table,\n                        const struct vl_mff_map *vl_mff_map,\n                        struct ofpbuf *ofpacts,\n                        ofp_port_t max_port, uint8_t max_table)\n{\n    ovs_be16 raw_flags;\n    enum ofperr error;\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT11_FLOW_MOD) {\n        /* Standard OpenFlow 1.1+ flow_mod. */\n        const struct ofp11_flow_mod *ofm;\n\n        ofm = ofpbuf_pull(&b, sizeof *ofm);\n\n        error = ofputil_pull_ofp11_match(&b, tun_table, vl_mff_map, &fm->match,\n                                         NULL);\n        if (error) {\n            return error;\n        }\n\n        /* Translate the message. */\n        fm->priority = ntohs(ofm->priority);\n        if (ofm->command == OFPFC_ADD\n            || (oh->version == OFP11_VERSION\n                && (ofm->command == OFPFC_MODIFY ||\n                    ofm->command == OFPFC_MODIFY_STRICT)\n                && ofm->cookie_mask == htonll(0))) {\n            /* In OpenFlow 1.1 only, a \"modify\" or \"modify-strict\" that does\n             * not match on the cookie is treated as an \"add\" if there is no\n             * match. */\n            fm->cookie = htonll(0);\n            fm->cookie_mask = htonll(0);\n            fm->new_cookie = ofm->cookie;\n        } else {\n            fm->cookie = ofm->cookie;\n            fm->cookie_mask = ofm->cookie_mask;\n            fm->new_cookie = OVS_BE64_MAX;\n        }\n        fm->modify_cookie = false;\n        fm->command = ofm->command;\n\n        /* Get table ID.\n         *\n         * OF1.1 entirely forbids table_id == OFPTT_ALL.\n         * OF1.2+ allows table_id == OFPTT_ALL only for deletes. */\n        fm->table_id = ofm->table_id;\n        if (fm->table_id == OFPTT_ALL\n            && (oh->version == OFP11_VERSION\n                || (ofm->command != OFPFC_DELETE &&\n                    ofm->command != OFPFC_DELETE_STRICT))) {\n            return OFPERR_OFPFMFC_BAD_TABLE_ID;\n        }\n\n        fm->idle_timeout = ntohs(ofm->idle_timeout);\n        fm->hard_timeout = ntohs(ofm->hard_timeout);\n        if (oh->version >= OFP14_VERSION && ofm->command == OFPFC_ADD) {\n            fm->importance = ntohs(ofm->importance);\n        } else {\n            fm->importance = 0;\n        }\n        fm->buffer_id = ntohl(ofm->buffer_id);\n        error = ofputil_port_from_ofp11(ofm->out_port, &fm->out_port);\n        if (error) {\n            return error;\n        }\n\n        fm->out_group = (ofm->command == OFPFC_DELETE ||\n                         ofm->command == OFPFC_DELETE_STRICT\n                         ? ntohl(ofm->out_group)\n                         : OFPG_ANY);\n        raw_flags = ofm->flags;\n    } else {\n        uint16_t command;\n\n        if (raw == OFPRAW_OFPT10_FLOW_MOD) {\n            /* Standard OpenFlow 1.0 flow_mod. */\n            const struct ofp10_flow_mod *ofm;\n\n            /* Get the ofp10_flow_mod. */\n            ofm = ofpbuf_pull(&b, sizeof *ofm);\n\n            /* Translate the rule. */\n            ofputil_match_from_ofp10_match(&ofm->match, &fm->match);\n            ofputil_normalize_match(&fm->match);\n\n            /* OpenFlow 1.0 says that exact-match rules have to have the\n             * highest possible priority. */\n            fm->priority = (ofm->match.wildcards & htonl(OFPFW10_ALL)\n                            ? ntohs(ofm->priority)\n                            : UINT16_MAX);\n\n            /* Translate the message. */\n            command = ntohs(ofm->command);\n            fm->cookie = htonll(0);\n            fm->cookie_mask = htonll(0);\n            fm->new_cookie = ofm->cookie;\n            fm->idle_timeout = ntohs(ofm->idle_timeout);\n            fm->hard_timeout = ntohs(ofm->hard_timeout);\n            fm->importance = 0;\n            fm->buffer_id = ntohl(ofm->buffer_id);\n            fm->out_port = u16_to_ofp(ntohs(ofm->out_port));\n            fm->out_group = OFPG_ANY;\n            raw_flags = ofm->flags;\n        } else if (raw == OFPRAW_NXT_FLOW_MOD) {\n            /* Nicira extended flow_mod. */\n            const struct nx_flow_mod *nfm;\n\n            /* Dissect the message. */\n            nfm = ofpbuf_pull(&b, sizeof *nfm);\n            error = nx_pull_match(&b, ntohs(nfm->match_len),\n                                  &fm->match, &fm->cookie, &fm->cookie_mask,\n                                  tun_table, vl_mff_map);\n            if (error) {\n                return error;\n            }\n\n            /* Translate the message. */\n            command = ntohs(nfm->command);\n            if ((command & 0xff) == OFPFC_ADD && fm->cookie_mask) {\n                /* Flow additions may only set a new cookie, not match an\n                 * existing cookie. */\n                return OFPERR_NXBRC_NXM_INVALID;\n            }\n            fm->priority = ntohs(nfm->priority);\n            fm->new_cookie = nfm->cookie;\n            fm->idle_timeout = ntohs(nfm->idle_timeout);\n            fm->hard_timeout = ntohs(nfm->hard_timeout);\n            fm->importance = 0;\n            fm->buffer_id = ntohl(nfm->buffer_id);\n            fm->out_port = u16_to_ofp(ntohs(nfm->out_port));\n            fm->out_group = OFPG_ANY;\n            raw_flags = nfm->flags;\n        } else {\n            OVS_NOT_REACHED();\n        }\n\n        fm->modify_cookie = fm->new_cookie != OVS_BE64_MAX;\n        if (protocol & OFPUTIL_P_TID) {\n            fm->command = command & 0xff;\n            fm->table_id = command >> 8;\n        } else {\n            if (command > 0xff) {\n                VLOG_WARN_RL(&bad_ofmsg_rl, \"flow_mod has explicit table_id \"\n                             \"but flow_mod_table_id extension is not enabled\");\n            }\n            fm->command = command;\n            fm->table_id = 0xff;\n        }\n    }\n\n    if (fm->command > OFPFC_DELETE_STRICT) {\n        return OFPERR_OFPFMFC_BAD_COMMAND;\n    }\n\n    fm->ofpacts_tlv_bitmap = 0;\n    error = ofpacts_pull_openflow_instructions(&b, b.size, oh->version,\n                                               vl_mff_map,\n                                               &fm->ofpacts_tlv_bitmap,\n                                               ofpacts);\n    if (error) {\n        return error;\n    }\n    fm->ofpacts = ofpacts->data;\n    fm->ofpacts_len = ofpacts->size;\n\n    error = ofputil_decode_flow_mod_flags(raw_flags, fm->command,\n                                          oh->version, &fm->flags);\n    if (error) {\n        return error;\n    }\n\n    if (fm->flags & OFPUTIL_FF_EMERG) {\n        /* We do not support the OpenFlow 1.0 emergency flow cache, which\n         * is not required in OpenFlow 1.0.1 and removed from OpenFlow 1.1.\n         *\n         * OpenFlow 1.0 specifies the error code to use when idle_timeout\n         * or hard_timeout is nonzero.  Otherwise, there is no good error\n         * code, so just state that the flow table is full. */\n        return (fm->hard_timeout || fm->idle_timeout\n                ? OFPERR_OFPFMFC_BAD_EMERG_TIMEOUT\n                : OFPERR_OFPFMFC_TABLE_FULL);\n    }\n\n    return ofpacts_check_consistency(fm->ofpacts, fm->ofpacts_len,\n                                     &fm->match.flow, max_port,\n                                     fm->table_id, max_table, protocol);\n}\n\nstatic enum ofperr\nofputil_pull_bands(struct ofpbuf *msg, size_t len, uint16_t *n_bands,\n                   struct ofpbuf *bands)\n{\n    const struct ofp13_meter_band_header *ombh;\n    struct ofputil_meter_band *mb;\n    uint16_t n = 0;\n\n    ombh = ofpbuf_try_pull(msg, len);\n    if (!ombh) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    while (len >= sizeof (struct ofp13_meter_band_drop)) {\n        size_t ombh_len = ntohs(ombh->len);\n        /* All supported band types have the same length. */\n        if (ombh_len != sizeof (struct ofp13_meter_band_drop)) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        mb = ofpbuf_put_uninit(bands, sizeof *mb);\n        mb->type = ntohs(ombh->type);\n        if (mb->type != OFPMBT13_DROP && mb->type != OFPMBT13_DSCP_REMARK) {\n            return OFPERR_OFPMMFC_BAD_BAND;\n        }\n        mb->rate = ntohl(ombh->rate);\n        mb->burst_size = ntohl(ombh->burst_size);\n        mb->prec_level = (mb->type == OFPMBT13_DSCP_REMARK) ?\n            ((struct ofp13_meter_band_dscp_remark *)ombh)->prec_level : 0;\n        n++;\n        len -= ombh_len;\n        ombh = ALIGNED_CAST(struct ofp13_meter_band_header *,\n                            (char *) ombh + ombh_len);\n    }\n    if (len) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    *n_bands = n;\n    return 0;\n}\n\nenum ofperr\nofputil_decode_meter_mod(const struct ofp_header *oh,\n                         struct ofputil_meter_mod *mm,\n                         struct ofpbuf *bands)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n    const struct ofp13_meter_mod *omm = ofpbuf_pull(&b, sizeof *omm);\n\n    /* Translate the message. */\n    mm->command = ntohs(omm->command);\n    if (mm->command != OFPMC13_ADD &&\n        mm->command != OFPMC13_MODIFY &&\n        mm->command != OFPMC13_DELETE) {\n        return OFPERR_OFPMMFC_BAD_COMMAND;\n    }\n    mm->meter.meter_id = ntohl(omm->meter_id);\n\n    if (mm->command == OFPMC13_DELETE) {\n        mm->meter.flags = 0;\n        mm->meter.n_bands = 0;\n        mm->meter.bands = NULL;\n    } else {\n        enum ofperr error;\n\n        mm->meter.flags = ntohs(omm->flags);\n        if (mm->meter.flags & OFPMF13_KBPS &&\n            mm->meter.flags & OFPMF13_PKTPS) {\n            return OFPERR_OFPMMFC_BAD_FLAGS;\n        }\n\n        error = ofputil_pull_bands(&b, b.size, &mm->meter.n_bands, bands);\n        if (error) {\n            return error;\n        }\n        mm->meter.bands = bands->data;\n    }\n    return 0;\n}\n\nvoid\nofputil_decode_meter_request(const struct ofp_header *oh, uint32_t *meter_id)\n{\n    const struct ofp13_meter_multipart_request *omr = ofpmsg_body(oh);\n    *meter_id = ntohl(omr->meter_id);\n}\n\nstruct ofpbuf *\nofputil_encode_meter_request(enum ofp_version ofp_version,\n                             enum ofputil_meter_request_type type,\n                             uint32_t meter_id)\n{\n    struct ofpbuf *msg;\n\n    enum ofpraw raw;\n\n    switch (type) {\n    case OFPUTIL_METER_CONFIG:\n        raw = OFPRAW_OFPST13_METER_CONFIG_REQUEST;\n        break;\n    case OFPUTIL_METER_STATS:\n        raw = OFPRAW_OFPST13_METER_REQUEST;\n        break;\n    default:\n    case OFPUTIL_METER_FEATURES:\n        raw = OFPRAW_OFPST13_METER_FEATURES_REQUEST;\n        break;\n    }\n\n    msg = ofpraw_alloc(raw, ofp_version, 0);\n\n    if (type != OFPUTIL_METER_FEATURES) {\n        struct ofp13_meter_multipart_request *omr;\n        omr = ofpbuf_put_zeros(msg, sizeof *omr);\n        omr->meter_id = htonl(meter_id);\n    }\n    return msg;\n}\n\nstatic void\nofputil_put_bands(uint16_t n_bands, const struct ofputil_meter_band *mb,\n                  struct ofpbuf *msg)\n{\n    uint16_t n = 0;\n\n    for (n = 0; n < n_bands; ++n) {\n        /* Currently all band types have same size. */\n        struct ofp13_meter_band_dscp_remark *ombh;\n        size_t ombh_len = sizeof *ombh;\n\n        ombh = ofpbuf_put_zeros(msg, ombh_len);\n\n        ombh->type = htons(mb->type);\n        ombh->len = htons(ombh_len);\n        ombh->rate = htonl(mb->rate);\n        ombh->burst_size = htonl(mb->burst_size);\n        ombh->prec_level = mb->prec_level;\n\n        mb++;\n    }\n}\n\n/* Encode a meter stat for 'mc' and append it to 'replies'. */\nvoid\nofputil_append_meter_config(struct ovs_list *replies,\n                            const struct ofputil_meter_config *mc)\n{\n    struct ofpbuf *msg = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = msg->size;\n    struct ofp13_meter_config *reply;\n\n    ofpbuf_put_uninit(msg, sizeof *reply);\n    ofputil_put_bands(mc->n_bands, mc->bands, msg);\n\n    reply = ofpbuf_at_assert(msg, start_ofs, sizeof *reply);\n    reply->flags = htons(mc->flags);\n    reply->meter_id = htonl(mc->meter_id);\n    reply->length = htons(msg->size - start_ofs);\n\n    ofpmp_postappend(replies, start_ofs);\n}\n\n/* Encode a meter stat for 'ms' and append it to 'replies'. */\nvoid\nofputil_append_meter_stats(struct ovs_list *replies,\n                           const struct ofputil_meter_stats *ms)\n{\n    struct ofp13_meter_stats *reply;\n    uint16_t n = 0;\n    uint16_t len;\n\n    len = sizeof *reply + ms->n_bands * sizeof(struct ofp13_meter_band_stats);\n    reply = ofpmp_append(replies, len);\n\n    reply->meter_id = htonl(ms->meter_id);\n    reply->len = htons(len);\n    memset(reply->pad, 0, sizeof reply->pad);\n    reply->flow_count = htonl(ms->flow_count);\n    reply->packet_in_count = htonll(ms->packet_in_count);\n    reply->byte_in_count = htonll(ms->byte_in_count);\n    reply->duration_sec = htonl(ms->duration_sec);\n    reply->duration_nsec = htonl(ms->duration_nsec);\n\n    for (n = 0; n < ms->n_bands; ++n) {\n        const struct ofputil_meter_band_stats *src = &ms->bands[n];\n        struct ofp13_meter_band_stats *dst = &reply->band_stats[n];\n\n        dst->packet_band_count = htonll(src->packet_count);\n        dst->byte_band_count = htonll(src->byte_count);\n    }\n}\n\n/* Converts an OFPMP_METER_CONFIG reply in 'msg' into an abstract\n * ofputil_meter_config in 'mc', with mc->bands pointing to bands decoded into\n * 'bands'.  The caller must have initialized 'bands' and retains ownership of\n * it across the call.\n *\n * Multiple OFPST13_METER_CONFIG replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  'bands' is cleared for each reply.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_meter_config(struct ofpbuf *msg,\n                            struct ofputil_meter_config *mc,\n                            struct ofpbuf *bands)\n{\n    const struct ofp13_meter_config *omc;\n    enum ofperr err;\n\n    /* Pull OpenFlow headers for the first call. */\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    omc = ofpbuf_try_pull(msg, sizeof *omc);\n    if (!omc) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"OFPMP_METER_CONFIG reply has %\"PRIu32\" leftover bytes at end\",\n                     msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    ofpbuf_clear(bands);\n    err = ofputil_pull_bands(msg, ntohs(omc->length) - sizeof *omc,\n                             &mc->n_bands, bands);\n    if (err) {\n        return err;\n    }\n    mc->meter_id = ntohl(omc->meter_id);\n    mc->flags = ntohs(omc->flags);\n    mc->bands = bands->data;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_pull_band_stats(struct ofpbuf *msg, size_t len, uint16_t *n_bands,\n                        struct ofpbuf *bands)\n{\n    const struct ofp13_meter_band_stats *ombs;\n    struct ofputil_meter_band_stats *mbs;\n    uint16_t n, i;\n\n    ombs = ofpbuf_try_pull(msg, len);\n    if (!ombs) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    n = len / sizeof *ombs;\n    if (len != n * sizeof *ombs) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    mbs = ofpbuf_put_uninit(bands, len);\n\n    for (i = 0; i < n; ++i) {\n        mbs[i].packet_count = ntohll(ombs[i].packet_band_count);\n        mbs[i].byte_count = ntohll(ombs[i].byte_band_count);\n    }\n    *n_bands = n;\n    return 0;\n}\n\n/* Converts an OFPMP_METER reply in 'msg' into an abstract\n * ofputil_meter_stats in 'ms', with ms->bands pointing to band stats\n * decoded into 'bands'.\n *\n * Multiple OFPMP_METER replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  'bands' is cleared for each reply.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_meter_stats(struct ofpbuf *msg,\n                           struct ofputil_meter_stats *ms,\n                           struct ofpbuf *bands)\n{\n    const struct ofp13_meter_stats *oms;\n    enum ofperr err;\n\n    /* Pull OpenFlow headers for the first call. */\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    oms = ofpbuf_try_pull(msg, sizeof *oms);\n    if (!oms) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"OFPMP_METER reply has %\"PRIu32\" leftover bytes at end\",\n                     msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    ofpbuf_clear(bands);\n    err = ofputil_pull_band_stats(msg, ntohs(oms->len) - sizeof *oms,\n                                  &ms->n_bands, bands);\n    if (err) {\n        return err;\n    }\n    ms->meter_id = ntohl(oms->meter_id);\n    ms->flow_count = ntohl(oms->flow_count);\n    ms->packet_in_count = ntohll(oms->packet_in_count);\n    ms->byte_in_count = ntohll(oms->byte_in_count);\n    ms->duration_sec = ntohl(oms->duration_sec);\n    ms->duration_nsec = ntohl(oms->duration_nsec);\n    ms->bands = bands->data;\n\n    return 0;\n}\n\nvoid\nofputil_decode_meter_features(const struct ofp_header *oh,\n                              struct ofputil_meter_features *mf)\n{\n    const struct ofp13_meter_features *omf = ofpmsg_body(oh);\n\n    mf->max_meters = ntohl(omf->max_meter);\n    mf->band_types = ntohl(omf->band_types);\n    mf->capabilities = ntohl(omf->capabilities);\n    mf->max_bands = omf->max_bands;\n    mf->max_color = omf->max_color;\n}\n\nstruct ofpbuf *\nofputil_encode_meter_features_reply(const struct ofputil_meter_features *mf,\n                                    const struct ofp_header *request)\n{\n    struct ofpbuf *reply;\n    struct ofp13_meter_features *omf;\n\n    reply = ofpraw_alloc_stats_reply(request, 0);\n    omf = ofpbuf_put_zeros(reply, sizeof *omf);\n\n    omf->max_meter = htonl(mf->max_meters);\n    omf->band_types = htonl(mf->band_types);\n    omf->capabilities = htonl(mf->capabilities);\n    omf->max_bands = mf->max_bands;\n    omf->max_color = mf->max_color;\n\n    return reply;\n}\n\nstruct ofpbuf *\nofputil_encode_meter_mod(enum ofp_version ofp_version,\n                         const struct ofputil_meter_mod *mm)\n{\n    struct ofpbuf *msg;\n\n    struct ofp13_meter_mod *omm;\n\n    msg = ofpraw_alloc(OFPRAW_OFPT13_METER_MOD, ofp_version,\n                       NXM_TYPICAL_LEN + mm->meter.n_bands * 16);\n    omm = ofpbuf_put_zeros(msg, sizeof *omm);\n    omm->command = htons(mm->command);\n    if (mm->command != OFPMC13_DELETE) {\n        omm->flags = htons(mm->meter.flags);\n    }\n    omm->meter_id = htonl(mm->meter.meter_id);\n\n    ofputil_put_bands(mm->meter.n_bands, mm->meter.bands, msg);\n\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic ovs_be16\nofputil_tid_command(const struct ofputil_flow_mod *fm,\n                    enum ofputil_protocol protocol)\n{\n    return htons(protocol & OFPUTIL_P_TID\n                 ? (fm->command & 0xff) | (fm->table_id << 8)\n                 : fm->command);\n}\n\n/* Converts 'fm' into an OFPT_FLOW_MOD or NXT_FLOW_MOD message according to\n * 'protocol' and returns the message. */\nstruct ofpbuf *\nofputil_encode_flow_mod(const struct ofputil_flow_mod *fm,\n                        enum ofputil_protocol protocol)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n    ovs_be16 raw_flags = ofputil_encode_flow_mod_flags(fm->flags, version);\n    struct ofpbuf *msg;\n\n    switch (protocol) {\n    case OFPUTIL_P_OF11_STD:\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM: {\n        struct ofp11_flow_mod *ofm;\n        int tailroom;\n\n        tailroom = ofputil_match_typical_len(protocol) + fm->ofpacts_len;\n        msg = ofpraw_alloc(OFPRAW_OFPT11_FLOW_MOD, version, tailroom);\n        ofm = ofpbuf_put_zeros(msg, sizeof *ofm);\n        if ((protocol == OFPUTIL_P_OF11_STD\n             && (fm->command == OFPFC_MODIFY ||\n                 fm->command == OFPFC_MODIFY_STRICT)\n             && fm->cookie_mask == htonll(0))\n            || fm->command == OFPFC_ADD) {\n            ofm->cookie = fm->new_cookie;\n        } else {\n            ofm->cookie = fm->cookie & fm->cookie_mask;\n        }\n        ofm->cookie_mask = fm->cookie_mask;\n        if (fm->table_id != OFPTT_ALL\n            || (protocol != OFPUTIL_P_OF11_STD\n                && (fm->command == OFPFC_DELETE ||\n                    fm->command == OFPFC_DELETE_STRICT))) {\n            ofm->table_id = fm->table_id;\n        } else {\n            ofm->table_id = 0;\n        }\n        ofm->command = fm->command;\n        ofm->idle_timeout = htons(fm->idle_timeout);\n        ofm->hard_timeout = htons(fm->hard_timeout);\n        ofm->priority = htons(fm->priority);\n        ofm->buffer_id = htonl(fm->buffer_id);\n        ofm->out_port = ofputil_port_to_ofp11(fm->out_port);\n        ofm->out_group = htonl(fm->out_group);\n        ofm->flags = raw_flags;\n        if (version >= OFP14_VERSION && fm->command == OFPFC_ADD) {\n            ofm->importance = htons(fm->importance);\n        } else {\n            ofm->importance = 0;\n        }\n        ofputil_put_ofp11_match(msg, &fm->match, protocol);\n        ofpacts_put_openflow_instructions(fm->ofpacts, fm->ofpacts_len, msg,\n                                          version);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID: {\n        struct ofp10_flow_mod *ofm;\n\n        msg = ofpraw_alloc(OFPRAW_OFPT10_FLOW_MOD, OFP10_VERSION,\n                           fm->ofpacts_len);\n        ofm = ofpbuf_put_zeros(msg, sizeof *ofm);\n        ofputil_match_to_ofp10_match(&fm->match, &ofm->match);\n        ofm->cookie = fm->new_cookie;\n        ofm->command = ofputil_tid_command(fm, protocol);\n        ofm->idle_timeout = htons(fm->idle_timeout);\n        ofm->hard_timeout = htons(fm->hard_timeout);\n        ofm->priority = htons(fm->priority);\n        ofm->buffer_id = htonl(fm->buffer_id);\n        ofm->out_port = htons(ofp_to_u16(fm->out_port));\n        ofm->flags = raw_flags;\n        ofpacts_put_openflow_actions(fm->ofpacts, fm->ofpacts_len, msg,\n                                     version);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID: {\n        struct nx_flow_mod *nfm;\n        int match_len;\n\n        msg = ofpraw_alloc(OFPRAW_NXT_FLOW_MOD, OFP10_VERSION,\n                           NXM_TYPICAL_LEN + fm->ofpacts_len);\n        nfm = ofpbuf_put_zeros(msg, sizeof *nfm);\n        nfm->command = ofputil_tid_command(fm, protocol);\n        nfm->cookie = fm->new_cookie;\n        match_len = nx_put_match(msg, &fm->match, fm->cookie, fm->cookie_mask);\n        nfm = msg->msg;\n        nfm->idle_timeout = htons(fm->idle_timeout);\n        nfm->hard_timeout = htons(fm->hard_timeout);\n        nfm->priority = htons(fm->priority);\n        nfm->buffer_id = htonl(fm->buffer_id);\n        nfm->out_port = htons(ofp_to_u16(fm->out_port));\n        nfm->flags = raw_flags;\n        nfm->match_len = htons(match_len);\n        ofpacts_put_openflow_actions(fm->ofpacts, fm->ofpacts_len, msg,\n                                     version);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic enum ofperr\nofputil_decode_ofpst10_flow_request(struct ofputil_flow_stats_request *fsr,\n                                    const struct ofp10_flow_stats_request *ofsr,\n                                    bool aggregate)\n{\n    fsr->aggregate = aggregate;\n    ofputil_match_from_ofp10_match(&ofsr->match, &fsr->match);\n    fsr->out_port = u16_to_ofp(ntohs(ofsr->out_port));\n    fsr->out_group = OFPG_ANY;\n    fsr->table_id = ofsr->table_id;\n    fsr->cookie = fsr->cookie_mask = htonll(0);\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_decode_ofpst11_flow_request(struct ofputil_flow_stats_request *fsr,\n                                    struct ofpbuf *b, bool aggregate,\n                                    const struct tun_table *tun_table,\n                                    const struct vl_mff_map *vl_mff_map)\n{\n    const struct ofp11_flow_stats_request *ofsr;\n    enum ofperr error;\n\n    ofsr = ofpbuf_pull(b, sizeof *ofsr);\n    fsr->aggregate = aggregate;\n    fsr->table_id = ofsr->table_id;\n    error = ofputil_port_from_ofp11(ofsr->out_port, &fsr->out_port);\n    if (error) {\n        return error;\n    }\n    fsr->out_group = ntohl(ofsr->out_group);\n    fsr->cookie = ofsr->cookie;\n    fsr->cookie_mask = ofsr->cookie_mask;\n    error = ofputil_pull_ofp11_match(b, tun_table, vl_mff_map, &fsr->match,\n                                     NULL);\n    if (error) {\n        return error;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,\n                                 struct ofpbuf *b, bool aggregate,\n                                 const struct tun_table *tun_table,\n                                 const struct vl_mff_map *vl_mff_map)\n{\n    const struct nx_flow_stats_request *nfsr;\n    enum ofperr error;\n\n    nfsr = ofpbuf_pull(b, sizeof *nfsr);\n    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,\n                          &fsr->cookie, &fsr->cookie_mask, tun_table,\n                          vl_mff_map);\n    if (error) {\n        return error;\n    }\n    if (b->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    fsr->aggregate = aggregate;\n    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));\n    fsr->out_group = OFPG_ANY;\n    fsr->table_id = nfsr->table_id;\n\n    return 0;\n}\n\n/* Constructs and returns an OFPT_QUEUE_GET_CONFIG request for the specified\n * 'port' and 'queue', suitable for OpenFlow version 'version'.\n *\n * 'queue' is honored only for OpenFlow 1.4 and later; older versions always\n * request all queues. */\nstruct ofpbuf *\nofputil_encode_queue_get_config_request(enum ofp_version version,\n                                        ofp_port_t port,\n                                        uint32_t queue)\n{\n    struct ofpbuf *request;\n\n    if (version == OFP10_VERSION) {\n        struct ofp10_queue_get_config_request *qgcr10;\n\n        request = ofpraw_alloc(OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST,\n                               version, 0);\n        qgcr10 = ofpbuf_put_zeros(request, sizeof *qgcr10);\n        qgcr10->port = htons(ofp_to_u16(port));\n    } else if (version < OFP14_VERSION) {\n        struct ofp11_queue_get_config_request *qgcr11;\n\n        request = ofpraw_alloc(OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST,\n                               version, 0);\n        qgcr11 = ofpbuf_put_zeros(request, sizeof *qgcr11);\n        qgcr11->port = ofputil_port_to_ofp11(port);\n    } else {\n        struct ofp14_queue_desc_request *qdr14;\n\n        request = ofpraw_alloc(OFPRAW_OFPST14_QUEUE_DESC_REQUEST,\n                               version, 0);\n        qdr14 = ofpbuf_put_zeros(request, sizeof *qdr14);\n        qdr14->port = ofputil_port_to_ofp11(port);\n        qdr14->queue = htonl(queue);\n    }\n\n    return request;\n}\n\n/* Parses OFPT_QUEUE_GET_CONFIG request 'oh', storing the port specified by the\n * request into '*port'.  Returns 0 if successful, otherwise an OpenFlow error\n * code. */\nenum ofperr\nofputil_decode_queue_get_config_request(const struct ofp_header *oh,\n                                        ofp_port_t *port, uint32_t *queue)\n{\n    const struct ofp10_queue_get_config_request *qgcr10;\n    const struct ofp11_queue_get_config_request *qgcr11;\n    const struct ofp14_queue_desc_request *qdr14;\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    switch ((int) raw) {\n    case OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST:\n        qgcr10 = b.data;\n        *port = u16_to_ofp(ntohs(qgcr10->port));\n        *queue = OFPQ_ALL;\n        break;\n\n    case OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST:\n        qgcr11 = b.data;\n        *queue = OFPQ_ALL;\n        enum ofperr error = ofputil_port_from_ofp11(qgcr11->port, port);\n        if (error || *port == OFPP_ANY) {\n            return error;\n        }\n        break;\n\n    case OFPRAW_OFPST14_QUEUE_DESC_REQUEST:\n        qdr14 = b.data;\n        *queue = ntohl(qdr14->queue);\n        return ofputil_port_from_ofp11(qdr14->port, port);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return (ofp_to_u16(*port) < ofp_to_u16(OFPP_MAX)\n            ? 0\n            : OFPERR_OFPQOFC_BAD_PORT);\n}\n\n/* Constructs and returns the beginning of a reply to\n * OFPT_QUEUE_GET_CONFIG_REQUEST or OFPMP_QUEUE_DESC request 'oh'.  The caller\n * may append information about individual queues with\n * ofputil_append_queue_get_config_reply(). */\nvoid\nofputil_start_queue_get_config_reply(const struct ofp_header *request,\n                                     struct ovs_list *replies)\n{\n    struct ofpbuf *reply;\n    enum ofperr error;\n    ofp_port_t port;\n    uint32_t queue;\n\n    error = ofputil_decode_queue_get_config_request(request, &port, &queue);\n    ovs_assert(!error);\n\n    enum ofpraw raw = ofpraw_decode_assert(request);\n    switch ((int) raw) {\n    case OFPRAW_OFPT10_QUEUE_GET_CONFIG_REQUEST:\n        reply = ofpraw_alloc_reply(OFPRAW_OFPT10_QUEUE_GET_CONFIG_REPLY,\n                                   request, 0);\n        struct ofp10_queue_get_config_reply *qgcr10\n            = ofpbuf_put_zeros(reply, sizeof *qgcr10);\n        qgcr10->port = htons(ofp_to_u16(port));\n        break;\n\n    case OFPRAW_OFPT11_QUEUE_GET_CONFIG_REQUEST:\n        reply = ofpraw_alloc_reply(OFPRAW_OFPT11_QUEUE_GET_CONFIG_REPLY,\n                                   request, 0);\n        struct ofp11_queue_get_config_reply *qgcr11\n            = ofpbuf_put_zeros(reply, sizeof *qgcr11);\n        qgcr11->port = ofputil_port_to_ofp11(port);\n        break;\n\n    case OFPRAW_OFPST14_QUEUE_DESC_REQUEST:\n        reply = ofpraw_alloc_stats_reply(request, 0);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ovs_list_init(replies);\n    ovs_list_push_back(replies, &reply->list_node);\n}\n\nstatic void\nput_ofp10_queue_rate(struct ofpbuf *reply,\n                     enum ofp10_queue_properties property, uint16_t rate)\n{\n    if (rate != UINT16_MAX) {\n        struct ofp10_queue_prop_rate *oqpr;\n\n        oqpr = ofpbuf_put_zeros(reply, sizeof *oqpr);\n        oqpr->prop_header.property = htons(property);\n        oqpr->prop_header.len = htons(sizeof *oqpr);\n        oqpr->rate = htons(rate);\n    }\n}\n\nstatic void\nput_ofp14_queue_rate(struct ofpbuf *reply,\n                     enum ofp14_queue_desc_prop_type type, uint16_t rate)\n{\n    if (rate != UINT16_MAX) {\n        ofpprop_put_u16(reply, type, rate);\n    }\n}\n\nvoid\nofputil_append_queue_get_config_reply(const struct ofputil_queue_config *qc,\n                                      struct ovs_list *replies)\n{\n    enum ofp_version ofp_version = ofpmp_version(replies);\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = reply->size;\n    size_t len_ofs;\n    ovs_be16 *len;\n\n    if (ofp_version < OFP14_VERSION) {\n        if (ofp_version < OFP12_VERSION) {\n            struct ofp10_packet_queue *opq10;\n\n            opq10 = ofpbuf_put_zeros(reply, sizeof *opq10);\n            opq10->queue_id = htonl(qc->queue);\n            len_ofs = (char *) &opq10->len - (char *) reply->data;\n        } else {\n            struct ofp12_packet_queue *opq12;\n\n            opq12 = ofpbuf_put_zeros(reply, sizeof *opq12);\n            opq12->port = ofputil_port_to_ofp11(qc->port);\n            opq12->queue_id = htonl(qc->queue);\n            len_ofs = (char *) &opq12->len - (char *) reply->data;\n        }\n\n        put_ofp10_queue_rate(reply, OFPQT10_MIN_RATE, qc->min_rate);\n        put_ofp10_queue_rate(reply, OFPQT11_MAX_RATE, qc->max_rate);\n    } else {\n        struct ofp14_queue_desc *oqd = ofpbuf_put_zeros(reply, sizeof *oqd);\n        oqd->port_no = ofputil_port_to_ofp11(qc->port);\n        oqd->queue_id = htonl(qc->queue);\n        len_ofs = (char *) &oqd->len - (char *) reply->data;\n        put_ofp14_queue_rate(reply, OFPQDPT14_MIN_RATE, qc->min_rate);\n        put_ofp14_queue_rate(reply, OFPQDPT14_MAX_RATE, qc->max_rate);\n    }\n\n    len = ofpbuf_at(reply, len_ofs, sizeof *len);\n    *len = htons(reply->size - start_ofs);\n\n    if (ofp_version >= OFP14_VERSION) {\n        ofpmp_postappend(replies, start_ofs);\n    }\n}\n\nstatic enum ofperr\nparse_ofp10_queue_rate(const struct ofp10_queue_prop_header *hdr,\n                       uint16_t *rate)\n{\n    const struct ofp10_queue_prop_rate *oqpr;\n\n    if (hdr->len == htons(sizeof *oqpr)) {\n        oqpr = (const struct ofp10_queue_prop_rate *) hdr;\n        *rate = ntohs(oqpr->rate);\n        return 0;\n    } else {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n}\n\nstatic int\nofputil_pull_queue_get_config_reply10(struct ofpbuf *msg,\n                                      struct ofputil_queue_config *queue)\n{\n    const struct ofp_header *oh = msg->header;\n    unsigned int opq_len;       /* Length of protocol-specific queue header. */\n    unsigned int len;           /* Total length of queue + properties. */\n\n    /* Obtain the port number from the message header. */\n    if (oh->version == OFP10_VERSION) {\n        const struct ofp10_queue_get_config_reply *oqgcr10 = msg->msg;\n        queue->port = u16_to_ofp(ntohs(oqgcr10->port));\n    } else {\n        const struct ofp11_queue_get_config_reply *oqgcr11 = msg->msg;\n        enum ofperr error = ofputil_port_from_ofp11(oqgcr11->port,\n                                                    &queue->port);\n        if (error) {\n            return error;\n        }\n    }\n\n    /* Pull off the queue header and get the queue number and length. */\n    if (oh->version < OFP12_VERSION) {\n        const struct ofp10_packet_queue *opq10;\n        opq10 = ofpbuf_try_pull(msg, sizeof *opq10);\n        if (!opq10) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        queue->queue = ntohl(opq10->queue_id);\n        len = ntohs(opq10->len);\n        opq_len = sizeof *opq10;\n    } else {\n        const struct ofp12_packet_queue *opq12;\n        opq12 = ofpbuf_try_pull(msg, sizeof *opq12);\n        if (!opq12) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        queue->queue = ntohl(opq12->queue_id);\n        len = ntohs(opq12->len);\n        opq_len = sizeof *opq12;\n    }\n\n    /* Length check. */\n    if (len < opq_len || len > msg->size + opq_len || len % 8) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= opq_len;\n\n    /* Pull properties.  The format of these properties differs from used in\n     * OF1.4+ so we can't use the common property functions. */\n    while (len > 0) {\n        const struct ofp10_queue_prop_header *hdr;\n        unsigned int property;\n        unsigned int prop_len;\n        enum ofperr error = 0;\n\n        hdr = ofpbuf_at_assert(msg, 0, sizeof *hdr);\n        prop_len = ntohs(hdr->len);\n        if (prop_len < sizeof *hdr || prop_len > len || prop_len % 8) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        property = ntohs(hdr->property);\n        switch (property) {\n        case OFPQT10_MIN_RATE:\n            error = parse_ofp10_queue_rate(hdr, &queue->min_rate);\n            break;\n\n        case OFPQT11_MAX_RATE:\n            error = parse_ofp10_queue_rate(hdr, &queue->max_rate);\n            break;\n\n        default:\n            VLOG_INFO_RL(&bad_ofmsg_rl, \"unknown queue property %u\", property);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n\n        ofpbuf_pull(msg, prop_len);\n        len -= prop_len;\n    }\n    return 0;\n}\n\nstatic int\nofputil_pull_queue_get_config_reply14(struct ofpbuf *msg,\n                                      struct ofputil_queue_config *queue)\n{\n    struct ofp14_queue_desc *oqd14 = ofpbuf_try_pull(msg, sizeof *oqd14);\n    if (!oqd14) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    enum ofperr error = ofputil_port_from_ofp11(oqd14->port_no, &queue->port);\n    if (error) {\n        return error;\n    }\n    queue->queue = ntohl(oqd14->queue_id);\n\n    /* Length check. */\n    unsigned int len = ntohs(oqd14->len);\n    if (len < sizeof *oqd14 || len > msg->size + sizeof *oqd14 || len % 8) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= sizeof *oqd14;\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPQDPT14_MIN_RATE:\n            error = ofpprop_parse_u16(&payload, &queue->min_rate);\n            break;\n\n        case OFPQDPT14_MAX_RATE:\n            error = ofpprop_parse_u16(&payload, &queue->max_rate);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(true, \"queue desc\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\n/* Decodes information about a queue from the OFPT_QUEUE_GET_CONFIG_REPLY in\n * 'reply' and stores it in '*queue'.  ofputil_decode_queue_get_config_reply()\n * must already have pulled off the main header.\n *\n * This function returns EOF if the last queue has already been decoded, 0 if a\n * queue was successfully decoded into '*queue', or an ofperr if there was a\n * problem decoding 'reply'. */\nint\nofputil_pull_queue_get_config_reply(struct ofpbuf *msg,\n                                    struct ofputil_queue_config *queue)\n{\n    enum ofpraw raw;\n    if (!msg->header) {\n        /* Pull OpenFlow header. */\n        raw = ofpraw_pull_assert(msg);\n\n        /* Pull protocol-specific ofp_queue_get_config_reply header (OF1.4\n         * doesn't have one at all). */\n        if (raw == OFPRAW_OFPT10_QUEUE_GET_CONFIG_REPLY) {\n            ofpbuf_pull(msg, sizeof(struct ofp10_queue_get_config_reply));\n        } else if (raw == OFPRAW_OFPT11_QUEUE_GET_CONFIG_REPLY) {\n            ofpbuf_pull(msg, sizeof(struct ofp11_queue_get_config_reply));\n        } else {\n            ovs_assert(raw == OFPRAW_OFPST14_QUEUE_DESC_REPLY);\n        }\n    } else {\n        raw = ofpraw_decode_assert(msg->header);\n    }\n\n    queue->min_rate = UINT16_MAX;\n    queue->max_rate = UINT16_MAX;\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_QUEUE_DESC_REPLY) {\n        return ofputil_pull_queue_get_config_reply14(msg, queue);\n    } else {\n        return ofputil_pull_queue_get_config_reply10(msg, queue);\n    }\n}\n\n/* Converts an OFPST_FLOW, OFPST_AGGREGATE, NXST_FLOW, or NXST_AGGREGATE\n * request 'oh', into an abstract flow_stats_request in 'fsr'.  Returns 0 if\n * successful, otherwise an OpenFlow error code.\n *\n * 'vl_mff_map' is an optional parameter that is used to validate the length\n * of variable length mf_fields in 'match'. If it is not provided, the\n * default mf_fields with maximum length will be used. */\nenum ofperr\nofputil_decode_flow_stats_request(struct ofputil_flow_stats_request *fsr,\n                                  const struct ofp_header *oh,\n                                  const struct tun_table *tun_table,\n                                  const struct vl_mff_map *vl_mff_map)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    switch ((int) raw) {\n    case OFPRAW_OFPST10_FLOW_REQUEST:\n        return ofputil_decode_ofpst10_flow_request(fsr, b.data, false);\n\n    case OFPRAW_OFPST10_AGGREGATE_REQUEST:\n        return ofputil_decode_ofpst10_flow_request(fsr, b.data, true);\n\n    case OFPRAW_OFPST11_FLOW_REQUEST:\n        return ofputil_decode_ofpst11_flow_request(fsr, &b, false, tun_table,\n                                                   vl_mff_map);\n\n    case OFPRAW_OFPST11_AGGREGATE_REQUEST:\n        return ofputil_decode_ofpst11_flow_request(fsr, &b, true, tun_table,\n                                                   vl_mff_map);\n\n    case OFPRAW_NXST_FLOW_REQUEST:\n        return ofputil_decode_nxst_flow_request(fsr, &b, false, tun_table,\n                                                vl_mff_map);\n\n    case OFPRAW_NXST_AGGREGATE_REQUEST:\n        return ofputil_decode_nxst_flow_request(fsr, &b, true, tun_table,\n                                                vl_mff_map);\n\n    default:\n        /* Hey, the caller lied. */\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Converts abstract flow_stats_request 'fsr' into an OFPST_FLOW,\n * OFPST_AGGREGATE, NXST_FLOW, or NXST_AGGREGATE request 'oh' according to\n * 'protocol', and returns the message. */\nstruct ofpbuf *\nofputil_encode_flow_stats_request(const struct ofputil_flow_stats_request *fsr,\n                                  enum ofputil_protocol protocol)\n{\n    struct ofpbuf *msg;\n    enum ofpraw raw;\n\n    switch (protocol) {\n    case OFPUTIL_P_OF11_STD:\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM: {\n        struct ofp11_flow_stats_request *ofsr;\n\n        raw = (fsr->aggregate\n               ? OFPRAW_OFPST11_AGGREGATE_REQUEST\n               : OFPRAW_OFPST11_FLOW_REQUEST);\n        msg = ofpraw_alloc(raw, ofputil_protocol_to_ofp_version(protocol),\n                           ofputil_match_typical_len(protocol));\n        ofsr = ofpbuf_put_zeros(msg, sizeof *ofsr);\n        ofsr->table_id = fsr->table_id;\n        ofsr->out_port = ofputil_port_to_ofp11(fsr->out_port);\n        ofsr->out_group = htonl(fsr->out_group);\n        ofsr->cookie = fsr->cookie;\n        ofsr->cookie_mask = fsr->cookie_mask;\n        ofputil_put_ofp11_match(msg, &fsr->match, protocol);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID: {\n        struct ofp10_flow_stats_request *ofsr;\n\n        raw = (fsr->aggregate\n               ? OFPRAW_OFPST10_AGGREGATE_REQUEST\n               : OFPRAW_OFPST10_FLOW_REQUEST);\n        msg = ofpraw_alloc(raw, OFP10_VERSION, 0);\n        ofsr = ofpbuf_put_zeros(msg, sizeof *ofsr);\n        ofputil_match_to_ofp10_match(&fsr->match, &ofsr->match);\n        ofsr->table_id = fsr->table_id;\n        ofsr->out_port = htons(ofp_to_u16(fsr->out_port));\n        break;\n    }\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID: {\n        struct nx_flow_stats_request *nfsr;\n        int match_len;\n\n        raw = (fsr->aggregate\n               ? OFPRAW_NXST_AGGREGATE_REQUEST\n               : OFPRAW_NXST_FLOW_REQUEST);\n        msg = ofpraw_alloc(raw, OFP10_VERSION, NXM_TYPICAL_LEN);\n        ofpbuf_put_zeros(msg, sizeof *nfsr);\n        match_len = nx_put_match(msg, &fsr->match,\n                                 fsr->cookie, fsr->cookie_mask);\n\n        nfsr = msg->msg;\n        nfsr->out_port = htons(ofp_to_u16(fsr->out_port));\n        nfsr->match_len = htons(match_len);\n        nfsr->table_id = fsr->table_id;\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return msg;\n}\n\n/* Converts an OFPST_FLOW or NXST_FLOW reply in 'msg' into an abstract\n * ofputil_flow_stats in 'fs'.\n *\n * Multiple OFPST_FLOW or NXST_FLOW replies can be packed into a single\n * OpenFlow message.  Calling this function multiple times for a single 'msg'\n * iterates through the replies.  The caller must initially leave 'msg''s layer\n * pointers null and not modify them between calls.\n *\n * Most switches don't send the values needed to populate fs->idle_age and\n * fs->hard_age, so those members will usually be set to 0.  If the switch from\n * which 'msg' originated is known to implement NXT_FLOW_AGE, then pass\n * 'flow_age_extension' as true so that the contents of 'msg' determine the\n * 'idle_age' and 'hard_age' members in 'fs'.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of the flow stats\n * reply's actions.  The caller must initialize 'ofpacts' and retains ownership\n * of it.  'fs->ofpacts' will point into the 'ofpacts' buffer.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_flow_stats_reply(struct ofputil_flow_stats *fs,\n                                struct ofpbuf *msg,\n                                bool flow_age_extension,\n                                struct ofpbuf *ofpacts)\n{\n    const struct ofp_header *oh;\n    size_t instructions_len;\n    enum ofperr error;\n    enum ofpraw raw;\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n    oh = msg->header;\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST11_FLOW_REPLY\n               || raw == OFPRAW_OFPST13_FLOW_REPLY) {\n        const struct ofp11_flow_stats *ofs;\n        size_t length;\n        uint16_t padded_match_len;\n\n        ofs = ofpbuf_try_pull(msg, sizeof *ofs);\n        if (!ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(ofs->length);\n        if (length < sizeof *ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply claims invalid \"\n                         \"length %\"PRIuSIZE, length);\n            return EINVAL;\n        }\n\n        if (ofputil_pull_ofp11_match(msg, NULL, NULL, &fs->match,\n                                     &padded_match_len)) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply bad match\");\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *ofs - padded_match_len;\n\n        fs->priority = ntohs(ofs->priority);\n        fs->table_id = ofs->table_id;\n        fs->duration_sec = ntohl(ofs->duration_sec);\n        fs->duration_nsec = ntohl(ofs->duration_nsec);\n        fs->idle_timeout = ntohs(ofs->idle_timeout);\n        fs->hard_timeout = ntohs(ofs->hard_timeout);\n        if (oh->version >= OFP14_VERSION) {\n            fs->importance = ntohs(ofs->importance);\n        } else {\n            fs->importance = 0;\n        }\n        if (raw == OFPRAW_OFPST13_FLOW_REPLY) {\n            error = ofputil_decode_flow_mod_flags(ofs->flags, -1, oh->version,\n                                                  &fs->flags);\n            if (error) {\n                return error;\n            }\n        } else {\n            fs->flags = 0;\n        }\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        fs->cookie = ofs->cookie;\n        fs->packet_count = ntohll(ofs->packet_count);\n        fs->byte_count = ntohll(ofs->byte_count);\n    } else if (raw == OFPRAW_OFPST10_FLOW_REPLY) {\n        const struct ofp10_flow_stats *ofs;\n        size_t length;\n\n        ofs = ofpbuf_try_pull(msg, sizeof *ofs);\n        if (!ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(ofs->length);\n        if (length < sizeof *ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply claims invalid \"\n                         \"length %\"PRIuSIZE, length);\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *ofs;\n\n        fs->cookie = get_32aligned_be64(&ofs->cookie);\n        ofputil_match_from_ofp10_match(&ofs->match, &fs->match);\n        fs->priority = ntohs(ofs->priority);\n        fs->table_id = ofs->table_id;\n        fs->duration_sec = ntohl(ofs->duration_sec);\n        fs->duration_nsec = ntohl(ofs->duration_nsec);\n        fs->idle_timeout = ntohs(ofs->idle_timeout);\n        fs->hard_timeout = ntohs(ofs->hard_timeout);\n        fs->importance = 0;\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        fs->packet_count = ntohll(get_32aligned_be64(&ofs->packet_count));\n        fs->byte_count = ntohll(get_32aligned_be64(&ofs->byte_count));\n        fs->flags = 0;\n    } else if (raw == OFPRAW_NXST_FLOW_REPLY) {\n        const struct nx_flow_stats *nfs;\n        size_t match_len, length;\n\n        nfs = ofpbuf_try_pull(msg, sizeof *nfs);\n        if (!nfs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(nfs->length);\n        match_len = ntohs(nfs->match_len);\n        if (length < sizeof *nfs + ROUND_UP(match_len, 8)) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW reply with match_len=%\"PRIuSIZE\" \"\n                         \"claims invalid length %\"PRIuSIZE, match_len, length);\n            return EINVAL;\n        }\n        if (nx_pull_match(msg, match_len, &fs->match, NULL, NULL, NULL,\n                          NULL)) {\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *nfs - ROUND_UP(match_len, 8);\n\n        fs->cookie = nfs->cookie;\n        fs->table_id = nfs->table_id;\n        fs->duration_sec = ntohl(nfs->duration_sec);\n        fs->duration_nsec = ntohl(nfs->duration_nsec);\n        fs->priority = ntohs(nfs->priority);\n        fs->idle_timeout = ntohs(nfs->idle_timeout);\n        fs->hard_timeout = ntohs(nfs->hard_timeout);\n        fs->importance = 0;\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        if (flow_age_extension) {\n            if (nfs->idle_age) {\n                fs->idle_age = ntohs(nfs->idle_age) - 1;\n            }\n            if (nfs->hard_age) {\n                fs->hard_age = ntohs(nfs->hard_age) - 1;\n            }\n        }\n        fs->packet_count = ntohll(nfs->packet_count);\n        fs->byte_count = ntohll(nfs->byte_count);\n        fs->flags = 0;\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (ofpacts_pull_openflow_instructions(msg, instructions_len, oh->version,\n                                           NULL, NULL, ofpacts)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply bad instructions\");\n        return EINVAL;\n    }\n    fs->ofpacts = ofpacts->data;\n    fs->ofpacts_len = ofpacts->size;\n\n    return 0;\n}\n\n/* Returns 'count' unchanged except that UINT64_MAX becomes 0.\n *\n * We use this in situations where OVS internally uses UINT64_MAX to mean\n * \"value unknown\" but OpenFlow 1.0 does not define any unknown value. */\nstatic uint64_t\nunknown_to_zero(uint64_t count)\n{\n    return count != UINT64_MAX ? count : 0;\n}\n\n/* Appends an OFPST_FLOW or NXST_FLOW reply that contains the data in 'fs' to\n * those already present in the list of ofpbufs in 'replies'.  'replies' should\n * have been initialized with ofpmp_init(). */\nvoid\nofputil_append_flow_stats_reply(const struct ofputil_flow_stats *fs,\n                                struct ovs_list *replies,\n                                const struct tun_table *tun_table)\n{\n    struct ofputil_flow_stats *fs_ = CONST_CAST(struct ofputil_flow_stats *,\n                                                fs);\n    const struct tun_table *orig_tun_table;\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = reply->size;\n    enum ofp_version version = ofpmp_version(replies);\n    enum ofpraw raw = ofpmp_decode_raw(replies);\n\n    orig_tun_table = fs->match.flow.tunnel.metadata.tab;\n    fs_->match.flow.tunnel.metadata.tab = tun_table;\n\n    if (raw == OFPRAW_OFPST11_FLOW_REPLY || raw == OFPRAW_OFPST13_FLOW_REPLY) {\n        struct ofp11_flow_stats *ofs;\n\n        ofpbuf_put_uninit(reply, sizeof *ofs);\n        oxm_put_match(reply, &fs->match, version);\n        ofpacts_put_openflow_instructions(fs->ofpacts, fs->ofpacts_len, reply,\n                                          version);\n\n        ofs = ofpbuf_at_assert(reply, start_ofs, sizeof *ofs);\n        ofs->length = htons(reply->size - start_ofs);\n        ofs->table_id = fs->table_id;\n        ofs->pad = 0;\n        ofs->duration_sec = htonl(fs->duration_sec);\n        ofs->duration_nsec = htonl(fs->duration_nsec);\n        ofs->priority = htons(fs->priority);\n        ofs->idle_timeout = htons(fs->idle_timeout);\n        ofs->hard_timeout = htons(fs->hard_timeout);\n        if (version >= OFP14_VERSION) {\n            ofs->importance = htons(fs->importance);\n        } else {\n            ofs->importance = 0;\n        }\n        if (raw == OFPRAW_OFPST13_FLOW_REPLY) {\n            ofs->flags = ofputil_encode_flow_mod_flags(fs->flags, version);\n        } else {\n            ofs->flags = 0;\n        }\n        memset(ofs->pad2, 0, sizeof ofs->pad2);\n        ofs->cookie = fs->cookie;\n        ofs->packet_count = htonll(unknown_to_zero(fs->packet_count));\n        ofs->byte_count = htonll(unknown_to_zero(fs->byte_count));\n    } else if (raw == OFPRAW_OFPST10_FLOW_REPLY) {\n        struct ofp10_flow_stats *ofs;\n\n        ofpbuf_put_uninit(reply, sizeof *ofs);\n        ofpacts_put_openflow_actions(fs->ofpacts, fs->ofpacts_len, reply,\n                                     version);\n        ofs = ofpbuf_at_assert(reply, start_ofs, sizeof *ofs);\n        ofs->length = htons(reply->size - start_ofs);\n        ofs->table_id = fs->table_id;\n        ofs->pad = 0;\n        ofputil_match_to_ofp10_match(&fs->match, &ofs->match);\n        ofs->duration_sec = htonl(fs->duration_sec);\n        ofs->duration_nsec = htonl(fs->duration_nsec);\n        ofs->priority = htons(fs->priority);\n        ofs->idle_timeout = htons(fs->idle_timeout);\n        ofs->hard_timeout = htons(fs->hard_timeout);\n        memset(ofs->pad2, 0, sizeof ofs->pad2);\n        put_32aligned_be64(&ofs->cookie, fs->cookie);\n        put_32aligned_be64(&ofs->packet_count,\n                           htonll(unknown_to_zero(fs->packet_count)));\n        put_32aligned_be64(&ofs->byte_count,\n                           htonll(unknown_to_zero(fs->byte_count)));\n    } else if (raw == OFPRAW_NXST_FLOW_REPLY) {\n        struct nx_flow_stats *nfs;\n        int match_len;\n\n        ofpbuf_put_uninit(reply, sizeof *nfs);\n        match_len = nx_put_match(reply, &fs->match, 0, 0);\n        ofpacts_put_openflow_actions(fs->ofpacts, fs->ofpacts_len, reply,\n                                     version);\n        nfs = ofpbuf_at_assert(reply, start_ofs, sizeof *nfs);\n        nfs->length = htons(reply->size - start_ofs);\n        nfs->table_id = fs->table_id;\n        nfs->pad = 0;\n        nfs->duration_sec = htonl(fs->duration_sec);\n        nfs->duration_nsec = htonl(fs->duration_nsec);\n        nfs->priority = htons(fs->priority);\n        nfs->idle_timeout = htons(fs->idle_timeout);\n        nfs->hard_timeout = htons(fs->hard_timeout);\n        nfs->idle_age = htons(fs->idle_age < 0 ? 0\n                              : fs->idle_age < UINT16_MAX ? fs->idle_age + 1\n                              : UINT16_MAX);\n        nfs->hard_age = htons(fs->hard_age < 0 ? 0\n                              : fs->hard_age < UINT16_MAX ? fs->hard_age + 1\n                              : UINT16_MAX);\n        nfs->match_len = htons(match_len);\n        nfs->cookie = fs->cookie;\n        nfs->packet_count = htonll(fs->packet_count);\n        nfs->byte_count = htonll(fs->byte_count);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    ofpmp_postappend(replies, start_ofs);\n    fs_->match.flow.tunnel.metadata.tab = orig_tun_table;\n}\n\n/* Converts abstract ofputil_aggregate_stats 'stats' into an OFPST_AGGREGATE or\n * NXST_AGGREGATE reply matching 'request', and returns the message. */\nstruct ofpbuf *\nofputil_encode_aggregate_stats_reply(\n    const struct ofputil_aggregate_stats *stats,\n    const struct ofp_header *request)\n{\n    struct ofp_aggregate_stats_reply *asr;\n    uint64_t packet_count;\n    uint64_t byte_count;\n    struct ofpbuf *msg;\n    enum ofpraw raw;\n\n    ofpraw_decode(&raw, request);\n    if (raw == OFPRAW_OFPST10_AGGREGATE_REQUEST) {\n        packet_count = unknown_to_zero(stats->packet_count);\n        byte_count = unknown_to_zero(stats->byte_count);\n    } else {\n        packet_count = stats->packet_count;\n        byte_count = stats->byte_count;\n    }\n\n    msg = ofpraw_alloc_stats_reply(request, 0);\n    asr = ofpbuf_put_zeros(msg, sizeof *asr);\n    put_32aligned_be64(&asr->packet_count, htonll(packet_count));\n    put_32aligned_be64(&asr->byte_count, htonll(byte_count));\n    asr->flow_count = htonl(stats->flow_count);\n\n    return msg;\n}\n\nenum ofperr\nofputil_decode_aggregate_stats_reply(struct ofputil_aggregate_stats *stats,\n                                     const struct ofp_header *reply)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(reply, ntohs(reply->length));\n    ofpraw_pull_assert(&msg);\n\n    struct ofp_aggregate_stats_reply *asr = msg.msg;\n    stats->packet_count = ntohll(get_32aligned_be64(&asr->packet_count));\n    stats->byte_count = ntohll(get_32aligned_be64(&asr->byte_count));\n    stats->flow_count = ntohl(asr->flow_count);\n\n    return 0;\n}\n\n/* Converts an OFPT_FLOW_REMOVED or NXT_FLOW_REMOVED message 'oh' into an\n * abstract ofputil_flow_removed in 'fr'.  Returns 0 if successful, otherwise\n * an OpenFlow error code. */\nenum ofperr\nofputil_decode_flow_removed(struct ofputil_flow_removed *fr,\n                            const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT11_FLOW_REMOVED) {\n        const struct ofp12_flow_removed *ofr;\n        enum ofperr error;\n\n        ofr = ofpbuf_pull(&b, sizeof *ofr);\n\n        error = ofputil_pull_ofp11_match(&b, NULL, NULL, &fr->match, NULL);\n        if (error) {\n            return error;\n        }\n\n        fr->priority = ntohs(ofr->priority);\n        fr->cookie = ofr->cookie;\n        fr->reason = ofr->reason;\n        fr->table_id = ofr->table_id;\n        fr->duration_sec = ntohl(ofr->duration_sec);\n        fr->duration_nsec = ntohl(ofr->duration_nsec);\n        fr->idle_timeout = ntohs(ofr->idle_timeout);\n        fr->hard_timeout = ntohs(ofr->hard_timeout);\n        fr->packet_count = ntohll(ofr->packet_count);\n        fr->byte_count = ntohll(ofr->byte_count);\n    } else if (raw == OFPRAW_OFPT10_FLOW_REMOVED) {\n        const struct ofp10_flow_removed *ofr;\n\n        ofr = ofpbuf_pull(&b, sizeof *ofr);\n\n        ofputil_match_from_ofp10_match(&ofr->match, &fr->match);\n        fr->priority = ntohs(ofr->priority);\n        fr->cookie = ofr->cookie;\n        fr->reason = ofr->reason;\n        fr->table_id = 255;\n        fr->duration_sec = ntohl(ofr->duration_sec);\n        fr->duration_nsec = ntohl(ofr->duration_nsec);\n        fr->idle_timeout = ntohs(ofr->idle_timeout);\n        fr->hard_timeout = 0;\n        fr->packet_count = ntohll(ofr->packet_count);\n        fr->byte_count = ntohll(ofr->byte_count);\n    } else if (raw == OFPRAW_NXT_FLOW_REMOVED) {\n        struct nx_flow_removed *nfr;\n        enum ofperr error;\n\n        nfr = ofpbuf_pull(&b, sizeof *nfr);\n        error = nx_pull_match(&b, ntohs(nfr->match_len), &fr->match, NULL,\n                              NULL, NULL, NULL);\n        if (error) {\n            return error;\n        }\n        if (b.size) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        fr->priority = ntohs(nfr->priority);\n        fr->cookie = nfr->cookie;\n        fr->reason = nfr->reason;\n        fr->table_id = nfr->table_id ? nfr->table_id - 1 : 255;\n        fr->duration_sec = ntohl(nfr->duration_sec);\n        fr->duration_nsec = ntohl(nfr->duration_nsec);\n        fr->idle_timeout = ntohs(nfr->idle_timeout);\n        fr->hard_timeout = 0;\n        fr->packet_count = ntohll(nfr->packet_count);\n        fr->byte_count = ntohll(nfr->byte_count);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    return 0;\n}\n\n/* Converts abstract ofputil_flow_removed 'fr' into an OFPT_FLOW_REMOVED or\n * NXT_FLOW_REMOVED message 'oh' according to 'protocol', and returns the\n * message. */\nstruct ofpbuf *\nofputil_encode_flow_removed(const struct ofputil_flow_removed *fr,\n                            enum ofputil_protocol protocol)\n{\n    struct ofpbuf *msg;\n    enum ofp_flow_removed_reason reason = fr->reason;\n\n    if (reason == OFPRR_METER_DELETE && !(protocol & OFPUTIL_P_OF14_UP)) {\n        reason = OFPRR_DELETE;\n    }\n\n    switch (protocol) {\n    case OFPUTIL_P_OF11_STD:\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM: {\n        struct ofp12_flow_removed *ofr;\n\n        msg = ofpraw_alloc_xid(OFPRAW_OFPT11_FLOW_REMOVED,\n                               ofputil_protocol_to_ofp_version(protocol),\n                               htonl(0),\n                               ofputil_match_typical_len(protocol));\n        ofr = ofpbuf_put_zeros(msg, sizeof *ofr);\n        ofr->cookie = fr->cookie;\n        ofr->priority = htons(fr->priority);\n        ofr->reason = reason;\n        ofr->table_id = fr->table_id;\n        ofr->duration_sec = htonl(fr->duration_sec);\n        ofr->duration_nsec = htonl(fr->duration_nsec);\n        ofr->idle_timeout = htons(fr->idle_timeout);\n        ofr->hard_timeout = htons(fr->hard_timeout);\n        ofr->packet_count = htonll(fr->packet_count);\n        ofr->byte_count = htonll(fr->byte_count);\n        ofputil_put_ofp11_match(msg, &fr->match, protocol);\n        break;\n    }\n\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID: {\n        struct ofp10_flow_removed *ofr;\n\n        msg = ofpraw_alloc_xid(OFPRAW_OFPT10_FLOW_REMOVED, OFP10_VERSION,\n                               htonl(0), 0);\n        ofr = ofpbuf_put_zeros(msg, sizeof *ofr);\n        ofputil_match_to_ofp10_match(&fr->match, &ofr->match);\n        ofr->cookie = fr->cookie;\n        ofr->priority = htons(fr->priority);\n        ofr->reason = reason;\n        ofr->duration_sec = htonl(fr->duration_sec);\n        ofr->duration_nsec = htonl(fr->duration_nsec);\n        ofr->idle_timeout = htons(fr->idle_timeout);\n        ofr->packet_count = htonll(unknown_to_zero(fr->packet_count));\n        ofr->byte_count = htonll(unknown_to_zero(fr->byte_count));\n        break;\n    }\n\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID: {\n        struct nx_flow_removed *nfr;\n        int match_len;\n\n        msg = ofpraw_alloc_xid(OFPRAW_NXT_FLOW_REMOVED, OFP10_VERSION,\n                               htonl(0), NXM_TYPICAL_LEN);\n        ofpbuf_put_zeros(msg, sizeof *nfr);\n        match_len = nx_put_match(msg, &fr->match, 0, 0);\n\n        nfr = msg->msg;\n        nfr->cookie = fr->cookie;\n        nfr->priority = htons(fr->priority);\n        nfr->reason = reason;\n        nfr->table_id = fr->table_id + 1;\n        nfr->duration_sec = htonl(fr->duration_sec);\n        nfr->duration_nsec = htonl(fr->duration_nsec);\n        nfr->idle_timeout = htons(fr->idle_timeout);\n        nfr->match_len = htons(match_len);\n        nfr->packet_count = htonll(fr->packet_count);\n        nfr->byte_count = htonll(fr->byte_count);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return msg;\n}\n\n/* The caller has done basic initialization of '*pin'; the other output\n * arguments needs to be initialized. */\nstatic enum ofperr\ndecode_nx_packet_in2(const struct ofp_header *oh, bool loose,\n                     const struct tun_table *tun_table,\n                     const struct vl_mff_map *vl_mff_map,\n                     struct ofputil_packet_in *pin,\n                     size_t *total_len, uint32_t *buffer_id,\n                     struct ofpbuf *continuation)\n{\n    *total_len = 0;\n    *buffer_id = UINT32_MAX;\n\n    struct ofpbuf properties;\n    ofpbuf_use_const(&properties, oh, ntohs(oh->length));\n    ofpraw_pull_assert(&properties);\n\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        enum ofperr error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case NXPINT_PACKET:\n            pin->packet = payload.msg;\n            pin->packet_len = ofpbuf_msgsize(&payload);\n            break;\n\n        case NXPINT_FULL_LEN: {\n            uint32_t u32;\n            error = ofpprop_parse_u32(&payload, &u32);\n            *total_len = u32;\n            break;\n        }\n\n        case NXPINT_BUFFER_ID:\n            error = ofpprop_parse_u32(&payload, buffer_id);\n            break;\n\n        case NXPINT_TABLE_ID:\n            error = ofpprop_parse_u8(&payload, &pin->table_id);\n            break;\n\n        case NXPINT_COOKIE:\n            error = ofpprop_parse_be64(&payload, &pin->cookie);\n            break;\n\n        case NXPINT_REASON: {\n            uint8_t reason;\n            error = ofpprop_parse_u8(&payload, &reason);\n            pin->reason = reason;\n            break;\n        }\n\n        case NXPINT_METADATA:\n            error = oxm_decode_match(payload.msg, ofpbuf_msgsize(&payload),\n                                     loose, tun_table, vl_mff_map,\n                                     &pin->flow_metadata);\n            break;\n\n        case NXPINT_USERDATA:\n            pin->userdata = payload.msg;\n            pin->userdata_len = ofpbuf_msgsize(&payload);\n            break;\n\n        case NXPINT_CONTINUATION:\n            if (continuation) {\n                error = ofpprop_parse_nested(&payload, continuation);\n            }\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(loose, \"NX_PACKET_IN2\", type);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n    }\n\n    if (!pin->packet_len) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXT_PACKET_IN2 lacks packet\");\n        return OFPERR_OFPBRC_BAD_LEN;\n    } else if (!*total_len) {\n        *total_len = pin->packet_len;\n    } else if (*total_len < pin->packet_len) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXT_PACKET_IN2 claimed full_len < len\");\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    return 0;\n}\n\n/* Decodes the packet-in message starting at 'oh' into '*pin'.  Populates\n * 'pin->packet' and 'pin->packet_len' with the part of the packet actually\n * included in the message.  If 'total_lenp' is nonnull, populates\n * '*total_lenp' with the original length of the packet (which is larger than\n * 'packet->len' if only part of the packet was included).  If 'buffer_idp' is\n * nonnull, stores the packet's buffer ID in '*buffer_idp' (UINT32_MAX if it\n * was not buffered).\n *\n * Populates 'continuation', if nonnull, with the continuation data from the\n * packet-in (an empty buffer, if 'oh' did not contain continuation data).  The\n * format of this data is supposed to be opaque to anything other than\n * ovs-vswitchd, so that in any other process the only reasonable use of this\n * data is to be copied into an NXT_RESUME message via ofputil_encode_resume().\n *\n * This function points 'pin->packet' into 'oh', so the caller should not free\n * it separately from the original OpenFlow message.  This is also true for\n * 'pin->userdata' (which could also end up NULL if there is no userdata).\n *\n * 'vl_mff_map' is an optional parameter that is used to validate the length\n * of variable length mf_fields in 'match'. If it is not provided, the\n * default mf_fields with maximum length will be used.\n *\n * Returns 0 if successful, otherwise an OpenFlow error code. */\nenum ofperr\nofputil_decode_packet_in(const struct ofp_header *oh, bool loose,\n                         const struct tun_table *tun_table,\n                         const struct vl_mff_map *vl_mff_map,\n                         struct ofputil_packet_in *pin,\n                         size_t *total_lenp, uint32_t *buffer_idp,\n                         struct ofpbuf *continuation)\n{\n    uint32_t buffer_id;\n    size_t total_len;\n\n    memset(pin, 0, sizeof *pin);\n    pin->cookie = OVS_BE64_MAX;\n    if (continuation) {\n        ofpbuf_use_const(continuation, NULL, 0);\n    }\n\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT13_PACKET_IN || raw == OFPRAW_OFPT12_PACKET_IN) {\n        const struct ofp12_packet_in *opi = ofpbuf_pull(&b, sizeof *opi);\n        const ovs_be64 *cookie = (raw == OFPRAW_OFPT13_PACKET_IN\n                                  ? ofpbuf_pull(&b, sizeof *cookie)\n                                  : NULL);\n        enum ofperr error = oxm_pull_match_loose(&b, tun_table,\n                                                 &pin->flow_metadata);\n        if (error) {\n            return error;\n        }\n\n        if (!ofpbuf_try_pull(&b, 2)) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        pin->reason = opi->reason;\n        pin->table_id = opi->table_id;\n        buffer_id = ntohl(opi->buffer_id);\n        total_len = ntohs(opi->total_len);\n        if (cookie) {\n            pin->cookie = *cookie;\n        }\n\n        pin->packet = b.data;\n        pin->packet_len = b.size;\n    } else if (raw == OFPRAW_OFPT10_PACKET_IN) {\n        const struct ofp10_packet_in *opi;\n\n        opi = ofpbuf_pull(&b, offsetof(struct ofp10_packet_in, data));\n\n        pin->packet = CONST_CAST(uint8_t *, opi->data);\n        pin->packet_len = b.size;\n\n        match_init_catchall(&pin->flow_metadata);\n        match_set_in_port(&pin->flow_metadata,\n                          u16_to_ofp(ntohs(opi->in_port)));\n        pin->reason = opi->reason;\n        buffer_id = ntohl(opi->buffer_id);\n        total_len = ntohs(opi->total_len);\n    } else if (raw == OFPRAW_OFPT11_PACKET_IN) {\n        const struct ofp11_packet_in *opi;\n        ofp_port_t in_port;\n        enum ofperr error;\n\n        opi = ofpbuf_pull(&b, sizeof *opi);\n\n        pin->packet = b.data;\n        pin->packet_len = b.size;\n\n        buffer_id = ntohl(opi->buffer_id);\n        error = ofputil_port_from_ofp11(opi->in_port, &in_port);\n        if (error) {\n            return error;\n        }\n        match_init_catchall(&pin->flow_metadata);\n        match_set_in_port(&pin->flow_metadata, in_port);\n        total_len = ntohs(opi->total_len);\n        pin->reason = opi->reason;\n        pin->table_id = opi->table_id;\n    } else if (raw == OFPRAW_NXT_PACKET_IN) {\n        const struct nx_packet_in *npi;\n        int error;\n\n        npi = ofpbuf_pull(&b, sizeof *npi);\n        error = nx_pull_match_loose(&b, ntohs(npi->match_len),\n                                    &pin->flow_metadata, NULL, NULL, NULL);\n        if (error) {\n            return error;\n        }\n\n        if (!ofpbuf_try_pull(&b, 2)) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        pin->reason = npi->reason;\n        pin->table_id = npi->table_id;\n        pin->cookie = npi->cookie;\n\n        buffer_id = ntohl(npi->buffer_id);\n        total_len = ntohs(npi->total_len);\n\n        pin->packet = b.data;\n        pin->packet_len = b.size;\n    } else if (raw == OFPRAW_NXT_PACKET_IN2 || raw == OFPRAW_NXT_RESUME) {\n        enum ofperr error = decode_nx_packet_in2(oh, loose, tun_table,\n                                                 vl_mff_map, pin, &total_len,\n                                                 &buffer_id, continuation);\n        if (error) {\n            return error;\n        }\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (total_lenp) {\n        *total_lenp = total_len;\n    }\n    if (buffer_idp) {\n        *buffer_idp = buffer_id;\n    }\n\n    return 0;\n}\n\nstatic int\nencode_packet_in_reason(enum ofp_packet_in_reason reason,\n                        enum ofp_version version)\n{\n    switch (reason) {\n    case OFPR_NO_MATCH:\n    case OFPR_ACTION:\n    case OFPR_INVALID_TTL:\n        return reason;\n\n    case OFPR_ACTION_SET:\n    case OFPR_GROUP:\n    case OFPR_PACKET_OUT:\n        return version < OFP14_VERSION ? OFPR_ACTION : reason;\n\n    case OFPR_EXPLICIT_MISS:\n        return version < OFP13_VERSION ? OFPR_ACTION : OFPR_NO_MATCH;\n\n    case OFPR_IMPLICIT_MISS:\n        return OFPR_NO_MATCH;\n\n    case OFPR_N_REASONS:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Only NXT_PACKET_IN2 (not NXT_RESUME) should include NXCPT_USERDATA, so this\n * function omits it.  The caller can add it itself if desired. */\nstatic void\nofputil_put_packet_in(const struct ofputil_packet_in *pin,\n                      enum ofp_version version, size_t include_bytes,\n                      struct ofpbuf *msg)\n{\n    /* Add packet properties. */\n    ofpprop_put(msg, NXPINT_PACKET, pin->packet, include_bytes);\n    if (include_bytes != pin->packet_len) {\n        ofpprop_put_u32(msg, NXPINT_FULL_LEN, pin->packet_len);\n    }\n\n    /* Add flow properties. */\n    ofpprop_put_u8(msg, NXPINT_TABLE_ID, pin->table_id);\n    if (pin->cookie != OVS_BE64_MAX) {\n        ofpprop_put_be64(msg, NXPINT_COOKIE, pin->cookie);\n    }\n\n    /* Add other properties. */\n    ofpprop_put_u8(msg, NXPINT_REASON,\n                   encode_packet_in_reason(pin->reason, version));\n\n    size_t start = ofpprop_start(msg, NXPINT_METADATA);\n    oxm_put_raw(msg, &pin->flow_metadata, version);\n    ofpprop_end(msg, start);\n}\n\nstatic void\nput_actions_property(struct ofpbuf *msg, uint64_t prop_type,\n                     enum ofp_version version,\n                     const struct ofpact *actions, size_t actions_len)\n{\n    if (actions_len) {\n        size_t start = ofpprop_start_nested(msg, prop_type);\n        ofpacts_put_openflow_actions(actions, actions_len, msg, version);\n        ofpprop_end(msg, start);\n    }\n}\n\nenum nx_continuation_prop_type {\n    NXCPT_BRIDGE = 0x8000,\n    NXCPT_STACK,\n    NXCPT_MIRRORS,\n    NXCPT_CONNTRACKED,\n    NXCPT_TABLE_ID,\n    NXCPT_COOKIE,\n    NXCPT_ACTIONS,\n    NXCPT_ACTION_SET,\n};\n\n/* Only NXT_PACKET_IN2 (not NXT_RESUME) should include NXCPT_USERDATA, so this\n * function omits it.  The caller can add it itself if desired. */\nstatic void\nofputil_put_packet_in_private(const struct ofputil_packet_in_private *pin,\n                              enum ofp_version version, size_t include_bytes,\n                              struct ofpbuf *msg)\n{\n    ofputil_put_packet_in(&pin->public, version, include_bytes, msg);\n\n    size_t continuation_ofs = ofpprop_start_nested(msg, NXPINT_CONTINUATION);\n    size_t inner_ofs = msg->size;\n\n    if (!uuid_is_zero(&pin->bridge)) {\n        ofpprop_put_uuid(msg, NXCPT_BRIDGE, &pin->bridge);\n    }\n\n    struct ofpbuf pin_stack;\n    ofpbuf_use_const(&pin_stack, pin->stack, pin->stack_size);\n\n    while (pin_stack.size) {\n        uint8_t len;\n        uint8_t *val = nx_stack_pop(&pin_stack, &len);\n        ofpprop_put(msg, NXCPT_STACK, val, len);\n    }\n\n    if (pin->mirrors) {\n        ofpprop_put_u32(msg, NXCPT_MIRRORS, pin->mirrors);\n    }\n\n    if (pin->conntracked) {\n        ofpprop_put_flag(msg, NXCPT_CONNTRACKED);\n    }\n\n    if (pin->actions_len) {\n        /* Divide 'pin->actions' into groups that begins with an\n         * unroll_xlate action.  For each group, emit a NXCPT_TABLE_ID and\n         * NXCPT_COOKIE property (if either has changed; each is initially\n         * assumed 0), then a NXCPT_ACTIONS property with the grouped\n         * actions.\n         *\n         * The alternative is to make OFPACT_UNROLL_XLATE public.  We can\n         * always do that later, since this is a private property. */\n        const struct ofpact *const end = ofpact_end(pin->actions,\n                                                    pin->actions_len);\n        const struct ofpact_unroll_xlate *unroll = NULL;\n        uint8_t table_id = 0;\n        ovs_be64 cookie = 0;\n\n        const struct ofpact *a;\n        for (a = pin->actions; ; a = ofpact_next(a)) {\n            if (a == end || a->type == OFPACT_UNROLL_XLATE) {\n                if (unroll) {\n                    if (table_id != unroll->rule_table_id) {\n                        ofpprop_put_u8(msg, NXCPT_TABLE_ID,\n                                       unroll->rule_table_id);\n                        table_id = unroll->rule_table_id;\n                    }\n                    if (cookie != unroll->rule_cookie) {\n                        ofpprop_put_be64(msg, NXCPT_COOKIE,\n                                         unroll->rule_cookie);\n                        cookie = unroll->rule_cookie;\n                    }\n                }\n\n                const struct ofpact *start\n                    = unroll ? ofpact_next(&unroll->ofpact) : pin->actions;\n                put_actions_property(msg, NXCPT_ACTIONS, version,\n                                     start, (a - start) * sizeof *a);\n\n                if (a == end) {\n                    break;\n                }\n                unroll = ofpact_get_UNROLL_XLATE(a);\n            }\n        }\n    }\n\n    if (pin->action_set_len) {\n        size_t start = ofpprop_start_nested(msg, NXCPT_ACTION_SET);\n        ofpacts_put_openflow_actions(pin->action_set,\n                                     pin->action_set_len, msg, version);\n        ofpprop_end(msg, start);\n    }\n\n    if (msg->size > inner_ofs) {\n        ofpprop_end(msg, continuation_ofs);\n    } else {\n        msg->size = continuation_ofs;\n    }\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp10_packet_in(const struct ofputil_packet_in *pin)\n{\n    struct ofp10_packet_in *opi;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc_xid(OFPRAW_OFPT10_PACKET_IN, OFP10_VERSION,\n                           htonl(0), pin->packet_len);\n    opi = ofpbuf_put_zeros(msg, offsetof(struct ofp10_packet_in, data));\n    opi->total_len = htons(pin->packet_len);\n    opi->in_port = htons(ofp_to_u16(pin->flow_metadata.flow.in_port.ofp_port));\n    opi->reason = encode_packet_in_reason(pin->reason, OFP10_VERSION);\n    opi->buffer_id = htonl(UINT32_MAX);\n\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_nx_packet_in(const struct ofputil_packet_in *pin,\n                            enum ofp_version version)\n{\n    struct nx_packet_in *npi;\n    struct ofpbuf *msg;\n    size_t match_len;\n\n    /* The final argument is just an estimate of the space required. */\n    msg = ofpraw_alloc_xid(OFPRAW_NXT_PACKET_IN, version,\n                           htonl(0), NXM_TYPICAL_LEN + 2 + pin->packet_len);\n    ofpbuf_put_zeros(msg, sizeof *npi);\n    match_len = nx_put_match(msg, &pin->flow_metadata, 0, 0);\n    ofpbuf_put_zeros(msg, 2);\n\n    npi = msg->msg;\n    npi->buffer_id = htonl(UINT32_MAX);\n    npi->total_len = htons(pin->packet_len);\n    npi->reason = encode_packet_in_reason(pin->reason, version);\n    npi->table_id = pin->table_id;\n    npi->cookie = pin->cookie;\n    npi->match_len = htons(match_len);\n\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_nx_packet_in2(const struct ofputil_packet_in_private *pin,\n                             enum ofp_version version, size_t include_bytes)\n{\n    /* 'extra' is just an estimate of the space required. */\n    size_t extra = (pin->public.packet_len\n                    + NXM_TYPICAL_LEN   /* flow_metadata */\n                    + pin->stack_size * 4\n                    + pin->actions_len\n                    + pin->action_set_len\n                    + 256);     /* fudge factor */\n    struct ofpbuf *msg = ofpraw_alloc_xid(OFPRAW_NXT_PACKET_IN2, version,\n                                          htonl(0), extra);\n\n    ofputil_put_packet_in_private(pin, version, include_bytes, msg);\n    if (pin->public.userdata_len) {\n        ofpprop_put(msg, NXPINT_USERDATA, pin->public.userdata,\n                    pin->public.userdata_len);\n    }\n\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp11_packet_in(const struct ofputil_packet_in *pin)\n{\n    struct ofp11_packet_in *opi;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc_xid(OFPRAW_OFPT11_PACKET_IN, OFP11_VERSION,\n                           htonl(0), pin->packet_len);\n    opi = ofpbuf_put_zeros(msg, sizeof *opi);\n    opi->buffer_id = htonl(UINT32_MAX);\n    opi->in_port = ofputil_port_to_ofp11(\n        pin->flow_metadata.flow.in_port.ofp_port);\n    opi->in_phy_port = opi->in_port;\n    opi->total_len = htons(pin->packet_len);\n    opi->reason = encode_packet_in_reason(pin->reason, OFP11_VERSION);\n    opi->table_id = pin->table_id;\n\n    return msg;\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp12_packet_in(const struct ofputil_packet_in *pin,\n                               enum ofp_version version)\n{\n    enum ofpraw raw = (version >= OFP13_VERSION\n                       ? OFPRAW_OFPT13_PACKET_IN\n                       : OFPRAW_OFPT12_PACKET_IN);\n    struct ofpbuf *msg;\n\n    /* The final argument is just an estimate of the space required. */\n    msg = ofpraw_alloc_xid(raw, version,\n                           htonl(0), NXM_TYPICAL_LEN + 2 + pin->packet_len);\n\n    struct ofp12_packet_in *opi = ofpbuf_put_zeros(msg, sizeof *opi);\n    opi->buffer_id = htonl(UINT32_MAX);\n    opi->total_len = htons(pin->packet_len);\n    opi->reason = encode_packet_in_reason(pin->reason, version);\n    opi->table_id = pin->table_id;\n\n    if (version >= OFP13_VERSION) {\n        ovs_be64 cookie = pin->cookie;\n        ofpbuf_put(msg, &cookie, sizeof cookie);\n    }\n\n    oxm_put_match(msg, &pin->flow_metadata, version);\n    ofpbuf_put_zeros(msg, 2);\n\n    return msg;\n}\n\n/* Converts abstract ofputil_packet_in_private 'pin' into a PACKET_IN message\n * for 'protocol', using the packet-in format specified by 'packet_in_format'.\n *\n * This function is really meant only for use by ovs-vswitchd.  To any other\n * code, the \"continuation\" data, i.e. the data that is in struct\n * ofputil_packet_in_private but not in struct ofputil_packet_in, is supposed\n * to be opaque (and it might change from one OVS version to another).  Thus,\n * if any other code wants to encode a packet-in, it should use a non-\"private\"\n * version of this function.  (Such a version doesn't currently exist because\n * only ovs-vswitchd currently wants to encode packet-ins.  If you need one,\n * write it...) */\nstruct ofpbuf *\nofputil_encode_packet_in_private(const struct ofputil_packet_in_private *pin,\n                                 enum ofputil_protocol protocol,\n                                 enum nx_packet_in_format packet_in_format)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n\n    struct ofpbuf *msg;\n    switch (packet_in_format) {\n    case NXPIF_STANDARD:\n        switch (protocol) {\n        case OFPUTIL_P_OF10_STD:\n        case OFPUTIL_P_OF10_STD_TID:\n        case OFPUTIL_P_OF10_NXM:\n        case OFPUTIL_P_OF10_NXM_TID:\n            msg = ofputil_encode_ofp10_packet_in(&pin->public);\n            break;\n\n        case OFPUTIL_P_OF11_STD:\n            msg = ofputil_encode_ofp11_packet_in(&pin->public);\n            break;\n\n        case OFPUTIL_P_OF12_OXM:\n        case OFPUTIL_P_OF13_OXM:\n        case OFPUTIL_P_OF14_OXM:\n        case OFPUTIL_P_OF15_OXM:\n        case OFPUTIL_P_OF16_OXM:\n            msg = ofputil_encode_ofp12_packet_in(&pin->public, version);\n            break;\n\n        default:\n            OVS_NOT_REACHED();\n        }\n        break;\n\n    case NXPIF_NXT_PACKET_IN:\n        msg = ofputil_encode_nx_packet_in(&pin->public, version);\n        break;\n\n    case NXPIF_NXT_PACKET_IN2:\n        return ofputil_encode_nx_packet_in2(pin, version,\n                                            pin->public.packet_len);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ofpbuf_put(msg, pin->public.packet, pin->public.packet_len);\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\n/* Returns a string form of 'reason'.  The return value is either a statically\n * allocated constant string or the 'bufsize'-byte buffer 'reasonbuf'.\n * 'bufsize' should be at least OFPUTIL_PACKET_IN_REASON_BUFSIZE. */\nconst char *\nofputil_packet_in_reason_to_string(enum ofp_packet_in_reason reason,\n                                   char *reasonbuf, size_t bufsize)\n{\n    switch (reason) {\n    case OFPR_NO_MATCH:\n        return \"no_match\";\n    case OFPR_ACTION:\n        return \"action\";\n    case OFPR_INVALID_TTL:\n        return \"invalid_ttl\";\n    case OFPR_ACTION_SET:\n        return \"action_set\";\n    case OFPR_GROUP:\n        return \"group\";\n    case OFPR_PACKET_OUT:\n        return \"packet_out\";\n    case OFPR_EXPLICIT_MISS:\n    case OFPR_IMPLICIT_MISS:\n        return \"\";\n\n    case OFPR_N_REASONS:\n    default:\n        snprintf(reasonbuf, bufsize, \"%d\", (int) reason);\n        return reasonbuf;\n    }\n}\n\nbool\nofputil_packet_in_reason_from_string(const char *s,\n                                     enum ofp_packet_in_reason *reason)\n{\n    int i;\n\n    for (i = 0; i < OFPR_N_REASONS; i++) {\n        char reasonbuf[OFPUTIL_PACKET_IN_REASON_BUFSIZE];\n        const char *reason_s;\n\n        reason_s = ofputil_packet_in_reason_to_string(i, reasonbuf,\n                                                      sizeof reasonbuf);\n        if (!strcasecmp(s, reason_s)) {\n            *reason = i;\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Returns a newly allocated NXT_RESUME message for 'pin', with the given\n * 'continuation', for 'protocol'.  This message is suitable for resuming the\n * pipeline traveral of the packet represented by 'pin', if sent to the switch\n * from which 'pin' was received. */\nstruct ofpbuf *\nofputil_encode_resume(const struct ofputil_packet_in *pin,\n                      const struct ofpbuf *continuation,\n                      enum ofputil_protocol protocol)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n    size_t extra = pin->packet_len + NXM_TYPICAL_LEN + continuation->size;\n    struct ofpbuf *msg = ofpraw_alloc_xid(OFPRAW_NXT_RESUME, version,\n                                          0, extra);\n    ofputil_put_packet_in(pin, version, pin->packet_len, msg);\n    ofpprop_put_nested(msg, NXPINT_CONTINUATION, continuation);\n    ofpmsg_update_length(msg);\n    return msg;\n}\n\nstatic enum ofperr\nparse_stack_prop(const struct ofpbuf *property, struct ofpbuf *stack)\n{\n    unsigned int len = ofpbuf_msgsize(property);\n    if (len > sizeof(union mf_subvalue)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXCPT_STACK property has bad length %u\",\n                     len);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n    nx_stack_push_bottom(stack, property->msg, len);\n    return 0;\n}\n\nstatic enum ofperr\nparse_actions_property(struct ofpbuf *property, enum ofp_version version,\n                       struct ofpbuf *ofpacts)\n{\n    if (!ofpbuf_try_pull(property, ROUND_UP(ofpbuf_headersize(property), 8))) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"actions property has bad length %\"PRIu32,\n                     property->size);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    return ofpacts_pull_openflow_actions(property, property->size,\n                                         version, NULL, NULL, ofpacts);\n}\n\n/* This is like ofputil_decode_packet_in(), except that it decodes the\n * continuation data into 'pin'.  The format of this data is supposed to be\n * opaque to any process other than ovs-vswitchd, so this function should not\n * be used outside ovs-vswitchd.\n *\n * 'vl_mff_map' is an optional parameter that is used to validate the length\n * of variable length mf_fields in 'match'. If it is not provided, the\n * default mf_fields with maximum length will be used.\n *\n * When successful, 'pin' contains some dynamically allocated data.  Call\n * ofputil_packet_in_private_destroy() to free this data. */\nenum ofperr\nofputil_decode_packet_in_private(const struct ofp_header *oh, bool loose,\n                                 const struct tun_table *tun_table,\n                                 const struct vl_mff_map *vl_mff_map,\n                                 struct ofputil_packet_in_private *pin,\n                                 size_t *total_len, uint32_t *buffer_id)\n{\n    memset(pin, 0, sizeof *pin);\n\n    struct ofpbuf continuation;\n    enum ofperr error;\n    error = ofputil_decode_packet_in(oh, loose, tun_table, vl_mff_map,\n                                     &pin->public, total_len, buffer_id,\n                                     &continuation);\n    if (error) {\n        return error;\n    }\n\n    struct ofpbuf actions, action_set;\n    ofpbuf_init(&actions, 0);\n    ofpbuf_init(&action_set, 0);\n\n    uint8_t table_id = 0;\n    ovs_be64 cookie = 0;\n\n    struct ofpbuf stack;\n    ofpbuf_init(&stack, 0);\n\n    while (continuation.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        error = ofpprop_pull(&continuation, &payload, &type);\n        if (error) {\n            break;\n        }\n\n        switch (type) {\n        case NXCPT_BRIDGE:\n            error = ofpprop_parse_uuid(&payload, &pin->bridge);\n            break;\n\n        case NXCPT_STACK:\n            error = parse_stack_prop(&payload, &stack);\n            break;\n\n        case NXCPT_MIRRORS:\n            error = ofpprop_parse_u32(&payload, &pin->mirrors);\n            break;\n\n        case NXCPT_CONNTRACKED:\n            pin->conntracked = true;\n            break;\n\n        case NXCPT_TABLE_ID:\n            error = ofpprop_parse_u8(&payload, &table_id);\n            break;\n\n        case NXCPT_COOKIE:\n            error = ofpprop_parse_be64(&payload, &cookie);\n            break;\n\n        case NXCPT_ACTIONS: {\n            struct ofpact_unroll_xlate *unroll\n                = ofpact_put_UNROLL_XLATE(&actions);\n            unroll->rule_table_id = table_id;\n            unroll->rule_cookie = cookie;\n            error = parse_actions_property(&payload, oh->version, &actions);\n            break;\n        }\n\n        case NXCPT_ACTION_SET:\n            error = parse_actions_property(&payload, oh->version, &action_set);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(loose, \"continuation\", type);\n            break;\n        }\n        if (error) {\n            break;\n        }\n    }\n\n    pin->actions_len = actions.size;\n    pin->actions = ofpbuf_steal_data(&actions);\n    pin->action_set_len = action_set.size;\n    pin->action_set = ofpbuf_steal_data(&action_set);\n    pin->stack_size = stack.size;\n    pin->stack = ofpbuf_steal_data(&stack);\n\n    if (error) {\n        ofputil_packet_in_private_destroy(pin);\n    }\n\n    return error;\n}\n\n/* Frees data in 'pin' that is dynamically allocated by\n * ofputil_decode_packet_in_private().\n *\n * 'pin->public' contains some pointer members that\n * ofputil_decode_packet_in_private() doesn't initialize to newly allocated\n * data, so this function doesn't free those. */\nvoid\nofputil_packet_in_private_destroy(struct ofputil_packet_in_private *pin)\n{\n    if (pin) {\n        free(pin->stack);\n        free(pin->actions);\n        free(pin->action_set);\n    }\n}\n\n/* Converts an OFPT_PACKET_OUT in 'opo' into an abstract ofputil_packet_out in\n * 'po'.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of the packet out\n * message's actions.  The caller must initialize 'ofpacts' and retains\n * ownership of it.  'po->ofpacts' will point into the 'ofpacts' buffer.\n *\n * 'po->packet' refers to the packet data in 'oh', so the buffer containing\n * 'oh' must not be destroyed while 'po' is being used.\n *\n * Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_packet_out(struct ofputil_packet_out *po,\n                          const struct ofp_header *oh,\n                          struct ofpbuf *ofpacts)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    ofpbuf_clear(ofpacts);\n    if (raw == OFPRAW_OFPT11_PACKET_OUT) {\n        enum ofperr error;\n        const struct ofp11_packet_out *opo = ofpbuf_pull(&b, sizeof *opo);\n\n        po->buffer_id = ntohl(opo->buffer_id);\n        error = ofputil_port_from_ofp11(opo->in_port, &po->in_port);\n        if (error) {\n            return error;\n        }\n\n        error = ofpacts_pull_openflow_actions(&b, ntohs(opo->actions_len),\n                                              oh->version, NULL, NULL,\n                                              ofpacts);\n        if (error) {\n            return error;\n        }\n    } else if (raw == OFPRAW_OFPT10_PACKET_OUT) {\n        enum ofperr error;\n        const struct ofp10_packet_out *opo = ofpbuf_pull(&b, sizeof *opo);\n\n        po->buffer_id = ntohl(opo->buffer_id);\n        po->in_port = u16_to_ofp(ntohs(opo->in_port));\n\n        error = ofpacts_pull_openflow_actions(&b, ntohs(opo->actions_len),\n                                              oh->version, NULL, NULL,\n                                              ofpacts);\n        if (error) {\n            return error;\n        }\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (ofp_to_u16(po->in_port) >= ofp_to_u16(OFPP_MAX)\n        && po->in_port != OFPP_LOCAL\n        && po->in_port != OFPP_NONE && po->in_port != OFPP_CONTROLLER) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"packet-out has bad input port %#\"PRIx32,\n                     po->in_port);\n        return OFPERR_OFPBRC_BAD_PORT;\n    }\n\n    po->ofpacts = ofpacts->data;\n    po->ofpacts_len = ofpacts->size;\n\n    if (po->buffer_id == UINT32_MAX) {\n        po->packet = b.data;\n        po->packet_len = b.size;\n    } else {\n        po->packet = NULL;\n        po->packet_len = 0;\n    }\n\n    return 0;\n}\n\f\n/* ofputil_phy_port */\n\n/* NETDEV_F_* to and from OFPPF_* and OFPPF10_*. */\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_HD    == OFPPF_10MB_HD);  /* bit 0 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_FD    == OFPPF_10MB_FD);  /* bit 1 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_HD   == OFPPF_100MB_HD); /* bit 2 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_FD   == OFPPF_100MB_FD); /* bit 3 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_HD     == OFPPF_1GB_HD);   /* bit 4 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_FD     == OFPPF_1GB_FD);   /* bit 5 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10GB_FD    == OFPPF_10GB_FD);  /* bit 6 */\n\n/* NETDEV_F_ bits 11...15 are OFPPF10_ bits 7...11: */\nBUILD_ASSERT_DECL((int) NETDEV_F_COPPER == (OFPPF10_COPPER << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_FIBER == (OFPPF10_FIBER << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_AUTONEG == (OFPPF10_AUTONEG << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE == (OFPPF10_PAUSE << 4));\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE_ASYM == (OFPPF10_PAUSE_ASYM << 4));\n\nstatic enum netdev_features\nnetdev_port_features_from_ofp10(ovs_be32 ofp10_)\n{\n    uint32_t ofp10 = ntohl(ofp10_);\n    return (ofp10 & 0x7f) | ((ofp10 & 0xf80) << 4);\n}\n\nstatic ovs_be32\nnetdev_port_features_to_ofp10(enum netdev_features features)\n{\n    return htonl((features & 0x7f) | ((features & 0xf800) >> 4));\n}\n\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_HD    == OFPPF_10MB_HD);     /* bit 0 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10MB_FD    == OFPPF_10MB_FD);     /* bit 1 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_HD   == OFPPF_100MB_HD);    /* bit 2 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100MB_FD   == OFPPF_100MB_FD);    /* bit 3 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_HD     == OFPPF_1GB_HD);      /* bit 4 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1GB_FD     == OFPPF_1GB_FD);      /* bit 5 */\nBUILD_ASSERT_DECL((int) NETDEV_F_10GB_FD    == OFPPF_10GB_FD);     /* bit 6 */\nBUILD_ASSERT_DECL((int) NETDEV_F_40GB_FD    == OFPPF11_40GB_FD);   /* bit 7 */\nBUILD_ASSERT_DECL((int) NETDEV_F_100GB_FD   == OFPPF11_100GB_FD);  /* bit 8 */\nBUILD_ASSERT_DECL((int) NETDEV_F_1TB_FD     == OFPPF11_1TB_FD);    /* bit 9 */\nBUILD_ASSERT_DECL((int) NETDEV_F_OTHER      == OFPPF11_OTHER);     /* bit 10 */\nBUILD_ASSERT_DECL((int) NETDEV_F_COPPER     == OFPPF11_COPPER);    /* bit 11 */\nBUILD_ASSERT_DECL((int) NETDEV_F_FIBER      == OFPPF11_FIBER);     /* bit 12 */\nBUILD_ASSERT_DECL((int) NETDEV_F_AUTONEG    == OFPPF11_AUTONEG);   /* bit 13 */\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE      == OFPPF11_PAUSE);     /* bit 14 */\nBUILD_ASSERT_DECL((int) NETDEV_F_PAUSE_ASYM == OFPPF11_PAUSE_ASYM);/* bit 15 */\n\nstatic enum netdev_features\nnetdev_port_features_from_ofp11(ovs_be32 ofp11)\n{\n    return ntohl(ofp11) & 0xffff;\n}\n\nstatic ovs_be32\nnetdev_port_features_to_ofp11(enum netdev_features features)\n{\n    return htonl(features & 0xffff);\n}\n\nstatic enum ofperr\nofputil_decode_ofp10_phy_port(struct ofputil_phy_port *pp,\n                              const struct ofp10_phy_port *opp)\n{\n    pp->port_no = u16_to_ofp(ntohs(opp->port_no));\n    pp->hw_addr = opp->hw_addr;\n    ovs_strlcpy(pp->name, opp->name, OFP_MAX_PORT_NAME_LEN);\n\n    pp->config = ntohl(opp->config) & OFPPC10_ALL;\n    pp->state = ntohl(opp->state) & OFPPS10_ALL;\n\n    pp->curr = netdev_port_features_from_ofp10(opp->curr);\n    pp->advertised = netdev_port_features_from_ofp10(opp->advertised);\n    pp->supported = netdev_port_features_from_ofp10(opp->supported);\n    pp->peer = netdev_port_features_from_ofp10(opp->peer);\n\n    pp->curr_speed = netdev_features_to_bps(pp->curr, 0) / 1000;\n    pp->max_speed = netdev_features_to_bps(pp->supported, 0) / 1000;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_decode_ofp11_port(struct ofputil_phy_port *pp,\n                          const struct ofp11_port *op)\n{\n    enum ofperr error;\n\n    error = ofputil_port_from_ofp11(op->port_no, &pp->port_no);\n    if (error) {\n        return error;\n    }\n    pp->hw_addr = op->hw_addr;\n    ovs_strlcpy(pp->name, op->name, OFP_MAX_PORT_NAME_LEN);\n\n    pp->config = ntohl(op->config) & OFPPC11_ALL;\n    pp->state = ntohl(op->state) & OFPPS11_ALL;\n\n    pp->curr = netdev_port_features_from_ofp11(op->curr);\n    pp->advertised = netdev_port_features_from_ofp11(op->advertised);\n    pp->supported = netdev_port_features_from_ofp11(op->supported);\n    pp->peer = netdev_port_features_from_ofp11(op->peer);\n\n    pp->curr_speed = ntohl(op->curr_speed);\n    pp->max_speed = ntohl(op->max_speed);\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_ofp14_port_ethernet_property(const struct ofpbuf *payload,\n                                   struct ofputil_phy_port *pp)\n{\n    struct ofp14_port_desc_prop_ethernet *eth = payload->data;\n\n    if (payload->size != sizeof *eth) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    pp->curr = netdev_port_features_from_ofp11(eth->curr);\n    pp->advertised = netdev_port_features_from_ofp11(eth->advertised);\n    pp->supported = netdev_port_features_from_ofp11(eth->supported);\n    pp->peer = netdev_port_features_from_ofp11(eth->peer);\n\n    pp->curr_speed = ntohl(eth->curr_speed);\n    pp->max_speed = ntohl(eth->max_speed);\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_pull_ofp14_port(struct ofputil_phy_port *pp, struct ofpbuf *msg)\n{\n    struct ofp14_port *op = ofpbuf_try_pull(msg, sizeof *op);\n    if (!op) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    size_t len = ntohs(op->length);\n    if (len < sizeof *op || len - sizeof *op > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= sizeof *op;\n\n    enum ofperr error = ofputil_port_from_ofp11(op->port_no, &pp->port_no);\n    if (error) {\n        return error;\n    }\n    pp->hw_addr = op->hw_addr;\n    ovs_strlcpy(pp->name, op->name, OFP_MAX_PORT_NAME_LEN);\n\n    pp->config = ntohl(op->config) & OFPPC11_ALL;\n    pp->state = ntohl(op->state) & OFPPS11_ALL;\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPPDPT14_ETHERNET:\n            error = parse_ofp14_port_ethernet_property(&payload, pp);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(true, \"port\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\nstatic void\nofputil_encode_ofp10_phy_port(const struct ofputil_phy_port *pp,\n                              struct ofp10_phy_port *opp)\n{\n    memset(opp, 0, sizeof *opp);\n\n    opp->port_no = htons(ofp_to_u16(pp->port_no));\n    opp->hw_addr = pp->hw_addr;\n    ovs_strlcpy(opp->name, pp->name, OFP_MAX_PORT_NAME_LEN);\n\n    opp->config = htonl(pp->config & OFPPC10_ALL);\n    opp->state = htonl(pp->state & OFPPS10_ALL);\n\n    opp->curr = netdev_port_features_to_ofp10(pp->curr);\n    opp->advertised = netdev_port_features_to_ofp10(pp->advertised);\n    opp->supported = netdev_port_features_to_ofp10(pp->supported);\n    opp->peer = netdev_port_features_to_ofp10(pp->peer);\n}\n\nstatic void\nofputil_encode_ofp11_port(const struct ofputil_phy_port *pp,\n                          struct ofp11_port *op)\n{\n    memset(op, 0, sizeof *op);\n\n    op->port_no = ofputil_port_to_ofp11(pp->port_no);\n    op->hw_addr = pp->hw_addr;\n    ovs_strlcpy(op->name, pp->name, OFP_MAX_PORT_NAME_LEN);\n\n    op->config = htonl(pp->config & OFPPC11_ALL);\n    op->state = htonl(pp->state & OFPPS11_ALL);\n\n    op->curr = netdev_port_features_to_ofp11(pp->curr);\n    op->advertised = netdev_port_features_to_ofp11(pp->advertised);\n    op->supported = netdev_port_features_to_ofp11(pp->supported);\n    op->peer = netdev_port_features_to_ofp11(pp->peer);\n\n    op->curr_speed = htonl(pp->curr_speed);\n    op->max_speed = htonl(pp->max_speed);\n}\n\nstatic void\nofputil_put_ofp14_port(const struct ofputil_phy_port *pp,\n                       struct ofpbuf *b)\n{\n    struct ofp14_port *op;\n    struct ofp14_port_desc_prop_ethernet *eth;\n\n    ofpbuf_prealloc_tailroom(b, sizeof *op + sizeof *eth);\n\n    op = ofpbuf_put_zeros(b, sizeof *op);\n    op->port_no = ofputil_port_to_ofp11(pp->port_no);\n    op->length = htons(sizeof *op + sizeof *eth);\n    op->hw_addr = pp->hw_addr;\n    ovs_strlcpy(op->name, pp->name, sizeof op->name);\n    op->config = htonl(pp->config & OFPPC11_ALL);\n    op->state = htonl(pp->state & OFPPS11_ALL);\n\n    eth = ofpprop_put_zeros(b, OFPPDPT14_ETHERNET, sizeof *eth);\n    eth->curr = netdev_port_features_to_ofp11(pp->curr);\n    eth->advertised = netdev_port_features_to_ofp11(pp->advertised);\n    eth->supported = netdev_port_features_to_ofp11(pp->supported);\n    eth->peer = netdev_port_features_to_ofp11(pp->peer);\n    eth->curr_speed = htonl(pp->curr_speed);\n    eth->max_speed = htonl(pp->max_speed);\n}\n\nstatic void\nofputil_put_phy_port(enum ofp_version ofp_version,\n                     const struct ofputil_phy_port *pp, struct ofpbuf *b)\n{\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_phy_port *opp = ofpbuf_put_uninit(b, sizeof *opp);\n        ofputil_encode_ofp10_phy_port(pp, opp);\n        break;\n    }\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        struct ofp11_port *op = ofpbuf_put_uninit(b, sizeof *op);\n        ofputil_encode_ofp11_port(pp, op);\n        break;\n    }\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_put_ofp14_port(pp, b);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nenum ofperr\nofputil_decode_port_desc_stats_request(const struct ofp_header *request,\n                                       ofp_port_t *port)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(request,\n                                               ntohs(request->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPST10_PORT_DESC_REQUEST) {\n        *port = OFPP_ANY;\n        return 0;\n    } else if (raw == OFPRAW_OFPST15_PORT_DESC_REQUEST) {\n        ovs_be32 *ofp11_port;\n\n        ofp11_port = ofpbuf_pull(&b, sizeof *ofp11_port);\n        return ofputil_port_from_ofp11(*ofp11_port, port);\n    } else {\n        OVS_NOT_REACHED();\n    }\n}\n\nstruct ofpbuf *\nofputil_encode_port_desc_stats_request(enum ofp_version ofp_version,\n                                       ofp_port_t port)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST10_PORT_DESC_REQUEST,\n                               ofp_version, 0);\n        break;\n    case OFP15_VERSION:\n    case OFP16_VERSION:{\n        struct ofp15_port_desc_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST15_PORT_DESC_REQUEST,\n                               ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = ofputil_port_to_ofp11(port);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nvoid\nofputil_append_port_desc_stats_reply(const struct ofputil_phy_port *pp,\n                                     struct ovs_list *replies)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_ofs = reply->size;\n\n    ofputil_put_phy_port(ofpmp_version(replies), pp, reply);\n    ofpmp_postappend(replies, start_ofs);\n}\n\f\n/* ofputil_switch_config */\n\n/* Decodes 'oh', which must be an OFPT_GET_CONFIG_REPLY or OFPT_SET_CONFIG\n * message, into 'config'.  Returns false if 'oh' contained any flags that\n * aren't specified in its version of OpenFlow, true otherwise. */\nstatic bool\nofputil_decode_switch_config(const struct ofp_header *oh,\n                             struct ofputil_switch_config *config)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    const struct ofp_switch_config *osc = ofpbuf_pull(&b, sizeof *osc);\n    config->frag = ntohs(osc->flags) & OFPC_FRAG_MASK;\n    config->miss_send_len = ntohs(osc->miss_send_len);\n\n    ovs_be16 valid_mask = htons(OFPC_FRAG_MASK);\n    if (oh->version < OFP13_VERSION) {\n        const ovs_be16 ttl_bit = htons(OFPC_INVALID_TTL_TO_CONTROLLER);\n        valid_mask |= ttl_bit;\n        config->invalid_ttl_to_controller = (osc->flags & ttl_bit) != 0;\n    } else {\n        config->invalid_ttl_to_controller = -1;\n    }\n\n    return !(osc->flags & ~valid_mask);\n}\n\nvoid\nofputil_decode_get_config_reply(const struct ofp_header *oh,\n                                struct ofputil_switch_config *config)\n{\n    ofputil_decode_switch_config(oh, config);\n}\n\nenum ofperr\nofputil_decode_set_config(const struct ofp_header *oh,\n                          struct ofputil_switch_config *config)\n{\n    return (ofputil_decode_switch_config(oh, config)\n            ? 0\n            : OFPERR_OFPSCFC_BAD_FLAGS);\n}\n\nstatic struct ofpbuf *\nofputil_put_switch_config(const struct ofputil_switch_config *config,\n                          struct ofpbuf *b)\n{\n    const struct ofp_header *oh = b->data;\n    struct ofp_switch_config *osc = ofpbuf_put_zeros(b, sizeof *osc);\n    osc->flags = htons(config->frag);\n    if (config->invalid_ttl_to_controller > 0 && oh->version < OFP13_VERSION) {\n        osc->flags |= htons(OFPC_INVALID_TTL_TO_CONTROLLER);\n    }\n    osc->miss_send_len = htons(config->miss_send_len);\n    return b;\n}\n\nstruct ofpbuf *\nofputil_encode_get_config_reply(const struct ofp_header *request,\n                                const struct ofputil_switch_config *config)\n{\n    struct ofpbuf *b = ofpraw_alloc_reply(OFPRAW_OFPT_GET_CONFIG_REPLY,\n                                          request, 0);\n    return ofputil_put_switch_config(config, b);\n}\n\nstruct ofpbuf *\nofputil_encode_set_config(const struct ofputil_switch_config *config,\n                          enum ofp_version version)\n{\n    struct ofpbuf *b = ofpraw_alloc(OFPRAW_OFPT_SET_CONFIG, version, 0);\n    return ofputil_put_switch_config(config, b);\n}\n\f\n/* ofputil_switch_features */\n\n#define OFPC_COMMON (OFPC_FLOW_STATS | OFPC_TABLE_STATS | OFPC_PORT_STATS | \\\n                     OFPC_IP_REASM | OFPC_QUEUE_STATS)\nBUILD_ASSERT_DECL((int) OFPUTIL_C_FLOW_STATS == OFPC_FLOW_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_TABLE_STATS == OFPC_TABLE_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_PORT_STATS == OFPC_PORT_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_IP_REASM == OFPC_IP_REASM);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_QUEUE_STATS == OFPC_QUEUE_STATS);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_ARP_MATCH_IP == OFPC_ARP_MATCH_IP);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_PORT_BLOCKED == OFPC12_PORT_BLOCKED);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_BUNDLES == OFPC14_BUNDLES);\nBUILD_ASSERT_DECL((int) OFPUTIL_C_FLOW_MONITORING == OFPC14_FLOW_MONITORING);\n\nstatic uint32_t\nofputil_capabilities_mask(enum ofp_version ofp_version)\n{\n    /* Handle capabilities whose bit is unique for all OpenFlow versions */\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n        return OFPC_COMMON | OFPC_ARP_MATCH_IP;\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n        return OFPC_COMMON | OFPC12_PORT_BLOCKED;\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return OFPC_COMMON | OFPC12_PORT_BLOCKED | OFPC14_BUNDLES\n            | OFPC14_FLOW_MONITORING;\n    default:\n        /* Caller needs to check osf->header.version itself */\n        return 0;\n    }\n}\n\n/* Pulls an OpenFlow \"switch_features\" structure from 'b' and decodes it into\n * an abstract representation in '*features', readying 'b' to iterate over the\n * OpenFlow port structures following 'osf' with later calls to\n * ofputil_pull_phy_port().  Returns 0 if successful, otherwise an OFPERR_*\n * value.  */\nenum ofperr\nofputil_pull_switch_features(struct ofpbuf *b,\n                             struct ofputil_switch_features *features)\n{\n    const struct ofp_header *oh = b->data;\n    enum ofpraw raw = ofpraw_pull_assert(b);\n    const struct ofp_switch_features *osf = ofpbuf_pull(b, sizeof *osf);\n    features->datapath_id = ntohll(osf->datapath_id);\n    features->n_buffers = ntohl(osf->n_buffers);\n    features->n_tables = osf->n_tables;\n    features->auxiliary_id = 0;\n\n    features->capabilities = ntohl(osf->capabilities) &\n        ofputil_capabilities_mask(oh->version);\n\n    if (raw == OFPRAW_OFPT10_FEATURES_REPLY) {\n        if (osf->capabilities & htonl(OFPC10_STP)) {\n            features->capabilities |= OFPUTIL_C_STP;\n        }\n        features->ofpacts = ofpact_bitmap_from_openflow(osf->actions,\n                                                        OFP10_VERSION);\n    } else if (raw == OFPRAW_OFPT11_FEATURES_REPLY\n               || raw == OFPRAW_OFPT13_FEATURES_REPLY) {\n        if (osf->capabilities & htonl(OFPC11_GROUP_STATS)) {\n            features->capabilities |= OFPUTIL_C_GROUP_STATS;\n        }\n        features->ofpacts = 0;\n        if (raw == OFPRAW_OFPT13_FEATURES_REPLY) {\n            features->auxiliary_id = osf->auxiliary_id;\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n\n    return 0;\n}\n\n/* In OpenFlow 1.0, 1.1, and 1.2, an OFPT_FEATURES_REPLY message lists all the\n * switch's ports, unless there are too many to fit.  In OpenFlow 1.3 and\n * later, an OFPT_FEATURES_REPLY does not list ports at all.\n *\n * Given a buffer 'b' that contains a Features Reply message, this message\n * checks if it contains a complete list of the switch's ports.  Returns true,\n * if so.  Returns false if the list is missing (OF1.3+) or incomplete\n * (OF1.0/1.1/1.2), and in the latter case removes all of the ports from the\n * message.\n *\n * When this function returns false, the caller should send an OFPST_PORT_DESC\n * stats request to get the ports. */\nbool\nofputil_switch_features_has_ports(struct ofpbuf *b)\n{\n    struct ofp_header *oh = b->data;\n    size_t phy_port_size;\n\n    if (oh->version >= OFP13_VERSION) {\n        /* OpenFlow 1.3+ never has ports in the feature reply. */\n        return false;\n    }\n\n    phy_port_size = (oh->version == OFP10_VERSION\n                     ? sizeof(struct ofp10_phy_port)\n                     : sizeof(struct ofp11_port));\n    if (ntohs(oh->length) + phy_port_size <= UINT16_MAX) {\n        /* There's room for additional ports in the feature reply.\n         * Assume that the list is complete. */\n        return true;\n    }\n\n    /* The feature reply has no room for more ports.  Probably the list is\n     * truncated.  Drop the ports and tell the caller to retrieve them with\n     * OFPST_PORT_DESC. */\n    b->size = sizeof *oh + sizeof(struct ofp_switch_features);\n    ofpmsg_update_length(b);\n    return false;\n}\n\n/* Returns a buffer owned by the caller that encodes 'features' in the format\n * required by 'protocol' with the given 'xid'.  The caller should append port\n * information to the buffer with subsequent calls to\n * ofputil_put_switch_features_port(). */\nstruct ofpbuf *\nofputil_encode_switch_features(const struct ofputil_switch_features *features,\n                               enum ofputil_protocol protocol, ovs_be32 xid)\n{\n    struct ofp_switch_features *osf;\n    struct ofpbuf *b;\n    enum ofp_version version;\n    enum ofpraw raw;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    switch (version) {\n    case OFP10_VERSION:\n        raw = OFPRAW_OFPT10_FEATURES_REPLY;\n        break;\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        raw = OFPRAW_OFPT11_FEATURES_REPLY;\n        break;\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        raw = OFPRAW_OFPT13_FEATURES_REPLY;\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n    b = ofpraw_alloc_xid(raw, version, xid, 0);\n    osf = ofpbuf_put_zeros(b, sizeof *osf);\n    osf->datapath_id = htonll(features->datapath_id);\n    osf->n_buffers = htonl(features->n_buffers);\n    osf->n_tables = features->n_tables;\n\n    osf->capabilities = htonl(features->capabilities &\n                              ofputil_capabilities_mask(version));\n    switch (version) {\n    case OFP10_VERSION:\n        if (features->capabilities & OFPUTIL_C_STP) {\n            osf->capabilities |= htonl(OFPC10_STP);\n        }\n        osf->actions = ofpact_bitmap_to_openflow(features->ofpacts,\n                                                 OFP10_VERSION);\n        break;\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        osf->auxiliary_id = features->auxiliary_id;\n        /* fall through */\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        if (features->capabilities & OFPUTIL_C_GROUP_STATS) {\n            osf->capabilities |= htonl(OFPC11_GROUP_STATS);\n        }\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return b;\n}\n\n/* Encodes 'pp' into the format required by the switch_features message already\n * in 'b', which should have been returned by ofputil_encode_switch_features(),\n * and appends the encoded version to 'b'. */\nvoid\nofputil_put_switch_features_port(const struct ofputil_phy_port *pp,\n                                 struct ofpbuf *b)\n{\n    const struct ofp_header *oh = b->data;\n\n    if (oh->version < OFP13_VERSION) {\n        /* Try adding a port description to the message, but drop it again if\n         * the buffer overflows.  (This possibility for overflow is why\n         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */\n        size_t start_ofs = b->size;\n        ofputil_put_phy_port(oh->version, pp, b);\n        if (b->size > UINT16_MAX) {\n            b->size = start_ofs;\n        }\n    }\n}\n\f\n/* ofputil_port_status */\n\n/* Decodes the OpenFlow \"port status\" message in '*ops' into an abstract form\n * in '*ps'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_port_status(const struct ofp_header *oh,\n                           struct ofputil_port_status *ps)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    const struct ofp_port_status *ops = ofpbuf_pull(&b, sizeof *ops);\n    if (ops->reason != OFPPR_ADD &&\n        ops->reason != OFPPR_DELETE &&\n        ops->reason != OFPPR_MODIFY) {\n        return OFPERR_NXBRC_BAD_REASON;\n    }\n    ps->reason = ops->reason;\n\n    int retval = ofputil_pull_phy_port(oh->version, &b, &ps->desc);\n    ovs_assert(retval != EOF);\n    return retval;\n}\n\n/* Converts the abstract form of a \"port status\" message in '*ps' into an\n * OpenFlow message suitable for 'protocol', and returns that encoded form in\n * a buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_port_status(const struct ofputil_port_status *ps,\n                           enum ofputil_protocol protocol)\n{\n    struct ofp_port_status *ops;\n    struct ofpbuf *b;\n    enum ofp_version version;\n    enum ofpraw raw;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    switch (version) {\n    case OFP10_VERSION:\n        raw = OFPRAW_OFPT10_PORT_STATUS;\n        break;\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n        raw = OFPRAW_OFPT11_PORT_STATUS;\n        break;\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        raw = OFPRAW_OFPT14_PORT_STATUS;\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    b = ofpraw_alloc_xid(raw, version, htonl(0), 0);\n    ops = ofpbuf_put_zeros(b, sizeof *ops);\n    ops->reason = ps->reason;\n    ofputil_put_phy_port(version, &ps->desc, b);\n    ofpmsg_update_length(b);\n    return b;\n}\n\n/* ofputil_port_mod */\n\nstatic enum ofperr\nparse_port_mod_ethernet_property(struct ofpbuf *property,\n                                 struct ofputil_port_mod *pm)\n{\n    ovs_be32 advertise;\n    enum ofperr error;\n\n    error = ofpprop_parse_be32(property, &advertise);\n    if (!error) {\n        pm->advertise = netdev_port_features_from_ofp11(advertise);\n    }\n    return error;\n}\n\n/* Decodes the OpenFlow \"port mod\" message in '*oh' into an abstract form in\n * '*pm'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_port_mod(const struct ofp_header *oh,\n                        struct ofputil_port_mod *pm, bool loose)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT10_PORT_MOD) {\n        const struct ofp10_port_mod *opm = b.data;\n\n        pm->port_no = u16_to_ofp(ntohs(opm->port_no));\n        pm->hw_addr = opm->hw_addr;\n        pm->config = ntohl(opm->config) & OFPPC10_ALL;\n        pm->mask = ntohl(opm->mask) & OFPPC10_ALL;\n        pm->advertise = netdev_port_features_from_ofp10(opm->advertise);\n    } else if (raw == OFPRAW_OFPT11_PORT_MOD) {\n        const struct ofp11_port_mod *opm = b.data;\n        enum ofperr error;\n\n        error = ofputil_port_from_ofp11(opm->port_no, &pm->port_no);\n        if (error) {\n            return error;\n        }\n\n        pm->hw_addr = opm->hw_addr;\n        pm->config = ntohl(opm->config) & OFPPC11_ALL;\n        pm->mask = ntohl(opm->mask) & OFPPC11_ALL;\n        pm->advertise = netdev_port_features_from_ofp11(opm->advertise);\n    } else if (raw == OFPRAW_OFPT14_PORT_MOD) {\n        const struct ofp14_port_mod *opm = ofpbuf_pull(&b, sizeof *opm);\n        enum ofperr error;\n\n        memset(pm, 0, sizeof *pm);\n\n        error = ofputil_port_from_ofp11(opm->port_no, &pm->port_no);\n        if (error) {\n            return error;\n        }\n\n        pm->hw_addr = opm->hw_addr;\n        pm->config = ntohl(opm->config) & OFPPC11_ALL;\n        pm->mask = ntohl(opm->mask) & OFPPC11_ALL;\n\n        while (b.size > 0) {\n            struct ofpbuf property;\n            enum ofperr error;\n            uint64_t type;\n\n            error = ofpprop_pull(&b, &property, &type);\n            if (error) {\n                return error;\n            }\n\n            switch (type) {\n            case OFPPMPT14_ETHERNET:\n                error = parse_port_mod_ethernet_property(&property, pm);\n                break;\n\n            default:\n                error = OFPPROP_UNKNOWN(loose, \"port_mod\", type);\n                break;\n            }\n\n            if (error) {\n                return error;\n            }\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_TYPE;\n    }\n\n    pm->config &= pm->mask;\n    return 0;\n}\n\n/* Converts the abstract form of a \"port mod\" message in '*pm' into an OpenFlow\n * message suitable for 'protocol', and returns that encoded form in a buffer\n * owned by the caller. */\nstruct ofpbuf *\nofputil_encode_port_mod(const struct ofputil_port_mod *pm,\n                        enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *b;\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_port_mod *opm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT10_PORT_MOD, ofp_version, 0);\n        opm = ofpbuf_put_zeros(b, sizeof *opm);\n        opm->port_no = htons(ofp_to_u16(pm->port_no));\n        opm->hw_addr = pm->hw_addr;\n        opm->config = htonl(pm->config & OFPPC10_ALL);\n        opm->mask = htonl(pm->mask & OFPPC10_ALL);\n        opm->advertise = netdev_port_features_to_ofp10(pm->advertise);\n        break;\n    }\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        struct ofp11_port_mod *opm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT11_PORT_MOD, ofp_version, 0);\n        opm = ofpbuf_put_zeros(b, sizeof *opm);\n        opm->port_no = ofputil_port_to_ofp11(pm->port_no);\n        opm->hw_addr = pm->hw_addr;\n        opm->config = htonl(pm->config & OFPPC11_ALL);\n        opm->mask = htonl(pm->mask & OFPPC11_ALL);\n        opm->advertise = netdev_port_features_to_ofp11(pm->advertise);\n        break;\n    }\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp14_port_mod *opm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT14_PORT_MOD, ofp_version, 0);\n        opm = ofpbuf_put_zeros(b, sizeof *opm);\n        opm->port_no = ofputil_port_to_ofp11(pm->port_no);\n        opm->hw_addr = pm->hw_addr;\n        opm->config = htonl(pm->config & OFPPC11_ALL);\n        opm->mask = htonl(pm->mask & OFPPC11_ALL);\n\n        if (pm->advertise) {\n            ofpprop_put_be32(b, OFPPMPT14_ETHERNET,\n                             netdev_port_features_to_ofp11(pm->advertise));\n        }\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return b;\n}\n\f\n/* Table features. */\n\nstatic enum ofperr\npull_table_feature_property(struct ofpbuf *msg, struct ofpbuf *payload,\n                            uint64_t *typep)\n{\n    enum ofperr error;\n\n    error = ofpprop_pull(msg, payload, typep);\n    if (payload && !error) {\n        ofpbuf_pull(payload, (char *)payload->msg - (char *)payload->header);\n    }\n    return error;\n}\n\nstatic enum ofperr\nparse_action_bitmap(struct ofpbuf *payload, enum ofp_version ofp_version,\n                    uint64_t *ofpacts)\n{\n    uint32_t types = 0;\n\n    while (payload->size > 0) {\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &type);\n        if (error) {\n            return error;\n        }\n        if (type < CHAR_BIT * sizeof types) {\n            types |= 1u << type;\n        }\n    }\n\n    *ofpacts = ofpact_bitmap_from_openflow(htonl(types), ofp_version);\n    return 0;\n}\n\nstatic enum ofperr\nparse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)\n{\n    *insts = 0;\n    while (payload->size > 0) {\n        enum ovs_instruction_type inst;\n        enum ofperr error;\n        uint64_t ofpit;\n\n        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.\n         * It seems clear that they aren't padded to 8 bytes, though, because\n         * both standards say that \"non-experimenter instructions are 4 bytes\"\n         * and do not mention any padding before the first instruction ID.\n         * (There wouldn't be any point in padding to 8 bytes if the IDs were\n         * aligned on an odd 4-byte boundary.)\n         *\n         * Anyway, we just assume they're all glommed together on byte\n         * boundaries. */\n        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);\n        if (error) {\n            return error;\n        }\n\n        error = ovs_instruction_type_from_inst_type(&inst, ofpit);\n        if (!error) {\n            *insts |= 1u << inst;\n        } else if (!loose) {\n            return error;\n        }\n    }\n    return 0;\n}\n\nstatic enum ofperr\nparse_table_features_next_table(struct ofpbuf *payload,\n                                unsigned long int *next_tables)\n{\n    size_t i;\n\n    memset(next_tables, 0, bitmap_n_bytes(255));\n    for (i = 0; i < payload->size; i++) {\n        uint8_t id = ((const uint8_t *) payload->data)[i];\n        if (id >= 255) {\n            return OFPERR_OFPBPC_BAD_VALUE;\n        }\n        bitmap_set1(next_tables, id);\n    }\n    return 0;\n}\n\nstatic enum ofperr\nparse_oxms(struct ofpbuf *payload, bool loose,\n           struct mf_bitmap *exactp, struct mf_bitmap *maskedp)\n{\n    struct mf_bitmap exact = MF_BITMAP_INITIALIZER;\n    struct mf_bitmap masked = MF_BITMAP_INITIALIZER;\n\n    while (payload->size > 0) {\n        const struct mf_field *field;\n        enum ofperr error;\n        bool hasmask;\n\n        error = nx_pull_header(payload, NULL, &field, &hasmask);\n        if (!error) {\n            bitmap_set1(hasmask ? masked.bm : exact.bm, field->id);\n        } else if (error != OFPERR_OFPBMC_BAD_FIELD || !loose) {\n            return error;\n        }\n    }\n    if (exactp) {\n        *exactp = exact;\n    } else if (!bitmap_is_all_zeros(exact.bm, MFF_N_IDS)) {\n        return OFPERR_OFPBMC_BAD_MASK;\n    }\n    if (maskedp) {\n        *maskedp = masked;\n    } else if (!bitmap_is_all_zeros(masked.bm, MFF_N_IDS)) {\n        return OFPERR_OFPBMC_BAD_MASK;\n    }\n    return 0;\n}\n\n/* Converts an OFPMP_TABLE_FEATURES request or reply in 'msg' into an abstract\n * ofputil_table_features in 'tf'.\n *\n * If 'loose' is true, this function ignores properties and values that it does\n * not understand, as a controller would want to do when interpreting\n * capabilities provided by a switch.  If 'loose' is false, this function\n * treats unknown properties and values as an error, as a switch would want to\n * do when interpreting a configuration request made by a controller.\n *\n * A single OpenFlow message can specify features for multiple tables.  Calling\n * this function multiple times for a single 'msg' iterates through the tables\n * in the message.  The caller must initially leave 'msg''s layer pointers null\n * and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no tables were left in this 'msg', otherwise\n * a positive \"enum ofperr\" value. */\nint\nofputil_decode_table_features(struct ofpbuf *msg,\n                              struct ofputil_table_features *tf, bool loose)\n{\n    memset(tf, 0, sizeof *tf);\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    const struct ofp_header *oh = msg->header;\n    struct ofp13_table_features *otf = msg->data;\n    if (msg->size < sizeof *otf) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    unsigned int len = ntohs(otf->length);\n    if (len < sizeof *otf || len % 8 || len > msg->size) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    tf->table_id = otf->table_id;\n    if (tf->table_id == OFPTT_ALL) {\n        return OFPERR_OFPTFFC_BAD_TABLE;\n    }\n\n    ovs_strlcpy(tf->name, otf->name, OFP_MAX_TABLE_NAME_LEN);\n    tf->metadata_match = otf->metadata_match;\n    tf->metadata_write = otf->metadata_write;\n    tf->miss_config = OFPUTIL_TABLE_MISS_DEFAULT;\n    if (oh->version >= OFP14_VERSION) {\n        uint32_t caps = ntohl(otf->capabilities);\n        tf->supports_eviction = (caps & OFPTC14_EVICTION) != 0;\n        tf->supports_vacancy_events = (caps & OFPTC14_VACANCY_EVENTS) != 0;\n    } else {\n        tf->supports_eviction = -1;\n        tf->supports_vacancy_events = -1;\n    }\n    tf->max_entries = ntohl(otf->max_entries);\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    ofpbuf_pull(&properties, sizeof *otf);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = pull_table_feature_property(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch ((enum ofp13_table_feature_prop_type) type) {\n        case OFPTFPT13_INSTRUCTIONS:\n            error = parse_instruction_ids(&payload, loose,\n                                          &tf->nonmiss.instructions);\n            break;\n        case OFPTFPT13_INSTRUCTIONS_MISS:\n            error = parse_instruction_ids(&payload, loose,\n                                          &tf->miss.instructions);\n            break;\n\n        case OFPTFPT13_NEXT_TABLES:\n            error = parse_table_features_next_table(&payload,\n                                                    tf->nonmiss.next);\n            break;\n        case OFPTFPT13_NEXT_TABLES_MISS:\n            error = parse_table_features_next_table(&payload, tf->miss.next);\n            break;\n\n        case OFPTFPT13_WRITE_ACTIONS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->nonmiss.write.ofpacts);\n            break;\n        case OFPTFPT13_WRITE_ACTIONS_MISS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->miss.write.ofpacts);\n            break;\n\n        case OFPTFPT13_APPLY_ACTIONS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->nonmiss.apply.ofpacts);\n            break;\n        case OFPTFPT13_APPLY_ACTIONS_MISS:\n            error = parse_action_bitmap(&payload, oh->version,\n                                        &tf->miss.apply.ofpacts);\n            break;\n\n        case OFPTFPT13_MATCH:\n            error = parse_oxms(&payload, loose, &tf->match, &tf->mask);\n            break;\n        case OFPTFPT13_WILDCARDS:\n            error = parse_oxms(&payload, loose, &tf->wildcard, NULL);\n            break;\n\n        case OFPTFPT13_WRITE_SETFIELD:\n            error = parse_oxms(&payload, loose,\n                               &tf->nonmiss.write.set_fields, NULL);\n            break;\n        case OFPTFPT13_WRITE_SETFIELD_MISS:\n            error = parse_oxms(&payload, loose,\n                               &tf->miss.write.set_fields, NULL);\n            break;\n        case OFPTFPT13_APPLY_SETFIELD:\n            error = parse_oxms(&payload, loose,\n                               &tf->nonmiss.apply.set_fields, NULL);\n            break;\n        case OFPTFPT13_APPLY_SETFIELD_MISS:\n            error = parse_oxms(&payload, loose,\n                               &tf->miss.apply.set_fields, NULL);\n            break;\n\n        case OFPTFPT13_EXPERIMENTER:\n        case OFPTFPT13_EXPERIMENTER_MISS:\n        default:\n            error = OFPPROP_UNKNOWN(loose, \"table features\", type);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n    }\n\n    /* Fix inconsistencies:\n     *\n     *     - Turn on 'match' bits that are set in 'mask', because maskable\n     *       fields are matchable.\n     *\n     *     - Turn on 'wildcard' bits that are set in 'mask', because a field\n     *       that is arbitrarily maskable can be wildcarded entirely.\n     *\n     *     - Turn off 'wildcard' bits that are not in 'match', because a field\n     *       must be matchable for it to be meaningfully wildcarded. */\n    bitmap_or(tf->match.bm, tf->mask.bm, MFF_N_IDS);\n    bitmap_or(tf->wildcard.bm, tf->mask.bm, MFF_N_IDS);\n    bitmap_and(tf->wildcard.bm, tf->match.bm, MFF_N_IDS);\n\n    return 0;\n}\n\n/* Encodes and returns a request to obtain the table features of a switch.\n * The message is encoded for OpenFlow version 'ofp_version'. */\nstruct ofpbuf *\nofputil_encode_table_features_request(enum ofp_version ofp_version)\n{\n    struct ofpbuf *request = NULL;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        ovs_fatal(0, \"dump-table-features needs OpenFlow 1.3 or later \"\n                     \"(\\'-O OpenFlow13\\')\");\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST13_TABLE_FEATURES_REQUEST,\n                               ofp_version, 0);\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstatic void\nput_fields_property(struct ofpbuf *reply,\n                    const struct mf_bitmap *fields,\n                    const struct mf_bitmap *masks,\n                    enum ofp13_table_feature_prop_type property,\n                    enum ofp_version version)\n{\n    size_t start_ofs;\n    int field;\n\n    start_ofs = ofpprop_start(reply, property);\n    BITMAP_FOR_EACH_1 (field, MFF_N_IDS, fields->bm) {\n        nx_put_header(reply, field, version,\n                      masks && bitmap_is_set(masks->bm, field));\n    }\n    ofpprop_end(reply, start_ofs);\n}\n\nstatic void\nput_table_action_features(struct ofpbuf *reply,\n                          const struct ofputil_table_action_features *taf,\n                          enum ofp13_table_feature_prop_type actions_type,\n                          enum ofp13_table_feature_prop_type set_fields_type,\n                          int miss_offset, enum ofp_version version)\n{\n    ofpprop_put_bitmap(reply, actions_type + miss_offset,\n                       ntohl(ofpact_bitmap_to_openflow(taf->ofpacts,\n                                                       version)));\n    put_fields_property(reply, &taf->set_fields, NULL,\n                        set_fields_type + miss_offset, version);\n}\n\nstatic void\nput_table_instruction_features(\n    struct ofpbuf *reply, const struct ofputil_table_instruction_features *tif,\n    int miss_offset, enum ofp_version version)\n{\n    size_t start_ofs;\n    uint8_t table_id;\n\n    ofpprop_put_bitmap(reply, OFPTFPT13_INSTRUCTIONS + miss_offset,\n                       ntohl(ovsinst_bitmap_to_openflow(tif->instructions,\n                                                        version)));\n\n    start_ofs = ofpprop_start(reply, OFPTFPT13_NEXT_TABLES + miss_offset);\n    BITMAP_FOR_EACH_1 (table_id, 255, tif->next) {\n        ofpbuf_put(reply, &table_id, 1);\n    }\n    ofpprop_end(reply, start_ofs);\n\n    put_table_action_features(reply, &tif->write,\n                              OFPTFPT13_WRITE_ACTIONS,\n                              OFPTFPT13_WRITE_SETFIELD, miss_offset, version);\n    put_table_action_features(reply, &tif->apply,\n                              OFPTFPT13_APPLY_ACTIONS,\n                              OFPTFPT13_APPLY_SETFIELD, miss_offset, version);\n}\n\nvoid\nofputil_append_table_features_reply(const struct ofputil_table_features *tf,\n                                    struct ovs_list *replies)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    enum ofp_version version = ofpmp_version(replies);\n    size_t start_ofs = reply->size;\n    struct ofp13_table_features *otf;\n\n    otf = ofpbuf_put_zeros(reply, sizeof *otf);\n    otf->table_id = tf->table_id;\n    ovs_strlcpy(otf->name, tf->name, sizeof otf->name);\n    otf->metadata_match = tf->metadata_match;\n    otf->metadata_write = tf->metadata_write;\n    if (version >= OFP14_VERSION) {\n        if (tf->supports_eviction) {\n            otf->capabilities |= htonl(OFPTC14_EVICTION);\n        }\n        if (tf->supports_vacancy_events) {\n            otf->capabilities |= htonl(OFPTC14_VACANCY_EVENTS);\n        }\n    }\n    otf->max_entries = htonl(tf->max_entries);\n\n    put_table_instruction_features(reply, &tf->nonmiss, 0, version);\n    put_table_instruction_features(reply, &tf->miss, 1, version);\n\n    put_fields_property(reply, &tf->match, &tf->mask,\n                        OFPTFPT13_MATCH, version);\n    put_fields_property(reply, &tf->wildcard, NULL,\n                        OFPTFPT13_WILDCARDS, version);\n\n    otf = ofpbuf_at_assert(reply, start_ofs, sizeof *otf);\n    otf->length = htons(reply->size - start_ofs);\n    ofpmp_postappend(replies, start_ofs);\n}\n\nstatic enum ofperr\nparse_table_desc_vacancy_property(struct ofpbuf *property,\n                                  struct ofputil_table_desc *td)\n{\n    struct ofp14_table_mod_prop_vacancy *otv = property->data;\n\n    if (property->size != sizeof *otv) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    td->table_vacancy.vacancy_down = otv->vacancy_down;\n    td->table_vacancy.vacancy_up = otv->vacancy_up;\n    td->table_vacancy.vacancy = otv->vacancy;\n    return 0;\n}\n\n/* Decodes the next OpenFlow \"table desc\" message (of possibly several) from\n * 'msg' into an abstract form in '*td'.  Returns 0 if successful, EOF if the\n * last \"table desc\" in 'msg' was already decoded, otherwise an OFPERR_*\n * value. */\nint\nofputil_decode_table_desc(struct ofpbuf *msg,\n                          struct ofputil_table_desc *td,\n                          enum ofp_version version)\n{\n    memset(td, 0, sizeof *td);\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    struct ofp14_table_desc *otd = ofpbuf_try_pull(msg, sizeof *otd);\n    if (!otd) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFP14_TABLE_DESC reply has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    td->table_id = otd->table_id;\n    size_t length = ntohs(otd->length);\n    if (length < sizeof *otd || length - sizeof *otd > msg->size) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFP14_TABLE_DESC reply claims invalid \"\n                     \"length %\"PRIuSIZE, length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    length -= sizeof *otd;\n\n    td->eviction = ofputil_decode_table_eviction(otd->config, version);\n    td->vacancy = ofputil_decode_table_vacancy(otd->config, version);\n    td->eviction_flags = UINT32_MAX;\n\n    struct ofpbuf properties = ofpbuf_const_initializer(\n        ofpbuf_pull(msg, length), length);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPTMPT14_EVICTION:\n            error = ofpprop_parse_u32(&payload, &td->eviction_flags);\n            break;\n\n        case OFPTMPT14_VACANCY:\n            error = parse_table_desc_vacancy_property(&payload, td);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(true, \"table_desc\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\n/* Encodes and returns a request to obtain description of tables of a switch.\n * The message is encoded for OpenFlow version 'ofp_version'. */\nstruct ofpbuf *\nofputil_encode_table_desc_request(enum ofp_version ofp_version)\n{\n    struct ofpbuf *request = NULL;\n\n    if (ofp_version >= OFP14_VERSION) {\n        request = ofpraw_alloc(OFPRAW_OFPST14_TABLE_DESC_REQUEST,\n                               ofp_version, 0);\n    } else {\n        ovs_fatal(0, \"dump-table-desc needs OpenFlow 1.4 or later \"\n                  \"(\\'-O OpenFlow14\\')\");\n    }\n\n    return request;\n}\n\n/* Function to append Table desc information in a reply list. */\nvoid\nofputil_append_table_desc_reply(const struct ofputil_table_desc *td,\n                                struct ovs_list *replies,\n                                enum ofp_version version)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    size_t start_otd;\n    struct ofp14_table_desc *otd;\n\n    start_otd = reply->size;\n    ofpbuf_put_zeros(reply, sizeof *otd);\n    if (td->eviction_flags != UINT32_MAX) {\n        ofpprop_put_u32(reply, OFPTMPT14_EVICTION, td->eviction_flags);\n    }\n    if (td->vacancy == OFPUTIL_TABLE_VACANCY_ON) {\n        struct ofp14_table_mod_prop_vacancy *otv;\n\n        otv = ofpprop_put_zeros(reply, OFPTMPT14_VACANCY, sizeof *otv);\n        otv->vacancy_down = td->table_vacancy.vacancy_down;\n        otv->vacancy_up = td->table_vacancy.vacancy_up;\n        otv->vacancy = td->table_vacancy.vacancy;\n    }\n\n    otd = ofpbuf_at_assert(reply, start_otd, sizeof *otd);\n    otd->length = htons(reply->size - start_otd);\n    otd->table_id = td->table_id;\n    otd->config = ofputil_encode_table_config(OFPUTIL_TABLE_MISS_DEFAULT,\n                                              td->eviction, td->vacancy,\n                                              version);\n    ofpmp_postappend(replies, start_otd);\n}\n\n/* This function parses Vacancy property, and decodes the\n * ofp14_table_mod_prop_vacancy in ofputil_table_mod.\n * Returns OFPERR_OFPBPC_BAD_VALUE error code when vacancy_down is\n * greater than vacancy_up and also when current vacancy has non-zero\n * value. Returns 0 on success. */\nstatic enum ofperr\nparse_table_mod_vacancy_property(struct ofpbuf *property,\n                                 struct ofputil_table_mod *tm)\n{\n    struct ofp14_table_mod_prop_vacancy *otv = property->data;\n\n    if (property->size != sizeof *otv) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n    tm->table_vacancy.vacancy_down = otv->vacancy_down;\n    tm->table_vacancy.vacancy_up = otv->vacancy_up;\n    if (tm->table_vacancy.vacancy_down > tm->table_vacancy.vacancy_up) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"Value of vacancy_down is greater than vacancy_up\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    if (tm->table_vacancy.vacancy_down > 100 ||\n        tm->table_vacancy.vacancy_up > 100) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"Vacancy threshold percentage \"\n                    \"should not be greater than 100\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    tm->table_vacancy.vacancy = otv->vacancy;\n    if (tm->table_vacancy.vacancy) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"Vacancy value should be zero for table-mod messages\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    return 0;\n}\n\n/* Given 'config', taken from an OpenFlow 'version' message that specifies\n * table configuration (a table mod, table stats, or table features message),\n * returns the table vacancy configuration that it specifies.\n *\n * Only OpenFlow 1.4 and later specify table vacancy configuration this way,\n * so for other 'version' this function always returns\n * OFPUTIL_TABLE_VACANCY_DEFAULT. */\nstatic enum ofputil_table_vacancy\nofputil_decode_table_vacancy(ovs_be32 config, enum ofp_version version)\n{\n    return (version < OFP14_VERSION ? OFPUTIL_TABLE_VACANCY_DEFAULT\n            : config & htonl(OFPTC14_VACANCY_EVENTS) ? OFPUTIL_TABLE_VACANCY_ON\n            : OFPUTIL_TABLE_VACANCY_OFF);\n}\n\n/* Given 'config', taken from an OpenFlow 'version' message that specifies\n * table configuration (a table mod, table stats, or table features message),\n * returns the table eviction configuration that it specifies.\n *\n * Only OpenFlow 1.4 and later specify table eviction configuration this way,\n * so for other 'version' values this function always returns\n * OFPUTIL_TABLE_EVICTION_DEFAULT. */\nstatic enum ofputil_table_eviction\nofputil_decode_table_eviction(ovs_be32 config, enum ofp_version version)\n{\n    return (version < OFP14_VERSION ? OFPUTIL_TABLE_EVICTION_DEFAULT\n            : config & htonl(OFPTC14_EVICTION) ? OFPUTIL_TABLE_EVICTION_ON\n            : OFPUTIL_TABLE_EVICTION_OFF);\n}\n\n/* Returns a bitmap of OFPTC* values suitable for 'config' fields in various\n * OpenFlow messages of the given 'version', based on the provided 'miss' and\n * 'eviction' values. */\nstatic ovs_be32\nofputil_encode_table_config(enum ofputil_table_miss miss,\n                            enum ofputil_table_eviction eviction,\n                            enum ofputil_table_vacancy vacancy,\n                            enum ofp_version version)\n{\n    uint32_t config = 0;\n    /* Search for \"OFPTC_* Table Configuration\" in the documentation for more\n     * information on the crazy evolution of this field. */\n    switch (version) {\n    case OFP10_VERSION:\n        /* OpenFlow 1.0 didn't have such a field, any value ought to do. */\n        return htonl(0);\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        /* OpenFlow 1.1 and 1.2 define only OFPTC11_TABLE_MISS_*. */\n        switch (miss) {\n        case OFPUTIL_TABLE_MISS_DEFAULT:\n            /* Really this shouldn't be used for encoding (the caller should\n             * provide a specific value) but I can't imagine that defaulting to\n             * the fall-through case here will hurt. */\n        case OFPUTIL_TABLE_MISS_CONTROLLER:\n        default:\n            return htonl(OFPTC11_TABLE_MISS_CONTROLLER);\n        case OFPUTIL_TABLE_MISS_CONTINUE:\n            return htonl(OFPTC11_TABLE_MISS_CONTINUE);\n        case OFPUTIL_TABLE_MISS_DROP:\n            return htonl(OFPTC11_TABLE_MISS_DROP);\n        }\n        OVS_NOT_REACHED();\n\n    case OFP13_VERSION:\n        /* OpenFlow 1.3 removed OFPTC11_TABLE_MISS_* and didn't define any new\n         * flags, so this is correct. */\n        return htonl(0);\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        /* OpenFlow 1.4 introduced OFPTC14_EVICTION and\n         * OFPTC14_VACANCY_EVENTS. */\n        if (eviction == OFPUTIL_TABLE_EVICTION_ON) {\n            config |= OFPTC14_EVICTION;\n        }\n        if (vacancy == OFPUTIL_TABLE_VACANCY_ON) {\n            config |= OFPTC14_VACANCY_EVENTS;\n        }\n        return htonl(config);\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Given 'config', taken from an OpenFlow 'version' message that specifies\n * table configuration (a table mod, table stats, or table features message),\n * returns the table miss configuration that it specifies.\n *\n * Only OpenFlow 1.1 and 1.2 specify table miss configurations this way, so for\n * other 'version' values this function always returns\n * OFPUTIL_TABLE_MISS_DEFAULT. */\nstatic enum ofputil_table_miss\nofputil_decode_table_miss(ovs_be32 config_, enum ofp_version version)\n{\n    uint32_t config = ntohl(config_);\n\n    if (version == OFP11_VERSION || version == OFP12_VERSION) {\n        switch (config & OFPTC11_TABLE_MISS_MASK) {\n        case OFPTC11_TABLE_MISS_CONTROLLER:\n            return OFPUTIL_TABLE_MISS_CONTROLLER;\n\n        case OFPTC11_TABLE_MISS_CONTINUE:\n            return OFPUTIL_TABLE_MISS_CONTINUE;\n\n        case OFPTC11_TABLE_MISS_DROP:\n            return OFPUTIL_TABLE_MISS_DROP;\n\n        default:\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"bad table miss config %d\", config);\n            return OFPUTIL_TABLE_MISS_CONTROLLER;\n        }\n    } else {\n        return OFPUTIL_TABLE_MISS_DEFAULT;\n    }\n}\n\n/* Decodes the OpenFlow \"table mod\" message in '*oh' into an abstract form in\n * '*pm'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_table_mod(const struct ofp_header *oh,\n                         struct ofputil_table_mod *pm)\n{\n    memset(pm, 0, sizeof *pm);\n    pm->miss = OFPUTIL_TABLE_MISS_DEFAULT;\n    pm->eviction = OFPUTIL_TABLE_EVICTION_DEFAULT;\n    pm->eviction_flags = UINT32_MAX;\n    pm->vacancy = OFPUTIL_TABLE_VACANCY_DEFAULT;\n\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT11_TABLE_MOD) {\n        const struct ofp11_table_mod *otm = b.data;\n\n        pm->table_id = otm->table_id;\n        pm->miss = ofputil_decode_table_miss(otm->config, oh->version);\n    } else if (raw == OFPRAW_OFPT14_TABLE_MOD) {\n        const struct ofp14_table_mod *otm = ofpbuf_pull(&b, sizeof *otm);\n\n        pm->table_id = otm->table_id;\n        pm->miss = ofputil_decode_table_miss(otm->config, oh->version);\n        pm->eviction = ofputil_decode_table_eviction(otm->config, oh->version);\n        pm->vacancy = ofputil_decode_table_vacancy(otm->config, oh->version);\n        while (b.size > 0) {\n            struct ofpbuf property;\n            enum ofperr error;\n            uint64_t type;\n\n            error = ofpprop_pull(&b, &property, &type);\n            if (error) {\n                return error;\n            }\n\n            switch (type) {\n            case OFPTMPT14_EVICTION:\n                error = ofpprop_parse_u32(&property, &pm->eviction);\n                break;\n\n            case OFPTMPT14_VACANCY:\n                error = parse_table_mod_vacancy_property(&property, pm);\n                break;\n\n            default:\n                error = OFPERR_OFPBRC_BAD_TYPE;\n                break;\n            }\n\n            if (error) {\n                return error;\n            }\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_TYPE;\n    }\n\n    return 0;\n}\n\n/* Converts the abstract form of a \"table mod\" message in '*tm' into an\n * OpenFlow message suitable for 'protocol', and returns that encoded form in a\n * buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_table_mod(const struct ofputil_table_mod *tm,\n                        enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *b;\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        ovs_fatal(0, \"table mod needs OpenFlow 1.1 or later \"\n                     \"(\\'-O OpenFlow11\\')\");\n        break;\n    }\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        struct ofp11_table_mod *otm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT11_TABLE_MOD, ofp_version, 0);\n        otm = ofpbuf_put_zeros(b, sizeof *otm);\n        otm->table_id = tm->table_id;\n        otm->config = ofputil_encode_table_config(tm->miss, tm->eviction,\n                                                  tm->vacancy, ofp_version);\n        break;\n    }\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp14_table_mod *otm;\n\n        b = ofpraw_alloc(OFPRAW_OFPT14_TABLE_MOD, ofp_version, 0);\n        otm = ofpbuf_put_zeros(b, sizeof *otm);\n        otm->table_id = tm->table_id;\n        otm->config = ofputil_encode_table_config(tm->miss, tm->eviction,\n                                                  tm->vacancy, ofp_version);\n\n        if (tm->eviction_flags != UINT32_MAX) {\n            ofpprop_put_u32(b, OFPTMPT14_EVICTION, tm->eviction_flags);\n        }\n        if (tm->vacancy == OFPUTIL_TABLE_VACANCY_ON) {\n            struct ofp14_table_mod_prop_vacancy *otv;\n\n            otv = ofpprop_put_zeros(b, OFPTMPT14_VACANCY, sizeof *otv);\n            otv->vacancy_down = tm->table_vacancy.vacancy_down;\n            otv->vacancy_up = tm->table_vacancy.vacancy_up;\n        }\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return b;\n}\n\f\n/* ofputil_role_request */\n\n/* Decodes the OpenFlow \"role request\" or \"role reply\" message in '*oh' into\n * an abstract form in '*rr'.  Returns 0 if successful, otherwise an\n * OFPERR_* value. */\nenum ofperr\nofputil_decode_role_message(const struct ofp_header *oh,\n                            struct ofputil_role_request *rr)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT12_ROLE_REQUEST ||\n        raw == OFPRAW_OFPT12_ROLE_REPLY) {\n        const struct ofp12_role_request *orr = b.msg;\n\n        if (orr->role != htonl(OFPCR12_ROLE_NOCHANGE) &&\n            orr->role != htonl(OFPCR12_ROLE_EQUAL) &&\n            orr->role != htonl(OFPCR12_ROLE_MASTER) &&\n            orr->role != htonl(OFPCR12_ROLE_SLAVE)) {\n            return OFPERR_OFPRRFC_BAD_ROLE;\n        }\n\n        rr->role = ntohl(orr->role);\n        if (raw == OFPRAW_OFPT12_ROLE_REQUEST\n            ? orr->role == htonl(OFPCR12_ROLE_NOCHANGE)\n            : orr->generation_id == OVS_BE64_MAX) {\n            rr->have_generation_id = false;\n            rr->generation_id = 0;\n        } else {\n            rr->have_generation_id = true;\n            rr->generation_id = ntohll(orr->generation_id);\n        }\n    } else if (raw == OFPRAW_NXT_ROLE_REQUEST ||\n               raw == OFPRAW_NXT_ROLE_REPLY) {\n        const struct nx_role_request *nrr = b.msg;\n\n        BUILD_ASSERT(NX_ROLE_OTHER + 1 == OFPCR12_ROLE_EQUAL);\n        BUILD_ASSERT(NX_ROLE_MASTER + 1 == OFPCR12_ROLE_MASTER);\n        BUILD_ASSERT(NX_ROLE_SLAVE + 1 == OFPCR12_ROLE_SLAVE);\n\n        if (nrr->role != htonl(NX_ROLE_OTHER) &&\n            nrr->role != htonl(NX_ROLE_MASTER) &&\n            nrr->role != htonl(NX_ROLE_SLAVE)) {\n            return OFPERR_OFPRRFC_BAD_ROLE;\n        }\n\n        rr->role = ntohl(nrr->role) + 1;\n        rr->have_generation_id = false;\n        rr->generation_id = 0;\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    return 0;\n}\n\n/* Returns an encoded form of a role reply suitable for the \"request\" in a\n * buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_role_reply(const struct ofp_header *request,\n                          const struct ofputil_role_request *rr)\n{\n    struct ofpbuf *buf;\n    enum ofpraw raw;\n\n    raw = ofpraw_decode_assert(request);\n    if (raw == OFPRAW_OFPT12_ROLE_REQUEST) {\n        struct ofp12_role_request *orr;\n\n        buf = ofpraw_alloc_reply(OFPRAW_OFPT12_ROLE_REPLY, request, 0);\n        orr = ofpbuf_put_zeros(buf, sizeof *orr);\n\n        orr->role = htonl(rr->role);\n        orr->generation_id = htonll(rr->have_generation_id\n                                    ? rr->generation_id\n                                    : UINT64_MAX);\n    } else if (raw == OFPRAW_NXT_ROLE_REQUEST) {\n        struct nx_role_request *nrr;\n\n        BUILD_ASSERT(NX_ROLE_OTHER == OFPCR12_ROLE_EQUAL - 1);\n        BUILD_ASSERT(NX_ROLE_MASTER == OFPCR12_ROLE_MASTER - 1);\n        BUILD_ASSERT(NX_ROLE_SLAVE == OFPCR12_ROLE_SLAVE - 1);\n\n        buf = ofpraw_alloc_reply(OFPRAW_NXT_ROLE_REPLY, request, 0);\n        nrr = ofpbuf_put_zeros(buf, sizeof *nrr);\n        nrr->role = htonl(rr->role - 1);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    return buf;\n}\n\f\n/* Encodes \"role status\" message 'status' for sending in the given\n * 'protocol'.  Returns the role status message, if 'protocol' supports them,\n * otherwise a null pointer. */\nstruct ofpbuf *\nofputil_encode_role_status(const struct ofputil_role_status *status,\n                           enum ofputil_protocol protocol)\n{\n    enum ofp_version version;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    if (version >= OFP14_VERSION) {\n        struct ofp14_role_status *rstatus;\n        struct ofpbuf *buf;\n\n        buf = ofpraw_alloc_xid(OFPRAW_OFPT14_ROLE_STATUS, version, htonl(0),\n                               0);\n        rstatus = ofpbuf_put_zeros(buf, sizeof *rstatus);\n        rstatus->role = htonl(status->role);\n        rstatus->reason = status->reason;\n        rstatus->generation_id = htonll(status->generation_id);\n\n        return buf;\n    } else {\n        return NULL;\n    }\n}\n\nenum ofperr\nofputil_decode_role_status(const struct ofp_header *oh,\n                           struct ofputil_role_status *rs)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    ovs_assert(raw == OFPRAW_OFPT14_ROLE_STATUS);\n\n    const struct ofp14_role_status *r = b.msg;\n    if (r->role != htonl(OFPCR12_ROLE_NOCHANGE) &&\n        r->role != htonl(OFPCR12_ROLE_EQUAL) &&\n        r->role != htonl(OFPCR12_ROLE_MASTER) &&\n        r->role != htonl(OFPCR12_ROLE_SLAVE)) {\n        return OFPERR_OFPRRFC_BAD_ROLE;\n    }\n\n    rs->role = ntohl(r->role);\n    rs->generation_id = ntohll(r->generation_id);\n    rs->reason = r->reason;\n\n    return 0;\n}\n\n/* Encodes 'rf' according to 'protocol', and returns the encoded message.\n * 'protocol' must be for OpenFlow 1.4 or later. */\nstruct ofpbuf *\nofputil_encode_requestforward(const struct ofputil_requestforward *rf,\n                              enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *inner;\n\n    switch (rf->reason) {\n    case OFPRFR_GROUP_MOD:\n        inner = ofputil_encode_group_mod(ofp_version, rf->group_mod);\n        break;\n\n    case OFPRFR_METER_MOD:\n        inner = ofputil_encode_meter_mod(ofp_version, rf->meter_mod);\n        break;\n\n    case OFPRFR_N_REASONS:\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    struct ofp_header *inner_oh = inner->data;\n    inner_oh->xid = rf->xid;\n    inner_oh->length = htons(inner->size);\n\n    struct ofpbuf *outer = ofpraw_alloc_xid(OFPRAW_OFPT14_REQUESTFORWARD,\n                                            ofp_version, htonl(0),\n                                            inner->size);\n    ofpbuf_put(outer, inner->data, inner->size);\n    ofpbuf_delete(inner);\n\n    return outer;\n}\n\n/* Decodes OFPT_REQUESTFORWARD message 'outer'.  On success, puts the decoded\n * form into '*rf' and returns 0, and the caller is later responsible for\n * freeing the content of 'rf', with ofputil_destroy_requestforward(rf).  On\n * failure, returns an ofperr and '*rf' is indeterminate. */\nenum ofperr\nofputil_decode_requestforward(const struct ofp_header *outer,\n                              struct ofputil_requestforward *rf)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(outer, ntohs(outer->length));\n\n    /* Skip past outer message. */\n    enum ofpraw outer_raw = ofpraw_pull_assert(&b);\n    ovs_assert(outer_raw == OFPRAW_OFPT14_REQUESTFORWARD);\n\n    /* Validate inner message. */\n    if (b.size < sizeof(struct ofp_header)) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    const struct ofp_header *inner = b.data;\n    unsigned int inner_len = ntohs(inner->length);\n    if (inner_len < sizeof(struct ofp_header) || inner_len > b.size) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    if (inner->version != outer->version) {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n\n    /* Parse inner message. */\n    enum ofptype type;\n    enum ofperr error = ofptype_decode(&type, inner);\n    if (error) {\n        return error;\n    }\n\n    rf->xid = inner->xid;\n    if (type == OFPTYPE_GROUP_MOD) {\n        rf->reason = OFPRFR_GROUP_MOD;\n        rf->group_mod = xmalloc(sizeof *rf->group_mod);\n        error = ofputil_decode_group_mod(inner, rf->group_mod);\n        if (error) {\n            free(rf->group_mod);\n            return error;\n        }\n    } else if (type == OFPTYPE_METER_MOD) {\n        rf->reason = OFPRFR_METER_MOD;\n        rf->meter_mod = xmalloc(sizeof *rf->meter_mod);\n        ofpbuf_init(&rf->bands, 64);\n        error = ofputil_decode_meter_mod(inner, rf->meter_mod, &rf->bands);\n        if (error) {\n            free(rf->meter_mod);\n            ofpbuf_uninit(&rf->bands);\n            return error;\n        }\n    } else {\n        return OFPERR_OFPBFC_MSG_UNSUP;\n    }\n\n    return 0;\n}\n\n/* Frees the content of 'rf', which should have been initialized through a\n * successful call to ofputil_decode_requestforward(). */\nvoid\nofputil_destroy_requestforward(struct ofputil_requestforward *rf)\n{\n    if (!rf) {\n        return;\n    }\n\n    switch (rf->reason) {\n    case OFPRFR_GROUP_MOD:\n        ofputil_uninit_group_mod(rf->group_mod);\n        free(rf->group_mod);\n        break;\n\n    case OFPRFR_METER_MOD:\n        ofpbuf_uninit(&rf->bands);\n        free(rf->meter_mod);\n        break;\n\n    case OFPRFR_N_REASONS:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Table stats. */\n\n/* OpenFlow 1.0 and 1.1 don't distinguish between a field that cannot be\n * matched and a field that must be wildcarded.  This function returns a bitmap\n * that contains both kinds of fields. */\nstatic struct mf_bitmap\nwild_or_nonmatchable_fields(const struct ofputil_table_features *features)\n{\n    struct mf_bitmap wc = features->match;\n    bitmap_not(wc.bm, MFF_N_IDS);\n    bitmap_or(wc.bm, features->wildcard.bm, MFF_N_IDS);\n    return wc;\n}\n\nstruct ofp10_wc_map {\n    enum ofp10_flow_wildcards wc10;\n    enum mf_field_id mf;\n};\n\nstatic const struct ofp10_wc_map ofp10_wc_map[] = {\n    { OFPFW10_IN_PORT,     MFF_IN_PORT },\n    { OFPFW10_DL_VLAN,     MFF_VLAN_VID },\n    { OFPFW10_DL_SRC,      MFF_ETH_SRC },\n    { OFPFW10_DL_DST,      MFF_ETH_DST},\n    { OFPFW10_DL_TYPE,     MFF_ETH_TYPE },\n    { OFPFW10_NW_PROTO,    MFF_IP_PROTO },\n    { OFPFW10_TP_SRC,      MFF_TCP_SRC },\n    { OFPFW10_TP_DST,      MFF_TCP_DST },\n    { OFPFW10_NW_SRC_MASK, MFF_IPV4_SRC },\n    { OFPFW10_NW_DST_MASK, MFF_IPV4_DST },\n    { OFPFW10_DL_VLAN_PCP, MFF_VLAN_PCP },\n    { OFPFW10_NW_TOS,      MFF_IP_DSCP },\n};\n\nstatic ovs_be32\nmf_bitmap_to_of10(const struct mf_bitmap *fields)\n{\n    const struct ofp10_wc_map *p;\n    uint32_t wc10 = 0;\n\n    for (p = ofp10_wc_map; p < &ofp10_wc_map[ARRAY_SIZE(ofp10_wc_map)]; p++) {\n        if (bitmap_is_set(fields->bm, p->mf)) {\n            wc10 |= p->wc10;\n        }\n    }\n    return htonl(wc10);\n}\n\nstatic struct mf_bitmap\nmf_bitmap_from_of10(ovs_be32 wc10_)\n{\n    struct mf_bitmap fields = MF_BITMAP_INITIALIZER;\n    const struct ofp10_wc_map *p;\n    uint32_t wc10 = ntohl(wc10_);\n\n    for (p = ofp10_wc_map; p < &ofp10_wc_map[ARRAY_SIZE(ofp10_wc_map)]; p++) {\n        if (wc10 & p->wc10) {\n            bitmap_set1(fields.bm, p->mf);\n        }\n    }\n    return fields;\n}\n\nstatic void\nofputil_put_ofp10_table_stats(const struct ofputil_table_stats *stats,\n                              const struct ofputil_table_features *features,\n                              struct ofpbuf *buf)\n{\n    struct mf_bitmap wc = wild_or_nonmatchable_fields(features);\n    struct ofp10_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = features->table_id;\n    ovs_strlcpy(out->name, features->name, sizeof out->name);\n    out->wildcards = mf_bitmap_to_of10(&wc);\n    out->max_entries = htonl(features->max_entries);\n    out->active_count = htonl(stats->active_count);\n    put_32aligned_be64(&out->lookup_count, htonll(stats->lookup_count));\n    put_32aligned_be64(&out->matched_count, htonll(stats->matched_count));\n}\n\nstruct ofp11_wc_map {\n    enum ofp11_flow_match_fields wc11;\n    enum mf_field_id mf;\n};\n\nstatic const struct ofp11_wc_map ofp11_wc_map[] = {\n    { OFPFMF11_IN_PORT,     MFF_IN_PORT },\n    { OFPFMF11_DL_VLAN,     MFF_VLAN_VID },\n    { OFPFMF11_DL_VLAN_PCP, MFF_VLAN_PCP },\n    { OFPFMF11_DL_TYPE,     MFF_ETH_TYPE },\n    { OFPFMF11_NW_TOS,      MFF_IP_DSCP },\n    { OFPFMF11_NW_PROTO,    MFF_IP_PROTO },\n    { OFPFMF11_TP_SRC,      MFF_TCP_SRC },\n    { OFPFMF11_TP_DST,      MFF_TCP_DST },\n    { OFPFMF11_MPLS_LABEL,  MFF_MPLS_LABEL },\n    { OFPFMF11_MPLS_TC,     MFF_MPLS_TC },\n    /* I don't know what OFPFMF11_TYPE means. */\n    { OFPFMF11_DL_SRC,      MFF_ETH_SRC },\n    { OFPFMF11_DL_DST,      MFF_ETH_DST },\n    { OFPFMF11_NW_SRC,      MFF_IPV4_SRC },\n    { OFPFMF11_NW_DST,      MFF_IPV4_DST },\n    { OFPFMF11_METADATA,    MFF_METADATA },\n};\n\nstatic ovs_be32\nmf_bitmap_to_of11(const struct mf_bitmap *fields)\n{\n    const struct ofp11_wc_map *p;\n    uint32_t wc11 = 0;\n\n    for (p = ofp11_wc_map; p < &ofp11_wc_map[ARRAY_SIZE(ofp11_wc_map)]; p++) {\n        if (bitmap_is_set(fields->bm, p->mf)) {\n            wc11 |= p->wc11;\n        }\n    }\n    return htonl(wc11);\n}\n\nstatic struct mf_bitmap\nmf_bitmap_from_of11(ovs_be32 wc11_)\n{\n    struct mf_bitmap fields = MF_BITMAP_INITIALIZER;\n    const struct ofp11_wc_map *p;\n    uint32_t wc11 = ntohl(wc11_);\n\n    for (p = ofp11_wc_map; p < &ofp11_wc_map[ARRAY_SIZE(ofp11_wc_map)]; p++) {\n        if (wc11 & p->wc11) {\n            bitmap_set1(fields.bm, p->mf);\n        }\n    }\n    return fields;\n}\n\nstatic void\nofputil_put_ofp11_table_stats(const struct ofputil_table_stats *stats,\n                              const struct ofputil_table_features *features,\n                              struct ofpbuf *buf)\n{\n    struct mf_bitmap wc = wild_or_nonmatchable_fields(features);\n    struct ofp11_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = features->table_id;\n    ovs_strlcpy(out->name, features->name, sizeof out->name);\n    out->wildcards = mf_bitmap_to_of11(&wc);\n    out->match = mf_bitmap_to_of11(&features->match);\n    out->instructions = ovsinst_bitmap_to_openflow(\n        features->nonmiss.instructions, OFP11_VERSION);\n    out->write_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.write.ofpacts, OFP11_VERSION);\n    out->apply_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.apply.ofpacts, OFP11_VERSION);\n    out->config = htonl(features->miss_config);\n    out->max_entries = htonl(features->max_entries);\n    out->active_count = htonl(stats->active_count);\n    out->lookup_count = htonll(stats->lookup_count);\n    out->matched_count = htonll(stats->matched_count);\n}\n\nstatic void\nofputil_put_ofp12_table_stats(const struct ofputil_table_stats *stats,\n                              const struct ofputil_table_features *features,\n                              struct ofpbuf *buf)\n{\n    struct ofp12_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = features->table_id;\n    ovs_strlcpy(out->name, features->name, sizeof out->name);\n    out->match = oxm_bitmap_from_mf_bitmap(&features->match, OFP12_VERSION);\n    out->wildcards = oxm_bitmap_from_mf_bitmap(&features->wildcard,\n                                             OFP12_VERSION);\n    out->write_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.write.ofpacts, OFP12_VERSION);\n    out->apply_actions = ofpact_bitmap_to_openflow(\n        features->nonmiss.apply.ofpacts, OFP12_VERSION);\n    out->write_setfields = oxm_bitmap_from_mf_bitmap(\n        &features->nonmiss.write.set_fields, OFP12_VERSION);\n    out->apply_setfields = oxm_bitmap_from_mf_bitmap(\n        &features->nonmiss.apply.set_fields, OFP12_VERSION);\n    out->metadata_match = features->metadata_match;\n    out->metadata_write = features->metadata_write;\n    out->instructions = ovsinst_bitmap_to_openflow(\n        features->nonmiss.instructions, OFP12_VERSION);\n    out->config = ofputil_encode_table_config(features->miss_config,\n                                              OFPUTIL_TABLE_EVICTION_DEFAULT,\n                                              OFPUTIL_TABLE_VACANCY_DEFAULT,\n                                              OFP12_VERSION);\n    out->max_entries = htonl(features->max_entries);\n    out->active_count = htonl(stats->active_count);\n    out->lookup_count = htonll(stats->lookup_count);\n    out->matched_count = htonll(stats->matched_count);\n}\n\nstatic void\nofputil_put_ofp13_table_stats(const struct ofputil_table_stats *stats,\n                              struct ofpbuf *buf)\n{\n    struct ofp13_table_stats *out;\n\n    out = ofpbuf_put_zeros(buf, sizeof *out);\n    out->table_id = stats->table_id;\n    out->active_count = htonl(stats->active_count);\n    out->lookup_count = htonll(stats->lookup_count);\n    out->matched_count = htonll(stats->matched_count);\n}\n\nstruct ofpbuf *\nofputil_encode_table_stats_reply(const struct ofp_header *request)\n{\n    return ofpraw_alloc_stats_reply(request, 0);\n}\n\nvoid\nofputil_append_table_stats_reply(struct ofpbuf *reply,\n                                 const struct ofputil_table_stats *stats,\n                                 const struct ofputil_table_features *features)\n{\n    struct ofp_header *oh = reply->header;\n\n    ovs_assert(stats->table_id == features->table_id);\n\n    switch ((enum ofp_version) oh->version) {\n    case OFP10_VERSION:\n        ofputil_put_ofp10_table_stats(stats, features, reply);\n        break;\n\n    case OFP11_VERSION:\n        ofputil_put_ofp11_table_stats(stats, features, reply);\n        break;\n\n    case OFP12_VERSION:\n        ofputil_put_ofp12_table_stats(stats, features, reply);\n        break;\n\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_put_ofp13_table_stats(stats, reply);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic int\nofputil_decode_ofp10_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp10_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n    ovs_strlcpy(features->name, ots->name, sizeof features->name);\n    features->max_entries = ntohl(ots->max_entries);\n    features->match = features->wildcard = mf_bitmap_from_of10(ots->wildcards);\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(get_32aligned_be64(&ots->lookup_count));\n    stats->matched_count = ntohll(get_32aligned_be64(&ots->matched_count));\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp11_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp11_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n    ovs_strlcpy(features->name, ots->name, sizeof features->name);\n    features->max_entries = ntohl(ots->max_entries);\n    features->nonmiss.instructions = ovsinst_bitmap_from_openflow(\n        ots->instructions, OFP11_VERSION);\n    features->nonmiss.write.ofpacts = ofpact_bitmap_from_openflow(\n        ots->write_actions, OFP11_VERSION);\n    features->nonmiss.apply.ofpacts = ofpact_bitmap_from_openflow(\n        ots->write_actions, OFP11_VERSION);\n    features->miss = features->nonmiss;\n    features->miss_config = ofputil_decode_table_miss(ots->config,\n                                                      OFP11_VERSION);\n    features->match = mf_bitmap_from_of11(ots->match);\n    features->wildcard = mf_bitmap_from_of11(ots->wildcards);\n    bitmap_or(features->match.bm, features->wildcard.bm, MFF_N_IDS);\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp12_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp12_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n    ovs_strlcpy(features->name, ots->name, sizeof features->name);\n    features->metadata_match = ots->metadata_match;\n    features->metadata_write = ots->metadata_write;\n    features->miss_config = ofputil_decode_table_miss(ots->config,\n                                                      OFP12_VERSION);\n    features->max_entries = ntohl(ots->max_entries);\n\n    features->nonmiss.instructions = ovsinst_bitmap_from_openflow(\n        ots->instructions, OFP12_VERSION);\n    features->nonmiss.write.ofpacts = ofpact_bitmap_from_openflow(\n        ots->write_actions, OFP12_VERSION);\n    features->nonmiss.apply.ofpacts = ofpact_bitmap_from_openflow(\n        ots->apply_actions, OFP12_VERSION);\n    features->nonmiss.write.set_fields = oxm_bitmap_to_mf_bitmap(\n        ots->write_setfields, OFP12_VERSION);\n    features->nonmiss.apply.set_fields = oxm_bitmap_to_mf_bitmap(\n        ots->apply_setfields, OFP12_VERSION);\n    features->miss = features->nonmiss;\n\n    features->match = oxm_bitmap_to_mf_bitmap(ots->match, OFP12_VERSION);\n    features->wildcard = oxm_bitmap_to_mf_bitmap(ots->wildcards,\n                                                 OFP12_VERSION);\n    bitmap_or(features->match.bm, features->wildcard.bm, MFF_N_IDS);\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp13_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp13_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n\nint\nofputil_decode_table_stats_reply(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    const struct ofp_header *oh;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n    oh = msg->header;\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    memset(stats, 0, sizeof *stats);\n    memset(features, 0, sizeof *features);\n    features->supports_eviction = -1;\n    features->supports_vacancy_events = -1;\n\n    switch ((enum ofp_version) oh->version) {\n    case OFP10_VERSION:\n        return ofputil_decode_ofp10_table_stats(msg, stats, features);\n\n    case OFP11_VERSION:\n        return ofputil_decode_ofp11_table_stats(msg, stats, features);\n\n    case OFP12_VERSION:\n        return ofputil_decode_ofp12_table_stats(msg, stats, features);\n\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return ofputil_decode_ofp13_table_stats(msg, stats, features);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\f\n/* ofputil_flow_monitor_request */\n\n/* Converts an NXST_FLOW_MONITOR request in 'msg' into an abstract\n * ofputil_flow_monitor_request in 'rq'.\n *\n * Multiple NXST_FLOW_MONITOR requests can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the requests.  The caller must initially leave 'msg''s layer\n * pointers null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no requests were left in this 'msg',\n * otherwise an OFPERR_* value. */\nint\nofputil_decode_flow_monitor_request(struct ofputil_flow_monitor_request *rq,\n                                    struct ofpbuf *msg)\n{\n    struct nx_flow_monitor_request *nfmr;\n    uint16_t flags;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    nfmr = ofpbuf_try_pull(msg, sizeof *nfmr);\n    if (!nfmr) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW_MONITOR request has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    flags = ntohs(nfmr->flags);\n    if (!(flags & (NXFMF_ADD | NXFMF_DELETE | NXFMF_MODIFY))\n        || flags & ~(NXFMF_INITIAL | NXFMF_ADD | NXFMF_DELETE\n                     | NXFMF_MODIFY | NXFMF_ACTIONS | NXFMF_OWN)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW_MONITOR has bad flags %#\"PRIx16,\n                     flags);\n        return OFPERR_OFPMOFC_BAD_FLAGS;\n    }\n\n    if (!is_all_zeros(nfmr->zeros, sizeof nfmr->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    rq->id = ntohl(nfmr->id);\n    rq->flags = flags;\n    rq->out_port = u16_to_ofp(ntohs(nfmr->out_port));\n    rq->table_id = nfmr->table_id;\n\n    return nx_pull_match(msg, ntohs(nfmr->match_len), &rq->match, NULL,\n                         NULL, NULL, NULL);\n}\n\nvoid\nofputil_append_flow_monitor_request(\n    const struct ofputil_flow_monitor_request *rq, struct ofpbuf *msg)\n{\n    struct nx_flow_monitor_request *nfmr;\n    size_t start_ofs;\n    int match_len;\n\n    if (!msg->size) {\n        ofpraw_put(OFPRAW_NXST_FLOW_MONITOR_REQUEST, OFP10_VERSION, msg);\n    }\n\n    start_ofs = msg->size;\n    ofpbuf_put_zeros(msg, sizeof *nfmr);\n    match_len = nx_put_match(msg, &rq->match, htonll(0), htonll(0));\n\n    nfmr = ofpbuf_at_assert(msg, start_ofs, sizeof *nfmr);\n    nfmr->id = htonl(rq->id);\n    nfmr->flags = htons(rq->flags);\n    nfmr->out_port = htons(ofp_to_u16(rq->out_port));\n    nfmr->match_len = htons(match_len);\n    nfmr->table_id = rq->table_id;\n}\n\n/* Converts an NXST_FLOW_MONITOR reply (also known as a flow update) in 'msg'\n * into an abstract ofputil_flow_update in 'update'.  The caller must have\n * initialized update->match to point to space allocated for a match.\n *\n * Uses 'ofpacts' to store the abstract OFPACT_* version of the update's\n * actions (except for NXFME_ABBREV, which never includes actions).  The caller\n * must initialize 'ofpacts' and retains ownership of it.  'update->ofpacts'\n * will point into the 'ofpacts' buffer.\n *\n * Multiple flow updates can be packed into a single OpenFlow message.  Calling\n * this function multiple times for a single 'msg' iterates through the\n * updates.  The caller must initially leave 'msg''s layer pointers null and\n * not modify them between calls.\n *\n * Returns 0 if successful, EOF if no updates were left in this 'msg',\n * otherwise an OFPERR_* value. */\nint\nofputil_decode_flow_update(struct ofputil_flow_update *update,\n                           struct ofpbuf *msg, struct ofpbuf *ofpacts)\n{\n    struct nx_flow_update_header *nfuh;\n    unsigned int length;\n    struct ofp_header *oh;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    ofpbuf_clear(ofpacts);\n    if (!msg->size) {\n        return EOF;\n    }\n\n    if (msg->size < sizeof(struct nx_flow_update_header)) {\n        goto bad_len;\n    }\n\n    oh = msg->header;\n\n    nfuh = msg->data;\n    update->event = ntohs(nfuh->event);\n    length = ntohs(nfuh->length);\n    if (length > msg->size || length % 8) {\n        goto bad_len;\n    }\n\n    if (update->event == NXFME_ABBREV) {\n        struct nx_flow_update_abbrev *nfua;\n\n        if (length != sizeof *nfua) {\n            goto bad_len;\n        }\n\n        nfua = ofpbuf_pull(msg, sizeof *nfua);\n        update->xid = nfua->xid;\n        return 0;\n    } else if (update->event == NXFME_ADDED\n               || update->event == NXFME_DELETED\n               || update->event == NXFME_MODIFIED) {\n        struct nx_flow_update_full *nfuf;\n        unsigned int actions_len;\n        unsigned int match_len;\n        enum ofperr error;\n\n        if (length < sizeof *nfuf) {\n            goto bad_len;\n        }\n\n        nfuf = ofpbuf_pull(msg, sizeof *nfuf);\n        match_len = ntohs(nfuf->match_len);\n        if (sizeof *nfuf + match_len > length) {\n            goto bad_len;\n        }\n\n        update->reason = ntohs(nfuf->reason);\n        update->idle_timeout = ntohs(nfuf->idle_timeout);\n        update->hard_timeout = ntohs(nfuf->hard_timeout);\n        update->table_id = nfuf->table_id;\n        update->cookie = nfuf->cookie;\n        update->priority = ntohs(nfuf->priority);\n\n        error = nx_pull_match(msg, match_len, &update->match, NULL, NULL, NULL,\n                              NULL);\n        if (error) {\n            return error;\n        }\n\n        actions_len = length - sizeof *nfuf - ROUND_UP(match_len, 8);\n        error = ofpacts_pull_openflow_actions(msg, actions_len, oh->version,\n                                              NULL, NULL, ofpacts);\n        if (error) {\n            return error;\n        }\n\n        update->ofpacts = ofpacts->data;\n        update->ofpacts_len = ofpacts->size;\n        return 0;\n    } else {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"NXST_FLOW_MONITOR reply has bad event %\"PRIu16,\n                     ntohs(nfuh->event));\n        return OFPERR_NXBRC_FM_BAD_EVENT;\n    }\n\nbad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW_MONITOR reply has %\"PRIu32\" \"\n                 \"leftover bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n\nuint32_t\nofputil_decode_flow_monitor_cancel(const struct ofp_header *oh)\n{\n    const struct nx_flow_monitor_cancel *cancel = ofpmsg_body(oh);\n\n    return ntohl(cancel->id);\n}\n\nstruct ofpbuf *\nofputil_encode_flow_monitor_cancel(uint32_t id)\n{\n    struct nx_flow_monitor_cancel *nfmc;\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc(OFPRAW_NXT_FLOW_MONITOR_CANCEL, OFP10_VERSION, 0);\n    nfmc = ofpbuf_put_uninit(msg, sizeof *nfmc);\n    nfmc->id = htonl(id);\n    return msg;\n}\n\nvoid\nofputil_start_flow_update(struct ovs_list *replies)\n{\n    struct ofpbuf *msg;\n\n    msg = ofpraw_alloc_xid(OFPRAW_NXST_FLOW_MONITOR_REPLY, OFP10_VERSION,\n                           htonl(0), 1024);\n\n    ovs_list_init(replies);\n    ovs_list_push_back(replies, &msg->list_node);\n}\n\nvoid\nofputil_append_flow_update(const struct ofputil_flow_update *update,\n                           struct ovs_list *replies,\n                           const struct tun_table *tun_table)\n{\n    struct ofputil_flow_update *update_ =\n        CONST_CAST(struct ofputil_flow_update *, update);\n    const struct tun_table *orig_tun_table;\n    enum ofp_version version = ofpmp_version(replies);\n    struct nx_flow_update_header *nfuh;\n    struct ofpbuf *msg;\n    size_t start_ofs;\n\n    orig_tun_table = update->match.flow.tunnel.metadata.tab;\n    update_->match.flow.tunnel.metadata.tab = tun_table;\n\n    msg = ofpbuf_from_list(ovs_list_back(replies));\n    start_ofs = msg->size;\n\n    if (update->event == NXFME_ABBREV) {\n        struct nx_flow_update_abbrev *nfua;\n\n        nfua = ofpbuf_put_zeros(msg, sizeof *nfua);\n        nfua->xid = update->xid;\n    } else {\n        struct nx_flow_update_full *nfuf;\n        int match_len;\n\n        ofpbuf_put_zeros(msg, sizeof *nfuf);\n        match_len = nx_put_match(msg, &update->match, htonll(0), htonll(0));\n        ofpacts_put_openflow_actions(update->ofpacts, update->ofpacts_len, msg,\n                                     version);\n        nfuf = ofpbuf_at_assert(msg, start_ofs, sizeof *nfuf);\n        nfuf->reason = htons(update->reason);\n        nfuf->priority = htons(update->priority);\n        nfuf->idle_timeout = htons(update->idle_timeout);\n        nfuf->hard_timeout = htons(update->hard_timeout);\n        nfuf->match_len = htons(match_len);\n        nfuf->table_id = update->table_id;\n        nfuf->cookie = update->cookie;\n    }\n\n    nfuh = ofpbuf_at_assert(msg, start_ofs, sizeof *nfuh);\n    nfuh->length = htons(msg->size - start_ofs);\n    nfuh->event = htons(update->event);\n\n    ofpmp_postappend(replies, start_ofs);\n    update_->match.flow.tunnel.metadata.tab = orig_tun_table;\n}\n\f\nstruct ofpbuf *\nofputil_encode_packet_out(const struct ofputil_packet_out *po,\n                          enum ofputil_protocol protocol)\n{\n    enum ofp_version ofp_version = ofputil_protocol_to_ofp_version(protocol);\n    struct ofpbuf *msg;\n    size_t size;\n\n    size = po->ofpacts_len;\n    if (po->buffer_id == UINT32_MAX) {\n        size += po->packet_len;\n    }\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_packet_out *opo;\n        size_t actions_ofs;\n\n        msg = ofpraw_alloc(OFPRAW_OFPT10_PACKET_OUT, OFP10_VERSION, size);\n        ofpbuf_put_zeros(msg, sizeof *opo);\n        actions_ofs = msg->size;\n        ofpacts_put_openflow_actions(po->ofpacts, po->ofpacts_len, msg,\n                                     ofp_version);\n\n        opo = msg->msg;\n        opo->buffer_id = htonl(po->buffer_id);\n        opo->in_port = htons(ofp_to_u16(po->in_port));\n        opo->actions_len = htons(msg->size - actions_ofs);\n        break;\n    }\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_packet_out *opo;\n        size_t len;\n\n        msg = ofpraw_alloc(OFPRAW_OFPT11_PACKET_OUT, ofp_version, size);\n        ofpbuf_put_zeros(msg, sizeof *opo);\n        len = ofpacts_put_openflow_actions(po->ofpacts, po->ofpacts_len, msg,\n                                           ofp_version);\n        opo = msg->msg;\n        opo->buffer_id = htonl(po->buffer_id);\n        opo->in_port = ofputil_port_to_ofp11(po->in_port);\n        opo->actions_len = htons(len);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (po->buffer_id == UINT32_MAX) {\n        ofpbuf_put(msg, po->packet, po->packet_len);\n    }\n\n    ofpmsg_update_length(msg);\n\n    return msg;\n}\n\f\n/* Creates and returns an OFPT_ECHO_REQUEST message with an empty payload. */\nstruct ofpbuf *\nmake_echo_request(enum ofp_version ofp_version)\n{\n    return ofpraw_alloc_xid(OFPRAW_OFPT_ECHO_REQUEST, ofp_version,\n                            htonl(0), 0);\n}\n\n/* Creates and returns an OFPT_ECHO_REPLY message matching the\n * OFPT_ECHO_REQUEST message in 'rq'. */\nstruct ofpbuf *\nmake_echo_reply(const struct ofp_header *rq)\n{\n    struct ofpbuf rq_buf = ofpbuf_const_initializer(rq, ntohs(rq->length));\n    ofpraw_pull_assert(&rq_buf);\n\n    struct ofpbuf *reply = ofpraw_alloc_reply(OFPRAW_OFPT_ECHO_REPLY,\n                                              rq, rq_buf.size);\n    ofpbuf_put(reply, rq_buf.data, rq_buf.size);\n    return reply;\n}\n\nstruct ofpbuf *\nofputil_encode_barrier_request(enum ofp_version ofp_version)\n{\n    enum ofpraw type;\n\n    switch (ofp_version) {\n    case OFP16_VERSION:\n    case OFP15_VERSION:\n    case OFP14_VERSION:\n    case OFP13_VERSION:\n    case OFP12_VERSION:\n    case OFP11_VERSION:\n        type = OFPRAW_OFPT11_BARRIER_REQUEST;\n        break;\n\n    case OFP10_VERSION:\n        type = OFPRAW_OFPT10_BARRIER_REQUEST;\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return ofpraw_alloc(type, ofp_version, 0);\n}\n\nconst char *\nofputil_frag_handling_to_string(enum ofputil_frag_handling frag)\n{\n    switch (frag) {\n    case OFPUTIL_FRAG_NORMAL:   return \"normal\";\n    case OFPUTIL_FRAG_DROP:     return \"drop\";\n    case OFPUTIL_FRAG_REASM:    return \"reassemble\";\n    case OFPUTIL_FRAG_NX_MATCH: return \"nx-match\";\n    }\n\n    OVS_NOT_REACHED();\n}\n\nbool\nofputil_frag_handling_from_string(const char *s,\n                                  enum ofputil_frag_handling *frag)\n{\n    if (!strcasecmp(s, \"normal\")) {\n        *frag = OFPUTIL_FRAG_NORMAL;\n    } else if (!strcasecmp(s, \"drop\")) {\n        *frag = OFPUTIL_FRAG_DROP;\n    } else if (!strcasecmp(s, \"reassemble\")) {\n        *frag = OFPUTIL_FRAG_REASM;\n    } else if (!strcasecmp(s, \"nx-match\")) {\n        *frag = OFPUTIL_FRAG_NX_MATCH;\n    } else {\n        return false;\n    }\n    return true;\n}\n\n/* Converts the OpenFlow 1.1+ port number 'ofp11_port' into an OpenFlow 1.0\n * port number and stores the latter in '*ofp10_port', for the purpose of\n * decoding OpenFlow 1.1+ protocol messages.  Returns 0 if successful,\n * otherwise an OFPERR_* number.  On error, stores OFPP_NONE in '*ofp10_port'.\n *\n * See the definition of OFP11_MAX for an explanation of the mapping. */\nenum ofperr\nofputil_port_from_ofp11(ovs_be32 ofp11_port, ofp_port_t *ofp10_port)\n{\n    uint32_t ofp11_port_h = ntohl(ofp11_port);\n\n    if (ofp11_port_h < ofp_to_u16(OFPP_MAX)) {\n        *ofp10_port = u16_to_ofp(ofp11_port_h);\n        return 0;\n    } else if (ofp11_port_h >= ofp11_to_u32(OFPP11_MAX)) {\n        *ofp10_port = u16_to_ofp(ofp11_port_h - OFPP11_OFFSET);\n        return 0;\n    } else {\n        *ofp10_port = OFPP_NONE;\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"port %\"PRIu32\" is outside the supported \"\n                     \"range 0 through %d or 0x%\"PRIx32\" through 0x%\"PRIx32,\n                     ofp11_port_h, ofp_to_u16(OFPP_MAX) - 1,\n                     ofp11_to_u32(OFPP11_MAX), UINT32_MAX);\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n}\n\n/* Returns the OpenFlow 1.1+ port number equivalent to the OpenFlow 1.0 port\n * number 'ofp10_port', for encoding OpenFlow 1.1+ protocol messages.\n *\n * See the definition of OFP11_MAX for an explanation of the mapping. */\novs_be32\nofputil_port_to_ofp11(ofp_port_t ofp10_port)\n{\n    return htonl(ofp_to_u16(ofp10_port) < ofp_to_u16(OFPP_MAX)\n                 ? ofp_to_u16(ofp10_port)\n                 : ofp_to_u16(ofp10_port) + OFPP11_OFFSET);\n}\n\n#define OFPUTIL_NAMED_PORTS                     \\\n        OFPUTIL_NAMED_PORT(IN_PORT)             \\\n        OFPUTIL_NAMED_PORT(TABLE)               \\\n        OFPUTIL_NAMED_PORT(NORMAL)              \\\n        OFPUTIL_NAMED_PORT(FLOOD)               \\\n        OFPUTIL_NAMED_PORT(ALL)                 \\\n        OFPUTIL_NAMED_PORT(CONTROLLER)          \\\n        OFPUTIL_NAMED_PORT(LOCAL)               \\\n        OFPUTIL_NAMED_PORT(ANY)                 \\\n        OFPUTIL_NAMED_PORT(UNSET)\n\n/* For backwards compatibility, so that \"none\" is recognized as OFPP_ANY */\n#define OFPUTIL_NAMED_PORTS_WITH_NONE           \\\n        OFPUTIL_NAMED_PORTS                     \\\n        OFPUTIL_NAMED_PORT(NONE)\n\n/* Stores the port number represented by 's' into '*portp'.  's' may be an\n * integer or, for reserved ports, the standard OpenFlow name for the port\n * (e.g. \"LOCAL\").\n *\n * Returns true if successful, false if 's' is not a valid OpenFlow port number\n * or name.  The caller should issue an error message in this case, because\n * this function usually does not.  (This gives the caller an opportunity to\n * look up the port name another way, e.g. by contacting the switch and listing\n * the names of all its ports).\n *\n * This function accepts OpenFlow 1.0 port numbers.  It also accepts a subset\n * of OpenFlow 1.1+ port numbers, mapping those port numbers into the 16-bit\n * range as described in include/openflow/openflow-1.1.h. */\nbool\nofputil_port_from_string(const char *s, ofp_port_t *portp)\n{\n    unsigned int port32; /* int is at least 32 bits wide. */\n\n    if (*s == '-') {\n        VLOG_WARN(\"Negative value %s is not a valid port number.\", s);\n        return false;\n    }\n    *portp = 0;\n    if (str_to_uint(s, 10, &port32)) {\n        if (port32 < ofp_to_u16(OFPP_MAX)) {\n            /* Pass. */\n        } else if (port32 < ofp_to_u16(OFPP_FIRST_RESV)) {\n            VLOG_WARN(\"port %u is a reserved OF1.0 port number that will \"\n                      \"be translated to %u when talking to an OF1.1 or \"\n                      \"later controller\", port32, port32 + OFPP11_OFFSET);\n        } else if (port32 <= ofp_to_u16(OFPP_LAST_RESV)) {\n            char name[OFP_MAX_PORT_NAME_LEN];\n\n            ofputil_port_to_string(u16_to_ofp(port32), name, sizeof name);\n            VLOG_WARN_ONCE(\"referring to port %s as %\"PRIu32\" is deprecated \"\n                           \"for compatibility with OpenFlow 1.1 and later\",\n                           name, port32);\n        } else if (port32 < ofp11_to_u32(OFPP11_MAX)) {\n            VLOG_WARN(\"port %u is outside the supported range 0 through \"\n                      \"%\"PRIx16\" or 0x%x through 0x%\"PRIx32, port32,\n                      UINT16_MAX, ofp11_to_u32(OFPP11_MAX), UINT32_MAX);\n            return false;\n        } else {\n            port32 -= OFPP11_OFFSET;\n        }\n\n        *portp = u16_to_ofp(port32);\n        return true;\n    } else {\n        struct pair {\n            const char *name;\n            ofp_port_t value;\n        };\n        static const struct pair pairs[] = {\n#define OFPUTIL_NAMED_PORT(NAME) {#NAME, OFPP_##NAME},\n            OFPUTIL_NAMED_PORTS_WITH_NONE\n#undef OFPUTIL_NAMED_PORT\n        };\n        const struct pair *p;\n\n        for (p = pairs; p < &pairs[ARRAY_SIZE(pairs)]; p++) {\n            if (!strcasecmp(s, p->name)) {\n                *portp = p->value;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/* Appends to 's' a string representation of the OpenFlow port number 'port'.\n * Most ports' string representation is just the port number, but for special\n * ports, e.g. OFPP_LOCAL, it is the name, e.g. \"LOCAL\". */\nvoid\nofputil_format_port(ofp_port_t port, struct ds *s)\n{\n    char name[OFP_MAX_PORT_NAME_LEN];\n\n    ofputil_port_to_string(port, name, sizeof name);\n    ds_put_cstr(s, name);\n}\n\n/* Puts in the 'bufsize' byte in 'namebuf' a null-terminated string\n * representation of OpenFlow port number 'port'.  Most ports are represented\n * as just the port number, but special ports, e.g. OFPP_LOCAL, are represented\n * by name, e.g. \"LOCAL\". */\nvoid\nofputil_port_to_string(ofp_port_t port,\n                       char namebuf[OFP_MAX_PORT_NAME_LEN], size_t bufsize)\n{\n    switch (port) {\n#define OFPUTIL_NAMED_PORT(NAME)                        \\\n        case OFPP_##NAME:                               \\\n            ovs_strlcpy(namebuf, #NAME, bufsize);       \\\n            break;\n        OFPUTIL_NAMED_PORTS\n#undef OFPUTIL_NAMED_PORT\n\n    default:\n        snprintf(namebuf, bufsize, \"%\"PRIu32, port);\n        break;\n    }\n}\n\n/* Stores the group id represented by 's' into '*group_idp'.  's' may be an\n * integer or, for reserved group IDs, the standard OpenFlow name for the group\n * (either \"ANY\" or \"ALL\").\n *\n * Returns true if successful, false if 's' is not a valid OpenFlow group ID or\n * name. */\nbool\nofputil_group_from_string(const char *s, uint32_t *group_idp)\n{\n    if (!strcasecmp(s, \"any\")) {\n        *group_idp = OFPG_ANY;\n    } else if (!strcasecmp(s, \"all\")) {\n        *group_idp = OFPG_ALL;\n    } else if (!str_to_uint(s, 10, group_idp)) {\n        VLOG_WARN(\"%s is not a valid group ID.  (Valid group IDs are \"\n                  \"32-bit nonnegative integers or the keywords ANY or \"\n                  \"ALL.)\", s);\n        return false;\n    }\n\n    return true;\n}\n\n/* Appends to 's' a string representation of the OpenFlow group ID 'group_id'.\n * Most groups' string representation is just the number, but for special\n * groups, e.g. OFPG_ALL, it is the name, e.g. \"ALL\". */\nvoid\nofputil_format_group(uint32_t group_id, struct ds *s)\n{\n    char name[MAX_GROUP_NAME_LEN];\n\n    ofputil_group_to_string(group_id, name, sizeof name);\n    ds_put_cstr(s, name);\n}\n\n\n/* Puts in the 'bufsize' byte in 'namebuf' a null-terminated string\n * representation of OpenFlow group ID 'group_id'.  Most group are represented\n * as just their number, but special groups, e.g. OFPG_ALL, are represented\n * by name, e.g. \"ALL\". */\nvoid\nofputil_group_to_string(uint32_t group_id,\n                        char namebuf[MAX_GROUP_NAME_LEN + 1], size_t bufsize)\n{\n    switch (group_id) {\n    case OFPG_ALL:\n        ovs_strlcpy(namebuf, \"ALL\", bufsize);\n        break;\n\n    case OFPG_ANY:\n        ovs_strlcpy(namebuf, \"ANY\", bufsize);\n        break;\n\n    default:\n        snprintf(namebuf, bufsize, \"%\"PRIu32, group_id);\n        break;\n    }\n}\n\n/* Given a buffer 'b' that contains an array of OpenFlow ports of type\n * 'ofp_version', tries to pull the first element from the array.  If\n * successful, initializes '*pp' with an abstract representation of the\n * port and returns 0.  If no ports remain to be decoded, returns EOF.\n * On an error, returns a positive OFPERR_* value. */\nint\nofputil_pull_phy_port(enum ofp_version ofp_version, struct ofpbuf *b,\n                      struct ofputil_phy_port *pp)\n{\n    memset(pp, 0, sizeof *pp);\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        const struct ofp10_phy_port *opp = ofpbuf_try_pull(b, sizeof *opp);\n        return opp ? ofputil_decode_ofp10_phy_port(pp, opp) : EOF;\n    }\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION: {\n        const struct ofp11_port *op = ofpbuf_try_pull(b, sizeof *op);\n        return op ? ofputil_decode_ofp11_port(pp, op) : EOF;\n    }\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return b->size ? ofputil_pull_ofp14_port(pp, b) : EOF;\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic void\nofputil_normalize_match__(struct match *match, bool may_log)\n{\n    enum {\n        MAY_NW_ADDR     = 1 << 0, /* nw_src, nw_dst */\n        MAY_TP_ADDR     = 1 << 1, /* tp_src, tp_dst */\n        MAY_NW_PROTO    = 1 << 2, /* nw_proto */\n        MAY_IPVx        = 1 << 3, /* tos, frag, ttl */\n        MAY_ARP_SHA     = 1 << 4, /* arp_sha */\n        MAY_ARP_THA     = 1 << 5, /* arp_tha */\n        MAY_IPV6        = 1 << 6, /* ipv6_src, ipv6_dst, ipv6_label */\n        MAY_ND_TARGET   = 1 << 7, /* nd_target */\n        MAY_MPLS        = 1 << 8, /* mpls label and tc */\n    } may_match;\n\n    struct flow_wildcards wc;\n\n    /* Figure out what fields may be matched. */\n    if (match->flow.dl_type == htons(ETH_TYPE_IP)) {\n        may_match = MAY_NW_PROTO | MAY_IPVx | MAY_NW_ADDR;\n        if (match->flow.nw_proto == IPPROTO_TCP ||\n            match->flow.nw_proto == IPPROTO_UDP ||\n            match->flow.nw_proto == IPPROTO_SCTP ||\n            match->flow.nw_proto == IPPROTO_ICMP) {\n            may_match |= MAY_TP_ADDR;\n        }\n    } else if (match->flow.dl_type == htons(ETH_TYPE_IPV6)) {\n        may_match = MAY_NW_PROTO | MAY_IPVx | MAY_IPV6;\n        if (match->flow.nw_proto == IPPROTO_TCP ||\n            match->flow.nw_proto == IPPROTO_UDP ||\n            match->flow.nw_proto == IPPROTO_SCTP) {\n            may_match |= MAY_TP_ADDR;\n        } else if (match->flow.nw_proto == IPPROTO_ICMPV6) {\n            may_match |= MAY_TP_ADDR;\n            if (match->flow.tp_src == htons(ND_NEIGHBOR_SOLICIT)) {\n                may_match |= MAY_ND_TARGET | MAY_ARP_SHA;\n            } else if (match->flow.tp_src == htons(ND_NEIGHBOR_ADVERT)) {\n                may_match |= MAY_ND_TARGET | MAY_ARP_THA;\n            }\n        }\n    } else if (match->flow.dl_type == htons(ETH_TYPE_ARP) ||\n               match->flow.dl_type == htons(ETH_TYPE_RARP)) {\n        may_match = MAY_NW_PROTO | MAY_NW_ADDR | MAY_ARP_SHA | MAY_ARP_THA;\n    } else if (eth_type_mpls(match->flow.dl_type)) {\n        may_match = MAY_MPLS;\n    } else {\n        may_match = 0;\n    }\n\n    /* Clear the fields that may not be matched. */\n    wc = match->wc;\n    if (!(may_match & MAY_NW_ADDR)) {\n        wc.masks.nw_src = wc.masks.nw_dst = htonl(0);\n    }\n    if (!(may_match & MAY_TP_ADDR)) {\n        wc.masks.tp_src = wc.masks.tp_dst = htons(0);\n    }\n    if (!(may_match & MAY_NW_PROTO)) {\n        wc.masks.nw_proto = 0;\n    }\n    if (!(may_match & MAY_IPVx)) {\n        wc.masks.nw_tos = 0;\n        wc.masks.nw_ttl = 0;\n    }\n    if (!(may_match & MAY_ARP_SHA)) {\n        WC_UNMASK_FIELD(&wc, arp_sha);\n    }\n    if (!(may_match & MAY_ARP_THA)) {\n        WC_UNMASK_FIELD(&wc, arp_tha);\n    }\n    if (!(may_match & MAY_IPV6)) {\n        wc.masks.ipv6_src = wc.masks.ipv6_dst = in6addr_any;\n        wc.masks.ipv6_label = htonl(0);\n    }\n    if (!(may_match & MAY_ND_TARGET)) {\n        wc.masks.nd_target = in6addr_any;\n    }\n    if (!(may_match & MAY_MPLS)) {\n        memset(wc.masks.mpls_lse, 0, sizeof wc.masks.mpls_lse);\n    }\n\n    /* Log any changes. */\n    if (!flow_wildcards_equal(&wc, &match->wc)) {\n        bool log = may_log && !VLOG_DROP_INFO(&bad_ofmsg_rl);\n        char *pre = log ? match_to_string(match, OFP_DEFAULT_PRIORITY) : NULL;\n\n        match->wc = wc;\n        match_zero_wildcarded_fields(match);\n\n        if (log) {\n            char *post = match_to_string(match, OFP_DEFAULT_PRIORITY);\n            VLOG_INFO(\"normalization changed ofp_match, details:\");\n            VLOG_INFO(\" pre: %s\", pre);\n            VLOG_INFO(\"post: %s\", post);\n            free(pre);\n            free(post);\n        }\n    }\n}\n\n/* \"Normalizes\" the wildcards in 'match'.  That means:\n *\n *    1. If the type of level N is known, then only the valid fields for that\n *       level may be specified.  For example, ARP does not have a TOS field,\n *       so nw_tos must be wildcarded if 'match' specifies an ARP flow.\n *       Similarly, IPv4 does not have any IPv6 addresses, so ipv6_src and\n *       ipv6_dst (and other fields) must be wildcarded if 'match' specifies an\n *       IPv4 flow.\n *\n *    2. If the type of level N is not known (or not understood by Open\n *       vSwitch), then no fields at all for that level may be specified.  For\n *       example, Open vSwitch does not understand SCTP, an L4 protocol, so the\n *       L4 fields tp_src and tp_dst must be wildcarded if 'match' specifies an\n *       SCTP flow.\n *\n * If this function changes 'match', it logs a rate-limited informational\n * message. */\nvoid\nofputil_normalize_match(struct match *match)\n{\n    ofputil_normalize_match__(match, true);\n}\n\n/* Same as ofputil_normalize_match() without the logging.  Thus, this function\n * is suitable for a program's internal use, whereas ofputil_normalize_match()\n * sense for use on flows received from elsewhere (so that a bug in the program\n * that sent them can be reported and corrected). */\nvoid\nofputil_normalize_match_quiet(struct match *match)\n{\n    ofputil_normalize_match__(match, false);\n}\n\nstatic size_t\nparse_value(const char *s, const char *delimiters)\n{\n    size_t n = 0;\n\n    /* Iterate until we reach a delimiter.\n     *\n     * strchr(s, '\\0') returns s+strlen(s), so this test handles the null\n     * terminator at the end of 's'.  */\n    while (!strchr(delimiters, s[n])) {\n        if (s[n] == '(') {\n            int level = 0;\n            do {\n                switch (s[n]) {\n                case '\\0':\n                    return n;\n                case '(':\n                    level++;\n                    break;\n                case ')':\n                    level--;\n                    break;\n                }\n                n++;\n            } while (level > 0);\n        } else {\n            n++;\n        }\n    }\n    return n;\n}\n\n/* Parses a key or a key-value pair from '*stringp'.\n *\n * On success: Stores the key into '*keyp'.  Stores the value, if present, into\n * '*valuep', otherwise an empty string.  Advances '*stringp' past the end of\n * the key-value pair, preparing it for another call.  '*keyp' and '*valuep'\n * are substrings of '*stringp' created by replacing some of its bytes by null\n * terminators.  Returns true.\n *\n * If '*stringp' is just white space or commas, sets '*keyp' and '*valuep' to\n * NULL and returns false. */\nbool\nofputil_parse_key_value(char **stringp, char **keyp, char **valuep)\n{\n    /* Skip white space and delimiters.  If that brings us to the end of the\n     * input string, we are done and there are no more key-value pairs. */\n    *stringp += strspn(*stringp, \", \\t\\r\\n\");\n    if (**stringp == '\\0') {\n        *keyp = *valuep = NULL;\n        return false;\n    }\n\n    /* Extract the key and the delimiter that ends the key-value pair or begins\n     * the value.  Advance the input position past the key and delimiter. */\n    char *key = *stringp;\n    size_t key_len = strcspn(key, \":=(, \\t\\r\\n\");\n    char key_delim = key[key_len];\n    key[key_len] = '\\0';\n    *stringp += key_len + (key_delim != '\\0');\n\n    /* Figure out what delimiter ends the value:\n     *\n     *     - If key_delim is \":\" or \"=\", the value extends until white space\n     *       or a comma.\n     *\n     *     - If key_delim is \"(\", the value extends until \")\".\n     *\n     * If there is no value, we are done. */\n    const char *value_delims;\n    if (key_delim == ':' || key_delim == '=') {\n        value_delims = \", \\t\\r\\n\";\n    } else if (key_delim == '(') {\n        value_delims = \")\";\n    } else {\n        *keyp = key;\n        *valuep = key + key_len; /* Empty string. */\n        return true;\n    }\n\n    /* Extract the value.  Advance the input position past the value and\n     * delimiter. */\n    char *value = *stringp;\n    size_t value_len = parse_value(value, value_delims);\n    char value_delim = value[value_len];\n    value[value_len] = '\\0';\n    *stringp += value_len + (value_delim != '\\0');\n\n    *keyp = key;\n    *valuep = value;\n    return true;\n}\n\n/* Encode a dump ports request for 'port', the encoded message\n * will be for OpenFlow version 'ofp_version'. Returns message\n * as a struct ofpbuf. Returns encoded message on success, NULL on error */\nstruct ofpbuf *\nofputil_encode_dump_ports_request(enum ofp_version ofp_version, ofp_port_t port)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION: {\n        struct ofp10_port_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST10_PORT_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = htons(ofp_to_u16(port));\n        break;\n    }\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_port_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST11_PORT_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = ofputil_port_to_ofp11(port);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstatic void\nofputil_port_stats_to_ofp10(const struct ofputil_port_stats *ops,\n                            struct ofp10_port_stats *ps10)\n{\n    ps10->port_no = htons(ofp_to_u16(ops->port_no));\n    memset(ps10->pad, 0, sizeof ps10->pad);\n    put_32aligned_be64(&ps10->rx_packets, htonll(ops->stats.rx_packets));\n    put_32aligned_be64(&ps10->tx_packets, htonll(ops->stats.tx_packets));\n    put_32aligned_be64(&ps10->rx_bytes, htonll(ops->stats.rx_bytes));\n    put_32aligned_be64(&ps10->tx_bytes, htonll(ops->stats.tx_bytes));\n    put_32aligned_be64(&ps10->rx_dropped, htonll(ops->stats.rx_dropped));\n    put_32aligned_be64(&ps10->tx_dropped, htonll(ops->stats.tx_dropped));\n    put_32aligned_be64(&ps10->rx_errors, htonll(ops->stats.rx_errors));\n    put_32aligned_be64(&ps10->tx_errors, htonll(ops->stats.tx_errors));\n    put_32aligned_be64(&ps10->rx_frame_err, htonll(ops->stats.rx_frame_errors));\n    put_32aligned_be64(&ps10->rx_over_err, htonll(ops->stats.rx_over_errors));\n    put_32aligned_be64(&ps10->rx_crc_err, htonll(ops->stats.rx_crc_errors));\n    put_32aligned_be64(&ps10->collisions, htonll(ops->stats.collisions));\n}\n\nstatic void\nofputil_port_stats_to_ofp11(const struct ofputil_port_stats *ops,\n                            struct ofp11_port_stats *ps11)\n{\n    ps11->port_no = ofputil_port_to_ofp11(ops->port_no);\n    memset(ps11->pad, 0, sizeof ps11->pad);\n    ps11->rx_packets = htonll(ops->stats.rx_packets);\n    ps11->tx_packets = htonll(ops->stats.tx_packets);\n    ps11->rx_bytes = htonll(ops->stats.rx_bytes);\n    ps11->tx_bytes = htonll(ops->stats.tx_bytes);\n    ps11->rx_dropped = htonll(ops->stats.rx_dropped);\n    ps11->tx_dropped = htonll(ops->stats.tx_dropped);\n    ps11->rx_errors = htonll(ops->stats.rx_errors);\n    ps11->tx_errors = htonll(ops->stats.tx_errors);\n    ps11->rx_frame_err = htonll(ops->stats.rx_frame_errors);\n    ps11->rx_over_err = htonll(ops->stats.rx_over_errors);\n    ps11->rx_crc_err = htonll(ops->stats.rx_crc_errors);\n    ps11->collisions = htonll(ops->stats.collisions);\n}\n\nstatic void\nofputil_port_stats_to_ofp13(const struct ofputil_port_stats *ops,\n                            struct ofp13_port_stats *ps13)\n{\n    ofputil_port_stats_to_ofp11(ops, &ps13->ps);\n    ps13->duration_sec = htonl(ops->duration_sec);\n    ps13->duration_nsec = htonl(ops->duration_nsec);\n}\n\nstatic void\nofputil_append_ofp14_port_stats(const struct ofputil_port_stats *ops,\n                                struct ovs_list *replies)\n{\n    struct ofp14_port_stats_prop_ethernet *eth;\n    struct intel_port_stats_rfc2819 *stats_rfc2819;\n    struct ofp14_port_stats *ps14;\n    struct ofpbuf *reply;\n\n    reply = ofpmp_reserve(replies, sizeof *ps14 + sizeof *eth +\n                          sizeof *stats_rfc2819);\n\n    ps14 = ofpbuf_put_uninit(reply, sizeof *ps14);\n    ps14->length = htons(sizeof *ps14 + sizeof *eth +\n                         sizeof *stats_rfc2819);\n    memset(ps14->pad, 0, sizeof ps14->pad);\n    ps14->port_no = ofputil_port_to_ofp11(ops->port_no);\n    ps14->duration_sec = htonl(ops->duration_sec);\n    ps14->duration_nsec = htonl(ops->duration_nsec);\n    ps14->rx_packets = htonll(ops->stats.rx_packets);\n    ps14->tx_packets = htonll(ops->stats.tx_packets);\n    ps14->rx_bytes = htonll(ops->stats.rx_bytes);\n    ps14->tx_bytes = htonll(ops->stats.tx_bytes);\n    ps14->rx_dropped = htonll(ops->stats.rx_dropped);\n    ps14->tx_dropped = htonll(ops->stats.tx_dropped);\n    ps14->rx_errors = htonll(ops->stats.rx_errors);\n    ps14->tx_errors = htonll(ops->stats.tx_errors);\n\n    eth = ofpprop_put_zeros(reply, OFPPSPT14_ETHERNET, sizeof *eth);\n    eth->rx_frame_err = htonll(ops->stats.rx_frame_errors);\n    eth->rx_over_err = htonll(ops->stats.rx_over_errors);\n    eth->rx_crc_err = htonll(ops->stats.rx_crc_errors);\n    eth->collisions = htonll(ops->stats.collisions);\n\n    uint64_t prop_type = OFPPROP_EXP(INTEL_VENDOR_ID,\n                                     INTEL_PORT_STATS_RFC2819);\n\n    stats_rfc2819 = ofpprop_put_zeros(reply, prop_type,\n                                      sizeof *stats_rfc2819);\n\n    memset(stats_rfc2819->pad, 0, sizeof stats_rfc2819->pad);\n    stats_rfc2819->rx_1_to_64_packets = htonll(ops->stats.rx_1_to_64_packets);\n    stats_rfc2819->rx_65_to_127_packets =\n        htonll(ops->stats.rx_65_to_127_packets);\n    stats_rfc2819->rx_128_to_255_packets =\n        htonll(ops->stats.rx_128_to_255_packets);\n    stats_rfc2819->rx_256_to_511_packets =\n        htonll(ops->stats.rx_256_to_511_packets);\n    stats_rfc2819->rx_512_to_1023_packets =\n        htonll(ops->stats.rx_512_to_1023_packets);\n    stats_rfc2819->rx_1024_to_1522_packets =\n        htonll(ops->stats.rx_1024_to_1522_packets);\n    stats_rfc2819->rx_1523_to_max_packets =\n        htonll(ops->stats.rx_1523_to_max_packets);\n\n    stats_rfc2819->tx_1_to_64_packets = htonll(ops->stats.tx_1_to_64_packets);\n    stats_rfc2819->tx_65_to_127_packets =\n        htonll(ops->stats.tx_65_to_127_packets);\n    stats_rfc2819->tx_128_to_255_packets =\n        htonll(ops->stats.tx_128_to_255_packets);\n    stats_rfc2819->tx_256_to_511_packets =\n        htonll(ops->stats.tx_256_to_511_packets);\n    stats_rfc2819->tx_512_to_1023_packets =\n        htonll(ops->stats.tx_512_to_1023_packets);\n    stats_rfc2819->tx_1024_to_1522_packets =\n        htonll(ops->stats.tx_1024_to_1522_packets);\n    stats_rfc2819->tx_1523_to_max_packets =\n        htonll(ops->stats.tx_1523_to_max_packets);\n\n    stats_rfc2819->tx_multicast_packets =\n        htonll(ops->stats.tx_multicast_packets);\n    stats_rfc2819->rx_broadcast_packets =\n        htonll(ops->stats.rx_broadcast_packets);\n    stats_rfc2819->tx_broadcast_packets =\n        htonll(ops->stats.tx_broadcast_packets);\n    stats_rfc2819->rx_undersized_errors =\n        htonll(ops->stats.rx_undersized_errors);\n    stats_rfc2819->rx_oversize_errors =\n        htonll(ops->stats.rx_oversize_errors);\n    stats_rfc2819->rx_fragmented_errors =\n        htonll(ops->stats.rx_fragmented_errors);\n    stats_rfc2819->rx_jabber_errors =\n        htonll(ops->stats.rx_jabber_errors);\n}\n\n/* Encode a ports stat for 'ops' and append it to 'replies'. */\nvoid\nofputil_append_port_stat(struct ovs_list *replies,\n                         const struct ofputil_port_stats *ops)\n{\n    switch (ofpmp_version(replies)) {\n    case OFP13_VERSION: {\n        struct ofp13_port_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_port_stats_to_ofp13(ops, reply);\n        break;\n    }\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        struct ofp11_port_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_port_stats_to_ofp11(ops, reply);\n        break;\n    }\n\n    case OFP10_VERSION: {\n        struct ofp10_port_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_port_stats_to_ofp10(ops, reply);\n        break;\n    }\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_append_ofp14_port_stats(ops, replies);\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic enum ofperr\nofputil_port_stats_from_ofp10(struct ofputil_port_stats *ops,\n                              const struct ofp10_port_stats *ps10)\n{\n\n    ops->port_no = u16_to_ofp(ntohs(ps10->port_no));\n    ops->stats.rx_packets = ntohll(get_32aligned_be64(&ps10->rx_packets));\n    ops->stats.tx_packets = ntohll(get_32aligned_be64(&ps10->tx_packets));\n    ops->stats.rx_bytes = ntohll(get_32aligned_be64(&ps10->rx_bytes));\n    ops->stats.tx_bytes = ntohll(get_32aligned_be64(&ps10->tx_bytes));\n    ops->stats.rx_dropped = ntohll(get_32aligned_be64(&ps10->rx_dropped));\n    ops->stats.tx_dropped = ntohll(get_32aligned_be64(&ps10->tx_dropped));\n    ops->stats.rx_errors = ntohll(get_32aligned_be64(&ps10->rx_errors));\n    ops->stats.tx_errors = ntohll(get_32aligned_be64(&ps10->tx_errors));\n    ops->stats.rx_frame_errors =\n        ntohll(get_32aligned_be64(&ps10->rx_frame_err));\n    ops->stats.rx_over_errors = ntohll(get_32aligned_be64(&ps10->rx_over_err));\n    ops->stats.rx_crc_errors = ntohll(get_32aligned_be64(&ps10->rx_crc_err));\n    ops->stats.collisions = ntohll(get_32aligned_be64(&ps10->collisions));\n    ops->duration_sec = ops->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_port_stats_from_ofp11(struct ofputil_port_stats *ops,\n                              const struct ofp11_port_stats *ps11)\n{\n    enum ofperr error;\n\n    error = ofputil_port_from_ofp11(ps11->port_no, &ops->port_no);\n    if (error) {\n        return error;\n    }\n\n    ops->stats.rx_packets = ntohll(ps11->rx_packets);\n    ops->stats.tx_packets = ntohll(ps11->tx_packets);\n    ops->stats.rx_bytes = ntohll(ps11->rx_bytes);\n    ops->stats.tx_bytes = ntohll(ps11->tx_bytes);\n    ops->stats.rx_dropped = ntohll(ps11->rx_dropped);\n    ops->stats.tx_dropped = ntohll(ps11->tx_dropped);\n    ops->stats.rx_errors = ntohll(ps11->rx_errors);\n    ops->stats.tx_errors = ntohll(ps11->tx_errors);\n    ops->stats.rx_frame_errors = ntohll(ps11->rx_frame_err);\n    ops->stats.rx_over_errors = ntohll(ps11->rx_over_err);\n    ops->stats.rx_crc_errors = ntohll(ps11->rx_crc_err);\n    ops->stats.collisions = ntohll(ps11->collisions);\n    ops->duration_sec = ops->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_port_stats_from_ofp13(struct ofputil_port_stats *ops,\n                              const struct ofp13_port_stats *ps13)\n{\n    enum ofperr error = ofputil_port_stats_from_ofp11(ops, &ps13->ps);\n    if (!error) {\n        ops->duration_sec = ntohl(ps13->duration_sec);\n        ops->duration_nsec = ntohl(ps13->duration_nsec);\n    }\n    return error;\n}\n\nstatic enum ofperr\nparse_ofp14_port_stats_ethernet_property(const struct ofpbuf *payload,\n                                         struct ofputil_port_stats *ops)\n{\n    const struct ofp14_port_stats_prop_ethernet *eth = payload->data;\n\n    if (payload->size != sizeof *eth) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    ops->stats.rx_frame_errors = ntohll(eth->rx_frame_err);\n    ops->stats.rx_over_errors = ntohll(eth->rx_over_err);\n    ops->stats.rx_crc_errors = ntohll(eth->rx_crc_err);\n    ops->stats.collisions = ntohll(eth->collisions);\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_intel_port_stats_rfc2819_property(const struct ofpbuf *payload,\n                                        struct ofputil_port_stats *ops)\n{\n    const struct intel_port_stats_rfc2819 *rfc2819 = payload->data;\n\n    if (payload->size != sizeof *rfc2819) {\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n    ops->stats.rx_1_to_64_packets = ntohll(rfc2819->rx_1_to_64_packets);\n    ops->stats.rx_65_to_127_packets = ntohll(rfc2819->rx_65_to_127_packets);\n    ops->stats.rx_128_to_255_packets = ntohll(rfc2819->rx_128_to_255_packets);\n    ops->stats.rx_256_to_511_packets = ntohll(rfc2819->rx_256_to_511_packets);\n    ops->stats.rx_512_to_1023_packets =\n        ntohll(rfc2819->rx_512_to_1023_packets);\n    ops->stats.rx_1024_to_1522_packets =\n        ntohll(rfc2819->rx_1024_to_1522_packets);\n    ops->stats.rx_1523_to_max_packets =\n        ntohll(rfc2819->rx_1523_to_max_packets);\n\n    ops->stats.tx_1_to_64_packets = ntohll(rfc2819->tx_1_to_64_packets);\n    ops->stats.tx_65_to_127_packets = ntohll(rfc2819->tx_65_to_127_packets);\n    ops->stats.tx_128_to_255_packets = ntohll(rfc2819->tx_128_to_255_packets);\n    ops->stats.tx_256_to_511_packets = ntohll(rfc2819->tx_256_to_511_packets);\n    ops->stats.tx_512_to_1023_packets =\n        ntohll(rfc2819->tx_512_to_1023_packets);\n    ops->stats.tx_1024_to_1522_packets =\n        ntohll(rfc2819->tx_1024_to_1522_packets);\n    ops->stats.tx_1523_to_max_packets =\n        ntohll(rfc2819->tx_1523_to_max_packets);\n\n    ops->stats.tx_multicast_packets = ntohll(rfc2819->tx_multicast_packets);\n    ops->stats.rx_broadcast_packets = ntohll(rfc2819->rx_broadcast_packets);\n    ops->stats.tx_broadcast_packets = ntohll(rfc2819->tx_broadcast_packets);\n    ops->stats.rx_undersized_errors = ntohll(rfc2819->rx_undersized_errors);\n\n    ops->stats.rx_oversize_errors = ntohll(rfc2819->rx_oversize_errors);\n    ops->stats.rx_fragmented_errors = ntohll(rfc2819->rx_fragmented_errors);\n    ops->stats.rx_jabber_errors = ntohll(rfc2819->rx_jabber_errors);\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_intel_port_stats_property(const struct ofpbuf *payload,\n                                uint32_t exp_type,\n                                struct ofputil_port_stats *ops)\n{\n    enum ofperr error;\n\n    switch (exp_type) {\n    case INTEL_PORT_STATS_RFC2819:\n        error = parse_intel_port_stats_rfc2819_property(payload, ops);\n        break;\n    default:\n        error = OFPERR_OFPBPC_BAD_EXP_TYPE;\n        break;\n    }\n\n    return error;\n}\n\nstatic enum ofperr\nofputil_pull_ofp14_port_stats(struct ofputil_port_stats *ops,\n                              struct ofpbuf *msg)\n{\n    const struct ofp14_port_stats *ps14 = ofpbuf_try_pull(msg, sizeof *ps14);\n    if (!ps14) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    size_t len = ntohs(ps14->length);\n    if (len < sizeof *ps14 || len - sizeof *ps14 > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= sizeof *ps14;\n\n    enum ofperr error = ofputil_port_from_ofp11(ps14->port_no, &ops->port_no);\n    if (error) {\n        return error;\n    }\n\n    ops->duration_sec = ntohl(ps14->duration_sec);\n    ops->duration_nsec = ntohl(ps14->duration_nsec);\n    ops->stats.rx_packets = ntohll(ps14->rx_packets);\n    ops->stats.tx_packets = ntohll(ps14->tx_packets);\n    ops->stats.rx_bytes = ntohll(ps14->rx_bytes);\n    ops->stats.tx_bytes = ntohll(ps14->tx_bytes);\n    ops->stats.rx_dropped = ntohll(ps14->rx_dropped);\n    ops->stats.tx_dropped = ntohll(ps14->tx_dropped);\n    ops->stats.rx_errors = ntohll(ps14->rx_errors);\n    ops->stats.tx_errors = ntohll(ps14->tx_errors);\n\n\n    struct ofpbuf properties = ofpbuf_const_initializer(ofpbuf_pull(msg, len),\n                                                        len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type = 0;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n        switch (type) {\n        case OFPPSPT14_ETHERNET:\n            error = parse_ofp14_port_stats_ethernet_property(&payload, ops);\n            break;\n        case OFPPROP_EXP(INTEL_VENDOR_ID, INTEL_PORT_STATS_RFC2819):\n            error = parse_intel_port_stats_property(&payload,\n                                                    INTEL_PORT_STATS_RFC2819,\n                                                    ops);\n            break;\n        default:\n            error = OFPPROP_UNKNOWN(true, \"port stats\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\n/* Returns the number of port stats elements in OFPTYPE_PORT_STATS_REPLY\n * message 'oh'. */\nsize_t\nofputil_count_port_stats(const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    for (size_t n = 0; ; n++) {\n        struct ofputil_port_stats ps;\n        if (ofputil_decode_port_stats(&ps, &b)) {\n            return n;\n        }\n    }\n}\n\n/* Converts an OFPST_PORT_STATS reply in 'msg' into an abstract\n * ofputil_port_stats in 'ps'.\n *\n * Multiple OFPST_PORT_STATS replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  The caller must initially leave 'msg''s layer pointers\n * null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_port_stats(struct ofputil_port_stats *ps, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    memset(&(ps->stats), 0xFF, sizeof (ps->stats));\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_PORT_REPLY) {\n        return ofputil_pull_ofp14_port_stats(ps, msg);\n    } else if (raw == OFPRAW_OFPST13_PORT_REPLY) {\n        const struct ofp13_port_stats *ps13;\n        ps13 = ofpbuf_try_pull(msg, sizeof *ps13);\n        if (!ps13) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp13(ps, ps13);\n    } else if (raw == OFPRAW_OFPST11_PORT_REPLY) {\n        const struct ofp11_port_stats *ps11;\n\n        ps11 = ofpbuf_try_pull(msg, sizeof *ps11);\n        if (!ps11) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp11(ps, ps11);\n    } else if (raw == OFPRAW_OFPST10_PORT_REPLY) {\n        const struct ofp10_port_stats *ps10;\n\n        ps10 = ofpbuf_try_pull(msg, sizeof *ps10);\n        if (!ps10) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp10(ps, ps10);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n bad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_PORT reply has %\"PRIu32\" leftover \"\n                 \"bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n\n/* Parse a port status request message into a 16 bit OpenFlow 1.0\n * port number and stores the latter in '*ofp10_port'.\n * Returns 0 if successful, otherwise an OFPERR_* number. */\nenum ofperr\nofputil_decode_port_stats_request(const struct ofp_header *request,\n                                  ofp_port_t *ofp10_port)\n{\n    switch ((enum ofp_version)request->version) {\n    case OFP16_VERSION:\n    case OFP15_VERSION:\n    case OFP14_VERSION:\n    case OFP13_VERSION:\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        const struct ofp11_port_stats_request *psr11 = ofpmsg_body(request);\n        return ofputil_port_from_ofp11(psr11->port_no, ofp10_port);\n    }\n\n    case OFP10_VERSION: {\n        const struct ofp10_port_stats_request *psr10 = ofpmsg_body(request);\n        *ofp10_port = u16_to_ofp(ntohs(psr10->port_no));\n        return 0;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic void\nofputil_ipfix_stats_to_reply(const struct ofputil_ipfix_stats *ois,\n                            struct nx_ipfix_stats_reply *reply)\n{\n    reply->collector_set_id = htonl(ois->collector_set_id);\n    reply->total_flows = htonll(ois->total_flows);\n    reply->current_flows = htonll(ois->current_flows);\n    reply->pkts = htonll(ois->pkts);\n    reply->ipv4_pkts = htonll(ois->ipv4_pkts);\n    reply->ipv6_pkts = htonll(ois->ipv6_pkts);\n    reply->error_pkts = htonll(ois->error_pkts);\n    reply->ipv4_error_pkts = htonll(ois->ipv4_error_pkts);\n    reply->ipv6_error_pkts = htonll(ois->ipv6_error_pkts);\n    reply->tx_pkts = htonll(ois->tx_pkts);\n    reply->tx_errors = htonll(ois->tx_errors);\n    memset(reply->pad, 0, sizeof reply->pad);\n}\n\n/* Encode a ipfix stat for 'ois' and append it to 'replies'. */\nvoid\nofputil_append_ipfix_stat(struct ovs_list *replies,\n                         const struct ofputil_ipfix_stats *ois)\n{\n    struct nx_ipfix_stats_reply *reply = ofpmp_append(replies, sizeof *reply);\n    ofputil_ipfix_stats_to_reply(ois, reply);\n}\n\nstatic enum ofperr\nofputil_ipfix_stats_from_nx(struct ofputil_ipfix_stats *is,\n                            const struct nx_ipfix_stats_reply *reply)\n{\n    is->collector_set_id = ntohl(reply->collector_set_id);\n    is->total_flows = ntohll(reply->total_flows);\n    is->current_flows = ntohll(reply->current_flows);\n    is->pkts = ntohll(reply->pkts);\n    is->ipv4_pkts = ntohll(reply->ipv4_pkts);\n    is->ipv6_pkts = ntohll(reply->ipv6_pkts);\n    is->error_pkts = ntohll(reply->error_pkts);\n    is->ipv4_error_pkts = ntohll(reply->ipv4_error_pkts);\n    is->ipv6_error_pkts = ntohll(reply->ipv6_error_pkts);\n    is->tx_pkts = ntohll(reply->tx_pkts);\n    is->tx_errors = ntohll(reply->tx_errors);\n\n    return 0;\n}\n\nint\nofputil_pull_ipfix_stats(struct ofputil_ipfix_stats *is, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    memset(is, 0xFF, sizeof (*is));\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_NXST_IPFIX_BRIDGE_REPLY ||\n               raw == OFPRAW_NXST_IPFIX_FLOW_REPLY) {\n        struct nx_ipfix_stats_reply *reply;\n\n        reply = ofpbuf_try_pull(msg, sizeof *reply);\n        return ofputil_ipfix_stats_from_nx(is, reply);\n    } else {\n        OVS_NOT_REACHED();\n    }\n}\n\n\n/* Returns the number of ipfix stats elements in\n * OFPTYPE_IPFIX_BRIDGE_STATS_REPLY or OFPTYPE_IPFIX_FLOW_STATS_REPLY\n * message 'oh'. */\nsize_t\nofputil_count_ipfix_stats(const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    return b.size / sizeof(struct ofputil_ipfix_stats);\n}\n\n/* Frees all of the \"struct ofputil_bucket\"s in the 'buckets' list. */\nvoid\nofputil_bucket_list_destroy(struct ovs_list *buckets)\n{\n    struct ofputil_bucket *bucket;\n\n    LIST_FOR_EACH_POP (bucket, list_node, buckets) {\n        free(bucket->ofpacts);\n        free(bucket);\n    }\n}\n\n/* Clones 'bucket' and its ofpacts data */\nstatic struct ofputil_bucket *\nofputil_bucket_clone_data(const struct ofputil_bucket *bucket)\n{\n    struct ofputil_bucket *new;\n\n    new = xmemdup(bucket, sizeof *bucket);\n    new->ofpacts = xmemdup(bucket->ofpacts, bucket->ofpacts_len);\n\n    return new;\n}\n\n/* Clones each of the buckets in the list 'src' appending them\n * in turn to 'dest' which should be an initialised list.\n * An exception is that if the pointer value of a bucket in 'src'\n * matches 'skip' then it is not cloned or appended to 'dest'.\n * This allows all of 'src' or 'all of 'src' except 'skip' to\n * be cloned and appended to 'dest'. */\nvoid\nofputil_bucket_clone_list(struct ovs_list *dest, const struct ovs_list *src,\n                          const struct ofputil_bucket *skip)\n{\n    struct ofputil_bucket *bucket;\n\n    LIST_FOR_EACH (bucket, list_node, src) {\n        struct ofputil_bucket *new_bucket;\n\n        if (bucket == skip) {\n            continue;\n        }\n\n        new_bucket = ofputil_bucket_clone_data(bucket);\n        ovs_list_push_back(dest, &new_bucket->list_node);\n    }\n}\n\n/* Find a bucket in the list 'buckets' whose bucket id is 'bucket_id'\n * Returns the first bucket found or NULL if no buckets are found. */\nstruct ofputil_bucket *\nofputil_bucket_find(const struct ovs_list *buckets, uint32_t bucket_id)\n{\n    struct ofputil_bucket *bucket;\n\n    if (bucket_id > OFPG15_BUCKET_MAX) {\n        return NULL;\n    }\n\n    LIST_FOR_EACH (bucket, list_node, buckets) {\n        if (bucket->bucket_id == bucket_id) {\n            return bucket;\n        }\n    }\n\n    return NULL;\n}\n\n/* Returns true if more than one bucket in the list 'buckets'\n * have the same bucket id. Returns false otherwise. */\nbool\nofputil_bucket_check_duplicate_id(const struct ovs_list *buckets)\n{\n    struct ofputil_bucket *i, *j;\n\n    LIST_FOR_EACH (i, list_node, buckets) {\n        LIST_FOR_EACH_REVERSE (j, list_node, buckets) {\n            if (i == j) {\n                break;\n            }\n            if (i->bucket_id == j->bucket_id) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/* Returns the bucket at the front of the list 'buckets'.\n * Undefined if 'buckets is empty. */\nstruct ofputil_bucket *\nofputil_bucket_list_front(const struct ovs_list *buckets)\n{\n    static struct ofputil_bucket *bucket;\n\n    ASSIGN_CONTAINER(bucket, ovs_list_front(buckets), list_node);\n\n    return bucket;\n}\n\n/* Returns the bucket at the back of the list 'buckets'.\n * Undefined if 'buckets is empty. */\nstruct ofputil_bucket *\nofputil_bucket_list_back(const struct ovs_list *buckets)\n{\n    static struct ofputil_bucket *bucket;\n\n    ASSIGN_CONTAINER(bucket, ovs_list_back(buckets), list_node);\n\n    return bucket;\n}\n\n/* Returns an OpenFlow group stats request for OpenFlow version 'ofp_version',\n * that requests stats for group 'group_id'.  (Use OFPG_ALL to request stats\n * for all groups.)\n *\n * Group statistics include packet and byte counts for each group. */\nstruct ofpbuf *\nofputil_encode_group_stats_request(enum ofp_version ofp_version,\n                                   uint32_t group_id)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        ovs_fatal(0, \"dump-group-stats needs OpenFlow 1.1 or later \"\n                     \"(\\'-O OpenFlow11\\')\");\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_group_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST11_GROUP_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->group_id = htonl(group_id);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nvoid\nofputil_uninit_group_desc(struct ofputil_group_desc *gd)\n{\n    ofputil_bucket_list_destroy(&gd->buckets);\n    ofputil_group_properties_destroy(&gd->props);\n}\n\n/* Decodes the OpenFlow group description request in 'oh', returning the group\n * whose description is requested, or OFPG_ALL if stats for all groups was\n * requested. */\nuint32_t\nofputil_decode_group_desc_request(const struct ofp_header *oh)\n{\n    struct ofpbuf request = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&request);\n    if (raw == OFPRAW_OFPST11_GROUP_DESC_REQUEST) {\n        return OFPG_ALL;\n    } else if (raw == OFPRAW_OFPST15_GROUP_DESC_REQUEST) {\n        ovs_be32 *group_id = ofpbuf_pull(&request, sizeof *group_id);\n        return ntohl(*group_id);\n    } else {\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Returns an OpenFlow group description request for OpenFlow version\n * 'ofp_version', that requests stats for group 'group_id'.  Use OFPG_ALL to\n * request stats for all groups (OpenFlow 1.4 and earlier always request all\n * groups).\n *\n * Group descriptions include the bucket and action configuration for each\n * group. */\nstruct ofpbuf *\nofputil_encode_group_desc_request(enum ofp_version ofp_version,\n                                  uint32_t group_id)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        ovs_fatal(0, \"dump-groups needs OpenFlow 1.1 or later \"\n                     \"(\\'-O OpenFlow11\\')\");\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST11_GROUP_DESC_REQUEST,\n                               ofp_version, 0);\n        break;\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp15_group_desc_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST15_GROUP_DESC_REQUEST,\n                               ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->group_id = htonl(group_id);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstatic void\nofputil_group_bucket_counters_to_ofp11(const struct ofputil_group_stats *gs,\n                                    struct ofp11_bucket_counter bucket_cnts[])\n{\n    int i;\n\n    for (i = 0; i < gs->n_buckets; i++) {\n       bucket_cnts[i].packet_count = htonll(gs->bucket_stats[i].packet_count);\n       bucket_cnts[i].byte_count = htonll(gs->bucket_stats[i].byte_count);\n    }\n}\n\nstatic void\nofputil_group_stats_to_ofp11(const struct ofputil_group_stats *gs,\n                             struct ofp11_group_stats *gs11, size_t length,\n                             struct ofp11_bucket_counter bucket_cnts[])\n{\n    memset(gs11, 0, sizeof *gs11);\n    gs11->length = htons(length);\n    gs11->group_id = htonl(gs->group_id);\n    gs11->ref_count = htonl(gs->ref_count);\n    gs11->packet_count = htonll(gs->packet_count);\n    gs11->byte_count = htonll(gs->byte_count);\n    ofputil_group_bucket_counters_to_ofp11(gs, bucket_cnts);\n}\n\nstatic void\nofputil_group_stats_to_ofp13(const struct ofputil_group_stats *gs,\n                             struct ofp13_group_stats *gs13, size_t length,\n                             struct ofp11_bucket_counter bucket_cnts[])\n{\n    ofputil_group_stats_to_ofp11(gs, &gs13->gs, length, bucket_cnts);\n    gs13->duration_sec = htonl(gs->duration_sec);\n    gs13->duration_nsec = htonl(gs->duration_nsec);\n\n}\n\n/* Encodes 'gs' properly for the format of the list of group statistics\n * replies already begun in 'replies' and appends it to the list.  'replies'\n * must have originally been initialized with ofpmp_init(). */\nvoid\nofputil_append_group_stats(struct ovs_list *replies,\n                           const struct ofputil_group_stats *gs)\n{\n    size_t bucket_counter_size;\n    struct ofp11_bucket_counter *bucket_counters;\n    size_t length;\n\n    bucket_counter_size = gs->n_buckets * sizeof(struct ofp11_bucket_counter);\n\n    switch (ofpmp_version(replies)) {\n    case OFP11_VERSION:\n    case OFP12_VERSION:{\n            struct ofp11_group_stats *gs11;\n\n            length = sizeof *gs11 + bucket_counter_size;\n            gs11 = ofpmp_append(replies, length);\n            bucket_counters = (struct ofp11_bucket_counter *)(gs11 + 1);\n            ofputil_group_stats_to_ofp11(gs, gs11, length, bucket_counters);\n            break;\n        }\n\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n            struct ofp13_group_stats *gs13;\n\n            length = sizeof *gs13 + bucket_counter_size;\n            gs13 = ofpmp_append(replies, length);\n            bucket_counters = (struct ofp11_bucket_counter *)(gs13 + 1);\n            ofputil_group_stats_to_ofp13(gs, gs13, length, bucket_counters);\n            break;\n        }\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n/* Returns an OpenFlow group features request for OpenFlow version\n * 'ofp_version'. */\nstruct ofpbuf *\nofputil_encode_group_features_request(enum ofp_version ofp_version)\n{\n    struct ofpbuf *request = NULL;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n        ovs_fatal(0, \"dump-group-features needs OpenFlow 1.2 or later \"\n                     \"(\\'-O OpenFlow12\\')\");\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST12_GROUP_FEATURES_REQUEST,\n                               ofp_version, 0);\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\n/* Returns a OpenFlow message that encodes 'features' properly as a reply to\n * group features request 'request'. */\nstruct ofpbuf *\nofputil_encode_group_features_reply(\n    const struct ofputil_group_features *features,\n    const struct ofp_header *request)\n{\n    struct ofp12_group_features_stats *ogf;\n    struct ofpbuf *reply;\n    int i;\n\n    reply = ofpraw_alloc_xid(OFPRAW_OFPST12_GROUP_FEATURES_REPLY,\n                             request->version, request->xid, 0);\n    ogf = ofpbuf_put_zeros(reply, sizeof *ogf);\n    ogf->types = htonl(features->types);\n    ogf->capabilities = htonl(features->capabilities);\n    for (i = 0; i < OFPGT12_N_TYPES; i++) {\n        ogf->max_groups[i] = htonl(features->max_groups[i]);\n        ogf->actions[i] = ofpact_bitmap_to_openflow(features->ofpacts[i],\n                                                    request->version);\n    }\n\n    return reply;\n}\n\n/* Decodes group features reply 'oh' into 'features'. */\nvoid\nofputil_decode_group_features_reply(const struct ofp_header *oh,\n                                    struct ofputil_group_features *features)\n{\n    const struct ofp12_group_features_stats *ogf = ofpmsg_body(oh);\n    int i;\n\n    features->types = ntohl(ogf->types);\n    features->capabilities = ntohl(ogf->capabilities);\n    for (i = 0; i < OFPGT12_N_TYPES; i++) {\n        features->max_groups[i] = ntohl(ogf->max_groups[i]);\n        features->ofpacts[i] = ofpact_bitmap_from_openflow(\n            ogf->actions[i], oh->version);\n    }\n}\n\n/* Parse a group status request message into a 32 bit OpenFlow 1.1\n * group ID and stores the latter in '*group_id'.\n * Returns 0 if successful, otherwise an OFPERR_* number. */\nenum ofperr\nofputil_decode_group_stats_request(const struct ofp_header *request,\n                                   uint32_t *group_id)\n{\n    const struct ofp11_group_stats_request *gsr11 = ofpmsg_body(request);\n    *group_id = ntohl(gsr11->group_id);\n    return 0;\n}\n\n/* Converts a group stats reply in 'msg' into an abstract ofputil_group_stats\n * in 'gs'.  Assigns freshly allocated memory to gs->bucket_stats for the\n * caller to eventually free.\n *\n * Multiple group stats replies can be packed into a single OpenFlow message.\n * Calling this function multiple times for a single 'msg' iterates through the\n * replies.  The caller must initially leave 'msg''s layer pointers null and\n * not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_group_stats_reply(struct ofpbuf *msg,\n                                 struct ofputil_group_stats *gs)\n{\n    struct ofp11_bucket_counter *obc;\n    struct ofp11_group_stats *ogs11;\n    enum ofpraw raw;\n    enum ofperr error;\n    size_t base_len;\n    size_t length;\n    size_t i;\n\n    gs->bucket_stats = NULL;\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    if (raw == OFPRAW_OFPST11_GROUP_REPLY) {\n        base_len = sizeof *ogs11;\n        ogs11 = ofpbuf_try_pull(msg, sizeof *ogs11);\n        gs->duration_sec = gs->duration_nsec = UINT32_MAX;\n    } else if (raw == OFPRAW_OFPST13_GROUP_REPLY) {\n        struct ofp13_group_stats *ogs13;\n\n        base_len = sizeof *ogs13;\n        ogs13 = ofpbuf_try_pull(msg, sizeof *ogs13);\n        if (ogs13) {\n            ogs11 = &ogs13->gs;\n            gs->duration_sec = ntohl(ogs13->duration_sec);\n            gs->duration_nsec = ntohl(ogs13->duration_nsec);\n        } else {\n            ogs11 = NULL;\n        }\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (!ogs11) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s reply has %\"PRIu32\" leftover bytes at end\",\n                     ofpraw_get_name(raw), msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    length = ntohs(ogs11->length);\n    if (length < sizeof base_len) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s reply claims invalid length %\"PRIuSIZE,\n                     ofpraw_get_name(raw), length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    gs->group_id = ntohl(ogs11->group_id);\n    gs->ref_count = ntohl(ogs11->ref_count);\n    gs->packet_count = ntohll(ogs11->packet_count);\n    gs->byte_count = ntohll(ogs11->byte_count);\n\n    gs->n_buckets = (length - base_len) / sizeof *obc;\n    obc = ofpbuf_try_pull(msg, gs->n_buckets * sizeof *obc);\n    if (!obc) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s reply has %\"PRIu32\" leftover bytes at end\",\n                     ofpraw_get_name(raw), msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    gs->bucket_stats = xmalloc(gs->n_buckets * sizeof *gs->bucket_stats);\n    for (i = 0; i < gs->n_buckets; i++) {\n        gs->bucket_stats[i].packet_count = ntohll(obc[i].packet_count);\n        gs->bucket_stats[i].byte_count = ntohll(obc[i].byte_count);\n    }\n\n    return 0;\n}\n\nstatic void\nofputil_put_ofp11_bucket(const struct ofputil_bucket *bucket,\n                         struct ofpbuf *openflow, enum ofp_version ofp_version)\n{\n    struct ofp11_bucket *ob;\n    size_t start;\n\n    start = openflow->size;\n    ofpbuf_put_zeros(openflow, sizeof *ob);\n    ofpacts_put_openflow_actions(bucket->ofpacts, bucket->ofpacts_len,\n                                openflow, ofp_version);\n    ob = ofpbuf_at_assert(openflow, start, sizeof *ob);\n    ob->len = htons(openflow->size - start);\n    ob->weight = htons(bucket->weight);\n    ob->watch_port = ofputil_port_to_ofp11(bucket->watch_port);\n    ob->watch_group = htonl(bucket->watch_group);\n}\n\nstatic void\nofputil_put_ofp15_bucket(const struct ofputil_bucket *bucket,\n                         uint32_t bucket_id, enum ofp11_group_type group_type,\n                         struct ofpbuf *openflow, enum ofp_version ofp_version)\n{\n    struct ofp15_bucket *ob;\n    size_t start, actions_start, actions_len;\n\n    start = openflow->size;\n    ofpbuf_put_zeros(openflow, sizeof *ob);\n\n    actions_start = openflow->size;\n    ofpacts_put_openflow_actions(bucket->ofpacts, bucket->ofpacts_len,\n                                 openflow, ofp_version);\n    actions_len = openflow->size - actions_start;\n\n    if (group_type == OFPGT11_SELECT) {\n        ofpprop_put_u16(openflow, OFPGBPT15_WEIGHT, bucket->weight);\n    }\n    if (bucket->watch_port != OFPP_ANY) {\n        ofpprop_put_be32(openflow, OFPGBPT15_WATCH_PORT,\n                         ofputil_port_to_ofp11(bucket->watch_port));\n    }\n    if (bucket->watch_group != OFPG_ANY) {\n        ofpprop_put_u32(openflow, OFPGBPT15_WATCH_GROUP, bucket->watch_group);\n    }\n\n    ob = ofpbuf_at_assert(openflow, start, sizeof *ob);\n    ob->len = htons(openflow->size - start);\n    ob->action_array_len = htons(actions_len);\n    ob->bucket_id = htonl(bucket_id);\n}\n\nstatic void\nofputil_put_group_prop_ntr_selection_method(enum ofp_version ofp_version,\n                                            const struct ofputil_group_props *gp,\n                                            struct ofpbuf *openflow)\n{\n    struct ntr_group_prop_selection_method *prop;\n    size_t start;\n\n    start = openflow->size;\n    ofpbuf_put_zeros(openflow, sizeof *prop);\n    oxm_put_field_array(openflow, &gp->fields, ofp_version);\n    prop = ofpbuf_at_assert(openflow, start, sizeof *prop);\n    prop->type = htons(OFPGPT15_EXPERIMENTER);\n    prop->experimenter = htonl(NTR_VENDOR_ID);\n    prop->exp_type = htonl(NTRT_SELECTION_METHOD);\n    strcpy(prop->selection_method, gp->selection_method);\n    prop->selection_method_param = htonll(gp->selection_method_param);\n    ofpprop_end(openflow, start);\n}\n\nstatic void\nofputil_append_ofp11_group_desc_reply(const struct ofputil_group_desc *gds,\n                                      const struct ovs_list *buckets,\n                                      struct ovs_list *replies,\n                                      enum ofp_version version)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    struct ofp11_group_desc_stats *ogds;\n    struct ofputil_bucket *bucket;\n    size_t start_ogds;\n\n    start_ogds = reply->size;\n    ofpbuf_put_zeros(reply, sizeof *ogds);\n    LIST_FOR_EACH (bucket, list_node, buckets) {\n        ofputil_put_ofp11_bucket(bucket, reply, version);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->length = htons(reply->size - start_ogds);\n    ogds->type = gds->type;\n    ogds->group_id = htonl(gds->group_id);\n\n    ofpmp_postappend(replies, start_ogds);\n}\n\nstatic void\nofputil_append_ofp15_group_desc_reply(const struct ofputil_group_desc *gds,\n                                      const struct ovs_list *buckets,\n                                      struct ovs_list *replies,\n                                      enum ofp_version version)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    struct ofp15_group_desc_stats *ogds;\n    struct ofputil_bucket *bucket;\n    size_t start_ogds, start_buckets;\n\n    start_ogds = reply->size;\n    ofpbuf_put_zeros(reply, sizeof *ogds);\n    start_buckets = reply->size;\n    LIST_FOR_EACH (bucket, list_node, buckets) {\n        ofputil_put_ofp15_bucket(bucket, bucket->bucket_id,\n                                 gds->type, reply, version);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->type = gds->type;\n    ogds->group_id = htonl(gds->group_id);\n    ogds->bucket_list_len =  htons(reply->size - start_buckets);\n\n    /* Add group properties */\n    if (gds->props.selection_method[0]) {\n        ofputil_put_group_prop_ntr_selection_method(version, &gds->props,\n                                                    reply);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->length = htons(reply->size - start_ogds);\n\n    ofpmp_postappend(replies, start_ogds);\n}\n\n/* Appends a group stats reply that contains the data in 'gds' to those already\n * present in the list of ofpbufs in 'replies'.  'replies' should have been\n * initialized with ofpmp_init(). */\nvoid\nofputil_append_group_desc_reply(const struct ofputil_group_desc *gds,\n                                const struct ovs_list *buckets,\n                                struct ovs_list *replies)\n{\n    enum ofp_version version = ofpmp_version(replies);\n\n    switch (version)\n    {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        ofputil_append_ofp11_group_desc_reply(gds, buckets, replies, version);\n        break;\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        ofputil_append_ofp15_group_desc_reply(gds, buckets, replies, version);\n        break;\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic enum ofperr\nofputil_pull_ofp11_buckets(struct ofpbuf *msg, size_t buckets_length,\n                           enum ofp_version version, struct ovs_list *buckets)\n{\n    struct ofp11_bucket *ob;\n    uint32_t bucket_id = 0;\n\n    ovs_list_init(buckets);\n    while (buckets_length > 0) {\n        struct ofputil_bucket *bucket;\n        struct ofpbuf ofpacts;\n        enum ofperr error;\n        size_t ob_len;\n\n        ob = (buckets_length >= sizeof *ob\n              ? ofpbuf_try_pull(msg, sizeof *ob)\n              : NULL);\n        if (!ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"buckets end with %\"PRIuSIZE\" leftover bytes\",\n                         buckets_length);\n            ofputil_bucket_list_destroy(buckets);\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        }\n\n        ob_len = ntohs(ob->len);\n        if (ob_len < sizeof *ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" is not valid\", ob_len);\n            ofputil_bucket_list_destroy(buckets);\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        } else if (ob_len > buckets_length) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" exceeds remaining buckets data size %\"PRIuSIZE,\n                         ob_len, buckets_length);\n            ofputil_bucket_list_destroy(buckets);\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        }\n        buckets_length -= ob_len;\n\n        ofpbuf_init(&ofpacts, 0);\n        error = ofpacts_pull_openflow_actions(msg, ob_len - sizeof *ob,\n                                              version, NULL, NULL, &ofpacts);\n        if (error) {\n            ofpbuf_uninit(&ofpacts);\n            ofputil_bucket_list_destroy(buckets);\n            return error;\n        }\n\n        bucket = xzalloc(sizeof *bucket);\n        bucket->weight = ntohs(ob->weight);\n        error = ofputil_port_from_ofp11(ob->watch_port, &bucket->watch_port);\n        if (error) {\n            ofpbuf_uninit(&ofpacts);\n            ofputil_bucket_list_destroy(buckets);\n            free(bucket);\n            return OFPERR_OFPGMFC_BAD_WATCH;\n        }\n        bucket->watch_group = ntohl(ob->watch_group);\n        bucket->bucket_id = bucket_id++;\n\n        bucket->ofpacts = ofpbuf_steal_data(&ofpacts);\n        bucket->ofpacts_len = ofpacts.size;\n        ovs_list_push_back(buckets, &bucket->list_node);\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_pull_ofp15_buckets(struct ofpbuf *msg, size_t buckets_length,\n                           enum ofp_version version, uint8_t group_type,\n                           struct ovs_list *buckets)\n{\n    struct ofp15_bucket *ob;\n\n    ovs_list_init(buckets);\n    while (buckets_length > 0) {\n        struct ofputil_bucket *bucket = NULL;\n        struct ofpbuf ofpacts;\n        enum ofperr err = OFPERR_OFPGMFC_BAD_BUCKET;\n        size_t ob_len, actions_len, properties_len;\n        ovs_be32 watch_port = ofputil_port_to_ofp11(OFPP_ANY);\n        ovs_be32 watch_group = htonl(OFPG_ANY);\n        ovs_be16 weight = htons(group_type == OFPGT11_SELECT ? 1 : 0);\n\n        ofpbuf_init(&ofpacts, 0);\n\n        ob = ofpbuf_try_pull(msg, sizeof *ob);\n        if (!ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"buckets end with %\"PRIuSIZE\n                         \" leftover bytes\", buckets_length);\n            goto err;\n        }\n\n        ob_len = ntohs(ob->len);\n        actions_len = ntohs(ob->action_array_len);\n\n        if (ob_len < sizeof *ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" is not valid\", ob_len);\n            goto err;\n        } else if (ob_len > buckets_length) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket length \"\n                         \"%\"PRIuSIZE\" exceeds remaining buckets data size %\"\n                         PRIuSIZE, ob_len, buckets_length);\n            goto err;\n        } else if (actions_len > ob_len - sizeof *ob) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OpenFlow message bucket actions \"\n                         \"length %\"PRIuSIZE\" exceeds remaining bucket \"\n                         \"data size %\"PRIuSIZE, actions_len,\n                         ob_len - sizeof *ob);\n            goto err;\n        }\n        buckets_length -= ob_len;\n\n        err = ofpacts_pull_openflow_actions(msg, actions_len, version,\n                                            NULL, NULL, &ofpacts);\n        if (err) {\n            goto err;\n        }\n\n        properties_len = ob_len - sizeof *ob - actions_len;\n        struct ofpbuf properties = ofpbuf_const_initializer(\n            ofpbuf_pull(msg, properties_len), properties_len);\n        while (properties.size > 0) {\n            struct ofpbuf payload;\n            uint64_t type;\n\n            err = ofpprop_pull(&properties, &payload, &type);\n            if (err) {\n                goto err;\n            }\n\n            switch (type) {\n            case OFPGBPT15_WEIGHT:\n                err = ofpprop_parse_be16(&payload, &weight);\n                break;\n\n            case OFPGBPT15_WATCH_PORT:\n                err = ofpprop_parse_be32(&payload, &watch_port);\n                break;\n\n            case OFPGBPT15_WATCH_GROUP:\n                err = ofpprop_parse_be32(&payload, &watch_group);\n                break;\n\n            default:\n                err = OFPPROP_UNKNOWN(false, \"group bucket\", type);\n                break;\n            }\n\n            if (err) {\n                goto err;\n            }\n        }\n\n        bucket = xzalloc(sizeof *bucket);\n\n        bucket->weight = ntohs(weight);\n        err = ofputil_port_from_ofp11(watch_port, &bucket->watch_port);\n        if (err) {\n            err = OFPERR_OFPGMFC_BAD_WATCH;\n            goto err;\n        }\n        bucket->watch_group = ntohl(watch_group);\n        bucket->bucket_id = ntohl(ob->bucket_id);\n        if (bucket->bucket_id > OFPG15_BUCKET_MAX) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"bucket id (%u) is out of range\",\n                         bucket->bucket_id);\n            err = OFPERR_OFPGMFC_BAD_BUCKET;\n            goto err;\n        }\n\n        bucket->ofpacts = ofpbuf_steal_data(&ofpacts);\n        bucket->ofpacts_len = ofpacts.size;\n        ovs_list_push_back(buckets, &bucket->list_node);\n\n        continue;\n\n    err:\n        free(bucket);\n        ofpbuf_uninit(&ofpacts);\n        ofputil_bucket_list_destroy(buckets);\n        return err;\n    }\n\n    if (ofputil_bucket_check_duplicate_id(buckets)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"Duplicate bucket id\");\n        ofputil_bucket_list_destroy(buckets);\n        return OFPERR_OFPGMFC_BAD_BUCKET;\n    }\n\n    return 0;\n}\n\nstatic void\nofputil_init_group_properties(struct ofputil_group_props *gp)\n{\n    memset(gp, 0, sizeof *gp);\n}\n\nvoid\nofputil_group_properties_copy(struct ofputil_group_props *to,\n                              const struct ofputil_group_props *from)\n{\n    *to = *from;\n    to->fields.values = xmemdup(from->fields.values, from->fields.values_size);\n}\n\nvoid\nofputil_group_properties_destroy(struct ofputil_group_props *gp)\n{\n    free(gp->fields.values);\n}\n\nstatic enum ofperr\nparse_group_prop_ntr_selection_method(struct ofpbuf *payload,\n                                      enum ofp11_group_type group_type,\n                                      enum ofp15_group_mod_command group_cmd,\n                                      struct ofputil_group_props *gp)\n{\n    struct ntr_group_prop_selection_method *prop = payload->data;\n    size_t fields_len, method_len;\n    enum ofperr error;\n\n    switch (group_type) {\n    case OFPGT11_SELECT:\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_INDIRECT:\n    case OFPGT11_FF:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                    \"only allowed for select groups\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    default:\n        return OFPERR_OFPGMFC_BAD_TYPE;\n    }\n\n    switch (group_cmd) {\n    case OFPGC15_ADD:\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n        break;\n    case OFPGC15_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n    case OFPGC15_REMOVE_BUCKET:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                    \"only allowed for add and delete group modifications\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    default:\n        return OFPERR_OFPGMFC_BAD_COMMAND;\n    }\n\n    if (payload->size < sizeof *prop) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property \"\n                    \"length %u is not valid\", payload->size);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    method_len = strnlen(prop->selection_method, NTR_MAX_SELECTION_METHOD_LEN);\n\n    if (method_len == NTR_MAX_SELECTION_METHOD_LEN) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method is not null terminated\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    if (strcmp(\"hash\", prop->selection_method)\n        && strcmp(\"dp_hash\", prop->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method '%s' is not supported\",\n                    prop->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    /* 'method_len' is now non-zero. */\n\n    strcpy(gp->selection_method, prop->selection_method);\n    gp->selection_method_param = ntohll(prop->selection_method_param);\n\n    ofpbuf_pull(payload, sizeof *prop);\n\n    fields_len = ntohs(prop->length) - sizeof *prop;\n    if (fields_len && strcmp(\"hash\", gp->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method %s \"\n                    \"does not support fields\", gp->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    error = oxm_pull_field_array(payload->data, fields_len,\n                                 &gp->fields);\n    if (error) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method fields are invalid\");\n        return error;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\nparse_ofp15_group_properties(struct ofpbuf *msg,\n                             enum ofp11_group_type group_type,\n                             enum ofp15_group_mod_command group_cmd,\n                             struct ofputil_group_props *gp,\n                             size_t properties_len)\n{\n    struct ofpbuf properties = ofpbuf_const_initializer(\n        ofpbuf_pull(msg, properties_len), properties_len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPPROP_EXP(NTR_VENDOR_ID, NTRT_SELECTION_METHOD):\n        case OFPPROP_EXP(NTR_COMPAT_VENDOR_ID, NTRT_SELECTION_METHOD):\n            error = parse_group_prop_ntr_selection_method(&payload, group_type,\n                                                          group_cmd, gp);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(false, \"group\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nofputil_decode_ofp11_group_desc_reply(struct ofputil_group_desc *gd,\n                                      struct ofpbuf *msg,\n                                      enum ofp_version version)\n{\n    struct ofp11_group_desc_stats *ogds;\n    size_t length;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    ogds = ofpbuf_try_pull(msg, sizeof *ogds);\n    if (!ogds) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    gd->type = ogds->type;\n    gd->group_id = ntohl(ogds->group_id);\n\n    length = ntohs(ogds->length);\n    if (length < sizeof *ogds || length - sizeof *ogds > msg->size) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply claims invalid \"\n                     \"length %\"PRIuSIZE, length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    return ofputil_pull_ofp11_buckets(msg, length - sizeof *ogds, version,\n                                      &gd->buckets);\n}\n\nstatic int\nofputil_decode_ofp15_group_desc_reply(struct ofputil_group_desc *gd,\n                                      struct ofpbuf *msg,\n                                      enum ofp_version version)\n{\n    struct ofp15_group_desc_stats *ogds;\n    uint16_t length, bucket_list_len;\n    int error;\n\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    ogds = ofpbuf_try_pull(msg, sizeof *ogds);\n    if (!ogds) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply has %\"PRIu32\" \"\n                     \"leftover bytes at end\", msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    gd->type = ogds->type;\n    gd->group_id = ntohl(ogds->group_id);\n\n    length = ntohs(ogds->length);\n    if (length < sizeof *ogds || length - sizeof *ogds > msg->size) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply claims invalid \"\n                     \"length %u\", length);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    bucket_list_len = ntohs(ogds->bucket_list_len);\n    if (length < bucket_list_len + sizeof *ogds) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST11_GROUP_DESC reply claims invalid \"\n                     \"bucket list length %u\", bucket_list_len);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    error = ofputil_pull_ofp15_buckets(msg, bucket_list_len, version, gd->type,\n                                       &gd->buckets);\n    if (error) {\n        return error;\n    }\n\n    /* By definition group desc messages don't have a group mod command.\n     * However, parse_group_prop_ntr_selection_method() checks to make sure\n     * that the command is OFPGC15_ADD or OFPGC15_DELETE to guard\n     * against group mod messages with other commands supplying\n     * a NTR selection method group experimenter property.\n     * Such properties are valid for group desc replies so\n     * claim that the group mod command is OFPGC15_ADD to\n     * satisfy the check in parse_group_prop_ntr_selection_method() */\n    error = parse_ofp15_group_properties(\n        msg, gd->type, OFPGC15_ADD, &gd->props,\n        length - sizeof *ogds - bucket_list_len);\n    if (error) {\n        ofputil_bucket_list_destroy(&gd->buckets);\n    }\n    return error;\n}\n\n/* Converts a group description reply in 'msg' into an abstract\n * ofputil_group_desc in 'gd'.\n *\n * Multiple group description replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  The caller must initially leave 'msg''s layer pointers\n * null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_group_desc_reply(struct ofputil_group_desc *gd,\n                                struct ofpbuf *msg, enum ofp_version version)\n{\n    ofputil_init_group_properties(&gd->props);\n\n    switch (version)\n    {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        return ofputil_decode_ofp11_group_desc_reply(gd, msg, version);\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return ofputil_decode_ofp15_group_desc_reply(gd, msg, version);\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nvoid\nofputil_uninit_group_mod(struct ofputil_group_mod *gm)\n{\n    ofputil_bucket_list_destroy(&gm->buckets);\n    ofputil_group_properties_destroy(&gm->props);\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp11_group_mod(enum ofp_version ofp_version,\n                               const struct ofputil_group_mod *gm)\n{\n    struct ofpbuf *b;\n    struct ofp11_group_mod *ogm;\n    size_t start_ogm;\n    struct ofputil_bucket *bucket;\n\n    b = ofpraw_alloc(OFPRAW_OFPT11_GROUP_MOD, ofp_version, 0);\n    start_ogm = b->size;\n    ofpbuf_put_zeros(b, sizeof *ogm);\n\n    LIST_FOR_EACH (bucket, list_node, &gm->buckets) {\n        ofputil_put_ofp11_bucket(bucket, b, ofp_version);\n    }\n    ogm = ofpbuf_at_assert(b, start_ogm, sizeof *ogm);\n    ogm->command = htons(gm->command);\n    ogm->type = gm->type;\n    ogm->group_id = htonl(gm->group_id);\n\n    return b;\n}\n\nstatic struct ofpbuf *\nofputil_encode_ofp15_group_mod(enum ofp_version ofp_version,\n                               const struct ofputil_group_mod *gm)\n{\n    struct ofpbuf *b;\n    struct ofp15_group_mod *ogm;\n    size_t start_ogm;\n    struct ofputil_bucket *bucket;\n    struct id_pool *bucket_ids = NULL;\n\n    b = ofpraw_alloc(OFPRAW_OFPT15_GROUP_MOD, ofp_version, 0);\n    start_ogm = b->size;\n    ofpbuf_put_zeros(b, sizeof *ogm);\n\n    LIST_FOR_EACH (bucket, list_node, &gm->buckets) {\n        uint32_t bucket_id;\n\n        /* Generate a bucket id if none was supplied */\n        if (bucket->bucket_id > OFPG15_BUCKET_MAX) {\n            if (!bucket_ids) {\n                const struct ofputil_bucket *bkt;\n\n                bucket_ids = id_pool_create(0, OFPG15_BUCKET_MAX + 1);\n\n                /* Mark all bucket_ids that are present in gm\n                 * as used in the pool. */\n                LIST_FOR_EACH_REVERSE (bkt, list_node, &gm->buckets) {\n                    if (bkt == bucket) {\n                        break;\n                    }\n                    if (bkt->bucket_id <= OFPG15_BUCKET_MAX) {\n                        id_pool_add(bucket_ids, bkt->bucket_id);\n                    }\n                }\n            }\n\n            if (!id_pool_alloc_id(bucket_ids, &bucket_id)) {\n                OVS_NOT_REACHED();\n            }\n        } else {\n            bucket_id = bucket->bucket_id;\n        }\n\n        ofputil_put_ofp15_bucket(bucket, bucket_id, gm->type, b, ofp_version);\n    }\n    ogm = ofpbuf_at_assert(b, start_ogm, sizeof *ogm);\n    ogm->command = htons(gm->command);\n    ogm->type = gm->type;\n    ogm->group_id = htonl(gm->group_id);\n    ogm->command_bucket_id = htonl(gm->command_bucket_id);\n    ogm->bucket_array_len = htons(b->size - start_ogm - sizeof *ogm);\n\n    /* Add group properties */\n    if (gm->props.selection_method[0]) {\n        ofputil_put_group_prop_ntr_selection_method(ofp_version, &gm->props, b);\n    }\n\n    id_pool_destroy(bucket_ids);\n    return b;\n}\n\nstatic void\nbad_group_cmd(enum ofp15_group_mod_command cmd)\n{\n    const char *opt_version;\n    const char *version;\n    const char *cmd_str;\n\n    switch (cmd) {\n    case OFPGC15_ADD:\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n    case OFPGC15_DELETE:\n        version = \"1.1\";\n        opt_version = \"11\";\n        break;\n\n    case OFPGC15_INSERT_BUCKET:\n    case OFPGC15_REMOVE_BUCKET:\n        version = \"1.5\";\n        opt_version = \"15\";\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    switch (cmd) {\n    case OFPGC15_ADD:\n        cmd_str = \"add-group\";\n        break;\n\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n        cmd_str = \"mod-group\";\n        break;\n\n    case OFPGC15_DELETE:\n        cmd_str = \"del-group\";\n        break;\n\n    case OFPGC15_INSERT_BUCKET:\n        cmd_str = \"insert-bucket\";\n        break;\n\n    case OFPGC15_REMOVE_BUCKET:\n        cmd_str = \"remove-bucket\";\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    ovs_fatal(0, \"%s needs OpenFlow %s or later (\\'-O OpenFlow%s\\')\",\n              cmd_str, version, opt_version);\n\n}\n\n/* Converts abstract group mod 'gm' into a message for OpenFlow version\n * 'ofp_version' and returns the message. */\nstruct ofpbuf *\nofputil_encode_group_mod(enum ofp_version ofp_version,\n                         const struct ofputil_group_mod *gm)\n{\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n        bad_group_cmd(gm->command);\n\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        if (gm->command > OFPGC11_DELETE && gm->command != OFPGC11_ADD_OR_MOD) {\n            bad_group_cmd(gm->command);\n        }\n        return ofputil_encode_ofp11_group_mod(ofp_version, gm);\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        return ofputil_encode_ofp15_group_mod(ofp_version, gm);\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic enum ofperr\nofputil_pull_ofp11_group_mod(struct ofpbuf *msg, enum ofp_version ofp_version,\n                             struct ofputil_group_mod *gm)\n{\n    const struct ofp11_group_mod *ogm;\n    enum ofperr error;\n\n    ogm = ofpbuf_pull(msg, sizeof *ogm);\n    gm->command = ntohs(ogm->command);\n    gm->type = ogm->type;\n    gm->group_id = ntohl(ogm->group_id);\n    gm->command_bucket_id = OFPG15_BUCKET_ALL;\n\n    error = ofputil_pull_ofp11_buckets(msg, msg->size, ofp_version,\n                                       &gm->buckets);\n\n    /* OF1.3.5+ prescribes an error when an OFPGC_DELETE includes buckets. */\n    if (!error\n        && ofp_version >= OFP13_VERSION\n        && gm->command == OFPGC11_DELETE\n        && !ovs_list_is_empty(&gm->buckets)) {\n        error = OFPERR_OFPGMFC_INVALID_GROUP;\n        ofputil_bucket_list_destroy(&gm->buckets);\n    }\n\n    return error;\n}\n\nstatic enum ofperr\nofputil_pull_ofp15_group_mod(struct ofpbuf *msg, enum ofp_version ofp_version,\n                             struct ofputil_group_mod *gm)\n{\n    const struct ofp15_group_mod *ogm;\n    uint16_t bucket_list_len;\n    enum ofperr error = OFPERR_OFPGMFC_BAD_BUCKET;\n\n    ogm = ofpbuf_pull(msg, sizeof *ogm);\n    gm->command = ntohs(ogm->command);\n    gm->type = ogm->type;\n    gm->group_id = ntohl(ogm->group_id);\n\n    gm->command_bucket_id = ntohl(ogm->command_bucket_id);\n    switch (gm->command) {\n    case OFPGC15_REMOVE_BUCKET:\n        if (gm->command_bucket_id == OFPG15_BUCKET_ALL) {\n            error = 0;\n        }\n        /* Fall through */\n    case OFPGC15_INSERT_BUCKET:\n        if (gm->command_bucket_id <= OFPG15_BUCKET_MAX ||\n            gm->command_bucket_id == OFPG15_BUCKET_FIRST\n            || gm->command_bucket_id == OFPG15_BUCKET_LAST) {\n            error = 0;\n        }\n        break;\n\n    case OFPGC11_ADD:\n    case OFPGC11_MODIFY:\n    case OFPGC11_ADD_OR_MOD:\n    case OFPGC11_DELETE:\n    default:\n        if (gm->command_bucket_id == OFPG15_BUCKET_ALL) {\n            error = 0;\n        }\n        break;\n    }\n    if (error) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"group command bucket id (%u) is out of range\",\n                     gm->command_bucket_id);\n        return OFPERR_OFPGMFC_BAD_BUCKET;\n    }\n\n    bucket_list_len = ntohs(ogm->bucket_array_len);\n    if (bucket_list_len > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    error = ofputil_pull_ofp15_buckets(msg, bucket_list_len, ofp_version,\n                                       gm->type, &gm->buckets);\n    if (error) {\n        return error;\n    }\n\n    error = parse_ofp15_group_properties(msg, gm->type, gm->command,\n                                         &gm->props, msg->size);\n    if (error) {\n        ofputil_bucket_list_destroy(&gm->buckets);\n    }\n    return error;\n}\n\nstatic enum ofperr\nofputil_check_group_mod(const struct ofputil_group_mod *gm)\n{\n    switch (gm->type) {\n    case OFPGT11_INDIRECT:\n        if (gm->command != OFPGC11_DELETE\n            && !ovs_list_is_singleton(&gm->buckets) ) {\n            return OFPERR_OFPGMFC_INVALID_GROUP;\n        }\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_SELECT:\n    case OFPGT11_FF:\n        break;\n    default:\n        return OFPERR_OFPGMFC_BAD_TYPE;\n    }\n\n    switch (gm->command) {\n    case OFPGC11_ADD:\n    case OFPGC11_MODIFY:\n    case OFPGC11_ADD_OR_MOD:\n    case OFPGC11_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n        break;\n    case OFPGC15_REMOVE_BUCKET:\n        if (!ovs_list_is_empty(&gm->buckets)) {\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        }\n        break;\n    default:\n        return OFPERR_OFPGMFC_BAD_COMMAND;\n    }\n\n    struct ofputil_bucket *bucket;\n    LIST_FOR_EACH (bucket, list_node, &gm->buckets) {\n        if (bucket->weight && gm->type != OFPGT11_SELECT) {\n            return OFPERR_OFPGMFC_INVALID_GROUP;\n        }\n\n        switch (gm->type) {\n        case OFPGT11_ALL:\n        case OFPGT11_INDIRECT:\n            if (ofputil_bucket_has_liveness(bucket)) {\n                return OFPERR_OFPGMFC_WATCH_UNSUPPORTED;\n            }\n            break;\n        case OFPGT11_SELECT:\n            break;\n        case OFPGT11_FF:\n            if (!ofputil_bucket_has_liveness(bucket)) {\n                return OFPERR_OFPGMFC_INVALID_GROUP;\n            }\n            break;\n        default:\n            /* Returning BAD TYPE to be consistent\n             * though gm->type has been checked already. */\n            return OFPERR_OFPGMFC_BAD_TYPE;\n        }\n    }\n\n    return 0;\n}\n\n/* Converts OpenFlow group mod message 'oh' into an abstract group mod in\n * 'gm'.  Returns 0 if successful, otherwise an OpenFlow error code. */\nenum ofperr\nofputil_decode_group_mod(const struct ofp_header *oh,\n                         struct ofputil_group_mod *gm)\n{\n    ofputil_init_group_properties(&gm->props);\n\n    enum ofp_version ofp_version = oh->version;\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&msg);\n\n    enum ofperr err;\n    switch (ofp_version)\n    {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n        err = ofputil_pull_ofp11_group_mod(&msg, ofp_version, gm);\n        break;\n\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        err = ofputil_pull_ofp15_group_mod(&msg, ofp_version, gm);\n        break;\n\n    case OFP10_VERSION:\n    default:\n        OVS_NOT_REACHED();\n    }\n    if (err) {\n        return err;\n    }\n\n    err = ofputil_check_group_mod(gm);\n    if (err) {\n        ofputil_uninit_group_mod(gm);\n    }\n    return err;\n}\n\n/* Destroys 'bms'. */\nvoid\nofputil_free_bundle_msgs(struct ofputil_bundle_msg *bms, size_t n_bms)\n{\n    for (size_t i = 0; i < n_bms; i++) {\n        switch ((int)bms[i].type) {\n        case OFPTYPE_FLOW_MOD:\n            free(CONST_CAST(struct ofpact *, bms[i].fm.ofpacts));\n            break;\n        case OFPTYPE_GROUP_MOD:\n            ofputil_uninit_group_mod(&bms[i].gm);\n            break;\n        case OFPTYPE_PACKET_OUT:\n            free(bms[i].po.ofpacts);\n            free(CONST_CAST(void *, bms[i].po.packet));\n            break;\n        default:\n            break;\n        }\n    }\n    free(bms);\n}\n\nvoid\nofputil_encode_bundle_msgs(const struct ofputil_bundle_msg *bms,\n                           size_t n_bms, struct ovs_list *requests,\n                           enum ofputil_protocol protocol)\n{\n    enum ofp_version version = ofputil_protocol_to_ofp_version(protocol);\n\n    for (size_t i = 0; i < n_bms; i++) {\n        struct ofpbuf *request = NULL;\n\n        switch ((int)bms[i].type) {\n        case OFPTYPE_FLOW_MOD:\n            request = ofputil_encode_flow_mod(&bms[i].fm, protocol);\n            break;\n        case OFPTYPE_GROUP_MOD:\n            request = ofputil_encode_group_mod(version, &bms[i].gm);\n            break;\n        case OFPTYPE_PACKET_OUT:\n            request = ofputil_encode_packet_out(&bms[i].po, protocol);\n            break;\n        default:\n            break;\n        }\n        if (request) {\n            ovs_list_push_back(requests, &request->list_node);\n        }\n    }\n}\n\n/* Parse a queue status request message into 'oqsr'.\n * Returns 0 if successful, otherwise an OFPERR_* number. */\nenum ofperr\nofputil_decode_queue_stats_request(const struct ofp_header *request,\n                                   struct ofputil_queue_stats_request *oqsr)\n{\n    switch ((enum ofp_version)request->version) {\n    case OFP16_VERSION:\n    case OFP15_VERSION:\n    case OFP14_VERSION:\n    case OFP13_VERSION:\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        const struct ofp11_queue_stats_request *qsr11 = ofpmsg_body(request);\n        oqsr->queue_id = ntohl(qsr11->queue_id);\n        return ofputil_port_from_ofp11(qsr11->port_no, &oqsr->port_no);\n    }\n\n    case OFP10_VERSION: {\n        const struct ofp10_queue_stats_request *qsr10 = ofpmsg_body(request);\n        oqsr->queue_id = ntohl(qsr10->queue_id);\n        oqsr->port_no = u16_to_ofp(ntohs(qsr10->port_no));\n        /* OF 1.0 uses OFPP_ALL for OFPP_ANY */\n        if (oqsr->port_no == OFPP_ALL) {\n            oqsr->port_no = OFPP_ANY;\n        }\n        return 0;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Encode a queue stats request for 'oqsr', the encoded message\n * will be for OpenFlow version 'ofp_version'. Returns message\n * as a struct ofpbuf. Returns encoded message on success, NULL on error. */\nstruct ofpbuf *\nofputil_encode_queue_stats_request(enum ofp_version ofp_version,\n                                   const struct ofputil_queue_stats_request *oqsr)\n{\n    struct ofpbuf *request;\n\n    switch (ofp_version) {\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp11_queue_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST11_QUEUE_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        req->port_no = ofputil_port_to_ofp11(oqsr->port_no);\n        req->queue_id = htonl(oqsr->queue_id);\n        break;\n    }\n    case OFP10_VERSION: {\n        struct ofp10_queue_stats_request *req;\n        request = ofpraw_alloc(OFPRAW_OFPST10_QUEUE_REQUEST, ofp_version, 0);\n        req = ofpbuf_put_zeros(request, sizeof *req);\n        /* OpenFlow 1.0 needs OFPP_ALL instead of OFPP_ANY */\n        req->port_no = htons(ofp_to_u16(oqsr->port_no == OFPP_ANY\n                                        ? OFPP_ALL : oqsr->port_no));\n        req->queue_id = htonl(oqsr->queue_id);\n        break;\n    }\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\n/* Returns the number of queue stats elements in OFPTYPE_QUEUE_STATS_REPLY\n * message 'oh'. */\nsize_t\nofputil_count_queue_stats(const struct ofp_header *oh)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&b);\n\n    for (size_t n = 0; ; n++) {\n        struct ofputil_queue_stats qs;\n        if (ofputil_decode_queue_stats(&qs, &b)) {\n            return n;\n        }\n    }\n}\n\nstatic enum ofperr\nofputil_queue_stats_from_ofp10(struct ofputil_queue_stats *oqs,\n                               const struct ofp10_queue_stats *qs10)\n{\n    oqs->port_no = u16_to_ofp(ntohs(qs10->port_no));\n    oqs->queue_id = ntohl(qs10->queue_id);\n    oqs->tx_bytes = ntohll(get_32aligned_be64(&qs10->tx_bytes));\n    oqs->tx_packets = ntohll(get_32aligned_be64(&qs10->tx_packets));\n    oqs->tx_errors = ntohll(get_32aligned_be64(&qs10->tx_errors));\n    oqs->duration_sec = oqs->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_queue_stats_from_ofp11(struct ofputil_queue_stats *oqs,\n                               const struct ofp11_queue_stats *qs11)\n{\n    enum ofperr error;\n\n    error = ofputil_port_from_ofp11(qs11->port_no, &oqs->port_no);\n    if (error) {\n        return error;\n    }\n\n    oqs->queue_id = ntohl(qs11->queue_id);\n    oqs->tx_bytes = ntohll(qs11->tx_bytes);\n    oqs->tx_packets = ntohll(qs11->tx_packets);\n    oqs->tx_errors = ntohll(qs11->tx_errors);\n    oqs->duration_sec = oqs->duration_nsec = UINT32_MAX;\n\n    return 0;\n}\n\nstatic enum ofperr\nofputil_queue_stats_from_ofp13(struct ofputil_queue_stats *oqs,\n                               const struct ofp13_queue_stats *qs13)\n{\n    enum ofperr error = ofputil_queue_stats_from_ofp11(oqs, &qs13->qs);\n    if (!error) {\n        oqs->duration_sec = ntohl(qs13->duration_sec);\n        oqs->duration_nsec = ntohl(qs13->duration_nsec);\n    }\n\n    return error;\n}\n\nstatic enum ofperr\nofputil_pull_ofp14_queue_stats(struct ofputil_queue_stats *oqs,\n                               struct ofpbuf *msg)\n{\n    const struct ofp14_queue_stats *qs14;\n    size_t len;\n\n    qs14 = ofpbuf_try_pull(msg, sizeof *qs14);\n    if (!qs14) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    len = ntohs(qs14->length);\n    if (len < sizeof *qs14 || len - sizeof *qs14 > msg->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    ofpbuf_pull(msg, len - sizeof *qs14);\n\n    /* No properties yet defined, so ignore them for now. */\n\n    return ofputil_queue_stats_from_ofp13(oqs, &qs14->qs);\n}\n\n/* Converts an OFPST_QUEUE_STATS reply in 'msg' into an abstract\n * ofputil_queue_stats in 'qs'.\n *\n * Multiple OFPST_QUEUE_STATS replies can be packed into a single OpenFlow\n * message.  Calling this function multiple times for a single 'msg' iterates\n * through the replies.  The caller must initially leave 'msg''s layer pointers\n * null and not modify them between calls.\n *\n * Returns 0 if successful, EOF if no replies were left in this 'msg',\n * otherwise a positive errno value. */\nint\nofputil_decode_queue_stats(struct ofputil_queue_stats *qs, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_QUEUE_REPLY) {\n        return ofputil_pull_ofp14_queue_stats(qs, msg);\n    } else if (raw == OFPRAW_OFPST13_QUEUE_REPLY) {\n        const struct ofp13_queue_stats *qs13;\n\n        qs13 = ofpbuf_try_pull(msg, sizeof *qs13);\n        if (!qs13) {\n            goto bad_len;\n        }\n        return ofputil_queue_stats_from_ofp13(qs, qs13);\n    } else if (raw == OFPRAW_OFPST11_QUEUE_REPLY) {\n        const struct ofp11_queue_stats *qs11;\n\n        qs11 = ofpbuf_try_pull(msg, sizeof *qs11);\n        if (!qs11) {\n            goto bad_len;\n        }\n        return ofputil_queue_stats_from_ofp11(qs, qs11);\n    } else if (raw == OFPRAW_OFPST10_QUEUE_REPLY) {\n        const struct ofp10_queue_stats *qs10;\n\n        qs10 = ofpbuf_try_pull(msg, sizeof *qs10);\n        if (!qs10) {\n            goto bad_len;\n        }\n        return ofputil_queue_stats_from_ofp10(qs, qs10);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n bad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_QUEUE reply has %\"PRIu32\" leftover \"\n                 \"bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n\nstatic void\nofputil_queue_stats_to_ofp10(const struct ofputil_queue_stats *oqs,\n                             struct ofp10_queue_stats *qs10)\n{\n    qs10->port_no = htons(ofp_to_u16(oqs->port_no));\n    memset(qs10->pad, 0, sizeof qs10->pad);\n    qs10->queue_id = htonl(oqs->queue_id);\n    put_32aligned_be64(&qs10->tx_bytes, htonll(oqs->tx_bytes));\n    put_32aligned_be64(&qs10->tx_packets, htonll(oqs->tx_packets));\n    put_32aligned_be64(&qs10->tx_errors, htonll(oqs->tx_errors));\n}\n\nstatic void\nofputil_queue_stats_to_ofp11(const struct ofputil_queue_stats *oqs,\n                             struct ofp11_queue_stats *qs11)\n{\n    qs11->port_no = ofputil_port_to_ofp11(oqs->port_no);\n    qs11->queue_id = htonl(oqs->queue_id);\n    qs11->tx_bytes = htonll(oqs->tx_bytes);\n    qs11->tx_packets = htonll(oqs->tx_packets);\n    qs11->tx_errors = htonll(oqs->tx_errors);\n}\n\nstatic void\nofputil_queue_stats_to_ofp13(const struct ofputil_queue_stats *oqs,\n                             struct ofp13_queue_stats *qs13)\n{\n    ofputil_queue_stats_to_ofp11(oqs, &qs13->qs);\n    if (oqs->duration_sec != UINT32_MAX) {\n        qs13->duration_sec = htonl(oqs->duration_sec);\n        qs13->duration_nsec = htonl(oqs->duration_nsec);\n    } else {\n        qs13->duration_sec = OVS_BE32_MAX;\n        qs13->duration_nsec = OVS_BE32_MAX;\n    }\n}\n\nstatic void\nofputil_queue_stats_to_ofp14(const struct ofputil_queue_stats *oqs,\n                             struct ofp14_queue_stats *qs14)\n{\n    qs14->length = htons(sizeof *qs14);\n    memset(qs14->pad, 0, sizeof qs14->pad);\n    ofputil_queue_stats_to_ofp13(oqs, &qs14->qs);\n}\n\n\n/* Encode a queue stat for 'oqs' and append it to 'replies'. */\nvoid\nofputil_append_queue_stat(struct ovs_list *replies,\n                          const struct ofputil_queue_stats *oqs)\n{\n    switch (ofpmp_version(replies)) {\n    case OFP13_VERSION: {\n        struct ofp13_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp13(oqs, reply);\n        break;\n    }\n\n    case OFP12_VERSION:\n    case OFP11_VERSION: {\n        struct ofp11_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp11(oqs, reply);\n        break;\n    }\n\n    case OFP10_VERSION: {\n        struct ofp10_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp10(oqs, reply);\n        break;\n    }\n\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION: {\n        struct ofp14_queue_stats *reply = ofpmp_append(replies, sizeof *reply);\n        ofputil_queue_stats_to_ofp14(oqs, reply);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nenum ofperr\nofputil_decode_bundle_ctrl(const struct ofp_header *oh,\n                           struct ofputil_bundle_ctrl_msg *msg)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    ovs_assert(raw == OFPRAW_OFPT14_BUNDLE_CONTROL\n               || raw == OFPRAW_ONFT13_BUNDLE_CONTROL);\n\n    const struct ofp14_bundle_ctrl_msg *m = b.msg;\n    msg->bundle_id = ntohl(m->bundle_id);\n    msg->type = ntohs(m->type);\n    msg->flags = ntohs(m->flags);\n\n    return 0;\n}\n\nstruct ofpbuf *\nofputil_encode_bundle_ctrl_request(enum ofp_version ofp_version,\n                                   struct ofputil_bundle_ctrl_msg *bc)\n{\n    struct ofpbuf *request;\n    struct ofp14_bundle_ctrl_msg *m;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        ovs_fatal(0, \"bundles need OpenFlow 1.3 or later \"\n                     \"(\\'-O OpenFlow14\\')\");\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        request = ofpraw_alloc(ofp_version == OFP13_VERSION\n                               ? OFPRAW_ONFT13_BUNDLE_CONTROL\n                               : OFPRAW_OFPT14_BUNDLE_CONTROL, ofp_version, 0);\n        m = ofpbuf_put_zeros(request, sizeof *m);\n\n        m->bundle_id = htonl(bc->bundle_id);\n        m->type = htons(bc->type);\n        m->flags = htons(bc->flags);\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n\nstruct ofpbuf *\nofputil_encode_bundle_ctrl_reply(const struct ofp_header *oh,\n                                 struct ofputil_bundle_ctrl_msg *msg)\n{\n    struct ofpbuf *buf;\n    struct ofp14_bundle_ctrl_msg *m;\n\n    buf = ofpraw_alloc_reply(oh->version == OFP13_VERSION\n                             ? OFPRAW_ONFT13_BUNDLE_CONTROL\n                             : OFPRAW_OFPT14_BUNDLE_CONTROL, oh, 0);\n    m = ofpbuf_put_zeros(buf, sizeof *m);\n\n    m->bundle_id = htonl(msg->bundle_id);\n    m->type = htons(msg->type);\n    m->flags = htons(msg->flags);\n\n    return buf;\n}\n\n/* Return true for bundlable state change requests, false for other messages.\n */\nstatic bool\nofputil_is_bundlable(enum ofptype type)\n{\n    switch (type) {\n        /* Minimum required by OpenFlow 1.4. */\n    case OFPTYPE_PORT_MOD:\n    case OFPTYPE_FLOW_MOD:\n        /* Other supported types. */\n    case OFPTYPE_GROUP_MOD:\n    case OFPTYPE_PACKET_OUT:\n        return true;\n\n        /* Nice to have later. */\n    case OFPTYPE_FLOW_MOD_TABLE_ID:\n    case OFPTYPE_TABLE_MOD:\n    case OFPTYPE_METER_MOD:\n    case OFPTYPE_NXT_TLV_TABLE_MOD:\n\n        /* Not to be bundlable. */\n    case OFPTYPE_ECHO_REQUEST:\n    case OFPTYPE_FEATURES_REQUEST:\n    case OFPTYPE_GET_CONFIG_REQUEST:\n    case OFPTYPE_SET_CONFIG:\n    case OFPTYPE_BARRIER_REQUEST:\n    case OFPTYPE_ROLE_REQUEST:\n    case OFPTYPE_ECHO_REPLY:\n    case OFPTYPE_SET_FLOW_FORMAT:\n    case OFPTYPE_SET_PACKET_IN_FORMAT:\n    case OFPTYPE_SET_CONTROLLER_ID:\n    case OFPTYPE_FLOW_AGE:\n    case OFPTYPE_FLOW_MONITOR_CANCEL:\n    case OFPTYPE_SET_ASYNC_CONFIG:\n    case OFPTYPE_GET_ASYNC_REQUEST:\n    case OFPTYPE_DESC_STATS_REQUEST:\n    case OFPTYPE_FLOW_STATS_REQUEST:\n    case OFPTYPE_AGGREGATE_STATS_REQUEST:\n    case OFPTYPE_TABLE_STATS_REQUEST:\n    case OFPTYPE_TABLE_FEATURES_STATS_REQUEST:\n    case OFPTYPE_TABLE_DESC_REQUEST:\n    case OFPTYPE_PORT_STATS_REQUEST:\n    case OFPTYPE_QUEUE_STATS_REQUEST:\n    case OFPTYPE_PORT_DESC_STATS_REQUEST:\n    case OFPTYPE_FLOW_MONITOR_STATS_REQUEST:\n    case OFPTYPE_METER_STATS_REQUEST:\n    case OFPTYPE_METER_CONFIG_STATS_REQUEST:\n    case OFPTYPE_METER_FEATURES_STATS_REQUEST:\n    case OFPTYPE_GROUP_STATS_REQUEST:\n    case OFPTYPE_GROUP_DESC_STATS_REQUEST:\n    case OFPTYPE_GROUP_FEATURES_STATS_REQUEST:\n    case OFPTYPE_QUEUE_GET_CONFIG_REQUEST:\n    case OFPTYPE_BUNDLE_CONTROL:\n    case OFPTYPE_BUNDLE_ADD_MESSAGE:\n    case OFPTYPE_HELLO:\n    case OFPTYPE_ERROR:\n    case OFPTYPE_FEATURES_REPLY:\n    case OFPTYPE_GET_CONFIG_REPLY:\n    case OFPTYPE_PACKET_IN:\n    case OFPTYPE_FLOW_REMOVED:\n    case OFPTYPE_PORT_STATUS:\n    case OFPTYPE_BARRIER_REPLY:\n    case OFPTYPE_QUEUE_GET_CONFIG_REPLY:\n    case OFPTYPE_DESC_STATS_REPLY:\n    case OFPTYPE_FLOW_STATS_REPLY:\n    case OFPTYPE_QUEUE_STATS_REPLY:\n    case OFPTYPE_PORT_STATS_REPLY:\n    case OFPTYPE_TABLE_STATS_REPLY:\n    case OFPTYPE_AGGREGATE_STATS_REPLY:\n    case OFPTYPE_PORT_DESC_STATS_REPLY:\n    case OFPTYPE_ROLE_REPLY:\n    case OFPTYPE_FLOW_MONITOR_PAUSED:\n    case OFPTYPE_FLOW_MONITOR_RESUMED:\n    case OFPTYPE_FLOW_MONITOR_STATS_REPLY:\n    case OFPTYPE_GET_ASYNC_REPLY:\n    case OFPTYPE_GROUP_STATS_REPLY:\n    case OFPTYPE_GROUP_DESC_STATS_REPLY:\n    case OFPTYPE_GROUP_FEATURES_STATS_REPLY:\n    case OFPTYPE_METER_STATS_REPLY:\n    case OFPTYPE_METER_CONFIG_STATS_REPLY:\n    case OFPTYPE_METER_FEATURES_STATS_REPLY:\n    case OFPTYPE_TABLE_FEATURES_STATS_REPLY:\n    case OFPTYPE_TABLE_DESC_REPLY:\n    case OFPTYPE_ROLE_STATUS:\n    case OFPTYPE_REQUESTFORWARD:\n    case OFPTYPE_TABLE_STATUS:\n    case OFPTYPE_NXT_TLV_TABLE_REQUEST:\n    case OFPTYPE_NXT_TLV_TABLE_REPLY:\n    case OFPTYPE_NXT_RESUME:\n    case OFPTYPE_IPFIX_BRIDGE_STATS_REQUEST:\n    case OFPTYPE_IPFIX_BRIDGE_STATS_REPLY:\n    case OFPTYPE_IPFIX_FLOW_STATS_REQUEST:\n    case OFPTYPE_IPFIX_FLOW_STATS_REPLY:\n    case OFPTYPE_CT_FLUSH_ZONE:\n        break;\n    }\n\n    return false;\n}\n\nenum ofperr\nofputil_decode_bundle_add(const struct ofp_header *oh,\n                          struct ofputil_bundle_add_msg *msg,\n                          enum ofptype *typep)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n\n    /* Pull the outer ofp_header. */\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    ovs_assert(raw == OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE\n               || raw == OFPRAW_ONFT13_BUNDLE_ADD_MESSAGE);\n\n    /* Pull the bundle_ctrl header. */\n    const struct ofp14_bundle_ctrl_msg *m = ofpbuf_pull(&b, sizeof *m);\n    msg->bundle_id = ntohl(m->bundle_id);\n    msg->flags = ntohs(m->flags);\n\n    /* Pull the inner ofp_header. */\n    if (b.size < sizeof(struct ofp_header)) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    msg->msg = b.data;\n    if (msg->msg->version != oh->version) {\n        return OFPERR_OFPBFC_BAD_VERSION;\n    }\n    size_t inner_len = ntohs(msg->msg->length);\n    if (inner_len < sizeof(struct ofp_header) || inner_len > b.size) {\n        return OFPERR_OFPBFC_MSG_BAD_LEN;\n    }\n    if (msg->msg->xid != oh->xid) {\n        return OFPERR_OFPBFC_MSG_BAD_XID;\n    }\n\n    /* Reject unbundlable messages. */\n    enum ofptype type;\n    enum ofperr error = ofptype_decode(&type, msg->msg);\n    if (error) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPT14_BUNDLE_ADD_MESSAGE contained \"\n                     \"message is unparsable (%s)\", ofperr_get_name(error));\n        return OFPERR_OFPBFC_MSG_UNSUP; /* 'error' would be confusing. */\n    }\n\n    if (!ofputil_is_bundlable(type)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"%s message not allowed inside \"\n                     \"OFPT14_BUNDLE_ADD_MESSAGE\", ofptype_get_name(type));\n        return OFPERR_OFPBFC_MSG_UNSUP;\n    }\n    if (typep) {\n        *typep = type;\n    }\n\n    return 0;\n}\n\nstruct ofpbuf *\nofputil_encode_bundle_add(enum ofp_version ofp_version,\n                          struct ofputil_bundle_add_msg *msg)\n{\n    struct ofpbuf *request;\n    struct ofp14_bundle_ctrl_msg *m;\n\n    /* Must use the same xid as the embedded message. */\n    request = ofpraw_alloc_xid(ofp_version == OFP13_VERSION\n                               ? OFPRAW_ONFT13_BUNDLE_ADD_MESSAGE\n                               : OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE, ofp_version,\n                               msg->msg->xid, ntohs(msg->msg->length));\n    m = ofpbuf_put_zeros(request, sizeof *m);\n\n    m->bundle_id = htonl(msg->bundle_id);\n    m->flags = htons(msg->flags);\n    ofpbuf_put(request, msg->msg, ntohs(msg->msg->length));\n\n    ofpmsg_update_length(request);\n    return request;\n}\n\nstatic void\nencode_tlv_table_mappings(struct ofpbuf *b, struct ovs_list *mappings)\n{\n    struct ofputil_tlv_map *map;\n\n    LIST_FOR_EACH (map, list_node, mappings) {\n        struct nx_tlv_map *nx_map;\n\n        nx_map = ofpbuf_put_zeros(b, sizeof *nx_map);\n        nx_map->option_class = htons(map->option_class);\n        nx_map->option_type = map->option_type;\n        nx_map->option_len = map->option_len;\n        nx_map->index = htons(map->index);\n    }\n}\n\nstruct ofpbuf *\nofputil_encode_tlv_table_mod(enum ofp_version ofp_version,\n                                struct ofputil_tlv_table_mod *ttm)\n{\n    struct ofpbuf *b;\n    struct nx_tlv_table_mod *nx_ttm;\n\n    b = ofpraw_alloc(OFPRAW_NXT_TLV_TABLE_MOD, ofp_version, 0);\n    nx_ttm = ofpbuf_put_zeros(b, sizeof *nx_ttm);\n    nx_ttm->command = htons(ttm->command);\n    encode_tlv_table_mappings(b, &ttm->mappings);\n\n    return b;\n}\n\nstatic enum ofperr\ndecode_tlv_table_mappings(struct ofpbuf *msg, unsigned int max_fields,\n                             struct ovs_list *mappings)\n{\n    ovs_list_init(mappings);\n\n    while (msg->size) {\n        struct nx_tlv_map *nx_map;\n        struct ofputil_tlv_map *map;\n\n        nx_map = ofpbuf_pull(msg, sizeof *nx_map);\n        map = xmalloc(sizeof *map);\n        ovs_list_push_back(mappings, &map->list_node);\n\n        map->option_class = ntohs(nx_map->option_class);\n        map->option_type = nx_map->option_type;\n\n        map->option_len = nx_map->option_len;\n        if (map->option_len % 4 || map->option_len > TLV_MAX_OPT_SIZE) {\n            VLOG_WARN_RL(&bad_ofmsg_rl,\n                         \"tlv table option length (%u) is not a valid option size\",\n                         map->option_len);\n            ofputil_uninit_tlv_table(mappings);\n            return OFPERR_NXTTMFC_BAD_OPT_LEN;\n        }\n\n        map->index = ntohs(nx_map->index);\n        if (map->index >= max_fields) {\n            VLOG_WARN_RL(&bad_ofmsg_rl,\n                         \"tlv table field index (%u) is too large (max %u)\",\n                         map->index, max_fields - 1);\n            ofputil_uninit_tlv_table(mappings);\n            return OFPERR_NXTTMFC_BAD_FIELD_IDX;\n        }\n    }\n\n    return 0;\n}\n\nenum ofperr\nofputil_decode_tlv_table_mod(const struct ofp_header *oh,\n                                struct ofputil_tlv_table_mod *ttm)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&msg);\n\n    struct nx_tlv_table_mod *nx_ttm = ofpbuf_pull(&msg, sizeof *nx_ttm);\n    ttm->command = ntohs(nx_ttm->command);\n    if (ttm->command > NXTTMC_CLEAR) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"tlv table mod command (%u) is out of range\",\n                     ttm->command);\n        return OFPERR_NXTTMFC_BAD_COMMAND;\n    }\n\n    return decode_tlv_table_mappings(&msg, TUN_METADATA_NUM_OPTS,\n                                        &ttm->mappings);\n}\n\nstruct ofpbuf *\nofputil_encode_tlv_table_reply(const struct ofp_header *oh,\n                                  struct ofputil_tlv_table_reply *ttr)\n{\n    struct ofpbuf *b;\n    struct nx_tlv_table_reply *nx_ttr;\n\n    b = ofpraw_alloc_reply(OFPRAW_NXT_TLV_TABLE_REPLY, oh, 0);\n    nx_ttr = ofpbuf_put_zeros(b, sizeof *nx_ttr);\n    nx_ttr->max_option_space = htonl(ttr->max_option_space);\n    nx_ttr->max_fields = htons(ttr->max_fields);\n\n    encode_tlv_table_mappings(b, &ttr->mappings);\n\n    return b;\n}\n\n/* Decodes the NXT_TLV_TABLE_REPLY message in 'oh' into '*ttr'.  Returns 0\n * if successful, otherwise an ofperr.\n *\n * The decoder verifies that the indexes in 'ttr->mappings' are less than\n * 'ttr->max_fields', but the caller must ensure, if necessary, that they are\n * less than TUN_METADATA_NUM_OPTS. */\nenum ofperr\nofputil_decode_tlv_table_reply(const struct ofp_header *oh,\n                                  struct ofputil_tlv_table_reply *ttr)\n{\n    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    ofpraw_pull_assert(&msg);\n\n    struct nx_tlv_table_reply *nx_ttr = ofpbuf_pull(&msg, sizeof *nx_ttr);\n    ttr->max_option_space = ntohl(nx_ttr->max_option_space);\n    ttr->max_fields = ntohs(nx_ttr->max_fields);\n\n    return decode_tlv_table_mappings(&msg, ttr->max_fields, &ttr->mappings);\n}\n\nvoid\nofputil_uninit_tlv_table(struct ovs_list *mappings)\n{\n    struct ofputil_tlv_map *map;\n\n    LIST_FOR_EACH_POP (map, list_node, mappings) {\n        free(map);\n    }\n}\n\nconst char *\nofputil_async_msg_type_to_string(enum ofputil_async_msg_type type)\n{\n    switch (type) {\n    case OAM_PACKET_IN:      return \"PACKET_IN\";\n    case OAM_PORT_STATUS:    return \"PORT_STATUS\";\n    case OAM_FLOW_REMOVED:   return \"FLOW_REMOVED\";\n    case OAM_ROLE_STATUS:    return \"ROLE_STATUS\";\n    case OAM_TABLE_STATUS:   return \"TABLE_STATUS\";\n    case OAM_REQUESTFORWARD: return \"REQUESTFORWARD\";\n\n    case OAM_N_TYPES:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstruct ofp14_async_prop {\n    uint64_t prop_type;\n    enum ofputil_async_msg_type oam;\n    bool master;\n    uint32_t allowed10, allowed14;\n};\n\n#define AP_PAIR(SLAVE_PROP_TYPE, OAM, A10, A14) \\\n    { SLAVE_PROP_TYPE,       OAM, false, A10, (A14) ? (A14) : (A10) },  \\\n    { (SLAVE_PROP_TYPE + 1), OAM, true,  A10, (A14) ? (A14) : (A10) }\n\nstatic const struct ofp14_async_prop async_props[] = {\n    AP_PAIR( 0, OAM_PACKET_IN,      OFPR10_BITS, OFPR14_BITS),\n    AP_PAIR( 2, OAM_PORT_STATUS,    (1 << OFPPR_N_REASONS) - 1, 0),\n    AP_PAIR( 4, OAM_FLOW_REMOVED,   (1 << OVS_OFPRR_NONE) - 1, 0),\n    AP_PAIR( 6, OAM_ROLE_STATUS,    (1 << OFPCRR_N_REASONS) - 1, 0),\n    AP_PAIR( 8, OAM_TABLE_STATUS,   OFPTR_BITS, 0),\n    AP_PAIR(10, OAM_REQUESTFORWARD, (1 << OFPRFR_N_REASONS) - 1, 0),\n};\n\n#define FOR_EACH_ASYNC_PROP(VAR)                                \\\n    for (const struct ofp14_async_prop *VAR = async_props;      \\\n         VAR < &async_props[ARRAY_SIZE(async_props)]; VAR++)\n\nstatic const struct ofp14_async_prop *\nget_ofp14_async_config_prop_by_prop_type(uint64_t prop_type)\n{\n    FOR_EACH_ASYNC_PROP (ap) {\n        if (prop_type == ap->prop_type) {\n            return ap;\n        }\n    }\n    return NULL;\n}\n\nstatic const struct ofp14_async_prop *\nget_ofp14_async_config_prop_by_oam(enum ofputil_async_msg_type oam,\n                                   bool master)\n{\n    FOR_EACH_ASYNC_PROP (ap) {\n        if (ap->oam == oam && ap->master == master) {\n            return ap;\n        }\n    }\n    return NULL;\n}\n\nstatic uint32_t\nofp14_async_prop_allowed(const struct ofp14_async_prop *prop,\n                         enum ofp_version version)\n{\n    return version >= OFP14_VERSION ? prop->allowed14 : prop->allowed10;\n}\n\nstatic ovs_be32\nencode_async_mask(const struct ofputil_async_cfg *src,\n                  const struct ofp14_async_prop *ap,\n                  enum ofp_version version)\n{\n    uint32_t mask = ap->master ? src->master[ap->oam] : src->slave[ap->oam];\n    return htonl(mask & ofp14_async_prop_allowed(ap, version));\n}\n\nstatic enum ofperr\ndecode_async_mask(ovs_be32 src,\n                  const struct ofp14_async_prop *ap, enum ofp_version version,\n                  bool loose, struct ofputil_async_cfg *dst)\n{\n    uint32_t mask = ntohl(src);\n    uint32_t allowed = ofp14_async_prop_allowed(ap, version);\n    if (mask & ~allowed) {\n        OFPPROP_LOG(&bad_ofmsg_rl, loose,\n                    \"bad value %#x for %s (allowed mask %#x)\",\n                    mask, ofputil_async_msg_type_to_string(ap->oam),\n                    allowed);\n        mask &= allowed;\n        if (!loose) {\n            return OFPERR_OFPACFC_INVALID;\n        }\n    }\n\n    if (ap->oam == OAM_PACKET_IN) {\n        if (mask & (1u << OFPR_NO_MATCH)) {\n            mask |= 1u << OFPR_EXPLICIT_MISS;\n            if (version < OFP13_VERSION) {\n                mask |= 1u << OFPR_IMPLICIT_MISS;\n            }\n        }\n    }\n\n    uint32_t *array = ap->master ? dst->master : dst->slave;\n    array[ap->oam] = mask;\n    return 0;\n}\n\nstatic enum ofperr\nparse_async_tlv(const struct ofpbuf *property,\n                const struct ofp14_async_prop *ap,\n                struct ofputil_async_cfg *ac,\n                enum ofp_version version, bool loose)\n{\n    enum ofperr error;\n    ovs_be32 mask;\n\n    error  = ofpprop_parse_be32(property, &mask);\n    if (error) {\n        return error;\n    }\n\n    if (ofpprop_is_experimenter(ap->prop_type)) {\n        /* For experimenter properties, whether a property is for the master or\n         * slave role is indicated by both 'type' and 'exp_type' in struct\n         * ofp_prop_experimenter.  Check that these are consistent. */\n        const struct ofp_prop_experimenter *ope = property->data;\n        bool should_be_master = ope->type == htons(0xffff);\n        if (should_be_master != ap->master) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"async property type %#\"PRIx16\" \"\n                         \"indicates %s role but exp_type %\"PRIu32\" indicates \"\n                         \"%s role\",\n                         ntohs(ope->type),\n                         should_be_master ? \"master\" : \"slave\",\n                         ntohl(ope->exp_type),\n                         ap->master ? \"master\" : \"slave\");\n            return OFPERR_OFPBPC_BAD_EXP_TYPE;\n        }\n    }\n\n    return decode_async_mask(mask, ap, version, loose, ac);\n}\n\nstatic void\ndecode_legacy_async_masks(const ovs_be32 masks[2],\n                          enum ofputil_async_msg_type oam,\n                          enum ofp_version version,\n                          struct ofputil_async_cfg *dst)\n{\n    for (int i = 0; i < 2; i++) {\n        bool master = i == 0;\n        const struct ofp14_async_prop *ap\n            = get_ofp14_async_config_prop_by_oam(oam, master);\n        decode_async_mask(masks[i], ap, version, true, dst);\n    }\n}\n\n/* Decodes the OpenFlow \"set async config\" request and \"get async config\n * reply\" message in '*oh' into an abstract form in 'ac'.\n *\n * Some versions of the \"set async config\" request change only some of the\n * settings and leave the others alone.  This function uses 'basis' as the\n * initial state for decoding these.  Other versions of the request change all\n * the settings; this function ignores 'basis' when decoding these.\n *\n * If 'loose' is true, this function ignores properties and values that it does\n * not understand, as a controller would want to do when interpreting\n * capabilities provided by a switch.  If 'loose' is false, this function\n * treats unknown properties and values as an error, as a switch would want to\n * do when interpreting a configuration request made by a controller.\n *\n * Returns 0 if successful, otherwise an OFPERR_* value.\n *\n * Returns error code OFPERR_OFPACFC_INVALID if the value of mask is not in\n * the valid range of mask.\n *\n * Returns error code OFPERR_OFPACFC_UNSUPPORTED if the configuration is not\n * supported.*/\nenum ofperr\nofputil_decode_set_async_config(const struct ofp_header *oh, bool loose,\n                                const struct ofputil_async_cfg *basis,\n                                struct ofputil_async_cfg *ac)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    if (raw == OFPRAW_OFPT13_SET_ASYNC ||\n        raw == OFPRAW_NXT_SET_ASYNC_CONFIG ||\n        raw == OFPRAW_OFPT13_GET_ASYNC_REPLY) {\n        const struct nx_async_config *msg = ofpmsg_body(oh);\n\n        *ac = OFPUTIL_ASYNC_CFG_INIT;\n        decode_legacy_async_masks(msg->packet_in_mask, OAM_PACKET_IN,\n                                  oh->version, ac);\n        decode_legacy_async_masks(msg->port_status_mask, OAM_PORT_STATUS,\n                                  oh->version, ac);\n        decode_legacy_async_masks(msg->flow_removed_mask, OAM_FLOW_REMOVED,\n                                  oh->version, ac);\n    } else if (raw == OFPRAW_OFPT14_SET_ASYNC ||\n               raw == OFPRAW_OFPT14_GET_ASYNC_REPLY ||\n               raw == OFPRAW_NXT_SET_ASYNC_CONFIG2) {\n        *ac = *basis;\n        while (b.size > 0) {\n            struct ofpbuf property;\n            enum ofperr error;\n            uint64_t type;\n\n            error = ofpprop_pull__(&b, &property, 8, 0xfffe, &type);\n            if (error) {\n                return error;\n            }\n\n            const struct ofp14_async_prop *ap\n                = get_ofp14_async_config_prop_by_prop_type(type);\n            error = (ap\n                     ? parse_async_tlv(&property, ap, ac, oh->version, loose)\n                     : OFPPROP_UNKNOWN(loose, \"async config\", type));\n            if (error) {\n                /* Most messages use OFPBPC_BAD_TYPE but async has its own (who\n                 * knows why, it's OpenFlow. */\n                if (error == OFPERR_OFPBPC_BAD_TYPE) {\n                    error = OFPERR_OFPACFC_UNSUPPORTED;\n                }\n                return error;\n            }\n        }\n    } else {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n    return 0;\n}\n\nstatic void\nencode_legacy_async_masks(const struct ofputil_async_cfg *ac,\n                          enum ofputil_async_msg_type oam,\n                          enum ofp_version version,\n                          ovs_be32 masks[2])\n{\n    for (int i = 0; i < 2; i++) {\n        bool master = i == 0;\n        const struct ofp14_async_prop *ap\n            = get_ofp14_async_config_prop_by_oam(oam, master);\n        masks[i] = encode_async_mask(ac, ap, version);\n    }\n}\n\nstatic void\nofputil_put_async_config__(const struct ofputil_async_cfg *ac,\n                           struct ofpbuf *buf, bool tlv,\n                           enum ofp_version version, uint32_t oams)\n{\n    if (!tlv) {\n        struct nx_async_config *msg = ofpbuf_put_zeros(buf, sizeof *msg);\n        encode_legacy_async_masks(ac, OAM_PACKET_IN, version,\n                                  msg->packet_in_mask);\n        encode_legacy_async_masks(ac, OAM_PORT_STATUS, version,\n                                  msg->port_status_mask);\n        encode_legacy_async_masks(ac, OAM_FLOW_REMOVED, version,\n                                  msg->flow_removed_mask);\n    } else {\n        FOR_EACH_ASYNC_PROP (ap) {\n            if (oams & (1u << ap->oam)) {\n                size_t ofs = buf->size;\n                ofpprop_put_be32(buf, ap->prop_type,\n                                 encode_async_mask(ac, ap, version));\n\n                /* For experimenter properties, we need to use type 0xfffe for\n                 * master and 0xffff for slaves. */\n                if (ofpprop_is_experimenter(ap->prop_type)) {\n                    struct ofp_prop_experimenter *ope\n                        = ofpbuf_at_assert(buf, ofs, sizeof *ope);\n                    ope->type = ap->master ? htons(0xffff) : htons(0xfffe);\n                }\n            }\n        }\n    }\n}\n\n/* Encodes and returns a reply to the OFPT_GET_ASYNC_REQUEST in 'oh' that\n * states that the asynchronous message configuration is 'ac'. */\nstruct ofpbuf *\nofputil_encode_get_async_reply(const struct ofp_header *oh,\n                               const struct ofputil_async_cfg *ac)\n{\n    struct ofpbuf *buf;\n\n    enum ofpraw raw = (oh->version < OFP14_VERSION\n                       ? OFPRAW_OFPT13_GET_ASYNC_REPLY\n                       : OFPRAW_OFPT14_GET_ASYNC_REPLY);\n    struct ofpbuf *reply = ofpraw_alloc_reply(raw, oh, 0);\n    ofputil_put_async_config__(ac, reply,\n                               raw == OFPRAW_OFPT14_GET_ASYNC_REPLY,\n                               oh->version, UINT32_MAX);\n    return reply;\n\n    return buf;\n}\n\n/* Encodes and returns a message, in a format appropriate for OpenFlow version\n * 'ofp_version', that sets the asynchronous message configuration to 'ac'.\n *\n * Specify 'oams' as a bitmap of OAM_* that indicate the asynchronous messages\n * to configure.  OF1.0 through OF1.3 can't natively configure a subset of\n * messages, so more messages than requested may be configured.  OF1.0 through\n * OF1.3 also can't configure OVS extension OAM_* values, so if 'oam' includes\n * any extensions then this function encodes an Open vSwitch extension message\n * that does support configuring OVS extension OAM_*. */\nstruct ofpbuf *\nofputil_encode_set_async_config(const struct ofputil_async_cfg *ac,\n                                uint32_t oams, enum ofp_version ofp_version)\n{\n    enum ofpraw raw = (ofp_version >= OFP14_VERSION ? OFPRAW_OFPT14_SET_ASYNC\n                       : oams & OAM_EXTENSIONS ? OFPRAW_NXT_SET_ASYNC_CONFIG2\n                       : ofp_version >= OFP13_VERSION ? OFPRAW_OFPT13_SET_ASYNC\n                       : OFPRAW_NXT_SET_ASYNC_CONFIG);\n    struct ofpbuf *request = ofpraw_alloc(raw, ofp_version, 0);\n    ofputil_put_async_config__(ac, request,\n                               (raw == OFPRAW_OFPT14_SET_ASYNC ||\n                                raw == OFPRAW_NXT_SET_ASYNC_CONFIG2),\n                               ofp_version, oams);\n    return request;\n}\n\nstruct ofputil_async_cfg\nofputil_async_cfg_default(enum ofp_version version)\n{\n    /* We enable all of the OF1.4 reasons regardless of 'version' because the\n     * reasons added in OF1.4 just are just refinements of the OFPR_ACTION\n     * introduced in OF1.0, breaking it into more specific categories.  When we\n     * encode these for earlier OpenFlow versions, we translate them into\n     * OFPR_ACTION.  */\n    uint32_t pin = OFPR14_BITS & ~(1u << OFPR_INVALID_TTL);\n    pin |= 1u << OFPR_EXPLICIT_MISS;\n    if (version <= OFP12_VERSION) {\n        pin |= 1u << OFPR_IMPLICIT_MISS;\n    }\n\n    return (struct ofputil_async_cfg) {\n        .master[OAM_PACKET_IN] = pin,\n\n        .master[OAM_FLOW_REMOVED]\n            = (version >= OFP14_VERSION ? OFPRR14_BITS : OFPRR10_BITS),\n\n        .master[OAM_PORT_STATUS] = OFPPR_BITS,\n        .slave[OAM_PORT_STATUS] = OFPPR_BITS,\n    };\n}\n\nstatic void\nofputil_put_ofp14_table_desc(const struct ofputil_table_desc *td,\n                             struct ofpbuf *b, enum ofp_version version)\n{\n    struct ofp14_table_desc *otd;\n    struct ofp14_table_mod_prop_vacancy *otv;\n    size_t start_otd;\n\n    start_otd = b->size;\n    ofpbuf_put_zeros(b, sizeof *otd);\n\n    ofpprop_put_u32(b, OFPTMPT14_EVICTION, td->eviction_flags);\n\n    otv = ofpbuf_put_zeros(b, sizeof *otv);\n    otv->type = htons(OFPTMPT14_VACANCY);\n    otv->length = htons(sizeof *otv);\n    otv->vacancy_down = td->table_vacancy.vacancy_down;\n    otv->vacancy_up = td->table_vacancy.vacancy_up;\n    otv->vacancy = td->table_vacancy.vacancy;\n\n    otd = ofpbuf_at_assert(b, start_otd, sizeof *otd);\n    otd->length = htons(b->size - start_otd);\n    otd->table_id = td->table_id;\n    otd->config = ofputil_encode_table_config(OFPUTIL_TABLE_MISS_DEFAULT,\n                                              td->eviction, td->vacancy,\n                                              version);\n}\n\n/* Converts the abstract form of a \"table status\" message in '*ts' into an\n * OpenFlow message suitable for 'protocol', and returns that encoded form in\n * a buffer owned by the caller. */\nstruct ofpbuf *\nofputil_encode_table_status(const struct ofputil_table_status *ts,\n                            enum ofputil_protocol protocol)\n{\n    enum ofp_version version;\n    struct ofpbuf *b;\n\n    version = ofputil_protocol_to_ofp_version(protocol);\n    if (version >= OFP14_VERSION) {\n        enum ofpraw raw;\n        struct ofp14_table_status *ots;\n\n        raw = OFPRAW_OFPT14_TABLE_STATUS;\n        b = ofpraw_alloc_xid(raw, version, htonl(0), 0);\n        ots = ofpbuf_put_zeros(b, sizeof *ots);\n        ots->reason = ts->reason;\n        ofputil_put_ofp14_table_desc(&ts->desc, b, version);\n        ofpmsg_update_length(b);\n        return b;\n    } else {\n        return NULL;\n    }\n}\n\n/* Decodes the OpenFlow \"table status\" message in '*ots' into an abstract form\n * in '*ts'.  Returns 0 if successful, otherwise an OFPERR_* value. */\nenum ofperr\nofputil_decode_table_status(const struct ofp_header *oh,\n                            struct ofputil_table_status *ts)\n{\n    const struct ofp14_table_status *ots;\n    struct ofpbuf b;\n    enum ofperr error;\n    enum ofpraw raw;\n\n    ofpbuf_use_const(&b, oh, ntohs(oh->length));\n    raw = ofpraw_pull_assert(&b);\n    ots = ofpbuf_pull(&b, sizeof *ots);\n\n    if (raw == OFPRAW_OFPT14_TABLE_STATUS) {\n        if (ots->reason != OFPTR_VACANCY_DOWN\n            && ots->reason != OFPTR_VACANCY_UP) {\n            return OFPERR_OFPBPC_BAD_VALUE;\n        }\n        ts->reason = ots->reason;\n\n        error = ofputil_decode_table_desc(&b, &ts->desc, oh->version);\n        return error;\n    } else {\n        return OFPERR_OFPBRC_BAD_VERSION;\n    }\n\n    return 0;\n}\n"], "filenames": ["lib/ofp-util.c"], "buggy_code_start_loc": [8955], "buggy_code_end_loc": [8971], "fixing_code_start_loc": [8955], "fixing_code_end_loc": [8971], "type": "CWE-617", "message": "An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6, affecting parse_group_prop_ntr_selection_method in lib/ofp-util.c. When decoding a group mod, it validates the group type and command after the whole group mod has been decoded. The OF1.5 decoder, however, tries to use the type and command earlier, when it might still be invalid. This causes an assertion failure (via OVS_NOT_REACHED). ovs-vswitchd does not enable support for OpenFlow 1.5 by default.", "other": {"cve": {"id": "CVE-2018-17204", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-19T16:29:00.897", "lastModified": "2021-08-04T17:14:46.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6, affecting parse_group_prop_ntr_selection_method in lib/ofp-util.c. When decoding a group mod, it validates the group type and command after the whole group mod has been decoded. The OF1.5 decoder, however, tries to use the type and command earlier, when it might still be invalid. This causes an assertion failure (via OVS_NOT_REACHED). ovs-vswitchd does not enable support for OpenFlow 1.5 by default."}, {"lang": "es", "value": "Se ha descubierto un problema en Open vSwitch (OvS) en versiones 2.7.x hasta la 2.7.6 que afecta a parse_group_prop_ntr_selection_method en lib/ofp-util.c. Cuando se descodifica un mod de grupo, valida el tipo de grupo y comando despu\u00e9s de que todo el mod de grupo se haya descodificado. Sin embargo, el decodificador OF1.5 intenta utilizar el tipo y comando antes, cuando puede ser todav\u00eda no v\u00e1lido. Esto provoca un fallo de aserci\u00f3n (mediante OVS_NOT_REACHED). ovs-vswitchd tiene deshabilitado el soporte para OpenFlow 1.5 por defecto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openvswitch:openvswitch:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndIncluding": "2.7.6", "matchCriteriaId": "682FD155-6A56-43D5-9953-852BB3AA0109"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:10:*:*:*:*:*:*:*", "matchCriteriaId": "E722FEF7-58A6-47AD-B1D0-DB0B71B0C7AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:13:*:*:*:*:*:*:*", "matchCriteriaId": "704CFA1A-953E-4105-BFBE-406034B83DED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:3500", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0053", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0081", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/openvswitch/ovs/commit/4af6da3b275b764b1afe194df6499b33d2bf4cde", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3873-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openvswitch/ovs/commit/4af6da3b275b764b1afe194df6499b33d2bf4cde"}}