{"buggy_code": ["/*\n * Per core/cpu state\n *\n * Used to coordinate shared registers between HT threads or\n * among events on a single PMU.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <asm/hardirq.h>\n#include <asm/apic.h>\n\n#include \"perf_event.h\"\n\n/*\n * Intel PerfMon, used on Core and later.\n */\nstatic u64 intel_perfmon_event_map[PERF_COUNT_HW_MAX] __read_mostly =\n{\n\t[PERF_COUNT_HW_CPU_CYCLES]\t\t= 0x003c,\n\t[PERF_COUNT_HW_INSTRUCTIONS]\t\t= 0x00c0,\n\t[PERF_COUNT_HW_CACHE_REFERENCES]\t= 0x4f2e,\n\t[PERF_COUNT_HW_CACHE_MISSES]\t\t= 0x412e,\n\t[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]\t= 0x00c4,\n\t[PERF_COUNT_HW_BRANCH_MISSES]\t\t= 0x00c5,\n\t[PERF_COUNT_HW_BUS_CYCLES]\t\t= 0x013c,\n\t[PERF_COUNT_HW_REF_CPU_CYCLES]\t\t= 0x0300, /* pseudo-encoding */\n};\n\nstatic struct event_constraint intel_core_event_constraints[] __read_mostly =\n{\n\tINTEL_EVENT_CONSTRAINT(0x11, 0x2), /* FP_ASSIST */\n\tINTEL_EVENT_CONSTRAINT(0x12, 0x2), /* MUL */\n\tINTEL_EVENT_CONSTRAINT(0x13, 0x2), /* DIV */\n\tINTEL_EVENT_CONSTRAINT(0x14, 0x1), /* CYCLES_DIV_BUSY */\n\tINTEL_EVENT_CONSTRAINT(0x19, 0x2), /* DELAYED_BYPASS */\n\tINTEL_EVENT_CONSTRAINT(0xc1, 0x1), /* FP_COMP_INSTR_RET */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_core2_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_EVENT_CONSTRAINT(0x10, 0x1), /* FP_COMP_OPS_EXE */\n\tINTEL_EVENT_CONSTRAINT(0x11, 0x2), /* FP_ASSIST */\n\tINTEL_EVENT_CONSTRAINT(0x12, 0x2), /* MUL */\n\tINTEL_EVENT_CONSTRAINT(0x13, 0x2), /* DIV */\n\tINTEL_EVENT_CONSTRAINT(0x14, 0x1), /* CYCLES_DIV_BUSY */\n\tINTEL_EVENT_CONSTRAINT(0x18, 0x1), /* IDLE_DURING_DIV */\n\tINTEL_EVENT_CONSTRAINT(0x19, 0x2), /* DELAYED_BYPASS */\n\tINTEL_EVENT_CONSTRAINT(0xa1, 0x1), /* RS_UOPS_DISPATCH_CYCLES */\n\tINTEL_EVENT_CONSTRAINT(0xc9, 0x1), /* ITLB_MISS_RETIRED (T30-9) */\n\tINTEL_EVENT_CONSTRAINT(0xcb, 0x1), /* MEM_LOAD_RETIRED */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_nehalem_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_EVENT_CONSTRAINT(0x40, 0x3), /* L1D_CACHE_LD */\n\tINTEL_EVENT_CONSTRAINT(0x41, 0x3), /* L1D_CACHE_ST */\n\tINTEL_EVENT_CONSTRAINT(0x42, 0x3), /* L1D_CACHE_LOCK */\n\tINTEL_EVENT_CONSTRAINT(0x43, 0x3), /* L1D_ALL_REF */\n\tINTEL_EVENT_CONSTRAINT(0x48, 0x3), /* L1D_PEND_MISS */\n\tINTEL_EVENT_CONSTRAINT(0x4e, 0x3), /* L1D_PREFETCH */\n\tINTEL_EVENT_CONSTRAINT(0x51, 0x3), /* L1D */\n\tINTEL_EVENT_CONSTRAINT(0x63, 0x3), /* CACHE_LOCK_CYCLES */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct extra_reg intel_nehalem_extra_regs[] __read_mostly =\n{\n\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0xffff, RSP_0),\n\tEVENT_EXTRA_END\n};\n\nstatic struct event_constraint intel_westmere_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_EVENT_CONSTRAINT(0x51, 0x3), /* L1D */\n\tINTEL_EVENT_CONSTRAINT(0x60, 0x1), /* OFFCORE_REQUESTS_OUTSTANDING */\n\tINTEL_EVENT_CONSTRAINT(0x63, 0x3), /* CACHE_LOCK_CYCLES */\n\tINTEL_EVENT_CONSTRAINT(0xb3, 0x1), /* SNOOPQ_REQUEST_OUTSTANDING */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_snb_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_UEVENT_CONSTRAINT(0x04a3, 0xf), /* CYCLE_ACTIVITY.CYCLES_NO_DISPATCH */\n\tINTEL_UEVENT_CONSTRAINT(0x05a3, 0xf), /* CYCLE_ACTIVITY.STALLS_L2_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x02a3, 0x4), /* CYCLE_ACTIVITY.CYCLES_L1D_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x06a3, 0x4), /* CYCLE_ACTIVITY.STALLS_L1D_PENDING */\n\tINTEL_EVENT_CONSTRAINT(0x48, 0x4), /* L1D_PEND_MISS.PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x01c0, 0x2), /* INST_RETIRED.PREC_DIST */\n\tINTEL_EVENT_CONSTRAINT(0xcd, 0x8), /* MEM_TRANS_RETIRED.LOAD_LATENCY */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_ivb_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_UEVENT_CONSTRAINT(0x0148, 0x4), /* L1D_PEND_MISS.PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x0279, 0xf), /* IDQ.EMTPY */\n\tINTEL_UEVENT_CONSTRAINT(0x019c, 0xf), /* IDQ_UOPS_NOT_DELIVERED.CORE */\n\tINTEL_UEVENT_CONSTRAINT(0x04a3, 0xf), /* CYCLE_ACTIVITY.CYCLES_NO_EXECUTE */\n\tINTEL_UEVENT_CONSTRAINT(0x05a3, 0xf), /* CYCLE_ACTIVITY.STALLS_L2_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x06a3, 0xf), /* CYCLE_ACTIVITY.STALLS_LDM_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x08a3, 0x4), /* CYCLE_ACTIVITY.CYCLES_L1D_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x0ca3, 0x4), /* CYCLE_ACTIVITY.STALLS_L1D_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x01c0, 0x2), /* INST_RETIRED.PREC_DIST */\n\tINTEL_EVENT_CONSTRAINT(0xd0, 0xf), /* MEM_UOPS_RETIRED.* */\n\tINTEL_EVENT_CONSTRAINT(0xd1, 0xf), /* MEM_LOAD_UOPS_RETIRED.* */\n\tINTEL_EVENT_CONSTRAINT(0xd2, 0xf), /* MEM_LOAD_UOPS_LLC_HIT_RETIRED.* */\n\tINTEL_EVENT_CONSTRAINT(0xd3, 0xf), /*  MEM_LOAD_UOPS_LLC_MISS_RETIRED.* */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct extra_reg intel_westmere_extra_regs[] __read_mostly =\n{\n\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0xffff, RSP_0),\n\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0xffff, RSP_1),\n\tEVENT_EXTRA_END\n};\n\nstatic struct event_constraint intel_v1_event_constraints[] __read_mostly =\n{\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_gen_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct extra_reg intel_snb_extra_regs[] __read_mostly = {\n\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3fffffffffull, RSP_0),\n\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3fffffffffull, RSP_1),\n\tEVENT_EXTRA_END\n};\n\nstatic u64 intel_pmu_event_map(int hw_event)\n{\n\treturn intel_perfmon_event_map[hw_event];\n}\n\n#define SNB_DMND_DATA_RD\t(1ULL << 0)\n#define SNB_DMND_RFO\t\t(1ULL << 1)\n#define SNB_DMND_IFETCH\t\t(1ULL << 2)\n#define SNB_DMND_WB\t\t(1ULL << 3)\n#define SNB_PF_DATA_RD\t\t(1ULL << 4)\n#define SNB_PF_RFO\t\t(1ULL << 5)\n#define SNB_PF_IFETCH\t\t(1ULL << 6)\n#define SNB_LLC_DATA_RD\t\t(1ULL << 7)\n#define SNB_LLC_RFO\t\t(1ULL << 8)\n#define SNB_LLC_IFETCH\t\t(1ULL << 9)\n#define SNB_BUS_LOCKS\t\t(1ULL << 10)\n#define SNB_STRM_ST\t\t(1ULL << 11)\n#define SNB_OTHER\t\t(1ULL << 15)\n#define SNB_RESP_ANY\t\t(1ULL << 16)\n#define SNB_NO_SUPP\t\t(1ULL << 17)\n#define SNB_LLC_HITM\t\t(1ULL << 18)\n#define SNB_LLC_HITE\t\t(1ULL << 19)\n#define SNB_LLC_HITS\t\t(1ULL << 20)\n#define SNB_LLC_HITF\t\t(1ULL << 21)\n#define SNB_LOCAL\t\t(1ULL << 22)\n#define SNB_REMOTE\t\t(0xffULL << 23)\n#define SNB_SNP_NONE\t\t(1ULL << 31)\n#define SNB_SNP_NOT_NEEDED\t(1ULL << 32)\n#define SNB_SNP_MISS\t\t(1ULL << 33)\n#define SNB_NO_FWD\t\t(1ULL << 34)\n#define SNB_SNP_FWD\t\t(1ULL << 35)\n#define SNB_HITM\t\t(1ULL << 36)\n#define SNB_NON_DRAM\t\t(1ULL << 37)\n\n#define SNB_DMND_READ\t\t(SNB_DMND_DATA_RD|SNB_LLC_DATA_RD)\n#define SNB_DMND_WRITE\t\t(SNB_DMND_RFO|SNB_LLC_RFO)\n#define SNB_DMND_PREFETCH\t(SNB_PF_DATA_RD|SNB_PF_RFO)\n\n#define SNB_SNP_ANY\t\t(SNB_SNP_NONE|SNB_SNP_NOT_NEEDED| \\\n\t\t\t\t SNB_SNP_MISS|SNB_NO_FWD|SNB_SNP_FWD| \\\n\t\t\t\t SNB_HITM)\n\n#define SNB_DRAM_ANY\t\t(SNB_LOCAL|SNB_REMOTE|SNB_SNP_ANY)\n#define SNB_DRAM_REMOTE\t\t(SNB_REMOTE|SNB_SNP_ANY)\n\n#define SNB_L3_ACCESS\t\tSNB_RESP_ANY\n#define SNB_L3_MISS\t\t(SNB_DRAM_ANY|SNB_NON_DRAM)\n\nstatic __initconst const u64 snb_hw_cache_extra_regs\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_READ|SNB_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_READ|SNB_L3_MISS,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_WRITE|SNB_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_WRITE|SNB_L3_MISS,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_PREFETCH|SNB_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_PREFETCH|SNB_L3_MISS,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_READ|SNB_DRAM_ANY,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_READ|SNB_DRAM_REMOTE,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_WRITE|SNB_DRAM_ANY,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_WRITE|SNB_DRAM_REMOTE,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_PREFETCH|SNB_DRAM_ANY,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_PREFETCH|SNB_DRAM_REMOTE,\n\t},\n },\n};\n\nstatic __initconst const u64 snb_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0xf1d0, /* MEM_UOP_RETIRED.LOADS        */\n\t\t[ C(RESULT_MISS)   ] = 0x0151, /* L1D.REPLACEMENT              */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0xf2d0, /* MEM_UOP_RETIRED.STORES       */\n\t\t[ C(RESULT_MISS)   ] = 0x0851, /* L1D.ALL_M_REPLACEMENT        */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x024e, /* HW_PRE_REQ.DL1_MISS          */\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* ICACHE.MISSES */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t/* OFFCORE_RESPONSE.PREFETCH.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.PREFETCH.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x81d0, /* MEM_UOP_RETIRED.ALL_LOADS */\n\t\t[ C(RESULT_MISS)   ] = 0x0108, /* DTLB_LOAD_MISSES.CAUSES_A_WALK */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x82d0, /* MEM_UOP_RETIRED.ALL_STORES */\n\t\t[ C(RESULT_MISS)   ] = 0x0149, /* DTLB_STORE_MISSES.MISS_CAUSES_A_WALK */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x1085, /* ITLB_MISSES.STLB_HIT         */\n\t\t[ C(RESULT_MISS)   ] = 0x0185, /* ITLB_MISSES.CAUSES_A_WALK    */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ALL_BRANCHES */\n\t\t[ C(RESULT_MISS)   ] = 0x00c5, /* BR_MISP_RETIRED.ALL_BRANCHES */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n\n};\n\nstatic __initconst const u64 westmere_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x010b, /* MEM_INST_RETIRED.LOADS       */\n\t\t[ C(RESULT_MISS)   ] = 0x0151, /* L1D.REPL                     */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x020b, /* MEM_INST_RETURED.STORES      */\n\t\t[ C(RESULT_MISS)   ] = 0x0251, /* L1D.M_REPL                   */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x014e, /* L1D_PREFETCH.REQUESTS        */\n\t\t[ C(RESULT_MISS)   ] = 0x024e, /* L1D_PREFETCH.MISS            */\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0380, /* L1I.READS                    */\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* L1I.MISSES                   */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t/*\n\t * Use RFO, not WRITEBACK, because a write miss would typically occur\n\t * on RFO.\n\t */\n\t[ C(OP_WRITE) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t/* OFFCORE_RESPONSE.PREFETCH.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.PREFETCH.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x010b, /* MEM_INST_RETIRED.LOADS       */\n\t\t[ C(RESULT_MISS)   ] = 0x0108, /* DTLB_LOAD_MISSES.ANY         */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x020b, /* MEM_INST_RETURED.STORES      */\n\t\t[ C(RESULT_MISS)   ] = 0x010c, /* MEM_STORE_RETIRED.DTLB_MISS  */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01c0, /* INST_RETIRED.ANY_P           */\n\t\t[ C(RESULT_MISS)   ] = 0x0185, /* ITLB_MISSES.ANY              */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ALL_BRANCHES */\n\t\t[ C(RESULT_MISS)   ] = 0x03e8, /* BPU_CLEARS.ANY               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n};\n\n/*\n * Nehalem/Westmere MSR_OFFCORE_RESPONSE bits;\n * See IA32 SDM Vol 3B 30.6.1.3\n */\n\n#define NHM_DMND_DATA_RD\t(1 << 0)\n#define NHM_DMND_RFO\t\t(1 << 1)\n#define NHM_DMND_IFETCH\t\t(1 << 2)\n#define NHM_DMND_WB\t\t(1 << 3)\n#define NHM_PF_DATA_RD\t\t(1 << 4)\n#define NHM_PF_DATA_RFO\t\t(1 << 5)\n#define NHM_PF_IFETCH\t\t(1 << 6)\n#define NHM_OFFCORE_OTHER\t(1 << 7)\n#define NHM_UNCORE_HIT\t\t(1 << 8)\n#define NHM_OTHER_CORE_HIT_SNP\t(1 << 9)\n#define NHM_OTHER_CORE_HITM\t(1 << 10)\n        \t\t\t/* reserved */\n#define NHM_REMOTE_CACHE_FWD\t(1 << 12)\n#define NHM_REMOTE_DRAM\t\t(1 << 13)\n#define NHM_LOCAL_DRAM\t\t(1 << 14)\n#define NHM_NON_DRAM\t\t(1 << 15)\n\n#define NHM_LOCAL\t\t(NHM_LOCAL_DRAM|NHM_REMOTE_CACHE_FWD)\n#define NHM_REMOTE\t\t(NHM_REMOTE_DRAM)\n\n#define NHM_DMND_READ\t\t(NHM_DMND_DATA_RD)\n#define NHM_DMND_WRITE\t\t(NHM_DMND_RFO|NHM_DMND_WB)\n#define NHM_DMND_PREFETCH\t(NHM_PF_DATA_RD|NHM_PF_DATA_RFO)\n\n#define NHM_L3_HIT\t(NHM_UNCORE_HIT|NHM_OTHER_CORE_HIT_SNP|NHM_OTHER_CORE_HITM)\n#define NHM_L3_MISS\t(NHM_NON_DRAM|NHM_LOCAL_DRAM|NHM_REMOTE_DRAM|NHM_REMOTE_CACHE_FWD)\n#define NHM_L3_ACCESS\t(NHM_L3_HIT|NHM_L3_MISS)\n\nstatic __initconst const u64 nehalem_hw_cache_extra_regs\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_READ|NHM_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_READ|NHM_L3_MISS,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_WRITE|NHM_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_WRITE|NHM_L3_MISS,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_PREFETCH|NHM_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_PREFETCH|NHM_L3_MISS,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_READ|NHM_LOCAL|NHM_REMOTE,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_READ|NHM_REMOTE,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_WRITE|NHM_LOCAL|NHM_REMOTE,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_WRITE|NHM_REMOTE,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_PREFETCH|NHM_LOCAL|NHM_REMOTE,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_PREFETCH|NHM_REMOTE,\n\t},\n },\n};\n\nstatic __initconst const u64 nehalem_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x010b, /* MEM_INST_RETIRED.LOADS       */\n\t\t[ C(RESULT_MISS)   ] = 0x0151, /* L1D.REPL                     */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x020b, /* MEM_INST_RETURED.STORES      */\n\t\t[ C(RESULT_MISS)   ] = 0x0251, /* L1D.M_REPL                   */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x014e, /* L1D_PREFETCH.REQUESTS        */\n\t\t[ C(RESULT_MISS)   ] = 0x024e, /* L1D_PREFETCH.MISS            */\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0380, /* L1I.READS                    */\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* L1I.MISSES                   */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t/*\n\t * Use RFO, not WRITEBACK, because a write miss would typically occur\n\t * on RFO.\n\t */\n\t[ C(OP_WRITE) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t/* OFFCORE_RESPONSE.PREFETCH.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.PREFETCH.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f40, /* L1D_CACHE_LD.MESI   (alias)  */\n\t\t[ C(RESULT_MISS)   ] = 0x0108, /* DTLB_LOAD_MISSES.ANY         */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f41, /* L1D_CACHE_ST.MESI   (alias)  */\n\t\t[ C(RESULT_MISS)   ] = 0x010c, /* MEM_STORE_RETIRED.DTLB_MISS  */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01c0, /* INST_RETIRED.ANY_P           */\n\t\t[ C(RESULT_MISS)   ] = 0x20c8, /* ITLB_MISS_RETIRED            */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ALL_BRANCHES */\n\t\t[ C(RESULT_MISS)   ] = 0x03e8, /* BPU_CLEARS.ANY               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n};\n\nstatic __initconst const u64 core2_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f40, /* L1D_CACHE_LD.MESI          */\n\t\t[ C(RESULT_MISS)   ] = 0x0140, /* L1D_CACHE_LD.I_STATE       */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f41, /* L1D_CACHE_ST.MESI          */\n\t\t[ C(RESULT_MISS)   ] = 0x0141, /* L1D_CACHE_ST.I_STATE       */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x104e, /* L1D_PREFETCH.REQUESTS      */\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0080, /* L1I.READS                  */\n\t\t[ C(RESULT_MISS)   ] = 0x0081, /* L1I.MISSES                 */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f29, /* L2_LD.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x4129, /* L2_LD.ISTATE               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f2A, /* L2_ST.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x412A, /* L2_ST.ISTATE               */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f40, /* L1D_CACHE_LD.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0208, /* DTLB_MISSES.MISS_LD        */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f41, /* L1D_CACHE_ST.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0808, /* DTLB_MISSES.MISS_ST        */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c0, /* INST_RETIRED.ANY_P         */\n\t\t[ C(RESULT_MISS)   ] = 0x1282, /* ITLBMISSES                 */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ANY        */\n\t\t[ C(RESULT_MISS)   ] = 0x00c5, /* BP_INST_RETIRED.MISPRED    */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n};\n\nstatic __initconst const u64 atom_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2140, /* L1D_CACHE.LD               */\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2240, /* L1D_CACHE.ST               */\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0380, /* L1I.READS                  */\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* L1I.MISSES                 */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f29, /* L2_LD.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x4129, /* L2_LD.ISTATE               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f2A, /* L2_ST.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x412A, /* L2_ST.ISTATE               */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2140, /* L1D_CACHE_LD.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0508, /* DTLB_MISSES.MISS_LD        */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2240, /* L1D_CACHE_ST.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0608, /* DTLB_MISSES.MISS_ST        */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c0, /* INST_RETIRED.ANY_P         */\n\t\t[ C(RESULT_MISS)   ] = 0x0282, /* ITLB.MISSES                */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ANY        */\n\t\t[ C(RESULT_MISS)   ] = 0x00c5, /* BP_INST_RETIRED.MISPRED    */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n};\n\nstatic inline bool intel_pmu_needs_lbr_smpl(struct perf_event *event)\n{\n\t/* user explicitly requested branch sampling */\n\tif (has_branch_stack(event))\n\t\treturn true;\n\n\t/* implicit branch sampling to correct PEBS skid */\n\tif (x86_pmu.intel_cap.pebs_trap && event->attr.precise_ip > 1)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void intel_pmu_disable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\tif (test_bit(INTEL_PMC_IDX_FIXED_BTS, cpuc->active_mask))\n\t\tintel_pmu_disable_bts();\n\n\tintel_pmu_pebs_disable_all();\n\tintel_pmu_lbr_disable_all();\n}\n\nstatic void intel_pmu_enable_all(int added)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tintel_pmu_pebs_enable_all();\n\tintel_pmu_lbr_enable_all();\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL,\n\t\t\tx86_pmu.intel_ctrl & ~cpuc->intel_ctrl_guest_mask);\n\n\tif (test_bit(INTEL_PMC_IDX_FIXED_BTS, cpuc->active_mask)) {\n\t\tstruct perf_event *event =\n\t\t\tcpuc->events[INTEL_PMC_IDX_FIXED_BTS];\n\n\t\tif (WARN_ON_ONCE(!event))\n\t\t\treturn;\n\n\t\tintel_pmu_enable_bts(event->hw.config);\n\t}\n}\n\n/*\n * Workaround for:\n *   Intel Errata AAK100 (model 26)\n *   Intel Errata AAP53  (model 30)\n *   Intel Errata BD53   (model 44)\n *\n * The official story:\n *   These chips need to be 'reset' when adding counters by programming the\n *   magic three (non-counting) events 0x4300B5, 0x4300D2, and 0x4300B1 either\n *   in sequence on the same PMC or on different PMCs.\n *\n * In practise it appears some of these events do in fact count, and\n * we need to programm all 4 events.\n */\nstatic void intel_pmu_nhm_workaround(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstatic const unsigned long nhm_magic[4] = {\n\t\t0x4300B5,\n\t\t0x4300D2,\n\t\t0x4300B1,\n\t\t0x4300B1\n\t};\n\tstruct perf_event *event;\n\tint i;\n\n\t/*\n\t * The Errata requires below steps:\n\t * 1) Clear MSR_IA32_PEBS_ENABLE and MSR_CORE_PERF_GLOBAL_CTRL;\n\t * 2) Configure 4 PERFEVTSELx with the magic events and clear\n\t *    the corresponding PMCx;\n\t * 3) set bit0~bit3 of MSR_CORE_PERF_GLOBAL_CTRL;\n\t * 4) Clear MSR_CORE_PERF_GLOBAL_CTRL;\n\t * 5) Clear 4 pairs of ERFEVTSELx and PMCx;\n\t */\n\n\t/*\n\t * The real steps we choose are a little different from above.\n\t * A) To reduce MSR operations, we don't run step 1) as they\n\t *    are already cleared before this function is called;\n\t * B) Call x86_perf_event_update to save PMCx before configuring\n\t *    PERFEVTSELx with magic number;\n\t * C) With step 5), we do clear only when the PERFEVTSELx is\n\t *    not used currently.\n\t * D) Call x86_perf_event_set_period to restore PMCx;\n\t */\n\n\t/* We always operate 4 pairs of PERF Counters */\n\tfor (i = 0; i < 4; i++) {\n\t\tevent = cpuc->events[i];\n\t\tif (event)\n\t\t\tx86_perf_event_update(event);\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\twrmsrl(MSR_ARCH_PERFMON_EVENTSEL0 + i, nhm_magic[i]);\n\t\twrmsrl(MSR_ARCH_PERFMON_PERFCTR0 + i, 0x0);\n\t}\n\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, 0xf);\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, 0x0);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tevent = cpuc->events[i];\n\n\t\tif (event) {\n\t\t\tx86_perf_event_set_period(event);\n\t\t\t__x86_pmu_enable_event(&event->hw,\n\t\t\t\t\tARCH_PERFMON_EVENTSEL_ENABLE);\n\t\t} else\n\t\t\twrmsrl(MSR_ARCH_PERFMON_EVENTSEL0 + i, 0x0);\n\t}\n}\n\nstatic void intel_pmu_nhm_enable_all(int added)\n{\n\tif (added)\n\t\tintel_pmu_nhm_workaround();\n\tintel_pmu_enable_all(added);\n}\n\nstatic inline u64 intel_pmu_get_status(void)\n{\n\tu64 status;\n\n\trdmsrl(MSR_CORE_PERF_GLOBAL_STATUS, status);\n\n\treturn status;\n}\n\nstatic inline void intel_pmu_ack_status(u64 ack)\n{\n\twrmsrl(MSR_CORE_PERF_GLOBAL_OVF_CTRL, ack);\n}\n\nstatic void intel_pmu_disable_fixed(struct hw_perf_event *hwc)\n{\n\tint idx = hwc->idx - INTEL_PMC_IDX_FIXED;\n\tu64 ctrl_val, mask;\n\n\tmask = 0xfULL << (idx * 4);\n\n\trdmsrl(hwc->config_base, ctrl_val);\n\tctrl_val &= ~mask;\n\twrmsrl(hwc->config_base, ctrl_val);\n}\n\nstatic void intel_pmu_disable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (unlikely(hwc->idx == INTEL_PMC_IDX_FIXED_BTS)) {\n\t\tintel_pmu_disable_bts();\n\t\tintel_pmu_drain_bts_buffer();\n\t\treturn;\n\t}\n\n\tcpuc->intel_ctrl_guest_mask &= ~(1ull << hwc->idx);\n\tcpuc->intel_ctrl_host_mask &= ~(1ull << hwc->idx);\n\n\t/*\n\t * must disable before any actual event\n\t * because any event may be combined with LBR\n\t */\n\tif (intel_pmu_needs_lbr_smpl(event))\n\t\tintel_pmu_lbr_disable(event);\n\n\tif (unlikely(hwc->config_base == MSR_ARCH_PERFMON_FIXED_CTR_CTRL)) {\n\t\tintel_pmu_disable_fixed(hwc);\n\t\treturn;\n\t}\n\n\tx86_pmu_disable_event(event);\n\n\tif (unlikely(event->attr.precise_ip))\n\t\tintel_pmu_pebs_disable(event);\n}\n\nstatic void intel_pmu_enable_fixed(struct hw_perf_event *hwc)\n{\n\tint idx = hwc->idx - INTEL_PMC_IDX_FIXED;\n\tu64 ctrl_val, bits, mask;\n\n\t/*\n\t * Enable IRQ generation (0x8),\n\t * and enable ring-3 counting (0x2) and ring-0 counting (0x1)\n\t * if requested:\n\t */\n\tbits = 0x8ULL;\n\tif (hwc->config & ARCH_PERFMON_EVENTSEL_USR)\n\t\tbits |= 0x2;\n\tif (hwc->config & ARCH_PERFMON_EVENTSEL_OS)\n\t\tbits |= 0x1;\n\n\t/*\n\t * ANY bit is supported in v3 and up\n\t */\n\tif (x86_pmu.version > 2 && hwc->config & ARCH_PERFMON_EVENTSEL_ANY)\n\t\tbits |= 0x4;\n\n\tbits <<= (idx * 4);\n\tmask = 0xfULL << (idx * 4);\n\n\trdmsrl(hwc->config_base, ctrl_val);\n\tctrl_val &= ~mask;\n\tctrl_val |= bits;\n\twrmsrl(hwc->config_base, ctrl_val);\n}\n\nstatic void intel_pmu_enable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (unlikely(hwc->idx == INTEL_PMC_IDX_FIXED_BTS)) {\n\t\tif (!__this_cpu_read(cpu_hw_events.enabled))\n\t\t\treturn;\n\n\t\tintel_pmu_enable_bts(hwc->config);\n\t\treturn;\n\t}\n\t/*\n\t * must enabled before any actual event\n\t * because any event may be combined with LBR\n\t */\n\tif (intel_pmu_needs_lbr_smpl(event))\n\t\tintel_pmu_lbr_enable(event);\n\n\tif (event->attr.exclude_host)\n\t\tcpuc->intel_ctrl_guest_mask |= (1ull << hwc->idx);\n\tif (event->attr.exclude_guest)\n\t\tcpuc->intel_ctrl_host_mask |= (1ull << hwc->idx);\n\n\tif (unlikely(hwc->config_base == MSR_ARCH_PERFMON_FIXED_CTR_CTRL)) {\n\t\tintel_pmu_enable_fixed(hwc);\n\t\treturn;\n\t}\n\n\tif (unlikely(event->attr.precise_ip))\n\t\tintel_pmu_pebs_enable(event);\n\n\t__x86_pmu_enable_event(hwc, ARCH_PERFMON_EVENTSEL_ENABLE);\n}\n\n/*\n * Save and restart an expired event. Called by NMI contexts,\n * so it has to be careful about preempting normal event ops:\n */\nint intel_pmu_save_and_restart(struct perf_event *event)\n{\n\tx86_perf_event_update(event);\n\treturn x86_perf_event_set_period(event);\n}\n\nstatic void intel_pmu_reset(void)\n{\n\tstruct debug_store *ds = __this_cpu_read(cpu_hw_events.ds);\n\tunsigned long flags;\n\tint idx;\n\n\tif (!x86_pmu.num_counters)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpr_info(\"clearing PMU state on CPU#%d\\n\", smp_processor_id());\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\twrmsrl_safe(x86_pmu_config_addr(idx), 0ull);\n\t\twrmsrl_safe(x86_pmu_event_addr(idx),  0ull);\n\t}\n\tfor (idx = 0; idx < x86_pmu.num_counters_fixed; idx++)\n\t\twrmsrl_safe(MSR_ARCH_PERFMON_FIXED_CTR0 + idx, 0ull);\n\n\tif (ds)\n\t\tds->bts_index = ds->bts_buffer_base;\n\n\tlocal_irq_restore(flags);\n}\n\n/*\n * This handler is triggered by the local APIC, so the APIC IRQ handling\n * rules apply:\n */\nstatic int intel_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tint bit, loops;\n\tu64 status;\n\tint handled;\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This handler doesn't seem to have any issues with the unmasking\n\t * so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tintel_pmu_disable_all();\n\thandled = intel_pmu_drain_bts_buffer();\n\tstatus = intel_pmu_get_status();\n\tif (!status) {\n\t\tintel_pmu_enable_all(0);\n\t\treturn handled;\n\t}\n\n\tloops = 0;\nagain:\n\tintel_pmu_ack_status(status);\n\tif (++loops > 100) {\n\t\tWARN_ONCE(1, \"perfevents: irq loop stuck!\\n\");\n\t\tperf_event_print_debug();\n\t\tintel_pmu_reset();\n\t\tgoto done;\n\t}\n\n\tinc_irq_stat(apic_perf_irqs);\n\n\tintel_pmu_lbr_read();\n\n\t/*\n\t * PEBS overflow sets bit 62 in the global status register\n\t */\n\tif (__test_and_clear_bit(62, (unsigned long *)&status)) {\n\t\thandled++;\n\t\tx86_pmu.drain_pebs(regs);\n\t}\n\n\tfor_each_set_bit(bit, (unsigned long *)&status, X86_PMC_IDX_MAX) {\n\t\tstruct perf_event *event = cpuc->events[bit];\n\n\t\thandled++;\n\n\t\tif (!test_bit(bit, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tif (!intel_pmu_save_and_restart(event))\n\t\t\tcontinue;\n\n\t\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\n\t\tif (has_branch_stack(event))\n\t\t\tdata.br_stack = &cpuc->lbr_stack;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\t/*\n\t * Repeat if there is more work to be done:\n\t */\n\tstatus = intel_pmu_get_status();\n\tif (status)\n\t\tgoto again;\n\ndone:\n\tintel_pmu_enable_all(0);\n\treturn handled;\n}\n\nstatic struct event_constraint *\nintel_bts_constraints(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tunsigned int hw_event, bts_event;\n\n\tif (event->attr.freq)\n\t\treturn NULL;\n\n\thw_event = hwc->config & INTEL_ARCH_EVENT_MASK;\n\tbts_event = x86_pmu.event_map(PERF_COUNT_HW_BRANCH_INSTRUCTIONS);\n\n\tif (unlikely(hw_event == bts_event && hwc->sample_period == 1))\n\t\treturn &bts_constraint;\n\n\treturn NULL;\n}\n\nstatic int intel_alt_er(int idx)\n{\n\tif (!(x86_pmu.er_flags & ERF_HAS_RSP_1))\n\t\treturn idx;\n\n\tif (idx == EXTRA_REG_RSP_0)\n\t\treturn EXTRA_REG_RSP_1;\n\n\tif (idx == EXTRA_REG_RSP_1)\n\t\treturn EXTRA_REG_RSP_0;\n\n\treturn idx;\n}\n\nstatic void intel_fixup_er(struct perf_event *event, int idx)\n{\n\tevent->hw.extra_reg.idx = idx;\n\n\tif (idx == EXTRA_REG_RSP_0) {\n\t\tevent->hw.config &= ~INTEL_ARCH_EVENT_MASK;\n\t\tevent->hw.config |= 0x01b7;\n\t\tevent->hw.extra_reg.reg = MSR_OFFCORE_RSP_0;\n\t} else if (idx == EXTRA_REG_RSP_1) {\n\t\tevent->hw.config &= ~INTEL_ARCH_EVENT_MASK;\n\t\tevent->hw.config |= 0x01bb;\n\t\tevent->hw.extra_reg.reg = MSR_OFFCORE_RSP_1;\n\t}\n}\n\n/*\n * manage allocation of shared extra msr for certain events\n *\n * sharing can be:\n * per-cpu: to be shared between the various events on a single PMU\n * per-core: per-cpu + shared by HT threads\n */\nstatic struct event_constraint *\n__intel_shared_reg_get_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t   struct perf_event *event,\n\t\t\t\t   struct hw_perf_event_extra *reg)\n{\n\tstruct event_constraint *c = &emptyconstraint;\n\tstruct er_account *era;\n\tunsigned long flags;\n\tint idx = reg->idx;\n\n\t/*\n\t * reg->alloc can be set due to existing state, so for fake cpuc we\n\t * need to ignore this, otherwise we might fail to allocate proper fake\n\t * state for this extra reg constraint. Also see the comment below.\n\t */\n\tif (reg->alloc && !cpuc->is_fake)\n\t\treturn NULL; /* call x86_get_event_constraint() */\n\nagain:\n\tera = &cpuc->shared_regs->regs[idx];\n\t/*\n\t * we use spin_lock_irqsave() to avoid lockdep issues when\n\t * passing a fake cpuc\n\t */\n\traw_spin_lock_irqsave(&era->lock, flags);\n\n\tif (!atomic_read(&era->ref) || era->config == reg->config) {\n\n\t\t/*\n\t\t * If its a fake cpuc -- as per validate_{group,event}() we\n\t\t * shouldn't touch event state and we can avoid doing so\n\t\t * since both will only call get_event_constraints() once\n\t\t * on each event, this avoids the need for reg->alloc.\n\t\t *\n\t\t * Not doing the ER fixup will only result in era->reg being\n\t\t * wrong, but since we won't actually try and program hardware\n\t\t * this isn't a problem either.\n\t\t */\n\t\tif (!cpuc->is_fake) {\n\t\t\tif (idx != reg->idx)\n\t\t\t\tintel_fixup_er(event, idx);\n\n\t\t\t/*\n\t\t\t * x86_schedule_events() can call get_event_constraints()\n\t\t\t * multiple times on events in the case of incremental\n\t\t\t * scheduling(). reg->alloc ensures we only do the ER\n\t\t\t * allocation once.\n\t\t\t */\n\t\t\treg->alloc = 1;\n\t\t}\n\n\t\t/* lock in msr value */\n\t\tera->config = reg->config;\n\t\tera->reg = reg->reg;\n\n\t\t/* one more user */\n\t\tatomic_inc(&era->ref);\n\n\t\t/*\n\t\t * need to call x86_get_event_constraint()\n\t\t * to check if associated event has constraints\n\t\t */\n\t\tc = NULL;\n\t} else {\n\t\tidx = intel_alt_er(idx);\n\t\tif (idx != reg->idx) {\n\t\t\traw_spin_unlock_irqrestore(&era->lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&era->lock, flags);\n\n\treturn c;\n}\n\nstatic void\n__intel_shared_reg_put_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t   struct hw_perf_event_extra *reg)\n{\n\tstruct er_account *era;\n\n\t/*\n\t * Only put constraint if extra reg was actually allocated. Also takes\n\t * care of event which do not use an extra shared reg.\n\t *\n\t * Also, if this is a fake cpuc we shouldn't touch any event state\n\t * (reg->alloc) and we don't care about leaving inconsistent cpuc state\n\t * either since it'll be thrown out.\n\t */\n\tif (!reg->alloc || cpuc->is_fake)\n\t\treturn;\n\n\tera = &cpuc->shared_regs->regs[reg->idx];\n\n\t/* one fewer user */\n\tatomic_dec(&era->ref);\n\n\t/* allocate again next time */\n\treg->alloc = 0;\n}\n\nstatic struct event_constraint *\nintel_shared_regs_constraints(struct cpu_hw_events *cpuc,\n\t\t\t      struct perf_event *event)\n{\n\tstruct event_constraint *c = NULL, *d;\n\tstruct hw_perf_event_extra *xreg, *breg;\n\n\txreg = &event->hw.extra_reg;\n\tif (xreg->idx != EXTRA_REG_NONE) {\n\t\tc = __intel_shared_reg_get_constraints(cpuc, event, xreg);\n\t\tif (c == &emptyconstraint)\n\t\t\treturn c;\n\t}\n\tbreg = &event->hw.branch_reg;\n\tif (breg->idx != EXTRA_REG_NONE) {\n\t\td = __intel_shared_reg_get_constraints(cpuc, event, breg);\n\t\tif (d == &emptyconstraint) {\n\t\t\t__intel_shared_reg_put_constraints(cpuc, xreg);\n\t\t\tc = d;\n\t\t}\n\t}\n\treturn c;\n}\n\nstruct event_constraint *\nx86_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tif (x86_pmu.event_constraints) {\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif ((event->hw.config & c->cmask) == c->code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\n\treturn &unconstrained;\n}\n\nstatic struct event_constraint *\nintel_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tc = intel_bts_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_pebs_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_shared_regs_constraints(cpuc, event);\n\tif (c)\n\t\treturn c;\n\n\treturn x86_get_event_constraints(cpuc, event);\n}\n\nstatic void\nintel_put_shared_regs_event_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t\tstruct perf_event *event)\n{\n\tstruct hw_perf_event_extra *reg;\n\n\treg = &event->hw.extra_reg;\n\tif (reg->idx != EXTRA_REG_NONE)\n\t\t__intel_shared_reg_put_constraints(cpuc, reg);\n\n\treg = &event->hw.branch_reg;\n\tif (reg->idx != EXTRA_REG_NONE)\n\t\t__intel_shared_reg_put_constraints(cpuc, reg);\n}\n\nstatic void intel_put_event_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t\tstruct perf_event *event)\n{\n\tintel_put_shared_regs_event_constraints(cpuc, event);\n}\n\nstatic void intel_pebs_aliases_core2(struct perf_event *event)\n{\n\tif ((event->hw.config & X86_RAW_EVENT_MASK) == 0x003c) {\n\t\t/*\n\t\t * Use an alternative encoding for CPU_CLK_UNHALTED.THREAD_P\n\t\t * (0x003c) so that we can use it with PEBS.\n\t\t *\n\t\t * The regular CPU_CLK_UNHALTED.THREAD_P event (0x003c) isn't\n\t\t * PEBS capable. However we can use INST_RETIRED.ANY_P\n\t\t * (0x00c0), which is a PEBS capable event, to get the same\n\t\t * count.\n\t\t *\n\t\t * INST_RETIRED.ANY_P counts the number of cycles that retires\n\t\t * CNTMASK instructions. By setting CNTMASK to a value (16)\n\t\t * larger than the maximum number of instructions that can be\n\t\t * retired per cycle (4) and then inverting the condition, we\n\t\t * count all cycles that retire 16 or less instructions, which\n\t\t * is every cycle.\n\t\t *\n\t\t * Thereby we gain a PEBS capable cycle counter.\n\t\t */\n\t\tu64 alt_config = X86_CONFIG(.event=0xc0, .inv=1, .cmask=16);\n\n\t\talt_config |= (event->hw.config & ~X86_RAW_EVENT_MASK);\n\t\tevent->hw.config = alt_config;\n\t}\n}\n\nstatic void intel_pebs_aliases_snb(struct perf_event *event)\n{\n\tif ((event->hw.config & X86_RAW_EVENT_MASK) == 0x003c) {\n\t\t/*\n\t\t * Use an alternative encoding for CPU_CLK_UNHALTED.THREAD_P\n\t\t * (0x003c) so that we can use it with PEBS.\n\t\t *\n\t\t * The regular CPU_CLK_UNHALTED.THREAD_P event (0x003c) isn't\n\t\t * PEBS capable. However we can use UOPS_RETIRED.ALL\n\t\t * (0x01c2), which is a PEBS capable event, to get the same\n\t\t * count.\n\t\t *\n\t\t * UOPS_RETIRED.ALL counts the number of cycles that retires\n\t\t * CNTMASK micro-ops. By setting CNTMASK to a value (16)\n\t\t * larger than the maximum number of micro-ops that can be\n\t\t * retired per cycle (4) and then inverting the condition, we\n\t\t * count all cycles that retire 16 or less micro-ops, which\n\t\t * is every cycle.\n\t\t *\n\t\t * Thereby we gain a PEBS capable cycle counter.\n\t\t */\n\t\tu64 alt_config = X86_CONFIG(.event=0xc2, .umask=0x01, .inv=1, .cmask=16);\n\n\t\talt_config |= (event->hw.config & ~X86_RAW_EVENT_MASK);\n\t\tevent->hw.config = alt_config;\n\t}\n}\n\nstatic int intel_pmu_hw_config(struct perf_event *event)\n{\n\tint ret = x86_pmu_hw_config(event);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (event->attr.precise_ip && x86_pmu.pebs_aliases)\n\t\tx86_pmu.pebs_aliases(event);\n\n\tif (intel_pmu_needs_lbr_smpl(event)) {\n\t\tret = intel_pmu_setup_lbr_filter(event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (event->attr.type != PERF_TYPE_RAW)\n\t\treturn 0;\n\n\tif (!(event->attr.config & ARCH_PERFMON_EVENTSEL_ANY))\n\t\treturn 0;\n\n\tif (x86_pmu.version < 3)\n\t\treturn -EINVAL;\n\n\tif (perf_paranoid_cpu() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tevent->hw.config |= ARCH_PERFMON_EVENTSEL_ANY;\n\n\treturn 0;\n}\n\nstruct perf_guest_switch_msr *perf_guest_get_msrs(int *nr)\n{\n\tif (x86_pmu.guest_get_msrs)\n\t\treturn x86_pmu.guest_get_msrs(nr);\n\t*nr = 0;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(perf_guest_get_msrs);\n\nstatic struct perf_guest_switch_msr *intel_guest_get_msrs(int *nr)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_guest_switch_msr *arr = cpuc->guest_switch_msrs;\n\n\tarr[0].msr = MSR_CORE_PERF_GLOBAL_CTRL;\n\tarr[0].host = x86_pmu.intel_ctrl & ~cpuc->intel_ctrl_guest_mask;\n\tarr[0].guest = x86_pmu.intel_ctrl & ~cpuc->intel_ctrl_host_mask;\n\t/*\n\t * If PMU counter has PEBS enabled it is not enough to disable counter\n\t * on a guest entry since PEBS memory write can overshoot guest entry\n\t * and corrupt guest memory. Disabling PEBS solves the problem.\n\t */\n\tarr[1].msr = MSR_IA32_PEBS_ENABLE;\n\tarr[1].host = cpuc->pebs_enabled;\n\tarr[1].guest = 0;\n\n\t*nr = 2;\n\treturn arr;\n}\n\nstatic struct perf_guest_switch_msr *core_guest_get_msrs(int *nr)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_guest_switch_msr *arr = cpuc->guest_switch_msrs;\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++)  {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\n\t\tarr[idx].msr = x86_pmu_config_addr(idx);\n\t\tarr[idx].host = arr[idx].guest = 0;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tarr[idx].host = arr[idx].guest =\n\t\t\tevent->hw.config | ARCH_PERFMON_EVENTSEL_ENABLE;\n\n\t\tif (event->attr.exclude_host)\n\t\t\tarr[idx].host &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\t\telse if (event->attr.exclude_guest)\n\t\t\tarr[idx].guest &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\t}\n\n\t*nr = x86_pmu.num_counters;\n\treturn arr;\n}\n\nstatic void core_pmu_enable_event(struct perf_event *event)\n{\n\tif (!event->attr.exclude_host)\n\t\tx86_pmu_enable_event(event);\n}\n\nstatic void core_pmu_enable_all(int added)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tstruct hw_perf_event *hwc = &cpuc->events[idx]->hw;\n\n\t\tif (!test_bit(idx, cpuc->active_mask) ||\n\t\t\t\tcpuc->events[idx]->attr.exclude_host)\n\t\t\tcontinue;\n\n\t\t__x86_pmu_enable_event(hwc, ARCH_PERFMON_EVENTSEL_ENABLE);\n\t}\n}\n\nPMU_FORMAT_ATTR(event,\t\"config:0-7\"\t);\nPMU_FORMAT_ATTR(umask,\t\"config:8-15\"\t);\nPMU_FORMAT_ATTR(edge,\t\"config:18\"\t);\nPMU_FORMAT_ATTR(pc,\t\"config:19\"\t);\nPMU_FORMAT_ATTR(any,\t\"config:21\"\t); /* v3 + */\nPMU_FORMAT_ATTR(inv,\t\"config:23\"\t);\nPMU_FORMAT_ATTR(cmask,\t\"config:24-31\"\t);\n\nstatic struct attribute *intel_arch_formats_attr[] = {\n\t&format_attr_event.attr,\n\t&format_attr_umask.attr,\n\t&format_attr_edge.attr,\n\t&format_attr_pc.attr,\n\t&format_attr_inv.attr,\n\t&format_attr_cmask.attr,\n\tNULL,\n};\n\nssize_t intel_event_sysfs_show(char *page, u64 config)\n{\n\tu64 event = (config & ARCH_PERFMON_EVENTSEL_EVENT);\n\n\treturn x86_event_sysfs_show(page, config, event);\n}\n\nstatic __initconst const struct x86_pmu core_pmu = {\n\t.name\t\t\t= \"core\",\n\t.handle_irq\t\t= x86_pmu_handle_irq,\n\t.disable_all\t\t= x86_pmu_disable_all,\n\t.enable_all\t\t= core_pmu_enable_all,\n\t.enable\t\t\t= core_pmu_enable_event,\n\t.disable\t\t= x86_pmu_disable_event,\n\t.hw_config\t\t= x86_pmu_hw_config,\n\t.schedule_events\t= x86_schedule_events,\n\t.eventsel\t\t= MSR_ARCH_PERFMON_EVENTSEL0,\n\t.perfctr\t\t= MSR_ARCH_PERFMON_PERFCTR0,\n\t.event_map\t\t= intel_pmu_event_map,\n\t.max_events\t\t= ARRAY_SIZE(intel_perfmon_event_map),\n\t.apic\t\t\t= 1,\n\t/*\n\t * Intel PMCs cannot be accessed sanely above 32 bit width,\n\t * so we install an artificial 1<<31 period regardless of\n\t * the generic event period:\n\t */\n\t.max_period\t\t= (1ULL << 31) - 1,\n\t.get_event_constraints\t= intel_get_event_constraints,\n\t.put_event_constraints\t= intel_put_event_constraints,\n\t.event_constraints\t= intel_core_event_constraints,\n\t.guest_get_msrs\t\t= core_guest_get_msrs,\n\t.format_attrs\t\t= intel_arch_formats_attr,\n\t.events_sysfs_show\t= intel_event_sysfs_show,\n};\n\nstruct intel_shared_regs *allocate_shared_regs(int cpu)\n{\n\tstruct intel_shared_regs *regs;\n\tint i;\n\n\tregs = kzalloc_node(sizeof(struct intel_shared_regs),\n\t\t\t    GFP_KERNEL, cpu_to_node(cpu));\n\tif (regs) {\n\t\t/*\n\t\t * initialize the locks to keep lockdep happy\n\t\t */\n\t\tfor (i = 0; i < EXTRA_REG_MAX; i++)\n\t\t\traw_spin_lock_init(&regs->regs[i].lock);\n\n\t\tregs->core_id = -1;\n\t}\n\treturn regs;\n}\n\nstatic int intel_pmu_cpu_prepare(int cpu)\n{\n\tstruct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);\n\n\tif (!(x86_pmu.extra_regs || x86_pmu.lbr_sel_map))\n\t\treturn NOTIFY_OK;\n\n\tcpuc->shared_regs = allocate_shared_regs(cpu);\n\tif (!cpuc->shared_regs)\n\t\treturn NOTIFY_BAD;\n\n\treturn NOTIFY_OK;\n}\n\nstatic void intel_pmu_cpu_starting(int cpu)\n{\n\tstruct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);\n\tint core_id = topology_core_id(cpu);\n\tint i;\n\n\tinit_debug_store_on_cpu(cpu);\n\t/*\n\t * Deal with CPUs that don't clear their LBRs on power-up.\n\t */\n\tintel_pmu_lbr_reset();\n\n\tcpuc->lbr_sel = NULL;\n\n\tif (!cpuc->shared_regs)\n\t\treturn;\n\n\tif (!(x86_pmu.er_flags & ERF_NO_HT_SHARING)) {\n\t\tfor_each_cpu(i, topology_thread_cpumask(cpu)) {\n\t\t\tstruct intel_shared_regs *pc;\n\n\t\t\tpc = per_cpu(cpu_hw_events, i).shared_regs;\n\t\t\tif (pc && pc->core_id == core_id) {\n\t\t\t\tcpuc->kfree_on_online = cpuc->shared_regs;\n\t\t\t\tcpuc->shared_regs = pc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcpuc->shared_regs->core_id = core_id;\n\t\tcpuc->shared_regs->refcnt++;\n\t}\n\n\tif (x86_pmu.lbr_sel_map)\n\t\tcpuc->lbr_sel = &cpuc->shared_regs->regs[EXTRA_REG_LBR];\n}\n\nstatic void intel_pmu_cpu_dying(int cpu)\n{\n\tstruct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);\n\tstruct intel_shared_regs *pc;\n\n\tpc = cpuc->shared_regs;\n\tif (pc) {\n\t\tif (pc->core_id == -1 || --pc->refcnt == 0)\n\t\t\tkfree(pc);\n\t\tcpuc->shared_regs = NULL;\n\t}\n\n\tfini_debug_store_on_cpu(cpu);\n}\n\nstatic void intel_pmu_flush_branch_stack(void)\n{\n\t/*\n\t * Intel LBR does not tag entries with the\n\t * PID of the current task, then we need to\n\t * flush it on ctxsw\n\t * For now, we simply reset it\n\t */\n\tif (x86_pmu.lbr_nr)\n\t\tintel_pmu_lbr_reset();\n}\n\nPMU_FORMAT_ATTR(offcore_rsp, \"config1:0-63\");\n\nstatic struct attribute *intel_arch3_formats_attr[] = {\n\t&format_attr_event.attr,\n\t&format_attr_umask.attr,\n\t&format_attr_edge.attr,\n\t&format_attr_pc.attr,\n\t&format_attr_any.attr,\n\t&format_attr_inv.attr,\n\t&format_attr_cmask.attr,\n\n\t&format_attr_offcore_rsp.attr, /* XXX do NHM/WSM + SNB breakout */\n\tNULL,\n};\n\nstatic __initconst const struct x86_pmu intel_pmu = {\n\t.name\t\t\t= \"Intel\",\n\t.handle_irq\t\t= intel_pmu_handle_irq,\n\t.disable_all\t\t= intel_pmu_disable_all,\n\t.enable_all\t\t= intel_pmu_enable_all,\n\t.enable\t\t\t= intel_pmu_enable_event,\n\t.disable\t\t= intel_pmu_disable_event,\n\t.hw_config\t\t= intel_pmu_hw_config,\n\t.schedule_events\t= x86_schedule_events,\n\t.eventsel\t\t= MSR_ARCH_PERFMON_EVENTSEL0,\n\t.perfctr\t\t= MSR_ARCH_PERFMON_PERFCTR0,\n\t.event_map\t\t= intel_pmu_event_map,\n\t.max_events\t\t= ARRAY_SIZE(intel_perfmon_event_map),\n\t.apic\t\t\t= 1,\n\t/*\n\t * Intel PMCs cannot be accessed sanely above 32 bit width,\n\t * so we install an artificial 1<<31 period regardless of\n\t * the generic event period:\n\t */\n\t.max_period\t\t= (1ULL << 31) - 1,\n\t.get_event_constraints\t= intel_get_event_constraints,\n\t.put_event_constraints\t= intel_put_event_constraints,\n\t.pebs_aliases\t\t= intel_pebs_aliases_core2,\n\n\t.format_attrs\t\t= intel_arch3_formats_attr,\n\t.events_sysfs_show\t= intel_event_sysfs_show,\n\n\t.cpu_prepare\t\t= intel_pmu_cpu_prepare,\n\t.cpu_starting\t\t= intel_pmu_cpu_starting,\n\t.cpu_dying\t\t= intel_pmu_cpu_dying,\n\t.guest_get_msrs\t\t= intel_guest_get_msrs,\n\t.flush_branch_stack\t= intel_pmu_flush_branch_stack,\n};\n\nstatic __init void intel_clovertown_quirk(void)\n{\n\t/*\n\t * PEBS is unreliable due to:\n\t *\n\t *   AJ67  - PEBS may experience CPL leaks\n\t *   AJ68  - PEBS PMI may be delayed by one event\n\t *   AJ69  - GLOBAL_STATUS[62] will only be set when DEBUGCTL[12]\n\t *   AJ106 - FREEZE_LBRS_ON_PMI doesn't work in combination with PEBS\n\t *\n\t * AJ67 could be worked around by restricting the OS/USR flags.\n\t * AJ69 could be worked around by setting PMU_FREEZE_ON_PMI.\n\t *\n\t * AJ106 could possibly be worked around by not allowing LBR\n\t *       usage from PEBS, including the fixup.\n\t * AJ68  could possibly be worked around by always programming\n\t *\t a pebs_event_reset[0] value and coping with the lost events.\n\t *\n\t * But taken together it might just make sense to not enable PEBS on\n\t * these chips.\n\t */\n\tpr_warn(\"PEBS disabled due to CPU errata\\n\");\n\tx86_pmu.pebs = 0;\n\tx86_pmu.pebs_constraints = NULL;\n}\n\nstatic int intel_snb_pebs_broken(int cpu)\n{\n\tu32 rev = UINT_MAX; /* default to broken for unknown models */\n\n\tswitch (cpu_data(cpu).x86_model) {\n\tcase 42: /* SNB */\n\t\trev = 0x28;\n\t\tbreak;\n\n\tcase 45: /* SNB-EP */\n\t\tswitch (cpu_data(cpu).x86_mask) {\n\t\tcase 6: rev = 0x618; break;\n\t\tcase 7: rev = 0x70c; break;\n\t\t}\n\t}\n\n\treturn (cpu_data(cpu).microcode < rev);\n}\n\nstatic void intel_snb_check_microcode(void)\n{\n\tint pebs_broken = 0;\n\tint cpu;\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tif ((pebs_broken = intel_snb_pebs_broken(cpu)))\n\t\t\tbreak;\n\t}\n\tput_online_cpus();\n\n\tif (pebs_broken == x86_pmu.pebs_broken)\n\t\treturn;\n\n\t/*\n\t * Serialized by the microcode lock..\n\t */\n\tif (x86_pmu.pebs_broken) {\n\t\tpr_info(\"PEBS enabled due to microcode update\\n\");\n\t\tx86_pmu.pebs_broken = 0;\n\t} else {\n\t\tpr_info(\"PEBS disabled due to CPU errata, please upgrade microcode\\n\");\n\t\tx86_pmu.pebs_broken = 1;\n\t}\n}\n\nstatic __init void intel_sandybridge_quirk(void)\n{\n\tx86_pmu.check_microcode = intel_snb_check_microcode;\n\tintel_snb_check_microcode();\n}\n\nstatic const struct { int id; char *name; } intel_arch_events_map[] __initconst = {\n\t{ PERF_COUNT_HW_CPU_CYCLES, \"cpu cycles\" },\n\t{ PERF_COUNT_HW_INSTRUCTIONS, \"instructions\" },\n\t{ PERF_COUNT_HW_BUS_CYCLES, \"bus cycles\" },\n\t{ PERF_COUNT_HW_CACHE_REFERENCES, \"cache references\" },\n\t{ PERF_COUNT_HW_CACHE_MISSES, \"cache misses\" },\n\t{ PERF_COUNT_HW_BRANCH_INSTRUCTIONS, \"branch instructions\" },\n\t{ PERF_COUNT_HW_BRANCH_MISSES, \"branch misses\" },\n};\n\nstatic __init void intel_arch_events_quirk(void)\n{\n\tint bit;\n\n\t/* disable event that reported as not presend by cpuid */\n\tfor_each_set_bit(bit, x86_pmu.events_mask, ARRAY_SIZE(intel_arch_events_map)) {\n\t\tintel_perfmon_event_map[intel_arch_events_map[bit].id] = 0;\n\t\tpr_warn(\"CPUID marked event: \\'%s\\' unavailable\\n\",\n\t\t\tintel_arch_events_map[bit].name);\n\t}\n}\n\nstatic __init void intel_nehalem_quirk(void)\n{\n\tunion cpuid10_ebx ebx;\n\n\tebx.full = x86_pmu.events_maskl;\n\tif (ebx.split.no_branch_misses_retired) {\n\t\t/*\n\t\t * Erratum AAJ80 detected, we work it around by using\n\t\t * the BR_MISP_EXEC.ANY event. This will over-count\n\t\t * branch-misses, but it's still much better than the\n\t\t * architectural event which is often completely bogus:\n\t\t */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_BRANCH_MISSES] = 0x7f89;\n\t\tebx.split.no_branch_misses_retired = 0;\n\t\tx86_pmu.events_maskl = ebx.full;\n\t\tpr_info(\"CPU erratum AAJ80 worked around\\n\");\n\t}\n}\n\n__init int intel_pmu_init(void)\n{\n\tunion cpuid10_edx edx;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_ebx ebx;\n\tstruct event_constraint *c;\n\tunsigned int unused;\n\tint version;\n\n\tif (!cpu_has(&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {\n\t\tswitch (boot_cpu_data.x86) {\n\t\tcase 0x6:\n\t\t\treturn p6_pmu_init();\n\t\tcase 0xb:\n\t\t\treturn knc_pmu_init();\n\t\tcase 0xf:\n\t\t\treturn p4_pmu_init();\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t * Check whether the Architectural PerfMon supports\n\t * Branch Misses Retired hw_event or not.\n\t */\n\tcpuid(10, &eax.full, &ebx.full, &unused, &edx.full);\n\tif (eax.split.mask_length < ARCH_PERFMON_EVENTS_COUNT)\n\t\treturn -ENODEV;\n\n\tversion = eax.split.version_id;\n\tif (version < 2)\n\t\tx86_pmu = core_pmu;\n\telse\n\t\tx86_pmu = intel_pmu;\n\n\tx86_pmu.version\t\t\t= version;\n\tx86_pmu.num_counters\t\t= eax.split.num_counters;\n\tx86_pmu.cntval_bits\t\t= eax.split.bit_width;\n\tx86_pmu.cntval_mask\t\t= (1ULL << eax.split.bit_width) - 1;\n\n\tx86_pmu.events_maskl\t\t= ebx.full;\n\tx86_pmu.events_mask_len\t\t= eax.split.mask_length;\n\n\tx86_pmu.max_pebs_events\t\t= min_t(unsigned, MAX_PEBS_EVENTS, x86_pmu.num_counters);\n\n\t/*\n\t * Quirk: v2 perfmon does not report fixed-purpose events, so\n\t * assume at least 3 events:\n\t */\n\tif (version > 1)\n\t\tx86_pmu.num_counters_fixed = max((int)edx.split.num_counters_fixed, 3);\n\n\t/*\n\t * v2 and above have a perf capabilities MSR\n\t */\n\tif (version > 1) {\n\t\tu64 capabilities;\n\n\t\trdmsrl(MSR_IA32_PERF_CAPABILITIES, capabilities);\n\t\tx86_pmu.intel_cap.capabilities = capabilities;\n\t}\n\n\tintel_ds_init();\n\n\tx86_add_quirk(intel_arch_events_quirk); /* Install first, so it runs last */\n\n\t/*\n\t * Install the hw-cache-events table:\n\t */\n\tswitch (boot_cpu_data.x86_model) {\n\tcase 14: /* 65 nm core solo/duo, \"Yonah\" */\n\t\tpr_cont(\"Core events, \");\n\t\tbreak;\n\n\tcase 15: /* original 65 nm celeron/pentium/core2/xeon, \"Merom\"/\"Conroe\" */\n\t\tx86_add_quirk(intel_clovertown_quirk);\n\tcase 22: /* single-core 65 nm celeron/core2solo \"Merom-L\"/\"Conroe-L\" */\n\tcase 23: /* current 45 nm celeron/core2/xeon \"Penryn\"/\"Wolfdale\" */\n\tcase 29: /* six-core 45 nm xeon \"Dunnington\" */\n\t\tmemcpy(hw_cache_event_ids, core2_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_core();\n\n\t\tx86_pmu.event_constraints = intel_core2_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_core2_pebs_event_constraints;\n\t\tpr_cont(\"Core2 events, \");\n\t\tbreak;\n\n\tcase 26: /* 45 nm nehalem, \"Bloomfield\" */\n\tcase 30: /* 45 nm nehalem, \"Lynnfield\" */\n\tcase 46: /* 45 nm nehalem-ex, \"Beckton\" */\n\t\tmemcpy(hw_cache_event_ids, nehalem_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_nehalem_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_nehalem_pebs_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.extra_regs = intel_nehalem_extra_regs;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tx86_add_quirk(intel_nehalem_quirk);\n\n\t\tpr_cont(\"Nehalem events, \");\n\t\tbreak;\n\n\tcase 28: /* Atom */\n\tcase 38: /* Lincroft */\n\tcase 39: /* Penwell */\n\tcase 53: /* Cloverview */\n\tcase 54: /* Cedarview */\n\t\tmemcpy(hw_cache_event_ids, atom_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_atom();\n\n\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_atom_pebs_event_constraints;\n\t\tpr_cont(\"Atom events, \");\n\t\tbreak;\n\n\tcase 37: /* 32 nm nehalem, \"Clarkdale\" */\n\tcase 44: /* 32 nm nehalem, \"Gulftown\" */\n\tcase 47: /* 32 nm Xeon E7 */\n\t\tmemcpy(hw_cache_event_ids, westmere_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_westmere_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.pebs_constraints = intel_westmere_pebs_event_constraints;\n\t\tx86_pmu.extra_regs = intel_westmere_extra_regs;\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"Westmere events, \");\n\t\tbreak;\n\n\tcase 42: /* SandyBridge */\n\tcase 45: /* SandyBridge, \"Romely-EP\" */\n\t\tx86_add_quirk(intel_sandybridge_quirk);\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n\t\tx86_pmu.event_constraints = intel_snb_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_snb_pebs_event_constraints;\n\t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n\t\t/* all extra regs are per-cpu when HT is on */\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_DISPATCHED.THREAD,c=1,i=1 to count stall cycles*/\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"SandyBridge events, \");\n\t\tbreak;\n\tcase 58: /* IvyBridge */\n\tcase 62: /* IvyBridge EP */\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n\t\tx86_pmu.event_constraints = intel_ivb_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_ivb_pebs_event_constraints;\n\t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n\t\t/* all extra regs are per-cpu when HT is on */\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"IvyBridge events, \");\n\t\tbreak;\n\n\n\tdefault:\n\t\tswitch (x86_pmu.version) {\n\t\tcase 1:\n\t\t\tx86_pmu.event_constraints = intel_v1_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon v1, \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * default constraints for v2 and up\n\t\t\t */\n\t\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon, \");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (x86_pmu.num_counters > INTEL_PMC_MAX_GENERIC) {\n\t\tWARN(1, KERN_ERR \"hw perf events %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters, INTEL_PMC_MAX_GENERIC);\n\t\tx86_pmu.num_counters = INTEL_PMC_MAX_GENERIC;\n\t}\n\tx86_pmu.intel_ctrl = (1 << x86_pmu.num_counters) - 1;\n\n\tif (x86_pmu.num_counters_fixed > INTEL_PMC_MAX_FIXED) {\n\t\tWARN(1, KERN_ERR \"hw perf events fixed %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters_fixed, INTEL_PMC_MAX_FIXED);\n\t\tx86_pmu.num_counters_fixed = INTEL_PMC_MAX_FIXED;\n\t}\n\n\tx86_pmu.intel_ctrl |=\n\t\t((1LL << x86_pmu.num_counters_fixed)-1) << INTEL_PMC_IDX_FIXED;\n\n\tif (x86_pmu.event_constraints) {\n\t\t/*\n\t\t * event on fixed counter2 (REF_CYCLES) only works on this\n\t\t * counter, so do not extend mask to generic counters\n\t\t */\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif (c->cmask != X86_RAW_EVENT_MASK\n\t\t\t    || c->idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;\n\t\t\tc->weight += x86_pmu.num_counters;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Per core/cpu state\n *\n * Used to coordinate shared registers between HT threads or\n * among events on a single PMU.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <asm/hardirq.h>\n#include <asm/apic.h>\n\n#include \"perf_event.h\"\n\n/*\n * Intel PerfMon, used on Core and later.\n */\nstatic u64 intel_perfmon_event_map[PERF_COUNT_HW_MAX] __read_mostly =\n{\n\t[PERF_COUNT_HW_CPU_CYCLES]\t\t= 0x003c,\n\t[PERF_COUNT_HW_INSTRUCTIONS]\t\t= 0x00c0,\n\t[PERF_COUNT_HW_CACHE_REFERENCES]\t= 0x4f2e,\n\t[PERF_COUNT_HW_CACHE_MISSES]\t\t= 0x412e,\n\t[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]\t= 0x00c4,\n\t[PERF_COUNT_HW_BRANCH_MISSES]\t\t= 0x00c5,\n\t[PERF_COUNT_HW_BUS_CYCLES]\t\t= 0x013c,\n\t[PERF_COUNT_HW_REF_CPU_CYCLES]\t\t= 0x0300, /* pseudo-encoding */\n};\n\nstatic struct event_constraint intel_core_event_constraints[] __read_mostly =\n{\n\tINTEL_EVENT_CONSTRAINT(0x11, 0x2), /* FP_ASSIST */\n\tINTEL_EVENT_CONSTRAINT(0x12, 0x2), /* MUL */\n\tINTEL_EVENT_CONSTRAINT(0x13, 0x2), /* DIV */\n\tINTEL_EVENT_CONSTRAINT(0x14, 0x1), /* CYCLES_DIV_BUSY */\n\tINTEL_EVENT_CONSTRAINT(0x19, 0x2), /* DELAYED_BYPASS */\n\tINTEL_EVENT_CONSTRAINT(0xc1, 0x1), /* FP_COMP_INSTR_RET */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_core2_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_EVENT_CONSTRAINT(0x10, 0x1), /* FP_COMP_OPS_EXE */\n\tINTEL_EVENT_CONSTRAINT(0x11, 0x2), /* FP_ASSIST */\n\tINTEL_EVENT_CONSTRAINT(0x12, 0x2), /* MUL */\n\tINTEL_EVENT_CONSTRAINT(0x13, 0x2), /* DIV */\n\tINTEL_EVENT_CONSTRAINT(0x14, 0x1), /* CYCLES_DIV_BUSY */\n\tINTEL_EVENT_CONSTRAINT(0x18, 0x1), /* IDLE_DURING_DIV */\n\tINTEL_EVENT_CONSTRAINT(0x19, 0x2), /* DELAYED_BYPASS */\n\tINTEL_EVENT_CONSTRAINT(0xa1, 0x1), /* RS_UOPS_DISPATCH_CYCLES */\n\tINTEL_EVENT_CONSTRAINT(0xc9, 0x1), /* ITLB_MISS_RETIRED (T30-9) */\n\tINTEL_EVENT_CONSTRAINT(0xcb, 0x1), /* MEM_LOAD_RETIRED */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_nehalem_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_EVENT_CONSTRAINT(0x40, 0x3), /* L1D_CACHE_LD */\n\tINTEL_EVENT_CONSTRAINT(0x41, 0x3), /* L1D_CACHE_ST */\n\tINTEL_EVENT_CONSTRAINT(0x42, 0x3), /* L1D_CACHE_LOCK */\n\tINTEL_EVENT_CONSTRAINT(0x43, 0x3), /* L1D_ALL_REF */\n\tINTEL_EVENT_CONSTRAINT(0x48, 0x3), /* L1D_PEND_MISS */\n\tINTEL_EVENT_CONSTRAINT(0x4e, 0x3), /* L1D_PREFETCH */\n\tINTEL_EVENT_CONSTRAINT(0x51, 0x3), /* L1D */\n\tINTEL_EVENT_CONSTRAINT(0x63, 0x3), /* CACHE_LOCK_CYCLES */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct extra_reg intel_nehalem_extra_regs[] __read_mostly =\n{\n\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0xffff, RSP_0),\n\tEVENT_EXTRA_END\n};\n\nstatic struct event_constraint intel_westmere_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_EVENT_CONSTRAINT(0x51, 0x3), /* L1D */\n\tINTEL_EVENT_CONSTRAINT(0x60, 0x1), /* OFFCORE_REQUESTS_OUTSTANDING */\n\tINTEL_EVENT_CONSTRAINT(0x63, 0x3), /* CACHE_LOCK_CYCLES */\n\tINTEL_EVENT_CONSTRAINT(0xb3, 0x1), /* SNOOPQ_REQUEST_OUTSTANDING */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_snb_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_UEVENT_CONSTRAINT(0x04a3, 0xf), /* CYCLE_ACTIVITY.CYCLES_NO_DISPATCH */\n\tINTEL_UEVENT_CONSTRAINT(0x05a3, 0xf), /* CYCLE_ACTIVITY.STALLS_L2_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x02a3, 0x4), /* CYCLE_ACTIVITY.CYCLES_L1D_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x06a3, 0x4), /* CYCLE_ACTIVITY.STALLS_L1D_PENDING */\n\tINTEL_EVENT_CONSTRAINT(0x48, 0x4), /* L1D_PEND_MISS.PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x01c0, 0x2), /* INST_RETIRED.PREC_DIST */\n\tINTEL_EVENT_CONSTRAINT(0xcd, 0x8), /* MEM_TRANS_RETIRED.LOAD_LATENCY */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_ivb_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tINTEL_UEVENT_CONSTRAINT(0x0148, 0x4), /* L1D_PEND_MISS.PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x0279, 0xf), /* IDQ.EMTPY */\n\tINTEL_UEVENT_CONSTRAINT(0x019c, 0xf), /* IDQ_UOPS_NOT_DELIVERED.CORE */\n\tINTEL_UEVENT_CONSTRAINT(0x04a3, 0xf), /* CYCLE_ACTIVITY.CYCLES_NO_EXECUTE */\n\tINTEL_UEVENT_CONSTRAINT(0x05a3, 0xf), /* CYCLE_ACTIVITY.STALLS_L2_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x06a3, 0xf), /* CYCLE_ACTIVITY.STALLS_LDM_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x08a3, 0x4), /* CYCLE_ACTIVITY.CYCLES_L1D_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x0ca3, 0x4), /* CYCLE_ACTIVITY.STALLS_L1D_PENDING */\n\tINTEL_UEVENT_CONSTRAINT(0x01c0, 0x2), /* INST_RETIRED.PREC_DIST */\n\tINTEL_EVENT_CONSTRAINT(0xd0, 0xf), /* MEM_UOPS_RETIRED.* */\n\tINTEL_EVENT_CONSTRAINT(0xd1, 0xf), /* MEM_LOAD_UOPS_RETIRED.* */\n\tINTEL_EVENT_CONSTRAINT(0xd2, 0xf), /* MEM_LOAD_UOPS_LLC_HIT_RETIRED.* */\n\tINTEL_EVENT_CONSTRAINT(0xd3, 0xf), /*  MEM_LOAD_UOPS_LLC_MISS_RETIRED.* */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct extra_reg intel_westmere_extra_regs[] __read_mostly =\n{\n\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0xffff, RSP_0),\n\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0xffff, RSP_1),\n\tEVENT_EXTRA_END\n};\n\nstatic struct event_constraint intel_v1_event_constraints[] __read_mostly =\n{\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct event_constraint intel_gen_event_constraints[] __read_mostly =\n{\n\tFIXED_EVENT_CONSTRAINT(0x00c0, 0), /* INST_RETIRED.ANY */\n\tFIXED_EVENT_CONSTRAINT(0x003c, 1), /* CPU_CLK_UNHALTED.CORE */\n\tFIXED_EVENT_CONSTRAINT(0x0300, 2), /* CPU_CLK_UNHALTED.REF */\n\tEVENT_CONSTRAINT_END\n};\n\nstatic struct extra_reg intel_snb_extra_regs[] __read_mostly = {\n\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3f807f8fffull, RSP_0),\n\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3f807f8fffull, RSP_1),\n\tEVENT_EXTRA_END\n};\n\nstatic struct extra_reg intel_snbep_extra_regs[] __read_mostly = {\n\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3fffff8fffull, RSP_0),\n\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3fffff8fffull, RSP_1),\n\tEVENT_EXTRA_END\n};\n\nstatic u64 intel_pmu_event_map(int hw_event)\n{\n\treturn intel_perfmon_event_map[hw_event];\n}\n\n#define SNB_DMND_DATA_RD\t(1ULL << 0)\n#define SNB_DMND_RFO\t\t(1ULL << 1)\n#define SNB_DMND_IFETCH\t\t(1ULL << 2)\n#define SNB_DMND_WB\t\t(1ULL << 3)\n#define SNB_PF_DATA_RD\t\t(1ULL << 4)\n#define SNB_PF_RFO\t\t(1ULL << 5)\n#define SNB_PF_IFETCH\t\t(1ULL << 6)\n#define SNB_LLC_DATA_RD\t\t(1ULL << 7)\n#define SNB_LLC_RFO\t\t(1ULL << 8)\n#define SNB_LLC_IFETCH\t\t(1ULL << 9)\n#define SNB_BUS_LOCKS\t\t(1ULL << 10)\n#define SNB_STRM_ST\t\t(1ULL << 11)\n#define SNB_OTHER\t\t(1ULL << 15)\n#define SNB_RESP_ANY\t\t(1ULL << 16)\n#define SNB_NO_SUPP\t\t(1ULL << 17)\n#define SNB_LLC_HITM\t\t(1ULL << 18)\n#define SNB_LLC_HITE\t\t(1ULL << 19)\n#define SNB_LLC_HITS\t\t(1ULL << 20)\n#define SNB_LLC_HITF\t\t(1ULL << 21)\n#define SNB_LOCAL\t\t(1ULL << 22)\n#define SNB_REMOTE\t\t(0xffULL << 23)\n#define SNB_SNP_NONE\t\t(1ULL << 31)\n#define SNB_SNP_NOT_NEEDED\t(1ULL << 32)\n#define SNB_SNP_MISS\t\t(1ULL << 33)\n#define SNB_NO_FWD\t\t(1ULL << 34)\n#define SNB_SNP_FWD\t\t(1ULL << 35)\n#define SNB_HITM\t\t(1ULL << 36)\n#define SNB_NON_DRAM\t\t(1ULL << 37)\n\n#define SNB_DMND_READ\t\t(SNB_DMND_DATA_RD|SNB_LLC_DATA_RD)\n#define SNB_DMND_WRITE\t\t(SNB_DMND_RFO|SNB_LLC_RFO)\n#define SNB_DMND_PREFETCH\t(SNB_PF_DATA_RD|SNB_PF_RFO)\n\n#define SNB_SNP_ANY\t\t(SNB_SNP_NONE|SNB_SNP_NOT_NEEDED| \\\n\t\t\t\t SNB_SNP_MISS|SNB_NO_FWD|SNB_SNP_FWD| \\\n\t\t\t\t SNB_HITM)\n\n#define SNB_DRAM_ANY\t\t(SNB_LOCAL|SNB_REMOTE|SNB_SNP_ANY)\n#define SNB_DRAM_REMOTE\t\t(SNB_REMOTE|SNB_SNP_ANY)\n\n#define SNB_L3_ACCESS\t\tSNB_RESP_ANY\n#define SNB_L3_MISS\t\t(SNB_DRAM_ANY|SNB_NON_DRAM)\n\nstatic __initconst const u64 snb_hw_cache_extra_regs\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_READ|SNB_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_READ|SNB_L3_MISS,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_WRITE|SNB_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_WRITE|SNB_L3_MISS,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_PREFETCH|SNB_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_PREFETCH|SNB_L3_MISS,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_READ|SNB_DRAM_ANY,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_READ|SNB_DRAM_REMOTE,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_WRITE|SNB_DRAM_ANY,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_WRITE|SNB_DRAM_REMOTE,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = SNB_DMND_PREFETCH|SNB_DRAM_ANY,\n\t\t[ C(RESULT_MISS)   ] = SNB_DMND_PREFETCH|SNB_DRAM_REMOTE,\n\t},\n },\n};\n\nstatic __initconst const u64 snb_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0xf1d0, /* MEM_UOP_RETIRED.LOADS        */\n\t\t[ C(RESULT_MISS)   ] = 0x0151, /* L1D.REPLACEMENT              */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0xf2d0, /* MEM_UOP_RETIRED.STORES       */\n\t\t[ C(RESULT_MISS)   ] = 0x0851, /* L1D.ALL_M_REPLACEMENT        */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x024e, /* HW_PRE_REQ.DL1_MISS          */\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* ICACHE.MISSES */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t/* OFFCORE_RESPONSE.PREFETCH.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.PREFETCH.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x81d0, /* MEM_UOP_RETIRED.ALL_LOADS */\n\t\t[ C(RESULT_MISS)   ] = 0x0108, /* DTLB_LOAD_MISSES.CAUSES_A_WALK */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x82d0, /* MEM_UOP_RETIRED.ALL_STORES */\n\t\t[ C(RESULT_MISS)   ] = 0x0149, /* DTLB_STORE_MISSES.MISS_CAUSES_A_WALK */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x1085, /* ITLB_MISSES.STLB_HIT         */\n\t\t[ C(RESULT_MISS)   ] = 0x0185, /* ITLB_MISSES.CAUSES_A_WALK    */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ALL_BRANCHES */\n\t\t[ C(RESULT_MISS)   ] = 0x00c5, /* BR_MISP_RETIRED.ALL_BRANCHES */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n\n};\n\nstatic __initconst const u64 westmere_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x010b, /* MEM_INST_RETIRED.LOADS       */\n\t\t[ C(RESULT_MISS)   ] = 0x0151, /* L1D.REPL                     */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x020b, /* MEM_INST_RETURED.STORES      */\n\t\t[ C(RESULT_MISS)   ] = 0x0251, /* L1D.M_REPL                   */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x014e, /* L1D_PREFETCH.REQUESTS        */\n\t\t[ C(RESULT_MISS)   ] = 0x024e, /* L1D_PREFETCH.MISS            */\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0380, /* L1I.READS                    */\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* L1I.MISSES                   */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t/*\n\t * Use RFO, not WRITEBACK, because a write miss would typically occur\n\t * on RFO.\n\t */\n\t[ C(OP_WRITE) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t/* OFFCORE_RESPONSE.PREFETCH.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.PREFETCH.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x010b, /* MEM_INST_RETIRED.LOADS       */\n\t\t[ C(RESULT_MISS)   ] = 0x0108, /* DTLB_LOAD_MISSES.ANY         */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x020b, /* MEM_INST_RETURED.STORES      */\n\t\t[ C(RESULT_MISS)   ] = 0x010c, /* MEM_STORE_RETIRED.DTLB_MISS  */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01c0, /* INST_RETIRED.ANY_P           */\n\t\t[ C(RESULT_MISS)   ] = 0x0185, /* ITLB_MISSES.ANY              */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ALL_BRANCHES */\n\t\t[ C(RESULT_MISS)   ] = 0x03e8, /* BPU_CLEARS.ANY               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n};\n\n/*\n * Nehalem/Westmere MSR_OFFCORE_RESPONSE bits;\n * See IA32 SDM Vol 3B 30.6.1.3\n */\n\n#define NHM_DMND_DATA_RD\t(1 << 0)\n#define NHM_DMND_RFO\t\t(1 << 1)\n#define NHM_DMND_IFETCH\t\t(1 << 2)\n#define NHM_DMND_WB\t\t(1 << 3)\n#define NHM_PF_DATA_RD\t\t(1 << 4)\n#define NHM_PF_DATA_RFO\t\t(1 << 5)\n#define NHM_PF_IFETCH\t\t(1 << 6)\n#define NHM_OFFCORE_OTHER\t(1 << 7)\n#define NHM_UNCORE_HIT\t\t(1 << 8)\n#define NHM_OTHER_CORE_HIT_SNP\t(1 << 9)\n#define NHM_OTHER_CORE_HITM\t(1 << 10)\n        \t\t\t/* reserved */\n#define NHM_REMOTE_CACHE_FWD\t(1 << 12)\n#define NHM_REMOTE_DRAM\t\t(1 << 13)\n#define NHM_LOCAL_DRAM\t\t(1 << 14)\n#define NHM_NON_DRAM\t\t(1 << 15)\n\n#define NHM_LOCAL\t\t(NHM_LOCAL_DRAM|NHM_REMOTE_CACHE_FWD)\n#define NHM_REMOTE\t\t(NHM_REMOTE_DRAM)\n\n#define NHM_DMND_READ\t\t(NHM_DMND_DATA_RD)\n#define NHM_DMND_WRITE\t\t(NHM_DMND_RFO|NHM_DMND_WB)\n#define NHM_DMND_PREFETCH\t(NHM_PF_DATA_RD|NHM_PF_DATA_RFO)\n\n#define NHM_L3_HIT\t(NHM_UNCORE_HIT|NHM_OTHER_CORE_HIT_SNP|NHM_OTHER_CORE_HITM)\n#define NHM_L3_MISS\t(NHM_NON_DRAM|NHM_LOCAL_DRAM|NHM_REMOTE_DRAM|NHM_REMOTE_CACHE_FWD)\n#define NHM_L3_ACCESS\t(NHM_L3_HIT|NHM_L3_MISS)\n\nstatic __initconst const u64 nehalem_hw_cache_extra_regs\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_READ|NHM_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_READ|NHM_L3_MISS,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_WRITE|NHM_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_WRITE|NHM_L3_MISS,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_PREFETCH|NHM_L3_ACCESS,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_PREFETCH|NHM_L3_MISS,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_READ|NHM_LOCAL|NHM_REMOTE,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_READ|NHM_REMOTE,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_WRITE|NHM_LOCAL|NHM_REMOTE,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_WRITE|NHM_REMOTE,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = NHM_DMND_PREFETCH|NHM_LOCAL|NHM_REMOTE,\n\t\t[ C(RESULT_MISS)   ] = NHM_DMND_PREFETCH|NHM_REMOTE,\n\t},\n },\n};\n\nstatic __initconst const u64 nehalem_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x010b, /* MEM_INST_RETIRED.LOADS       */\n\t\t[ C(RESULT_MISS)   ] = 0x0151, /* L1D.REPL                     */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x020b, /* MEM_INST_RETURED.STORES      */\n\t\t[ C(RESULT_MISS)   ] = 0x0251, /* L1D.M_REPL                   */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x014e, /* L1D_PREFETCH.REQUESTS        */\n\t\t[ C(RESULT_MISS)   ] = 0x024e, /* L1D_PREFETCH.MISS            */\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0380, /* L1I.READS                    */\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* L1I.MISSES                   */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_DATA.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t/*\n\t * Use RFO, not WRITEBACK, because a write miss would typically occur\n\t * on RFO.\n\t */\n\t[ C(OP_WRITE) ] = {\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.ANY_RFO.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t/* OFFCORE_RESPONSE.PREFETCH.LOCAL_CACHE */\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t/* OFFCORE_RESPONSE.PREFETCH.ANY_LLC_MISS */\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f40, /* L1D_CACHE_LD.MESI   (alias)  */\n\t\t[ C(RESULT_MISS)   ] = 0x0108, /* DTLB_LOAD_MISSES.ANY         */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f41, /* L1D_CACHE_ST.MESI   (alias)  */\n\t\t[ C(RESULT_MISS)   ] = 0x010c, /* MEM_STORE_RETIRED.DTLB_MISS  */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01c0, /* INST_RETIRED.ANY_P           */\n\t\t[ C(RESULT_MISS)   ] = 0x20c8, /* ITLB_MISS_RETIRED            */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ALL_BRANCHES */\n\t\t[ C(RESULT_MISS)   ] = 0x03e8, /* BPU_CLEARS.ANY               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(NODE) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x01b7,\n\t\t[ C(RESULT_MISS)   ] = 0x01b7,\n\t},\n },\n};\n\nstatic __initconst const u64 core2_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f40, /* L1D_CACHE_LD.MESI          */\n\t\t[ C(RESULT_MISS)   ] = 0x0140, /* L1D_CACHE_LD.I_STATE       */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f41, /* L1D_CACHE_ST.MESI          */\n\t\t[ C(RESULT_MISS)   ] = 0x0141, /* L1D_CACHE_ST.I_STATE       */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x104e, /* L1D_PREFETCH.REQUESTS      */\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0080, /* L1I.READS                  */\n\t\t[ C(RESULT_MISS)   ] = 0x0081, /* L1I.MISSES                 */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f29, /* L2_LD.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x4129, /* L2_LD.ISTATE               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f2A, /* L2_ST.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x412A, /* L2_ST.ISTATE               */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f40, /* L1D_CACHE_LD.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0208, /* DTLB_MISSES.MISS_LD        */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0f41, /* L1D_CACHE_ST.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0808, /* DTLB_MISSES.MISS_ST        */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c0, /* INST_RETIRED.ANY_P         */\n\t\t[ C(RESULT_MISS)   ] = 0x1282, /* ITLBMISSES                 */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ANY        */\n\t\t[ C(RESULT_MISS)   ] = 0x00c5, /* BP_INST_RETIRED.MISPRED    */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n};\n\nstatic __initconst const u64 atom_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2140, /* L1D_CACHE.LD               */\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2240, /* L1D_CACHE.ST               */\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0380, /* L1I.READS                  */\n\t\t[ C(RESULT_MISS)   ] = 0x0280, /* L1I.MISSES                 */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f29, /* L2_LD.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x4129, /* L2_LD.ISTATE               */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x4f2A, /* L2_ST.MESI                 */\n\t\t[ C(RESULT_MISS)   ] = 0x412A, /* L2_ST.ISTATE               */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2140, /* L1D_CACHE_LD.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0508, /* DTLB_MISSES.MISS_LD        */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x2240, /* L1D_CACHE_ST.MESI  (alias) */\n\t\t[ C(RESULT_MISS)   ] = 0x0608, /* DTLB_MISSES.MISS_ST        */\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c0, /* INST_RETIRED.ANY_P         */\n\t\t[ C(RESULT_MISS)   ] = 0x0282, /* ITLB.MISSES                */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4, /* BR_INST_RETIRED.ANY        */\n\t\t[ C(RESULT_MISS)   ] = 0x00c5, /* BP_INST_RETIRED.MISPRED    */\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n};\n\nstatic inline bool intel_pmu_needs_lbr_smpl(struct perf_event *event)\n{\n\t/* user explicitly requested branch sampling */\n\tif (has_branch_stack(event))\n\t\treturn true;\n\n\t/* implicit branch sampling to correct PEBS skid */\n\tif (x86_pmu.intel_cap.pebs_trap && event->attr.precise_ip > 1)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void intel_pmu_disable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\tif (test_bit(INTEL_PMC_IDX_FIXED_BTS, cpuc->active_mask))\n\t\tintel_pmu_disable_bts();\n\n\tintel_pmu_pebs_disable_all();\n\tintel_pmu_lbr_disable_all();\n}\n\nstatic void intel_pmu_enable_all(int added)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tintel_pmu_pebs_enable_all();\n\tintel_pmu_lbr_enable_all();\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL,\n\t\t\tx86_pmu.intel_ctrl & ~cpuc->intel_ctrl_guest_mask);\n\n\tif (test_bit(INTEL_PMC_IDX_FIXED_BTS, cpuc->active_mask)) {\n\t\tstruct perf_event *event =\n\t\t\tcpuc->events[INTEL_PMC_IDX_FIXED_BTS];\n\n\t\tif (WARN_ON_ONCE(!event))\n\t\t\treturn;\n\n\t\tintel_pmu_enable_bts(event->hw.config);\n\t}\n}\n\n/*\n * Workaround for:\n *   Intel Errata AAK100 (model 26)\n *   Intel Errata AAP53  (model 30)\n *   Intel Errata BD53   (model 44)\n *\n * The official story:\n *   These chips need to be 'reset' when adding counters by programming the\n *   magic three (non-counting) events 0x4300B5, 0x4300D2, and 0x4300B1 either\n *   in sequence on the same PMC or on different PMCs.\n *\n * In practise it appears some of these events do in fact count, and\n * we need to programm all 4 events.\n */\nstatic void intel_pmu_nhm_workaround(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstatic const unsigned long nhm_magic[4] = {\n\t\t0x4300B5,\n\t\t0x4300D2,\n\t\t0x4300B1,\n\t\t0x4300B1\n\t};\n\tstruct perf_event *event;\n\tint i;\n\n\t/*\n\t * The Errata requires below steps:\n\t * 1) Clear MSR_IA32_PEBS_ENABLE and MSR_CORE_PERF_GLOBAL_CTRL;\n\t * 2) Configure 4 PERFEVTSELx with the magic events and clear\n\t *    the corresponding PMCx;\n\t * 3) set bit0~bit3 of MSR_CORE_PERF_GLOBAL_CTRL;\n\t * 4) Clear MSR_CORE_PERF_GLOBAL_CTRL;\n\t * 5) Clear 4 pairs of ERFEVTSELx and PMCx;\n\t */\n\n\t/*\n\t * The real steps we choose are a little different from above.\n\t * A) To reduce MSR operations, we don't run step 1) as they\n\t *    are already cleared before this function is called;\n\t * B) Call x86_perf_event_update to save PMCx before configuring\n\t *    PERFEVTSELx with magic number;\n\t * C) With step 5), we do clear only when the PERFEVTSELx is\n\t *    not used currently.\n\t * D) Call x86_perf_event_set_period to restore PMCx;\n\t */\n\n\t/* We always operate 4 pairs of PERF Counters */\n\tfor (i = 0; i < 4; i++) {\n\t\tevent = cpuc->events[i];\n\t\tif (event)\n\t\t\tx86_perf_event_update(event);\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\twrmsrl(MSR_ARCH_PERFMON_EVENTSEL0 + i, nhm_magic[i]);\n\t\twrmsrl(MSR_ARCH_PERFMON_PERFCTR0 + i, 0x0);\n\t}\n\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, 0xf);\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, 0x0);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tevent = cpuc->events[i];\n\n\t\tif (event) {\n\t\t\tx86_perf_event_set_period(event);\n\t\t\t__x86_pmu_enable_event(&event->hw,\n\t\t\t\t\tARCH_PERFMON_EVENTSEL_ENABLE);\n\t\t} else\n\t\t\twrmsrl(MSR_ARCH_PERFMON_EVENTSEL0 + i, 0x0);\n\t}\n}\n\nstatic void intel_pmu_nhm_enable_all(int added)\n{\n\tif (added)\n\t\tintel_pmu_nhm_workaround();\n\tintel_pmu_enable_all(added);\n}\n\nstatic inline u64 intel_pmu_get_status(void)\n{\n\tu64 status;\n\n\trdmsrl(MSR_CORE_PERF_GLOBAL_STATUS, status);\n\n\treturn status;\n}\n\nstatic inline void intel_pmu_ack_status(u64 ack)\n{\n\twrmsrl(MSR_CORE_PERF_GLOBAL_OVF_CTRL, ack);\n}\n\nstatic void intel_pmu_disable_fixed(struct hw_perf_event *hwc)\n{\n\tint idx = hwc->idx - INTEL_PMC_IDX_FIXED;\n\tu64 ctrl_val, mask;\n\n\tmask = 0xfULL << (idx * 4);\n\n\trdmsrl(hwc->config_base, ctrl_val);\n\tctrl_val &= ~mask;\n\twrmsrl(hwc->config_base, ctrl_val);\n}\n\nstatic void intel_pmu_disable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (unlikely(hwc->idx == INTEL_PMC_IDX_FIXED_BTS)) {\n\t\tintel_pmu_disable_bts();\n\t\tintel_pmu_drain_bts_buffer();\n\t\treturn;\n\t}\n\n\tcpuc->intel_ctrl_guest_mask &= ~(1ull << hwc->idx);\n\tcpuc->intel_ctrl_host_mask &= ~(1ull << hwc->idx);\n\n\t/*\n\t * must disable before any actual event\n\t * because any event may be combined with LBR\n\t */\n\tif (intel_pmu_needs_lbr_smpl(event))\n\t\tintel_pmu_lbr_disable(event);\n\n\tif (unlikely(hwc->config_base == MSR_ARCH_PERFMON_FIXED_CTR_CTRL)) {\n\t\tintel_pmu_disable_fixed(hwc);\n\t\treturn;\n\t}\n\n\tx86_pmu_disable_event(event);\n\n\tif (unlikely(event->attr.precise_ip))\n\t\tintel_pmu_pebs_disable(event);\n}\n\nstatic void intel_pmu_enable_fixed(struct hw_perf_event *hwc)\n{\n\tint idx = hwc->idx - INTEL_PMC_IDX_FIXED;\n\tu64 ctrl_val, bits, mask;\n\n\t/*\n\t * Enable IRQ generation (0x8),\n\t * and enable ring-3 counting (0x2) and ring-0 counting (0x1)\n\t * if requested:\n\t */\n\tbits = 0x8ULL;\n\tif (hwc->config & ARCH_PERFMON_EVENTSEL_USR)\n\t\tbits |= 0x2;\n\tif (hwc->config & ARCH_PERFMON_EVENTSEL_OS)\n\t\tbits |= 0x1;\n\n\t/*\n\t * ANY bit is supported in v3 and up\n\t */\n\tif (x86_pmu.version > 2 && hwc->config & ARCH_PERFMON_EVENTSEL_ANY)\n\t\tbits |= 0x4;\n\n\tbits <<= (idx * 4);\n\tmask = 0xfULL << (idx * 4);\n\n\trdmsrl(hwc->config_base, ctrl_val);\n\tctrl_val &= ~mask;\n\tctrl_val |= bits;\n\twrmsrl(hwc->config_base, ctrl_val);\n}\n\nstatic void intel_pmu_enable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (unlikely(hwc->idx == INTEL_PMC_IDX_FIXED_BTS)) {\n\t\tif (!__this_cpu_read(cpu_hw_events.enabled))\n\t\t\treturn;\n\n\t\tintel_pmu_enable_bts(hwc->config);\n\t\treturn;\n\t}\n\t/*\n\t * must enabled before any actual event\n\t * because any event may be combined with LBR\n\t */\n\tif (intel_pmu_needs_lbr_smpl(event))\n\t\tintel_pmu_lbr_enable(event);\n\n\tif (event->attr.exclude_host)\n\t\tcpuc->intel_ctrl_guest_mask |= (1ull << hwc->idx);\n\tif (event->attr.exclude_guest)\n\t\tcpuc->intel_ctrl_host_mask |= (1ull << hwc->idx);\n\n\tif (unlikely(hwc->config_base == MSR_ARCH_PERFMON_FIXED_CTR_CTRL)) {\n\t\tintel_pmu_enable_fixed(hwc);\n\t\treturn;\n\t}\n\n\tif (unlikely(event->attr.precise_ip))\n\t\tintel_pmu_pebs_enable(event);\n\n\t__x86_pmu_enable_event(hwc, ARCH_PERFMON_EVENTSEL_ENABLE);\n}\n\n/*\n * Save and restart an expired event. Called by NMI contexts,\n * so it has to be careful about preempting normal event ops:\n */\nint intel_pmu_save_and_restart(struct perf_event *event)\n{\n\tx86_perf_event_update(event);\n\treturn x86_perf_event_set_period(event);\n}\n\nstatic void intel_pmu_reset(void)\n{\n\tstruct debug_store *ds = __this_cpu_read(cpu_hw_events.ds);\n\tunsigned long flags;\n\tint idx;\n\n\tif (!x86_pmu.num_counters)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpr_info(\"clearing PMU state on CPU#%d\\n\", smp_processor_id());\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\twrmsrl_safe(x86_pmu_config_addr(idx), 0ull);\n\t\twrmsrl_safe(x86_pmu_event_addr(idx),  0ull);\n\t}\n\tfor (idx = 0; idx < x86_pmu.num_counters_fixed; idx++)\n\t\twrmsrl_safe(MSR_ARCH_PERFMON_FIXED_CTR0 + idx, 0ull);\n\n\tif (ds)\n\t\tds->bts_index = ds->bts_buffer_base;\n\n\tlocal_irq_restore(flags);\n}\n\n/*\n * This handler is triggered by the local APIC, so the APIC IRQ handling\n * rules apply:\n */\nstatic int intel_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tint bit, loops;\n\tu64 status;\n\tint handled;\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This handler doesn't seem to have any issues with the unmasking\n\t * so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tintel_pmu_disable_all();\n\thandled = intel_pmu_drain_bts_buffer();\n\tstatus = intel_pmu_get_status();\n\tif (!status) {\n\t\tintel_pmu_enable_all(0);\n\t\treturn handled;\n\t}\n\n\tloops = 0;\nagain:\n\tintel_pmu_ack_status(status);\n\tif (++loops > 100) {\n\t\tWARN_ONCE(1, \"perfevents: irq loop stuck!\\n\");\n\t\tperf_event_print_debug();\n\t\tintel_pmu_reset();\n\t\tgoto done;\n\t}\n\n\tinc_irq_stat(apic_perf_irqs);\n\n\tintel_pmu_lbr_read();\n\n\t/*\n\t * PEBS overflow sets bit 62 in the global status register\n\t */\n\tif (__test_and_clear_bit(62, (unsigned long *)&status)) {\n\t\thandled++;\n\t\tx86_pmu.drain_pebs(regs);\n\t}\n\n\tfor_each_set_bit(bit, (unsigned long *)&status, X86_PMC_IDX_MAX) {\n\t\tstruct perf_event *event = cpuc->events[bit];\n\n\t\thandled++;\n\n\t\tif (!test_bit(bit, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tif (!intel_pmu_save_and_restart(event))\n\t\t\tcontinue;\n\n\t\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\n\t\tif (has_branch_stack(event))\n\t\t\tdata.br_stack = &cpuc->lbr_stack;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\t/*\n\t * Repeat if there is more work to be done:\n\t */\n\tstatus = intel_pmu_get_status();\n\tif (status)\n\t\tgoto again;\n\ndone:\n\tintel_pmu_enable_all(0);\n\treturn handled;\n}\n\nstatic struct event_constraint *\nintel_bts_constraints(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tunsigned int hw_event, bts_event;\n\n\tif (event->attr.freq)\n\t\treturn NULL;\n\n\thw_event = hwc->config & INTEL_ARCH_EVENT_MASK;\n\tbts_event = x86_pmu.event_map(PERF_COUNT_HW_BRANCH_INSTRUCTIONS);\n\n\tif (unlikely(hw_event == bts_event && hwc->sample_period == 1))\n\t\treturn &bts_constraint;\n\n\treturn NULL;\n}\n\nstatic int intel_alt_er(int idx)\n{\n\tif (!(x86_pmu.er_flags & ERF_HAS_RSP_1))\n\t\treturn idx;\n\n\tif (idx == EXTRA_REG_RSP_0)\n\t\treturn EXTRA_REG_RSP_1;\n\n\tif (idx == EXTRA_REG_RSP_1)\n\t\treturn EXTRA_REG_RSP_0;\n\n\treturn idx;\n}\n\nstatic void intel_fixup_er(struct perf_event *event, int idx)\n{\n\tevent->hw.extra_reg.idx = idx;\n\n\tif (idx == EXTRA_REG_RSP_0) {\n\t\tevent->hw.config &= ~INTEL_ARCH_EVENT_MASK;\n\t\tevent->hw.config |= 0x01b7;\n\t\tevent->hw.extra_reg.reg = MSR_OFFCORE_RSP_0;\n\t} else if (idx == EXTRA_REG_RSP_1) {\n\t\tevent->hw.config &= ~INTEL_ARCH_EVENT_MASK;\n\t\tevent->hw.config |= 0x01bb;\n\t\tevent->hw.extra_reg.reg = MSR_OFFCORE_RSP_1;\n\t}\n}\n\n/*\n * manage allocation of shared extra msr for certain events\n *\n * sharing can be:\n * per-cpu: to be shared between the various events on a single PMU\n * per-core: per-cpu + shared by HT threads\n */\nstatic struct event_constraint *\n__intel_shared_reg_get_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t   struct perf_event *event,\n\t\t\t\t   struct hw_perf_event_extra *reg)\n{\n\tstruct event_constraint *c = &emptyconstraint;\n\tstruct er_account *era;\n\tunsigned long flags;\n\tint idx = reg->idx;\n\n\t/*\n\t * reg->alloc can be set due to existing state, so for fake cpuc we\n\t * need to ignore this, otherwise we might fail to allocate proper fake\n\t * state for this extra reg constraint. Also see the comment below.\n\t */\n\tif (reg->alloc && !cpuc->is_fake)\n\t\treturn NULL; /* call x86_get_event_constraint() */\n\nagain:\n\tera = &cpuc->shared_regs->regs[idx];\n\t/*\n\t * we use spin_lock_irqsave() to avoid lockdep issues when\n\t * passing a fake cpuc\n\t */\n\traw_spin_lock_irqsave(&era->lock, flags);\n\n\tif (!atomic_read(&era->ref) || era->config == reg->config) {\n\n\t\t/*\n\t\t * If its a fake cpuc -- as per validate_{group,event}() we\n\t\t * shouldn't touch event state and we can avoid doing so\n\t\t * since both will only call get_event_constraints() once\n\t\t * on each event, this avoids the need for reg->alloc.\n\t\t *\n\t\t * Not doing the ER fixup will only result in era->reg being\n\t\t * wrong, but since we won't actually try and program hardware\n\t\t * this isn't a problem either.\n\t\t */\n\t\tif (!cpuc->is_fake) {\n\t\t\tif (idx != reg->idx)\n\t\t\t\tintel_fixup_er(event, idx);\n\n\t\t\t/*\n\t\t\t * x86_schedule_events() can call get_event_constraints()\n\t\t\t * multiple times on events in the case of incremental\n\t\t\t * scheduling(). reg->alloc ensures we only do the ER\n\t\t\t * allocation once.\n\t\t\t */\n\t\t\treg->alloc = 1;\n\t\t}\n\n\t\t/* lock in msr value */\n\t\tera->config = reg->config;\n\t\tera->reg = reg->reg;\n\n\t\t/* one more user */\n\t\tatomic_inc(&era->ref);\n\n\t\t/*\n\t\t * need to call x86_get_event_constraint()\n\t\t * to check if associated event has constraints\n\t\t */\n\t\tc = NULL;\n\t} else {\n\t\tidx = intel_alt_er(idx);\n\t\tif (idx != reg->idx) {\n\t\t\traw_spin_unlock_irqrestore(&era->lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&era->lock, flags);\n\n\treturn c;\n}\n\nstatic void\n__intel_shared_reg_put_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t   struct hw_perf_event_extra *reg)\n{\n\tstruct er_account *era;\n\n\t/*\n\t * Only put constraint if extra reg was actually allocated. Also takes\n\t * care of event which do not use an extra shared reg.\n\t *\n\t * Also, if this is a fake cpuc we shouldn't touch any event state\n\t * (reg->alloc) and we don't care about leaving inconsistent cpuc state\n\t * either since it'll be thrown out.\n\t */\n\tif (!reg->alloc || cpuc->is_fake)\n\t\treturn;\n\n\tera = &cpuc->shared_regs->regs[reg->idx];\n\n\t/* one fewer user */\n\tatomic_dec(&era->ref);\n\n\t/* allocate again next time */\n\treg->alloc = 0;\n}\n\nstatic struct event_constraint *\nintel_shared_regs_constraints(struct cpu_hw_events *cpuc,\n\t\t\t      struct perf_event *event)\n{\n\tstruct event_constraint *c = NULL, *d;\n\tstruct hw_perf_event_extra *xreg, *breg;\n\n\txreg = &event->hw.extra_reg;\n\tif (xreg->idx != EXTRA_REG_NONE) {\n\t\tc = __intel_shared_reg_get_constraints(cpuc, event, xreg);\n\t\tif (c == &emptyconstraint)\n\t\t\treturn c;\n\t}\n\tbreg = &event->hw.branch_reg;\n\tif (breg->idx != EXTRA_REG_NONE) {\n\t\td = __intel_shared_reg_get_constraints(cpuc, event, breg);\n\t\tif (d == &emptyconstraint) {\n\t\t\t__intel_shared_reg_put_constraints(cpuc, xreg);\n\t\t\tc = d;\n\t\t}\n\t}\n\treturn c;\n}\n\nstruct event_constraint *\nx86_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tif (x86_pmu.event_constraints) {\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif ((event->hw.config & c->cmask) == c->code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\n\treturn &unconstrained;\n}\n\nstatic struct event_constraint *\nintel_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tc = intel_bts_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_pebs_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_shared_regs_constraints(cpuc, event);\n\tif (c)\n\t\treturn c;\n\n\treturn x86_get_event_constraints(cpuc, event);\n}\n\nstatic void\nintel_put_shared_regs_event_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t\tstruct perf_event *event)\n{\n\tstruct hw_perf_event_extra *reg;\n\n\treg = &event->hw.extra_reg;\n\tif (reg->idx != EXTRA_REG_NONE)\n\t\t__intel_shared_reg_put_constraints(cpuc, reg);\n\n\treg = &event->hw.branch_reg;\n\tif (reg->idx != EXTRA_REG_NONE)\n\t\t__intel_shared_reg_put_constraints(cpuc, reg);\n}\n\nstatic void intel_put_event_constraints(struct cpu_hw_events *cpuc,\n\t\t\t\t\tstruct perf_event *event)\n{\n\tintel_put_shared_regs_event_constraints(cpuc, event);\n}\n\nstatic void intel_pebs_aliases_core2(struct perf_event *event)\n{\n\tif ((event->hw.config & X86_RAW_EVENT_MASK) == 0x003c) {\n\t\t/*\n\t\t * Use an alternative encoding for CPU_CLK_UNHALTED.THREAD_P\n\t\t * (0x003c) so that we can use it with PEBS.\n\t\t *\n\t\t * The regular CPU_CLK_UNHALTED.THREAD_P event (0x003c) isn't\n\t\t * PEBS capable. However we can use INST_RETIRED.ANY_P\n\t\t * (0x00c0), which is a PEBS capable event, to get the same\n\t\t * count.\n\t\t *\n\t\t * INST_RETIRED.ANY_P counts the number of cycles that retires\n\t\t * CNTMASK instructions. By setting CNTMASK to a value (16)\n\t\t * larger than the maximum number of instructions that can be\n\t\t * retired per cycle (4) and then inverting the condition, we\n\t\t * count all cycles that retire 16 or less instructions, which\n\t\t * is every cycle.\n\t\t *\n\t\t * Thereby we gain a PEBS capable cycle counter.\n\t\t */\n\t\tu64 alt_config = X86_CONFIG(.event=0xc0, .inv=1, .cmask=16);\n\n\t\talt_config |= (event->hw.config & ~X86_RAW_EVENT_MASK);\n\t\tevent->hw.config = alt_config;\n\t}\n}\n\nstatic void intel_pebs_aliases_snb(struct perf_event *event)\n{\n\tif ((event->hw.config & X86_RAW_EVENT_MASK) == 0x003c) {\n\t\t/*\n\t\t * Use an alternative encoding for CPU_CLK_UNHALTED.THREAD_P\n\t\t * (0x003c) so that we can use it with PEBS.\n\t\t *\n\t\t * The regular CPU_CLK_UNHALTED.THREAD_P event (0x003c) isn't\n\t\t * PEBS capable. However we can use UOPS_RETIRED.ALL\n\t\t * (0x01c2), which is a PEBS capable event, to get the same\n\t\t * count.\n\t\t *\n\t\t * UOPS_RETIRED.ALL counts the number of cycles that retires\n\t\t * CNTMASK micro-ops. By setting CNTMASK to a value (16)\n\t\t * larger than the maximum number of micro-ops that can be\n\t\t * retired per cycle (4) and then inverting the condition, we\n\t\t * count all cycles that retire 16 or less micro-ops, which\n\t\t * is every cycle.\n\t\t *\n\t\t * Thereby we gain a PEBS capable cycle counter.\n\t\t */\n\t\tu64 alt_config = X86_CONFIG(.event=0xc2, .umask=0x01, .inv=1, .cmask=16);\n\n\t\talt_config |= (event->hw.config & ~X86_RAW_EVENT_MASK);\n\t\tevent->hw.config = alt_config;\n\t}\n}\n\nstatic int intel_pmu_hw_config(struct perf_event *event)\n{\n\tint ret = x86_pmu_hw_config(event);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (event->attr.precise_ip && x86_pmu.pebs_aliases)\n\t\tx86_pmu.pebs_aliases(event);\n\n\tif (intel_pmu_needs_lbr_smpl(event)) {\n\t\tret = intel_pmu_setup_lbr_filter(event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (event->attr.type != PERF_TYPE_RAW)\n\t\treturn 0;\n\n\tif (!(event->attr.config & ARCH_PERFMON_EVENTSEL_ANY))\n\t\treturn 0;\n\n\tif (x86_pmu.version < 3)\n\t\treturn -EINVAL;\n\n\tif (perf_paranoid_cpu() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tevent->hw.config |= ARCH_PERFMON_EVENTSEL_ANY;\n\n\treturn 0;\n}\n\nstruct perf_guest_switch_msr *perf_guest_get_msrs(int *nr)\n{\n\tif (x86_pmu.guest_get_msrs)\n\t\treturn x86_pmu.guest_get_msrs(nr);\n\t*nr = 0;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(perf_guest_get_msrs);\n\nstatic struct perf_guest_switch_msr *intel_guest_get_msrs(int *nr)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_guest_switch_msr *arr = cpuc->guest_switch_msrs;\n\n\tarr[0].msr = MSR_CORE_PERF_GLOBAL_CTRL;\n\tarr[0].host = x86_pmu.intel_ctrl & ~cpuc->intel_ctrl_guest_mask;\n\tarr[0].guest = x86_pmu.intel_ctrl & ~cpuc->intel_ctrl_host_mask;\n\t/*\n\t * If PMU counter has PEBS enabled it is not enough to disable counter\n\t * on a guest entry since PEBS memory write can overshoot guest entry\n\t * and corrupt guest memory. Disabling PEBS solves the problem.\n\t */\n\tarr[1].msr = MSR_IA32_PEBS_ENABLE;\n\tarr[1].host = cpuc->pebs_enabled;\n\tarr[1].guest = 0;\n\n\t*nr = 2;\n\treturn arr;\n}\n\nstatic struct perf_guest_switch_msr *core_guest_get_msrs(int *nr)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_guest_switch_msr *arr = cpuc->guest_switch_msrs;\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++)  {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\n\t\tarr[idx].msr = x86_pmu_config_addr(idx);\n\t\tarr[idx].host = arr[idx].guest = 0;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tarr[idx].host = arr[idx].guest =\n\t\t\tevent->hw.config | ARCH_PERFMON_EVENTSEL_ENABLE;\n\n\t\tif (event->attr.exclude_host)\n\t\t\tarr[idx].host &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\t\telse if (event->attr.exclude_guest)\n\t\t\tarr[idx].guest &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\t}\n\n\t*nr = x86_pmu.num_counters;\n\treturn arr;\n}\n\nstatic void core_pmu_enable_event(struct perf_event *event)\n{\n\tif (!event->attr.exclude_host)\n\t\tx86_pmu_enable_event(event);\n}\n\nstatic void core_pmu_enable_all(int added)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx;\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tstruct hw_perf_event *hwc = &cpuc->events[idx]->hw;\n\n\t\tif (!test_bit(idx, cpuc->active_mask) ||\n\t\t\t\tcpuc->events[idx]->attr.exclude_host)\n\t\t\tcontinue;\n\n\t\t__x86_pmu_enable_event(hwc, ARCH_PERFMON_EVENTSEL_ENABLE);\n\t}\n}\n\nPMU_FORMAT_ATTR(event,\t\"config:0-7\"\t);\nPMU_FORMAT_ATTR(umask,\t\"config:8-15\"\t);\nPMU_FORMAT_ATTR(edge,\t\"config:18\"\t);\nPMU_FORMAT_ATTR(pc,\t\"config:19\"\t);\nPMU_FORMAT_ATTR(any,\t\"config:21\"\t); /* v3 + */\nPMU_FORMAT_ATTR(inv,\t\"config:23\"\t);\nPMU_FORMAT_ATTR(cmask,\t\"config:24-31\"\t);\n\nstatic struct attribute *intel_arch_formats_attr[] = {\n\t&format_attr_event.attr,\n\t&format_attr_umask.attr,\n\t&format_attr_edge.attr,\n\t&format_attr_pc.attr,\n\t&format_attr_inv.attr,\n\t&format_attr_cmask.attr,\n\tNULL,\n};\n\nssize_t intel_event_sysfs_show(char *page, u64 config)\n{\n\tu64 event = (config & ARCH_PERFMON_EVENTSEL_EVENT);\n\n\treturn x86_event_sysfs_show(page, config, event);\n}\n\nstatic __initconst const struct x86_pmu core_pmu = {\n\t.name\t\t\t= \"core\",\n\t.handle_irq\t\t= x86_pmu_handle_irq,\n\t.disable_all\t\t= x86_pmu_disable_all,\n\t.enable_all\t\t= core_pmu_enable_all,\n\t.enable\t\t\t= core_pmu_enable_event,\n\t.disable\t\t= x86_pmu_disable_event,\n\t.hw_config\t\t= x86_pmu_hw_config,\n\t.schedule_events\t= x86_schedule_events,\n\t.eventsel\t\t= MSR_ARCH_PERFMON_EVENTSEL0,\n\t.perfctr\t\t= MSR_ARCH_PERFMON_PERFCTR0,\n\t.event_map\t\t= intel_pmu_event_map,\n\t.max_events\t\t= ARRAY_SIZE(intel_perfmon_event_map),\n\t.apic\t\t\t= 1,\n\t/*\n\t * Intel PMCs cannot be accessed sanely above 32 bit width,\n\t * so we install an artificial 1<<31 period regardless of\n\t * the generic event period:\n\t */\n\t.max_period\t\t= (1ULL << 31) - 1,\n\t.get_event_constraints\t= intel_get_event_constraints,\n\t.put_event_constraints\t= intel_put_event_constraints,\n\t.event_constraints\t= intel_core_event_constraints,\n\t.guest_get_msrs\t\t= core_guest_get_msrs,\n\t.format_attrs\t\t= intel_arch_formats_attr,\n\t.events_sysfs_show\t= intel_event_sysfs_show,\n};\n\nstruct intel_shared_regs *allocate_shared_regs(int cpu)\n{\n\tstruct intel_shared_regs *regs;\n\tint i;\n\n\tregs = kzalloc_node(sizeof(struct intel_shared_regs),\n\t\t\t    GFP_KERNEL, cpu_to_node(cpu));\n\tif (regs) {\n\t\t/*\n\t\t * initialize the locks to keep lockdep happy\n\t\t */\n\t\tfor (i = 0; i < EXTRA_REG_MAX; i++)\n\t\t\traw_spin_lock_init(&regs->regs[i].lock);\n\n\t\tregs->core_id = -1;\n\t}\n\treturn regs;\n}\n\nstatic int intel_pmu_cpu_prepare(int cpu)\n{\n\tstruct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);\n\n\tif (!(x86_pmu.extra_regs || x86_pmu.lbr_sel_map))\n\t\treturn NOTIFY_OK;\n\n\tcpuc->shared_regs = allocate_shared_regs(cpu);\n\tif (!cpuc->shared_regs)\n\t\treturn NOTIFY_BAD;\n\n\treturn NOTIFY_OK;\n}\n\nstatic void intel_pmu_cpu_starting(int cpu)\n{\n\tstruct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);\n\tint core_id = topology_core_id(cpu);\n\tint i;\n\n\tinit_debug_store_on_cpu(cpu);\n\t/*\n\t * Deal with CPUs that don't clear their LBRs on power-up.\n\t */\n\tintel_pmu_lbr_reset();\n\n\tcpuc->lbr_sel = NULL;\n\n\tif (!cpuc->shared_regs)\n\t\treturn;\n\n\tif (!(x86_pmu.er_flags & ERF_NO_HT_SHARING)) {\n\t\tfor_each_cpu(i, topology_thread_cpumask(cpu)) {\n\t\t\tstruct intel_shared_regs *pc;\n\n\t\t\tpc = per_cpu(cpu_hw_events, i).shared_regs;\n\t\t\tif (pc && pc->core_id == core_id) {\n\t\t\t\tcpuc->kfree_on_online = cpuc->shared_regs;\n\t\t\t\tcpuc->shared_regs = pc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcpuc->shared_regs->core_id = core_id;\n\t\tcpuc->shared_regs->refcnt++;\n\t}\n\n\tif (x86_pmu.lbr_sel_map)\n\t\tcpuc->lbr_sel = &cpuc->shared_regs->regs[EXTRA_REG_LBR];\n}\n\nstatic void intel_pmu_cpu_dying(int cpu)\n{\n\tstruct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);\n\tstruct intel_shared_regs *pc;\n\n\tpc = cpuc->shared_regs;\n\tif (pc) {\n\t\tif (pc->core_id == -1 || --pc->refcnt == 0)\n\t\t\tkfree(pc);\n\t\tcpuc->shared_regs = NULL;\n\t}\n\n\tfini_debug_store_on_cpu(cpu);\n}\n\nstatic void intel_pmu_flush_branch_stack(void)\n{\n\t/*\n\t * Intel LBR does not tag entries with the\n\t * PID of the current task, then we need to\n\t * flush it on ctxsw\n\t * For now, we simply reset it\n\t */\n\tif (x86_pmu.lbr_nr)\n\t\tintel_pmu_lbr_reset();\n}\n\nPMU_FORMAT_ATTR(offcore_rsp, \"config1:0-63\");\n\nstatic struct attribute *intel_arch3_formats_attr[] = {\n\t&format_attr_event.attr,\n\t&format_attr_umask.attr,\n\t&format_attr_edge.attr,\n\t&format_attr_pc.attr,\n\t&format_attr_any.attr,\n\t&format_attr_inv.attr,\n\t&format_attr_cmask.attr,\n\n\t&format_attr_offcore_rsp.attr, /* XXX do NHM/WSM + SNB breakout */\n\tNULL,\n};\n\nstatic __initconst const struct x86_pmu intel_pmu = {\n\t.name\t\t\t= \"Intel\",\n\t.handle_irq\t\t= intel_pmu_handle_irq,\n\t.disable_all\t\t= intel_pmu_disable_all,\n\t.enable_all\t\t= intel_pmu_enable_all,\n\t.enable\t\t\t= intel_pmu_enable_event,\n\t.disable\t\t= intel_pmu_disable_event,\n\t.hw_config\t\t= intel_pmu_hw_config,\n\t.schedule_events\t= x86_schedule_events,\n\t.eventsel\t\t= MSR_ARCH_PERFMON_EVENTSEL0,\n\t.perfctr\t\t= MSR_ARCH_PERFMON_PERFCTR0,\n\t.event_map\t\t= intel_pmu_event_map,\n\t.max_events\t\t= ARRAY_SIZE(intel_perfmon_event_map),\n\t.apic\t\t\t= 1,\n\t/*\n\t * Intel PMCs cannot be accessed sanely above 32 bit width,\n\t * so we install an artificial 1<<31 period regardless of\n\t * the generic event period:\n\t */\n\t.max_period\t\t= (1ULL << 31) - 1,\n\t.get_event_constraints\t= intel_get_event_constraints,\n\t.put_event_constraints\t= intel_put_event_constraints,\n\t.pebs_aliases\t\t= intel_pebs_aliases_core2,\n\n\t.format_attrs\t\t= intel_arch3_formats_attr,\n\t.events_sysfs_show\t= intel_event_sysfs_show,\n\n\t.cpu_prepare\t\t= intel_pmu_cpu_prepare,\n\t.cpu_starting\t\t= intel_pmu_cpu_starting,\n\t.cpu_dying\t\t= intel_pmu_cpu_dying,\n\t.guest_get_msrs\t\t= intel_guest_get_msrs,\n\t.flush_branch_stack\t= intel_pmu_flush_branch_stack,\n};\n\nstatic __init void intel_clovertown_quirk(void)\n{\n\t/*\n\t * PEBS is unreliable due to:\n\t *\n\t *   AJ67  - PEBS may experience CPL leaks\n\t *   AJ68  - PEBS PMI may be delayed by one event\n\t *   AJ69  - GLOBAL_STATUS[62] will only be set when DEBUGCTL[12]\n\t *   AJ106 - FREEZE_LBRS_ON_PMI doesn't work in combination with PEBS\n\t *\n\t * AJ67 could be worked around by restricting the OS/USR flags.\n\t * AJ69 could be worked around by setting PMU_FREEZE_ON_PMI.\n\t *\n\t * AJ106 could possibly be worked around by not allowing LBR\n\t *       usage from PEBS, including the fixup.\n\t * AJ68  could possibly be worked around by always programming\n\t *\t a pebs_event_reset[0] value and coping with the lost events.\n\t *\n\t * But taken together it might just make sense to not enable PEBS on\n\t * these chips.\n\t */\n\tpr_warn(\"PEBS disabled due to CPU errata\\n\");\n\tx86_pmu.pebs = 0;\n\tx86_pmu.pebs_constraints = NULL;\n}\n\nstatic int intel_snb_pebs_broken(int cpu)\n{\n\tu32 rev = UINT_MAX; /* default to broken for unknown models */\n\n\tswitch (cpu_data(cpu).x86_model) {\n\tcase 42: /* SNB */\n\t\trev = 0x28;\n\t\tbreak;\n\n\tcase 45: /* SNB-EP */\n\t\tswitch (cpu_data(cpu).x86_mask) {\n\t\tcase 6: rev = 0x618; break;\n\t\tcase 7: rev = 0x70c; break;\n\t\t}\n\t}\n\n\treturn (cpu_data(cpu).microcode < rev);\n}\n\nstatic void intel_snb_check_microcode(void)\n{\n\tint pebs_broken = 0;\n\tint cpu;\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tif ((pebs_broken = intel_snb_pebs_broken(cpu)))\n\t\t\tbreak;\n\t}\n\tput_online_cpus();\n\n\tif (pebs_broken == x86_pmu.pebs_broken)\n\t\treturn;\n\n\t/*\n\t * Serialized by the microcode lock..\n\t */\n\tif (x86_pmu.pebs_broken) {\n\t\tpr_info(\"PEBS enabled due to microcode update\\n\");\n\t\tx86_pmu.pebs_broken = 0;\n\t} else {\n\t\tpr_info(\"PEBS disabled due to CPU errata, please upgrade microcode\\n\");\n\t\tx86_pmu.pebs_broken = 1;\n\t}\n}\n\nstatic __init void intel_sandybridge_quirk(void)\n{\n\tx86_pmu.check_microcode = intel_snb_check_microcode;\n\tintel_snb_check_microcode();\n}\n\nstatic const struct { int id; char *name; } intel_arch_events_map[] __initconst = {\n\t{ PERF_COUNT_HW_CPU_CYCLES, \"cpu cycles\" },\n\t{ PERF_COUNT_HW_INSTRUCTIONS, \"instructions\" },\n\t{ PERF_COUNT_HW_BUS_CYCLES, \"bus cycles\" },\n\t{ PERF_COUNT_HW_CACHE_REFERENCES, \"cache references\" },\n\t{ PERF_COUNT_HW_CACHE_MISSES, \"cache misses\" },\n\t{ PERF_COUNT_HW_BRANCH_INSTRUCTIONS, \"branch instructions\" },\n\t{ PERF_COUNT_HW_BRANCH_MISSES, \"branch misses\" },\n};\n\nstatic __init void intel_arch_events_quirk(void)\n{\n\tint bit;\n\n\t/* disable event that reported as not presend by cpuid */\n\tfor_each_set_bit(bit, x86_pmu.events_mask, ARRAY_SIZE(intel_arch_events_map)) {\n\t\tintel_perfmon_event_map[intel_arch_events_map[bit].id] = 0;\n\t\tpr_warn(\"CPUID marked event: \\'%s\\' unavailable\\n\",\n\t\t\tintel_arch_events_map[bit].name);\n\t}\n}\n\nstatic __init void intel_nehalem_quirk(void)\n{\n\tunion cpuid10_ebx ebx;\n\n\tebx.full = x86_pmu.events_maskl;\n\tif (ebx.split.no_branch_misses_retired) {\n\t\t/*\n\t\t * Erratum AAJ80 detected, we work it around by using\n\t\t * the BR_MISP_EXEC.ANY event. This will over-count\n\t\t * branch-misses, but it's still much better than the\n\t\t * architectural event which is often completely bogus:\n\t\t */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_BRANCH_MISSES] = 0x7f89;\n\t\tebx.split.no_branch_misses_retired = 0;\n\t\tx86_pmu.events_maskl = ebx.full;\n\t\tpr_info(\"CPU erratum AAJ80 worked around\\n\");\n\t}\n}\n\n__init int intel_pmu_init(void)\n{\n\tunion cpuid10_edx edx;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_ebx ebx;\n\tstruct event_constraint *c;\n\tunsigned int unused;\n\tint version;\n\n\tif (!cpu_has(&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {\n\t\tswitch (boot_cpu_data.x86) {\n\t\tcase 0x6:\n\t\t\treturn p6_pmu_init();\n\t\tcase 0xb:\n\t\t\treturn knc_pmu_init();\n\t\tcase 0xf:\n\t\t\treturn p4_pmu_init();\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t * Check whether the Architectural PerfMon supports\n\t * Branch Misses Retired hw_event or not.\n\t */\n\tcpuid(10, &eax.full, &ebx.full, &unused, &edx.full);\n\tif (eax.split.mask_length < ARCH_PERFMON_EVENTS_COUNT)\n\t\treturn -ENODEV;\n\n\tversion = eax.split.version_id;\n\tif (version < 2)\n\t\tx86_pmu = core_pmu;\n\telse\n\t\tx86_pmu = intel_pmu;\n\n\tx86_pmu.version\t\t\t= version;\n\tx86_pmu.num_counters\t\t= eax.split.num_counters;\n\tx86_pmu.cntval_bits\t\t= eax.split.bit_width;\n\tx86_pmu.cntval_mask\t\t= (1ULL << eax.split.bit_width) - 1;\n\n\tx86_pmu.events_maskl\t\t= ebx.full;\n\tx86_pmu.events_mask_len\t\t= eax.split.mask_length;\n\n\tx86_pmu.max_pebs_events\t\t= min_t(unsigned, MAX_PEBS_EVENTS, x86_pmu.num_counters);\n\n\t/*\n\t * Quirk: v2 perfmon does not report fixed-purpose events, so\n\t * assume at least 3 events:\n\t */\n\tif (version > 1)\n\t\tx86_pmu.num_counters_fixed = max((int)edx.split.num_counters_fixed, 3);\n\n\t/*\n\t * v2 and above have a perf capabilities MSR\n\t */\n\tif (version > 1) {\n\t\tu64 capabilities;\n\n\t\trdmsrl(MSR_IA32_PERF_CAPABILITIES, capabilities);\n\t\tx86_pmu.intel_cap.capabilities = capabilities;\n\t}\n\n\tintel_ds_init();\n\n\tx86_add_quirk(intel_arch_events_quirk); /* Install first, so it runs last */\n\n\t/*\n\t * Install the hw-cache-events table:\n\t */\n\tswitch (boot_cpu_data.x86_model) {\n\tcase 14: /* 65 nm core solo/duo, \"Yonah\" */\n\t\tpr_cont(\"Core events, \");\n\t\tbreak;\n\n\tcase 15: /* original 65 nm celeron/pentium/core2/xeon, \"Merom\"/\"Conroe\" */\n\t\tx86_add_quirk(intel_clovertown_quirk);\n\tcase 22: /* single-core 65 nm celeron/core2solo \"Merom-L\"/\"Conroe-L\" */\n\tcase 23: /* current 45 nm celeron/core2/xeon \"Penryn\"/\"Wolfdale\" */\n\tcase 29: /* six-core 45 nm xeon \"Dunnington\" */\n\t\tmemcpy(hw_cache_event_ids, core2_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_core();\n\n\t\tx86_pmu.event_constraints = intel_core2_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_core2_pebs_event_constraints;\n\t\tpr_cont(\"Core2 events, \");\n\t\tbreak;\n\n\tcase 26: /* 45 nm nehalem, \"Bloomfield\" */\n\tcase 30: /* 45 nm nehalem, \"Lynnfield\" */\n\tcase 46: /* 45 nm nehalem-ex, \"Beckton\" */\n\t\tmemcpy(hw_cache_event_ids, nehalem_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_nehalem_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_nehalem_pebs_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.extra_regs = intel_nehalem_extra_regs;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tx86_add_quirk(intel_nehalem_quirk);\n\n\t\tpr_cont(\"Nehalem events, \");\n\t\tbreak;\n\n\tcase 28: /* Atom */\n\tcase 38: /* Lincroft */\n\tcase 39: /* Penwell */\n\tcase 53: /* Cloverview */\n\tcase 54: /* Cedarview */\n\t\tmemcpy(hw_cache_event_ids, atom_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\n\t\tintel_pmu_lbr_init_atom();\n\n\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_atom_pebs_event_constraints;\n\t\tpr_cont(\"Atom events, \");\n\t\tbreak;\n\n\tcase 37: /* 32 nm nehalem, \"Clarkdale\" */\n\tcase 44: /* 32 nm nehalem, \"Gulftown\" */\n\tcase 47: /* 32 nm Xeon E7 */\n\t\tmemcpy(hw_cache_event_ids, westmere_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, nehalem_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_nhm();\n\n\t\tx86_pmu.event_constraints = intel_westmere_event_constraints;\n\t\tx86_pmu.enable_all = intel_pmu_nhm_enable_all;\n\t\tx86_pmu.pebs_constraints = intel_westmere_pebs_event_constraints;\n\t\tx86_pmu.extra_regs = intel_westmere_extra_regs;\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\n\t\t/* UOPS_ISSUED.STALLED_CYCLES */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_EXECUTED.CORE_ACTIVE_CYCLES,c=1,i=1 */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"Westmere events, \");\n\t\tbreak;\n\n\tcase 42: /* SandyBridge */\n\tcase 45: /* SandyBridge, \"Romely-EP\" */\n\t\tx86_add_quirk(intel_sandybridge_quirk);\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n\t\tx86_pmu.event_constraints = intel_snb_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_snb_pebs_event_constraints;\n\t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tif (boot_cpu_data.x86_model == 45)\n\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n\t\telse\n\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n\t\t/* all extra regs are per-cpu when HT is on */\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\t\t/* UOPS_DISPATCHED.THREAD,c=1,i=1 to count stall cycles*/\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =\n\t\t\tX86_CONFIG(.event=0xb1, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"SandyBridge events, \");\n\t\tbreak;\n\tcase 58: /* IvyBridge */\n\tcase 62: /* IvyBridge EP */\n\t\tmemcpy(hw_cache_event_ids, snb_hw_cache_event_ids,\n\t\t       sizeof(hw_cache_event_ids));\n\t\tmemcpy(hw_cache_extra_regs, snb_hw_cache_extra_regs,\n\t\t       sizeof(hw_cache_extra_regs));\n\n\t\tintel_pmu_lbr_init_snb();\n\n\t\tx86_pmu.event_constraints = intel_ivb_event_constraints;\n\t\tx86_pmu.pebs_constraints = intel_ivb_pebs_event_constraints;\n\t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n\t\tif (boot_cpu_data.x86_model == 62)\n\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n\t\telse\n\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n\t\t/* all extra regs are per-cpu when HT is on */\n\t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n\t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n\n\t\t/* UOPS_ISSUED.ANY,c=1,i=1 to count stall cycles */\n\t\tintel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =\n\t\t\tX86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);\n\n\t\tpr_cont(\"IvyBridge events, \");\n\t\tbreak;\n\n\n\tdefault:\n\t\tswitch (x86_pmu.version) {\n\t\tcase 1:\n\t\t\tx86_pmu.event_constraints = intel_v1_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon v1, \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * default constraints for v2 and up\n\t\t\t */\n\t\t\tx86_pmu.event_constraints = intel_gen_event_constraints;\n\t\t\tpr_cont(\"generic architected perfmon, \");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (x86_pmu.num_counters > INTEL_PMC_MAX_GENERIC) {\n\t\tWARN(1, KERN_ERR \"hw perf events %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters, INTEL_PMC_MAX_GENERIC);\n\t\tx86_pmu.num_counters = INTEL_PMC_MAX_GENERIC;\n\t}\n\tx86_pmu.intel_ctrl = (1 << x86_pmu.num_counters) - 1;\n\n\tif (x86_pmu.num_counters_fixed > INTEL_PMC_MAX_FIXED) {\n\t\tWARN(1, KERN_ERR \"hw perf events fixed %d > max(%d), clipping!\",\n\t\t     x86_pmu.num_counters_fixed, INTEL_PMC_MAX_FIXED);\n\t\tx86_pmu.num_counters_fixed = INTEL_PMC_MAX_FIXED;\n\t}\n\n\tx86_pmu.intel_ctrl |=\n\t\t((1LL << x86_pmu.num_counters_fixed)-1) << INTEL_PMC_IDX_FIXED;\n\n\tif (x86_pmu.event_constraints) {\n\t\t/*\n\t\t * event on fixed counter2 (REF_CYCLES) only works on this\n\t\t * counter, so do not extend mask to generic counters\n\t\t */\n\t\tfor_each_event_constraint(c, x86_pmu.event_constraints) {\n\t\t\tif (c->cmask != X86_RAW_EVENT_MASK\n\t\t\t    || c->idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;\n\t\t\tc->weight += x86_pmu.num_counters;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"], "filenames": ["arch/x86/kernel/cpu/perf_event_intel.c"], "buggy_code_start_loc": [156], "buggy_code_end_loc": [2127], "fixing_code_start_loc": [156], "fixing_code_end_loc": [2139], "type": "CWE-20", "message": "arch/x86/kernel/cpu/perf_event_intel.c in the Linux kernel before 3.8.9, when the Performance Events Subsystem is enabled, specifies an incorrect bitmask, which allows local users to cause a denial of service (general protection fault and system crash) by attempting to set a reserved bit.", "other": {"cve": {"id": "CVE-2013-2146", "sourceIdentifier": "secalert@redhat.com", "published": "2013-06-07T14:03:19.830", "lastModified": "2023-02-13T00:28:25.640", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "arch/x86/kernel/cpu/perf_event_intel.c in the Linux kernel before 3.8.9, when the Performance Events Subsystem is enabled, specifies an incorrect bitmask, which allows local users to cause a denial of service (general protection fault and system crash) by attempting to set a reserved bit."}, {"lang": "es", "value": "arch/x86/kernel/cpu/perf_event_intel.c en Linux kernel hasta v3.8.9 cuando Performance Events Subsystem esta habilitado, especifica una m\u00e1scara de bits correctos, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (error de protecci\u00f3n general y el bloqueo del sistema) al tratar de establecer un bit reservado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.8", "matchCriteriaId": "D11FDC31-8717-4FE1-A2F0-731D2F387B2E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=f1923820c447e986a9da0fc6bf60c1dccdf0408e", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1173.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.9", "source": "secalert@redhat.com"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:176", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/06/05/23", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=971309", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e"}}