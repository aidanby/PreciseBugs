{"buggy_code": ["/*\n * MOV demuxer\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * first version by Francois Revol <revol@free.fr>\n * seek function by Gael Chardon <gael.dev@4now.net>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"config_components.h\"\n\n#include <inttypes.h>\n#include <limits.h>\n#include <stdint.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/aes.h\"\n#include \"libavutil/aes_ctr.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/sha.h\"\n#include \"libavutil/spherical.h\"\n#include \"libavutil/stereo3d.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavutil/uuid.h\"\n#include \"libavcodec/ac3tab.h\"\n#include \"libavcodec/flac.h\"\n#include \"libavcodec/hevc.h\"\n#include \"libavcodec/mpegaudiodecheader.h\"\n#include \"libavcodec/mlp_parse.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"demux.h\"\n#include \"dovi_isom.h\"\n#include \"riff.h\"\n#include \"isom.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"id3v1.h\"\n#include \"mov_chan.h\"\n#include \"replaygain.h\"\n\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n\n#include \"qtpalette.h\"\n\n/* those functions parse an atom */\n/* links atom IDs to parse functions */\ntypedef struct MOVParseTableEntry {\n    uint32_t type;\n    int (*parse)(MOVContext *ctx, AVIOContext *pb, MOVAtom atom);\n} MOVParseTableEntry;\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom);\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f);\nstatic int64_t add_ctts_entry(MOVCtts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration);\n\nstatic int mov_metadata_track_or_disc_number(MOVContext *c, AVIOContext *pb,\n                                             unsigned len, const char *key)\n{\n    char buf[16];\n\n    short current, total = 0;\n    avio_rb16(pb); // unknown\n    current = avio_rb16(pb);\n    if (len >= 6)\n        total = avio_rb16(pb);\n    if (!total)\n        snprintf(buf, sizeof(buf), \"%d\", current);\n    else\n        snprintf(buf, sizeof(buf), \"%d/%d\", current, total);\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_bypass_padding(MOVContext *c, AVIOContext *pb,\n                                            unsigned len, const char *key)\n{\n    /* bypass padding bytes */\n    avio_r8(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_no_padding(MOVContext *c, AVIOContext *pb,\n                                        unsigned len, const char *key)\n{\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_gnre(MOVContext *c, AVIOContext *pb,\n                             unsigned len, const char *key)\n{\n    short genre;\n\n    avio_r8(pb); // unknown\n\n    genre = avio_r8(pb);\n    if (genre < 1 || genre > ID3v1_GENRE_MAX)\n        return 0;\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, ff_id3v1_genre_str[genre-1], 0);\n\n    return 0;\n}\n\nstatic const uint32_t mac_to_unicode[128] = {\n    0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,\n    0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,\n    0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,\n    0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,\n    0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,\n    0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,\n    0x221E,0x00B1,0x2264,0x2265,0x00A5,0x00B5,0x2202,0x2211,\n    0x220F,0x03C0,0x222B,0x00AA,0x00BA,0x03A9,0x00E6,0x00F8,\n    0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,\n    0x00BB,0x2026,0x00A0,0x00C0,0x00C3,0x00D5,0x0152,0x0153,\n    0x2013,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,\n    0x00FF,0x0178,0x2044,0x20AC,0x2039,0x203A,0xFB01,0xFB02,\n    0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,\n    0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,\n    0xF8FF,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x02C6,0x02DC,\n    0x00AF,0x02D8,0x02D9,0x02DA,0x00B8,0x02DD,0x02DB,0x02C7,\n};\n\nstatic int mov_read_mac_string(MOVContext *c, AVIOContext *pb, int len,\n                               char *dst, int dstlen)\n{\n    char *p = dst;\n    char *end = dst+dstlen-1;\n    int i;\n\n    for (i = 0; i < len; i++) {\n        uint8_t t, c = avio_r8(pb);\n\n        if (p >= end)\n            continue;\n\n        if (c < 0x80)\n            *p++ = c;\n        else if (p < end)\n            PUT_UTF8(mac_to_unicode[c-0x80], t, if (p < end) *p++ = t;);\n    }\n    *p = 0;\n    return p - dst;\n}\n\nstatic int mov_read_covr(MOVContext *c, AVIOContext *pb, int type, int len)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    int ret;\n\n    switch (type) {\n    case 0xd:  id = AV_CODEC_ID_MJPEG; break;\n    case 0xe:  id = AV_CODEC_ID_PNG;   break;\n    case 0x1b: id = AV_CODEC_ID_BMP;   break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown cover type: 0x%x.\\n\", type);\n        avio_skip(pb, len);\n        return 0;\n    }\n\n    sc = av_mallocz(sizeof(*sc));\n    if (!sc)\n        return AVERROR(ENOMEM);\n    ret = ff_add_attached_pic(c->fc, NULL, pb, NULL, len);\n    if (ret < 0) {\n        av_free(sc);\n        return ret;\n    }\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    st->priv_data = sc;\n\n    if (st->attached_pic.size >= 8 && id != AV_CODEC_ID_BMP) {\n        if (AV_RB64(st->attached_pic.data) == 0x89504e470d0a1a0a) {\n            id = AV_CODEC_ID_PNG;\n        } else {\n            id = AV_CODEC_ID_MJPEG;\n        }\n    }\n    st->codecpar->codec_id   = id;\n\n    return 0;\n}\n\n// 3GPP TS 26.244\nstatic int mov_metadata_loci(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    char language[4] = { 0 };\n    char buf[200], place[100];\n    uint16_t langcode = 0;\n    double longitude, latitude, altitude;\n    const char *key = \"location\";\n\n    if (len < 4 + 2 + 1 + 1 + 4 + 4 + 4) {\n        av_log(c->fc, AV_LOG_ERROR, \"loci too short\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // version+flags\n    langcode = avio_rb16(pb);\n    ff_mov_lang_to_iso639(langcode, language);\n    len -= 6;\n\n    len -= avio_get_str(pb, len, place, sizeof(place));\n    if (len < 1) {\n        av_log(c->fc, AV_LOG_ERROR, \"place name too long\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(pb, 1); // role\n    len -= 1;\n\n    if (len < 12) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"loci too short (%u bytes left, need at least %d)\\n\", len, 12);\n        return AVERROR_INVALIDDATA;\n    }\n    longitude = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    latitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    altitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n\n    // Try to output in the same format as the ?xyz field\n    snprintf(buf, sizeof(buf), \"%+08.4f%+09.4f\",  latitude, longitude);\n    if (altitude)\n        av_strlcatf(buf, sizeof(buf), \"%+f\", altitude);\n    av_strlcatf(buf, sizeof(buf), \"/%s\", place);\n\n    if (*language && strcmp(language, \"und\")) {\n        char key2[16];\n        snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n        av_dict_set(&c->fc->metadata, key2, buf, 0);\n    }\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    return av_dict_set(&c->fc->metadata, key, buf, 0);\n}\n\nstatic int mov_metadata_hmmt(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    int i, n_hmmt;\n\n    if (len < 2)\n        return 0;\n    if (c->ignore_chapters)\n        return 0;\n\n    n_hmmt = avio_rb32(pb);\n    if (n_hmmt > len / 4)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < n_hmmt && !pb->eof_reached; i++) {\n        int moment_time = avio_rb32(pb);\n        avpriv_new_chapter(c->fc, i, av_make_q(1, 1000), moment_time, AV_NOPTS_VALUE, NULL);\n    }\n    if (avio_feof(pb))\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nstatic int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    char tmp_key[AV_FOURCC_MAX_STRING_SIZE] = {0};\n    char key2[32], language[4] = {0};\n    char *str = NULL;\n    const char *key = NULL;\n    uint16_t langcode = 0;\n    uint32_t data_type = 0, str_size, str_size_alloc;\n    int (*parse)(MOVContext*, AVIOContext*, unsigned, const char*) = NULL;\n    int raw = 0;\n    int num = 0;\n\n    switch (atom.type) {\n    case MKTAG( '@','P','R','M'): key = \"premiere_version\"; raw = 1; break;\n    case MKTAG( '@','P','R','Q'): key = \"quicktime_version\"; raw = 1; break;\n    case MKTAG( 'X','M','P','_'):\n        if (c->export_xmp) { key = \"xmp\"; raw = 1; } break;\n    case MKTAG( 'a','A','R','T'): key = \"album_artist\";    break;\n    case MKTAG( 'a','k','I','D'): key = \"account_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'a','p','I','D'): key = \"account_id\"; break;\n    case MKTAG( 'c','a','t','g'): key = \"category\"; break;\n    case MKTAG( 'c','p','i','l'): key = \"compilation\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'c','p','r','t'): key = \"copyright\"; break;\n    case MKTAG( 'd','e','s','c'): key = \"description\"; break;\n    case MKTAG( 'd','i','s','k'): key = \"disc\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 'e','g','i','d'): key = \"episode_uid\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'F','I','R','M'): key = \"firmware\"; raw = 1; break;\n    case MKTAG( 'g','n','r','e'): key = \"genre\";\n        parse = mov_metadata_gnre; break;\n    case MKTAG( 'h','d','v','d'): key = \"hd_video\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'H','M','M','T'):\n        return mov_metadata_hmmt(c, pb, atom.size);\n    case MKTAG( 'k','e','y','w'): key = \"keywords\";  break;\n    case MKTAG( 'l','d','e','s'): key = \"synopsis\";  break;\n    case MKTAG( 'l','o','c','i'):\n        return mov_metadata_loci(c, pb, atom.size);\n    case MKTAG( 'm','a','n','u'): key = \"make\"; break;\n    case MKTAG( 'm','o','d','l'): key = \"model\"; break;\n    case MKTAG( 'p','c','s','t'): key = \"podcast\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','g','a','p'): key = \"gapless_playback\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','u','r','d'): key = \"purchase_date\"; break;\n    case MKTAG( 'r','t','n','g'): key = \"rating\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 's','o','a','a'): key = \"sort_album_artist\"; break;\n    case MKTAG( 's','o','a','l'): key = \"sort_album\";   break;\n    case MKTAG( 's','o','a','r'): key = \"sort_artist\";  break;\n    case MKTAG( 's','o','c','o'): key = \"sort_composer\"; break;\n    case MKTAG( 's','o','n','m'): key = \"sort_name\";    break;\n    case MKTAG( 's','o','s','n'): key = \"sort_show\";    break;\n    case MKTAG( 's','t','i','k'): key = \"media_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 't','r','k','n'): key = \"track\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 't','v','e','n'): key = \"episode_id\"; break;\n    case MKTAG( 't','v','e','s'): key = \"episode_sort\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 't','v','n','n'): key = \"network\";   break;\n    case MKTAG( 't','v','s','h'): key = \"show\";      break;\n    case MKTAG( 't','v','s','n'): key = \"season_number\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG(0xa9,'A','R','T'): key = \"artist\";    break;\n    case MKTAG(0xa9,'P','R','D'): key = \"producer\";  break;\n    case MKTAG(0xa9,'a','l','b'): key = \"album\";     break;\n    case MKTAG(0xa9,'a','u','t'): key = \"artist\";    break;\n    case MKTAG(0xa9,'c','h','p'): key = \"chapter\";   break;\n    case MKTAG(0xa9,'c','m','t'): key = \"comment\";   break;\n    case MKTAG(0xa9,'c','o','m'): key = \"composer\";  break;\n    case MKTAG(0xa9,'c','p','y'): key = \"copyright\"; break;\n    case MKTAG(0xa9,'d','a','y'): key = \"date\";      break;\n    case MKTAG(0xa9,'d','i','r'): key = \"director\";  break;\n    case MKTAG(0xa9,'d','i','s'): key = \"disclaimer\"; break;\n    case MKTAG(0xa9,'e','d','1'): key = \"edit_date\"; break;\n    case MKTAG(0xa9,'e','n','c'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'f','m','t'): key = \"original_format\"; break;\n    case MKTAG(0xa9,'g','e','n'): key = \"genre\";     break;\n    case MKTAG(0xa9,'g','r','p'): key = \"grouping\";  break;\n    case MKTAG(0xa9,'h','s','t'): key = \"host_computer\"; break;\n    case MKTAG(0xa9,'i','n','f'): key = \"comment\";   break;\n    case MKTAG(0xa9,'l','y','r'): key = \"lyrics\";    break;\n    case MKTAG(0xa9,'m','a','k'): key = \"make\";      break;\n    case MKTAG(0xa9,'m','o','d'): key = \"model\";     break;\n    case MKTAG(0xa9,'n','a','m'): key = \"title\";     break;\n    case MKTAG(0xa9,'o','p','e'): key = \"original_artist\"; break;\n    case MKTAG(0xa9,'p','r','d'): key = \"producer\";  break;\n    case MKTAG(0xa9,'p','r','f'): key = \"performers\"; break;\n    case MKTAG(0xa9,'r','e','q'): key = \"playback_requirements\"; break;\n    case MKTAG(0xa9,'s','r','c'): key = \"original_source\"; break;\n    case MKTAG(0xa9,'s','t','3'): key = \"subtitle\";  break;\n    case MKTAG(0xa9,'s','w','r'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','o','o'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','r','k'): key = \"track\";     break;\n    case MKTAG(0xa9,'u','r','l'): key = \"URL\";       break;\n    case MKTAG(0xa9,'w','r','n'): key = \"warning\";   break;\n    case MKTAG(0xa9,'w','r','t'): key = \"composer\";  break;\n    case MKTAG(0xa9,'x','y','z'): key = \"location\";  break;\n    }\nretry:\n    if (c->itunes_metadata && atom.size > 8) {\n        int data_size = avio_rb32(pb);\n        int tag = avio_rl32(pb);\n        if (tag == MKTAG('d','a','t','a') && data_size <= atom.size && data_size >= 16) {\n            data_type = avio_rb32(pb); // type\n            avio_rb32(pb); // unknown\n            str_size = data_size - 16;\n            atom.size -= 16;\n\n            if (!key && c->found_hdlr_mdta && c->meta_keys) {\n                uint32_t index = av_bswap32(atom.type); // BE number has been read as LE\n                if (index < c->meta_keys_count && index > 0) {\n                    key = c->meta_keys[index];\n                } else if (atom.type != MKTAG('c', 'o', 'v', 'r')) {\n                    av_log(c->fc, AV_LOG_WARNING,\n                           \"The index of 'data' is out of range: %\"PRId32\" < 1 or >= %d.\\n\",\n                           index, c->meta_keys_count);\n                }\n            }\n            if (atom.type == MKTAG('c', 'o', 'v', 'r') ||\n                (key && !strcmp(key, \"com.apple.quicktime.artwork\"))) {\n                int ret = mov_read_covr(c, pb, data_type, str_size);\n                if (ret < 0) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Error parsing cover art.\\n\");\n                    return ret;\n                }\n                atom.size -= str_size;\n                if (atom.size > 8)\n                    goto retry;\n                return ret;\n            }\n        } else return 0;\n    } else if (atom.size > 4 && key && !c->itunes_metadata && !raw) {\n        str_size = avio_rb16(pb); // string length\n        if (str_size > atom.size) {\n            raw = 1;\n            avio_seek(pb, -2, SEEK_CUR);\n            av_log(c->fc, AV_LOG_WARNING, \"UDTA parsing failed retrying raw\\n\");\n            goto retry;\n        }\n        langcode = avio_rb16(pb);\n        ff_mov_lang_to_iso639(langcode, language);\n        atom.size -= 4;\n    } else\n        str_size = atom.size;\n\n    if (c->export_all && !key) {\n        key = av_fourcc_make_string(tmp_key, atom.type);\n    }\n\n    if (!key)\n        return 0;\n    if (atom.size < 0 || str_size >= INT_MAX/2)\n        return AVERROR_INVALIDDATA;\n\n    // Allocates enough space if data_type is a int32 or float32 number, otherwise\n    // worst-case requirement for output string in case of utf8 coded input\n    num = (data_type >= 21 && data_type <= 23);\n    str_size_alloc = (num ? 512 : (raw ? str_size : str_size * 2)) + 1;\n    str = av_mallocz(str_size_alloc);\n    if (!str)\n        return AVERROR(ENOMEM);\n\n    if (parse)\n        parse(c, pb, str_size, key);\n    else {\n        if (!raw && (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff)))) { // MAC Encoded\n            mov_read_mac_string(c, pb, str_size, str, str_size_alloc);\n        } else if (data_type == 21) { // BE signed integer, variable size\n            int val = 0;\n            if (str_size == 1)\n                val = (int8_t)avio_r8(pb);\n            else if (str_size == 2)\n                val = (int16_t)avio_rb16(pb);\n            else if (str_size == 3)\n                val = ((int32_t)(avio_rb24(pb)<<8))>>8;\n            else if (str_size == 4)\n                val = (int32_t)avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%d\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%d) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 22) { // BE unsigned integer, variable size\n            unsigned int val = 0;\n            if (str_size == 1)\n                val = avio_r8(pb);\n            else if (str_size == 2)\n                val = avio_rb16(pb);\n            else if (str_size == 3)\n                val = avio_rb24(pb);\n            else if (str_size == 4)\n                val = avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%u\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%u) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 23 && str_size >= 4) {  // BE float32\n            float val = av_int2float(avio_rb32(pb));\n            if (snprintf(str, str_size_alloc, \"%f\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the float32 number (%f) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type > 1 && data_type != 4) {\n            // data_type can be 0 if not set at all above. data_type 1 means\n            // UTF8 and 4 means \"UTF8 sort\". For any other type (UTF16 or e.g.\n            // a picture), don't return it blindly in a string that is supposed\n            // to be UTF8 text.\n            av_log(c->fc, AV_LOG_WARNING, \"Skipping unhandled metadata %s of type %d\\n\", key, data_type);\n            av_free(str);\n            return 0;\n        } else {\n            int ret = ffio_read_size(pb, str, str_size);\n            if (ret < 0) {\n                av_free(str);\n                return ret;\n            }\n            str[str_size] = 0;\n        }\n        c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n        av_dict_set(&c->fc->metadata, key, str, 0);\n        if (*language && strcmp(language, \"und\")) {\n            snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n            av_dict_set(&c->fc->metadata, key2, str, 0);\n        }\n        if (!strcmp(key, \"encoder\")) {\n            int major, minor, micro;\n            if (sscanf(str, \"HandBrake %d.%d.%d\", &major, &minor, &micro) == 3) {\n                c->handbrake_version = 1000000*major + 1000*minor + micro;\n            }\n        }\n    }\n\n    av_freep(&str);\n    return 0;\n}\n\nstatic int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n    int ret;\n\n    if (c->ignore_chapters)\n        return 0;\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        ret = ffio_read_size(pb, str, str_len);\n        if (ret < 0)\n            return ret;\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}\n\n#define MIN_DATA_ENTRY_BOX_SIZE 12\nstatic int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int entries, i, j;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n    entries = avio_rb32(pb);\n    if (!entries ||\n        entries >  (atom.size - 1) / MIN_DATA_ENTRY_BOX_SIZE + 1 ||\n        entries >= UINT_MAX / sizeof(*sc->drefs))\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < sc->drefs_count; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        av_freep(&dref->path);\n        av_freep(&dref->dir);\n    }\n    av_free(sc->drefs);\n    sc->drefs_count = 0;\n    sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));\n    if (!sc->drefs)\n        return AVERROR(ENOMEM);\n    sc->drefs_count = entries;\n\n    for (i = 0; i < entries; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        uint32_t size = avio_rb32(pb);\n        int64_t next = avio_tell(pb);\n\n        if (size < 12 || next < 0 || next > INT64_MAX - size)\n            return AVERROR_INVALIDDATA;\n\n        next += size - 4;\n\n        dref->type = avio_rl32(pb);\n        avio_rb32(pb); // version + flags\n\n        if (dref->type == MKTAG('a','l','i','s') && size > 150) {\n            /* macintosh alias record */\n            uint16_t volume_len, len;\n            int16_t type;\n            int ret;\n\n            avio_skip(pb, 10);\n\n            volume_len = avio_r8(pb);\n            volume_len = FFMIN(volume_len, 27);\n            ret = ffio_read_size(pb, dref->volume, 27);\n            if (ret < 0)\n                return ret;\n            dref->volume[volume_len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);\n\n            avio_skip(pb, 12);\n\n            len = avio_r8(pb);\n            len = FFMIN(len, 63);\n            ret = ffio_read_size(pb, dref->filename, 63);\n            if (ret < 0)\n                return ret;\n            dref->filename[len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);\n\n            avio_skip(pb, 16);\n\n            /* read next level up_from_alias/down_to_target */\n            dref->nlvl_from = avio_rb16(pb);\n            dref->nlvl_to   = avio_rb16(pb);\n            av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",\n                   dref->nlvl_from, dref->nlvl_to);\n\n            avio_skip(pb, 16);\n\n            for (type = 0; type != -1 && avio_tell(pb) < next; ) {\n                if (avio_feof(pb))\n                    return AVERROR_EOF;\n                type = avio_rb16(pb);\n                len = avio_rb16(pb);\n                av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);\n                if (len&1)\n                    len += 1;\n                if (type == 2) { // absolute path\n                    av_free(dref->path);\n                    dref->path = av_mallocz(len+1);\n                    if (!dref->path)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->path, len);\n                    if (ret < 0) {\n                        av_freep(&dref->path);\n                        return ret;\n                    }\n                    if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n                        len -= volume_len;\n                        memmove(dref->path, dref->path+volume_len, len);\n                        dref->path[len] = 0;\n                    }\n                    // trim string of any ending zeros\n                    for (j = len - 1; j >= 0; j--) {\n                        if (dref->path[j] == 0)\n                            len--;\n                        else\n                            break;\n                    }\n                    for (j = 0; j < len; j++)\n                        if (dref->path[j] == ':' || dref->path[j] == 0)\n                            dref->path[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);\n                } else if (type == 0) { // directory name\n                    av_free(dref->dir);\n                    dref->dir = av_malloc(len+1);\n                    if (!dref->dir)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->dir, len);\n                    if (ret < 0) {\n                        av_freep(&dref->dir);\n                        return ret;\n                    }\n                    dref->dir[len] = 0;\n                    for (j = 0; j < len; j++)\n                        if (dref->dir[j] == ':')\n                            dref->dir[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);\n                } else\n                    avio_skip(pb, len);\n            }\n        } else {\n            av_log(c->fc, AV_LOG_DEBUG, \"Unknown dref type 0x%08\"PRIx32\" size %\"PRIu32\"\\n\",\n                   dref->type, size);\n            entries--;\n            i--;\n        }\n        avio_seek(pb, next, SEEK_SET);\n    }\n    return 0;\n}\n\nstatic int mov_read_hdlr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint32_t type;\n    uint32_t ctype;\n    int64_t title_size;\n    char *title_str;\n    int ret;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    /* component type */\n    ctype = avio_rl32(pb);\n    type = avio_rl32(pb); /* component subtype */\n\n    av_log(c->fc, AV_LOG_TRACE, \"ctype=%s\\n\", av_fourcc2str(ctype));\n    av_log(c->fc, AV_LOG_TRACE, \"stype=%s\\n\", av_fourcc2str(type));\n\n    if (c->trak_index < 0) {  // meta not inside a trak\n        if (type == MKTAG('m','d','t','a')) {\n            c->found_hdlr_mdta = 1;\n        }\n        return 0;\n    }\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if     (type == MKTAG('v','i','d','e'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    else if (type == MKTAG('s','o','u','n'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    else if (type == MKTAG('m','1','a',' '))\n        st->codecpar->codec_id = AV_CODEC_ID_MP2;\n    else if ((type == MKTAG('s','u','b','p')) || (type == MKTAG('c','l','c','p')))\n        st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    avio_rb32(pb); /* component  manufacture */\n    avio_rb32(pb); /* component flags */\n    avio_rb32(pb); /* component flags mask */\n\n    title_size = atom.size - 24;\n    if (title_size > 0) {\n        if (title_size > FFMIN(INT_MAX, SIZE_MAX-1))\n            return AVERROR_INVALIDDATA;\n        title_str = av_malloc(title_size + 1); /* Add null terminator */\n        if (!title_str)\n            return AVERROR(ENOMEM);\n\n        ret = ffio_read_size(pb, title_str, title_size);\n        if (ret < 0) {\n            av_freep(&title_str);\n            return ret;\n        }\n        title_str[title_size] = 0;\n        if (title_str[0]) {\n            int off = (!c->isom && title_str[0] == title_size - 1);\n            // flag added so as to not set stream handler name if already set from mdia->hdlr\n            av_dict_set(&st->metadata, \"handler_name\", title_str + off, AV_DICT_DONT_OVERWRITE);\n        }\n        av_freep(&title_str);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_esds(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return ff_mov_read_esds(c->fc, pb);\n}\n\nstatic int mov_read_dac3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int ac3info, acmod, lfeon, bsmod;\n    uint64_t mask;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    ac3info = avio_rb24(pb);\n    bsmod = (ac3info >> 14) & 0x7;\n    acmod = (ac3info >> 11) & 0x7;\n    lfeon = (ac3info >> 10) & 0x1;\n\n    mask = ff_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        mask |= AV_CH_LOW_FREQUENCY;\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout, mask);\n\n    *ast = bsmod;\n    if (st->codecpar->ch_layout.nb_channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n    return 0;\n}\n\nstatic int mov_read_dec3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int eac3info, acmod, lfeon, bsmod;\n    uint64_t mask;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    /* No need to parse fields for additional independent substreams and its\n     * associated dependent substreams since libavcodec's E-AC-3 decoder\n     * does not support them yet. */\n    avio_rb16(pb); /* data_rate and num_ind_sub */\n    eac3info = avio_rb24(pb);\n    bsmod = (eac3info >> 12) & 0x1f;\n    acmod = (eac3info >>  9) & 0x7;\n    lfeon = (eac3info >>  8) & 0x1;\n\n    mask = ff_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        mask |= AV_CH_LOW_FREQUENCY;\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout, mask);\n\n    *ast = bsmod;\n    if (st->codecpar->ch_layout.nb_channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n    return 0;\n}\n\nstatic int mov_read_ddts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#define DDTS_SIZE 20\n    uint8_t buf[DDTS_SIZE + AV_INPUT_BUFFER_PADDING_SIZE];\n    AVStream *st = NULL;\n    uint32_t frame_duration_code = 0;\n    uint32_t channel_layout_code = 0;\n    GetBitContext gb;\n    int ret;\n\n    if ((ret = ffio_read_size(pb, buf, DDTS_SIZE)) < 0)\n        return ret;\n\n    init_get_bits(&gb, buf, 8 * DDTS_SIZE);\n\n    if (c->fc->nb_streams < 1) {\n        return 0;\n    }\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    st->codecpar->sample_rate = get_bits_long(&gb, 32);\n    if (st->codecpar->sample_rate <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n    skip_bits_long(&gb, 32); /* max bitrate */\n    st->codecpar->bit_rate = get_bits_long(&gb, 32);\n    st->codecpar->bits_per_coded_sample = get_bits(&gb, 8);\n    frame_duration_code = get_bits(&gb, 2);\n    skip_bits(&gb, 30); /* various fields */\n    channel_layout_code = get_bits(&gb, 16);\n\n    st->codecpar->frame_size =\n            (frame_duration_code == 0) ? 512 :\n            (frame_duration_code == 1) ? 1024 :\n            (frame_duration_code == 2) ? 2048 :\n            (frame_duration_code == 3) ? 4096 : 0;\n\n    if (channel_layout_code > 0xff) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported DTS audio channel layout\\n\");\n    }\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout,\n            ((channel_layout_code & 0x1) ? AV_CH_FRONT_CENTER : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_LEFT : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_RIGHT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_LEFT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_RIGHT : 0) |\n            ((channel_layout_code & 0x8) ? AV_CH_LOW_FREQUENCY : 0));\n\n    return 0;\n}\n\nstatic int mov_read_chan(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 16)\n        return 0;\n\n    /* skip version and flags */\n    avio_skip(pb, 4);\n\n    ff_mov_read_chan(c->fc, pb, st, atom.size - 4);\n\n    return 0;\n}\n\nstatic int mov_read_wfex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((ret = ff_get_wav_header(c->fc, pb, st->codecpar, atom.size, 0)) < 0)\n        av_log(c->fc, AV_LOG_WARNING, \"get_wav_header failed\\n\");\n\n    return ret;\n}\n\n/* This atom overrides any previously set aspect ratio */\nstatic int mov_read_pasp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int num = avio_rb32(pb);\n    const int den = avio_rb32(pb);\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (den != 0) {\n        av_reduce(&st->sample_aspect_ratio.num, &st->sample_aspect_ratio.den,\n                  num, den, 32767);\n    }\n    return 0;\n}\n\n/* this atom contains actual media data */\nstatic int mov_read_mdat(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size == 0) /* wrong one (MP4) */\n        return 0;\n    c->found_mdat=1;\n    return 0; /* now go for moov */\n}\n\n#define DRM_BLOB_SIZE 56\n\nstatic int mov_read_adrm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint8_t intermediate_key[20];\n    uint8_t intermediate_iv[20];\n    uint8_t input[64];\n    uint8_t output[64];\n    uint8_t file_checksum[20];\n    uint8_t calculated_checksum[20];\n    char checksum_string[2 * sizeof(file_checksum) + 1];\n    struct AVSHA *sha;\n    int i;\n    int ret = 0;\n    uint8_t *activation_bytes = c->activation_bytes;\n    uint8_t *fixed_key = c->audible_fixed_key;\n\n    c->aax_mode = 1;\n\n    sha = av_sha_alloc();\n    if (!sha)\n        return AVERROR(ENOMEM);\n    av_free(c->aes_decrypt);\n    c->aes_decrypt = av_aes_alloc();\n    if (!c->aes_decrypt) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    /* drm blob processing */\n    avio_read(pb, output, 8); // go to offset 8, absolute position 0x251\n    avio_read(pb, input, DRM_BLOB_SIZE);\n    avio_read(pb, output, 4); // go to offset 4, absolute position 0x28d\n    avio_read(pb, file_checksum, 20);\n\n    // required by external tools\n    ff_data_to_hex(checksum_string, file_checksum, sizeof(file_checksum), 1);\n    av_log(c->fc, AV_LOG_INFO, \"[aax] file checksum == %s\\n\", checksum_string);\n\n    /* verify activation data */\n    if (!activation_bytes) {\n        av_log(c->fc, AV_LOG_WARNING, \"[aax] activation_bytes option is missing!\\n\");\n        ret = 0;  /* allow ffprobe to continue working on .aax files */\n        goto fail;\n    }\n    if (c->activation_bytes_size != 4) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] activation_bytes value needs to be 4 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* verify fixed key */\n    if (c->audible_fixed_key_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] audible_fixed_key value needs to be 16 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* AAX (and AAX+) key derivation */\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_key);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, intermediate_key, 20);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_iv);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, intermediate_key, 16);\n    av_sha_update(sha, intermediate_iv, 16);\n    av_sha_final(sha, calculated_checksum);\n    if (memcmp(calculated_checksum, file_checksum, 20)) { // critical error\n        av_log(c->fc, AV_LOG_ERROR, \"[aax] mismatch in checksums!\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    av_aes_init(c->aes_decrypt, intermediate_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, output, input, DRM_BLOB_SIZE >> 4, intermediate_iv, 1);\n    for (i = 0; i < 4; i++) {\n        // file data (in output) is stored in big-endian mode\n        if (activation_bytes[i] != output[3 - i]) { // critical error\n            av_log(c->fc, AV_LOG_ERROR, \"[aax] error in drm blob decryption!\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    memcpy(c->file_key, output + 8, 16);\n    memcpy(input, output + 26, 16);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, input, 16);\n    av_sha_update(sha, c->file_key, 16);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_final(sha, c->file_iv);\n\nfail:\n    av_free(sha);\n\n    return ret;\n}\n\nstatic int mov_aaxc_crypto(MOVContext *c)\n{\n    if (c->audible_key_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aaxc] audible_key value needs to be 16 bytes!\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (c->audible_iv_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aaxc] audible_iv value needs to be 16 bytes!\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    c->aes_decrypt = av_aes_alloc();\n    if (!c->aes_decrypt) {\n        return AVERROR(ENOMEM);\n    }\n\n    memcpy(c->file_key, c->audible_key, 16);\n    memcpy(c->file_iv, c->audible_iv, 16);\n    c->aax_mode = 1;\n\n    return 0;\n}\n\n// Audible AAX (and AAX+) bytestream decryption\nstatic int aax_filter(uint8_t *input, int size, MOVContext *c)\n{\n    int blocks = 0;\n    unsigned char iv[16];\n\n    memcpy(iv, c->file_iv, 16); // iv is overwritten\n    blocks = size >> 4; // trailing bytes are not encrypted!\n    av_aes_init(c->aes_decrypt, c->file_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, input, input, blocks, iv, 1);\n\n    return 0;\n}\n\n/* read major brand, minor version and compatible brands and store them as metadata */\nstatic int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t minor_ver;\n    int comp_brand_size;\n    char* comp_brands_str;\n    uint8_t type[5] = {0};\n    int ret = ffio_read_size(pb, type, 4);\n    if (ret < 0)\n        return ret;\n\n    if (strcmp(type, \"qt  \"))\n        c->isom = 1;\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n    c->is_still_picture_avif = !strncmp(type, \"avif\", 4);\n    minor_ver = avio_rb32(pb); /* minor version */\n    av_dict_set_int(&c->fc->metadata, \"minor_version\", minor_ver, 0);\n\n    comp_brand_size = atom.size - 8;\n    if (comp_brand_size < 0 || comp_brand_size == INT_MAX)\n        return AVERROR_INVALIDDATA;\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n    if (!comp_brands_str)\n        return AVERROR(ENOMEM);\n\n    ret = ffio_read_size(pb, comp_brands_str, comp_brand_size);\n    if (ret < 0) {\n        av_freep(&comp_brands_str);\n        return ret;\n    }\n    comp_brands_str[comp_brand_size] = 0;\n    av_dict_set(&c->fc->metadata, \"compatible_brands\",\n                comp_brands_str, AV_DICT_DONT_STRDUP_VAL);\n\n    // Logic for handling Audible's .aaxc files\n    if (!strcmp(type, \"aaxc\")) {\n        mov_aaxc_crypto(c);\n    }\n\n    return 0;\n}\n\n/* this atom should contain all header atoms */\nstatic int mov_read_moov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n\n    if (c->found_moov) {\n        av_log(c->fc, AV_LOG_WARNING, \"Found duplicated MOOV Atom. Skipped it\\n\");\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n    /* we parsed the 'moov' atom, we can terminate the parsing as soon as we find the 'mdat' */\n    /* so we don't parse the whole file if over a network */\n    c->found_moov=1;\n    return 0; /* now go for mdat */\n}\n\nstatic MOVFragmentStreamInfo * get_frag_stream_info(\n    MOVFragmentIndex *frag_index,\n    int index,\n    int id)\n{\n    int i;\n    MOVFragmentIndexItem * item;\n\n    if (index < 0 || index >= frag_index->nb_items)\n        return NULL;\n    item = &frag_index->item[index];\n    for (i = 0; i < item->nb_stream_info; i++)\n        if (item->stream_info[i].id == id)\n            return &item->stream_info[i];\n\n    // This shouldn't happen\n    return NULL;\n}\n\nstatic void set_frag_stream(MOVFragmentIndex *frag_index, int id)\n{\n    int i;\n    MOVFragmentIndexItem * item;\n\n    if (frag_index->current < 0 ||\n        frag_index->current >= frag_index->nb_items)\n        return;\n\n    item = &frag_index->item[frag_index->current];\n    for (i = 0; i < item->nb_stream_info; i++)\n        if (item->stream_info[i].id == id) {\n            item->current = i;\n            return;\n        }\n\n    // id not found.  This shouldn't happen.\n    item->current = -1;\n}\n\nstatic MOVFragmentStreamInfo * get_current_frag_stream_info(\n    MOVFragmentIndex *frag_index)\n{\n    MOVFragmentIndexItem *item;\n    if (frag_index->current < 0 ||\n        frag_index->current >= frag_index->nb_items)\n        return NULL;\n\n    item = &frag_index->item[frag_index->current];\n    if (item->current >= 0 && item->current < item->nb_stream_info)\n        return &item->stream_info[item->current];\n\n    // This shouldn't happen\n    return NULL;\n}\n\nstatic int search_frag_moof_offset(MOVFragmentIndex *frag_index, int64_t offset)\n{\n    int a, b, m;\n    int64_t moof_offset;\n\n    // Optimize for appending new entries\n    if (!frag_index->nb_items ||\n        frag_index->item[frag_index->nb_items - 1].moof_offset < offset)\n        return frag_index->nb_items;\n\n    a = -1;\n    b = frag_index->nb_items;\n\n    while (b - a > 1) {\n        m = (a + b) >> 1;\n        moof_offset = frag_index->item[m].moof_offset;\n        if (moof_offset >= offset)\n            b = m;\n        if (moof_offset <= offset)\n            a = m;\n    }\n    return b;\n}\n\nstatic int64_t get_stream_info_time(MOVFragmentStreamInfo * frag_stream_info)\n{\n    av_assert0(frag_stream_info);\n    if (frag_stream_info->sidx_pts != AV_NOPTS_VALUE)\n        return frag_stream_info->sidx_pts;\n    if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE)\n        return frag_stream_info->first_tfra_pts;\n    return frag_stream_info->tfdt_dts;\n}\n\nstatic int64_t get_frag_time(AVFormatContext *s, AVStream *dst_st,\n                             MOVFragmentIndex *frag_index, int index)\n{\n    MOVFragmentStreamInfo * frag_stream_info;\n    MOVStreamContext *sc = dst_st->priv_data;\n    int64_t timestamp;\n    int i, j;\n\n    // If the stream is referenced by any sidx, limit the search\n    // to fragments that referenced this stream in the sidx\n    if (sc->has_sidx) {\n        frag_stream_info = get_frag_stream_info(frag_index, index, dst_st->id);\n        if (frag_stream_info->sidx_pts != AV_NOPTS_VALUE)\n            return frag_stream_info->sidx_pts;\n        if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE)\n            return frag_stream_info->first_tfra_pts;\n        return frag_stream_info->sidx_pts;\n    }\n\n    for (i = 0; i < frag_index->item[index].nb_stream_info; i++) {\n        AVStream *frag_stream = NULL;\n        frag_stream_info = &frag_index->item[index].stream_info[i];\n        for (j = 0; j < s->nb_streams; j++)\n            if (s->streams[j]->id == frag_stream_info->id)\n                frag_stream = s->streams[j];\n        if (!frag_stream) {\n            av_log(s, AV_LOG_WARNING, \"No stream matching sidx ID found.\\n\");\n            continue;\n        }\n        timestamp = get_stream_info_time(frag_stream_info);\n        if (timestamp != AV_NOPTS_VALUE)\n            return av_rescale_q(timestamp, frag_stream->time_base, dst_st->time_base);\n    }\n    return AV_NOPTS_VALUE;\n}\n\nstatic int search_frag_timestamp(AVFormatContext *s, MOVFragmentIndex *frag_index,\n                                 AVStream *st, int64_t timestamp)\n{\n    int a, b, m, m0;\n    int64_t frag_time;\n\n    a = -1;\n    b = frag_index->nb_items;\n\n    while (b - a > 1) {\n        m0 = m = (a + b) >> 1;\n\n        while (m < b &&\n               (frag_time = get_frag_time(s, st, frag_index, m)) == AV_NOPTS_VALUE)\n            m++;\n\n        if (m < b && frag_time <= timestamp)\n            a = m;\n        else\n            b = m0;\n    }\n\n    return a;\n}\n\nstatic int update_frag_index(MOVContext *c, int64_t offset)\n{\n    int index, i;\n    MOVFragmentIndexItem * item;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    // If moof_offset already exists in frag_index, return index to it\n    index = search_frag_moof_offset(&c->frag_index, offset);\n    if (index < c->frag_index.nb_items &&\n        c->frag_index.item[index].moof_offset == offset)\n        return index;\n\n    // offset is not yet in frag index.\n    // Insert new item at index (sorted by moof offset)\n    item = av_fast_realloc(c->frag_index.item,\n                           &c->frag_index.allocated_size,\n                           (c->frag_index.nb_items + 1) *\n                           sizeof(*c->frag_index.item));\n    if (!item)\n        return -1;\n    c->frag_index.item = item;\n\n    frag_stream_info = av_realloc_array(NULL, c->fc->nb_streams,\n                                        sizeof(*item->stream_info));\n    if (!frag_stream_info)\n        return -1;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        // Avoid building frag index if streams lack track id.\n        if (c->fc->streams[i]->id < 0) {\n            av_free(frag_stream_info);\n            return AVERROR_INVALIDDATA;\n        }\n\n        frag_stream_info[i].id = c->fc->streams[i]->id;\n        frag_stream_info[i].sidx_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].index_base = -1;\n        frag_stream_info[i].index_entry = -1;\n        frag_stream_info[i].encryption_index = NULL;\n    }\n\n    if (index < c->frag_index.nb_items)\n        memmove(c->frag_index.item + index + 1, c->frag_index.item + index,\n                (c->frag_index.nb_items - index) * sizeof(*c->frag_index.item));\n\n    item = &c->frag_index.item[index];\n    item->headers_read = 0;\n    item->current = 0;\n    item->nb_stream_info = c->fc->nb_streams;\n    item->moof_offset = offset;\n    item->stream_info = frag_stream_info;\n    c->frag_index.nb_items++;\n\n    return index;\n}\n\nstatic void fix_frag_index_entries(MOVFragmentIndex *frag_index, int index,\n                                   int id, int entries)\n{\n    int i;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    if (index < 0)\n        return;\n    for (i = index; i < frag_index->nb_items; i++) {\n        frag_stream_info = get_frag_stream_info(frag_index, i, id);\n        if (frag_stream_info && frag_stream_info->index_entry >= 0)\n            frag_stream_info->index_entry += entries;\n    }\n}\n\nstatic int mov_read_moof(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    // Set by mov_read_tfhd(). mov_read_trun() will reject files missing tfhd.\n    c->fragment.found_tfhd = 0;\n\n    if (!c->has_looked_for_mfra && c->use_mfra_for > 0) {\n        c->has_looked_for_mfra = 1;\n        if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n            int ret;\n            av_log(c->fc, AV_LOG_VERBOSE, \"stream has moof boxes, will look \"\n                    \"for a mfra\\n\");\n            if ((ret = mov_read_mfra(c, pb)) < 0) {\n                av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but failed to \"\n                        \"read the mfra (may be a live ismv)\\n\");\n            }\n        } else {\n            av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but stream is not \"\n                    \"seekable, can not look for mfra\\n\");\n        }\n    }\n    c->fragment.moof_offset = c->fragment.implicit_offset = avio_tell(pb) - 8;\n    av_log(c->fc, AV_LOG_TRACE, \"moof offset %\"PRIx64\"\\n\", c->fragment.moof_offset);\n    c->frag_index.current = update_frag_index(c, c->fragment.moof_offset);\n    return mov_read_default(c, pb, atom);\n}\n\nstatic void mov_metadata_creation_time(AVDictionary **metadata, int64_t time, void *logctx)\n{\n    if (time) {\n        if (time >= 2082844800)\n            time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        if ((int64_t)(time * 1000000ULL) / 1000000 != time) {\n            av_log(logctx, AV_LOG_DEBUG, \"creation_time is not representable\\n\");\n            return;\n        }\n\n        avpriv_dict_set_timestamp(metadata, \"creation_time\", time * 1000000);\n    }\n}\n\nstatic int mov_read_mdhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    char language[4] = {0};\n    unsigned lang;\n    int64_t creation_time;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->time_scale) {\n        av_log(c->fc, AV_LOG_ERROR, \"Multiple mdhd?\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n    avio_rb24(pb); /* flags */\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&st->metadata, creation_time, c->fc);\n\n    sc->time_scale = avio_rb32(pb);\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mdhd time scale %d, defaulting to 1\\n\", sc->time_scale);\n        sc->time_scale = 1;\n    }\n    st->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n\n    lang = avio_rb16(pb); /* language */\n    if (ff_mov_lang_to_iso639(lang, language))\n        av_dict_set(&st->metadata, \"language\", language, 0);\n    avio_rb16(pb); /* quality */\n\n    return 0;\n}\n\nstatic int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i;\n    int64_t creation_time;\n    int version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&c->fc->metadata, creation_time, c->fc);\n    c->time_scale = avio_rb32(pb); /* time scale */\n    if (c->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mvhd time scale %d, defaulting to 1\\n\", c->time_scale);\n        c->time_scale = 1;\n    }\n    av_log(c->fc, AV_LOG_TRACE, \"time scale = %i\\n\", c->time_scale);\n\n    c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n    // set the AVFormatContext duration because the duration of individual tracks\n    // may be inaccurate\n    if (!c->trex_data)\n        c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);\n    avio_rb32(pb); /* preferred scale */\n\n    avio_rb16(pb); /* preferred volume */\n\n    avio_skip(pb, 10); /* reserved */\n\n    /* movie display matrix, store it in main context and use it later on */\n    for (i = 0; i < 3; i++) {\n        c->movie_display_matrix[i][0] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][1] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][2] = avio_rb32(pb); //  2.30 fixed point\n    }\n\n    avio_rb32(pb); /* preview time */\n    avio_rb32(pb); /* preview duration */\n    avio_rb32(pb); /* poster time */\n    avio_rb32(pb); /* selection time */\n    avio_rb32(pb); /* selection duration */\n    avio_rb32(pb); /* current time */\n    avio_rb32(pb); /* next track ID */\n\n    return 0;\n}\n\nstatic void set_last_stream_little_endian(AVFormatContext *fc)\n{\n    AVStream *st;\n\n    if (fc->nb_streams < 1)\n        return;\n    st = fc->streams[fc->nb_streams-1];\n\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S16BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE;\n        break;\n    case AV_CODEC_ID_PCM_S24BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n        break;\n    case AV_CODEC_ID_PCM_S32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n        break;\n    case AV_CODEC_ID_PCM_F32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F32LE;\n        break;\n    case AV_CODEC_ID_PCM_F64BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F64LE;\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int mov_read_enda(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int little_endian = avio_rb16(pb) & 0xFF;\n    av_log(c->fc, AV_LOG_TRACE, \"enda %d\\n\", little_endian);\n    if (little_endian == 1)\n        set_last_stream_little_endian(c->fc);\n    return 0;\n}\n\nstatic int mov_read_pcmc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int format_flags;\n\n    if (atom.size < 6) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty pcmC box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_r8(pb);    // version\n    avio_rb24(pb);  // flags\n    format_flags = avio_r8(pb);\n    if (format_flags == 1) // indicates little-endian format. If not present, big-endian format is used\n        set_last_stream_little_endian(c->fc);\n\n    return 0;\n}\n\nstatic int mov_read_colr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t *icc_profile;\n    char color_parameter_type[5] = { 0 };\n    uint16_t color_primaries, color_trc, color_matrix;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    ret = ffio_read_size(pb, color_parameter_type, 4);\n    if (ret < 0)\n        return ret;\n    if (strncmp(color_parameter_type, \"nclx\", 4) &&\n        strncmp(color_parameter_type, \"nclc\", 4) &&\n        strncmp(color_parameter_type, \"prof\", 4)) {\n        av_log(c->fc, AV_LOG_WARNING, \"unsupported color_parameter_type %s\\n\",\n               color_parameter_type);\n        return 0;\n    }\n\n    if (!strncmp(color_parameter_type, \"prof\", 4)) {\n        icc_profile = av_stream_new_side_data(st, AV_PKT_DATA_ICC_PROFILE, atom.size - 4);\n        if (!icc_profile)\n            return AVERROR(ENOMEM);\n        ret = ffio_read_size(pb, icc_profile, atom.size - 4);\n        if (ret < 0)\n            return ret;\n    } else {\n        color_primaries = avio_rb16(pb);\n        color_trc = avio_rb16(pb);\n        color_matrix = avio_rb16(pb);\n\n        av_log(c->fc, AV_LOG_TRACE,\n               \"%s: pri %d trc %d matrix %d\",\n               color_parameter_type, color_primaries, color_trc, color_matrix);\n\n        if (!strncmp(color_parameter_type, \"nclx\", 4)) {\n            uint8_t color_range = avio_r8(pb) >> 7;\n            av_log(c->fc, AV_LOG_TRACE, \" full %\"PRIu8\"\", color_range);\n            if (color_range)\n                st->codecpar->color_range = AVCOL_RANGE_JPEG;\n            else\n                st->codecpar->color_range = AVCOL_RANGE_MPEG;\n        }\n\n        if (!av_color_primaries_name(color_primaries))\n            color_primaries = AVCOL_PRI_UNSPECIFIED;\n        if (!av_color_transfer_name(color_trc))\n            color_trc = AVCOL_TRC_UNSPECIFIED;\n        if (!av_color_space_name(color_matrix))\n            color_matrix = AVCOL_SPC_UNSPECIFIED;\n\n        st->codecpar->color_primaries = color_primaries;\n        st->codecpar->color_trc       = color_trc;\n        st->codecpar->color_space     = color_matrix;\n        av_log(c->fc, AV_LOG_TRACE, \"\\n\");\n    }\n    return 0;\n}\n\nstatic int mov_read_fiel(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned mov_field_order;\n    enum AVFieldOrder decoded_field_order = AV_FIELD_UNKNOWN;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if (atom.size < 2)\n        return AVERROR_INVALIDDATA;\n    mov_field_order = avio_rb16(pb);\n    if ((mov_field_order & 0xFF00) == 0x0100)\n        decoded_field_order = AV_FIELD_PROGRESSIVE;\n    else if ((mov_field_order & 0xFF00) == 0x0200) {\n        switch (mov_field_order & 0xFF) {\n        case 0x01: decoded_field_order = AV_FIELD_TT;\n                   break;\n        case 0x06: decoded_field_order = AV_FIELD_BB;\n                   break;\n        case 0x09: decoded_field_order = AV_FIELD_TB;\n                   break;\n        case 0x0E: decoded_field_order = AV_FIELD_BT;\n                   break;\n        }\n    }\n    if (decoded_field_order == AV_FIELD_UNKNOWN && mov_field_order) {\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown MOV field order 0x%04x\\n\", mov_field_order);\n    }\n    st->codecpar->field_order = decoded_field_order;\n\n    return 0;\n}\n\nstatic int mov_realloc_extradata(AVCodecParameters *par, MOVAtom atom)\n{\n    int err = 0;\n    uint64_t size = (uint64_t)par->extradata_size + atom.size + 8 + AV_INPUT_BUFFER_PADDING_SIZE;\n    if (size > INT_MAX || (uint64_t)atom.size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp(&par->extradata, size)) < 0) {\n        par->extradata_size = 0;\n        return err;\n    }\n    par->extradata_size = size - AV_INPUT_BUFFER_PADDING_SIZE;\n    return 0;\n}\n\n/* Read a whole atom into the extradata return the size of the atom read, possibly truncated if != atom.size */\nstatic int64_t mov_read_atom_into_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                                        AVCodecParameters *par, uint8_t *buf)\n{\n    int64_t result = atom.size;\n    int err;\n\n    AV_WB32(buf    , atom.size + 8);\n    AV_WL32(buf + 4, atom.type);\n    err = ffio_read_size(pb, buf + 8, atom.size);\n    if (err < 0) {\n        par->extradata_size -= atom.size;\n        return err;\n    } else if (err < atom.size) {\n        av_log(c->fc, AV_LOG_WARNING, \"truncated extradata\\n\");\n        par->extradata_size -= atom.size - err;\n        result = err;\n    }\n    memset(buf + 8 + err, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    return result;\n}\n\n/* FIXME modify QDM2/SVQ3/H.264 decoders to take full atom as extradata */\nstatic int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                              enum AVCodecID codec_id)\n{\n    AVStream *st;\n    uint64_t original_size;\n    int err;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (st->codecpar->codec_id != codec_id)\n        return 0; /* unexpected codec_id - don't mess with extradata */\n\n    original_size = st->codecpar->extradata_size;\n    err = mov_realloc_extradata(st->codecpar, atom);\n    if (err)\n        return err;\n\n    err =  mov_read_atom_into_extradata(c, pb, atom, st->codecpar,  st->codecpar->extradata + original_size);\n    if (err < 0)\n        return err;\n    return 0; // Note: this is the original behavior to ignore truncation.\n}\n\n/* wrapper functions for reading ALAC/AVS/MJPEG/MJPEG2000 extradata atoms only for those codecs */\nstatic int mov_read_alac(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_ALAC);\n}\n\nstatic int mov_read_avss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVS);\n}\n\nstatic int mov_read_jp2h(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_JPEG2000);\n}\n\nstatic int mov_read_dpxe(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_R10K);\n}\n\nstatic int mov_read_avid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVUI);\n    if (!ret)\n        ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_DNXHD);\n    return ret;\n}\n\nstatic int mov_read_targa_y216(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_TARGA_Y216);\n\n    if (!ret && c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->extradata_size >= 40) {\n            par->height = AV_RB16(&par->extradata[36]);\n            par->width  = AV_RB16(&par->extradata[38]);\n        }\n    }\n    return ret;\n}\n\nstatic int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (c->fc->nb_streams >= 1) {\n        AVStream *const  st = c->fc->streams[c->fc->nb_streams - 1];\n        FFStream *const sti = ffstream(st);\n        AVCodecParameters *par = st->codecpar;\n\n        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n            par->codec_id == AV_CODEC_ID_H264 &&\n            atom.size > 11) {\n            int cid;\n            avio_skip(pb, 10);\n            cid = avio_rb16(pb);\n            /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n            if (cid == 0xd4d || cid == 0xd4e)\n                par->width = 1440;\n            return 0;\n        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||\n                    par->codec_tag == MKTAG('A', 'V', 'j', '2') ||\n                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&\n                   atom.size >= 24) {\n            int num, den;\n            avio_skip(pb, 12);\n            num = avio_rb32(pb);\n            den = avio_rb32(pb);\n            if (num <= 0 || den <= 0)\n                return 0;\n            switch (avio_rb32(pb)) {\n            case 2:\n                if (den >= INT_MAX / 2)\n                    return 0;\n                den *= 2;\n            case 1:\n                sti->display_aspect_ratio = (AVRational){ num, den };\n            default:\n                return 0;\n            }\n        }\n    }\n\n    return mov_read_avid(c, pb, atom);\n}\n\nstatic int mov_read_aclr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = 0;\n    int length = 0;\n    uint64_t original_size;\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_id == AV_CODEC_ID_H264)\n            return 0;\n        if (atom.size == 16) {\n            original_size = par->extradata_size;\n            ret = mov_realloc_extradata(par, atom);\n            if (!ret) {\n                length =  mov_read_atom_into_extradata(c, pb, atom, par, par->extradata + original_size);\n                if (length == atom.size) {\n                    const uint8_t range_value = par->extradata[original_size + 19];\n                    switch (range_value) {\n                    case 1:\n                        par->color_range = AVCOL_RANGE_MPEG;\n                        break;\n                    case 2:\n                        par->color_range = AVCOL_RANGE_JPEG;\n                        break;\n                    default:\n                        av_log(c->fc, AV_LOG_WARNING, \"ignored unknown aclr value (%d)\\n\", range_value);\n                        break;\n                    }\n                    ff_dlog(c->fc, \"color_range: %d\\n\", par->color_range);\n                } else {\n                  /* For some reason the whole atom was not added to the extradata */\n                  av_log(c->fc, AV_LOG_ERROR, \"aclr not decoded - incomplete atom\\n\");\n                }\n            } else {\n                av_log(c->fc, AV_LOG_ERROR, \"aclr not decoded - unable to add atom to extradata\\n\");\n            }\n        } else {\n            av_log(c->fc, AV_LOG_WARNING, \"aclr not decoded - unexpected size %\"PRId64\"\\n\", atom.size);\n        }\n    }\n\n    return ret;\n}\n\nstatic int mov_read_svq3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_SVQ3);\n}\n\nstatic int mov_read_wave(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_QDM2 ||\n        st->codecpar->codec_id == AV_CODEC_ID_QDMC ||\n        st->codecpar->codec_id == AV_CODEC_ID_SPEEX) {\n        // pass all frma atom to codec, needed at least for QDMC and QDM2\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n        if (ret < 0)\n            return ret;\n    } else if (atom.size > 8) { /* to read frma, esds atoms */\n        if (st->codecpar->codec_id == AV_CODEC_ID_ALAC && atom.size >= 24) {\n            uint64_t buffer;\n            ret = ffio_ensure_seekback(pb, 8);\n            if (ret < 0)\n                return ret;\n            buffer = avio_rb64(pb);\n            atom.size -= 8;\n            if (  (buffer & 0xFFFFFFFF) == MKBETAG('f','r','m','a')\n                && buffer >> 32 <= atom.size\n                && buffer >> 32 >= 8) {\n                avio_skip(pb, -8);\n                atom.size += 8;\n            } else if (!st->codecpar->extradata_size) {\n#define ALAC_EXTRADATA_SIZE 36\n                st->codecpar->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);\n                if (!st->codecpar->extradata)\n                    return AVERROR(ENOMEM);\n                st->codecpar->extradata_size = ALAC_EXTRADATA_SIZE;\n                AV_WB32(st->codecpar->extradata    , ALAC_EXTRADATA_SIZE);\n                AV_WB32(st->codecpar->extradata + 4, MKTAG('a','l','a','c'));\n                AV_WB64(st->codecpar->extradata + 12, buffer);\n                avio_read(pb, st->codecpar->extradata + 20, 16);\n                avio_skip(pb, atom.size - 24);\n                return 0;\n            }\n        }\n        if ((ret = mov_read_default(c, pb, atom)) < 0)\n            return ret;\n    } else\n        avio_skip(pb, atom.size);\n    return 0;\n}\n\n/**\n * This function reads atom content and puts data in extradata without tag\n * nor size unlike mov_read_extradata.\n */\nstatic int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (atom.size >= 10) {\n        // Broken files created by legacy versions of libavformat will\n        // wrap a whole fiel atom inside of a glbl atom.\n        unsigned size = avio_rb32(pb);\n        unsigned type = avio_rl32(pb);\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        avio_seek(pb, -8, SEEK_CUR);\n        if (type == MKTAG('f','i','e','l') && size == atom.size)\n            return mov_read_default(c, pb, atom);\n    }\n    if (st->codecpar->extradata_size > 1 && st->codecpar->extradata) {\n        av_log(c->fc, AV_LOG_WARNING, \"ignoring multiple glbl\\n\");\n        return 0;\n    }\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n    if (ret < 0)\n        return ret;\n    if (atom.type == MKTAG('h','v','c','C') && st->codecpar->codec_tag == MKTAG('d','v','h','1'))\n        /* HEVC-based Dolby Vision derived from hvc1.\n           Happens to match with an identifier\n           previously utilized for DV. Thus, if we have\n           the hvcC extradata box available as specified,\n           set codec to HEVC */\n        st->codecpar->codec_id = AV_CODEC_ID_HEVC;\n\n    return 0;\n}\n\nstatic int mov_read_dvc1(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t profile_level;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size >= (1<<28) || atom.size < 7)\n        return AVERROR_INVALIDDATA;\n\n    profile_level = avio_r8(pb);\n    if ((profile_level & 0xf0) != 0xc0)\n        return 0;\n\n    avio_seek(pb, 6, SEEK_CUR);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 7);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n/**\n * An strf atom is a BITMAPINFOHEADER struct. This struct is 40 bytes itself,\n * but can have extradata appended at the end after the 40 bytes belonging\n * to the struct.\n */\nstatic int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    if (atom.size <= 40)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 40);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 40);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int mov_read_stco(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->trak_index < 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"STCO outside TRAK\\n\");\n        return 0;\n    }\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    if (!entries)\n        return 0;\n\n    if (sc->chunk_offsets) {\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicated STCO atom\\n\");\n        return 0;\n    }\n    av_free(sc->chunk_offsets);\n    sc->chunk_count = 0;\n    sc->chunk_offsets = av_malloc_array(entries, sizeof(*sc->chunk_offsets));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->chunk_count = entries;\n\n    if      (atom.type == MKTAG('s','t','c','o'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb32(pb);\n    else if (atom.type == MKTAG('c','o','6','4'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb64(pb);\n    else\n        return AVERROR_INVALIDDATA;\n\n    sc->chunk_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STCO atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_codec_id(AVStream *st, uint32_t format)\n{\n    int id = ff_codec_get_id(ff_codec_movaudio_tags, format);\n\n    if (id <= 0 &&\n        ((format & 0xFFFF) == 'm' + ('s' << 8) ||\n         (format & 0xFFFF) == 'T' + ('S' << 8)))\n        id = ff_codec_get_id(ff_codec_wav_tags, av_bswap32(format) & 0xFFFF);\n\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_VIDEO && id > 0) {\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    } else if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO &&\n               /* skip old ASF MPEG-4 tag */\n               format && format != MKTAG('m','p','4','s')) {\n        id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n        if (id <= 0)\n            id = ff_codec_get_id(ff_codec_bmp_tags, format);\n        if (id > 0)\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA ||\n                    (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n                    st->codecpar->codec_id == AV_CODEC_ID_NONE)) {\n            id = ff_codec_get_id(ff_codec_movsubtitle_tags, format);\n            if (id > 0)\n                st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n            else\n                id = ff_codec_get_id(ff_codec_movdata_tags, format);\n        }\n    }\n\n    st->codecpar->codec_tag = format;\n\n    return id;\n}\n\nstatic void mov_parse_stsd_video(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    uint8_t codec_name[32] = { 0 };\n    int64_t stsd_start;\n    unsigned int len;\n    uint32_t id = 0;\n\n    /* The first 16 bytes of the video sample description are already\n     * read in ff_mov_read_stsd_entries() */\n    stsd_start = avio_tell(pb) - 16;\n\n    avio_rb16(pb); /* version */\n    avio_rb16(pb); /* revision level */\n    id = avio_rl32(pb); /* vendor */\n    av_dict_set(&st->metadata, \"vendor_id\", av_fourcc2str(id), 0);\n    avio_rb32(pb); /* temporal quality */\n    avio_rb32(pb); /* spatial quality */\n\n    st->codecpar->width  = avio_rb16(pb); /* width */\n    st->codecpar->height = avio_rb16(pb); /* height */\n\n    avio_rb32(pb); /* horiz resolution */\n    avio_rb32(pb); /* vert resolution */\n    avio_rb32(pb); /* data size, always 0 */\n    avio_rb16(pb); /* frames per samples */\n\n    len = avio_r8(pb); /* codec name, pascal string */\n    if (len > 31)\n        len = 31;\n    mov_read_mac_string(c, pb, len, codec_name, sizeof(codec_name));\n    if (len < 31)\n        avio_skip(pb, 31 - len);\n\n    if (codec_name[0])\n        av_dict_set(&st->metadata, \"encoder\", codec_name, 0);\n\n    /* codec_tag YV12 triggers an UV swap in rawdec.c */\n    if (!strncmp(codec_name, \"Planar Y'CbCr 8-bit 4:2:0\", 25)) {\n        st->codecpar->codec_tag = MKTAG('I', '4', '2', '0');\n        st->codecpar->width &= ~1;\n        st->codecpar->height &= ~1;\n    }\n    /* Flash Media Server uses tag H.263 with Sorenson Spark */\n    if (st->codecpar->codec_tag == MKTAG('H','2','6','3') &&\n        !strncmp(codec_name, \"Sorenson H263\", 13))\n        st->codecpar->codec_id = AV_CODEC_ID_FLV1;\n\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* depth */\n\n    avio_seek(pb, stsd_start, SEEK_SET);\n\n    if (ff_get_qtpalette(st->codecpar->codec_id, pb, sc->palette)) {\n        st->codecpar->bits_per_coded_sample &= 0x1F;\n        sc->has_palette = 1;\n    }\n}\n\nstatic void mov_parse_stsd_audio(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    int bits_per_sample, flags;\n    uint16_t version = avio_rb16(pb);\n    uint32_t id = 0;\n    AVDictionaryEntry *compatible_brands = av_dict_get(c->fc->metadata, \"compatible_brands\", NULL, AV_DICT_MATCH_CASE);\n    int channel_count;\n\n    avio_rb16(pb); /* revision level */\n    id = avio_rl32(pb); /* vendor */\n    av_dict_set(&st->metadata, \"vendor_id\", av_fourcc2str(id), 0);\n\n    channel_count = avio_rb16(pb);\n\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* sample size */\n    av_log(c->fc, AV_LOG_TRACE, \"audio channels %d\\n\", channel_count);\n\n    sc->audio_cid = avio_rb16(pb);\n    avio_rb16(pb); /* packet size = 0 */\n\n    st->codecpar->sample_rate = ((avio_rb32(pb) >> 16));\n\n    // Read QT version 1 fields. In version 0 these do not exist.\n    av_log(c->fc, AV_LOG_TRACE, \"version =%d, isom =%d\\n\", version, c->isom);\n    if (!c->isom ||\n        (compatible_brands && strstr(compatible_brands->value, \"qt  \")) ||\n        (sc->stsd_version == 0 && version > 0)) {\n        if (version == 1) {\n            sc->samples_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per packet */\n            sc->bytes_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per sample */\n        } else if (version == 2) {\n            avio_rb32(pb); /* sizeof struct only */\n            st->codecpar->sample_rate = av_int2double(avio_rb64(pb));\n            channel_count = avio_rb32(pb);\n            st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n            st->codecpar->ch_layout.nb_channels = channel_count;\n            avio_rb32(pb); /* always 0x7F000000 */\n            st->codecpar->bits_per_coded_sample = avio_rb32(pb);\n\n            flags = avio_rb32(pb); /* lpcm format specific flag */\n            sc->bytes_per_frame   = avio_rb32(pb);\n            sc->samples_per_frame = avio_rb32(pb);\n            if (st->codecpar->codec_tag == MKTAG('l','p','c','m'))\n                st->codecpar->codec_id =\n                    ff_mov_get_lpcm_codec_id(st->codecpar->bits_per_coded_sample,\n                                             flags);\n        }\n        if (version == 0 || (version == 1 && sc->audio_cid != -2)) {\n            /* can't correctly handle variable sized packet as audio unit */\n            switch (st->codecpar->codec_id) {\n            case AV_CODEC_ID_MP2:\n            case AV_CODEC_ID_MP3:\n                ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n                break;\n            }\n        }\n    }\n\n    if (sc->format == 0) {\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('r','a','w',' '));\n        else if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('t','w','o','s'));\n    }\n\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_U8:\n        if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        break;\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S16BE:\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S8;\n        else if (st->codecpar->bits_per_coded_sample == 24)\n            st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S24BE : AV_CODEC_ID_PCM_S24LE;\n        else if (st->codecpar->bits_per_coded_sample == 32)\n             st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S32BE : AV_CODEC_ID_PCM_S32LE;\n        break;\n    /* set values for old format before stsd version 1 appeared */\n    case AV_CODEC_ID_MACE3:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 2 * st->codecpar->ch_layout.nb_channels;\n        break;\n    case AV_CODEC_ID_MACE6:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 1 * st->codecpar->ch_layout.nb_channels;\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n        sc->samples_per_frame = 64;\n        sc->bytes_per_frame   = 34 * st->codecpar->ch_layout.nb_channels;\n        break;\n    case AV_CODEC_ID_GSM:\n        sc->samples_per_frame = 160;\n        sc->bytes_per_frame   = 33;\n        break;\n    default:\n        break;\n    }\n\n    bits_per_sample = av_get_bits_per_sample(st->codecpar->codec_id);\n    if (bits_per_sample && (bits_per_sample >> 3) * (uint64_t)st->codecpar->ch_layout.nb_channels <= INT_MAX) {\n        st->codecpar->bits_per_coded_sample = bits_per_sample;\n        sc->sample_size = (bits_per_sample >> 3) * st->codecpar->ch_layout.nb_channels;\n    }\n}\n\nstatic void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    // ttxt stsd contains display flags, justification, background\n    // color, fonts, and default styles, so fake an atom to read it\n    MOVAtom fake_atom = { .size = size };\n    // mp4s contains a regular esds atom\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}\n\nstatic uint32_t yuv_to_rgba(uint32_t ycbcr)\n{\n    uint8_t r, g, b;\n    int y, cb, cr;\n\n    y  = (ycbcr >> 16) & 0xFF;\n    cr = (ycbcr >> 8)  & 0xFF;\n    cb =  ycbcr        & 0xFF;\n\n    b = av_clip_uint8((1164 * (y - 16)                     + 2018 * (cb - 128)) / 1000);\n    g = av_clip_uint8((1164 * (y - 16) -  813 * (cr - 128) -  391 * (cb - 128)) / 1000);\n    r = av_clip_uint8((1164 * (y - 16) + 1596 * (cr - 128)                    ) / 1000);\n\n    return (r << 16) | (g << 8) | b;\n}\n\nstatic int mov_rewrite_dvd_sub_extradata(AVStream *st)\n{\n    char buf[256] = {0};\n    uint8_t *src = st->codecpar->extradata;\n    int i, ret;\n\n    if (st->codecpar->extradata_size != 64)\n        return 0;\n\n    if (st->codecpar->width > 0 &&  st->codecpar->height > 0)\n        snprintf(buf, sizeof(buf), \"size: %dx%d\\n\",\n                 st->codecpar->width, st->codecpar->height);\n    av_strlcat(buf, \"palette: \", sizeof(buf));\n\n    for (i = 0; i < 16; i++) {\n        uint32_t yuv = AV_RB32(src + i * 4);\n        uint32_t rgba = yuv_to_rgba(yuv);\n\n        av_strlcatf(buf, sizeof(buf), \"%06\"PRIx32\"%s\", rgba, i != 15 ? \", \" : \"\");\n    }\n\n    if (av_strlcat(buf, \"\\n\", sizeof(buf)) >= sizeof(buf))\n        return 0;\n\n    ret = ff_alloc_extradata(st->codecpar, strlen(buf));\n    if (ret < 0)\n        return ret;\n    memcpy(st->codecpar->extradata, buf, st->codecpar->extradata_size);\n\n    return 0;\n}\n\nstatic int mov_parse_stsd_data(MOVContext *c, AVIOContext *pb,\n                                AVStream *st, MOVStreamContext *sc,\n                                int64_t size)\n{\n    int ret;\n\n    if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {\n        if ((int)size != size)\n            return AVERROR(ENOMEM);\n\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n        if (ret < 0)\n            return ret;\n        if (size > 16) {\n            MOVStreamContext *tmcd_ctx = st->priv_data;\n            int val;\n            val = AV_RB32(st->codecpar->extradata + 4);\n            tmcd_ctx->tmcd_flags = val;\n            st->avg_frame_rate.num = AV_RB32(st->codecpar->extradata + 8); /* timescale */\n            st->avg_frame_rate.den = AV_RB32(st->codecpar->extradata + 12); /* frameDuration */\n            tmcd_ctx->tmcd_nb_frames = st->codecpar->extradata[16]; /* number of frames */\n            if (size > 30) {\n                uint32_t len = AV_RB32(st->codecpar->extradata + 18); /* name atom length */\n                uint32_t format = AV_RB32(st->codecpar->extradata + 22);\n                if (format == AV_RB32(\"name\") && (int64_t)size >= (int64_t)len + 18) {\n                    uint16_t str_size = AV_RB16(st->codecpar->extradata + 26); /* string length */\n                    if (str_size > 0 && size >= (int)str_size + 30 &&\n                        st->codecpar->extradata[30] /* Don't add empty string */) {\n                        char *reel_name = av_malloc(str_size + 1);\n                        if (!reel_name)\n                            return AVERROR(ENOMEM);\n                        memcpy(reel_name, st->codecpar->extradata + 30, str_size);\n                        reel_name[str_size] = 0; /* Add null terminator */\n                        av_dict_set(&st->metadata, \"reel_name\", reel_name,\n                                    AV_DICT_DONT_STRDUP_VAL);\n                    }\n                }\n            }\n        }\n    } else {\n        /* other codec type, just skip (rtp, mp4s ...) */\n        avio_skip(pb, size);\n    }\n    return 0;\n}\n\nstatic int mov_finalize_stsd_codec(MOVContext *c, AVIOContext *pb,\n                                   AVStream *st, MOVStreamContext *sc)\n{\n    FFStream *const sti = ffstream(st);\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n        !st->codecpar->sample_rate && sc->time_scale > 1)\n        st->codecpar->sample_rate = sc->time_scale;\n\n    /* special codec parameters handling */\n    switch (st->codecpar->codec_id) {\n#if CONFIG_DV_DEMUXER\n    case AV_CODEC_ID_DVAUDIO:\n        c->dv_fctx = avformat_alloc_context();\n        if (!c->dv_fctx) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context alloc error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        c->dv_demux = avpriv_dv_init_demux(c->dv_fctx);\n        if (!c->dv_demux) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context init error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        sc->dv_audio_container = 1;\n        st->codecpar->codec_id    = AV_CODEC_ID_PCM_S16LE;\n        break;\n#endif\n    /* no ifdef since parameters are always those */\n    case AV_CODEC_ID_QCELP:\n        av_channel_layout_uninit(&st->codecpar->ch_layout);\n        st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;\n        // force sample rate for qcelp when not stored in mov\n        if (st->codecpar->codec_tag != MKTAG('Q','c','l','p'))\n            st->codecpar->sample_rate = 8000;\n        // FIXME: Why is the following needed for some files?\n        sc->samples_per_frame = 160;\n        if (!sc->bytes_per_frame)\n            sc->bytes_per_frame = 35;\n        break;\n    case AV_CODEC_ID_AMR_NB:\n        av_channel_layout_uninit(&st->codecpar->ch_layout);\n        st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;\n        /* force sample rate for amr, stsd in 3gp does not store sample rate */\n        st->codecpar->sample_rate = 8000;\n        break;\n    case AV_CODEC_ID_AMR_WB:\n        av_channel_layout_uninit(&st->codecpar->ch_layout);\n        st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;\n        st->codecpar->sample_rate = 16000;\n        break;\n    case AV_CODEC_ID_MP2:\n    case AV_CODEC_ID_MP3:\n        /* force type after stsd for m1a hdlr */\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        break;\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_ADPCM_MS:\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n    case AV_CODEC_ID_ILBC:\n    case AV_CODEC_ID_MACE3:\n    case AV_CODEC_ID_MACE6:\n    case AV_CODEC_ID_QDM2:\n        st->codecpar->block_align = sc->bytes_per_frame;\n        break;\n    case AV_CODEC_ID_ALAC:\n        if (st->codecpar->extradata_size == 36) {\n            int channel_count = AV_RB8(st->codecpar->extradata + 21);\n            if (st->codecpar->ch_layout.nb_channels != channel_count) {\n                av_channel_layout_uninit(&st->codecpar->ch_layout);\n                st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n                st->codecpar->ch_layout.nb_channels = channel_count;\n            }\n            st->codecpar->sample_rate = AV_RB32(st->codecpar->extradata + 32);\n        }\n        break;\n    case AV_CODEC_ID_AC3:\n    case AV_CODEC_ID_EAC3:\n    case AV_CODEC_ID_MPEG1VIDEO:\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_VP8:\n    case AV_CODEC_ID_VP9:\n        sti->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    case AV_CODEC_ID_AV1:\n        /* field_order detection of H264 requires parsing */\n    case AV_CODEC_ID_H264:\n        sti->need_parsing = AVSTREAM_PARSE_HEADERS;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic int mov_skip_multiple_stsd(MOVContext *c, AVIOContext *pb,\n                                  int codec_tag, int format,\n                                  int64_t size)\n{\n    if (codec_tag &&\n         (codec_tag != format &&\n          // AVID 1:1 samples with differing data format and codec tag exist\n          (codec_tag != AV_RL32(\"AV1x\") || format != AV_RL32(\"AVup\")) &&\n          // prores is allowed to have differing data format and codec tag\n          codec_tag != AV_RL32(\"apcn\") && codec_tag != AV_RL32(\"apch\") &&\n          // so is dv (sigh)\n          codec_tag != AV_RL32(\"dvpp\") && codec_tag != AV_RL32(\"dvcp\") &&\n          (c->fc->video_codec_id ? ff_codec_get_id(ff_codec_movvideo_tags, format) != c->fc->video_codec_id\n                                 : codec_tag != MKTAG('j','p','e','g')))) {\n        /* Multiple fourcc, we skip JPEG. This is not correct, we should\n         * export it as a separate AVStream but this needs a few changes\n         * in the MOV demuxer, patch welcome. */\n\n        av_log(c->fc, AV_LOG_WARNING, \"multiple fourcc not supported\\n\");\n        avio_skip(pb, size);\n        return 1;\n    }\n\n    return 0;\n}\n\nint ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int pseudo_stream_id;\n\n    av_assert0 (c->fc->nb_streams >= 1);\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (pseudo_stream_id = 0;\n         pseudo_stream_id < entries && !pb->eof_reached;\n         pseudo_stream_id++) {\n        //Parsing Sample description table\n        enum AVCodecID id;\n        int ret, dref_id = 1;\n        MOVAtom a = { AV_RL32(\"stsd\") };\n        int64_t start_pos = avio_tell(pb);\n        int64_t size    = avio_rb32(pb); /* size */\n        uint32_t format = avio_rl32(pb); /* data format */\n\n        if (size >= 16) {\n            avio_rb32(pb); /* reserved */\n            avio_rb16(pb); /* reserved */\n            dref_id = avio_rb16(pb);\n        } else if (size <= 7) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"invalid size %\"PRId64\" in stsd\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (mov_skip_multiple_stsd(c, pb, st->codecpar->codec_tag, format,\n                                   size - (avio_tell(pb) - start_pos))) {\n            sc->stsd_count++;\n            continue;\n        }\n\n        sc->pseudo_stream_id = st->codecpar->codec_tag ? -1 : pseudo_stream_id;\n        sc->dref_id= dref_id;\n        sc->format = format;\n\n        id = mov_codec_id(st, format);\n\n        av_log(c->fc, AV_LOG_TRACE,\n               \"size=%\"PRId64\" 4CC=%s codec_type=%d\\n\", size,\n               av_fourcc2str(format), st->codecpar->codec_type);\n\n        st->codecpar->codec_id = id;\n        if (st->codecpar->codec_type==AVMEDIA_TYPE_VIDEO) {\n            mov_parse_stsd_video(c, pb, st, sc);\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_AUDIO) {\n            mov_parse_stsd_audio(c, pb, st, sc);\n            if (st->codecpar->sample_rate < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n                return AVERROR_INVALIDDATA;\n            }\n            if (st->codecpar->ch_layout.nb_channels < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid channels %d\\n\", st->codecpar->ch_layout.nb_channels);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_SUBTITLE){\n            mov_parse_stsd_subtitle(c, pb, st, sc,\n                                    size - (avio_tell(pb) - start_pos));\n        } else {\n            ret = mov_parse_stsd_data(c, pb, st, sc,\n                                      size - (avio_tell(pb) - start_pos));\n            if (ret < 0)\n                return ret;\n        }\n        /* this will read extra atoms at the end (wave, alac, damr, avcC, hvcC, SMI ...) */\n        a.size = size - (avio_tell(pb) - start_pos);\n        if (a.size > 8) {\n            if ((ret = mov_read_default(c, pb, a)) < 0)\n                return ret;\n        } else if (a.size > 0)\n            avio_skip(pb, a.size);\n\n        if (sc->extradata && st->codecpar->extradata) {\n            int extra_size = st->codecpar->extradata_size;\n\n            /* Move the current stream extradata to the stream context one. */\n            sc->extradata_size[pseudo_stream_id] = extra_size;\n            sc->extradata[pseudo_stream_id] = st->codecpar->extradata;\n            st->codecpar->extradata      = NULL;\n            st->codecpar->extradata_size = 0;\n        }\n        sc->stsd_count++;\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STSD atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    sc->stsd_version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    /* Each entry contains a size (4 bytes) and format (4 bytes). */\n    if (entries <= 0 || entries > atom.size / 8 || entries > 1024) {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid STSD entries %d\\n\", entries);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->extradata) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Duplicate stsd found in this track.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* Prepare space for hosting multiple extradata. */\n    sc->extradata = av_calloc(entries, sizeof(*sc->extradata));\n    if (!sc->extradata)\n        return AVERROR(ENOMEM);\n\n    sc->extradata_size = av_calloc(entries, sizeof(*sc->extradata_size));\n    if (!sc->extradata_size) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = ff_mov_read_stsd_entries(c, pb, entries);\n    if (ret < 0)\n        goto fail;\n\n    /* Restore back the primary extradata. */\n    av_freep(&st->codecpar->extradata);\n    st->codecpar->extradata_size = sc->extradata_size[0];\n    if (sc->extradata_size[0]) {\n        st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!st->codecpar->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);\n    }\n\n    return mov_finalize_stsd_codec(c, pb, st, sc);\nfail:\n    if (sc->extradata) {\n        int j;\n        for (j = 0; j < sc->stsd_count; j++)\n            av_freep(&sc->extradata[j]);\n    }\n\n    av_freep(&sc->extradata);\n    av_freep(&sc->extradata_size);\n    return ret;\n}\n\nstatic int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n    if ((uint64_t)entries * 12 + 4 > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stsc.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (sc->stsc_data) {\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicated STSC atom\\n\");\n        return 0;\n    }\n    av_free(sc->stsc_data);\n    sc->stsc_count = 0;\n    sc->stsc_data = av_malloc_array(entries, sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stsc_data[i].first = avio_rb32(pb);\n        sc->stsc_data[i].count = avio_rb32(pb);\n        sc->stsc_data[i].id = avio_rb32(pb);\n    }\n\n    sc->stsc_count = i;\n    for (i = sc->stsc_count - 1; i < UINT_MAX; i--) {\n        int64_t first_min = i + 1;\n        if ((i+1 < sc->stsc_count && sc->stsc_data[i].first >= sc->stsc_data[i+1].first) ||\n            (i > 0 && sc->stsc_data[i].first <= sc->stsc_data[i-1].first) ||\n            sc->stsc_data[i].first < first_min ||\n            sc->stsc_data[i].count < 1 ||\n            sc->stsc_data[i].id < 1) {\n            av_log(c->fc, AV_LOG_WARNING, \"STSC entry %d is invalid (first=%d count=%d id=%d)\\n\", i, sc->stsc_data[i].first, sc->stsc_data[i].count, sc->stsc_data[i].id);\n            if (i+1 >= sc->stsc_count) {\n                if (sc->stsc_data[i].count == 0 && i > 0) {\n                    sc->stsc_count --;\n                    continue;\n                }\n                sc->stsc_data[i].first = FFMAX(sc->stsc_data[i].first, first_min);\n                if (i > 0 && sc->stsc_data[i].first <= sc->stsc_data[i-1].first)\n                    sc->stsc_data[i].first = FFMIN(sc->stsc_data[i-1].first + 1LL, INT_MAX);\n                sc->stsc_data[i].count = FFMAX(sc->stsc_data[i].count, 1);\n                sc->stsc_data[i].id    = FFMAX(sc->stsc_data[i].id, 1);\n                continue;\n            }\n            av_assert0(sc->stsc_data[i+1].first >= 2);\n            // We replace this entry by the next valid\n            sc->stsc_data[i].first = sc->stsc_data[i+1].first - 1;\n            sc->stsc_data[i].count = sc->stsc_data[i+1].count;\n            sc->stsc_data[i].id    = sc->stsc_data[i+1].id;\n        }\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STSC atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic inline int mov_stsc_index_valid(unsigned int index, unsigned int count)\n{\n    return index < count - 1;\n}\n\n/* Compute the samples value for the stsc entry at the given index. */\nstatic inline int64_t mov_get_stsc_samples(MOVStreamContext *sc, unsigned int index)\n{\n    int chunk_count;\n\n    if (mov_stsc_index_valid(index, sc->stsc_count))\n        chunk_count = sc->stsc_data[index + 1].first - sc->stsc_data[index].first;\n    else {\n        // Validation for stsc / stco  happens earlier in mov_read_stsc + mov_read_trak.\n        av_assert0(sc->stsc_data[index].first <= sc->chunk_count);\n        chunk_count = sc->chunk_count - (sc->stsc_data[index].first - 1);\n    }\n\n    return sc->stsc_data[index].count * (int64_t)chunk_count;\n}\n\nstatic int mov_read_stps(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n\n    entries = avio_rb32(pb);\n    if (sc->stps_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STPS atom\\n\");\n    av_free(sc->stps_data);\n    sc->stps_count = 0;\n    sc->stps_data = av_malloc_array(entries, sizeof(*sc->stps_data));\n    if (!sc->stps_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stps_data[i] = avio_rb32(pb);\n    }\n\n    sc->stps_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STPS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    FFStream *sti;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sti = ffstream(st);\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"keyframe_count = %u\\n\", entries);\n\n    if (!entries) {\n        sc->keyframe_absent = 1;\n        if (!sti->need_parsing && st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n            sti->need_parsing = AVSTREAM_PARSE_HEADERS;\n        return 0;\n    }\n    if (sc->keyframes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSS atom\\n\");\n    if (entries >= UINT_MAX / sizeof(int))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->keyframes);\n    sc->keyframe_count = 0;\n    sc->keyframes = av_malloc_array(entries, sizeof(*sc->keyframes));\n    if (!sc->keyframes)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->keyframes[i] = avio_rb32(pb);\n    }\n\n    sc->keyframe_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STSS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, sample_size, field_size, num_bytes;\n    GetBitContext gb;\n    unsigned char* buf;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (atom.type == MKTAG('s','t','s','z')) {\n        sample_size = avio_rb32(pb);\n        if (!sc->sample_size) /* do not overwrite value computed in stsd */\n            sc->sample_size = sample_size;\n        sc->stsz_sample_size = sample_size;\n        field_size = 32;\n    } else {\n        sample_size = 0;\n        avio_rb24(pb); /* reserved */\n        field_size = avio_r8(pb);\n    }\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"sample_size = %u sample_count = %u\\n\", sc->sample_size, entries);\n\n    sc->sample_count = entries;\n    if (sample_size)\n        return 0;\n\n    if (field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample field size %u\\n\", field_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!entries)\n        return 0;\n    if (entries >= (INT_MAX - 4 - 8 * AV_INPUT_BUFFER_PADDING_SIZE) / field_size)\n        return AVERROR_INVALIDDATA;\n    if (sc->sample_sizes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSZ atom\\n\");\n    av_free(sc->sample_sizes);\n    sc->sample_count = 0;\n    sc->sample_sizes = av_malloc_array(entries, sizeof(*sc->sample_sizes));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n\n    num_bytes = (entries*field_size+4)>>3;\n\n    buf = av_malloc(num_bytes+AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        av_freep(&sc->sample_sizes);\n        return AVERROR(ENOMEM);\n    }\n\n    ret = ffio_read_size(pb, buf, num_bytes);\n    if (ret < 0) {\n        av_freep(&sc->sample_sizes);\n        av_free(buf);\n        av_log(c->fc, AV_LOG_WARNING, \"STSZ atom truncated\\n\");\n        return 0;\n    }\n\n    init_get_bits(&gb, buf, 8*num_bytes);\n\n    for (i = 0; i < entries; i++) {\n        sc->sample_sizes[i] = get_bits_long(&gb, field_size);\n        if (sc->sample_sizes[i] < 0) {\n            av_free(buf);\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid sample size %d\\n\", sc->sample_sizes[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        sc->data_size += sc->sample_sizes[i];\n    }\n\n    sc->sample_count = i;\n\n    av_free(buf);\n\n    return 0;\n}\n\nstatic int mov_read_stts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, alloc_size = 0;\n    int64_t duration = 0;\n    int64_t total_sample_count = 0;\n    int64_t current_dts = 0;\n    int64_t corrected_dts = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stts.entries = %u\\n\",\n            c->fc->nb_streams-1, entries);\n\n    if (sc->stts_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STTS atom\\n\");\n    av_freep(&sc->stts_data);\n    sc->stts_count = 0;\n    if (entries >= INT_MAX / sizeof(*sc->stts_data))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned int sample_duration;\n        unsigned int sample_count;\n        unsigned int min_entries = FFMIN(FFMAX(i + 1, 1024 * 1024), entries);\n        MOVStts *stts_data = av_fast_realloc(sc->stts_data, &alloc_size,\n                                             min_entries * sizeof(*sc->stts_data));\n        if (!stts_data) {\n            av_freep(&sc->stts_data);\n            sc->stts_count = 0;\n            return AVERROR(ENOMEM);\n        }\n        sc->stts_count = min_entries;\n        sc->stts_data = stts_data;\n\n        sample_count    = avio_rb32(pb);\n        sample_duration = avio_rb32(pb);\n\n        sc->stts_data[i].count= sample_count;\n        sc->stts_data[i].duration= sample_duration;\n\n        av_log(c->fc, AV_LOG_TRACE, \"sample_count=%u, sample_duration=%u\\n\",\n                sample_count, sample_duration);\n\n        /* STTS sample offsets are uint32 but some files store it as int32\n         * with negative values used to correct DTS delays.\n           There may be abnormally large values as well. */\n        if (sample_duration > c->max_stts_delta) {\n            // assume high delta is a correction if negative when cast as int32\n            int32_t delta_magnitude = (int32_t)sample_duration;\n            av_log(c->fc, AV_LOG_WARNING, \"Too large sample offset %u in stts entry %u with count %u in st:%d. Clipping to 1.\\n\",\n                   sample_duration, i, sample_count, st->index);\n            sc->stts_data[i].duration = 1;\n            corrected_dts += (delta_magnitude < 0 ? (int64_t)delta_magnitude : 1) * sample_count;\n        } else {\n            corrected_dts += sample_duration * sample_count;\n        }\n\n        current_dts += sc->stts_data[i].duration * sample_count;\n\n        if (current_dts > corrected_dts) {\n            int64_t drift = (current_dts - corrected_dts)/FFMAX(sample_count, 1);\n            uint32_t correction = (sc->stts_data[i].duration > drift) ? drift : sc->stts_data[i].duration - 1;\n            current_dts -= correction * sample_count;\n            sc->stts_data[i].duration -= correction;\n        }\n\n        duration+=(int64_t)sc->stts_data[i].duration*(uint64_t)sc->stts_data[i].count;\n        total_sample_count+=sc->stts_data[i].count;\n    }\n\n    sc->stts_count = i;\n\n    if (duration > 0 &&\n        duration <= INT64_MAX - sc->duration_for_fps &&\n        total_sample_count <= INT_MAX - sc->nb_frames_for_fps) {\n        sc->duration_for_fps  += duration;\n        sc->nb_frames_for_fps += total_sample_count;\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STTS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    st->nb_frames= total_sample_count;\n    if (duration)\n        st->duration= FFMIN(st->duration, duration);\n\n    // All samples have zero duration. They have higher chance be chose by\n    // mov_find_next_sample, which leads to seek again and again.\n    //\n    // It's AVERROR_INVALIDDATA actually, but such files exist in the wild.\n    // So only mark data stream as discarded for safety.\n    if (!duration && sc->stts_count &&\n            st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"All samples in data stream index:id [%d:%d] have zero \"\n               \"duration, stream set to be discarded by default. Override \"\n               \"using AVStream->discard or -discard for ffmpeg command.\\n\",\n               st->index, st->id);\n        st->discard = AVDISCARD_ALL;\n    }\n    sc->track_end = duration;\n    return 0;\n}\n\nstatic int mov_read_sdtp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = atom.size - 4;\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].sdtp.entries = %\" PRId64 \"\\n\",\n           c->fc->nb_streams - 1, entries);\n\n    if (sc->sdtp_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated SDTP atom\\n\");\n    av_freep(&sc->sdtp_data);\n    sc->sdtp_count = 0;\n\n    sc->sdtp_data = av_malloc(entries);\n    if (!sc->sdtp_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++)\n        sc->sdtp_data[i] = avio_r8(pb);\n    sc->sdtp_count = i;\n\n    return 0;\n}\n\nstatic void mov_update_dts_shift(MOVStreamContext *sc, int duration, void *logctx)\n{\n    if (duration < 0) {\n        if (duration == INT_MIN) {\n            av_log(logctx, AV_LOG_WARNING, \"mov_update_dts_shift(): dts_shift set to %d\\n\", INT_MAX);\n            duration++;\n        }\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n    }\n}\n\nstatic int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, ctts_count = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].ctts.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->ctts_data);\n    sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int count    = avio_rb32(pb);\n        int duration = avio_rb32(pb);\n\n        if (count <= 0) {\n            av_log(c->fc, AV_LOG_TRACE,\n                   \"ignoring CTTS entry with count=%d duration=%d\\n\",\n                   count, duration);\n            continue;\n        }\n\n        add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size,\n                       count, duration);\n\n        av_log(c->fc, AV_LOG_TRACE, \"count=%d, duration=%d\\n\",\n                count, duration);\n\n        if (FFNABS(duration) < -(1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (i+2<entries)\n            mov_update_dts_shift(sc, duration, c->fc);\n    }\n\n    sc->ctts_count = ctts_count;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted CTTS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    av_log(c->fc, AV_LOG_TRACE, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}\n\nstatic int mov_read_sgpd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    uint8_t version;\n    uint32_t grouping_type;\n    uint32_t default_length;\n    av_unused uint32_t default_group_description_index;\n    uint32_t entry_count;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    grouping_type = avio_rl32(pb);\n\n    /*\n     * This function only supports \"sync\" boxes, but the code is able to parse\n     * other boxes (such as \"tscl\", \"tsas\" and \"stsa\")\n     */\n    if (grouping_type != MKTAG('s','y','n','c'))\n        return 0;\n\n    default_length = version >= 1 ? avio_rb32(pb) : 0;\n    default_group_description_index = version >= 2 ? avio_rb32(pb) : 0;\n    entry_count = avio_rb32(pb);\n\n    av_freep(&sc->sgpd_sync);\n    sc->sgpd_sync_count = entry_count;\n    sc->sgpd_sync = av_calloc(entry_count, sizeof(*sc->sgpd_sync));\n    if (!sc->sgpd_sync)\n        return AVERROR(ENOMEM);\n\n    for (uint32_t i = 0; i < entry_count && !pb->eof_reached; i++) {\n        uint32_t description_length = default_length;\n        if (version >= 1 && default_length == 0)\n            description_length = avio_rb32(pb);\n        if (grouping_type == MKTAG('s','y','n','c')) {\n            const uint8_t nal_unit_type = avio_r8(pb) & 0x3f;\n            sc->sgpd_sync[i] = nal_unit_type;\n            description_length -= 1;\n        }\n        avio_skip(pb, description_length);\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted SGPD atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_sbgp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    uint8_t version;\n    uint32_t grouping_type;\n    MOVSbgp *table, **tablep;\n    int *table_count;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    grouping_type = avio_rl32(pb);\n\n    if (grouping_type == MKTAG('r','a','p',' ')) {\n        tablep = &sc->rap_group;\n        table_count = &sc->rap_group_count;\n    } else if (grouping_type == MKTAG('s','y','n','c')) {\n        tablep = &sc->sync_group;\n        table_count = &sc->sync_group_count;\n    } else {\n        return 0;\n    }\n\n    if (version == 1)\n        avio_rb32(pb); /* grouping_type_parameter */\n\n    entries = avio_rb32(pb);\n    if (!entries)\n        return 0;\n    if (*tablep)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated SBGP %s atom\\n\", av_fourcc2str(grouping_type));\n    av_freep(tablep);\n    table = av_malloc_array(entries, sizeof(*table));\n    if (!table)\n        return AVERROR(ENOMEM);\n    *tablep = table;\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        table[i].count = avio_rb32(pb); /* sample_count */\n        table[i].index = avio_rb32(pb); /* group_description_index */\n    }\n\n    *table_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted SBGP atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\n/**\n * Get ith edit list entry (media time, duration).\n */\nstatic int get_edit_list_entry(MOVContext *mov,\n                               const MOVStreamContext *msc,\n                               unsigned int edit_list_index,\n                               int64_t *edit_list_media_time,\n                               int64_t *edit_list_duration,\n                               int64_t global_timescale)\n{\n    if (edit_list_index == msc->elst_count) {\n        return 0;\n    }\n    *edit_list_media_time = msc->elst_data[edit_list_index].time;\n    *edit_list_duration = msc->elst_data[edit_list_index].duration;\n\n    /* duration is in global timescale units;convert to msc timescale */\n    if (global_timescale == 0) {\n      avpriv_request_sample(mov->fc, \"Support for mvhd.timescale = 0 with editlists\");\n      return 0;\n    }\n    *edit_list_duration = av_rescale(*edit_list_duration, msc->time_scale,\n                                     global_timescale);\n    return 1;\n}\n\n/**\n * Find the closest previous frame to the timestamp_pts, in e_old index\n * entries. Searching for just any frame / just key frames can be controlled by\n * last argument 'flag'.\n * Note that if ctts_data is not NULL, we will always search for a key frame\n * irrespective of the value of 'flag'. If we don't find any keyframe, we will\n * return the first frame of the video.\n *\n * Here the timestamp_pts is considered to be a presentation timestamp and\n * the timestamp of index entries are considered to be decoding timestamps.\n *\n * Returns 0 if successful in finding a frame, else returns -1.\n * Places the found index corresponding output arg.\n *\n * If ctts_old is not NULL, then refines the searched entry by searching\n * backwards from the found timestamp, to find the frame with correct PTS.\n *\n * Places the found ctts_index and ctts_sample in corresponding output args.\n */\nstatic int find_prev_closest_index(AVStream *st,\n                                   AVIndexEntry *e_old,\n                                   int nb_old,\n                                   MOVCtts* ctts_data,\n                                   int64_t ctts_count,\n                                   int64_t timestamp_pts,\n                                   int flag,\n                                   int64_t* index,\n                                   int64_t* ctts_index,\n                                   int64_t* ctts_sample)\n{\n    MOVStreamContext *msc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    AVIndexEntry *e_keep = sti->index_entries;\n    int nb_keep = sti->nb_index_entries;\n    int64_t i = 0;\n    int64_t index_ctts_count;\n\n    av_assert0(index);\n\n    // If dts_shift > 0, then all the index timestamps will have to be offset by\n    // at least dts_shift amount to obtain PTS.\n    // Hence we decrement the searched timestamp_pts by dts_shift to find the closest index element.\n    if (msc->dts_shift > 0) {\n        timestamp_pts -= msc->dts_shift;\n    }\n\n    sti->index_entries    = e_old;\n    sti->nb_index_entries = nb_old;\n    *index = av_index_search_timestamp(st, timestamp_pts, flag | AVSEEK_FLAG_BACKWARD);\n\n    // Keep going backwards in the index entries until the timestamp is the same.\n    if (*index >= 0) {\n        for (i = *index; i > 0 && e_old[i].timestamp == e_old[i - 1].timestamp;\n             i--) {\n            if ((flag & AVSEEK_FLAG_ANY) ||\n                (e_old[i - 1].flags & AVINDEX_KEYFRAME)) {\n                *index = i - 1;\n            }\n        }\n    }\n\n    // If we have CTTS then refine the search, by searching backwards over PTS\n    // computed by adding corresponding CTTS durations to index timestamps.\n    if (ctts_data && *index >= 0) {\n        av_assert0(ctts_index);\n        av_assert0(ctts_sample);\n        // Find out the ctts_index for the found frame.\n        *ctts_index = 0;\n        *ctts_sample = 0;\n        for (index_ctts_count = 0; index_ctts_count < *index; index_ctts_count++) {\n            if (*ctts_index < ctts_count) {\n                (*ctts_sample)++;\n                if (ctts_data[*ctts_index].count == *ctts_sample) {\n                    (*ctts_index)++;\n                    *ctts_sample = 0;\n                }\n            }\n        }\n\n        while (*index >= 0 && (*ctts_index) >= 0 && (*ctts_index) < ctts_count) {\n            // Find a \"key frame\" with PTS <= timestamp_pts (So that we can decode B-frames correctly).\n            // No need to add dts_shift to the timestamp here becase timestamp_pts has already been\n            // compensated by dts_shift above.\n            if ((e_old[*index].timestamp + ctts_data[*ctts_index].duration) <= timestamp_pts &&\n                (e_old[*index].flags & AVINDEX_KEYFRAME)) {\n                break;\n            }\n\n            (*index)--;\n            if (*ctts_sample == 0) {\n                (*ctts_index)--;\n                if (*ctts_index >= 0)\n                  *ctts_sample = ctts_data[*ctts_index].count - 1;\n            } else {\n                (*ctts_sample)--;\n            }\n        }\n    }\n\n    /* restore AVStream state*/\n    sti->index_entries    = e_keep;\n    sti->nb_index_entries = nb_keep;\n    return *index >= 0 ? 0 : -1;\n}\n\n/**\n * Add index entry with the given values, to the end of ffstream(st)->index_entries.\n * Returns the new size ffstream(st)->index_entries if successful, else returns -1.\n *\n * This function is similar to ff_add_index_entry in libavformat/utils.c\n * except that here we are always unconditionally adding an index entry to\n * the end, instead of searching the entries list and skipping the add if\n * there is an existing entry with the same timestamp.\n * This is needed because the mov_fix_index calls this func with the same\n * unincremented timestamp for successive discarded frames.\n */\nstatic int64_t add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,\n                               int size, int distance, int flags)\n{\n    FFStream *const sti = ffstream(st);\n    AVIndexEntry *entries, *ie;\n    int64_t index = -1;\n    const size_t min_size_needed = (sti->nb_index_entries + 1) * sizeof(AVIndexEntry);\n\n    // Double the allocation each time, to lower memory fragmentation.\n    // Another difference from ff_add_index_entry function.\n    const size_t requested_size =\n        min_size_needed > sti->index_entries_allocated_size ?\n        FFMAX(min_size_needed, 2 * sti->index_entries_allocated_size) :\n        min_size_needed;\n\n    if (sti->nb_index_entries + 1U >= UINT_MAX / sizeof(AVIndexEntry))\n        return -1;\n\n    entries = av_fast_realloc(sti->index_entries,\n                              &sti->index_entries_allocated_size,\n                              requested_size);\n    if (!entries)\n        return -1;\n\n    sti->index_entries = entries;\n\n    index = sti->nb_index_entries++;\n    ie= &entries[index];\n\n    ie->pos = pos;\n    ie->timestamp = timestamp;\n    ie->min_distance= distance;\n    ie->size= size;\n    ie->flags = flags;\n    return index;\n}\n\n/**\n * Rewrite timestamps of index entries in the range [end_index - frame_duration_buffer_size, end_index)\n * by subtracting end_ts successively by the amounts given in frame_duration_buffer.\n */\nstatic void fix_index_entry_timestamps(AVStream* st, int end_index, int64_t end_ts,\n                                       int64_t* frame_duration_buffer,\n                                       int frame_duration_buffer_size) {\n    FFStream *const sti = ffstream(st);\n    int i = 0;\n    av_assert0(end_index >= 0 && end_index <= sti->nb_index_entries);\n    for (i = 0; i < frame_duration_buffer_size; i++) {\n        end_ts -= frame_duration_buffer[frame_duration_buffer_size - 1 - i];\n        sti->index_entries[end_index - 1 - i].timestamp = end_ts;\n    }\n}\n\n/**\n * Append a new ctts entry to ctts_data.\n * Returns the new ctts_count if successful, else returns -1.\n */\nstatic int64_t add_ctts_entry(MOVCtts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration)\n{\n    MOVCtts *ctts_buf_new;\n    const size_t min_size_needed = (*ctts_count + 1) * sizeof(MOVCtts);\n    const size_t requested_size =\n        min_size_needed > *allocated_size ?\n        FFMAX(min_size_needed, 2 * (*allocated_size)) :\n        min_size_needed;\n\n    if ((unsigned)(*ctts_count) >= UINT_MAX / sizeof(MOVCtts) - 1)\n        return -1;\n\n    ctts_buf_new = av_fast_realloc(*ctts_data, allocated_size, requested_size);\n\n    if (!ctts_buf_new)\n        return -1;\n\n    *ctts_data = ctts_buf_new;\n\n    ctts_buf_new[*ctts_count].count = count;\n    ctts_buf_new[*ctts_count].duration = duration;\n\n    *ctts_count = (*ctts_count) + 1;\n    return *ctts_count;\n}\n\n#define MAX_REORDER_DELAY 16\nstatic void mov_estimate_video_delay(MOVContext *c, AVStream* st)\n{\n    MOVStreamContext *msc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int ctts_ind = 0;\n    int ctts_sample = 0;\n    int64_t pts_buf[MAX_REORDER_DELAY + 1]; // Circular buffer to sort pts.\n    int buf_start = 0;\n    int j, r, num_swaps;\n\n    for (j = 0; j < MAX_REORDER_DELAY + 1; j++)\n        pts_buf[j] = INT64_MIN;\n\n    if (st->codecpar->video_delay <= 0 && msc->ctts_data &&\n        st->codecpar->codec_id == AV_CODEC_ID_H264) {\n        st->codecpar->video_delay = 0;\n        for (int ind = 0; ind < sti->nb_index_entries && ctts_ind < msc->ctts_count; ++ind) {\n            // Point j to the last elem of the buffer and insert the current pts there.\n            j = buf_start;\n            buf_start = (buf_start + 1);\n            if (buf_start == MAX_REORDER_DELAY + 1)\n                buf_start = 0;\n\n            pts_buf[j] = sti->index_entries[ind].timestamp + msc->ctts_data[ctts_ind].duration;\n\n            // The timestamps that are already in the sorted buffer, and are greater than the\n            // current pts, are exactly the timestamps that need to be buffered to output PTS\n            // in correct sorted order.\n            // Hence the video delay (which is the buffer size used to sort DTS and output PTS),\n            // can be computed as the maximum no. of swaps any particular timestamp needs to\n            // go through, to keep this buffer in sorted order.\n            num_swaps = 0;\n            while (j != buf_start) {\n                r = j - 1;\n                if (r < 0) r = MAX_REORDER_DELAY;\n                if (pts_buf[j] < pts_buf[r]) {\n                    FFSWAP(int64_t, pts_buf[j], pts_buf[r]);\n                    ++num_swaps;\n                } else {\n                    break;\n                }\n                j = r;\n            }\n            st->codecpar->video_delay = FFMAX(st->codecpar->video_delay, num_swaps);\n\n            ctts_sample++;\n            if (ctts_sample == msc->ctts_data[ctts_ind].count) {\n                ctts_ind++;\n                ctts_sample = 0;\n            }\n        }\n        av_log(c->fc, AV_LOG_DEBUG, \"Setting codecpar->delay to %d for stream st: %d\\n\",\n               st->codecpar->video_delay, st->index);\n    }\n}\n\nstatic void mov_current_sample_inc(MOVStreamContext *sc)\n{\n    sc->current_sample++;\n    sc->current_index++;\n    if (sc->index_ranges &&\n        sc->current_index >= sc->current_index_range->end &&\n        sc->current_index_range->end) {\n        sc->current_index_range++;\n        sc->current_index = sc->current_index_range->start;\n    }\n}\n\nstatic void mov_current_sample_dec(MOVStreamContext *sc)\n{\n    sc->current_sample--;\n    sc->current_index--;\n    if (sc->index_ranges &&\n        sc->current_index < sc->current_index_range->start &&\n        sc->current_index_range > sc->index_ranges) {\n        sc->current_index_range--;\n        sc->current_index = sc->current_index_range->end - 1;\n    }\n}\n\nstatic void mov_current_sample_set(MOVStreamContext *sc, int current_sample)\n{\n    int64_t range_size;\n\n    sc->current_sample = current_sample;\n    sc->current_index = current_sample;\n    if (!sc->index_ranges) {\n        return;\n    }\n\n    for (sc->current_index_range = sc->index_ranges;\n        sc->current_index_range->end;\n        sc->current_index_range++) {\n        range_size = sc->current_index_range->end - sc->current_index_range->start;\n        if (range_size > current_sample) {\n            sc->current_index = sc->current_index_range->start + current_sample;\n            break;\n        }\n        current_sample -= range_size;\n    }\n}\n\n/**\n * Fix ffstream(st)->index_entries, so that it contains only the entries (and the entries\n * which are needed to decode them) that fall in the edit list time ranges.\n * Also fixes the timestamps of the index entries to match the timeline\n * specified the edit lists.\n */\nstatic void mov_fix_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *msc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    AVIndexEntry *e_old = sti->index_entries;\n    int nb_old = sti->nb_index_entries;\n    const AVIndexEntry *e_old_end = e_old + nb_old;\n    const AVIndexEntry *current = NULL;\n    MOVCtts *ctts_data_old = msc->ctts_data;\n    int64_t ctts_index_old = 0;\n    int64_t ctts_sample_old = 0;\n    int64_t ctts_count_old = msc->ctts_count;\n    int64_t edit_list_media_time = 0;\n    int64_t edit_list_duration = 0;\n    int64_t frame_duration = 0;\n    int64_t edit_list_dts_counter = 0;\n    int64_t edit_list_dts_entry_end = 0;\n    int64_t edit_list_start_ctts_sample = 0;\n    int64_t curr_cts;\n    int64_t curr_ctts = 0;\n    int64_t empty_edits_sum_duration = 0;\n    int64_t edit_list_index = 0;\n    int64_t index;\n    int flags;\n    int64_t start_dts = 0;\n    int64_t edit_list_start_encountered = 0;\n    int64_t search_timestamp = 0;\n    int64_t* frame_duration_buffer = NULL;\n    int num_discarded_begin = 0;\n    int first_non_zero_audio_edit = -1;\n    int packet_skip_samples = 0;\n    MOVIndexRange *current_index_range;\n    int found_keyframe_after_edit = 0;\n    int found_non_empty_edit = 0;\n\n    if (!msc->elst_data || msc->elst_count <= 0 || nb_old <= 0) {\n        return;\n    }\n\n    // allocate the index ranges array\n    msc->index_ranges = av_malloc((msc->elst_count + 1) * sizeof(msc->index_ranges[0]));\n    if (!msc->index_ranges) {\n        av_log(mov->fc, AV_LOG_ERROR, \"Cannot allocate index ranges buffer\\n\");\n        return;\n    }\n    msc->current_index_range = msc->index_ranges;\n    current_index_range = msc->index_ranges - 1;\n\n    // Clean AVStream from traces of old index\n    sti->index_entries = NULL;\n    sti->index_entries_allocated_size = 0;\n    sti->nb_index_entries = 0;\n\n    // Clean ctts fields of MOVStreamContext\n    msc->ctts_data = NULL;\n    msc->ctts_count = 0;\n    msc->ctts_index = 0;\n    msc->ctts_sample = 0;\n    msc->ctts_allocated_size = 0;\n\n    // Reinitialize min_corrected_pts so that it can be computed again.\n    msc->min_corrected_pts = -1;\n\n    // If the dts_shift is positive (in case of negative ctts values in mov),\n    // then negate the DTS by dts_shift\n    if (msc->dts_shift > 0) {\n        edit_list_dts_entry_end -= msc->dts_shift;\n        av_log(mov->fc, AV_LOG_DEBUG, \"Shifting DTS by %d because of negative CTTS.\\n\", msc->dts_shift);\n    }\n\n    start_dts = edit_list_dts_entry_end;\n\n    while (get_edit_list_entry(mov, msc, edit_list_index, &edit_list_media_time,\n                               &edit_list_duration, mov->time_scale)) {\n        av_log(mov->fc, AV_LOG_DEBUG, \"Processing st: %d, edit list %\"PRId64\" - media time: %\"PRId64\", duration: %\"PRId64\"\\n\",\n               st->index, edit_list_index, edit_list_media_time, edit_list_duration);\n        edit_list_index++;\n        edit_list_dts_counter = edit_list_dts_entry_end;\n        edit_list_dts_entry_end += edit_list_duration;\n        num_discarded_begin = 0;\n        if (!found_non_empty_edit && edit_list_media_time == -1) {\n            empty_edits_sum_duration += edit_list_duration;\n            continue;\n        }\n        found_non_empty_edit = 1;\n\n        // If we encounter a non-negative edit list reset the skip_samples/start_pad fields and set them\n        // according to the edit list below.\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            if (first_non_zero_audio_edit < 0) {\n                first_non_zero_audio_edit = 1;\n            } else {\n                first_non_zero_audio_edit = 0;\n            }\n\n            if (first_non_zero_audio_edit > 0)\n                sti->skip_samples = msc->start_pad = 0;\n        }\n\n        // While reordering frame index according to edit list we must handle properly\n        // the scenario when edit list entry starts from none key frame.\n        // We find closest previous key frame and preserve it and consequent frames in index.\n        // All frames which are outside edit list entry time boundaries will be dropped after decoding.\n        search_timestamp = edit_list_media_time;\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            // Audio decoders like AAC need need a decoder delay samples previous to the current sample,\n            // to correctly decode this frame. Hence for audio we seek to a frame 1 sec. before the\n            // edit_list_media_time to cover the decoder delay.\n            search_timestamp = FFMAX(search_timestamp - msc->time_scale, e_old[0].timestamp);\n        }\n\n        if (find_prev_closest_index(st, e_old, nb_old, ctts_data_old, ctts_count_old, search_timestamp, 0,\n                                    &index, &ctts_index_old, &ctts_sample_old) < 0) {\n            av_log(mov->fc, AV_LOG_WARNING,\n                   \"st: %d edit list: %\"PRId64\" Missing key frame while searching for timestamp: %\"PRId64\"\\n\",\n                   st->index, edit_list_index, search_timestamp);\n            if (find_prev_closest_index(st, e_old, nb_old, ctts_data_old, ctts_count_old, search_timestamp, AVSEEK_FLAG_ANY,\n                                        &index, &ctts_index_old, &ctts_sample_old) < 0) {\n                av_log(mov->fc, AV_LOG_WARNING,\n                       \"st: %d edit list %\"PRId64\" Cannot find an index entry before timestamp: %\"PRId64\".\\n\",\n                       st->index, edit_list_index, search_timestamp);\n                index = 0;\n                ctts_index_old = 0;\n                ctts_sample_old = 0;\n            }\n        }\n        current = e_old + index;\n        edit_list_start_ctts_sample = ctts_sample_old;\n\n        // Iterate over index and arrange it according to edit list\n        edit_list_start_encountered = 0;\n        found_keyframe_after_edit = 0;\n        for (; current < e_old_end; current++, index++) {\n            // check  if frame outside edit list mark it for discard\n            frame_duration = (current + 1 <  e_old_end) ?\n                             ((current + 1)->timestamp - current->timestamp) : edit_list_duration;\n\n            flags = current->flags;\n\n            // frames (pts) before or after edit list\n            curr_cts = current->timestamp + msc->dts_shift;\n            curr_ctts = 0;\n\n            if (ctts_data_old && ctts_index_old < ctts_count_old) {\n                curr_ctts = ctts_data_old[ctts_index_old].duration;\n                av_log(mov->fc, AV_LOG_TRACE, \"stts: %\"PRId64\" ctts: %\"PRId64\", ctts_index: %\"PRId64\", ctts_count: %\"PRId64\"\\n\",\n                       curr_cts, curr_ctts, ctts_index_old, ctts_count_old);\n                curr_cts += curr_ctts;\n                ctts_sample_old++;\n                if (ctts_sample_old == ctts_data_old[ctts_index_old].count) {\n                    if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                       &msc->ctts_allocated_size,\n                                       ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                                       ctts_data_old[ctts_index_old].duration) == -1) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                               ctts_index_old,\n                               ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                               ctts_data_old[ctts_index_old].duration);\n                        break;\n                    }\n                    ctts_index_old++;\n                    ctts_sample_old = 0;\n                    edit_list_start_ctts_sample = 0;\n                }\n            }\n\n            if (curr_cts < edit_list_media_time || curr_cts >= (edit_list_duration + edit_list_media_time)) {\n                if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && st->codecpar->codec_id != AV_CODEC_ID_VORBIS &&\n                    curr_cts < edit_list_media_time && curr_cts + frame_duration > edit_list_media_time &&\n                    first_non_zero_audio_edit > 0) {\n                    packet_skip_samples = edit_list_media_time - curr_cts;\n                    sti->skip_samples += packet_skip_samples;\n\n                    // Shift the index entry timestamp by packet_skip_samples to be correct.\n                    edit_list_dts_counter -= packet_skip_samples;\n                    if (edit_list_start_encountered == 0)  {\n                        edit_list_start_encountered = 1;\n                        // Make timestamps strictly monotonically increasing for audio, by rewriting timestamps for\n                        // discarded packets.\n                        if (frame_duration_buffer) {\n                            fix_index_entry_timestamps(st, sti->nb_index_entries, edit_list_dts_counter,\n                                                       frame_duration_buffer, num_discarded_begin);\n                            av_freep(&frame_duration_buffer);\n                        }\n                    }\n\n                    av_log(mov->fc, AV_LOG_DEBUG, \"skip %d audio samples from curr_cts: %\"PRId64\"\\n\", packet_skip_samples, curr_cts);\n                } else {\n                    flags |= AVINDEX_DISCARD_FRAME;\n                    av_log(mov->fc, AV_LOG_DEBUG, \"drop a frame at curr_cts: %\"PRId64\" @ %\"PRId64\"\\n\", curr_cts, index);\n\n                    if (edit_list_start_encountered == 0) {\n                        num_discarded_begin++;\n                        frame_duration_buffer = av_realloc(frame_duration_buffer,\n                                                           num_discarded_begin * sizeof(int64_t));\n                        if (!frame_duration_buffer) {\n                            av_log(mov->fc, AV_LOG_ERROR, \"Cannot reallocate frame duration buffer\\n\");\n                            break;\n                        }\n                        frame_duration_buffer[num_discarded_begin - 1] = frame_duration;\n\n                        // Increment skip_samples for the first non-zero audio edit list\n                        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n                            first_non_zero_audio_edit > 0 && st->codecpar->codec_id != AV_CODEC_ID_VORBIS) {\n                            sti->skip_samples += frame_duration;\n                        }\n                    }\n                }\n            } else {\n                if (msc->min_corrected_pts < 0) {\n                    msc->min_corrected_pts = edit_list_dts_counter + curr_ctts + msc->dts_shift;\n                } else {\n                    msc->min_corrected_pts = FFMIN(msc->min_corrected_pts, edit_list_dts_counter + curr_ctts + msc->dts_shift);\n                }\n                if (edit_list_start_encountered == 0) {\n                    edit_list_start_encountered = 1;\n                    // Make timestamps strictly monotonically increasing by rewriting timestamps for\n                    // discarded packets.\n                    if (frame_duration_buffer) {\n                        fix_index_entry_timestamps(st, sti->nb_index_entries, edit_list_dts_counter,\n                                                   frame_duration_buffer, num_discarded_begin);\n                        av_freep(&frame_duration_buffer);\n                    }\n                }\n            }\n\n            if (add_index_entry(st, current->pos, edit_list_dts_counter, current->size,\n                                current->min_distance, flags) == -1) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot add index entry\\n\");\n                break;\n            }\n\n            // Update the index ranges array\n            if (current_index_range < msc->index_ranges || index != current_index_range->end) {\n                current_index_range++;\n                current_index_range->start = index;\n            }\n            current_index_range->end = index + 1;\n\n            // Only start incrementing DTS in frame_duration amounts, when we encounter a frame in edit list.\n            if (edit_list_start_encountered > 0) {\n                edit_list_dts_counter = edit_list_dts_counter + frame_duration;\n            }\n\n            // Break when found first key frame after edit entry completion\n            if ((curr_cts + frame_duration >= (edit_list_duration + edit_list_media_time)) &&\n                ((flags & AVINDEX_KEYFRAME) || ((st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)))) {\n                if (ctts_data_old) {\n                    // If we have CTTS and this is the first keyframe after edit elist,\n                    // wait for one more, because there might be trailing B-frames after this I-frame\n                    // that do belong to the edit.\n                    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO && found_keyframe_after_edit == 0) {\n                        found_keyframe_after_edit = 1;\n                        continue;\n                    }\n                    if (ctts_sample_old != 0) {\n                        if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                           &msc->ctts_allocated_size,\n                                           ctts_sample_old - edit_list_start_ctts_sample,\n                                           ctts_data_old[ctts_index_old].duration) == -1) {\n                            av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                                   ctts_index_old, ctts_sample_old - edit_list_start_ctts_sample,\n                                   ctts_data_old[ctts_index_old].duration);\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n    // If there are empty edits, then msc->min_corrected_pts might be positive\n    // intentionally. So we subtract the sum duration of emtpy edits here.\n    msc->min_corrected_pts -= empty_edits_sum_duration;\n\n    // If the minimum pts turns out to be greater than zero after fixing the index, then we subtract the\n    // dts by that amount to make the first pts zero.\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (msc->min_corrected_pts > 0) {\n            av_log(mov->fc, AV_LOG_DEBUG, \"Offset DTS by %\"PRId64\" to make first pts zero.\\n\", msc->min_corrected_pts);\n            for (int i = 0; i < sti->nb_index_entries; ++i)\n                sti->index_entries[i].timestamp -= msc->min_corrected_pts;\n        }\n    }\n    // Start time should be equal to zero or the duration of any empty edits.\n    st->start_time = empty_edits_sum_duration;\n\n    // Update av stream length, if it ends up shorter than the track's media duration\n    st->duration = FFMIN(st->duration, edit_list_dts_entry_end - start_dts);\n    msc->start_pad = sti->skip_samples;\n\n    // Free the old index and the old CTTS structures\n    av_free(e_old);\n    av_free(ctts_data_old);\n    av_freep(&frame_duration_buffer);\n\n    // Null terminate the index ranges array\n    current_index_range++;\n    current_index_range->start = 0;\n    current_index_range->end = 0;\n    msc->current_index = msc->index_ranges[0].start;\n}\n\nstatic uint32_t get_sgpd_sync_index(const MOVStreamContext *sc, int nal_unit_type)\n{\n    for (uint32_t i = 0; i < sc->sgpd_sync_count; i++)\n        if (sc->sgpd_sync[i] == HEVC_NAL_CRA_NUT)\n            return i + 1;\n    return 0;\n}\n\nstatic int build_open_gop_key_points(AVStream *st)\n{\n    int k;\n    int sample_id = 0;\n    uint32_t cra_index;\n    MOVStreamContext *sc = st->priv_data;\n\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)\n        return 0;\n\n    /* Build an unrolled index of the samples */\n    sc->sample_offsets_count = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        sc->sample_offsets_count += sc->ctts_data[i].count;\n    av_freep(&sc->sample_offsets);\n    sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));\n    if (!sc->sample_offsets)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        for (int j = 0; j < sc->ctts_data[i].count; j++)\n             sc->sample_offsets[k++] = sc->ctts_data[i].duration;\n\n    /* The following HEVC NAL type reveal the use of open GOP sync points\n     * (TODO: BLA types may also be concerned) */\n    cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT); /* Clean Random Access */\n    if (!cra_index)\n        return 0;\n\n    /* Build a list of open-GOP key samples */\n    sc->open_key_samples_count = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++)\n        if (sc->sync_group[i].index == cra_index)\n            sc->open_key_samples_count += sc->sync_group[i].count;\n    av_freep(&sc->open_key_samples);\n    sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));\n    if (!sc->open_key_samples)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++) {\n        const MOVSbgp *sg = &sc->sync_group[i];\n        if (sg->index == cra_index)\n            for (uint32_t j = 0; j < sg->count; j++)\n                sc->open_key_samples[k++] = sample_id;\n        sample_id += sg->count;\n    }\n\n    /* Identify the minimal time step between samples */\n    sc->min_sample_duration = UINT_MAX;\n    for (uint32_t i = 0; i < sc->stts_count; i++)\n        sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);\n\n    return 0;\n}\n\nstatic void mov_build_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int64_t current_offset;\n    int64_t current_dts = 0;\n    unsigned int stts_index = 0;\n    unsigned int stsc_index = 0;\n    unsigned int stss_index = 0;\n    unsigned int stps_index = 0;\n    unsigned int i, j;\n    uint64_t stream_size = 0;\n    MOVCtts *ctts_data_old = sc->ctts_data;\n    unsigned int ctts_count_old = sc->ctts_count;\n\n    int ret = build_open_gop_key_points(st);\n    if (ret < 0)\n        return;\n\n    if (sc->elst_count) {\n        int i, edit_start_index = 0, multiple_edits = 0;\n        int64_t empty_duration = 0; // empty duration of the first edit list entry\n        int64_t start_time = 0; // start time of the media\n\n        for (i = 0; i < sc->elst_count; i++) {\n            const MOVElst *e = &sc->elst_data[i];\n            if (i == 0 && e->time == -1) {\n                /* if empty, the first entry is the start time of the stream\n                 * relative to the presentation itself */\n                empty_duration = e->duration;\n                edit_start_index = 1;\n            } else if (i == edit_start_index && e->time >= 0) {\n                start_time = e->time;\n            } else {\n                multiple_edits = 1;\n            }\n        }\n\n        if (multiple_edits && !mov->advanced_editlist)\n            av_log(mov->fc, AV_LOG_WARNING, \"multiple edit list entries, \"\n                   \"Use -advanced_editlist to correctly decode otherwise \"\n                   \"a/v desync might occur\\n\");\n\n        /* adjust first dts according to edit list */\n        if ((empty_duration || start_time) && mov->time_scale > 0) {\n            if (empty_duration)\n                empty_duration = av_rescale(empty_duration, sc->time_scale, mov->time_scale);\n\n            if (av_sat_sub64(start_time, empty_duration) != start_time - (uint64_t)empty_duration)\n                av_log(mov->fc, AV_LOG_WARNING, \"start_time - empty_duration is not representable\\n\");\n\n            sc->time_offset = start_time -  (uint64_t)empty_duration;\n            sc->min_corrected_pts = start_time;\n            if (!mov->advanced_editlist)\n                current_dts = -sc->time_offset;\n        }\n\n        if (!multiple_edits && !mov->advanced_editlist &&\n            st->codecpar->codec_id == AV_CODEC_ID_AAC && start_time > 0)\n            sc->start_pad = start_time;\n    }\n\n    /* only use old uncompressed audio chunk demuxing when stts specifies it */\n    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n          sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {\n        unsigned int current_sample = 0;\n        unsigned int stts_sample = 0;\n        unsigned int sample_size;\n        unsigned int distance = 0;\n        unsigned int rap_group_index = 0;\n        unsigned int rap_group_sample = 0;\n        int rap_group_present = sc->rap_group_count && sc->rap_group;\n        int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_count && sc->stps_data[0] > 0);\n\n        current_dts -= sc->dts_shift;\n\n        if (!sc->sample_count || sti->nb_index_entries)\n            return;\n        if (sc->sample_count >= UINT_MAX / sizeof(*sti->index_entries) - sti->nb_index_entries)\n            return;\n        if (av_reallocp_array(&sti->index_entries,\n                              sti->nb_index_entries + sc->sample_count,\n                              sizeof(*sti->index_entries)) < 0) {\n            sti->nb_index_entries = 0;\n            return;\n        }\n        sti->index_entries_allocated_size = (sti->nb_index_entries + sc->sample_count) * sizeof(*sti->index_entries);\n\n        if (ctts_data_old) {\n            // Expand ctts entries such that we have a 1-1 mapping with samples\n            if (sc->sample_count >= UINT_MAX / sizeof(*sc->ctts_data))\n                return;\n            sc->ctts_count = 0;\n            sc->ctts_allocated_size = 0;\n            sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size,\n                                    sc->sample_count * sizeof(*sc->ctts_data));\n            if (!sc->ctts_data) {\n                av_free(ctts_data_old);\n                return;\n            }\n\n            memset((uint8_t*)(sc->ctts_data), 0, sc->ctts_allocated_size);\n\n            for (i = 0; i < ctts_count_old &&\n                        sc->ctts_count < sc->sample_count; i++)\n                for (j = 0; j < ctts_data_old[i].count &&\n                            sc->ctts_count < sc->sample_count; j++)\n                    add_ctts_entry(&sc->ctts_data, &sc->ctts_count,\n                                   &sc->ctts_allocated_size, 1,\n                                   ctts_data_old[i].duration);\n            av_free(ctts_data_old);\n        }\n\n        for (i = 0; i < sc->chunk_count; i++) {\n            int64_t next_offset = i+1 < sc->chunk_count ? sc->chunk_offsets[i+1] : INT64_MAX;\n            current_offset = sc->chunk_offsets[i];\n            while (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n\n            if (next_offset > current_offset && sc->sample_size>0 && sc->sample_size < sc->stsz_sample_size &&\n                sc->stsc_data[stsc_index].count * (int64_t)sc->stsz_sample_size > next_offset - current_offset) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too large), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n            if (sc->stsz_sample_size>0 && sc->stsz_sample_size < sc->sample_size) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too small), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n\n            for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {\n                int keyframe = 0;\n                if (current_sample >= sc->sample_count) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong sample count\\n\");\n                    return;\n                }\n\n                if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {\n                    keyframe = 1;\n                    if (stss_index + 1 < sc->keyframe_count)\n                        stss_index++;\n                } else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {\n                    keyframe = 1;\n                    if (stps_index + 1 < sc->stps_count)\n                        stps_index++;\n                }\n                if (rap_group_present && rap_group_index < sc->rap_group_count) {\n                    if (sc->rap_group[rap_group_index].index > 0)\n                        keyframe = 1;\n                    if (++rap_group_sample == sc->rap_group[rap_group_index].count) {\n                        rap_group_sample = 0;\n                        rap_group_index++;\n                    }\n                }\n                if (sc->keyframe_absent\n                    && !sc->stps_count\n                    && !rap_group_present\n                    && (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || (i==0 && j==0)))\n                     keyframe = 1;\n                if (keyframe)\n                    distance = 0;\n                sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];\n                if (sc->pseudo_stream_id == -1 ||\n                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {\n                    AVIndexEntry *e;\n                    if (sample_size > 0x3FFFFFFF) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", sample_size);\n                        return;\n                    }\n                    e = &sti->index_entries[sti->nb_index_entries++];\n                    e->pos = current_offset;\n                    e->timestamp = current_dts;\n                    e->size = sample_size;\n                    e->min_distance = distance;\n                    e->flags = keyframe ? AVINDEX_KEYFRAME : 0;\n                    av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                            \"size %u, distance %u, keyframe %d\\n\", st->index, current_sample,\n                            current_offset, current_dts, sample_size, distance, keyframe);\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sti->nb_index_entries < 100)\n                        ff_rfps_add_frame(mov->fc, st, current_dts);\n                }\n\n                current_offset += sample_size;\n                stream_size += sample_size;\n\n                current_dts += sc->stts_data[stts_index].duration;\n\n                distance++;\n                stts_sample++;\n                current_sample++;\n                if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {\n                    stts_sample = 0;\n                    stts_index++;\n                }\n            }\n        }\n        if (st->duration > 0)\n            st->codecpar->bit_rate = stream_size*8*sc->time_scale/st->duration;\n    } else {\n        unsigned chunk_samples, total = 0;\n\n        if (!sc->chunk_count)\n            return;\n\n        // compute total chunk count\n        for (i = 0; i < sc->stsc_count; i++) {\n            unsigned count, chunk_count;\n\n            chunk_samples = sc->stsc_data[i].count;\n            if (i != sc->stsc_count - 1 &&\n                sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {\n                av_log(mov->fc, AV_LOG_ERROR, \"error unaligned chunk\\n\");\n                return;\n            }\n\n            if (sc->samples_per_frame >= 160) { // gsm\n                count = chunk_samples / sc->samples_per_frame;\n            } else if (sc->samples_per_frame > 1) {\n                unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;\n                count = (chunk_samples+samples-1) / samples;\n            } else {\n                count = (chunk_samples+1023) / 1024;\n            }\n\n            if (mov_stsc_index_valid(i, sc->stsc_count))\n                chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;\n            else\n                chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);\n            total += chunk_count * count;\n        }\n\n        av_log(mov->fc, AV_LOG_TRACE, \"chunk count %u\\n\", total);\n        if (total >= UINT_MAX / sizeof(*sti->index_entries) - sti->nb_index_entries)\n            return;\n        if (av_reallocp_array(&sti->index_entries,\n                              sti->nb_index_entries + total,\n                              sizeof(*sti->index_entries)) < 0) {\n            sti->nb_index_entries = 0;\n            return;\n        }\n        sti->index_entries_allocated_size = (sti->nb_index_entries + total) * sizeof(*sti->index_entries);\n\n        // populate index\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            if (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            chunk_samples = sc->stsc_data[stsc_index].count;\n\n            while (chunk_samples > 0) {\n                AVIndexEntry *e;\n                unsigned size, samples;\n\n                if (sc->samples_per_frame > 1 && !sc->bytes_per_frame) {\n                    avpriv_request_sample(mov->fc,\n                           \"Zero bytes per frame, but %d samples per frame\",\n                           sc->samples_per_frame);\n                    return;\n                }\n\n                if (sc->samples_per_frame >= 160) { // gsm\n                    samples = sc->samples_per_frame;\n                    size = sc->bytes_per_frame;\n                } else {\n                    if (sc->samples_per_frame > 1) {\n                        samples = FFMIN((1024 / sc->samples_per_frame)*\n                                        sc->samples_per_frame, chunk_samples);\n                        size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;\n                    } else {\n                        samples = FFMIN(1024, chunk_samples);\n                        size = samples * sc->sample_size;\n                    }\n                }\n\n                if (sti->nb_index_entries >= total) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong chunk count %u\\n\", total);\n                    return;\n                }\n                if (size > 0x3FFFFFFF) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", size);\n                    return;\n                }\n                e = &sti->index_entries[sti->nb_index_entries++];\n                e->pos = current_offset;\n                e->timestamp = current_dts;\n                e->size = size;\n                e->min_distance = 0;\n                e->flags = AVINDEX_KEYFRAME;\n                av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, chunk %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                       \"size %u, duration %u\\n\", st->index, i, current_offset, current_dts,\n                       size, samples);\n\n                current_offset += size;\n                current_dts += samples;\n                chunk_samples -= samples;\n            }\n        }\n    }\n\n    if (!mov->ignore_editlist && mov->advanced_editlist) {\n        // Fix index according to edit lists.\n        mov_fix_index(mov, st);\n    }\n\n    // Update start time of the stream.\n    if (st->start_time == AV_NOPTS_VALUE && st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sti->nb_index_entries > 0) {\n        st->start_time = sti->index_entries[0].timestamp + sc->dts_shift;\n        if (sc->ctts_data) {\n            st->start_time += sc->ctts_data[0].duration;\n        }\n    }\n\n    mov_estimate_video_delay(mov, st);\n}\n\nstatic int test_same_origin(const char *src, const char *ref) {\n    char src_proto[64];\n    char ref_proto[64];\n    char src_auth[256];\n    char ref_auth[256];\n    char src_host[256];\n    char ref_host[256];\n    int src_port=-1;\n    int ref_port=-1;\n\n    av_url_split(src_proto, sizeof(src_proto), src_auth, sizeof(src_auth), src_host, sizeof(src_host), &src_port, NULL, 0, src);\n    av_url_split(ref_proto, sizeof(ref_proto), ref_auth, sizeof(ref_auth), ref_host, sizeof(ref_host), &ref_port, NULL, 0, ref);\n\n    if (strlen(src) == 0) {\n        return -1;\n    } else if (strlen(src_auth) + 1 >= sizeof(src_auth) ||\n        strlen(ref_auth) + 1 >= sizeof(ref_auth) ||\n        strlen(src_host) + 1 >= sizeof(src_host) ||\n        strlen(ref_host) + 1 >= sizeof(ref_host)) {\n        return 0;\n    } else if (strcmp(src_proto, ref_proto) ||\n               strcmp(src_auth, ref_auth) ||\n               strcmp(src_host, ref_host) ||\n               src_port != ref_port) {\n        return 0;\n    } else\n        return 1;\n}\n\nstatic int mov_open_dref(MOVContext *c, AVIOContext **pb, const char *src, MOVDref *ref)\n{\n    /* try relative path, we do not try the absolute because it can leak information about our\n       system to an attacker */\n    if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n        char filename[1025];\n        const char *src_path;\n        int i, l;\n\n        /* find a source dir */\n        src_path = strrchr(src, '/');\n        if (src_path)\n            src_path++;\n        else\n            src_path = src;\n\n        /* find a next level down to target */\n        for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n            if (ref->path[l] == '/') {\n                if (i == ref->nlvl_to - 1)\n                    break;\n                else\n                    i++;\n            }\n\n        /* compose filename if next level down to target was found */\n        if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n            memcpy(filename, src, src_path - src);\n            filename[src_path - src] = 0;\n\n            for (i = 1; i < ref->nlvl_from; i++)\n                av_strlcat(filename, \"../\", sizeof(filename));\n\n            av_strlcat(filename, ref->path + l + 1, sizeof(filename));\n            if (!c->use_absolute_path) {\n                int same_origin = test_same_origin(src, filename);\n\n                if (!same_origin) {\n                    av_log(c->fc, AV_LOG_ERROR,\n                        \"Reference with mismatching origin, %s not tried for security reasons, \"\n                        \"set demuxer option use_absolute_path to allow it anyway\\n\",\n                        ref->path);\n                    return AVERROR(ENOENT);\n                }\n\n                if (strstr(ref->path + l + 1, \"..\") ||\n                    strstr(ref->path + l + 1, \":\") ||\n                    (ref->nlvl_from > 1 && same_origin < 0) ||\n                    (filename[0] == '/' && src_path == src))\n                    return AVERROR(ENOENT);\n            }\n\n            if (strlen(filename) + 1 == sizeof(filename))\n                return AVERROR(ENOENT);\n            if (!c->fc->io_open(c->fc, pb, filename, AVIO_FLAG_READ, NULL))\n                return 0;\n        }\n    } else if (c->use_absolute_path) {\n        av_log(c->fc, AV_LOG_WARNING, \"Using absolute path on user request, \"\n               \"this is a possible security issue\\n\");\n        if (!c->fc->io_open(c->fc, pb, ref->path, AVIO_FLAG_READ, NULL))\n            return 0;\n    } else {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Absolute path %s not tried for security reasons, \"\n               \"set demuxer option use_absolute_path to allow absolute paths\\n\",\n               ref->path);\n    }\n\n    return AVERROR(ENOENT);\n}\n\nstatic void fix_timescale(MOVContext *c, MOVStreamContext *sc)\n{\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"stream %d, timescale not set\\n\", sc->ffindex);\n        sc->time_scale = c->time_scale;\n        if (sc->time_scale <= 0)\n            sc->time_scale = 1;\n    }\n}\n\nstatic int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret;\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st) return AVERROR(ENOMEM);\n    st->id = -1;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc) return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n    sc->ffindex = st->index;\n    c->trak_index = st->index;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n\n    c->trak_index = -1;\n\n    // Here stsc refers to a chunk not described in stco. This is technically invalid,\n    // but we can overlook it (clearing stsc) whenever stts_count == 0 (indicating no samples).\n    if (!sc->chunk_count && !sc->stts_count && sc->stsc_count) {\n        sc->stsc_count = 0;\n        av_freep(&sc->stsc_data);\n    }\n\n    /* sanity checks */\n    if ((sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n                            (!sc->sample_size && !sc->sample_count))) ||\n        (!sc->chunk_count && sc->sample_count)) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n               st->index);\n        return 0;\n    }\n    if (sc->stsc_count && sc->stsc_data[ sc->stsc_count - 1 ].first > sc->chunk_count) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, contradictionary STSC and STCO\\n\",\n               st->index);\n        return AVERROR_INVALIDDATA;\n    }\n\n    fix_timescale(c, sc);\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n    mov_build_index(c, st);\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n        if (c->enable_drefs) {\n            if (mov_open_dref(c, &sc->pb, c->fc->url, dref) < 0)\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"stream %d, error opening alias: path='%s', dir='%s', \"\n                       \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n                       st->index, dref->path, dref->dir, dref->filename,\n                       dref->volume, dref->nlvl_from, dref->nlvl_to);\n        } else {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Skipped opening external track: \"\n                   \"stream %d, alias: path='%s', dir='%s', \"\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d.\"\n                   \"Set enable_drefs to allow this.\\n\",\n                   st->index, dref->path, dref->dir, dref->filename,\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n        }\n    } else {\n        sc->pb = c->fc->pb;\n        sc->pb_is_copied = 1;\n    }\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (!st->sample_aspect_ratio.num && st->codecpar->width && st->codecpar->height &&\n            sc->height && sc->width &&\n            (st->codecpar->width != sc->width || st->codecpar->height != sc->height)) {\n            st->sample_aspect_ratio = av_d2q(((double)st->codecpar->height * sc->width) /\n                                             ((double)st->codecpar->width * sc->height), INT_MAX);\n        }\n\n#if FF_API_R_FRAME_RATE\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n#endif\n    }\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n    if (!st->codecpar->extradata_size && st->codecpar->codec_id == AV_CODEC_ID_H264 &&\n        TAG_IS_AVCI(st->codecpar->codec_tag)) {\n        ret = ff_generate_avci_extradata(st);\n        if (ret < 0)\n            return ret;\n    }\n\n    switch (st->codecpar->codec_id) {\n#if CONFIG_H261_DECODER\n    case AV_CODEC_ID_H261:\n#endif\n#if CONFIG_H263_DECODER\n    case AV_CODEC_ID_H263:\n#endif\n#if CONFIG_MPEG4_DECODER\n    case AV_CODEC_ID_MPEG4:\n#endif\n        st->codecpar->width = 0; /* let decoder init width/height */\n        st->codecpar->height= 0;\n        break;\n    }\n\n    // If the duration of the mp3 packets is not constant, then they could need a parser\n    if (st->codecpar->codec_id == AV_CODEC_ID_MP3\n        && sc->stts_count > 3\n        && sc->stts_count*10 > st->nb_frames\n        && sc->time_scale == st->codecpar->sample_rate) {\n            ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n    }\n    /* Do not need those anymore. */\n    av_freep(&sc->chunk_offsets);\n    av_freep(&sc->sample_sizes);\n    av_freep(&sc->keyframes);\n    av_freep(&sc->stts_data);\n    av_freep(&sc->stps_data);\n    av_freep(&sc->elst_data);\n    av_freep(&sc->rap_group);\n    av_freep(&sc->sync_group);\n    av_freep(&sc->sgpd_sync);\n\n    return 0;\n}\n\nstatic int mov_read_ilst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    c->itunes_metadata = 1;\n    ret = mov_read_default(c, pb, atom);\n    c->itunes_metadata = 0;\n    return ret;\n}\n\nstatic int mov_read_keys(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t count;\n    uint32_t i;\n\n    if (atom.size < 8)\n        return 0;\n\n    avio_skip(pb, 4);\n    count = avio_rb32(pb);\n    if (count > UINT_MAX / sizeof(*c->meta_keys) - 1) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"The 'keys' atom with the invalid key count: %\"PRIu32\"\\n\", count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->meta_keys_count = count + 1;\n    c->meta_keys = av_mallocz(c->meta_keys_count * sizeof(*c->meta_keys));\n    if (!c->meta_keys)\n        return AVERROR(ENOMEM);\n\n    for (i = 1; i <= count; ++i) {\n        uint32_t key_size = avio_rb32(pb);\n        uint32_t type = avio_rl32(pb);\n        if (key_size < 8) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"The key# %\"PRIu32\" in meta has invalid size:\"\n                   \"%\"PRIu32\"\\n\", i, key_size);\n            return AVERROR_INVALIDDATA;\n        }\n        key_size -= 8;\n        if (type != MKTAG('m','d','t','a')) {\n            avio_skip(pb, key_size);\n        }\n        c->meta_keys[i] = av_mallocz(key_size + 1);\n        if (!c->meta_keys[i])\n            return AVERROR(ENOMEM);\n        avio_read(pb, c->meta_keys[i], key_size);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_custom(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t end = av_sat_add64(avio_tell(pb), atom.size);\n    uint8_t *key = NULL, *val = NULL, *mean = NULL;\n    int i;\n    int ret = 0;\n    AVStream *st;\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (i = 0; i < 3; i++) {\n        uint8_t **p;\n        uint32_t len, tag;\n\n        if (end - avio_tell(pb) <= 12)\n            break;\n\n        len = avio_rb32(pb);\n        tag = avio_rl32(pb);\n        avio_skip(pb, 4); // flags\n\n        if (len < 12 || len - 12 > end - avio_tell(pb))\n            break;\n        len -= 12;\n\n        if (tag == MKTAG('m', 'e', 'a', 'n'))\n            p = &mean;\n        else if (tag == MKTAG('n', 'a', 'm', 'e'))\n            p = &key;\n        else if (tag == MKTAG('d', 'a', 't', 'a') && len > 4) {\n            avio_skip(pb, 4);\n            len -= 4;\n            p = &val;\n        } else\n            break;\n\n        if (*p)\n            break;\n\n        *p = av_malloc(len + 1);\n        if (!*p) {\n            ret = AVERROR(ENOMEM);\n            break;\n        }\n        ret = ffio_read_size(pb, *p, len);\n        if (ret < 0) {\n            av_freep(p);\n            break;\n        }\n        (*p)[len] = 0;\n    }\n\n    if (mean && key && val) {\n        if (strcmp(key, \"iTunSMPB\") == 0) {\n            int priming, remainder, samples;\n            if(sscanf(val, \"%*X %X %X %X\", &priming, &remainder, &samples) == 3){\n                if(priming>0 && priming<16384)\n                    sc->start_pad = priming;\n            }\n        }\n        if (strcmp(key, \"cdec\") != 0) {\n            av_dict_set(&c->fc->metadata, key, val,\n                        AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n            key = val = NULL;\n        }\n    } else {\n        av_log(c->fc, AV_LOG_VERBOSE,\n               \"Unhandled or malformed custom metadata of size %\"PRId64\"\\n\", atom.size);\n    }\n\n    avio_seek(pb, end, SEEK_SET);\n    av_freep(&key);\n    av_freep(&val);\n    av_freep(&mean);\n    return ret;\n}\n\nstatic int avif_add_stream(MOVContext *c, int item_id)\n{\n    MOVStreamContext *sc;\n    AVStream *st;\n    int item_index = -1;\n    for (int i = 0; i < c->avif_info_size; i++)\n        if (c->avif_info[i].item_id == item_id) {\n            item_index = i;\n            break;\n        }\n    if (item_index < 0)\n        return AVERROR_INVALIDDATA;\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->id = c->fc->nb_streams;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc)\n        return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id = AV_CODEC_ID_AV1;\n    sc->ffindex = st->index;\n    c->trak_index = st->index;\n    st->avg_frame_rate.num = st->avg_frame_rate.den = 1;\n    st->time_base.num = st->time_base.den = 1;\n    st->nb_frames = 1;\n    sc->time_scale = 1;\n    sc = st->priv_data;\n    sc->pb = c->fc->pb;\n    sc->pb_is_copied = 1;\n\n    // Populate the necessary fields used by mov_build_index.\n    sc->stsc_count = 1;\n    sc->stsc_data = av_malloc_array(1, sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n    sc->stsc_data[0].first = 1;\n    sc->stsc_data[0].count = 1;\n    sc->stsc_data[0].id = 1;\n    sc->chunk_count = 1;\n    sc->chunk_offsets = av_malloc_array(1, sizeof(*sc->chunk_offsets));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->sample_count = 1;\n    sc->sample_sizes = av_malloc_array(1, sizeof(*sc->sample_sizes));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n    sc->stts_count = 1;\n    sc->stts_data = av_malloc_array(1, sizeof(*sc->stts_data));\n    if (!sc->stts_data)\n        return AVERROR(ENOMEM);\n    sc->stts_data[0].count = 1;\n    // Not used for still images. But needed by mov_build_index.\n    sc->stts_data[0].duration = 0;\n    sc->sample_sizes[0] = c->avif_info[item_index].extent_length;\n    sc->chunk_offsets[0] = c->avif_info[item_index].extent_offset;\n\n    mov_build_index(c, st);\n    return 0;\n}\n\nstatic int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    while (atom.size > 8) {\n        uint32_t tag;\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        tag = avio_rl32(pb);\n        atom.size -= 4;\n        if (tag == MKTAG('h','d','l','r')) {\n            int ret;\n            avio_seek(pb, -8, SEEK_CUR);\n            atom.size += 8;\n            if ((ret = mov_read_default(c, pb, atom)) < 0)\n                return ret;\n            if (c->is_still_picture_avif) {\n                int ret;\n                // Add a stream for the YUV planes (primary item).\n                if ((ret = avif_add_stream(c, c->primary_item_id)) < 0)\n                    return ret;\n                // For still AVIF images, the meta box contains all the\n                // necessary information that would generally be provided by the\n                // moov box. So simply mark that we have found the moov box so\n                // that parsing can continue.\n                c->found_moov = 1;\n            }\n            return ret;\n        }\n    }\n    return 0;\n}\n\n// return 1 when matrix is identity, 0 otherwise\n#define IS_MATRIX_IDENT(matrix)            \\\n    ( (matrix)[0][0] == (1 << 16) &&       \\\n      (matrix)[1][1] == (1 << 16) &&       \\\n      (matrix)[2][2] == (1 << 30) &&       \\\n     !(matrix)[0][1] && !(matrix)[0][2] && \\\n     !(matrix)[1][0] && !(matrix)[1][2] && \\\n     !(matrix)[2][0] && !(matrix)[2][1])\n\nstatic int mov_read_tkhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i, j, e;\n    int width;\n    int height;\n    int display_matrix[3][3];\n    int res_display_matrix[3][3] = { { 0 } };\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    int flags;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    // Each stream (trak) should have exactly 1 tkhd. This catches bad files and\n    // avoids corrupting AVStreams mapped to an earlier tkhd.\n    if (st->id != -1)\n        return AVERROR_INVALIDDATA;\n\n    version = avio_r8(pb);\n    flags = avio_rb24(pb);\n    st->disposition |= (flags & MOV_TKHD_FLAG_ENABLED) ? AV_DISPOSITION_DEFAULT : 0;\n\n    if (version == 1) {\n        avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        avio_rb32(pb); /* creation time */\n        avio_rb32(pb); /* modification time */\n    }\n    st->id = (int)avio_rb32(pb); /* track id (NOT 0 !)*/\n    avio_rb32(pb); /* reserved */\n\n    /* highlevel (considering edits) duration in movie timebase */\n    (version == 1) ? avio_rb64(pb) : avio_rb32(pb);\n    avio_rb32(pb); /* reserved */\n    avio_rb32(pb); /* reserved */\n\n    avio_rb16(pb); /* layer */\n    avio_rb16(pb); /* alternate group */\n    avio_rb16(pb); /* volume */\n    avio_rb16(pb); /* reserved */\n\n    //read in the display matrix (outlined in ISO 14496-12, Section 6.2.2)\n    // they're kept in fixed point format through all calculations\n    // save u,v,z to store the whole matrix in the AV_PKT_DATA_DISPLAYMATRIX\n    // side data, but the scale factor is not needed to calculate aspect ratio\n    for (i = 0; i < 3; i++) {\n        display_matrix[i][0] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][1] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][2] = avio_rb32(pb);   //  2.30 fixed point\n    }\n\n    width = avio_rb32(pb);       // 16.16 fixed point track width\n    height = avio_rb32(pb);      // 16.16 fixed point track height\n    sc->width = width >> 16;\n    sc->height = height >> 16;\n\n    // apply the moov display matrix (after the tkhd one)\n    for (i = 0; i < 3; i++) {\n        const int sh[3] = { 16, 16, 30 };\n        for (j = 0; j < 3; j++) {\n            for (e = 0; e < 3; e++) {\n                res_display_matrix[i][j] +=\n                    ((int64_t) display_matrix[i][e] *\n                     c->movie_display_matrix[e][j]) >> sh[e];\n            }\n        }\n    }\n\n    // save the matrix when it is not the default identity\n    if (!IS_MATRIX_IDENT(res_display_matrix)) {\n        av_freep(&sc->display_matrix);\n        sc->display_matrix = av_malloc(sizeof(int32_t) * 9);\n        if (!sc->display_matrix)\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < 3; i++)\n            for (j = 0; j < 3; j++)\n                sc->display_matrix[i * 3 + j] = res_display_matrix[i][j];\n    }\n\n    // transform the display width/height according to the matrix\n    // to keep the same scale, use [width height 1<<16]\n    if (width && height && sc->display_matrix) {\n        double disp_transform[2];\n\n        for (i = 0; i < 2; i++)\n            disp_transform[i] = hypot(sc->display_matrix[0 + i],\n                                      sc->display_matrix[3 + i]);\n\n        if (disp_transform[0] > 1       && disp_transform[1] > 1 &&\n            disp_transform[0] < (1<<24) && disp_transform[1] < (1<<24) &&\n            fabs((disp_transform[0] / disp_transform[1]) - 1.0) > 0.01)\n            st->sample_aspect_ratio = av_d2q(\n                disp_transform[0] / disp_transform[1],\n                INT_MAX);\n    }\n    return 0;\n}\n\nstatic int mov_read_tfhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    MOVTrackExt *trex = NULL;\n    int flags, track_id, i;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    track_id = avio_rb32(pb);\n    if (!track_id)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < c->trex_count; i++)\n        if (c->trex_data[i].track_id == track_id) {\n            trex = &c->trex_data[i];\n            break;\n        }\n    if (!trex) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding trex (id %u)\\n\", track_id);\n        return 0;\n    }\n    c->fragment.found_tfhd = 1;\n    frag->track_id = track_id;\n    set_frag_stream(&c->frag_index, track_id);\n\n    frag->base_data_offset = flags & MOV_TFHD_BASE_DATA_OFFSET ?\n                             avio_rb64(pb) : flags & MOV_TFHD_DEFAULT_BASE_IS_MOOF ?\n                             frag->moof_offset : frag->implicit_offset;\n    frag->stsd_id  = flags & MOV_TFHD_STSD_ID ? avio_rb32(pb) : trex->stsd_id;\n\n    frag->duration = flags & MOV_TFHD_DEFAULT_DURATION ?\n                     avio_rb32(pb) : trex->duration;\n    frag->size     = flags & MOV_TFHD_DEFAULT_SIZE ?\n                     avio_rb32(pb) : trex->size;\n    frag->flags    = flags & MOV_TFHD_DEFAULT_FLAGS ?\n                     avio_rb32(pb) : trex->flags;\n    av_log(c->fc, AV_LOG_TRACE, \"frag flags 0x%x\\n\", frag->flags);\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info)\n        frag_stream_info->next_trun_dts = AV_NOPTS_VALUE;\n\n    return 0;\n}\n\nstatic int mov_read_chap(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    unsigned i, num;\n    void *new_tracks;\n\n    num = atom.size / 4;\n    if (!(new_tracks = av_malloc_array(num, sizeof(int))))\n        return AVERROR(ENOMEM);\n\n    av_free(c->chapter_tracks);\n    c->chapter_tracks = new_tracks;\n    c->nb_chapter_tracks = num;\n\n    for (i = 0; i < num && !pb->eof_reached; i++)\n        c->chapter_tracks[i] = avio_rb32(pb);\n\n    c->nb_chapter_tracks = i;\n\n    return 0;\n}\n\nstatic int mov_read_trex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVTrackExt *trex;\n    int err;\n\n    if ((uint64_t)c->trex_count+1 >= UINT_MAX / sizeof(*c->trex_data))\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp_array(&c->trex_data, c->trex_count + 1,\n                                 sizeof(*c->trex_data))) < 0) {\n        c->trex_count = 0;\n        return err;\n    }\n\n    c->fc->duration = AV_NOPTS_VALUE; // the duration from mvhd is not representing the whole file when fragments are used.\n\n    trex = &c->trex_data[c->trex_count++];\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    trex->track_id = avio_rb32(pb);\n    trex->stsd_id  = avio_rb32(pb);\n    trex->duration = avio_rb32(pb);\n    trex->size     = avio_rb32(pb);\n    trex->flags    = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_tfdt(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    int version, i;\n    MOVFragmentStreamInfo * frag_stream_info;\n    int64_t base_media_decode_time;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return 0;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id + 1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    if (version) {\n        base_media_decode_time = avio_rb64(pb);\n    } else {\n        base_media_decode_time = avio_rb32(pb);\n    }\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info)\n        frag_stream_info->tfdt_dts = base_media_decode_time;\n    sc->track_end = base_media_decode_time;\n\n    return 0;\n}\n\nstatic int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    FFStream *sti = NULL;\n    MOVStreamContext *sc;\n    MOVCtts *ctts_data;\n    uint64_t offset;\n    int64_t dts, pts = AV_NOPTS_VALUE;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i;\n    int64_t prev_dts = AV_NOPTS_VALUE;\n    int next_frag_index = -1, index_entry_pos;\n    size_t requested_size;\n    size_t old_ctts_allocated_size;\n    AVIndexEntry *new_entries;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    if (!frag->found_tfhd) {\n        av_log(c->fc, AV_LOG_ERROR, \"trun track id unknown, no tfhd was found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            sti = ffstream(st);\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return 0;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n\n    // Find the next frag_index index that has a valid index_entry for\n    // the current track_id.\n    //\n    // A valid index_entry means the trun for the fragment was read\n    // and it's samples are in index_entries at the given position.\n    // New index entries will be inserted before the index_entry found.\n    index_entry_pos = sti->nb_index_entries;\n    for (i = c->frag_index.current + 1; i < c->frag_index.nb_items; i++) {\n        frag_stream_info = get_frag_stream_info(&c->frag_index, i, frag->track_id);\n        if (frag_stream_info && frag_stream_info->index_entry >= 0) {\n            next_frag_index = i;\n            index_entry_pos = frag_stream_info->index_entry;\n            break;\n        }\n    }\n    av_assert0(index_entry_pos <= sti->nb_index_entries);\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_log(c->fc, AV_LOG_TRACE, \"flags 0x%x entries %u\\n\", flags, entries);\n\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info) {\n        if (frag_stream_info->next_trun_dts != AV_NOPTS_VALUE) {\n            dts = frag_stream_info->next_trun_dts - sc->time_offset;\n        } else if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE &&\n            c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n            pts = frag_stream_info->first_tfra_pts;\n            av_log(c->fc, AV_LOG_DEBUG, \"found mfra time %\"PRId64\n                    \", using it for pts\\n\", pts);\n        } else if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE &&\n            c->use_mfra_for == FF_MOV_FLAG_MFRA_DTS) {\n            dts = frag_stream_info->first_tfra_pts;\n            av_log(c->fc, AV_LOG_DEBUG, \"found mfra time %\"PRId64\n                    \", using it for dts\\n\", pts);\n        } else {\n            int has_tfdt = frag_stream_info->tfdt_dts != AV_NOPTS_VALUE;\n            int has_sidx = frag_stream_info->sidx_pts != AV_NOPTS_VALUE;\n            int fallback_tfdt = !c->use_tfdt && !has_sidx && has_tfdt;\n            int fallback_sidx =  c->use_tfdt && !has_tfdt && has_sidx;\n\n            if (fallback_sidx) {\n                av_log(c->fc, AV_LOG_DEBUG, \"use_tfdt set but no tfdt found, using sidx instead\\n\");\n            }\n            if (fallback_tfdt) {\n                av_log(c->fc, AV_LOG_DEBUG, \"use_tfdt not set but no sidx found, using tfdt instead\\n\");\n            }\n\n            if (has_tfdt && c->use_tfdt || fallback_tfdt) {\n                dts = frag_stream_info->tfdt_dts - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found tfdt time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            } else if (has_sidx && !c->use_tfdt || fallback_sidx) {\n                // FIXME: sidx earliest_presentation_time is *PTS*, s.b.\n                // pts = frag_stream_info->sidx_pts;\n                dts = frag_stream_info->sidx_pts - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found sidx time %\"PRId64\n                        \", using it for dts\\n\", frag_stream_info->sidx_pts);\n            } else {\n                dts = sc->track_end - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found track end time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n        }\n    } else {\n        dts = sc->track_end - sc->time_offset;\n        av_log(c->fc, AV_LOG_DEBUG, \"found track end time %\"PRId64\n                \", using it for dts\\n\", dts);\n    }\n    offset   = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_log(c->fc, AV_LOG_TRACE, \"first sample flags 0x%x\\n\", first_sample_flags);\n\n    // realloc space for new index entries\n    if ((uint64_t)sti->nb_index_entries + entries >= UINT_MAX / sizeof(AVIndexEntry)) {\n        entries = UINT_MAX / sizeof(AVIndexEntry) - sti->nb_index_entries;\n        av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n    }\n    if (entries == 0)\n        return 0;\n\n    requested_size = (sti->nb_index_entries + entries) * sizeof(AVIndexEntry);\n    new_entries = av_fast_realloc(sti->index_entries,\n                                  &sti->index_entries_allocated_size,\n                                  requested_size);\n    if (!new_entries)\n        return AVERROR(ENOMEM);\n    sti->index_entries= new_entries;\n\n    requested_size = (sti->nb_index_entries + entries) * sizeof(*sc->ctts_data);\n    old_ctts_allocated_size = sc->ctts_allocated_size;\n    ctts_data = av_fast_realloc(sc->ctts_data, &sc->ctts_allocated_size,\n                                requested_size);\n    if (!ctts_data)\n        return AVERROR(ENOMEM);\n    sc->ctts_data = ctts_data;\n\n    // In case there were samples without ctts entries, ensure they get\n    // zero valued entries. This ensures clips which mix boxes with and\n    // without ctts entries don't pickup uninitialized data.\n    memset((uint8_t*)(sc->ctts_data) + old_ctts_allocated_size, 0,\n           sc->ctts_allocated_size - old_ctts_allocated_size);\n\n    if (index_entry_pos < sti->nb_index_entries) {\n        // Make hole in index_entries and ctts_data for new samples\n        memmove(sti->index_entries + index_entry_pos + entries,\n                sti->index_entries + index_entry_pos,\n                sizeof(*sti->index_entries) *\n                (sti->nb_index_entries - index_entry_pos));\n        memmove(sc->ctts_data + index_entry_pos + entries,\n                sc->ctts_data + index_entry_pos,\n                sizeof(*sc->ctts_data) * (sc->ctts_count - index_entry_pos));\n        if (index_entry_pos < sc->current_sample) {\n            sc->current_sample += entries;\n        }\n    }\n\n    sti->nb_index_entries += entries;\n    sc->ctts_count = sti->nb_index_entries;\n\n    // Record the index_entry position in frag_index of this fragment\n    if (frag_stream_info) {\n        frag_stream_info->index_entry = index_entry_pos;\n        if (frag_stream_info->index_base < 0)\n            frag_stream_info->index_base = index_entry_pos;\n    }\n\n    if (index_entry_pos > 0)\n        prev_dts = sti->index_entries[index_entry_pos-1].timestamp;\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        unsigned ctts_duration = 0;\n        int keyframe = 0;\n        int index_entry_flags = 0;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      ctts_duration   = avio_rb32(pb);\n\n        mov_update_dts_shift(sc, ctts_duration, c->fc);\n        if (pts != AV_NOPTS_VALUE) {\n            dts = pts - sc->dts_shift;\n            if (flags & MOV_TRUN_SAMPLE_CTS) {\n                dts -= ctts_duration;\n            } else {\n                dts -= sc->time_offset;\n            }\n            av_log(c->fc, AV_LOG_DEBUG,\n                   \"pts %\"PRId64\" calculated dts %\"PRId64\n                   \" sc->dts_shift %d ctts.duration %d\"\n                   \" sc->time_offset %\"PRId64\n                   \" flags & MOV_TRUN_SAMPLE_CTS %d\\n\",\n                   pts, dts,\n                   sc->dts_shift, ctts_duration,\n                   sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n            pts = AV_NOPTS_VALUE;\n        }\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else\n            keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe) {\n            distance = 0;\n            index_entry_flags |= AVINDEX_KEYFRAME;\n        }\n        // Fragments can overlap in time.  Discard overlapping frames after\n        // decoding.\n        if (prev_dts >= dts)\n            index_entry_flags |= AVINDEX_DISCARD_FRAME;\n\n        sti->index_entries[index_entry_pos].pos   = offset;\n        sti->index_entries[index_entry_pos].timestamp = dts;\n        sti->index_entries[index_entry_pos].size  = sample_size;\n        sti->index_entries[index_entry_pos].min_distance = distance;\n        sti->index_entries[index_entry_pos].flags = index_entry_flags;\n\n        sc->ctts_data[index_entry_pos].count = 1;\n        sc->ctts_data[index_entry_pos].duration = ctts_duration;\n        index_entry_pos++;\n\n        av_log(c->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %u, distance %d, keyframe %d\\n\", st->index,\n                index_entry_pos, offset, dts, sample_size, distance, keyframe);\n        distance++;\n        if (av_sat_add64(dts, sample_duration) != dts + (uint64_t)sample_duration)\n            return AVERROR_INVALIDDATA;\n        if (!sample_size)\n            return AVERROR_INVALIDDATA;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n\n        if (sample_duration <= INT64_MAX - sc->duration_for_fps &&\n            1 <= INT_MAX - sc->nb_frames_for_fps\n        ) {\n            sc->duration_for_fps += sample_duration;\n            sc->nb_frames_for_fps ++;\n        }\n    }\n    if (frag_stream_info)\n        frag_stream_info->next_trun_dts = dts + sc->time_offset;\n    if (i < entries) {\n        // EOF found before reading all entries.  Fix the hole this would\n        // leave in index_entries and ctts_data\n        int gap = entries - i;\n        memmove(sti->index_entries + index_entry_pos,\n                sti->index_entries + index_entry_pos + gap,\n                sizeof(*sti->index_entries) *\n                (sti->nb_index_entries - (index_entry_pos + gap)));\n        memmove(sc->ctts_data + index_entry_pos,\n                sc->ctts_data + index_entry_pos + gap,\n                sizeof(*sc->ctts_data) *\n                (sc->ctts_count - (index_entry_pos + gap)));\n\n        sti->nb_index_entries -= gap;\n        sc->ctts_count -= gap;\n        if (index_entry_pos < sc->current_sample) {\n            sc->current_sample -= gap;\n        }\n        entries = i;\n    }\n\n    // The end of this new fragment may overlap in time with the start\n    // of the next fragment in index_entries. Mark the samples in the next\n    // fragment that overlap with AVINDEX_DISCARD_FRAME\n    prev_dts = AV_NOPTS_VALUE;\n    if (index_entry_pos > 0)\n        prev_dts = sti->index_entries[index_entry_pos-1].timestamp;\n    for (int i = index_entry_pos; i < sti->nb_index_entries; i++) {\n        if (prev_dts < sti->index_entries[i].timestamp)\n            break;\n        sti->index_entries[i].flags |= AVINDEX_DISCARD_FRAME;\n    }\n\n    // If a hole was created to insert the new index_entries into,\n    // the index_entry recorded for all subsequent moof must\n    // be incremented by the number of entries inserted.\n    fix_frag_index_entries(&c->frag_index, next_frag_index,\n                           frag->track_id, entries);\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted TRUN atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    frag->implicit_offset = offset;\n\n    sc->track_end = dts + sc->time_offset;\n    if (st->duration < sc->track_end)\n        st->duration = sc->track_end;\n\n    return 0;\n}\n\nstatic int mov_read_sidx(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t stream_size = avio_size(pb);\n    int64_t offset = av_sat_add64(avio_tell(pb), atom.size), pts, timestamp;\n    uint8_t version, is_complete;\n    int64_t offadd;\n    unsigned i, j, track_id, item_count;\n    AVStream *st = NULL;\n    AVStream *ref_st = NULL;\n    MOVStreamContext *sc, *ref_sc = NULL;\n    AVRational timescale;\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"sidx version %u\", version);\n        return 0;\n    }\n\n    avio_rb24(pb); // flags\n\n    track_id = avio_rb32(pb); // Reference ID\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %d\\n\", track_id);\n        return 0;\n    }\n\n    sc = st->priv_data;\n\n    timescale = av_make_q(1, avio_rb32(pb));\n\n    if (timescale.den <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sidx timescale 1/%d\\n\", timescale.den);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (version == 0) {\n        pts = avio_rb32(pb);\n        offadd= avio_rb32(pb);\n    } else {\n        pts = avio_rb64(pb);\n        offadd= avio_rb64(pb);\n    }\n    if (av_sat_add64(offset, offadd) != offset + (uint64_t)offadd)\n        return AVERROR_INVALIDDATA;\n\n    offset += (uint64_t)offadd;\n\n    avio_rb16(pb); // reserved\n\n    item_count = avio_rb16(pb);\n    if (item_count == 0)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < item_count; i++) {\n        int index;\n        MOVFragmentStreamInfo * frag_stream_info;\n        uint32_t size = avio_rb32(pb);\n        uint32_t duration = avio_rb32(pb);\n        if (size & 0x80000000) {\n            avpriv_request_sample(c->fc, \"sidx reference_type 1\");\n            return AVERROR_PATCHWELCOME;\n        }\n        avio_rb32(pb); // sap_flags\n        timestamp = av_rescale_q(pts, timescale, st->time_base);\n\n        index = update_frag_index(c, offset);\n        frag_stream_info = get_frag_stream_info(&c->frag_index, index, track_id);\n        if (frag_stream_info)\n            frag_stream_info->sidx_pts = timestamp;\n\n        if (av_sat_add64(offset, size) != offset + (uint64_t)size ||\n            av_sat_add64(pts, duration) != pts + (uint64_t)duration\n        )\n            return AVERROR_INVALIDDATA;\n        offset += size;\n        pts += duration;\n    }\n\n    st->duration = sc->track_end = pts;\n\n    sc->has_sidx = 1;\n\n    // See if the remaining bytes are just an mfra which we can ignore.\n    is_complete = offset == stream_size;\n    if (!is_complete && (pb->seekable & AVIO_SEEKABLE_NORMAL) && stream_size > 0 ) {\n        int64_t ret;\n        int64_t original_pos = avio_tell(pb);\n        if (!c->have_read_mfra_size) {\n            if ((ret = avio_seek(pb, stream_size - 4, SEEK_SET)) < 0)\n                return ret;\n            c->mfra_size = avio_rb32(pb);\n            c->have_read_mfra_size = 1;\n            if ((ret = avio_seek(pb, original_pos, SEEK_SET)) < 0)\n                return ret;\n        }\n        if (offset == stream_size - c->mfra_size)\n            is_complete = 1;\n    }\n\n    if (is_complete) {\n        // Find first entry in fragment index that came from an sidx.\n        // This will pretty much always be the first entry.\n        for (i = 0; i < c->frag_index.nb_items; i++) {\n            MOVFragmentIndexItem * item = &c->frag_index.item[i];\n            for (j = 0; ref_st == NULL && j < item->nb_stream_info; j++) {\n                MOVFragmentStreamInfo * si;\n                si = &item->stream_info[j];\n                if (si->sidx_pts != AV_NOPTS_VALUE) {\n                    ref_st = c->fc->streams[j];\n                    ref_sc = ref_st->priv_data;\n                    break;\n                }\n            }\n        }\n        if (ref_st) for (i = 0; i < c->fc->nb_streams; i++) {\n            st = c->fc->streams[i];\n            sc = st->priv_data;\n            if (!sc->has_sidx) {\n                st->duration = sc->track_end = av_rescale(ref_st->duration, sc->time_scale, ref_sc->time_scale);\n            }\n        }\n\n        c->frag_index.complete = 1;\n    }\n\n    return 0;\n}\n\n/* this atom should be null (from specs), but some buggy files put the 'moov' atom inside it... */\n/* like the files created with Adobe Premiere 5.0, for samples see */\n/* http://graphics.tudelft.nl/~wouter/publications/soundtests/ */\nstatic int mov_read_wide(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int err;\n\n    if (atom.size < 8)\n        return 0; /* continue */\n    if (avio_rb32(pb) != 0) { /* 0 sized mdat atom... use the 'wide' atom size */\n        avio_skip(pb, atom.size - 4);\n        return 0;\n    }\n    atom.type = avio_rl32(pb);\n    atom.size -= 8;\n    if (atom.type != MKTAG('m','d','a','t')) {\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n    err = mov_read_mdat(c, pb, atom);\n    return err;\n}\n\nstatic int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#if CONFIG_ZLIB\n    FFIOContext ctx;\n    uint8_t *cmov_data;\n    uint8_t *moov_data; /* uncompressed data */\n    long cmov_len, moov_len;\n    int ret = -1;\n\n    avio_rb32(pb); /* dcom atom */\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n        return AVERROR_INVALIDDATA;\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_rb32(pb); /* cmvd atom */\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n        return AVERROR_INVALIDDATA;\n    moov_len = avio_rb32(pb); /* uncompressed size */\n    cmov_len = atom.size - 6 * 4;\n\n    cmov_data = av_malloc(cmov_len);\n    if (!cmov_data)\n        return AVERROR(ENOMEM);\n    moov_data = av_malloc(moov_len);\n    if (!moov_data) {\n        av_free(cmov_data);\n        return AVERROR(ENOMEM);\n    }\n    ret = ffio_read_size(pb, cmov_data, cmov_len);\n    if (ret < 0)\n        goto free_and_return;\n\n    ret = AVERROR_INVALIDDATA;\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n        goto free_and_return;\n    ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL);\n    ctx.pub.seekable = AVIO_SEEKABLE_NORMAL;\n    atom.type = MKTAG('m','o','o','v');\n    atom.size = moov_len;\n    ret = mov_read_default(c, &ctx.pub, atom);\nfree_and_return:\n    av_free(moov_data);\n    av_free(cmov_data);\n    return ret;\n#else\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n    return AVERROR(ENOSYS);\n#endif\n}\n\n/* edit list atom */\nstatic int mov_read_elst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, edit_count, version;\n    int64_t elst_entry_size;\n\n    if (c->fc->nb_streams < 1 || c->ignore_editlist)\n        return 0;\n    sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    edit_count = avio_rb32(pb); /* entries */\n    atom.size -= 8;\n\n    elst_entry_size = version == 1 ? 20 : 12;\n    if (atom.size != edit_count * elst_entry_size) {\n        if (c->fc->strict_std_compliance >= FF_COMPLIANCE_STRICT) {\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid edit list entry_count: %d for elst atom of size: %\"PRId64\" bytes.\\n\",\n                   edit_count, atom.size + 8);\n            return AVERROR_INVALIDDATA;\n        } else {\n            edit_count = atom.size / elst_entry_size;\n            if (edit_count * elst_entry_size != atom.size) {\n                av_log(c->fc, AV_LOG_WARNING, \"ELST atom of %\"PRId64\" bytes, bigger than %d entries.\\n\", atom.size, edit_count);\n            }\n        }\n    }\n\n    if (!edit_count)\n        return 0;\n    if (sc->elst_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated ELST atom\\n\");\n    av_free(sc->elst_data);\n    sc->elst_count = 0;\n    sc->elst_data = av_malloc_array(edit_count, sizeof(*sc->elst_data));\n    if (!sc->elst_data)\n        return AVERROR(ENOMEM);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].edit_count = %i\\n\", c->fc->nb_streams - 1, edit_count);\n    for (i = 0; i < edit_count && atom.size > 0 && !pb->eof_reached; i++) {\n        MOVElst *e = &sc->elst_data[i];\n\n        if (version == 1) {\n            e->duration = avio_rb64(pb);\n            e->time     = avio_rb64(pb);\n            atom.size -= 16;\n        } else {\n            e->duration = avio_rb32(pb); /* segment duration */\n            e->time     = (int32_t)avio_rb32(pb); /* media time */\n            atom.size -= 8;\n        }\n        e->rate = avio_rb32(pb) / 65536.0;\n        atom.size -= 4;\n        av_log(c->fc, AV_LOG_TRACE, \"duration=%\"PRId64\" time=%\"PRId64\" rate=%f\\n\",\n               e->duration, e->time, e->rate);\n\n        if (e->time < 0 && e->time != -1 &&\n            c->fc->strict_std_compliance >= FF_COMPLIANCE_STRICT) {\n            av_log(c->fc, AV_LOG_ERROR, \"Track %d, edit %d: Invalid edit list media time=%\"PRId64\"\\n\",\n                   c->fc->nb_streams-1, i, e->time);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    sc->elst_count = i;\n\n    return 0;\n}\n\nstatic int mov_read_tmcd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n    sc->timecode_track = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_vpcc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int version, color_range, color_primaries, color_trc, color_space;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty VP Codec Configuration box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version != 1) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported VP Codec Configuration box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    avio_skip(pb, 2); /* profile + level */\n    color_range     = avio_r8(pb); /* bitDepth, chromaSubsampling, videoFullRangeFlag */\n    color_primaries = avio_r8(pb);\n    color_trc       = avio_r8(pb);\n    color_space     = avio_r8(pb);\n    if (avio_rb16(pb)) /* codecIntializationDataSize */\n        return AVERROR_INVALIDDATA;\n\n    if (!av_color_primaries_name(color_primaries))\n        color_primaries = AVCOL_PRI_UNSPECIFIED;\n    if (!av_color_transfer_name(color_trc))\n        color_trc = AVCOL_TRC_UNSPECIFIED;\n    if (!av_color_space_name(color_space))\n        color_space = AVCOL_SPC_UNSPECIFIED;\n\n    st->codecpar->color_range     = (color_range & 1) ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;\n    st->codecpar->color_primaries = color_primaries;\n    st->codecpar->color_trc       = color_trc;\n    st->codecpar->color_space     = color_space;\n\n    return 0;\n}\n\nstatic int mov_read_smdm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Mastering Display Metadata box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Mastering Display Metadata box version %d\\n\", version);\n        return 0;\n    }\n    if (sc->mastering)\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 3); /* flags */\n\n    sc->mastering = av_mastering_display_metadata_alloc();\n    if (!sc->mastering)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < 3; i++) {\n        sc->mastering->display_primaries[i][0] = av_make_q(avio_rb16(pb), 1 << 16);\n        sc->mastering->display_primaries[i][1] = av_make_q(avio_rb16(pb), 1 << 16);\n    }\n    sc->mastering->white_point[0] = av_make_q(avio_rb16(pb), 1 << 16);\n    sc->mastering->white_point[1] = av_make_q(avio_rb16(pb), 1 << 16);\n\n    sc->mastering->max_luminance = av_make_q(avio_rb32(pb), 1 << 8);\n    sc->mastering->min_luminance = av_make_q(avio_rb32(pb), 1 << 14);\n\n    sc->mastering->has_primaries = 1;\n    sc->mastering->has_luminance = 1;\n\n    return 0;\n}\n\nstatic int mov_read_mdcv(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    const int mapping[3] = {1, 2, 0};\n    const int chroma_den = 50000;\n    const int luma_den = 10000;\n    int i;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 24 || sc->mastering) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid Mastering Display Color Volume box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sc->mastering = av_mastering_display_metadata_alloc();\n    if (!sc->mastering)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < 3; i++) {\n        const int j = mapping[i];\n        sc->mastering->display_primaries[j][0] = av_make_q(avio_rb16(pb), chroma_den);\n        sc->mastering->display_primaries[j][1] = av_make_q(avio_rb16(pb), chroma_den);\n    }\n    sc->mastering->white_point[0] = av_make_q(avio_rb16(pb), chroma_den);\n    sc->mastering->white_point[1] = av_make_q(avio_rb16(pb), chroma_den);\n\n    sc->mastering->max_luminance = av_make_q(avio_rb32(pb), luma_den);\n    sc->mastering->min_luminance = av_make_q(avio_rb32(pb), luma_den);\n\n    sc->mastering->has_luminance = 1;\n    sc->mastering->has_primaries = 1;\n\n    return 0;\n}\n\nstatic int mov_read_coll(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Content Light Level box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Content Light Level box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    if (sc->coll){\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicate COLL\\n\");\n        return 0;\n    }\n\n    sc->coll = av_content_light_metadata_alloc(&sc->coll_size);\n    if (!sc->coll)\n        return AVERROR(ENOMEM);\n\n    sc->coll->MaxCLL  = avio_rb16(pb);\n    sc->coll->MaxFALL = avio_rb16(pb);\n\n    return 0;\n}\n\nstatic int mov_read_clli(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 4) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Content Light Level Info box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->coll){\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicate CLLI/COLL\\n\");\n        return 0;\n    }\n\n    sc->coll = av_content_light_metadata_alloc(&sc->coll_size);\n    if (!sc->coll)\n        return AVERROR(ENOMEM);\n\n    sc->coll->MaxCLL  = avio_rb16(pb);\n    sc->coll->MaxFALL = avio_rb16(pb);\n\n    return 0;\n}\n\nstatic int mov_read_st3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVStereo3DType type;\n    int mode;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty stereoscopic video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->stereo3d)\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 4); /* version + flags */\n\n    mode = avio_r8(pb);\n    switch (mode) {\n    case 0:\n        type = AV_STEREO3D_2D;\n        break;\n    case 1:\n        type = AV_STEREO3D_TOPBOTTOM;\n        break;\n    case 2:\n        type = AV_STEREO3D_SIDEBYSIDE;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown st3d mode value %d\\n\", mode);\n        return 0;\n    }\n\n    sc->stereo3d = av_stereo3d_alloc();\n    if (!sc->stereo3d)\n        return AVERROR(ENOMEM);\n\n    sc->stereo3d->type = type;\n    return 0;\n}\n\nstatic int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int size, version, layout;\n    int32_t yaw, pitch, roll;\n    uint32_t l = 0, t = 0, r = 0, b = 0;\n    uint32_t tag, padding = 0;\n    enum AVSphericalProjection projection;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 8) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty spherical video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = avio_rb32(pb);\n    if (size <= 12 || size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('s','v','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing spherical video header\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    avio_skip(pb, size - 12); /* metadata_source */\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','o','j')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection box\\n\");\n        return 0;\n    }\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection header box\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    /* 16.16 fixed point */\n    yaw   = avio_rb32(pb);\n    pitch = avio_rb32(pb);\n    roll  = avio_rb32(pb);\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    switch (tag) {\n    case MKTAG('c','b','m','p'):\n        layout = avio_rb32(pb);\n        if (layout) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Unsupported cubemap layout %d\\n\", layout);\n            return 0;\n        }\n        projection = AV_SPHERICAL_CUBEMAP;\n        padding = avio_rb32(pb);\n        break;\n    case MKTAG('e','q','u','i'):\n        t = avio_rb32(pb);\n        b = avio_rb32(pb);\n        l = avio_rb32(pb);\n        r = avio_rb32(pb);\n\n        if (b >= UINT_MAX - t || r >= UINT_MAX - l) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"Invalid bounding rectangle coordinates \"\n                   \"%\"PRIu32\",%\"PRIu32\",%\"PRIu32\",%\"PRIu32\"\\n\", l, t, r, b);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (l || t || r || b)\n            projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE;\n        else\n            projection = AV_SPHERICAL_EQUIRECTANGULAR;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown projection type: %s\\n\", av_fourcc2str(tag));\n        return 0;\n    }\n\n    sc->spherical = av_spherical_alloc(&sc->spherical_size);\n    if (!sc->spherical)\n        return AVERROR(ENOMEM);\n\n    sc->spherical->projection = projection;\n\n    sc->spherical->yaw   = yaw;\n    sc->spherical->pitch = pitch;\n    sc->spherical->roll  = roll;\n\n    sc->spherical->padding = padding;\n\n    sc->spherical->bound_left   = l;\n    sc->spherical->bound_top    = t;\n    sc->spherical->bound_right  = r;\n    sc->spherical->bound_bottom = b;\n\n    return 0;\n}\n\nstatic int mov_parse_uuid_spherical(MOVStreamContext *sc, AVIOContext *pb, size_t len)\n{\n    int ret = 0;\n    uint8_t *buffer = av_malloc(len + 1);\n    const char *val;\n\n    if (!buffer)\n        return AVERROR(ENOMEM);\n    buffer[len] = '\\0';\n\n    ret = ffio_read_size(pb, buffer, len);\n    if (ret < 0)\n        goto out;\n\n    /* Check for mandatory keys and values, try to support XML as best-effort */\n    if (!sc->spherical &&\n        av_stristr(buffer, \"<GSpherical:StitchingSoftware>\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Spherical>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Stitched>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:ProjectionType>\")) &&\n        av_stristr(val, \"equirectangular\")) {\n        sc->spherical = av_spherical_alloc(&sc->spherical_size);\n        if (!sc->spherical)\n            goto out;\n\n        sc->spherical->projection = AV_SPHERICAL_EQUIRECTANGULAR;\n\n        if (av_stristr(buffer, \"<GSpherical:StereoMode>\") && !sc->stereo3d) {\n            enum AVStereo3DType mode;\n\n            if (av_stristr(buffer, \"left-right\"))\n                mode = AV_STEREO3D_SIDEBYSIDE;\n            else if (av_stristr(buffer, \"top-bottom\"))\n                mode = AV_STEREO3D_TOPBOTTOM;\n            else\n                mode = AV_STEREO3D_2D;\n\n            sc->stereo3d = av_stereo3d_alloc();\n            if (!sc->stereo3d)\n                goto out;\n\n            sc->stereo3d->type = mode;\n        }\n\n        /* orientation */\n        val = av_stristr(buffer, \"<GSpherical:InitialViewHeadingDegrees>\");\n        if (val)\n            sc->spherical->yaw = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewPitchDegrees>\");\n        if (val)\n            sc->spherical->pitch = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewRollDegrees>\");\n        if (val)\n            sc->spherical->roll = strtol(val, NULL, 10) * (1 << 16);\n    }\n\nout:\n    av_free(buffer);\n    return ret;\n}\n\nstatic int mov_read_uuid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t ret;\n    AVUUID uuid;\n    static const AVUUID uuid_isml_manifest = {\n        0xa5, 0xd4, 0x0b, 0x30, 0xe8, 0x14, 0x11, 0xdd,\n        0xba, 0x2f, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66\n    };\n    static const AVUUID uuid_xmp = {\n        0xbe, 0x7a, 0xcf, 0xcb, 0x97, 0xa9, 0x42, 0xe8,\n        0x9c, 0x71, 0x99, 0x94, 0x91, 0xe3, 0xaf, 0xac\n    };\n    static const AVUUID uuid_spherical = {\n        0xff, 0xcc, 0x82, 0x63, 0xf8, 0x55, 0x4a, 0x93,\n        0x88, 0x14, 0x58, 0x7a, 0x02, 0x52, 0x1f, 0xdd,\n    };\n\n    if (atom.size < AV_UUID_LEN || atom.size >= FFMIN(INT_MAX, SIZE_MAX))\n        return AVERROR_INVALIDDATA;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    ret = ffio_read_size(pb, uuid, AV_UUID_LEN);\n    if (ret < 0)\n        return ret;\n    if (av_uuid_equal(uuid, uuid_isml_manifest)) {\n        uint8_t *buffer, *ptr;\n        char *endptr;\n        size_t len = atom.size - AV_UUID_LEN;\n\n        if (len < 4) {\n            return AVERROR_INVALIDDATA;\n        }\n        ret = avio_skip(pb, 4); // zeroes\n        len -= 4;\n\n        buffer = av_mallocz(len + 1);\n        if (!buffer) {\n            return AVERROR(ENOMEM);\n        }\n        ret = ffio_read_size(pb, buffer, len);\n        if (ret < 0) {\n            av_free(buffer);\n            return ret;\n        }\n\n        ptr = buffer;\n        while ((ptr = av_stristr(ptr, \"systemBitrate=\\\"\"))) {\n            ptr += sizeof(\"systemBitrate=\\\"\") - 1;\n            c->bitrates_count++;\n            c->bitrates = av_realloc_f(c->bitrates, c->bitrates_count, sizeof(*c->bitrates));\n            if (!c->bitrates) {\n                c->bitrates_count = 0;\n                av_free(buffer);\n                return AVERROR(ENOMEM);\n            }\n            errno = 0;\n            ret = strtol(ptr, &endptr, 10);\n            if (ret < 0 || errno || *endptr != '\"') {\n                c->bitrates[c->bitrates_count - 1] = 0;\n            } else {\n                c->bitrates[c->bitrates_count - 1] = ret;\n            }\n        }\n\n        av_free(buffer);\n    } else if (av_uuid_equal(uuid, uuid_xmp)) {\n        uint8_t *buffer;\n        size_t len = atom.size - AV_UUID_LEN;\n        if (c->export_xmp) {\n            buffer = av_mallocz(len + 1);\n            if (!buffer) {\n                return AVERROR(ENOMEM);\n            }\n            ret = ffio_read_size(pb, buffer, len);\n            if (ret < 0) {\n                av_free(buffer);\n                return ret;\n            }\n            buffer[len] = '\\0';\n            av_dict_set(&c->fc->metadata, \"xmp\",\n                        buffer, AV_DICT_DONT_STRDUP_VAL);\n        } else {\n            // skip all uuid atom, which makes it fast for long uuid-xmp file\n            ret = avio_skip(pb, len);\n            if (ret < 0)\n                return ret;\n        }\n    } else if (av_uuid_equal(uuid, uuid_spherical)) {\n        size_t len = atom.size - AV_UUID_LEN;\n        ret = mov_parse_uuid_spherical(sc, pb, len);\n        if (ret < 0)\n            return ret;\n        if (!sc->spherical)\n            av_log(c->fc, AV_LOG_WARNING, \"Invalid spherical metadata found\\n\");\n    }\n\n    return 0;\n}\n\nstatic int mov_read_free(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    uint8_t content[16];\n\n    if (atom.size < 8)\n        return 0;\n\n    ret = avio_read(pb, content, FFMIN(sizeof(content), atom.size));\n    if (ret < 0)\n        return ret;\n\n    if (   !c->found_moov\n        && !c->found_mdat\n        && !memcmp(content, \"Anevia\\x1A\\x1A\", 8)\n        && c->use_mfra_for == FF_MOV_FLAG_MFRA_AUTO) {\n        c->use_mfra_for = FF_MOV_FLAG_MFRA_PTS;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_frma(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t format = avio_rl32(pb);\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    switch (sc->format)\n    {\n    case MKTAG('e','n','c','v'):        // encrypted video\n    case MKTAG('e','n','c','a'):        // encrypted audio\n        id = mov_codec_id(st, format);\n        if (st->codecpar->codec_id != AV_CODEC_ID_NONE &&\n            st->codecpar->codec_id != id) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream has codec id %d\\n\",\n                   (char*)&format, st->codecpar->codec_id);\n            break;\n        }\n\n        st->codecpar->codec_id = id;\n        sc->format = format;\n        break;\n\n    default:\n        if (format != sc->format) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream format is '%.4s'\\n\",\n                   (char*)&format, (char*)&sc->format);\n        }\n        break;\n    }\n\n    return 0;\n}\n\n/**\n * Gets the current encryption info and associated current stream context.  If\n * we are parsing a track fragment, this will return the specific encryption\n * info for this fragment; otherwise this will return the global encryption\n * info for the current stream.\n */\nstatic int get_current_encryption_info(MOVContext *c, MOVEncryptionIndex **encryption_index, MOVStreamContext **sc)\n{\n    MOVFragmentStreamInfo *frag_stream_info;\n    AVStream *st;\n    int i;\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info) {\n        for (i = 0; i < c->fc->nb_streams; i++) {\n            if (c->fc->streams[i]->id == frag_stream_info->id) {\n              st = c->fc->streams[i];\n              break;\n            }\n        }\n        if (i == c->fc->nb_streams)\n            return 0;\n        *sc = st->priv_data;\n\n        if (!frag_stream_info->encryption_index) {\n            // If this stream isn't encrypted, don't create the index.\n            if (!(*sc)->cenc.default_encrypted_sample)\n                return 0;\n            frag_stream_info->encryption_index = av_mallocz(sizeof(*frag_stream_info->encryption_index));\n            if (!frag_stream_info->encryption_index)\n                return AVERROR(ENOMEM);\n        }\n        *encryption_index = frag_stream_info->encryption_index;\n        return 1;\n    } else {\n        // No current track fragment, using stream level encryption info.\n\n        if (c->fc->nb_streams < 1)\n            return 0;\n        st = c->fc->streams[c->fc->nb_streams - 1];\n        *sc = st->priv_data;\n\n        if (!(*sc)->cenc.encryption_index) {\n            // If this stream isn't encrypted, don't create the index.\n            if (!(*sc)->cenc.default_encrypted_sample)\n                return 0;\n            (*sc)->cenc.encryption_index = av_mallocz(sizeof(*frag_stream_info->encryption_index));\n            if (!(*sc)->cenc.encryption_index)\n                return AVERROR(ENOMEM);\n        }\n\n        *encryption_index = (*sc)->cenc.encryption_index;\n        return 1;\n    }\n}\n\nstatic int mov_read_sample_encryption_info(MOVContext *c, AVIOContext *pb, MOVStreamContext *sc, AVEncryptionInfo **sample, int use_subsamples)\n{\n    int i, ret;\n    unsigned int subsample_count;\n    AVSubsampleEncryptionInfo *subsamples;\n\n    if (!sc->cenc.default_encrypted_sample) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing schm or tenc\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    *sample = av_encryption_info_clone(sc->cenc.default_encrypted_sample);\n    if (!*sample)\n        return AVERROR(ENOMEM);\n\n    if (sc->cenc.per_sample_iv_size != 0) {\n        if ((ret = ffio_read_size(pb, (*sample)->iv, sc->cenc.per_sample_iv_size)) < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"failed to read the initialization vector\\n\");\n            av_encryption_info_free(*sample);\n            *sample = NULL;\n            return ret;\n        }\n    }\n\n    if (use_subsamples) {\n        subsample_count = avio_rb16(pb);\n        av_free((*sample)->subsamples);\n        (*sample)->subsamples = av_calloc(subsample_count, sizeof(*subsamples));\n        if (!(*sample)->subsamples) {\n            av_encryption_info_free(*sample);\n            *sample = NULL;\n            return AVERROR(ENOMEM);\n        }\n\n        for (i = 0; i < subsample_count && !pb->eof_reached; i++) {\n            (*sample)->subsamples[i].bytes_of_clear_data = avio_rb16(pb);\n            (*sample)->subsamples[i].bytes_of_protected_data = avio_rb32(pb);\n        }\n\n        if (pb->eof_reached) {\n            av_log(c->fc, AV_LOG_ERROR, \"hit EOF while reading sub-sample encryption info\\n\");\n            av_encryption_info_free(*sample);\n            *sample = NULL;\n            return AVERROR_INVALIDDATA;\n        }\n        (*sample)->subsample_count = subsample_count;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_senc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVEncryptionInfo **encrypted_samples;\n    MOVEncryptionIndex *encryption_index;\n    MOVStreamContext *sc;\n    int use_subsamples, ret;\n    unsigned int sample_count, i, alloc_size = 0;\n\n    ret = get_current_encryption_info(c, &encryption_index, &sc);\n    if (ret != 1)\n        return ret;\n\n    if (encryption_index->nb_encrypted_samples) {\n        // This can happen if we have both saio/saiz and senc atoms.\n        av_log(c->fc, AV_LOG_DEBUG, \"Ignoring duplicate encryption info in senc\\n\");\n        return 0;\n    }\n\n    avio_r8(pb); /* version */\n    use_subsamples = avio_rb24(pb) & 0x02; /* flags */\n\n    sample_count = avio_rb32(pb);\n    if (sample_count >= INT_MAX / sizeof(*encrypted_samples))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < sample_count; i++) {\n        unsigned int min_samples = FFMIN(FFMAX(i + 1, 1024 * 1024), sample_count);\n        encrypted_samples = av_fast_realloc(encryption_index->encrypted_samples, &alloc_size,\n                                            min_samples * sizeof(*encrypted_samples));\n        if (encrypted_samples) {\n            encryption_index->encrypted_samples = encrypted_samples;\n\n            ret = mov_read_sample_encryption_info(\n                c, pb, sc, &encryption_index->encrypted_samples[i], use_subsamples);\n        } else {\n            ret = AVERROR(ENOMEM);\n        }\n        if (pb->eof_reached) {\n            av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading senc\\n\");\n            if (ret >= 0)\n                av_encryption_info_free(encryption_index->encrypted_samples[i]);\n            ret = AVERROR_INVALIDDATA;\n        }\n\n        if (ret < 0) {\n            for (; i > 0; i--)\n                av_encryption_info_free(encryption_index->encrypted_samples[i - 1]);\n            av_freep(&encryption_index->encrypted_samples);\n            return ret;\n        }\n    }\n    encryption_index->nb_encrypted_samples = sample_count;\n\n    return 0;\n}\n\nstatic int mov_parse_auxiliary_info(MOVContext *c, MOVStreamContext *sc, AVIOContext *pb, MOVEncryptionIndex *encryption_index)\n{\n    AVEncryptionInfo **sample, **encrypted_samples;\n    int64_t prev_pos;\n    size_t sample_count, sample_info_size, i;\n    int ret = 0;\n    unsigned int alloc_size = 0;\n\n    if (encryption_index->nb_encrypted_samples)\n        return 0;\n    sample_count = encryption_index->auxiliary_info_sample_count;\n    if (encryption_index->auxiliary_offsets_count != 1) {\n        av_log(c->fc, AV_LOG_ERROR, \"Multiple auxiliary info chunks are not supported\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    if (sample_count >= INT_MAX / sizeof(*encrypted_samples))\n        return AVERROR(ENOMEM);\n\n    prev_pos = avio_tell(pb);\n    if (!(pb->seekable & AVIO_SEEKABLE_NORMAL) ||\n        avio_seek(pb, encryption_index->auxiliary_offsets[0], SEEK_SET) != encryption_index->auxiliary_offsets[0]) {\n        av_log(c->fc, AV_LOG_INFO, \"Failed to seek for auxiliary info, will only parse senc atoms for encryption info\\n\");\n        goto finish;\n    }\n\n    for (i = 0; i < sample_count && !pb->eof_reached; i++) {\n        unsigned int min_samples = FFMIN(FFMAX(i + 1, 1024 * 1024), sample_count);\n        encrypted_samples = av_fast_realloc(encryption_index->encrypted_samples, &alloc_size,\n                                            min_samples * sizeof(*encrypted_samples));\n        if (!encrypted_samples) {\n            ret = AVERROR(ENOMEM);\n            goto finish;\n        }\n        encryption_index->encrypted_samples = encrypted_samples;\n\n        sample = &encryption_index->encrypted_samples[i];\n        sample_info_size = encryption_index->auxiliary_info_default_size\n                               ? encryption_index->auxiliary_info_default_size\n                               : encryption_index->auxiliary_info_sizes[i];\n\n        ret = mov_read_sample_encryption_info(c, pb, sc, sample, sample_info_size > sc->cenc.per_sample_iv_size);\n        if (ret < 0)\n            goto finish;\n    }\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading auxiliary info\\n\");\n        ret = AVERROR_INVALIDDATA;\n    } else {\n        encryption_index->nb_encrypted_samples = sample_count;\n    }\n\nfinish:\n    avio_seek(pb, prev_pos, SEEK_SET);\n    if (ret < 0) {\n        for (; i > 0; i--) {\n            av_encryption_info_free(encryption_index->encrypted_samples[i - 1]);\n        }\n        av_freep(&encryption_index->encrypted_samples);\n    }\n    return ret;\n}\n\n/**\n * Tries to read the given number of bytes from the stream and puts it in a\n * newly allocated buffer.  This reads in small chunks to avoid allocating large\n * memory if the file contains an invalid/malicious size value.\n */\nstatic int mov_try_read_block(AVIOContext *pb, size_t size, uint8_t **data)\n{\n    const unsigned int block_size = 1024 * 1024;\n    uint8_t *buffer = NULL;\n    unsigned int alloc_size = 0, offset = 0;\n    while (offset < size) {\n        unsigned int new_size =\n            alloc_size >= INT_MAX - block_size ? INT_MAX : alloc_size + block_size;\n        uint8_t *new_buffer = av_fast_realloc(buffer, &alloc_size, new_size);\n        unsigned int to_read = FFMIN(size, alloc_size) - offset;\n        if (!new_buffer) {\n            av_free(buffer);\n            return AVERROR(ENOMEM);\n        }\n        buffer = new_buffer;\n\n        if (avio_read(pb, buffer + offset, to_read) != to_read) {\n            av_free(buffer);\n            return AVERROR_INVALIDDATA;\n        }\n        offset += to_read;\n    }\n\n    *data = buffer;\n    return 0;\n}\n\nstatic int mov_read_saiz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVEncryptionIndex *encryption_index;\n    MOVStreamContext *sc;\n    int ret;\n    unsigned int sample_count, aux_info_type, aux_info_param;\n\n    ret = get_current_encryption_info(c, &encryption_index, &sc);\n    if (ret != 1)\n        return ret;\n\n    if (encryption_index->nb_encrypted_samples) {\n        // This can happen if we have both saio/saiz and senc atoms.\n        av_log(c->fc, AV_LOG_DEBUG, \"Ignoring duplicate encryption info in saiz\\n\");\n        return 0;\n    }\n\n    if (encryption_index->auxiliary_info_sample_count) {\n        av_log(c->fc, AV_LOG_ERROR, \"Duplicate saiz atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_r8(pb); /* version */\n    if (avio_rb24(pb) & 0x01) {  /* flags */\n        aux_info_type = avio_rb32(pb);\n        aux_info_param = avio_rb32(pb);\n        if (sc->cenc.default_encrypted_sample) {\n            if (aux_info_type != sc->cenc.default_encrypted_sample->scheme) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saiz box with non-zero aux_info_type\\n\");\n                return 0;\n            }\n            if (aux_info_param != 0) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saiz box with non-zero aux_info_type_parameter\\n\");\n                return 0;\n            }\n        } else {\n            // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n            if ((aux_info_type == MKBETAG('c','e','n','c') ||\n                 aux_info_type == MKBETAG('c','e','n','s') ||\n                 aux_info_type == MKBETAG('c','b','c','1') ||\n                 aux_info_type == MKBETAG('c','b','c','s')) &&\n                aux_info_param == 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Saw encrypted saiz without schm/tenc\\n\");\n                return AVERROR_INVALIDDATA;\n            } else {\n                return 0;\n            }\n        }\n    } else if (!sc->cenc.default_encrypted_sample) {\n        // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n        return 0;\n    }\n\n    encryption_index->auxiliary_info_default_size = avio_r8(pb);\n    sample_count = avio_rb32(pb);\n    encryption_index->auxiliary_info_sample_count = sample_count;\n\n    if (encryption_index->auxiliary_info_default_size == 0) {\n        ret = mov_try_read_block(pb, sample_count, &encryption_index->auxiliary_info_sizes);\n        if (ret < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to read the auxiliary info\\n\");\n            return ret;\n        }\n    }\n\n    if (encryption_index->auxiliary_offsets_count) {\n        return mov_parse_auxiliary_info(c, sc, pb, encryption_index);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_saio(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint64_t *auxiliary_offsets;\n    MOVEncryptionIndex *encryption_index;\n    MOVStreamContext *sc;\n    int i, ret;\n    unsigned int version, entry_count, aux_info_type, aux_info_param;\n    unsigned int alloc_size = 0;\n\n    ret = get_current_encryption_info(c, &encryption_index, &sc);\n    if (ret != 1)\n        return ret;\n\n    if (encryption_index->nb_encrypted_samples) {\n        // This can happen if we have both saio/saiz and senc atoms.\n        av_log(c->fc, AV_LOG_DEBUG, \"Ignoring duplicate encryption info in saio\\n\");\n        return 0;\n    }\n\n    if (encryption_index->auxiliary_offsets_count) {\n        av_log(c->fc, AV_LOG_ERROR, \"Duplicate saio atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb); /* version */\n    if (avio_rb24(pb) & 0x01) {  /* flags */\n        aux_info_type = avio_rb32(pb);\n        aux_info_param = avio_rb32(pb);\n        if (sc->cenc.default_encrypted_sample) {\n            if (aux_info_type != sc->cenc.default_encrypted_sample->scheme) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saio box with non-zero aux_info_type\\n\");\n                return 0;\n            }\n            if (aux_info_param != 0) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saio box with non-zero aux_info_type_parameter\\n\");\n                return 0;\n            }\n        } else {\n            // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n            if ((aux_info_type == MKBETAG('c','e','n','c') ||\n                 aux_info_type == MKBETAG('c','e','n','s') ||\n                 aux_info_type == MKBETAG('c','b','c','1') ||\n                 aux_info_type == MKBETAG('c','b','c','s')) &&\n                aux_info_param == 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Saw encrypted saio without schm/tenc\\n\");\n                return AVERROR_INVALIDDATA;\n            } else {\n                return 0;\n            }\n        }\n    } else if (!sc->cenc.default_encrypted_sample) {\n        // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n        return 0;\n    }\n\n    entry_count = avio_rb32(pb);\n    if (entry_count >= INT_MAX / sizeof(*auxiliary_offsets))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entry_count && !pb->eof_reached; i++) {\n        unsigned int min_offsets = FFMIN(FFMAX(i + 1, 1024), entry_count);\n        auxiliary_offsets = av_fast_realloc(\n            encryption_index->auxiliary_offsets, &alloc_size,\n            min_offsets * sizeof(*auxiliary_offsets));\n        if (!auxiliary_offsets) {\n            av_freep(&encryption_index->auxiliary_offsets);\n            return AVERROR(ENOMEM);\n        }\n        encryption_index->auxiliary_offsets = auxiliary_offsets;\n\n        if (version == 0) {\n            encryption_index->auxiliary_offsets[i] = avio_rb32(pb);\n        } else {\n            encryption_index->auxiliary_offsets[i] = avio_rb64(pb);\n        }\n        if (c->frag_index.current >= 0) {\n            encryption_index->auxiliary_offsets[i] += c->fragment.base_data_offset;\n        }\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading saio\\n\");\n        av_freep(&encryption_index->auxiliary_offsets);\n        return AVERROR_INVALIDDATA;\n    }\n\n    encryption_index->auxiliary_offsets_count = entry_count;\n\n    if (encryption_index->auxiliary_info_sample_count) {\n        return mov_parse_auxiliary_info(c, sc, pb, encryption_index);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_pssh(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVEncryptionInitInfo *info, *old_init_info;\n    uint8_t **key_ids;\n    AVStream *st;\n    uint8_t *side_data, *extra_data, *old_side_data;\n    size_t side_data_size, old_side_data_size;\n    int ret = 0;\n    unsigned int version, kid_count, extra_data_size, alloc_size = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb);  /* flags */\n\n    info = av_encryption_init_info_alloc(/* system_id_size */ 16, /* num_key_ids */ 0,\n                                         /* key_id_size */ 16, /* data_size */ 0);\n    if (!info)\n        return AVERROR(ENOMEM);\n\n    if ((ret = ffio_read_size(pb, info->system_id, 16)) < 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Failed to read the system id\\n\");\n        goto finish;\n    }\n\n    if (version > 0) {\n        kid_count = avio_rb32(pb);\n        if (kid_count >= INT_MAX / sizeof(*key_ids)) {\n            ret = AVERROR(ENOMEM);\n            goto finish;\n        }\n\n        for (unsigned int i = 0; i < kid_count && !pb->eof_reached; i++) {\n            unsigned int min_kid_count = FFMIN(FFMAX(i + 1, 1024), kid_count);\n            key_ids = av_fast_realloc(info->key_ids, &alloc_size,\n                                      min_kid_count * sizeof(*key_ids));\n            if (!key_ids) {\n                ret = AVERROR(ENOMEM);\n                goto finish;\n            }\n            info->key_ids = key_ids;\n\n            info->key_ids[i] = av_mallocz(16);\n            if (!info->key_ids[i]) {\n                ret = AVERROR(ENOMEM);\n                goto finish;\n            }\n            info->num_key_ids = i + 1;\n\n            if ((ret = ffio_read_size(pb, info->key_ids[i], 16)) < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Failed to read the key id\\n\");\n                goto finish;\n            }\n        }\n\n        if (pb->eof_reached) {\n            av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading pssh\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto finish;\n        }\n    }\n\n    extra_data_size = avio_rb32(pb);\n    ret = mov_try_read_block(pb, extra_data_size, &extra_data);\n    if (ret < 0)\n        goto finish;\n\n    av_freep(&info->data);  // malloc(0) may still allocate something.\n    info->data = extra_data;\n    info->data_size = extra_data_size;\n\n    // If there is existing initialization data, append to the list.\n    old_side_data = av_stream_get_side_data(st, AV_PKT_DATA_ENCRYPTION_INIT_INFO, &old_side_data_size);\n    if (old_side_data) {\n        old_init_info = av_encryption_init_info_get_side_data(old_side_data, old_side_data_size);\n        if (old_init_info) {\n            // Append to the end of the list.\n            for (AVEncryptionInitInfo *cur = old_init_info;; cur = cur->next) {\n                if (!cur->next) {\n                    cur->next = info;\n                    break;\n                }\n            }\n            info = old_init_info;\n        } else {\n            // Assume existing side-data will be valid, so the only error we could get is OOM.\n            ret = AVERROR(ENOMEM);\n            goto finish;\n        }\n    }\n\n    side_data = av_encryption_init_info_add_side_data(info, &side_data_size);\n    if (!side_data) {\n        ret = AVERROR(ENOMEM);\n        goto finish;\n    }\n    ret = av_stream_add_side_data(st, AV_PKT_DATA_ENCRYPTION_INIT_INFO,\n                                  side_data, side_data_size);\n    if (ret < 0)\n        av_free(side_data);\n\nfinish:\n    av_encryption_init_info_free(info);\n    return ret;\n}\n\nstatic int mov_read_schm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->pseudo_stream_id != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"schm boxes are only supported in first sample descriptor\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (atom.size < 8)\n        return AVERROR_INVALIDDATA;\n\n    avio_rb32(pb); /* version and flags */\n\n    if (!sc->cenc.default_encrypted_sample) {\n        sc->cenc.default_encrypted_sample = av_encryption_info_alloc(0, 16, 16);\n        if (!sc->cenc.default_encrypted_sample) {\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    sc->cenc.default_encrypted_sample->scheme = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_tenc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int version, pattern, is_protected, iv_size;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->pseudo_stream_id != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"tenc atom are only supported in first sample descriptor\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (!sc->cenc.default_encrypted_sample) {\n        sc->cenc.default_encrypted_sample = av_encryption_info_alloc(0, 16, 16);\n        if (!sc->cenc.default_encrypted_sample) {\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    if (atom.size < 20)\n        return AVERROR_INVALIDDATA;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    avio_r8(pb); /* reserved */\n    pattern = avio_r8(pb);\n\n    if (version > 0) {\n        sc->cenc.default_encrypted_sample->crypt_byte_block = pattern >> 4;\n        sc->cenc.default_encrypted_sample->skip_byte_block = pattern & 0xf;\n    }\n\n    is_protected = avio_r8(pb);\n    if (is_protected && !sc->cenc.encryption_index) {\n        // The whole stream should be by-default encrypted.\n        sc->cenc.encryption_index = av_mallocz(sizeof(MOVEncryptionIndex));\n        if (!sc->cenc.encryption_index)\n            return AVERROR(ENOMEM);\n    }\n    sc->cenc.per_sample_iv_size = avio_r8(pb);\n    if (sc->cenc.per_sample_iv_size != 0 && sc->cenc.per_sample_iv_size != 8 &&\n        sc->cenc.per_sample_iv_size != 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid per-sample IV size value\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (avio_read(pb, sc->cenc.default_encrypted_sample->key_id, 16) != 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read the default key ID\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (is_protected && !sc->cenc.per_sample_iv_size) {\n        iv_size = avio_r8(pb);\n        if (iv_size != 8 && iv_size != 16) {\n            av_log(c->fc, AV_LOG_ERROR, \"invalid default_constant_IV_size in tenc atom\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (avio_read(pb, sc->cenc.default_encrypted_sample->iv, iv_size) != iv_size) {\n            av_log(c->fc, AV_LOG_ERROR, \"failed to read the default IV\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n\n    /* Check FlacSpecificBox version. */\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n\n    avio_rb24(pb); /* Flags */\n\n    if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n        return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n    }\n    flac_parse_block_header(buf, &last, &type, &size);\n\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n\n    return 0;\n}\n\nstatic int cenc_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int bytes_of_protected_data;\n\n    if (!sc->cenc.aes_ctr) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n\n        bytes_of_protected_data = sample->subsamples[i].bytes_of_protected_data;\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, bytes_of_protected_data);\n\n        input += bytes_of_protected_data;\n        size -= bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cbc1_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int num_of_encrypted_blocks;\n    uint8_t iv[16];\n\n    if (!sc->cenc.aes_ctx) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctx = av_aes_alloc();\n        if (!sc->cenc.aes_ctx) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_init(sc->cenc.aes_ctx, c->decryption_key, 16 * 8, 1);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    memcpy(iv, sample->iv, 16);\n\n    /* whole-block full sample encryption */\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        av_aes_crypt(sc->cenc.aes_ctx, input, input, size/16, iv, 1);\n        return 0;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (sample->subsamples[i].bytes_of_protected_data % 16) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample BytesOfProtectedData is not a multiple of 16\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n        num_of_encrypted_blocks = sample->subsamples[i].bytes_of_protected_data/16;\n        if (num_of_encrypted_blocks > 0) {\n            av_aes_crypt(sc->cenc.aes_ctx, input, input, num_of_encrypted_blocks, iv, 1);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cens_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t *data;\n\n    if (!sc->cenc.aes_ctr) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n\n    /* whole-block full sample encryption */\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cens' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_ctr_crypt(sc->cenc.aes_ctr, data, data, 16*sample->crypt_byte_block);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cbcs_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t iv[16];\n    uint8_t *data;\n\n    if (!sc->cenc.aes_ctx) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctx = av_aes_alloc();\n        if (!sc->cenc.aes_ctx) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_init(sc->cenc.aes_ctx, c->decryption_key, 16 * 8, 1);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    /* whole-block full sample encryption */\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        memcpy(iv, sample->iv, 16);\n        av_aes_crypt(sc->cenc.aes_ctx, input, input, size/16, iv, 1);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cbcs' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n        memcpy(iv, sample->iv, 16);\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_crypt(sc->cenc.aes_ctx, data, data, sample->crypt_byte_block, iv, 1);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cenc_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    if (sample->scheme == MKBETAG('c','e','n','c') && !sample->crypt_byte_block && !sample->skip_byte_block) {\n        return cenc_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','b','c','1') && !sample->crypt_byte_block && !sample->skip_byte_block) {\n        return cbc1_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','e','n','s')) {\n        return cens_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','b','c','s')) {\n        return cbcs_scheme_decrypt(c, sc, sample, input, size);\n    } else {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid encryption scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n}\n\nstatic MOVFragmentStreamInfo *get_frag_stream_info_from_pkt(MOVFragmentIndex *frag_index, AVPacket *pkt, int id)\n{\n    int current = frag_index->current;\n\n    if (!frag_index->nb_items)\n        return NULL;\n\n    // Check frag_index->current is the right one for pkt. It can out of sync.\n    if (current >= 0 && current < frag_index->nb_items) {\n        if (frag_index->item[current].moof_offset < pkt->pos &&\n            (current + 1 == frag_index->nb_items ||\n             frag_index->item[current + 1].moof_offset > pkt->pos))\n            return get_frag_stream_info(frag_index, current, id);\n    }\n\n\n    for (int i = 0; i < frag_index->nb_items; i++) {\n        if (frag_index->item[i].moof_offset > pkt->pos)\n            break;\n        current = i;\n    }\n    frag_index->current = current;\n    return get_frag_stream_info(frag_index, current, id);\n}\n\nstatic int cenc_filter(MOVContext *mov, AVStream* st, MOVStreamContext *sc, AVPacket *pkt, int current_index)\n{\n    MOVFragmentStreamInfo *frag_stream_info;\n    MOVEncryptionIndex *encryption_index;\n    AVEncryptionInfo *encrypted_sample;\n    int encrypted_index, ret;\n\n    frag_stream_info = get_frag_stream_info_from_pkt(&mov->frag_index, pkt, st->id);\n    encrypted_index = current_index;\n    encryption_index = NULL;\n    if (frag_stream_info) {\n        // Note this only supports encryption info in the first sample descriptor.\n        if (mov->fragment.stsd_id == 1) {\n            if (frag_stream_info->encryption_index) {\n                encrypted_index = current_index - frag_stream_info->index_base;\n                encryption_index = frag_stream_info->encryption_index;\n            } else {\n                encryption_index = sc->cenc.encryption_index;\n            }\n        }\n    } else {\n        encryption_index = sc->cenc.encryption_index;\n    }\n\n    if (encryption_index) {\n        if (encryption_index->auxiliary_info_sample_count &&\n            !encryption_index->nb_encrypted_samples) {\n            av_log(mov->fc, AV_LOG_ERROR, \"saiz atom found without saio\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (encryption_index->auxiliary_offsets_count &&\n            !encryption_index->nb_encrypted_samples) {\n            av_log(mov->fc, AV_LOG_ERROR, \"saio atom found without saiz\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!encryption_index->nb_encrypted_samples) {\n            // Full-sample encryption with default settings.\n            encrypted_sample = sc->cenc.default_encrypted_sample;\n        } else if (encrypted_index >= 0 && encrypted_index < encryption_index->nb_encrypted_samples) {\n            // Per-sample setting override.\n            encrypted_sample = encryption_index->encrypted_samples[encrypted_index];\n        } else {\n            av_log(mov->fc, AV_LOG_ERROR, \"Incorrect number of samples in encryption info\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (mov->decryption_key) {\n            return cenc_decrypt(mov, sc, encrypted_sample, pkt->data, pkt->size);\n        } else {\n            size_t size;\n            uint8_t *side_data = av_encryption_info_add_side_data(encrypted_sample, &size);\n            if (!side_data)\n                return AVERROR(ENOMEM);\n            ret = av_packet_add_side_data(pkt, AV_PKT_DATA_ENCRYPTION_INFO, side_data, size);\n            if (ret < 0)\n                av_free(side_data);\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_read_dops(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int OPUS_SEEK_PREROLL_MS = 80;\n    int ret;\n    AVStream *st;\n    size_t size;\n    uint16_t pre_skip;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 11)\n        return AVERROR_INVALIDDATA;\n\n    /* Check OpusSpecificBox version. */\n    if (avio_r8(pb) != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"unsupported OpusSpecificBox version\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* OpusSpecificBox size plus magic for Ogg OpusHead header. */\n    size = atom.size + 8;\n\n    if ((ret = ff_alloc_extradata(st->codecpar, size)) < 0)\n        return ret;\n\n    AV_WL32(st->codecpar->extradata, MKTAG('O','p','u','s'));\n    AV_WL32(st->codecpar->extradata + 4, MKTAG('H','e','a','d'));\n    AV_WB8(st->codecpar->extradata + 8, 1); /* OpusHead version */\n    avio_read(pb, st->codecpar->extradata + 9, size - 9);\n\n    /* OpusSpecificBox is stored in big-endian, but OpusHead is\n       little-endian; aside from the preceeding magic and version they're\n       otherwise currently identical.  Data after output gain at offset 16\n       doesn't need to be bytewapped. */\n    pre_skip = AV_RB16(st->codecpar->extradata + 10);\n    AV_WL16(st->codecpar->extradata + 10, pre_skip);\n    AV_WL32(st->codecpar->extradata + 12, AV_RB32(st->codecpar->extradata + 12));\n    AV_WL16(st->codecpar->extradata + 16, AV_RB16(st->codecpar->extradata + 16));\n\n    st->codecpar->initial_padding = pre_skip;\n    st->codecpar->seek_preroll = av_rescale_q(OPUS_SEEK_PREROLL_MS,\n                                              (AVRational){1, 1000},\n                                              (AVRational){1, 48000});\n\n    return 0;\n}\n\nstatic int mov_read_dmlp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned format_info;\n    int channel_assignment, channel_assignment1, channel_assignment2;\n    int ratebits;\n    uint64_t chmask;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 10)\n        return AVERROR_INVALIDDATA;\n\n    format_info = avio_rb32(pb);\n\n    ratebits            = (format_info >> 28) & 0xF;\n    channel_assignment1 = (format_info >> 15) & 0x1F;\n    channel_assignment2 = format_info & 0x1FFF;\n    if (channel_assignment2)\n        channel_assignment = channel_assignment2;\n    else\n        channel_assignment = channel_assignment1;\n\n    st->codecpar->frame_size = 40 << (ratebits & 0x7);\n    st->codecpar->sample_rate = mlp_samplerate(ratebits);\n\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    chmask = truehd_layout(channel_assignment);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout, chmask);\n\n    return 0;\n}\n\nstatic int mov_read_dvcc_dvvc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t buf[ISOM_DVCC_DVVC_SIZE];\n    int ret;\n    int64_t read_size = atom.size;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    // At most 24 bytes\n    read_size = FFMIN(read_size, ISOM_DVCC_DVVC_SIZE);\n\n    if ((ret = ffio_read_size(pb, buf, read_size)) < 0)\n        return ret;\n\n    return ff_isom_parse_dvcc_dvvc(c->fc, st, buf, read_size);\n}\n\nstatic int mov_read_kind(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVFormatContext *ctx = c->fc;\n    AVStream *st = NULL;\n    AVBPrint scheme_buf, value_buf;\n    int64_t scheme_str_len = 0, value_str_len = 0;\n    int version, flags, ret = AVERROR_BUG;\n    int64_t size = atom.size;\n\n    if (atom.size < 6)\n        // 4 bytes for version + flags, 2x 1 byte for null\n        return AVERROR_INVALIDDATA;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    version = avio_r8(pb);\n    flags   = avio_rb24(pb);\n    size   -= 4;\n\n    if (version != 0 || flags != 0) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Unsupported 'kind' box with version %d, flags: %x\",\n               version, flags);\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_bprint_init(&scheme_buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n    av_bprint_init(&value_buf,  0, AV_BPRINT_SIZE_UNLIMITED);\n\n    if ((scheme_str_len = ff_read_string_to_bprint_overwrite(pb, &scheme_buf,\n                                                             size)) < 0) {\n        ret = scheme_str_len;\n        goto cleanup;\n    }\n\n    if (scheme_str_len + 1 >= size) {\n        // we need to have another string, even if nullptr.\n        // we check with + 1 since we expect that if size was not hit,\n        // an additional null was read.\n        ret = AVERROR_INVALIDDATA;\n        goto cleanup;\n    }\n\n    size -= scheme_str_len + 1;\n\n    if ((value_str_len = ff_read_string_to_bprint_overwrite(pb, &value_buf,\n                                                            size)) < 0) {\n        ret = value_str_len;\n        goto cleanup;\n    }\n\n    if (value_str_len == size) {\n        // in case of no trailing null, box is not valid.\n        ret = AVERROR_INVALIDDATA;\n        goto cleanup;\n    }\n\n    av_log(ctx, AV_LOG_TRACE,\n           \"%s stream %d KindBox(scheme: %s, value: %s)\\n\",\n           av_get_media_type_string(st->codecpar->codec_type),\n           st->index,\n           scheme_buf.str, value_buf.str);\n\n    for (int i = 0; ff_mov_track_kind_table[i].scheme_uri; i++) {\n        const struct MP4TrackKindMapping map = ff_mov_track_kind_table[i];\n        if (!av_strstart(scheme_buf.str, map.scheme_uri, NULL))\n            continue;\n\n        for (int j = 0; map.value_maps[j].disposition; j++) {\n            const struct MP4TrackKindValueMapping value_map = map.value_maps[j];\n            if (!av_strstart(value_buf.str, value_map.value, NULL))\n                continue;\n\n            st->disposition |= value_map.disposition;\n        }\n    }\n\n    ret = 0;\n\ncleanup:\n\n    av_bprint_finalize(&scheme_buf, NULL);\n    av_bprint_finalize(&value_buf,  NULL);\n\n    return ret;\n}\n\nstatic int mov_read_SA3D(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int i, version, type;\n    int ambisonic_order, channel_order, normalization, channel_count;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"SA3D audio box too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SA3D box version %d\\n\", version);\n        return 0;\n    }\n\n    type = avio_r8(pb);\n    if (type) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported ambisonic type %d\\n\", type);\n        return 0;\n    }\n\n    ambisonic_order = avio_rb32(pb);\n\n    channel_order = avio_r8(pb);\n    if (channel_order) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported channel_order %d\\n\", channel_order);\n        return 0;\n    }\n\n    normalization = avio_r8(pb);\n    if (normalization) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported normalization %d\\n\", normalization);\n        return 0;\n    }\n\n    channel_count = avio_rb32(pb);\n    if (ambisonic_order < 0 || channel_count != (ambisonic_order + 1LL) * (ambisonic_order + 1LL)) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Invalid number of channels (%d / %d)\\n\",\n               channel_count, ambisonic_order);\n        return 0;\n    }\n\n    for (i = 0; i < channel_count; i++) {\n        if (i != avio_rb32(pb)) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Ambisonic channel reordering is not supported\\n\");\n            return 0;\n        }\n    }\n\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_AMBISONIC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n\n    return 0;\n}\n\nstatic int mov_read_SAND(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty SAND audio box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SAND box version %d\\n\", version);\n        return 0;\n    }\n\n    st->disposition |= AV_DISPOSITION_NON_DIEGETIC;\n\n    return 0;\n}\n\nstatic int rb_size(AVIOContext *pb, uint64_t* value, int size)\n{\n    if (size == 0)\n        *value = 0;\n    else if (size == 1)\n        *value = avio_r8(pb);\n    else if (size == 2)\n        *value = avio_rb16(pb);\n    else if (size == 4)\n        *value = avio_rb32(pb);\n    else if (size == 8)\n        *value = avio_rb64(pb);\n    else\n        return -1;\n    return size;\n}\n\nstatic int mov_read_pitm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    avio_rb32(pb);  // version & flags.\n    c->primary_item_id = avio_rb16(pb);\n    return atom.size;\n}\n\nstatic int mov_read_iloc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int version, offset_size, length_size, base_offset_size, index_size;\n    int item_count, extent_count;\n    uint64_t base_offset, extent_offset, extent_length;\n    uint8_t value;\n\n    if (!c->is_still_picture_avif) {\n        // * For non-avif, we simply ignore the iloc box.\n        // * For animated avif, we don't care about the iloc box as all the\n        //   necessary information can be found in the moov box.\n        return 0;\n    }\n\n    if (c->fc->nb_streams) {\n        av_log(c->fc, AV_LOG_INFO, \"Duplicate iloc box found\\n\");\n        return 0;\n    }\n\n    version = avio_r8(pb);\n    avio_rb24(pb);  // flags.\n\n    value = avio_r8(pb);\n    offset_size = (value >> 4) & 0xF;\n    length_size = value & 0xF;\n    value = avio_r8(pb);\n    base_offset_size = (value >> 4) & 0xF;\n    index_size = !version ? 0 : (value & 0xF);\n    if (index_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"iloc: index_size != 0 not supported.\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    item_count = (version < 2) ? avio_rb16(pb) : avio_rb32(pb);\n\n    c->avif_info = av_malloc_array(item_count, sizeof(*c->avif_info));\n    if (!c->avif_info)\n        return AVERROR(ENOMEM);\n    c->avif_info_size = item_count;\n\n    for (int i = 0; i < item_count; i++) {\n        int item_id = (version < 2) ? avio_rb16(pb) : avio_rb32(pb);\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        c->avif_info[i].item_id = item_id;\n\n        if (version > 0)\n            avio_rb16(pb);  // construction_method.\n        avio_rb16(pb);  // data_reference_index.\n        if (rb_size(pb, &base_offset, base_offset_size) < 0)\n            return AVERROR_INVALIDDATA;\n        extent_count = avio_rb16(pb);\n        if (extent_count > 1) {\n            // For still AVIF images, we only support one extent item.\n            av_log(c->fc, AV_LOG_ERROR, \"iloc: extent_count > 1 not supported.\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        for (int j = 0; j < extent_count; j++) {\n            if (rb_size(pb, &extent_offset, offset_size) < 0 ||\n                rb_size(pb, &extent_length, length_size) < 0)\n                return AVERROR_INVALIDDATA;\n            c->avif_info[i].extent_length = extent_length;\n            c->avif_info[i].extent_offset = base_offset + extent_offset;\n        }\n    }\n\n    return atom.size;\n}\n\nstatic const MOVParseTableEntry mov_default_parse_table[] = {\n{ MKTAG('A','C','L','R'), mov_read_aclr },\n{ MKTAG('A','P','R','G'), mov_read_avid },\n{ MKTAG('A','A','L','P'), mov_read_avid },\n{ MKTAG('A','R','E','S'), mov_read_ares },\n{ MKTAG('a','v','s','s'), mov_read_avss },\n{ MKTAG('a','v','1','C'), mov_read_glbl },\n{ MKTAG('c','h','p','l'), mov_read_chpl },\n{ MKTAG('c','o','6','4'), mov_read_stco },\n{ MKTAG('c','o','l','r'), mov_read_colr },\n{ MKTAG('c','t','t','s'), mov_read_ctts }, /* composition time to sample */\n{ MKTAG('d','i','n','f'), mov_read_default },\n{ MKTAG('D','p','x','E'), mov_read_dpxe },\n{ MKTAG('d','r','e','f'), mov_read_dref },\n{ MKTAG('e','d','t','s'), mov_read_default },\n{ MKTAG('e','l','s','t'), mov_read_elst },\n{ MKTAG('e','n','d','a'), mov_read_enda },\n{ MKTAG('f','i','e','l'), mov_read_fiel },\n{ MKTAG('a','d','r','m'), mov_read_adrm },\n{ MKTAG('f','t','y','p'), mov_read_ftyp },\n{ MKTAG('g','l','b','l'), mov_read_glbl },\n{ MKTAG('h','d','l','r'), mov_read_hdlr },\n{ MKTAG('i','l','s','t'), mov_read_ilst },\n{ MKTAG('j','p','2','h'), mov_read_jp2h },\n{ MKTAG('m','d','a','t'), mov_read_mdat },\n{ MKTAG('m','d','h','d'), mov_read_mdhd },\n{ MKTAG('m','d','i','a'), mov_read_default },\n{ MKTAG('m','e','t','a'), mov_read_meta },\n{ MKTAG('m','i','n','f'), mov_read_default },\n{ MKTAG('m','o','o','f'), mov_read_moof },\n{ MKTAG('m','o','o','v'), mov_read_moov },\n{ MKTAG('m','v','e','x'), mov_read_default },\n{ MKTAG('m','v','h','d'), mov_read_mvhd },\n{ MKTAG('S','M','I',' '), mov_read_svq3 },\n{ MKTAG('a','l','a','c'), mov_read_alac }, /* alac specific atom */\n{ MKTAG('a','v','c','C'), mov_read_glbl },\n{ MKTAG('p','a','s','p'), mov_read_pasp },\n{ MKTAG('s','i','d','x'), mov_read_sidx },\n{ MKTAG('s','t','b','l'), mov_read_default },\n{ MKTAG('s','t','c','o'), mov_read_stco },\n{ MKTAG('s','t','p','s'), mov_read_stps },\n{ MKTAG('s','t','r','f'), mov_read_strf },\n{ MKTAG('s','t','s','c'), mov_read_stsc },\n{ MKTAG('s','t','s','d'), mov_read_stsd }, /* sample description */\n{ MKTAG('s','t','s','s'), mov_read_stss }, /* sync sample */\n{ MKTAG('s','t','s','z'), mov_read_stsz }, /* sample size */\n{ MKTAG('s','t','t','s'), mov_read_stts },\n{ MKTAG('s','t','z','2'), mov_read_stsz }, /* compact sample size */\n{ MKTAG('s','d','t','p'), mov_read_sdtp }, /* independent and disposable samples */\n{ MKTAG('t','k','h','d'), mov_read_tkhd }, /* track header */\n{ MKTAG('t','f','d','t'), mov_read_tfdt },\n{ MKTAG('t','f','h','d'), mov_read_tfhd }, /* track fragment header */\n{ MKTAG('t','r','a','k'), mov_read_trak },\n{ MKTAG('t','r','a','f'), mov_read_default },\n{ MKTAG('t','r','e','f'), mov_read_default },\n{ MKTAG('t','m','c','d'), mov_read_tmcd },\n{ MKTAG('c','h','a','p'), mov_read_chap },\n{ MKTAG('t','r','e','x'), mov_read_trex },\n{ MKTAG('t','r','u','n'), mov_read_trun },\n{ MKTAG('u','d','t','a'), mov_read_default },\n{ MKTAG('w','a','v','e'), mov_read_wave },\n{ MKTAG('e','s','d','s'), mov_read_esds },\n{ MKTAG('d','a','c','3'), mov_read_dac3 }, /* AC-3 info */\n{ MKTAG('d','e','c','3'), mov_read_dec3 }, /* EAC-3 info */\n{ MKTAG('d','d','t','s'), mov_read_ddts }, /* DTS audio descriptor */\n{ MKTAG('w','i','d','e'), mov_read_wide }, /* place holder */\n{ MKTAG('w','f','e','x'), mov_read_wfex },\n{ MKTAG('c','m','o','v'), mov_read_cmov },\n{ MKTAG('c','h','a','n'), mov_read_chan }, /* channel layout */\n{ MKTAG('d','v','c','1'), mov_read_dvc1 },\n{ MKTAG('s','g','p','d'), mov_read_sgpd },\n{ MKTAG('s','b','g','p'), mov_read_sbgp },\n{ MKTAG('h','v','c','C'), mov_read_glbl },\n{ MKTAG('u','u','i','d'), mov_read_uuid },\n{ MKTAG('C','i','n', 0x8e), mov_read_targa_y216 },\n{ MKTAG('f','r','e','e'), mov_read_free },\n{ MKTAG('-','-','-','-'), mov_read_custom },\n{ MKTAG('s','i','n','f'), mov_read_default },\n{ MKTAG('f','r','m','a'), mov_read_frma },\n{ MKTAG('s','e','n','c'), mov_read_senc },\n{ MKTAG('s','a','i','z'), mov_read_saiz },\n{ MKTAG('s','a','i','o'), mov_read_saio },\n{ MKTAG('p','s','s','h'), mov_read_pssh },\n{ MKTAG('s','c','h','m'), mov_read_schm },\n{ MKTAG('s','c','h','i'), mov_read_default },\n{ MKTAG('t','e','n','c'), mov_read_tenc },\n{ MKTAG('d','f','L','a'), mov_read_dfla },\n{ MKTAG('s','t','3','d'), mov_read_st3d }, /* stereoscopic 3D video box */\n{ MKTAG('s','v','3','d'), mov_read_sv3d }, /* spherical video box */\n{ MKTAG('d','O','p','s'), mov_read_dops },\n{ MKTAG('d','m','l','p'), mov_read_dmlp },\n{ MKTAG('S','m','D','m'), mov_read_smdm },\n{ MKTAG('C','o','L','L'), mov_read_coll },\n{ MKTAG('v','p','c','C'), mov_read_vpcc },\n{ MKTAG('m','d','c','v'), mov_read_mdcv },\n{ MKTAG('c','l','l','i'), mov_read_clli },\n{ MKTAG('d','v','c','C'), mov_read_dvcc_dvvc },\n{ MKTAG('d','v','v','C'), mov_read_dvcc_dvvc },\n{ MKTAG('d','v','w','C'), mov_read_dvcc_dvvc },\n{ MKTAG('k','i','n','d'), mov_read_kind },\n{ MKTAG('S','A','3','D'), mov_read_SA3D }, /* ambisonic audio box */\n{ MKTAG('S','A','N','D'), mov_read_SAND }, /* non diegetic audio box */\n{ MKTAG('i','l','o','c'), mov_read_iloc },\n{ MKTAG('p','c','m','C'), mov_read_pcmc }, /* PCM configuration box */\n{ MKTAG('p','i','t','m'), mov_read_pitm },\n{ 0, NULL }\n};\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (c->atom_depth > 10) {\n        av_log(c->fc, AV_LOG_ERROR, \"Atoms too deeply nested\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->atom_depth ++;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size <= atom.size - 8) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = avio_rb32(pb);\n        a.type = avio_rl32(pb);\n        if (avio_feof(pb))\n            break;\n        if (((a.type == MKTAG('f','r','e','e') && c->moov_retry) ||\n              a.type == MKTAG('h','o','o','v')) &&\n            a.size >= 8 &&\n            c->fc->strict_std_compliance < FF_COMPLIANCE_STRICT) {\n                uint32_t type;\n                avio_skip(pb, 4);\n                type = avio_rl32(pb);\n                if (avio_feof(pb))\n                    break;\n                avio_seek(pb, -8, SEEK_CUR);\n                if (type == MKTAG('m','v','h','d') ||\n                    type == MKTAG('c','m','o','v')) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free or hoov atom.\\n\");\n                    a.type = MKTAG('m','o','o','v');\n                }\n        }\n        if (atom.type != MKTAG('r','o','o','t') &&\n            atom.type != MKTAG('m','o','o','v')) {\n            if (a.type == MKTAG('t','r','a','k') ||\n                a.type == MKTAG('m','d','a','t')) {\n                av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                avio_skip(pb, -8);\n                c->atom_depth --;\n                return 0;\n            }\n        }\n        total_size += 8;\n        if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */\n            a.size = avio_rb64(pb) - 8;\n            total_size += 8;\n        }\n        av_log(c->fc, AV_LOG_TRACE, \"type:'%s' parent:'%s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n               av_fourcc2str(a.type), av_fourcc2str(atom.type), a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        if (a.size < 0)\n            break;\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        // Supports parsing the QuickTime Metadata Keys.\n        // https://developer.apple.com/library/mac/documentation/QuickTime/QTFF/Metadata/Metadata.html\n        if (!parse && c->found_hdlr_mdta &&\n            atom.type == MKTAG('m','e','t','a') &&\n            a.type == MKTAG('k','e','y','s') &&\n            c->meta_keys_count == 0) {\n            parse = mov_read_keys;\n        }\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0) {\n                c->atom_depth --;\n                return err;\n            }\n            if (c->found_moov && c->found_mdat && a.size <= INT64_MAX - start_pos &&\n                ((!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->frag_index.complete) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->frag_index.complete)\n                    c->next_root_atom = start_pos + a.size;\n                c->atom_depth --;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n            else if (left < 0) {\n                av_log(c->fc, AV_LOG_WARNING,\n                       \"overread end of atom '%s' by %\"PRId64\" bytes\\n\",\n                       av_fourcc2str(a.type), -left);\n                avio_seek(pb, left, SEEK_CUR);\n            }\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    c->atom_depth --;\n    return 0;\n}\n\nstatic int mov_probe(const AVProbeData *p)\n{\n    int64_t offset;\n    uint32_t tag;\n    int score = 0;\n    int moov_offset = -1;\n\n    /* check file header */\n    offset = 0;\n    for (;;) {\n        int64_t size;\n        int minsize = 8;\n        /* ignore invalid offset */\n        if ((offset + 8ULL) > (unsigned int)p->buf_size)\n            break;\n        size = AV_RB32(p->buf + offset);\n        if (size == 1 && offset + 16 <= (unsigned int)p->buf_size) {\n            size = AV_RB64(p->buf+offset + 8);\n            minsize = 16;\n        } else if (size == 0) {\n            size = p->buf_size - offset;\n        }\n        if (size < minsize) {\n            offset += 4;\n            continue;\n        }\n        tag = AV_RL32(p->buf + offset + 4);\n        switch(tag) {\n        /* check for obvious tags */\n        case MKTAG('m','o','o','v'):\n            moov_offset = offset + 4;\n        case MKTAG('m','d','a','t'):\n        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */\n        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */\n        case MKTAG('f','t','y','p'):\n            if (tag == MKTAG('f','t','y','p') &&\n                       (   AV_RL32(p->buf + offset + 8) == MKTAG('j','p','2',' ')\n                        || AV_RL32(p->buf + offset + 8) == MKTAG('j','p','x',' ')\n                        || AV_RL32(p->buf + offset + 8) == MKTAG('j','x','l',' ')\n                    )) {\n                score = FFMAX(score, 5);\n            } else {\n                score = AVPROBE_SCORE_MAX;\n            }\n            break;\n        /* those are more common words, so rate then a bit less */\n        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */\n        case MKTAG('w','i','d','e'):\n        case MKTAG('f','r','e','e'):\n        case MKTAG('j','u','n','k'):\n        case MKTAG('p','i','c','t'):\n            score  = FFMAX(score, AVPROBE_SCORE_MAX - 5);\n            break;\n        case MKTAG(0x82,0x82,0x7f,0x7d):\n        case MKTAG('s','k','i','p'):\n        case MKTAG('u','u','i','d'):\n        case MKTAG('p','r','f','l'):\n            /* if we only find those cause probedata is too small at least rate them */\n            score  = FFMAX(score, AVPROBE_SCORE_EXTENSION);\n            break;\n        }\n        if (size > INT64_MAX - offset)\n            break;\n        offset += size;\n    }\n    if (score > AVPROBE_SCORE_MAX - 50 && moov_offset != -1) {\n        /* moov atom in the header - we should make sure that this is not a\n         * MOV-packed MPEG-PS */\n        offset = moov_offset;\n\n        while (offset < (p->buf_size - 16)) { /* Sufficient space */\n               /* We found an actual hdlr atom */\n            if (AV_RL32(p->buf + offset     ) == MKTAG('h','d','l','r') &&\n                AV_RL32(p->buf + offset +  8) == MKTAG('m','h','l','r') &&\n                AV_RL32(p->buf + offset + 12) == MKTAG('M','P','E','G')) {\n                av_log(NULL, AV_LOG_WARNING, \"Found media data tag MPEG indicating this is a MOV-packed MPEG-PS.\\n\");\n                /* We found a media handler reference atom describing an\n                 * MPEG-PS-in-MOV, return a\n                 * low score to force expanding the probe window until\n                 * mpegps_probe finds what it needs */\n                return 5;\n            } else {\n                /* Keep looking */\n                offset += 2;\n            }\n        }\n    }\n\n    return score;\n}\n\n// must be done after parsing all trak because there's no order requirement\nstatic void mov_read_chapters(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    int64_t cur_pos;\n    int i, j;\n    int chapter_track;\n\n    for (j = 0; j < mov->nb_chapter_tracks; j++) {\n        AVStream *st = NULL;\n        FFStream *sti = NULL;\n        chapter_track = mov->chapter_tracks[j];\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->id == chapter_track) {\n                st = s->streams[i];\n                break;\n            }\n        if (!st) {\n            av_log(s, AV_LOG_ERROR, \"Referenced QT chapter track not found\\n\");\n            continue;\n        }\n        sti = ffstream(st);\n\n        sc = st->priv_data;\n        cur_pos = avio_tell(sc->pb);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            st->disposition |= AV_DISPOSITION_ATTACHED_PIC | AV_DISPOSITION_TIMED_THUMBNAILS;\n            if (sti->nb_index_entries) {\n                // Retrieve the first frame, if possible\n                AVIndexEntry *sample = &sti->index_entries[0];\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to retrieve first frame\\n\");\n                    goto finish;\n                }\n\n                if (ff_add_attached_pic(s, st, sc->pb, NULL, sample->size) < 0)\n                    goto finish;\n            }\n        } else {\n            st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st->codecpar->codec_id = AV_CODEC_ID_BIN_DATA;\n            st->discard = AVDISCARD_ALL;\n            for (int i = 0; i < sti->nb_index_entries; i++) {\n                AVIndexEntry *sample = &sti->index_entries[i];\n                int64_t end = i+1 < sti->nb_index_entries ? sti->index_entries[i+1].timestamp : st->duration;\n                uint8_t *title;\n                uint16_t ch;\n                int len, title_len;\n\n                if (end < sample->timestamp) {\n                    av_log(s, AV_LOG_WARNING, \"ignoring stream duration which is shorter than chapters\\n\");\n                    end = AV_NOPTS_VALUE;\n                }\n\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Chapter %d not found in file\\n\", i);\n                    goto finish;\n                }\n\n                // the first two bytes are the length of the title\n                len = avio_rb16(sc->pb);\n                if (len > sample->size-2)\n                    continue;\n                title_len = 2*len + 1;\n                if (!(title = av_mallocz(title_len)))\n                    goto finish;\n\n                // The samples could theoretically be in any encoding if there's an encd\n                // atom following, but in practice are only utf-8 or utf-16, distinguished\n                // instead by the presence of a BOM\n                if (!len) {\n                    title[0] = 0;\n                } else {\n                    ch = avio_rb16(sc->pb);\n                    if (ch == 0xfeff)\n                        avio_get_str16be(sc->pb, len, title, title_len);\n                    else if (ch == 0xfffe)\n                        avio_get_str16le(sc->pb, len, title, title_len);\n                    else {\n                        AV_WB16(title, ch);\n                        if (len == 1 || len == 2)\n                            title[len] = 0;\n                        else\n                            avio_get_str(sc->pb, INT_MAX, title + 2, len - 1);\n                    }\n                }\n\n                avpriv_new_chapter(s, i, st->time_base, sample->timestamp, end, title);\n                av_freep(&title);\n            }\n        }\nfinish:\n        avio_seek(sc->pb, cur_pos, SEEK_SET);\n    }\n}\n\nstatic int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             int64_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}\n\nstatic int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n\n    if (!sti->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_timecode_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int flags = 0;\n    int64_t cur_pos = avio_tell(sc->pb);\n    int64_t value;\n    AVRational tc_rate = st->avg_frame_rate;\n    int tmcd_nb_frames = sc->tmcd_nb_frames;\n    int rounded_tc_rate;\n\n    if (!sti->nb_index_entries)\n        return -1;\n\n    if (!tc_rate.num || !tc_rate.den || !tmcd_nb_frames)\n        return -1;\n\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    value = avio_rb32(s->pb);\n\n    if (sc->tmcd_flags & 0x0001) flags |= AV_TIMECODE_FLAG_DROPFRAME;\n    if (sc->tmcd_flags & 0x0002) flags |= AV_TIMECODE_FLAG_24HOURSMAX;\n    if (sc->tmcd_flags & 0x0004) flags |= AV_TIMECODE_FLAG_ALLOWNEGATIVE;\n\n    /* Assume Counter flag is set to 1 in tmcd track (even though it is likely\n     * not the case) and thus assume \"frame number format\" instead of QT one.\n     * No sample with tmcd track can be found with a QT timecode at the moment,\n     * despite what the tmcd track \"suggests\" (Counter flag set to 0 means QT\n     * format). */\n\n    /* 60 fps content have tmcd_nb_frames set to 30 but tc_rate set to 60, so\n     * we multiply the frame number with the quotient.\n     * See tickets #9492, #9710. */\n    rounded_tc_rate = (tc_rate.num + tc_rate.den / 2) / tc_rate.den;\n    /* Work around files where tmcd_nb_frames is rounded down from frame rate\n     * instead of up. See ticket #5978. */\n    if (tmcd_nb_frames == tc_rate.num / tc_rate.den &&\n        s->strict_std_compliance < FF_COMPLIANCE_STRICT)\n        tmcd_nb_frames = rounded_tc_rate;\n    value = av_rescale(value, rounded_tc_rate, tmcd_nb_frames);\n\n    parse_timecode_in_framenum_format(s, st, value, flags);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic void mov_free_encryption_index(MOVEncryptionIndex **index) {\n    int i;\n    if (!index || !*index) return;\n    for (i = 0; i < (*index)->nb_encrypted_samples; i++) {\n        av_encryption_info_free((*index)->encrypted_samples[i]);\n    }\n    av_freep(&(*index)->encrypted_samples);\n    av_freep(&(*index)->auxiliary_info_sizes);\n    av_freep(&(*index)->auxiliary_offsets);\n    av_freep(index);\n}\n\nstatic int mov_read_close(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (!sc)\n            continue;\n\n        av_freep(&sc->ctts_data);\n        for (j = 0; j < sc->drefs_count; j++) {\n            av_freep(&sc->drefs[j].path);\n            av_freep(&sc->drefs[j].dir);\n        }\n        av_freep(&sc->drefs);\n\n        sc->drefs_count = 0;\n\n        if (!sc->pb_is_copied)\n            ff_format_io_close(s, &sc->pb);\n\n        sc->pb = NULL;\n        av_freep(&sc->chunk_offsets);\n        av_freep(&sc->stsc_data);\n        av_freep(&sc->sample_sizes);\n        av_freep(&sc->keyframes);\n        av_freep(&sc->stts_data);\n        av_freep(&sc->sdtp_data);\n        av_freep(&sc->stps_data);\n        av_freep(&sc->elst_data);\n        av_freep(&sc->rap_group);\n        av_freep(&sc->sync_group);\n        av_freep(&sc->sgpd_sync);\n        av_freep(&sc->sample_offsets);\n        av_freep(&sc->open_key_samples);\n        av_freep(&sc->display_matrix);\n        av_freep(&sc->index_ranges);\n\n        if (sc->extradata)\n            for (j = 0; j < sc->stsd_count; j++)\n                av_free(sc->extradata[j]);\n        av_freep(&sc->extradata);\n        av_freep(&sc->extradata_size);\n\n        mov_free_encryption_index(&sc->cenc.encryption_index);\n        av_encryption_info_free(sc->cenc.default_encrypted_sample);\n        av_aes_ctr_free(sc->cenc.aes_ctr);\n\n        av_freep(&sc->stereo3d);\n        av_freep(&sc->spherical);\n        av_freep(&sc->mastering);\n        av_freep(&sc->coll);\n    }\n\n    av_freep(&mov->dv_demux);\n    avformat_free_context(mov->dv_fctx);\n    mov->dv_fctx = NULL;\n\n    if (mov->meta_keys) {\n        for (i = 1; i < mov->meta_keys_count; i++) {\n            av_freep(&mov->meta_keys[i]);\n        }\n        av_freep(&mov->meta_keys);\n    }\n\n    av_freep(&mov->trex_data);\n    av_freep(&mov->bitrates);\n\n    for (i = 0; i < mov->frag_index.nb_items; i++) {\n        MOVFragmentStreamInfo *frag = mov->frag_index.item[i].stream_info;\n        for (j = 0; j < mov->frag_index.item[i].nb_stream_info; j++) {\n            mov_free_encryption_index(&frag[j].encryption_index);\n        }\n        av_freep(&mov->frag_index.item[i].stream_info);\n    }\n    av_freep(&mov->frag_index.item);\n\n    av_freep(&mov->aes_decrypt);\n    av_freep(&mov->chapter_tracks);\n    av_freep(&mov->avif_info);\n\n    return 0;\n}\n\nstatic int tmcd_is_referenced(AVFormatContext *s, int tmcd_id)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&\n            sc->timecode_track == tmcd_id)\n            return 1;\n    }\n    return 0;\n}\n\n/* look for a tmcd track not referenced by any video track, and export it globally */\nstatic void export_orphan_timecode(AVFormatContext *s)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n\n        if (st->codecpar->codec_tag  == MKTAG('t','m','c','d') &&\n            !tmcd_is_referenced(s, i + 1)) {\n            AVDictionaryEntry *tcr = av_dict_get(st->metadata, \"timecode\", NULL, 0);\n            if (tcr) {\n                av_dict_set(&s->metadata, \"timecode\", tcr->value, 0);\n                break;\n            }\n        }\n    }\n}\n\nstatic int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    unsigned track_id, item_count;\n\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n\n    version = avio_r8(f);\n    avio_rb24(f);\n    track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    item_count = avio_rb32(f);\n    for (i = 0; i < item_count; i++) {\n        int64_t time, offset;\n        int index;\n        MOVFragmentStreamInfo * frag_stream_info;\n\n        if (avio_feof(f)) {\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n\n        // The first sample of each stream in a fragment is always a random\n        // access sample.  So it's entry in the tfra can be used as the\n        // initial PTS of the fragment.\n        index = update_frag_index(mov, offset);\n        frag_stream_info = get_frag_stream_info(&mov->frag_index, index, track_id);\n        if (frag_stream_info &&\n            frag_stream_info->first_tfra_pts == AV_NOPTS_VALUE)\n            frag_stream_info->first_tfra_pts = time;\n\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f)\n{\n    int64_t stream_size = avio_size(f);\n    int64_t original_pos = avio_tell(f);\n    int64_t seek_ret;\n    int ret = -1;\n    if ((seek_ret = avio_seek(f, stream_size - 4, SEEK_SET)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    c->mfra_size = avio_rb32(f);\n    c->have_read_mfra_size = 1;\n    if (!c->mfra_size || c->mfra_size > stream_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (unreasonable size)\\n\");\n        goto fail;\n    }\n    if ((seek_ret = avio_seek(f, -((int64_t) c->mfra_size), SEEK_CUR)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    if (avio_rb32(f) != c->mfra_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (size mismatch)\\n\");\n        goto fail;\n    }\n    if (avio_rb32(f) != MKBETAG('m', 'f', 'r', 'a')) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (tag mismatch)\\n\");\n        goto fail;\n    }\n    av_log(c->fc, AV_LOG_VERBOSE, \"stream has mfra\\n\");\n    do {\n        ret = read_tfra(c, f);\n        if (ret < 0)\n            goto fail;\n    } while (!ret);\n    ret = 0;\n    c->frag_index.complete = 1;\nfail:\n    seek_ret = avio_seek(f, original_pos, SEEK_SET);\n    if (seek_ret < 0) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"failed to seek back after looking for mfra\\n\");\n        ret = seek_ret;\n    }\n    return ret;\n}\n\nstatic int mov_read_header(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int j, err;\n    MOVAtom atom = { AV_RL32(\"root\") };\n    int i;\n\n    if (mov->decryption_key_len != 0 && mov->decryption_key_len != AES_CTR_KEY_SIZE) {\n        av_log(s, AV_LOG_ERROR, \"Invalid decryption key len %d expected %d\\n\",\n            mov->decryption_key_len, AES_CTR_KEY_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    mov->fc = s;\n    mov->trak_index = -1;\n    /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL)\n        atom.size = avio_size(pb);\n    else\n        atom.size = INT64_MAX;\n\n    /* check MOV header */\n    do {\n        if (mov->moov_retry)\n            avio_seek(pb, 0, SEEK_SET);\n        if ((err = mov_read_default(mov, pb, atom)) < 0) {\n            av_log(s, AV_LOG_ERROR, \"error reading header\\n\");\n            return err;\n        }\n    } while ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !mov->found_moov && !mov->moov_retry++);\n    if (!mov->found_moov) {\n        av_log(s, AV_LOG_ERROR, \"moov atom not found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    av_log(mov->fc, AV_LOG_TRACE, \"on_parse_exit_offset=%\"PRId64\"\\n\", avio_tell(pb));\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        if (mov->nb_chapter_tracks > 0 && !mov->ignore_chapters)\n            mov_read_chapters(s);\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"tmcd\")) {\n                mov_read_timecode_track(s, s->streams[i]);\n            } else if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"rtmd\")) {\n                mov_read_rtmd_track(s, s->streams[i]);\n            }\n    }\n\n    /* copy timecode metadata from tmcd tracks to the related video streams */\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n        if (sc->timecode_track > 0) {\n            AVDictionaryEntry *tcr;\n            int tmcd_st_id = -1;\n\n            for (j = 0; j < s->nb_streams; j++)\n                if (s->streams[j]->id == sc->timecode_track)\n                    tmcd_st_id = j;\n\n            if (tmcd_st_id < 0 || tmcd_st_id == i)\n                continue;\n            tcr = av_dict_get(s->streams[tmcd_st_id]->metadata, \"timecode\", NULL, 0);\n            if (tcr)\n                av_dict_set(&st->metadata, \"timecode\", tcr->value, 0);\n        }\n    }\n    export_orphan_timecode(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        FFStream *const sti = ffstream(st);\n        MOVStreamContext *sc = st->priv_data;\n        fix_timescale(mov, sc);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n            st->codecpar->codec_id   == AV_CODEC_ID_AAC) {\n            sti->skip_samples = sc->start_pad;\n        }\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sc->nb_frames_for_fps > 0 && sc->duration_for_fps > 0)\n            av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,\n                      sc->time_scale*(int64_t)sc->nb_frames_for_fps, sc->duration_for_fps, INT_MAX);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            if (st->codecpar->width <= 0 || st->codecpar->height <= 0) {\n                st->codecpar->width  = sc->width;\n                st->codecpar->height = sc->height;\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_DVD_SUBTITLE) {\n                if ((err = mov_rewrite_dvd_sub_extradata(st)) < 0)\n                    return err;\n            }\n        }\n        if (mov->handbrake_version &&\n            mov->handbrake_version <= 1000000*0 + 1000*10 + 2 &&  // 0.10.2\n            st->codecpar->codec_id == AV_CODEC_ID_MP3) {\n            av_log(s, AV_LOG_VERBOSE, \"Forcing full parsing for mp3 stream\\n\");\n            sti->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    if (mov->trex_data) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (st->duration > 0) {\n                /* Akin to sc->data_size * 8 * sc->time_scale / st->duration but accounting for overflows. */\n                st->codecpar->bit_rate = av_rescale(sc->data_size, ((int64_t) sc->time_scale) * 8, st->duration);\n                if (st->codecpar->bit_rate == INT64_MIN) {\n                    av_log(s, AV_LOG_WARNING, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    st->codecpar->bit_rate = 0;\n                    if (s->error_recognition & AV_EF_EXPLODE)\n                        return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n\n    if (mov->use_mfra_for > 0) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (sc->duration_for_fps > 0) {\n                /* Akin to sc->data_size * 8 * sc->time_scale / sc->duration_for_fps but accounting for overflows. */\n                st->codecpar->bit_rate = av_rescale(sc->data_size, ((int64_t) sc->time_scale) * 8, sc->duration_for_fps);\n                if (st->codecpar->bit_rate == INT64_MIN) {\n                    av_log(s, AV_LOG_WARNING, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    st->codecpar->bit_rate = 0;\n                    if (s->error_recognition & AV_EF_EXPLODE)\n                        return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < mov->bitrates_count && i < s->nb_streams; i++) {\n        if (mov->bitrates[i]) {\n            s->streams[i]->codecpar->bit_rate = mov->bitrates[i];\n        }\n    }\n\n    ff_rfps_calculate(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        switch (st->codecpar->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            err = ff_replaygain_export(st, s->metadata);\n            if (err < 0)\n                return err;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (sc->display_matrix) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, (uint8_t*)sc->display_matrix,\n                                              sizeof(int32_t) * 9);\n                if (err < 0)\n                    return err;\n\n                sc->display_matrix = NULL;\n            }\n            if (sc->stereo3d) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_STEREO3D,\n                                              (uint8_t *)sc->stereo3d,\n                                              sizeof(*sc->stereo3d));\n                if (err < 0)\n                    return err;\n\n                sc->stereo3d = NULL;\n            }\n            if (sc->spherical) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_SPHERICAL,\n                                              (uint8_t *)sc->spherical,\n                                              sc->spherical_size);\n                if (err < 0)\n                    return err;\n\n                sc->spherical = NULL;\n            }\n            if (sc->mastering) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,\n                                              (uint8_t *)sc->mastering,\n                                              sizeof(*sc->mastering));\n                if (err < 0)\n                    return err;\n\n                sc->mastering = NULL;\n            }\n            if (sc->coll) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,\n                                              (uint8_t *)sc->coll,\n                                              sc->coll_size);\n                if (err < 0)\n                    return err;\n\n                sc->coll = NULL;\n            }\n            break;\n        }\n    }\n    ff_configure_buffers_for_index(s, AV_TIME_BASE);\n\n    for (i = 0; i < mov->frag_index.nb_items; i++)\n        if (mov->frag_index.item[i].moof_offset <= mov->fragment.moof_offset)\n            mov->frag_index.item[i].headers_read = 1;\n\n    return 0;\n}\n\nstatic AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)\n{\n    AVIndexEntry *sample = NULL;\n    int64_t best_dts = INT64_MAX;\n    int i;\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *avst = s->streams[i];\n        FFStream *const avsti = ffstream(avst);\n        MOVStreamContext *msc = avst->priv_data;\n        if (msc->pb && msc->current_sample < avsti->nb_index_entries) {\n            AVIndexEntry *current_sample = &avsti->index_entries[msc->current_sample];\n            int64_t dts = av_rescale(current_sample->timestamp, AV_TIME_BASE, msc->time_scale);\n            av_log(s, AV_LOG_TRACE, \"stream %d, sample %d, dts %\"PRId64\"\\n\", i, msc->current_sample, dts);\n            if (!sample || (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && current_sample->pos < sample->pos) ||\n                ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) &&\n                 ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb && dts != AV_NOPTS_VALUE &&\n                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||\n                  (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {\n                sample = current_sample;\n                best_dts = dts;\n                *st = avst;\n            }\n        }\n    }\n    return sample;\n}\n\nstatic int should_retry(AVIOContext *pb, int error_code) {\n    if (error_code == AVERROR_EOF || avio_feof(pb))\n        return 0;\n\n    return 1;\n}\n\nstatic int mov_switch_root(AVFormatContext *s, int64_t target, int index)\n{\n    int ret;\n    MOVContext *mov = s->priv_data;\n\n    if (index >= 0 && index < mov->frag_index.nb_items)\n        target = mov->frag_index.item[index].moof_offset;\n    if (avio_seek(s->pb, target, SEEK_SET) != target) {\n        av_log(mov->fc, AV_LOG_ERROR, \"root atom offset 0x%\"PRIx64\": partial file\\n\", target);\n        return AVERROR_INVALIDDATA;\n    }\n\n    mov->next_root_atom = 0;\n    if (index < 0 || index >= mov->frag_index.nb_items)\n        index = search_frag_moof_offset(&mov->frag_index, target);\n    if (index < mov->frag_index.nb_items &&\n        mov->frag_index.item[index].moof_offset == target) {\n        if (index + 1 < mov->frag_index.nb_items)\n            mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;\n        if (mov->frag_index.item[index].headers_read)\n            return 0;\n        mov->frag_index.item[index].headers_read = 1;\n    }\n\n    mov->found_mdat = 0;\n\n    ret = mov_read_default(mov, s->pb, (MOVAtom){ AV_RL32(\"root\"), INT64_MAX });\n    if (ret < 0)\n        return ret;\n    if (avio_feof(s->pb))\n        return AVERROR_EOF;\n    av_log(s, AV_LOG_TRACE, \"read fragments, offset 0x%\"PRIx64\"\\n\", avio_tell(s->pb));\n\n    return 1;\n}\n\nstatic int mov_change_extradata(MOVStreamContext *sc, AVPacket *pkt)\n{\n    uint8_t *side, *extradata;\n    int extradata_size;\n\n    /* Save the current index. */\n    sc->last_stsd_index = sc->stsc_data[sc->stsc_index].id - 1;\n\n    /* Notify the decoder that extradata changed. */\n    extradata_size = sc->extradata_size[sc->last_stsd_index];\n    extradata = sc->extradata[sc->last_stsd_index];\n    if (extradata_size > 0 && extradata) {\n        side = av_packet_new_side_data(pkt,\n                                       AV_PKT_DATA_NEW_EXTRADATA,\n                                       extradata_size);\n        if (!side)\n            return AVERROR(ENOMEM);\n        memcpy(side, extradata, extradata_size);\n    }\n\n    return 0;\n}\n\nstatic int get_eia608_packet(AVIOContext *pb, AVPacket *pkt, int size)\n{\n    int new_size, ret;\n\n    if (size <= 8)\n        return AVERROR_INVALIDDATA;\n    new_size = ((size - 8) / 2) * 3;\n    ret = av_new_packet(pkt, new_size);\n    if (ret < 0)\n        return ret;\n\n    avio_skip(pb, 8);\n    for (int j = 0; j < new_size; j += 3) {\n        pkt->data[j] = 0xFC;\n        pkt->data[j+1] = avio_r8(pb);\n        pkt->data[j+2] = avio_r8(pb);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    AVIndexEntry *sample;\n    AVStream *st = NULL;\n    int64_t current_index;\n    int ret;\n    mov->fc = s;\n retry:\n    sample = mov_find_next_sample(s, &st);\n    if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {\n        if (!mov->next_root_atom)\n            return AVERROR_EOF;\n        if ((ret = mov_switch_root(s, mov->next_root_atom, -1)) < 0)\n            return ret;\n        goto retry;\n    }\n    sc = st->priv_data;\n    /* must be done just before reading, to avoid infinite loop on sample */\n    current_index = sc->current_index;\n    mov_current_sample_inc(sc);\n\n    if (mov->next_root_atom) {\n        sample->pos = FFMIN(sample->pos, mov->next_root_atom);\n        sample->size = FFMIN(sample->size, (mov->next_root_atom - sample->pos));\n    }\n\n    if (st->discard != AVDISCARD_ALL) {\n        int64_t ret64 = avio_seek(sc->pb, sample->pos, SEEK_SET);\n        if (ret64 != sample->pos) {\n            av_log(mov->fc, AV_LOG_ERROR, \"stream %d, offset 0x%\"PRIx64\": partial file\\n\",\n                   sc->ffindex, sample->pos);\n            if (should_retry(sc->pb, ret64)) {\n                mov_current_sample_dec(sc);\n            } else if (ret64 < 0) {\n                return (int)ret64;\n            }\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (st->discard == AVDISCARD_NONKEY && !(sample->flags & AVINDEX_KEYFRAME)) {\n            av_log(mov->fc, AV_LOG_DEBUG, \"Nonkey frame from stream %d discarded due to AVDISCARD_NONKEY\\n\", sc->ffindex);\n            goto retry;\n        }\n\n        if (st->codecpar->codec_id == AV_CODEC_ID_EIA_608 && sample->size > 8)\n            ret = get_eia608_packet(sc->pb, pkt, sample->size);\n        else\n            ret = av_get_packet(sc->pb, pkt, sample->size);\n        if (ret < 0) {\n            if (should_retry(sc->pb, ret)) {\n                mov_current_sample_dec(sc);\n            }\n            return ret;\n        }\n#if CONFIG_DV_DEMUXER\n        if (mov->dv_demux && sc->dv_audio_container) {\n            ret = avpriv_dv_produce_packet(mov->dv_demux, pkt, pkt->data, pkt->size, pkt->pos);\n            av_packet_unref(pkt);\n            if (ret < 0)\n                return ret;\n            ret = avpriv_dv_get_packet(mov->dv_demux, pkt);\n            if (ret < 0)\n                return ret;\n        }\n#endif\n        if (sc->has_palette) {\n            uint8_t *pal;\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n            if (!pal) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n            } else {\n                memcpy(pal, sc->palette, AVPALETTE_SIZE);\n                sc->has_palette = 0;\n            }\n        }\n        if (st->codecpar->codec_id == AV_CODEC_ID_MP3 && !ffstream(st)->need_parsing && pkt->size > 4) {\n            if (ff_mpa_check_header(AV_RB32(pkt->data)) < 0)\n                ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    pkt->stream_index = sc->ffindex;\n    pkt->dts = sample->timestamp;\n    if (sample->flags & AVINDEX_DISCARD_FRAME) {\n        pkt->flags |= AV_PKT_FLAG_DISCARD;\n    }\n    if (sc->ctts_data && sc->ctts_index < sc->ctts_count) {\n        pkt->pts = pkt->dts + sc->dts_shift + sc->ctts_data[sc->ctts_index].duration;\n        /* update ctts context */\n        sc->ctts_sample++;\n        if (sc->ctts_index < sc->ctts_count &&\n            sc->ctts_data[sc->ctts_index].count == sc->ctts_sample) {\n            sc->ctts_index++;\n            sc->ctts_sample = 0;\n        }\n    } else {\n        int64_t next_dts = (sc->current_sample < ffstream(st)->nb_index_entries) ?\n            ffstream(st)->index_entries[sc->current_sample].timestamp : st->duration;\n\n        if (next_dts >= pkt->dts)\n            pkt->duration = next_dts - pkt->dts;\n        pkt->pts = pkt->dts;\n    }\n    if (st->discard == AVDISCARD_ALL)\n        goto retry;\n    if (sc->sdtp_data && sc->current_sample <= sc->sdtp_count) {\n        uint8_t sample_flags = sc->sdtp_data[sc->current_sample - 1];\n        uint8_t sample_is_depended_on = (sample_flags >> 2) & 0x3;\n        pkt->flags |= sample_is_depended_on == MOV_SAMPLE_DEPENDENCY_NO ? AV_PKT_FLAG_DISPOSABLE : 0;\n    }\n    pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : 0;\n    pkt->pos = sample->pos;\n\n    /* Multiple stsd handling. */\n    if (sc->stsc_data) {\n        if (sc->stsc_data[sc->stsc_index].id > 0 &&\n            sc->stsc_data[sc->stsc_index].id - 1 < sc->stsd_count &&\n            sc->stsc_data[sc->stsc_index].id - 1 != sc->last_stsd_index) {\n            ret = mov_change_extradata(sc, pkt);\n            if (ret < 0)\n                return ret;\n        }\n\n        /* Update the stsc index for the next sample */\n        sc->stsc_sample++;\n        if (mov_stsc_index_valid(sc->stsc_index, sc->stsc_count) &&\n            mov_get_stsc_samples(sc, sc->stsc_index) == sc->stsc_sample) {\n            sc->stsc_index++;\n            sc->stsc_sample = 0;\n        }\n    }\n\n    if (mov->aax_mode)\n        aax_filter(pkt->data, pkt->size, mov);\n\n    ret = cenc_filter(mov, st, sc, pkt, current_index);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n{\n    MOVContext *mov = s->priv_data;\n    int index;\n\n    if (!mov->frag_index.complete)\n        return 0;\n\n    index = search_frag_timestamp(s, &mov->frag_index, st, timestamp);\n    if (index < 0)\n        index = 0;\n    if (!mov->frag_index.item[index].headers_read)\n        return mov_switch_root(s, -1, index);\n    if (index + 1 < mov->frag_index.nb_items)\n        mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;\n\n    return 0;\n}\n\nstatic int is_open_key_sample(const MOVStreamContext *sc, int sample)\n{\n    // TODO: a bisect search would scale much better\n    for (int i = 0; i < sc->open_key_samples_count; i++) {\n        const int oks = sc->open_key_samples[i];\n        if (oks == sample)\n            return 1;\n        if (oks > sample) /* list is monotically increasing so we can stop early */\n            break;\n    }\n    return 0;\n}\n\n/*\n * Some key sample may be key frames but not IDR frames, so a random access to\n * them may not be allowed.\n */\nstatic int can_seek_to_key_sample(AVStream *st, int sample, int64_t requested_pts)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int64_t key_sample_dts, key_sample_pts;\n\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC)\n        return 1;\n\n    if (sample >= sc->sample_offsets_count)\n        return 1;\n\n    key_sample_dts = sti->index_entries[sample].timestamp;\n    key_sample_pts = key_sample_dts + sc->sample_offsets[sample] + sc->dts_shift;\n\n    /*\n     * If the sample needs to be presented before an open key sample, they may\n     * not be decodable properly, even though they come after in decoding\n     * order.\n     */\n    if (is_open_key_sample(sc, sample) && key_sample_pts > requested_pts)\n        return 0;\n\n    return 1;\n}\n\nstatic int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int sample, time_sample, ret;\n    unsigned int i;\n\n    // Here we consider timestamp to be PTS, hence try to offset it so that we\n    // can search over the DTS timeline.\n    timestamp -= (sc->min_corrected_pts + sc->dts_shift);\n\n    ret = mov_seek_fragment(s, st, timestamp);\n    if (ret < 0)\n        return ret;\n\n    for (;;) {\n        sample = av_index_search_timestamp(st, timestamp, flags);\n        av_log(s, AV_LOG_TRACE, \"stream %d, timestamp %\"PRId64\", sample %d\\n\", st->index, timestamp, sample);\n        if (sample < 0 && sti->nb_index_entries && timestamp < sti->index_entries[0].timestamp)\n            sample = 0;\n        if (sample < 0) /* not sure what to do */\n            return AVERROR_INVALIDDATA;\n\n        if (!sample || can_seek_to_key_sample(st, sample, timestamp))\n            break;\n        timestamp -= FFMAX(sc->min_sample_duration, 1);\n    }\n\n    mov_current_sample_set(sc, sample);\n    av_log(s, AV_LOG_TRACE, \"stream %d, found sample %d\\n\", st->index, sc->current_sample);\n    /* adjust ctts index */\n    if (sc->ctts_data) {\n        time_sample = 0;\n        for (i = 0; i < sc->ctts_count; i++) {\n            int next = time_sample + sc->ctts_data[i].count;\n            if (next > sc->current_sample) {\n                sc->ctts_index = i;\n                sc->ctts_sample = sc->current_sample - time_sample;\n                break;\n            }\n            time_sample = next;\n        }\n    }\n\n    /* adjust stsd index */\n    if (sc->chunk_count) {\n        time_sample = 0;\n        for (i = 0; i < sc->stsc_count; i++) {\n            int64_t next = time_sample + mov_get_stsc_samples(sc, i);\n            if (next > sc->current_sample) {\n                sc->stsc_index = i;\n                sc->stsc_sample = sc->current_sample - time_sample;\n                break;\n            }\n            av_assert0(next == (int)next);\n            time_sample = next;\n        }\n    }\n\n    return sample;\n}\n\nstatic int64_t mov_get_skip_samples(AVStream *st, int sample)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int64_t first_ts = sti->index_entries[0].timestamp;\n    int64_t ts = sti->index_entries[sample].timestamp;\n    int64_t off;\n\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO)\n        return 0;\n\n    /* compute skip samples according to stream start_pad, seek ts and first ts */\n    off = av_rescale_q(ts - first_ts, st->time_base,\n                       (AVRational){1, st->codecpar->sample_rate});\n    return FFMAX(sc->start_pad - off, 0);\n}\n\nstatic int mov_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    MOVContext *mc = s->priv_data;\n    AVStream *st;\n    FFStream *sti;\n    int sample;\n    int i;\n\n    if (stream_index >= s->nb_streams)\n        return AVERROR_INVALIDDATA;\n\n    st = s->streams[stream_index];\n    sti = ffstream(st);\n    sample = mov_seek_stream(s, st, sample_time, flags);\n    if (sample < 0)\n        return sample;\n\n    if (mc->seek_individually) {\n        /* adjust seek timestamp to found sample timestamp */\n        int64_t seek_timestamp = sti->index_entries[sample].timestamp;\n        sti->skip_samples = mov_get_skip_samples(st, sample);\n\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *const st  = s->streams[i];\n            FFStream *const sti = ffstream(st);\n            int64_t timestamp;\n\n            if (stream_index == i)\n                continue;\n\n            timestamp = av_rescale_q(seek_timestamp, s->streams[stream_index]->time_base, st->time_base);\n            sample = mov_seek_stream(s, st, timestamp, flags);\n            if (sample >= 0)\n                sti->skip_samples = mov_get_skip_samples(st, sample);\n        }\n    } else {\n        for (i = 0; i < s->nb_streams; i++) {\n            MOVStreamContext *sc;\n            st = s->streams[i];\n            sc = st->priv_data;\n            mov_current_sample_set(sc, 0);\n        }\n        while (1) {\n            MOVStreamContext *sc;\n            AVIndexEntry *entry = mov_find_next_sample(s, &st);\n            if (!entry)\n                return AVERROR_INVALIDDATA;\n            sc = st->priv_data;\n            if (sc->ffindex == stream_index && sc->current_sample == sample)\n                break;\n            mov_current_sample_inc(sc);\n        }\n    }\n    return 0;\n}\n\n#define OFFSET(x) offsetof(MOVContext, x)\n#define FLAGS AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption mov_options[] = {\n    {\"use_absolute_path\",\n        \"allow using absolute path when opening alias, this is a possible security issue\",\n        OFFSET(use_absolute_path), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"seek_streams_individually\",\n        \"Seek each stream individually to the closest point\",\n        OFFSET(seek_individually), AV_OPT_TYPE_BOOL, { .i64 = 1 },\n        0, 1, FLAGS},\n    {\"ignore_editlist\", \"Ignore the edit list atom.\", OFFSET(ignore_editlist), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"advanced_editlist\",\n        \"Modify the AVIndex according to the editlists. Use this option to decode in the order specified by the edits.\",\n        OFFSET(advanced_editlist), AV_OPT_TYPE_BOOL, {.i64 = 1},\n        0, 1, FLAGS},\n    {\"ignore_chapters\", \"\", OFFSET(ignore_chapters), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"use_mfra_for\",\n        \"use mfra for fragment timestamps\",\n        OFFSET(use_mfra_for), AV_OPT_TYPE_INT, {.i64 = FF_MOV_FLAG_MFRA_AUTO},\n        -1, FF_MOV_FLAG_MFRA_PTS, FLAGS,\n        \"use_mfra_for\"},\n    {\"auto\", \"auto\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_AUTO}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"dts\", \"dts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_DTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"pts\", \"pts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_PTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"use_tfdt\", \"use tfdt for fragment timestamps\", OFFSET(use_tfdt), AV_OPT_TYPE_BOOL, {.i64 = 1},\n        0, 1, FLAGS},\n    { \"export_all\", \"Export unrecognized metadata entries\", OFFSET(export_all),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"export_xmp\", \"Export full XMP metadata\", OFFSET(export_xmp),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"activation_bytes\", \"Secret bytes for Audible AAX files\", OFFSET(activation_bytes),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_key\", \"AES-128 Key for Audible AAXC files\", OFFSET(audible_key),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_iv\", \"AES-128 IV for Audible AAXC files\", OFFSET(audible_iv),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_fixed_key\", // extracted from libAAX_SDK.so and AAXSDKWin.dll files!\n        \"Fixed key used for handling Audible AAX files\", OFFSET(audible_fixed_key),\n        AV_OPT_TYPE_BINARY, {.str=\"77214d4b196a87cd520045fd20a51d67\"},\n        .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"decryption_key\", \"The media decryption key (hex)\", OFFSET(decryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"enable_drefs\", \"Enable external track support.\", OFFSET(enable_drefs), AV_OPT_TYPE_BOOL,\n        {.i64 = 0}, 0, 1, FLAGS },\n    { \"max_stts_delta\", \"treat offsets above this value as invalid\", OFFSET(max_stts_delta), AV_OPT_TYPE_INT, {.i64 = UINT_MAX-48000*10 }, 0, UINT_MAX, .flags = AV_OPT_FLAG_DECODING_PARAM },\n\n    { NULL },\n};\n\nstatic const AVClass mov_class = {\n    .class_name = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .item_name  = av_default_item_name,\n    .option     = mov_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nconst AVInputFormat ff_mov_demuxer = {\n    .name           = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),\n    .priv_class     = &mov_class,\n    .priv_data_size = sizeof(MOVContext),\n    .extensions     = \"mov,mp4,m4a,3gp,3g2,mj2,psp,m4b,ism,ismv,isma,f4v,avif\",\n    .flags_internal = FF_FMT_INIT_CLEANUP,\n    .read_probe     = mov_probe,\n    .read_header    = mov_read_header,\n    .read_packet    = mov_read_packet,\n    .read_close     = mov_read_close,\n    .read_seek      = mov_read_seek,\n    .flags          = AVFMT_NO_BYTE_SEEK | AVFMT_SEEK_TO_PTS | AVFMT_SHOW_IDS,\n};\n"], "fixing_code": ["/*\n * MOV demuxer\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * first version by Francois Revol <revol@free.fr>\n * seek function by Gael Chardon <gael.dev@4now.net>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"config_components.h\"\n\n#include <inttypes.h>\n#include <limits.h>\n#include <stdint.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/aes.h\"\n#include \"libavutil/aes_ctr.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/sha.h\"\n#include \"libavutil/spherical.h\"\n#include \"libavutil/stereo3d.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavutil/uuid.h\"\n#include \"libavcodec/ac3tab.h\"\n#include \"libavcodec/flac.h\"\n#include \"libavcodec/hevc.h\"\n#include \"libavcodec/mpegaudiodecheader.h\"\n#include \"libavcodec/mlp_parse.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"demux.h\"\n#include \"dovi_isom.h\"\n#include \"riff.h\"\n#include \"isom.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"id3v1.h\"\n#include \"mov_chan.h\"\n#include \"replaygain.h\"\n\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n\n#include \"qtpalette.h\"\n\n/* those functions parse an atom */\n/* links atom IDs to parse functions */\ntypedef struct MOVParseTableEntry {\n    uint32_t type;\n    int (*parse)(MOVContext *ctx, AVIOContext *pb, MOVAtom atom);\n} MOVParseTableEntry;\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom);\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f);\nstatic int64_t add_ctts_entry(MOVCtts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration);\n\nstatic int mov_metadata_track_or_disc_number(MOVContext *c, AVIOContext *pb,\n                                             unsigned len, const char *key)\n{\n    char buf[16];\n\n    short current, total = 0;\n    avio_rb16(pb); // unknown\n    current = avio_rb16(pb);\n    if (len >= 6)\n        total = avio_rb16(pb);\n    if (!total)\n        snprintf(buf, sizeof(buf), \"%d\", current);\n    else\n        snprintf(buf, sizeof(buf), \"%d/%d\", current, total);\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_bypass_padding(MOVContext *c, AVIOContext *pb,\n                                            unsigned len, const char *key)\n{\n    /* bypass padding bytes */\n    avio_r8(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_no_padding(MOVContext *c, AVIOContext *pb,\n                                        unsigned len, const char *key)\n{\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_gnre(MOVContext *c, AVIOContext *pb,\n                             unsigned len, const char *key)\n{\n    short genre;\n\n    avio_r8(pb); // unknown\n\n    genre = avio_r8(pb);\n    if (genre < 1 || genre > ID3v1_GENRE_MAX)\n        return 0;\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, ff_id3v1_genre_str[genre-1], 0);\n\n    return 0;\n}\n\nstatic const uint32_t mac_to_unicode[128] = {\n    0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,\n    0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,\n    0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,\n    0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,\n    0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,\n    0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,\n    0x221E,0x00B1,0x2264,0x2265,0x00A5,0x00B5,0x2202,0x2211,\n    0x220F,0x03C0,0x222B,0x00AA,0x00BA,0x03A9,0x00E6,0x00F8,\n    0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,\n    0x00BB,0x2026,0x00A0,0x00C0,0x00C3,0x00D5,0x0152,0x0153,\n    0x2013,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,\n    0x00FF,0x0178,0x2044,0x20AC,0x2039,0x203A,0xFB01,0xFB02,\n    0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,\n    0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,\n    0xF8FF,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x02C6,0x02DC,\n    0x00AF,0x02D8,0x02D9,0x02DA,0x00B8,0x02DD,0x02DB,0x02C7,\n};\n\nstatic int mov_read_mac_string(MOVContext *c, AVIOContext *pb, int len,\n                               char *dst, int dstlen)\n{\n    char *p = dst;\n    char *end = dst+dstlen-1;\n    int i;\n\n    for (i = 0; i < len; i++) {\n        uint8_t t, c = avio_r8(pb);\n\n        if (p >= end)\n            continue;\n\n        if (c < 0x80)\n            *p++ = c;\n        else if (p < end)\n            PUT_UTF8(mac_to_unicode[c-0x80], t, if (p < end) *p++ = t;);\n    }\n    *p = 0;\n    return p - dst;\n}\n\nstatic int mov_read_covr(MOVContext *c, AVIOContext *pb, int type, int len)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    int ret;\n\n    switch (type) {\n    case 0xd:  id = AV_CODEC_ID_MJPEG; break;\n    case 0xe:  id = AV_CODEC_ID_PNG;   break;\n    case 0x1b: id = AV_CODEC_ID_BMP;   break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown cover type: 0x%x.\\n\", type);\n        avio_skip(pb, len);\n        return 0;\n    }\n\n    sc = av_mallocz(sizeof(*sc));\n    if (!sc)\n        return AVERROR(ENOMEM);\n    ret = ff_add_attached_pic(c->fc, NULL, pb, NULL, len);\n    if (ret < 0) {\n        av_free(sc);\n        return ret;\n    }\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    st->priv_data = sc;\n\n    if (st->attached_pic.size >= 8 && id != AV_CODEC_ID_BMP) {\n        if (AV_RB64(st->attached_pic.data) == 0x89504e470d0a1a0a) {\n            id = AV_CODEC_ID_PNG;\n        } else {\n            id = AV_CODEC_ID_MJPEG;\n        }\n    }\n    st->codecpar->codec_id   = id;\n\n    return 0;\n}\n\n// 3GPP TS 26.244\nstatic int mov_metadata_loci(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    char language[4] = { 0 };\n    char buf[200], place[100];\n    uint16_t langcode = 0;\n    double longitude, latitude, altitude;\n    const char *key = \"location\";\n\n    if (len < 4 + 2 + 1 + 1 + 4 + 4 + 4) {\n        av_log(c->fc, AV_LOG_ERROR, \"loci too short\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // version+flags\n    langcode = avio_rb16(pb);\n    ff_mov_lang_to_iso639(langcode, language);\n    len -= 6;\n\n    len -= avio_get_str(pb, len, place, sizeof(place));\n    if (len < 1) {\n        av_log(c->fc, AV_LOG_ERROR, \"place name too long\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(pb, 1); // role\n    len -= 1;\n\n    if (len < 12) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"loci too short (%u bytes left, need at least %d)\\n\", len, 12);\n        return AVERROR_INVALIDDATA;\n    }\n    longitude = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    latitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    altitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n\n    // Try to output in the same format as the ?xyz field\n    snprintf(buf, sizeof(buf), \"%+08.4f%+09.4f\",  latitude, longitude);\n    if (altitude)\n        av_strlcatf(buf, sizeof(buf), \"%+f\", altitude);\n    av_strlcatf(buf, sizeof(buf), \"/%s\", place);\n\n    if (*language && strcmp(language, \"und\")) {\n        char key2[16];\n        snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n        av_dict_set(&c->fc->metadata, key2, buf, 0);\n    }\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    return av_dict_set(&c->fc->metadata, key, buf, 0);\n}\n\nstatic int mov_metadata_hmmt(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    int i, n_hmmt;\n\n    if (len < 2)\n        return 0;\n    if (c->ignore_chapters)\n        return 0;\n\n    n_hmmt = avio_rb32(pb);\n    if (n_hmmt > len / 4)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < n_hmmt && !pb->eof_reached; i++) {\n        int moment_time = avio_rb32(pb);\n        avpriv_new_chapter(c->fc, i, av_make_q(1, 1000), moment_time, AV_NOPTS_VALUE, NULL);\n    }\n    if (avio_feof(pb))\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nstatic int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    char tmp_key[AV_FOURCC_MAX_STRING_SIZE] = {0};\n    char key2[32], language[4] = {0};\n    char *str = NULL;\n    const char *key = NULL;\n    uint16_t langcode = 0;\n    uint32_t data_type = 0, str_size, str_size_alloc;\n    int (*parse)(MOVContext*, AVIOContext*, unsigned, const char*) = NULL;\n    int raw = 0;\n    int num = 0;\n\n    switch (atom.type) {\n    case MKTAG( '@','P','R','M'): key = \"premiere_version\"; raw = 1; break;\n    case MKTAG( '@','P','R','Q'): key = \"quicktime_version\"; raw = 1; break;\n    case MKTAG( 'X','M','P','_'):\n        if (c->export_xmp) { key = \"xmp\"; raw = 1; } break;\n    case MKTAG( 'a','A','R','T'): key = \"album_artist\";    break;\n    case MKTAG( 'a','k','I','D'): key = \"account_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'a','p','I','D'): key = \"account_id\"; break;\n    case MKTAG( 'c','a','t','g'): key = \"category\"; break;\n    case MKTAG( 'c','p','i','l'): key = \"compilation\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'c','p','r','t'): key = \"copyright\"; break;\n    case MKTAG( 'd','e','s','c'): key = \"description\"; break;\n    case MKTAG( 'd','i','s','k'): key = \"disc\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 'e','g','i','d'): key = \"episode_uid\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'F','I','R','M'): key = \"firmware\"; raw = 1; break;\n    case MKTAG( 'g','n','r','e'): key = \"genre\";\n        parse = mov_metadata_gnre; break;\n    case MKTAG( 'h','d','v','d'): key = \"hd_video\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'H','M','M','T'):\n        return mov_metadata_hmmt(c, pb, atom.size);\n    case MKTAG( 'k','e','y','w'): key = \"keywords\";  break;\n    case MKTAG( 'l','d','e','s'): key = \"synopsis\";  break;\n    case MKTAG( 'l','o','c','i'):\n        return mov_metadata_loci(c, pb, atom.size);\n    case MKTAG( 'm','a','n','u'): key = \"make\"; break;\n    case MKTAG( 'm','o','d','l'): key = \"model\"; break;\n    case MKTAG( 'p','c','s','t'): key = \"podcast\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','g','a','p'): key = \"gapless_playback\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','u','r','d'): key = \"purchase_date\"; break;\n    case MKTAG( 'r','t','n','g'): key = \"rating\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 's','o','a','a'): key = \"sort_album_artist\"; break;\n    case MKTAG( 's','o','a','l'): key = \"sort_album\";   break;\n    case MKTAG( 's','o','a','r'): key = \"sort_artist\";  break;\n    case MKTAG( 's','o','c','o'): key = \"sort_composer\"; break;\n    case MKTAG( 's','o','n','m'): key = \"sort_name\";    break;\n    case MKTAG( 's','o','s','n'): key = \"sort_show\";    break;\n    case MKTAG( 's','t','i','k'): key = \"media_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 't','r','k','n'): key = \"track\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 't','v','e','n'): key = \"episode_id\"; break;\n    case MKTAG( 't','v','e','s'): key = \"episode_sort\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 't','v','n','n'): key = \"network\";   break;\n    case MKTAG( 't','v','s','h'): key = \"show\";      break;\n    case MKTAG( 't','v','s','n'): key = \"season_number\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG(0xa9,'A','R','T'): key = \"artist\";    break;\n    case MKTAG(0xa9,'P','R','D'): key = \"producer\";  break;\n    case MKTAG(0xa9,'a','l','b'): key = \"album\";     break;\n    case MKTAG(0xa9,'a','u','t'): key = \"artist\";    break;\n    case MKTAG(0xa9,'c','h','p'): key = \"chapter\";   break;\n    case MKTAG(0xa9,'c','m','t'): key = \"comment\";   break;\n    case MKTAG(0xa9,'c','o','m'): key = \"composer\";  break;\n    case MKTAG(0xa9,'c','p','y'): key = \"copyright\"; break;\n    case MKTAG(0xa9,'d','a','y'): key = \"date\";      break;\n    case MKTAG(0xa9,'d','i','r'): key = \"director\";  break;\n    case MKTAG(0xa9,'d','i','s'): key = \"disclaimer\"; break;\n    case MKTAG(0xa9,'e','d','1'): key = \"edit_date\"; break;\n    case MKTAG(0xa9,'e','n','c'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'f','m','t'): key = \"original_format\"; break;\n    case MKTAG(0xa9,'g','e','n'): key = \"genre\";     break;\n    case MKTAG(0xa9,'g','r','p'): key = \"grouping\";  break;\n    case MKTAG(0xa9,'h','s','t'): key = \"host_computer\"; break;\n    case MKTAG(0xa9,'i','n','f'): key = \"comment\";   break;\n    case MKTAG(0xa9,'l','y','r'): key = \"lyrics\";    break;\n    case MKTAG(0xa9,'m','a','k'): key = \"make\";      break;\n    case MKTAG(0xa9,'m','o','d'): key = \"model\";     break;\n    case MKTAG(0xa9,'n','a','m'): key = \"title\";     break;\n    case MKTAG(0xa9,'o','p','e'): key = \"original_artist\"; break;\n    case MKTAG(0xa9,'p','r','d'): key = \"producer\";  break;\n    case MKTAG(0xa9,'p','r','f'): key = \"performers\"; break;\n    case MKTAG(0xa9,'r','e','q'): key = \"playback_requirements\"; break;\n    case MKTAG(0xa9,'s','r','c'): key = \"original_source\"; break;\n    case MKTAG(0xa9,'s','t','3'): key = \"subtitle\";  break;\n    case MKTAG(0xa9,'s','w','r'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','o','o'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','r','k'): key = \"track\";     break;\n    case MKTAG(0xa9,'u','r','l'): key = \"URL\";       break;\n    case MKTAG(0xa9,'w','r','n'): key = \"warning\";   break;\n    case MKTAG(0xa9,'w','r','t'): key = \"composer\";  break;\n    case MKTAG(0xa9,'x','y','z'): key = \"location\";  break;\n    }\nretry:\n    if (c->itunes_metadata && atom.size > 8) {\n        int data_size = avio_rb32(pb);\n        int tag = avio_rl32(pb);\n        if (tag == MKTAG('d','a','t','a') && data_size <= atom.size && data_size >= 16) {\n            data_type = avio_rb32(pb); // type\n            avio_rb32(pb); // unknown\n            str_size = data_size - 16;\n            atom.size -= 16;\n\n            if (!key && c->found_hdlr_mdta && c->meta_keys) {\n                uint32_t index = av_bswap32(atom.type); // BE number has been read as LE\n                if (index < c->meta_keys_count && index > 0) {\n                    key = c->meta_keys[index];\n                } else if (atom.type != MKTAG('c', 'o', 'v', 'r')) {\n                    av_log(c->fc, AV_LOG_WARNING,\n                           \"The index of 'data' is out of range: %\"PRId32\" < 1 or >= %d.\\n\",\n                           index, c->meta_keys_count);\n                }\n            }\n            if (atom.type == MKTAG('c', 'o', 'v', 'r') ||\n                (key && !strcmp(key, \"com.apple.quicktime.artwork\"))) {\n                int ret = mov_read_covr(c, pb, data_type, str_size);\n                if (ret < 0) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Error parsing cover art.\\n\");\n                    return ret;\n                }\n                atom.size -= str_size;\n                if (atom.size > 8)\n                    goto retry;\n                return ret;\n            }\n        } else return 0;\n    } else if (atom.size > 4 && key && !c->itunes_metadata && !raw) {\n        str_size = avio_rb16(pb); // string length\n        if (str_size > atom.size) {\n            raw = 1;\n            avio_seek(pb, -2, SEEK_CUR);\n            av_log(c->fc, AV_LOG_WARNING, \"UDTA parsing failed retrying raw\\n\");\n            goto retry;\n        }\n        langcode = avio_rb16(pb);\n        ff_mov_lang_to_iso639(langcode, language);\n        atom.size -= 4;\n    } else\n        str_size = atom.size;\n\n    if (c->export_all && !key) {\n        key = av_fourcc_make_string(tmp_key, atom.type);\n    }\n\n    if (!key)\n        return 0;\n    if (atom.size < 0 || str_size >= INT_MAX/2)\n        return AVERROR_INVALIDDATA;\n\n    // Allocates enough space if data_type is a int32 or float32 number, otherwise\n    // worst-case requirement for output string in case of utf8 coded input\n    num = (data_type >= 21 && data_type <= 23);\n    str_size_alloc = (num ? 512 : (raw ? str_size : str_size * 2)) + 1;\n    str = av_mallocz(str_size_alloc);\n    if (!str)\n        return AVERROR(ENOMEM);\n\n    if (parse)\n        parse(c, pb, str_size, key);\n    else {\n        if (!raw && (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff)))) { // MAC Encoded\n            mov_read_mac_string(c, pb, str_size, str, str_size_alloc);\n        } else if (data_type == 21) { // BE signed integer, variable size\n            int val = 0;\n            if (str_size == 1)\n                val = (int8_t)avio_r8(pb);\n            else if (str_size == 2)\n                val = (int16_t)avio_rb16(pb);\n            else if (str_size == 3)\n                val = ((int32_t)(avio_rb24(pb)<<8))>>8;\n            else if (str_size == 4)\n                val = (int32_t)avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%d\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%d) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 22) { // BE unsigned integer, variable size\n            unsigned int val = 0;\n            if (str_size == 1)\n                val = avio_r8(pb);\n            else if (str_size == 2)\n                val = avio_rb16(pb);\n            else if (str_size == 3)\n                val = avio_rb24(pb);\n            else if (str_size == 4)\n                val = avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%u\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%u) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 23 && str_size >= 4) {  // BE float32\n            float val = av_int2float(avio_rb32(pb));\n            if (snprintf(str, str_size_alloc, \"%f\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the float32 number (%f) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type > 1 && data_type != 4) {\n            // data_type can be 0 if not set at all above. data_type 1 means\n            // UTF8 and 4 means \"UTF8 sort\". For any other type (UTF16 or e.g.\n            // a picture), don't return it blindly in a string that is supposed\n            // to be UTF8 text.\n            av_log(c->fc, AV_LOG_WARNING, \"Skipping unhandled metadata %s of type %d\\n\", key, data_type);\n            av_free(str);\n            return 0;\n        } else {\n            int ret = ffio_read_size(pb, str, str_size);\n            if (ret < 0) {\n                av_free(str);\n                return ret;\n            }\n            str[str_size] = 0;\n        }\n        c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n        av_dict_set(&c->fc->metadata, key, str, 0);\n        if (*language && strcmp(language, \"und\")) {\n            snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n            av_dict_set(&c->fc->metadata, key2, str, 0);\n        }\n        if (!strcmp(key, \"encoder\")) {\n            int major, minor, micro;\n            if (sscanf(str, \"HandBrake %d.%d.%d\", &major, &minor, &micro) == 3) {\n                c->handbrake_version = 1000000*major + 1000*minor + micro;\n            }\n        }\n    }\n\n    av_freep(&str);\n    return 0;\n}\n\nstatic int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n    int ret;\n\n    if (c->ignore_chapters)\n        return 0;\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        ret = ffio_read_size(pb, str, str_len);\n        if (ret < 0)\n            return ret;\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}\n\n#define MIN_DATA_ENTRY_BOX_SIZE 12\nstatic int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int entries, i, j;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n    entries = avio_rb32(pb);\n    if (!entries ||\n        entries >  (atom.size - 1) / MIN_DATA_ENTRY_BOX_SIZE + 1 ||\n        entries >= UINT_MAX / sizeof(*sc->drefs))\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < sc->drefs_count; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        av_freep(&dref->path);\n        av_freep(&dref->dir);\n    }\n    av_free(sc->drefs);\n    sc->drefs_count = 0;\n    sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));\n    if (!sc->drefs)\n        return AVERROR(ENOMEM);\n    sc->drefs_count = entries;\n\n    for (i = 0; i < entries; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        uint32_t size = avio_rb32(pb);\n        int64_t next = avio_tell(pb);\n\n        if (size < 12 || next < 0 || next > INT64_MAX - size)\n            return AVERROR_INVALIDDATA;\n\n        next += size - 4;\n\n        dref->type = avio_rl32(pb);\n        avio_rb32(pb); // version + flags\n\n        if (dref->type == MKTAG('a','l','i','s') && size > 150) {\n            /* macintosh alias record */\n            uint16_t volume_len, len;\n            int16_t type;\n            int ret;\n\n            avio_skip(pb, 10);\n\n            volume_len = avio_r8(pb);\n            volume_len = FFMIN(volume_len, 27);\n            ret = ffio_read_size(pb, dref->volume, 27);\n            if (ret < 0)\n                return ret;\n            dref->volume[volume_len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);\n\n            avio_skip(pb, 12);\n\n            len = avio_r8(pb);\n            len = FFMIN(len, 63);\n            ret = ffio_read_size(pb, dref->filename, 63);\n            if (ret < 0)\n                return ret;\n            dref->filename[len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);\n\n            avio_skip(pb, 16);\n\n            /* read next level up_from_alias/down_to_target */\n            dref->nlvl_from = avio_rb16(pb);\n            dref->nlvl_to   = avio_rb16(pb);\n            av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",\n                   dref->nlvl_from, dref->nlvl_to);\n\n            avio_skip(pb, 16);\n\n            for (type = 0; type != -1 && avio_tell(pb) < next; ) {\n                if (avio_feof(pb))\n                    return AVERROR_EOF;\n                type = avio_rb16(pb);\n                len = avio_rb16(pb);\n                av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);\n                if (len&1)\n                    len += 1;\n                if (type == 2) { // absolute path\n                    av_free(dref->path);\n                    dref->path = av_mallocz(len+1);\n                    if (!dref->path)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->path, len);\n                    if (ret < 0) {\n                        av_freep(&dref->path);\n                        return ret;\n                    }\n                    if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n                        len -= volume_len;\n                        memmove(dref->path, dref->path+volume_len, len);\n                        dref->path[len] = 0;\n                    }\n                    // trim string of any ending zeros\n                    for (j = len - 1; j >= 0; j--) {\n                        if (dref->path[j] == 0)\n                            len--;\n                        else\n                            break;\n                    }\n                    for (j = 0; j < len; j++)\n                        if (dref->path[j] == ':' || dref->path[j] == 0)\n                            dref->path[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);\n                } else if (type == 0) { // directory name\n                    av_free(dref->dir);\n                    dref->dir = av_malloc(len+1);\n                    if (!dref->dir)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->dir, len);\n                    if (ret < 0) {\n                        av_freep(&dref->dir);\n                        return ret;\n                    }\n                    dref->dir[len] = 0;\n                    for (j = 0; j < len; j++)\n                        if (dref->dir[j] == ':')\n                            dref->dir[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);\n                } else\n                    avio_skip(pb, len);\n            }\n        } else {\n            av_log(c->fc, AV_LOG_DEBUG, \"Unknown dref type 0x%08\"PRIx32\" size %\"PRIu32\"\\n\",\n                   dref->type, size);\n            entries--;\n            i--;\n        }\n        avio_seek(pb, next, SEEK_SET);\n    }\n    return 0;\n}\n\nstatic int mov_read_hdlr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint32_t type;\n    uint32_t ctype;\n    int64_t title_size;\n    char *title_str;\n    int ret;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    /* component type */\n    ctype = avio_rl32(pb);\n    type = avio_rl32(pb); /* component subtype */\n\n    av_log(c->fc, AV_LOG_TRACE, \"ctype=%s\\n\", av_fourcc2str(ctype));\n    av_log(c->fc, AV_LOG_TRACE, \"stype=%s\\n\", av_fourcc2str(type));\n\n    if (c->trak_index < 0) {  // meta not inside a trak\n        if (type == MKTAG('m','d','t','a')) {\n            c->found_hdlr_mdta = 1;\n        }\n        return 0;\n    }\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if     (type == MKTAG('v','i','d','e'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    else if (type == MKTAG('s','o','u','n'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    else if (type == MKTAG('m','1','a',' '))\n        st->codecpar->codec_id = AV_CODEC_ID_MP2;\n    else if ((type == MKTAG('s','u','b','p')) || (type == MKTAG('c','l','c','p')))\n        st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    avio_rb32(pb); /* component  manufacture */\n    avio_rb32(pb); /* component flags */\n    avio_rb32(pb); /* component flags mask */\n\n    title_size = atom.size - 24;\n    if (title_size > 0) {\n        if (title_size > FFMIN(INT_MAX, SIZE_MAX-1))\n            return AVERROR_INVALIDDATA;\n        title_str = av_malloc(title_size + 1); /* Add null terminator */\n        if (!title_str)\n            return AVERROR(ENOMEM);\n\n        ret = ffio_read_size(pb, title_str, title_size);\n        if (ret < 0) {\n            av_freep(&title_str);\n            return ret;\n        }\n        title_str[title_size] = 0;\n        if (title_str[0]) {\n            int off = (!c->isom && title_str[0] == title_size - 1);\n            // flag added so as to not set stream handler name if already set from mdia->hdlr\n            av_dict_set(&st->metadata, \"handler_name\", title_str + off, AV_DICT_DONT_OVERWRITE);\n        }\n        av_freep(&title_str);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_esds(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return ff_mov_read_esds(c->fc, pb);\n}\n\nstatic int mov_read_dac3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int ac3info, acmod, lfeon, bsmod;\n    uint64_t mask;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    ac3info = avio_rb24(pb);\n    bsmod = (ac3info >> 14) & 0x7;\n    acmod = (ac3info >> 11) & 0x7;\n    lfeon = (ac3info >> 10) & 0x1;\n\n    mask = ff_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        mask |= AV_CH_LOW_FREQUENCY;\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout, mask);\n\n    *ast = bsmod;\n    if (st->codecpar->ch_layout.nb_channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n    return 0;\n}\n\nstatic int mov_read_dec3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int eac3info, acmod, lfeon, bsmod;\n    uint64_t mask;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    /* No need to parse fields for additional independent substreams and its\n     * associated dependent substreams since libavcodec's E-AC-3 decoder\n     * does not support them yet. */\n    avio_rb16(pb); /* data_rate and num_ind_sub */\n    eac3info = avio_rb24(pb);\n    bsmod = (eac3info >> 12) & 0x1f;\n    acmod = (eac3info >>  9) & 0x7;\n    lfeon = (eac3info >>  8) & 0x1;\n\n    mask = ff_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        mask |= AV_CH_LOW_FREQUENCY;\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout, mask);\n\n    *ast = bsmod;\n    if (st->codecpar->ch_layout.nb_channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n    return 0;\n}\n\nstatic int mov_read_ddts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#define DDTS_SIZE 20\n    uint8_t buf[DDTS_SIZE + AV_INPUT_BUFFER_PADDING_SIZE];\n    AVStream *st = NULL;\n    uint32_t frame_duration_code = 0;\n    uint32_t channel_layout_code = 0;\n    GetBitContext gb;\n    int ret;\n\n    if ((ret = ffio_read_size(pb, buf, DDTS_SIZE)) < 0)\n        return ret;\n\n    init_get_bits(&gb, buf, 8 * DDTS_SIZE);\n\n    if (c->fc->nb_streams < 1) {\n        return 0;\n    }\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    st->codecpar->sample_rate = get_bits_long(&gb, 32);\n    if (st->codecpar->sample_rate <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n    skip_bits_long(&gb, 32); /* max bitrate */\n    st->codecpar->bit_rate = get_bits_long(&gb, 32);\n    st->codecpar->bits_per_coded_sample = get_bits(&gb, 8);\n    frame_duration_code = get_bits(&gb, 2);\n    skip_bits(&gb, 30); /* various fields */\n    channel_layout_code = get_bits(&gb, 16);\n\n    st->codecpar->frame_size =\n            (frame_duration_code == 0) ? 512 :\n            (frame_duration_code == 1) ? 1024 :\n            (frame_duration_code == 2) ? 2048 :\n            (frame_duration_code == 3) ? 4096 : 0;\n\n    if (channel_layout_code > 0xff) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported DTS audio channel layout\\n\");\n    }\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout,\n            ((channel_layout_code & 0x1) ? AV_CH_FRONT_CENTER : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_LEFT : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_RIGHT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_LEFT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_RIGHT : 0) |\n            ((channel_layout_code & 0x8) ? AV_CH_LOW_FREQUENCY : 0));\n\n    return 0;\n}\n\nstatic int mov_read_chan(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 16)\n        return 0;\n\n    /* skip version and flags */\n    avio_skip(pb, 4);\n\n    ff_mov_read_chan(c->fc, pb, st, atom.size - 4);\n\n    return 0;\n}\n\nstatic int mov_read_wfex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((ret = ff_get_wav_header(c->fc, pb, st->codecpar, atom.size, 0)) < 0)\n        av_log(c->fc, AV_LOG_WARNING, \"get_wav_header failed\\n\");\n\n    return ret;\n}\n\n/* This atom overrides any previously set aspect ratio */\nstatic int mov_read_pasp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int num = avio_rb32(pb);\n    const int den = avio_rb32(pb);\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (den != 0) {\n        av_reduce(&st->sample_aspect_ratio.num, &st->sample_aspect_ratio.den,\n                  num, den, 32767);\n    }\n    return 0;\n}\n\n/* this atom contains actual media data */\nstatic int mov_read_mdat(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size == 0) /* wrong one (MP4) */\n        return 0;\n    c->found_mdat=1;\n    return 0; /* now go for moov */\n}\n\n#define DRM_BLOB_SIZE 56\n\nstatic int mov_read_adrm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint8_t intermediate_key[20];\n    uint8_t intermediate_iv[20];\n    uint8_t input[64];\n    uint8_t output[64];\n    uint8_t file_checksum[20];\n    uint8_t calculated_checksum[20];\n    char checksum_string[2 * sizeof(file_checksum) + 1];\n    struct AVSHA *sha;\n    int i;\n    int ret = 0;\n    uint8_t *activation_bytes = c->activation_bytes;\n    uint8_t *fixed_key = c->audible_fixed_key;\n\n    c->aax_mode = 1;\n\n    sha = av_sha_alloc();\n    if (!sha)\n        return AVERROR(ENOMEM);\n    av_free(c->aes_decrypt);\n    c->aes_decrypt = av_aes_alloc();\n    if (!c->aes_decrypt) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    /* drm blob processing */\n    avio_read(pb, output, 8); // go to offset 8, absolute position 0x251\n    avio_read(pb, input, DRM_BLOB_SIZE);\n    avio_read(pb, output, 4); // go to offset 4, absolute position 0x28d\n    avio_read(pb, file_checksum, 20);\n\n    // required by external tools\n    ff_data_to_hex(checksum_string, file_checksum, sizeof(file_checksum), 1);\n    av_log(c->fc, AV_LOG_INFO, \"[aax] file checksum == %s\\n\", checksum_string);\n\n    /* verify activation data */\n    if (!activation_bytes) {\n        av_log(c->fc, AV_LOG_WARNING, \"[aax] activation_bytes option is missing!\\n\");\n        ret = 0;  /* allow ffprobe to continue working on .aax files */\n        goto fail;\n    }\n    if (c->activation_bytes_size != 4) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] activation_bytes value needs to be 4 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* verify fixed key */\n    if (c->audible_fixed_key_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] audible_fixed_key value needs to be 16 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* AAX (and AAX+) key derivation */\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_key);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, intermediate_key, 20);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_iv);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, intermediate_key, 16);\n    av_sha_update(sha, intermediate_iv, 16);\n    av_sha_final(sha, calculated_checksum);\n    if (memcmp(calculated_checksum, file_checksum, 20)) { // critical error\n        av_log(c->fc, AV_LOG_ERROR, \"[aax] mismatch in checksums!\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    av_aes_init(c->aes_decrypt, intermediate_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, output, input, DRM_BLOB_SIZE >> 4, intermediate_iv, 1);\n    for (i = 0; i < 4; i++) {\n        // file data (in output) is stored in big-endian mode\n        if (activation_bytes[i] != output[3 - i]) { // critical error\n            av_log(c->fc, AV_LOG_ERROR, \"[aax] error in drm blob decryption!\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    memcpy(c->file_key, output + 8, 16);\n    memcpy(input, output + 26, 16);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, input, 16);\n    av_sha_update(sha, c->file_key, 16);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_final(sha, c->file_iv);\n\nfail:\n    av_free(sha);\n\n    return ret;\n}\n\nstatic int mov_aaxc_crypto(MOVContext *c)\n{\n    if (c->audible_key_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aaxc] audible_key value needs to be 16 bytes!\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (c->audible_iv_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aaxc] audible_iv value needs to be 16 bytes!\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    c->aes_decrypt = av_aes_alloc();\n    if (!c->aes_decrypt) {\n        return AVERROR(ENOMEM);\n    }\n\n    memcpy(c->file_key, c->audible_key, 16);\n    memcpy(c->file_iv, c->audible_iv, 16);\n    c->aax_mode = 1;\n\n    return 0;\n}\n\n// Audible AAX (and AAX+) bytestream decryption\nstatic int aax_filter(uint8_t *input, int size, MOVContext *c)\n{\n    int blocks = 0;\n    unsigned char iv[16];\n\n    memcpy(iv, c->file_iv, 16); // iv is overwritten\n    blocks = size >> 4; // trailing bytes are not encrypted!\n    av_aes_init(c->aes_decrypt, c->file_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, input, input, blocks, iv, 1);\n\n    return 0;\n}\n\n/* read major brand, minor version and compatible brands and store them as metadata */\nstatic int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t minor_ver;\n    int comp_brand_size;\n    char* comp_brands_str;\n    uint8_t type[5] = {0};\n    int ret = ffio_read_size(pb, type, 4);\n    if (ret < 0)\n        return ret;\n\n    if (strcmp(type, \"qt  \"))\n        c->isom = 1;\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n    c->is_still_picture_avif = !strncmp(type, \"avif\", 4);\n    minor_ver = avio_rb32(pb); /* minor version */\n    av_dict_set_int(&c->fc->metadata, \"minor_version\", minor_ver, 0);\n\n    comp_brand_size = atom.size - 8;\n    if (comp_brand_size < 0 || comp_brand_size == INT_MAX)\n        return AVERROR_INVALIDDATA;\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n    if (!comp_brands_str)\n        return AVERROR(ENOMEM);\n\n    ret = ffio_read_size(pb, comp_brands_str, comp_brand_size);\n    if (ret < 0) {\n        av_freep(&comp_brands_str);\n        return ret;\n    }\n    comp_brands_str[comp_brand_size] = 0;\n    av_dict_set(&c->fc->metadata, \"compatible_brands\",\n                comp_brands_str, AV_DICT_DONT_STRDUP_VAL);\n\n    // Logic for handling Audible's .aaxc files\n    if (!strcmp(type, \"aaxc\")) {\n        mov_aaxc_crypto(c);\n    }\n\n    return 0;\n}\n\n/* this atom should contain all header atoms */\nstatic int mov_read_moov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n\n    if (c->found_moov) {\n        av_log(c->fc, AV_LOG_WARNING, \"Found duplicated MOOV Atom. Skipped it\\n\");\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n    /* we parsed the 'moov' atom, we can terminate the parsing as soon as we find the 'mdat' */\n    /* so we don't parse the whole file if over a network */\n    c->found_moov=1;\n    return 0; /* now go for mdat */\n}\n\nstatic MOVFragmentStreamInfo * get_frag_stream_info(\n    MOVFragmentIndex *frag_index,\n    int index,\n    int id)\n{\n    int i;\n    MOVFragmentIndexItem * item;\n\n    if (index < 0 || index >= frag_index->nb_items)\n        return NULL;\n    item = &frag_index->item[index];\n    for (i = 0; i < item->nb_stream_info; i++)\n        if (item->stream_info[i].id == id)\n            return &item->stream_info[i];\n\n    // This shouldn't happen\n    return NULL;\n}\n\nstatic void set_frag_stream(MOVFragmentIndex *frag_index, int id)\n{\n    int i;\n    MOVFragmentIndexItem * item;\n\n    if (frag_index->current < 0 ||\n        frag_index->current >= frag_index->nb_items)\n        return;\n\n    item = &frag_index->item[frag_index->current];\n    for (i = 0; i < item->nb_stream_info; i++)\n        if (item->stream_info[i].id == id) {\n            item->current = i;\n            return;\n        }\n\n    // id not found.  This shouldn't happen.\n    item->current = -1;\n}\n\nstatic MOVFragmentStreamInfo * get_current_frag_stream_info(\n    MOVFragmentIndex *frag_index)\n{\n    MOVFragmentIndexItem *item;\n    if (frag_index->current < 0 ||\n        frag_index->current >= frag_index->nb_items)\n        return NULL;\n\n    item = &frag_index->item[frag_index->current];\n    if (item->current >= 0 && item->current < item->nb_stream_info)\n        return &item->stream_info[item->current];\n\n    // This shouldn't happen\n    return NULL;\n}\n\nstatic int search_frag_moof_offset(MOVFragmentIndex *frag_index, int64_t offset)\n{\n    int a, b, m;\n    int64_t moof_offset;\n\n    // Optimize for appending new entries\n    if (!frag_index->nb_items ||\n        frag_index->item[frag_index->nb_items - 1].moof_offset < offset)\n        return frag_index->nb_items;\n\n    a = -1;\n    b = frag_index->nb_items;\n\n    while (b - a > 1) {\n        m = (a + b) >> 1;\n        moof_offset = frag_index->item[m].moof_offset;\n        if (moof_offset >= offset)\n            b = m;\n        if (moof_offset <= offset)\n            a = m;\n    }\n    return b;\n}\n\nstatic int64_t get_stream_info_time(MOVFragmentStreamInfo * frag_stream_info)\n{\n    av_assert0(frag_stream_info);\n    if (frag_stream_info->sidx_pts != AV_NOPTS_VALUE)\n        return frag_stream_info->sidx_pts;\n    if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE)\n        return frag_stream_info->first_tfra_pts;\n    return frag_stream_info->tfdt_dts;\n}\n\nstatic int64_t get_frag_time(AVFormatContext *s, AVStream *dst_st,\n                             MOVFragmentIndex *frag_index, int index)\n{\n    MOVFragmentStreamInfo * frag_stream_info;\n    MOVStreamContext *sc = dst_st->priv_data;\n    int64_t timestamp;\n    int i, j;\n\n    // If the stream is referenced by any sidx, limit the search\n    // to fragments that referenced this stream in the sidx\n    if (sc->has_sidx) {\n        frag_stream_info = get_frag_stream_info(frag_index, index, dst_st->id);\n        if (frag_stream_info->sidx_pts != AV_NOPTS_VALUE)\n            return frag_stream_info->sidx_pts;\n        if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE)\n            return frag_stream_info->first_tfra_pts;\n        return frag_stream_info->sidx_pts;\n    }\n\n    for (i = 0; i < frag_index->item[index].nb_stream_info; i++) {\n        AVStream *frag_stream = NULL;\n        frag_stream_info = &frag_index->item[index].stream_info[i];\n        for (j = 0; j < s->nb_streams; j++)\n            if (s->streams[j]->id == frag_stream_info->id)\n                frag_stream = s->streams[j];\n        if (!frag_stream) {\n            av_log(s, AV_LOG_WARNING, \"No stream matching sidx ID found.\\n\");\n            continue;\n        }\n        timestamp = get_stream_info_time(frag_stream_info);\n        if (timestamp != AV_NOPTS_VALUE)\n            return av_rescale_q(timestamp, frag_stream->time_base, dst_st->time_base);\n    }\n    return AV_NOPTS_VALUE;\n}\n\nstatic int search_frag_timestamp(AVFormatContext *s, MOVFragmentIndex *frag_index,\n                                 AVStream *st, int64_t timestamp)\n{\n    int a, b, m, m0;\n    int64_t frag_time;\n\n    a = -1;\n    b = frag_index->nb_items;\n\n    while (b - a > 1) {\n        m0 = m = (a + b) >> 1;\n\n        while (m < b &&\n               (frag_time = get_frag_time(s, st, frag_index, m)) == AV_NOPTS_VALUE)\n            m++;\n\n        if (m < b && frag_time <= timestamp)\n            a = m;\n        else\n            b = m0;\n    }\n\n    return a;\n}\n\nstatic int update_frag_index(MOVContext *c, int64_t offset)\n{\n    int index, i;\n    MOVFragmentIndexItem * item;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    // If moof_offset already exists in frag_index, return index to it\n    index = search_frag_moof_offset(&c->frag_index, offset);\n    if (index < c->frag_index.nb_items &&\n        c->frag_index.item[index].moof_offset == offset)\n        return index;\n\n    // offset is not yet in frag index.\n    // Insert new item at index (sorted by moof offset)\n    item = av_fast_realloc(c->frag_index.item,\n                           &c->frag_index.allocated_size,\n                           (c->frag_index.nb_items + 1) *\n                           sizeof(*c->frag_index.item));\n    if (!item)\n        return -1;\n    c->frag_index.item = item;\n\n    frag_stream_info = av_realloc_array(NULL, c->fc->nb_streams,\n                                        sizeof(*item->stream_info));\n    if (!frag_stream_info)\n        return -1;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        // Avoid building frag index if streams lack track id.\n        if (c->fc->streams[i]->id < 0) {\n            av_free(frag_stream_info);\n            return AVERROR_INVALIDDATA;\n        }\n\n        frag_stream_info[i].id = c->fc->streams[i]->id;\n        frag_stream_info[i].sidx_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].index_base = -1;\n        frag_stream_info[i].index_entry = -1;\n        frag_stream_info[i].encryption_index = NULL;\n    }\n\n    if (index < c->frag_index.nb_items)\n        memmove(c->frag_index.item + index + 1, c->frag_index.item + index,\n                (c->frag_index.nb_items - index) * sizeof(*c->frag_index.item));\n\n    item = &c->frag_index.item[index];\n    item->headers_read = 0;\n    item->current = 0;\n    item->nb_stream_info = c->fc->nb_streams;\n    item->moof_offset = offset;\n    item->stream_info = frag_stream_info;\n    c->frag_index.nb_items++;\n\n    return index;\n}\n\nstatic void fix_frag_index_entries(MOVFragmentIndex *frag_index, int index,\n                                   int id, int entries)\n{\n    int i;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    if (index < 0)\n        return;\n    for (i = index; i < frag_index->nb_items; i++) {\n        frag_stream_info = get_frag_stream_info(frag_index, i, id);\n        if (frag_stream_info && frag_stream_info->index_entry >= 0)\n            frag_stream_info->index_entry += entries;\n    }\n}\n\nstatic int mov_read_moof(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    // Set by mov_read_tfhd(). mov_read_trun() will reject files missing tfhd.\n    c->fragment.found_tfhd = 0;\n\n    if (!c->has_looked_for_mfra && c->use_mfra_for > 0) {\n        c->has_looked_for_mfra = 1;\n        if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n            int ret;\n            av_log(c->fc, AV_LOG_VERBOSE, \"stream has moof boxes, will look \"\n                    \"for a mfra\\n\");\n            if ((ret = mov_read_mfra(c, pb)) < 0) {\n                av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but failed to \"\n                        \"read the mfra (may be a live ismv)\\n\");\n            }\n        } else {\n            av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but stream is not \"\n                    \"seekable, can not look for mfra\\n\");\n        }\n    }\n    c->fragment.moof_offset = c->fragment.implicit_offset = avio_tell(pb) - 8;\n    av_log(c->fc, AV_LOG_TRACE, \"moof offset %\"PRIx64\"\\n\", c->fragment.moof_offset);\n    c->frag_index.current = update_frag_index(c, c->fragment.moof_offset);\n    return mov_read_default(c, pb, atom);\n}\n\nstatic void mov_metadata_creation_time(AVDictionary **metadata, int64_t time, void *logctx)\n{\n    if (time) {\n        if (time >= 2082844800)\n            time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        if ((int64_t)(time * 1000000ULL) / 1000000 != time) {\n            av_log(logctx, AV_LOG_DEBUG, \"creation_time is not representable\\n\");\n            return;\n        }\n\n        avpriv_dict_set_timestamp(metadata, \"creation_time\", time * 1000000);\n    }\n}\n\nstatic int mov_read_mdhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    char language[4] = {0};\n    unsigned lang;\n    int64_t creation_time;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->time_scale) {\n        av_log(c->fc, AV_LOG_ERROR, \"Multiple mdhd?\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n    avio_rb24(pb); /* flags */\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&st->metadata, creation_time, c->fc);\n\n    sc->time_scale = avio_rb32(pb);\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mdhd time scale %d, defaulting to 1\\n\", sc->time_scale);\n        sc->time_scale = 1;\n    }\n    st->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n\n    lang = avio_rb16(pb); /* language */\n    if (ff_mov_lang_to_iso639(lang, language))\n        av_dict_set(&st->metadata, \"language\", language, 0);\n    avio_rb16(pb); /* quality */\n\n    return 0;\n}\n\nstatic int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i;\n    int64_t creation_time;\n    int version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&c->fc->metadata, creation_time, c->fc);\n    c->time_scale = avio_rb32(pb); /* time scale */\n    if (c->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mvhd time scale %d, defaulting to 1\\n\", c->time_scale);\n        c->time_scale = 1;\n    }\n    av_log(c->fc, AV_LOG_TRACE, \"time scale = %i\\n\", c->time_scale);\n\n    c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n    // set the AVFormatContext duration because the duration of individual tracks\n    // may be inaccurate\n    if (!c->trex_data)\n        c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);\n    avio_rb32(pb); /* preferred scale */\n\n    avio_rb16(pb); /* preferred volume */\n\n    avio_skip(pb, 10); /* reserved */\n\n    /* movie display matrix, store it in main context and use it later on */\n    for (i = 0; i < 3; i++) {\n        c->movie_display_matrix[i][0] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][1] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][2] = avio_rb32(pb); //  2.30 fixed point\n    }\n\n    avio_rb32(pb); /* preview time */\n    avio_rb32(pb); /* preview duration */\n    avio_rb32(pb); /* poster time */\n    avio_rb32(pb); /* selection time */\n    avio_rb32(pb); /* selection duration */\n    avio_rb32(pb); /* current time */\n    avio_rb32(pb); /* next track ID */\n\n    return 0;\n}\n\nstatic void set_last_stream_little_endian(AVFormatContext *fc)\n{\n    AVStream *st;\n\n    if (fc->nb_streams < 1)\n        return;\n    st = fc->streams[fc->nb_streams-1];\n\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S16BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE;\n        break;\n    case AV_CODEC_ID_PCM_S24BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n        break;\n    case AV_CODEC_ID_PCM_S32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n        break;\n    case AV_CODEC_ID_PCM_F32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F32LE;\n        break;\n    case AV_CODEC_ID_PCM_F64BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F64LE;\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int mov_read_enda(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int little_endian = avio_rb16(pb) & 0xFF;\n    av_log(c->fc, AV_LOG_TRACE, \"enda %d\\n\", little_endian);\n    if (little_endian == 1)\n        set_last_stream_little_endian(c->fc);\n    return 0;\n}\n\nstatic int mov_read_pcmc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int format_flags;\n\n    if (atom.size < 6) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty pcmC box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_r8(pb);    // version\n    avio_rb24(pb);  // flags\n    format_flags = avio_r8(pb);\n    if (format_flags == 1) // indicates little-endian format. If not present, big-endian format is used\n        set_last_stream_little_endian(c->fc);\n\n    return 0;\n}\n\nstatic int mov_read_colr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t *icc_profile;\n    char color_parameter_type[5] = { 0 };\n    uint16_t color_primaries, color_trc, color_matrix;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    ret = ffio_read_size(pb, color_parameter_type, 4);\n    if (ret < 0)\n        return ret;\n    if (strncmp(color_parameter_type, \"nclx\", 4) &&\n        strncmp(color_parameter_type, \"nclc\", 4) &&\n        strncmp(color_parameter_type, \"prof\", 4)) {\n        av_log(c->fc, AV_LOG_WARNING, \"unsupported color_parameter_type %s\\n\",\n               color_parameter_type);\n        return 0;\n    }\n\n    if (!strncmp(color_parameter_type, \"prof\", 4)) {\n        icc_profile = av_stream_new_side_data(st, AV_PKT_DATA_ICC_PROFILE, atom.size - 4);\n        if (!icc_profile)\n            return AVERROR(ENOMEM);\n        ret = ffio_read_size(pb, icc_profile, atom.size - 4);\n        if (ret < 0)\n            return ret;\n    } else {\n        color_primaries = avio_rb16(pb);\n        color_trc = avio_rb16(pb);\n        color_matrix = avio_rb16(pb);\n\n        av_log(c->fc, AV_LOG_TRACE,\n               \"%s: pri %d trc %d matrix %d\",\n               color_parameter_type, color_primaries, color_trc, color_matrix);\n\n        if (!strncmp(color_parameter_type, \"nclx\", 4)) {\n            uint8_t color_range = avio_r8(pb) >> 7;\n            av_log(c->fc, AV_LOG_TRACE, \" full %\"PRIu8\"\", color_range);\n            if (color_range)\n                st->codecpar->color_range = AVCOL_RANGE_JPEG;\n            else\n                st->codecpar->color_range = AVCOL_RANGE_MPEG;\n        }\n\n        if (!av_color_primaries_name(color_primaries))\n            color_primaries = AVCOL_PRI_UNSPECIFIED;\n        if (!av_color_transfer_name(color_trc))\n            color_trc = AVCOL_TRC_UNSPECIFIED;\n        if (!av_color_space_name(color_matrix))\n            color_matrix = AVCOL_SPC_UNSPECIFIED;\n\n        st->codecpar->color_primaries = color_primaries;\n        st->codecpar->color_trc       = color_trc;\n        st->codecpar->color_space     = color_matrix;\n        av_log(c->fc, AV_LOG_TRACE, \"\\n\");\n    }\n    return 0;\n}\n\nstatic int mov_read_fiel(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned mov_field_order;\n    enum AVFieldOrder decoded_field_order = AV_FIELD_UNKNOWN;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if (atom.size < 2)\n        return AVERROR_INVALIDDATA;\n    mov_field_order = avio_rb16(pb);\n    if ((mov_field_order & 0xFF00) == 0x0100)\n        decoded_field_order = AV_FIELD_PROGRESSIVE;\n    else if ((mov_field_order & 0xFF00) == 0x0200) {\n        switch (mov_field_order & 0xFF) {\n        case 0x01: decoded_field_order = AV_FIELD_TT;\n                   break;\n        case 0x06: decoded_field_order = AV_FIELD_BB;\n                   break;\n        case 0x09: decoded_field_order = AV_FIELD_TB;\n                   break;\n        case 0x0E: decoded_field_order = AV_FIELD_BT;\n                   break;\n        }\n    }\n    if (decoded_field_order == AV_FIELD_UNKNOWN && mov_field_order) {\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown MOV field order 0x%04x\\n\", mov_field_order);\n    }\n    st->codecpar->field_order = decoded_field_order;\n\n    return 0;\n}\n\nstatic int mov_realloc_extradata(AVCodecParameters *par, MOVAtom atom)\n{\n    int err = 0;\n    uint64_t size = (uint64_t)par->extradata_size + atom.size + 8 + AV_INPUT_BUFFER_PADDING_SIZE;\n    if (size > INT_MAX || (uint64_t)atom.size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp(&par->extradata, size)) < 0) {\n        par->extradata_size = 0;\n        return err;\n    }\n    par->extradata_size = size - AV_INPUT_BUFFER_PADDING_SIZE;\n    return 0;\n}\n\n/* Read a whole atom into the extradata return the size of the atom read, possibly truncated if != atom.size */\nstatic int64_t mov_read_atom_into_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                                        AVCodecParameters *par, uint8_t *buf)\n{\n    int64_t result = atom.size;\n    int err;\n\n    AV_WB32(buf    , atom.size + 8);\n    AV_WL32(buf + 4, atom.type);\n    err = ffio_read_size(pb, buf + 8, atom.size);\n    if (err < 0) {\n        par->extradata_size -= atom.size;\n        return err;\n    } else if (err < atom.size) {\n        av_log(c->fc, AV_LOG_WARNING, \"truncated extradata\\n\");\n        par->extradata_size -= atom.size - err;\n        result = err;\n    }\n    memset(buf + 8 + err, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    return result;\n}\n\n/* FIXME modify QDM2/SVQ3/H.264 decoders to take full atom as extradata */\nstatic int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                              enum AVCodecID codec_id)\n{\n    AVStream *st;\n    uint64_t original_size;\n    int err;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (st->codecpar->codec_id != codec_id)\n        return 0; /* unexpected codec_id - don't mess with extradata */\n\n    original_size = st->codecpar->extradata_size;\n    err = mov_realloc_extradata(st->codecpar, atom);\n    if (err)\n        return err;\n\n    err =  mov_read_atom_into_extradata(c, pb, atom, st->codecpar,  st->codecpar->extradata + original_size);\n    if (err < 0)\n        return err;\n    return 0; // Note: this is the original behavior to ignore truncation.\n}\n\n/* wrapper functions for reading ALAC/AVS/MJPEG/MJPEG2000 extradata atoms only for those codecs */\nstatic int mov_read_alac(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_ALAC);\n}\n\nstatic int mov_read_avss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVS);\n}\n\nstatic int mov_read_jp2h(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_JPEG2000);\n}\n\nstatic int mov_read_dpxe(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_R10K);\n}\n\nstatic int mov_read_avid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVUI);\n    if (!ret)\n        ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_DNXHD);\n    return ret;\n}\n\nstatic int mov_read_targa_y216(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_TARGA_Y216);\n\n    if (!ret && c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->extradata_size >= 40) {\n            par->height = AV_RB16(&par->extradata[36]);\n            par->width  = AV_RB16(&par->extradata[38]);\n        }\n    }\n    return ret;\n}\n\nstatic int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (c->fc->nb_streams >= 1) {\n        AVStream *const  st = c->fc->streams[c->fc->nb_streams - 1];\n        FFStream *const sti = ffstream(st);\n        AVCodecParameters *par = st->codecpar;\n\n        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n            par->codec_id == AV_CODEC_ID_H264 &&\n            atom.size > 11) {\n            int cid;\n            avio_skip(pb, 10);\n            cid = avio_rb16(pb);\n            /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n            if (cid == 0xd4d || cid == 0xd4e)\n                par->width = 1440;\n            return 0;\n        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||\n                    par->codec_tag == MKTAG('A', 'V', 'j', '2') ||\n                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&\n                   atom.size >= 24) {\n            int num, den;\n            avio_skip(pb, 12);\n            num = avio_rb32(pb);\n            den = avio_rb32(pb);\n            if (num <= 0 || den <= 0)\n                return 0;\n            switch (avio_rb32(pb)) {\n            case 2:\n                if (den >= INT_MAX / 2)\n                    return 0;\n                den *= 2;\n            case 1:\n                sti->display_aspect_ratio = (AVRational){ num, den };\n            default:\n                return 0;\n            }\n        }\n    }\n\n    return mov_read_avid(c, pb, atom);\n}\n\nstatic int mov_read_aclr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = 0;\n    int length = 0;\n    uint64_t original_size;\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_id == AV_CODEC_ID_H264)\n            return 0;\n        if (atom.size == 16) {\n            original_size = par->extradata_size;\n            ret = mov_realloc_extradata(par, atom);\n            if (!ret) {\n                length =  mov_read_atom_into_extradata(c, pb, atom, par, par->extradata + original_size);\n                if (length == atom.size) {\n                    const uint8_t range_value = par->extradata[original_size + 19];\n                    switch (range_value) {\n                    case 1:\n                        par->color_range = AVCOL_RANGE_MPEG;\n                        break;\n                    case 2:\n                        par->color_range = AVCOL_RANGE_JPEG;\n                        break;\n                    default:\n                        av_log(c->fc, AV_LOG_WARNING, \"ignored unknown aclr value (%d)\\n\", range_value);\n                        break;\n                    }\n                    ff_dlog(c->fc, \"color_range: %d\\n\", par->color_range);\n                } else {\n                  /* For some reason the whole atom was not added to the extradata */\n                  av_log(c->fc, AV_LOG_ERROR, \"aclr not decoded - incomplete atom\\n\");\n                }\n            } else {\n                av_log(c->fc, AV_LOG_ERROR, \"aclr not decoded - unable to add atom to extradata\\n\");\n            }\n        } else {\n            av_log(c->fc, AV_LOG_WARNING, \"aclr not decoded - unexpected size %\"PRId64\"\\n\", atom.size);\n        }\n    }\n\n    return ret;\n}\n\nstatic int mov_read_svq3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_SVQ3);\n}\n\nstatic int mov_read_wave(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_QDM2 ||\n        st->codecpar->codec_id == AV_CODEC_ID_QDMC ||\n        st->codecpar->codec_id == AV_CODEC_ID_SPEEX) {\n        // pass all frma atom to codec, needed at least for QDMC and QDM2\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n        if (ret < 0)\n            return ret;\n    } else if (atom.size > 8) { /* to read frma, esds atoms */\n        if (st->codecpar->codec_id == AV_CODEC_ID_ALAC && atom.size >= 24) {\n            uint64_t buffer;\n            ret = ffio_ensure_seekback(pb, 8);\n            if (ret < 0)\n                return ret;\n            buffer = avio_rb64(pb);\n            atom.size -= 8;\n            if (  (buffer & 0xFFFFFFFF) == MKBETAG('f','r','m','a')\n                && buffer >> 32 <= atom.size\n                && buffer >> 32 >= 8) {\n                avio_skip(pb, -8);\n                atom.size += 8;\n            } else if (!st->codecpar->extradata_size) {\n#define ALAC_EXTRADATA_SIZE 36\n                st->codecpar->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);\n                if (!st->codecpar->extradata)\n                    return AVERROR(ENOMEM);\n                st->codecpar->extradata_size = ALAC_EXTRADATA_SIZE;\n                AV_WB32(st->codecpar->extradata    , ALAC_EXTRADATA_SIZE);\n                AV_WB32(st->codecpar->extradata + 4, MKTAG('a','l','a','c'));\n                AV_WB64(st->codecpar->extradata + 12, buffer);\n                avio_read(pb, st->codecpar->extradata + 20, 16);\n                avio_skip(pb, atom.size - 24);\n                return 0;\n            }\n        }\n        if ((ret = mov_read_default(c, pb, atom)) < 0)\n            return ret;\n    } else\n        avio_skip(pb, atom.size);\n    return 0;\n}\n\n/**\n * This function reads atom content and puts data in extradata without tag\n * nor size unlike mov_read_extradata.\n */\nstatic int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (atom.size >= 10) {\n        // Broken files created by legacy versions of libavformat will\n        // wrap a whole fiel atom inside of a glbl atom.\n        unsigned size = avio_rb32(pb);\n        unsigned type = avio_rl32(pb);\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        avio_seek(pb, -8, SEEK_CUR);\n        if (type == MKTAG('f','i','e','l') && size == atom.size)\n            return mov_read_default(c, pb, atom);\n    }\n    if (st->codecpar->extradata_size > 1 && st->codecpar->extradata) {\n        av_log(c->fc, AV_LOG_WARNING, \"ignoring multiple glbl\\n\");\n        return 0;\n    }\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n    if (ret < 0)\n        return ret;\n    if (atom.type == MKTAG('h','v','c','C') && st->codecpar->codec_tag == MKTAG('d','v','h','1'))\n        /* HEVC-based Dolby Vision derived from hvc1.\n           Happens to match with an identifier\n           previously utilized for DV. Thus, if we have\n           the hvcC extradata box available as specified,\n           set codec to HEVC */\n        st->codecpar->codec_id = AV_CODEC_ID_HEVC;\n\n    return 0;\n}\n\nstatic int mov_read_dvc1(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t profile_level;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size >= (1<<28) || atom.size < 7)\n        return AVERROR_INVALIDDATA;\n\n    profile_level = avio_r8(pb);\n    if ((profile_level & 0xf0) != 0xc0)\n        return 0;\n\n    avio_seek(pb, 6, SEEK_CUR);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 7);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n/**\n * An strf atom is a BITMAPINFOHEADER struct. This struct is 40 bytes itself,\n * but can have extradata appended at the end after the 40 bytes belonging\n * to the struct.\n */\nstatic int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    if (atom.size <= 40)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 40);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 40);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int mov_read_stco(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->trak_index < 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"STCO outside TRAK\\n\");\n        return 0;\n    }\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    if (!entries)\n        return 0;\n\n    if (sc->chunk_offsets) {\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicated STCO atom\\n\");\n        return 0;\n    }\n    av_free(sc->chunk_offsets);\n    sc->chunk_count = 0;\n    sc->chunk_offsets = av_malloc_array(entries, sizeof(*sc->chunk_offsets));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->chunk_count = entries;\n\n    if      (atom.type == MKTAG('s','t','c','o'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb32(pb);\n    else if (atom.type == MKTAG('c','o','6','4'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb64(pb);\n    else\n        return AVERROR_INVALIDDATA;\n\n    sc->chunk_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STCO atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_codec_id(AVStream *st, uint32_t format)\n{\n    int id = ff_codec_get_id(ff_codec_movaudio_tags, format);\n\n    if (id <= 0 &&\n        ((format & 0xFFFF) == 'm' + ('s' << 8) ||\n         (format & 0xFFFF) == 'T' + ('S' << 8)))\n        id = ff_codec_get_id(ff_codec_wav_tags, av_bswap32(format) & 0xFFFF);\n\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_VIDEO && id > 0) {\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    } else if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO &&\n               /* skip old ASF MPEG-4 tag */\n               format && format != MKTAG('m','p','4','s')) {\n        id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n        if (id <= 0)\n            id = ff_codec_get_id(ff_codec_bmp_tags, format);\n        if (id > 0)\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA ||\n                    (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n                    st->codecpar->codec_id == AV_CODEC_ID_NONE)) {\n            id = ff_codec_get_id(ff_codec_movsubtitle_tags, format);\n            if (id > 0)\n                st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n            else\n                id = ff_codec_get_id(ff_codec_movdata_tags, format);\n        }\n    }\n\n    st->codecpar->codec_tag = format;\n\n    return id;\n}\n\nstatic void mov_parse_stsd_video(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    uint8_t codec_name[32] = { 0 };\n    int64_t stsd_start;\n    unsigned int len;\n    uint32_t id = 0;\n\n    /* The first 16 bytes of the video sample description are already\n     * read in ff_mov_read_stsd_entries() */\n    stsd_start = avio_tell(pb) - 16;\n\n    avio_rb16(pb); /* version */\n    avio_rb16(pb); /* revision level */\n    id = avio_rl32(pb); /* vendor */\n    av_dict_set(&st->metadata, \"vendor_id\", av_fourcc2str(id), 0);\n    avio_rb32(pb); /* temporal quality */\n    avio_rb32(pb); /* spatial quality */\n\n    st->codecpar->width  = avio_rb16(pb); /* width */\n    st->codecpar->height = avio_rb16(pb); /* height */\n\n    avio_rb32(pb); /* horiz resolution */\n    avio_rb32(pb); /* vert resolution */\n    avio_rb32(pb); /* data size, always 0 */\n    avio_rb16(pb); /* frames per samples */\n\n    len = avio_r8(pb); /* codec name, pascal string */\n    if (len > 31)\n        len = 31;\n    mov_read_mac_string(c, pb, len, codec_name, sizeof(codec_name));\n    if (len < 31)\n        avio_skip(pb, 31 - len);\n\n    if (codec_name[0])\n        av_dict_set(&st->metadata, \"encoder\", codec_name, 0);\n\n    /* codec_tag YV12 triggers an UV swap in rawdec.c */\n    if (!strncmp(codec_name, \"Planar Y'CbCr 8-bit 4:2:0\", 25)) {\n        st->codecpar->codec_tag = MKTAG('I', '4', '2', '0');\n        st->codecpar->width &= ~1;\n        st->codecpar->height &= ~1;\n    }\n    /* Flash Media Server uses tag H.263 with Sorenson Spark */\n    if (st->codecpar->codec_tag == MKTAG('H','2','6','3') &&\n        !strncmp(codec_name, \"Sorenson H263\", 13))\n        st->codecpar->codec_id = AV_CODEC_ID_FLV1;\n\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* depth */\n\n    avio_seek(pb, stsd_start, SEEK_SET);\n\n    if (ff_get_qtpalette(st->codecpar->codec_id, pb, sc->palette)) {\n        st->codecpar->bits_per_coded_sample &= 0x1F;\n        sc->has_palette = 1;\n    }\n}\n\nstatic void mov_parse_stsd_audio(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    int bits_per_sample, flags;\n    uint16_t version = avio_rb16(pb);\n    uint32_t id = 0;\n    AVDictionaryEntry *compatible_brands = av_dict_get(c->fc->metadata, \"compatible_brands\", NULL, AV_DICT_MATCH_CASE);\n    int channel_count;\n\n    avio_rb16(pb); /* revision level */\n    id = avio_rl32(pb); /* vendor */\n    av_dict_set(&st->metadata, \"vendor_id\", av_fourcc2str(id), 0);\n\n    channel_count = avio_rb16(pb);\n\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* sample size */\n    av_log(c->fc, AV_LOG_TRACE, \"audio channels %d\\n\", channel_count);\n\n    sc->audio_cid = avio_rb16(pb);\n    avio_rb16(pb); /* packet size = 0 */\n\n    st->codecpar->sample_rate = ((avio_rb32(pb) >> 16));\n\n    // Read QT version 1 fields. In version 0 these do not exist.\n    av_log(c->fc, AV_LOG_TRACE, \"version =%d, isom =%d\\n\", version, c->isom);\n    if (!c->isom ||\n        (compatible_brands && strstr(compatible_brands->value, \"qt  \")) ||\n        (sc->stsd_version == 0 && version > 0)) {\n        if (version == 1) {\n            sc->samples_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per packet */\n            sc->bytes_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per sample */\n        } else if (version == 2) {\n            avio_rb32(pb); /* sizeof struct only */\n            st->codecpar->sample_rate = av_int2double(avio_rb64(pb));\n            channel_count = avio_rb32(pb);\n            st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n            st->codecpar->ch_layout.nb_channels = channel_count;\n            avio_rb32(pb); /* always 0x7F000000 */\n            st->codecpar->bits_per_coded_sample = avio_rb32(pb);\n\n            flags = avio_rb32(pb); /* lpcm format specific flag */\n            sc->bytes_per_frame   = avio_rb32(pb);\n            sc->samples_per_frame = avio_rb32(pb);\n            if (st->codecpar->codec_tag == MKTAG('l','p','c','m'))\n                st->codecpar->codec_id =\n                    ff_mov_get_lpcm_codec_id(st->codecpar->bits_per_coded_sample,\n                                             flags);\n        }\n        if (version == 0 || (version == 1 && sc->audio_cid != -2)) {\n            /* can't correctly handle variable sized packet as audio unit */\n            switch (st->codecpar->codec_id) {\n            case AV_CODEC_ID_MP2:\n            case AV_CODEC_ID_MP3:\n                ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n                break;\n            }\n        }\n    }\n\n    if (sc->format == 0) {\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('r','a','w',' '));\n        else if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('t','w','o','s'));\n    }\n\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_U8:\n        if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        break;\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S16BE:\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S8;\n        else if (st->codecpar->bits_per_coded_sample == 24)\n            st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S24BE : AV_CODEC_ID_PCM_S24LE;\n        else if (st->codecpar->bits_per_coded_sample == 32)\n             st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S32BE : AV_CODEC_ID_PCM_S32LE;\n        break;\n    /* set values for old format before stsd version 1 appeared */\n    case AV_CODEC_ID_MACE3:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 2 * st->codecpar->ch_layout.nb_channels;\n        break;\n    case AV_CODEC_ID_MACE6:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 1 * st->codecpar->ch_layout.nb_channels;\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n        sc->samples_per_frame = 64;\n        sc->bytes_per_frame   = 34 * st->codecpar->ch_layout.nb_channels;\n        break;\n    case AV_CODEC_ID_GSM:\n        sc->samples_per_frame = 160;\n        sc->bytes_per_frame   = 33;\n        break;\n    default:\n        break;\n    }\n\n    bits_per_sample = av_get_bits_per_sample(st->codecpar->codec_id);\n    if (bits_per_sample && (bits_per_sample >> 3) * (uint64_t)st->codecpar->ch_layout.nb_channels <= INT_MAX) {\n        st->codecpar->bits_per_coded_sample = bits_per_sample;\n        sc->sample_size = (bits_per_sample >> 3) * st->codecpar->ch_layout.nb_channels;\n    }\n}\n\nstatic void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    // ttxt stsd contains display flags, justification, background\n    // color, fonts, and default styles, so fake an atom to read it\n    MOVAtom fake_atom = { .size = size };\n    // mp4s contains a regular esds atom\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}\n\nstatic uint32_t yuv_to_rgba(uint32_t ycbcr)\n{\n    uint8_t r, g, b;\n    int y, cb, cr;\n\n    y  = (ycbcr >> 16) & 0xFF;\n    cr = (ycbcr >> 8)  & 0xFF;\n    cb =  ycbcr        & 0xFF;\n\n    b = av_clip_uint8((1164 * (y - 16)                     + 2018 * (cb - 128)) / 1000);\n    g = av_clip_uint8((1164 * (y - 16) -  813 * (cr - 128) -  391 * (cb - 128)) / 1000);\n    r = av_clip_uint8((1164 * (y - 16) + 1596 * (cr - 128)                    ) / 1000);\n\n    return (r << 16) | (g << 8) | b;\n}\n\nstatic int mov_rewrite_dvd_sub_extradata(AVStream *st)\n{\n    char buf[256] = {0};\n    uint8_t *src = st->codecpar->extradata;\n    int i, ret;\n\n    if (st->codecpar->extradata_size != 64)\n        return 0;\n\n    if (st->codecpar->width > 0 &&  st->codecpar->height > 0)\n        snprintf(buf, sizeof(buf), \"size: %dx%d\\n\",\n                 st->codecpar->width, st->codecpar->height);\n    av_strlcat(buf, \"palette: \", sizeof(buf));\n\n    for (i = 0; i < 16; i++) {\n        uint32_t yuv = AV_RB32(src + i * 4);\n        uint32_t rgba = yuv_to_rgba(yuv);\n\n        av_strlcatf(buf, sizeof(buf), \"%06\"PRIx32\"%s\", rgba, i != 15 ? \", \" : \"\");\n    }\n\n    if (av_strlcat(buf, \"\\n\", sizeof(buf)) >= sizeof(buf))\n        return 0;\n\n    ret = ff_alloc_extradata(st->codecpar, strlen(buf));\n    if (ret < 0)\n        return ret;\n    memcpy(st->codecpar->extradata, buf, st->codecpar->extradata_size);\n\n    return 0;\n}\n\nstatic int mov_parse_stsd_data(MOVContext *c, AVIOContext *pb,\n                                AVStream *st, MOVStreamContext *sc,\n                                int64_t size)\n{\n    int ret;\n\n    if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {\n        if ((int)size != size)\n            return AVERROR(ENOMEM);\n\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n        if (ret < 0)\n            return ret;\n        if (size > 16) {\n            MOVStreamContext *tmcd_ctx = st->priv_data;\n            int val;\n            val = AV_RB32(st->codecpar->extradata + 4);\n            tmcd_ctx->tmcd_flags = val;\n            st->avg_frame_rate.num = AV_RB32(st->codecpar->extradata + 8); /* timescale */\n            st->avg_frame_rate.den = AV_RB32(st->codecpar->extradata + 12); /* frameDuration */\n            tmcd_ctx->tmcd_nb_frames = st->codecpar->extradata[16]; /* number of frames */\n            if (size > 30) {\n                uint32_t len = AV_RB32(st->codecpar->extradata + 18); /* name atom length */\n                uint32_t format = AV_RB32(st->codecpar->extradata + 22);\n                if (format == AV_RB32(\"name\") && (int64_t)size >= (int64_t)len + 18) {\n                    uint16_t str_size = AV_RB16(st->codecpar->extradata + 26); /* string length */\n                    if (str_size > 0 && size >= (int)str_size + 30 &&\n                        st->codecpar->extradata[30] /* Don't add empty string */) {\n                        char *reel_name = av_malloc(str_size + 1);\n                        if (!reel_name)\n                            return AVERROR(ENOMEM);\n                        memcpy(reel_name, st->codecpar->extradata + 30, str_size);\n                        reel_name[str_size] = 0; /* Add null terminator */\n                        av_dict_set(&st->metadata, \"reel_name\", reel_name,\n                                    AV_DICT_DONT_STRDUP_VAL);\n                    }\n                }\n            }\n        }\n    } else {\n        /* other codec type, just skip (rtp, mp4s ...) */\n        avio_skip(pb, size);\n    }\n    return 0;\n}\n\nstatic int mov_finalize_stsd_codec(MOVContext *c, AVIOContext *pb,\n                                   AVStream *st, MOVStreamContext *sc)\n{\n    FFStream *const sti = ffstream(st);\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n        !st->codecpar->sample_rate && sc->time_scale > 1)\n        st->codecpar->sample_rate = sc->time_scale;\n\n    /* special codec parameters handling */\n    switch (st->codecpar->codec_id) {\n#if CONFIG_DV_DEMUXER\n    case AV_CODEC_ID_DVAUDIO:\n        c->dv_fctx = avformat_alloc_context();\n        if (!c->dv_fctx) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context alloc error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        c->dv_demux = avpriv_dv_init_demux(c->dv_fctx);\n        if (!c->dv_demux) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context init error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        sc->dv_audio_container = 1;\n        st->codecpar->codec_id    = AV_CODEC_ID_PCM_S16LE;\n        break;\n#endif\n    /* no ifdef since parameters are always those */\n    case AV_CODEC_ID_QCELP:\n        av_channel_layout_uninit(&st->codecpar->ch_layout);\n        st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;\n        // force sample rate for qcelp when not stored in mov\n        if (st->codecpar->codec_tag != MKTAG('Q','c','l','p'))\n            st->codecpar->sample_rate = 8000;\n        // FIXME: Why is the following needed for some files?\n        sc->samples_per_frame = 160;\n        if (!sc->bytes_per_frame)\n            sc->bytes_per_frame = 35;\n        break;\n    case AV_CODEC_ID_AMR_NB:\n        av_channel_layout_uninit(&st->codecpar->ch_layout);\n        st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;\n        /* force sample rate for amr, stsd in 3gp does not store sample rate */\n        st->codecpar->sample_rate = 8000;\n        break;\n    case AV_CODEC_ID_AMR_WB:\n        av_channel_layout_uninit(&st->codecpar->ch_layout);\n        st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;\n        st->codecpar->sample_rate = 16000;\n        break;\n    case AV_CODEC_ID_MP2:\n    case AV_CODEC_ID_MP3:\n        /* force type after stsd for m1a hdlr */\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        break;\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_ADPCM_MS:\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n    case AV_CODEC_ID_ILBC:\n    case AV_CODEC_ID_MACE3:\n    case AV_CODEC_ID_MACE6:\n    case AV_CODEC_ID_QDM2:\n        st->codecpar->block_align = sc->bytes_per_frame;\n        break;\n    case AV_CODEC_ID_ALAC:\n        if (st->codecpar->extradata_size == 36) {\n            int channel_count = AV_RB8(st->codecpar->extradata + 21);\n            if (st->codecpar->ch_layout.nb_channels != channel_count) {\n                av_channel_layout_uninit(&st->codecpar->ch_layout);\n                st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n                st->codecpar->ch_layout.nb_channels = channel_count;\n            }\n            st->codecpar->sample_rate = AV_RB32(st->codecpar->extradata + 32);\n        }\n        break;\n    case AV_CODEC_ID_AC3:\n    case AV_CODEC_ID_EAC3:\n    case AV_CODEC_ID_MPEG1VIDEO:\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_VP8:\n    case AV_CODEC_ID_VP9:\n        sti->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    case AV_CODEC_ID_AV1:\n        /* field_order detection of H264 requires parsing */\n    case AV_CODEC_ID_H264:\n        sti->need_parsing = AVSTREAM_PARSE_HEADERS;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic int mov_skip_multiple_stsd(MOVContext *c, AVIOContext *pb,\n                                  int codec_tag, int format,\n                                  int64_t size)\n{\n    if (codec_tag &&\n         (codec_tag != format &&\n          // AVID 1:1 samples with differing data format and codec tag exist\n          (codec_tag != AV_RL32(\"AV1x\") || format != AV_RL32(\"AVup\")) &&\n          // prores is allowed to have differing data format and codec tag\n          codec_tag != AV_RL32(\"apcn\") && codec_tag != AV_RL32(\"apch\") &&\n          // so is dv (sigh)\n          codec_tag != AV_RL32(\"dvpp\") && codec_tag != AV_RL32(\"dvcp\") &&\n          (c->fc->video_codec_id ? ff_codec_get_id(ff_codec_movvideo_tags, format) != c->fc->video_codec_id\n                                 : codec_tag != MKTAG('j','p','e','g')))) {\n        /* Multiple fourcc, we skip JPEG. This is not correct, we should\n         * export it as a separate AVStream but this needs a few changes\n         * in the MOV demuxer, patch welcome. */\n\n        av_log(c->fc, AV_LOG_WARNING, \"multiple fourcc not supported\\n\");\n        avio_skip(pb, size);\n        return 1;\n    }\n\n    return 0;\n}\n\nint ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int pseudo_stream_id;\n\n    av_assert0 (c->fc->nb_streams >= 1);\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (pseudo_stream_id = 0;\n         pseudo_stream_id < entries && !pb->eof_reached;\n         pseudo_stream_id++) {\n        //Parsing Sample description table\n        enum AVCodecID id;\n        int ret, dref_id = 1;\n        MOVAtom a = { AV_RL32(\"stsd\") };\n        int64_t start_pos = avio_tell(pb);\n        int64_t size    = avio_rb32(pb); /* size */\n        uint32_t format = avio_rl32(pb); /* data format */\n\n        if (size >= 16) {\n            avio_rb32(pb); /* reserved */\n            avio_rb16(pb); /* reserved */\n            dref_id = avio_rb16(pb);\n        } else if (size <= 7) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"invalid size %\"PRId64\" in stsd\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (mov_skip_multiple_stsd(c, pb, st->codecpar->codec_tag, format,\n                                   size - (avio_tell(pb) - start_pos))) {\n            sc->stsd_count++;\n            continue;\n        }\n\n        sc->pseudo_stream_id = st->codecpar->codec_tag ? -1 : pseudo_stream_id;\n        sc->dref_id= dref_id;\n        sc->format = format;\n\n        id = mov_codec_id(st, format);\n\n        av_log(c->fc, AV_LOG_TRACE,\n               \"size=%\"PRId64\" 4CC=%s codec_type=%d\\n\", size,\n               av_fourcc2str(format), st->codecpar->codec_type);\n\n        st->codecpar->codec_id = id;\n        if (st->codecpar->codec_type==AVMEDIA_TYPE_VIDEO) {\n            mov_parse_stsd_video(c, pb, st, sc);\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_AUDIO) {\n            mov_parse_stsd_audio(c, pb, st, sc);\n            if (st->codecpar->sample_rate < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n                return AVERROR_INVALIDDATA;\n            }\n            if (st->codecpar->ch_layout.nb_channels < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid channels %d\\n\", st->codecpar->ch_layout.nb_channels);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_SUBTITLE){\n            mov_parse_stsd_subtitle(c, pb, st, sc,\n                                    size - (avio_tell(pb) - start_pos));\n        } else {\n            ret = mov_parse_stsd_data(c, pb, st, sc,\n                                      size - (avio_tell(pb) - start_pos));\n            if (ret < 0)\n                return ret;\n        }\n        /* this will read extra atoms at the end (wave, alac, damr, avcC, hvcC, SMI ...) */\n        a.size = size - (avio_tell(pb) - start_pos);\n        if (a.size > 8) {\n            if ((ret = mov_read_default(c, pb, a)) < 0)\n                return ret;\n        } else if (a.size > 0)\n            avio_skip(pb, a.size);\n\n        if (sc->extradata && st->codecpar->extradata) {\n            int extra_size = st->codecpar->extradata_size;\n\n            /* Move the current stream extradata to the stream context one. */\n            sc->extradata_size[pseudo_stream_id] = extra_size;\n            sc->extradata[pseudo_stream_id] = st->codecpar->extradata;\n            st->codecpar->extradata      = NULL;\n            st->codecpar->extradata_size = 0;\n        }\n        sc->stsd_count++;\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STSD atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    sc->stsd_version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    /* Each entry contains a size (4 bytes) and format (4 bytes). */\n    if (entries <= 0 || entries > atom.size / 8 || entries > 1024) {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid STSD entries %d\\n\", entries);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->extradata) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Duplicate stsd found in this track.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* Prepare space for hosting multiple extradata. */\n    sc->extradata = av_calloc(entries, sizeof(*sc->extradata));\n    if (!sc->extradata)\n        return AVERROR(ENOMEM);\n\n    sc->extradata_size = av_calloc(entries, sizeof(*sc->extradata_size));\n    if (!sc->extradata_size) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = ff_mov_read_stsd_entries(c, pb, entries);\n    if (ret < 0)\n        goto fail;\n\n    /* Restore back the primary extradata. */\n    av_freep(&st->codecpar->extradata);\n    st->codecpar->extradata_size = sc->extradata_size[0];\n    if (sc->extradata_size[0]) {\n        st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!st->codecpar->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);\n    }\n\n    return mov_finalize_stsd_codec(c, pb, st, sc);\nfail:\n    if (sc->extradata) {\n        int j;\n        for (j = 0; j < sc->stsd_count; j++)\n            av_freep(&sc->extradata[j]);\n    }\n\n    av_freep(&sc->extradata);\n    av_freep(&sc->extradata_size);\n    return ret;\n}\n\nstatic int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n    if ((uint64_t)entries * 12 + 4 > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stsc.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (sc->stsc_data) {\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicated STSC atom\\n\");\n        return 0;\n    }\n    av_free(sc->stsc_data);\n    sc->stsc_count = 0;\n    sc->stsc_data = av_malloc_array(entries, sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stsc_data[i].first = avio_rb32(pb);\n        sc->stsc_data[i].count = avio_rb32(pb);\n        sc->stsc_data[i].id = avio_rb32(pb);\n    }\n\n    sc->stsc_count = i;\n    for (i = sc->stsc_count - 1; i < UINT_MAX; i--) {\n        int64_t first_min = i + 1;\n        if ((i+1 < sc->stsc_count && sc->stsc_data[i].first >= sc->stsc_data[i+1].first) ||\n            (i > 0 && sc->stsc_data[i].first <= sc->stsc_data[i-1].first) ||\n            sc->stsc_data[i].first < first_min ||\n            sc->stsc_data[i].count < 1 ||\n            sc->stsc_data[i].id < 1) {\n            av_log(c->fc, AV_LOG_WARNING, \"STSC entry %d is invalid (first=%d count=%d id=%d)\\n\", i, sc->stsc_data[i].first, sc->stsc_data[i].count, sc->stsc_data[i].id);\n            if (i+1 >= sc->stsc_count) {\n                if (sc->stsc_data[i].count == 0 && i > 0) {\n                    sc->stsc_count --;\n                    continue;\n                }\n                sc->stsc_data[i].first = FFMAX(sc->stsc_data[i].first, first_min);\n                if (i > 0 && sc->stsc_data[i].first <= sc->stsc_data[i-1].first)\n                    sc->stsc_data[i].first = FFMIN(sc->stsc_data[i-1].first + 1LL, INT_MAX);\n                sc->stsc_data[i].count = FFMAX(sc->stsc_data[i].count, 1);\n                sc->stsc_data[i].id    = FFMAX(sc->stsc_data[i].id, 1);\n                continue;\n            }\n            av_assert0(sc->stsc_data[i+1].first >= 2);\n            // We replace this entry by the next valid\n            sc->stsc_data[i].first = sc->stsc_data[i+1].first - 1;\n            sc->stsc_data[i].count = sc->stsc_data[i+1].count;\n            sc->stsc_data[i].id    = sc->stsc_data[i+1].id;\n        }\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STSC atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic inline int mov_stsc_index_valid(unsigned int index, unsigned int count)\n{\n    return index < count - 1;\n}\n\n/* Compute the samples value for the stsc entry at the given index. */\nstatic inline int64_t mov_get_stsc_samples(MOVStreamContext *sc, unsigned int index)\n{\n    int chunk_count;\n\n    if (mov_stsc_index_valid(index, sc->stsc_count))\n        chunk_count = sc->stsc_data[index + 1].first - sc->stsc_data[index].first;\n    else {\n        // Validation for stsc / stco  happens earlier in mov_read_stsc + mov_read_trak.\n        av_assert0(sc->stsc_data[index].first <= sc->chunk_count);\n        chunk_count = sc->chunk_count - (sc->stsc_data[index].first - 1);\n    }\n\n    return sc->stsc_data[index].count * (int64_t)chunk_count;\n}\n\nstatic int mov_read_stps(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n\n    entries = avio_rb32(pb);\n    if (sc->stps_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STPS atom\\n\");\n    av_free(sc->stps_data);\n    sc->stps_count = 0;\n    sc->stps_data = av_malloc_array(entries, sizeof(*sc->stps_data));\n    if (!sc->stps_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stps_data[i] = avio_rb32(pb);\n    }\n\n    sc->stps_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STPS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    FFStream *sti;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sti = ffstream(st);\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"keyframe_count = %u\\n\", entries);\n\n    if (!entries) {\n        sc->keyframe_absent = 1;\n        if (!sti->need_parsing && st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n            sti->need_parsing = AVSTREAM_PARSE_HEADERS;\n        return 0;\n    }\n    if (sc->keyframes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSS atom\\n\");\n    if (entries >= UINT_MAX / sizeof(int))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->keyframes);\n    sc->keyframe_count = 0;\n    sc->keyframes = av_malloc_array(entries, sizeof(*sc->keyframes));\n    if (!sc->keyframes)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->keyframes[i] = avio_rb32(pb);\n    }\n\n    sc->keyframe_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STSS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, sample_size, field_size, num_bytes;\n    GetBitContext gb;\n    unsigned char* buf;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (atom.type == MKTAG('s','t','s','z')) {\n        sample_size = avio_rb32(pb);\n        if (!sc->sample_size) /* do not overwrite value computed in stsd */\n            sc->sample_size = sample_size;\n        sc->stsz_sample_size = sample_size;\n        field_size = 32;\n    } else {\n        sample_size = 0;\n        avio_rb24(pb); /* reserved */\n        field_size = avio_r8(pb);\n    }\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"sample_size = %u sample_count = %u\\n\", sc->sample_size, entries);\n\n    sc->sample_count = entries;\n    if (sample_size)\n        return 0;\n\n    if (field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample field size %u\\n\", field_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!entries)\n        return 0;\n    if (entries >= (INT_MAX - 4 - 8 * AV_INPUT_BUFFER_PADDING_SIZE) / field_size)\n        return AVERROR_INVALIDDATA;\n    if (sc->sample_sizes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSZ atom\\n\");\n    av_free(sc->sample_sizes);\n    sc->sample_count = 0;\n    sc->sample_sizes = av_malloc_array(entries, sizeof(*sc->sample_sizes));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n\n    num_bytes = (entries*field_size+4)>>3;\n\n    buf = av_malloc(num_bytes+AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        av_freep(&sc->sample_sizes);\n        return AVERROR(ENOMEM);\n    }\n\n    ret = ffio_read_size(pb, buf, num_bytes);\n    if (ret < 0) {\n        av_freep(&sc->sample_sizes);\n        av_free(buf);\n        av_log(c->fc, AV_LOG_WARNING, \"STSZ atom truncated\\n\");\n        return 0;\n    }\n\n    init_get_bits(&gb, buf, 8*num_bytes);\n\n    for (i = 0; i < entries; i++) {\n        sc->sample_sizes[i] = get_bits_long(&gb, field_size);\n        if (sc->sample_sizes[i] < 0) {\n            av_free(buf);\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid sample size %d\\n\", sc->sample_sizes[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        sc->data_size += sc->sample_sizes[i];\n    }\n\n    sc->sample_count = i;\n\n    av_free(buf);\n\n    return 0;\n}\n\nstatic int mov_read_stts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, alloc_size = 0;\n    int64_t duration = 0;\n    int64_t total_sample_count = 0;\n    int64_t current_dts = 0;\n    int64_t corrected_dts = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stts.entries = %u\\n\",\n            c->fc->nb_streams-1, entries);\n\n    if (sc->stts_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STTS atom\\n\");\n    av_freep(&sc->stts_data);\n    sc->stts_count = 0;\n    if (entries >= INT_MAX / sizeof(*sc->stts_data))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned int sample_duration;\n        unsigned int sample_count;\n        unsigned int min_entries = FFMIN(FFMAX(i + 1, 1024 * 1024), entries);\n        MOVStts *stts_data = av_fast_realloc(sc->stts_data, &alloc_size,\n                                             min_entries * sizeof(*sc->stts_data));\n        if (!stts_data) {\n            av_freep(&sc->stts_data);\n            sc->stts_count = 0;\n            return AVERROR(ENOMEM);\n        }\n        sc->stts_count = min_entries;\n        sc->stts_data = stts_data;\n\n        sample_count    = avio_rb32(pb);\n        sample_duration = avio_rb32(pb);\n\n        sc->stts_data[i].count= sample_count;\n        sc->stts_data[i].duration= sample_duration;\n\n        av_log(c->fc, AV_LOG_TRACE, \"sample_count=%u, sample_duration=%u\\n\",\n                sample_count, sample_duration);\n\n        /* STTS sample offsets are uint32 but some files store it as int32\n         * with negative values used to correct DTS delays.\n           There may be abnormally large values as well. */\n        if (sample_duration > c->max_stts_delta) {\n            // assume high delta is a correction if negative when cast as int32\n            int32_t delta_magnitude = (int32_t)sample_duration;\n            av_log(c->fc, AV_LOG_WARNING, \"Too large sample offset %u in stts entry %u with count %u in st:%d. Clipping to 1.\\n\",\n                   sample_duration, i, sample_count, st->index);\n            sc->stts_data[i].duration = 1;\n            corrected_dts += (delta_magnitude < 0 ? (int64_t)delta_magnitude : 1) * sample_count;\n        } else {\n            corrected_dts += sample_duration * sample_count;\n        }\n\n        current_dts += sc->stts_data[i].duration * sample_count;\n\n        if (current_dts > corrected_dts) {\n            int64_t drift = (current_dts - corrected_dts)/FFMAX(sample_count, 1);\n            uint32_t correction = (sc->stts_data[i].duration > drift) ? drift : sc->stts_data[i].duration - 1;\n            current_dts -= correction * sample_count;\n            sc->stts_data[i].duration -= correction;\n        }\n\n        duration+=(int64_t)sc->stts_data[i].duration*(uint64_t)sc->stts_data[i].count;\n        total_sample_count+=sc->stts_data[i].count;\n    }\n\n    sc->stts_count = i;\n\n    if (duration > 0 &&\n        duration <= INT64_MAX - sc->duration_for_fps &&\n        total_sample_count <= INT_MAX - sc->nb_frames_for_fps) {\n        sc->duration_for_fps  += duration;\n        sc->nb_frames_for_fps += total_sample_count;\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STTS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    st->nb_frames= total_sample_count;\n    if (duration)\n        st->duration= FFMIN(st->duration, duration);\n\n    // All samples have zero duration. They have higher chance be chose by\n    // mov_find_next_sample, which leads to seek again and again.\n    //\n    // It's AVERROR_INVALIDDATA actually, but such files exist in the wild.\n    // So only mark data stream as discarded for safety.\n    if (!duration && sc->stts_count &&\n            st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"All samples in data stream index:id [%d:%d] have zero \"\n               \"duration, stream set to be discarded by default. Override \"\n               \"using AVStream->discard or -discard for ffmpeg command.\\n\",\n               st->index, st->id);\n        st->discard = AVDISCARD_ALL;\n    }\n    sc->track_end = duration;\n    return 0;\n}\n\nstatic int mov_read_sdtp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = atom.size - 4;\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].sdtp.entries = %\" PRId64 \"\\n\",\n           c->fc->nb_streams - 1, entries);\n\n    if (sc->sdtp_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated SDTP atom\\n\");\n    av_freep(&sc->sdtp_data);\n    sc->sdtp_count = 0;\n\n    sc->sdtp_data = av_malloc(entries);\n    if (!sc->sdtp_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++)\n        sc->sdtp_data[i] = avio_r8(pb);\n    sc->sdtp_count = i;\n\n    return 0;\n}\n\nstatic void mov_update_dts_shift(MOVStreamContext *sc, int duration, void *logctx)\n{\n    if (duration < 0) {\n        if (duration == INT_MIN) {\n            av_log(logctx, AV_LOG_WARNING, \"mov_update_dts_shift(): dts_shift set to %d\\n\", INT_MAX);\n            duration++;\n        }\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n    }\n}\n\nstatic int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, ctts_count = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].ctts.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->ctts_data);\n    sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int count    = avio_rb32(pb);\n        int duration = avio_rb32(pb);\n\n        if (count <= 0) {\n            av_log(c->fc, AV_LOG_TRACE,\n                   \"ignoring CTTS entry with count=%d duration=%d\\n\",\n                   count, duration);\n            continue;\n        }\n\n        add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size,\n                       count, duration);\n\n        av_log(c->fc, AV_LOG_TRACE, \"count=%d, duration=%d\\n\",\n                count, duration);\n\n        if (FFNABS(duration) < -(1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (i+2<entries)\n            mov_update_dts_shift(sc, duration, c->fc);\n    }\n\n    sc->ctts_count = ctts_count;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted CTTS atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    av_log(c->fc, AV_LOG_TRACE, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}\n\nstatic int mov_read_sgpd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    uint8_t version;\n    uint32_t grouping_type;\n    uint32_t default_length;\n    av_unused uint32_t default_group_description_index;\n    uint32_t entry_count;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    grouping_type = avio_rl32(pb);\n\n    /*\n     * This function only supports \"sync\" boxes, but the code is able to parse\n     * other boxes (such as \"tscl\", \"tsas\" and \"stsa\")\n     */\n    if (grouping_type != MKTAG('s','y','n','c'))\n        return 0;\n\n    default_length = version >= 1 ? avio_rb32(pb) : 0;\n    default_group_description_index = version >= 2 ? avio_rb32(pb) : 0;\n    entry_count = avio_rb32(pb);\n\n    av_freep(&sc->sgpd_sync);\n    sc->sgpd_sync_count = entry_count;\n    sc->sgpd_sync = av_calloc(entry_count, sizeof(*sc->sgpd_sync));\n    if (!sc->sgpd_sync)\n        return AVERROR(ENOMEM);\n\n    for (uint32_t i = 0; i < entry_count && !pb->eof_reached; i++) {\n        uint32_t description_length = default_length;\n        if (version >= 1 && default_length == 0)\n            description_length = avio_rb32(pb);\n        if (grouping_type == MKTAG('s','y','n','c')) {\n            const uint8_t nal_unit_type = avio_r8(pb) & 0x3f;\n            sc->sgpd_sync[i] = nal_unit_type;\n            description_length -= 1;\n        }\n        avio_skip(pb, description_length);\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted SGPD atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_sbgp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    uint8_t version;\n    uint32_t grouping_type;\n    MOVSbgp *table, **tablep;\n    int *table_count;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    grouping_type = avio_rl32(pb);\n\n    if (grouping_type == MKTAG('r','a','p',' ')) {\n        tablep = &sc->rap_group;\n        table_count = &sc->rap_group_count;\n    } else if (grouping_type == MKTAG('s','y','n','c')) {\n        tablep = &sc->sync_group;\n        table_count = &sc->sync_group_count;\n    } else {\n        return 0;\n    }\n\n    if (version == 1)\n        avio_rb32(pb); /* grouping_type_parameter */\n\n    entries = avio_rb32(pb);\n    if (!entries)\n        return 0;\n    if (*tablep)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated SBGP %s atom\\n\", av_fourcc2str(grouping_type));\n    av_freep(tablep);\n    table = av_malloc_array(entries, sizeof(*table));\n    if (!table)\n        return AVERROR(ENOMEM);\n    *tablep = table;\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        table[i].count = avio_rb32(pb); /* sample_count */\n        table[i].index = avio_rb32(pb); /* group_description_index */\n    }\n\n    *table_count = i;\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted SBGP atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    return 0;\n}\n\n/**\n * Get ith edit list entry (media time, duration).\n */\nstatic int get_edit_list_entry(MOVContext *mov,\n                               const MOVStreamContext *msc,\n                               unsigned int edit_list_index,\n                               int64_t *edit_list_media_time,\n                               int64_t *edit_list_duration,\n                               int64_t global_timescale)\n{\n    if (edit_list_index == msc->elst_count) {\n        return 0;\n    }\n    *edit_list_media_time = msc->elst_data[edit_list_index].time;\n    *edit_list_duration = msc->elst_data[edit_list_index].duration;\n\n    /* duration is in global timescale units;convert to msc timescale */\n    if (global_timescale == 0) {\n      avpriv_request_sample(mov->fc, \"Support for mvhd.timescale = 0 with editlists\");\n      return 0;\n    }\n    *edit_list_duration = av_rescale(*edit_list_duration, msc->time_scale,\n                                     global_timescale);\n    return 1;\n}\n\n/**\n * Find the closest previous frame to the timestamp_pts, in e_old index\n * entries. Searching for just any frame / just key frames can be controlled by\n * last argument 'flag'.\n * Note that if ctts_data is not NULL, we will always search for a key frame\n * irrespective of the value of 'flag'. If we don't find any keyframe, we will\n * return the first frame of the video.\n *\n * Here the timestamp_pts is considered to be a presentation timestamp and\n * the timestamp of index entries are considered to be decoding timestamps.\n *\n * Returns 0 if successful in finding a frame, else returns -1.\n * Places the found index corresponding output arg.\n *\n * If ctts_old is not NULL, then refines the searched entry by searching\n * backwards from the found timestamp, to find the frame with correct PTS.\n *\n * Places the found ctts_index and ctts_sample in corresponding output args.\n */\nstatic int find_prev_closest_index(AVStream *st,\n                                   AVIndexEntry *e_old,\n                                   int nb_old,\n                                   MOVCtts* ctts_data,\n                                   int64_t ctts_count,\n                                   int64_t timestamp_pts,\n                                   int flag,\n                                   int64_t* index,\n                                   int64_t* ctts_index,\n                                   int64_t* ctts_sample)\n{\n    MOVStreamContext *msc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    AVIndexEntry *e_keep = sti->index_entries;\n    int nb_keep = sti->nb_index_entries;\n    int64_t i = 0;\n    int64_t index_ctts_count;\n\n    av_assert0(index);\n\n    // If dts_shift > 0, then all the index timestamps will have to be offset by\n    // at least dts_shift amount to obtain PTS.\n    // Hence we decrement the searched timestamp_pts by dts_shift to find the closest index element.\n    if (msc->dts_shift > 0) {\n        timestamp_pts -= msc->dts_shift;\n    }\n\n    sti->index_entries    = e_old;\n    sti->nb_index_entries = nb_old;\n    *index = av_index_search_timestamp(st, timestamp_pts, flag | AVSEEK_FLAG_BACKWARD);\n\n    // Keep going backwards in the index entries until the timestamp is the same.\n    if (*index >= 0) {\n        for (i = *index; i > 0 && e_old[i].timestamp == e_old[i - 1].timestamp;\n             i--) {\n            if ((flag & AVSEEK_FLAG_ANY) ||\n                (e_old[i - 1].flags & AVINDEX_KEYFRAME)) {\n                *index = i - 1;\n            }\n        }\n    }\n\n    // If we have CTTS then refine the search, by searching backwards over PTS\n    // computed by adding corresponding CTTS durations to index timestamps.\n    if (ctts_data && *index >= 0) {\n        av_assert0(ctts_index);\n        av_assert0(ctts_sample);\n        // Find out the ctts_index for the found frame.\n        *ctts_index = 0;\n        *ctts_sample = 0;\n        for (index_ctts_count = 0; index_ctts_count < *index; index_ctts_count++) {\n            if (*ctts_index < ctts_count) {\n                (*ctts_sample)++;\n                if (ctts_data[*ctts_index].count == *ctts_sample) {\n                    (*ctts_index)++;\n                    *ctts_sample = 0;\n                }\n            }\n        }\n\n        while (*index >= 0 && (*ctts_index) >= 0 && (*ctts_index) < ctts_count) {\n            // Find a \"key frame\" with PTS <= timestamp_pts (So that we can decode B-frames correctly).\n            // No need to add dts_shift to the timestamp here becase timestamp_pts has already been\n            // compensated by dts_shift above.\n            if ((e_old[*index].timestamp + ctts_data[*ctts_index].duration) <= timestamp_pts &&\n                (e_old[*index].flags & AVINDEX_KEYFRAME)) {\n                break;\n            }\n\n            (*index)--;\n            if (*ctts_sample == 0) {\n                (*ctts_index)--;\n                if (*ctts_index >= 0)\n                  *ctts_sample = ctts_data[*ctts_index].count - 1;\n            } else {\n                (*ctts_sample)--;\n            }\n        }\n    }\n\n    /* restore AVStream state*/\n    sti->index_entries    = e_keep;\n    sti->nb_index_entries = nb_keep;\n    return *index >= 0 ? 0 : -1;\n}\n\n/**\n * Add index entry with the given values, to the end of ffstream(st)->index_entries.\n * Returns the new size ffstream(st)->index_entries if successful, else returns -1.\n *\n * This function is similar to ff_add_index_entry in libavformat/utils.c\n * except that here we are always unconditionally adding an index entry to\n * the end, instead of searching the entries list and skipping the add if\n * there is an existing entry with the same timestamp.\n * This is needed because the mov_fix_index calls this func with the same\n * unincremented timestamp for successive discarded frames.\n */\nstatic int64_t add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,\n                               int size, int distance, int flags)\n{\n    FFStream *const sti = ffstream(st);\n    AVIndexEntry *entries, *ie;\n    int64_t index = -1;\n    const size_t min_size_needed = (sti->nb_index_entries + 1) * sizeof(AVIndexEntry);\n\n    // Double the allocation each time, to lower memory fragmentation.\n    // Another difference from ff_add_index_entry function.\n    const size_t requested_size =\n        min_size_needed > sti->index_entries_allocated_size ?\n        FFMAX(min_size_needed, 2 * sti->index_entries_allocated_size) :\n        min_size_needed;\n\n    if (sti->nb_index_entries + 1U >= UINT_MAX / sizeof(AVIndexEntry))\n        return -1;\n\n    entries = av_fast_realloc(sti->index_entries,\n                              &sti->index_entries_allocated_size,\n                              requested_size);\n    if (!entries)\n        return -1;\n\n    sti->index_entries = entries;\n\n    index = sti->nb_index_entries++;\n    ie= &entries[index];\n\n    ie->pos = pos;\n    ie->timestamp = timestamp;\n    ie->min_distance= distance;\n    ie->size= size;\n    ie->flags = flags;\n    return index;\n}\n\n/**\n * Rewrite timestamps of index entries in the range [end_index - frame_duration_buffer_size, end_index)\n * by subtracting end_ts successively by the amounts given in frame_duration_buffer.\n */\nstatic void fix_index_entry_timestamps(AVStream* st, int end_index, int64_t end_ts,\n                                       int64_t* frame_duration_buffer,\n                                       int frame_duration_buffer_size) {\n    FFStream *const sti = ffstream(st);\n    int i = 0;\n    av_assert0(end_index >= 0 && end_index <= sti->nb_index_entries);\n    for (i = 0; i < frame_duration_buffer_size; i++) {\n        end_ts -= frame_duration_buffer[frame_duration_buffer_size - 1 - i];\n        sti->index_entries[end_index - 1 - i].timestamp = end_ts;\n    }\n}\n\n/**\n * Append a new ctts entry to ctts_data.\n * Returns the new ctts_count if successful, else returns -1.\n */\nstatic int64_t add_ctts_entry(MOVCtts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration)\n{\n    MOVCtts *ctts_buf_new;\n    const size_t min_size_needed = (*ctts_count + 1) * sizeof(MOVCtts);\n    const size_t requested_size =\n        min_size_needed > *allocated_size ?\n        FFMAX(min_size_needed, 2 * (*allocated_size)) :\n        min_size_needed;\n\n    if ((unsigned)(*ctts_count) >= UINT_MAX / sizeof(MOVCtts) - 1)\n        return -1;\n\n    ctts_buf_new = av_fast_realloc(*ctts_data, allocated_size, requested_size);\n\n    if (!ctts_buf_new)\n        return -1;\n\n    *ctts_data = ctts_buf_new;\n\n    ctts_buf_new[*ctts_count].count = count;\n    ctts_buf_new[*ctts_count].duration = duration;\n\n    *ctts_count = (*ctts_count) + 1;\n    return *ctts_count;\n}\n\n#define MAX_REORDER_DELAY 16\nstatic void mov_estimate_video_delay(MOVContext *c, AVStream* st)\n{\n    MOVStreamContext *msc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int ctts_ind = 0;\n    int ctts_sample = 0;\n    int64_t pts_buf[MAX_REORDER_DELAY + 1]; // Circular buffer to sort pts.\n    int buf_start = 0;\n    int j, r, num_swaps;\n\n    for (j = 0; j < MAX_REORDER_DELAY + 1; j++)\n        pts_buf[j] = INT64_MIN;\n\n    if (st->codecpar->video_delay <= 0 && msc->ctts_data &&\n        st->codecpar->codec_id == AV_CODEC_ID_H264) {\n        st->codecpar->video_delay = 0;\n        for (int ind = 0; ind < sti->nb_index_entries && ctts_ind < msc->ctts_count; ++ind) {\n            // Point j to the last elem of the buffer and insert the current pts there.\n            j = buf_start;\n            buf_start = (buf_start + 1);\n            if (buf_start == MAX_REORDER_DELAY + 1)\n                buf_start = 0;\n\n            pts_buf[j] = sti->index_entries[ind].timestamp + msc->ctts_data[ctts_ind].duration;\n\n            // The timestamps that are already in the sorted buffer, and are greater than the\n            // current pts, are exactly the timestamps that need to be buffered to output PTS\n            // in correct sorted order.\n            // Hence the video delay (which is the buffer size used to sort DTS and output PTS),\n            // can be computed as the maximum no. of swaps any particular timestamp needs to\n            // go through, to keep this buffer in sorted order.\n            num_swaps = 0;\n            while (j != buf_start) {\n                r = j - 1;\n                if (r < 0) r = MAX_REORDER_DELAY;\n                if (pts_buf[j] < pts_buf[r]) {\n                    FFSWAP(int64_t, pts_buf[j], pts_buf[r]);\n                    ++num_swaps;\n                } else {\n                    break;\n                }\n                j = r;\n            }\n            st->codecpar->video_delay = FFMAX(st->codecpar->video_delay, num_swaps);\n\n            ctts_sample++;\n            if (ctts_sample == msc->ctts_data[ctts_ind].count) {\n                ctts_ind++;\n                ctts_sample = 0;\n            }\n        }\n        av_log(c->fc, AV_LOG_DEBUG, \"Setting codecpar->delay to %d for stream st: %d\\n\",\n               st->codecpar->video_delay, st->index);\n    }\n}\n\nstatic void mov_current_sample_inc(MOVStreamContext *sc)\n{\n    sc->current_sample++;\n    sc->current_index++;\n    if (sc->index_ranges &&\n        sc->current_index >= sc->current_index_range->end &&\n        sc->current_index_range->end) {\n        sc->current_index_range++;\n        sc->current_index = sc->current_index_range->start;\n    }\n}\n\nstatic void mov_current_sample_dec(MOVStreamContext *sc)\n{\n    sc->current_sample--;\n    sc->current_index--;\n    if (sc->index_ranges &&\n        sc->current_index < sc->current_index_range->start &&\n        sc->current_index_range > sc->index_ranges) {\n        sc->current_index_range--;\n        sc->current_index = sc->current_index_range->end - 1;\n    }\n}\n\nstatic void mov_current_sample_set(MOVStreamContext *sc, int current_sample)\n{\n    int64_t range_size;\n\n    sc->current_sample = current_sample;\n    sc->current_index = current_sample;\n    if (!sc->index_ranges) {\n        return;\n    }\n\n    for (sc->current_index_range = sc->index_ranges;\n        sc->current_index_range->end;\n        sc->current_index_range++) {\n        range_size = sc->current_index_range->end - sc->current_index_range->start;\n        if (range_size > current_sample) {\n            sc->current_index = sc->current_index_range->start + current_sample;\n            break;\n        }\n        current_sample -= range_size;\n    }\n}\n\n/**\n * Fix ffstream(st)->index_entries, so that it contains only the entries (and the entries\n * which are needed to decode them) that fall in the edit list time ranges.\n * Also fixes the timestamps of the index entries to match the timeline\n * specified the edit lists.\n */\nstatic void mov_fix_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *msc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    AVIndexEntry *e_old = sti->index_entries;\n    int nb_old = sti->nb_index_entries;\n    const AVIndexEntry *e_old_end = e_old + nb_old;\n    const AVIndexEntry *current = NULL;\n    MOVCtts *ctts_data_old = msc->ctts_data;\n    int64_t ctts_index_old = 0;\n    int64_t ctts_sample_old = 0;\n    int64_t ctts_count_old = msc->ctts_count;\n    int64_t edit_list_media_time = 0;\n    int64_t edit_list_duration = 0;\n    int64_t frame_duration = 0;\n    int64_t edit_list_dts_counter = 0;\n    int64_t edit_list_dts_entry_end = 0;\n    int64_t edit_list_start_ctts_sample = 0;\n    int64_t curr_cts;\n    int64_t curr_ctts = 0;\n    int64_t empty_edits_sum_duration = 0;\n    int64_t edit_list_index = 0;\n    int64_t index;\n    int flags;\n    int64_t start_dts = 0;\n    int64_t edit_list_start_encountered = 0;\n    int64_t search_timestamp = 0;\n    int64_t* frame_duration_buffer = NULL;\n    int num_discarded_begin = 0;\n    int first_non_zero_audio_edit = -1;\n    int packet_skip_samples = 0;\n    MOVIndexRange *current_index_range;\n    int found_keyframe_after_edit = 0;\n    int found_non_empty_edit = 0;\n\n    if (!msc->elst_data || msc->elst_count <= 0 || nb_old <= 0) {\n        return;\n    }\n\n    // allocate the index ranges array\n    msc->index_ranges = av_malloc((msc->elst_count + 1) * sizeof(msc->index_ranges[0]));\n    if (!msc->index_ranges) {\n        av_log(mov->fc, AV_LOG_ERROR, \"Cannot allocate index ranges buffer\\n\");\n        return;\n    }\n    msc->current_index_range = msc->index_ranges;\n    current_index_range = msc->index_ranges - 1;\n\n    // Clean AVStream from traces of old index\n    sti->index_entries = NULL;\n    sti->index_entries_allocated_size = 0;\n    sti->nb_index_entries = 0;\n\n    // Clean ctts fields of MOVStreamContext\n    msc->ctts_data = NULL;\n    msc->ctts_count = 0;\n    msc->ctts_index = 0;\n    msc->ctts_sample = 0;\n    msc->ctts_allocated_size = 0;\n\n    // Reinitialize min_corrected_pts so that it can be computed again.\n    msc->min_corrected_pts = -1;\n\n    // If the dts_shift is positive (in case of negative ctts values in mov),\n    // then negate the DTS by dts_shift\n    if (msc->dts_shift > 0) {\n        edit_list_dts_entry_end -= msc->dts_shift;\n        av_log(mov->fc, AV_LOG_DEBUG, \"Shifting DTS by %d because of negative CTTS.\\n\", msc->dts_shift);\n    }\n\n    start_dts = edit_list_dts_entry_end;\n\n    while (get_edit_list_entry(mov, msc, edit_list_index, &edit_list_media_time,\n                               &edit_list_duration, mov->time_scale)) {\n        av_log(mov->fc, AV_LOG_DEBUG, \"Processing st: %d, edit list %\"PRId64\" - media time: %\"PRId64\", duration: %\"PRId64\"\\n\",\n               st->index, edit_list_index, edit_list_media_time, edit_list_duration);\n        edit_list_index++;\n        edit_list_dts_counter = edit_list_dts_entry_end;\n        edit_list_dts_entry_end += edit_list_duration;\n        num_discarded_begin = 0;\n        if (!found_non_empty_edit && edit_list_media_time == -1) {\n            empty_edits_sum_duration += edit_list_duration;\n            continue;\n        }\n        found_non_empty_edit = 1;\n\n        // If we encounter a non-negative edit list reset the skip_samples/start_pad fields and set them\n        // according to the edit list below.\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            if (first_non_zero_audio_edit < 0) {\n                first_non_zero_audio_edit = 1;\n            } else {\n                first_non_zero_audio_edit = 0;\n            }\n\n            if (first_non_zero_audio_edit > 0)\n                sti->skip_samples = msc->start_pad = 0;\n        }\n\n        // While reordering frame index according to edit list we must handle properly\n        // the scenario when edit list entry starts from none key frame.\n        // We find closest previous key frame and preserve it and consequent frames in index.\n        // All frames which are outside edit list entry time boundaries will be dropped after decoding.\n        search_timestamp = edit_list_media_time;\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            // Audio decoders like AAC need need a decoder delay samples previous to the current sample,\n            // to correctly decode this frame. Hence for audio we seek to a frame 1 sec. before the\n            // edit_list_media_time to cover the decoder delay.\n            search_timestamp = FFMAX(search_timestamp - msc->time_scale, e_old[0].timestamp);\n        }\n\n        if (find_prev_closest_index(st, e_old, nb_old, ctts_data_old, ctts_count_old, search_timestamp, 0,\n                                    &index, &ctts_index_old, &ctts_sample_old) < 0) {\n            av_log(mov->fc, AV_LOG_WARNING,\n                   \"st: %d edit list: %\"PRId64\" Missing key frame while searching for timestamp: %\"PRId64\"\\n\",\n                   st->index, edit_list_index, search_timestamp);\n            if (find_prev_closest_index(st, e_old, nb_old, ctts_data_old, ctts_count_old, search_timestamp, AVSEEK_FLAG_ANY,\n                                        &index, &ctts_index_old, &ctts_sample_old) < 0) {\n                av_log(mov->fc, AV_LOG_WARNING,\n                       \"st: %d edit list %\"PRId64\" Cannot find an index entry before timestamp: %\"PRId64\".\\n\",\n                       st->index, edit_list_index, search_timestamp);\n                index = 0;\n                ctts_index_old = 0;\n                ctts_sample_old = 0;\n            }\n        }\n        current = e_old + index;\n        edit_list_start_ctts_sample = ctts_sample_old;\n\n        // Iterate over index and arrange it according to edit list\n        edit_list_start_encountered = 0;\n        found_keyframe_after_edit = 0;\n        for (; current < e_old_end; current++, index++) {\n            // check  if frame outside edit list mark it for discard\n            frame_duration = (current + 1 <  e_old_end) ?\n                             ((current + 1)->timestamp - current->timestamp) : edit_list_duration;\n\n            flags = current->flags;\n\n            // frames (pts) before or after edit list\n            curr_cts = current->timestamp + msc->dts_shift;\n            curr_ctts = 0;\n\n            if (ctts_data_old && ctts_index_old < ctts_count_old) {\n                curr_ctts = ctts_data_old[ctts_index_old].duration;\n                av_log(mov->fc, AV_LOG_TRACE, \"stts: %\"PRId64\" ctts: %\"PRId64\", ctts_index: %\"PRId64\", ctts_count: %\"PRId64\"\\n\",\n                       curr_cts, curr_ctts, ctts_index_old, ctts_count_old);\n                curr_cts += curr_ctts;\n                ctts_sample_old++;\n                if (ctts_sample_old == ctts_data_old[ctts_index_old].count) {\n                    if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                       &msc->ctts_allocated_size,\n                                       ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                                       ctts_data_old[ctts_index_old].duration) == -1) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                               ctts_index_old,\n                               ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                               ctts_data_old[ctts_index_old].duration);\n                        break;\n                    }\n                    ctts_index_old++;\n                    ctts_sample_old = 0;\n                    edit_list_start_ctts_sample = 0;\n                }\n            }\n\n            if (curr_cts < edit_list_media_time || curr_cts >= (edit_list_duration + edit_list_media_time)) {\n                if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && st->codecpar->codec_id != AV_CODEC_ID_VORBIS &&\n                    curr_cts < edit_list_media_time && curr_cts + frame_duration > edit_list_media_time &&\n                    first_non_zero_audio_edit > 0) {\n                    packet_skip_samples = edit_list_media_time - curr_cts;\n                    sti->skip_samples += packet_skip_samples;\n\n                    // Shift the index entry timestamp by packet_skip_samples to be correct.\n                    edit_list_dts_counter -= packet_skip_samples;\n                    if (edit_list_start_encountered == 0)  {\n                        edit_list_start_encountered = 1;\n                        // Make timestamps strictly monotonically increasing for audio, by rewriting timestamps for\n                        // discarded packets.\n                        if (frame_duration_buffer) {\n                            fix_index_entry_timestamps(st, sti->nb_index_entries, edit_list_dts_counter,\n                                                       frame_duration_buffer, num_discarded_begin);\n                            av_freep(&frame_duration_buffer);\n                        }\n                    }\n\n                    av_log(mov->fc, AV_LOG_DEBUG, \"skip %d audio samples from curr_cts: %\"PRId64\"\\n\", packet_skip_samples, curr_cts);\n                } else {\n                    flags |= AVINDEX_DISCARD_FRAME;\n                    av_log(mov->fc, AV_LOG_DEBUG, \"drop a frame at curr_cts: %\"PRId64\" @ %\"PRId64\"\\n\", curr_cts, index);\n\n                    if (edit_list_start_encountered == 0) {\n                        num_discarded_begin++;\n                        frame_duration_buffer = av_realloc(frame_duration_buffer,\n                                                           num_discarded_begin * sizeof(int64_t));\n                        if (!frame_duration_buffer) {\n                            av_log(mov->fc, AV_LOG_ERROR, \"Cannot reallocate frame duration buffer\\n\");\n                            break;\n                        }\n                        frame_duration_buffer[num_discarded_begin - 1] = frame_duration;\n\n                        // Increment skip_samples for the first non-zero audio edit list\n                        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n                            first_non_zero_audio_edit > 0 && st->codecpar->codec_id != AV_CODEC_ID_VORBIS) {\n                            sti->skip_samples += frame_duration;\n                        }\n                    }\n                }\n            } else {\n                if (msc->min_corrected_pts < 0) {\n                    msc->min_corrected_pts = edit_list_dts_counter + curr_ctts + msc->dts_shift;\n                } else {\n                    msc->min_corrected_pts = FFMIN(msc->min_corrected_pts, edit_list_dts_counter + curr_ctts + msc->dts_shift);\n                }\n                if (edit_list_start_encountered == 0) {\n                    edit_list_start_encountered = 1;\n                    // Make timestamps strictly monotonically increasing by rewriting timestamps for\n                    // discarded packets.\n                    if (frame_duration_buffer) {\n                        fix_index_entry_timestamps(st, sti->nb_index_entries, edit_list_dts_counter,\n                                                   frame_duration_buffer, num_discarded_begin);\n                        av_freep(&frame_duration_buffer);\n                    }\n                }\n            }\n\n            if (add_index_entry(st, current->pos, edit_list_dts_counter, current->size,\n                                current->min_distance, flags) == -1) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot add index entry\\n\");\n                break;\n            }\n\n            // Update the index ranges array\n            if (current_index_range < msc->index_ranges || index != current_index_range->end) {\n                current_index_range++;\n                current_index_range->start = index;\n            }\n            current_index_range->end = index + 1;\n\n            // Only start incrementing DTS in frame_duration amounts, when we encounter a frame in edit list.\n            if (edit_list_start_encountered > 0) {\n                edit_list_dts_counter = edit_list_dts_counter + frame_duration;\n            }\n\n            // Break when found first key frame after edit entry completion\n            if ((curr_cts + frame_duration >= (edit_list_duration + edit_list_media_time)) &&\n                ((flags & AVINDEX_KEYFRAME) || ((st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)))) {\n                if (ctts_data_old) {\n                    // If we have CTTS and this is the first keyframe after edit elist,\n                    // wait for one more, because there might be trailing B-frames after this I-frame\n                    // that do belong to the edit.\n                    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO && found_keyframe_after_edit == 0) {\n                        found_keyframe_after_edit = 1;\n                        continue;\n                    }\n                    if (ctts_sample_old != 0) {\n                        if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                           &msc->ctts_allocated_size,\n                                           ctts_sample_old - edit_list_start_ctts_sample,\n                                           ctts_data_old[ctts_index_old].duration) == -1) {\n                            av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                                   ctts_index_old, ctts_sample_old - edit_list_start_ctts_sample,\n                                   ctts_data_old[ctts_index_old].duration);\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n    // If there are empty edits, then msc->min_corrected_pts might be positive\n    // intentionally. So we subtract the sum duration of emtpy edits here.\n    msc->min_corrected_pts -= empty_edits_sum_duration;\n\n    // If the minimum pts turns out to be greater than zero after fixing the index, then we subtract the\n    // dts by that amount to make the first pts zero.\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (msc->min_corrected_pts > 0) {\n            av_log(mov->fc, AV_LOG_DEBUG, \"Offset DTS by %\"PRId64\" to make first pts zero.\\n\", msc->min_corrected_pts);\n            for (int i = 0; i < sti->nb_index_entries; ++i)\n                sti->index_entries[i].timestamp -= msc->min_corrected_pts;\n        }\n    }\n    // Start time should be equal to zero or the duration of any empty edits.\n    st->start_time = empty_edits_sum_duration;\n\n    // Update av stream length, if it ends up shorter than the track's media duration\n    st->duration = FFMIN(st->duration, edit_list_dts_entry_end - start_dts);\n    msc->start_pad = sti->skip_samples;\n\n    // Free the old index and the old CTTS structures\n    av_free(e_old);\n    av_free(ctts_data_old);\n    av_freep(&frame_duration_buffer);\n\n    // Null terminate the index ranges array\n    current_index_range++;\n    current_index_range->start = 0;\n    current_index_range->end = 0;\n    msc->current_index = msc->index_ranges[0].start;\n}\n\nstatic uint32_t get_sgpd_sync_index(const MOVStreamContext *sc, int nal_unit_type)\n{\n    for (uint32_t i = 0; i < sc->sgpd_sync_count; i++)\n        if (sc->sgpd_sync[i] == HEVC_NAL_CRA_NUT)\n            return i + 1;\n    return 0;\n}\n\nstatic int build_open_gop_key_points(AVStream *st)\n{\n    int k;\n    int sample_id = 0;\n    uint32_t cra_index;\n    MOVStreamContext *sc = st->priv_data;\n\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)\n        return 0;\n\n    /* Build an unrolled index of the samples */\n    sc->sample_offsets_count = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++) {\n        if (sc->ctts_data[i].count > INT_MAX - sc->sample_offsets_count)\n            return AVERROR(ENOMEM);\n        sc->sample_offsets_count += sc->ctts_data[i].count;\n    }\n    av_freep(&sc->sample_offsets);\n    sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));\n    if (!sc->sample_offsets)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        for (int j = 0; j < sc->ctts_data[i].count; j++)\n             sc->sample_offsets[k++] = sc->ctts_data[i].duration;\n\n    /* The following HEVC NAL type reveal the use of open GOP sync points\n     * (TODO: BLA types may also be concerned) */\n    cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT); /* Clean Random Access */\n    if (!cra_index)\n        return 0;\n\n    /* Build a list of open-GOP key samples */\n    sc->open_key_samples_count = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++)\n        if (sc->sync_group[i].index == cra_index) {\n            if (sc->sync_group[i].count > INT_MAX - sc->open_key_samples_count)\n                return AVERROR(ENOMEM);\n            sc->open_key_samples_count += sc->sync_group[i].count;\n        }\n    av_freep(&sc->open_key_samples);\n    sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));\n    if (!sc->open_key_samples)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++) {\n        const MOVSbgp *sg = &sc->sync_group[i];\n        if (sg->index == cra_index)\n            for (uint32_t j = 0; j < sg->count; j++)\n                sc->open_key_samples[k++] = sample_id;\n        if (sg->count > INT_MAX - sample_id)\n            return AVERROR_PATCHWELCOME;\n        sample_id += sg->count;\n    }\n\n    /* Identify the minimal time step between samples */\n    sc->min_sample_duration = UINT_MAX;\n    for (uint32_t i = 0; i < sc->stts_count; i++)\n        sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);\n\n    return 0;\n}\n\nstatic void mov_build_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int64_t current_offset;\n    int64_t current_dts = 0;\n    unsigned int stts_index = 0;\n    unsigned int stsc_index = 0;\n    unsigned int stss_index = 0;\n    unsigned int stps_index = 0;\n    unsigned int i, j;\n    uint64_t stream_size = 0;\n    MOVCtts *ctts_data_old = sc->ctts_data;\n    unsigned int ctts_count_old = sc->ctts_count;\n\n    int ret = build_open_gop_key_points(st);\n    if (ret < 0)\n        return;\n\n    if (sc->elst_count) {\n        int i, edit_start_index = 0, multiple_edits = 0;\n        int64_t empty_duration = 0; // empty duration of the first edit list entry\n        int64_t start_time = 0; // start time of the media\n\n        for (i = 0; i < sc->elst_count; i++) {\n            const MOVElst *e = &sc->elst_data[i];\n            if (i == 0 && e->time == -1) {\n                /* if empty, the first entry is the start time of the stream\n                 * relative to the presentation itself */\n                empty_duration = e->duration;\n                edit_start_index = 1;\n            } else if (i == edit_start_index && e->time >= 0) {\n                start_time = e->time;\n            } else {\n                multiple_edits = 1;\n            }\n        }\n\n        if (multiple_edits && !mov->advanced_editlist)\n            av_log(mov->fc, AV_LOG_WARNING, \"multiple edit list entries, \"\n                   \"Use -advanced_editlist to correctly decode otherwise \"\n                   \"a/v desync might occur\\n\");\n\n        /* adjust first dts according to edit list */\n        if ((empty_duration || start_time) && mov->time_scale > 0) {\n            if (empty_duration)\n                empty_duration = av_rescale(empty_duration, sc->time_scale, mov->time_scale);\n\n            if (av_sat_sub64(start_time, empty_duration) != start_time - (uint64_t)empty_duration)\n                av_log(mov->fc, AV_LOG_WARNING, \"start_time - empty_duration is not representable\\n\");\n\n            sc->time_offset = start_time -  (uint64_t)empty_duration;\n            sc->min_corrected_pts = start_time;\n            if (!mov->advanced_editlist)\n                current_dts = -sc->time_offset;\n        }\n\n        if (!multiple_edits && !mov->advanced_editlist &&\n            st->codecpar->codec_id == AV_CODEC_ID_AAC && start_time > 0)\n            sc->start_pad = start_time;\n    }\n\n    /* only use old uncompressed audio chunk demuxing when stts specifies it */\n    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n          sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {\n        unsigned int current_sample = 0;\n        unsigned int stts_sample = 0;\n        unsigned int sample_size;\n        unsigned int distance = 0;\n        unsigned int rap_group_index = 0;\n        unsigned int rap_group_sample = 0;\n        int rap_group_present = sc->rap_group_count && sc->rap_group;\n        int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_count && sc->stps_data[0] > 0);\n\n        current_dts -= sc->dts_shift;\n\n        if (!sc->sample_count || sti->nb_index_entries)\n            return;\n        if (sc->sample_count >= UINT_MAX / sizeof(*sti->index_entries) - sti->nb_index_entries)\n            return;\n        if (av_reallocp_array(&sti->index_entries,\n                              sti->nb_index_entries + sc->sample_count,\n                              sizeof(*sti->index_entries)) < 0) {\n            sti->nb_index_entries = 0;\n            return;\n        }\n        sti->index_entries_allocated_size = (sti->nb_index_entries + sc->sample_count) * sizeof(*sti->index_entries);\n\n        if (ctts_data_old) {\n            // Expand ctts entries such that we have a 1-1 mapping with samples\n            if (sc->sample_count >= UINT_MAX / sizeof(*sc->ctts_data))\n                return;\n            sc->ctts_count = 0;\n            sc->ctts_allocated_size = 0;\n            sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size,\n                                    sc->sample_count * sizeof(*sc->ctts_data));\n            if (!sc->ctts_data) {\n                av_free(ctts_data_old);\n                return;\n            }\n\n            memset((uint8_t*)(sc->ctts_data), 0, sc->ctts_allocated_size);\n\n            for (i = 0; i < ctts_count_old &&\n                        sc->ctts_count < sc->sample_count; i++)\n                for (j = 0; j < ctts_data_old[i].count &&\n                            sc->ctts_count < sc->sample_count; j++)\n                    add_ctts_entry(&sc->ctts_data, &sc->ctts_count,\n                                   &sc->ctts_allocated_size, 1,\n                                   ctts_data_old[i].duration);\n            av_free(ctts_data_old);\n        }\n\n        for (i = 0; i < sc->chunk_count; i++) {\n            int64_t next_offset = i+1 < sc->chunk_count ? sc->chunk_offsets[i+1] : INT64_MAX;\n            current_offset = sc->chunk_offsets[i];\n            while (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n\n            if (next_offset > current_offset && sc->sample_size>0 && sc->sample_size < sc->stsz_sample_size &&\n                sc->stsc_data[stsc_index].count * (int64_t)sc->stsz_sample_size > next_offset - current_offset) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too large), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n            if (sc->stsz_sample_size>0 && sc->stsz_sample_size < sc->sample_size) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too small), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n\n            for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {\n                int keyframe = 0;\n                if (current_sample >= sc->sample_count) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong sample count\\n\");\n                    return;\n                }\n\n                if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {\n                    keyframe = 1;\n                    if (stss_index + 1 < sc->keyframe_count)\n                        stss_index++;\n                } else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {\n                    keyframe = 1;\n                    if (stps_index + 1 < sc->stps_count)\n                        stps_index++;\n                }\n                if (rap_group_present && rap_group_index < sc->rap_group_count) {\n                    if (sc->rap_group[rap_group_index].index > 0)\n                        keyframe = 1;\n                    if (++rap_group_sample == sc->rap_group[rap_group_index].count) {\n                        rap_group_sample = 0;\n                        rap_group_index++;\n                    }\n                }\n                if (sc->keyframe_absent\n                    && !sc->stps_count\n                    && !rap_group_present\n                    && (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || (i==0 && j==0)))\n                     keyframe = 1;\n                if (keyframe)\n                    distance = 0;\n                sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];\n                if (sc->pseudo_stream_id == -1 ||\n                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {\n                    AVIndexEntry *e;\n                    if (sample_size > 0x3FFFFFFF) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", sample_size);\n                        return;\n                    }\n                    e = &sti->index_entries[sti->nb_index_entries++];\n                    e->pos = current_offset;\n                    e->timestamp = current_dts;\n                    e->size = sample_size;\n                    e->min_distance = distance;\n                    e->flags = keyframe ? AVINDEX_KEYFRAME : 0;\n                    av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                            \"size %u, distance %u, keyframe %d\\n\", st->index, current_sample,\n                            current_offset, current_dts, sample_size, distance, keyframe);\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sti->nb_index_entries < 100)\n                        ff_rfps_add_frame(mov->fc, st, current_dts);\n                }\n\n                current_offset += sample_size;\n                stream_size += sample_size;\n\n                current_dts += sc->stts_data[stts_index].duration;\n\n                distance++;\n                stts_sample++;\n                current_sample++;\n                if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {\n                    stts_sample = 0;\n                    stts_index++;\n                }\n            }\n        }\n        if (st->duration > 0)\n            st->codecpar->bit_rate = stream_size*8*sc->time_scale/st->duration;\n    } else {\n        unsigned chunk_samples, total = 0;\n\n        if (!sc->chunk_count)\n            return;\n\n        // compute total chunk count\n        for (i = 0; i < sc->stsc_count; i++) {\n            unsigned count, chunk_count;\n\n            chunk_samples = sc->stsc_data[i].count;\n            if (i != sc->stsc_count - 1 &&\n                sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {\n                av_log(mov->fc, AV_LOG_ERROR, \"error unaligned chunk\\n\");\n                return;\n            }\n\n            if (sc->samples_per_frame >= 160) { // gsm\n                count = chunk_samples / sc->samples_per_frame;\n            } else if (sc->samples_per_frame > 1) {\n                unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;\n                count = (chunk_samples+samples-1) / samples;\n            } else {\n                count = (chunk_samples+1023) / 1024;\n            }\n\n            if (mov_stsc_index_valid(i, sc->stsc_count))\n                chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;\n            else\n                chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);\n            total += chunk_count * count;\n        }\n\n        av_log(mov->fc, AV_LOG_TRACE, \"chunk count %u\\n\", total);\n        if (total >= UINT_MAX / sizeof(*sti->index_entries) - sti->nb_index_entries)\n            return;\n        if (av_reallocp_array(&sti->index_entries,\n                              sti->nb_index_entries + total,\n                              sizeof(*sti->index_entries)) < 0) {\n            sti->nb_index_entries = 0;\n            return;\n        }\n        sti->index_entries_allocated_size = (sti->nb_index_entries + total) * sizeof(*sti->index_entries);\n\n        // populate index\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            if (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            chunk_samples = sc->stsc_data[stsc_index].count;\n\n            while (chunk_samples > 0) {\n                AVIndexEntry *e;\n                unsigned size, samples;\n\n                if (sc->samples_per_frame > 1 && !sc->bytes_per_frame) {\n                    avpriv_request_sample(mov->fc,\n                           \"Zero bytes per frame, but %d samples per frame\",\n                           sc->samples_per_frame);\n                    return;\n                }\n\n                if (sc->samples_per_frame >= 160) { // gsm\n                    samples = sc->samples_per_frame;\n                    size = sc->bytes_per_frame;\n                } else {\n                    if (sc->samples_per_frame > 1) {\n                        samples = FFMIN((1024 / sc->samples_per_frame)*\n                                        sc->samples_per_frame, chunk_samples);\n                        size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;\n                    } else {\n                        samples = FFMIN(1024, chunk_samples);\n                        size = samples * sc->sample_size;\n                    }\n                }\n\n                if (sti->nb_index_entries >= total) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong chunk count %u\\n\", total);\n                    return;\n                }\n                if (size > 0x3FFFFFFF) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", size);\n                    return;\n                }\n                e = &sti->index_entries[sti->nb_index_entries++];\n                e->pos = current_offset;\n                e->timestamp = current_dts;\n                e->size = size;\n                e->min_distance = 0;\n                e->flags = AVINDEX_KEYFRAME;\n                av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, chunk %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                       \"size %u, duration %u\\n\", st->index, i, current_offset, current_dts,\n                       size, samples);\n\n                current_offset += size;\n                current_dts += samples;\n                chunk_samples -= samples;\n            }\n        }\n    }\n\n    if (!mov->ignore_editlist && mov->advanced_editlist) {\n        // Fix index according to edit lists.\n        mov_fix_index(mov, st);\n    }\n\n    // Update start time of the stream.\n    if (st->start_time == AV_NOPTS_VALUE && st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sti->nb_index_entries > 0) {\n        st->start_time = sti->index_entries[0].timestamp + sc->dts_shift;\n        if (sc->ctts_data) {\n            st->start_time += sc->ctts_data[0].duration;\n        }\n    }\n\n    mov_estimate_video_delay(mov, st);\n}\n\nstatic int test_same_origin(const char *src, const char *ref) {\n    char src_proto[64];\n    char ref_proto[64];\n    char src_auth[256];\n    char ref_auth[256];\n    char src_host[256];\n    char ref_host[256];\n    int src_port=-1;\n    int ref_port=-1;\n\n    av_url_split(src_proto, sizeof(src_proto), src_auth, sizeof(src_auth), src_host, sizeof(src_host), &src_port, NULL, 0, src);\n    av_url_split(ref_proto, sizeof(ref_proto), ref_auth, sizeof(ref_auth), ref_host, sizeof(ref_host), &ref_port, NULL, 0, ref);\n\n    if (strlen(src) == 0) {\n        return -1;\n    } else if (strlen(src_auth) + 1 >= sizeof(src_auth) ||\n        strlen(ref_auth) + 1 >= sizeof(ref_auth) ||\n        strlen(src_host) + 1 >= sizeof(src_host) ||\n        strlen(ref_host) + 1 >= sizeof(ref_host)) {\n        return 0;\n    } else if (strcmp(src_proto, ref_proto) ||\n               strcmp(src_auth, ref_auth) ||\n               strcmp(src_host, ref_host) ||\n               src_port != ref_port) {\n        return 0;\n    } else\n        return 1;\n}\n\nstatic int mov_open_dref(MOVContext *c, AVIOContext **pb, const char *src, MOVDref *ref)\n{\n    /* try relative path, we do not try the absolute because it can leak information about our\n       system to an attacker */\n    if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n        char filename[1025];\n        const char *src_path;\n        int i, l;\n\n        /* find a source dir */\n        src_path = strrchr(src, '/');\n        if (src_path)\n            src_path++;\n        else\n            src_path = src;\n\n        /* find a next level down to target */\n        for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n            if (ref->path[l] == '/') {\n                if (i == ref->nlvl_to - 1)\n                    break;\n                else\n                    i++;\n            }\n\n        /* compose filename if next level down to target was found */\n        if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n            memcpy(filename, src, src_path - src);\n            filename[src_path - src] = 0;\n\n            for (i = 1; i < ref->nlvl_from; i++)\n                av_strlcat(filename, \"../\", sizeof(filename));\n\n            av_strlcat(filename, ref->path + l + 1, sizeof(filename));\n            if (!c->use_absolute_path) {\n                int same_origin = test_same_origin(src, filename);\n\n                if (!same_origin) {\n                    av_log(c->fc, AV_LOG_ERROR,\n                        \"Reference with mismatching origin, %s not tried for security reasons, \"\n                        \"set demuxer option use_absolute_path to allow it anyway\\n\",\n                        ref->path);\n                    return AVERROR(ENOENT);\n                }\n\n                if (strstr(ref->path + l + 1, \"..\") ||\n                    strstr(ref->path + l + 1, \":\") ||\n                    (ref->nlvl_from > 1 && same_origin < 0) ||\n                    (filename[0] == '/' && src_path == src))\n                    return AVERROR(ENOENT);\n            }\n\n            if (strlen(filename) + 1 == sizeof(filename))\n                return AVERROR(ENOENT);\n            if (!c->fc->io_open(c->fc, pb, filename, AVIO_FLAG_READ, NULL))\n                return 0;\n        }\n    } else if (c->use_absolute_path) {\n        av_log(c->fc, AV_LOG_WARNING, \"Using absolute path on user request, \"\n               \"this is a possible security issue\\n\");\n        if (!c->fc->io_open(c->fc, pb, ref->path, AVIO_FLAG_READ, NULL))\n            return 0;\n    } else {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Absolute path %s not tried for security reasons, \"\n               \"set demuxer option use_absolute_path to allow absolute paths\\n\",\n               ref->path);\n    }\n\n    return AVERROR(ENOENT);\n}\n\nstatic void fix_timescale(MOVContext *c, MOVStreamContext *sc)\n{\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"stream %d, timescale not set\\n\", sc->ffindex);\n        sc->time_scale = c->time_scale;\n        if (sc->time_scale <= 0)\n            sc->time_scale = 1;\n    }\n}\n\nstatic int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret;\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st) return AVERROR(ENOMEM);\n    st->id = -1;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc) return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n    sc->ffindex = st->index;\n    c->trak_index = st->index;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n\n    c->trak_index = -1;\n\n    // Here stsc refers to a chunk not described in stco. This is technically invalid,\n    // but we can overlook it (clearing stsc) whenever stts_count == 0 (indicating no samples).\n    if (!sc->chunk_count && !sc->stts_count && sc->stsc_count) {\n        sc->stsc_count = 0;\n        av_freep(&sc->stsc_data);\n    }\n\n    /* sanity checks */\n    if ((sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n                            (!sc->sample_size && !sc->sample_count))) ||\n        (!sc->chunk_count && sc->sample_count)) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n               st->index);\n        return 0;\n    }\n    if (sc->stsc_count && sc->stsc_data[ sc->stsc_count - 1 ].first > sc->chunk_count) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, contradictionary STSC and STCO\\n\",\n               st->index);\n        return AVERROR_INVALIDDATA;\n    }\n\n    fix_timescale(c, sc);\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n    mov_build_index(c, st);\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n        if (c->enable_drefs) {\n            if (mov_open_dref(c, &sc->pb, c->fc->url, dref) < 0)\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"stream %d, error opening alias: path='%s', dir='%s', \"\n                       \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n                       st->index, dref->path, dref->dir, dref->filename,\n                       dref->volume, dref->nlvl_from, dref->nlvl_to);\n        } else {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Skipped opening external track: \"\n                   \"stream %d, alias: path='%s', dir='%s', \"\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d.\"\n                   \"Set enable_drefs to allow this.\\n\",\n                   st->index, dref->path, dref->dir, dref->filename,\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n        }\n    } else {\n        sc->pb = c->fc->pb;\n        sc->pb_is_copied = 1;\n    }\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (!st->sample_aspect_ratio.num && st->codecpar->width && st->codecpar->height &&\n            sc->height && sc->width &&\n            (st->codecpar->width != sc->width || st->codecpar->height != sc->height)) {\n            st->sample_aspect_ratio = av_d2q(((double)st->codecpar->height * sc->width) /\n                                             ((double)st->codecpar->width * sc->height), INT_MAX);\n        }\n\n#if FF_API_R_FRAME_RATE\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n#endif\n    }\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n    if (!st->codecpar->extradata_size && st->codecpar->codec_id == AV_CODEC_ID_H264 &&\n        TAG_IS_AVCI(st->codecpar->codec_tag)) {\n        ret = ff_generate_avci_extradata(st);\n        if (ret < 0)\n            return ret;\n    }\n\n    switch (st->codecpar->codec_id) {\n#if CONFIG_H261_DECODER\n    case AV_CODEC_ID_H261:\n#endif\n#if CONFIG_H263_DECODER\n    case AV_CODEC_ID_H263:\n#endif\n#if CONFIG_MPEG4_DECODER\n    case AV_CODEC_ID_MPEG4:\n#endif\n        st->codecpar->width = 0; /* let decoder init width/height */\n        st->codecpar->height= 0;\n        break;\n    }\n\n    // If the duration of the mp3 packets is not constant, then they could need a parser\n    if (st->codecpar->codec_id == AV_CODEC_ID_MP3\n        && sc->stts_count > 3\n        && sc->stts_count*10 > st->nb_frames\n        && sc->time_scale == st->codecpar->sample_rate) {\n            ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n    }\n    /* Do not need those anymore. */\n    av_freep(&sc->chunk_offsets);\n    av_freep(&sc->sample_sizes);\n    av_freep(&sc->keyframes);\n    av_freep(&sc->stts_data);\n    av_freep(&sc->stps_data);\n    av_freep(&sc->elst_data);\n    av_freep(&sc->rap_group);\n    av_freep(&sc->sync_group);\n    av_freep(&sc->sgpd_sync);\n\n    return 0;\n}\n\nstatic int mov_read_ilst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    c->itunes_metadata = 1;\n    ret = mov_read_default(c, pb, atom);\n    c->itunes_metadata = 0;\n    return ret;\n}\n\nstatic int mov_read_keys(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t count;\n    uint32_t i;\n\n    if (atom.size < 8)\n        return 0;\n\n    avio_skip(pb, 4);\n    count = avio_rb32(pb);\n    if (count > UINT_MAX / sizeof(*c->meta_keys) - 1) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"The 'keys' atom with the invalid key count: %\"PRIu32\"\\n\", count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->meta_keys_count = count + 1;\n    c->meta_keys = av_mallocz(c->meta_keys_count * sizeof(*c->meta_keys));\n    if (!c->meta_keys)\n        return AVERROR(ENOMEM);\n\n    for (i = 1; i <= count; ++i) {\n        uint32_t key_size = avio_rb32(pb);\n        uint32_t type = avio_rl32(pb);\n        if (key_size < 8) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"The key# %\"PRIu32\" in meta has invalid size:\"\n                   \"%\"PRIu32\"\\n\", i, key_size);\n            return AVERROR_INVALIDDATA;\n        }\n        key_size -= 8;\n        if (type != MKTAG('m','d','t','a')) {\n            avio_skip(pb, key_size);\n        }\n        c->meta_keys[i] = av_mallocz(key_size + 1);\n        if (!c->meta_keys[i])\n            return AVERROR(ENOMEM);\n        avio_read(pb, c->meta_keys[i], key_size);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_custom(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t end = av_sat_add64(avio_tell(pb), atom.size);\n    uint8_t *key = NULL, *val = NULL, *mean = NULL;\n    int i;\n    int ret = 0;\n    AVStream *st;\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (i = 0; i < 3; i++) {\n        uint8_t **p;\n        uint32_t len, tag;\n\n        if (end - avio_tell(pb) <= 12)\n            break;\n\n        len = avio_rb32(pb);\n        tag = avio_rl32(pb);\n        avio_skip(pb, 4); // flags\n\n        if (len < 12 || len - 12 > end - avio_tell(pb))\n            break;\n        len -= 12;\n\n        if (tag == MKTAG('m', 'e', 'a', 'n'))\n            p = &mean;\n        else if (tag == MKTAG('n', 'a', 'm', 'e'))\n            p = &key;\n        else if (tag == MKTAG('d', 'a', 't', 'a') && len > 4) {\n            avio_skip(pb, 4);\n            len -= 4;\n            p = &val;\n        } else\n            break;\n\n        if (*p)\n            break;\n\n        *p = av_malloc(len + 1);\n        if (!*p) {\n            ret = AVERROR(ENOMEM);\n            break;\n        }\n        ret = ffio_read_size(pb, *p, len);\n        if (ret < 0) {\n            av_freep(p);\n            break;\n        }\n        (*p)[len] = 0;\n    }\n\n    if (mean && key && val) {\n        if (strcmp(key, \"iTunSMPB\") == 0) {\n            int priming, remainder, samples;\n            if(sscanf(val, \"%*X %X %X %X\", &priming, &remainder, &samples) == 3){\n                if(priming>0 && priming<16384)\n                    sc->start_pad = priming;\n            }\n        }\n        if (strcmp(key, \"cdec\") != 0) {\n            av_dict_set(&c->fc->metadata, key, val,\n                        AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n            key = val = NULL;\n        }\n    } else {\n        av_log(c->fc, AV_LOG_VERBOSE,\n               \"Unhandled or malformed custom metadata of size %\"PRId64\"\\n\", atom.size);\n    }\n\n    avio_seek(pb, end, SEEK_SET);\n    av_freep(&key);\n    av_freep(&val);\n    av_freep(&mean);\n    return ret;\n}\n\nstatic int avif_add_stream(MOVContext *c, int item_id)\n{\n    MOVStreamContext *sc;\n    AVStream *st;\n    int item_index = -1;\n    for (int i = 0; i < c->avif_info_size; i++)\n        if (c->avif_info[i].item_id == item_id) {\n            item_index = i;\n            break;\n        }\n    if (item_index < 0)\n        return AVERROR_INVALIDDATA;\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->id = c->fc->nb_streams;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc)\n        return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id = AV_CODEC_ID_AV1;\n    sc->ffindex = st->index;\n    c->trak_index = st->index;\n    st->avg_frame_rate.num = st->avg_frame_rate.den = 1;\n    st->time_base.num = st->time_base.den = 1;\n    st->nb_frames = 1;\n    sc->time_scale = 1;\n    sc = st->priv_data;\n    sc->pb = c->fc->pb;\n    sc->pb_is_copied = 1;\n\n    // Populate the necessary fields used by mov_build_index.\n    sc->stsc_count = 1;\n    sc->stsc_data = av_malloc_array(1, sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n    sc->stsc_data[0].first = 1;\n    sc->stsc_data[0].count = 1;\n    sc->stsc_data[0].id = 1;\n    sc->chunk_count = 1;\n    sc->chunk_offsets = av_malloc_array(1, sizeof(*sc->chunk_offsets));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->sample_count = 1;\n    sc->sample_sizes = av_malloc_array(1, sizeof(*sc->sample_sizes));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n    sc->stts_count = 1;\n    sc->stts_data = av_malloc_array(1, sizeof(*sc->stts_data));\n    if (!sc->stts_data)\n        return AVERROR(ENOMEM);\n    sc->stts_data[0].count = 1;\n    // Not used for still images. But needed by mov_build_index.\n    sc->stts_data[0].duration = 0;\n    sc->sample_sizes[0] = c->avif_info[item_index].extent_length;\n    sc->chunk_offsets[0] = c->avif_info[item_index].extent_offset;\n\n    mov_build_index(c, st);\n    return 0;\n}\n\nstatic int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    while (atom.size > 8) {\n        uint32_t tag;\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        tag = avio_rl32(pb);\n        atom.size -= 4;\n        if (tag == MKTAG('h','d','l','r')) {\n            int ret;\n            avio_seek(pb, -8, SEEK_CUR);\n            atom.size += 8;\n            if ((ret = mov_read_default(c, pb, atom)) < 0)\n                return ret;\n            if (c->is_still_picture_avif) {\n                int ret;\n                // Add a stream for the YUV planes (primary item).\n                if ((ret = avif_add_stream(c, c->primary_item_id)) < 0)\n                    return ret;\n                // For still AVIF images, the meta box contains all the\n                // necessary information that would generally be provided by the\n                // moov box. So simply mark that we have found the moov box so\n                // that parsing can continue.\n                c->found_moov = 1;\n            }\n            return ret;\n        }\n    }\n    return 0;\n}\n\n// return 1 when matrix is identity, 0 otherwise\n#define IS_MATRIX_IDENT(matrix)            \\\n    ( (matrix)[0][0] == (1 << 16) &&       \\\n      (matrix)[1][1] == (1 << 16) &&       \\\n      (matrix)[2][2] == (1 << 30) &&       \\\n     !(matrix)[0][1] && !(matrix)[0][2] && \\\n     !(matrix)[1][0] && !(matrix)[1][2] && \\\n     !(matrix)[2][0] && !(matrix)[2][1])\n\nstatic int mov_read_tkhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i, j, e;\n    int width;\n    int height;\n    int display_matrix[3][3];\n    int res_display_matrix[3][3] = { { 0 } };\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    int flags;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    // Each stream (trak) should have exactly 1 tkhd. This catches bad files and\n    // avoids corrupting AVStreams mapped to an earlier tkhd.\n    if (st->id != -1)\n        return AVERROR_INVALIDDATA;\n\n    version = avio_r8(pb);\n    flags = avio_rb24(pb);\n    st->disposition |= (flags & MOV_TKHD_FLAG_ENABLED) ? AV_DISPOSITION_DEFAULT : 0;\n\n    if (version == 1) {\n        avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        avio_rb32(pb); /* creation time */\n        avio_rb32(pb); /* modification time */\n    }\n    st->id = (int)avio_rb32(pb); /* track id (NOT 0 !)*/\n    avio_rb32(pb); /* reserved */\n\n    /* highlevel (considering edits) duration in movie timebase */\n    (version == 1) ? avio_rb64(pb) : avio_rb32(pb);\n    avio_rb32(pb); /* reserved */\n    avio_rb32(pb); /* reserved */\n\n    avio_rb16(pb); /* layer */\n    avio_rb16(pb); /* alternate group */\n    avio_rb16(pb); /* volume */\n    avio_rb16(pb); /* reserved */\n\n    //read in the display matrix (outlined in ISO 14496-12, Section 6.2.2)\n    // they're kept in fixed point format through all calculations\n    // save u,v,z to store the whole matrix in the AV_PKT_DATA_DISPLAYMATRIX\n    // side data, but the scale factor is not needed to calculate aspect ratio\n    for (i = 0; i < 3; i++) {\n        display_matrix[i][0] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][1] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][2] = avio_rb32(pb);   //  2.30 fixed point\n    }\n\n    width = avio_rb32(pb);       // 16.16 fixed point track width\n    height = avio_rb32(pb);      // 16.16 fixed point track height\n    sc->width = width >> 16;\n    sc->height = height >> 16;\n\n    // apply the moov display matrix (after the tkhd one)\n    for (i = 0; i < 3; i++) {\n        const int sh[3] = { 16, 16, 30 };\n        for (j = 0; j < 3; j++) {\n            for (e = 0; e < 3; e++) {\n                res_display_matrix[i][j] +=\n                    ((int64_t) display_matrix[i][e] *\n                     c->movie_display_matrix[e][j]) >> sh[e];\n            }\n        }\n    }\n\n    // save the matrix when it is not the default identity\n    if (!IS_MATRIX_IDENT(res_display_matrix)) {\n        av_freep(&sc->display_matrix);\n        sc->display_matrix = av_malloc(sizeof(int32_t) * 9);\n        if (!sc->display_matrix)\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < 3; i++)\n            for (j = 0; j < 3; j++)\n                sc->display_matrix[i * 3 + j] = res_display_matrix[i][j];\n    }\n\n    // transform the display width/height according to the matrix\n    // to keep the same scale, use [width height 1<<16]\n    if (width && height && sc->display_matrix) {\n        double disp_transform[2];\n\n        for (i = 0; i < 2; i++)\n            disp_transform[i] = hypot(sc->display_matrix[0 + i],\n                                      sc->display_matrix[3 + i]);\n\n        if (disp_transform[0] > 1       && disp_transform[1] > 1 &&\n            disp_transform[0] < (1<<24) && disp_transform[1] < (1<<24) &&\n            fabs((disp_transform[0] / disp_transform[1]) - 1.0) > 0.01)\n            st->sample_aspect_ratio = av_d2q(\n                disp_transform[0] / disp_transform[1],\n                INT_MAX);\n    }\n    return 0;\n}\n\nstatic int mov_read_tfhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    MOVTrackExt *trex = NULL;\n    int flags, track_id, i;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    track_id = avio_rb32(pb);\n    if (!track_id)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < c->trex_count; i++)\n        if (c->trex_data[i].track_id == track_id) {\n            trex = &c->trex_data[i];\n            break;\n        }\n    if (!trex) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding trex (id %u)\\n\", track_id);\n        return 0;\n    }\n    c->fragment.found_tfhd = 1;\n    frag->track_id = track_id;\n    set_frag_stream(&c->frag_index, track_id);\n\n    frag->base_data_offset = flags & MOV_TFHD_BASE_DATA_OFFSET ?\n                             avio_rb64(pb) : flags & MOV_TFHD_DEFAULT_BASE_IS_MOOF ?\n                             frag->moof_offset : frag->implicit_offset;\n    frag->stsd_id  = flags & MOV_TFHD_STSD_ID ? avio_rb32(pb) : trex->stsd_id;\n\n    frag->duration = flags & MOV_TFHD_DEFAULT_DURATION ?\n                     avio_rb32(pb) : trex->duration;\n    frag->size     = flags & MOV_TFHD_DEFAULT_SIZE ?\n                     avio_rb32(pb) : trex->size;\n    frag->flags    = flags & MOV_TFHD_DEFAULT_FLAGS ?\n                     avio_rb32(pb) : trex->flags;\n    av_log(c->fc, AV_LOG_TRACE, \"frag flags 0x%x\\n\", frag->flags);\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info)\n        frag_stream_info->next_trun_dts = AV_NOPTS_VALUE;\n\n    return 0;\n}\n\nstatic int mov_read_chap(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    unsigned i, num;\n    void *new_tracks;\n\n    num = atom.size / 4;\n    if (!(new_tracks = av_malloc_array(num, sizeof(int))))\n        return AVERROR(ENOMEM);\n\n    av_free(c->chapter_tracks);\n    c->chapter_tracks = new_tracks;\n    c->nb_chapter_tracks = num;\n\n    for (i = 0; i < num && !pb->eof_reached; i++)\n        c->chapter_tracks[i] = avio_rb32(pb);\n\n    c->nb_chapter_tracks = i;\n\n    return 0;\n}\n\nstatic int mov_read_trex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVTrackExt *trex;\n    int err;\n\n    if ((uint64_t)c->trex_count+1 >= UINT_MAX / sizeof(*c->trex_data))\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp_array(&c->trex_data, c->trex_count + 1,\n                                 sizeof(*c->trex_data))) < 0) {\n        c->trex_count = 0;\n        return err;\n    }\n\n    c->fc->duration = AV_NOPTS_VALUE; // the duration from mvhd is not representing the whole file when fragments are used.\n\n    trex = &c->trex_data[c->trex_count++];\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    trex->track_id = avio_rb32(pb);\n    trex->stsd_id  = avio_rb32(pb);\n    trex->duration = avio_rb32(pb);\n    trex->size     = avio_rb32(pb);\n    trex->flags    = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_tfdt(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    int version, i;\n    MOVFragmentStreamInfo * frag_stream_info;\n    int64_t base_media_decode_time;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return 0;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id + 1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    if (version) {\n        base_media_decode_time = avio_rb64(pb);\n    } else {\n        base_media_decode_time = avio_rb32(pb);\n    }\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info)\n        frag_stream_info->tfdt_dts = base_media_decode_time;\n    sc->track_end = base_media_decode_time;\n\n    return 0;\n}\n\nstatic int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    FFStream *sti = NULL;\n    MOVStreamContext *sc;\n    MOVCtts *ctts_data;\n    uint64_t offset;\n    int64_t dts, pts = AV_NOPTS_VALUE;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i;\n    int64_t prev_dts = AV_NOPTS_VALUE;\n    int next_frag_index = -1, index_entry_pos;\n    size_t requested_size;\n    size_t old_ctts_allocated_size;\n    AVIndexEntry *new_entries;\n    MOVFragmentStreamInfo * frag_stream_info;\n\n    if (!frag->found_tfhd) {\n        av_log(c->fc, AV_LOG_ERROR, \"trun track id unknown, no tfhd was found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            sti = ffstream(st);\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return 0;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n\n    // Find the next frag_index index that has a valid index_entry for\n    // the current track_id.\n    //\n    // A valid index_entry means the trun for the fragment was read\n    // and it's samples are in index_entries at the given position.\n    // New index entries will be inserted before the index_entry found.\n    index_entry_pos = sti->nb_index_entries;\n    for (i = c->frag_index.current + 1; i < c->frag_index.nb_items; i++) {\n        frag_stream_info = get_frag_stream_info(&c->frag_index, i, frag->track_id);\n        if (frag_stream_info && frag_stream_info->index_entry >= 0) {\n            next_frag_index = i;\n            index_entry_pos = frag_stream_info->index_entry;\n            break;\n        }\n    }\n    av_assert0(index_entry_pos <= sti->nb_index_entries);\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_log(c->fc, AV_LOG_TRACE, \"flags 0x%x entries %u\\n\", flags, entries);\n\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info) {\n        if (frag_stream_info->next_trun_dts != AV_NOPTS_VALUE) {\n            dts = frag_stream_info->next_trun_dts - sc->time_offset;\n        } else if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE &&\n            c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n            pts = frag_stream_info->first_tfra_pts;\n            av_log(c->fc, AV_LOG_DEBUG, \"found mfra time %\"PRId64\n                    \", using it for pts\\n\", pts);\n        } else if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE &&\n            c->use_mfra_for == FF_MOV_FLAG_MFRA_DTS) {\n            dts = frag_stream_info->first_tfra_pts;\n            av_log(c->fc, AV_LOG_DEBUG, \"found mfra time %\"PRId64\n                    \", using it for dts\\n\", pts);\n        } else {\n            int has_tfdt = frag_stream_info->tfdt_dts != AV_NOPTS_VALUE;\n            int has_sidx = frag_stream_info->sidx_pts != AV_NOPTS_VALUE;\n            int fallback_tfdt = !c->use_tfdt && !has_sidx && has_tfdt;\n            int fallback_sidx =  c->use_tfdt && !has_tfdt && has_sidx;\n\n            if (fallback_sidx) {\n                av_log(c->fc, AV_LOG_DEBUG, \"use_tfdt set but no tfdt found, using sidx instead\\n\");\n            }\n            if (fallback_tfdt) {\n                av_log(c->fc, AV_LOG_DEBUG, \"use_tfdt not set but no sidx found, using tfdt instead\\n\");\n            }\n\n            if (has_tfdt && c->use_tfdt || fallback_tfdt) {\n                dts = frag_stream_info->tfdt_dts - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found tfdt time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            } else if (has_sidx && !c->use_tfdt || fallback_sidx) {\n                // FIXME: sidx earliest_presentation_time is *PTS*, s.b.\n                // pts = frag_stream_info->sidx_pts;\n                dts = frag_stream_info->sidx_pts - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found sidx time %\"PRId64\n                        \", using it for dts\\n\", frag_stream_info->sidx_pts);\n            } else {\n                dts = sc->track_end - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found track end time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n        }\n    } else {\n        dts = sc->track_end - sc->time_offset;\n        av_log(c->fc, AV_LOG_DEBUG, \"found track end time %\"PRId64\n                \", using it for dts\\n\", dts);\n    }\n    offset   = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_log(c->fc, AV_LOG_TRACE, \"first sample flags 0x%x\\n\", first_sample_flags);\n\n    // realloc space for new index entries\n    if ((uint64_t)sti->nb_index_entries + entries >= UINT_MAX / sizeof(AVIndexEntry)) {\n        entries = UINT_MAX / sizeof(AVIndexEntry) - sti->nb_index_entries;\n        av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n    }\n    if (entries == 0)\n        return 0;\n\n    requested_size = (sti->nb_index_entries + entries) * sizeof(AVIndexEntry);\n    new_entries = av_fast_realloc(sti->index_entries,\n                                  &sti->index_entries_allocated_size,\n                                  requested_size);\n    if (!new_entries)\n        return AVERROR(ENOMEM);\n    sti->index_entries= new_entries;\n\n    requested_size = (sti->nb_index_entries + entries) * sizeof(*sc->ctts_data);\n    old_ctts_allocated_size = sc->ctts_allocated_size;\n    ctts_data = av_fast_realloc(sc->ctts_data, &sc->ctts_allocated_size,\n                                requested_size);\n    if (!ctts_data)\n        return AVERROR(ENOMEM);\n    sc->ctts_data = ctts_data;\n\n    // In case there were samples without ctts entries, ensure they get\n    // zero valued entries. This ensures clips which mix boxes with and\n    // without ctts entries don't pickup uninitialized data.\n    memset((uint8_t*)(sc->ctts_data) + old_ctts_allocated_size, 0,\n           sc->ctts_allocated_size - old_ctts_allocated_size);\n\n    if (index_entry_pos < sti->nb_index_entries) {\n        // Make hole in index_entries and ctts_data for new samples\n        memmove(sti->index_entries + index_entry_pos + entries,\n                sti->index_entries + index_entry_pos,\n                sizeof(*sti->index_entries) *\n                (sti->nb_index_entries - index_entry_pos));\n        memmove(sc->ctts_data + index_entry_pos + entries,\n                sc->ctts_data + index_entry_pos,\n                sizeof(*sc->ctts_data) * (sc->ctts_count - index_entry_pos));\n        if (index_entry_pos < sc->current_sample) {\n            sc->current_sample += entries;\n        }\n    }\n\n    sti->nb_index_entries += entries;\n    sc->ctts_count = sti->nb_index_entries;\n\n    // Record the index_entry position in frag_index of this fragment\n    if (frag_stream_info) {\n        frag_stream_info->index_entry = index_entry_pos;\n        if (frag_stream_info->index_base < 0)\n            frag_stream_info->index_base = index_entry_pos;\n    }\n\n    if (index_entry_pos > 0)\n        prev_dts = sti->index_entries[index_entry_pos-1].timestamp;\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        unsigned ctts_duration = 0;\n        int keyframe = 0;\n        int index_entry_flags = 0;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      ctts_duration   = avio_rb32(pb);\n\n        mov_update_dts_shift(sc, ctts_duration, c->fc);\n        if (pts != AV_NOPTS_VALUE) {\n            dts = pts - sc->dts_shift;\n            if (flags & MOV_TRUN_SAMPLE_CTS) {\n                dts -= ctts_duration;\n            } else {\n                dts -= sc->time_offset;\n            }\n            av_log(c->fc, AV_LOG_DEBUG,\n                   \"pts %\"PRId64\" calculated dts %\"PRId64\n                   \" sc->dts_shift %d ctts.duration %d\"\n                   \" sc->time_offset %\"PRId64\n                   \" flags & MOV_TRUN_SAMPLE_CTS %d\\n\",\n                   pts, dts,\n                   sc->dts_shift, ctts_duration,\n                   sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n            pts = AV_NOPTS_VALUE;\n        }\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else\n            keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe) {\n            distance = 0;\n            index_entry_flags |= AVINDEX_KEYFRAME;\n        }\n        // Fragments can overlap in time.  Discard overlapping frames after\n        // decoding.\n        if (prev_dts >= dts)\n            index_entry_flags |= AVINDEX_DISCARD_FRAME;\n\n        sti->index_entries[index_entry_pos].pos   = offset;\n        sti->index_entries[index_entry_pos].timestamp = dts;\n        sti->index_entries[index_entry_pos].size  = sample_size;\n        sti->index_entries[index_entry_pos].min_distance = distance;\n        sti->index_entries[index_entry_pos].flags = index_entry_flags;\n\n        sc->ctts_data[index_entry_pos].count = 1;\n        sc->ctts_data[index_entry_pos].duration = ctts_duration;\n        index_entry_pos++;\n\n        av_log(c->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %u, distance %d, keyframe %d\\n\", st->index,\n                index_entry_pos, offset, dts, sample_size, distance, keyframe);\n        distance++;\n        if (av_sat_add64(dts, sample_duration) != dts + (uint64_t)sample_duration)\n            return AVERROR_INVALIDDATA;\n        if (!sample_size)\n            return AVERROR_INVALIDDATA;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n\n        if (sample_duration <= INT64_MAX - sc->duration_for_fps &&\n            1 <= INT_MAX - sc->nb_frames_for_fps\n        ) {\n            sc->duration_for_fps += sample_duration;\n            sc->nb_frames_for_fps ++;\n        }\n    }\n    if (frag_stream_info)\n        frag_stream_info->next_trun_dts = dts + sc->time_offset;\n    if (i < entries) {\n        // EOF found before reading all entries.  Fix the hole this would\n        // leave in index_entries and ctts_data\n        int gap = entries - i;\n        memmove(sti->index_entries + index_entry_pos,\n                sti->index_entries + index_entry_pos + gap,\n                sizeof(*sti->index_entries) *\n                (sti->nb_index_entries - (index_entry_pos + gap)));\n        memmove(sc->ctts_data + index_entry_pos,\n                sc->ctts_data + index_entry_pos + gap,\n                sizeof(*sc->ctts_data) *\n                (sc->ctts_count - (index_entry_pos + gap)));\n\n        sti->nb_index_entries -= gap;\n        sc->ctts_count -= gap;\n        if (index_entry_pos < sc->current_sample) {\n            sc->current_sample -= gap;\n        }\n        entries = i;\n    }\n\n    // The end of this new fragment may overlap in time with the start\n    // of the next fragment in index_entries. Mark the samples in the next\n    // fragment that overlap with AVINDEX_DISCARD_FRAME\n    prev_dts = AV_NOPTS_VALUE;\n    if (index_entry_pos > 0)\n        prev_dts = sti->index_entries[index_entry_pos-1].timestamp;\n    for (int i = index_entry_pos; i < sti->nb_index_entries; i++) {\n        if (prev_dts < sti->index_entries[i].timestamp)\n            break;\n        sti->index_entries[i].flags |= AVINDEX_DISCARD_FRAME;\n    }\n\n    // If a hole was created to insert the new index_entries into,\n    // the index_entry recorded for all subsequent moof must\n    // be incremented by the number of entries inserted.\n    fix_frag_index_entries(&c->frag_index, next_frag_index,\n                           frag->track_id, entries);\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted TRUN atom\\n\");\n        return AVERROR_EOF;\n    }\n\n    frag->implicit_offset = offset;\n\n    sc->track_end = dts + sc->time_offset;\n    if (st->duration < sc->track_end)\n        st->duration = sc->track_end;\n\n    return 0;\n}\n\nstatic int mov_read_sidx(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t stream_size = avio_size(pb);\n    int64_t offset = av_sat_add64(avio_tell(pb), atom.size), pts, timestamp;\n    uint8_t version, is_complete;\n    int64_t offadd;\n    unsigned i, j, track_id, item_count;\n    AVStream *st = NULL;\n    AVStream *ref_st = NULL;\n    MOVStreamContext *sc, *ref_sc = NULL;\n    AVRational timescale;\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"sidx version %u\", version);\n        return 0;\n    }\n\n    avio_rb24(pb); // flags\n\n    track_id = avio_rb32(pb); // Reference ID\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %d\\n\", track_id);\n        return 0;\n    }\n\n    sc = st->priv_data;\n\n    timescale = av_make_q(1, avio_rb32(pb));\n\n    if (timescale.den <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sidx timescale 1/%d\\n\", timescale.den);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (version == 0) {\n        pts = avio_rb32(pb);\n        offadd= avio_rb32(pb);\n    } else {\n        pts = avio_rb64(pb);\n        offadd= avio_rb64(pb);\n    }\n    if (av_sat_add64(offset, offadd) != offset + (uint64_t)offadd)\n        return AVERROR_INVALIDDATA;\n\n    offset += (uint64_t)offadd;\n\n    avio_rb16(pb); // reserved\n\n    item_count = avio_rb16(pb);\n    if (item_count == 0)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < item_count; i++) {\n        int index;\n        MOVFragmentStreamInfo * frag_stream_info;\n        uint32_t size = avio_rb32(pb);\n        uint32_t duration = avio_rb32(pb);\n        if (size & 0x80000000) {\n            avpriv_request_sample(c->fc, \"sidx reference_type 1\");\n            return AVERROR_PATCHWELCOME;\n        }\n        avio_rb32(pb); // sap_flags\n        timestamp = av_rescale_q(pts, timescale, st->time_base);\n\n        index = update_frag_index(c, offset);\n        frag_stream_info = get_frag_stream_info(&c->frag_index, index, track_id);\n        if (frag_stream_info)\n            frag_stream_info->sidx_pts = timestamp;\n\n        if (av_sat_add64(offset, size) != offset + (uint64_t)size ||\n            av_sat_add64(pts, duration) != pts + (uint64_t)duration\n        )\n            return AVERROR_INVALIDDATA;\n        offset += size;\n        pts += duration;\n    }\n\n    st->duration = sc->track_end = pts;\n\n    sc->has_sidx = 1;\n\n    // See if the remaining bytes are just an mfra which we can ignore.\n    is_complete = offset == stream_size;\n    if (!is_complete && (pb->seekable & AVIO_SEEKABLE_NORMAL) && stream_size > 0 ) {\n        int64_t ret;\n        int64_t original_pos = avio_tell(pb);\n        if (!c->have_read_mfra_size) {\n            if ((ret = avio_seek(pb, stream_size - 4, SEEK_SET)) < 0)\n                return ret;\n            c->mfra_size = avio_rb32(pb);\n            c->have_read_mfra_size = 1;\n            if ((ret = avio_seek(pb, original_pos, SEEK_SET)) < 0)\n                return ret;\n        }\n        if (offset == stream_size - c->mfra_size)\n            is_complete = 1;\n    }\n\n    if (is_complete) {\n        // Find first entry in fragment index that came from an sidx.\n        // This will pretty much always be the first entry.\n        for (i = 0; i < c->frag_index.nb_items; i++) {\n            MOVFragmentIndexItem * item = &c->frag_index.item[i];\n            for (j = 0; ref_st == NULL && j < item->nb_stream_info; j++) {\n                MOVFragmentStreamInfo * si;\n                si = &item->stream_info[j];\n                if (si->sidx_pts != AV_NOPTS_VALUE) {\n                    ref_st = c->fc->streams[j];\n                    ref_sc = ref_st->priv_data;\n                    break;\n                }\n            }\n        }\n        if (ref_st) for (i = 0; i < c->fc->nb_streams; i++) {\n            st = c->fc->streams[i];\n            sc = st->priv_data;\n            if (!sc->has_sidx) {\n                st->duration = sc->track_end = av_rescale(ref_st->duration, sc->time_scale, ref_sc->time_scale);\n            }\n        }\n\n        c->frag_index.complete = 1;\n    }\n\n    return 0;\n}\n\n/* this atom should be null (from specs), but some buggy files put the 'moov' atom inside it... */\n/* like the files created with Adobe Premiere 5.0, for samples see */\n/* http://graphics.tudelft.nl/~wouter/publications/soundtests/ */\nstatic int mov_read_wide(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int err;\n\n    if (atom.size < 8)\n        return 0; /* continue */\n    if (avio_rb32(pb) != 0) { /* 0 sized mdat atom... use the 'wide' atom size */\n        avio_skip(pb, atom.size - 4);\n        return 0;\n    }\n    atom.type = avio_rl32(pb);\n    atom.size -= 8;\n    if (atom.type != MKTAG('m','d','a','t')) {\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n    err = mov_read_mdat(c, pb, atom);\n    return err;\n}\n\nstatic int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#if CONFIG_ZLIB\n    FFIOContext ctx;\n    uint8_t *cmov_data;\n    uint8_t *moov_data; /* uncompressed data */\n    long cmov_len, moov_len;\n    int ret = -1;\n\n    avio_rb32(pb); /* dcom atom */\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n        return AVERROR_INVALIDDATA;\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_rb32(pb); /* cmvd atom */\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n        return AVERROR_INVALIDDATA;\n    moov_len = avio_rb32(pb); /* uncompressed size */\n    cmov_len = atom.size - 6 * 4;\n\n    cmov_data = av_malloc(cmov_len);\n    if (!cmov_data)\n        return AVERROR(ENOMEM);\n    moov_data = av_malloc(moov_len);\n    if (!moov_data) {\n        av_free(cmov_data);\n        return AVERROR(ENOMEM);\n    }\n    ret = ffio_read_size(pb, cmov_data, cmov_len);\n    if (ret < 0)\n        goto free_and_return;\n\n    ret = AVERROR_INVALIDDATA;\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n        goto free_and_return;\n    ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL);\n    ctx.pub.seekable = AVIO_SEEKABLE_NORMAL;\n    atom.type = MKTAG('m','o','o','v');\n    atom.size = moov_len;\n    ret = mov_read_default(c, &ctx.pub, atom);\nfree_and_return:\n    av_free(moov_data);\n    av_free(cmov_data);\n    return ret;\n#else\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n    return AVERROR(ENOSYS);\n#endif\n}\n\n/* edit list atom */\nstatic int mov_read_elst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, edit_count, version;\n    int64_t elst_entry_size;\n\n    if (c->fc->nb_streams < 1 || c->ignore_editlist)\n        return 0;\n    sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    edit_count = avio_rb32(pb); /* entries */\n    atom.size -= 8;\n\n    elst_entry_size = version == 1 ? 20 : 12;\n    if (atom.size != edit_count * elst_entry_size) {\n        if (c->fc->strict_std_compliance >= FF_COMPLIANCE_STRICT) {\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid edit list entry_count: %d for elst atom of size: %\"PRId64\" bytes.\\n\",\n                   edit_count, atom.size + 8);\n            return AVERROR_INVALIDDATA;\n        } else {\n            edit_count = atom.size / elst_entry_size;\n            if (edit_count * elst_entry_size != atom.size) {\n                av_log(c->fc, AV_LOG_WARNING, \"ELST atom of %\"PRId64\" bytes, bigger than %d entries.\\n\", atom.size, edit_count);\n            }\n        }\n    }\n\n    if (!edit_count)\n        return 0;\n    if (sc->elst_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated ELST atom\\n\");\n    av_free(sc->elst_data);\n    sc->elst_count = 0;\n    sc->elst_data = av_malloc_array(edit_count, sizeof(*sc->elst_data));\n    if (!sc->elst_data)\n        return AVERROR(ENOMEM);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].edit_count = %i\\n\", c->fc->nb_streams - 1, edit_count);\n    for (i = 0; i < edit_count && atom.size > 0 && !pb->eof_reached; i++) {\n        MOVElst *e = &sc->elst_data[i];\n\n        if (version == 1) {\n            e->duration = avio_rb64(pb);\n            e->time     = avio_rb64(pb);\n            atom.size -= 16;\n        } else {\n            e->duration = avio_rb32(pb); /* segment duration */\n            e->time     = (int32_t)avio_rb32(pb); /* media time */\n            atom.size -= 8;\n        }\n        e->rate = avio_rb32(pb) / 65536.0;\n        atom.size -= 4;\n        av_log(c->fc, AV_LOG_TRACE, \"duration=%\"PRId64\" time=%\"PRId64\" rate=%f\\n\",\n               e->duration, e->time, e->rate);\n\n        if (e->time < 0 && e->time != -1 &&\n            c->fc->strict_std_compliance >= FF_COMPLIANCE_STRICT) {\n            av_log(c->fc, AV_LOG_ERROR, \"Track %d, edit %d: Invalid edit list media time=%\"PRId64\"\\n\",\n                   c->fc->nb_streams-1, i, e->time);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    sc->elst_count = i;\n\n    return 0;\n}\n\nstatic int mov_read_tmcd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n    sc->timecode_track = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_vpcc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int version, color_range, color_primaries, color_trc, color_space;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty VP Codec Configuration box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version != 1) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported VP Codec Configuration box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    avio_skip(pb, 2); /* profile + level */\n    color_range     = avio_r8(pb); /* bitDepth, chromaSubsampling, videoFullRangeFlag */\n    color_primaries = avio_r8(pb);\n    color_trc       = avio_r8(pb);\n    color_space     = avio_r8(pb);\n    if (avio_rb16(pb)) /* codecIntializationDataSize */\n        return AVERROR_INVALIDDATA;\n\n    if (!av_color_primaries_name(color_primaries))\n        color_primaries = AVCOL_PRI_UNSPECIFIED;\n    if (!av_color_transfer_name(color_trc))\n        color_trc = AVCOL_TRC_UNSPECIFIED;\n    if (!av_color_space_name(color_space))\n        color_space = AVCOL_SPC_UNSPECIFIED;\n\n    st->codecpar->color_range     = (color_range & 1) ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;\n    st->codecpar->color_primaries = color_primaries;\n    st->codecpar->color_trc       = color_trc;\n    st->codecpar->color_space     = color_space;\n\n    return 0;\n}\n\nstatic int mov_read_smdm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Mastering Display Metadata box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Mastering Display Metadata box version %d\\n\", version);\n        return 0;\n    }\n    if (sc->mastering)\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 3); /* flags */\n\n    sc->mastering = av_mastering_display_metadata_alloc();\n    if (!sc->mastering)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < 3; i++) {\n        sc->mastering->display_primaries[i][0] = av_make_q(avio_rb16(pb), 1 << 16);\n        sc->mastering->display_primaries[i][1] = av_make_q(avio_rb16(pb), 1 << 16);\n    }\n    sc->mastering->white_point[0] = av_make_q(avio_rb16(pb), 1 << 16);\n    sc->mastering->white_point[1] = av_make_q(avio_rb16(pb), 1 << 16);\n\n    sc->mastering->max_luminance = av_make_q(avio_rb32(pb), 1 << 8);\n    sc->mastering->min_luminance = av_make_q(avio_rb32(pb), 1 << 14);\n\n    sc->mastering->has_primaries = 1;\n    sc->mastering->has_luminance = 1;\n\n    return 0;\n}\n\nstatic int mov_read_mdcv(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    const int mapping[3] = {1, 2, 0};\n    const int chroma_den = 50000;\n    const int luma_den = 10000;\n    int i;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 24 || sc->mastering) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid Mastering Display Color Volume box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sc->mastering = av_mastering_display_metadata_alloc();\n    if (!sc->mastering)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < 3; i++) {\n        const int j = mapping[i];\n        sc->mastering->display_primaries[j][0] = av_make_q(avio_rb16(pb), chroma_den);\n        sc->mastering->display_primaries[j][1] = av_make_q(avio_rb16(pb), chroma_den);\n    }\n    sc->mastering->white_point[0] = av_make_q(avio_rb16(pb), chroma_den);\n    sc->mastering->white_point[1] = av_make_q(avio_rb16(pb), chroma_den);\n\n    sc->mastering->max_luminance = av_make_q(avio_rb32(pb), luma_den);\n    sc->mastering->min_luminance = av_make_q(avio_rb32(pb), luma_den);\n\n    sc->mastering->has_luminance = 1;\n    sc->mastering->has_primaries = 1;\n\n    return 0;\n}\n\nstatic int mov_read_coll(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Content Light Level box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Content Light Level box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    if (sc->coll){\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicate COLL\\n\");\n        return 0;\n    }\n\n    sc->coll = av_content_light_metadata_alloc(&sc->coll_size);\n    if (!sc->coll)\n        return AVERROR(ENOMEM);\n\n    sc->coll->MaxCLL  = avio_rb16(pb);\n    sc->coll->MaxFALL = avio_rb16(pb);\n\n    return 0;\n}\n\nstatic int mov_read_clli(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 4) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Content Light Level Info box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->coll){\n        av_log(c->fc, AV_LOG_WARNING, \"Ignoring duplicate CLLI/COLL\\n\");\n        return 0;\n    }\n\n    sc->coll = av_content_light_metadata_alloc(&sc->coll_size);\n    if (!sc->coll)\n        return AVERROR(ENOMEM);\n\n    sc->coll->MaxCLL  = avio_rb16(pb);\n    sc->coll->MaxFALL = avio_rb16(pb);\n\n    return 0;\n}\n\nstatic int mov_read_st3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVStereo3DType type;\n    int mode;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty stereoscopic video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->stereo3d)\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 4); /* version + flags */\n\n    mode = avio_r8(pb);\n    switch (mode) {\n    case 0:\n        type = AV_STEREO3D_2D;\n        break;\n    case 1:\n        type = AV_STEREO3D_TOPBOTTOM;\n        break;\n    case 2:\n        type = AV_STEREO3D_SIDEBYSIDE;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown st3d mode value %d\\n\", mode);\n        return 0;\n    }\n\n    sc->stereo3d = av_stereo3d_alloc();\n    if (!sc->stereo3d)\n        return AVERROR(ENOMEM);\n\n    sc->stereo3d->type = type;\n    return 0;\n}\n\nstatic int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int size, version, layout;\n    int32_t yaw, pitch, roll;\n    uint32_t l = 0, t = 0, r = 0, b = 0;\n    uint32_t tag, padding = 0;\n    enum AVSphericalProjection projection;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 8) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty spherical video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = avio_rb32(pb);\n    if (size <= 12 || size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('s','v','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing spherical video header\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    avio_skip(pb, size - 12); /* metadata_source */\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','o','j')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection box\\n\");\n        return 0;\n    }\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection header box\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    /* 16.16 fixed point */\n    yaw   = avio_rb32(pb);\n    pitch = avio_rb32(pb);\n    roll  = avio_rb32(pb);\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    switch (tag) {\n    case MKTAG('c','b','m','p'):\n        layout = avio_rb32(pb);\n        if (layout) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Unsupported cubemap layout %d\\n\", layout);\n            return 0;\n        }\n        projection = AV_SPHERICAL_CUBEMAP;\n        padding = avio_rb32(pb);\n        break;\n    case MKTAG('e','q','u','i'):\n        t = avio_rb32(pb);\n        b = avio_rb32(pb);\n        l = avio_rb32(pb);\n        r = avio_rb32(pb);\n\n        if (b >= UINT_MAX - t || r >= UINT_MAX - l) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"Invalid bounding rectangle coordinates \"\n                   \"%\"PRIu32\",%\"PRIu32\",%\"PRIu32\",%\"PRIu32\"\\n\", l, t, r, b);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (l || t || r || b)\n            projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE;\n        else\n            projection = AV_SPHERICAL_EQUIRECTANGULAR;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown projection type: %s\\n\", av_fourcc2str(tag));\n        return 0;\n    }\n\n    sc->spherical = av_spherical_alloc(&sc->spherical_size);\n    if (!sc->spherical)\n        return AVERROR(ENOMEM);\n\n    sc->spherical->projection = projection;\n\n    sc->spherical->yaw   = yaw;\n    sc->spherical->pitch = pitch;\n    sc->spherical->roll  = roll;\n\n    sc->spherical->padding = padding;\n\n    sc->spherical->bound_left   = l;\n    sc->spherical->bound_top    = t;\n    sc->spherical->bound_right  = r;\n    sc->spherical->bound_bottom = b;\n\n    return 0;\n}\n\nstatic int mov_parse_uuid_spherical(MOVStreamContext *sc, AVIOContext *pb, size_t len)\n{\n    int ret = 0;\n    uint8_t *buffer = av_malloc(len + 1);\n    const char *val;\n\n    if (!buffer)\n        return AVERROR(ENOMEM);\n    buffer[len] = '\\0';\n\n    ret = ffio_read_size(pb, buffer, len);\n    if (ret < 0)\n        goto out;\n\n    /* Check for mandatory keys and values, try to support XML as best-effort */\n    if (!sc->spherical &&\n        av_stristr(buffer, \"<GSpherical:StitchingSoftware>\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Spherical>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Stitched>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:ProjectionType>\")) &&\n        av_stristr(val, \"equirectangular\")) {\n        sc->spherical = av_spherical_alloc(&sc->spherical_size);\n        if (!sc->spherical)\n            goto out;\n\n        sc->spherical->projection = AV_SPHERICAL_EQUIRECTANGULAR;\n\n        if (av_stristr(buffer, \"<GSpherical:StereoMode>\") && !sc->stereo3d) {\n            enum AVStereo3DType mode;\n\n            if (av_stristr(buffer, \"left-right\"))\n                mode = AV_STEREO3D_SIDEBYSIDE;\n            else if (av_stristr(buffer, \"top-bottom\"))\n                mode = AV_STEREO3D_TOPBOTTOM;\n            else\n                mode = AV_STEREO3D_2D;\n\n            sc->stereo3d = av_stereo3d_alloc();\n            if (!sc->stereo3d)\n                goto out;\n\n            sc->stereo3d->type = mode;\n        }\n\n        /* orientation */\n        val = av_stristr(buffer, \"<GSpherical:InitialViewHeadingDegrees>\");\n        if (val)\n            sc->spherical->yaw = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewPitchDegrees>\");\n        if (val)\n            sc->spherical->pitch = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewRollDegrees>\");\n        if (val)\n            sc->spherical->roll = strtol(val, NULL, 10) * (1 << 16);\n    }\n\nout:\n    av_free(buffer);\n    return ret;\n}\n\nstatic int mov_read_uuid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t ret;\n    AVUUID uuid;\n    static const AVUUID uuid_isml_manifest = {\n        0xa5, 0xd4, 0x0b, 0x30, 0xe8, 0x14, 0x11, 0xdd,\n        0xba, 0x2f, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66\n    };\n    static const AVUUID uuid_xmp = {\n        0xbe, 0x7a, 0xcf, 0xcb, 0x97, 0xa9, 0x42, 0xe8,\n        0x9c, 0x71, 0x99, 0x94, 0x91, 0xe3, 0xaf, 0xac\n    };\n    static const AVUUID uuid_spherical = {\n        0xff, 0xcc, 0x82, 0x63, 0xf8, 0x55, 0x4a, 0x93,\n        0x88, 0x14, 0x58, 0x7a, 0x02, 0x52, 0x1f, 0xdd,\n    };\n\n    if (atom.size < AV_UUID_LEN || atom.size >= FFMIN(INT_MAX, SIZE_MAX))\n        return AVERROR_INVALIDDATA;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    ret = ffio_read_size(pb, uuid, AV_UUID_LEN);\n    if (ret < 0)\n        return ret;\n    if (av_uuid_equal(uuid, uuid_isml_manifest)) {\n        uint8_t *buffer, *ptr;\n        char *endptr;\n        size_t len = atom.size - AV_UUID_LEN;\n\n        if (len < 4) {\n            return AVERROR_INVALIDDATA;\n        }\n        ret = avio_skip(pb, 4); // zeroes\n        len -= 4;\n\n        buffer = av_mallocz(len + 1);\n        if (!buffer) {\n            return AVERROR(ENOMEM);\n        }\n        ret = ffio_read_size(pb, buffer, len);\n        if (ret < 0) {\n            av_free(buffer);\n            return ret;\n        }\n\n        ptr = buffer;\n        while ((ptr = av_stristr(ptr, \"systemBitrate=\\\"\"))) {\n            ptr += sizeof(\"systemBitrate=\\\"\") - 1;\n            c->bitrates_count++;\n            c->bitrates = av_realloc_f(c->bitrates, c->bitrates_count, sizeof(*c->bitrates));\n            if (!c->bitrates) {\n                c->bitrates_count = 0;\n                av_free(buffer);\n                return AVERROR(ENOMEM);\n            }\n            errno = 0;\n            ret = strtol(ptr, &endptr, 10);\n            if (ret < 0 || errno || *endptr != '\"') {\n                c->bitrates[c->bitrates_count - 1] = 0;\n            } else {\n                c->bitrates[c->bitrates_count - 1] = ret;\n            }\n        }\n\n        av_free(buffer);\n    } else if (av_uuid_equal(uuid, uuid_xmp)) {\n        uint8_t *buffer;\n        size_t len = atom.size - AV_UUID_LEN;\n        if (c->export_xmp) {\n            buffer = av_mallocz(len + 1);\n            if (!buffer) {\n                return AVERROR(ENOMEM);\n            }\n            ret = ffio_read_size(pb, buffer, len);\n            if (ret < 0) {\n                av_free(buffer);\n                return ret;\n            }\n            buffer[len] = '\\0';\n            av_dict_set(&c->fc->metadata, \"xmp\",\n                        buffer, AV_DICT_DONT_STRDUP_VAL);\n        } else {\n            // skip all uuid atom, which makes it fast for long uuid-xmp file\n            ret = avio_skip(pb, len);\n            if (ret < 0)\n                return ret;\n        }\n    } else if (av_uuid_equal(uuid, uuid_spherical)) {\n        size_t len = atom.size - AV_UUID_LEN;\n        ret = mov_parse_uuid_spherical(sc, pb, len);\n        if (ret < 0)\n            return ret;\n        if (!sc->spherical)\n            av_log(c->fc, AV_LOG_WARNING, \"Invalid spherical metadata found\\n\");\n    }\n\n    return 0;\n}\n\nstatic int mov_read_free(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    uint8_t content[16];\n\n    if (atom.size < 8)\n        return 0;\n\n    ret = avio_read(pb, content, FFMIN(sizeof(content), atom.size));\n    if (ret < 0)\n        return ret;\n\n    if (   !c->found_moov\n        && !c->found_mdat\n        && !memcmp(content, \"Anevia\\x1A\\x1A\", 8)\n        && c->use_mfra_for == FF_MOV_FLAG_MFRA_AUTO) {\n        c->use_mfra_for = FF_MOV_FLAG_MFRA_PTS;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_frma(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t format = avio_rl32(pb);\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    switch (sc->format)\n    {\n    case MKTAG('e','n','c','v'):        // encrypted video\n    case MKTAG('e','n','c','a'):        // encrypted audio\n        id = mov_codec_id(st, format);\n        if (st->codecpar->codec_id != AV_CODEC_ID_NONE &&\n            st->codecpar->codec_id != id) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream has codec id %d\\n\",\n                   (char*)&format, st->codecpar->codec_id);\n            break;\n        }\n\n        st->codecpar->codec_id = id;\n        sc->format = format;\n        break;\n\n    default:\n        if (format != sc->format) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream format is '%.4s'\\n\",\n                   (char*)&format, (char*)&sc->format);\n        }\n        break;\n    }\n\n    return 0;\n}\n\n/**\n * Gets the current encryption info and associated current stream context.  If\n * we are parsing a track fragment, this will return the specific encryption\n * info for this fragment; otherwise this will return the global encryption\n * info for the current stream.\n */\nstatic int get_current_encryption_info(MOVContext *c, MOVEncryptionIndex **encryption_index, MOVStreamContext **sc)\n{\n    MOVFragmentStreamInfo *frag_stream_info;\n    AVStream *st;\n    int i;\n\n    frag_stream_info = get_current_frag_stream_info(&c->frag_index);\n    if (frag_stream_info) {\n        for (i = 0; i < c->fc->nb_streams; i++) {\n            if (c->fc->streams[i]->id == frag_stream_info->id) {\n              st = c->fc->streams[i];\n              break;\n            }\n        }\n        if (i == c->fc->nb_streams)\n            return 0;\n        *sc = st->priv_data;\n\n        if (!frag_stream_info->encryption_index) {\n            // If this stream isn't encrypted, don't create the index.\n            if (!(*sc)->cenc.default_encrypted_sample)\n                return 0;\n            frag_stream_info->encryption_index = av_mallocz(sizeof(*frag_stream_info->encryption_index));\n            if (!frag_stream_info->encryption_index)\n                return AVERROR(ENOMEM);\n        }\n        *encryption_index = frag_stream_info->encryption_index;\n        return 1;\n    } else {\n        // No current track fragment, using stream level encryption info.\n\n        if (c->fc->nb_streams < 1)\n            return 0;\n        st = c->fc->streams[c->fc->nb_streams - 1];\n        *sc = st->priv_data;\n\n        if (!(*sc)->cenc.encryption_index) {\n            // If this stream isn't encrypted, don't create the index.\n            if (!(*sc)->cenc.default_encrypted_sample)\n                return 0;\n            (*sc)->cenc.encryption_index = av_mallocz(sizeof(*frag_stream_info->encryption_index));\n            if (!(*sc)->cenc.encryption_index)\n                return AVERROR(ENOMEM);\n        }\n\n        *encryption_index = (*sc)->cenc.encryption_index;\n        return 1;\n    }\n}\n\nstatic int mov_read_sample_encryption_info(MOVContext *c, AVIOContext *pb, MOVStreamContext *sc, AVEncryptionInfo **sample, int use_subsamples)\n{\n    int i, ret;\n    unsigned int subsample_count;\n    AVSubsampleEncryptionInfo *subsamples;\n\n    if (!sc->cenc.default_encrypted_sample) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing schm or tenc\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    *sample = av_encryption_info_clone(sc->cenc.default_encrypted_sample);\n    if (!*sample)\n        return AVERROR(ENOMEM);\n\n    if (sc->cenc.per_sample_iv_size != 0) {\n        if ((ret = ffio_read_size(pb, (*sample)->iv, sc->cenc.per_sample_iv_size)) < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"failed to read the initialization vector\\n\");\n            av_encryption_info_free(*sample);\n            *sample = NULL;\n            return ret;\n        }\n    }\n\n    if (use_subsamples) {\n        subsample_count = avio_rb16(pb);\n        av_free((*sample)->subsamples);\n        (*sample)->subsamples = av_calloc(subsample_count, sizeof(*subsamples));\n        if (!(*sample)->subsamples) {\n            av_encryption_info_free(*sample);\n            *sample = NULL;\n            return AVERROR(ENOMEM);\n        }\n\n        for (i = 0; i < subsample_count && !pb->eof_reached; i++) {\n            (*sample)->subsamples[i].bytes_of_clear_data = avio_rb16(pb);\n            (*sample)->subsamples[i].bytes_of_protected_data = avio_rb32(pb);\n        }\n\n        if (pb->eof_reached) {\n            av_log(c->fc, AV_LOG_ERROR, \"hit EOF while reading sub-sample encryption info\\n\");\n            av_encryption_info_free(*sample);\n            *sample = NULL;\n            return AVERROR_INVALIDDATA;\n        }\n        (*sample)->subsample_count = subsample_count;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_senc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVEncryptionInfo **encrypted_samples;\n    MOVEncryptionIndex *encryption_index;\n    MOVStreamContext *sc;\n    int use_subsamples, ret;\n    unsigned int sample_count, i, alloc_size = 0;\n\n    ret = get_current_encryption_info(c, &encryption_index, &sc);\n    if (ret != 1)\n        return ret;\n\n    if (encryption_index->nb_encrypted_samples) {\n        // This can happen if we have both saio/saiz and senc atoms.\n        av_log(c->fc, AV_LOG_DEBUG, \"Ignoring duplicate encryption info in senc\\n\");\n        return 0;\n    }\n\n    avio_r8(pb); /* version */\n    use_subsamples = avio_rb24(pb) & 0x02; /* flags */\n\n    sample_count = avio_rb32(pb);\n    if (sample_count >= INT_MAX / sizeof(*encrypted_samples))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < sample_count; i++) {\n        unsigned int min_samples = FFMIN(FFMAX(i + 1, 1024 * 1024), sample_count);\n        encrypted_samples = av_fast_realloc(encryption_index->encrypted_samples, &alloc_size,\n                                            min_samples * sizeof(*encrypted_samples));\n        if (encrypted_samples) {\n            encryption_index->encrypted_samples = encrypted_samples;\n\n            ret = mov_read_sample_encryption_info(\n                c, pb, sc, &encryption_index->encrypted_samples[i], use_subsamples);\n        } else {\n            ret = AVERROR(ENOMEM);\n        }\n        if (pb->eof_reached) {\n            av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading senc\\n\");\n            if (ret >= 0)\n                av_encryption_info_free(encryption_index->encrypted_samples[i]);\n            ret = AVERROR_INVALIDDATA;\n        }\n\n        if (ret < 0) {\n            for (; i > 0; i--)\n                av_encryption_info_free(encryption_index->encrypted_samples[i - 1]);\n            av_freep(&encryption_index->encrypted_samples);\n            return ret;\n        }\n    }\n    encryption_index->nb_encrypted_samples = sample_count;\n\n    return 0;\n}\n\nstatic int mov_parse_auxiliary_info(MOVContext *c, MOVStreamContext *sc, AVIOContext *pb, MOVEncryptionIndex *encryption_index)\n{\n    AVEncryptionInfo **sample, **encrypted_samples;\n    int64_t prev_pos;\n    size_t sample_count, sample_info_size, i;\n    int ret = 0;\n    unsigned int alloc_size = 0;\n\n    if (encryption_index->nb_encrypted_samples)\n        return 0;\n    sample_count = encryption_index->auxiliary_info_sample_count;\n    if (encryption_index->auxiliary_offsets_count != 1) {\n        av_log(c->fc, AV_LOG_ERROR, \"Multiple auxiliary info chunks are not supported\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    if (sample_count >= INT_MAX / sizeof(*encrypted_samples))\n        return AVERROR(ENOMEM);\n\n    prev_pos = avio_tell(pb);\n    if (!(pb->seekable & AVIO_SEEKABLE_NORMAL) ||\n        avio_seek(pb, encryption_index->auxiliary_offsets[0], SEEK_SET) != encryption_index->auxiliary_offsets[0]) {\n        av_log(c->fc, AV_LOG_INFO, \"Failed to seek for auxiliary info, will only parse senc atoms for encryption info\\n\");\n        goto finish;\n    }\n\n    for (i = 0; i < sample_count && !pb->eof_reached; i++) {\n        unsigned int min_samples = FFMIN(FFMAX(i + 1, 1024 * 1024), sample_count);\n        encrypted_samples = av_fast_realloc(encryption_index->encrypted_samples, &alloc_size,\n                                            min_samples * sizeof(*encrypted_samples));\n        if (!encrypted_samples) {\n            ret = AVERROR(ENOMEM);\n            goto finish;\n        }\n        encryption_index->encrypted_samples = encrypted_samples;\n\n        sample = &encryption_index->encrypted_samples[i];\n        sample_info_size = encryption_index->auxiliary_info_default_size\n                               ? encryption_index->auxiliary_info_default_size\n                               : encryption_index->auxiliary_info_sizes[i];\n\n        ret = mov_read_sample_encryption_info(c, pb, sc, sample, sample_info_size > sc->cenc.per_sample_iv_size);\n        if (ret < 0)\n            goto finish;\n    }\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading auxiliary info\\n\");\n        ret = AVERROR_INVALIDDATA;\n    } else {\n        encryption_index->nb_encrypted_samples = sample_count;\n    }\n\nfinish:\n    avio_seek(pb, prev_pos, SEEK_SET);\n    if (ret < 0) {\n        for (; i > 0; i--) {\n            av_encryption_info_free(encryption_index->encrypted_samples[i - 1]);\n        }\n        av_freep(&encryption_index->encrypted_samples);\n    }\n    return ret;\n}\n\n/**\n * Tries to read the given number of bytes from the stream and puts it in a\n * newly allocated buffer.  This reads in small chunks to avoid allocating large\n * memory if the file contains an invalid/malicious size value.\n */\nstatic int mov_try_read_block(AVIOContext *pb, size_t size, uint8_t **data)\n{\n    const unsigned int block_size = 1024 * 1024;\n    uint8_t *buffer = NULL;\n    unsigned int alloc_size = 0, offset = 0;\n    while (offset < size) {\n        unsigned int new_size =\n            alloc_size >= INT_MAX - block_size ? INT_MAX : alloc_size + block_size;\n        uint8_t *new_buffer = av_fast_realloc(buffer, &alloc_size, new_size);\n        unsigned int to_read = FFMIN(size, alloc_size) - offset;\n        if (!new_buffer) {\n            av_free(buffer);\n            return AVERROR(ENOMEM);\n        }\n        buffer = new_buffer;\n\n        if (avio_read(pb, buffer + offset, to_read) != to_read) {\n            av_free(buffer);\n            return AVERROR_INVALIDDATA;\n        }\n        offset += to_read;\n    }\n\n    *data = buffer;\n    return 0;\n}\n\nstatic int mov_read_saiz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVEncryptionIndex *encryption_index;\n    MOVStreamContext *sc;\n    int ret;\n    unsigned int sample_count, aux_info_type, aux_info_param;\n\n    ret = get_current_encryption_info(c, &encryption_index, &sc);\n    if (ret != 1)\n        return ret;\n\n    if (encryption_index->nb_encrypted_samples) {\n        // This can happen if we have both saio/saiz and senc atoms.\n        av_log(c->fc, AV_LOG_DEBUG, \"Ignoring duplicate encryption info in saiz\\n\");\n        return 0;\n    }\n\n    if (encryption_index->auxiliary_info_sample_count) {\n        av_log(c->fc, AV_LOG_ERROR, \"Duplicate saiz atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_r8(pb); /* version */\n    if (avio_rb24(pb) & 0x01) {  /* flags */\n        aux_info_type = avio_rb32(pb);\n        aux_info_param = avio_rb32(pb);\n        if (sc->cenc.default_encrypted_sample) {\n            if (aux_info_type != sc->cenc.default_encrypted_sample->scheme) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saiz box with non-zero aux_info_type\\n\");\n                return 0;\n            }\n            if (aux_info_param != 0) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saiz box with non-zero aux_info_type_parameter\\n\");\n                return 0;\n            }\n        } else {\n            // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n            if ((aux_info_type == MKBETAG('c','e','n','c') ||\n                 aux_info_type == MKBETAG('c','e','n','s') ||\n                 aux_info_type == MKBETAG('c','b','c','1') ||\n                 aux_info_type == MKBETAG('c','b','c','s')) &&\n                aux_info_param == 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Saw encrypted saiz without schm/tenc\\n\");\n                return AVERROR_INVALIDDATA;\n            } else {\n                return 0;\n            }\n        }\n    } else if (!sc->cenc.default_encrypted_sample) {\n        // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n        return 0;\n    }\n\n    encryption_index->auxiliary_info_default_size = avio_r8(pb);\n    sample_count = avio_rb32(pb);\n    encryption_index->auxiliary_info_sample_count = sample_count;\n\n    if (encryption_index->auxiliary_info_default_size == 0) {\n        ret = mov_try_read_block(pb, sample_count, &encryption_index->auxiliary_info_sizes);\n        if (ret < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to read the auxiliary info\\n\");\n            return ret;\n        }\n    }\n\n    if (encryption_index->auxiliary_offsets_count) {\n        return mov_parse_auxiliary_info(c, sc, pb, encryption_index);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_saio(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint64_t *auxiliary_offsets;\n    MOVEncryptionIndex *encryption_index;\n    MOVStreamContext *sc;\n    int i, ret;\n    unsigned int version, entry_count, aux_info_type, aux_info_param;\n    unsigned int alloc_size = 0;\n\n    ret = get_current_encryption_info(c, &encryption_index, &sc);\n    if (ret != 1)\n        return ret;\n\n    if (encryption_index->nb_encrypted_samples) {\n        // This can happen if we have both saio/saiz and senc atoms.\n        av_log(c->fc, AV_LOG_DEBUG, \"Ignoring duplicate encryption info in saio\\n\");\n        return 0;\n    }\n\n    if (encryption_index->auxiliary_offsets_count) {\n        av_log(c->fc, AV_LOG_ERROR, \"Duplicate saio atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb); /* version */\n    if (avio_rb24(pb) & 0x01) {  /* flags */\n        aux_info_type = avio_rb32(pb);\n        aux_info_param = avio_rb32(pb);\n        if (sc->cenc.default_encrypted_sample) {\n            if (aux_info_type != sc->cenc.default_encrypted_sample->scheme) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saio box with non-zero aux_info_type\\n\");\n                return 0;\n            }\n            if (aux_info_param != 0) {\n                av_log(c->fc, AV_LOG_DEBUG, \"Ignoring saio box with non-zero aux_info_type_parameter\\n\");\n                return 0;\n            }\n        } else {\n            // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n            if ((aux_info_type == MKBETAG('c','e','n','c') ||\n                 aux_info_type == MKBETAG('c','e','n','s') ||\n                 aux_info_type == MKBETAG('c','b','c','1') ||\n                 aux_info_type == MKBETAG('c','b','c','s')) &&\n                aux_info_param == 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Saw encrypted saio without schm/tenc\\n\");\n                return AVERROR_INVALIDDATA;\n            } else {\n                return 0;\n            }\n        }\n    } else if (!sc->cenc.default_encrypted_sample) {\n        // Didn't see 'schm' or 'tenc', so this isn't encrypted.\n        return 0;\n    }\n\n    entry_count = avio_rb32(pb);\n    if (entry_count >= INT_MAX / sizeof(*auxiliary_offsets))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entry_count && !pb->eof_reached; i++) {\n        unsigned int min_offsets = FFMIN(FFMAX(i + 1, 1024), entry_count);\n        auxiliary_offsets = av_fast_realloc(\n            encryption_index->auxiliary_offsets, &alloc_size,\n            min_offsets * sizeof(*auxiliary_offsets));\n        if (!auxiliary_offsets) {\n            av_freep(&encryption_index->auxiliary_offsets);\n            return AVERROR(ENOMEM);\n        }\n        encryption_index->auxiliary_offsets = auxiliary_offsets;\n\n        if (version == 0) {\n            encryption_index->auxiliary_offsets[i] = avio_rb32(pb);\n        } else {\n            encryption_index->auxiliary_offsets[i] = avio_rb64(pb);\n        }\n        if (c->frag_index.current >= 0) {\n            encryption_index->auxiliary_offsets[i] += c->fragment.base_data_offset;\n        }\n    }\n\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading saio\\n\");\n        av_freep(&encryption_index->auxiliary_offsets);\n        return AVERROR_INVALIDDATA;\n    }\n\n    encryption_index->auxiliary_offsets_count = entry_count;\n\n    if (encryption_index->auxiliary_info_sample_count) {\n        return mov_parse_auxiliary_info(c, sc, pb, encryption_index);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_pssh(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVEncryptionInitInfo *info, *old_init_info;\n    uint8_t **key_ids;\n    AVStream *st;\n    uint8_t *side_data, *extra_data, *old_side_data;\n    size_t side_data_size, old_side_data_size;\n    int ret = 0;\n    unsigned int version, kid_count, extra_data_size, alloc_size = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb);  /* flags */\n\n    info = av_encryption_init_info_alloc(/* system_id_size */ 16, /* num_key_ids */ 0,\n                                         /* key_id_size */ 16, /* data_size */ 0);\n    if (!info)\n        return AVERROR(ENOMEM);\n\n    if ((ret = ffio_read_size(pb, info->system_id, 16)) < 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Failed to read the system id\\n\");\n        goto finish;\n    }\n\n    if (version > 0) {\n        kid_count = avio_rb32(pb);\n        if (kid_count >= INT_MAX / sizeof(*key_ids)) {\n            ret = AVERROR(ENOMEM);\n            goto finish;\n        }\n\n        for (unsigned int i = 0; i < kid_count && !pb->eof_reached; i++) {\n            unsigned int min_kid_count = FFMIN(FFMAX(i + 1, 1024), kid_count);\n            key_ids = av_fast_realloc(info->key_ids, &alloc_size,\n                                      min_kid_count * sizeof(*key_ids));\n            if (!key_ids) {\n                ret = AVERROR(ENOMEM);\n                goto finish;\n            }\n            info->key_ids = key_ids;\n\n            info->key_ids[i] = av_mallocz(16);\n            if (!info->key_ids[i]) {\n                ret = AVERROR(ENOMEM);\n                goto finish;\n            }\n            info->num_key_ids = i + 1;\n\n            if ((ret = ffio_read_size(pb, info->key_ids[i], 16)) < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Failed to read the key id\\n\");\n                goto finish;\n            }\n        }\n\n        if (pb->eof_reached) {\n            av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading pssh\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto finish;\n        }\n    }\n\n    extra_data_size = avio_rb32(pb);\n    ret = mov_try_read_block(pb, extra_data_size, &extra_data);\n    if (ret < 0)\n        goto finish;\n\n    av_freep(&info->data);  // malloc(0) may still allocate something.\n    info->data = extra_data;\n    info->data_size = extra_data_size;\n\n    // If there is existing initialization data, append to the list.\n    old_side_data = av_stream_get_side_data(st, AV_PKT_DATA_ENCRYPTION_INIT_INFO, &old_side_data_size);\n    if (old_side_data) {\n        old_init_info = av_encryption_init_info_get_side_data(old_side_data, old_side_data_size);\n        if (old_init_info) {\n            // Append to the end of the list.\n            for (AVEncryptionInitInfo *cur = old_init_info;; cur = cur->next) {\n                if (!cur->next) {\n                    cur->next = info;\n                    break;\n                }\n            }\n            info = old_init_info;\n        } else {\n            // Assume existing side-data will be valid, so the only error we could get is OOM.\n            ret = AVERROR(ENOMEM);\n            goto finish;\n        }\n    }\n\n    side_data = av_encryption_init_info_add_side_data(info, &side_data_size);\n    if (!side_data) {\n        ret = AVERROR(ENOMEM);\n        goto finish;\n    }\n    ret = av_stream_add_side_data(st, AV_PKT_DATA_ENCRYPTION_INIT_INFO,\n                                  side_data, side_data_size);\n    if (ret < 0)\n        av_free(side_data);\n\nfinish:\n    av_encryption_init_info_free(info);\n    return ret;\n}\n\nstatic int mov_read_schm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->pseudo_stream_id != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"schm boxes are only supported in first sample descriptor\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (atom.size < 8)\n        return AVERROR_INVALIDDATA;\n\n    avio_rb32(pb); /* version and flags */\n\n    if (!sc->cenc.default_encrypted_sample) {\n        sc->cenc.default_encrypted_sample = av_encryption_info_alloc(0, 16, 16);\n        if (!sc->cenc.default_encrypted_sample) {\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    sc->cenc.default_encrypted_sample->scheme = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_tenc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int version, pattern, is_protected, iv_size;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->pseudo_stream_id != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"tenc atom are only supported in first sample descriptor\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (!sc->cenc.default_encrypted_sample) {\n        sc->cenc.default_encrypted_sample = av_encryption_info_alloc(0, 16, 16);\n        if (!sc->cenc.default_encrypted_sample) {\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    if (atom.size < 20)\n        return AVERROR_INVALIDDATA;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    avio_r8(pb); /* reserved */\n    pattern = avio_r8(pb);\n\n    if (version > 0) {\n        sc->cenc.default_encrypted_sample->crypt_byte_block = pattern >> 4;\n        sc->cenc.default_encrypted_sample->skip_byte_block = pattern & 0xf;\n    }\n\n    is_protected = avio_r8(pb);\n    if (is_protected && !sc->cenc.encryption_index) {\n        // The whole stream should be by-default encrypted.\n        sc->cenc.encryption_index = av_mallocz(sizeof(MOVEncryptionIndex));\n        if (!sc->cenc.encryption_index)\n            return AVERROR(ENOMEM);\n    }\n    sc->cenc.per_sample_iv_size = avio_r8(pb);\n    if (sc->cenc.per_sample_iv_size != 0 && sc->cenc.per_sample_iv_size != 8 &&\n        sc->cenc.per_sample_iv_size != 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid per-sample IV size value\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (avio_read(pb, sc->cenc.default_encrypted_sample->key_id, 16) != 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read the default key ID\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (is_protected && !sc->cenc.per_sample_iv_size) {\n        iv_size = avio_r8(pb);\n        if (iv_size != 8 && iv_size != 16) {\n            av_log(c->fc, AV_LOG_ERROR, \"invalid default_constant_IV_size in tenc atom\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (avio_read(pb, sc->cenc.default_encrypted_sample->iv, iv_size) != iv_size) {\n            av_log(c->fc, AV_LOG_ERROR, \"failed to read the default IV\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n\n    /* Check FlacSpecificBox version. */\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n\n    avio_rb24(pb); /* Flags */\n\n    if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n        return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n    }\n    flac_parse_block_header(buf, &last, &type, &size);\n\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n\n    return 0;\n}\n\nstatic int cenc_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int bytes_of_protected_data;\n\n    if (!sc->cenc.aes_ctr) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n\n        bytes_of_protected_data = sample->subsamples[i].bytes_of_protected_data;\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, bytes_of_protected_data);\n\n        input += bytes_of_protected_data;\n        size -= bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cbc1_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int num_of_encrypted_blocks;\n    uint8_t iv[16];\n\n    if (!sc->cenc.aes_ctx) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctx = av_aes_alloc();\n        if (!sc->cenc.aes_ctx) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_init(sc->cenc.aes_ctx, c->decryption_key, 16 * 8, 1);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    memcpy(iv, sample->iv, 16);\n\n    /* whole-block full sample encryption */\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        av_aes_crypt(sc->cenc.aes_ctx, input, input, size/16, iv, 1);\n        return 0;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (sample->subsamples[i].bytes_of_protected_data % 16) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample BytesOfProtectedData is not a multiple of 16\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n        num_of_encrypted_blocks = sample->subsamples[i].bytes_of_protected_data/16;\n        if (num_of_encrypted_blocks > 0) {\n            av_aes_crypt(sc->cenc.aes_ctx, input, input, num_of_encrypted_blocks, iv, 1);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cens_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t *data;\n\n    if (!sc->cenc.aes_ctr) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n\n    /* whole-block full sample encryption */\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cens' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_ctr_crypt(sc->cenc.aes_ctr, data, data, 16*sample->crypt_byte_block);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cbcs_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t iv[16];\n    uint8_t *data;\n\n    if (!sc->cenc.aes_ctx) {\n        /* initialize the cipher */\n        sc->cenc.aes_ctx = av_aes_alloc();\n        if (!sc->cenc.aes_ctx) {\n            return AVERROR(ENOMEM);\n        }\n\n        ret = av_aes_init(sc->cenc.aes_ctx, c->decryption_key, 16 * 8, 1);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    /* whole-block full sample encryption */\n    if (!sample->subsample_count) {\n        /* decrypt the whole packet */\n        memcpy(iv, sample->iv, 16);\n        av_aes_crypt(sc->cenc.aes_ctx, input, input, size/16, iv, 1);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cbcs' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n\n        /* decrypt the encrypted bytes */\n        memcpy(iv, sample->iv, 16);\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_crypt(sc->cenc.aes_ctx, data, data, sample->crypt_byte_block, iv, 1);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int cenc_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    if (sample->scheme == MKBETAG('c','e','n','c') && !sample->crypt_byte_block && !sample->skip_byte_block) {\n        return cenc_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','b','c','1') && !sample->crypt_byte_block && !sample->skip_byte_block) {\n        return cbc1_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','e','n','s')) {\n        return cens_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','b','c','s')) {\n        return cbcs_scheme_decrypt(c, sc, sample, input, size);\n    } else {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid encryption scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n}\n\nstatic MOVFragmentStreamInfo *get_frag_stream_info_from_pkt(MOVFragmentIndex *frag_index, AVPacket *pkt, int id)\n{\n    int current = frag_index->current;\n\n    if (!frag_index->nb_items)\n        return NULL;\n\n    // Check frag_index->current is the right one for pkt. It can out of sync.\n    if (current >= 0 && current < frag_index->nb_items) {\n        if (frag_index->item[current].moof_offset < pkt->pos &&\n            (current + 1 == frag_index->nb_items ||\n             frag_index->item[current + 1].moof_offset > pkt->pos))\n            return get_frag_stream_info(frag_index, current, id);\n    }\n\n\n    for (int i = 0; i < frag_index->nb_items; i++) {\n        if (frag_index->item[i].moof_offset > pkt->pos)\n            break;\n        current = i;\n    }\n    frag_index->current = current;\n    return get_frag_stream_info(frag_index, current, id);\n}\n\nstatic int cenc_filter(MOVContext *mov, AVStream* st, MOVStreamContext *sc, AVPacket *pkt, int current_index)\n{\n    MOVFragmentStreamInfo *frag_stream_info;\n    MOVEncryptionIndex *encryption_index;\n    AVEncryptionInfo *encrypted_sample;\n    int encrypted_index, ret;\n\n    frag_stream_info = get_frag_stream_info_from_pkt(&mov->frag_index, pkt, st->id);\n    encrypted_index = current_index;\n    encryption_index = NULL;\n    if (frag_stream_info) {\n        // Note this only supports encryption info in the first sample descriptor.\n        if (mov->fragment.stsd_id == 1) {\n            if (frag_stream_info->encryption_index) {\n                encrypted_index = current_index - frag_stream_info->index_base;\n                encryption_index = frag_stream_info->encryption_index;\n            } else {\n                encryption_index = sc->cenc.encryption_index;\n            }\n        }\n    } else {\n        encryption_index = sc->cenc.encryption_index;\n    }\n\n    if (encryption_index) {\n        if (encryption_index->auxiliary_info_sample_count &&\n            !encryption_index->nb_encrypted_samples) {\n            av_log(mov->fc, AV_LOG_ERROR, \"saiz atom found without saio\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (encryption_index->auxiliary_offsets_count &&\n            !encryption_index->nb_encrypted_samples) {\n            av_log(mov->fc, AV_LOG_ERROR, \"saio atom found without saiz\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!encryption_index->nb_encrypted_samples) {\n            // Full-sample encryption with default settings.\n            encrypted_sample = sc->cenc.default_encrypted_sample;\n        } else if (encrypted_index >= 0 && encrypted_index < encryption_index->nb_encrypted_samples) {\n            // Per-sample setting override.\n            encrypted_sample = encryption_index->encrypted_samples[encrypted_index];\n        } else {\n            av_log(mov->fc, AV_LOG_ERROR, \"Incorrect number of samples in encryption info\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (mov->decryption_key) {\n            return cenc_decrypt(mov, sc, encrypted_sample, pkt->data, pkt->size);\n        } else {\n            size_t size;\n            uint8_t *side_data = av_encryption_info_add_side_data(encrypted_sample, &size);\n            if (!side_data)\n                return AVERROR(ENOMEM);\n            ret = av_packet_add_side_data(pkt, AV_PKT_DATA_ENCRYPTION_INFO, side_data, size);\n            if (ret < 0)\n                av_free(side_data);\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_read_dops(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int OPUS_SEEK_PREROLL_MS = 80;\n    int ret;\n    AVStream *st;\n    size_t size;\n    uint16_t pre_skip;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 11)\n        return AVERROR_INVALIDDATA;\n\n    /* Check OpusSpecificBox version. */\n    if (avio_r8(pb) != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"unsupported OpusSpecificBox version\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* OpusSpecificBox size plus magic for Ogg OpusHead header. */\n    size = atom.size + 8;\n\n    if ((ret = ff_alloc_extradata(st->codecpar, size)) < 0)\n        return ret;\n\n    AV_WL32(st->codecpar->extradata, MKTAG('O','p','u','s'));\n    AV_WL32(st->codecpar->extradata + 4, MKTAG('H','e','a','d'));\n    AV_WB8(st->codecpar->extradata + 8, 1); /* OpusHead version */\n    avio_read(pb, st->codecpar->extradata + 9, size - 9);\n\n    /* OpusSpecificBox is stored in big-endian, but OpusHead is\n       little-endian; aside from the preceeding magic and version they're\n       otherwise currently identical.  Data after output gain at offset 16\n       doesn't need to be bytewapped. */\n    pre_skip = AV_RB16(st->codecpar->extradata + 10);\n    AV_WL16(st->codecpar->extradata + 10, pre_skip);\n    AV_WL32(st->codecpar->extradata + 12, AV_RB32(st->codecpar->extradata + 12));\n    AV_WL16(st->codecpar->extradata + 16, AV_RB16(st->codecpar->extradata + 16));\n\n    st->codecpar->initial_padding = pre_skip;\n    st->codecpar->seek_preroll = av_rescale_q(OPUS_SEEK_PREROLL_MS,\n                                              (AVRational){1, 1000},\n                                              (AVRational){1, 48000});\n\n    return 0;\n}\n\nstatic int mov_read_dmlp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned format_info;\n    int channel_assignment, channel_assignment1, channel_assignment2;\n    int ratebits;\n    uint64_t chmask;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 10)\n        return AVERROR_INVALIDDATA;\n\n    format_info = avio_rb32(pb);\n\n    ratebits            = (format_info >> 28) & 0xF;\n    channel_assignment1 = (format_info >> 15) & 0x1F;\n    channel_assignment2 = format_info & 0x1FFF;\n    if (channel_assignment2)\n        channel_assignment = channel_assignment2;\n    else\n        channel_assignment = channel_assignment1;\n\n    st->codecpar->frame_size = 40 << (ratebits & 0x7);\n    st->codecpar->sample_rate = mlp_samplerate(ratebits);\n\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    chmask = truehd_layout(channel_assignment);\n    av_channel_layout_from_mask(&st->codecpar->ch_layout, chmask);\n\n    return 0;\n}\n\nstatic int mov_read_dvcc_dvvc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t buf[ISOM_DVCC_DVVC_SIZE];\n    int ret;\n    int64_t read_size = atom.size;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    // At most 24 bytes\n    read_size = FFMIN(read_size, ISOM_DVCC_DVVC_SIZE);\n\n    if ((ret = ffio_read_size(pb, buf, read_size)) < 0)\n        return ret;\n\n    return ff_isom_parse_dvcc_dvvc(c->fc, st, buf, read_size);\n}\n\nstatic int mov_read_kind(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVFormatContext *ctx = c->fc;\n    AVStream *st = NULL;\n    AVBPrint scheme_buf, value_buf;\n    int64_t scheme_str_len = 0, value_str_len = 0;\n    int version, flags, ret = AVERROR_BUG;\n    int64_t size = atom.size;\n\n    if (atom.size < 6)\n        // 4 bytes for version + flags, 2x 1 byte for null\n        return AVERROR_INVALIDDATA;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    version = avio_r8(pb);\n    flags   = avio_rb24(pb);\n    size   -= 4;\n\n    if (version != 0 || flags != 0) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Unsupported 'kind' box with version %d, flags: %x\",\n               version, flags);\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_bprint_init(&scheme_buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n    av_bprint_init(&value_buf,  0, AV_BPRINT_SIZE_UNLIMITED);\n\n    if ((scheme_str_len = ff_read_string_to_bprint_overwrite(pb, &scheme_buf,\n                                                             size)) < 0) {\n        ret = scheme_str_len;\n        goto cleanup;\n    }\n\n    if (scheme_str_len + 1 >= size) {\n        // we need to have another string, even if nullptr.\n        // we check with + 1 since we expect that if size was not hit,\n        // an additional null was read.\n        ret = AVERROR_INVALIDDATA;\n        goto cleanup;\n    }\n\n    size -= scheme_str_len + 1;\n\n    if ((value_str_len = ff_read_string_to_bprint_overwrite(pb, &value_buf,\n                                                            size)) < 0) {\n        ret = value_str_len;\n        goto cleanup;\n    }\n\n    if (value_str_len == size) {\n        // in case of no trailing null, box is not valid.\n        ret = AVERROR_INVALIDDATA;\n        goto cleanup;\n    }\n\n    av_log(ctx, AV_LOG_TRACE,\n           \"%s stream %d KindBox(scheme: %s, value: %s)\\n\",\n           av_get_media_type_string(st->codecpar->codec_type),\n           st->index,\n           scheme_buf.str, value_buf.str);\n\n    for (int i = 0; ff_mov_track_kind_table[i].scheme_uri; i++) {\n        const struct MP4TrackKindMapping map = ff_mov_track_kind_table[i];\n        if (!av_strstart(scheme_buf.str, map.scheme_uri, NULL))\n            continue;\n\n        for (int j = 0; map.value_maps[j].disposition; j++) {\n            const struct MP4TrackKindValueMapping value_map = map.value_maps[j];\n            if (!av_strstart(value_buf.str, value_map.value, NULL))\n                continue;\n\n            st->disposition |= value_map.disposition;\n        }\n    }\n\n    ret = 0;\n\ncleanup:\n\n    av_bprint_finalize(&scheme_buf, NULL);\n    av_bprint_finalize(&value_buf,  NULL);\n\n    return ret;\n}\n\nstatic int mov_read_SA3D(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int i, version, type;\n    int ambisonic_order, channel_order, normalization, channel_count;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"SA3D audio box too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SA3D box version %d\\n\", version);\n        return 0;\n    }\n\n    type = avio_r8(pb);\n    if (type) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported ambisonic type %d\\n\", type);\n        return 0;\n    }\n\n    ambisonic_order = avio_rb32(pb);\n\n    channel_order = avio_r8(pb);\n    if (channel_order) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported channel_order %d\\n\", channel_order);\n        return 0;\n    }\n\n    normalization = avio_r8(pb);\n    if (normalization) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported normalization %d\\n\", normalization);\n        return 0;\n    }\n\n    channel_count = avio_rb32(pb);\n    if (ambisonic_order < 0 || channel_count != (ambisonic_order + 1LL) * (ambisonic_order + 1LL)) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Invalid number of channels (%d / %d)\\n\",\n               channel_count, ambisonic_order);\n        return 0;\n    }\n\n    for (i = 0; i < channel_count; i++) {\n        if (i != avio_rb32(pb)) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Ambisonic channel reordering is not supported\\n\");\n            return 0;\n        }\n    }\n\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_AMBISONIC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n\n    return 0;\n}\n\nstatic int mov_read_SAND(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty SAND audio box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SAND box version %d\\n\", version);\n        return 0;\n    }\n\n    st->disposition |= AV_DISPOSITION_NON_DIEGETIC;\n\n    return 0;\n}\n\nstatic int rb_size(AVIOContext *pb, uint64_t* value, int size)\n{\n    if (size == 0)\n        *value = 0;\n    else if (size == 1)\n        *value = avio_r8(pb);\n    else if (size == 2)\n        *value = avio_rb16(pb);\n    else if (size == 4)\n        *value = avio_rb32(pb);\n    else if (size == 8)\n        *value = avio_rb64(pb);\n    else\n        return -1;\n    return size;\n}\n\nstatic int mov_read_pitm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    avio_rb32(pb);  // version & flags.\n    c->primary_item_id = avio_rb16(pb);\n    return atom.size;\n}\n\nstatic int mov_read_iloc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int version, offset_size, length_size, base_offset_size, index_size;\n    int item_count, extent_count;\n    uint64_t base_offset, extent_offset, extent_length;\n    uint8_t value;\n\n    if (!c->is_still_picture_avif) {\n        // * For non-avif, we simply ignore the iloc box.\n        // * For animated avif, we don't care about the iloc box as all the\n        //   necessary information can be found in the moov box.\n        return 0;\n    }\n\n    if (c->fc->nb_streams) {\n        av_log(c->fc, AV_LOG_INFO, \"Duplicate iloc box found\\n\");\n        return 0;\n    }\n\n    version = avio_r8(pb);\n    avio_rb24(pb);  // flags.\n\n    value = avio_r8(pb);\n    offset_size = (value >> 4) & 0xF;\n    length_size = value & 0xF;\n    value = avio_r8(pb);\n    base_offset_size = (value >> 4) & 0xF;\n    index_size = !version ? 0 : (value & 0xF);\n    if (index_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"iloc: index_size != 0 not supported.\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    item_count = (version < 2) ? avio_rb16(pb) : avio_rb32(pb);\n\n    c->avif_info = av_malloc_array(item_count, sizeof(*c->avif_info));\n    if (!c->avif_info)\n        return AVERROR(ENOMEM);\n    c->avif_info_size = item_count;\n\n    for (int i = 0; i < item_count; i++) {\n        int item_id = (version < 2) ? avio_rb16(pb) : avio_rb32(pb);\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        c->avif_info[i].item_id = item_id;\n\n        if (version > 0)\n            avio_rb16(pb);  // construction_method.\n        avio_rb16(pb);  // data_reference_index.\n        if (rb_size(pb, &base_offset, base_offset_size) < 0)\n            return AVERROR_INVALIDDATA;\n        extent_count = avio_rb16(pb);\n        if (extent_count > 1) {\n            // For still AVIF images, we only support one extent item.\n            av_log(c->fc, AV_LOG_ERROR, \"iloc: extent_count > 1 not supported.\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        for (int j = 0; j < extent_count; j++) {\n            if (rb_size(pb, &extent_offset, offset_size) < 0 ||\n                rb_size(pb, &extent_length, length_size) < 0)\n                return AVERROR_INVALIDDATA;\n            c->avif_info[i].extent_length = extent_length;\n            c->avif_info[i].extent_offset = base_offset + extent_offset;\n        }\n    }\n\n    return atom.size;\n}\n\nstatic const MOVParseTableEntry mov_default_parse_table[] = {\n{ MKTAG('A','C','L','R'), mov_read_aclr },\n{ MKTAG('A','P','R','G'), mov_read_avid },\n{ MKTAG('A','A','L','P'), mov_read_avid },\n{ MKTAG('A','R','E','S'), mov_read_ares },\n{ MKTAG('a','v','s','s'), mov_read_avss },\n{ MKTAG('a','v','1','C'), mov_read_glbl },\n{ MKTAG('c','h','p','l'), mov_read_chpl },\n{ MKTAG('c','o','6','4'), mov_read_stco },\n{ MKTAG('c','o','l','r'), mov_read_colr },\n{ MKTAG('c','t','t','s'), mov_read_ctts }, /* composition time to sample */\n{ MKTAG('d','i','n','f'), mov_read_default },\n{ MKTAG('D','p','x','E'), mov_read_dpxe },\n{ MKTAG('d','r','e','f'), mov_read_dref },\n{ MKTAG('e','d','t','s'), mov_read_default },\n{ MKTAG('e','l','s','t'), mov_read_elst },\n{ MKTAG('e','n','d','a'), mov_read_enda },\n{ MKTAG('f','i','e','l'), mov_read_fiel },\n{ MKTAG('a','d','r','m'), mov_read_adrm },\n{ MKTAG('f','t','y','p'), mov_read_ftyp },\n{ MKTAG('g','l','b','l'), mov_read_glbl },\n{ MKTAG('h','d','l','r'), mov_read_hdlr },\n{ MKTAG('i','l','s','t'), mov_read_ilst },\n{ MKTAG('j','p','2','h'), mov_read_jp2h },\n{ MKTAG('m','d','a','t'), mov_read_mdat },\n{ MKTAG('m','d','h','d'), mov_read_mdhd },\n{ MKTAG('m','d','i','a'), mov_read_default },\n{ MKTAG('m','e','t','a'), mov_read_meta },\n{ MKTAG('m','i','n','f'), mov_read_default },\n{ MKTAG('m','o','o','f'), mov_read_moof },\n{ MKTAG('m','o','o','v'), mov_read_moov },\n{ MKTAG('m','v','e','x'), mov_read_default },\n{ MKTAG('m','v','h','d'), mov_read_mvhd },\n{ MKTAG('S','M','I',' '), mov_read_svq3 },\n{ MKTAG('a','l','a','c'), mov_read_alac }, /* alac specific atom */\n{ MKTAG('a','v','c','C'), mov_read_glbl },\n{ MKTAG('p','a','s','p'), mov_read_pasp },\n{ MKTAG('s','i','d','x'), mov_read_sidx },\n{ MKTAG('s','t','b','l'), mov_read_default },\n{ MKTAG('s','t','c','o'), mov_read_stco },\n{ MKTAG('s','t','p','s'), mov_read_stps },\n{ MKTAG('s','t','r','f'), mov_read_strf },\n{ MKTAG('s','t','s','c'), mov_read_stsc },\n{ MKTAG('s','t','s','d'), mov_read_stsd }, /* sample description */\n{ MKTAG('s','t','s','s'), mov_read_stss }, /* sync sample */\n{ MKTAG('s','t','s','z'), mov_read_stsz }, /* sample size */\n{ MKTAG('s','t','t','s'), mov_read_stts },\n{ MKTAG('s','t','z','2'), mov_read_stsz }, /* compact sample size */\n{ MKTAG('s','d','t','p'), mov_read_sdtp }, /* independent and disposable samples */\n{ MKTAG('t','k','h','d'), mov_read_tkhd }, /* track header */\n{ MKTAG('t','f','d','t'), mov_read_tfdt },\n{ MKTAG('t','f','h','d'), mov_read_tfhd }, /* track fragment header */\n{ MKTAG('t','r','a','k'), mov_read_trak },\n{ MKTAG('t','r','a','f'), mov_read_default },\n{ MKTAG('t','r','e','f'), mov_read_default },\n{ MKTAG('t','m','c','d'), mov_read_tmcd },\n{ MKTAG('c','h','a','p'), mov_read_chap },\n{ MKTAG('t','r','e','x'), mov_read_trex },\n{ MKTAG('t','r','u','n'), mov_read_trun },\n{ MKTAG('u','d','t','a'), mov_read_default },\n{ MKTAG('w','a','v','e'), mov_read_wave },\n{ MKTAG('e','s','d','s'), mov_read_esds },\n{ MKTAG('d','a','c','3'), mov_read_dac3 }, /* AC-3 info */\n{ MKTAG('d','e','c','3'), mov_read_dec3 }, /* EAC-3 info */\n{ MKTAG('d','d','t','s'), mov_read_ddts }, /* DTS audio descriptor */\n{ MKTAG('w','i','d','e'), mov_read_wide }, /* place holder */\n{ MKTAG('w','f','e','x'), mov_read_wfex },\n{ MKTAG('c','m','o','v'), mov_read_cmov },\n{ MKTAG('c','h','a','n'), mov_read_chan }, /* channel layout */\n{ MKTAG('d','v','c','1'), mov_read_dvc1 },\n{ MKTAG('s','g','p','d'), mov_read_sgpd },\n{ MKTAG('s','b','g','p'), mov_read_sbgp },\n{ MKTAG('h','v','c','C'), mov_read_glbl },\n{ MKTAG('u','u','i','d'), mov_read_uuid },\n{ MKTAG('C','i','n', 0x8e), mov_read_targa_y216 },\n{ MKTAG('f','r','e','e'), mov_read_free },\n{ MKTAG('-','-','-','-'), mov_read_custom },\n{ MKTAG('s','i','n','f'), mov_read_default },\n{ MKTAG('f','r','m','a'), mov_read_frma },\n{ MKTAG('s','e','n','c'), mov_read_senc },\n{ MKTAG('s','a','i','z'), mov_read_saiz },\n{ MKTAG('s','a','i','o'), mov_read_saio },\n{ MKTAG('p','s','s','h'), mov_read_pssh },\n{ MKTAG('s','c','h','m'), mov_read_schm },\n{ MKTAG('s','c','h','i'), mov_read_default },\n{ MKTAG('t','e','n','c'), mov_read_tenc },\n{ MKTAG('d','f','L','a'), mov_read_dfla },\n{ MKTAG('s','t','3','d'), mov_read_st3d }, /* stereoscopic 3D video box */\n{ MKTAG('s','v','3','d'), mov_read_sv3d }, /* spherical video box */\n{ MKTAG('d','O','p','s'), mov_read_dops },\n{ MKTAG('d','m','l','p'), mov_read_dmlp },\n{ MKTAG('S','m','D','m'), mov_read_smdm },\n{ MKTAG('C','o','L','L'), mov_read_coll },\n{ MKTAG('v','p','c','C'), mov_read_vpcc },\n{ MKTAG('m','d','c','v'), mov_read_mdcv },\n{ MKTAG('c','l','l','i'), mov_read_clli },\n{ MKTAG('d','v','c','C'), mov_read_dvcc_dvvc },\n{ MKTAG('d','v','v','C'), mov_read_dvcc_dvvc },\n{ MKTAG('d','v','w','C'), mov_read_dvcc_dvvc },\n{ MKTAG('k','i','n','d'), mov_read_kind },\n{ MKTAG('S','A','3','D'), mov_read_SA3D }, /* ambisonic audio box */\n{ MKTAG('S','A','N','D'), mov_read_SAND }, /* non diegetic audio box */\n{ MKTAG('i','l','o','c'), mov_read_iloc },\n{ MKTAG('p','c','m','C'), mov_read_pcmc }, /* PCM configuration box */\n{ MKTAG('p','i','t','m'), mov_read_pitm },\n{ 0, NULL }\n};\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (c->atom_depth > 10) {\n        av_log(c->fc, AV_LOG_ERROR, \"Atoms too deeply nested\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->atom_depth ++;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size <= atom.size - 8) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = avio_rb32(pb);\n        a.type = avio_rl32(pb);\n        if (avio_feof(pb))\n            break;\n        if (((a.type == MKTAG('f','r','e','e') && c->moov_retry) ||\n              a.type == MKTAG('h','o','o','v')) &&\n            a.size >= 8 &&\n            c->fc->strict_std_compliance < FF_COMPLIANCE_STRICT) {\n                uint32_t type;\n                avio_skip(pb, 4);\n                type = avio_rl32(pb);\n                if (avio_feof(pb))\n                    break;\n                avio_seek(pb, -8, SEEK_CUR);\n                if (type == MKTAG('m','v','h','d') ||\n                    type == MKTAG('c','m','o','v')) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free or hoov atom.\\n\");\n                    a.type = MKTAG('m','o','o','v');\n                }\n        }\n        if (atom.type != MKTAG('r','o','o','t') &&\n            atom.type != MKTAG('m','o','o','v')) {\n            if (a.type == MKTAG('t','r','a','k') ||\n                a.type == MKTAG('m','d','a','t')) {\n                av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                avio_skip(pb, -8);\n                c->atom_depth --;\n                return 0;\n            }\n        }\n        total_size += 8;\n        if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */\n            a.size = avio_rb64(pb) - 8;\n            total_size += 8;\n        }\n        av_log(c->fc, AV_LOG_TRACE, \"type:'%s' parent:'%s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n               av_fourcc2str(a.type), av_fourcc2str(atom.type), a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        if (a.size < 0)\n            break;\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        // Supports parsing the QuickTime Metadata Keys.\n        // https://developer.apple.com/library/mac/documentation/QuickTime/QTFF/Metadata/Metadata.html\n        if (!parse && c->found_hdlr_mdta &&\n            atom.type == MKTAG('m','e','t','a') &&\n            a.type == MKTAG('k','e','y','s') &&\n            c->meta_keys_count == 0) {\n            parse = mov_read_keys;\n        }\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0) {\n                c->atom_depth --;\n                return err;\n            }\n            if (c->found_moov && c->found_mdat && a.size <= INT64_MAX - start_pos &&\n                ((!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->frag_index.complete) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->frag_index.complete)\n                    c->next_root_atom = start_pos + a.size;\n                c->atom_depth --;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n            else if (left < 0) {\n                av_log(c->fc, AV_LOG_WARNING,\n                       \"overread end of atom '%s' by %\"PRId64\" bytes\\n\",\n                       av_fourcc2str(a.type), -left);\n                avio_seek(pb, left, SEEK_CUR);\n            }\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    c->atom_depth --;\n    return 0;\n}\n\nstatic int mov_probe(const AVProbeData *p)\n{\n    int64_t offset;\n    uint32_t tag;\n    int score = 0;\n    int moov_offset = -1;\n\n    /* check file header */\n    offset = 0;\n    for (;;) {\n        int64_t size;\n        int minsize = 8;\n        /* ignore invalid offset */\n        if ((offset + 8ULL) > (unsigned int)p->buf_size)\n            break;\n        size = AV_RB32(p->buf + offset);\n        if (size == 1 && offset + 16 <= (unsigned int)p->buf_size) {\n            size = AV_RB64(p->buf+offset + 8);\n            minsize = 16;\n        } else if (size == 0) {\n            size = p->buf_size - offset;\n        }\n        if (size < minsize) {\n            offset += 4;\n            continue;\n        }\n        tag = AV_RL32(p->buf + offset + 4);\n        switch(tag) {\n        /* check for obvious tags */\n        case MKTAG('m','o','o','v'):\n            moov_offset = offset + 4;\n        case MKTAG('m','d','a','t'):\n        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */\n        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */\n        case MKTAG('f','t','y','p'):\n            if (tag == MKTAG('f','t','y','p') &&\n                       (   AV_RL32(p->buf + offset + 8) == MKTAG('j','p','2',' ')\n                        || AV_RL32(p->buf + offset + 8) == MKTAG('j','p','x',' ')\n                        || AV_RL32(p->buf + offset + 8) == MKTAG('j','x','l',' ')\n                    )) {\n                score = FFMAX(score, 5);\n            } else {\n                score = AVPROBE_SCORE_MAX;\n            }\n            break;\n        /* those are more common words, so rate then a bit less */\n        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */\n        case MKTAG('w','i','d','e'):\n        case MKTAG('f','r','e','e'):\n        case MKTAG('j','u','n','k'):\n        case MKTAG('p','i','c','t'):\n            score  = FFMAX(score, AVPROBE_SCORE_MAX - 5);\n            break;\n        case MKTAG(0x82,0x82,0x7f,0x7d):\n        case MKTAG('s','k','i','p'):\n        case MKTAG('u','u','i','d'):\n        case MKTAG('p','r','f','l'):\n            /* if we only find those cause probedata is too small at least rate them */\n            score  = FFMAX(score, AVPROBE_SCORE_EXTENSION);\n            break;\n        }\n        if (size > INT64_MAX - offset)\n            break;\n        offset += size;\n    }\n    if (score > AVPROBE_SCORE_MAX - 50 && moov_offset != -1) {\n        /* moov atom in the header - we should make sure that this is not a\n         * MOV-packed MPEG-PS */\n        offset = moov_offset;\n\n        while (offset < (p->buf_size - 16)) { /* Sufficient space */\n               /* We found an actual hdlr atom */\n            if (AV_RL32(p->buf + offset     ) == MKTAG('h','d','l','r') &&\n                AV_RL32(p->buf + offset +  8) == MKTAG('m','h','l','r') &&\n                AV_RL32(p->buf + offset + 12) == MKTAG('M','P','E','G')) {\n                av_log(NULL, AV_LOG_WARNING, \"Found media data tag MPEG indicating this is a MOV-packed MPEG-PS.\\n\");\n                /* We found a media handler reference atom describing an\n                 * MPEG-PS-in-MOV, return a\n                 * low score to force expanding the probe window until\n                 * mpegps_probe finds what it needs */\n                return 5;\n            } else {\n                /* Keep looking */\n                offset += 2;\n            }\n        }\n    }\n\n    return score;\n}\n\n// must be done after parsing all trak because there's no order requirement\nstatic void mov_read_chapters(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    int64_t cur_pos;\n    int i, j;\n    int chapter_track;\n\n    for (j = 0; j < mov->nb_chapter_tracks; j++) {\n        AVStream *st = NULL;\n        FFStream *sti = NULL;\n        chapter_track = mov->chapter_tracks[j];\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->id == chapter_track) {\n                st = s->streams[i];\n                break;\n            }\n        if (!st) {\n            av_log(s, AV_LOG_ERROR, \"Referenced QT chapter track not found\\n\");\n            continue;\n        }\n        sti = ffstream(st);\n\n        sc = st->priv_data;\n        cur_pos = avio_tell(sc->pb);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            st->disposition |= AV_DISPOSITION_ATTACHED_PIC | AV_DISPOSITION_TIMED_THUMBNAILS;\n            if (sti->nb_index_entries) {\n                // Retrieve the first frame, if possible\n                AVIndexEntry *sample = &sti->index_entries[0];\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to retrieve first frame\\n\");\n                    goto finish;\n                }\n\n                if (ff_add_attached_pic(s, st, sc->pb, NULL, sample->size) < 0)\n                    goto finish;\n            }\n        } else {\n            st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st->codecpar->codec_id = AV_CODEC_ID_BIN_DATA;\n            st->discard = AVDISCARD_ALL;\n            for (int i = 0; i < sti->nb_index_entries; i++) {\n                AVIndexEntry *sample = &sti->index_entries[i];\n                int64_t end = i+1 < sti->nb_index_entries ? sti->index_entries[i+1].timestamp : st->duration;\n                uint8_t *title;\n                uint16_t ch;\n                int len, title_len;\n\n                if (end < sample->timestamp) {\n                    av_log(s, AV_LOG_WARNING, \"ignoring stream duration which is shorter than chapters\\n\");\n                    end = AV_NOPTS_VALUE;\n                }\n\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Chapter %d not found in file\\n\", i);\n                    goto finish;\n                }\n\n                // the first two bytes are the length of the title\n                len = avio_rb16(sc->pb);\n                if (len > sample->size-2)\n                    continue;\n                title_len = 2*len + 1;\n                if (!(title = av_mallocz(title_len)))\n                    goto finish;\n\n                // The samples could theoretically be in any encoding if there's an encd\n                // atom following, but in practice are only utf-8 or utf-16, distinguished\n                // instead by the presence of a BOM\n                if (!len) {\n                    title[0] = 0;\n                } else {\n                    ch = avio_rb16(sc->pb);\n                    if (ch == 0xfeff)\n                        avio_get_str16be(sc->pb, len, title, title_len);\n                    else if (ch == 0xfffe)\n                        avio_get_str16le(sc->pb, len, title, title_len);\n                    else {\n                        AV_WB16(title, ch);\n                        if (len == 1 || len == 2)\n                            title[len] = 0;\n                        else\n                            avio_get_str(sc->pb, INT_MAX, title + 2, len - 1);\n                    }\n                }\n\n                avpriv_new_chapter(s, i, st->time_base, sample->timestamp, end, title);\n                av_freep(&title);\n            }\n        }\nfinish:\n        avio_seek(sc->pb, cur_pos, SEEK_SET);\n    }\n}\n\nstatic int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             int64_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}\n\nstatic int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n\n    if (!sti->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_timecode_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int flags = 0;\n    int64_t cur_pos = avio_tell(sc->pb);\n    int64_t value;\n    AVRational tc_rate = st->avg_frame_rate;\n    int tmcd_nb_frames = sc->tmcd_nb_frames;\n    int rounded_tc_rate;\n\n    if (!sti->nb_index_entries)\n        return -1;\n\n    if (!tc_rate.num || !tc_rate.den || !tmcd_nb_frames)\n        return -1;\n\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    value = avio_rb32(s->pb);\n\n    if (sc->tmcd_flags & 0x0001) flags |= AV_TIMECODE_FLAG_DROPFRAME;\n    if (sc->tmcd_flags & 0x0002) flags |= AV_TIMECODE_FLAG_24HOURSMAX;\n    if (sc->tmcd_flags & 0x0004) flags |= AV_TIMECODE_FLAG_ALLOWNEGATIVE;\n\n    /* Assume Counter flag is set to 1 in tmcd track (even though it is likely\n     * not the case) and thus assume \"frame number format\" instead of QT one.\n     * No sample with tmcd track can be found with a QT timecode at the moment,\n     * despite what the tmcd track \"suggests\" (Counter flag set to 0 means QT\n     * format). */\n\n    /* 60 fps content have tmcd_nb_frames set to 30 but tc_rate set to 60, so\n     * we multiply the frame number with the quotient.\n     * See tickets #9492, #9710. */\n    rounded_tc_rate = (tc_rate.num + tc_rate.den / 2) / tc_rate.den;\n    /* Work around files where tmcd_nb_frames is rounded down from frame rate\n     * instead of up. See ticket #5978. */\n    if (tmcd_nb_frames == tc_rate.num / tc_rate.den &&\n        s->strict_std_compliance < FF_COMPLIANCE_STRICT)\n        tmcd_nb_frames = rounded_tc_rate;\n    value = av_rescale(value, rounded_tc_rate, tmcd_nb_frames);\n\n    parse_timecode_in_framenum_format(s, st, value, flags);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic void mov_free_encryption_index(MOVEncryptionIndex **index) {\n    int i;\n    if (!index || !*index) return;\n    for (i = 0; i < (*index)->nb_encrypted_samples; i++) {\n        av_encryption_info_free((*index)->encrypted_samples[i]);\n    }\n    av_freep(&(*index)->encrypted_samples);\n    av_freep(&(*index)->auxiliary_info_sizes);\n    av_freep(&(*index)->auxiliary_offsets);\n    av_freep(index);\n}\n\nstatic int mov_read_close(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (!sc)\n            continue;\n\n        av_freep(&sc->ctts_data);\n        for (j = 0; j < sc->drefs_count; j++) {\n            av_freep(&sc->drefs[j].path);\n            av_freep(&sc->drefs[j].dir);\n        }\n        av_freep(&sc->drefs);\n\n        sc->drefs_count = 0;\n\n        if (!sc->pb_is_copied)\n            ff_format_io_close(s, &sc->pb);\n\n        sc->pb = NULL;\n        av_freep(&sc->chunk_offsets);\n        av_freep(&sc->stsc_data);\n        av_freep(&sc->sample_sizes);\n        av_freep(&sc->keyframes);\n        av_freep(&sc->stts_data);\n        av_freep(&sc->sdtp_data);\n        av_freep(&sc->stps_data);\n        av_freep(&sc->elst_data);\n        av_freep(&sc->rap_group);\n        av_freep(&sc->sync_group);\n        av_freep(&sc->sgpd_sync);\n        av_freep(&sc->sample_offsets);\n        av_freep(&sc->open_key_samples);\n        av_freep(&sc->display_matrix);\n        av_freep(&sc->index_ranges);\n\n        if (sc->extradata)\n            for (j = 0; j < sc->stsd_count; j++)\n                av_free(sc->extradata[j]);\n        av_freep(&sc->extradata);\n        av_freep(&sc->extradata_size);\n\n        mov_free_encryption_index(&sc->cenc.encryption_index);\n        av_encryption_info_free(sc->cenc.default_encrypted_sample);\n        av_aes_ctr_free(sc->cenc.aes_ctr);\n\n        av_freep(&sc->stereo3d);\n        av_freep(&sc->spherical);\n        av_freep(&sc->mastering);\n        av_freep(&sc->coll);\n    }\n\n    av_freep(&mov->dv_demux);\n    avformat_free_context(mov->dv_fctx);\n    mov->dv_fctx = NULL;\n\n    if (mov->meta_keys) {\n        for (i = 1; i < mov->meta_keys_count; i++) {\n            av_freep(&mov->meta_keys[i]);\n        }\n        av_freep(&mov->meta_keys);\n    }\n\n    av_freep(&mov->trex_data);\n    av_freep(&mov->bitrates);\n\n    for (i = 0; i < mov->frag_index.nb_items; i++) {\n        MOVFragmentStreamInfo *frag = mov->frag_index.item[i].stream_info;\n        for (j = 0; j < mov->frag_index.item[i].nb_stream_info; j++) {\n            mov_free_encryption_index(&frag[j].encryption_index);\n        }\n        av_freep(&mov->frag_index.item[i].stream_info);\n    }\n    av_freep(&mov->frag_index.item);\n\n    av_freep(&mov->aes_decrypt);\n    av_freep(&mov->chapter_tracks);\n    av_freep(&mov->avif_info);\n\n    return 0;\n}\n\nstatic int tmcd_is_referenced(AVFormatContext *s, int tmcd_id)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&\n            sc->timecode_track == tmcd_id)\n            return 1;\n    }\n    return 0;\n}\n\n/* look for a tmcd track not referenced by any video track, and export it globally */\nstatic void export_orphan_timecode(AVFormatContext *s)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n\n        if (st->codecpar->codec_tag  == MKTAG('t','m','c','d') &&\n            !tmcd_is_referenced(s, i + 1)) {\n            AVDictionaryEntry *tcr = av_dict_get(st->metadata, \"timecode\", NULL, 0);\n            if (tcr) {\n                av_dict_set(&s->metadata, \"timecode\", tcr->value, 0);\n                break;\n            }\n        }\n    }\n}\n\nstatic int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    unsigned track_id, item_count;\n\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n\n    version = avio_r8(f);\n    avio_rb24(f);\n    track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    item_count = avio_rb32(f);\n    for (i = 0; i < item_count; i++) {\n        int64_t time, offset;\n        int index;\n        MOVFragmentStreamInfo * frag_stream_info;\n\n        if (avio_feof(f)) {\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n\n        // The first sample of each stream in a fragment is always a random\n        // access sample.  So it's entry in the tfra can be used as the\n        // initial PTS of the fragment.\n        index = update_frag_index(mov, offset);\n        frag_stream_info = get_frag_stream_info(&mov->frag_index, index, track_id);\n        if (frag_stream_info &&\n            frag_stream_info->first_tfra_pts == AV_NOPTS_VALUE)\n            frag_stream_info->first_tfra_pts = time;\n\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f)\n{\n    int64_t stream_size = avio_size(f);\n    int64_t original_pos = avio_tell(f);\n    int64_t seek_ret;\n    int ret = -1;\n    if ((seek_ret = avio_seek(f, stream_size - 4, SEEK_SET)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    c->mfra_size = avio_rb32(f);\n    c->have_read_mfra_size = 1;\n    if (!c->mfra_size || c->mfra_size > stream_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (unreasonable size)\\n\");\n        goto fail;\n    }\n    if ((seek_ret = avio_seek(f, -((int64_t) c->mfra_size), SEEK_CUR)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    if (avio_rb32(f) != c->mfra_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (size mismatch)\\n\");\n        goto fail;\n    }\n    if (avio_rb32(f) != MKBETAG('m', 'f', 'r', 'a')) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (tag mismatch)\\n\");\n        goto fail;\n    }\n    av_log(c->fc, AV_LOG_VERBOSE, \"stream has mfra\\n\");\n    do {\n        ret = read_tfra(c, f);\n        if (ret < 0)\n            goto fail;\n    } while (!ret);\n    ret = 0;\n    c->frag_index.complete = 1;\nfail:\n    seek_ret = avio_seek(f, original_pos, SEEK_SET);\n    if (seek_ret < 0) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"failed to seek back after looking for mfra\\n\");\n        ret = seek_ret;\n    }\n    return ret;\n}\n\nstatic int mov_read_header(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int j, err;\n    MOVAtom atom = { AV_RL32(\"root\") };\n    int i;\n\n    if (mov->decryption_key_len != 0 && mov->decryption_key_len != AES_CTR_KEY_SIZE) {\n        av_log(s, AV_LOG_ERROR, \"Invalid decryption key len %d expected %d\\n\",\n            mov->decryption_key_len, AES_CTR_KEY_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    mov->fc = s;\n    mov->trak_index = -1;\n    /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL)\n        atom.size = avio_size(pb);\n    else\n        atom.size = INT64_MAX;\n\n    /* check MOV header */\n    do {\n        if (mov->moov_retry)\n            avio_seek(pb, 0, SEEK_SET);\n        if ((err = mov_read_default(mov, pb, atom)) < 0) {\n            av_log(s, AV_LOG_ERROR, \"error reading header\\n\");\n            return err;\n        }\n    } while ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !mov->found_moov && !mov->moov_retry++);\n    if (!mov->found_moov) {\n        av_log(s, AV_LOG_ERROR, \"moov atom not found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    av_log(mov->fc, AV_LOG_TRACE, \"on_parse_exit_offset=%\"PRId64\"\\n\", avio_tell(pb));\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        if (mov->nb_chapter_tracks > 0 && !mov->ignore_chapters)\n            mov_read_chapters(s);\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"tmcd\")) {\n                mov_read_timecode_track(s, s->streams[i]);\n            } else if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"rtmd\")) {\n                mov_read_rtmd_track(s, s->streams[i]);\n            }\n    }\n\n    /* copy timecode metadata from tmcd tracks to the related video streams */\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n        if (sc->timecode_track > 0) {\n            AVDictionaryEntry *tcr;\n            int tmcd_st_id = -1;\n\n            for (j = 0; j < s->nb_streams; j++)\n                if (s->streams[j]->id == sc->timecode_track)\n                    tmcd_st_id = j;\n\n            if (tmcd_st_id < 0 || tmcd_st_id == i)\n                continue;\n            tcr = av_dict_get(s->streams[tmcd_st_id]->metadata, \"timecode\", NULL, 0);\n            if (tcr)\n                av_dict_set(&st->metadata, \"timecode\", tcr->value, 0);\n        }\n    }\n    export_orphan_timecode(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        FFStream *const sti = ffstream(st);\n        MOVStreamContext *sc = st->priv_data;\n        fix_timescale(mov, sc);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n            st->codecpar->codec_id   == AV_CODEC_ID_AAC) {\n            sti->skip_samples = sc->start_pad;\n        }\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sc->nb_frames_for_fps > 0 && sc->duration_for_fps > 0)\n            av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,\n                      sc->time_scale*(int64_t)sc->nb_frames_for_fps, sc->duration_for_fps, INT_MAX);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            if (st->codecpar->width <= 0 || st->codecpar->height <= 0) {\n                st->codecpar->width  = sc->width;\n                st->codecpar->height = sc->height;\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_DVD_SUBTITLE) {\n                if ((err = mov_rewrite_dvd_sub_extradata(st)) < 0)\n                    return err;\n            }\n        }\n        if (mov->handbrake_version &&\n            mov->handbrake_version <= 1000000*0 + 1000*10 + 2 &&  // 0.10.2\n            st->codecpar->codec_id == AV_CODEC_ID_MP3) {\n            av_log(s, AV_LOG_VERBOSE, \"Forcing full parsing for mp3 stream\\n\");\n            sti->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    if (mov->trex_data) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (st->duration > 0) {\n                /* Akin to sc->data_size * 8 * sc->time_scale / st->duration but accounting for overflows. */\n                st->codecpar->bit_rate = av_rescale(sc->data_size, ((int64_t) sc->time_scale) * 8, st->duration);\n                if (st->codecpar->bit_rate == INT64_MIN) {\n                    av_log(s, AV_LOG_WARNING, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    st->codecpar->bit_rate = 0;\n                    if (s->error_recognition & AV_EF_EXPLODE)\n                        return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n\n    if (mov->use_mfra_for > 0) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (sc->duration_for_fps > 0) {\n                /* Akin to sc->data_size * 8 * sc->time_scale / sc->duration_for_fps but accounting for overflows. */\n                st->codecpar->bit_rate = av_rescale(sc->data_size, ((int64_t) sc->time_scale) * 8, sc->duration_for_fps);\n                if (st->codecpar->bit_rate == INT64_MIN) {\n                    av_log(s, AV_LOG_WARNING, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    st->codecpar->bit_rate = 0;\n                    if (s->error_recognition & AV_EF_EXPLODE)\n                        return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < mov->bitrates_count && i < s->nb_streams; i++) {\n        if (mov->bitrates[i]) {\n            s->streams[i]->codecpar->bit_rate = mov->bitrates[i];\n        }\n    }\n\n    ff_rfps_calculate(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        switch (st->codecpar->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            err = ff_replaygain_export(st, s->metadata);\n            if (err < 0)\n                return err;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (sc->display_matrix) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, (uint8_t*)sc->display_matrix,\n                                              sizeof(int32_t) * 9);\n                if (err < 0)\n                    return err;\n\n                sc->display_matrix = NULL;\n            }\n            if (sc->stereo3d) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_STEREO3D,\n                                              (uint8_t *)sc->stereo3d,\n                                              sizeof(*sc->stereo3d));\n                if (err < 0)\n                    return err;\n\n                sc->stereo3d = NULL;\n            }\n            if (sc->spherical) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_SPHERICAL,\n                                              (uint8_t *)sc->spherical,\n                                              sc->spherical_size);\n                if (err < 0)\n                    return err;\n\n                sc->spherical = NULL;\n            }\n            if (sc->mastering) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,\n                                              (uint8_t *)sc->mastering,\n                                              sizeof(*sc->mastering));\n                if (err < 0)\n                    return err;\n\n                sc->mastering = NULL;\n            }\n            if (sc->coll) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,\n                                              (uint8_t *)sc->coll,\n                                              sc->coll_size);\n                if (err < 0)\n                    return err;\n\n                sc->coll = NULL;\n            }\n            break;\n        }\n    }\n    ff_configure_buffers_for_index(s, AV_TIME_BASE);\n\n    for (i = 0; i < mov->frag_index.nb_items; i++)\n        if (mov->frag_index.item[i].moof_offset <= mov->fragment.moof_offset)\n            mov->frag_index.item[i].headers_read = 1;\n\n    return 0;\n}\n\nstatic AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)\n{\n    AVIndexEntry *sample = NULL;\n    int64_t best_dts = INT64_MAX;\n    int i;\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *avst = s->streams[i];\n        FFStream *const avsti = ffstream(avst);\n        MOVStreamContext *msc = avst->priv_data;\n        if (msc->pb && msc->current_sample < avsti->nb_index_entries) {\n            AVIndexEntry *current_sample = &avsti->index_entries[msc->current_sample];\n            int64_t dts = av_rescale(current_sample->timestamp, AV_TIME_BASE, msc->time_scale);\n            av_log(s, AV_LOG_TRACE, \"stream %d, sample %d, dts %\"PRId64\"\\n\", i, msc->current_sample, dts);\n            if (!sample || (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && current_sample->pos < sample->pos) ||\n                ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) &&\n                 ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb && dts != AV_NOPTS_VALUE &&\n                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||\n                  (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {\n                sample = current_sample;\n                best_dts = dts;\n                *st = avst;\n            }\n        }\n    }\n    return sample;\n}\n\nstatic int should_retry(AVIOContext *pb, int error_code) {\n    if (error_code == AVERROR_EOF || avio_feof(pb))\n        return 0;\n\n    return 1;\n}\n\nstatic int mov_switch_root(AVFormatContext *s, int64_t target, int index)\n{\n    int ret;\n    MOVContext *mov = s->priv_data;\n\n    if (index >= 0 && index < mov->frag_index.nb_items)\n        target = mov->frag_index.item[index].moof_offset;\n    if (avio_seek(s->pb, target, SEEK_SET) != target) {\n        av_log(mov->fc, AV_LOG_ERROR, \"root atom offset 0x%\"PRIx64\": partial file\\n\", target);\n        return AVERROR_INVALIDDATA;\n    }\n\n    mov->next_root_atom = 0;\n    if (index < 0 || index >= mov->frag_index.nb_items)\n        index = search_frag_moof_offset(&mov->frag_index, target);\n    if (index < mov->frag_index.nb_items &&\n        mov->frag_index.item[index].moof_offset == target) {\n        if (index + 1 < mov->frag_index.nb_items)\n            mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;\n        if (mov->frag_index.item[index].headers_read)\n            return 0;\n        mov->frag_index.item[index].headers_read = 1;\n    }\n\n    mov->found_mdat = 0;\n\n    ret = mov_read_default(mov, s->pb, (MOVAtom){ AV_RL32(\"root\"), INT64_MAX });\n    if (ret < 0)\n        return ret;\n    if (avio_feof(s->pb))\n        return AVERROR_EOF;\n    av_log(s, AV_LOG_TRACE, \"read fragments, offset 0x%\"PRIx64\"\\n\", avio_tell(s->pb));\n\n    return 1;\n}\n\nstatic int mov_change_extradata(MOVStreamContext *sc, AVPacket *pkt)\n{\n    uint8_t *side, *extradata;\n    int extradata_size;\n\n    /* Save the current index. */\n    sc->last_stsd_index = sc->stsc_data[sc->stsc_index].id - 1;\n\n    /* Notify the decoder that extradata changed. */\n    extradata_size = sc->extradata_size[sc->last_stsd_index];\n    extradata = sc->extradata[sc->last_stsd_index];\n    if (extradata_size > 0 && extradata) {\n        side = av_packet_new_side_data(pkt,\n                                       AV_PKT_DATA_NEW_EXTRADATA,\n                                       extradata_size);\n        if (!side)\n            return AVERROR(ENOMEM);\n        memcpy(side, extradata, extradata_size);\n    }\n\n    return 0;\n}\n\nstatic int get_eia608_packet(AVIOContext *pb, AVPacket *pkt, int size)\n{\n    int new_size, ret;\n\n    if (size <= 8)\n        return AVERROR_INVALIDDATA;\n    new_size = ((size - 8) / 2) * 3;\n    ret = av_new_packet(pkt, new_size);\n    if (ret < 0)\n        return ret;\n\n    avio_skip(pb, 8);\n    for (int j = 0; j < new_size; j += 3) {\n        pkt->data[j] = 0xFC;\n        pkt->data[j+1] = avio_r8(pb);\n        pkt->data[j+2] = avio_r8(pb);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    AVIndexEntry *sample;\n    AVStream *st = NULL;\n    int64_t current_index;\n    int ret;\n    mov->fc = s;\n retry:\n    sample = mov_find_next_sample(s, &st);\n    if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {\n        if (!mov->next_root_atom)\n            return AVERROR_EOF;\n        if ((ret = mov_switch_root(s, mov->next_root_atom, -1)) < 0)\n            return ret;\n        goto retry;\n    }\n    sc = st->priv_data;\n    /* must be done just before reading, to avoid infinite loop on sample */\n    current_index = sc->current_index;\n    mov_current_sample_inc(sc);\n\n    if (mov->next_root_atom) {\n        sample->pos = FFMIN(sample->pos, mov->next_root_atom);\n        sample->size = FFMIN(sample->size, (mov->next_root_atom - sample->pos));\n    }\n\n    if (st->discard != AVDISCARD_ALL) {\n        int64_t ret64 = avio_seek(sc->pb, sample->pos, SEEK_SET);\n        if (ret64 != sample->pos) {\n            av_log(mov->fc, AV_LOG_ERROR, \"stream %d, offset 0x%\"PRIx64\": partial file\\n\",\n                   sc->ffindex, sample->pos);\n            if (should_retry(sc->pb, ret64)) {\n                mov_current_sample_dec(sc);\n            } else if (ret64 < 0) {\n                return (int)ret64;\n            }\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (st->discard == AVDISCARD_NONKEY && !(sample->flags & AVINDEX_KEYFRAME)) {\n            av_log(mov->fc, AV_LOG_DEBUG, \"Nonkey frame from stream %d discarded due to AVDISCARD_NONKEY\\n\", sc->ffindex);\n            goto retry;\n        }\n\n        if (st->codecpar->codec_id == AV_CODEC_ID_EIA_608 && sample->size > 8)\n            ret = get_eia608_packet(sc->pb, pkt, sample->size);\n        else\n            ret = av_get_packet(sc->pb, pkt, sample->size);\n        if (ret < 0) {\n            if (should_retry(sc->pb, ret)) {\n                mov_current_sample_dec(sc);\n            }\n            return ret;\n        }\n#if CONFIG_DV_DEMUXER\n        if (mov->dv_demux && sc->dv_audio_container) {\n            ret = avpriv_dv_produce_packet(mov->dv_demux, pkt, pkt->data, pkt->size, pkt->pos);\n            av_packet_unref(pkt);\n            if (ret < 0)\n                return ret;\n            ret = avpriv_dv_get_packet(mov->dv_demux, pkt);\n            if (ret < 0)\n                return ret;\n        }\n#endif\n        if (sc->has_palette) {\n            uint8_t *pal;\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n            if (!pal) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n            } else {\n                memcpy(pal, sc->palette, AVPALETTE_SIZE);\n                sc->has_palette = 0;\n            }\n        }\n        if (st->codecpar->codec_id == AV_CODEC_ID_MP3 && !ffstream(st)->need_parsing && pkt->size > 4) {\n            if (ff_mpa_check_header(AV_RB32(pkt->data)) < 0)\n                ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    pkt->stream_index = sc->ffindex;\n    pkt->dts = sample->timestamp;\n    if (sample->flags & AVINDEX_DISCARD_FRAME) {\n        pkt->flags |= AV_PKT_FLAG_DISCARD;\n    }\n    if (sc->ctts_data && sc->ctts_index < sc->ctts_count) {\n        pkt->pts = pkt->dts + sc->dts_shift + sc->ctts_data[sc->ctts_index].duration;\n        /* update ctts context */\n        sc->ctts_sample++;\n        if (sc->ctts_index < sc->ctts_count &&\n            sc->ctts_data[sc->ctts_index].count == sc->ctts_sample) {\n            sc->ctts_index++;\n            sc->ctts_sample = 0;\n        }\n    } else {\n        int64_t next_dts = (sc->current_sample < ffstream(st)->nb_index_entries) ?\n            ffstream(st)->index_entries[sc->current_sample].timestamp : st->duration;\n\n        if (next_dts >= pkt->dts)\n            pkt->duration = next_dts - pkt->dts;\n        pkt->pts = pkt->dts;\n    }\n    if (st->discard == AVDISCARD_ALL)\n        goto retry;\n    if (sc->sdtp_data && sc->current_sample <= sc->sdtp_count) {\n        uint8_t sample_flags = sc->sdtp_data[sc->current_sample - 1];\n        uint8_t sample_is_depended_on = (sample_flags >> 2) & 0x3;\n        pkt->flags |= sample_is_depended_on == MOV_SAMPLE_DEPENDENCY_NO ? AV_PKT_FLAG_DISPOSABLE : 0;\n    }\n    pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : 0;\n    pkt->pos = sample->pos;\n\n    /* Multiple stsd handling. */\n    if (sc->stsc_data) {\n        if (sc->stsc_data[sc->stsc_index].id > 0 &&\n            sc->stsc_data[sc->stsc_index].id - 1 < sc->stsd_count &&\n            sc->stsc_data[sc->stsc_index].id - 1 != sc->last_stsd_index) {\n            ret = mov_change_extradata(sc, pkt);\n            if (ret < 0)\n                return ret;\n        }\n\n        /* Update the stsc index for the next sample */\n        sc->stsc_sample++;\n        if (mov_stsc_index_valid(sc->stsc_index, sc->stsc_count) &&\n            mov_get_stsc_samples(sc, sc->stsc_index) == sc->stsc_sample) {\n            sc->stsc_index++;\n            sc->stsc_sample = 0;\n        }\n    }\n\n    if (mov->aax_mode)\n        aax_filter(pkt->data, pkt->size, mov);\n\n    ret = cenc_filter(mov, st, sc, pkt, current_index);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n{\n    MOVContext *mov = s->priv_data;\n    int index;\n\n    if (!mov->frag_index.complete)\n        return 0;\n\n    index = search_frag_timestamp(s, &mov->frag_index, st, timestamp);\n    if (index < 0)\n        index = 0;\n    if (!mov->frag_index.item[index].headers_read)\n        return mov_switch_root(s, -1, index);\n    if (index + 1 < mov->frag_index.nb_items)\n        mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;\n\n    return 0;\n}\n\nstatic int is_open_key_sample(const MOVStreamContext *sc, int sample)\n{\n    // TODO: a bisect search would scale much better\n    for (int i = 0; i < sc->open_key_samples_count; i++) {\n        const int oks = sc->open_key_samples[i];\n        if (oks == sample)\n            return 1;\n        if (oks > sample) /* list is monotically increasing so we can stop early */\n            break;\n    }\n    return 0;\n}\n\n/*\n * Some key sample may be key frames but not IDR frames, so a random access to\n * them may not be allowed.\n */\nstatic int can_seek_to_key_sample(AVStream *st, int sample, int64_t requested_pts)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int64_t key_sample_dts, key_sample_pts;\n\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC)\n        return 1;\n\n    if (sample >= sc->sample_offsets_count)\n        return 1;\n\n    key_sample_dts = sti->index_entries[sample].timestamp;\n    key_sample_pts = key_sample_dts + sc->sample_offsets[sample] + sc->dts_shift;\n\n    /*\n     * If the sample needs to be presented before an open key sample, they may\n     * not be decodable properly, even though they come after in decoding\n     * order.\n     */\n    if (is_open_key_sample(sc, sample) && key_sample_pts > requested_pts)\n        return 0;\n\n    return 1;\n}\n\nstatic int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int sample, time_sample, ret;\n    unsigned int i;\n\n    // Here we consider timestamp to be PTS, hence try to offset it so that we\n    // can search over the DTS timeline.\n    timestamp -= (sc->min_corrected_pts + sc->dts_shift);\n\n    ret = mov_seek_fragment(s, st, timestamp);\n    if (ret < 0)\n        return ret;\n\n    for (;;) {\n        sample = av_index_search_timestamp(st, timestamp, flags);\n        av_log(s, AV_LOG_TRACE, \"stream %d, timestamp %\"PRId64\", sample %d\\n\", st->index, timestamp, sample);\n        if (sample < 0 && sti->nb_index_entries && timestamp < sti->index_entries[0].timestamp)\n            sample = 0;\n        if (sample < 0) /* not sure what to do */\n            return AVERROR_INVALIDDATA;\n\n        if (!sample || can_seek_to_key_sample(st, sample, timestamp))\n            break;\n        timestamp -= FFMAX(sc->min_sample_duration, 1);\n    }\n\n    mov_current_sample_set(sc, sample);\n    av_log(s, AV_LOG_TRACE, \"stream %d, found sample %d\\n\", st->index, sc->current_sample);\n    /* adjust ctts index */\n    if (sc->ctts_data) {\n        time_sample = 0;\n        for (i = 0; i < sc->ctts_count; i++) {\n            int next = time_sample + sc->ctts_data[i].count;\n            if (next > sc->current_sample) {\n                sc->ctts_index = i;\n                sc->ctts_sample = sc->current_sample - time_sample;\n                break;\n            }\n            time_sample = next;\n        }\n    }\n\n    /* adjust stsd index */\n    if (sc->chunk_count) {\n        time_sample = 0;\n        for (i = 0; i < sc->stsc_count; i++) {\n            int64_t next = time_sample + mov_get_stsc_samples(sc, i);\n            if (next > sc->current_sample) {\n                sc->stsc_index = i;\n                sc->stsc_sample = sc->current_sample - time_sample;\n                break;\n            }\n            av_assert0(next == (int)next);\n            time_sample = next;\n        }\n    }\n\n    return sample;\n}\n\nstatic int64_t mov_get_skip_samples(AVStream *st, int sample)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    int64_t first_ts = sti->index_entries[0].timestamp;\n    int64_t ts = sti->index_entries[sample].timestamp;\n    int64_t off;\n\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO)\n        return 0;\n\n    /* compute skip samples according to stream start_pad, seek ts and first ts */\n    off = av_rescale_q(ts - first_ts, st->time_base,\n                       (AVRational){1, st->codecpar->sample_rate});\n    return FFMAX(sc->start_pad - off, 0);\n}\n\nstatic int mov_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    MOVContext *mc = s->priv_data;\n    AVStream *st;\n    FFStream *sti;\n    int sample;\n    int i;\n\n    if (stream_index >= s->nb_streams)\n        return AVERROR_INVALIDDATA;\n\n    st = s->streams[stream_index];\n    sti = ffstream(st);\n    sample = mov_seek_stream(s, st, sample_time, flags);\n    if (sample < 0)\n        return sample;\n\n    if (mc->seek_individually) {\n        /* adjust seek timestamp to found sample timestamp */\n        int64_t seek_timestamp = sti->index_entries[sample].timestamp;\n        sti->skip_samples = mov_get_skip_samples(st, sample);\n\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *const st  = s->streams[i];\n            FFStream *const sti = ffstream(st);\n            int64_t timestamp;\n\n            if (stream_index == i)\n                continue;\n\n            timestamp = av_rescale_q(seek_timestamp, s->streams[stream_index]->time_base, st->time_base);\n            sample = mov_seek_stream(s, st, timestamp, flags);\n            if (sample >= 0)\n                sti->skip_samples = mov_get_skip_samples(st, sample);\n        }\n    } else {\n        for (i = 0; i < s->nb_streams; i++) {\n            MOVStreamContext *sc;\n            st = s->streams[i];\n            sc = st->priv_data;\n            mov_current_sample_set(sc, 0);\n        }\n        while (1) {\n            MOVStreamContext *sc;\n            AVIndexEntry *entry = mov_find_next_sample(s, &st);\n            if (!entry)\n                return AVERROR_INVALIDDATA;\n            sc = st->priv_data;\n            if (sc->ffindex == stream_index && sc->current_sample == sample)\n                break;\n            mov_current_sample_inc(sc);\n        }\n    }\n    return 0;\n}\n\n#define OFFSET(x) offsetof(MOVContext, x)\n#define FLAGS AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption mov_options[] = {\n    {\"use_absolute_path\",\n        \"allow using absolute path when opening alias, this is a possible security issue\",\n        OFFSET(use_absolute_path), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"seek_streams_individually\",\n        \"Seek each stream individually to the closest point\",\n        OFFSET(seek_individually), AV_OPT_TYPE_BOOL, { .i64 = 1 },\n        0, 1, FLAGS},\n    {\"ignore_editlist\", \"Ignore the edit list atom.\", OFFSET(ignore_editlist), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"advanced_editlist\",\n        \"Modify the AVIndex according to the editlists. Use this option to decode in the order specified by the edits.\",\n        OFFSET(advanced_editlist), AV_OPT_TYPE_BOOL, {.i64 = 1},\n        0, 1, FLAGS},\n    {\"ignore_chapters\", \"\", OFFSET(ignore_chapters), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"use_mfra_for\",\n        \"use mfra for fragment timestamps\",\n        OFFSET(use_mfra_for), AV_OPT_TYPE_INT, {.i64 = FF_MOV_FLAG_MFRA_AUTO},\n        -1, FF_MOV_FLAG_MFRA_PTS, FLAGS,\n        \"use_mfra_for\"},\n    {\"auto\", \"auto\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_AUTO}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"dts\", \"dts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_DTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"pts\", \"pts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_PTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"use_tfdt\", \"use tfdt for fragment timestamps\", OFFSET(use_tfdt), AV_OPT_TYPE_BOOL, {.i64 = 1},\n        0, 1, FLAGS},\n    { \"export_all\", \"Export unrecognized metadata entries\", OFFSET(export_all),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"export_xmp\", \"Export full XMP metadata\", OFFSET(export_xmp),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"activation_bytes\", \"Secret bytes for Audible AAX files\", OFFSET(activation_bytes),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_key\", \"AES-128 Key for Audible AAXC files\", OFFSET(audible_key),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_iv\", \"AES-128 IV for Audible AAXC files\", OFFSET(audible_iv),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_fixed_key\", // extracted from libAAX_SDK.so and AAXSDKWin.dll files!\n        \"Fixed key used for handling Audible AAX files\", OFFSET(audible_fixed_key),\n        AV_OPT_TYPE_BINARY, {.str=\"77214d4b196a87cd520045fd20a51d67\"},\n        .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"decryption_key\", \"The media decryption key (hex)\", OFFSET(decryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"enable_drefs\", \"Enable external track support.\", OFFSET(enable_drefs), AV_OPT_TYPE_BOOL,\n        {.i64 = 0}, 0, 1, FLAGS },\n    { \"max_stts_delta\", \"treat offsets above this value as invalid\", OFFSET(max_stts_delta), AV_OPT_TYPE_INT, {.i64 = UINT_MAX-48000*10 }, 0, UINT_MAX, .flags = AV_OPT_FLAG_DECODING_PARAM },\n\n    { NULL },\n};\n\nstatic const AVClass mov_class = {\n    .class_name = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .item_name  = av_default_item_name,\n    .option     = mov_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nconst AVInputFormat ff_mov_demuxer = {\n    .name           = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),\n    .priv_class     = &mov_class,\n    .priv_data_size = sizeof(MOVContext),\n    .extensions     = \"mov,mp4,m4a,3gp,3g2,mj2,psp,m4b,ism,ismv,isma,f4v,avif\",\n    .flags_internal = FF_FMT_INIT_CLEANUP,\n    .read_probe     = mov_probe,\n    .read_header    = mov_read_header,\n    .read_packet    = mov_read_packet,\n    .read_close     = mov_read_close,\n    .read_seek      = mov_read_seek,\n    .flags          = AVFMT_NO_BYTE_SEEK | AVFMT_SEEK_TO_PTS | AVFMT_SHOW_IDS,\n};\n"], "filenames": ["libavformat/mov.c"], "buggy_code_start_loc": [3970], "buggy_code_end_loc": [4001], "fixing_code_start_loc": [3970], "fixing_code_end_loc": [4010], "type": "CWE-787", "message": "A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05", "other": {"cve": {"id": "CVE-2022-2566", "sourceIdentifier": "cve-coordination@google.com", "published": "2022-09-23T12:15:10.103", "lastModified": "2022-10-01T02:27:40.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05"}, {"lang": "es", "value": "Existe una escritura de memoria fuera de los l\u00edmites del mont\u00f3n en FFMPEG desde la versi\u00f3n 5.1. El c\u00e1lculo del tama\u00f1o en `build_open_gop_key_points()` recorre todas las entradas del bucle y a\u00f1ade `sc-&gt;ctts_data[i].count` a `sc-&gt;sample_offsets_count`. Esto puede conducir a un desbordamiento de enteros que resulta en una peque\u00f1a asignaci\u00f3n con `av_calloc()`. Un atacante puede provocar la ejecuci\u00f3n remota de c\u00f3digo a trav\u00e9s de un archivo mp4 malicioso. Recomendamos actualizar el commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.2, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:5.1:*:*:*:*:*:*:*", "matchCriteriaId": "B9105334-E041-4B8A-8EF2-79FBC94391F1"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/c953baa084607dd1d84c3bfcce3cf6a87c3e6e05", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c953baa084607dd1d84c3bfcce3cf6a87c3e6e05"}}