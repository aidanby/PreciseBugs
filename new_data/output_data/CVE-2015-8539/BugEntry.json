{"buggy_code": ["/*\n * Copyright (C) 2010 IBM Corporation\n * Copyright (C) 2010 Politecnico di Torino, Italy\n *                    TORSEC group -- http://security.polito.it\n *\n * Authors:\n * Mimi Zohar <zohar@us.ibm.com>\n * Roberto Sassu <roberto.sassu@polito.it>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/ctype.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <crypto/aes.h>\n\n#include \"encrypted.h\"\n#include \"ecryptfs_format.h\"\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\nstatic const char hash_alg[] = \"sha256\";\nstatic const char hmac_alg[] = \"hmac(sha256)\";\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_ECRYPTFS_DESC_LEN 16\n#define HASH_SIZE SHA256_DIGEST_SIZE\n#define MAX_DATA_SIZE 4096\n#define MIN_DATA_SIZE  20\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nenum {\n\tOpt_err = -1, Opt_new, Opt_load, Opt_update\n};\n\nenum {\n\tOpt_error = -1, Opt_default, Opt_ecryptfs\n};\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_blkcipher *tfm;\n\n\ttfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\tblksize = crypto_blkcipher_blocksize(tfm);\n\tcrypto_free_blkcipher(tfm);\n\treturn 0;\n}\n\n/*\n * valid_ecryptfs_desc - verify the description of a new/loaded encrypted key\n *\n * The description of a encrypted key with format 'ecryptfs' must contain\n * exactly 16 hexadecimal characters.\n *\n */\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * valid_master_desc - verify the 'key-type:desc' of a new/updated master-key\n *\n * key-type:= \"trusted:\" | \"user:\"\n * desc:= master-key description\n *\n * Verify that 'key-type' is valid and that 'desc' exists. On key update,\n * only the master key description is permitted to change, not the key-type.\n * The key-type remains constant.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}\n\n/*\n * datablob_parse - parse the keyctl data\n *\n * datablob format:\n * new [<format>] <master-key name> <decrypted data length>\n * load [<format>] <master-key name> <decrypted data length>\n *     <encrypted iv + data>\n * update <new-master-key name>\n *\n * Tokenizes a copy of the keyctl data, returning a pointer to each token,\n * which is null terminated.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n/*\n * datablob_format - format as an ascii string, before copying to userspace\n */\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}\n\n/*\n * request_user_key - request the user key\n *\n * Use a user provided key to encrypt/decrypt an encrypted-key.\n */\nstatic struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload(ukey);\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n\nstatic struct sdesc *alloc_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (!ret)\n\t\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int calc_hash(u8 *digest, const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nenum derived_key_type { ENC_KEY, AUTH_KEY };\n\n/* Derive authentication/encryption key from trusted key */\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf) {\n\t\tpr_err(\"encrypted_key: out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(derived_key, derived_buf, derived_buf_len);\n\tkfree(derived_buf);\n\treturn ret;\n}\n\nstatic int init_blkcipher_desc(struct blkcipher_desc *desc, const u8 *key,\n\t\t\t       unsigned int key_len, const u8 *iv,\n\t\t\t       unsigned int ivsize)\n{\n\tint ret;\n\n\tdesc->tfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc->tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(desc->tfm));\n\t\treturn PTR_ERR(desc->tfm);\n\t}\n\tdesc->flags = 0;\n\n\tret = crypto_blkcipher_setkey(desc->tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_blkcipher(desc->tfm);\n\t\treturn ret;\n\t}\n\tcrypto_blkcipher_set_iv(desc->tfm, iv, ivsize);\n\treturn 0;\n}\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = NULL;\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n\n/* Before returning data to userspace, encrypt decrypted data. */\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tunsigned int padlen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tpadlen = encrypted_datalen - epayload->decrypted_datalen;\n\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_in[1], pad, padlen);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\treturn ret;\n}\n\n/* verify HMAC before decrypting encrypted key */\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = memcmp(digest, epayload->format + epayload->datablob_len,\n\t\t     sizeof digest);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, sizeof pad);\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\treturn ret;\n}\n\n/* Allocate memory for decrypted key and datablob. */\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}\n\n/*\n * encrypted_init - initialize an encrypted key\n *\n * For a new key, use a random number for both the iv and data\n * itself.  For an old key, decrypt the hex encoded data.\n */\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}\n\n/*\n * encrypted_instantiate - instantiate an encrypted key\n *\n * Decrypt an existing encrypted datablob or create a new encrypted key\n * based on a kernel random number.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkfree(datablob);\n\treturn ret;\n}\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(epayload);\n}\n\n/*\n * encrypted_update - update the master key description\n *\n * Change the master key description for an existing encrypted key.\n * The next read will return an encrypted datablob using the new\n * master key description.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n/*\n * encrypted_read - format and copy the encrypted data to userspace\n *\n * The resulting datablob format is:\n * <master-key name> <decrypted data length> <encrypted iv> <encrypted data>\n *\n * On success, return to userspace the encrypted key datablob size.\n */\nstatic long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = rcu_dereference_key(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\n/*\n * encrypted_destroy - before freeing the key, clear the decrypted data\n *\n * Before freeing the key, clear the memory containing the decrypted\n * key data.\n */\nstatic void encrypted_destroy(struct key *key)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\n\tif (!epayload)\n\t\treturn;\n\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_encrypted);\n\nstatic void encrypted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init encrypted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\tret = encrypted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = aes_get_sizes();\n\tif (ret < 0)\n\t\tgoto out;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\tencrypted_shash_release();\n\treturn ret;\n\n}\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tencrypted_shash_release();\n\tunregister_key_type(&key_type_encrypted);\n}\n\nlate_initcall(init_encrypted);\nmodule_exit(cleanup_encrypted);\n\nMODULE_LICENSE(\"GPL\");\n", "/*\n * Copyright (C) 2010 IBM Corporation\n *\n * Author:\n * David Safford <safford@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <linux/key-type.h>\n#include <linux/rcupdate.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <linux/capability.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include \"trusted.h\"\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * calculate authorization info fields to send to TPM\n */\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH1_COMMAND (Seal) result from TPM\n */\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH2_COMMAND (unseal) result from TPM\n */\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * For key specific tpm requests, we will generate and send our\n * own TPM command packets using the drivers send function.\n */\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}\n\n/*\n * Lock a trusted key, by extending a selected PCR.\n *\n * Prevents a trusted key that is sealed to PCRs from being accessed.\n * This uses the tpm driver's extend function.\n */\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}\n\n/*\n * Create an object specific authorisation protocol (OSAP) session\n */\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}\n\n/*\n * Create an object independent authorisation protocol (oiap) session\n */\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}\n\nstruct tpm_digests {\n\tunsigned char encauth[SHA1_DIGEST_SIZE];\n\tunsigned char pubauth[SHA1_DIGEST_SIZE];\n\tunsigned char xorwork[SHA1_DIGEST_SIZE * 2];\n\tunsigned char xorhash[SHA1_DIGEST_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n};\n\n/*\n * Have the TPM seal(encrypt) the trusted key, possibly based on\n * Platform Configuration Registers (PCRs). AUTH1 for sealing key.\n */\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkfree(td);\n\treturn ret;\n}\n\n/*\n * use the AUTH2_COMMAND form of unseal, to authorize both key and blob\n */\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}\n\n/*\n * Have the TPM seal(encrypt) the symmetric key\n */\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkfree(tb);\n\treturn ret;\n}\n\n/*\n * Have the TPM unseal(decrypt) the symmetric key\n */\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkfree(tb);\n\treturn ret;\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_new, Opt_load, Opt_update,\n\tOpt_keyhandle, Opt_keyauth, Opt_blobauth,\n\tOpt_pcrinfo, Opt_pcrlock, Opt_migratable\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_err, NULL}\n};\n\n/* can have zero or more token= options */\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data and fill in the\n * \t\t    payload and options structures\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}\n\n/*\n * trusted_instantiate - create a new trusted key\n *\n * Unseal an existing trusted blob or, for a new key, get a\n * random key, then seal and create a trusted key-type key,\n * adding it to the specified keyring.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tif (!options->keyhandle) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tif (tpm2)\n\t\t\tret = tpm_unseal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (tpm2)\n\t\t\tret = tpm_seal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkfree(datablob);\n\tkfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkfree(payload);\n\treturn ret;\n}\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tmemset(p->key, 0, p->key_len);\n\tkfree(p);\n}\n\n/*\n * trusted_update - reseal an existing key with new PCR values\n */\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data[0];\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}\n\n/*\n * trusted_read - copy the sealed blob data to userspace in hex.\n * On success, return to userspace the trusted key datablob size.\n */\nstatic long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = rcu_dereference_key(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\tif (!buffer || buflen <= 0)\n\t\treturn 2 * p->blob_len;\n\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\treturn -ENOMEM;\n\n\tbufp = ascii_buf;\n\tfor (i = 0; i < p->blob_len; i++)\n\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\tif ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {\n\t\tkfree(ascii_buf);\n\t\treturn -EFAULT;\n\t}\n\tkfree(ascii_buf);\n\treturn 2 * p->blob_len;\n}\n\n/*\n * trusted_destroy - before freeing the key, clear the decrypted data\n */\nstatic void trusted_destroy(struct key *key)\n{\n\tstruct trusted_key_payload *p = key->payload.data[0];\n\n\tif (!p)\n\t\treturn;\n\tmemset(p->key, 0, p->key_len);\n\tkfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_trusted);\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}\n\nstatic void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}\n\nlate_initcall(init_trusted);\nmodule_exit(cleanup_trusted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* user_defined.c: user defined key type\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n\nstatic int logon_vet_description(const char *desc);\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_user = {\n\t.name\t\t\t= \"user\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_user);\n\n/*\n * This key type is essentially the same as key_type_user, but it does\n * not define a .read op. This is suitable for storing username and\n * password pairs in the keyring that you do not want to be readable\n * from userspace.\n */\nstruct key_type key_type_logon = {\n\t.name\t\t\t= \"logon\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.vet_description\t= logon_vet_description,\n};\nEXPORT_SYMBOL_GPL(key_type_logon);\n\n/*\n * Preparse a user defined key payload\n */\nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload.data[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(user_preparse);\n\n/*\n * Free a preparse of a user defined key payload\n */\nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkfree(prep->payload.data[0]);\n}\nEXPORT_SYMBOL_GPL(user_free_preparse);\n\n/*\n * update a user defined key\n * - the key's semaphore is write-locked\n */\nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_update);\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tkfree_rcu(upayload, rcu);\n\t}\n}\n\nEXPORT_SYMBOL(user_revoke);\n\n/*\n * dispose of the data dangling from the corpse of a user key\n */\nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\tkfree(upayload);\n}\n\nEXPORT_SYMBOL_GPL(user_destroy);\n\n/*\n * describe the user key\n */\nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n\nEXPORT_SYMBOL_GPL(user_describe);\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_read);\n\n/* Vet the description for a \"logon\" key */\nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2010 IBM Corporation\n * Copyright (C) 2010 Politecnico di Torino, Italy\n *                    TORSEC group -- http://security.polito.it\n *\n * Authors:\n * Mimi Zohar <zohar@us.ibm.com>\n * Roberto Sassu <roberto.sassu@polito.it>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/ctype.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <crypto/aes.h>\n\n#include \"encrypted.h\"\n#include \"ecryptfs_format.h\"\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\nstatic const char hash_alg[] = \"sha256\";\nstatic const char hmac_alg[] = \"hmac(sha256)\";\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_ECRYPTFS_DESC_LEN 16\n#define HASH_SIZE SHA256_DIGEST_SIZE\n#define MAX_DATA_SIZE 4096\n#define MIN_DATA_SIZE  20\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nenum {\n\tOpt_err = -1, Opt_new, Opt_load, Opt_update\n};\n\nenum {\n\tOpt_error = -1, Opt_default, Opt_ecryptfs\n};\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_blkcipher *tfm;\n\n\ttfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\tblksize = crypto_blkcipher_blocksize(tfm);\n\tcrypto_free_blkcipher(tfm);\n\treturn 0;\n}\n\n/*\n * valid_ecryptfs_desc - verify the description of a new/loaded encrypted key\n *\n * The description of a encrypted key with format 'ecryptfs' must contain\n * exactly 16 hexadecimal characters.\n *\n */\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * valid_master_desc - verify the 'key-type:desc' of a new/updated master-key\n *\n * key-type:= \"trusted:\" | \"user:\"\n * desc:= master-key description\n *\n * Verify that 'key-type' is valid and that 'desc' exists. On key update,\n * only the master key description is permitted to change, not the key-type.\n * The key-type remains constant.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}\n\n/*\n * datablob_parse - parse the keyctl data\n *\n * datablob format:\n * new [<format>] <master-key name> <decrypted data length>\n * load [<format>] <master-key name> <decrypted data length>\n *     <encrypted iv + data>\n * update <new-master-key name>\n *\n * Tokenizes a copy of the keyctl data, returning a pointer to each token,\n * which is null terminated.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n/*\n * datablob_format - format as an ascii string, before copying to userspace\n */\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}\n\n/*\n * request_user_key - request the user key\n *\n * Use a user provided key to encrypt/decrypt an encrypted-key.\n */\nstatic struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload(ukey);\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n\nstatic struct sdesc *alloc_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (!ret)\n\t\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int calc_hash(u8 *digest, const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nenum derived_key_type { ENC_KEY, AUTH_KEY };\n\n/* Derive authentication/encryption key from trusted key */\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf) {\n\t\tpr_err(\"encrypted_key: out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(derived_key, derived_buf, derived_buf_len);\n\tkfree(derived_buf);\n\treturn ret;\n}\n\nstatic int init_blkcipher_desc(struct blkcipher_desc *desc, const u8 *key,\n\t\t\t       unsigned int key_len, const u8 *iv,\n\t\t\t       unsigned int ivsize)\n{\n\tint ret;\n\n\tdesc->tfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc->tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(desc->tfm));\n\t\treturn PTR_ERR(desc->tfm);\n\t}\n\tdesc->flags = 0;\n\n\tret = crypto_blkcipher_setkey(desc->tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_blkcipher(desc->tfm);\n\t\treturn ret;\n\t}\n\tcrypto_blkcipher_set_iv(desc->tfm, iv, ivsize);\n\treturn 0;\n}\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = NULL;\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n\n/* Before returning data to userspace, encrypt decrypted data. */\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tunsigned int padlen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tpadlen = encrypted_datalen - epayload->decrypted_datalen;\n\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_in[1], pad, padlen);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\treturn ret;\n}\n\n/* verify HMAC before decrypting encrypted key */\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = memcmp(digest, epayload->format + epayload->datablob_len,\n\t\t     sizeof digest);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, sizeof pad);\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\treturn ret;\n}\n\n/* Allocate memory for decrypted key and datablob. */\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}\n\n/*\n * encrypted_init - initialize an encrypted key\n *\n * For a new key, use a random number for both the iv and data\n * itself.  For an old key, decrypt the hex encoded data.\n */\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}\n\n/*\n * encrypted_instantiate - instantiate an encrypted key\n *\n * Decrypt an existing encrypted datablob or create a new encrypted key\n * based on a kernel random number.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkfree(datablob);\n\treturn ret;\n}\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(epayload);\n}\n\n/*\n * encrypted_update - update the master key description\n *\n * Change the master key description for an existing encrypted key.\n * The next read will return an encrypted datablob using the new\n * master key description.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n/*\n * encrypted_read - format and copy the encrypted data to userspace\n *\n * The resulting datablob format is:\n * <master-key name> <decrypted data length> <encrypted iv> <encrypted data>\n *\n * On success, return to userspace the encrypted key datablob size.\n */\nstatic long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = rcu_dereference_key(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\n/*\n * encrypted_destroy - before freeing the key, clear the decrypted data\n *\n * Before freeing the key, clear the memory containing the decrypted\n * key data.\n */\nstatic void encrypted_destroy(struct key *key)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\n\tif (!epayload)\n\t\treturn;\n\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_encrypted);\n\nstatic void encrypted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init encrypted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\tret = encrypted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = aes_get_sizes();\n\tif (ret < 0)\n\t\tgoto out;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\tencrypted_shash_release();\n\treturn ret;\n\n}\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tencrypted_shash_release();\n\tunregister_key_type(&key_type_encrypted);\n}\n\nlate_initcall(init_encrypted);\nmodule_exit(cleanup_encrypted);\n\nMODULE_LICENSE(\"GPL\");\n", "/*\n * Copyright (C) 2010 IBM Corporation\n *\n * Author:\n * David Safford <safford@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <linux/key-type.h>\n#include <linux/rcupdate.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <linux/capability.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include \"trusted.h\"\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * calculate authorization info fields to send to TPM\n */\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH1_COMMAND (Seal) result from TPM\n */\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH2_COMMAND (unseal) result from TPM\n */\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * For key specific tpm requests, we will generate and send our\n * own TPM command packets using the drivers send function.\n */\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}\n\n/*\n * Lock a trusted key, by extending a selected PCR.\n *\n * Prevents a trusted key that is sealed to PCRs from being accessed.\n * This uses the tpm driver's extend function.\n */\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}\n\n/*\n * Create an object specific authorisation protocol (OSAP) session\n */\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}\n\n/*\n * Create an object independent authorisation protocol (oiap) session\n */\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}\n\nstruct tpm_digests {\n\tunsigned char encauth[SHA1_DIGEST_SIZE];\n\tunsigned char pubauth[SHA1_DIGEST_SIZE];\n\tunsigned char xorwork[SHA1_DIGEST_SIZE * 2];\n\tunsigned char xorhash[SHA1_DIGEST_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n};\n\n/*\n * Have the TPM seal(encrypt) the trusted key, possibly based on\n * Platform Configuration Registers (PCRs). AUTH1 for sealing key.\n */\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkfree(td);\n\treturn ret;\n}\n\n/*\n * use the AUTH2_COMMAND form of unseal, to authorize both key and blob\n */\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}\n\n/*\n * Have the TPM seal(encrypt) the symmetric key\n */\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkfree(tb);\n\treturn ret;\n}\n\n/*\n * Have the TPM unseal(decrypt) the symmetric key\n */\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkfree(tb);\n\treturn ret;\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_new, Opt_load, Opt_update,\n\tOpt_keyhandle, Opt_keyauth, Opt_blobauth,\n\tOpt_pcrinfo, Opt_pcrlock, Opt_migratable\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_err, NULL}\n};\n\n/* can have zero or more token= options */\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data and fill in the\n * \t\t    payload and options structures\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}\n\n/*\n * trusted_instantiate - create a new trusted key\n *\n * Unseal an existing trusted blob or, for a new key, get a\n * random key, then seal and create a trusted key-type key,\n * adding it to the specified keyring.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tif (!options->keyhandle) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tif (tpm2)\n\t\t\tret = tpm_unseal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (tpm2)\n\t\t\tret = tpm_seal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkfree(datablob);\n\tkfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkfree(payload);\n\treturn ret;\n}\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tmemset(p->key, 0, p->key_len);\n\tkfree(p);\n}\n\n/*\n * trusted_update - reseal an existing key with new PCR values\n */\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}\n\n/*\n * trusted_read - copy the sealed blob data to userspace in hex.\n * On success, return to userspace the trusted key datablob size.\n */\nstatic long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = rcu_dereference_key(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\tif (!buffer || buflen <= 0)\n\t\treturn 2 * p->blob_len;\n\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\treturn -ENOMEM;\n\n\tbufp = ascii_buf;\n\tfor (i = 0; i < p->blob_len; i++)\n\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\tif ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {\n\t\tkfree(ascii_buf);\n\t\treturn -EFAULT;\n\t}\n\tkfree(ascii_buf);\n\treturn 2 * p->blob_len;\n}\n\n/*\n * trusted_destroy - before freeing the key, clear the decrypted data\n */\nstatic void trusted_destroy(struct key *key)\n{\n\tstruct trusted_key_payload *p = key->payload.data[0];\n\n\tif (!p)\n\t\treturn;\n\tmemset(p->key, 0, p->key_len);\n\tkfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_trusted);\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}\n\nstatic void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}\n\nlate_initcall(init_trusted);\nmodule_exit(cleanup_trusted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* user_defined.c: user defined key type\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n\nstatic int logon_vet_description(const char *desc);\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_user = {\n\t.name\t\t\t= \"user\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_user);\n\n/*\n * This key type is essentially the same as key_type_user, but it does\n * not define a .read op. This is suitable for storing username and\n * password pairs in the keyring that you do not want to be readable\n * from userspace.\n */\nstruct key_type key_type_logon = {\n\t.name\t\t\t= \"logon\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.vet_description\t= logon_vet_description,\n};\nEXPORT_SYMBOL_GPL(key_type_logon);\n\n/*\n * Preparse a user defined key payload\n */\nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload.data[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(user_preparse);\n\n/*\n * Free a preparse of a user defined key payload\n */\nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkfree(prep->payload.data[0]);\n}\nEXPORT_SYMBOL_GPL(user_free_preparse);\n\n/*\n * update a user defined key\n * - the key's semaphore is write-locked\n */\nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\t\tzap = key->payload.data[0];\n\t\telse\n\t\t\tzap = NULL;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_update);\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tkfree_rcu(upayload, rcu);\n\t}\n}\n\nEXPORT_SYMBOL(user_revoke);\n\n/*\n * dispose of the data dangling from the corpse of a user key\n */\nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\tkfree(upayload);\n}\n\nEXPORT_SYMBOL_GPL(user_destroy);\n\n/*\n * describe the user key\n */\nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n\nEXPORT_SYMBOL_GPL(user_describe);\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_read);\n\n/* Vet the description for a \"logon\" key */\nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n"], "filenames": ["security/keys/encrypted-keys/encrypted.c", "security/keys/trusted.c", "security/keys/user_defined.c"], "buggy_code_start_loc": [847, 1010, 123], "buggy_code_end_loc": [847, 1016, 124], "fixing_code_start_loc": [848, 1010, 123], "fixing_code_end_loc": [850, 1020, 127], "type": "CWE-269", "message": "The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.", "other": {"cve": {"id": "CVE-2015-8539", "sourceIdentifier": "cve@mitre.org", "published": "2016-02-08T03:59:03.903", "lastModified": "2022-01-31T17:51:54.560", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c."}, {"lang": "es", "value": "El subsistema KEYS en el kernel de Linux en versiones anteriores a 4.4 permite a usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio (BUG) a trav\u00e9s de comandos keyctl manipulados que instancia una clave negativamente, relacionado con security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c y security/keys/user_defined.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_real_time_extension:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "18D823E3-E1F3-4A15-A9C7-1AB61C1B6703"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4", "matchCriteriaId": "311A4477-1B05-4B33-8886-88EF75FEB5B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "E425B7E4-0104-4CF8-A874-4CAF3273BCDF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "C066AC79-4021-4414-A9F2-6B75C2D62773"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=096fe9eaea40a17e125569f9e657e34cdb6d73bd", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00007.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00008.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00009.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00011.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00017.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00018.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00019.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00020.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00022.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-02/msg00034.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-03/msg00094.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00045.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00000.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/12/09/1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0151", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0152", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0181", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1284450", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/3798-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3798-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd"}}