{"buggy_code": ["package chrootarchive // import \"github.com/docker/docker/pkg/chrootarchive\"\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/user\"\n\t\"path/filepath\"\n\n\t\"github.com/docker/docker/pkg/archive\"\n\t\"github.com/docker/docker/pkg/idtools\"\n)\n\nfunc init() {\n\t// initialize nss libraries in Glibc so that the dynamic libraries are loaded in the host\n\t// environment not in the chroot from untrusted files.\n\t_, _ = user.Lookup(\"docker\")\n\t_, _ = net.LookupHost(\"localhost\")\n}\n\n// NewArchiver returns a new Archiver which uses chrootarchive.Untar\nfunc NewArchiver(idMapping *idtools.IdentityMapping) *archive.Archiver {\n\tif idMapping == nil {\n\t\tidMapping = &idtools.IdentityMapping{}\n\t}\n\treturn &archive.Archiver{\n\t\tUntar:     Untar,\n\t\tIDMapping: idMapping,\n\t}\n}\n\n// Untar reads a stream of bytes from `archive`, parses it as a tar archive,\n// and unpacks it into the directory at `dest`.\n// The archive may be compressed with one of the following algorithms:\n//  identity (uncompressed), gzip, bzip2, xz.\nfunc Untar(tarArchive io.Reader, dest string, options *archive.TarOptions) error {\n\treturn untarHandler(tarArchive, dest, options, true, dest)\n}\n\n// UntarWithRoot is the same as `Untar`, but allows you to pass in a root directory\n// The root directory is the directory that will be chrooted to.\n// `dest` must be a path within `root`, if it is not an error will be returned.\n//\n// `root` should set to a directory which is not controlled by any potentially\n// malicious process.\n//\n// This should be used to prevent a potential attacker from manipulating `dest`\n// such that it would provide access to files outside of `dest` through things\n// like symlinks. Normally `ResolveSymlinksInScope` would handle this, however\n// sanitizing symlinks in this manner is inherrently racey:\n// ref: CVE-2018-15664\nfunc UntarWithRoot(tarArchive io.Reader, dest string, options *archive.TarOptions, root string) error {\n\treturn untarHandler(tarArchive, dest, options, true, root)\n}\n\n// UntarUncompressed reads a stream of bytes from `archive`, parses it as a tar archive,\n// and unpacks it into the directory at `dest`.\n// The archive must be an uncompressed stream.\nfunc UntarUncompressed(tarArchive io.Reader, dest string, options *archive.TarOptions) error {\n\treturn untarHandler(tarArchive, dest, options, false, dest)\n}\n\n// Handler for teasing out the automatic decompression\nfunc untarHandler(tarArchive io.Reader, dest string, options *archive.TarOptions, decompress bool, root string) error {\n\tif tarArchive == nil {\n\t\treturn fmt.Errorf(\"Empty archive\")\n\t}\n\tif options == nil {\n\t\toptions = &archive.TarOptions{}\n\t}\n\tif options.ExcludePatterns == nil {\n\t\toptions.ExcludePatterns = []string{}\n\t}\n\n\tidMapping := idtools.NewIDMappingsFromMaps(options.UIDMaps, options.GIDMaps)\n\trootIDs := idMapping.RootPair()\n\n\tdest = filepath.Clean(dest)\n\tif _, err := os.Stat(dest); os.IsNotExist(err) {\n\t\tif err := idtools.MkdirAllAndChownNew(dest, 0755, rootIDs); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tr := ioutil.NopCloser(tarArchive)\n\tif decompress {\n\t\tdecompressedArchive, err := archive.DecompressStream(tarArchive)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer decompressedArchive.Close()\n\t\tr = decompressedArchive\n\t}\n\n\treturn invokeUnpack(r, dest, options, root)\n}\n\n// Tar tars the requested path while chrooted to the specified root.\nfunc Tar(srcPath string, options *archive.TarOptions, root string) (io.ReadCloser, error) {\n\tif options == nil {\n\t\toptions = &archive.TarOptions{}\n\t}\n\treturn invokePack(srcPath, options, root)\n}\n"], "fixing_code": ["package chrootarchive // import \"github.com/docker/docker/pkg/chrootarchive\"\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/user\"\n\t\"path/filepath\"\n\n\t\"github.com/docker/docker/pkg/archive\"\n\t\"github.com/docker/docker/pkg/idtools\"\n)\n\nfunc init() {\n\t// initialize nss libraries in Glibc so that the dynamic libraries are loaded in the host\n\t// environment not in the chroot from untrusted files.\n\t_, _ = user.Lookup(\"docker\")\n\t_, _ = net.LookupHost(\"localhost\")\n}\n\n// NewArchiver returns a new Archiver which uses chrootarchive.Untar\nfunc NewArchiver(idMapping *idtools.IdentityMapping) *archive.Archiver {\n\tif idMapping == nil {\n\t\tidMapping = &idtools.IdentityMapping{}\n\t}\n\treturn &archive.Archiver{\n\t\tUntar:     Untar,\n\t\tIDMapping: idMapping,\n\t}\n}\n\n// Untar reads a stream of bytes from `archive`, parses it as a tar archive,\n// and unpacks it into the directory at `dest`.\n// The archive may be compressed with one of the following algorithms:\n//  identity (uncompressed), gzip, bzip2, xz.\nfunc Untar(tarArchive io.Reader, dest string, options *archive.TarOptions) error {\n\treturn untarHandler(tarArchive, dest, options, true, dest)\n}\n\n// UntarWithRoot is the same as `Untar`, but allows you to pass in a root directory\n// The root directory is the directory that will be chrooted to.\n// `dest` must be a path within `root`, if it is not an error will be returned.\n//\n// `root` should set to a directory which is not controlled by any potentially\n// malicious process.\n//\n// This should be used to prevent a potential attacker from manipulating `dest`\n// such that it would provide access to files outside of `dest` through things\n// like symlinks. Normally `ResolveSymlinksInScope` would handle this, however\n// sanitizing symlinks in this manner is inherrently racey:\n// ref: CVE-2018-15664\nfunc UntarWithRoot(tarArchive io.Reader, dest string, options *archive.TarOptions, root string) error {\n\treturn untarHandler(tarArchive, dest, options, true, root)\n}\n\n// UntarUncompressed reads a stream of bytes from `archive`, parses it as a tar archive,\n// and unpacks it into the directory at `dest`.\n// The archive must be an uncompressed stream.\nfunc UntarUncompressed(tarArchive io.Reader, dest string, options *archive.TarOptions) error {\n\treturn untarHandler(tarArchive, dest, options, false, dest)\n}\n\n// Handler for teasing out the automatic decompression\nfunc untarHandler(tarArchive io.Reader, dest string, options *archive.TarOptions, decompress bool, root string) error {\n\tif tarArchive == nil {\n\t\treturn fmt.Errorf(\"Empty archive\")\n\t}\n\tif options == nil {\n\t\toptions = &archive.TarOptions{}\n\t}\n\tif options.ExcludePatterns == nil {\n\t\toptions.ExcludePatterns = []string{}\n\t}\n\n\t// If dest is inside a root then directory is created within chroot by extractor.\n\t// This case is only currently used by cp.\n\tif dest == root {\n\t\tidMapping := idtools.NewIDMappingsFromMaps(options.UIDMaps, options.GIDMaps)\n\t\trootIDs := idMapping.RootPair()\n\n\t\tdest = filepath.Clean(dest)\n\t\tif _, err := os.Stat(dest); os.IsNotExist(err) {\n\t\t\tif err := idtools.MkdirAllAndChownNew(dest, 0755, rootIDs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tr := ioutil.NopCloser(tarArchive)\n\tif decompress {\n\t\tdecompressedArchive, err := archive.DecompressStream(tarArchive)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer decompressedArchive.Close()\n\t\tr = decompressedArchive\n\t}\n\n\treturn invokeUnpack(r, dest, options, root)\n}\n\n// Tar tars the requested path while chrooted to the specified root.\nfunc Tar(srcPath string, options *archive.TarOptions, root string) (io.ReadCloser, error) {\n\tif options == nil {\n\t\toptions = &archive.TarOptions{}\n\t}\n\treturn invokePack(srcPath, options, root)\n}\n"], "filenames": ["pkg/chrootarchive/archive.go"], "buggy_code_start_loc": [77], "buggy_code_end_loc": [84], "fixing_code_start_loc": [77], "fixing_code_end_loc": [88], "type": "CWE-281", "message": "Moby is an open-source project created by Docker to enable software containerization. A bug was found in Moby (Docker Engine) where attempting to copy files using `docker cp` into a specially-crafted container can result in Unix file permission changes for existing files in the host\u2019s filesystem, widening access to others. This bug does not directly allow files to be read, modified, or executed without an additional cooperating process. This bug has been fixed in Moby (Docker Engine) 20.10.9. Users should update to this version as soon as possible. Running containers do not need to be restarted.", "other": {"cve": {"id": "CVE-2021-41089", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-04T21:15:12.620", "lastModified": "2022-06-14T11:15:10.577", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Moby is an open-source project created by Docker to enable software containerization. A bug was found in Moby (Docker Engine) where attempting to copy files using `docker cp` into a specially-crafted container can result in Unix file permission changes for existing files in the host\u2019s filesystem, widening access to others. This bug does not directly allow files to be read, modified, or executed without an additional cooperating process. This bug has been fixed in Moby (Docker Engine) 20.10.9. Users should update to this version as soon as possible. Running containers do not need to be restarted."}, {"lang": "es", "value": "Moby es un proyecto de c\u00f3digo abierto creado por Docker para permitir la contenedorizaci\u00f3n de software. Se ha encontrado un fallo en Moby (Docker Engine) en el que el intento de copiar archivos mediante `docker cp` en un contenedor especialmente dise\u00f1ado puede dar lugar a cambios en los permisos de archivos Unix para los archivos existentes en el sistema de archivos del host, ampliando el acceso a otros. Este fallo no permite directamente la lectura, modificaci\u00f3n o ejecuci\u00f3n de archivos sin un proceso adicional que coopere. Este error ha sido corregido en Moby (Docker Engine) 20.10.9. Los usuarios deben actualizar a esta versi\u00f3n lo antes posible. Los contenedores en ejecuci\u00f3n no necesitan ser reiniciados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.0, "impactScore": 3.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-281"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-281"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:moby:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.10.9", "matchCriteriaId": "83825875-76D7-4BB9-BB49-86568EBE67E9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-222547.pdf", "source": "security-advisories@github.com"}, {"url": "https://github.com/moby/moby/commit/bce32e5c93be4caf1a592582155b9cb837fc129a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/moby/moby/security/advisories/GHSA-v994-f8vw-g7j4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/B5Q6G6I4W5COQE25QMC7FJY3I3PAYFBB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZNFADTCHHYWVM6W4NJ6CB4FNFM2VMBIB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moby/moby/commit/bce32e5c93be4caf1a592582155b9cb837fc129a"}}