{"buggy_code": ["package com.enonic.xp.lib.auth;\n\nimport java.util.Comparator;\nimport java.util.concurrent.Callable;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\nimport javax.servlet.http.HttpSession;\n\nimport com.enonic.xp.context.Context;\nimport com.enonic.xp.context.ContextBuilder;\nimport com.enonic.xp.portal.PortalRequest;\nimport com.enonic.xp.script.bean.BeanContext;\nimport com.enonic.xp.script.bean.ScriptBean;\nimport com.enonic.xp.security.IdProvider;\nimport com.enonic.xp.security.IdProviderKey;\nimport com.enonic.xp.security.IdProviders;\nimport com.enonic.xp.security.RoleKeys;\nimport com.enonic.xp.security.SecurityConstants;\nimport com.enonic.xp.security.SecurityService;\nimport com.enonic.xp.security.SystemConstants;\nimport com.enonic.xp.security.User;\nimport com.enonic.xp.security.auth.AuthenticationInfo;\nimport com.enonic.xp.security.auth.EmailPasswordAuthToken;\nimport com.enonic.xp.security.auth.UsernamePasswordAuthToken;\nimport com.enonic.xp.security.auth.VerifiedEmailAuthToken;\nimport com.enonic.xp.security.auth.VerifiedUsernameAuthToken;\nimport com.enonic.xp.session.Session;\n\npublic final class LoginHandler\n    implements ScriptBean\n{\n    private enum Scope\n    {\n        SESSION, REQUEST, NONE\n    }\n\n    private String user;\n\n    private String password;\n\n    private boolean skipAuth;\n\n    private String[] idProvider;\n\n    private Integer sessionTimeout;\n\n    private Scope scope;\n\n    private Supplier<SecurityService> securityService;\n\n    private Supplier<Context> context;\n\n    private Supplier<PortalRequest> portalRequestSupplier;\n\n    public void setUser( final String user )\n    {\n        this.user = user;\n    }\n\n    public void setPassword( final String password )\n    {\n        this.password = password;\n    }\n\n    public void setSkipAuth( final boolean skipAuth )\n    {\n        this.skipAuth = skipAuth;\n    }\n\n    public void setIdProvider( final String[] idProvider )\n    {\n        this.idProvider = idProvider;\n    }\n\n    public void setSessionTimeout( final Integer sessionTimeout )\n    {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    public void setScope( final String scope )\n    {\n        this.scope = Scope.valueOf( scope );\n    }\n\n    public LoginResultMapper login()\n    {\n        AuthenticationInfo authInfo = noIdProviderSpecified() ? attemptLoginWithAllExistingIdProviders() : attemptLogin();\n\n        if ( authInfo.isAuthenticated() )\n        {\n            switch ( this.scope )\n            {\n                case NONE:\n                    // do nothing\n                    break;\n                case REQUEST:\n                    this.context.get().getLocalScope().setAttribute( authInfo );\n                    break;\n                case SESSION:\n                default:\n                    createSession( authInfo );\n                    break;\n            }\n\n            return new LoginResultMapper( authInfo );\n        }\n        else\n        {\n            return new LoginResultMapper( authInfo, \"Access Denied\" );\n        }\n    }\n\n    private void createSession( final AuthenticationInfo authInfo )\n    {\n        final Session session = this.context.get().getLocalScope().getSession();\n        if ( session != null )\n        {\n            session.setAttribute( authInfo );\n        }\n\n        if ( this.sessionTimeout != null )\n        {\n            setSessionTimeout();\n        }\n    }\n\n    private boolean noIdProviderSpecified()\n    {\n        return this.idProvider == null || this.idProvider.length == 0;\n    }\n\n    private AuthenticationInfo attemptLoginWithAllExistingIdProviders()\n    {\n        final IdProviders idProviders = runAsAuthenticated( this::getSortedIdProviders );\n\n        for ( IdProvider idProvider : idProviders )\n        {\n            final AuthenticationInfo authInfo = authenticate( idProvider.getKey() );\n            if ( ( authInfo != null ) && authInfo.isAuthenticated() )\n            {\n                return authInfo;\n            }\n        }\n\n        return AuthenticationInfo.unAuthenticated();\n    }\n\n    private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from( idProviders.stream().\n            sorted( Comparator.comparing( u -> u.getKey().toString() ) ).\n            collect( Collectors.toList() ) );\n    }\n\n    private AuthenticationInfo attemptLogin()\n    {\n\n        for ( String uStore : idProvider )\n        {\n            final AuthenticationInfo authInfo = authenticate( IdProviderKey.from( uStore ) );\n            if ( ( authInfo != null ) && authInfo.isAuthenticated() )\n            {\n                return authInfo;\n            }\n        }\n\n        return AuthenticationInfo.unAuthenticated();\n    }\n\n    private AuthenticationInfo authenticate( IdProviderKey idProvider )\n    {\n        AuthenticationInfo authInfo = null;\n\n        if ( isValidEmail( this.user ) )\n        {\n            if ( this.skipAuth )\n            {\n                final VerifiedEmailAuthToken verifiedEmailAuthToken = new VerifiedEmailAuthToken();\n                verifiedEmailAuthToken.setEmail( this.user );\n                verifiedEmailAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( verifiedEmailAuthToken ) );\n            }\n            else\n            {\n                final EmailPasswordAuthToken emailAuthToken = new EmailPasswordAuthToken();\n                emailAuthToken.setEmail( this.user );\n                emailAuthToken.setPassword( this.password );\n                emailAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( emailAuthToken ) );\n            }\n        }\n\n        if ( authInfo == null || !authInfo.isAuthenticated() )\n        {\n            if ( this.skipAuth )\n            {\n                final VerifiedUsernameAuthToken usernameAuthToken = new VerifiedUsernameAuthToken();\n                usernameAuthToken.setUsername( this.user );\n                usernameAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( usernameAuthToken ) );\n            }\n            else\n            {\n                final UsernamePasswordAuthToken usernameAuthToken = new UsernamePasswordAuthToken();\n                usernameAuthToken.setUsername( this.user );\n                usernameAuthToken.setPassword( this.password );\n                usernameAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( usernameAuthToken ) );\n            }\n        }\n\n        return authInfo;\n    }\n\n    private <T> T runAsAuthenticated( Callable<T> runnable )\n    {\n        final AuthenticationInfo authInfo = AuthenticationInfo.create().principals( RoleKeys.AUTHENTICATED ).user( User.ANONYMOUS ).build();\n        return ContextBuilder.from( this.context.get() ).\n            authInfo( authInfo ).\n            repositoryId( SystemConstants.SYSTEM_REPO_ID ).\n            branch( SecurityConstants.BRANCH_SECURITY ).build().\n            callWith( runnable );\n    }\n\n    private boolean isValidEmail( final String value )\n    {\n        return value != null && value.chars().filter( ch -> ch == '@' ).count() == 1;\n    }\n\n    private void setSessionTimeout()\n    {\n        final PortalRequest portalRequest = this.portalRequestSupplier.get();\n        if ( portalRequest != null )\n        {\n            final HttpSession httpSession = portalRequest.getRawRequest().getSession();\n            if ( httpSession != null )\n            {\n                httpSession.setMaxInactiveInterval( this.sessionTimeout );\n            }\n        }\n    }\n\n    @Override\n    public void initialize( final BeanContext context )\n    {\n        this.securityService = context.getService( SecurityService.class );\n        this.context = context.getBinding( Context.class );\n        this.portalRequestSupplier = context.getBinding( PortalRequest.class );\n    }\n}\n", "package com.enonic.xp.lib.auth;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.ArgumentMatcher;\nimport org.mockito.Mockito;\n\nimport com.enonic.xp.context.ContextAccessor;\nimport com.enonic.xp.security.IdProvider;\nimport com.enonic.xp.security.IdProviderKey;\nimport com.enonic.xp.security.IdProviders;\nimport com.enonic.xp.security.RoleKeys;\nimport com.enonic.xp.security.SecurityService;\nimport com.enonic.xp.security.auth.AuthenticationInfo;\nimport com.enonic.xp.security.auth.AuthenticationToken;\nimport com.enonic.xp.security.auth.EmailPasswordAuthToken;\nimport com.enonic.xp.session.Session;\nimport com.enonic.xp.session.SessionMock;\nimport com.enonic.xp.testing.ScriptTestSupport;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class LoginHandlerTest\n    extends ScriptTestSupport\n{\n    private SecurityService securityService;\n\n    @Override\n    public void initialize()\n        throws Exception\n    {\n        super.initialize();\n        this.securityService = Mockito.mock( SecurityService.class );\n        addService( SecurityService.class, this.securityService );\n\n        ContextAccessor.current().getLocalScope().setSession( new SessionMock() );\n    }\n\n    @AfterEach\n    public void removeNoSessionAuthInfo()\n    {\n        ContextAccessor.current().getLocalScope().removeAttribute( AuthenticationInfo.class );\n    }\n\n    @Test\n    public void testExamples()\n    {\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        final IdProviders idProviders =\n            IdProviders.from( IdProvider.create().displayName( \"system\" ).key( IdProviderKey.from( \"system\" ) ).build() );\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n        runScript( \"/lib/xp/examples/auth/login.js\" );\n    }\n\n    @Test\n    public void testLoginSuccess()\n    {\n        final AuthenticationInfo authInfo =\n            AuthenticationInfo.create().user( TestDataFixtures.getTestUser() ).principals( RoleKeys.ADMIN_LOGIN ).build();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"loginSuccess\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginWithScopeNONE()\n    {\n        ContextAccessor.current().getLocalScope().setSession( null );\n\n        final AuthenticationInfo authInfo =\n            AuthenticationInfo.create().user( TestDataFixtures.getTestUser() ).principals( RoleKeys.ADMIN_LOGIN ).build();\n\n        final IdProviders idProviders =\n            IdProviders.from( IdProvider.create().displayName( \"system\" ).key( IdProviderKey.from( \"system\" ) ).build() );\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n\n        runFunction( \"/test/login-test.js\", \"loginWithScopeNONE\" );\n\n        assertNull( ContextAccessor.current().getLocalScope().getSession() );\n        assertNull( ContextAccessor.current().getLocalScope().getAttribute( AuthenticationInfo.class ) );\n    }\n\n    @Test\n    public void testLoginSuccessNoSession()\n    {\n        final AuthenticationInfo authInfo =\n            AuthenticationInfo.create().user( TestDataFixtures.getTestUser() ).principals( RoleKeys.ADMIN_LOGIN ).build();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"loginSuccessNoSession\" );\n\n        final AuthenticationInfo localScopeAuth = ContextAccessor.current().getLocalScope().getAttribute( AuthenticationInfo.class );\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, localScopeAuth );\n        assertEquals( null, sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginNoIdProviders()\n    {\n        final IdProviders idProviders =\n            IdProviders.from( IdProvider.create().displayName( \"system\" ).key( IdProviderKey.from( \"system\" ) ).build() );\n\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n        runFunction( \"/test/login-test.js\", \"loginNoIdProvider\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginMultipleIdProvider()\n    {\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"loginMultipleIdProvider\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n    }\n\n    @Test\n    public void testInvalidLogin()\n    {\n        final AuthenticationInfo authInfo = AuthenticationInfo.unAuthenticated();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"invalidLogin\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertNull( sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginMultipleIdProvidersInOrder()\n    {\n        final IdProvider idProvider1 =\n            IdProvider.create().displayName( \"Id Provider 1\" ).key( IdProviderKey.from( \"idprovider1\" ) ).build();\n        final IdProvider idProvider3 =\n            IdProvider.create().displayName( \"Id Provider 3\" ).key( IdProviderKey.from( \"idprovider3\" ) ).build();\n        final IdProvider idProvider2 =\n            IdProvider.create().displayName( \"Id Provider 2\" ).key( IdProviderKey.from( \"idprovider2\" ) ).build();\n        final IdProviders idProviders = IdProviders.from( idProvider1, idProvider3, idProvider2 );\n\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        final EmailPasswordAuthToken expectedAuthToken = new EmailPasswordAuthToken();\n        expectedAuthToken.setEmail( \"user1@enonic.com\" );\n        expectedAuthToken.setPassword( \"pwd123\" );\n        expectedAuthToken.setIdProvider( idProvider3.getKey() );\n\n        final AuthTokenMatcher matcher = new AuthTokenMatcher( expectedAuthToken );\n        Mockito.when( this.securityService.authenticate( Mockito.argThat( matcher ) ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n        runFunction( \"/test/login-test.js\", \"loginMultipleIdProvidersInOrder\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n        assertEquals( 3, matcher.loginIdProviderAttempts.size() );\n        assertEquals( \"idprovider1\", matcher.loginIdProviderAttempts.get( 0 ).toString() );\n        assertEquals( \"idprovider2\", matcher.loginIdProviderAttempts.get( 1 ).toString() );\n        assertEquals( \"idprovider3\", matcher.loginIdProviderAttempts.get( 2 ).toString() );\n    }\n\n    private static class AuthTokenMatcher\n        implements ArgumentMatcher<AuthenticationToken>\n    {\n        EmailPasswordAuthToken thisObject;\n\n        AuthTokenMatcher( EmailPasswordAuthToken thisObject )\n        {\n            this.thisObject = thisObject;\n        }\n\n        List<IdProviderKey> loginIdProviderAttempts = new ArrayList<>();\n\n        @Override\n        public boolean matches( AuthenticationToken argument )\n        {\n            if ( !( argument instanceof EmailPasswordAuthToken ) )\n            {\n                return false;\n            }\n\n            final EmailPasswordAuthToken authToken = (EmailPasswordAuthToken) argument;\n            loginIdProviderAttempts.add( authToken.getIdProvider() );\n\n            return thisObject.getClass().equals( authToken.getClass() ) &&\n                this.thisObject.getIdProvider().equals( authToken.getIdProvider() ) &&\n                this.thisObject.getEmail().equals( authToken.getEmail() ) &&\n                this.thisObject.getPassword().equals( authToken.getPassword() );\n        }\n    }\n}\n"], "fixing_code": ["package com.enonic.xp.lib.auth;\n\nimport java.util.Comparator;\nimport java.util.concurrent.Callable;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\nimport javax.servlet.http.HttpSession;\n\nimport com.enonic.xp.context.Context;\nimport com.enonic.xp.context.ContextBuilder;\nimport com.enonic.xp.context.LocalScope;\nimport com.enonic.xp.portal.PortalRequest;\nimport com.enonic.xp.script.bean.BeanContext;\nimport com.enonic.xp.script.bean.ScriptBean;\nimport com.enonic.xp.security.IdProvider;\nimport com.enonic.xp.security.IdProviderKey;\nimport com.enonic.xp.security.IdProviders;\nimport com.enonic.xp.security.RoleKeys;\nimport com.enonic.xp.security.SecurityConstants;\nimport com.enonic.xp.security.SecurityService;\nimport com.enonic.xp.security.SystemConstants;\nimport com.enonic.xp.security.User;\nimport com.enonic.xp.security.auth.AuthenticationInfo;\nimport com.enonic.xp.security.auth.EmailPasswordAuthToken;\nimport com.enonic.xp.security.auth.UsernamePasswordAuthToken;\nimport com.enonic.xp.security.auth.VerifiedEmailAuthToken;\nimport com.enonic.xp.security.auth.VerifiedUsernameAuthToken;\nimport com.enonic.xp.session.Session;\n\npublic final class LoginHandler\n    implements ScriptBean\n{\n    private String user;\n\n    private String password;\n\n    private boolean skipAuth;\n\n    private String[] idProvider;\n\n    private Integer sessionTimeout;\n\n    private Scope scope;\n\n    private Supplier<SecurityService> securityService;\n\n    private Supplier<Context> context;\n\n    private Supplier<PortalRequest> portalRequestSupplier;\n\n    public void setUser( final String user )\n    {\n        this.user = user;\n    }\n\n    public void setPassword( final String password )\n    {\n        this.password = password;\n    }\n\n    public void setSkipAuth( final boolean skipAuth )\n    {\n        this.skipAuth = skipAuth;\n    }\n\n    public void setIdProvider( final String[] idProvider )\n    {\n        this.idProvider = idProvider;\n    }\n\n    public void setSessionTimeout( final Integer sessionTimeout )\n    {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    public void setScope( final String scope )\n    {\n        this.scope = Scope.valueOf( scope );\n    }\n\n    public LoginResultMapper login()\n    {\n        AuthenticationInfo authInfo = noIdProviderSpecified() ? attemptLoginWithAllExistingIdProviders() : attemptLogin();\n\n        if ( authInfo.isAuthenticated() )\n        {\n            switch ( this.scope )\n            {\n                case NONE:\n                    // do nothing\n                    break;\n                case REQUEST:\n                    this.context.get().getLocalScope().setAttribute( authInfo );\n                    break;\n                case SESSION:\n                default:\n                    createSession( authInfo );\n                    break;\n            }\n\n            return new LoginResultMapper( authInfo );\n        }\n        else\n        {\n            return new LoginResultMapper( authInfo, \"Access Denied\" );\n        }\n    }\n\n    private void createSession( final AuthenticationInfo authInfo )\n    {\n        final LocalScope localScope = this.context.get().getLocalScope();\n        final Session session = localScope.getSession();\n\n        if ( session != null )\n        {\n            final var attributes = session.getAttributes();\n            session.invalidate();\n\n            final Session newSession = localScope.getSession();\n\n            if ( newSession != null )\n            {\n                attributes.forEach( newSession::setAttribute );\n                session.setAttribute( authInfo );\n\n                if ( this.sessionTimeout != null )\n                {\n                    setSessionTimeout();\n                }\n            }\n        }\n    }\n\n    private boolean noIdProviderSpecified()\n    {\n        return this.idProvider == null || this.idProvider.length == 0;\n    }\n\n    private AuthenticationInfo attemptLoginWithAllExistingIdProviders()\n    {\n        final IdProviders idProviders = runAsAuthenticated( this::getSortedIdProviders );\n\n        for ( IdProvider idProvider : idProviders )\n        {\n            final AuthenticationInfo authInfo = authenticate( idProvider.getKey() );\n            if ( ( authInfo != null ) && authInfo.isAuthenticated() )\n            {\n                return authInfo;\n            }\n        }\n\n        return AuthenticationInfo.unAuthenticated();\n    }\n\n    private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from(\n            idProviders.stream().sorted( Comparator.comparing( u -> u.getKey().toString() ) ).collect( Collectors.toList() ) );\n    }\n\n    private AuthenticationInfo attemptLogin()\n    {\n\n        for ( String uStore : idProvider )\n        {\n            final AuthenticationInfo authInfo = authenticate( IdProviderKey.from( uStore ) );\n            if ( ( authInfo != null ) && authInfo.isAuthenticated() )\n            {\n                return authInfo;\n            }\n        }\n\n        return AuthenticationInfo.unAuthenticated();\n    }\n\n    private AuthenticationInfo authenticate( IdProviderKey idProvider )\n    {\n        AuthenticationInfo authInfo = null;\n\n        if ( isValidEmail( this.user ) )\n        {\n            if ( this.skipAuth )\n            {\n                final VerifiedEmailAuthToken verifiedEmailAuthToken = new VerifiedEmailAuthToken();\n                verifiedEmailAuthToken.setEmail( this.user );\n                verifiedEmailAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( verifiedEmailAuthToken ) );\n            }\n            else\n            {\n                final EmailPasswordAuthToken emailAuthToken = new EmailPasswordAuthToken();\n                emailAuthToken.setEmail( this.user );\n                emailAuthToken.setPassword( this.password );\n                emailAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( emailAuthToken ) );\n            }\n        }\n\n        if ( authInfo == null || !authInfo.isAuthenticated() )\n        {\n            if ( this.skipAuth )\n            {\n                final VerifiedUsernameAuthToken usernameAuthToken = new VerifiedUsernameAuthToken();\n                usernameAuthToken.setUsername( this.user );\n                usernameAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( usernameAuthToken ) );\n            }\n            else\n            {\n                final UsernamePasswordAuthToken usernameAuthToken = new UsernamePasswordAuthToken();\n                usernameAuthToken.setUsername( this.user );\n                usernameAuthToken.setPassword( this.password );\n                usernameAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( usernameAuthToken ) );\n            }\n        }\n\n        return authInfo;\n    }\n\n    private <T> T runAsAuthenticated( Callable<T> runnable )\n    {\n        final AuthenticationInfo authInfo = AuthenticationInfo.create().principals( RoleKeys.AUTHENTICATED ).user( User.ANONYMOUS ).build();\n        return ContextBuilder.from( this.context.get() )\n            .authInfo( authInfo )\n            .repositoryId( SystemConstants.SYSTEM_REPO_ID )\n            .branch( SecurityConstants.BRANCH_SECURITY )\n            .build()\n            .callWith( runnable );\n    }\n\n    private boolean isValidEmail( final String value )\n    {\n        return value != null && value.chars().filter( ch -> ch == '@' ).count() == 1;\n    }\n\n    private void setSessionTimeout()\n    {\n        final PortalRequest portalRequest = this.portalRequestSupplier.get();\n        if ( portalRequest != null )\n        {\n            final HttpSession httpSession = portalRequest.getRawRequest().getSession();\n            if ( httpSession != null )\n            {\n                httpSession.setMaxInactiveInterval( this.sessionTimeout );\n            }\n        }\n    }\n\n    @Override\n    public void initialize( final BeanContext context )\n    {\n        this.securityService = context.getService( SecurityService.class );\n        this.context = context.getBinding( Context.class );\n        this.portalRequestSupplier = context.getBinding( PortalRequest.class );\n    }\n\n    private enum Scope\n    {\n        SESSION, REQUEST, NONE\n    }\n}\n", "package com.enonic.xp.lib.auth;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.ArgumentMatcher;\nimport org.mockito.Mockito;\n\nimport com.enonic.xp.context.ContextAccessor;\nimport com.enonic.xp.security.IdProvider;\nimport com.enonic.xp.security.IdProviderKey;\nimport com.enonic.xp.security.IdProviders;\nimport com.enonic.xp.security.RoleKeys;\nimport com.enonic.xp.security.SecurityService;\nimport com.enonic.xp.security.auth.AuthenticationInfo;\nimport com.enonic.xp.security.auth.AuthenticationToken;\nimport com.enonic.xp.security.auth.EmailPasswordAuthToken;\nimport com.enonic.xp.session.Session;\nimport com.enonic.xp.session.SessionMock;\nimport com.enonic.xp.testing.ScriptTestSupport;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\npublic class LoginHandlerTest\n    extends ScriptTestSupport\n{\n    private SecurityService securityService;\n\n    @Override\n    public void initialize()\n        throws Exception\n    {\n        super.initialize();\n        this.securityService = Mockito.mock( SecurityService.class );\n        addService( SecurityService.class, this.securityService );\n\n        ContextAccessor.current().getLocalScope().setSession( new SessionMock() );\n    }\n\n    @AfterEach\n    public void removeNoSessionAuthInfo()\n    {\n        ContextAccessor.current().getLocalScope().removeAttribute( AuthenticationInfo.class );\n    }\n\n    @Test\n    public void testExamples()\n    {\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        final IdProviders idProviders =\n            IdProviders.from( IdProvider.create().displayName( \"system\" ).key( IdProviderKey.from( \"system\" ) ).build() );\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n        runScript( \"/lib/xp/examples/auth/login.js\" );\n    }\n\n    @Test\n    public void testLoginSuccess()\n    {\n        final AuthenticationInfo authInfo =\n            AuthenticationInfo.create().user( TestDataFixtures.getTestUser() ).principals( RoleKeys.ADMIN_LOGIN ).build();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"loginSuccess\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginWithScopeNONE()\n    {\n        ContextAccessor.current().getLocalScope().setSession( null );\n\n        final AuthenticationInfo authInfo =\n            AuthenticationInfo.create().user( TestDataFixtures.getTestUser() ).principals( RoleKeys.ADMIN_LOGIN ).build();\n\n        final IdProviders idProviders =\n            IdProviders.from( IdProvider.create().displayName( \"system\" ).key( IdProviderKey.from( \"system\" ) ).build() );\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n\n        runFunction( \"/test/login-test.js\", \"loginWithScopeNONE\" );\n\n        assertNull( ContextAccessor.current().getLocalScope().getSession() );\n        assertNull( ContextAccessor.current().getLocalScope().getAttribute( AuthenticationInfo.class ) );\n    }\n\n    @Test\n    public void testLoginSuccessNoSession()\n    {\n        final AuthenticationInfo authInfo =\n            AuthenticationInfo.create().user( TestDataFixtures.getTestUser() ).principals( RoleKeys.ADMIN_LOGIN ).build();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"loginSuccessNoSession\" );\n\n        final AuthenticationInfo localScopeAuth = ContextAccessor.current().getLocalScope().getAttribute( AuthenticationInfo.class );\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, localScopeAuth );\n        assertEquals( null, sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginNoIdProviders()\n    {\n        final IdProviders idProviders =\n            IdProviders.from( IdProvider.create().displayName( \"system\" ).key( IdProviderKey.from( \"system\" ) ).build() );\n\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n        runFunction( \"/test/login-test.js\", \"loginNoIdProvider\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginMultipleIdProvider()\n    {\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"loginMultipleIdProvider\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n    }\n\n    @Test\n    public void testInvalidLogin()\n    {\n        final AuthenticationInfo authInfo = AuthenticationInfo.unAuthenticated();\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n\n        runFunction( \"/test/login-test.js\", \"invalidLogin\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertNull( sessionAuthInfo );\n    }\n\n    @Test\n    public void testLoginMultipleIdProvidersInOrder()\n    {\n        final IdProvider idProvider1 =\n            IdProvider.create().displayName( \"Id Provider 1\" ).key( IdProviderKey.from( \"idprovider1\" ) ).build();\n        final IdProvider idProvider3 =\n            IdProvider.create().displayName( \"Id Provider 3\" ).key( IdProviderKey.from( \"idprovider3\" ) ).build();\n        final IdProvider idProvider2 =\n            IdProvider.create().displayName( \"Id Provider 2\" ).key( IdProviderKey.from( \"idprovider2\" ) ).build();\n        final IdProviders idProviders = IdProviders.from( idProvider1, idProvider3, idProvider2 );\n\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        final EmailPasswordAuthToken expectedAuthToken = new EmailPasswordAuthToken();\n        expectedAuthToken.setEmail( \"user1@enonic.com\" );\n        expectedAuthToken.setPassword( \"pwd123\" );\n        expectedAuthToken.setIdProvider( idProvider3.getKey() );\n\n        final AuthTokenMatcher matcher = new AuthTokenMatcher( expectedAuthToken );\n        Mockito.when( this.securityService.authenticate( Mockito.argThat( matcher ) ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n        runFunction( \"/test/login-test.js\", \"loginMultipleIdProvidersInOrder\" );\n\n        final Session session = ContextAccessor.current().getLocalScope().getSession();\n        final AuthenticationInfo sessionAuthInfo = session.getAttribute( AuthenticationInfo.class );\n        assertEquals( authInfo, sessionAuthInfo );\n        assertEquals( 3, matcher.loginIdProviderAttempts.size() );\n        assertEquals( \"idprovider1\", matcher.loginIdProviderAttempts.get( 0 ).toString() );\n        assertEquals( \"idprovider2\", matcher.loginIdProviderAttempts.get( 1 ).toString() );\n        assertEquals( \"idprovider3\", matcher.loginIdProviderAttempts.get( 2 ).toString() );\n    }\n\n    @Test\n    public void testSessionInvalidatedOnLogin()\n    {\n        final AuthenticationInfo authInfo = TestDataFixtures.createAuthenticationInfo();\n\n        final IdProviders idProviders =\n            IdProviders.from( IdProvider.create().displayName( \"system\" ).key( IdProviderKey.from( \"system\" ) ).build() );\n\n        Mockito.when( this.securityService.authenticate( Mockito.any() ) ).thenReturn( authInfo );\n        Mockito.when( this.securityService.getIdProviders() ).thenReturn( idProviders );\n\n        final SessionMock session = Mockito.spy( new SessionMock() );\n        ContextAccessor.current().getLocalScope().setSession( session );\n\n        runScript( \"/lib/xp/examples/auth/login.js\" );\n\n        verify( session, times( 5 ) ).invalidate();\n    }\n\n    private static class AuthTokenMatcher\n        implements ArgumentMatcher<AuthenticationToken>\n    {\n        EmailPasswordAuthToken thisObject;\n\n        AuthTokenMatcher( EmailPasswordAuthToken thisObject )\n        {\n            this.thisObject = thisObject;\n        }\n\n        List<IdProviderKey> loginIdProviderAttempts = new ArrayList<>();\n\n        @Override\n        public boolean matches( AuthenticationToken argument )\n        {\n            if ( !( argument instanceof EmailPasswordAuthToken ) )\n            {\n                return false;\n            }\n\n            final EmailPasswordAuthToken authToken = (EmailPasswordAuthToken) argument;\n            loginIdProviderAttempts.add( authToken.getIdProvider() );\n\n            return thisObject.getClass().equals( authToken.getClass() ) &&\n                this.thisObject.getIdProvider().equals( authToken.getIdProvider() ) &&\n                this.thisObject.getEmail().equals( authToken.getEmail() ) &&\n                this.thisObject.getPassword().equals( authToken.getPassword() );\n        }\n    }\n}\n"], "filenames": ["modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java", "modules/lib/lib-auth/src/test/java/com/enonic/xp/lib/auth/LoginHandlerTest.java"], "buggy_code_start_loc": [11, 25], "buggy_code_end_loc": [255, 194], "fixing_code_start_loc": [12, 26], "fixing_code_end_loc": [268, 216], "type": "CWE-384", "message": "Enonic XP versions less than 7.7.4 are vulnerable to a session fixation issue. An remote and unauthenticated attacker can use prior sessions due to the lack of invalidating session attributes.\n\n", "other": {"cve": {"id": "CVE-2024-23679", "sourceIdentifier": "disclosure@vulncheck.com", "published": "2024-01-19T21:15:10.073", "lastModified": "2024-01-26T19:12:45.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Enonic XP versions less than 7.7.4 are vulnerable to a session fixation issue. An remote and unauthenticated attacker can use prior sessions due to the lack of invalidating session attributes.\n\n"}, {"lang": "es", "value": "Las versiones de Enonic XP inferiores a 7.7.4 son vulnerables a un problema de reparaci\u00f3n de sesi\u00f3n. Un atacante remoto y no autenticado puede utilizar sesiones anteriores debido a la falta de atributos de sesi\u00f3n invalidantes."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}, {"source": "disclosure@vulncheck.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enonic:xp:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.7.4", "matchCriteriaId": "3FC6521F-C0B8-4FE8-BE06-FAB57CFFE61A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enonic:xp:7.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "0231ECC2-744B-4441-942B-514C943F7294"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enonic:xp:7.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "DD92F3AC-0C60-4588-B5DE-3488F7B38C18"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enonic:xp:7.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "7B807EF9-DADE-4C67-8AAF-E29C70D8D32F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enonic:xp:7.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "0BB4FF1C-13D7-4385-A4EB-27750E88AE3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enonic:xp:7.8.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "890C984E-B1AD-4213-B355-DB26E6B1BE8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enonic:xp:7.8.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "E156CC35-DC76-463E-8882-86C36814976E"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-4m5p-5w5w-3jcf", "source": "disclosure@vulncheck.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/enonic/xp/commit/0189975691e9e6407a9fee87006f730e84f734ff", "source": "disclosure@vulncheck.com", "tags": ["Patch"]}, {"url": "https://github.com/enonic/xp/commit/1f44674eb9ab3fbab7103e8d08067846e88bace4", "source": "disclosure@vulncheck.com", "tags": ["Patch"]}, {"url": "https://github.com/enonic/xp/commit/2abac31cec8679074debc4f1fb69c25930e40842", "source": "disclosure@vulncheck.com", "tags": ["Patch"]}, {"url": "https://github.com/enonic/xp/issues/9253", "source": "disclosure@vulncheck.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/enonic/xp/security/advisories/GHSA-4m5p-5w5w-3jcf", "source": "disclosure@vulncheck.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://vulncheck.com/advisories/vc-advisory-GHSA-4m5p-5w5w-3jcf", "source": "disclosure@vulncheck.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/enonic/xp/commit/0189975691e9e6407a9fee87006f730e84f734ff"}}