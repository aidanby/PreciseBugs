{"buggy_code": ["/*\n * This file is part of the MicroPython project, http://micropython.org/\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2023 Damien P. George\n * Copyright (c) 2015-2017 Paul Sokolovsky\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"py/mpconfig.h\"\n#include \"py/runtime.h\"\n#include \"py/obj.h\"\n#include \"py/objlist.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_SELECT\n\n#if MICROPY_PY_SELECT_SELECT && MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n#error \"select.select is not supported with MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\"\n#endif\n\n#if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\n#include <poll.h>\n\n#if !((MP_STREAM_POLL_RD) == (POLLIN) && \\\n    (MP_STREAM_POLL_WR) == (POLLOUT) && \\\n    (MP_STREAM_POLL_ERR) == (POLLERR) && \\\n    (MP_STREAM_POLL_HUP) == (POLLHUP) && \\\n    (MP_STREAM_POLL_NVAL) == (POLLNVAL))\n#error \"With MICROPY_PY_SELECT_POSIX_OPTIMISATIONS enabled, POLL constants must match\"\n#endif\n\n// When non-file-descriptor objects are on the list to be polled (the polling of\n// which involves repeatedly calling ioctl(MP_STREAM_POLL)), this variable sets\n// the period between polling these objects.\n#define MICROPY_PY_SELECT_IOCTL_CALL_PERIOD_MS (1)\n\n#endif\n\n// Flags for ipoll()\n#define FLAG_ONESHOT (1)\n\n// A single pollable object.\ntypedef struct _poll_obj_t {\n    mp_obj_t obj;\n    mp_uint_t (*ioctl)(mp_obj_t obj, mp_uint_t request, uintptr_t arg, int *errcode);\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    // If the pollable object has an associated file descriptor, then pollfd points to an entry\n    // in poll_set_t::pollfds, and the events/revents fields for this object are stored in the\n    // pollfd entry (and the nonfd_* members are unused).\n    // Otherwise the object is a non-file-descriptor object and pollfd==NULL, and the events/\n    // revents fields are stored in the nonfd_* members (which are named as such so that code\n    // doesn't accidentally mix the use of these members when this optimisation is used).\n    struct pollfd *pollfd;\n    uint16_t nonfd_events;\n    uint16_t nonfd_revents;\n    #else\n    mp_uint_t events;\n    mp_uint_t revents;\n    #endif\n} poll_obj_t;\n\n// A set of pollable objects.\ntypedef struct _poll_set_t {\n    // Map containing a dict with key=object to poll, value=its corresponding poll_obj_t.\n    mp_map_t map;\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    // Array of pollfd entries for objects that have a file descriptor.\n    unsigned short alloc; // memory allocated for pollfds\n    unsigned short max_used; // maximum number of used entries in pollfds\n    unsigned short used; // actual number of used entries in pollfds\n    struct pollfd *pollfds;\n    #endif\n} poll_set_t;\n\nSTATIC void poll_set_init(poll_set_t *poll_set, size_t n) {\n    mp_map_init(&poll_set->map, n);\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    poll_set->alloc = 0;\n    poll_set->max_used = 0;\n    poll_set->used = 0;\n    poll_set->pollfds = NULL;\n    #endif\n}\n\n#if MICROPY_PY_SELECT_SELECT\nSTATIC void poll_set_deinit(poll_set_t *poll_set) {\n    mp_map_deinit(&poll_set->map);\n}\n#endif\n\n#if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\nSTATIC mp_uint_t poll_obj_get_events(poll_obj_t *poll_obj) {\n    assert(poll_obj->pollfd == NULL);\n    return poll_obj->nonfd_events;\n}\n\nSTATIC void poll_obj_set_events(poll_obj_t *poll_obj, mp_uint_t events) {\n    if (poll_obj->pollfd != NULL) {\n        poll_obj->pollfd->events = events;\n    } else {\n        poll_obj->nonfd_events = events;\n    }\n}\n\nSTATIC mp_uint_t poll_obj_get_revents(poll_obj_t *poll_obj) {\n    if (poll_obj->pollfd != NULL) {\n        return poll_obj->pollfd->revents;\n    } else {\n        return poll_obj->nonfd_revents;\n    }\n}\n\nSTATIC void poll_obj_set_revents(poll_obj_t *poll_obj, mp_uint_t revents) {\n    if (poll_obj->pollfd != NULL) {\n        poll_obj->pollfd->revents = revents;\n    } else {\n        poll_obj->nonfd_revents = revents;\n    }\n}\n\nSTATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n\n    if (poll_set->used == poll_set->max_used) {\n        // No free slots below max_used, so expand max_used (and possibly allocate).\n        if (poll_set->max_used >= poll_set->alloc) {\n            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n            poll_set->alloc += 4;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        // There should be a free slot below max_used.\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n\n    free_slot->fd = fd;\n    ++poll_set->used;\n\n    return free_slot;\n}\n\nstatic inline bool poll_set_all_are_fds(poll_set_t *poll_set) {\n    return poll_set->map.used == poll_set->used;\n}\n\n#else\n\nstatic inline mp_uint_t poll_obj_get_events(poll_obj_t *poll_obj) {\n    return poll_obj->events;\n}\n\nstatic inline void poll_obj_set_events(poll_obj_t *poll_obj, mp_uint_t events) {\n    poll_obj->events = events;\n}\n\nstatic inline mp_uint_t poll_obj_get_revents(poll_obj_t *poll_obj) {\n    return poll_obj->revents;\n}\n\nstatic inline void poll_obj_set_revents(poll_obj_t *poll_obj, mp_uint_t revents) {\n    poll_obj->revents = revents;\n}\n\n#endif\n\nSTATIC void poll_set_add_obj(poll_set_t *poll_set, const mp_obj_t *obj, mp_uint_t obj_len, mp_uint_t events, bool or_events) {\n    for (mp_uint_t i = 0; i < obj_len; i++) {\n        mp_map_elem_t *elem = mp_map_lookup(&poll_set->map, mp_obj_id(obj[i]), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n        if (elem->value == MP_OBJ_NULL) {\n            // object not found; get its ioctl and add it to the poll list\n\n            // If an exception is raised below when adding the new object then the map entry for that\n            // object remains unpopulated, and methods like poll() may crash.  This case is not handled.\n\n            poll_obj_t *poll_obj = m_new_obj(poll_obj_t);\n            poll_obj->obj = obj[i];\n\n            #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n            int fd = -1;\n            if (mp_obj_is_int(obj[i])) {\n                // A file descriptor integer passed in as the object, so use it directly.\n                fd = mp_obj_get_int(obj[i]);\n                if (fd < 0) {\n                    mp_raise_ValueError(NULL);\n                }\n                poll_obj->ioctl = NULL;\n            } else {\n                // An object passed in.  Check if it has a file descriptor.\n                const mp_stream_p_t *stream_p = mp_get_stream_raise(obj[i], MP_STREAM_OP_IOCTL);\n                poll_obj->ioctl = stream_p->ioctl;\n                int err;\n                mp_uint_t res = stream_p->ioctl(obj[i], MP_STREAM_GET_FILENO, 0, &err);\n                if (res != MP_STREAM_ERROR) {\n                    fd = res;\n                }\n            }\n            if (fd >= 0) {\n                // Object has a file descriptor so add it to pollfds.\n                poll_obj->pollfd = poll_set_add_fd(poll_set, fd);\n            } else {\n                // Object doesn't have a file descriptor.\n                poll_obj->pollfd = NULL;\n            }\n            #else\n            const mp_stream_p_t *stream_p = mp_get_stream_raise(obj[i], MP_STREAM_OP_IOCTL);\n            poll_obj->ioctl = stream_p->ioctl;\n            #endif\n\n            poll_obj_set_events(poll_obj, events);\n            poll_obj_set_revents(poll_obj, 0);\n            elem->value = MP_OBJ_FROM_PTR(poll_obj);\n        } else {\n            // object exists; update its events\n            poll_obj_t *poll_obj = (poll_obj_t *)MP_OBJ_TO_PTR(elem->value);\n            #if MICROPY_PY_SELECT_SELECT\n            if (or_events) {\n                events |= poll_obj_get_events(poll_obj);\n            }\n            #else\n            (void)or_events;\n            #endif\n            poll_obj_set_events(poll_obj, events);\n        }\n    }\n}\n\n// For each object in the poll set, poll it once.\nSTATIC mp_uint_t poll_set_poll_once(poll_set_t *poll_set, size_t *rwx_num) {\n    mp_uint_t n_ready = 0;\n    for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&poll_set->map, i)) {\n            continue;\n        }\n\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n\n        #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n        if (poll_obj->pollfd != NULL) {\n            // Object has file descriptor so will be polled separately by poll().\n            continue;\n        }\n        #endif\n\n        int errcode;\n        mp_int_t ret = poll_obj->ioctl(poll_obj->obj, MP_STREAM_POLL, poll_obj_get_events(poll_obj), &errcode);\n        poll_obj_set_revents(poll_obj, ret);\n\n        if (ret == -1) {\n            // error doing ioctl\n            mp_raise_OSError(errcode);\n        }\n\n        if (ret != 0) {\n            // object is ready\n            n_ready += 1;\n            #if MICROPY_PY_SELECT_SELECT\n            if (rwx_num != NULL) {\n                if (ret & MP_STREAM_POLL_RD) {\n                    rwx_num[0] += 1;\n                }\n                if (ret & MP_STREAM_POLL_WR) {\n                    rwx_num[1] += 1;\n                }\n                if ((ret & ~(MP_STREAM_POLL_RD | MP_STREAM_POLL_WR)) != 0) {\n                    rwx_num[2] += 1;\n                }\n            }\n            #else\n            (void)rwx_num;\n            #endif\n        }\n    }\n    return n_ready;\n}\n\nSTATIC mp_uint_t poll_set_poll_until_ready_or_timeout(poll_set_t *poll_set, size_t *rwx_num, mp_uint_t timeout) {\n    mp_uint_t start_ticks = mp_hal_ticks_ms();\n    bool has_timeout = timeout != (mp_uint_t)-1;\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\n    for (;;) {\n        MP_THREAD_GIL_EXIT();\n\n        // Compute the timeout.\n        int t = MICROPY_PY_SELECT_IOCTL_CALL_PERIOD_MS;\n        if (poll_set_all_are_fds(poll_set)) {\n            // All our pollables are file descriptors, so we can use a blocking\n            // poll and let it (the underlying system) handle the timeout.\n            if (timeout == (mp_uint_t)-1) {\n                t = -1;\n            } else {\n                mp_uint_t delta = mp_hal_ticks_ms() - start_ticks;\n                if (delta >= timeout) {\n                    t = 0;\n                } else {\n                    t = timeout - delta;\n                }\n            }\n        }\n\n        // Call system poll for those objects that have a file descriptor.\n        int n_ready = poll(poll_set->pollfds, poll_set->max_used, t);\n\n        MP_THREAD_GIL_ENTER();\n\n        // The call to poll() may have been interrupted, but per PEP 475 we must retry if the\n        // signal is EINTR (this implements a special case of calling MP_HAL_RETRY_SYSCALL()).\n        if (n_ready == -1) {\n            int err = errno;\n            if (err != EINTR) {\n                mp_raise_OSError(err);\n            }\n            n_ready = 0;\n        }\n\n        // Explicitly poll any objects that do not have a file descriptor.\n        if (!poll_set_all_are_fds(poll_set)) {\n            n_ready += poll_set_poll_once(poll_set, rwx_num);\n        }\n\n        // Return if an object is ready, or if the timeout expired.\n        if (n_ready > 0 || (has_timeout && mp_hal_ticks_ms() - start_ticks >= timeout)) {\n            return n_ready;\n        }\n\n        // This would be mp_event_wait_ms() but the call to poll() above already includes a delay.\n        mp_event_handle_nowait();\n    }\n\n    #else\n\n    for (;;) {\n        // poll the objects\n        mp_uint_t n_ready = poll_set_poll_once(poll_set, rwx_num);\n        uint32_t elapsed = mp_hal_ticks_ms() - start_ticks;\n        if (n_ready > 0 || (has_timeout && elapsed >= timeout)) {\n            return n_ready;\n        }\n        if (has_timeout) {\n            mp_event_wait_ms(timeout - elapsed);\n        } else {\n            mp_event_wait_indefinite();\n        }\n    }\n\n    #endif\n}\n\n#if MICROPY_PY_SELECT_SELECT\n// select(rlist, wlist, xlist[, timeout])\nSTATIC mp_obj_t select_select(size_t n_args, const mp_obj_t *args) {\n    // get array data from tuple/list arguments\n    size_t rwx_len[3];\n    mp_obj_t *r_array, *w_array, *x_array;\n    mp_obj_get_array(args[0], &rwx_len[0], &r_array);\n    mp_obj_get_array(args[1], &rwx_len[1], &w_array);\n    mp_obj_get_array(args[2], &rwx_len[2], &x_array);\n\n    // get timeout\n    mp_uint_t timeout = -1;\n    if (n_args == 4) {\n        if (args[3] != mp_const_none) {\n            #if MICROPY_PY_BUILTINS_FLOAT\n            float timeout_f = mp_obj_get_float_to_f(args[3]);\n            if (timeout_f >= 0) {\n                timeout = (mp_uint_t)(timeout_f * 1000);\n            }\n            #else\n            timeout = mp_obj_get_int(args[3]) * 1000;\n            #endif\n        }\n    }\n\n    // merge separate lists and get the ioctl function for each object\n    poll_set_t poll_set;\n    poll_set_init(&poll_set, rwx_len[0] + rwx_len[1] + rwx_len[2]);\n    poll_set_add_obj(&poll_set, r_array, rwx_len[0], MP_STREAM_POLL_RD, true);\n    poll_set_add_obj(&poll_set, w_array, rwx_len[1], MP_STREAM_POLL_WR, true);\n    poll_set_add_obj(&poll_set, x_array, rwx_len[2], MP_STREAM_POLL_ERR | MP_STREAM_POLL_HUP, true);\n\n    // poll all objects\n    rwx_len[0] = rwx_len[1] = rwx_len[2] = 0;\n    poll_set_poll_until_ready_or_timeout(&poll_set, rwx_len, timeout);\n\n    // one or more objects are ready, or we had a timeout\n    mp_obj_t list_array[3];\n    list_array[0] = mp_obj_new_list(rwx_len[0], NULL);\n    list_array[1] = mp_obj_new_list(rwx_len[1], NULL);\n    list_array[2] = mp_obj_new_list(rwx_len[2], NULL);\n    rwx_len[0] = rwx_len[1] = rwx_len[2] = 0;\n    for (mp_uint_t i = 0; i < poll_set.map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set.map.table[i].value);\n        if (poll_obj->revents & MP_STREAM_POLL_RD) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[0]))->items[rwx_len[0]++] = poll_obj->obj;\n        }\n        if (poll_obj->revents & MP_STREAM_POLL_WR) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[1]))->items[rwx_len[1]++] = poll_obj->obj;\n        }\n        if ((poll_obj->revents & ~(MP_STREAM_POLL_RD | MP_STREAM_POLL_WR)) != 0) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[2]))->items[rwx_len[2]++] = poll_obj->obj;\n        }\n    }\n    poll_set_deinit(&poll_set);\n    return mp_obj_new_tuple(3, list_array);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_select_select_obj, 3, 4, select_select);\n#endif // MICROPY_PY_SELECT_SELECT\n\ntypedef struct _mp_obj_poll_t {\n    mp_obj_base_t base;\n    poll_set_t poll_set;\n    short iter_cnt;\n    short iter_idx;\n    int flags;\n    // callee-owned tuple\n    mp_obj_t ret_tuple;\n} mp_obj_poll_t;\n\n// register(obj[, eventmask])\nSTATIC mp_obj_t poll_register(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_uint_t events;\n    if (n_args == 3) {\n        events = mp_obj_get_int(args[2]);\n    } else {\n        events = MP_STREAM_POLL_RD | MP_STREAM_POLL_WR;\n    }\n    poll_set_add_obj(&self->poll_set, &args[1], 1, events, false);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_register_obj, 2, 3, poll_register);\n\n// unregister(obj)\nSTATIC mp_obj_t poll_unregister(mp_obj_t self_in, mp_obj_t obj_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *elem = mp_map_lookup(&self->poll_set.map, mp_obj_id(obj_in), MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    if (elem != NULL) {\n        poll_obj_t *poll_obj = (poll_obj_t *)MP_OBJ_TO_PTR(elem->value);\n        if (poll_obj->pollfd != NULL) {\n            poll_obj->pollfd->fd = -1;\n            --self->poll_set.used;\n        }\n        elem->value = MP_OBJ_NULL;\n    }\n    #else\n    (void)elem;\n    #endif\n\n    // TODO raise KeyError if obj didn't exist in map\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_2(poll_unregister_obj, poll_unregister);\n\n// modify(obj, eventmask)\nSTATIC mp_obj_t poll_modify(mp_obj_t self_in, mp_obj_t obj_in, mp_obj_t eventmask_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *elem = mp_map_lookup(&self->poll_set.map, mp_obj_id(obj_in), MP_MAP_LOOKUP);\n    if (elem == NULL) {\n        mp_raise_OSError(MP_ENOENT);\n    }\n    poll_obj_set_events((poll_obj_t *)MP_OBJ_TO_PTR(elem->value), mp_obj_get_int(eventmask_in));\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_3(poll_modify_obj, poll_modify);\n\nSTATIC mp_uint_t poll_poll_internal(uint n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    // work out timeout (its given already in ms)\n    mp_uint_t timeout = -1;\n    int flags = 0;\n    if (n_args >= 2) {\n        if (args[1] != mp_const_none) {\n            mp_int_t timeout_i = mp_obj_get_int(args[1]);\n            if (timeout_i >= 0) {\n                timeout = timeout_i;\n            }\n        }\n        if (n_args >= 3) {\n            flags = mp_obj_get_int(args[2]);\n        }\n    }\n\n    self->flags = flags;\n\n    return poll_set_poll_until_ready_or_timeout(&self->poll_set, NULL, timeout);\n}\n\nSTATIC mp_obj_t poll_poll(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_uint_t n_ready = poll_poll_internal(n_args, args);\n\n    // one or more objects are ready, or we had a timeout\n    mp_obj_list_t *ret_list = MP_OBJ_TO_PTR(mp_obj_new_list(n_ready, NULL));\n    n_ready = 0;\n    for (mp_uint_t i = 0; i < self->poll_set.map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);\n        if (poll_obj_get_revents(poll_obj) != 0) {\n            mp_obj_t tuple[2] = {poll_obj->obj, MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj))};\n            ret_list->items[n_ready++] = mp_obj_new_tuple(2, tuple);\n        }\n    }\n    return MP_OBJ_FROM_PTR(ret_list);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_poll_obj, 1, 2, poll_poll);\n\nSTATIC mp_obj_t poll_ipoll(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (self->ret_tuple == MP_OBJ_NULL) {\n        self->ret_tuple = mp_obj_new_tuple(2, NULL);\n    }\n\n    int n_ready = poll_poll_internal(n_args, args);\n    self->iter_cnt = n_ready;\n    self->iter_idx = 0;\n\n    return args[0];\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_ipoll_obj, 1, 3, poll_ipoll);\n\nSTATIC mp_obj_t poll_iternext(mp_obj_t self_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->iter_cnt == 0) {\n        return MP_OBJ_STOP_ITERATION;\n    }\n\n    self->iter_cnt--;\n\n    for (mp_uint_t i = self->iter_idx; i < self->poll_set.map.alloc; ++i) {\n        self->iter_idx++;\n        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);\n        if (poll_obj_get_revents(poll_obj) != 0) {\n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->ret_tuple);\n            t->items[0] = poll_obj->obj;\n            t->items[1] = MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj));\n            if (self->flags & FLAG_ONESHOT) {\n                // Don't poll next time, until new event mask will be set explicitly\n                poll_obj_set_events(poll_obj, 0);\n            }\n            return MP_OBJ_FROM_PTR(t);\n        }\n    }\n\n    assert(!\"inconsistent number of poll active entries\");\n    self->iter_cnt = 0;\n    return MP_OBJ_STOP_ITERATION;\n}\n\nSTATIC const mp_rom_map_elem_t poll_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&poll_register_obj) },\n    { MP_ROM_QSTR(MP_QSTR_unregister), MP_ROM_PTR(&poll_unregister_obj) },\n    { MP_ROM_QSTR(MP_QSTR_modify), MP_ROM_PTR(&poll_modify_obj) },\n    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&poll_poll_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ipoll), MP_ROM_PTR(&poll_ipoll_obj) },\n};\nSTATIC MP_DEFINE_CONST_DICT(poll_locals_dict, poll_locals_dict_table);\n\nSTATIC MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_poll,\n    MP_QSTR_poll,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    iter, poll_iternext,\n    locals_dict, &poll_locals_dict\n    );\n\n// poll()\nSTATIC mp_obj_t select_poll(void) {\n    mp_obj_poll_t *poll = mp_obj_malloc(mp_obj_poll_t, &mp_type_poll);\n    poll_set_init(&poll->poll_set, 0);\n    poll->iter_cnt = 0;\n    poll->ret_tuple = MP_OBJ_NULL;\n    return MP_OBJ_FROM_PTR(poll);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mp_select_poll_obj, select_poll);\n\nSTATIC const mp_rom_map_elem_t mp_module_select_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_select) },\n    #if MICROPY_PY_SELECT_SELECT\n    { MP_ROM_QSTR(MP_QSTR_select), MP_ROM_PTR(&mp_select_select_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&mp_select_poll_obj) },\n    { MP_ROM_QSTR(MP_QSTR_POLLIN), MP_ROM_INT(MP_STREAM_POLL_RD) },\n    { MP_ROM_QSTR(MP_QSTR_POLLOUT), MP_ROM_INT(MP_STREAM_POLL_WR) },\n    { MP_ROM_QSTR(MP_QSTR_POLLERR), MP_ROM_INT(MP_STREAM_POLL_ERR) },\n    { MP_ROM_QSTR(MP_QSTR_POLLHUP), MP_ROM_INT(MP_STREAM_POLL_HUP) },\n};\n\nSTATIC MP_DEFINE_CONST_DICT(mp_module_select_globals, mp_module_select_globals_table);\n\nconst mp_obj_module_t mp_module_select = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_select_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_select, mp_module_select);\n\n#endif // MICROPY_PY_SELECT\n", "# Test select.poll in combination with file descriptors.\n\ntry:\n    import select, errno\n\n    select.poll  # Raises AttributeError for CPython implementations without poll()\nexcept (ImportError, AttributeError):\n    print(\"SKIP\")\n    raise SystemExit\n\n# Check that poll supports registering file descriptors (integers).\ntry:\n    select.poll().register(0)\nexcept OSError:\n    print(\"SKIP\")\n    raise SystemExit\n\n# Register invalid file descriptor.\ntry:\n    select.poll().register(-1)\nexcept ValueError:\n    print(\"ValueError\")\n\n# Test polling stdout, it should be writable.\npoller = select.poll()\npoller.register(1)\npoller.modify(1, select.POLLOUT)\nprint(poller.poll())\n\n# Unregister then re-register.\npoller.unregister(1)\npoller.register(1, select.POLLIN)\n\n# Poll for input, should return an empty list.\nprint(poller.poll(0))\n\n# Test registering a very large number of file descriptors.\npoller = select.poll()\nfor fd in range(6000):\n    poller.register(fd)\ntry:\n    poller.poll()\nexcept OSError as er:\n    print(er.errno == errno.EINVAL)\n"], "fixing_code": ["/*\n * This file is part of the MicroPython project, http://micropython.org/\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2023 Damien P. George\n * Copyright (c) 2015-2017 Paul Sokolovsky\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"py/mpconfig.h\"\n#include \"py/runtime.h\"\n#include \"py/obj.h\"\n#include \"py/objlist.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_SELECT\n\n#if MICROPY_PY_SELECT_SELECT && MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n#error \"select.select is not supported with MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\"\n#endif\n\n#if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\n#include <string.h>\n#include <poll.h>\n\n#if !((MP_STREAM_POLL_RD) == (POLLIN) && \\\n    (MP_STREAM_POLL_WR) == (POLLOUT) && \\\n    (MP_STREAM_POLL_ERR) == (POLLERR) && \\\n    (MP_STREAM_POLL_HUP) == (POLLHUP) && \\\n    (MP_STREAM_POLL_NVAL) == (POLLNVAL))\n#error \"With MICROPY_PY_SELECT_POSIX_OPTIMISATIONS enabled, POLL constants must match\"\n#endif\n\n// When non-file-descriptor objects are on the list to be polled (the polling of\n// which involves repeatedly calling ioctl(MP_STREAM_POLL)), this variable sets\n// the period between polling these objects.\n#define MICROPY_PY_SELECT_IOCTL_CALL_PERIOD_MS (1)\n\n#endif\n\n// Flags for ipoll()\n#define FLAG_ONESHOT (1)\n\n// A single pollable object.\ntypedef struct _poll_obj_t {\n    mp_obj_t obj;\n    mp_uint_t (*ioctl)(mp_obj_t obj, mp_uint_t request, uintptr_t arg, int *errcode);\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    // If the pollable object has an associated file descriptor, then pollfd points to an entry\n    // in poll_set_t::pollfds, and the events/revents fields for this object are stored in the\n    // pollfd entry (and the nonfd_* members are unused).\n    // Otherwise the object is a non-file-descriptor object and pollfd==NULL, and the events/\n    // revents fields are stored in the nonfd_* members (which are named as such so that code\n    // doesn't accidentally mix the use of these members when this optimisation is used).\n    struct pollfd *pollfd;\n    uint16_t nonfd_events;\n    uint16_t nonfd_revents;\n    #else\n    mp_uint_t events;\n    mp_uint_t revents;\n    #endif\n} poll_obj_t;\n\n// A set of pollable objects.\ntypedef struct _poll_set_t {\n    // Map containing a dict with key=object to poll, value=its corresponding poll_obj_t.\n    mp_map_t map;\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    // Array of pollfd entries for objects that have a file descriptor.\n    unsigned short alloc; // memory allocated for pollfds\n    unsigned short max_used; // maximum number of used entries in pollfds\n    unsigned short used; // actual number of used entries in pollfds\n    struct pollfd *pollfds;\n    #endif\n} poll_set_t;\n\nSTATIC void poll_set_init(poll_set_t *poll_set, size_t n) {\n    mp_map_init(&poll_set->map, n);\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    poll_set->alloc = 0;\n    poll_set->max_used = 0;\n    poll_set->used = 0;\n    poll_set->pollfds = NULL;\n    #endif\n}\n\n#if MICROPY_PY_SELECT_SELECT\nSTATIC void poll_set_deinit(poll_set_t *poll_set) {\n    mp_map_deinit(&poll_set->map);\n}\n#endif\n\n#if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\nSTATIC mp_uint_t poll_obj_get_events(poll_obj_t *poll_obj) {\n    assert(poll_obj->pollfd == NULL);\n    return poll_obj->nonfd_events;\n}\n\nSTATIC void poll_obj_set_events(poll_obj_t *poll_obj, mp_uint_t events) {\n    if (poll_obj->pollfd != NULL) {\n        poll_obj->pollfd->events = events;\n    } else {\n        poll_obj->nonfd_events = events;\n    }\n}\n\nSTATIC mp_uint_t poll_obj_get_revents(poll_obj_t *poll_obj) {\n    if (poll_obj->pollfd != NULL) {\n        return poll_obj->pollfd->revents;\n    } else {\n        return poll_obj->nonfd_revents;\n    }\n}\n\nSTATIC void poll_obj_set_revents(poll_obj_t *poll_obj, mp_uint_t revents) {\n    if (poll_obj->pollfd != NULL) {\n        poll_obj->pollfd->revents = revents;\n    } else {\n        poll_obj->nonfd_revents = revents;\n    }\n}\n\n// How much (in pollfds) to grow the allocation for poll_set->pollfds by.\n#define POLL_SET_ALLOC_INCREMENT (4)\n\nSTATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n\n    if (poll_set->used == poll_set->max_used) {\n        // No free slots below max_used, so expand max_used (and possibly allocate).\n        if (poll_set->max_used >= poll_set->alloc) {\n            size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;\n            // Try to grow in-place.\n            struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);\n            if (!new_fds) {\n                // Failed to grow in-place. Do a new allocation and copy over the pollfd values.\n                new_fds = m_new(struct pollfd, new_alloc);\n                memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);\n\n                // Update existing poll_obj_t to update their pollfd field to\n                // point to the same offset inside the new allocation.\n                for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {\n                    if (!mp_map_slot_is_filled(&poll_set->map, i)) {\n                        continue;\n                    }\n\n                    poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n                    if (!poll_obj) {\n                        // This is the one we're currently adding,\n                        // poll_set_add_obj doesn't assign elem->value until\n                        // afterwards.\n                        continue;\n                    }\n\n                    poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);\n                }\n\n                // Delete the old allocation.\n                m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);\n            }\n\n            poll_set->pollfds = new_fds;\n            poll_set->alloc = new_alloc;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        // There should be a free slot below max_used.\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n\n    free_slot->fd = fd;\n    ++poll_set->used;\n\n    return free_slot;\n}\n\nstatic inline bool poll_set_all_are_fds(poll_set_t *poll_set) {\n    return poll_set->map.used == poll_set->used;\n}\n\n#else\n\nstatic inline mp_uint_t poll_obj_get_events(poll_obj_t *poll_obj) {\n    return poll_obj->events;\n}\n\nstatic inline void poll_obj_set_events(poll_obj_t *poll_obj, mp_uint_t events) {\n    poll_obj->events = events;\n}\n\nstatic inline mp_uint_t poll_obj_get_revents(poll_obj_t *poll_obj) {\n    return poll_obj->revents;\n}\n\nstatic inline void poll_obj_set_revents(poll_obj_t *poll_obj, mp_uint_t revents) {\n    poll_obj->revents = revents;\n}\n\n#endif\n\nSTATIC void poll_set_add_obj(poll_set_t *poll_set, const mp_obj_t *obj, mp_uint_t obj_len, mp_uint_t events, bool or_events) {\n    for (mp_uint_t i = 0; i < obj_len; i++) {\n        mp_map_elem_t *elem = mp_map_lookup(&poll_set->map, mp_obj_id(obj[i]), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n        if (elem->value == MP_OBJ_NULL) {\n            // object not found; get its ioctl and add it to the poll list\n\n            // If an exception is raised below when adding the new object then the map entry for that\n            // object remains unpopulated, and methods like poll() may crash.  This case is not handled.\n\n            poll_obj_t *poll_obj = m_new_obj(poll_obj_t);\n            poll_obj->obj = obj[i];\n\n            #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n            int fd = -1;\n            if (mp_obj_is_int(obj[i])) {\n                // A file descriptor integer passed in as the object, so use it directly.\n                fd = mp_obj_get_int(obj[i]);\n                if (fd < 0) {\n                    mp_raise_ValueError(NULL);\n                }\n                poll_obj->ioctl = NULL;\n            } else {\n                // An object passed in.  Check if it has a file descriptor.\n                const mp_stream_p_t *stream_p = mp_get_stream_raise(obj[i], MP_STREAM_OP_IOCTL);\n                poll_obj->ioctl = stream_p->ioctl;\n                int err;\n                mp_uint_t res = stream_p->ioctl(obj[i], MP_STREAM_GET_FILENO, 0, &err);\n                if (res != MP_STREAM_ERROR) {\n                    fd = res;\n                }\n            }\n            if (fd >= 0) {\n                // Object has a file descriptor so add it to pollfds.\n                poll_obj->pollfd = poll_set_add_fd(poll_set, fd);\n            } else {\n                // Object doesn't have a file descriptor.\n                poll_obj->pollfd = NULL;\n            }\n            #else\n            const mp_stream_p_t *stream_p = mp_get_stream_raise(obj[i], MP_STREAM_OP_IOCTL);\n            poll_obj->ioctl = stream_p->ioctl;\n            #endif\n\n            poll_obj_set_events(poll_obj, events);\n            poll_obj_set_revents(poll_obj, 0);\n            elem->value = MP_OBJ_FROM_PTR(poll_obj);\n        } else {\n            // object exists; update its events\n            poll_obj_t *poll_obj = (poll_obj_t *)MP_OBJ_TO_PTR(elem->value);\n            #if MICROPY_PY_SELECT_SELECT\n            if (or_events) {\n                events |= poll_obj_get_events(poll_obj);\n            }\n            #else\n            (void)or_events;\n            #endif\n            poll_obj_set_events(poll_obj, events);\n        }\n    }\n}\n\n// For each object in the poll set, poll it once.\nSTATIC mp_uint_t poll_set_poll_once(poll_set_t *poll_set, size_t *rwx_num) {\n    mp_uint_t n_ready = 0;\n    for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&poll_set->map, i)) {\n            continue;\n        }\n\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n\n        #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n        if (poll_obj->pollfd != NULL) {\n            // Object has file descriptor so will be polled separately by poll().\n            continue;\n        }\n        #endif\n\n        int errcode;\n        mp_int_t ret = poll_obj->ioctl(poll_obj->obj, MP_STREAM_POLL, poll_obj_get_events(poll_obj), &errcode);\n        poll_obj_set_revents(poll_obj, ret);\n\n        if (ret == -1) {\n            // error doing ioctl\n            mp_raise_OSError(errcode);\n        }\n\n        if (ret != 0) {\n            // object is ready\n            n_ready += 1;\n            #if MICROPY_PY_SELECT_SELECT\n            if (rwx_num != NULL) {\n                if (ret & MP_STREAM_POLL_RD) {\n                    rwx_num[0] += 1;\n                }\n                if (ret & MP_STREAM_POLL_WR) {\n                    rwx_num[1] += 1;\n                }\n                if ((ret & ~(MP_STREAM_POLL_RD | MP_STREAM_POLL_WR)) != 0) {\n                    rwx_num[2] += 1;\n                }\n            }\n            #else\n            (void)rwx_num;\n            #endif\n        }\n    }\n    return n_ready;\n}\n\nSTATIC mp_uint_t poll_set_poll_until_ready_or_timeout(poll_set_t *poll_set, size_t *rwx_num, mp_uint_t timeout) {\n    mp_uint_t start_ticks = mp_hal_ticks_ms();\n    bool has_timeout = timeout != (mp_uint_t)-1;\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\n    for (;;) {\n        MP_THREAD_GIL_EXIT();\n\n        // Compute the timeout.\n        int t = MICROPY_PY_SELECT_IOCTL_CALL_PERIOD_MS;\n        if (poll_set_all_are_fds(poll_set)) {\n            // All our pollables are file descriptors, so we can use a blocking\n            // poll and let it (the underlying system) handle the timeout.\n            if (timeout == (mp_uint_t)-1) {\n                t = -1;\n            } else {\n                mp_uint_t delta = mp_hal_ticks_ms() - start_ticks;\n                if (delta >= timeout) {\n                    t = 0;\n                } else {\n                    t = timeout - delta;\n                }\n            }\n        }\n\n        // Call system poll for those objects that have a file descriptor.\n        int n_ready = poll(poll_set->pollfds, poll_set->max_used, t);\n\n        MP_THREAD_GIL_ENTER();\n\n        // The call to poll() may have been interrupted, but per PEP 475 we must retry if the\n        // signal is EINTR (this implements a special case of calling MP_HAL_RETRY_SYSCALL()).\n        if (n_ready == -1) {\n            int err = errno;\n            if (err != EINTR) {\n                mp_raise_OSError(err);\n            }\n            n_ready = 0;\n        }\n\n        // Explicitly poll any objects that do not have a file descriptor.\n        if (!poll_set_all_are_fds(poll_set)) {\n            n_ready += poll_set_poll_once(poll_set, rwx_num);\n        }\n\n        // Return if an object is ready, or if the timeout expired.\n        if (n_ready > 0 || (has_timeout && mp_hal_ticks_ms() - start_ticks >= timeout)) {\n            return n_ready;\n        }\n\n        // This would be mp_event_wait_ms() but the call to poll() above already includes a delay.\n        mp_event_handle_nowait();\n    }\n\n    #else\n\n    for (;;) {\n        // poll the objects\n        mp_uint_t n_ready = poll_set_poll_once(poll_set, rwx_num);\n        uint32_t elapsed = mp_hal_ticks_ms() - start_ticks;\n        if (n_ready > 0 || (has_timeout && elapsed >= timeout)) {\n            return n_ready;\n        }\n        if (has_timeout) {\n            mp_event_wait_ms(timeout - elapsed);\n        } else {\n            mp_event_wait_indefinite();\n        }\n    }\n\n    #endif\n}\n\n#if MICROPY_PY_SELECT_SELECT\n// select(rlist, wlist, xlist[, timeout])\nSTATIC mp_obj_t select_select(size_t n_args, const mp_obj_t *args) {\n    // get array data from tuple/list arguments\n    size_t rwx_len[3];\n    mp_obj_t *r_array, *w_array, *x_array;\n    mp_obj_get_array(args[0], &rwx_len[0], &r_array);\n    mp_obj_get_array(args[1], &rwx_len[1], &w_array);\n    mp_obj_get_array(args[2], &rwx_len[2], &x_array);\n\n    // get timeout\n    mp_uint_t timeout = -1;\n    if (n_args == 4) {\n        if (args[3] != mp_const_none) {\n            #if MICROPY_PY_BUILTINS_FLOAT\n            float timeout_f = mp_obj_get_float_to_f(args[3]);\n            if (timeout_f >= 0) {\n                timeout = (mp_uint_t)(timeout_f * 1000);\n            }\n            #else\n            timeout = mp_obj_get_int(args[3]) * 1000;\n            #endif\n        }\n    }\n\n    // merge separate lists and get the ioctl function for each object\n    poll_set_t poll_set;\n    poll_set_init(&poll_set, rwx_len[0] + rwx_len[1] + rwx_len[2]);\n    poll_set_add_obj(&poll_set, r_array, rwx_len[0], MP_STREAM_POLL_RD, true);\n    poll_set_add_obj(&poll_set, w_array, rwx_len[1], MP_STREAM_POLL_WR, true);\n    poll_set_add_obj(&poll_set, x_array, rwx_len[2], MP_STREAM_POLL_ERR | MP_STREAM_POLL_HUP, true);\n\n    // poll all objects\n    rwx_len[0] = rwx_len[1] = rwx_len[2] = 0;\n    poll_set_poll_until_ready_or_timeout(&poll_set, rwx_len, timeout);\n\n    // one or more objects are ready, or we had a timeout\n    mp_obj_t list_array[3];\n    list_array[0] = mp_obj_new_list(rwx_len[0], NULL);\n    list_array[1] = mp_obj_new_list(rwx_len[1], NULL);\n    list_array[2] = mp_obj_new_list(rwx_len[2], NULL);\n    rwx_len[0] = rwx_len[1] = rwx_len[2] = 0;\n    for (mp_uint_t i = 0; i < poll_set.map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set.map.table[i].value);\n        if (poll_obj->revents & MP_STREAM_POLL_RD) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[0]))->items[rwx_len[0]++] = poll_obj->obj;\n        }\n        if (poll_obj->revents & MP_STREAM_POLL_WR) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[1]))->items[rwx_len[1]++] = poll_obj->obj;\n        }\n        if ((poll_obj->revents & ~(MP_STREAM_POLL_RD | MP_STREAM_POLL_WR)) != 0) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[2]))->items[rwx_len[2]++] = poll_obj->obj;\n        }\n    }\n    poll_set_deinit(&poll_set);\n    return mp_obj_new_tuple(3, list_array);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_select_select_obj, 3, 4, select_select);\n#endif // MICROPY_PY_SELECT_SELECT\n\ntypedef struct _mp_obj_poll_t {\n    mp_obj_base_t base;\n    poll_set_t poll_set;\n    short iter_cnt;\n    short iter_idx;\n    int flags;\n    // callee-owned tuple\n    mp_obj_t ret_tuple;\n} mp_obj_poll_t;\n\n// register(obj[, eventmask])\nSTATIC mp_obj_t poll_register(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_uint_t events;\n    if (n_args == 3) {\n        events = mp_obj_get_int(args[2]);\n    } else {\n        events = MP_STREAM_POLL_RD | MP_STREAM_POLL_WR;\n    }\n    poll_set_add_obj(&self->poll_set, &args[1], 1, events, false);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_register_obj, 2, 3, poll_register);\n\n// unregister(obj)\nSTATIC mp_obj_t poll_unregister(mp_obj_t self_in, mp_obj_t obj_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *elem = mp_map_lookup(&self->poll_set.map, mp_obj_id(obj_in), MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    if (elem != NULL) {\n        poll_obj_t *poll_obj = (poll_obj_t *)MP_OBJ_TO_PTR(elem->value);\n        if (poll_obj->pollfd != NULL) {\n            poll_obj->pollfd->fd = -1;\n            --self->poll_set.used;\n        }\n        elem->value = MP_OBJ_NULL;\n    }\n    #else\n    (void)elem;\n    #endif\n\n    // TODO raise KeyError if obj didn't exist in map\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_2(poll_unregister_obj, poll_unregister);\n\n// modify(obj, eventmask)\nSTATIC mp_obj_t poll_modify(mp_obj_t self_in, mp_obj_t obj_in, mp_obj_t eventmask_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *elem = mp_map_lookup(&self->poll_set.map, mp_obj_id(obj_in), MP_MAP_LOOKUP);\n    if (elem == NULL) {\n        mp_raise_OSError(MP_ENOENT);\n    }\n    poll_obj_set_events((poll_obj_t *)MP_OBJ_TO_PTR(elem->value), mp_obj_get_int(eventmask_in));\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_3(poll_modify_obj, poll_modify);\n\nSTATIC mp_uint_t poll_poll_internal(uint n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    // work out timeout (its given already in ms)\n    mp_uint_t timeout = -1;\n    int flags = 0;\n    if (n_args >= 2) {\n        if (args[1] != mp_const_none) {\n            mp_int_t timeout_i = mp_obj_get_int(args[1]);\n            if (timeout_i >= 0) {\n                timeout = timeout_i;\n            }\n        }\n        if (n_args >= 3) {\n            flags = mp_obj_get_int(args[2]);\n        }\n    }\n\n    self->flags = flags;\n\n    return poll_set_poll_until_ready_or_timeout(&self->poll_set, NULL, timeout);\n}\n\nSTATIC mp_obj_t poll_poll(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_uint_t n_ready = poll_poll_internal(n_args, args);\n\n    // one or more objects are ready, or we had a timeout\n    mp_obj_list_t *ret_list = MP_OBJ_TO_PTR(mp_obj_new_list(n_ready, NULL));\n    n_ready = 0;\n    for (mp_uint_t i = 0; i < self->poll_set.map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);\n        if (poll_obj_get_revents(poll_obj) != 0) {\n            mp_obj_t tuple[2] = {poll_obj->obj, MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj))};\n            ret_list->items[n_ready++] = mp_obj_new_tuple(2, tuple);\n        }\n    }\n    return MP_OBJ_FROM_PTR(ret_list);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_poll_obj, 1, 2, poll_poll);\n\nSTATIC mp_obj_t poll_ipoll(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (self->ret_tuple == MP_OBJ_NULL) {\n        self->ret_tuple = mp_obj_new_tuple(2, NULL);\n    }\n\n    int n_ready = poll_poll_internal(n_args, args);\n    self->iter_cnt = n_ready;\n    self->iter_idx = 0;\n\n    return args[0];\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_ipoll_obj, 1, 3, poll_ipoll);\n\nSTATIC mp_obj_t poll_iternext(mp_obj_t self_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->iter_cnt == 0) {\n        return MP_OBJ_STOP_ITERATION;\n    }\n\n    self->iter_cnt--;\n\n    for (mp_uint_t i = self->iter_idx; i < self->poll_set.map.alloc; ++i) {\n        self->iter_idx++;\n        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);\n        if (poll_obj_get_revents(poll_obj) != 0) {\n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->ret_tuple);\n            t->items[0] = poll_obj->obj;\n            t->items[1] = MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj));\n            if (self->flags & FLAG_ONESHOT) {\n                // Don't poll next time, until new event mask will be set explicitly\n                poll_obj_set_events(poll_obj, 0);\n            }\n            return MP_OBJ_FROM_PTR(t);\n        }\n    }\n\n    assert(!\"inconsistent number of poll active entries\");\n    self->iter_cnt = 0;\n    return MP_OBJ_STOP_ITERATION;\n}\n\nSTATIC const mp_rom_map_elem_t poll_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&poll_register_obj) },\n    { MP_ROM_QSTR(MP_QSTR_unregister), MP_ROM_PTR(&poll_unregister_obj) },\n    { MP_ROM_QSTR(MP_QSTR_modify), MP_ROM_PTR(&poll_modify_obj) },\n    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&poll_poll_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ipoll), MP_ROM_PTR(&poll_ipoll_obj) },\n};\nSTATIC MP_DEFINE_CONST_DICT(poll_locals_dict, poll_locals_dict_table);\n\nSTATIC MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_poll,\n    MP_QSTR_poll,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    iter, poll_iternext,\n    locals_dict, &poll_locals_dict\n    );\n\n// poll()\nSTATIC mp_obj_t select_poll(void) {\n    mp_obj_poll_t *poll = mp_obj_malloc(mp_obj_poll_t, &mp_type_poll);\n    poll_set_init(&poll->poll_set, 0);\n    poll->iter_cnt = 0;\n    poll->ret_tuple = MP_OBJ_NULL;\n    return MP_OBJ_FROM_PTR(poll);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mp_select_poll_obj, select_poll);\n\nSTATIC const mp_rom_map_elem_t mp_module_select_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_select) },\n    #if MICROPY_PY_SELECT_SELECT\n    { MP_ROM_QSTR(MP_QSTR_select), MP_ROM_PTR(&mp_select_select_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&mp_select_poll_obj) },\n    { MP_ROM_QSTR(MP_QSTR_POLLIN), MP_ROM_INT(MP_STREAM_POLL_RD) },\n    { MP_ROM_QSTR(MP_QSTR_POLLOUT), MP_ROM_INT(MP_STREAM_POLL_WR) },\n    { MP_ROM_QSTR(MP_QSTR_POLLERR), MP_ROM_INT(MP_STREAM_POLL_ERR) },\n    { MP_ROM_QSTR(MP_QSTR_POLLHUP), MP_ROM_INT(MP_STREAM_POLL_HUP) },\n};\n\nSTATIC MP_DEFINE_CONST_DICT(mp_module_select_globals, mp_module_select_globals_table);\n\nconst mp_obj_module_t mp_module_select = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_select_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_select, mp_module_select);\n\n#endif // MICROPY_PY_SELECT\n", "# Test select.poll in combination with file descriptors.\n\ntry:\n    import select, errno\n\n    select.poll  # Raises AttributeError for CPython implementations without poll()\nexcept (ImportError, AttributeError):\n    print(\"SKIP\")\n    raise SystemExit\n\n# Check that poll supports registering file descriptors (integers).\ntry:\n    select.poll().register(0)\nexcept OSError:\n    print(\"SKIP\")\n    raise SystemExit\n\n# Register invalid file descriptor.\ntry:\n    select.poll().register(-1)\nexcept ValueError:\n    print(\"ValueError\")\n\n# Test polling stdout, it should be writable.\npoller = select.poll()\npoller.register(1)\npoller.modify(1, select.POLLOUT)\nprint(poller.poll())\n\n# Unregister then re-register.\npoller.unregister(1)\npoller.register(1, select.POLLIN)\n\n# Poll for input, should return an empty list.\nprint(poller.poll(0))\n\n# Test registering a very large number of file descriptors (will trigger\n# EINVAL due to more than OPEN_MAX fds).\npoller = select.poll()\nfor fd in range(6000):\n    poller.register(fd)\ntry:\n    poller.poll()\n    assert False\nexcept OSError as er:\n    print(er.errno == errno.EINVAL)\n\n# Register stdout/stderr, plus many extra ones to trigger the fd vector\n# resizing. Then unregister the excess ones and verify poll still works.\npoller = select.poll()\nfor fd in range(1, 1000):\n    poller.register(fd)\nfor i in range(3, 1000):\n    poller.unregister(i)\nprint(sorted(poller.poll()))\n"], "filenames": ["extmod/modselect.c", "tests/extmod/select_poll_fd.py"], "buggy_code_start_loc": [43, 37], "buggy_code_end_loc": [153, 44], "fixing_code_start_loc": [44, 37], "fixing_code_end_loc": [187, 56], "type": "CWE-416", "message": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2023-7152", "sourceIdentifier": "cna@vuldb.com", "published": "2023-12-29T05:15:09.473", "lastModified": "2024-02-29T01:42:57.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability."}, {"lang": "es", "value": "Una vulnerabilidad fue encontrada en MicroPython 1.21.0/1.22.0-preview y clasificada como cr\u00edtica. La funci\u00f3n poll_set_add_fd del archivo extmod/modselect.c es afectada por esta vulnerabilidad. La manipulaci\u00f3n conduce a use after free. La explotaci\u00f3n ha sido divulgada al p\u00fablico y puede utilizarse. El parche se identifica como 8b24aa36ba978eafc6114b6798b47b7bfecdca26. Se recomienda aplicar un parche para solucionar este problema. VDB-249158 es el identificador asignado a esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:micropython:micropython:1.21.0:*:*:*:*:*:*:*", "matchCriteriaId": "92240FCD-0BA9-46D0-9C9A-2CDD8FE2A769"}, {"vulnerable": true, "criteria": "cpe:2.3:a:micropython:micropython:1.22.0:preview:*:*:*:*:*:*", "matchCriteriaId": "B60BCDF9-D1CF-45ED-9B95-9F06C5C2A95F"}]}]}], "references": [{"url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/micropython/micropython/issues/12887", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://vuldb.com/?ctiid.249158", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.249158", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26"}}