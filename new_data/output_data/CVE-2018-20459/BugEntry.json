{"buggy_code": ["/* radare - LGPL - Copyright 2010-2018 - pancake */\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <r_util.h>\n#include \"armass16_const.h\"\n\n// TODO: only lo registers accessible in thumb arm\n\ntypedef struct {\n\tut64 off;\n\tut32 o;\n\tchar op[128];\n\tchar opstr[128];\n\tchar *a[16]; /* only 15 arguments can be used! */\n} ArmOpcode;\n\ntypedef struct {\n\tconst char *name;\n\tint code;\n\tint type;\n} ArmOp;\n\nenum {\n\tTYPE_MOV = 1,\n\tTYPE_TST = 2,\n\tTYPE_SWI = 3,\n\tTYPE_HLT = 4,\n\tTYPE_BRA = 5,\n\tTYPE_BRR = 6,\n\tTYPE_ARI = 7,\n\tTYPE_IMM = 8,\n\tTYPE_MEM = 9,\n\tTYPE_BKP = 10,\n\tTYPE_SWP = 11,\n\tTYPE_MOVW = 12,\n\tTYPE_MOVT = 13,\n\tTYPE_UDF = 14,\n\tTYPE_SHFT = 15,\n\tTYPE_COPROC = 16,\n\tTYPE_ENDIAN = 17,\n\tTYPE_MUL = 18,\n\tTYPE_CLZ = 19,\n\tTYPE_REV = 20,\n};\n\nstatic int strcmpnull(const char *a, const char *b) {\n\tif (!a || !b) {\n\t\treturn -1;\n\t}\n\treturn strcmp (a, b);\n}\n\n// static const char *const arm_shift[] = {\"lsl\", \"lsr\", \"asr\", \"ror\"};\n\nstatic ArmOp ops[] = {\n\t{ \"adc\", 0xa000, TYPE_ARI },\n\t{ \"adcs\", 0xb000, TYPE_ARI },\n\t{ \"adds\", 0x9000, TYPE_ARI },\n\t{ \"add\", 0x8000, TYPE_ARI },\n\t{ \"bkpt\", 0x2001, TYPE_BKP },\n\t{ \"subs\", 0x5000, TYPE_ARI },\n\t{ \"sub\", 0x4000, TYPE_ARI },\n\t{ \"sbcs\", 0xd000, TYPE_ARI },\n\t{ \"sbc\", 0xc000, TYPE_ARI },\n\t{ \"rsb\", 0x6000, TYPE_ARI },\n\t{ \"rsbs\", 0x7000, TYPE_ARI },\n\t{ \"rsc\", 0xe000, TYPE_ARI },\n\t{ \"rscs\", 0xf000, TYPE_ARI },\n\t{ \"bic\", 0x0000c0e1, TYPE_ARI },\n\n\t{ \"udf\", 0xf000f000, TYPE_UDF },\n\n\t{ \"push\", 0x2d09, TYPE_IMM },\n\t{ \"pop\", 0xbd08, TYPE_IMM },\n\n\t{ \"cps\", 0xb1, TYPE_IMM },\n\t{ \"nop\", 0xa0e1, -1 },\n\n\t{ \"ldrex\", 0x9f0f9000, TYPE_MEM },\n\t{ \"ldr\", 0x9000, TYPE_MEM },\n\n\t{ \"strexh\", 0x900fe000, TYPE_MEM },\n\t{ \"strexb\", 0x900fc000, TYPE_MEM },\n\t{ \"strex\", 0x900f8000, TYPE_MEM },\n\t{ \"strbt\", 0x0000e0e4, TYPE_MEM },\n\t{ \"strb\", 0x0000c0e5, TYPE_MEM },\n\t{ \"strd\", 0xf000c0e1, TYPE_MEM },\n\t{ \"strh\", 0xb00080e1, TYPE_MEM },\n\t{ \"str\", 0x8000, TYPE_MEM },\n\n\t{ \"blx\", 0x30ff2fe1, TYPE_BRR },\n\t{ \"bx\", 0x10ff2fe1, TYPE_BRR },\n\n\t{ \"bl\", 0xb, TYPE_BRA },\n// bx/blx - to register, b, bne,.. justjust  offset\n//    2220:       e12fff1e        bx      lr\n//    2224:       e12fff12        bx      r2\n//    2228:       e12fff13        bx      r3\n\n\t//{ \"bx\", 0xb, TYPE_BRA },\n\t{ \"b\", 0xa, TYPE_BRA },\n\n\t//{ \"mov\", 0x3, TYPE_MOV },\n\t//{ \"mov\", 0x0a3, TYPE_MOV },\n\t{ \"movw\", 0x3, TYPE_MOVW },\n\t{ \"movt\", 0x4003, TYPE_MOVT },\n\t{ \"mov\", 0xa001, TYPE_MOV },\n\t{ \"mvn\", 0xe000, TYPE_MOV },\n\t{ \"svc\", 0xf, TYPE_SWI }, // ???\n\t{ \"hlt\", 0x70000001, TYPE_HLT }, // ???u\n\n\t{ \"mul\", 0x900000e0, TYPE_MUL},\n\t{ \"smull\", 0x9000c0e0, TYPE_MUL},\n\t{ \"umull\", 0x900080e0, TYPE_MUL},\n\t{ \"smlal\", 0x9000e0e0, TYPE_MUL},\n\t{ \"smlabb\", 0x800000e1, TYPE_MUL},\n\t{ \"smlabt\", 0xc00000e1, TYPE_MUL},\n\t{ \"smlatb\", 0xa00000e1, TYPE_MUL},\n\t{ \"smlatt\", 0xe00000e1, TYPE_MUL},\n\t{ \"smlawb\", 0x800020e1, TYPE_MUL},\n\t{ \"smlawt\", 0xc00020e1, TYPE_MUL},\n\n\n\t{ \"ands\", 0x1000, TYPE_ARI },\n\t{ \"and\", 0x0000, TYPE_ARI },\n\t{ \"eors\", 0x3000, TYPE_ARI },\n\t{ \"eor\", 0x2000, TYPE_ARI },\n\t{ \"orrs\", 0x9001, TYPE_ARI },\n\t{ \"orr\", 0x8001, TYPE_ARI },\n\n\t{ \"cmp\", 0x5001, TYPE_TST },\n\t{ \"swp\", 0xe1, TYPE_SWP },\n\t{ \"cmn\", 0x0, TYPE_TST },\n\t{ \"teq\", 0x0, TYPE_TST },\n\t{ \"tst\", 0xe1, TYPE_TST },\n\n\t{\"lsr\", 0x3000a0e1, TYPE_SHFT},\n\t{\"asr\", 0x5000a0e1, TYPE_SHFT},\n\t{\"lsl\", 0x1000a0e1, TYPE_SHFT},\n\t{\"ror\", 0x7000a0e1, TYPE_SHFT},\n\n\t{\"rev16\", 0xb00fbf06, TYPE_REV},\n\t{\"revsh\", 0xb00fff06, TYPE_REV},\n\t{\"rev\",   0x300fbf06, TYPE_REV},\n\t{\"rbit\",  0x300fff06, TYPE_REV},\n\n\t{\"mrc\", 0x100010ee, TYPE_COPROC},\n\t{\"setend\", 0x000001f1, TYPE_ENDIAN},\n\t{ \"clz\", 0x000f6f01, TYPE_CLZ},\n\n\t{ NULL }\n};\n\nstatic const ut64 M_BIT = 0x1;\nstatic const ut64 S_BIT = 0x2;\nstatic const ut64 C_BITS = 0x3c;\nstatic const ut64 DOTN_BIT = 0x40;\nstatic const ut64 DOTW_BIT = 0x80;\nstatic const ut64 L_BIT = 0x100;\nstatic const ut64 X_BIT = 0x200;\nstatic const ut64 TWO_BIT = 0x400;\nstatic const ut64 IE_BIT = 0x800;\nstatic const ut64 ID_BIT = 0x1000;\nstatic const ut64 EA_BIT = 0x2000;\nstatic const ut64 FD_BIT = 0x4000;\nstatic const ut64 T_BIT = 0x8000;\nstatic const ut64 B_BIT = 0x10000;\nstatic const ut64 H_BIT = 0x20000;\nstatic const ut64 D_BIT = 0x40000;\nstatic const ut64 W_BIT = 0x80000;\nstatic const ut64 EIGHT_BIT = 0x100000;\nstatic const ut64 SIXTEEN_BIT = 0x200000;\nstatic const ut64 BB_BIT = 0x400000;\nstatic const ut64 BT_BIT = 0x800000;\nstatic const ut64 TB_BIT = 0x1000000;\nstatic const ut64 TT_BIT = 0x2000000;\nstatic const ut64 R_BIT = 0x4000000;\nstatic const ut64 IA_BIT = 0x8000000;\nstatic const ut64 DB_BIT = 0x10000000;\nstatic const ut64 SH_BIT = 0x20000000;\nstatic const ut64 WB_BIT = 0x40000000;\nstatic const ut64 WT_BIT = 0x80000000;\nstatic const ut64 C_MATCH_BIT = 0x100000000;\n\nstatic char *parse_hints(char *input) {\n\tif (!strcmpnull (input, \"unst\")) {\n\t\treturn \"6\";\n\t}\n\tif (!strcmpnull (input, \"un\")) {\n\t\treturn \"7\";\n\t}\n\tif (!strcmpnull (input, \"st\")) {\n\t\treturn \"14\";\n\t}\n\tif (!strcmpnull (input, \"sy\")) {\n\t\treturn \"15\";\n\t}\n\treturn \"-1\";\n}\n\nstatic st8 iflag(char *input) {\n\tst8 res = 0;\n\tut8 i;\n\tr_str_case (input, false);\n\t\n\tfor (i = 0; i < strlen(input); i++) {\n\t\tswitch (input[i]) {\n\t\tcase 'a':\n\t\t\tres |= 0x4;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tres |= 0x2;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tres |= 0x1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ut64 cqcheck(char **input) {\n\tut64 res = 0;\n\tint i;\n\tut8 offset = 0;\n\t\n\tconst char *conds[] = {\n\t\t\"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n\t\t\"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\", 0\n\t};\n\tfor (i = 0; conds[i]; i++) {\n\t\tif (r_str_startswith (*input, conds[i])) {\n\t\t\tres |= C_MATCH_BIT;\n\t\t\tres |= i << 2;\n\t\t\t*input += 2;\n\t\t\toffset += 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (r_str_startswith (*input, \".n\")) {\n\t\tres |= DOTN_BIT;\n\t\t*input += 2;\n\t\toffset += 2;\n\t} else\n\tif (r_str_startswith (*input, \".w\")) {\n\t\tres |= DOTW_BIT;\n\t\t*input += 2;\n\t\toffset += 2;\n\t}\n\t\n\tif (**input == '\\0') {\n\t\treturn res;\n\t}\n\t*input -= offset;\n\treturn 0;\n}\n\nstatic ut64 opmask(char *input, char *opcode, ut64 allowed_mask) {\n\tut64 res = 0;\n\t\n\tr_str_case (input, false);\n\tif (strlen (opcode) > strlen (input)) {\n\t\treturn 0;\n\t}\n\tif (r_str_startswith (input, opcode)) {\n\t\tinput += strlen (opcode);\n\t\tres |= M_BIT;\n\t\tres |= cqcheck (&input);\n\t\t\n\t\tif ((*input == 's') && (S_BIT & allowed_mask)) {\n\t\t\tres |= S_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\n\t\tif ((r_str_startswith (input, \"wb\")) && (WB_BIT & allowed_mask)) {\n\t\t\tres |= WB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"wt\")) && (WT_BIT & allowed_mask)) {\n\t\t\tres |= WT_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"db\")) && (DB_BIT & allowed_mask)) {\n\t\t\tres |= DB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"ea\")) && (EA_BIT & allowed_mask)) {\n\t\t\tres |= EA_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"ia\")) && (IA_BIT & allowed_mask)) {\n\t\t\tres |= IA_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"fd\")) && (FD_BIT & allowed_mask)) {\n\t\t\tres |= FD_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'l') && (L_BIT & allowed_mask)) {\n\t\t\tres |= L_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"bb\")) && (BB_BIT & allowed_mask)) {\n\t\t\tres |= BB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"tt\")) && (TT_BIT & allowed_mask)) {\n\t\t\tres |= TT_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"bt\")) && (BT_BIT & allowed_mask)) {\n\t\t\tres |= BT_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"tb\")) && (TB_BIT & allowed_mask)) {\n\t\t\tres |= TB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'w') && (W_BIT & allowed_mask)) {\n\t\t\tres |= W_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 'b') && (B_BIT & allowed_mask)) {\n\t\t\tres |= B_BIT;\n\t\t\tinput++;\n\t\t} else\n\t        if ((*input == 'h') && (H_BIT & allowed_mask)) {\n\t\t\tres |= H_BIT;\n\t\t\tinput++;\n\t\t} else\n\t\tif ((*input == 'd') && (D_BIT & allowed_mask)) {\n\t\t\tres |= D_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 't') && (T_BIT & allowed_mask)) {\n\t\t\tres |= T_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 's') && (S_BIT & allowed_mask)) {\n\t\t\tres |= S_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'r') && (R_BIT & allowed_mask)) {\n\t\t\tres |= R_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == '2') && (TWO_BIT & allowed_mask)) {\n\t\t\tres |= TWO_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == '8') && (EIGHT_BIT & allowed_mask)) {\n\t\t\tres |= EIGHT_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((r_str_startswith (input, \"16\")) && (SIXTEEN_BIT & allowed_mask)) {\n\t\t\tres |= SIXTEEN_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'l') && (L_BIT & allowed_mask)) {\n\t\t\tres |= L_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 'x') && (X_BIT & allowed_mask)) {\n\t\t\tres |= X_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"id\")) && (ID_BIT & allowed_mask)) {\n\t\t\tres |= ID_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"ie\")) && (IE_BIT & allowed_mask)) {\n\t\t\tres |= IE_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"sh\")) && (SH_BIT & allowed_mask)) {\n\t\t\tres |= SH_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif (!(res & C_MATCH_BIT)) {\n\t\t\tres |= 15 << 2; // nv is the default condition\n\t\t}\n\t\tif (*input == 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut32 itmask(char *input) {\n\tut32 res = 0;\n\tut32 i, length;\n\tr_str_case (input, false);\n\tif (2 > strlen (input)) {\n\t\treturn 0;\n\t}\n\tif (r_str_startswith (input, \"it\")) {\n\t\tinput += 2;\n\t\tres |= 1; // matched\n\t\tif (strlen(input) > 3) {\n\t\t\treturn 0;\n\t\t}\n\t\tres |= (strlen (input) & 0x3) << 4;\n\t\tlength = strlen (input);\n\t\tfor (i = 0; i < length; i++, input++ ) {\n\t\t\tif (*input == 'e') {\n\t\t\t\tres |= 1 << (3 - i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (*input == 't') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstatic bool err;\n//decode str as number\nstatic ut64 getnum(const char *str) {\n\tchar *endptr;\n\terr = false;\n\tut64 val;\n\n\tif (!str) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\twhile (*str == '$' || *str == '#') {\n\t\tstr++;\n\t}\n\tval = strtol (str, &endptr, 0);\n\tif (str != endptr && *endptr == '\\0') {\n\t\treturn val;\n\t}\n\terr = true;\n\treturn 0;\n}\n\nstatic ut64 getnumbang(const char *str) {\n\tut64 res;\n\n\tif (!str || !*str || !r_str_endswith (str, \"!\")) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\tchar *temp = r_str_ndup (str, strlen (str) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\terr = false;\n\tres = getnum (temp);\n\tfree (temp);\n\treturn res; // err propagates\n}\n\t\nstatic ut32 getimmed8(const char *str) {\n\tut32 num = getnum (str);\n\tif (err) {\n\t\treturn 0;\n\t}\n\tut32 rotate;\n\tif (num <= 0xff) {\n\t\treturn num;\n\t} else {\n\t\tfor (rotate = 1; rotate < 16; rotate++) {\n\t\t\t// rol 2\n\t\t\tnum = ((num << 2) | (num >> 30));\n\t\t\tif (num == (num & 0xff)) {\n\t\t\t\treturn (num | (rotate << 8));\n\t\t\t}\n\t\t}\n\t\terr = 1;\n\t\treturn 0;\n\t}\n}\n\nstatic st32 firstsigdigit (ut32 num) {\n\tst32 f = -1;\n\tst32 b = -1;\n\tut32 forwardmask = 0x80000000;\n\tut32 backwardmask = 0x1;\n\tut32 i;\n\tfor (i = 0; i < 32; i++ ) {\n\t\tif ( (forwardmask & num) && (f == -1)) {\n\t\t\tf = i;\n\t\t}\n\t\tif ( (backwardmask & num) && (b == -1)) {\n\t\t\tb = 32-i;\n\t\t}\n\t\tforwardmask >>= 1;\n\t\tbackwardmask <<= 1;\n\t}\n\n\tif ((b-f) < 9) {\n\t\treturn f;\n\t}\n\treturn -1;\n}\n\nstatic ut32 getthbimmed(st32 number) {\n\tut32 res = 0;\n\tif (number < 0) {\n\t\tres |= 1 << 18;\n\t}\n\tnumber >>= 1;\n\tres |= (( number & 0xff) << 8);\n\tnumber >>= 8;\n\tres |= ( number & 0x07);\n\tnumber >>= 3;\n\tres |= (( number & 0xff) << 24);\n\tnumber >>= 8;\n\tres |= (( number & 0x3) << 16);\n\tnumber >>= 2;\n\tif (number < 0) {\n\t\tres |= (( number & 0x1) << 3);\n\t\tnumber >>= 1;\n\t\tres |= (( number & 0x1) << 5);\n\t} else {\n\t\tres |= ((!( number & 0x1)) << 3);\n\t\tnumber >>= 1;\n\t\tres |= ((!( number & 0x1)) << 5);\n\t}\n\treturn res;\n}\n\nstatic ut32 getthzeroimmed12(ut32 number) {\n\tut32 res = 0;\n\tres |= (number & 0x800) << 7;\n\tres |= (number & 0x700) >> 4;\n\tres |= (number & 0x0ff) << 8;\n\treturn res;\n}\n\nstatic ut32 getthzeroimmed16(ut32 number) {\n\tut32 res = 0;\n\tres |= (number & 0xf000) << 12;\n\tres |= (number & 0x0800) << 7;\n\tres |= (number & 0x0700) >> 4;\n\tres |= (number & 0x00ff) << 8;\n\treturn res;\n}\n\nstatic ut32 getthimmed12(const char *str) {\n\tut64 num = getnum (str);\n\tif (err) {\n\t\treturn 0;\n\t}\n\n\tst32 FSD = 0;\n\tut64 result = 0;\n\tif (num <= 0xff) {\n\t\treturn num << 8;\n\t} else \tif ( ((num & 0xff00ff00) == 0) && ((num & 0x00ff0000) == ((num & 0x000000ff) << 16)) ) {\n\t\tresult |= (num & 0x000000ff) << 8;\n\t\tresult |= 0x00000010;\n\t\treturn result;\n\t} else if ( ((num & 0x00ff00ff) == 0) && ((num & 0xff000000) == ((num & 0x0000ff00) << 16)) ) {\n\t\tresult |= num & 0x0000ff00;\n\t\tresult |= 0x00000020;\n\t\treturn result;\n\t} else if ( ((num & 0xff000000) == ((num & 0x00ff0000) << 8)) && ((num & 0xff000000) == ((num & 0x0000ff00) << 16)) && ((num &0xff000000) == ((num & 0x000000ff) << 24)) ) {\n\t\tresult |= num & 0x0000ff00;\n\t\tresult |= 0x00000030;\n\t\treturn result;\n\t} else {\n\t\tFSD = firstsigdigit(num);\n\t\tif (FSD != -1) {\n\t\t        result |= ((num >> (24-FSD)) & 0x0000007f) << 8;\n\t\t\tresult |= ((8+FSD) & 0x1) << 15;\n\t\t\tresult |= ((8+FSD) & 0xe) << 3;\n\t\t\tresult |= ((8+FSD) & 0x10) << 14;\n\t\t\treturn result;\n\t\t} else {\n\t\t\terr = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nstatic char *getrange(char *s) {\n\tchar *p = NULL;\n\twhile (s && *s) {\n\t\tif (*s == ',') {\n\t\t\tp = s+1;\n\t\t\t*p=0;\n\t\t}\n\t\tif (*s == '[' || *s == ']') {\n\t\t\tmemmove (s, s + 1, strlen (s + 1) + 1);\n\t\t}\n\t\tif (*s == '}') {\n\t\t\t*s = 0;\n\t\t}\n\t\ts++;\n\t}\n\twhile (p && *p == ' ') {\n\t\tp++;\n\t}\n\treturn p;\n}\n\n//ret register #; -1 if failed\nstatic int getreg(const char *str) {\n\tint i;\n\tchar *ep;\n\tconst char *aliases[] = { \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\", NULL };\n\tif (!str || !*str) {\n\t\treturn -1;\n\t}\n\tif (*str == 'r') {\n\t\tint reg = strtol (str + 1, &ep, 10);\n\t\tif ((ep[0] != '\\0') || (str[1] == '\\0')) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (reg < 16 && reg >= 0) {\n\t\t\treturn reg;\n\t\t}\n\t}\n\tfor (i=0; aliases[i]; i++) {\n\t\tif (!strcmpnull (str, aliases[i])) {\n\t\t\treturn 10 + i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nstatic st32 getlistmask(char *input) {\n\tst32 tempres, res = 0;\n\tint i, j, start, end;\n\tchar *temp = NULL;\n\tchar *otemp = NULL;\n\tchar *temp2 = malloc (strlen (input) + 1);\n\tif (!temp2) {\n\t\tres = -1;\n\t\tgoto end;\n\t}\n\ttemp = (char *)malloc (strlen (input) + 1);\n\tif (!temp) {\n\t\tres = -1;\n\t\tgoto end;\n\t}\n\totemp = temp;\n\twhile (*input != '\\0') {\n\t\tfor (; *input == ' '; input++) {\n\t\t\t;\n\t\t}\n\t\tfor (i = 0; input[i] != ',' && input[i] != '\\0'; i++) {\n\t\t\t;\n\t\t}\n\t\tstrncpy (temp, input, i);\n\t\ttemp[i] = 0;\n\n\t\tinput += i;\n\t\tif (*input != '\\0') {\n\t\t\tinput++;\n\t\t}\n\n\t\tfor (i = 0; temp[i] != '-' && temp[i] != '\\0'; i++) {\n\t\t\t;\n\t\t}\n\t\tif (i == strlen (temp)) {\n\t\t\ttempres = getreg (temp);\n\t\t\tif (tempres == -1 || tempres > 15) {\n\t\t\t\tres = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tres |= 1 << tempres;\n\t\t} else {\n\t\t\tstrncpy (temp2, temp, i);\n\t\t\ttemp2[i] = 0;\n\t\t\ttemp += i + 1;\n\t\t\tstart = getreg (temp2);\n\t\t\tif (start == -1 || start > 15) {\n\t\t\t\tres = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tend = getreg (temp);\n\t\t\tif (end == -1 || end > 15) {\n\t\t\t\tres = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tfor (j = start; j <= end; j++ ) {\n\t\t\t\tres |= 1 << j;\n\t\t\t}\n\t\t}\n\t}\nend:\n\tfree (otemp);\n\tfree (temp2);\n\treturn res;\n}\n\nstatic st32 getregmemstart(const char *input) {\n\tif ((strlen (input) < 1) || (!(*input == '['))) {\n\t\treturn -1;\n\t}\n\tinput++;\n\treturn getreg (input);\n}\n\t\nstatic st32 getregmemstartend(const char *input) {\n\tst32 res;\n\tif (!input || (strlen (input) < 2) || (*input != '[') || !r_str_endswith (input, \"]\")) {\n\t\treturn -1;\n\t}\n\tinput++;\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getreg (temp);\n\tfree (temp);\n\treturn res;\n}\n\t\nstatic st32 getregmemend(const char *input) {\n\tst32 res;\n\tif (!input || !*input || !r_str_endswith (input, \"]\")) {\n\t\treturn -1;\n\t}\n\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getreg (temp);\n\tfree (temp);\n\treturn res;\n}\n\t\nstatic st32 getreglist(const char *input) {\n\tst32 res;\n\t\n\tif (!input || (strlen (input) < 2) || (*input != '{') || !r_str_endswith (input, \"}\")) {\n\t\treturn -1;\n\t}\n\tif (*input) {\n\t\tinput++;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getlistmask (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic st32 getnummemend (const char *input) {\n\tst32 res;\n\terr = false;\n\tif (!input || !*input || !r_str_endswith (input, \"]\")) {\n\t\terr = true;\n\t\treturn -1;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\terr = true;\n\t\treturn -1;\n\t}\n\tres = getnum (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic st32 getnummemendbang (const char *input) {\n\tst32 res;\n\terr = false;\n\tif (!input || (strlen (input) < 2) || (input[strlen(input) - 2] != ']' || !r_str_endswith (input, \"!\"))) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 2);\n\tif (!temp) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\tres = getnum (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic st32 getregmembang(const char *input) {\n\tst32 res;\n\tif (!input || !*input || !r_str_endswith (input, \"!\")) {\n\t\treturn -1;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getreg (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic int getcoproc(const char *str) {\n\tchar *ep;\n\tif (!str || !*str) {\n\t\treturn -1;\n\t}\n\tif (*str == 'p') {\n\t\tint coproc = strtol (str + 1, &ep, 10);\n\t\tif ((ep[0] != '\\0') || (str[1] == '\\0')) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (coproc < 16 && coproc >= 0) {\n\t\t\treturn coproc;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int getcoprocreg(const char *str) {\n\tchar *ep;\n\t\n\tif (!str || !*str) {\n\t\treturn -1;\n\t}\n\tif (r_str_startswith (str, \"c\")) {\n\t\tint reg = strtol (str + 1, &ep, 10);\n\t\tif ((ep[0] != '\\0') || (str[1] == '\\0')) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (reg < 16 && reg >= 0) {\n\t\t\treturn reg;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic ut8 interpret_msrbank (char *str, ut8 *spsr) {\n\tconst char fields[] = {'c', 'x', 's', 'f', 0};\n\tint res = 0;\n\tint i, j;\n\tif (r_str_startswith (str, \"spsr_\")) {\n\t\t*spsr = 1;\n\t} else {\n\t\t*spsr = 0;\n\t}\t\t\n\t\n\tif (r_str_startswith (str, \"apsr_\")) {\n\t\tif (!(strcmp (str+5, \"g\"))) {\n\t\t\treturn 0x4;\n\t\t}\n\t\tif (!(strcmp (str+5, \"nzcvq\"))) {\n\t\t\treturn 0x8;\n\t\t}\n\t\tif (!(strcmp (str+5, \"nzcvqg\"))) {\n\t\t\treturn 0xc;\n\t\t}\n\t}\n\tif (r_str_startswith (str, \"cpsr_\") || r_str_startswith (str, \"spsr_\")) {\n\t\tfor (i = 0; str[5+i]; i++) {\n\t\t\tfor (j = 0; fields[j]; j++) {\n\t\t\t\tif (str[5+i] == fields[j]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(fields[j])) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tres |= 1 << j;\n\t\t}\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\t\t\nstatic ut32 thumb_getshift(const char *str) {\n\t// only immediate shifts are ever used by thumb-2. Bit positions are different from ARM.\n\tconst char *shifts[] = {\n\t\t\"LSL\", \"LSR\", \"ASR\", \"ROR\", 0, \"RRX\"\n\t};\n\tchar *type = strdup (str);\n\tchar *arg;\n\tchar *space;\n\tut32 res = 0;\n\tut32 shift = false;\n\terr = false;\n\tut32 argn;\n\tut32 i;\n\t\n\tr_str_case (type,true);\n\t\n\tif (!strcmp (type, shifts[5])) {\n\t\t// handle RRX alias case\n\t\tres |= 3 << 12;\t\n\t\tfree (type);\n\t\treturn res;\n\t}\n\t\n\tspace = strchr (type, ' ');\n\tif (!space) {\n\t\tfree (type);\n\t\terr = true;\n\t\treturn 0;\n\t}\n\t*space = 0;\n\targ = strdup (++space);\n\t\n\tfor (i = 0; shifts[i]; i++) {\n\t\tif (!strcmp (type, shifts[i])) {\n\t\t\tshift = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!shift) {\n\t\terr = true;\n\t\tfree (type);\n\t\tfree (arg);\n\t\treturn 0;\n\t}\n\tres |= i << 12;\n\t\t\n\targn = getnum (arg);\n\tif (err || argn > 32) {\n\t\terr = true;\n\t\tfree (type);\n\t\tfree (arg);\n\t\treturn 0;\n\t}\n\tres |= ( (argn & 0x1c) << 2);\n\tres |= ( (argn & 0x3) << 14);\n\n\tfree (type);\n\tfree (arg);\n\treturn res;\n}\n\nstatic st32 getshiftmemend(const char *input) {\n\tst32 res;\n\tif (!input || !*input || !r_str_endswith (input, \"]\")) {\n\t\treturn -1;\n\t}\n\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = thumb_getshift (temp);\n\tfree (temp);\n\treturn res;\n}\n\nvoid collect_list(char *input[]) {\n\tif (input[0] == NULL) {\n\t\treturn;\n\t}\n\tchar *temp  = malloc (500);\n\tif (!temp) {\n\t\treturn;\n\t}\n\ttemp[0] = 0;\n\tint i;\n\tint conc = 0;\n\tint start, end = 0;\n\tint arrsz;\n\tfor (arrsz = 1; input[arrsz] != NULL; arrsz++) {\n\t\t;\n\t}\n\n\tfor (i = 0; input[i]; i++) {\n\t\tif (conc) {\n\t\t\tstrcat (temp, \", \");\n\t\t\tstrcat (temp, input[i]);\n\t\t}\n\t\tif (input[i][0] == '{') {\n\t\t\tconc = 1;\n\t\t\tstrcat (temp, input[i]);\n\t\t\tstart = i;\n\t\t}\n\t\tif ((conc) & (input[i][strlen (input[i]) - 1] == '}')) {\n\t\t\tconc = 0;\n\t\t\tend = i;\n\t\t}\n\t}\n\tif (end == 0) {\n\t\tfree (temp);\n\t\treturn;\n\t}\n\tinput[start] = temp;\n\tfor (i = start + 1; i < arrsz; i++) {\n\t\tinput[i] = input[(end-start) + i];\n\t}\n\tinput[i] = NULL;\n}\n\nstatic ut64 thumb_selector(char *args[]) {\n\tcollect_list(args);\n\tut64 res = 0;\n\tut8 i;\n\tfor (i = 0; i < 15; i++) {\n\t\tif (args[i] == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tif (getreg (args[i]) != -1) {\n\t\t\tres |= 1 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnum (args[i]);\n\t\tif (!err) {\n\t\t\tres |= 2 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;   \t\n\t\tthumb_getshift (args[i]);\n\t\tif (!err) {\n\t\t\tres |= 3 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getcoproc (args[i]) != -1) {\n\t\t\tres |= 4 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getcoprocreg (args[i]) != -1) {\n\t\t\tres |= 5 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmemstart (args[i]) != -1) {\n\t\t\tres |= 6 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmemstartend (args[i]) != -1) {\n\t\t\tres |= 7 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnummemend(args[i]);\n\t\tif (!err) {\n\t\t\tres |= 8 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnummemendbang(args[i]);\n\t\tif (!err) {\n\t\t\tres |= 9 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmembang (args[i]) != -1) {\n\t\t\tres |= 0xa << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getreglist (args[i]) != -1) {\n\t\t\tres |= 0xb << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmemend (args[i]) != -1) {\n\t\t\tres |= 0xc << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getshiftmemend (args[i]) != -1) {\n\t\t\tres |= 0xd << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnumbang(args[i]);\n\t\tif (!err) {\n\t\t\tres |= 0xe << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tres |= 0xf << (i*4);\n\t}\n\terr = false;\n\treturn res;\n}\n\t\t\nstatic ut32 getshift(const char *str) {\n\tchar type[128];\n\tchar arg[128];\n\tchar *space;\n\tut32 i=0, shift=0;\n\tconst char *shifts[] = {\n\t\t\"LSL\", \"LSR\", \"ASR\", \"ROR\",\n\t\t0, \"RRX\" // alias for ROR #0\n\t};\n\n\tstrncpy (type, str, sizeof (type) - 1);\n\t// XXX strcaecmp is probably unportable\n\tif (!r_str_casecmp (type, shifts[5])) {\n\t\t// handle RRX alias case\n\t\tshift = 6;\n\t} else { // all other shift types\n\t\tspace = strchr (type, ' ');\n\t\tif (!space) {\n\t\t\treturn 0;\n\t\t}\n\t\t*space = 0;\n\t\tstrncpy (arg, ++space, sizeof(arg) - 1);\n\n\t\tfor (i = 0; shifts[i]; i++) {\n\t\t\tif (!r_str_casecmp (type, shifts[i])) {\n\t\t\t\tshift = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!shift) {\n\t\t\treturn 0;\n\t\t}\n\t\tshift = i * 2;\n\t\tif ((i = getreg (arg)) != -1) {\n\t\t\ti <<= 8; // set reg\n//\t\t\ti|=1; // use reg\n\t\t\ti |= (1 << 4); // bitshift\n\t\t\ti |= shift << 4; // set shift mode\n\t\t\tif (shift == 6) {\n\t\t\t\ti |= (1 << 20);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *bracket = strchr (arg, ']');\n\t\t\tif (bracket) {\n\t\t\t\t*bracket = '\\0';\n\t\t\t}\n\t\t\t// ensure only the bottom 5 bits are used\n\t\t\ti &= 0x1f;\n\t\t\tif (!i) {\n\t\t\t\ti = 32;\n\t\t\t}\n\t\t\ti = (i * 8);\n\t\t\ti |= shift; // lsl, ror, ...\n\t\t\ti = i << 4;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic void arm_opcode_parse(ArmOpcode *ao, const char *str) {\n\tint i;\n\tmemset (ao, 0, sizeof (ArmOpcode));\n\tif (strlen (str) + 1 >= sizeof (ao->op)) {\n\t\treturn;\n\t}\n\tstrncpy (ao->op, str, sizeof (ao->op)-1);\n\tstrcpy (ao->opstr, ao->op);\n\tao->a[0] = strchr (ao->op, ' ');\n\tfor (i=0; i<15; i++) {\n\t\tif (ao->a[i]) {\n\t\t\t*ao->a[i] = 0;\n\t\t\tao->a[i+1] = strchr (++ao->a[i], ',');\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ao->a[i]) {\n\t\t*ao->a[i] = 0;\n\t\tao->a[i]++;\n\t}\n\tfor (i=0; i<16; i++) {\n\t\twhile (ao->a[i] && *ao->a[i] == ' ') {\n\t\t\tao->a[i]++;\n\t\t}\n\t}\n}\n\nstatic inline int arm_opcode_cond(ArmOpcode *ao, int delta) {\n\tconst char *conds[] = {\n\t\t\"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n\t\t\"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\", 0\n\t};\n\tint i, cond = 14; // 'always' is default\n\tchar *c = ao->op+delta;\n\tfor (i=0; conds[i]; i++) {\n\t\tif (!strcmpnull (c, conds[i])) {\n\t\t\tcond = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tao->o |= cond << 4;\n\treturn cond;\n}\n\nstatic st32 thumb_getoffset(char *label, ut64 cur) {\n\tst32 res = r_num_math (NULL, label);\n\tres -= 4;\n\tres -= cur; // possible integer underflow\n\t//printf(\"thumb_getoffset: %s, %lld, %lld\\n\", label, res, cur);\n\treturn res;\n}\n\nstatic st8 std_16bit_2reg(ArmOpcode *ao, ut64 m) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getreg (ao->a[1]);\n\tif ( (rd < 8) && (rn < 8) && !(m & DOTW_BIT)) {\n\t\tao->o |= rd << 8;\n\t\tao->o |= rn << 11;\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic st8 mem_16bit_2reg(ArmOpcode *ao, ut64 m) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getregmemstart (ao->a[1]);\n\tif ( (rd < 8) && (rn < 8) && !(m & DOTW_BIT)) {\n\t\tao->o |= rd << 8;\n\t\tao->o |= rn << 11;\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic st8 std_32bit_2reg(ArmOpcode *ao, ut64 m, bool shift) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getreg (ao->a[1]);\n\tif ((rd > 15) || (rn > 15) || (m & DOTN_BIT)) {\n\t\treturn -1;\n\t}\n\tif (m & S_BIT) {\n\t\tao->o |= 1 << 28;\n\t}\n\tif (shift) {\n\t\terr = false;\n\t\tut32 shiftnum = thumb_getshift (ao->a[2]);\n\t\tif (err) {\n\t\t\treturn -1;\n\t\t}\n\t\tao->o |= shiftnum;\n\t\tao->o |= rd << 24;\n\t\tao->o |= rn << 8;\n\t} else {\n\t\tao->o |= rd;\n\t\tao->o |= rn << 24;\n\t}\n\treturn 4;\n}\n\nstatic st8 mem_32bit_2reg(ArmOpcode *ao, ut64 m) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getregmemstart (ao->a[1]);\n\tif ((rd > 15) || (rn > 15) || (m & DOTN_BIT)) {\n\t\treturn -1;\n\t}\n\tao->o |= rd << 4;\n\tao->o |= rn << 24;\n\treturn 4;\n}\n\nstatic st8 std_32bit_3reg(ArmOpcode *ao, ut64 m, bool shift) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getreg (ao->a[1]);\n\tut8 rm = getreg (ao->a[2]);\n\tif ((rd > 15) || (rn > 15) || (rm > 15) || (m & DOTN_BIT)) {\n\t\treturn -1;\n\t}\n\tao->o |= rd;\n\tao->o |= rn << 24;\n\tao->o |= rm << 8;\n\tif (shift) {\n\t\terr = false;\n\t\tut32 shiftnum = thumb_getshift (ao->a[3]);\n\t\tif (err) {\n\t\t\treturn -1;\n\t\t}\n\t\tao->o |= shiftnum;\n\t}\n\tif (m & S_BIT) {\n\t\tao->o |= 1 << 28;\n\t}\n\treturn 4;\n}\n\nstatic void std_opt_2(ArmOpcode *ao) {\n\tao->a[2] = ao->a[1];\n\tao->a[1] = ao->a[0];\n}\n\nstatic void std_opt_3(ArmOpcode *ao) {\n\tao->a[3] = ao->a[2];\n\tao->a[2] = ao->a[1];\n\tao->a[1] = ao->a[0];\n}\n\n// TODO: group similar instructions like for non-thumb\nstatic int thumb_assemble(ArmOpcode *ao, ut64 off, const char *str) {\n\tut64 m;\n\tao->o = UT32_MAX;\n\tif (!strcmpnull (ao->op, \"udf\")) {\n\t\tao->o = 0xde;\n\t\tao->o |= getnum (ao->a[0]) << 8;\n\t\treturn 2;\n\t} else\n\tif ((m = opmask (ao->op, \"add\", S_BIT | W_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif (reg2 == 13) {\n\t\t\t\tif ((reg1 < 8) && (num < 1024) && (num % 4 == 0) && (!(m & DOTW_BIT)) && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0x00a8;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\tif ((reg1 == 13) && (num < 512) && (num % 4 == 0) && (!(m & DOTW_BIT)) && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0x00b0;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\terr = false;\n\t\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0x0df10000;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tao->o |= thnum;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t\t}\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\n\t\t\t\tif (num > 4095) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0x0df20000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif (num < 8) {\n\t\t\t\tao->o = 0x001c;\n\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\tao->o |= (num >> 2);\n\t\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((reg1 < 8) && (reg1 == reg2) && (num < 256)) {\n\t\t\t\tao->o = 0x0030;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\terr = false;\n\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\tao->o = 0x00f10000;\n\t\t\t\tao->o |= thnum;\n\t\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t\t}\n\n\t\t\tif (num > 4095) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x00f20000;\n\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\tif (reg2 == 13) {\n\t\t\t\tif ((reg1 == reg3) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\t\tao->o = 0x6844;\n\t\t\t\t\tao->o |= (reg1 & 0x7) << 8;\n\t\t\t\t\tao->o |= (reg1 >> 3) << 15;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\tif ((reg1 == 13) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\t\tao->o = 0x8544;\n\t\t\t\t\tao->o |= reg3 << 11;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0x0deb0000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= reg3 << 8;\n\t\t\t\tao->o |= shift;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t}\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg3 < 8) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\tao->o = 0x0018;\n\t\t\t\tao->o |= (reg3 >> 2);\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((reg1 == reg2) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\tao->o = 0x0044;\n\t\t\t\tao->o |= (reg1 & 0x7) << 8;\n\t\t\t\tao->o |= (reg1 >> 3) << 15;\n\t\t\t\tao->o |= reg3 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0x00eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"adc\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tao->o = 0x40f10000;\n\t\t\tao->o |= getthimmed12 (ao->a[2]);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x4041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x40eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tstd_opt_3 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\t\t// a bit naughty, perhaps?\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x40eb0000;\n\t\t\treturn std_32bit_3reg(ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"adr\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg = getreg (ao->a[0]);\n\t\t\tst32 label = getnum (ao->a[1]);\n\t\t\tif ( !(m & DOTW_BIT) && (reg < 8) && (label < 1024) && (label >= 0) && (label % 4 == 0)) {\n\t\t\t\tao->o = 0x00a0;\n\t\t\t\tao->o |= reg;\n\t\t\t\tao->o |= (label / 4) << 8;\n\t\t\t\treturn 2;\n\t\t\t} else if ((label < 0) && (label > -4096)) {\n\t\t\t\tif (m & DOTN_BIT) {\n\t\t\t\t\t// this is explicitly an error\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0xaff20000;\n\t\t\t\tao->o |= reg;\n\t\t\t\tao->o |= getthzeroimmed12 (-label);\n\t\t\t\treturn 4;\n\t\t\t} else if ((label > 0) && (label < 4096)) {\n\t\t\t\tif (m & DOTN_BIT) {\n\t\t\t\t\t// this is explicitly an error\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x0ff20000;\n\t\t\t\tao->o |= reg;\n\t\t\t\tao->o |= getthzeroimmed12 (label);\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\treturn -1;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"and\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x00ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut32 imm = getthimmed12 (ao->a[2]);\n\t\t\tao->o = 0x00f00000;\n\t\t\tao->o |= imm;\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tstd_opt_3 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x00ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"asr\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 imm = getnum (ao->a[2]);\n\t\t\tif (((int)imm < 1) && ((int)imm > 32)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x0010;\n\t\t\tao->o |= (imm & 0x3) << 14;\n\t\t\tao->o |= (imm & 0x1c) >> 2;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x4fea2000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (imm & 0x3) << 14;\n\t\t\tao->o |= (imm & 0x1c) << 2;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x40fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"b\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tst32 offset = thumb_getoffset (ao->a[0], off);\n\t\t\tif (offset % 2 != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((m & C_BITS) == C_BITS) {\n\t\t\t\tif ((offset >= -2048) && (offset <= 2046) && (!(m & DOTW_BIT))) {\n\t\t\t\t\tao->o = 0x00e0;\n\t\t\t\t\tao->o |= ((offset/2 & 0xff) << 8);\n\t\t\t\t\tao->o |= ((offset/2 & 0x700) >> 8);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tif ((offset < -16777216) || (offset > 16777214) || (offset % 2 != 0)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x00f00090;\n\t\t\t\tao->o |= getthbimmed(offset);\n\t\t\t\treturn 4;\n\t\t\t} else {\n\t\t\t\tif ((offset >= -256) && (offset <= 254) && (!(m & DOTW_BIT))) {\n\t\t\t\t\tao->o = 0x00d0;\n\t\t\t\t\tao->o |= (ut16) ((offset/2) << 8);\n\t\t\t\t\tao->o |= ((m & C_BITS) >> 2);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tif ((offset < -1048576) || (offset > 1048574) || (offset % 2 != 0)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0x00f00080;\n\t\t\t\tao->o |= (ut32)(offset & 0x80000) >> 16;\n\t\t\t\tao->o |= (ut32)(offset & 0x40000) >> 13;\n\t\t\t\tao->o |= (ut32)(offset & 0x3f000) << 12;\n\t\t\t\tao->o |= (ut32)(offset & 0xe00) >> 9;\n\t\t\t\tao->o |= (ut32)(offset & 0x1fe) << 7;\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tao->o |= 1 << 18;\n\t\t\t\t}\n\t\t\t\tao->o |= (((m & C_BITS) & 0xc) << 28);\n\t\t\t\tao->o |= (((m & C_BITS) & 0x30) << 12);\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bl\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tst32 offset = thumb_getoffset (ao->a[0], off);\n\t\t\tao->o = 0x00f000d0;\n\t\t\tif ((offset > 16777214) || (offset < -16777216) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= getthbimmed(offset);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bx\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tao->o = 0x0047;\n\t\t\tao->o |= reg1 << 11;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif (( m = opmask (ao->op, \"blx\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tao->o = 0x8047;\n\t\t\tao->o |= reg1 << 11;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_CONST: {\n\t\t\tst32 offset = thumb_getoffset (ao->a[0], off);\n\t\t\tao->o = 0x00f000c0;\n\t\t\tif ((offset > 16777214) || (offset < -16777216) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\toffset += off & 0x2; // (Align(PC,4)\n\t\t\tao->o |= getthbimmed (offset);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bfc\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST_CONST: {\n\t\t\tif (m & DOTN_BIT) {\n\t\t\t\t// this is explicitly an error\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 lsb = getnum (ao->a[1]);\n\t\t\tut32 width = getnum (ao->a[2]);\n\t\t\tut32 msb = lsb + width - 1;\n\t\t\tif ((lsb > 31) || (msb > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x6ff30000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= ((lsb & 0x1c) << 2);\n\t\t\tao->o |= ((lsb & 0x3) << 14);\n\t\t\tao->o |= (msb << 8);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bfi\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST_CONST: {\n\t\t\tut32 lsb = getnum (ao->a[2]);\n\t\t\tut32 width = getnum (ao->a[3]);\n\t\t\tut32 msb = lsb + width - 1;\n\t\t\tif ((lsb > 31) || (msb > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x60f30000;\n\t\t\tao->o |= ((lsb & 0x1c) << 2);\n\t\t\tao->o |= ((lsb & 0x3) << 14);\n\t\t\tao->o |= (msb << 8);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bic\", S_BIT) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x8043;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x20ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tao->o = 0x20f00000;\n\t\t\tao->o |= getthimmed12 (ao->a[2]);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tstd_opt_3 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x20ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bkpt\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\tif (num > 255) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00be;\n\t\t\tao->o |= num << 8;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cbnz\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tst32 offset = thumb_getoffset (ao->a[1], off);\n\t\t\tif ((reg1 > 7) || (offset > 127) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00b9;\n\t\t\tao->o |= reg1 << 8;\n\t\t\tao->o |= (offset & 0x3e) << 10;\n\t\t\tao->o |= (offset & 0x40) >> 5;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cbz\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tst32 offset = thumb_getoffset (ao->a[1], off);\n\t\t\tif ((reg1 > 7) || (offset > 127) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00b1;\n\t\t\tao->o |= reg1 << 8;\n\t\t\tao->o |= (offset & 0x3e) << 10;\n\t\t\tao->o |= (offset & 0x40) >> 5;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cdp\", TWO_BIT) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_COREG_COREG_COREG: {\n\t\t\tao->a[5] = \"0\";\n\t\t        }\n\t\t\t//intentional fallthrough\n\t\tcase THUMB_COPROC_CONST_COREG_COREG_COREG_CONST: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc1 = getnum (ao->a[1]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[2]);\n\t\t\tut8 reg2 = getcoprocreg (ao->a[3]);\n\t\t\tut8 reg3 = getcoprocreg (ao->a[4]);\n\t\t\tut32 opc2 = getnum (ao->a[5]);\n\t\t        if ((coproc > 15) || (opc1 > 15) || (opc2 > 7)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00ee0000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc1 << 28;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= opc2 << 13;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \t\n\tif (( m = opmask (ao->op, \"clrex\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff32f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"clz\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xb0fa80f0;\n\t\t\tao->a[2] = ao->a[1];\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cmn\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\t\t\tao->o = 0x10f1000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xc042;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tao->o = 0x10eb000f;\n\t\t\treturn std_32bit_2reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cmp\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getnum (ao->a[1]);\n\t\t\tif ((num < 256) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0028;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tnum = getthimmed12 (ao->a[1]);\n\t\t\tao->o = 0xb0f1000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tao->o = 0x8042;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (!(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x0045;\n\t\t\t\tao->o |= ((reg1 & 0x7) << 8);\n\t\t\t\tao->o |= ((reg1 & 0x8) << 12);\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\t\t\tao->o = 0xb0eb000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cps\", ID_BIT | IE_BIT) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER: {\n\t\t\tst8 aif = iflag(ao->a[0]);\n\t\t\tif (aif == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x60b6;\n\t\t\t\tao->o |= aif << 8;\n\t\t\t\tif (m & ID_BIT) {\n\t\t\t\t\tao->o |= 1 << 12;\n\t\t\t\t}\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[1] = \"0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_OTHER_CONST: {\n\t\t\tst8 aif = iflag(ao->a[0]);\n\t\t\tut8 mode = getnum (ao->a[1]);\n\t\t\tif ((mode > 31) || (aif == -1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xaff30085;\n\t\t\tao->o |= mode << 8;\n\t\t\tao->o |= aif << 13;\n\t\t\tif (m & ID_BIT) {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_CONST: {\n\t\t\tut8 mode = getnum (ao->a[0]);\n\t\t\tif ((m & ID_BIT) || (m & IE_BIT) || (mode > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xaff30081;\n\t\t\tao->o |= mode << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"dbg\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif (option > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xaff3f080;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"dmb\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff35f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tif (strcmpnull (ao->a[0], \"sy\")) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->a[0] = \"15\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif (option != 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xbff3508f;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"dsb\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff34f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tif (!strcmpnull ((ao->a[0] = parse_hints(ao->a[0])), \"-1\")) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif ((option != 6) && (option != 7) && (option != 14) && (option != 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xbff3408f;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"eor\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST:\n\t\t\tstd_opt_2 (ao);\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 imm = getthimmed12 (ao->a[2]);\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x80f00000;\n\t\t\tao->o |= imm;\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x4040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG:\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x80ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"isb\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff36f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tif (strcmpnull (ao->a[0], \"sy\")) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->a[0] = \"15\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif (option != 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xbff3608f;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = itmask (ao->op))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER: {\n\t\t\tut16 cond = 0;\n\t\t\tut16 i;\n\t\t\t\n\t\t\tconst char *conds[] = {\n\t\t\t\t\"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n\t\t\t\t\"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\", 0\n\t\t\t};\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tfor (i = 0; conds[i]; i++) {\n\t\t\t\tif (!(strcmpnull(ao->a[0], conds[i]))) {\n\t\t\t\t\tcond = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == 16) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00bf;\n\t\t\tao->o |= cond << 12;\n\n\t\t\tut8 nrcs = (m & 0x30) >> 4;\n\t\t\tut8 thiset = 0;\n\n\t\t\tfor (i = 0; i < nrcs; i++) {\n\t\t\t\tthiset = ((m & (1 << (3 - i))) >> (3 - i));\n\t\t\t\tao->o |= ((cond & 0x1) ^ thiset) << (11 - i);\n\t\t\t}\n\t\t\tao->o |= 1 << (11 - i);\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldc\", TWO_BIT | L_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 proc = getcoproc (ao->a[0]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[2]);\n\t\t\tst32 imm = getnummemend (ao->a[3]);\n\t\t\tao->o = 0x10ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (imm < 0) {\n\t\t\t\timm = -imm;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tif ((proc > 15) || (reg1 > 15) || (reg2 > 15) || (imm > 1024) || (imm % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= proc;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= (imm >> 2) << 8;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK:\n\t\t\tao->a[3] = \"0\";\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK_CONST: {\n\t\t\tut8 proc = getcoproc (ao->a[0]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[2]);\n\t\t\tst32 imm = getnum (ao->a[3]);\n\t\t\tao->o = 0x30ec0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (imm < 0) {\n\t\t\t\timm = -imm;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tif ((proc > 15) || (reg1 > 15) || (reg2 > 15) || (imm > 1024) || (imm % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= proc;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= (imm >> 2) << 8;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 proc = getcoproc (ao->a[0]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[2]);\n\t\t\tst32 imm = getnummemendbang (ao->a[3]);\n\t\t\tao->o = 0x30ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (imm < 0) {\n\t\t\t\timm = -imm;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tif ((proc > 15) || (reg1 > 15) || (reg2 > 15) || (imm > 1024) || (imm % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= proc;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= (imm >> 2) << 8;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldm\", DB_BIT | EA_BIT | IA_BIT | FD_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REGBANG_LIST: {\n\t\t\tut8 reg1 = getregmembang (ao->a[0]);\n\t\t\tut32 list = getreglist (ao->a[1]);\n\t\t\tif (!((m & DB_BIT) || (m & EA_BIT)) && !(list & 0xff00) && (reg1 < 8) && !(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x00c8;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tif (list & (1 << reg1)) {\n\t\t\t\t\tlist ^= 1 << (reg1);\n\t\t\t\t}\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\t\t\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (list & 0x2000) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((m & DB_BIT) || (m & EA_BIT)) {\n\t\t\t\tao->o = 0x30e90000;\n\t\t\t} else {\n\t\t\t\t// ldmia is the default!\n\t\t\t\tao->o = 0xb0e80000;\n\t\t\t}\n\t\t\t\t\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_LIST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 list = getreglist (ao->a[1]);\n\t\t\tif (!((m & DB_BIT) || (m & EA_BIT)) && !(list & 0xff00) && (reg1 < 8) && !(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x00c8;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= 1 << (reg1 + 8);\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (list & 0x2000) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((m & DB_BIT) || (m & EA_BIT)) {\n\t\t\t\tao->o = 0x10e90000;\n\t\t\t} else {\n\t\t\t\tao->o = 0x90e80000;\n\t\t\t}\n\t\t\t\t\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldr\", B_BIT | H_BIT | D_BIT | T_BIT | S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 ldrsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tif ((m & S_BIT) && !(m & (B_BIT | H_BIT))) {\n\t\t\treturn -1;\n\t\t}\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST:\n\t\t\tao->a[2] = ao->a[1];\n\t\t\tstrcat (ao->a[2],\"]\");\n\t\t\tao->a[1] = \"[r15\";\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREGBRACK:\n\t\t\tif (ao->a[2] == NULL) { // double fallthrough\n\t\t\t\tao->a[1][strlen (ao->a[1]) -1] = '\\0';\n\t\t\t\tao->a[2] = \"0]\";\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tst32 num = getnummemend (ao->a[2]);\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x50f8000e;\n\t\t\t\t\tao->o |= num << 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tif (reg2 == 15) {\n\t\t\t\t\tif ((num > 4095) || (num < -4095)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif ((reg1 < 8) && (num < 1024) && (num % 4 == 0)) {\n\t\t\t\t\t\tao->o = 0x0048;\n\t\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x5ff80000;\n\t\t\t\t\tif (num < 0) {\n\t\t\t\t\t\tnum = -num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0x0f00) >> 8;\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t\tif ((reg2 == 13) && (reg1 < 8) && (num >= 0) && (num < 1024) && (num % 4 == 0) && (!(m & DOTW_BIT))) {\n\t\t\t\t\tao->o = 0x0098;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tif ((num >= 0) && (num < 128) && (num % 4 == 0)) {\n\t\t\t\t\tao->o = 0x0068;\n\t\t\t\t\tao->o |= (num >> 4);\n\t\t\t\t\tao->o |= ((num >> 2) & 0x3) << 14;\n\t\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((num > 4095) || (num < -1023)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (num >= 0) {\n\t\t\t\t\tao->o = 0xd0f80000;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tao->o = 0x50f8000c;\n\t\t\t\tao->o |= (-num & 0xff) << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t} else\n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x10f8000e;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= num << 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tif (reg2 == 15) {\n\t\t\t\t\tif ((num > 4095) || (num < -4095)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x1ff80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tif (num < 0) {\n\t\t\t\t\t\tnum = -num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0x0f00) >> 8;\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t\tif ((num >= 0) && (num < 32) && (!(m & S_BIT))) {\n\t\t\t\t\tao->o = 0x0078;\n\t\t\t\t\tao->o |= (num >> 2);\n\t\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((num > 4095) || (num < -255)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (num >= 0) {\n\t\t\t\t\tao->o = 0x90f80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tao->o = 0x10f8000c;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t}\n\t\t\t\tao->o |= -num << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t} else\n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x30f8000e;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= num << 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tif (reg2 == 15) {\n\t\t\t\t\tif ((num > 4095) || (num < -4095)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x3ff80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tif (num < 0) {\n\t\t\t\t\t\tnum = -num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0x0f00) >> 8;\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t\tif ((num >= 0) && (num < 64) && (num % 2 == 0) && (!(m & S_BIT))) {\n\t\t\t\t\tao->o = 0x0088;\n\t\t\t\t\tao->o |= (num >> 3);\n\t\t\t\t\tao->o |= ((num >> 1) & 0x3) << 14;\n\t\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((num > 4095) || (num < -255)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (num >= 0) {\n\t\t\t\t\tao->o = 0xb0f80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tao->o = 0x30f8000c;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t}\n\t\t\t\tao->o |= -num << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\t\t\t\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[1]);\n\t\t\tst32 num = getnum (ao->a[2]);\n\t\t\tif ((num < -255) || (num > 255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->o = 0x50f80009;\n\t\t\t} else \n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0x10f80009;\n\t\t\t} else \n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0x30f80009;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 16;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tst32 num = getnummemendbang (ao->a[2]);\n\t\t\tif ((num < -255) || (num > 255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->o = 0x50f8000d;\n\t\t\t} else \n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0x10f8000d;\n\t\t\t} else \n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0x30f8000d;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 16;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_REGBRACK: {\n\t\t\tut8 reg3 = getregmemend (ao->a[2]);\n\t\t\tif (reg3 < 8) {\n\t\t\t\tif (ldrsel == 0) {\n\t\t\t\t\tao->o = 0x0058;\n\t\t\t\t} else\n\t\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o = 0x0056;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o = 0x005c;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o = 0x005e;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o = 0x005a;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tao->o |= (reg3 & 0x4) >> 2;\n\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tao->a[2][strlen (ao->a[2]) -1] = '\\0';\n\t\t\tao->a[3] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = getshiftmemend (ao->a[3]);\n\n\t\t\tshift >>= 2;\n\t\t\tif (shift & 0xffffcfff) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->o = 0x50f80000;\n\t\t\t} else\n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0x10f80000;\n\t\t\t} else\n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0x30f80000;\n\t\t\t} else\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 16;\n\t\t\t}\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tao->a[2][strlen (ao->a[2]) -1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((num > 1020) || (num < -1020) || (num % 4 != 0) || (ldrsel != D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x50e90000;\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\tst32 num = getnum (ao->a[3]);\n\t\t\tif ((num > 1020) || (num < -1020) || (num % 4 != 0) || (ldrsel != D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x70e80000;\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemendbang (ao->a[3]);\n\t\t\tif ((num > 1020) || (num < -1020) || (num % 4 != 0) || (ldrsel != D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x70e90000;\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldrex\", B_BIT | H_BIT | D_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 ldrsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[1]);\n\t\t\t\n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0xd0e84f0f;\n\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\tao->o |= reg2 << 24;\n\t\t\t\treturn 4;\n\t\t\t} else\n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0xd0e85f0f;\n\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\tao->o |= reg2 << 24;\n\t\t\t\treturn 4;\n\t\t\t} else\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->a[1][strlen (ao->a[1]) - 1] = '\\0';\n\t\t\t\tao->a[2] = \"0]\";\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACK: {\n\t\t\tst32 num = getnummemend (ao->a[2]);\n\t\t\tif ((ldrsel != 0) || (num < 0) || (num > 1020) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x50e8000f;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\tif (!(ldrsel & D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xd0e87f00;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\treturn 4;\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"lsl\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\t\t\tif (num > 32) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x0000;\t\t\t\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\tao->o |= (num & 0x03) << 14;\n\t\t\t\tao->o |= num >> 2;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x4fea0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (num >> 2) << 4;\n\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x8040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x00fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\t\t\n\tif ((m = opmask (ao->op, \"lsr\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\t\t\tif (num > 32) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x0008;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\tao->o |= (num & 0x03) << 14;\n\t\t\t\tao->o |= num >> 2;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x4fea1000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (num >> 2) << 4;\n\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xc040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x20fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mcr\", R_BIT | TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG: {\n\t\t\tao->a[5] = \"0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG_CONST: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc1 = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 coreg1 = getcoprocreg (ao->a[3]);\n\t\t\tut32 coreg2 = getcoprocreg (ao->a[4]);\n\t\t\tut32 opc2 = getnum (ao->a[5]);\n\n\t\t\tif ((coproc > 15) || (opc1 > 7) || (reg1 > 15) || (coreg1 > 15) || (coreg2 > 15) || (opc2 > 7) || (m & R_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x00ee1000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc1 << 29;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= coreg1 << 24;\n\t\t\tao->o |= coreg2 << 8;\n\t\t\tao->o |= opc2 << 13;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_CONST_REG_REG_COREG: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 reg2 = getreg (ao->a[3]);\n\t\t\tut32 coreg = getcoprocreg (ao->a[4]);\n\n\t\t\tif ((coproc > 15) || (opc > 15) || (reg1 > 15) || (reg2 > 15) || (coreg > 15) || (!(m & R_BIT))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40ec0000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc << 12;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= coreg << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mla\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut32 reg4 = getreg (ao->a[3]);\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00fb0000;\n\t\t\tao->o |= reg4 << 4;\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mls\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut32 reg4 = getreg (ao->a[3]);\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00fb1000;\n\t\t\tao->o |= reg4 << 4;\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mov\", S_BIT | W_BIT | T_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getnum (ao->a[1]);\n\n\t\t\tif (reg1 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((m & W_BIT) || (m & T_BIT)) {\n\t\t\t\tut32 wnum = getnum (ao->a[1]);\n\t\t\t\tif (wnum > 65535) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x40f20000;\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t}\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= getthzeroimmed16 (wnum);\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\t\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((num < 256) && (reg1 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0020;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\t\n\t\t\tao->o = 0x4ff00000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= getthimmed12 (ao->a[1]);\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tut32 reg2 = getreg (ao->a[1]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((!(m & S_BIT)) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0046;\n\t\t\t\tao->o |= (reg1 & 0x7) << 8;\n\t\t\t\tao->o |= (reg1 & 0x8) << 12;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tif ((reg1 < 8) && (reg2 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x4fea0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"mrc\", TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG: {\n\t\t\tao->a[5] = \"0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG_CONST: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc1 = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 coreg1 = getcoprocreg (ao->a[3]);\n\t\t\tut32 coreg2 = getcoprocreg (ao->a[4]);\n\t\t\tut32 opc2 = getnum (ao->a[5]);\n\n\t\t\tif ((coproc > 15) || (opc1 > 7) || (reg1 > 15) || (coreg1 > 15) || (coreg2 > 15) || (opc2 > 7)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10ee1000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc1 << 29;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= coreg1 << 24;\n\t\t\tao->o |= coreg2 << 8;\n\t\t\tao->o |= opc2 << 13;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mrrc\", TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_REG_REG_COREG: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 reg2 = getreg (ao->a[3]);\n\t\t\tut32 coreg = getcoprocreg (ao->a[4]);\n\n\t\t\tif ((coproc > 15) || (opc > 15) || (reg1 > 15) || (reg2 > 15) || (coreg > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x50ec0000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc << 12;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= coreg << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mrs\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_OTHER: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tr_str_case (ao->a[1], false);\n\n\t\t\tif (reg1 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((!strcmp(ao->a[1], \"cpsr\")) || (!strcmp(ao->a[1], \"apsr\"))) {\n\t\t\t\tao->o = 0xeff30080;\n\t\t\t\tao->o |= reg1;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif (!strcmp(ao->a[1], \"spsr\")) {\n\t\t\t\tao->o = 0xfff30080;\n\t\t\t\tao->o |= reg1;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"msr\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER_REG: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tut8 spsr = 0;\n\t\t\tut8 bank = interpret_msrbank (ao->a[0], &spsr);\n\t\t\tut32 reg1 = getreg (ao->a[1]);\n\n\t\t\tif ((bank == 0) || (reg1 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x80f30080;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= bank;\n\t\t\tif (spsr != 0) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mul\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\n\t\t\tao->o = 0x4043;\n\t\t\tif ((reg1 == reg3) && (std_16bit_2reg (ao, m))) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0x00fb00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mvn\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x6ff00000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= num;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xc043;\n\t\t\tif ((shift == 0) && (std_16bit_2reg (ao, m))) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0x6fea0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"nop\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30080;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tao->o = 0x00bf;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"orn\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x60f00000;\n\t\t\tao->o |= num;\n\t\t\treturn (std_32bit_2reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x60ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"orr\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40f00000;\n\t\t\tao->o |= num;\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0043;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x40ea0000;\n\t\t\treturn (std_32bit_3reg (ao, m, true));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"pkh\", BT_BIT | TB_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & TB_BIT) {\n\t\t\t\tao->a[3] = \"asr 0\";\n\t\t\t} else\n\t\t\tif (m & BT_BIT) {\n\t\t\t\tao->a[3] = \"lsl 0\";\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (((m & TB_BIT) && ((shift & 0x00003000) != 0x00002000)) || ((m & BT_BIT) && ((shift & 0x00003000) != 0)) || ((m & (TB_BIT | BT_BIT)) == 0)) {\t\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xc0ea0000;\n\t\t\treturn (std_32bit_3reg (ao, m, true));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"pld\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tst32 num = getnummemend (ao->a[1]);\n\n\t\t\tif (reg1 == 15) {\n\t\t\t\tif ((num < -4095) || (num > 4095)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x1ff800f0;\n\t\t\t\tif (num > 0) {\n\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t} else {\n\t\t\t\t\tnum = -num;\n\t\t\t\t}\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg1 > 15) || (num < -255) || (num > 4095)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num > 0) {\n\t\t\t\tao->o = 0x90f800f0;\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\tao->o |= reg1 << 24;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tnum = -num;\n\t\t\tao->o = 0x10f800fc;\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_BRACKREG_REGBRACK: {\n\t\t\tao->a[1][strlen (ao->a[1]) - 1] = '\\0';\n\t\t\tao->a[2] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = getshiftmemend (ao->a[2]) >> 2;\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || ((shift & 0xffffcfff) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10f800f0;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"pli\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tst32 num = getnummemend (ao->a[1]);\n\n\t\t\tif (reg1 == 15) {\n\t\t\t\tif ((num < -4095) || (num > 4095)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x1ff900f0;\n\t\t\t\tif (num > 0) {\n\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t} else {\n\t\t\t\t\tnum = -num;\n\t\t\t\t}\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg1 > 15) || (num < -255) || (num > 4095)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num > 0) {\n\t\t\t\tao->o = 0x90f900f0;\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\tao->o |= reg1 << 24;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tnum = -num;\n\t\t\tao->o = 0x10f900fc;\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_BRACKREG_REGBRACK: {\n\t\t\tao->a[1][strlen (ao->a[1]) -1] = '\\0';\n\t\t\tao->a[2] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = getshiftmemend (ao->a[2]) >> 2;\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || ((shift & 0xffffcfff) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10f900f0;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"pop\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_LIST: {\n\t\t\tst32 list = getreglist (ao->a[0]);\n\t\t\tif ((list <= 0) || ((list & (1 << 13)) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((!(m & DOTW_BIT)) && ((list & 0x00007f00) == 0)) {\n\t\t\t\tao->o = 0x00bc;\n\t\t\t\tao->o |= (list & 0x8000) >> 15;\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0xbde80000;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"push\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_LIST: {\n\t\t\tst32 list = getreglist (ao->a[0]);\n\t\t\tif ((list <= 0) || ((list & 0x0000a000) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((!(m & DOTW_BIT)) && ((list & 0x00001f00) == 0)) {\n\t\t\t\tao->o = 0x00b4;\n\t\t\t\tao->o |= (list & 0x4000) >> 14;\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x2de90000;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa10f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa10f0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x80fa80f0;\n\t\t\t}\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa10f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qdadd\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x80fa90f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qdsub\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x80fab0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa10f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa10f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa10f0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x80faa0f0;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rbit\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = ao->a[1];\n\t\t\tao->o = 0x90faa0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rev\", SIXTEEN_BIT | SH_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x40ba;\n\t\t\t} else\n\t\t\tif (m & SH_BIT) {\n\t\t\t\tao->o = 0xc0ba;\n\t\t\t} else {\n\t\t\t\tao->o = 0x00ba;\n\t\t\t}\n\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa90f0;\n\t\t\t} else\n\t\t\tif (m & SH_BIT) {\n\t\t\t\tao->o = 0x90fab0f0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x90fa80f0;\n\t\t\t}\n\t\t\tao->a[2] = ao->a[1];\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rfe\", IA_BIT | FD_BIT | DB_BIT | EA_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 wb = 0;\n\t\tswitch (argt) {\n\t\tcase THUMB_REGBANG: {\n\t\t\tao->a[0][strlen (ao->a[0]) - 1] = '\\0';\n\t\t\twb = 0x20000000;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\n\t\t\tif (reg1 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((m & DB_BIT) || (m & EA_BIT)) {\n\t\t\t\tao->o = 0x10e800c0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x90e900c0;\n\t\t\t}\n\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= wb;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ror\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (num > 31) || (num < 1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x4fea3000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\tao->o |= (num & 0x1c) << 2;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xc041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x60fa00f0;\n\t\t\treturn (std_32bit_3reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rrx\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x4fea3000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rsb\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x4042;\n\t\t\tif ((num == 0) && std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0xc0f10000;\n\t\t\tao->o |= num;\n\t\t\treturn (std_32bit_2reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0xc0eb0000;\n\t\t\treturn (std_32bit_3reg (ao, m, true));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa00f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa00f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sbc\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x8041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x60eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tao->o = 0x60f10000;\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= num;\n\t\t\t\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"sbfx\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST_CONST: {\n\t\t\tut32 lsb = getnum (ao->a[2]);\n\t\t\tut32 width = getnum (ao->a[3]);\n\t\t\tut32 msb = lsb + width - 1;\n\t\t\tif ((lsb > 31) || (msb > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x40f30000;\n\t\t\tao->o |= ((lsb & 0x1c) << 2);\n\t\t\tao->o |= ((lsb & 0x3) << 14);\n\t\t\tao->o |= ((width - 1) << 8);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sdiv\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x90fbf0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sel\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa80f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"setend\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tao->o = 0x50b6;\n\t\t\tif (!(strcmpnull (ao->a[0], \"be\"))) {\n\t\t\t\tao->o |= 1 << 11;\n\t\t\t\treturn 2;\n\t\t\t} else\n\t\t\tif (!(strcmpnull (ao->a[0], \"le\"))) {\n\t\t\t\treturn 2;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t        }\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sev\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE:\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30480;\n\t\t\t\treturn 4;\n\t\t\t} else {\n\t\t\t\tao->o = 0x40bf;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shadd\", EIGHT_BIT | SIXTEEN_BIT ))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa20f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa20f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa20f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa20f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa20f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa20f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smc\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\t\n\t\t\tif (err || (num > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xf0f70080;\n\t\t\tao->o |= num << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smla\", BB_BIT | BT_BIT | TB_BIT | TT_BIT | WB_BIT | WT_BIT | L_BIT | D_BIT | X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15) || (m & DOTN_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & L_BIT) {\n\t\t\t\tif (m & BB_BIT) {\n\t\t\t\t\tao->o = 0xc0fb8000;\n\t\t\t\t} else\n\t\t\t\tif (m & BT_BIT) {\n\t\t\t\t\tao->o = 0xc0fb9000;\n\t\t\t\t} else\n\t\t\t\tif (m & TB_BIT) {\n\t\t\t\t\tao->o = 0xc0fba000;\n\t\t\t\t} else\n\t\t\t\tif (m & TT_BIT) {\n\t\t\t\t\tao->o = 0xc0fbb000;\n\t\t\t\t} else\n\t\t\t\tif (m & D_BIT) {\n\t\t\t\t\tao->o = 0xc0fbc000;\n\t\t\t\t\tif (m & X_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 12;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tao->o = 0xc0fb0000;\n\t\t\t\t}\n\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\tao->o |= reg2;\n\t\t\t\tao->o |= reg3 << 24;\n\t\t\t\tao->o |= reg4 << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tif (m & BB_BIT) {\n\t\t\t\tao->o = 0x10fb0000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & BT_BIT) {\n\t\t\t\tao->o = 0x10fb1000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & TB_BIT) {\n\t\t\t\tao->o = 0x10fb2000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & TT_BIT) {\n\t\t\t\tao->o = 0x10fb3000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & D_BIT) {\n\t\t\t\tao->o = 0x20fb0000;\n\t\t\t\tif (m & X_BIT) {\n\t\t\t\t\tao->o |= 1 << 12;\n\t\t\t\t}\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & WB_BIT) {\n\t\t\t\tao->o = 0x30fb0000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & WT_BIT) {\n\t\t\t\tao->o = 0x30fb1000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\treturn -1;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smlsd\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x40fb0000;\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smlsld\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15) || (m & DOTN_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xd0fbc000;\n\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smmla\", R_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x50fb0000;\n\t\t\tif (m & R_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smmls\", R_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x60fb0000;\n\t\t\tif (m & R_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smmul\", R_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x50fb00f0;\n\t\t\tif (m & R_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smuad\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x20fb00f0;\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smul\", BB_BIT | BT_BIT | TB_BIT | TT_BIT | WB_BIT | WT_BIT | L_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & BB_BIT) {\n\t\t\t\tao->o = 0x10fb00f0;\n\t\t\t} else\n\t\t\tif (m & BT_BIT) {\n\t\t\t\tao->o = 0x10fb10f0;\n\t\t\t} else\n\t\t\tif (m & TB_BIT) {\n\t\t\t\tao->o = 0x10fb20f0;\n\t\t\t} else\n\t\t\tif (m & TT_BIT) {\n\t\t\t\tao->o = 0x10fb30f0;\n\t\t\t} else\n\t\t\tif (m & WB_BIT) {\n\t\t\t\tao->o = 0x30fb00f0;\n\t\t\t} else\n\t\t\tif (m & WT_BIT) {\n\t\t\t\tao->o = 0x30fb10f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15) || (m & DOTN_BIT) || (!(m & L_BIT))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x80fb0000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smusd\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x40fb00f0;\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"srs\", DB_BIT | FD_BIT | IA_BIT | EA_BIT))) {\n\t\tut32 w = 0;\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONSTBANG: {\n\t\t\tao->a[0][strlen (ao->a[0]) - 1] = '\\0';\n\t\t\tw = 1;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\tif (num > 31) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((m & DB_BIT) || (m & FD_BIT)) {\n\t\t\t\tao->o = 0x0de800c0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x8de900c0;\n\t\t\t}\t\t\t\t\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= w << 29;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ssat\", SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_CONST_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getnum (ao->a[1]) - 1;\n\t\t\tut8 reg2 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (err || (reg1 > 15) || (reg2 > 15) || (num > 31) || (shift & 0x00001000) || ((m & SIXTEEN_BIT) && shift)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (shift & 0x00002000) {\n\t\t\t\tshift |= 0x20000000;\n\t\t\t\tshift &= 0xffffdfff;\n\t\t\t}\n\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x20f30000;\n\t\t\t} else {\n\t\t\t\tao->o = 0x00f30000;\n\t\t\t}\n\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ssax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ssub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa00f0;\n\t\t\t} else\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa00f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else if ((m = opmask (ao->op, \"stc\", L_BIT | TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK: {\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 coproc = getcoproc (ao->a[0]);\n\t\t\tut8 coreg = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((coproc > 15) || (coreg > 15) || (reg > 15) || (num > 4092) || (num < -4092) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t\tao->o = 0x00ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= coreg << 4;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK_CONST: {\n\t\t\tut8 coproc = getcoproc (ao->a[0]);\n\t\t\tut8 coreg = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg = getregmemstartend (ao->a[2]);\n\t\t\tst32 num = getnum (ao->a[3]);\n\n\t\t\tif ((coproc > 15) || (coreg > 15) || (reg > 15) || (num > 4092) || (num < -4092) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t\tao->o = 0x20ec0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= coreg << 4;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 coproc = getcoproc (ao->a[0]);\n\t\t\tut8 coreg = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemendbang (ao->a[3]);\n\n\t\t\tif ((coproc > 15) || (coreg > 15) || (reg > 15) || (num > 4092) || (num < -4092) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t\tao->o = 0x20ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= coreg << 4;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else if ((m = opmask (ao->op, \"stm\", FD_BIT | DB_BIT | IA_BIT | EA_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tbool wb = false;\n\t\tswitch (argt) {\n\t\tcase THUMB_REGBANG_LIST: {\n\t\t\twb = true;\n\t\t\tao->a[0][strlen (ao->a[0]) - 1] = '\\0';\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_LIST: {\n\t\t\tut8 reg = getreg (ao->a[0]);\n\t\t\tst32 list = getreglist (ao->a[1]);\n\t\t\tif ((list <= 0) || ((list & 0x0000a000) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((!(m & DOTW_BIT)) && ((list & 0x0000ff00) == 0) && (!(m & (FD_BIT | DB_BIT))) && wb) {\n\t\t\t\tao->o = 0x00c0;\n\t\t\t\tao->o |= (list & 0x000000ff) << 8;\n\t\t\t\tao->o |= reg;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif ((m & (FD_BIT | DB_BIT | IA_BIT | EA_BIT)) == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif (m & (FD_BIT | DB_BIT)) {\n\t\t\t\tao->o = 0x00e90000;\n\t\t\t} else {\n\t\t\t\tao->o = 0x80e80000;\n\t\t\t}\n\n\t\t\tif (wb) {\n\t\t\t\tao->o |= 1 << 29;\n\t\t\t}\n\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (list & 0x000000ff) << 8;\n\t\t\tao->o |= (list & 0x0000ff00) >> 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else if ((m = opmask (ao->op, \"str\", B_BIT | T_BIT | D_BIT | H_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 strsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_BRACKREGBRACK:\n\t\t\tif (ao->a[2] == NULL) { // double fallthrough\n\t\t\t\tao->a[1][strlen (ao->a[1]) -1] = '\\0';\n\t\t\t\tao->a[2] = \"0]\";\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tst32 num = getnummemend (ao->a[2]);\n\t\t\tif (m & T_BIT) {\n\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (strsel == 0) {\n\t\t\t\t\tao->o = 0x40f8000e;\n\t\t\t\t} else\n\t\t\t        if (strsel == H_BIT) {\n\t\t\t\t\tao->o = 0x20f8000e;\n\t\t\t\t} else\n\t\t\t        if (strsel == B_BIT) {\n\t\t\t\t\tao->o = 0x00f8000e;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t}\n\t\t\t\n\t\t\tif ((strsel == 0) && (reg2 == 13) && (num >= 0) && (num < 1024) && ((num % 4) == 0) && (reg1 < 8) & (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0090;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tbool t1form = false;\n\t\t\tif ((strsel == 0) && (num < 128) && (num >= 0) && (num % 4 == 0)) {\n\t\t\t\tao->o = 0x0060;\n\t\t\t\tao->o |= (num >> 4);\n\t\t\t\tao->o |= ((num >> 2) & 0x3) << 14;\n\t\t\t\tt1form = true;\n\t\t\t}\n\t\t\tif ((strsel == B_BIT) && (num < 32) && (num >= 0)) {\n\t\t\t\tao->o = 0x0070;\n\t\t\t\tao->o |= (num >> 2);\n\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\tt1form = true;\n\t\t\t}\n\t\t\tif ((strsel == H_BIT) && (num < 64) && (num >= 0) && (num % 2 == 0)) {\n\t\t\t\tao->o = 0x0080;\n\t\t\t\tao->o |= (num >> 3);\n\t\t\t\tao->o |= ((num >> 1) & 0x3) << 14;\n\t\t\t\tt1form = true;\n\t\t\t}\n\t\t\tif (t1form) {\n\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ((num > 4095) || (num < -255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((num >= 0) && (num < 4096)) {\n\t\t\t\tif (strsel == 0) {\n\t\t\t\t\tao->o = 0xc0f80000;\n\t\t\t\t} else\n\t\t\t\tif (strsel == B_BIT) {\n\t\t\t\t\tao->o = 0x80f80000;\n\t\t\t\t} else\n\t\t\t\tif (strsel == H_BIT) {\n\t\t\t\t\tao->o = 0xa0f80000;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= (num >> 8);\n\t\t\t\tao->o |= (num & 0x000000ff) << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t}\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f8000c;\n\t\t\t} else\n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f8000c;\n\t\t\t} else\n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f8000c;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= -num << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[1]);\n\t\t\tst32 num = getnum (ao->a[2]);\n\n\t\t\tif ((num > 255) || (num < -255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f80009;\n\t\t\t} else \n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f80009;\n\t\t\t} else \n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f80009;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tst32 num = getnummemendbang (ao->a[2]);\n\n\t\t\tif ((num > 255) || (num < -255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f8000d;\n\t\t\t} else \n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f8000d;\n\t\t\t} else \n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f8000d;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_REGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tut8 reg3 = getregmemend (ao->a[2]);\n\t\t\tif ((reg1 < 8) && (reg2 < 8) && (reg3 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tif (strsel == 0) {\n\t\t\t\t\tao->o = 0x0050;\n\t\t\t\t} else\n\t\t\t\tif (strsel == B_BIT) {\n\t\t\t\t\tao->o = 0x0054;\n\t\t\t\t} else\n\t\t\t\tif (strsel == H_BIT) {\n\t\t\t\t\tao->o = 0x0052;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tao->o |= (reg3 >> 2);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = getshiftmemend (ao->a[3]) >> 2;\n\t\t\t\n\t\t\tif (((shift & 0xffffcfff) != 0) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f80000;\n\t\t\t} else \n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f80000;\n\t\t\t} else \n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f80000;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (strsel != D_BIT) || (num > 1023) || (num < -1023) || ((num % 4) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40e90000;\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemendbang (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (strsel != D_BIT) || (num > 1023) || (num < -1023) || ((num % 4) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x60e90000;\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\tst32 num = getnum (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (strsel != D_BIT) || (num > 1023) || (num < -1023) || ((num % 4) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x60e80000;\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"strex\", B_BIT | D_BIT | H_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 strsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\t\n\t\t\tif ((strsel == D_BIT) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0xc0e8400f;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 4;\n\t\t\t\tao->o |= reg3 << 24;\n\t\t\t\treturn 4;\n\t\t\t} else\n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0xc0e8500f;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 4;\n\t\t\t\tao->o |= reg3 << 24;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((strsel != 0) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (num < 0) || (num > 1023) || ((num % 4) !=0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40e80000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 4;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getregmemstartend (ao->a[3]);\n\n\t\t\tif ((strsel != D_BIT) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xc0e87000;\n\t\t\tao->o |= reg1 << 8;\n\t\t\tao->o |= reg2 << 4;\n\t\t\tao->o |= reg3;\n\t\t\tao->o |= reg4 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"sub\", S_BIT | W_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((reg1 == 15) && (reg2 == 14) && (num < 256)) {\n\t\t\t\tao->o = 0xdef3008f;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tif (reg2 == 13) {\n\t\t\t\tif ((reg1 == 13) && (!(m & DOTW_BIT)) && (!(m & W_BIT)) && (num <= 4096) && (num % 4 == 0)) {\n\t\t\t\t\tao->o = 0x80b0;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\terr = false;\n\t\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\t\t\n\t\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0xadf10000;\n\t\t\t\t\tao->o |= thnum;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t\t}\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\n\t\t\t\tif (num > 4096) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0xadf20000;\n\t\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\t\tao->o |= reg1;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg1 < 8) && (reg2 < 8) && (!(m & DOTW_BIT)) && (!(m & W_BIT)) && (num < 8)) {\n\t\t\t\tao->o = 0x001e;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\tao->o |= (num >> 2);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif ((reg1 < 8) && (reg1 == reg2) && (!(m & DOTW_BIT)) && (!(m & W_BIT)) && (num < 256)) {\n\t\t\t\tao->o = 0x0038;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\terr = false;\n\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\t\n\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\tao->o = 0xa0f10000;\n\t\t\t\tao->o |= thnum;\n\t\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t\t}\n\n\t\t\tif (num > 4096) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xa0f20000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT:\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (reg2 == 13) {\n\t\t\t\tao->o = 0xadeb0000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= reg3 << 8;\n\t\t\t\tao->o |= shift;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t}\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((shift == 0) && (reg1 < 8) && (reg2 < 8) && (reg3 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x001a;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tao->o |= (reg3 >> 2);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xa0eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"svc\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\tif (num > 255) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00df;\n\t\t\tao->o |= num << 8;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sxta\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif ((shift != 0) && ((shift & 0x0000f010) != 0x00003000)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\t\t\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x40fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x20fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x00fa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sxt\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) && (reg2 > 15) && (shift != 0) && ((shift & 0x0000f010) != 0x00003000)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x40b2;\n\t\t\t\tif ((shift == 0) && std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tao->o = 0x4ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x2ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x00b2;\n\t\t\t\tif ((shift == 0) && std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tao->o = 0x0ffa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"tb\", B_BIT | H_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (B_BIT | H_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_BRACKREG_REGBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getregmemend (ao->a[1]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0xd0e800f0;\n\t\t\t\tao->o |= reg1 << 24;\n\t\t\t\tao->o |= reg2 << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tao->a[1][strlen (ao->a[1]) - 1] = '\\0';\n\t\t\tao->a[2] = \"lsl 1]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = getshiftmemend (ao->a[2]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (shift != 0x00004000) || (sufsel != H_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xd0e810f0;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"teq\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\n\t\t\tif (err || (reg > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x90f0000f;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tao->o = 0x90ea000f;\n\t\t\treturn std_32bit_2reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"tst\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\n\t\t\tif (err || (reg1 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10f0000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0042;\n\t\t\t\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tao->o = 0x10ea000f;\n\t\t\treturn std_32bit_2reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa40f0;\n\t\t\t} else\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa40f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa40f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ubfx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 lsb = getnum (ao->a[2]);\n\t\t\tut32 widthm1 = getnum (ao->a[3]) - 1;\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (lsb > 31) || ((31 - lsb) <= widthm1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xc0f30000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= (lsb & 0x1c) << 2;\n\t\t\tao->o |= (lsb & 0x3) << 14;\n\t\t\tao->o |= widthm1 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"udiv\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xb0fbf0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa60f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa60f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa60f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa60f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa60f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa60f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"umaal\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xe0fb6000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"umlal\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xe0fb0000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"umull\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xa0fb0000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa50f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa50f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa50f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa50f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa50f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa50f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usad8\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x70fb00f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usada8\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x70fb0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usat\", SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\t\tut32 num = getnum (ao->a[1]);\n\t\t\t\tut8 reg2 = getreg (ao->a[2]);\n\n\t\t\t\tif ((reg1 > 15) || (num > 15) || (reg2 > 15)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0xa0f30000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= reg2 << 24;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_CONST_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getnum (ao->a[1]);\n\t\t\tut8 reg2 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (num > 31) || (reg2 > 15) || (m & SIXTEEN_BIT) || ((shift & 0x00001000) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x80f30000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= (num & 0xf) << 8;\n\t\t\tao->o |= (num >> 4 ) << 12;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= (shift & 0x00002000) << 16;\n\t\t\tao->o |= (shift & 0x0000c070);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa40f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa40f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa40f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uxta\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (shift && ((shift & 0x0000f010) != 0x00003000)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x50fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x30fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x10fa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\treturn (std_32bit_3reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uxt\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tif ((sufsel == B_BIT) || (sufsel == H_BIT)) {\n\t\t\t\tif (sufsel == B_BIT) {\n\t\t\t\t\tao->o = 0xc0b2;\n\t\t\t\t} else {\n\t\t\t\t\tao->o = 0x80b2;\n\t\t\t\t}\n\t\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (shift && ((shift & 0x0000f010) != 0x00003000))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x5ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x3ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x1ffa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"wfe\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30280;\n\t\t\t\treturn 4;\n\t\t        } else {\n\t\t\t\tao->o = 0x20bf;\n\t\t\t\treturn 2;\n\t\t        }\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"wfi\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30380;\n\t\t\t\treturn 4;\n\t\t        } else {\n\t\t\t\tao->o = 0x30bf;\n\t\t\t\treturn 2;\n\t\t        }\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"yield\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30180;\n\t\t\t\treturn 4;\n\t\t        } else {\n\t\t\t\tao->o = 0x10bf;\n\t\t\t\treturn 2;\n\t\t        }\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int findyz(int x, int *y, int *z) {\n\tint i, j;\n\tfor (i = 0;i < 0xff; i++) {\n\t\tfor (j = 0;j < 0xf;j++) {\n\t\t\tint v = i << j;\n\t\t\tif (v > x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (v == x) {\n\t\t\t\t*y = i;\n\t\t\t\t*z = 16 - (j / 2);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int arm_assemble(ArmOpcode *ao, ut64 off, const char *str) {\n\tint i, j, ret, reg, a, b;\n\tint coproc, opc;\n\tbool rex = false;\n\tint shift, low, high;\n\tfor (i = 0; ops[i].name; i++) {\n\t\tif (!strncmp (ao->op, ops[i].name, strlen (ops[i].name))) {\n\t\t\tao->o = ops[i].code;\n\t\t\tarm_opcode_cond (ao, strlen(ops[i].name));\n\t\t\tif (ao->a[0] || ops[i].type == TYPE_BKP) {\n\t\t\t\tswitch (ops[i].type) {\n\t\t\t\tcase TYPE_MEM:\n\t\t\t\t\tif (!strncmp (ops[i].name, \"strex\", 5)) {\n\t\t\t\t\t\trex = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (ops[i].name, \"str\") || !strcmp (ops[i].name, \"ldr\")) {\n\t\t\t\t\t\tif (!ao->a[2]) {\n\t\t\t\t\t\t\tao->a[2] = \"0\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgetrange (ao->a[0]);\n\t\t\t\t\tgetrange (ao->a[1]);\n\t\t\t\t\tgetrange (ao->a[2]);\n\t\t\t\t\tif (ao->a[0] && ao->a[1]) {\n\t\t\t\t\t\tchar rn[8];\n\t\t\t\t\t\tstrncpy (rn, ao->a[1], 7);\n\t\t\t\t\t\tint r0 = getreg (ao->a[0]);\n\t\t\t\t\t\tint r1 = getreg (ao->a[1]);\n\t\t\t\t\t\tif ((r0 < 0 || r0 > 15) || (r1 > 15 || r1 < 0)) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= r0 << 20;\n\t\t\t\t\t\tif (!strcmp (ops[i].name, \"strd\")) {\n\t\t\t\t\t\t\tr1 = getreg (ao->a[2]);\n\t\t\t\t\t\t\tif (r1 == -1) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tao->o |= r1 << 8;\n\t\t\t\t\t\t\tif (ao->a[3]) {\n\t\t\t\t\t\t\t\tchar *bracket = strchr (ao->a[3], ']');\n\t\t\t\t\t\t\t\tif (bracket) {\n\t\t\t\t\t\t\t\t\t*bracket = '\\0';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint num = getnum (ao->a[3]);\n\t\t\t\t\t\t\t\tao->o |= (num & 0x0f) << 24;\n\t\t\t\t\t\t\t\tao->o |= ((num >> 4) & 0x0f) << 16;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!strcmp (ops[i].name, \"strh\")) {\n\t\t\t\t\t\t\tao->o |= r1 << 8;\n\t\t\t\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\t\t\t\t\tif (reg != -1) {\n\t\t\t\t\t\t\t\t\tao->o |= reg << 24;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tao->o |= 1 << 14;\n\t\t\t\t\t\t\t\t\tao->o |= getnum (ao->a[2]) << 24;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tao->o |= 1 << 14;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rex) {\n\t\t\t\t\t\t\tao->o |= r1 << 24;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o |= r1 << 8; // delta\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = getreg (ao->a[2]);\n\t\t\t\t\tif (ret != -1) {\n\t\t\t\t\t\tif (rex) {\n\t\t\t\t\t\t\tao->o |= 1;\n\t\t\t\t\t\t\tao->o |= (ret & 0x0f) << 8;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o |= (strstr (str, \"],\")) ? 6 : 7;\n\t\t\t\t\t\t\tao->o |= (ret & 0x0f) << 24;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ao->a[3]) {\n\t\t\t\t\t\t\tshift = getshift (ao->a[3]);\n\t\t\t\t\t\t\tlow = shift & 0xFF;\n\t\t\t\t\t\t\thigh = shift & 0xFF00;\n\t\t\t\t\t\t\tao->o |= low << 24;\n\t\t\t\t\t\t\tao->o |= high << 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint num = getnum (ao->a[2]) & 0xfff;\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rex) {\n\t\t\t\t\t\t\tao->o |= 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o |= (strstr (str, \"],\")) ? 4 : 5;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= 1;\n\t\t\t\t\t\tao->o |= (num & 0xff) << 24;\n\t\t\t\t\t\tao->o |= ((num >> 8) & 0xf) << 16;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_IMM:\n\t\t\t\t\tif (*ao->a[0]++ == '{') {\n\t\t\t\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\t\t\t\tif (ao->a[j] && *ao->a[j]) {\n\t\t\t\t\t\t\t\tgetrange (ao->a[j]); // XXX filter regname string\n\t\t\t\t\t\t\t\treg = getreg (ao->a[j]);\n\t\t\t\t\t\t\t\tif (reg != -1) {\n\t\t\t\t\t\t\t\t\tif (reg < 8) {\n\t\t\t\t\t\t\t\t\t\tao->o |= 1 << (24 + reg);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tao->o |= 1 << (8 + reg);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= getnum (ao->a[0]) << 24; // ???\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_BRA:\n\t\t\t\t\tif ((ret = getreg (ao->a[0])) == -1) {\n\t\t\t\t\t\t// TODO: control if branch out of range\n\t\t\t\t\t\tret = (getnum (ao->a[0]) - (int)ao->off - 8) / 4;\n\t\t\t\t\t\tif (ret >= 0x00800000 || ret < (int)0xff800000) {\n\t\t\t\t\t\t\teprintf (\"Branch into out of range\\n\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= ((ret >> 16) & 0xff) << 8;\n\t\t\t\t\t\tao->o |= ((ret >> 8) & 0xff) << 16;\n\t\t\t\t\t\tao->o |= ((ret)&0xff) << 24;\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"This branch does not accept reg as arg\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_BKP:\n\t\t\t\t\tao->o |= 0x70 << 24;\n\t\t\t\t\tif (ao->a[0]) {\n\t\t\t\t\t\tint n = getnum (ao->a[0]);\n\t\t\t\t\t\tao->o |= ((n & 0xf) << 24);\n\t\t\t\t\t\tao->o |= (((n >> 4) & 0xff) << 16);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_BRR:\n\t\t\t\t\tif ((ret = getreg (ao->a[0])) == -1) {\n\t\t\t\t\t\tut32 dst = getnum (ao->a[0]);\n\t\t\t\t\t\tdst -= (ao->off + 8);\n\t\t\t\t\t\tif (dst & 0x2) {\n\t\t\t\t\t\t\tao->o = 0xfb;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o = 0xfa;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdst /= 4;\n\t\t\t\t\t\tao->o |= ((dst >> 16) & 0xff) << 8;\n\t\t\t\t\t\tao->o |= ((dst >> 8) & 0xff) << 16;\n\t\t\t\t\t\tao->o |= ((dst)&0xff) << 24;\n\t\t\t\t\t\treturn 4;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= (getreg (ao->a[0]) << 24);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_HLT: {\n\t\t\t\t\tut32 o = 0, n = getnum (ao->a[0]);\n\t\t\t\t\to |= ((n >> 12) & 0xf) << 8;\n\t\t\t\t\to |= ((n >> 8) & 0xf) << 20;\n\t\t\t\t\to |= ((n >> 4) & 0xf) << 16;\n\t\t\t\t\to |= ((n) & 0xf) << 24;\n\t\t\t\t\tao->o |=o;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SWI:\n\t\t\t\tao->o |= (getnum (ao->a[0]) & 0xff) << 24;\n\t\t\t\tao->o |= ((getnum (ao->a[0]) >> 8) & 0xff) << 16;\n\t\t\t\tao->o |= ((getnum (ao->a[0]) >> 16) & 0xff) << 8;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UDF:\n\t\t\t\t{\n\t\t\t\t\t// e7f000f0 = udf 0\n\t\t\t\t\t// e7ffffff = udf 0xffff\n\t\t\t\t\tut32 n = getnum (ao->a[0]);\n\t\t\t\t\tao->o |= 0xe7;\n\t\t\t\t\tao->o |= (n & 0xf) << 24;\n\t\t\t\t\tao->o |= ((n >> 4) & 0xff) << 16;\n\t\t\t\t\tao->o |= ((n >> 12) & 0xf) << 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_ARI:\n\t\t\t\tif (!ao->a[2]) {\n\t\t\t\t\tao->a[2] = ao->a[1];\n\t\t\t\t\tao->a[1] = ao->a[0];\n\t\t\t\t}\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 8;\n\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\tao->o |= (reg != -1)? reg << 24 : 2 | getnum (ao->a[2]) << 24;\n\t\t\t\tif (ao->a[3]) {\n\t\t\t\t\tao->o |= getshift (ao->a[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SWP:\n\t\t\t\t{\n\t\t\t\tint a1 = getreg (ao->a[1]);\n\t\t\t\tif (a1) {\n\t\t\t\t\tao->o = 0xe1;\n\t\t\t\t\tao->o |= (getreg (ao->a[0]) << 4) << 16;\n\t\t\t\t\tao->o |= (0x90 + a1) << 24;\n\t\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\t\tao->o |= (getreg (ao->a[2] + 1)) << 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (0xff == ((ao->o >> 16) & 0xff)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MOV:\n\t\t\t\tif (!strcmpnull (ao->op, \"movs\")) {\n\t\t\t\t\tao->o = 0xb0e1;\n\t\t\t\t}\n\t\t\t\tao->o |= getreg (ao->a[0]) << 20;\n\t\t\t\tret = getreg (ao->a[1]);\n\t\t\t\tif (ret != -1) {\n\t\t\t\t\tao->o |= ret << 24;\n\t\t\t\t} else {\n\t\t\t\t\tint immed = getimmed8 (ao->a[1]);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= 0xa003 | (immed & 0xff) << 24 | (immed >> 8) << 16;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MOVW:\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= getreg (ao->a[0]) << 20;\n\t\t\t\tret = getnum (ao->a[1]);\n\n\t\t\t\tao->o |= 0x3 | ret << 24;\n\t\t\t\tao->o |= (ret & 0xf000) >> 4;\n\t\t\t\tao->o |= (ret & 0xf00) << 8;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MOVT:\n\t\t\t\tao->o |= getreg (ao->a[0]) << 20;\n\t\t\t\tret = getnum (ao->a[1]);\n\n\t\t\t\tao->o |= 0x4003 | ret << 24;\n\t\t\t\tao->o |= (ret & 0xf000) >> 4;\n\t\t\t\tao->o |= (ret & 0xf00) << 8;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MUL:\n\t\t\t\tif (!strcmpnull (ao->op, \"mul\")) {\n\t\t\t\t\tret = getreg (ao->a[0]);\n\t\t\t\t\ta = getreg (ao->a[1]);\n\t\t\t\t\tb = getreg (ao->a[2]);\n\t\t\t\t\tif (b == -1) {\n\t\t\t\t\t\tb = a;\n\t\t\t\t\t\ta = ret;\n\t\t\t\t\t}\n\t\t\t\t\tif (ret == -1 || a == -1) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= ret << 8;\n\t\t\t\t\tao->o |= a << 24;\n\t\t\t\t\tao->o |= b << 16;\n\t\t\t\t} else {\n\t\t\t\t\tlow = getreg (ao->a[0]);\n\t\t\t\t\thigh = getreg (ao->a[1]);\n\t\t\t\t\ta = getreg (ao->a[2]);\n\t\t\t\t\tb = getreg (ao->a[3]);\n\t\t\t\t\tif (low == -1 || high == -1 || a == -1 || b == -1) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmpnull (ao->op, \"smlal\")) {\n\t\t\t\t\t\tao->o |= low << 20;\n\t\t\t\t\t\tao->o |= high << 8;\n\t\t\t\t\t\tao->o |= a << 24;\n\t\t\t\t\t\tao->o |= b << 16;\n\t\t\t\t\t} else if (!strncmp (ao->op, \"smla\", 4)) {\n\t\t\t\t\t\tif (low > 14 || high > 14 || a > 14) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= low << 8;\n\t\t\t\t\t\tao->o |= high << 24;\n\t\t\t\t\t\tao->o |= a << 16;\n\t\t\t\t\t\tao->o |= b << 20;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= low << 20;\n\t\t\t\t\t\tao->o |= high << 8;\n\t\t\t\t\t\tao->o |= a << 24;\n\t\t\t\t\t\tao->o |= b << 16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_TST:\n\t\t\t\ta = getreg (ao->a[0]);\n\t\t\t\tb = getreg (ao->a[1]);\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tint y, z;\n\t\t\t\t\tb = getnum (ao->a[1]);\n\t\t\t\t\tif (b >= 0 && b <= 0xff) {\n\t\t\t\t\t\tao->o = 0x50e3;\n\t\t\t\t\t\t// TODO: if (b>255) -> automatic multiplier\n\t\t\t\t\t\tao->o |= (a << 8);\n\t\t\t\t\t\tao->o |= ((b & 0xff) << 24);\n\t\t\t\t\t} else\n\t\t\t\t\tif (findyz (b, &y, &z)) {\n\t\t\t\t\t\tao->o = 0x50e3;\n\t\t\t\t\t\tao->o |= (y << 24);\n\t\t\t\t\t\tao->o |= (z << 16);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Parameter %d out0x3000a0e1 of range (0-255)\\n\", (int)b);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tao->o |= (a << 8);\n\t\t\t\t\tao->o |= (b << 24);\n\t\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\t\tao->o |= getshift (ao->a[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\tint n = getnum (ao->a[2]);\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\teprintf (\"Invalid multiplier\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= (n >> 1) << 16;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SHFT:\n\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 16;\n\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 24;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_REV:\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 24;\n\n\t\t\t\tbreak;\n\t\t\tcase TYPE_ENDIAN:\n\t\t\t\tif (!strcmp (ao->a[0], \"le\")) {\n\t\t\t\t\tao->o |= 0;\n\t\t\t\t} else if (!strcmp (ao->a[0], \"be\")) {\n\t\t\t\t\tao->o |= 0x20000;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_COPROC:\n\t\t\t\t//printf (\"%s %s %s %s %s\\n\", ao->a[0], ao->a[1], ao->a[2], ao->a[3], ao->a[4] );\n\t\t\t\tif (ao->a[0]) {\n\t\t\t\t\tcoproc = getnum (ao->a[0] + 1);\n\t\t\t\t\tif (coproc == -1 || coproc > 9) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= coproc << 16;\n\t\t\t\t}\n\n\t\t\t\topc = getnum (ao->a[1]);\n\t\t\t\tif (opc == -1 || opc > 7) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= opc << 13;\n\n\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\t// coproc register 1\n\t\t\t\tconst char *a3 = ao->a[3];\n\t\t\t\tif (a3) {\n\t\t\t\t\tcoproc = getnum (a3 + 1);\n\t\t\t\t\tif (coproc == -1 || coproc > 15) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= coproc << 8;\n\t\t\t\t}\n\n\t\t\t\tconst char *a4 = ao->a[4];\n\t\t\t\tif (a4) {\n\t\t\t\t\tcoproc = getnum (ao->a[4] + 1);\n\t\t\t\t\tif (coproc == -1 || coproc > 15) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= coproc << 24;\n\t\t\t\t}\n\n\t\t\t\tcoproc = getnum (ao->a[5]);\n\t\t\t\tif (coproc > -1) {\n\t\t\t\t\tif (coproc > 7) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// optional opcode\n\t\t\t\t\tao->o |= coproc << 29;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CLZ:\n\t\t\t\tao->o |= 1 << 28;\n\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 24;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\ntypedef int (*AssembleFunction)(ArmOpcode *, ut64, const char *);\nstatic AssembleFunction assemble[2] = { &arm_assemble, &thumb_assemble };\n\nut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\t//eprintf (\"armass: Unknown opcode (%s)\\n\", buf);\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}\n\n#ifdef MAIN\nvoid thisplay(const char *str) {\n\tchar cmd[32];\n\tint op = armass_assemble (str, 0x1000, 1);\n\tprintf (\"[%04x] %s\\n\", op, str);\n\tsnprintf (cmd, sizeof(cmd), \"rasm2 -d -b 16 -a arm %04x\", op);\n\tsystem (cmd);\n}\n\nvoid display(const char *str) {\n\tchar cmd[32];\n\tint op = armass_assemble (str, 0x1000, 0);\n\tprintf (\"[%08x] %s\\n\", op, str);\n\tsnprintf (cmd, sizeof(cmd), \"rasm2 -d -a arm %08x\", op);\n\tsystem (cmd);\n}\n\nint main() {\n\tthisplay (\"ldmia r1!, {r3, r4, r5}\");\n\tthisplay (\"stmia r1!, {r3, r4, r5}\");\n\tthisplay (\"bkpt 12\");\nreturn 0;\n\tthisplay(\"sub r1, r2, 0\");\n\tthisplay(\"sub r1, r2, 4\");\n\tthisplay(\"sub r1, r2, 5\");\n\tthisplay(\"sub r1, r2, 7\");\n\tthisplay(\"sub r3, 44\");\nreturn 0;\n#if 0\n\tthisplay(\"mov r0, 11\");\n\tthisplay(\"mov r0, r2\");\n\tthisplay(\"mov r1, r4\");\n\tthisplay(\"cmp r1, r2\");\n\tthisplay(\"cmp r3, 44\");\n\tthisplay(\"nop\");\n\tthisplay(\"svc 15\");\n\tthisplay(\"add r1, r2\");\n\tthisplay(\"add r3, 44\");\n\tthisplay(\"sub r1, r2, 3\");\n\tthisplay(\"sub r3, 44\");\n\tthisplay(\"tst r3,r4\");\n\tthisplay(\"bx r3\");\n\tthisplay(\"b 33\");\n\tthisplay(\"b 0\");\n\tthisplay(\"bne 44\");\n\tthisplay(\"and r2,r3\");\n#endif\n\t// INVALID thisplay(\"ldr r1, [pc, r2]\");\n\t// INVALID thisplay(\"ldr r1, [sp, r2]\");\n#if 0\n\tthisplay(\"ldr r1, [pc, 12]\");\n\tthisplay(\"ldr r1, [sp, 24]\");\n\tthisplay(\"ldr r1, [r2, r3]\");\n#endif\n\t// INVALID thisplay(\"str r1, [pc, 22]\");\n\t// INVALID thisplay(\"str r1, [pc, r2]\");\n\t// INVALID thisplay(\"str r1, [sp, r2]\");\n#if 0\n   0:   8991            ldrh    r1, [r2, #12]\n   2:   7b11            ldrb    r1, [r2, #12]\n   4:   8191            strh    r1, [r2, #12]\n   6:   7311            strb    r1, [r2, #12]\n#endif\n\tthisplay(\"ldrh r1, [r2, 8]\"); // aligned to 4\n\tthisplay(\"ldrh r1, [r3, 8]\"); // aligned to 4\n\tthisplay(\"ldrh r1, [r4, 16]\"); // aligned to 4\n\tthisplay(\"ldrh r1, [r2, 32]\"); // aligned to 4\n\tthisplay(\"ldrb r1, [r2, 20]\"); // aligned to 4\n\tthisplay(\"strh r1, [r2, 20]\"); // aligned to 4\n\tthisplay(\"strb r1, [r2, 20]\"); // aligned to 4\n\tthisplay(\"str r1, [sp, 20]\"); // aligned to 4\n\tthisplay(\"str r1, [r2, 12]\"); // OK\n\tthisplay(\"str r1, [r2, r3]\");\nreturn 0;\n#if 0\n\tdisplay(\"mov r0, 33\");\n\tdisplay(\"mov r1, 33\");\n\tdisplay(\"movne r0, 33\");\n\tdisplay(\"tst r0, r1, lsl #2\");\n\tdisplay(\"svc 0x80\");\n\tdisplay(\"sub r3, r1, r2\");\n\tdisplay(\"add r0, r1, r2\");\n\tdisplay(\"mov fp, 0\");\n\tdisplay(\"pop {pc}\");\n\tdisplay(\"pop {r3}\");\n\tdisplay(\"bx r1\");\n\tdisplay(\"bx r3\");\n\tdisplay(\"bx pc\");\n\tdisplay(\"blx fp\");\n\tdisplay(\"pop {pc}\");\n\tdisplay(\"add lr, pc, lr\");\n\tdisplay(\"adds r3, #8\");\n\tdisplay(\"adds r3, r2, #8\");\n\tdisplay(\"subs r2, #1\");\n\tdisplay(\"cmp r0, r4\");\n\tdisplay(\"cmp r7, pc\");\n\tdisplay(\"cmp r1, r3\");\n\tdisplay(\"mov pc, 44\");\n\tdisplay(\"mov pc, r3\");\n\tdisplay(\"push {pc}\");\n\tdisplay(\"pop {pc}\");\n\tdisplay(\"nop\");\n\tdisplay(\"ldr r1, [r2, 33]\");\n\tdisplay(\"ldr r1, [r2, r3]\");\n\tdisplay(\"ldr r3, [r4, r6]\");\n\tdisplay(\"str r1, [pc, 33]\");\n\tdisplay(\"str r1, [pc], 2\");\n\tdisplay(\"str r1, [pc, 3]\");\n\tdisplay(\"str r1, [pc, r4]\");\n\tdisplay(\"bx r3\");\n\tdisplay(\"bcc 33\");\n\tdisplay(\"blx r3\");\n\tdisplay(\"bne 0x1200\");\n\tdisplay(\"str r0, [r1]\");\n\tdisplay(\"push {fp,lr}\");\n\tdisplay(\"pop {fp,lr}\");\n\tdisplay(\"pop {pc}\");\n#endif\n\n   //10ab4:       00047e30        andeq   r7, r4, r0, lsr lr\n   //10ab8:       00036e70        andeq   r6, r3, r0, ror lr\n\n\tdisplay(\"andeq r7, r4, r0, lsr lr\");\n\tdisplay(\"andeq r6, r3, r0, ror lr\");\n//  c4:   e8bd80f0        pop     {r4, r5, r6, r7, pc}\n\tdisplay(\"pop {r4,r5,r6,r7,pc}\");\n\n\n#if 0\n\tdisplay(\"blx r1\");\n\tdisplay(\"blx 0x8048\");\n#endif\n\n#if 0\n\tdisplay(\"b 0x123\");\n\tdisplay(\"bl 0x123\");\n\tdisplay(\"blt 0x123\"); // XXX: not supported\n#endif\n\treturn 0;\n}\n#endif\n", "/* radare - LGPL - Copyright 2015-2018 - pancake */\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <r_util.h>\n\ntypedef enum optype_t {\n\tARM_NOTYPE = -1,\n\tARM_GPR = 1,\n\tARM_CONSTANT = 2,\n\tARM_FP = 4,\n\tARM_MEM_OPT = 8\n} OpType;\n\ntypedef enum regtype_t {\n\tARM_UNDEFINED = -1,\n\tARM_REG64 = 1,\n\tARM_REG32 = 2,\n\tARM_SP = 4,\n\tARM_PC = 8,\n\tARM_SIMD = 16\n} RegType;\n\ntypedef enum shifttype_t {\n\tARM_NO_SHIFT = -1,\n\tARM_LSL = 0,\n\tARM_LSR = 1,\n\tARM_ASR = 2\n} ShiftType;\n\ntypedef struct operand_t {\n\tOpType type;\n\tunion {\n\t\tstruct {\n\t\t\tint reg;\n\t\t\tRegType reg_type;\n\t\t\tut16 sp_val;\n\t\t};\n\t\tstruct {\n\t\t\tut64 immediate;\n\t\t\tint sign;\n\t\t};\n\t\tstruct {\n\t\t\tut64 shift_amount;\n\t\t\tShiftType shift;\n\t\t};\n\t\tstruct {\n\t\t\tut32 mem_option;\n\t\t};\n\t};\n} Operand;\n\n#define MAX_OPERANDS 7\n\ntypedef struct Opcode_t {\n\tchar *mnemonic;\n\tut32 op[3];\n\tsize_t op_len;\n\tut8 opcode[3];\n\tint operands_count;\n\tOperand operands[MAX_OPERANDS];\n} ArmOp;\n\nstatic int get_mem_option(char *token) {\n\t// values 4, 8, 12, are unused. XXX to adjust\n\tconst char *options[] = {\"sy\", \"st\", \"ld\", \"xxx\", \"ish\", \"ishst\",\n\t                         \"ishld\", \"xxx\", \"nsh\", \"nshst\", \"nshld\",\n\t                         \"xxx\", \"osh\", \"oshst\", \"oshld\", NULL};\n\tint i = 0;\n\twhile (options[i]) {\n\t\tif (!r_str_casecmp (token, options[i])) {\n\t\t\treturn 15 - i;\n\t\t}\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nstatic int countLeadingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x) {\n\t\tx >>= 1;\n\t\t--count;\n\t}\n\treturn count;\n}\n\nstatic int countTrailingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x > 0) {\n\t\tif ((x & 1) == 1) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tcount ++;\n\t\t\tx = x >> 1;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic int calcNegOffset(int n, int shift) {\n\tint a = n >> shift;\n\tif (a == 0) {\n\t\treturn 0xff;\n\t}\n\t// find first set bit then invert it and all\n\t// bits below it\n\tint t = 0x400;\n\twhile (!(t & a) && a != 0 && t != 0) {\n\t\tt = t >> 1;\n\t}\n\tt = t & (t - 1);\n\ta = a ^ t;\n\t// If bits below 32 are set\n\tif (countTrailingZeros(n) > shift) {\n\t\ta--;\n\t}\n\treturn 0xff & (0xff - a);\n}\n\nstatic int countLeadingOnes(ut32 x) {\n\treturn countLeadingZeros (~x);\n}\n\nstatic int countTrailingOnes(ut32 x) {\n\treturn countTrailingZeros (~x);\n}\n\nstatic bool isMask(ut32 value) {\n  return value && ((value + 1) & value) == 0;\n}\n\nstatic bool isShiftedMask (ut32 value) {\n  return value && isMask ((value - 1) | value);\n}\n\nstatic ut32 decodeBitMasks(ut32 imm) {\n\t// get element size\n\tint size = 32;\n\t// determine rot to make element be 0^m 1^n\n\tut32 cto, i;\n\tut32 mask = ((ut64) - 1LL) >> (64 - size);\n\n\tif (isShiftedMask (imm)) {\n\t\ti = countTrailingZeros (imm);\n\t\tcto = countTrailingOnes (imm >> i);\n\t} else {\n\t\timm |= ~mask;\n\t\tif (!isShiftedMask (imm)) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tut32 clo = countLeadingOnes (imm);\n\t\ti = 64 - clo;\n\t\tcto = clo + countTrailingOnes (imm) - (64 - size);\n\t}\n\n\t// Encode in Immr the number of RORs it would take to get *from* 0^m 1^n\n\t// to our target value, where I is the number of RORs to go the opposite\n\t// direction\n\tut32 immr = (size - i) & (size - 1);\n\t// If size has a 1 in the n'th bit, create a value that has zeroes in\n\t// bits [0, n] and ones above that.\n\tut64 nimms = ~(size - 1) << 1;\n\t// Or the cto value into the low bits, which must be below the Nth bit\n\t// bit mentioned above.\n\tnimms |= (cto - 1);\n\t// Extract and toggle seventh bit to make N field.\n\tut32 n = ((nimms >> 6) & 1) ^ 1;\n\tut64 encoding = (n << 12) | (immr << 6) | (nimms & 0x3f);\n\treturn encoding;\n}\n\nstatic ut32 mov(ArmOp *op) {\n\tint k = 0;\n\tut32 data = UT32_MAX;\n\tif (!strncmp (op->mnemonic, \"movz\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80d2;\n\t\t} else if (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8052;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movk\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8072;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80f2;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movn\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8012;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x8092;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"mov\", 3)) {\n\t\t//printf (\"%d - %d [%d]\\n\", op->operands[0].type, op->operands[1].type, ARM_GPR);\n\t\tif (op->operands[0].type & ARM_GPR) {\n\t\t\tif (op->operands[1].type & ARM_GPR) {\n\t\t\t\tif (op->operands[1].reg_type & ARM_REG64) {\n\t\t\t\t\tk = 0xe00300aa;\n\t\t\t\t} else {\n\t\t\t\t\tk = 0xe003002a;\n\t\t\t\t}\n\t\t\t\tdata = k | op->operands[1].reg << 8;\n\t\t\t} else if (op->operands[1].type & ARM_CONSTANT) {\n\t\t\t\tk = 0x80d2;\n\t\t\t\tdata = k | op->operands[1].immediate << 29;\n\t\t\t}\n\t\t\tdata |=  op->operands[0].reg << 24;\n\t\t}\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata |= (op->operands[0].reg << 24); // arg(0)\n\tdata |= ((op->operands[1].immediate & 7) << 29); // arg(1)\n\tdata |= (((op->operands[1].immediate >> 3) & 0xff) << 16); // arg(1)\n\tdata |= ((op->operands[1].immediate >> 10) << 7); // arg(1)\n\treturn data;\n}\n\nstatic ut32 cmp(ArmOp *op) {\n\tut32 data = UT32_MAX;\n\tint k = 0;\n\tif (op->operands[0].reg_type & ARM_REG64 && op->operands[1].reg_type & ARM_REG64) {\n\t\tk =  0x1f0000eb;\n\t} else if (op->operands[0].reg_type & ARM_REG32 && op->operands[1].reg_type & ARM_REG32) {\n\t\tif (op->operands[2].shift_amount > 31) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t\tk =  0x1f00006b;\n\t} else {\n\t\treturn UT32_MAX;\n\t}\n\n\tdata = k | (op->operands[0].reg & 0x18) << 13 | op->operands[0].reg << 29 | op->operands[1].reg << 8;\n\n\tif (op->operands[2].shift != ARM_NO_SHIFT) {\n\t\tdata |= op->operands[2].shift_amount << 18 | op->operands[2].shift << 14;\n\t}\n\treturn data;\n}\n\n\nstatic ut32 regsluop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xff || n < -0x100) {\n\t\treturn data;\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tif (n < 0) {\n\t\tn *= -1;\n\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\n\t\tif (countTrailingZeros(n) > 3) {\n\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t} else {\n\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t}\n\t} else {\n\t\tdata |= (0xf & (n & 63)) << 20;\n\t\tif (countTrailingZeros(n) < 4) {\n\t\t\tdata |= (n >> 4) << 8;\n\t\t} else {\n\t\t\tdata |= (0xff & n) << 4;\n\t\t}\n\t\tdata |= (n >> 8) << 8;\n\t}\n\n\treturn data;\n}\n\n// Register Load/store ops\nstatic ut32 reglsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t} else {\n\t\tint n = op->operands[2].immediate;\n\t\tif (n > 0x100 || n < -0x100) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tif (n == 0 || (n > 0 && countTrailingZeros(n) >= 4)) {\n\t\t\tk ++;\n\t\t}\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\t\t\tif (countTrailingZeros(n) > 3) {\n\t\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t\t}\n\t\t} else {\n\t\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\t\tif (countTrailingZeros(n) < 2) {\n\t\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\t\tdata++;\n\t\t\t\t\t\tdata |= (0xff & n) << 16;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\tif (countTrailingZeros(n) < 4) {\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\tdata |= (0xff & n) << 15;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 23;\n\t\t\t}\n\t\t}\n\t}\n\treturn data;\n}\n\n// Byte load/store ops\nstatic ut32 bytelsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\treturn data;\n\t}\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tif ((k & 0xf) != 8) {\n\t\t\tk--;\n\t\t}\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xfff || n < -0x100) {\n\t\treturn UT32_MAX;\n\t}\n\t// Half ops\n\tint halfop = false;\n\tif ((k & 0xf) == 8) {\n\t\thalfop = true;\n\t\tif (n == 0 || (countTrailingZeros(n) && n > 0)) {\n\t\t\tk++;\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tk--;\n\t\t}\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tint imm = n;\n\tint low_shift = 20;\n\tint high_shift = 8;\n\tint top_shift = 10;\n\tif (n < 0) {\n\t\timm = 0xfff + (n + 1);\n\t}\n\tif (halfop) {\n\t\tif (imm & 0x1 || n < 0) {\n\t\t\tdata |= (0xf & imm) << low_shift ;\n\t\t\tdata |= (0x7 & (imm >> 4)) << high_shift;\n\t\t\tdata |= (0x7 & (imm >> 6)) << top_shift;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << (low_shift - 3);\n\t\t\tdata |= (0x7 & (imm >> 4)) << (high_shift + 13);\n\t\t\tdata |= (0x7 & (imm >> 7)) << (top_shift  - 2);\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tdata |= (0xf & imm) << 20;\n\t\t\tdata |= (0x1f & (imm >> 4)) << 8;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << 18;\n\t\t\tdata |= (0x3 & (imm >> 4)) << 22;\n\t\t\tdata |= (0x7 & (imm >> 6)) << 8;\n\t\t}\n\t}\n\treturn data;\n}\n\nstatic ut32 branch(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tif (op->operands[0].type & ARM_CONSTANT) {\n\t\tn = op->operands[0].immediate;\n\t\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\t\tn -= addr;\n\t\t\tn = n >> 2;\n\t\t\tint t = n >> 24;\n\t\t\tint h = n >> 16;\n\t\t\tint m = (n & 0xff00) >> 8;\n\t\t\tn &= 0xff;\n\t\t\tdata = k;\n\t\t\tdata |= n << 24;\n\t\t\tdata |= m << 16;\n\t\t\tdata |= h << 8;\n\t\t\tdata |= t;\n\t\t}\n\t} else {\n\t\tn = op->operands[0].reg;\n\t\tif (n < 0 || n > 31) {\n\t\t\treturn -1;\n\t\t}\n\t\tn = n << 5;\n\t\tint h = n >> 8;\n\t\tn &= 0xff;\n\t\tdata = k;\n\t\tdata |= n << 24;\n\t\tdata |= h << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 bdot(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tint a = 0;\n\tn = op->operands[0].immediate;\n\t// I am sure there's a logical way to do negative offsets,\n\t// but I was unable to find any sensible docs so I did my best\n\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\tn -= addr;\n\t\tdata = k;\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\ta = (n << 3) - 1;\n\t\t\tdata |= (0xff - a) << 24;\n\n\t\t\ta = calcNegOffset(n, 5);\n\t\t\tdata |= a << 16;\n\n\t\t\ta = calcNegOffset(n, 13);\n\t\t\tdata |= a << 8;\n\t\t} else {\n\t\t\tdata |= (n & 31) << 27;\n\t\t\tdata |= (0xff & (n >> 5)) << 16;\n\t\t\tdata |= (0xff & (n >> 13)) << 8;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nstatic ut32 mem_barrier (ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tdata = k;\n\tif (!strncmp (op->mnemonic, \"isb\", 3)) {\n\t\tif (op->operands[0].mem_option == 15 || op->operands[0].type == ARM_NOTYPE) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t}\n\tif (op->operands[0].type == ARM_MEM_OPT) {\n\t\tdata |= op->operands[0].mem_option << 16;\n\t} else if (op->operands_count == 1 && op->operands[0].type == ARM_CONSTANT) {\n\t\tdata |= (op->operands[0].immediate << 16);\n\t}\n\treturn data;\n}\n\n#include \"armass64_const.h\"\n\nstatic ut32 msrk(ut16 v) {\n\tut32 r = 0;\n\tut32 a = ((v >> 12) & 0xf) << 1;\n\tut32 b = ((v & 0xfff) >> 3) & 0xff;\n\tr |= a << 8;\n\tr |= b << 16;\n\treturn r;\n}\n\nstatic ut32 msr(ArmOp *op, int w) {\n\tut32 data = UT32_MAX;\n\tint i;\n\tut32 r, b;\n\t/* handle swapped args */\n\tif (w) {\n\t\tif (op->operands[1].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[1].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[1].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[1].reg = op->operands[1].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t} else {\n\t\tif (op->operands[0].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[0].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[0].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[0].reg = op->operands[0].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t}\n\tdata = (r << 24) | b | 0xd5;\n\tif (w) {\n\t\t/* mrs */\n\t\tdata |= 0x413000;\n\t}\n\tif (op->operands[1].reg_type == ARM_REG64) {\n\t\tdata |= op->operands[1].reg << 24;\n\t}\n\n\treturn data;\n}\n\nstatic ut32 orr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[2].type & ARM_GPR) {\n\t\t// All operands need to be the same\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type &&\n\t \t    op->operands[1].reg_type == op->operands[2].reg_type)) {\n\t\t \t   return data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000000aa;\n\t\t} else {\n\t\t\tdata = 0x0000002a;\n\t\t}\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\t\tdata += op->operands[2].reg << 8;\n\t} else if (op->operands[2].type & ARM_CONSTANT) {\n\t\t// Reg types need to match\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type)) {\n\t\t\treturn data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000040b2;\n\t\t} else {\n\t\t\tdata = 0x00000032;\n\t\t}\n\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\n\t\tut32 imm = decodeBitMasks (op->operands[2].immediate);\n\t\tif (imm == -1) {\n\t\t\treturn imm;\n\t\t}\n\t\tint low = imm & 0xF;\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\timm = ((imm >> 6) | 0x78);\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 8;\n\t\t\t}\n\t\t} else {\n\t\t\timm = ((imm >> 2));\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 4;\n\t\t\t}\n\t\t}\n\t\tdata |= (4 * low) << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 adrp(ArmOp *op, ut64 addr, ut32 k) { //, int reg, ut64 dst) {\n\tut64 at = 0LL;\n\tut32 data = k;\n\tif (op->operands[0].type == ARM_GPR) {\n\t\tdata += ((op->operands[0].reg & 0xff) << 24);\n\t} else {\n\t\teprintf (\"Usage: adrp x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t} else {\n\t\teprintf (\"Usage: adrp, x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\n#if 0\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n#endif\n\tdata += b0 << 16;\n\tdata += b1 << 8;\n\treturn data;\n}\n\nstatic ut32 adr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\tut64 at = 0LL;\n\n\tif (op->operands[1].type & ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t}\n\tdata = 0x00000030;\n\tdata += 0x01000000 * op->operands[0].reg;\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n\treturn data;\n}\n\nstatic ut32 stp(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[3].immediate & 0x7) {\n\t\treturn data;\n\t}\n\tif (k == 0x000040a9 && (op->operands[0].reg == op->operands[1].reg)) {\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += op->operands[1].reg << 18;\n\tdata += (op->operands[2].reg & 0x7) << 29;\n\tdata += (op->operands[2].reg >> 3) << 16;\n\tdata += (op->operands[3].immediate & 0x8) << 20;\n\tdata += (op->operands[3].immediate >> 4) << 8;\n\treturn data;\n}\n\nstatic ut32 exception(ArmOp *op, ut32 k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\tint n = op->operands[0].immediate;\n\t\tdata = k;\n\t\tdata += (((n / 8) & 0xff) << 16);\n\t\tdata += n << 29;//((n >> 8) << 8);\n\t}\n\treturn data;\n}\n\nstatic ut32 arithmetic (ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\tif (op->operands_count < 3) {\n\t\treturn data;\n\t}\n\n\tif (!(op->operands[0].type & ARM_GPR &&\n\t      op->operands[1].type & ARM_GPR)) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk -= 6;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += (op->operands[1].reg & 7) << (24 + 5);\n\tdata += (op->operands[1].reg >> 3) << 16;\n\tif (op->operands[2].reg_type & ARM_REG64) {\n\t\tdata += op->operands[2].reg << 8;\n\t} else {\n\t\tdata += (op->operands[2].reg & 0x3f) << 18;\n\t\tdata += (op->operands[2].reg >> 6) << 8;\n\t}\n\treturn data;\n}\n\nstatic bool parseOperands(char* str, ArmOp *op) {\n\tchar *t = strdup (str);\n\tint operand = 0;\n\tchar *token = t;\n\tchar *x;\n\tint imm_count = 0;\n\tint mem_opt = 0;\n\tif (!token) {\n\t\treturn false;\n\t}\n\n\twhile (token) {\n\t\tchar *next = strchr (token, ',');\n\t\tif (next) {\n\t\t\t*next++ = 0;\n\t\t}\n\t\twhile (token[0] == ' ') {\n\t\t\ttoken++;\n\t\t}\n\t\tif (operand >= MAX_OPERANDS) {\n\t\t\teprintf (\"Too many operands\\n\");\n\t\t\treturn false;\n\t\t}\n\t\top->operands[operand].type = ARM_NOTYPE;\n\t\top->operands[operand].reg_type = ARM_UNDEFINED;\n\t\top->operands[operand].shift = ARM_NO_SHIFT;\n\n\t\twhile (token[0] == ' ' || token[0] == '[' || token[0] == ']') {\n\t\t\ttoken ++;\n\t\t}\n\n\t\tif (!strncmp (token, \"lsl\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSL;\n\t\t} else if (!strncmp (token, \"lsr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSR;\n\t\t} else if (!strncmp (token, \"asr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_ASR;\n\t\t}\n\t\tif (op->operands[operand].shift != ARM_NO_SHIFT) {\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].shift_amount = r_num_math (NULL, token + 4);\n\t\t\tif (op->operands[operand].shift_amount > 63) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\toperand ++;\n\t\t\ttoken = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (token[0]) {\n\t\tcase 'x':\n\t\t\tx = strchr (token, ',');\n\t\t\tif (x) {\n\t\t\t\tx[0] = '\\0';\n\t\t\t}\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG64;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG32;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_FP;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tif (token[1] == 'P' || token [1] == 'p') {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {\n\t\t\t\t\t\top->operands[operand].sp_val = msr_const[i].val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\t\top->operands[operand].reg_type = ARM_SP | ARM_REG64;\n\t\t\t\top->operands[operand].reg = 31;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\tcase 'l':\n\t\tcase 'I':\n\t\tcase 'i':\n\t\tcase 'N':\n\t\tcase 'n':\n\t\tcase 'O':\n\t\tcase 'o':\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\top->operands[operand].sign = -1;\n\t\t\t// falthru\n\t\tdefault:\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_CONSTANT;\n\t\t\top->operands[operand].immediate = r_num_math (NULL, token);\n\t\t\timm_count++;\n\t\t\tbreak;\n\t\t}\n\t\ttoken = next;\n\n\t\toperand ++;\n\t\tif (operand > MAX_OPERANDS) {\n\t\t\tfree (t);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic bool parseOpcode(const char *str, ArmOp *op) {\n\tchar *in = strdup (str);\n\tchar *space = strchr (in, ' ');\n\tif (!space) {\n\t\top->operands[0].type = ARM_NOTYPE;\n\t\top->mnemonic = in;\n \t\treturn true;\n\t}\n\tspace[0] = '\\0';\n\top->mnemonic = in;\n\tspace ++;\n\treturn parseOperands (space, op);\n}\n\nbool arm64ass(const char *str, ut64 addr, ut32 *op) {\n\tArmOp ops = {0};\n\tif (!parseOpcode (str, &ops)) {\n\t\treturn false;\n\t}\n\t/* TODO: write tests for this and move out the regsize logic into the mov */\n\tif (!strncmp (str, \"mov\", 3)) {\n\t\t*op = mov (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"cmp\", 3)) {\n\t\t*op = cmp (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsh\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsw\", 5)) {\n\t\t*op = bytelsop (&ops, 0x000080b8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsb\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldr\", 3)) {\n\t\t*op = reglsop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"str\", 3)) {\n\t\t*op = reglsop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stp\", 3)) {\n\t\t*op = stp (&ops, 0x000000a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldp\", 3)) {\n\t\t*op = stp (&ops, 0x000040a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"sub\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0xd1);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"add\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0x91);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adr x\", 5)) { // w\n\t\t*op = adr (&ops, addr);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adrp x\", 6)) {\n\t\t*op = adrp (&ops, addr, 0x00000090);\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"isb\")) {\n\t\t*op = 0xdf3f03d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"nop\")) {\n\t\t*op = 0x1f2003d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"ret\")) {\n\t\t*op = 0xc0035fd6;\n\t\treturn true;\n\t}\n\tif (!strncmp (str, \"msr \", 4)) {\n\t\t*op = msr (&ops, 0);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"mrs \", 4)) {\n\t\t*op = msr (&ops, 1);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"orr \", 4)) {\n\t\t*op = orr (&ops, addr);\n\t\treturn *op != UT32_MAX;\n\t}\n\tif (!strncmp (str, \"svc \", 4)) { // system level exception\n\t\t*op = exception (&ops, 0x010000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hvc \", 4)) { // hypervisor level exception\n\t\t*op = exception (&ops, 0x020000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"smc \", 4)) { // secure monitor exception\n\t\t*op = exception (&ops, 0x030000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"brk \", 4)) { // breakpoint\n\t\t*op = exception (&ops, 0x000020d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hlt \", 4)) { // halt\n\t\t*op = exception (&ops, 0x000040d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b \", 2)) {\n\t\t*op = branch (&ops, addr, 0x14);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.eq \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x00000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.hs \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x02000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"bl \", 3)) {\n\t\t*op = branch (&ops, addr, 0x94);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"br x\", 4)) {\n\t\t*op = branch (&ops, addr, 0x1fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"blr x\", 5)) {\n\t\t*op = branch (&ops, addr, 0x3fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dmb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0xbf3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dsb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0x9f3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"isb\", 3)) {\n\t\t*op = mem_barrier (&ops, addr, 0xdf3f03d5);\n\t\treturn *op != -1;\n\t}\n\treturn false;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2018 - pancake */\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <r_util.h>\n#include \"armass16_const.h\"\n\n// TODO: only lo registers accessible in thumb arm\n\ntypedef struct {\n\tut64 off;\n\tut32 o;\n\tchar op[128];\n\tchar opstr[128];\n\tchar *a[16]; /* only 15 arguments can be used! */\n} ArmOpcode;\n\ntypedef struct {\n\tconst char *name;\n\tint code;\n\tint type;\n} ArmOp;\n\nenum {\n\tTYPE_MOV = 1,\n\tTYPE_TST = 2,\n\tTYPE_SWI = 3,\n\tTYPE_HLT = 4,\n\tTYPE_BRA = 5,\n\tTYPE_BRR = 6,\n\tTYPE_ARI = 7,\n\tTYPE_IMM = 8,\n\tTYPE_MEM = 9,\n\tTYPE_BKP = 10,\n\tTYPE_SWP = 11,\n\tTYPE_MOVW = 12,\n\tTYPE_MOVT = 13,\n\tTYPE_UDF = 14,\n\tTYPE_SHFT = 15,\n\tTYPE_COPROC = 16,\n\tTYPE_ENDIAN = 17,\n\tTYPE_MUL = 18,\n\tTYPE_CLZ = 19,\n\tTYPE_REV = 20,\n};\n\nstatic int strcmpnull(const char *a, const char *b) {\n\tif (!a || !b) {\n\t\treturn -1;\n\t}\n\treturn strcmp (a, b);\n}\n\n// static const char *const arm_shift[] = {\"lsl\", \"lsr\", \"asr\", \"ror\"};\n\nstatic ArmOp ops[] = {\n\t{ \"adc\", 0xa000, TYPE_ARI },\n\t{ \"adcs\", 0xb000, TYPE_ARI },\n\t{ \"adds\", 0x9000, TYPE_ARI },\n\t{ \"add\", 0x8000, TYPE_ARI },\n\t{ \"bkpt\", 0x2001, TYPE_BKP },\n\t{ \"subs\", 0x5000, TYPE_ARI },\n\t{ \"sub\", 0x4000, TYPE_ARI },\n\t{ \"sbcs\", 0xd000, TYPE_ARI },\n\t{ \"sbc\", 0xc000, TYPE_ARI },\n\t{ \"rsb\", 0x6000, TYPE_ARI },\n\t{ \"rsbs\", 0x7000, TYPE_ARI },\n\t{ \"rsc\", 0xe000, TYPE_ARI },\n\t{ \"rscs\", 0xf000, TYPE_ARI },\n\t{ \"bic\", 0x0000c0e1, TYPE_ARI },\n\n\t{ \"udf\", 0xf000f000, TYPE_UDF },\n\n\t{ \"push\", 0x2d09, TYPE_IMM },\n\t{ \"pop\", 0xbd08, TYPE_IMM },\n\n\t{ \"cps\", 0xb1, TYPE_IMM },\n\t{ \"nop\", 0xa0e1, -1 },\n\n\t{ \"ldrex\", 0x9f0f9000, TYPE_MEM },\n\t{ \"ldr\", 0x9000, TYPE_MEM },\n\n\t{ \"strexh\", 0x900fe000, TYPE_MEM },\n\t{ \"strexb\", 0x900fc000, TYPE_MEM },\n\t{ \"strex\", 0x900f8000, TYPE_MEM },\n\t{ \"strbt\", 0x0000e0e4, TYPE_MEM },\n\t{ \"strb\", 0x0000c0e5, TYPE_MEM },\n\t{ \"strd\", 0xf000c0e1, TYPE_MEM },\n\t{ \"strh\", 0xb00080e1, TYPE_MEM },\n\t{ \"str\", 0x8000, TYPE_MEM },\n\n\t{ \"blx\", 0x30ff2fe1, TYPE_BRR },\n\t{ \"bx\", 0x10ff2fe1, TYPE_BRR },\n\n\t{ \"bl\", 0xb, TYPE_BRA },\n// bx/blx - to register, b, bne,.. justjust  offset\n//    2220:       e12fff1e        bx      lr\n//    2224:       e12fff12        bx      r2\n//    2228:       e12fff13        bx      r3\n\n\t//{ \"bx\", 0xb, TYPE_BRA },\n\t{ \"b\", 0xa, TYPE_BRA },\n\n\t//{ \"mov\", 0x3, TYPE_MOV },\n\t//{ \"mov\", 0x0a3, TYPE_MOV },\n\t{ \"movw\", 0x3, TYPE_MOVW },\n\t{ \"movt\", 0x4003, TYPE_MOVT },\n\t{ \"mov\", 0xa001, TYPE_MOV },\n\t{ \"mvn\", 0xe000, TYPE_MOV },\n\t{ \"svc\", 0xf, TYPE_SWI }, // ???\n\t{ \"hlt\", 0x70000001, TYPE_HLT }, // ???u\n\n\t{ \"mul\", 0x900000e0, TYPE_MUL},\n\t{ \"smull\", 0x9000c0e0, TYPE_MUL},\n\t{ \"umull\", 0x900080e0, TYPE_MUL},\n\t{ \"smlal\", 0x9000e0e0, TYPE_MUL},\n\t{ \"smlabb\", 0x800000e1, TYPE_MUL},\n\t{ \"smlabt\", 0xc00000e1, TYPE_MUL},\n\t{ \"smlatb\", 0xa00000e1, TYPE_MUL},\n\t{ \"smlatt\", 0xe00000e1, TYPE_MUL},\n\t{ \"smlawb\", 0x800020e1, TYPE_MUL},\n\t{ \"smlawt\", 0xc00020e1, TYPE_MUL},\n\n\n\t{ \"ands\", 0x1000, TYPE_ARI },\n\t{ \"and\", 0x0000, TYPE_ARI },\n\t{ \"eors\", 0x3000, TYPE_ARI },\n\t{ \"eor\", 0x2000, TYPE_ARI },\n\t{ \"orrs\", 0x9001, TYPE_ARI },\n\t{ \"orr\", 0x8001, TYPE_ARI },\n\n\t{ \"cmp\", 0x5001, TYPE_TST },\n\t{ \"swp\", 0xe1, TYPE_SWP },\n\t{ \"cmn\", 0x0, TYPE_TST },\n\t{ \"teq\", 0x0, TYPE_TST },\n\t{ \"tst\", 0xe1, TYPE_TST },\n\n\t{\"lsr\", 0x3000a0e1, TYPE_SHFT},\n\t{\"asr\", 0x5000a0e1, TYPE_SHFT},\n\t{\"lsl\", 0x1000a0e1, TYPE_SHFT},\n\t{\"ror\", 0x7000a0e1, TYPE_SHFT},\n\n\t{\"rev16\", 0xb00fbf06, TYPE_REV},\n\t{\"revsh\", 0xb00fff06, TYPE_REV},\n\t{\"rev\",   0x300fbf06, TYPE_REV},\n\t{\"rbit\",  0x300fff06, TYPE_REV},\n\n\t{\"mrc\", 0x100010ee, TYPE_COPROC},\n\t{\"setend\", 0x000001f1, TYPE_ENDIAN},\n\t{ \"clz\", 0x000f6f01, TYPE_CLZ},\n\n\t{ NULL }\n};\n\nstatic const ut64 M_BIT = 0x1;\nstatic const ut64 S_BIT = 0x2;\nstatic const ut64 C_BITS = 0x3c;\nstatic const ut64 DOTN_BIT = 0x40;\nstatic const ut64 DOTW_BIT = 0x80;\nstatic const ut64 L_BIT = 0x100;\nstatic const ut64 X_BIT = 0x200;\nstatic const ut64 TWO_BIT = 0x400;\nstatic const ut64 IE_BIT = 0x800;\nstatic const ut64 ID_BIT = 0x1000;\nstatic const ut64 EA_BIT = 0x2000;\nstatic const ut64 FD_BIT = 0x4000;\nstatic const ut64 T_BIT = 0x8000;\nstatic const ut64 B_BIT = 0x10000;\nstatic const ut64 H_BIT = 0x20000;\nstatic const ut64 D_BIT = 0x40000;\nstatic const ut64 W_BIT = 0x80000;\nstatic const ut64 EIGHT_BIT = 0x100000;\nstatic const ut64 SIXTEEN_BIT = 0x200000;\nstatic const ut64 BB_BIT = 0x400000;\nstatic const ut64 BT_BIT = 0x800000;\nstatic const ut64 TB_BIT = 0x1000000;\nstatic const ut64 TT_BIT = 0x2000000;\nstatic const ut64 R_BIT = 0x4000000;\nstatic const ut64 IA_BIT = 0x8000000;\nstatic const ut64 DB_BIT = 0x10000000;\nstatic const ut64 SH_BIT = 0x20000000;\nstatic const ut64 WB_BIT = 0x40000000;\nstatic const ut64 WT_BIT = 0x80000000;\nstatic const ut64 C_MATCH_BIT = 0x100000000;\n\nstatic char *parse_hints(char *input) {\n\tif (!strcmpnull (input, \"unst\")) {\n\t\treturn \"6\";\n\t}\n\tif (!strcmpnull (input, \"un\")) {\n\t\treturn \"7\";\n\t}\n\tif (!strcmpnull (input, \"st\")) {\n\t\treturn \"14\";\n\t}\n\tif (!strcmpnull (input, \"sy\")) {\n\t\treturn \"15\";\n\t}\n\treturn \"-1\";\n}\n\nstatic st8 iflag(char *input) {\n\tst8 res = 0;\n\tut8 i;\n\tr_str_case (input, false);\n\t\n\tfor (i = 0; i < strlen(input); i++) {\n\t\tswitch (input[i]) {\n\t\tcase 'a':\n\t\t\tres |= 0x4;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tres |= 0x2;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tres |= 0x1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ut64 cqcheck(char **input) {\n\tut64 res = 0;\n\tint i;\n\tut8 offset = 0;\n\t\n\tconst char *conds[] = {\n\t\t\"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n\t\t\"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\", 0\n\t};\n\tfor (i = 0; conds[i]; i++) {\n\t\tif (r_str_startswith (*input, conds[i])) {\n\t\t\tres |= C_MATCH_BIT;\n\t\t\tres |= i << 2;\n\t\t\t*input += 2;\n\t\t\toffset += 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (r_str_startswith (*input, \".n\")) {\n\t\tres |= DOTN_BIT;\n\t\t*input += 2;\n\t\toffset += 2;\n\t} else\n\tif (r_str_startswith (*input, \".w\")) {\n\t\tres |= DOTW_BIT;\n\t\t*input += 2;\n\t\toffset += 2;\n\t}\n\t\n\tif (**input == '\\0') {\n\t\treturn res;\n\t}\n\t*input -= offset;\n\treturn 0;\n}\n\nstatic ut64 opmask(char *input, char *opcode, ut64 allowed_mask) {\n\tut64 res = 0;\n\t\n\tr_str_case (input, false);\n\tif (strlen (opcode) > strlen (input)) {\n\t\treturn 0;\n\t}\n\tif (r_str_startswith (input, opcode)) {\n\t\tinput += strlen (opcode);\n\t\tres |= M_BIT;\n\t\tres |= cqcheck (&input);\n\t\t\n\t\tif ((*input == 's') && (S_BIT & allowed_mask)) {\n\t\t\tres |= S_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\n\t\tif ((r_str_startswith (input, \"wb\")) && (WB_BIT & allowed_mask)) {\n\t\t\tres |= WB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"wt\")) && (WT_BIT & allowed_mask)) {\n\t\t\tres |= WT_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"db\")) && (DB_BIT & allowed_mask)) {\n\t\t\tres |= DB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"ea\")) && (EA_BIT & allowed_mask)) {\n\t\t\tres |= EA_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"ia\")) && (IA_BIT & allowed_mask)) {\n\t\t\tres |= IA_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"fd\")) && (FD_BIT & allowed_mask)) {\n\t\t\tres |= FD_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'l') && (L_BIT & allowed_mask)) {\n\t\t\tres |= L_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"bb\")) && (BB_BIT & allowed_mask)) {\n\t\t\tres |= BB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"tt\")) && (TT_BIT & allowed_mask)) {\n\t\t\tres |= TT_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"bt\")) && (BT_BIT & allowed_mask)) {\n\t\t\tres |= BT_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"tb\")) && (TB_BIT & allowed_mask)) {\n\t\t\tres |= TB_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'w') && (W_BIT & allowed_mask)) {\n\t\t\tres |= W_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 'b') && (B_BIT & allowed_mask)) {\n\t\t\tres |= B_BIT;\n\t\t\tinput++;\n\t\t} else\n\t        if ((*input == 'h') && (H_BIT & allowed_mask)) {\n\t\t\tres |= H_BIT;\n\t\t\tinput++;\n\t\t} else\n\t\tif ((*input == 'd') && (D_BIT & allowed_mask)) {\n\t\t\tres |= D_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 't') && (T_BIT & allowed_mask)) {\n\t\t\tres |= T_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 's') && (S_BIT & allowed_mask)) {\n\t\t\tres |= S_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'r') && (R_BIT & allowed_mask)) {\n\t\t\tres |= R_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == '2') && (TWO_BIT & allowed_mask)) {\n\t\t\tres |= TWO_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == '8') && (EIGHT_BIT & allowed_mask)) {\n\t\t\tres |= EIGHT_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((r_str_startswith (input, \"16\")) && (SIXTEEN_BIT & allowed_mask)) {\n\t\t\tres |= SIXTEEN_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((*input == 'l') && (L_BIT & allowed_mask)) {\n\t\t\tres |= L_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tif ((*input == 'x') && (X_BIT & allowed_mask)) {\n\t\t\tres |= X_BIT;\n\t\t\tinput++;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"id\")) && (ID_BIT & allowed_mask)) {\n\t\t\tres |= ID_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tif ((r_str_startswith (input, \"ie\")) && (IE_BIT & allowed_mask)) {\n\t\t\tres |= IE_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif ((r_str_startswith (input, \"sh\")) && (SH_BIT & allowed_mask)) {\n\t\t\tres |= SH_BIT;\n\t\t\tinput += 2;\n\t\t}\n\t\tres |= cqcheck (&input);\n\t\tif (!(res & C_MATCH_BIT)) {\n\t\t\tres |= 15 << 2; // nv is the default condition\n\t\t}\n\t\tif (*input == 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut32 itmask(char *input) {\n\tut32 res = 0;\n\tut32 i, length;\n\tr_str_case (input, false);\n\tif (2 > strlen (input)) {\n\t\treturn 0;\n\t}\n\tif (r_str_startswith (input, \"it\")) {\n\t\tinput += 2;\n\t\tres |= 1; // matched\n\t\tif (strlen(input) > 3) {\n\t\t\treturn 0;\n\t\t}\n\t\tres |= (strlen (input) & 0x3) << 4;\n\t\tlength = strlen (input);\n\t\tfor (i = 0; i < length; i++, input++ ) {\n\t\t\tif (*input == 'e') {\n\t\t\t\tres |= 1 << (3 - i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (*input == 't') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstatic bool err;\n//decode str as number\nstatic ut64 getnum(const char *str) {\n\tchar *endptr;\n\terr = false;\n\tut64 val;\n\n\tif (!str) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\twhile (*str == '$' || *str == '#') {\n\t\tstr++;\n\t}\n\tval = strtol (str, &endptr, 0);\n\tif (str != endptr && *endptr == '\\0') {\n\t\treturn val;\n\t}\n\terr = true;\n\treturn 0;\n}\n\nstatic ut64 getnumbang(const char *str) {\n\tut64 res;\n\n\tif (!str || !*str || !r_str_endswith (str, \"!\")) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\tchar *temp = r_str_ndup (str, strlen (str) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\terr = false;\n\tres = getnum (temp);\n\tfree (temp);\n\treturn res; // err propagates\n}\n\t\nstatic ut32 getimmed8(const char *str) {\n\tut32 num = getnum (str);\n\tif (err) {\n\t\treturn 0;\n\t}\n\tut32 rotate;\n\tif (num <= 0xff) {\n\t\treturn num;\n\t} else {\n\t\tfor (rotate = 1; rotate < 16; rotate++) {\n\t\t\t// rol 2\n\t\t\tnum = ((num << 2) | (num >> 30));\n\t\t\tif (num == (num & 0xff)) {\n\t\t\t\treturn (num | (rotate << 8));\n\t\t\t}\n\t\t}\n\t\terr = 1;\n\t\treturn 0;\n\t}\n}\n\nstatic st32 firstsigdigit (ut32 num) {\n\tst32 f = -1;\n\tst32 b = -1;\n\tut32 forwardmask = 0x80000000;\n\tut32 backwardmask = 0x1;\n\tut32 i;\n\tfor (i = 0; i < 32; i++ ) {\n\t\tif ( (forwardmask & num) && (f == -1)) {\n\t\t\tf = i;\n\t\t}\n\t\tif ( (backwardmask & num) && (b == -1)) {\n\t\t\tb = 32-i;\n\t\t}\n\t\tforwardmask >>= 1;\n\t\tbackwardmask <<= 1;\n\t}\n\n\tif ((b-f) < 9) {\n\t\treturn f;\n\t}\n\treturn -1;\n}\n\nstatic ut32 getthbimmed(st32 number) {\n\tut32 res = 0;\n\tif (number < 0) {\n\t\tres |= 1 << 18;\n\t}\n\tnumber >>= 1;\n\tres |= (( number & 0xff) << 8);\n\tnumber >>= 8;\n\tres |= ( number & 0x07);\n\tnumber >>= 3;\n\tres |= (( number & 0xff) << 24);\n\tnumber >>= 8;\n\tres |= (( number & 0x3) << 16);\n\tnumber >>= 2;\n\tif (number < 0) {\n\t\tres |= (( number & 0x1) << 3);\n\t\tnumber >>= 1;\n\t\tres |= (( number & 0x1) << 5);\n\t} else {\n\t\tres |= ((!( number & 0x1)) << 3);\n\t\tnumber >>= 1;\n\t\tres |= ((!( number & 0x1)) << 5);\n\t}\n\treturn res;\n}\n\nstatic ut32 getthzeroimmed12(ut32 number) {\n\tut32 res = 0;\n\tres |= (number & 0x800) << 7;\n\tres |= (number & 0x700) >> 4;\n\tres |= (number & 0x0ff) << 8;\n\treturn res;\n}\n\nstatic ut32 getthzeroimmed16(ut32 number) {\n\tut32 res = 0;\n\tres |= (number & 0xf000) << 12;\n\tres |= (number & 0x0800) << 7;\n\tres |= (number & 0x0700) >> 4;\n\tres |= (number & 0x00ff) << 8;\n\treturn res;\n}\n\nstatic ut32 getthimmed12(const char *str) {\n\tut64 num = getnum (str);\n\tif (err) {\n\t\treturn 0;\n\t}\n\n\tst32 FSD = 0;\n\tut64 result = 0;\n\tif (num <= 0xff) {\n\t\treturn num << 8;\n\t} else \tif ( ((num & 0xff00ff00) == 0) && ((num & 0x00ff0000) == ((num & 0x000000ff) << 16)) ) {\n\t\tresult |= (num & 0x000000ff) << 8;\n\t\tresult |= 0x00000010;\n\t\treturn result;\n\t} else if ( ((num & 0x00ff00ff) == 0) && ((num & 0xff000000) == ((num & 0x0000ff00) << 16)) ) {\n\t\tresult |= num & 0x0000ff00;\n\t\tresult |= 0x00000020;\n\t\treturn result;\n\t} else if ( ((num & 0xff000000) == ((num & 0x00ff0000) << 8)) && ((num & 0xff000000) == ((num & 0x0000ff00) << 16)) && ((num &0xff000000) == ((num & 0x000000ff) << 24)) ) {\n\t\tresult |= num & 0x0000ff00;\n\t\tresult |= 0x00000030;\n\t\treturn result;\n\t} else {\n\t\tFSD = firstsigdigit(num);\n\t\tif (FSD != -1) {\n\t\t        result |= ((num >> (24-FSD)) & 0x0000007f) << 8;\n\t\t\tresult |= ((8+FSD) & 0x1) << 15;\n\t\t\tresult |= ((8+FSD) & 0xe) << 3;\n\t\t\tresult |= ((8+FSD) & 0x10) << 14;\n\t\t\treturn result;\n\t\t} else {\n\t\t\terr = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nstatic char *getrange(char *s) {\n\tchar *p = NULL;\n\twhile (s && *s) {\n\t\tif (*s == ',') {\n\t\t\tp = s+1;\n\t\t\t*p=0;\n\t\t}\n\t\tif (*s == '[' || *s == ']') {\n\t\t\tmemmove (s, s + 1, strlen (s + 1) + 1);\n\t\t}\n\t\tif (*s == '}') {\n\t\t\t*s = 0;\n\t\t}\n\t\ts++;\n\t}\n\twhile (p && *p == ' ') {\n\t\tp++;\n\t}\n\treturn p;\n}\n\n//ret register #; -1 if failed\nstatic int getreg(const char *str) {\n\tint i;\n\tchar *ep;\n\tconst char *aliases[] = { \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\", NULL };\n\tif (!str || !*str) {\n\t\treturn -1;\n\t}\n\tif (*str == 'r') {\n\t\tint reg = strtol (str + 1, &ep, 10);\n\t\tif ((ep[0] != '\\0') || (str[1] == '\\0')) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (reg < 16 && reg >= 0) {\n\t\t\treturn reg;\n\t\t}\n\t}\n\tfor (i=0; aliases[i]; i++) {\n\t\tif (!strcmpnull (str, aliases[i])) {\n\t\t\treturn 10 + i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nstatic st32 getlistmask(char *input) {\n\tst32 tempres, res = 0;\n\tint i, j, start, end;\n\tchar *temp = NULL;\n\tchar *otemp = NULL;\n\tchar *temp2 = malloc (strlen (input) + 1);\n\tif (!temp2) {\n\t\tres = -1;\n\t\tgoto end;\n\t}\n\ttemp = (char *)malloc (strlen (input) + 1);\n\tif (!temp) {\n\t\tres = -1;\n\t\tgoto end;\n\t}\n\totemp = temp;\n\twhile (*input != '\\0') {\n\t\tfor (; *input == ' '; input++) {\n\t\t\t;\n\t\t}\n\t\tfor (i = 0; input[i] != ',' && input[i] != '\\0'; i++) {\n\t\t\t;\n\t\t}\n\t\tstrncpy (temp, input, i);\n\t\ttemp[i] = 0;\n\n\t\tinput += i;\n\t\tif (*input != '\\0') {\n\t\t\tinput++;\n\t\t}\n\n\t\tfor (i = 0; temp[i] != '-' && temp[i] != '\\0'; i++) {\n\t\t\t;\n\t\t}\n\t\tif (i == strlen (temp)) {\n\t\t\ttempres = getreg (temp);\n\t\t\tif (tempres == -1 || tempres > 15) {\n\t\t\t\tres = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tres |= 1 << tempres;\n\t\t} else {\n\t\t\tstrncpy (temp2, temp, i);\n\t\t\ttemp2[i] = 0;\n\t\t\ttemp += i + 1;\n\t\t\tstart = getreg (temp2);\n\t\t\tif (start == -1 || start > 15) {\n\t\t\t\tres = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tend = getreg (temp);\n\t\t\tif (end == -1 || end > 15) {\n\t\t\t\tres = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tfor (j = start; j <= end; j++ ) {\n\t\t\t\tres |= 1 << j;\n\t\t\t}\n\t\t}\n\t}\nend:\n\tfree (otemp);\n\tfree (temp2);\n\treturn res;\n}\n\nstatic st32 getregmemstart(const char *input) {\n\tif ((strlen (input) < 1) || (!(*input == '['))) {\n\t\treturn -1;\n\t}\n\tinput++;\n\treturn getreg (input);\n}\n\t\nstatic st32 getregmemstartend(const char *input) {\n\tst32 res;\n\tif (!input || (strlen (input) < 2) || (*input != '[') || !r_str_endswith (input, \"]\")) {\n\t\treturn -1;\n\t}\n\tinput++;\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getreg (temp);\n\tfree (temp);\n\treturn res;\n}\n\t\nstatic st32 getregmemend(const char *input) {\n\tst32 res;\n\tif (!input || !*input || !r_str_endswith (input, \"]\")) {\n\t\treturn -1;\n\t}\n\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getreg (temp);\n\tfree (temp);\n\treturn res;\n}\n\t\nstatic st32 getreglist(const char *input) {\n\tst32 res;\n\t\n\tif (!input || (strlen (input) < 2) || (*input != '{') || !r_str_endswith (input, \"}\")) {\n\t\treturn -1;\n\t}\n\tif (*input) {\n\t\tinput++;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getlistmask (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic st32 getnummemend (const char *input) {\n\tst32 res;\n\terr = false;\n\tif (!input || !*input || !r_str_endswith (input, \"]\")) {\n\t\terr = true;\n\t\treturn -1;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\terr = true;\n\t\treturn -1;\n\t}\n\tres = getnum (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic st32 getnummemendbang (const char *input) {\n\tst32 res;\n\terr = false;\n\tif (!input || (strlen (input) < 2) || (input[strlen(input) - 2] != ']' || !r_str_endswith (input, \"!\"))) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 2);\n\tif (!temp) {\n\t\terr = true;\n\t\treturn 0;\n\t}\n\tres = getnum (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic st32 getregmembang(const char *input) {\n\tst32 res;\n\tif (!input || !*input || !r_str_endswith (input, \"!\")) {\n\t\treturn -1;\n\t}\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = getreg (temp);\n\tfree (temp);\n\treturn res;\n}\n\nstatic int getcoproc(const char *str) {\n\tchar *ep;\n\tif (!str || !*str) {\n\t\treturn -1;\n\t}\n\tif (*str == 'p') {\n\t\tint coproc = strtol (str + 1, &ep, 10);\n\t\tif ((ep[0] != '\\0') || (str[1] == '\\0')) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (coproc < 16 && coproc >= 0) {\n\t\t\treturn coproc;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int getcoprocreg(const char *str) {\n\tchar *ep;\n\t\n\tif (!str || !*str) {\n\t\treturn -1;\n\t}\n\tif (r_str_startswith (str, \"c\")) {\n\t\tint reg = strtol (str + 1, &ep, 10);\n\t\tif ((ep[0] != '\\0') || (str[1] == '\\0')) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (reg < 16 && reg >= 0) {\n\t\t\treturn reg;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic ut8 interpret_msrbank (char *str, ut8 *spsr) {\n\tconst char fields[] = {'c', 'x', 's', 'f', 0};\n\tint res = 0;\n\tint i, j;\n\tif (r_str_startswith (str, \"spsr_\")) {\n\t\t*spsr = 1;\n\t} else {\n\t\t*spsr = 0;\n\t}\t\t\n\t\n\tif (r_str_startswith (str, \"apsr_\")) {\n\t\tif (!(strcmp (str+5, \"g\"))) {\n\t\t\treturn 0x4;\n\t\t}\n\t\tif (!(strcmp (str+5, \"nzcvq\"))) {\n\t\t\treturn 0x8;\n\t\t}\n\t\tif (!(strcmp (str+5, \"nzcvqg\"))) {\n\t\t\treturn 0xc;\n\t\t}\n\t}\n\tif (r_str_startswith (str, \"cpsr_\") || r_str_startswith (str, \"spsr_\")) {\n\t\tfor (i = 0; str[5+i]; i++) {\n\t\t\tfor (j = 0; fields[j]; j++) {\n\t\t\t\tif (str[5+i] == fields[j]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(fields[j])) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tres |= 1 << j;\n\t\t}\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\t\t\nstatic ut32 thumb_getshift(const char *str) {\n\t// only immediate shifts are ever used by thumb-2. Bit positions are different from ARM.\n\tconst char *shifts[] = {\n\t\t\"LSL\", \"LSR\", \"ASR\", \"ROR\", 0, \"RRX\"\n\t};\n\tchar *type = strdup (str);\n\tchar *arg;\n\tchar *space;\n\tut32 res = 0;\n\tut32 shift = false;\n\terr = false;\n\tut32 argn;\n\tut32 i;\n\t\n\tr_str_case (type,true);\n\t\n\tif (!strcmp (type, shifts[5])) {\n\t\t// handle RRX alias case\n\t\tres |= 3 << 12;\t\n\t\tfree (type);\n\t\treturn res;\n\t}\n\t\n\tspace = strchr (type, ' ');\n\tif (!space) {\n\t\tfree (type);\n\t\terr = true;\n\t\treturn 0;\n\t}\n\t*space = 0;\n\targ = strdup (++space);\n\t\n\tfor (i = 0; shifts[i]; i++) {\n\t\tif (!strcmp (type, shifts[i])) {\n\t\t\tshift = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!shift) {\n\t\terr = true;\n\t\tfree (type);\n\t\tfree (arg);\n\t\treturn 0;\n\t}\n\tres |= i << 12;\n\t\t\n\targn = getnum (arg);\n\tif (err || argn > 32) {\n\t\terr = true;\n\t\tfree (type);\n\t\tfree (arg);\n\t\treturn 0;\n\t}\n\tres |= ( (argn & 0x1c) << 2);\n\tres |= ( (argn & 0x3) << 14);\n\n\tfree (type);\n\tfree (arg);\n\treturn res;\n}\n\nstatic st32 getshiftmemend(const char *input) {\n\tst32 res;\n\tif (!input || !*input || !r_str_endswith (input, \"]\")) {\n\t\treturn -1;\n\t}\n\n\tchar *temp = r_str_ndup (input, strlen (input) - 1);\n\tif (!temp) {\n\t\treturn -1;\n\t}\n\tres = thumb_getshift (temp);\n\tfree (temp);\n\treturn res;\n}\n\nvoid collect_list(char *input[]) {\n\tif (input[0] == NULL) {\n\t\treturn;\n\t}\n\tchar *temp  = malloc (500);\n\tif (!temp) {\n\t\treturn;\n\t}\n\ttemp[0] = 0;\n\tint i;\n\tint conc = 0;\n\tint start, end = 0;\n\tint arrsz;\n\tfor (arrsz = 1; input[arrsz] != NULL; arrsz++) {\n\t\t;\n\t}\n\n\tfor (i = 0; input[i]; i++) {\n\t\tif (conc) {\n\t\t\tstrcat (temp, \", \");\n\t\t\tstrcat (temp, input[i]);\n\t\t}\n\t\tif (input[i][0] == '{') {\n\t\t\tconc = 1;\n\t\t\tstrcat (temp, input[i]);\n\t\t\tstart = i;\n\t\t}\n\t\tif ((conc) & (input[i][strlen (input[i]) - 1] == '}')) {\n\t\t\tconc = 0;\n\t\t\tend = i;\n\t\t}\n\t}\n\tif (end == 0) {\n\t\tfree (temp);\n\t\treturn;\n\t}\n\tinput[start] = temp;\n\tfor (i = start + 1; i < arrsz; i++) {\n\t\tinput[i] = input[(end-start) + i];\n\t}\n\tinput[i] = NULL;\n}\n\nstatic ut64 thumb_selector(char *args[]) {\n\tcollect_list(args);\n\tut64 res = 0;\n\tut8 i;\n\tfor (i = 0; i < 15; i++) {\n\t\tif (args[i] == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tif (getreg (args[i]) != -1) {\n\t\t\tres |= 1 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnum (args[i]);\n\t\tif (!err) {\n\t\t\tres |= 2 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;   \t\n\t\tthumb_getshift (args[i]);\n\t\tif (!err) {\n\t\t\tres |= 3 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getcoproc (args[i]) != -1) {\n\t\t\tres |= 4 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getcoprocreg (args[i]) != -1) {\n\t\t\tres |= 5 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmemstart (args[i]) != -1) {\n\t\t\tres |= 6 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmemstartend (args[i]) != -1) {\n\t\t\tres |= 7 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnummemend(args[i]);\n\t\tif (!err) {\n\t\t\tres |= 8 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnummemendbang(args[i]);\n\t\tif (!err) {\n\t\t\tres |= 9 << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmembang (args[i]) != -1) {\n\t\t\tres |= 0xa << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getreglist (args[i]) != -1) {\n\t\t\tres |= 0xb << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getregmemend (args[i]) != -1) {\n\t\t\tres |= 0xc << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tif (getshiftmemend (args[i]) != -1) {\n\t\t\tres |= 0xd << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\terr = false;\n\t\tgetnumbang(args[i]);\n\t\tif (!err) {\n\t\t\tres |= 0xe << (i*4);\n\t\t\tcontinue;\n\t\t}\n\t\tres |= 0xf << (i*4);\n\t}\n\terr = false;\n\treturn res;\n}\n\t\t\nstatic ut32 getshift(const char *str) {\n\tchar type[128];\n\tchar arg[128];\n\tchar *space;\n\tut32 i=0, shift=0;\n\tconst char *shifts[] = {\n\t\t\"LSL\", \"LSR\", \"ASR\", \"ROR\",\n\t\t0, \"RRX\" // alias for ROR #0\n\t};\n\n\tstrncpy (type, str, sizeof (type) - 1);\n\t// XXX strcaecmp is probably unportable\n\tif (!r_str_casecmp (type, shifts[5])) {\n\t\t// handle RRX alias case\n\t\tshift = 6;\n\t} else { // all other shift types\n\t\tspace = strchr (type, ' ');\n\t\tif (!space) {\n\t\t\treturn 0;\n\t\t}\n\t\t*space = 0;\n\t\tstrncpy (arg, ++space, sizeof(arg) - 1);\n\n\t\tfor (i = 0; shifts[i]; i++) {\n\t\t\tif (!r_str_casecmp (type, shifts[i])) {\n\t\t\t\tshift = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!shift) {\n\t\t\treturn 0;\n\t\t}\n\t\tshift = i * 2;\n\t\tif ((i = getreg (arg)) != -1) {\n\t\t\ti <<= 8; // set reg\n//\t\t\ti|=1; // use reg\n\t\t\ti |= (1 << 4); // bitshift\n\t\t\ti |= shift << 4; // set shift mode\n\t\t\tif (shift == 6) {\n\t\t\t\ti |= (1 << 20);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *bracket = strchr (arg, ']');\n\t\t\tif (bracket) {\n\t\t\t\t*bracket = '\\0';\n\t\t\t}\n\t\t\t// ensure only the bottom 5 bits are used\n\t\t\ti &= 0x1f;\n\t\t\tif (!i) {\n\t\t\t\ti = 32;\n\t\t\t}\n\t\t\ti = (i * 8);\n\t\t\ti |= shift; // lsl, ror, ...\n\t\t\ti = i << 4;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic void arm_opcode_parse(ArmOpcode *ao, const char *str) {\n\tint i;\n\tmemset (ao, 0, sizeof (ArmOpcode));\n\tif (strlen (str) + 1 >= sizeof (ao->op)) {\n\t\treturn;\n\t}\n\tstrncpy (ao->op, str, sizeof (ao->op)-1);\n\tstrcpy (ao->opstr, ao->op);\n\tao->a[0] = strchr (ao->op, ' ');\n\tfor (i=0; i<15; i++) {\n\t\tif (ao->a[i]) {\n\t\t\t*ao->a[i] = 0;\n\t\t\tao->a[i+1] = strchr (++ao->a[i], ',');\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ao->a[i]) {\n\t\t*ao->a[i] = 0;\n\t\tao->a[i]++;\n\t}\n\tfor (i=0; i<16; i++) {\n\t\twhile (ao->a[i] && *ao->a[i] == ' ') {\n\t\t\tao->a[i]++;\n\t\t}\n\t}\n}\n\nstatic inline int arm_opcode_cond(ArmOpcode *ao, int delta) {\n\tconst char *conds[] = {\n\t\t\"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n\t\t\"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\", 0\n\t};\n\tint i, cond = 14; // 'always' is default\n\tchar *c = ao->op+delta;\n\tfor (i=0; conds[i]; i++) {\n\t\tif (!strcmpnull (c, conds[i])) {\n\t\t\tcond = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tao->o |= cond << 4;\n\treturn cond;\n}\n\nstatic st32 thumb_getoffset(char *label, ut64 cur) {\n\tst32 res = r_num_math (NULL, label);\n\tres -= 4;\n\tres -= cur; // possible integer underflow\n\t//printf(\"thumb_getoffset: %s, %lld, %lld\\n\", label, res, cur);\n\treturn res;\n}\n\nstatic st8 std_16bit_2reg(ArmOpcode *ao, ut64 m) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getreg (ao->a[1]);\n\tif ( (rd < 8) && (rn < 8) && !(m & DOTW_BIT)) {\n\t\tao->o |= rd << 8;\n\t\tao->o |= rn << 11;\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic st8 mem_16bit_2reg(ArmOpcode *ao, ut64 m) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getregmemstart (ao->a[1]);\n\tif ( (rd < 8) && (rn < 8) && !(m & DOTW_BIT)) {\n\t\tao->o |= rd << 8;\n\t\tao->o |= rn << 11;\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic st8 std_32bit_2reg(ArmOpcode *ao, ut64 m, bool shift) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getreg (ao->a[1]);\n\tif ((rd > 15) || (rn > 15) || (m & DOTN_BIT)) {\n\t\treturn -1;\n\t}\n\tif (m & S_BIT) {\n\t\tao->o |= 1 << 28;\n\t}\n\tif (shift) {\n\t\terr = false;\n\t\tut32 shiftnum = thumb_getshift (ao->a[2]);\n\t\tif (err) {\n\t\t\treturn -1;\n\t\t}\n\t\tao->o |= shiftnum;\n\t\tao->o |= rd << 24;\n\t\tao->o |= rn << 8;\n\t} else {\n\t\tao->o |= rd;\n\t\tao->o |= rn << 24;\n\t}\n\treturn 4;\n}\n\nstatic st8 mem_32bit_2reg(ArmOpcode *ao, ut64 m) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getregmemstart (ao->a[1]);\n\tif ((rd > 15) || (rn > 15) || (m & DOTN_BIT)) {\n\t\treturn -1;\n\t}\n\tao->o |= rd << 4;\n\tao->o |= rn << 24;\n\treturn 4;\n}\n\nstatic st8 std_32bit_3reg(ArmOpcode *ao, ut64 m, bool shift) {\n\tut8 rd = getreg (ao->a[0]);\n\tut8 rn = getreg (ao->a[1]);\n\tut8 rm = getreg (ao->a[2]);\n\tif ((rd > 15) || (rn > 15) || (rm > 15) || (m & DOTN_BIT)) {\n\t\treturn -1;\n\t}\n\tao->o |= rd;\n\tao->o |= rn << 24;\n\tao->o |= rm << 8;\n\tif (shift) {\n\t\terr = false;\n\t\tut32 shiftnum = thumb_getshift (ao->a[3]);\n\t\tif (err) {\n\t\t\treturn -1;\n\t\t}\n\t\tao->o |= shiftnum;\n\t}\n\tif (m & S_BIT) {\n\t\tao->o |= 1 << 28;\n\t}\n\treturn 4;\n}\n\nstatic void std_opt_2(ArmOpcode *ao) {\n\tao->a[2] = ao->a[1];\n\tao->a[1] = ao->a[0];\n}\n\nstatic void std_opt_3(ArmOpcode *ao) {\n\tao->a[3] = ao->a[2];\n\tao->a[2] = ao->a[1];\n\tao->a[1] = ao->a[0];\n}\n\n// TODO: group similar instructions like for non-thumb\nstatic int thumb_assemble(ArmOpcode *ao, ut64 off, const char *str) {\n\tut64 m;\n\tao->o = UT32_MAX;\n\tif (!strcmpnull (ao->op, \"udf\")) {\n\t\tao->o = 0xde;\n\t\tao->o |= getnum (ao->a[0]) << 8;\n\t\treturn 2;\n\t} else\n\tif ((m = opmask (ao->op, \"add\", S_BIT | W_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif (reg2 == 13) {\n\t\t\t\tif ((reg1 < 8) && (num < 1024) && (num % 4 == 0) && (!(m & DOTW_BIT)) && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0x00a8;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\tif ((reg1 == 13) && (num < 512) && (num % 4 == 0) && (!(m & DOTW_BIT)) && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0x00b0;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\terr = false;\n\t\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0x0df10000;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tao->o |= thnum;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t\t}\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\n\t\t\t\tif (num > 4095) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0x0df20000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif (num < 8) {\n\t\t\t\tao->o = 0x001c;\n\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\tao->o |= (num >> 2);\n\t\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((reg1 < 8) && (reg1 == reg2) && (num < 256)) {\n\t\t\t\tao->o = 0x0030;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\terr = false;\n\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\tao->o = 0x00f10000;\n\t\t\t\tao->o |= thnum;\n\t\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t\t}\n\n\t\t\tif (num > 4095) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x00f20000;\n\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\tif (reg2 == 13) {\n\t\t\t\tif ((reg1 == reg3) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\t\tao->o = 0x6844;\n\t\t\t\t\tao->o |= (reg1 & 0x7) << 8;\n\t\t\t\t\tao->o |= (reg1 >> 3) << 15;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\tif ((reg1 == 13) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\t\tao->o = 0x8544;\n\t\t\t\t\tao->o |= reg3 << 11;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0x0deb0000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= reg3 << 8;\n\t\t\t\tao->o |= shift;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t}\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg3 < 8) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\tao->o = 0x0018;\n\t\t\t\tao->o |= (reg3 >> 2);\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((reg1 == reg2) && (!(m & DOTW_BIT)) && (shift == 0)) {\n\t\t\t\tao->o = 0x0044;\n\t\t\t\tao->o |= (reg1 & 0x7) << 8;\n\t\t\t\tao->o |= (reg1 >> 3) << 15;\n\t\t\t\tao->o |= reg3 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0x00eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"adc\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tao->o = 0x40f10000;\n\t\t\tao->o |= getthimmed12 (ao->a[2]);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x4041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x40eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tstd_opt_3 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\t\t// a bit naughty, perhaps?\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x40eb0000;\n\t\t\treturn std_32bit_3reg(ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"adr\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg = getreg (ao->a[0]);\n\t\t\tst32 label = getnum (ao->a[1]);\n\t\t\tif ( !(m & DOTW_BIT) && (reg < 8) && (label < 1024) && (label >= 0) && (label % 4 == 0)) {\n\t\t\t\tao->o = 0x00a0;\n\t\t\t\tao->o |= reg;\n\t\t\t\tao->o |= (label / 4) << 8;\n\t\t\t\treturn 2;\n\t\t\t} else if ((label < 0) && (label > -4096)) {\n\t\t\t\tif (m & DOTN_BIT) {\n\t\t\t\t\t// this is explicitly an error\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0xaff20000;\n\t\t\t\tao->o |= reg;\n\t\t\t\tao->o |= getthzeroimmed12 (-label);\n\t\t\t\treturn 4;\n\t\t\t} else if ((label > 0) && (label < 4096)) {\n\t\t\t\tif (m & DOTN_BIT) {\n\t\t\t\t\t// this is explicitly an error\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x0ff20000;\n\t\t\t\tao->o |= reg;\n\t\t\t\tao->o |= getthzeroimmed12 (label);\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\treturn -1;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"and\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x00ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut32 imm = getthimmed12 (ao->a[2]);\n\t\t\tao->o = 0x00f00000;\n\t\t\tao->o |= imm;\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tstd_opt_3 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x00ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"asr\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 imm = getnum (ao->a[2]);\n\t\t\tif (((int)imm < 1) && ((int)imm > 32)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x0010;\n\t\t\tao->o |= (imm & 0x3) << 14;\n\t\t\tao->o |= (imm & 0x1c) >> 2;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x4fea2000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (imm & 0x3) << 14;\n\t\t\tao->o |= (imm & 0x1c) << 2;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x40fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"b\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tst32 offset = thumb_getoffset (ao->a[0], off);\n\t\t\tif (offset % 2 != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((m & C_BITS) == C_BITS) {\n\t\t\t\tif ((offset >= -2048) && (offset <= 2046) && (!(m & DOTW_BIT))) {\n\t\t\t\t\tao->o = 0x00e0;\n\t\t\t\t\tao->o |= ((offset/2 & 0xff) << 8);\n\t\t\t\t\tao->o |= ((offset/2 & 0x700) >> 8);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tif ((offset < -16777216) || (offset > 16777214) || (offset % 2 != 0)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x00f00090;\n\t\t\t\tao->o |= getthbimmed(offset);\n\t\t\t\treturn 4;\n\t\t\t} else {\n\t\t\t\tif ((offset >= -256) && (offset <= 254) && (!(m & DOTW_BIT))) {\n\t\t\t\t\tao->o = 0x00d0;\n\t\t\t\t\tao->o |= (ut16) ((offset/2) << 8);\n\t\t\t\t\tao->o |= ((m & C_BITS) >> 2);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tif ((offset < -1048576) || (offset > 1048574) || (offset % 2 != 0)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0x00f00080;\n\t\t\t\tao->o |= (ut32)(offset & 0x80000) >> 16;\n\t\t\t\tao->o |= (ut32)(offset & 0x40000) >> 13;\n\t\t\t\tao->o |= (ut32)(offset & 0x3f000) << 12;\n\t\t\t\tao->o |= (ut32)(offset & 0xe00) >> 9;\n\t\t\t\tao->o |= (ut32)(offset & 0x1fe) << 7;\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tao->o |= 1 << 18;\n\t\t\t\t}\n\t\t\t\tao->o |= (((m & C_BITS) & 0xc) << 28);\n\t\t\t\tao->o |= (((m & C_BITS) & 0x30) << 12);\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bl\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tst32 offset = thumb_getoffset (ao->a[0], off);\n\t\t\tao->o = 0x00f000d0;\n\t\t\tif ((offset > 16777214) || (offset < -16777216) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= getthbimmed(offset);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bx\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tao->o = 0x0047;\n\t\t\tao->o |= reg1 << 11;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif (( m = opmask (ao->op, \"blx\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tao->o = 0x8047;\n\t\t\tao->o |= reg1 << 11;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_CONST: {\n\t\t\tst32 offset = thumb_getoffset (ao->a[0], off);\n\t\t\tao->o = 0x00f000c0;\n\t\t\tif ((offset > 16777214) || (offset < -16777216) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\toffset += off & 0x2; // (Align(PC,4)\n\t\t\tao->o |= getthbimmed (offset);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bfc\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST_CONST: {\n\t\t\tif (m & DOTN_BIT) {\n\t\t\t\t// this is explicitly an error\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 lsb = getnum (ao->a[1]);\n\t\t\tut32 width = getnum (ao->a[2]);\n\t\t\tut32 msb = lsb + width - 1;\n\t\t\tif ((lsb > 31) || (msb > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x6ff30000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= ((lsb & 0x1c) << 2);\n\t\t\tao->o |= ((lsb & 0x3) << 14);\n\t\t\tao->o |= (msb << 8);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bfi\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST_CONST: {\n\t\t\tut32 lsb = getnum (ao->a[2]);\n\t\t\tut32 width = getnum (ao->a[3]);\n\t\t\tut32 msb = lsb + width - 1;\n\t\t\tif ((lsb > 31) || (msb > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x60f30000;\n\t\t\tao->o |= ((lsb & 0x1c) << 2);\n\t\t\tao->o |= ((lsb & 0x3) << 14);\n\t\t\tao->o |= (msb << 8);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bic\", S_BIT) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x8043;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x20ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tao->o = 0x20f00000;\n\t\t\tao->o |= getthimmed12 (ao->a[2]);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tstd_opt_3 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x20ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"bkpt\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\tif (num > 255) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00be;\n\t\t\tao->o |= num << 8;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cbnz\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tst32 offset = thumb_getoffset (ao->a[1], off);\n\t\t\tif ((reg1 > 7) || (offset > 127) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00b9;\n\t\t\tao->o |= reg1 << 8;\n\t\t\tao->o |= (offset & 0x3e) << 10;\n\t\t\tao->o |= (offset & 0x40) >> 5;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cbz\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tst32 offset = thumb_getoffset (ao->a[1], off);\n\t\t\tif ((reg1 > 7) || (offset > 127) || (offset % 2 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00b1;\n\t\t\tao->o |= reg1 << 8;\n\t\t\tao->o |= (offset & 0x3e) << 10;\n\t\t\tao->o |= (offset & 0x40) >> 5;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cdp\", TWO_BIT) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_COREG_COREG_COREG: {\n\t\t\tao->a[5] = \"0\";\n\t\t        }\n\t\t\t//intentional fallthrough\n\t\tcase THUMB_COPROC_CONST_COREG_COREG_COREG_CONST: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc1 = getnum (ao->a[1]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[2]);\n\t\t\tut8 reg2 = getcoprocreg (ao->a[3]);\n\t\t\tut8 reg3 = getcoprocreg (ao->a[4]);\n\t\t\tut32 opc2 = getnum (ao->a[5]);\n\t\t        if ((coproc > 15) || (opc1 > 15) || (opc2 > 7)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00ee0000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc1 << 28;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= opc2 << 13;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \t\n\tif (( m = opmask (ao->op, \"clrex\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff32f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"clz\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xb0fa80f0;\n\t\t\tao->a[2] = ao->a[1];\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cmn\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\t\t\tao->o = 0x10f1000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xc042;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tao->o = 0x10eb000f;\n\t\t\treturn std_32bit_2reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cmp\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getnum (ao->a[1]);\n\t\t\tif ((num < 256) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0028;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tnum = getthimmed12 (ao->a[1]);\n\t\t\tao->o = 0xb0f1000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tao->o = 0x8042;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (!(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x0045;\n\t\t\t\tao->o |= ((reg1 & 0x7) << 8);\n\t\t\t\tao->o |= ((reg1 & 0x8) << 12);\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\t\t\tao->o = 0xb0eb000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"cps\", ID_BIT | IE_BIT) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER: {\n\t\t\tst8 aif = iflag(ao->a[0]);\n\t\t\tif (aif == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x60b6;\n\t\t\t\tao->o |= aif << 8;\n\t\t\t\tif (m & ID_BIT) {\n\t\t\t\t\tao->o |= 1 << 12;\n\t\t\t\t}\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[1] = \"0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_OTHER_CONST: {\n\t\t\tst8 aif = iflag(ao->a[0]);\n\t\t\tut8 mode = getnum (ao->a[1]);\n\t\t\tif ((mode > 31) || (aif == -1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xaff30085;\n\t\t\tao->o |= mode << 8;\n\t\t\tao->o |= aif << 13;\n\t\t\tif (m & ID_BIT) {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_CONST: {\n\t\t\tut8 mode = getnum (ao->a[0]);\n\t\t\tif ((m & ID_BIT) || (m & IE_BIT) || (mode > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xaff30081;\n\t\t\tao->o |= mode << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"dbg\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif (option > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xaff3f080;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"dmb\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff35f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tif (strcmpnull (ao->a[0], \"sy\")) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->a[0] = \"15\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif (option != 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xbff3508f;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"dsb\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff34f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tif (!strcmpnull ((ao->a[0] = parse_hints(ao->a[0])), \"-1\")) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif ((option != 6) && (option != 7) && (option != 14) && (option != 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xbff3408f;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"eor\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST:\n\t\t\tstd_opt_2 (ao);\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 imm = getthimmed12 (ao->a[2]);\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x80f00000;\n\t\t\tao->o |= imm;\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x4040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG:\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x80ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"isb\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tao->o = 0xbff36f8f;\n\t\t\treturn 4;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tif (strcmpnull (ao->a[0], \"sy\")) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->a[0] = \"15\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 option = getnum (ao->a[0]);\n\t\t\tif (option != 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xbff3608f;\n\t\t\tao->o |= option << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = itmask (ao->op))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER: {\n\t\t\tut16 cond = 0;\n\t\t\tut16 i;\n\t\t\t\n\t\t\tconst char *conds[] = {\n\t\t\t\t\"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n\t\t\t\t\"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\", 0\n\t\t\t};\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tfor (i = 0; conds[i]; i++) {\n\t\t\t\tif (!(strcmpnull(ao->a[0], conds[i]))) {\n\t\t\t\t\tcond = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == 16) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00bf;\n\t\t\tao->o |= cond << 12;\n\n\t\t\tut8 nrcs = (m & 0x30) >> 4;\n\t\t\tut8 thiset = 0;\n\n\t\t\tfor (i = 0; i < nrcs; i++) {\n\t\t\t\tthiset = ((m & (1 << (3 - i))) >> (3 - i));\n\t\t\t\tao->o |= ((cond & 0x1) ^ thiset) << (11 - i);\n\t\t\t}\n\t\t\tao->o |= 1 << (11 - i);\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldc\", TWO_BIT | L_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 proc = getcoproc (ao->a[0]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[2]);\n\t\t\tst32 imm = getnummemend (ao->a[3]);\n\t\t\tao->o = 0x10ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (imm < 0) {\n\t\t\t\timm = -imm;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tif ((proc > 15) || (reg1 > 15) || (reg2 > 15) || (imm > 1024) || (imm % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= proc;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= (imm >> 2) << 8;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK:\n\t\t\tao->a[3] = \"0\";\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK_CONST: {\n\t\t\tut8 proc = getcoproc (ao->a[0]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[2]);\n\t\t\tst32 imm = getnum (ao->a[3]);\n\t\t\tao->o = 0x30ec0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (imm < 0) {\n\t\t\t\timm = -imm;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tif ((proc > 15) || (reg1 > 15) || (reg2 > 15) || (imm > 1024) || (imm % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= proc;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= (imm >> 2) << 8;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 proc = getcoproc (ao->a[0]);\n\t\t\tut8 reg1 = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[2]);\n\t\t\tst32 imm = getnummemendbang (ao->a[3]);\n\t\t\tao->o = 0x30ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (imm < 0) {\n\t\t\t\timm = -imm;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tif ((proc > 15) || (reg1 > 15) || (reg2 > 15) || (imm > 1024) || (imm % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= proc;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= (imm >> 2) << 8;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldm\", DB_BIT | EA_BIT | IA_BIT | FD_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REGBANG_LIST: {\n\t\t\tut8 reg1 = getregmembang (ao->a[0]);\n\t\t\tut32 list = getreglist (ao->a[1]);\n\t\t\tif (!((m & DB_BIT) || (m & EA_BIT)) && !(list & 0xff00) && (reg1 < 8) && !(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x00c8;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tif (list & (1 << reg1)) {\n\t\t\t\t\tlist ^= 1 << (reg1);\n\t\t\t\t}\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\t\t\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (list & 0x2000) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((m & DB_BIT) || (m & EA_BIT)) {\n\t\t\t\tao->o = 0x30e90000;\n\t\t\t} else {\n\t\t\t\t// ldmia is the default!\n\t\t\t\tao->o = 0xb0e80000;\n\t\t\t}\n\t\t\t\t\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_LIST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 list = getreglist (ao->a[1]);\n\t\t\tif (!((m & DB_BIT) || (m & EA_BIT)) && !(list & 0xff00) && (reg1 < 8) && !(m & DOTW_BIT)) {\n\t\t\t\tao->o = 0x00c8;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= 1 << (reg1 + 8);\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (list & 0x2000) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((m & DB_BIT) || (m & EA_BIT)) {\n\t\t\t\tao->o = 0x10e90000;\n\t\t\t} else {\n\t\t\t\tao->o = 0x90e80000;\n\t\t\t}\n\t\t\t\t\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldr\", B_BIT | H_BIT | D_BIT | T_BIT | S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 ldrsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tif ((m & S_BIT) && !(m & (B_BIT | H_BIT))) {\n\t\t\treturn -1;\n\t\t}\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST:\n\t\t\tao->a[2] = ao->a[1];\n\t\t\tstrcat (ao->a[2],\"]\");\n\t\t\tao->a[1] = \"[r15\";\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREGBRACK:\n\t\t\tif (ao->a[2] == NULL) { // double fallthrough\n\t\t\t\tao->a[1][strlen (ao->a[1]) -1] = '\\0';\n\t\t\t\tao->a[2] = \"0]\";\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tst32 num = getnummemend (ao->a[2]);\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x50f8000e;\n\t\t\t\t\tao->o |= num << 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tif (reg2 == 15) {\n\t\t\t\t\tif ((num > 4095) || (num < -4095)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif ((reg1 < 8) && (num < 1024) && (num % 4 == 0)) {\n\t\t\t\t\t\tao->o = 0x0048;\n\t\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x5ff80000;\n\t\t\t\t\tif (num < 0) {\n\t\t\t\t\t\tnum = -num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0x0f00) >> 8;\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t\tif ((reg2 == 13) && (reg1 < 8) && (num >= 0) && (num < 1024) && (num % 4 == 0) && (!(m & DOTW_BIT))) {\n\t\t\t\t\tao->o = 0x0098;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tif ((num >= 0) && (num < 128) && (num % 4 == 0)) {\n\t\t\t\t\tao->o = 0x0068;\n\t\t\t\t\tao->o |= (num >> 4);\n\t\t\t\t\tao->o |= ((num >> 2) & 0x3) << 14;\n\t\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((num > 4095) || (num < -1023)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (num >= 0) {\n\t\t\t\t\tao->o = 0xd0f80000;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tao->o = 0x50f8000c;\n\t\t\t\tao->o |= (-num & 0xff) << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t} else\n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x10f8000e;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= num << 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tif (reg2 == 15) {\n\t\t\t\t\tif ((num > 4095) || (num < -4095)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x1ff80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tif (num < 0) {\n\t\t\t\t\t\tnum = -num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0x0f00) >> 8;\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t\tif ((num >= 0) && (num < 32) && (!(m & S_BIT))) {\n\t\t\t\t\tao->o = 0x0078;\n\t\t\t\t\tao->o |= (num >> 2);\n\t\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((num > 4095) || (num < -255)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (num >= 0) {\n\t\t\t\t\tao->o = 0x90f80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tao->o = 0x10f8000c;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t}\n\t\t\t\tao->o |= -num << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t} else\n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x30f8000e;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= num << 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tif (reg2 == 15) {\n\t\t\t\t\tif ((num > 4095) || (num < -4095)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tao->o = 0x3ff80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tif (num < 0) {\n\t\t\t\t\t\tnum = -num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0x0f00) >> 8;\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t\tif ((num >= 0) && (num < 64) && (num % 2 == 0) && (!(m & S_BIT))) {\n\t\t\t\t\tao->o = 0x0088;\n\t\t\t\t\tao->o |= (num >> 3);\n\t\t\t\t\tao->o |= ((num >> 1) & 0x3) << 14;\n\t\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((num > 4095) || (num < -255)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (num >= 0) {\n\t\t\t\t\tao->o = 0xb0f80000;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= (num & 0xff) << 8;\n\t\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t\t}\n\t\t\t\tao->o = 0x30f8000c;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 16;\n\t\t\t\t}\n\t\t\t\tao->o |= -num << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\t\t\t\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[1]);\n\t\t\tst32 num = getnum (ao->a[2]);\n\t\t\tif ((num < -255) || (num > 255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->o = 0x50f80009;\n\t\t\t} else \n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0x10f80009;\n\t\t\t} else \n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0x30f80009;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 16;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tst32 num = getnummemendbang (ao->a[2]);\n\t\t\tif ((num < -255) || (num > 255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->o = 0x50f8000d;\n\t\t\t} else \n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0x10f8000d;\n\t\t\t} else \n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0x30f8000d;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 16;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_REGBRACK: {\n\t\t\tut8 reg3 = getregmemend (ao->a[2]);\n\t\t\tif (reg3 < 8) {\n\t\t\t\tif (ldrsel == 0) {\n\t\t\t\t\tao->o = 0x0058;\n\t\t\t\t} else\n\t\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o = 0x0056;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o = 0x005c;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o = 0x005e;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o = 0x005a;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tao->o |= (reg3 & 0x4) >> 2;\n\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tao->a[2][strlen (ao->a[2]) -1] = '\\0';\n\t\t\tao->a[3] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = getshiftmemend (ao->a[3]);\n\n\t\t\tshift >>= 2;\n\t\t\tif (shift & 0xffffcfff) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->o = 0x50f80000;\n\t\t\t} else\n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0x10f80000;\n\t\t\t} else\n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0x30f80000;\n\t\t\t} else\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 16;\n\t\t\t}\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tao->a[2][strlen (ao->a[2]) -1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((num > 1020) || (num < -1020) || (num % 4 != 0) || (ldrsel != D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x50e90000;\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\tst32 num = getnum (ao->a[3]);\n\t\t\tif ((num > 1020) || (num < -1020) || (num % 4 != 0) || (ldrsel != D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x70e80000;\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemendbang (ao->a[3]);\n\t\t\tif ((num > 1020) || (num < -1020) || (num % 4 != 0) || (ldrsel != D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x70e90000;\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ldrex\", B_BIT | H_BIT | D_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 ldrsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[1]);\n\t\t\t\n\t\t\tif (ldrsel == B_BIT) {\n\t\t\t\tao->o = 0xd0e84f0f;\n\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\tao->o |= reg2 << 24;\n\t\t\t\treturn 4;\n\t\t\t} else\n\t\t\tif (ldrsel == H_BIT) {\n\t\t\t\tao->o = 0xd0e85f0f;\n\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\tao->o |= reg2 << 24;\n\t\t\t\treturn 4;\n\t\t\t} else\n\t\t\tif (ldrsel == 0) {\n\t\t\t\tao->a[1][strlen (ao->a[1]) - 1] = '\\0';\n\t\t\t\tao->a[2] = \"0]\";\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACK: {\n\t\t\tst32 num = getnummemend (ao->a[2]);\n\t\t\tif ((ldrsel != 0) || (num < 0) || (num > 1020) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x50e8000f;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\tif (!(ldrsel & D_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xd0e87f00;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\treturn 4;\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"lsl\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\t\t\tif (num > 32) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x0000;\t\t\t\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\tao->o |= (num & 0x03) << 14;\n\t\t\t\tao->o |= num >> 2;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x4fea0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (num >> 2) << 4;\n\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x8040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x00fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\t\t\n\tif ((m = opmask (ao->op, \"lsr\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\t\t\tif (num > 32) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x0008;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\tao->o |= (num & 0x03) << 14;\n\t\t\t\tao->o |= num >> 2;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x4fea1000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (num >> 2) << 4;\n\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xc040;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x20fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mcr\", R_BIT | TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG: {\n\t\t\tao->a[5] = \"0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG_CONST: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc1 = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 coreg1 = getcoprocreg (ao->a[3]);\n\t\t\tut32 coreg2 = getcoprocreg (ao->a[4]);\n\t\t\tut32 opc2 = getnum (ao->a[5]);\n\n\t\t\tif ((coproc > 15) || (opc1 > 7) || (reg1 > 15) || (coreg1 > 15) || (coreg2 > 15) || (opc2 > 7) || (m & R_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x00ee1000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc1 << 29;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= coreg1 << 24;\n\t\t\tao->o |= coreg2 << 8;\n\t\t\tao->o |= opc2 << 13;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_CONST_REG_REG_COREG: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 reg2 = getreg (ao->a[3]);\n\t\t\tut32 coreg = getcoprocreg (ao->a[4]);\n\n\t\t\tif ((coproc > 15) || (opc > 15) || (reg1 > 15) || (reg2 > 15) || (coreg > 15) || (!(m & R_BIT))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40ec0000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc << 12;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= coreg << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mla\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut32 reg4 = getreg (ao->a[3]);\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00fb0000;\n\t\t\tao->o |= reg4 << 4;\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mls\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut32 reg4 = getreg (ao->a[3]);\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00fb1000;\n\t\t\tao->o |= reg4 << 4;\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mov\", S_BIT | W_BIT | T_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getnum (ao->a[1]);\n\n\t\t\tif (reg1 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((m & W_BIT) || (m & T_BIT)) {\n\t\t\t\tut32 wnum = getnum (ao->a[1]);\n\t\t\t\tif (wnum > 65535) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x40f20000;\n\t\t\t\tif (m & T_BIT) {\n\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t}\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= getthzeroimmed16 (wnum);\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\t\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((num < 256) && (reg1 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0020;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\t\n\t\t\tao->o = 0x4ff00000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= getthimmed12 (ao->a[1]);\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tut32 reg2 = getreg (ao->a[1]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((!(m & S_BIT)) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0046;\n\t\t\t\tao->o |= (reg1 & 0x7) << 8;\n\t\t\t\tao->o |= (reg1 & 0x8) << 12;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tif ((reg1 < 8) && (reg2 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x4fea0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"mrc\", TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG: {\n\t\t\tao->a[5] = \"0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_CONST_REG_COREG_COREG_CONST: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc1 = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 coreg1 = getcoprocreg (ao->a[3]);\n\t\t\tut32 coreg2 = getcoprocreg (ao->a[4]);\n\t\t\tut32 opc2 = getnum (ao->a[5]);\n\n\t\t\tif ((coproc > 15) || (opc1 > 7) || (reg1 > 15) || (coreg1 > 15) || (coreg2 > 15) || (opc2 > 7)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10ee1000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc1 << 29;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= coreg1 << 24;\n\t\t\tao->o |= coreg2 << 8;\n\t\t\tao->o |= opc2 << 13;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mrrc\", TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_CONST_REG_REG_COREG: {\n\t\t\tut32 coproc = getcoproc (ao->a[0]);\n\t\t\tut32 opc = getnum (ao->a[1]);\n\t\t\tut32 reg1 = getreg (ao->a[2]);\n\t\t\tut32 reg2 = getreg (ao->a[3]);\n\t\t\tut32 coreg = getcoprocreg (ao->a[4]);\n\n\t\t\tif ((coproc > 15) || (opc > 15) || (reg1 > 15) || (reg2 > 15) || (coreg > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x50ec0000;\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= opc << 12;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= coreg << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mrs\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_OTHER: {\n\t\t\tut32 reg1 = getreg (ao->a[0]);\n\t\t\tr_str_case (ao->a[1], false);\n\n\t\t\tif (reg1 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((!strcmp(ao->a[1], \"cpsr\")) || (!strcmp(ao->a[1], \"apsr\"))) {\n\t\t\t\tao->o = 0xeff30080;\n\t\t\t\tao->o |= reg1;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif (!strcmp(ao->a[1], \"spsr\")) {\n\t\t\t\tao->o = 0xfff30080;\n\t\t\t\tao->o |= reg1;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"msr\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER_REG: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tut8 spsr = 0;\n\t\t\tut8 bank = interpret_msrbank (ao->a[0], &spsr);\n\t\t\tut32 reg1 = getreg (ao->a[1]);\n\n\t\t\tif ((bank == 0) || (reg1 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x80f30080;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= bank;\n\t\t\tif (spsr != 0) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mul\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\n\t\t\tao->o = 0x4043;\n\t\t\tif ((reg1 == reg3) && (std_16bit_2reg (ao, m))) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0x00fb00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"mvn\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x6ff00000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= num;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xc043;\n\t\t\tif ((shift == 0) && (std_16bit_2reg (ao, m))) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0x6fea0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"nop\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30080;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tao->o = 0x00bf;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"orn\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x60f00000;\n\t\t\tao->o |= num;\n\t\t\treturn (std_32bit_2reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x60ea0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"orr\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40f00000;\n\t\t\tao->o |= num;\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0043;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x40ea0000;\n\t\t\treturn (std_32bit_3reg (ao, m, true));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"pkh\", BT_BIT | TB_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & TB_BIT) {\n\t\t\t\tao->a[3] = \"asr 0\";\n\t\t\t} else\n\t\t\tif (m & BT_BIT) {\n\t\t\t\tao->a[3] = \"lsl 0\";\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (((m & TB_BIT) && ((shift & 0x00003000) != 0x00002000)) || ((m & BT_BIT) && ((shift & 0x00003000) != 0)) || ((m & (TB_BIT | BT_BIT)) == 0)) {\t\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xc0ea0000;\n\t\t\treturn (std_32bit_3reg (ao, m, true));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"pld\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tst32 num = getnummemend (ao->a[1]);\n\n\t\t\tif (reg1 == 15) {\n\t\t\t\tif ((num < -4095) || (num > 4095)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x1ff800f0;\n\t\t\t\tif (num > 0) {\n\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t} else {\n\t\t\t\t\tnum = -num;\n\t\t\t\t}\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg1 > 15) || (num < -255) || (num > 4095)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num > 0) {\n\t\t\t\tao->o = 0x90f800f0;\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\tao->o |= reg1 << 24;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tnum = -num;\n\t\t\tao->o = 0x10f800fc;\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_BRACKREG_REGBRACK: {\n\t\t\tao->a[1][strlen (ao->a[1]) - 1] = '\\0';\n\t\t\tao->a[2] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = getshiftmemend (ao->a[2]) >> 2;\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || ((shift & 0xffffcfff) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10f800f0;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"pli\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tst32 num = getnummemend (ao->a[1]);\n\n\t\t\tif (reg1 == 15) {\n\t\t\t\tif ((num < -4095) || (num > 4095)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o = 0x1ff900f0;\n\t\t\t\tif (num > 0) {\n\t\t\t\t\tao->o |= 1 << 31;\n\t\t\t\t} else {\n\t\t\t\t\tnum = -num;\n\t\t\t\t}\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg1 > 15) || (num < -255) || (num > 4095)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num > 0) {\n\t\t\t\tao->o = 0x90f900f0;\n\t\t\t\tao->o |= (num & 0x0ff) << 8;\n\t\t\t\tao->o |= (num & 0xf00) >> 8;\n\t\t\t\tao->o |= reg1 << 24;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tnum = -num;\n\t\t\tao->o = 0x10f900fc;\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_BRACKREG_REGBRACK: {\n\t\t\tao->a[1][strlen (ao->a[1]) -1] = '\\0';\n\t\t\tao->a[2] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = getshiftmemend (ao->a[2]) >> 2;\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || ((shift & 0xffffcfff) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10f900f0;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"pop\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_LIST: {\n\t\t\tst32 list = getreglist (ao->a[0]);\n\t\t\tif ((list <= 0) || ((list & (1 << 13)) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((!(m & DOTW_BIT)) && ((list & 0x00007f00) == 0)) {\n\t\t\t\tao->o = 0x00bc;\n\t\t\t\tao->o |= (list & 0x8000) >> 15;\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0xbde80000;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"push\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_LIST: {\n\t\t\tst32 list = getreglist (ao->a[0]);\n\t\t\tif ((list <= 0) || ((list & 0x0000a000) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((!(m & DOTW_BIT)) && ((list & 0x00001f00) == 0)) {\n\t\t\t\tao->o = 0x00b4;\n\t\t\t\tao->o |= (list & 0x4000) >> 14;\n\t\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->o = 0x2de90000;\n\t\t\tao->o |= (list & 0xff00) >> 8;\n\t\t\tao->o |= (list & 0xff) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa10f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa10f0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x80fa80f0;\n\t\t\t}\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa10f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qdadd\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x80fa90f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qdsub\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x80fab0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa10f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"qsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa10f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa10f0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x80faa0f0;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rbit\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = ao->a[1];\n\t\t\tao->o = 0x90faa0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rev\", SIXTEEN_BIT | SH_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x40ba;\n\t\t\t} else\n\t\t\tif (m & SH_BIT) {\n\t\t\t\tao->o = 0xc0ba;\n\t\t\t} else {\n\t\t\t\tao->o = 0x00ba;\n\t\t\t}\n\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa90f0;\n\t\t\t} else\n\t\t\tif (m & SH_BIT) {\n\t\t\t\tao->o = 0x90fab0f0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x90fa80f0;\n\t\t\t}\n\t\t\tao->a[2] = ao->a[1];\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rfe\", IA_BIT | FD_BIT | DB_BIT | EA_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 wb = 0;\n\t\tswitch (argt) {\n\t\tcase THUMB_REGBANG: {\n\t\t\tao->a[0][strlen (ao->a[0]) - 1] = '\\0';\n\t\t\twb = 0x20000000;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\n\t\t\tif (reg1 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((m & DB_BIT) || (m & EA_BIT)) {\n\t\t\t\tao->o = 0x10e800c0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x90e900c0;\n\t\t\t}\n\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= wb;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ror\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (num > 31) || (num < 1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x4fea3000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\tao->o |= (num & 0x1c) << 2;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0xc041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x60fa00f0;\n\t\t\treturn (std_32bit_3reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rrx\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x4fea3000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\tif (m & S_BIT) {\n\t\t\t\tao->o |= 1 << 28;\n\t\t\t}\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"rsb\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x4042;\n\t\t\tif ((num == 0) && std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->o = 0xc0f10000;\n\t\t\tao->o |= num;\n\t\t\treturn (std_32bit_2reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0xc0eb0000;\n\t\t\treturn (std_32bit_3reg (ao, m, true));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa00f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa00f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sbc\", S_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x8041;\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tao->o = 0x60eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tao->o = 0x60f10000;\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[2]);\n\n\t\t\tif (err) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= num;\n\t\t\t\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif (( m = opmask (ao->op, \"sbfx\", 0) )) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST_CONST: {\n\t\t\tut32 lsb = getnum (ao->a[2]);\n\t\t\tut32 width = getnum (ao->a[3]);\n\t\t\tut32 msb = lsb + width - 1;\n\t\t\tif ((lsb > 31) || (msb > 31)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x40f30000;\n\t\t\tao->o |= ((lsb & 0x1c) << 2);\n\t\t\tao->o |= ((lsb & 0x3) << 14);\n\t\t\tao->o |= ((width - 1) << 8);\n\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sdiv\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x90fbf0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sel\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa80f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"setend\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_OTHER: {\n\t\t\tr_str_case (ao->a[0], false);\n\t\t\tao->o = 0x50b6;\n\t\t\tif (!(strcmpnull (ao->a[0], \"be\"))) {\n\t\t\t\tao->o |= 1 << 11;\n\t\t\t\treturn 2;\n\t\t\t} else\n\t\t\tif (!(strcmpnull (ao->a[0], \"le\"))) {\n\t\t\t\treturn 2;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t        }\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sev\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE:\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30480;\n\t\t\t\treturn 4;\n\t\t\t} else {\n\t\t\t\tao->o = 0x40bf;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shadd\", EIGHT_BIT | SIXTEEN_BIT ))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa20f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa20f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa20f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa20f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"shsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa20f0;\n\t\t\t} else\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa20f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smc\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\terr = false;\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\t\n\t\t\tif (err || (num > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xf0f70080;\n\t\t\tao->o |= num << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smla\", BB_BIT | BT_BIT | TB_BIT | TT_BIT | WB_BIT | WT_BIT | L_BIT | D_BIT | X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15) || (m & DOTN_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (m & L_BIT) {\n\t\t\t\tif (m & BB_BIT) {\n\t\t\t\t\tao->o = 0xc0fb8000;\n\t\t\t\t} else\n\t\t\t\tif (m & BT_BIT) {\n\t\t\t\t\tao->o = 0xc0fb9000;\n\t\t\t\t} else\n\t\t\t\tif (m & TB_BIT) {\n\t\t\t\t\tao->o = 0xc0fba000;\n\t\t\t\t} else\n\t\t\t\tif (m & TT_BIT) {\n\t\t\t\t\tao->o = 0xc0fbb000;\n\t\t\t\t} else\n\t\t\t\tif (m & D_BIT) {\n\t\t\t\t\tao->o = 0xc0fbc000;\n\t\t\t\t\tif (m & X_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 12;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tao->o = 0xc0fb0000;\n\t\t\t\t}\n\t\t\t\tao->o |= reg1 << 4;\n\t\t\t\tao->o |= reg2;\n\t\t\t\tao->o |= reg3 << 24;\n\t\t\t\tao->o |= reg4 << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tif (m & BB_BIT) {\n\t\t\t\tao->o = 0x10fb0000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & BT_BIT) {\n\t\t\t\tao->o = 0x10fb1000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & TB_BIT) {\n\t\t\t\tao->o = 0x10fb2000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & TT_BIT) {\n\t\t\t\tao->o = 0x10fb3000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & D_BIT) {\n\t\t\t\tao->o = 0x20fb0000;\n\t\t\t\tif (m & X_BIT) {\n\t\t\t\t\tao->o |= 1 << 12;\n\t\t\t\t}\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & WB_BIT) {\n\t\t\t\tao->o = 0x30fb0000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\tif (m & WT_BIT) {\n\t\t\t\tao->o = 0x30fb1000;\n\t\t\t\tao->o |= reg4 << 4;\n\t\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t}\n\t\t\treturn -1;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smlsd\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x40fb0000;\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smlsld\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15) || (m & DOTN_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0xd0fbc000;\n\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smmla\", R_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x50fb0000;\n\t\t\tif (m & R_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smmls\", R_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif (reg4 > 15) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x60fb0000;\n\t\t\tif (m & R_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smmul\", R_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x50fb00f0;\n\t\t\tif (m & R_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smuad\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x20fb00f0;\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smul\", BB_BIT | BT_BIT | TB_BIT | TT_BIT | WB_BIT | WT_BIT | L_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & BB_BIT) {\n\t\t\t\tao->o = 0x10fb00f0;\n\t\t\t} else\n\t\t\tif (m & BT_BIT) {\n\t\t\t\tao->o = 0x10fb10f0;\n\t\t\t} else\n\t\t\tif (m & TB_BIT) {\n\t\t\t\tao->o = 0x10fb20f0;\n\t\t\t} else\n\t\t\tif (m & TT_BIT) {\n\t\t\t\tao->o = 0x10fb30f0;\n\t\t\t} else\n\t\t\tif (m & WB_BIT) {\n\t\t\t\tao->o = 0x30fb00f0;\n\t\t\t} else\n\t\t\tif (m & WT_BIT) {\n\t\t\t\tao->o = 0x30fb10f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15) || (m & DOTN_BIT) || (!(m & L_BIT))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x80fb0000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"smusd\", X_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x40fb00f0;\n\t\t\tif (m & X_BIT) {\n\t\t\t\tao->o |= 1 << 12;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"srs\", DB_BIT | FD_BIT | IA_BIT | EA_BIT))) {\n\t\tut32 w = 0;\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONSTBANG: {\n\t\t\tao->a[0][strlen (ao->a[0]) - 1] = '\\0';\n\t\t\tw = 1;\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_CONST: {\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\tif (num > 31) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((m & DB_BIT) || (m & FD_BIT)) {\n\t\t\t\tao->o = 0x0de800c0;\n\t\t\t} else {\n\t\t\t\tao->o = 0x8de900c0;\n\t\t\t}\t\t\t\t\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= w << 29;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ssat\", SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_CONST_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getnum (ao->a[1]) - 1;\n\t\t\tut8 reg2 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (err || (reg1 > 15) || (reg2 > 15) || (num > 31) || (shift & 0x00001000) || ((m & SIXTEEN_BIT) && shift)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (shift & 0x00002000) {\n\t\t\t\tshift |= 0x20000000;\n\t\t\t\tshift &= 0xffffdfff;\n\t\t\t}\n\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x20f30000;\n\t\t\t} else {\n\t\t\t\tao->o = 0x00f30000;\n\t\t\t}\n\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ssax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa00f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ssub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa00f0;\n\t\t\t} else\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa00f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else if ((m = opmask (ao->op, \"stc\", L_BIT | TWO_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK: {\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 coproc = getcoproc (ao->a[0]);\n\t\t\tut8 coreg = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((coproc > 15) || (coreg > 15) || (reg > 15) || (num > 4092) || (num < -4092) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t\tao->o = 0x00ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\t\t\t\t\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= coreg << 4;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREGBRACK_CONST: {\n\t\t\tut8 coproc = getcoproc (ao->a[0]);\n\t\t\tut8 coreg = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg = getregmemstartend (ao->a[2]);\n\t\t\tst32 num = getnum (ao->a[3]);\n\n\t\t\tif ((coproc > 15) || (coreg > 15) || (reg > 15) || (num > 4092) || (num < -4092) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t\tao->o = 0x20ec0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= coreg << 4;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_COPROC_COREG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 coproc = getcoproc (ao->a[0]);\n\t\t\tut8 coreg = getcoprocreg (ao->a[1]);\n\t\t\tut8 reg = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemendbang (ao->a[3]);\n\n\t\t\tif ((coproc > 15) || (coreg > 15) || (reg > 15) || (num > 4092) || (num < -4092) || (num % 4 != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t\tao->o = 0x20ed0000;\n\t\t\tif (m & L_BIT) {\n\t\t\t\tao->o |= 1 << 30;\n\t\t\t}\n\t\t\tif (m & TWO_BIT) {\n\t\t\t\tao->o |= 1 << 20;\n\t\t\t}\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= coproc;\n\t\t\tao->o |= coreg << 4;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else if ((m = opmask (ao->op, \"stm\", FD_BIT | DB_BIT | IA_BIT | EA_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tbool wb = false;\n\t\tswitch (argt) {\n\t\tcase THUMB_REGBANG_LIST: {\n\t\t\twb = true;\n\t\t\tao->a[0][strlen (ao->a[0]) - 1] = '\\0';\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_LIST: {\n\t\t\tut8 reg = getreg (ao->a[0]);\n\t\t\tst32 list = getreglist (ao->a[1]);\n\t\t\tif ((list <= 0) || ((list & 0x0000a000) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((!(m & DOTW_BIT)) && ((list & 0x0000ff00) == 0) && (!(m & (FD_BIT | DB_BIT))) && wb) {\n\t\t\t\tao->o = 0x00c0;\n\t\t\t\tao->o |= (list & 0x000000ff) << 8;\n\t\t\t\tao->o |= reg;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif ((m & (FD_BIT | DB_BIT | IA_BIT | EA_BIT)) == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif (m & (FD_BIT | DB_BIT)) {\n\t\t\t\tao->o = 0x00e90000;\n\t\t\t} else {\n\t\t\t\tao->o = 0x80e80000;\n\t\t\t}\n\n\t\t\tif (wb) {\n\t\t\t\tao->o |= 1 << 29;\n\t\t\t}\n\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= (list & 0x000000ff) << 8;\n\t\t\tao->o |= (list & 0x0000ff00) >> 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else if ((m = opmask (ao->op, \"str\", B_BIT | T_BIT | D_BIT | H_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 strsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_BRACKREGBRACK:\n\t\t\tif (ao->a[2] == NULL) { // double fallthrough\n\t\t\t\tao->a[1][strlen (ao->a[1]) -1] = '\\0';\n\t\t\t\tao->a[2] = \"0]\";\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tst32 num = getnummemend (ao->a[2]);\n\t\t\tif (m & T_BIT) {\n\t\t\t\tif ((num < 0) || (num > 255)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (strsel == 0) {\n\t\t\t\t\tao->o = 0x40f8000e;\n\t\t\t\t} else\n\t\t\t        if (strsel == H_BIT) {\n\t\t\t\t\tao->o = 0x20f8000e;\n\t\t\t\t} else\n\t\t\t        if (strsel == B_BIT) {\n\t\t\t\t\tao->o = 0x00f8000e;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t}\n\t\t\t\n\t\t\tif ((strsel == 0) && (reg2 == 13) && (num >= 0) && (num < 1024) && ((num % 4) == 0) && (reg1 < 8) & (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x0090;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tbool t1form = false;\n\t\t\tif ((strsel == 0) && (num < 128) && (num >= 0) && (num % 4 == 0)) {\n\t\t\t\tao->o = 0x0060;\n\t\t\t\tao->o |= (num >> 4);\n\t\t\t\tao->o |= ((num >> 2) & 0x3) << 14;\n\t\t\t\tt1form = true;\n\t\t\t}\n\t\t\tif ((strsel == B_BIT) && (num < 32) && (num >= 0)) {\n\t\t\t\tao->o = 0x0070;\n\t\t\t\tao->o |= (num >> 2);\n\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\tt1form = true;\n\t\t\t}\n\t\t\tif ((strsel == H_BIT) && (num < 64) && (num >= 0) && (num % 2 == 0)) {\n\t\t\t\tao->o = 0x0080;\n\t\t\t\tao->o |= (num >> 3);\n\t\t\t\tao->o |= ((num >> 1) & 0x3) << 14;\n\t\t\t\tt1form = true;\n\t\t\t}\n\t\t\tif (t1form) {\n\t\t\t\tif (mem_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ((num > 4095) || (num < -255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((num >= 0) && (num < 4096)) {\n\t\t\t\tif (strsel == 0) {\n\t\t\t\t\tao->o = 0xc0f80000;\n\t\t\t\t} else\n\t\t\t\tif (strsel == B_BIT) {\n\t\t\t\t\tao->o = 0x80f80000;\n\t\t\t\t} else\n\t\t\t\tif (strsel == H_BIT) {\n\t\t\t\t\tao->o = 0xa0f80000;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= (num >> 8);\n\t\t\t\tao->o |= (num & 0x000000ff) << 8;\n\t\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t\t}\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f8000c;\n\t\t\t} else\n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f8000c;\n\t\t\t} else\n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f8000c;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o |= -num << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstartend (ao->a[1]);\n\t\t\tst32 num = getnum (ao->a[2]);\n\n\t\t\tif ((num > 255) || (num < -255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f80009;\n\t\t\t} else \n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f80009;\n\t\t\t} else \n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f80009;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tst32 num = getnummemendbang (ao->a[2]);\n\n\t\t\tif ((num > 255) || (num < -255)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f8000d;\n\t\t\t} else \n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f8000d;\n\t\t\t} else \n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f8000d;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 1;\n\t\t\t}\n\t\t\tao->o |= num << 8;\n\t\t\treturn mem_32bit_2reg (ao, m);\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_BRACKREG_REGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tut8 reg3 = getregmemend (ao->a[2]);\n\t\t\tif ((reg1 < 8) && (reg2 < 8) && (reg3 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tif (strsel == 0) {\n\t\t\t\t\tao->o = 0x0050;\n\t\t\t\t} else\n\t\t\t\tif (strsel == B_BIT) {\n\t\t\t\t\tao->o = 0x0054;\n\t\t\t\t} else\n\t\t\t\tif (strsel == H_BIT) {\n\t\t\t\t\tao->o = 0x0052;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tao->o |= (reg3 >> 2);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"lsl 0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getregmemstart (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = getshiftmemend (ao->a[3]) >> 2;\n\t\t\t\n\t\t\tif (((shift & 0xffffcfff) != 0) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (strsel == 0) {\n\t\t\t\tao->o = 0x40f80000;\n\t\t\t} else \n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0x00f80000;\n\t\t\t} else \n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0x20f80000;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= shift;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (strsel != D_BIT) || (num > 1023) || (num < -1023) || ((num % 4) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40e90000;\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACKBANG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemendbang (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (strsel != D_BIT) || (num > 1023) || (num < -1023) || ((num % 4) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x60e90000;\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_BRACKREGBRACK_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\tst32 num = getnum (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (strsel != D_BIT) || (num > 1023) || (num < -1023) || ((num % 4) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x60e80000;\n\n\t\t\tif (num < 0) {\n\t\t\t\tnum = -num;\n\t\t\t} else {\n\t\t\t\tao->o |= 1 << 31;\n\t\t\t}\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"strex\", B_BIT | D_BIT | H_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut32 strsel = m & (B_BIT | H_BIT | D_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstartend (ao->a[2]);\n\t\t\t\n\t\t\tif ((strsel == D_BIT) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (strsel == B_BIT) {\n\t\t\t\tao->o = 0xc0e8400f;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 4;\n\t\t\t\tao->o |= reg3 << 24;\n\t\t\t\treturn 4;\n\t\t\t} else\n\t\t\tif (strsel == H_BIT) {\n\t\t\t\tao->o = 0xc0e8500f;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 4;\n\t\t\t\tao->o |= reg3 << 24;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tao->a[2][strlen (ao->a[2]) - 1] = '\\0';\n\t\t\tao->a[3] = \"0]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_BRACKREG_CONSTBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getregmemstart (ao->a[2]);\n\t\t\tst32 num = getnummemend (ao->a[3]);\n\n\t\t\tif ((strsel != 0) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (num < 0) || (num > 1023) || ((num % 4) !=0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x40e80000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 4;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= (num >> 2) << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG_REG_BRACKREGBRACK: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getregmemstartend (ao->a[3]);\n\n\t\t\tif ((strsel != D_BIT) || (reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xc0e87000;\n\t\t\tao->o |= reg1 << 8;\n\t\t\tao->o |= reg2 << 4;\n\t\t\tao->o |= reg3;\n\t\t\tao->o |= reg4 << 24;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\t}\n\t} else \n\tif ((m = opmask (ao->op, \"sub\", S_BIT | W_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 num = getnum (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((reg1 == 15) && (reg2 == 14) && (num < 256)) {\n\t\t\t\tao->o = 0xdef3008f;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tif (reg2 == 13) {\n\t\t\t\tif ((reg1 == 13) && (!(m & DOTW_BIT)) && (!(m & W_BIT)) && (num <= 4096) && (num % 4 == 0)) {\n\t\t\t\t\tao->o = 0x80b0;\n\t\t\t\t\tao->o |= (num >> 2) << 8;\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\terr = false;\n\t\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\t\t\n\t\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\t\tao->o = 0xadf10000;\n\t\t\t\t\tao->o |= thnum;\n\t\t\t\t\tao->o |= reg1;\n\t\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t\t}\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\n\t\t\t\tif (num > 4096) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0xadf20000;\n\t\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\t\tao->o |= reg1;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((reg1 < 8) && (reg2 < 8) && (!(m & DOTW_BIT)) && (!(m & W_BIT)) && (num < 8)) {\n\t\t\t\tao->o = 0x001e;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\tao->o |= (num & 0x3) << 14;\n\t\t\t\tao->o |= (num >> 2);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif ((reg1 < 8) && (reg1 == reg2) && (!(m & DOTW_BIT)) && (!(m & W_BIT)) && (num < 256)) {\n\t\t\t\tao->o = 0x0038;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\terr = false;\n\t\t\tut32 thnum = getthimmed12 (ao->a[2]);\n\t\t\t\n\t\t\tif (!err && (!(m & W_BIT))) {\n\t\t\t\tao->o = 0xa0f10000;\n\t\t\t\tao->o |= thnum;\n\t\t\t\treturn std_32bit_2reg (ao, m, false);\n\t\t\t}\n\n\t\t\tif (num > 4096) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xa0f20000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= getthzeroimmed12 (num);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT:\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (reg2 == 13) {\n\t\t\t\tao->o = 0xadeb0000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= reg3 << 8;\n\t\t\t\tao->o |= shift;\n\t\t\t\tif (m & S_BIT) {\n\t\t\t\t\tao->o |= 1 << 28;\n\t\t\t\t}\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tif ((shift == 0) && (reg1 < 8) && (reg2 < 8) && (reg3 < 8) && (!(m & DOTW_BIT))) {\n\t\t\t\tao->o = 0x001a;\n\t\t\t\tao->o |= reg1 << 8;\n\t\t\t\tao->o |= reg2 << 11;\n\t\t\t\tao->o |= (reg3 & 0x3) << 14;\n\t\t\t\tao->o |= (reg3 >> 2);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xa0eb0000;\n\t\t\treturn std_32bit_3reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"svc\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_CONST: {\n\t\t\tut32 num = getnum (ao->a[0]);\n\t\t\tif (num > 255) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tao->o = 0x00df;\n\t\t\tao->o |= num << 8;\n\t\t\treturn 2;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sxta\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif ((shift != 0) && ((shift & 0x0000f010) != 0x00003000)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\t\t\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x40fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x20fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x00fa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"sxt\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) && (reg2 > 15) && (shift != 0) && ((shift & 0x0000f010) != 0x00003000)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x40b2;\n\t\t\t\tif ((shift == 0) && std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tao->o = 0x4ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x2ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x00b2;\n\t\t\t\tif ((shift == 0) && std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tao->o = 0x0ffa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"tb\", B_BIT | H_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (B_BIT | H_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_BRACKREG_REGBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getregmemend (ao->a[1]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0xd0e800f0;\n\t\t\t\tao->o |= reg1 << 24;\n\t\t\t\tao->o |= reg2 << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\tao->a[1][strlen (ao->a[1]) - 1] = '\\0';\n\t\t\tao->a[2] = \"lsl 1]\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_BRACKREG_REG_SHIFTBRACK: {\n\t\t\tut8 reg1 = getregmemstart (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = getshiftmemend (ao->a[2]);\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (shift != 0x00004000) || (sufsel != H_BIT)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xd0e810f0;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= reg2 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"teq\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\n\t\t\tif (err || (reg > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x90f0000f;\n\t\t\tao->o |= reg << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tao->o = 0x90ea000f;\n\t\t\treturn std_32bit_2reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"tst\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\terr = false;\n\t\t\tut32 num = getthimmed12 (ao->a[1]);\n\n\t\t\tif (err || (reg1 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x10f0000f;\n\t\t\tao->o |= reg1 << 24;\n\t\t\tao->o |= num;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tcase THUMB_REG_REG: {\n\t\t\tao->o = 0x0042;\n\t\t\t\n\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tao->o = 0x10ea000f;\n\t\t\treturn std_32bit_2reg (ao, m, true);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (m & EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa40f0;\n\t\t\t} else\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa40f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa40f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"ubfx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_CONST_CONST: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 lsb = getnum (ao->a[2]);\n\t\t\tut32 widthm1 = getnum (ao->a[3]) - 1;\n\t\t\t\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (lsb > 31) || ((31 - lsb) <= widthm1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0xc0f30000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= (lsb & 0x1c) << 2;\n\t\t\tao->o |= (lsb & 0x3) << 14;\n\t\t\tao->o |= widthm1 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"udiv\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xb0fbf0f0;\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa60f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa60f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa60f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t\t\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa60f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uhsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa60f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa60f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"umaal\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xe0fb6000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"umlal\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xe0fb0000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"umull\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0xa0fb0000;\n\t\t\tao->o |= reg1 << 4;\n\t\t\tao->o |= reg2;\n\t\t\tao->o |= reg3 << 24;\n\t\t\tao->o |= reg4 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqadd\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0x80fa50f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0x90fa50f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqasx\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xa0fa50f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqsax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa50f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uqsub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa50f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa50f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usad8\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0x70fb00f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usada8\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG_REG_REG: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut8 reg3 = getreg (ao->a[2]);\n\t\t\tut8 reg4 = getreg (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (reg3 > 15) || (reg4 > 15)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tao->o = 0x70fb0000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= reg3 << 8;\n\t\t\tao->o |= reg4 << 4;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usat\", SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_CONST_REG: {\n\t\t\tif (m & SIXTEEN_BIT) {\n\t\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\t\tut32 num = getnum (ao->a[1]);\n\t\t\t\tut8 reg2 = getreg (ao->a[2]);\n\n\t\t\t\tif ((reg1 > 15) || (num > 15) || (reg2 > 15)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tao->o = 0xa0f30000;\n\t\t\t\tao->o |= reg1;\n\t\t\t\tao->o |= reg2 << 24;\n\t\t\t\tao->o |= num << 8;\n\t\t\t\treturn 4;\n\t\t\t}\n\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_CONST_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut32 num = getnum (ao->a[1]);\n\t\t\tut8 reg2 = getreg (ao->a[2]);\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif ((reg1 > 15) || (num > 31) || (reg2 > 15) || (m & SIXTEEN_BIT) || ((shift & 0x00001000) != 0)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o = 0x80f30000;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= (num & 0xf) << 8;\n\t\t\tao->o |= (num >> 4 ) << 12;\n\t\t\tao->o |= reg2 << 24;\n\t\t\tao->o |= (shift & 0x00002000) << 16;\n\t\t\tao->o |= (shift & 0x0000c070);\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usax\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->o = 0xe0fa40f0;\n\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"usub\", EIGHT_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (EIGHT_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tif (sufsel == EIGHT_BIT) {\n\t\t\t\tao->o = 0xc0fa40f0;\n\t\t\t} else \n\t\t\tif (sufsel == SIXTEEN_BIT) {\n\t\t\t\tao->o = 0xd0fa40f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn std_32bit_3reg (ao, m, false);\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uxta\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tstd_opt_2 (ao);\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG: {\n\t\t\tao->a[3] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tif (ao->a[3] == NULL) { // double fallthrough\n\t\t\t\tstd_opt_3 (ao);\n\t\t\t}\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_REG_SHIFT: {\n\t\t\tut32 shift = thumb_getshift (ao->a[3]);\n\n\t\t\tif (shift && ((shift & 0x0000f010) != 0x00003000)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x50fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x30fa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x10fa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\treturn (std_32bit_3reg (ao, m, false));\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"uxt\", B_BIT | H_BIT | SIXTEEN_BIT))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tut64 sufsel = m & (B_BIT | H_BIT | SIXTEEN_BIT);\n\t\tswitch (argt) {\n\t\tcase THUMB_REG_REG: {\n\t\t\tif ((sufsel == B_BIT) || (sufsel == H_BIT)) {\n\t\t\t\tif (sufsel == B_BIT) {\n\t\t\t\t\tao->o = 0xc0b2;\n\t\t\t\t} else {\n\t\t\t\t\tao->o = 0x80b2;\n\t\t\t\t}\n\t\t\t\tif (std_16bit_2reg (ao, m)) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tao->a[2] = \"lsl 0\";\n\t\t        }\n\t\t\t// intentional fallthrough\n\t\tcase THUMB_REG_REG_SHIFT: {\n\t\t\tut8 reg1 = getreg (ao->a[0]);\n\t\t\tut8 reg2 = getreg (ao->a[1]);\n\t\t\tut32 shift = thumb_getshift (ao->a[2]);\n\n\t\t\tif ((reg1 > 15) || (reg2 > 15) || (shift && ((shift & 0x0000f010) != 0x00003000))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (sufsel == B_BIT) {\n\t\t\t\tao->o = 0x5ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == (B_BIT | SIXTEEN_BIT)) {\n\t\t\t\tao->o = 0x3ffa80f0;\n\t\t\t} else\n\t\t\tif (sufsel == H_BIT) {\n\t\t\t\tao->o = 0x1ffa80f0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tao->o |= (shift & 0x00000060) << 7;\n\t\t\tao->o |= reg1;\n\t\t\tao->o |= reg2 << 8;\n\t\t\treturn 4;\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"wfe\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30280;\n\t\t\t\treturn 4;\n\t\t        } else {\n\t\t\t\tao->o = 0x20bf;\n\t\t\t\treturn 2;\n\t\t        }\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"wfi\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30380;\n\t\t\t\treturn 4;\n\t\t        } else {\n\t\t\t\tao->o = 0x30bf;\n\t\t\t\treturn 2;\n\t\t        }\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else\n\tif ((m = opmask (ao->op, \"yield\", 0))) {\n\t\tut64 argt = thumb_selector (ao->a);\n\t\tswitch (argt) {\n\t\tcase THUMB_NONE: {\n\t\t\tif (m & DOTW_BIT) {\n\t\t\t\tao->o = 0xaff30180;\n\t\t\t\treturn 4;\n\t\t        } else {\n\t\t\t\tao->o = 0x10bf;\n\t\t\t\treturn 2;\n\t\t        }\n\t\t        }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int findyz(int x, int *y, int *z) {\n\tint i, j;\n\tfor (i = 0;i < 0xff; i++) {\n\t\tfor (j = 0;j < 0xf;j++) {\n\t\t\tint v = i << j;\n\t\t\tif (v > x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (v == x) {\n\t\t\t\t*y = i;\n\t\t\t\t*z = 16 - (j / 2);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int arm_assemble(ArmOpcode *ao, ut64 off, const char *str) {\n\tint i, j, ret, reg, a, b;\n\tint coproc, opc;\n\tbool rex = false;\n\tint shift, low, high;\n\tfor (i = 0; ops[i].name; i++) {\n\t\tif (!strncmp (ao->op, ops[i].name, strlen (ops[i].name))) {\n\t\t\tao->o = ops[i].code;\n\t\t\tarm_opcode_cond (ao, strlen(ops[i].name));\n\t\t\tif (ao->a[0] || ops[i].type == TYPE_BKP) {\n\t\t\t\tswitch (ops[i].type) {\n\t\t\t\tcase TYPE_MEM:\n\t\t\t\t\tif (!strncmp (ops[i].name, \"strex\", 5)) {\n\t\t\t\t\t\trex = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (ops[i].name, \"str\") || !strcmp (ops[i].name, \"ldr\")) {\n\t\t\t\t\t\tif (!ao->a[2]) {\n\t\t\t\t\t\t\tao->a[2] = \"0\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgetrange (ao->a[0]);\n\t\t\t\t\tgetrange (ao->a[1]);\n\t\t\t\t\tgetrange (ao->a[2]);\n\t\t\t\t\tif (ao->a[0] && ao->a[1]) {\n\t\t\t\t\t\tchar rn[8];\n\t\t\t\t\t\tstrncpy (rn, ao->a[1], 7);\n\t\t\t\t\t\tint r0 = getreg (ao->a[0]);\n\t\t\t\t\t\tint r1 = getreg (ao->a[1]);\n\t\t\t\t\t\tif ((r0 < 0 || r0 > 15) || (r1 > 15 || r1 < 0)) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= r0 << 20;\n\t\t\t\t\t\tif (!strcmp (ops[i].name, \"strd\")) {\n\t\t\t\t\t\t\tr1 = getreg (ao->a[2]);\n\t\t\t\t\t\t\tif (r1 == -1) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tao->o |= r1 << 8;\n\t\t\t\t\t\t\tif (ao->a[3]) {\n\t\t\t\t\t\t\t\tchar *bracket = strchr (ao->a[3], ']');\n\t\t\t\t\t\t\t\tif (bracket) {\n\t\t\t\t\t\t\t\t\t*bracket = '\\0';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint num = getnum (ao->a[3]);\n\t\t\t\t\t\t\t\tao->o |= (num & 0x0f) << 24;\n\t\t\t\t\t\t\t\tao->o |= ((num >> 4) & 0x0f) << 16;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!strcmp (ops[i].name, \"strh\")) {\n\t\t\t\t\t\t\tao->o |= r1 << 8;\n\t\t\t\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\t\t\t\t\tif (reg != -1) {\n\t\t\t\t\t\t\t\t\tao->o |= reg << 24;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tao->o |= 1 << 14;\n\t\t\t\t\t\t\t\t\tao->o |= getnum (ao->a[2]) << 24;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tao->o |= 1 << 14;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rex) {\n\t\t\t\t\t\t\tao->o |= r1 << 24;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o |= r1 << 8; // delta\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = getreg (ao->a[2]);\n\t\t\t\t\tif (ret != -1) {\n\t\t\t\t\t\tif (rex) {\n\t\t\t\t\t\t\tao->o |= 1;\n\t\t\t\t\t\t\tao->o |= (ret & 0x0f) << 8;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o |= (strstr (str, \"],\")) ? 6 : 7;\n\t\t\t\t\t\t\tao->o |= (ret & 0x0f) << 24;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ao->a[3]) {\n\t\t\t\t\t\t\tshift = getshift (ao->a[3]);\n\t\t\t\t\t\t\tlow = shift & 0xFF;\n\t\t\t\t\t\t\thigh = shift & 0xFF00;\n\t\t\t\t\t\t\tao->o |= low << 24;\n\t\t\t\t\t\t\tao->o |= high << 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint num = getnum (ao->a[2]) & 0xfff;\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rex) {\n\t\t\t\t\t\t\tao->o |= 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o |= (strstr (str, \"],\")) ? 4 : 5;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= 1;\n\t\t\t\t\t\tao->o |= (num & 0xff) << 24;\n\t\t\t\t\t\tao->o |= ((num >> 8) & 0xf) << 16;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_IMM:\n\t\t\t\t\tif (*ao->a[0]++ == '{') {\n\t\t\t\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\t\t\t\tif (ao->a[j] && *ao->a[j]) {\n\t\t\t\t\t\t\t\tgetrange (ao->a[j]); // XXX filter regname string\n\t\t\t\t\t\t\t\treg = getreg (ao->a[j]);\n\t\t\t\t\t\t\t\tif (reg != -1) {\n\t\t\t\t\t\t\t\t\tif (reg < 8) {\n\t\t\t\t\t\t\t\t\t\tao->o |= 1 << (24 + reg);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tao->o |= 1 << (8 + reg);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= getnum (ao->a[0]) << 24; // ???\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_BRA:\n\t\t\t\t\tif ((ret = getreg (ao->a[0])) == -1) {\n\t\t\t\t\t\t// TODO: control if branch out of range\n\t\t\t\t\t\tret = (getnum (ao->a[0]) - (int)ao->off - 8) / 4;\n\t\t\t\t\t\tif (ret >= 0x00800000 || ret < (int)0xff800000) {\n\t\t\t\t\t\t\teprintf (\"Branch into out of range\\n\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= ((ret >> 16) & 0xff) << 8;\n\t\t\t\t\t\tao->o |= ((ret >> 8) & 0xff) << 16;\n\t\t\t\t\t\tao->o |= ((ret)&0xff) << 24;\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"This branch does not accept reg as arg\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_BKP:\n\t\t\t\t\tao->o |= 0x70 << 24;\n\t\t\t\t\tif (ao->a[0]) {\n\t\t\t\t\t\tint n = getnum (ao->a[0]);\n\t\t\t\t\t\tao->o |= ((n & 0xf) << 24);\n\t\t\t\t\t\tao->o |= (((n >> 4) & 0xff) << 16);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_BRR:\n\t\t\t\t\tif ((ret = getreg (ao->a[0])) == -1) {\n\t\t\t\t\t\tut32 dst = getnum (ao->a[0]);\n\t\t\t\t\t\tdst -= (ao->off + 8);\n\t\t\t\t\t\tif (dst & 0x2) {\n\t\t\t\t\t\t\tao->o = 0xfb;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tao->o = 0xfa;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdst /= 4;\n\t\t\t\t\t\tao->o |= ((dst >> 16) & 0xff) << 8;\n\t\t\t\t\t\tao->o |= ((dst >> 8) & 0xff) << 16;\n\t\t\t\t\t\tao->o |= ((dst)&0xff) << 24;\n\t\t\t\t\t\treturn 4;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= (getreg (ao->a[0]) << 24);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_HLT: {\n\t\t\t\t\tut32 o = 0, n = getnum (ao->a[0]);\n\t\t\t\t\to |= ((n >> 12) & 0xf) << 8;\n\t\t\t\t\to |= ((n >> 8) & 0xf) << 20;\n\t\t\t\t\to |= ((n >> 4) & 0xf) << 16;\n\t\t\t\t\to |= ((n) & 0xf) << 24;\n\t\t\t\t\tao->o |=o;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SWI:\n\t\t\t\tao->o |= (getnum (ao->a[0]) & 0xff) << 24;\n\t\t\t\tao->o |= ((getnum (ao->a[0]) >> 8) & 0xff) << 16;\n\t\t\t\tao->o |= ((getnum (ao->a[0]) >> 16) & 0xff) << 8;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UDF:\n\t\t\t\t{\n\t\t\t\t\t// e7f000f0 = udf 0\n\t\t\t\t\t// e7ffffff = udf 0xffff\n\t\t\t\t\tut32 n = getnum (ao->a[0]);\n\t\t\t\t\tao->o |= 0xe7;\n\t\t\t\t\tao->o |= (n & 0xf) << 24;\n\t\t\t\t\tao->o |= ((n >> 4) & 0xff) << 16;\n\t\t\t\t\tao->o |= ((n >> 12) & 0xf) << 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_ARI:\n\t\t\t\tif (!ao->a[2]) {\n\t\t\t\t\tao->a[2] = ao->a[1];\n\t\t\t\t\tao->a[1] = ao->a[0];\n\t\t\t\t}\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 8;\n\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\tao->o |= (reg != -1)? reg << 24 : 2 | getnum (ao->a[2]) << 24;\n\t\t\t\tif (ao->a[3]) {\n\t\t\t\t\tao->o |= getshift (ao->a[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SWP:\n\t\t\t\t{\n\t\t\t\tint a1 = getreg (ao->a[1]);\n\t\t\t\tif (a1) {\n\t\t\t\t\tao->o = 0xe1;\n\t\t\t\t\tao->o |= (getreg (ao->a[0]) << 4) << 16;\n\t\t\t\t\tao->o |= (0x90 + a1) << 24;\n\t\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\t\tao->o |= (getreg (ao->a[2] + 1)) << 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (0xff == ((ao->o >> 16) & 0xff)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MOV:\n\t\t\t\tif (!strcmpnull (ao->op, \"movs\")) {\n\t\t\t\t\tao->o = 0xb0e1;\n\t\t\t\t}\n\t\t\t\tao->o |= getreg (ao->a[0]) << 20;\n\t\t\t\tret = getreg (ao->a[1]);\n\t\t\t\tif (ret != -1) {\n\t\t\t\t\tao->o |= ret << 24;\n\t\t\t\t} else {\n\t\t\t\t\tint immed = getimmed8 (ao->a[1]);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= 0xa003 | (immed & 0xff) << 24 | (immed >> 8) << 16;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MOVW:\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= getreg (ao->a[0]) << 20;\n\t\t\t\tret = getnum (ao->a[1]);\n\n\t\t\t\tao->o |= 0x3 | ret << 24;\n\t\t\t\tao->o |= (ret & 0xf000) >> 4;\n\t\t\t\tao->o |= (ret & 0xf00) << 8;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MOVT:\n\t\t\t\tao->o |= getreg (ao->a[0]) << 20;\n\t\t\t\tret = getnum (ao->a[1]);\n\n\t\t\t\tao->o |= 0x4003 | ret << 24;\n\t\t\t\tao->o |= (ret & 0xf000) >> 4;\n\t\t\t\tao->o |= (ret & 0xf00) << 8;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_MUL:\n\t\t\t\tif (!strcmpnull (ao->op, \"mul\")) {\n\t\t\t\t\tret = getreg (ao->a[0]);\n\t\t\t\t\ta = getreg (ao->a[1]);\n\t\t\t\t\tb = getreg (ao->a[2]);\n\t\t\t\t\tif (b == -1) {\n\t\t\t\t\t\tb = a;\n\t\t\t\t\t\ta = ret;\n\t\t\t\t\t}\n\t\t\t\t\tif (ret == -1 || a == -1) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= ret << 8;\n\t\t\t\t\tao->o |= a << 24;\n\t\t\t\t\tao->o |= b << 16;\n\t\t\t\t} else {\n\t\t\t\t\tlow = getreg (ao->a[0]);\n\t\t\t\t\thigh = getreg (ao->a[1]);\n\t\t\t\t\ta = getreg (ao->a[2]);\n\t\t\t\t\tb = getreg (ao->a[3]);\n\t\t\t\t\tif (low == -1 || high == -1 || a == -1 || b == -1) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmpnull (ao->op, \"smlal\")) {\n\t\t\t\t\t\tao->o |= low << 20;\n\t\t\t\t\t\tao->o |= high << 8;\n\t\t\t\t\t\tao->o |= a << 24;\n\t\t\t\t\t\tao->o |= b << 16;\n\t\t\t\t\t} else if (!strncmp (ao->op, \"smla\", 4)) {\n\t\t\t\t\t\tif (low > 14 || high > 14 || a > 14) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tao->o |= low << 8;\n\t\t\t\t\t\tao->o |= high << 24;\n\t\t\t\t\t\tao->o |= a << 16;\n\t\t\t\t\t\tao->o |= b << 20;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tao->o |= low << 20;\n\t\t\t\t\t\tao->o |= high << 8;\n\t\t\t\t\t\tao->o |= a << 24;\n\t\t\t\t\t\tao->o |= b << 16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_TST:\n\t\t\t\ta = getreg (ao->a[0]);\n\t\t\t\tb = getreg (ao->a[1]);\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tint y, z;\n\t\t\t\t\tb = getnum (ao->a[1]);\n\t\t\t\t\tif (b >= 0 && b <= 0xff) {\n\t\t\t\t\t\tao->o = 0x50e3;\n\t\t\t\t\t\t// TODO: if (b>255) -> automatic multiplier\n\t\t\t\t\t\tao->o |= (a << 8);\n\t\t\t\t\t\tao->o |= ((b & 0xff) << 24);\n\t\t\t\t\t} else\n\t\t\t\t\tif (findyz (b, &y, &z)) {\n\t\t\t\t\t\tao->o = 0x50e3;\n\t\t\t\t\t\tao->o |= (y << 24);\n\t\t\t\t\t\tao->o |= (z << 16);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Parameter %d out0x3000a0e1 of range (0-255)\\n\", (int)b);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tao->o |= (a << 8);\n\t\t\t\t\tao->o |= (b << 24);\n\t\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\t\tao->o |= getshift (ao->a[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ao->a[2]) {\n\t\t\t\t\tint n = getnum (ao->a[2]);\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\teprintf (\"Invalid multiplier\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= (n >> 1) << 16;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SHFT:\n\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 16;\n\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 24;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_REV:\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 24;\n\n\t\t\t\tbreak;\n\t\t\tcase TYPE_ENDIAN:\n\t\t\t\tif (!strcmp (ao->a[0], \"le\")) {\n\t\t\t\t\tao->o |= 0;\n\t\t\t\t} else if (!strcmp (ao->a[0], \"be\")) {\n\t\t\t\t\tao->o |= 0x20000;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_COPROC:\n\t\t\t\t//printf (\"%s %s %s %s %s\\n\", ao->a[0], ao->a[1], ao->a[2], ao->a[3], ao->a[4] );\n\t\t\t\tif (ao->a[0]) {\n\t\t\t\t\tcoproc = getnum (ao->a[0] + 1);\n\t\t\t\t\tif (coproc == -1 || coproc > 9) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= coproc << 16;\n\t\t\t\t}\n\n\t\t\t\topc = getnum (ao->a[1]);\n\t\t\t\tif (opc == -1 || opc > 7) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= opc << 13;\n\n\t\t\t\treg = getreg (ao->a[2]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\t// coproc register 1\n\t\t\t\tconst char *a3 = ao->a[3];\n\t\t\t\tif (a3) {\n\t\t\t\t\tcoproc = getnum (a3 + 1);\n\t\t\t\t\tif (coproc == -1 || coproc > 15) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= coproc << 8;\n\t\t\t\t}\n\n\t\t\t\tconst char *a4 = ao->a[4];\n\t\t\t\tif (a4) {\n\t\t\t\t\tcoproc = getnum (ao->a[4] + 1);\n\t\t\t\t\tif (coproc == -1 || coproc > 15) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tao->o |= coproc << 24;\n\t\t\t\t}\n\n\t\t\t\tcoproc = getnum (ao->a[5]);\n\t\t\t\tif (coproc > -1) {\n\t\t\t\t\tif (coproc > 7) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// optional opcode\n\t\t\t\t\tao->o |= coproc << 29;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CLZ:\n\t\t\t\tao->o |= 1 << 28;\n\n\t\t\t\treg = getreg (ao->a[0]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 20;\n\n\t\t\t\treg = getreg (ao->a[1]);\n\t\t\t\tif (reg == -1 || reg > 14) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tao->o |= reg << 24;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\ntypedef int (*AssembleFunction)(ArmOpcode *, ut64, const char *);\nstatic AssembleFunction assemble[2] = { &arm_assemble, &thumb_assemble };\n\nut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[j]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\t//eprintf (\"armass: Unknown opcode (%s)\\n\", buf);\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}\n\n#ifdef MAIN\nvoid thisplay(const char *str) {\n\tchar cmd[32];\n\tint op = armass_assemble (str, 0x1000, 1);\n\tprintf (\"[%04x] %s\\n\", op, str);\n\tsnprintf (cmd, sizeof(cmd), \"rasm2 -d -b 16 -a arm %04x\", op);\n\tsystem (cmd);\n}\n\nvoid display(const char *str) {\n\tchar cmd[32];\n\tint op = armass_assemble (str, 0x1000, 0);\n\tprintf (\"[%08x] %s\\n\", op, str);\n\tsnprintf (cmd, sizeof(cmd), \"rasm2 -d -a arm %08x\", op);\n\tsystem (cmd);\n}\n\nint main() {\n\tthisplay (\"ldmia r1!, {r3, r4, r5}\");\n\tthisplay (\"stmia r1!, {r3, r4, r5}\");\n\tthisplay (\"bkpt 12\");\nreturn 0;\n\tthisplay(\"sub r1, r2, 0\");\n\tthisplay(\"sub r1, r2, 4\");\n\tthisplay(\"sub r1, r2, 5\");\n\tthisplay(\"sub r1, r2, 7\");\n\tthisplay(\"sub r3, 44\");\nreturn 0;\n#if 0\n\tthisplay(\"mov r0, 11\");\n\tthisplay(\"mov r0, r2\");\n\tthisplay(\"mov r1, r4\");\n\tthisplay(\"cmp r1, r2\");\n\tthisplay(\"cmp r3, 44\");\n\tthisplay(\"nop\");\n\tthisplay(\"svc 15\");\n\tthisplay(\"add r1, r2\");\n\tthisplay(\"add r3, 44\");\n\tthisplay(\"sub r1, r2, 3\");\n\tthisplay(\"sub r3, 44\");\n\tthisplay(\"tst r3,r4\");\n\tthisplay(\"bx r3\");\n\tthisplay(\"b 33\");\n\tthisplay(\"b 0\");\n\tthisplay(\"bne 44\");\n\tthisplay(\"and r2,r3\");\n#endif\n\t// INVALID thisplay(\"ldr r1, [pc, r2]\");\n\t// INVALID thisplay(\"ldr r1, [sp, r2]\");\n#if 0\n\tthisplay(\"ldr r1, [pc, 12]\");\n\tthisplay(\"ldr r1, [sp, 24]\");\n\tthisplay(\"ldr r1, [r2, r3]\");\n#endif\n\t// INVALID thisplay(\"str r1, [pc, 22]\");\n\t// INVALID thisplay(\"str r1, [pc, r2]\");\n\t// INVALID thisplay(\"str r1, [sp, r2]\");\n#if 0\n   0:   8991            ldrh    r1, [r2, #12]\n   2:   7b11            ldrb    r1, [r2, #12]\n   4:   8191            strh    r1, [r2, #12]\n   6:   7311            strb    r1, [r2, #12]\n#endif\n\tthisplay(\"ldrh r1, [r2, 8]\"); // aligned to 4\n\tthisplay(\"ldrh r1, [r3, 8]\"); // aligned to 4\n\tthisplay(\"ldrh r1, [r4, 16]\"); // aligned to 4\n\tthisplay(\"ldrh r1, [r2, 32]\"); // aligned to 4\n\tthisplay(\"ldrb r1, [r2, 20]\"); // aligned to 4\n\tthisplay(\"strh r1, [r2, 20]\"); // aligned to 4\n\tthisplay(\"strb r1, [r2, 20]\"); // aligned to 4\n\tthisplay(\"str r1, [sp, 20]\"); // aligned to 4\n\tthisplay(\"str r1, [r2, 12]\"); // OK\n\tthisplay(\"str r1, [r2, r3]\");\nreturn 0;\n#if 0\n\tdisplay(\"mov r0, 33\");\n\tdisplay(\"mov r1, 33\");\n\tdisplay(\"movne r0, 33\");\n\tdisplay(\"tst r0, r1, lsl #2\");\n\tdisplay(\"svc 0x80\");\n\tdisplay(\"sub r3, r1, r2\");\n\tdisplay(\"add r0, r1, r2\");\n\tdisplay(\"mov fp, 0\");\n\tdisplay(\"pop {pc}\");\n\tdisplay(\"pop {r3}\");\n\tdisplay(\"bx r1\");\n\tdisplay(\"bx r3\");\n\tdisplay(\"bx pc\");\n\tdisplay(\"blx fp\");\n\tdisplay(\"pop {pc}\");\n\tdisplay(\"add lr, pc, lr\");\n\tdisplay(\"adds r3, #8\");\n\tdisplay(\"adds r3, r2, #8\");\n\tdisplay(\"subs r2, #1\");\n\tdisplay(\"cmp r0, r4\");\n\tdisplay(\"cmp r7, pc\");\n\tdisplay(\"cmp r1, r3\");\n\tdisplay(\"mov pc, 44\");\n\tdisplay(\"mov pc, r3\");\n\tdisplay(\"push {pc}\");\n\tdisplay(\"pop {pc}\");\n\tdisplay(\"nop\");\n\tdisplay(\"ldr r1, [r2, 33]\");\n\tdisplay(\"ldr r1, [r2, r3]\");\n\tdisplay(\"ldr r3, [r4, r6]\");\n\tdisplay(\"str r1, [pc, 33]\");\n\tdisplay(\"str r1, [pc], 2\");\n\tdisplay(\"str r1, [pc, 3]\");\n\tdisplay(\"str r1, [pc, r4]\");\n\tdisplay(\"bx r3\");\n\tdisplay(\"bcc 33\");\n\tdisplay(\"blx r3\");\n\tdisplay(\"bne 0x1200\");\n\tdisplay(\"str r0, [r1]\");\n\tdisplay(\"push {fp,lr}\");\n\tdisplay(\"pop {fp,lr}\");\n\tdisplay(\"pop {pc}\");\n#endif\n\n   //10ab4:       00047e30        andeq   r7, r4, r0, lsr lr\n   //10ab8:       00036e70        andeq   r6, r3, r0, ror lr\n\n\tdisplay(\"andeq r7, r4, r0, lsr lr\");\n\tdisplay(\"andeq r6, r3, r0, ror lr\");\n//  c4:   e8bd80f0        pop     {r4, r5, r6, r7, pc}\n\tdisplay(\"pop {r4,r5,r6,r7,pc}\");\n\n\n#if 0\n\tdisplay(\"blx r1\");\n\tdisplay(\"blx 0x8048\");\n#endif\n\n#if 0\n\tdisplay(\"b 0x123\");\n\tdisplay(\"bl 0x123\");\n\tdisplay(\"blt 0x123\"); // XXX: not supported\n#endif\n\treturn 0;\n}\n#endif\n", "/* radare - LGPL - Copyright 2015-2018 - pancake */\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <r_util.h>\n\ntypedef enum optype_t {\n\tARM_NOTYPE = -1,\n\tARM_GPR = 1,\n\tARM_CONSTANT = 2,\n\tARM_FP = 4,\n\tARM_MEM_OPT = 8\n} OpType;\n\ntypedef enum regtype_t {\n\tARM_UNDEFINED = -1,\n\tARM_REG64 = 1,\n\tARM_REG32 = 2,\n\tARM_SP = 4,\n\tARM_PC = 8,\n\tARM_SIMD = 16\n} RegType;\n\ntypedef enum shifttype_t {\n\tARM_NO_SHIFT = -1,\n\tARM_LSL = 0,\n\tARM_LSR = 1,\n\tARM_ASR = 2\n} ShiftType;\n\ntypedef struct operand_t {\n\tOpType type;\n\tunion {\n\t\tstruct {\n\t\t\tint reg;\n\t\t\tRegType reg_type;\n\t\t\tut16 sp_val;\n\t\t};\n\t\tstruct {\n\t\t\tut64 immediate;\n\t\t\tint sign;\n\t\t};\n\t\tstruct {\n\t\t\tut64 shift_amount;\n\t\t\tShiftType shift;\n\t\t};\n\t\tstruct {\n\t\t\tut32 mem_option;\n\t\t};\n\t};\n} Operand;\n\n#define MAX_OPERANDS 7\n\ntypedef struct Opcode_t {\n\tchar *mnemonic;\n\tut32 op[3];\n\tsize_t op_len;\n\tut8 opcode[3];\n\tint operands_count;\n\tOperand operands[MAX_OPERANDS];\n} ArmOp;\n\nstatic int get_mem_option(char *token) {\n\t// values 4, 8, 12, are unused. XXX to adjust\n\tconst char *options[] = {\"sy\", \"st\", \"ld\", \"xxx\", \"ish\", \"ishst\",\n\t                         \"ishld\", \"xxx\", \"nsh\", \"nshst\", \"nshld\",\n\t                         \"xxx\", \"osh\", \"oshst\", \"oshld\", NULL};\n\tint i = 0;\n\twhile (options[i]) {\n\t\tif (!r_str_casecmp (token, options[i])) {\n\t\t\treturn 15 - i;\n\t\t}\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nstatic int countLeadingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x) {\n\t\tx >>= 1;\n\t\t--count;\n\t}\n\treturn count;\n}\n\nstatic int countTrailingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x > 0) {\n\t\tif ((x & 1) == 1) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tcount ++;\n\t\t\tx = x >> 1;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic int calcNegOffset(int n, int shift) {\n\tint a = n >> shift;\n\tif (a == 0) {\n\t\treturn 0xff;\n\t}\n\t// find first set bit then invert it and all\n\t// bits below it\n\tint t = 0x400;\n\twhile (!(t & a) && a != 0 && t != 0) {\n\t\tt = t >> 1;\n\t}\n\tt = t & (t - 1);\n\ta = a ^ t;\n\t// If bits below 32 are set\n\tif (countTrailingZeros(n) > shift) {\n\t\ta--;\n\t}\n\treturn 0xff & (0xff - a);\n}\n\nstatic int countLeadingOnes(ut32 x) {\n\treturn countLeadingZeros (~x);\n}\n\nstatic int countTrailingOnes(ut32 x) {\n\treturn countTrailingZeros (~x);\n}\n\nstatic bool isMask(ut32 value) {\n  return value && ((value + 1) & value) == 0;\n}\n\nstatic bool isShiftedMask (ut32 value) {\n  return value && isMask ((value - 1) | value);\n}\n\nstatic ut32 decodeBitMasks(ut32 imm) {\n\t// get element size\n\tint size = 32;\n\t// determine rot to make element be 0^m 1^n\n\tut32 cto, i;\n\tut32 mask = ((ut64) - 1LL) >> (64 - size);\n\n\tif (isShiftedMask (imm)) {\n\t\ti = countTrailingZeros (imm);\n\t\tcto = countTrailingOnes (imm >> i);\n\t} else {\n\t\timm |= ~mask;\n\t\tif (!isShiftedMask (imm)) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tut32 clo = countLeadingOnes (imm);\n\t\ti = 64 - clo;\n\t\tcto = clo + countTrailingOnes (imm) - (64 - size);\n\t}\n\n\t// Encode in Immr the number of RORs it would take to get *from* 0^m 1^n\n\t// to our target value, where I is the number of RORs to go the opposite\n\t// direction\n\tut32 immr = (size - i) & (size - 1);\n\t// If size has a 1 in the n'th bit, create a value that has zeroes in\n\t// bits [0, n] and ones above that.\n\tut64 nimms = ~(size - 1) << 1;\n\t// Or the cto value into the low bits, which must be below the Nth bit\n\t// bit mentioned above.\n\tnimms |= (cto - 1);\n\t// Extract and toggle seventh bit to make N field.\n\tut32 n = ((nimms >> 6) & 1) ^ 1;\n\tut64 encoding = (n << 12) | (immr << 6) | (nimms & 0x3f);\n\treturn encoding;\n}\n\nstatic ut32 mov(ArmOp *op) {\n\tint k = 0;\n\tut32 data = UT32_MAX;\n\tif (!strncmp (op->mnemonic, \"movz\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80d2;\n\t\t} else if (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8052;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movk\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8072;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80f2;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movn\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8012;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x8092;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"mov\", 3)) {\n\t\t//printf (\"%d - %d [%d]\\n\", op->operands[0].type, op->operands[1].type, ARM_GPR);\n\t\tif (op->operands[0].type & ARM_GPR) {\n\t\t\tif (op->operands[1].type & ARM_GPR) {\n\t\t\t\tif (op->operands[1].reg_type & ARM_REG64) {\n\t\t\t\t\tk = 0xe00300aa;\n\t\t\t\t} else {\n\t\t\t\t\tk = 0xe003002a;\n\t\t\t\t}\n\t\t\t\tdata = k | op->operands[1].reg << 8;\n\t\t\t} else if (op->operands[1].type & ARM_CONSTANT) {\n\t\t\t\tk = 0x80d2;\n\t\t\t\tdata = k | op->operands[1].immediate << 29;\n\t\t\t}\n\t\t\tdata |=  op->operands[0].reg << 24;\n\t\t}\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata |= (op->operands[0].reg << 24); // arg(0)\n\tdata |= ((op->operands[1].immediate & 7) << 29); // arg(1)\n\tdata |= (((op->operands[1].immediate >> 3) & 0xff) << 16); // arg(1)\n\tdata |= ((op->operands[1].immediate >> 10) << 7); // arg(1)\n\treturn data;\n}\n\nstatic ut32 cmp(ArmOp *op) {\n\tut32 data = UT32_MAX;\n\tint k = 0;\n\tif (op->operands[0].reg_type & ARM_REG64 && op->operands[1].reg_type & ARM_REG64) {\n\t\tk =  0x1f0000eb;\n\t} else if (op->operands[0].reg_type & ARM_REG32 && op->operands[1].reg_type & ARM_REG32) {\n\t\tif (op->operands[2].shift_amount > 31) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t\tk =  0x1f00006b;\n\t} else {\n\t\treturn UT32_MAX;\n\t}\n\n\tdata = k | (op->operands[0].reg & 0x18) << 13 | op->operands[0].reg << 29 | op->operands[1].reg << 8;\n\n\tif (op->operands[2].shift != ARM_NO_SHIFT) {\n\t\tdata |= op->operands[2].shift_amount << 18 | op->operands[2].shift << 14;\n\t}\n\treturn data;\n}\n\n\nstatic ut32 regsluop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xff || n < -0x100) {\n\t\treturn data;\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tif (n < 0) {\n\t\tn *= -1;\n\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\n\t\tif (countTrailingZeros(n) > 3) {\n\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t} else {\n\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t}\n\t} else {\n\t\tdata |= (0xf & (n & 63)) << 20;\n\t\tif (countTrailingZeros(n) < 4) {\n\t\t\tdata |= (n >> 4) << 8;\n\t\t} else {\n\t\t\tdata |= (0xff & n) << 4;\n\t\t}\n\t\tdata |= (n >> 8) << 8;\n\t}\n\n\treturn data;\n}\n\n// Register Load/store ops\nstatic ut32 reglsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t} else {\n\t\tint n = op->operands[2].immediate;\n\t\tif (n > 0x100 || n < -0x100) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tif (n == 0 || (n > 0 && countTrailingZeros(n) >= 4)) {\n\t\t\tk ++;\n\t\t}\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\t\t\tif (countTrailingZeros(n) > 3) {\n\t\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t\t}\n\t\t} else {\n\t\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\t\tif (countTrailingZeros(n) < 2) {\n\t\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\t\tdata++;\n\t\t\t\t\t\tdata |= (0xff & n) << 16;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\tif (countTrailingZeros(n) < 4) {\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\tdata |= (0xff & n) << 15;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 23;\n\t\t\t}\n\t\t}\n\t}\n\treturn data;\n}\n\n// Byte load/store ops\nstatic ut32 bytelsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\treturn data;\n\t}\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tif ((k & 0xf) != 8) {\n\t\t\tk--;\n\t\t}\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xfff || n < -0x100) {\n\t\treturn UT32_MAX;\n\t}\n\t// Half ops\n\tint halfop = false;\n\tif ((k & 0xf) == 8) {\n\t\thalfop = true;\n\t\tif (n == 0 || (countTrailingZeros(n) && n > 0)) {\n\t\t\tk++;\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tk--;\n\t\t}\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tint imm = n;\n\tint low_shift = 20;\n\tint high_shift = 8;\n\tint top_shift = 10;\n\tif (n < 0) {\n\t\timm = 0xfff + (n + 1);\n\t}\n\tif (halfop) {\n\t\tif (imm & 0x1 || n < 0) {\n\t\t\tdata |= (0xf & imm) << low_shift ;\n\t\t\tdata |= (0x7 & (imm >> 4)) << high_shift;\n\t\t\tdata |= (0x7 & (imm >> 6)) << top_shift;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << (low_shift - 3);\n\t\t\tdata |= (0x7 & (imm >> 4)) << (high_shift + 13);\n\t\t\tdata |= (0x7 & (imm >> 7)) << (top_shift  - 2);\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tdata |= (0xf & imm) << 20;\n\t\t\tdata |= (0x1f & (imm >> 4)) << 8;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << 18;\n\t\t\tdata |= (0x3 & (imm >> 4)) << 22;\n\t\t\tdata |= (0x7 & (imm >> 6)) << 8;\n\t\t}\n\t}\n\treturn data;\n}\n\nstatic ut32 branch(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tif (op->operands[0].type & ARM_CONSTANT) {\n\t\tn = op->operands[0].immediate;\n\t\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\t\tn -= addr;\n\t\t\tn = n >> 2;\n\t\t\tint t = n >> 24;\n\t\t\tint h = n >> 16;\n\t\t\tint m = (n & 0xff00) >> 8;\n\t\t\tn &= 0xff;\n\t\t\tdata = k;\n\t\t\tdata |= n << 24;\n\t\t\tdata |= m << 16;\n\t\t\tdata |= h << 8;\n\t\t\tdata |= t;\n\t\t}\n\t} else {\n\t\tn = op->operands[0].reg;\n\t\tif (n < 0 || n > 31) {\n\t\t\treturn -1;\n\t\t}\n\t\tn = n << 5;\n\t\tint h = n >> 8;\n\t\tn &= 0xff;\n\t\tdata = k;\n\t\tdata |= n << 24;\n\t\tdata |= h << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 bdot(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tint a = 0;\n\tn = op->operands[0].immediate;\n\t// I am sure there's a logical way to do negative offsets,\n\t// but I was unable to find any sensible docs so I did my best\n\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\tn -= addr;\n\t\tdata = k;\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\ta = (n << 3) - 1;\n\t\t\tdata |= (0xff - a) << 24;\n\n\t\t\ta = calcNegOffset(n, 5);\n\t\t\tdata |= a << 16;\n\n\t\t\ta = calcNegOffset(n, 13);\n\t\t\tdata |= a << 8;\n\t\t} else {\n\t\t\tdata |= (n & 31) << 27;\n\t\t\tdata |= (0xff & (n >> 5)) << 16;\n\t\t\tdata |= (0xff & (n >> 13)) << 8;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nstatic ut32 mem_barrier (ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tdata = k;\n\tif (!strncmp (op->mnemonic, \"isb\", 3)) {\n\t\tif (op->operands[0].mem_option == 15 || op->operands[0].type == ARM_NOTYPE) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t}\n\tif (op->operands[0].type == ARM_MEM_OPT) {\n\t\tdata |= op->operands[0].mem_option << 16;\n\t} else if (op->operands_count == 1 && op->operands[0].type == ARM_CONSTANT) {\n\t\tdata |= (op->operands[0].immediate << 16);\n\t}\n\treturn data;\n}\n\n#include \"armass64_const.h\"\n\nstatic ut32 msrk(ut16 v) {\n\tut32 r = 0;\n\tut32 a = ((v >> 12) & 0xf) << 1;\n\tut32 b = ((v & 0xfff) >> 3) & 0xff;\n\tr |= a << 8;\n\tr |= b << 16;\n\treturn r;\n}\n\nstatic ut32 msr(ArmOp *op, int w) {\n\tut32 data = UT32_MAX;\n\tint i;\n\tut32 r, b;\n\t/* handle swapped args */\n\tif (w) {\n\t\tif (op->operands[1].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[1].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[1].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[1].reg = op->operands[1].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t} else {\n\t\tif (op->operands[0].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[0].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[0].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[0].reg = op->operands[0].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t}\n\tdata = (r << 24) | b | 0xd5;\n\tif (w) {\n\t\t/* mrs */\n\t\tdata |= 0x413000;\n\t}\n\tif (op->operands[1].reg_type == ARM_REG64) {\n\t\tdata |= op->operands[1].reg << 24;\n\t}\n\n\treturn data;\n}\n\nstatic ut32 orr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[2].type & ARM_GPR) {\n\t\t// All operands need to be the same\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type &&\n\t \t    op->operands[1].reg_type == op->operands[2].reg_type)) {\n\t\t \t   return data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000000aa;\n\t\t} else {\n\t\t\tdata = 0x0000002a;\n\t\t}\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\t\tdata += op->operands[2].reg << 8;\n\t} else if (op->operands[2].type & ARM_CONSTANT) {\n\t\t// Reg types need to match\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type)) {\n\t\t\treturn data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000040b2;\n\t\t} else {\n\t\t\tdata = 0x00000032;\n\t\t}\n\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\n\t\tut32 imm = decodeBitMasks (op->operands[2].immediate);\n\t\tif (imm == -1) {\n\t\t\treturn imm;\n\t\t}\n\t\tint low = imm & 0xF;\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\timm = ((imm >> 6) | 0x78);\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 8;\n\t\t\t}\n\t\t} else {\n\t\t\timm = ((imm >> 2));\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 4;\n\t\t\t}\n\t\t}\n\t\tdata |= (4 * low) << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 adrp(ArmOp *op, ut64 addr, ut32 k) { //, int reg, ut64 dst) {\n\tut64 at = 0LL;\n\tut32 data = k;\n\tif (op->operands[0].type == ARM_GPR) {\n\t\tdata += ((op->operands[0].reg & 0xff) << 24);\n\t} else {\n\t\teprintf (\"Usage: adrp x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t} else {\n\t\teprintf (\"Usage: adrp, x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\n#if 0\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n#endif\n\tdata += b0 << 16;\n\tdata += b1 << 8;\n\treturn data;\n}\n\nstatic ut32 adr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\tut64 at = 0LL;\n\n\tif (op->operands[1].type & ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t}\n\tdata = 0x00000030;\n\tdata += 0x01000000 * op->operands[0].reg;\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n\treturn data;\n}\n\nstatic ut32 stp(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[3].immediate & 0x7) {\n\t\treturn data;\n\t}\n\tif (k == 0x000040a9 && (op->operands[0].reg == op->operands[1].reg)) {\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += op->operands[1].reg << 18;\n\tdata += (op->operands[2].reg & 0x7) << 29;\n\tdata += (op->operands[2].reg >> 3) << 16;\n\tdata += (op->operands[3].immediate & 0x8) << 20;\n\tdata += (op->operands[3].immediate >> 4) << 8;\n\treturn data;\n}\n\nstatic ut32 exception(ArmOp *op, ut32 k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\tint n = op->operands[0].immediate;\n\t\tdata = k;\n\t\tdata += (((n / 8) & 0xff) << 16);\n\t\tdata += n << 29;//((n >> 8) << 8);\n\t}\n\treturn data;\n}\n\nstatic ut32 arithmetic (ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\tif (op->operands_count < 3) {\n\t\treturn data;\n\t}\n\n\tif (!(op->operands[0].type & ARM_GPR &&\n\t      op->operands[1].type & ARM_GPR)) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk -= 6;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += (op->operands[1].reg & 7) << (24 + 5);\n\tdata += (op->operands[1].reg >> 3) << 16;\n\tif (op->operands[2].reg_type & ARM_REG64) {\n\t\tdata += op->operands[2].reg << 8;\n\t} else {\n\t\tdata += (op->operands[2].reg & 0x3f) << 18;\n\t\tdata += (op->operands[2].reg >> 6) << 8;\n\t}\n\treturn data;\n}\n\nstatic bool parseOperands(char* str, ArmOp *op) {\n\tchar *t = strdup (str);\n\tint operand = 0;\n\tchar *token = t;\n\tchar *x;\n\tint imm_count = 0;\n\tint mem_opt = 0;\n\tif (!token) {\n\t\treturn false;\n\t}\n\n\twhile (token) {\n\t\tchar *next = strchr (token, ',');\n\t\tif (next) {\n\t\t\t*next++ = 0;\n\t\t}\n\t\twhile (token[0] == ' ') {\n\t\t\ttoken++;\n\t\t}\n\t\tif (operand >= MAX_OPERANDS) {\n\t\t\teprintf (\"Too many operands\\n\");\n\t\t\treturn false;\n\t\t}\n\t\top->operands[operand].type = ARM_NOTYPE;\n\t\top->operands[operand].reg_type = ARM_UNDEFINED;\n\t\top->operands[operand].shift = ARM_NO_SHIFT;\n\n\t\twhile (token[0] == ' ' || token[0] == '[' || token[0] == ']') {\n\t\t\ttoken ++;\n\t\t}\n\n\t\tif (!strncmp (token, \"lsl\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSL;\n\t\t} else if (!strncmp (token, \"lsr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSR;\n\t\t} else if (!strncmp (token, \"asr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_ASR;\n\t\t}\n\t\tif (strlen (token) > 4 && op->operands[operand].shift != ARM_NO_SHIFT) {\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].shift_amount = r_num_math (NULL, token + 4);\n\t\t\tif (op->operands[operand].shift_amount > 63) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\toperand ++;\n\t\t\ttoken = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (token[0]) {\n\t\tcase 'x':\n\t\t\tx = strchr (token, ',');\n\t\t\tif (x) {\n\t\t\t\tx[0] = '\\0';\n\t\t\t}\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG64;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG32;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_FP;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tif (token[1] == 'P' || token [1] == 'p') {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {\n\t\t\t\t\t\top->operands[operand].sp_val = msr_const[i].val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\t\top->operands[operand].reg_type = ARM_SP | ARM_REG64;\n\t\t\t\top->operands[operand].reg = 31;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\tcase 'l':\n\t\tcase 'I':\n\t\tcase 'i':\n\t\tcase 'N':\n\t\tcase 'n':\n\t\tcase 'O':\n\t\tcase 'o':\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\top->operands[operand].sign = -1;\n\t\t\t// falthru\n\t\tdefault:\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_CONSTANT;\n\t\t\top->operands[operand].immediate = r_num_math (NULL, token);\n\t\t\timm_count++;\n\t\t\tbreak;\n\t\t}\n\t\ttoken = next;\n\n\t\toperand ++;\n\t\tif (operand > MAX_OPERANDS) {\n\t\t\tfree (t);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic bool parseOpcode(const char *str, ArmOp *op) {\n\tchar *in = strdup (str);\n\tchar *space = strchr (in, ' ');\n\tif (!space) {\n\t\top->operands[0].type = ARM_NOTYPE;\n\t\top->mnemonic = in;\n \t\treturn true;\n\t}\n\tspace[0] = '\\0';\n\top->mnemonic = in;\n\tspace ++;\n\treturn parseOperands (space, op);\n}\n\nbool arm64ass(const char *str, ut64 addr, ut32 *op) {\n\tArmOp ops = {0};\n\tif (!parseOpcode (str, &ops)) {\n\t\treturn false;\n\t}\n\t/* TODO: write tests for this and move out the regsize logic into the mov */\n\tif (!strncmp (str, \"mov\", 3)) {\n\t\t*op = mov (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"cmp\", 3)) {\n\t\t*op = cmp (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsh\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsw\", 5)) {\n\t\t*op = bytelsop (&ops, 0x000080b8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsb\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldr\", 3)) {\n\t\t*op = reglsop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"str\", 3)) {\n\t\t*op = reglsop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stp\", 3)) {\n\t\t*op = stp (&ops, 0x000000a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldp\", 3)) {\n\t\t*op = stp (&ops, 0x000040a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"sub\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0xd1);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"add\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0x91);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adr x\", 5)) { // w\n\t\t*op = adr (&ops, addr);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adrp x\", 6)) {\n\t\t*op = adrp (&ops, addr, 0x00000090);\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"isb\")) {\n\t\t*op = 0xdf3f03d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"nop\")) {\n\t\t*op = 0x1f2003d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"ret\")) {\n\t\t*op = 0xc0035fd6;\n\t\treturn true;\n\t}\n\tif (!strncmp (str, \"msr \", 4)) {\n\t\t*op = msr (&ops, 0);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"mrs \", 4)) {\n\t\t*op = msr (&ops, 1);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"orr \", 4)) {\n\t\t*op = orr (&ops, addr);\n\t\treturn *op != UT32_MAX;\n\t}\n\tif (!strncmp (str, \"svc \", 4)) { // system level exception\n\t\t*op = exception (&ops, 0x010000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hvc \", 4)) { // hypervisor level exception\n\t\t*op = exception (&ops, 0x020000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"smc \", 4)) { // secure monitor exception\n\t\t*op = exception (&ops, 0x030000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"brk \", 4)) { // breakpoint\n\t\t*op = exception (&ops, 0x000020d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hlt \", 4)) { // halt\n\t\t*op = exception (&ops, 0x000040d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b \", 2)) {\n\t\t*op = branch (&ops, addr, 0x14);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.eq \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x00000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.hs \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x02000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"bl \", 3)) {\n\t\t*op = branch (&ops, addr, 0x94);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"br x\", 4)) {\n\t\t*op = branch (&ops, addr, 0x1fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"blr x\", 5)) {\n\t\t*op = branch (&ops, addr, 0x3fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dmb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0xbf3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dsb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0x9f3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"isb\", 3)) {\n\t\t*op = mem_barrier (&ops, addr, 0xdf3f03d5);\n\t\treturn *op != -1;\n\t}\n\treturn false;\n}\n"], "filenames": ["libr/asm/arch/arm/armass.c", "libr/asm/arch/arm/armass64.c"], "buggy_code_start_loc": [6548, 759], "buggy_code_end_loc": [6549, 760], "fixing_code_start_loc": [6548, 759], "fixing_code_end_loc": [6549, 760], "type": "CWE-125", "message": "In radare2 through 3.1.3, the armass_assemble function in libr/asm/arch/arm/armass.c allows attackers to cause a denial-of-service (application crash by out-of-bounds read) by crafting an arm assembly input because a loop uses an incorrect index in armass.c and certain length validation is missing in armass64.c, a related issue to CVE-2018-20457.", "other": {"cve": {"id": "CVE-2018-20459", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-25T19:29:00.477", "lastModified": "2020-10-15T16:14:48.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In radare2 through 3.1.3, the armass_assemble function in libr/asm/arch/arm/armass.c allows attackers to cause a denial-of-service (application crash by out-of-bounds read) by crafting an arm assembly input because a loop uses an incorrect index in armass.c and certain length validation is missing in armass64.c, a related issue to CVE-2018-20457."}, {"lang": "es", "value": "En radare2 hasta la versi\u00f3n 3.1.3, la funci\u00f3n armass_assemble en libr/asm/arch/arm/armass.c permite que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n mediante una lectura fuera de l\u00edmites) manipulando una entrada de ensamblado de arm debido a que un bucle emplea un \u00edndice incorrecto en armass.c y falta cierta validaci\u00f3n de longitud en armass64.c. Esto est\u00e1 relacionado con CVE-2018-20457."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.1.3", "matchCriteriaId": "9AD48578-CD96-4442-9E09-5C9538A7C7C9"}]}]}], "references": [{"url": "https://github.com/radare/radare2/issues/12418", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/commit/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7"}}