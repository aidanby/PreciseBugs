{"buggy_code": ["package db\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/camptocamp/terraboard/config\"\n\t\"github.com/camptocamp/terraboard/internal/terraform/addrs\"\n\t\"github.com/camptocamp/terraboard/internal/terraform/states\"\n\t\"github.com/camptocamp/terraboard/internal/terraform/states/statefile\"\n\t\"github.com/camptocamp/terraboard/state\"\n\t\"github.com/camptocamp/terraboard/types\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\tctyJson \"github.com/zclconf/go-cty/cty/json\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/logger\"\n)\n\n// Database is a wrapping structure to *gorm.DB\ntype Database struct {\n\t*gorm.DB\n\tlock sync.Mutex\n}\n\nvar pageSize = 20\n\n// Init setups up the Database and a pointer to it\nfunc Init(config config.DBConfig, debug bool) *Database {\n\tvar err error\n\tconnString := fmt.Sprintf(\n\t\t\"host=%s port=%d user=%s dbname=%s sslmode=%s password=%s\",\n\t\tconfig.Host,\n\t\tconfig.Port,\n\t\tconfig.User,\n\t\tconfig.Name,\n\t\tconfig.SSLMode,\n\t\tconfig.Password,\n\t)\n\tdb, err := gorm.Open(postgres.Open(connString), &gorm.Config{\n\t\tLogger: &LogrusGormLogger,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Infof(\"Automigrate\")\n\terr = db.AutoMigrate(\n\t\t&types.Lineage{},\n\t\t&types.Version{},\n\t\t&types.State{},\n\t\t&types.Module{},\n\t\t&types.Resource{},\n\t\t&types.Attribute{},\n\t\t&types.OutputValue{},\n\t\t&types.Plan{},\n\t\t&types.PlanModel{},\n\t\t&types.PlanModelVariable{},\n\t\t&types.PlanOutput{},\n\t\t&types.PlanResourceChange{},\n\t\t&types.PlanState{},\n\t\t&types.PlanStateModule{},\n\t\t&types.PlanStateOutput{},\n\t\t&types.PlanStateResource{},\n\t\t&types.PlanStateResourceAttribute{},\n\t\t&types.PlanStateValue{},\n\t\t&types.Change{},\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Migration failed: %v\\n\", err)\n\t}\n\n\tif debug {\n\t\tdb.Config.Logger.LogMode(logger.Info)\n\t}\n\n\td := &Database{DB: db}\n\tif err = d.MigrateLineage(); err != nil {\n\t\tlog.Fatalf(\"Lineage migration failed: %v\\n\", err)\n\t}\n\n\treturn d\n}\n\n// MigrateLineage is a migration function to update db and its data to the\n// new lineage db scheme. It will update State table data, delete \"lineage\" column\n// and add corresponding Lineage entries\nfunc (db *Database) MigrateLineage() error {\n\tif db.Migrator().HasColumn(&types.State{}, \"lineage\") {\n\t\tvar states []types.State\n\t\tif err := db.Find(&states).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, st := range states {\n\t\t\tif err := db.UpdateState(st); err != nil {\n\t\t\t\treturn fmt.Errorf(\"Failed to update %s state during lineage migration: %v\", st.Path, err)\n\t\t\t}\n\t\t}\n\n\t\t// Custom migration rules\n\t\tif err := db.Migrator().DropColumn(&types.State{}, \"lineage\"); err != nil {\n\t\t\treturn fmt.Errorf(\"Failed to drop lineage column during migration: %v\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype attributeValues map[string]interface{}\n\nfunc (db *Database) stateS3toDB(sf *statefile.File, path string, versionID string) (st types.State, err error) {\n\tvar version types.Version\n\tdb.First(&version, types.Version{VersionID: versionID})\n\n\t// Check if the associated lineage is already present in lineages table\n\t// If so, it recovers its ID otherwise it inserts it at the same time as the state\n\tvar lineage types.Lineage\n\tdb.lock.Lock()\n\terr = db.FirstOrCreate(&lineage, types.Lineage{Value: sf.Lineage}).Error\n\tif err != nil || lineage.ID == 0 {\n\t\tlog.WithField(\"error\", err).\n\t\t\tError(\"Unknown error in stateS3toDB during lineage finding\")\n\t\treturn types.State{}, err\n\t}\n\tdb.lock.Unlock()\n\n\tst = types.State{\n\t\tPath:      path,\n\t\tVersion:   version,\n\t\tTFVersion: sf.TerraformVersion.String(),\n\t\tSerial:    int64(sf.Serial),\n\t\tLineageID: sql.NullInt64{Int64: int64(lineage.ID), Valid: true},\n\t}\n\n\tfor _, m := range sf.State.Modules {\n\t\tmod := types.Module{\n\t\t\tPath: m.Addr.String(),\n\t\t}\n\t\tfor _, r := range m.Resources {\n\t\t\tfor index, i := range r.Instances {\n\t\t\t\tres := types.Resource{\n\t\t\t\t\tType:       r.Addr.Resource.Type,\n\t\t\t\t\tName:       r.Addr.Resource.Name,\n\t\t\t\t\tIndex:      getResourceIndex(index),\n\t\t\t\t\tAttributes: marshalAttributeValues(i.Current),\n\t\t\t\t}\n\t\t\t\tmod.Resources = append(mod.Resources, res)\n\t\t\t}\n\t\t}\n\n\t\tfor n, r := range m.OutputValues {\n\t\t\tjsonVal, err := ctyJson.Marshal(r.Value, r.Value.Type())\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Errorf(\"failed to load output for %s\", r.Addr.String())\n\t\t\t}\n\t\t\tout := types.OutputValue{\n\t\t\t\tSensitive: r.Sensitive,\n\t\t\t\tName:      n,\n\t\t\t\tValue:     string(jsonVal),\n\t\t\t}\n\n\t\t\tmod.OutputValues = append(mod.OutputValues, out)\n\t\t}\n\n\t\tst.Modules = append(st.Modules, mod)\n\t}\n\treturn\n}\n\n// getResourceIndex transforms an addrs.InstanceKey instance into a string representation\nfunc getResourceIndex(index addrs.InstanceKey) string {\n\tswitch index.(type) {\n\tcase addrs.IntKey, addrs.StringKey:\n\t\treturn index.String()\n\t}\n\treturn \"\"\n}\n\nfunc marshalAttributeValues(src *states.ResourceInstanceObjectSrc) (attrs []types.Attribute) {\n\tvals := make(attributeValues)\n\tif src == nil {\n\t\treturn\n\t}\n\tif src.AttrsFlat != nil {\n\t\tfor k, v := range src.AttrsFlat {\n\t\t\tvals[k] = v\n\t\t}\n\t} else if err := json.Unmarshal(src.AttrsJSON, &vals); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\tlog.Debug(vals)\n\n\tfor k, v := range vals {\n\t\tvJSON, _ := json.Marshal(v)\n\t\tattr := types.Attribute{\n\t\t\tKey:   k,\n\t\t\tValue: string(vJSON),\n\t\t}\n\t\tlog.Debug(attrs)\n\t\tattrs = append(attrs, attr)\n\t}\n\treturn attrs\n}\n\n// InsertState inserts a Terraform State in the Database\nfunc (db *Database) InsertState(path string, versionID string, sf *statefile.File) error {\n\tst, err := db.stateS3toDB(sf, path, versionID)\n\tif err == nil {\n\t\tdb.Create(&st)\n\t}\n\treturn nil\n}\n\n// UpdateState update a Terraform State in the Database with Lineage foreign constraint\n// It will also insert Lineage entry in the db if needed.\n// This method is only use during the Lineage migration since States are immutable\nfunc (db *Database) UpdateState(st types.State) error {\n\t// Get lineage from old column\n\tvar lineageValue sql.NullString\n\tif err := db.Raw(\"SELECT lineage FROM states WHERE id = ?\", st.ID).Scan(&lineageValue).Error; err != nil {\n\t\treturn fmt.Errorf(\"Error on %s lineage recovering during migration: %v\", st.Path, err)\n\t}\n\tif lineageValue.String == \"\" || !lineageValue.Valid {\n\t\tlog.Warnf(\"Missing lineage for '%s' state, attempt to recover lineage from other states...\", st.Path)\n\t\tvar lineages []string\n\t\tdb.Table(\"states\").\n\t\t\tDistinct(\"lineage\").\n\t\t\tOrder(\"lineage desc\").\n\t\t\tWhere(\"path = ?\", st.Path).\n\t\t\tScan(&lineages)\n\n\t\tfor _, l := range lineages {\n\t\t\tif l != \"\" {\n\t\t\t\tlineageValue.String = l\n\t\t\t\tlineageValue.Valid = true\n\t\t\t\tlog.Infof(\"Missing lineage for '%s' state solved!\", st.Path)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif lineageValue.String == \"\" || !lineageValue.Valid {\n\t\t\tlog.Warnf(\"Failed to recover '%s' lineage from others states. Orphan state\", st.Path)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Create Lineage entry if not exist (value column is unique)\n\tlineage := types.Lineage{\n\t\tValue: lineageValue.String,\n\t}\n\ttx := db.FirstOrCreate(&lineage, lineage)\n\tif tx.Error != nil || lineage.ID == 0 {\n\t\treturn tx.Error\n\t}\n\n\t// Get Lineage ID for foreign constraint\n\tst.LineageID = sql.NullInt64{Int64: int64(lineage.ID), Valid: true}\n\n\treturn db.Save(&st).Error\n}\n\n// InsertVersion inserts an AWS S3 Version in the Database\nfunc (db *Database) InsertVersion(version *state.Version) error {\n\tvar v types.Version\n\tdb.lock.Lock()\n\tdb.FirstOrCreate(&v, types.Version{\n\t\tVersionID:    version.ID,\n\t\tLastModified: version.LastModified,\n\t})\n\tdb.lock.Unlock()\n\treturn nil\n}\n\n// GetState retrieves a State from the database by its path and versionID\nfunc (db *Database) GetState(lineage, versionID string) (state types.State) {\n\tdb.Joins(\"JOIN lineages on states.lineage_id=lineages.id\").\n\t\tJoins(\"JOIN versions on states.version_id=versions.id\").\n\t\tPreload(\"Version\").Preload(\"Modules\").Preload(\"Modules.Resources\").Preload(\"Modules.Resources.Attributes\").\n\t\tPreload(\"Modules.OutputValues\").\n\t\tFind(&state, \"lineages.value = ? AND versions.version_id = ?\", lineage, versionID)\n\treturn\n}\n\n// GetLineageActivity returns a slice of StateStat from the Database\n// for a given lineage representing the State activity over time (Versions)\nfunc (db *Database) GetLineageActivity(lineage string) (states []types.StateStat) {\n\tsql := \"SELECT t.path, t.serial, t.tf_version, t.version_id, t.last_modified, count(resources.*) as resource_count\" +\n\t\t\" FROM (SELECT states.id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified FROM states JOIN lineages ON lineages.id = states.lineage_id JOIN versions ON versions.id = states.version_id WHERE lineages.value = ? ORDER BY states.path, versions.last_modified ASC) t\" +\n\t\t\" JOIN modules ON modules.state_id = t.id\" +\n\t\t\" JOIN resources ON resources.module_id = modules.id\" +\n\t\t\" GROUP BY t.path, t.serial, t.tf_version, t.version_id, t.last_modified\" +\n\t\t\" ORDER BY last_modified ASC\"\n\n\tdb.Raw(sql, lineage).Find(&states)\n\treturn\n}\n\n// KnownVersions returns a slice of all known Versions in the Database\nfunc (db *Database) KnownVersions() (versions []string) {\n\t// TODO: err\n\trows, _ := db.Table(\"versions\").Select(\"DISTINCT version_id\").Rows()\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tvar version string\n\t\tif err := rows.Scan(&version); err != nil {\n\t\t\tlog.Error(err.Error())\n\t\t}\n\t\tversions = append(versions, version)\n\t}\n\treturn\n}\n\n// SearchAttribute returns a slice of SearchResult given a query\n// The query might contain parameters 'type', 'name', 'key', 'value' and 'tf_version'\n// SearchAttribute also returns paging information: the page number and the total results\nfunc (db *Database) SearchAttribute(query url.Values) (results []types.SearchResult, page int, total int) {\n\tlog.WithFields(log.Fields{\n\t\t\"query\": query,\n\t}).Info(\"Searching for attribute with query\")\n\n\ttargetVersion := string(query.Get(\"versionid\"))\n\n\tsqlQuery := \"\"\n\tif targetVersion == \"\" {\n\t\tsqlQuery += \" FROM (SELECT states.path, max(states.serial) as mx FROM states GROUP BY states.path) t\" +\n\t\t\t\" JOIN states ON t.path = states.path AND t.mx = states.serial\"\n\t} else {\n\t\tsqlQuery += \" FROM states\"\n\t}\n\n\tsqlQuery += \" JOIN modules ON states.id = modules.state_id\" +\n\t\t\" JOIN resources ON modules.id = resources.module_id\" +\n\t\t\" JOIN attributes ON resources.id = attributes.resource_id\" +\n\t\t\" JOIN lineages ON lineages.id = states.lineage_id\" +\n\t\t\" JOIN versions ON states.version_id = versions.id\"\n\n\tvar where []string\n\tvar params []interface{}\n\tif targetVersion != \"\" && targetVersion != \"*\" {\n\t\t// filter by version unless we want all (*) or most recent (\"\")\n\t\twhere = append(where, \"states.version_id = ?\")\n\t\tparams = append(params, targetVersion)\n\t}\n\n\tif v := string(query.Get(\"type\")); v != \"\" {\n\t\twhere = append(where, \"resources.type LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := string(query.Get(\"name\")); v != \"\" {\n\t\twhere = append(where, \"resources.name LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := string(query.Get(\"key\")); v != \"\" {\n\t\twhere = append(where, \"attributes.key LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := string(query.Get(\"value\")); v != \"\" {\n\t\twhere = append(where, \"attributes.value LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := query.Get(\"tf_version\"); string(v) != \"\" {\n\t\twhere = append(where, fmt.Sprintf(\"states.tf_version LIKE '%s'\", fmt.Sprintf(\"%%%s%%\", v)))\n\t}\n\n\tif v := query.Get(\"lineage_value\"); string(v) != \"\" {\n\t\twhere = append(where, fmt.Sprintf(\"lineages.value LIKE '%s'\", fmt.Sprintf(\"%%%s%%\", v)))\n\t}\n\n\tif len(where) > 0 {\n\t\tsqlQuery += \" WHERE \" + strings.Join(where, \" AND \")\n\t}\n\n\t// Count everything\n\trow := db.Raw(\"SELECT count(*)\"+sqlQuery, params...).Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\t// Now get results\n\t// gorm doesn't support subqueries...\n\tsql := \"SELECT states.path, versions.version_id, states.tf_version, states.serial, lineages.value as lineage_value, modules.path as module_path, resources.type, resources.name, resources.index, attributes.key, attributes.value\" +\n\t\tsqlQuery +\n\t\t\" ORDER BY states.path, states.serial, lineage_value, modules.path, resources.type, resources.name, resources.index, attributes.key\" +\n\t\t\" LIMIT ?\"\n\n\tparams = append(params, pageSize)\n\n\tif v := string(query.Get(\"page\")); v != \"\" {\n\t\tpage, _ = strconv.Atoi(v) // TODO: err\n\t\to := (page - 1) * pageSize\n\t\tsql += \" OFFSET ?\"\n\t\tparams = append(params, o)\n\t} else {\n\t\tpage = 1\n\t}\n\n\tdb.Raw(sql, params...).Find(&results)\n\n\treturn\n}\n\n// ListStatesVersions returns a map of Version IDs to a slice of State paths\n// from the Database\nfunc (db *Database) ListStatesVersions() (statesVersions map[string][]string) {\n\trows, _ := db.Table(\"states\").\n\t\tJoins(\"JOIN versions ON versions.id = states.version_id\").\n\t\tSelect(\"states.path, versions.version_id\").Rows()\n\tdefer rows.Close()\n\tstatesVersions = make(map[string][]string)\n\tfor rows.Next() {\n\t\tvar path string\n\t\tvar versionID string\n\t\tif err := rows.Scan(&path, &versionID); err != nil {\n\t\t\tlog.Error(err.Error())\n\t\t}\n\t\tstatesVersions[versionID] = append(statesVersions[versionID], path)\n\t}\n\treturn\n}\n\n// ListTerraformVersionsWithCount returns a slice of maps of Terraform versions\n// mapped to the count of most recent State paths using them.\n// ListTerraformVersionsWithCount also takes a query with possible parameter 'orderBy'\n// to sort results. Default sorting is by descending version number.\nfunc (db *Database) ListTerraformVersionsWithCount(query url.Values) (results []map[string]string, err error) {\n\torderBy := string(query.Get(\"orderBy\"))\n\tsql := \"SELECT t.tf_version, COUNT(*)\" +\n\t\t\" FROM (SELECT DISTINCT ON(states.path) states.id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified\" +\n\t\t\" FROM states JOIN versions ON versions.id = states.version_id ORDER BY states.path, versions.last_modified DESC) t\" +\n\t\t\" GROUP BY t.tf_version ORDER BY \"\n\n\tif orderBy == \"version\" {\n\t\tsql += \"string_to_array(t.tf_version, '.')::int[] DESC\"\n\t} else {\n\t\tsql += \"count DESC\"\n\t}\n\n\trows, err := db.Raw(sql).Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar name string\n\t\tvar count string\n\t\tr := make(map[string]string)\n\t\tif err = rows.Scan(&name, &count); err != nil {\n\t\t\treturn\n\t\t}\n\t\tr[\"name\"] = name\n\t\tr[\"count\"] = count\n\t\tresults = append(results, r)\n\t}\n\treturn\n}\n\n// ListStateStats returns a slice of StateStat, along with paging information\nfunc (db *Database) ListStateStats(query url.Values) (states []types.StateStat, page int, total int) {\n\trow := db.Raw(\"SELECT count(*) FROM (SELECT DISTINCT lineage_id FROM states) AS t\").Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\tvar paginationQuery string\n\tvar params []interface{}\n\tpage = 1\n\tif v := string(query.Get(\"page\")); v != \"\" {\n\t\tpage, _ = strconv.Atoi(v) // TODO: err\n\t\toffset := (page - 1) * pageSize\n\t\tparams = append(params, offset)\n\t\tpaginationQuery = \" LIMIT 20 OFFSET ?\"\n\t} else {\n\t\tpage = -1\n\t}\n\n\tsql := \"SELECT t.path, lineages.value as lineage_value, t.serial, t.tf_version, t.version_id, t.last_modified, count(resources.*) as resource_count\" +\n\t\t\" FROM (SELECT DISTINCT ON(states.lineage_id) states.id, states.lineage_id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified FROM states JOIN versions ON versions.id = states.version_id ORDER BY states.lineage_id, versions.last_modified DESC) t\" +\n\t\t\" JOIN modules ON modules.state_id = t.id\" +\n\t\t\" JOIN resources ON resources.module_id = modules.id\" +\n\t\t\" JOIN lineages ON lineages.id = t.lineage_id\" +\n\t\t\" GROUP BY t.path, lineages.value, t.serial, t.tf_version, t.version_id, t.last_modified\" +\n\t\t\" ORDER BY last_modified DESC\" +\n\t\tpaginationQuery\n\n\tdb.Raw(sql, params...).Find(&states)\n\treturn\n}\n\n// listField is a wrapper utility method to list distinct values in Database tables.\nfunc (db *Database) listField(table, field string) (results []string, err error) {\n\trows, err := db.Table(table).Select(fmt.Sprintf(\"DISTINCT %s\", field)).Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar t string\n\t\tif err = rows.Scan(&t); err != nil {\n\t\t\treturn\n\t\t}\n\t\tresults = append(results, t)\n\t}\n\n\treturn\n}\n\n// ListResourceTypes lists all Resource types from the Database\nfunc (db *Database) ListResourceTypes() ([]string, error) {\n\treturn db.listField(\"resources\", \"type\")\n}\n\n// ListResourceTypesWithCount returns a list of Resource types with associated counts\n// from the Database\nfunc (db *Database) ListResourceTypesWithCount() (results []map[string]string, err error) {\n\tsql := \"SELECT resources.type, COUNT(*)\" +\n\t\t\" FROM (SELECT DISTINCT ON(states.path) states.id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified\" +\n\t\t\" FROM states\" +\n\t\t\" JOIN versions ON versions.id = states.version_id\" +\n\t\t\" ORDER BY states.path, versions.last_modified DESC) t\" +\n\t\t\" JOIN modules ON modules.state_id = t.id\" +\n\t\t\" JOIN resources ON resources.module_id = modules.id\" +\n\t\t\" GROUP BY resources.type\" +\n\t\t\" ORDER BY count DESC\"\n\n\trows, err := db.Raw(sql).Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar name string\n\t\tvar count string\n\t\tr := make(map[string]string)\n\t\tif err = rows.Scan(&name, &count); err != nil {\n\t\t\treturn\n\t\t}\n\t\tr[\"name\"] = name\n\t\tr[\"count\"] = count\n\t\tresults = append(results, r)\n\t}\n\treturn\n}\n\n// ListResourceNames lists all Resource names from the Database\nfunc (db *Database) ListResourceNames() ([]string, error) {\n\treturn db.listField(\"resources\", \"name\")\n}\n\n// ListTfVersions lists all Terraform versions from the Database\nfunc (db *Database) ListTfVersions() ([]string, error) {\n\treturn db.listField(\"states\", \"tf_version\")\n}\n\n// ListAttributeKeys lists all Resource Attribute keys for a given Resource type\n// from the Database\nfunc (db *Database) ListAttributeKeys(resourceType string) (results []string, err error) {\n\tquery := db.Table(\"attributes\").\n\t\tSelect(\"DISTINCT key\").\n\t\tJoins(\"JOIN resources ON attributes.resource_id = resources.id\")\n\n\tif resourceType != \"\" {\n\t\tquery = query.Where(\"resources.type = ?\", resourceType)\n\t}\n\n\trows, err := query.Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar t string\n\t\tif err = rows.Scan(&t); err != nil {\n\t\t\treturn\n\t\t}\n\t\tresults = append(results, t)\n\t}\n\n\treturn\n}\n\n// InsertPlan inserts a Terraform plan with associated information in the Database\nfunc (db *Database) InsertPlan(plan []byte) error {\n\tvar lineage types.Lineage\n\tif err := json.Unmarshal(plan, &lineage); err != nil {\n\t\treturn err\n\t}\n\n\t// Recover lineage from db if it's already exists or insert it\n\tres := db.FirstOrCreate(&lineage, lineage)\n\tif res.Error != nil {\n\t\treturn fmt.Errorf(\"Error on lineage retrival during plan insertion: %v\", res.Error)\n\t}\n\n\tvar p types.Plan\n\tif err := json.Unmarshal(plan, &p); err != nil {\n\t\treturn err\n\t}\n\tif err := json.Unmarshal(p.PlanJSON, &p.ParsedPlan); err != nil {\n\t\treturn err\n\t}\n\n\tp.LineageID = lineage.ID\n\treturn db.Create(&p).Error\n}\n\n// GetPlansSummary retrieves a summary of all Plans of a lineage from the database\nfunc (db *Database) GetPlansSummary(lineage, limitStr, pageStr string) (plans []types.Plan, page int, total int) {\n\tvar whereClause []interface{}\n\tvar whereClauseTotal string\n\tif lineage != \"\" {\n\t\twhereClause = append(whereClause, `\"Lineage\".\"value\" = ?`, lineage)\n\t\twhereClauseTotal = ` JOIN lineages on lineages.id=t.lineage_id WHERE lineages.value = ?`\n\t}\n\n\trow := db.Raw(\"SELECT count(*) FROM plans AS t\"+whereClauseTotal, lineage).Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\tvar limit int\n\tif limitStr == \"\" {\n\t\tlimit = -1\n\t} else {\n\t\tvar err error\n\t\tlimit, err = strconv.Atoi(limitStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans limit ignored: %v\", err)\n\t\t\tlimit = -1\n\t\t}\n\t}\n\n\tvar offset int\n\tif pageStr == \"\" {\n\t\toffset = -1\n\t} else {\n\t\tvar err error\n\t\tpage, err = strconv.Atoi(pageStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans offset ignored: %v\", err)\n\t\t} else {\n\t\t\toffset = (page - 1) * pageSize\n\t\t}\n\t}\n\n\tdb.Select(`\"plans\".\"id\"`, `\"plans\".\"created_at\"`, `\"plans\".\"updated_at\"`, `\"plans\".\"tf_version\"`,\n\t\t`\"plans\".\"git_remote\"`, `\"plans\".\"git_commit\"`, `\"plans\".\"ci_url\"`, `\"plans\".\"source\"`, `\"plans\".\"exit_code\"`).\n\t\tJoins(\"Lineage\").\n\t\tOrder(\"created_at desc\").\n\t\tLimit(limit).\n\t\tOffset(offset).\n\t\tFind(&plans, whereClause...)\n\n\treturn\n}\n\n// GetPlan retrieves a specific Plan by his ID from the database\nfunc (db *Database) GetPlan(id string) (plans types.Plan) {\n\tdb.Joins(\"Lineage\").\n\t\tPreload(\"ParsedPlan\").\n\t\tPreload(\"ParsedPlan.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tPreload(\"ParsedPlan.Variables\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges.Change\").\n\t\tPreload(\"ParsedPlan.PlanOutputs\").\n\t\tPreload(\"ParsedPlan.PlanOutputs.Change\").\n\t\tPreload(\"ParsedPlan.PlanState\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tFind(&plans, `\"plans\".\"id\" = ?`, id)\n\n\treturn\n}\n\n// GetPlans retrieves all Plan of a lineage from the database\nfunc (db *Database) GetPlans(lineage, limitStr, pageStr string) (plans []types.Plan, page int, total int) {\n\tvar whereClause []interface{}\n\tvar whereClauseTotal string\n\tif lineage != \"\" {\n\t\twhereClause = append(whereClause, `\"Lineage\".\"value\" = ?`, lineage)\n\t\twhereClauseTotal = ` JOIN lineages on lineages.id=t.lineage_id WHERE lineages.value = ?`\n\t}\n\n\trow := db.Raw(\"SELECT count(*) FROM plans AS t\"+whereClauseTotal, lineage).Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\tvar limit int\n\tif limitStr == \"\" {\n\t\tlimit = -1\n\t} else {\n\t\tvar err error\n\t\tlimit, err = strconv.Atoi(limitStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans limit ignored: %v\", err)\n\t\t\tlimit = -1\n\t\t}\n\t}\n\n\tvar offset int\n\tif pageStr == \"\" {\n\t\toffset = -1\n\t} else {\n\t\tvar err error\n\t\tpage, err = strconv.Atoi(pageStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans offset ignored: %v\", err)\n\t\t} else {\n\t\t\toffset = (page - 1) * pageSize\n\t\t}\n\t}\n\n\tdb.Joins(\"Lineage\").\n\t\tPreload(\"ParsedPlan\").\n\t\tPreload(\"ParsedPlan.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tPreload(\"ParsedPlan.Variables\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges.Change\").\n\t\tPreload(\"ParsedPlan.PlanOutputs\").\n\t\tPreload(\"ParsedPlan.PlanOutputs.Change\").\n\t\tPreload(\"ParsedPlan.PlanState\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tOrder(\"created_at desc\").\n\t\tLimit(limit).\n\t\tOffset(offset).\n\t\tFind(&plans, whereClause...)\n\n\treturn\n}\n\n// GetLineages retrieves all Lineage from the database\nfunc (db *Database) GetLineages(limitStr string) (lineages []types.Lineage) {\n\tvar limit int\n\tif limitStr == \"\" {\n\t\tlimit = -1\n\t} else {\n\t\tvar err error\n\t\tlimit, err = strconv.Atoi(limitStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetLineages limit ignored: %v\", err)\n\t\t\tlimit = -1\n\t\t}\n\t}\n\n\tdb.Order(\"created_at desc\").\n\t\tLimit(limit).\n\t\tFind(&lineages)\n\treturn\n}\n\n// DefaultVersion returns the default VersionID for a given Lineage\n// Copied and adapted from github.com/hashicorp/terraform/command/jsonstate/state.go\nfunc (db *Database) DefaultVersion(lineage string) (version string, err error) {\n\tsqlQuery := \"SELECT versions.version_id FROM\" +\n\t\t\" (SELECT states.path, max(states.serial) as mx FROM states GROUP BY states.path) t\" +\n\t\t\" JOIN states ON t.path = states.path AND t.mx = states.serial\" +\n\t\t\" JOIN versions on states.version_id=versions.id\" +\n\t\t\" JOIN lineages on lineages.id=states.lineage_id\" +\n\t\t\" WHERE lineages.value = ?\" +\n\t\t\" ORDER BY versions.last_modified DESC\"\n\n\trow := db.Raw(sqlQuery, lineage).Row()\n\terr = row.Scan(&version)\n\treturn\n}\n\n// Close get generic database interface *sql.DB from the current *gorm.DB\n// and close it\nfunc (db *Database) Close() {\n\tsqlDb, err := db.DB.DB()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to terminate db instance: %v\\n\", err)\n\t}\n\tsqlDb.Close()\n}\n"], "fixing_code": ["package db\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/camptocamp/terraboard/config\"\n\t\"github.com/camptocamp/terraboard/internal/terraform/addrs\"\n\t\"github.com/camptocamp/terraboard/internal/terraform/states\"\n\t\"github.com/camptocamp/terraboard/internal/terraform/states/statefile\"\n\t\"github.com/camptocamp/terraboard/state\"\n\t\"github.com/camptocamp/terraboard/types\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\tctyJson \"github.com/zclconf/go-cty/cty/json\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/logger\"\n)\n\n// Database is a wrapping structure to *gorm.DB\ntype Database struct {\n\t*gorm.DB\n\tlock sync.Mutex\n}\n\nvar pageSize = 20\n\n// Init setups up the Database and a pointer to it\nfunc Init(config config.DBConfig, debug bool) *Database {\n\tvar err error\n\tconnString := fmt.Sprintf(\n\t\t\"host=%s port=%d user=%s dbname=%s sslmode=%s password=%s\",\n\t\tconfig.Host,\n\t\tconfig.Port,\n\t\tconfig.User,\n\t\tconfig.Name,\n\t\tconfig.SSLMode,\n\t\tconfig.Password,\n\t)\n\tdb, err := gorm.Open(postgres.Open(connString), &gorm.Config{\n\t\tLogger: &LogrusGormLogger,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Infof(\"Automigrate\")\n\terr = db.AutoMigrate(\n\t\t&types.Lineage{},\n\t\t&types.Version{},\n\t\t&types.State{},\n\t\t&types.Module{},\n\t\t&types.Resource{},\n\t\t&types.Attribute{},\n\t\t&types.OutputValue{},\n\t\t&types.Plan{},\n\t\t&types.PlanModel{},\n\t\t&types.PlanModelVariable{},\n\t\t&types.PlanOutput{},\n\t\t&types.PlanResourceChange{},\n\t\t&types.PlanState{},\n\t\t&types.PlanStateModule{},\n\t\t&types.PlanStateOutput{},\n\t\t&types.PlanStateResource{},\n\t\t&types.PlanStateResourceAttribute{},\n\t\t&types.PlanStateValue{},\n\t\t&types.Change{},\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Migration failed: %v\\n\", err)\n\t}\n\n\tif debug {\n\t\tdb.Config.Logger.LogMode(logger.Info)\n\t}\n\n\td := &Database{DB: db}\n\tif err = d.MigrateLineage(); err != nil {\n\t\tlog.Fatalf(\"Lineage migration failed: %v\\n\", err)\n\t}\n\n\treturn d\n}\n\n// MigrateLineage is a migration function to update db and its data to the\n// new lineage db scheme. It will update State table data, delete \"lineage\" column\n// and add corresponding Lineage entries\nfunc (db *Database) MigrateLineage() error {\n\tif db.Migrator().HasColumn(&types.State{}, \"lineage\") {\n\t\tvar states []types.State\n\t\tif err := db.Find(&states).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, st := range states {\n\t\t\tif err := db.UpdateState(st); err != nil {\n\t\t\t\treturn fmt.Errorf(\"Failed to update %s state during lineage migration: %v\", st.Path, err)\n\t\t\t}\n\t\t}\n\n\t\t// Custom migration rules\n\t\tif err := db.Migrator().DropColumn(&types.State{}, \"lineage\"); err != nil {\n\t\t\treturn fmt.Errorf(\"Failed to drop lineage column during migration: %v\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype attributeValues map[string]interface{}\n\nfunc (db *Database) stateS3toDB(sf *statefile.File, path string, versionID string) (st types.State, err error) {\n\tvar version types.Version\n\tdb.First(&version, types.Version{VersionID: versionID})\n\n\t// Check if the associated lineage is already present in lineages table\n\t// If so, it recovers its ID otherwise it inserts it at the same time as the state\n\tvar lineage types.Lineage\n\tdb.lock.Lock()\n\terr = db.FirstOrCreate(&lineage, types.Lineage{Value: sf.Lineage}).Error\n\tif err != nil || lineage.ID == 0 {\n\t\tlog.WithField(\"error\", err).\n\t\t\tError(\"Unknown error in stateS3toDB during lineage finding\")\n\t\treturn types.State{}, err\n\t}\n\tdb.lock.Unlock()\n\n\tst = types.State{\n\t\tPath:      path,\n\t\tVersion:   version,\n\t\tTFVersion: sf.TerraformVersion.String(),\n\t\tSerial:    int64(sf.Serial),\n\t\tLineageID: sql.NullInt64{Int64: int64(lineage.ID), Valid: true},\n\t}\n\n\tfor _, m := range sf.State.Modules {\n\t\tmod := types.Module{\n\t\t\tPath: m.Addr.String(),\n\t\t}\n\t\tfor _, r := range m.Resources {\n\t\t\tfor index, i := range r.Instances {\n\t\t\t\tres := types.Resource{\n\t\t\t\t\tType:       r.Addr.Resource.Type,\n\t\t\t\t\tName:       r.Addr.Resource.Name,\n\t\t\t\t\tIndex:      getResourceIndex(index),\n\t\t\t\t\tAttributes: marshalAttributeValues(i.Current),\n\t\t\t\t}\n\t\t\t\tmod.Resources = append(mod.Resources, res)\n\t\t\t}\n\t\t}\n\n\t\tfor n, r := range m.OutputValues {\n\t\t\tjsonVal, err := ctyJson.Marshal(r.Value, r.Value.Type())\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Errorf(\"failed to load output for %s\", r.Addr.String())\n\t\t\t}\n\t\t\tout := types.OutputValue{\n\t\t\t\tSensitive: r.Sensitive,\n\t\t\t\tName:      n,\n\t\t\t\tValue:     string(jsonVal),\n\t\t\t}\n\n\t\t\tmod.OutputValues = append(mod.OutputValues, out)\n\t\t}\n\n\t\tst.Modules = append(st.Modules, mod)\n\t}\n\treturn\n}\n\n// getResourceIndex transforms an addrs.InstanceKey instance into a string representation\nfunc getResourceIndex(index addrs.InstanceKey) string {\n\tswitch index.(type) {\n\tcase addrs.IntKey, addrs.StringKey:\n\t\treturn index.String()\n\t}\n\treturn \"\"\n}\n\nfunc marshalAttributeValues(src *states.ResourceInstanceObjectSrc) (attrs []types.Attribute) {\n\tvals := make(attributeValues)\n\tif src == nil {\n\t\treturn\n\t}\n\tif src.AttrsFlat != nil {\n\t\tfor k, v := range src.AttrsFlat {\n\t\t\tvals[k] = v\n\t\t}\n\t} else if err := json.Unmarshal(src.AttrsJSON, &vals); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\tlog.Debug(vals)\n\n\tfor k, v := range vals {\n\t\tvJSON, _ := json.Marshal(v)\n\t\tattr := types.Attribute{\n\t\t\tKey:   k,\n\t\t\tValue: string(vJSON),\n\t\t}\n\t\tlog.Debug(attrs)\n\t\tattrs = append(attrs, attr)\n\t}\n\treturn attrs\n}\n\n// InsertState inserts a Terraform State in the Database\nfunc (db *Database) InsertState(path string, versionID string, sf *statefile.File) error {\n\tst, err := db.stateS3toDB(sf, path, versionID)\n\tif err == nil {\n\t\tdb.Create(&st)\n\t}\n\treturn nil\n}\n\n// UpdateState update a Terraform State in the Database with Lineage foreign constraint\n// It will also insert Lineage entry in the db if needed.\n// This method is only use during the Lineage migration since States are immutable\nfunc (db *Database) UpdateState(st types.State) error {\n\t// Get lineage from old column\n\tvar lineageValue sql.NullString\n\tif err := db.Raw(\"SELECT lineage FROM states WHERE id = ?\", st.ID).Scan(&lineageValue).Error; err != nil {\n\t\treturn fmt.Errorf(\"Error on %s lineage recovering during migration: %v\", st.Path, err)\n\t}\n\tif lineageValue.String == \"\" || !lineageValue.Valid {\n\t\tlog.Warnf(\"Missing lineage for '%s' state, attempt to recover lineage from other states...\", st.Path)\n\t\tvar lineages []string\n\t\tdb.Table(\"states\").\n\t\t\tDistinct(\"lineage\").\n\t\t\tOrder(\"lineage desc\").\n\t\t\tWhere(\"path = ?\", st.Path).\n\t\t\tScan(&lineages)\n\n\t\tfor _, l := range lineages {\n\t\t\tif l != \"\" {\n\t\t\t\tlineageValue.String = l\n\t\t\t\tlineageValue.Valid = true\n\t\t\t\tlog.Infof(\"Missing lineage for '%s' state solved!\", st.Path)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif lineageValue.String == \"\" || !lineageValue.Valid {\n\t\t\tlog.Warnf(\"Failed to recover '%s' lineage from others states. Orphan state\", st.Path)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Create Lineage entry if not exist (value column is unique)\n\tlineage := types.Lineage{\n\t\tValue: lineageValue.String,\n\t}\n\ttx := db.FirstOrCreate(&lineage, lineage)\n\tif tx.Error != nil || lineage.ID == 0 {\n\t\treturn tx.Error\n\t}\n\n\t// Get Lineage ID for foreign constraint\n\tst.LineageID = sql.NullInt64{Int64: int64(lineage.ID), Valid: true}\n\n\treturn db.Save(&st).Error\n}\n\n// InsertVersion inserts an AWS S3 Version in the Database\nfunc (db *Database) InsertVersion(version *state.Version) error {\n\tvar v types.Version\n\tdb.lock.Lock()\n\tdb.FirstOrCreate(&v, types.Version{\n\t\tVersionID:    version.ID,\n\t\tLastModified: version.LastModified,\n\t})\n\tdb.lock.Unlock()\n\treturn nil\n}\n\n// GetState retrieves a State from the database by its path and versionID\nfunc (db *Database) GetState(lineage, versionID string) (state types.State) {\n\tdb.Joins(\"JOIN lineages on states.lineage_id=lineages.id\").\n\t\tJoins(\"JOIN versions on states.version_id=versions.id\").\n\t\tPreload(\"Version\").Preload(\"Modules\").Preload(\"Modules.Resources\").Preload(\"Modules.Resources.Attributes\").\n\t\tPreload(\"Modules.OutputValues\").\n\t\tFind(&state, \"lineages.value = ? AND versions.version_id = ?\", lineage, versionID)\n\treturn\n}\n\n// GetLineageActivity returns a slice of StateStat from the Database\n// for a given lineage representing the State activity over time (Versions)\nfunc (db *Database) GetLineageActivity(lineage string) (states []types.StateStat) {\n\tsql := \"SELECT t.path, t.serial, t.tf_version, t.version_id, t.last_modified, count(resources.*) as resource_count\" +\n\t\t\" FROM (SELECT states.id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified FROM states JOIN lineages ON lineages.id = states.lineage_id JOIN versions ON versions.id = states.version_id WHERE lineages.value = ? ORDER BY states.path, versions.last_modified ASC) t\" +\n\t\t\" JOIN modules ON modules.state_id = t.id\" +\n\t\t\" JOIN resources ON resources.module_id = modules.id\" +\n\t\t\" GROUP BY t.path, t.serial, t.tf_version, t.version_id, t.last_modified\" +\n\t\t\" ORDER BY last_modified ASC\"\n\n\tdb.Raw(sql, lineage).Find(&states)\n\treturn\n}\n\n// KnownVersions returns a slice of all known Versions in the Database\nfunc (db *Database) KnownVersions() (versions []string) {\n\t// TODO: err\n\trows, _ := db.Table(\"versions\").Select(\"DISTINCT version_id\").Rows()\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tvar version string\n\t\tif err := rows.Scan(&version); err != nil {\n\t\t\tlog.Error(err.Error())\n\t\t}\n\t\tversions = append(versions, version)\n\t}\n\treturn\n}\n\n// SearchAttribute returns a slice of SearchResult given a query\n// The query might contain parameters 'type', 'name', 'key', 'value' and 'tf_version'\n// SearchAttribute also returns paging information: the page number and the total results\nfunc (db *Database) SearchAttribute(query url.Values) (results []types.SearchResult, page int, total int) {\n\tlog.WithFields(log.Fields{\n\t\t\"query\": query,\n\t}).Info(\"Searching for attribute with query\")\n\n\ttargetVersion := string(query.Get(\"versionid\"))\n\n\tsqlQuery := \"\"\n\tif targetVersion == \"\" {\n\t\tsqlQuery += \" FROM (SELECT states.path, max(states.serial) as mx FROM states GROUP BY states.path) t\" +\n\t\t\t\" JOIN states ON t.path = states.path AND t.mx = states.serial\"\n\t} else {\n\t\tsqlQuery += \" FROM states\"\n\t}\n\n\tsqlQuery += \" JOIN modules ON states.id = modules.state_id\" +\n\t\t\" JOIN resources ON modules.id = resources.module_id\" +\n\t\t\" JOIN attributes ON resources.id = attributes.resource_id\" +\n\t\t\" JOIN lineages ON lineages.id = states.lineage_id\" +\n\t\t\" JOIN versions ON states.version_id = versions.id\"\n\n\tvar where []string\n\tvar params []interface{}\n\tif targetVersion != \"\" && targetVersion != \"*\" {\n\t\t// filter by version unless we want all (*) or most recent (\"\")\n\t\twhere = append(where, \"states.version_id = ?\")\n\t\tparams = append(params, targetVersion)\n\t}\n\n\tif v := string(query.Get(\"type\")); v != \"\" {\n\t\twhere = append(where, \"resources.type LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := string(query.Get(\"name\")); v != \"\" {\n\t\twhere = append(where, \"resources.name LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := string(query.Get(\"key\")); v != \"\" {\n\t\twhere = append(where, \"attributes.key LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := string(query.Get(\"value\")); v != \"\" {\n\t\twhere = append(where, \"attributes.value LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := query.Get(\"tf_version\"); string(v) != \"\" {\n\t\twhere = append(where, \"states.tf_version LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif v := query.Get(\"lineage_value\"); string(v) != \"\" {\n\t\twhere = append(where, \"lineages.value LIKE ?\")\n\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n\t}\n\n\tif len(where) > 0 {\n\t\tsqlQuery += \" WHERE \" + strings.Join(where, \" AND \")\n\t}\n\n\t// Count everything\n\trow := db.Raw(\"SELECT count(*)\"+sqlQuery, params...).Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\t// Now get results\n\t// gorm doesn't support subqueries...\n\tsql := \"SELECT states.path, versions.version_id, states.tf_version, states.serial, lineages.value as lineage_value, modules.path as module_path, resources.type, resources.name, resources.index, attributes.key, attributes.value\" +\n\t\tsqlQuery +\n\t\t\" ORDER BY states.path, states.serial, lineage_value, modules.path, resources.type, resources.name, resources.index, attributes.key\" +\n\t\t\" LIMIT ?\"\n\n\tparams = append(params, pageSize)\n\n\tif v := string(query.Get(\"page\")); v != \"\" {\n\t\tpage, _ = strconv.Atoi(v) // TODO: err\n\t\to := (page - 1) * pageSize\n\t\tsql += \" OFFSET ?\"\n\t\tparams = append(params, o)\n\t} else {\n\t\tpage = 1\n\t}\n\n\tdb.Raw(sql, params...).Find(&results)\n\n\treturn\n}\n\n// ListStatesVersions returns a map of Version IDs to a slice of State paths\n// from the Database\nfunc (db *Database) ListStatesVersions() (statesVersions map[string][]string) {\n\trows, _ := db.Table(\"states\").\n\t\tJoins(\"JOIN versions ON versions.id = states.version_id\").\n\t\tSelect(\"states.path, versions.version_id\").Rows()\n\tdefer rows.Close()\n\tstatesVersions = make(map[string][]string)\n\tfor rows.Next() {\n\t\tvar path string\n\t\tvar versionID string\n\t\tif err := rows.Scan(&path, &versionID); err != nil {\n\t\t\tlog.Error(err.Error())\n\t\t}\n\t\tstatesVersions[versionID] = append(statesVersions[versionID], path)\n\t}\n\treturn\n}\n\n// ListTerraformVersionsWithCount returns a slice of maps of Terraform versions\n// mapped to the count of most recent State paths using them.\n// ListTerraformVersionsWithCount also takes a query with possible parameter 'orderBy'\n// to sort results. Default sorting is by descending version number.\nfunc (db *Database) ListTerraformVersionsWithCount(query url.Values) (results []map[string]string, err error) {\n\torderBy := string(query.Get(\"orderBy\"))\n\tsql := \"SELECT t.tf_version, COUNT(*)\" +\n\t\t\" FROM (SELECT DISTINCT ON(states.path) states.id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified\" +\n\t\t\" FROM states JOIN versions ON versions.id = states.version_id ORDER BY states.path, versions.last_modified DESC) t\" +\n\t\t\" GROUP BY t.tf_version ORDER BY \"\n\n\tif orderBy == \"version\" {\n\t\tsql += \"string_to_array(t.tf_version, '.')::int[] DESC\"\n\t} else {\n\t\tsql += \"count DESC\"\n\t}\n\n\trows, err := db.Raw(sql).Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar name string\n\t\tvar count string\n\t\tr := make(map[string]string)\n\t\tif err = rows.Scan(&name, &count); err != nil {\n\t\t\treturn\n\t\t}\n\t\tr[\"name\"] = name\n\t\tr[\"count\"] = count\n\t\tresults = append(results, r)\n\t}\n\treturn\n}\n\n// ListStateStats returns a slice of StateStat, along with paging information\nfunc (db *Database) ListStateStats(query url.Values) (states []types.StateStat, page int, total int) {\n\trow := db.Raw(\"SELECT count(*) FROM (SELECT DISTINCT lineage_id FROM states) AS t\").Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\tvar paginationQuery string\n\tvar params []interface{}\n\tpage = 1\n\tif v := string(query.Get(\"page\")); v != \"\" {\n\t\tpage, _ = strconv.Atoi(v) // TODO: err\n\t\toffset := (page - 1) * pageSize\n\t\tparams = append(params, offset)\n\t\tpaginationQuery = \" LIMIT 20 OFFSET ?\"\n\t} else {\n\t\tpage = -1\n\t}\n\n\tsql := \"SELECT t.path, lineages.value as lineage_value, t.serial, t.tf_version, t.version_id, t.last_modified, count(resources.*) as resource_count\" +\n\t\t\" FROM (SELECT DISTINCT ON(states.lineage_id) states.id, states.lineage_id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified FROM states JOIN versions ON versions.id = states.version_id ORDER BY states.lineage_id, versions.last_modified DESC) t\" +\n\t\t\" JOIN modules ON modules.state_id = t.id\" +\n\t\t\" JOIN resources ON resources.module_id = modules.id\" +\n\t\t\" JOIN lineages ON lineages.id = t.lineage_id\" +\n\t\t\" GROUP BY t.path, lineages.value, t.serial, t.tf_version, t.version_id, t.last_modified\" +\n\t\t\" ORDER BY last_modified DESC\" +\n\t\tpaginationQuery\n\n\tdb.Raw(sql, params...).Find(&states)\n\treturn\n}\n\n// listField is a wrapper utility method to list distinct values in Database tables.\nfunc (db *Database) listField(table, field string) (results []string, err error) {\n\trows, err := db.Table(table).Select(fmt.Sprintf(\"DISTINCT %s\", field)).Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar t string\n\t\tif err = rows.Scan(&t); err != nil {\n\t\t\treturn\n\t\t}\n\t\tresults = append(results, t)\n\t}\n\n\treturn\n}\n\n// ListResourceTypes lists all Resource types from the Database\nfunc (db *Database) ListResourceTypes() ([]string, error) {\n\treturn db.listField(\"resources\", \"type\")\n}\n\n// ListResourceTypesWithCount returns a list of Resource types with associated counts\n// from the Database\nfunc (db *Database) ListResourceTypesWithCount() (results []map[string]string, err error) {\n\tsql := \"SELECT resources.type, COUNT(*)\" +\n\t\t\" FROM (SELECT DISTINCT ON(states.path) states.id, states.path, states.serial, states.tf_version, versions.version_id, versions.last_modified\" +\n\t\t\" FROM states\" +\n\t\t\" JOIN versions ON versions.id = states.version_id\" +\n\t\t\" ORDER BY states.path, versions.last_modified DESC) t\" +\n\t\t\" JOIN modules ON modules.state_id = t.id\" +\n\t\t\" JOIN resources ON resources.module_id = modules.id\" +\n\t\t\" GROUP BY resources.type\" +\n\t\t\" ORDER BY count DESC\"\n\n\trows, err := db.Raw(sql).Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar name string\n\t\tvar count string\n\t\tr := make(map[string]string)\n\t\tif err = rows.Scan(&name, &count); err != nil {\n\t\t\treturn\n\t\t}\n\t\tr[\"name\"] = name\n\t\tr[\"count\"] = count\n\t\tresults = append(results, r)\n\t}\n\treturn\n}\n\n// ListResourceNames lists all Resource names from the Database\nfunc (db *Database) ListResourceNames() ([]string, error) {\n\treturn db.listField(\"resources\", \"name\")\n}\n\n// ListTfVersions lists all Terraform versions from the Database\nfunc (db *Database) ListTfVersions() ([]string, error) {\n\treturn db.listField(\"states\", \"tf_version\")\n}\n\n// ListAttributeKeys lists all Resource Attribute keys for a given Resource type\n// from the Database\nfunc (db *Database) ListAttributeKeys(resourceType string) (results []string, err error) {\n\tquery := db.Table(\"attributes\").\n\t\tSelect(\"DISTINCT key\").\n\t\tJoins(\"JOIN resources ON attributes.resource_id = resources.id\")\n\n\tif resourceType != \"\" {\n\t\tquery = query.Where(\"resources.type = ?\", resourceType)\n\t}\n\n\trows, err := query.Rows()\n\tif err != nil {\n\t\treturn results, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar t string\n\t\tif err = rows.Scan(&t); err != nil {\n\t\t\treturn\n\t\t}\n\t\tresults = append(results, t)\n\t}\n\n\treturn\n}\n\n// InsertPlan inserts a Terraform plan with associated information in the Database\nfunc (db *Database) InsertPlan(plan []byte) error {\n\tvar lineage types.Lineage\n\tif err := json.Unmarshal(plan, &lineage); err != nil {\n\t\treturn err\n\t}\n\n\t// Recover lineage from db if it's already exists or insert it\n\tres := db.FirstOrCreate(&lineage, lineage)\n\tif res.Error != nil {\n\t\treturn fmt.Errorf(\"Error on lineage retrival during plan insertion: %v\", res.Error)\n\t}\n\n\tvar p types.Plan\n\tif err := json.Unmarshal(plan, &p); err != nil {\n\t\treturn err\n\t}\n\tif err := json.Unmarshal(p.PlanJSON, &p.ParsedPlan); err != nil {\n\t\treturn err\n\t}\n\n\tp.LineageID = lineage.ID\n\treturn db.Create(&p).Error\n}\n\n// GetPlansSummary retrieves a summary of all Plans of a lineage from the database\nfunc (db *Database) GetPlansSummary(lineage, limitStr, pageStr string) (plans []types.Plan, page int, total int) {\n\tvar whereClause []interface{}\n\tvar whereClauseTotal string\n\tif lineage != \"\" {\n\t\twhereClause = append(whereClause, `\"Lineage\".\"value\" = ?`, lineage)\n\t\twhereClauseTotal = ` JOIN lineages on lineages.id=t.lineage_id WHERE lineages.value = ?`\n\t}\n\n\trow := db.Raw(\"SELECT count(*) FROM plans AS t\"+whereClauseTotal, lineage).Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\tvar limit int\n\tif limitStr == \"\" {\n\t\tlimit = -1\n\t} else {\n\t\tvar err error\n\t\tlimit, err = strconv.Atoi(limitStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans limit ignored: %v\", err)\n\t\t\tlimit = -1\n\t\t}\n\t}\n\n\tvar offset int\n\tif pageStr == \"\" {\n\t\toffset = -1\n\t} else {\n\t\tvar err error\n\t\tpage, err = strconv.Atoi(pageStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans offset ignored: %v\", err)\n\t\t} else {\n\t\t\toffset = (page - 1) * pageSize\n\t\t}\n\t}\n\n\tdb.Select(`\"plans\".\"id\"`, `\"plans\".\"created_at\"`, `\"plans\".\"updated_at\"`, `\"plans\".\"tf_version\"`,\n\t\t`\"plans\".\"git_remote\"`, `\"plans\".\"git_commit\"`, `\"plans\".\"ci_url\"`, `\"plans\".\"source\"`, `\"plans\".\"exit_code\"`).\n\t\tJoins(\"Lineage\").\n\t\tOrder(\"created_at desc\").\n\t\tLimit(limit).\n\t\tOffset(offset).\n\t\tFind(&plans, whereClause...)\n\n\treturn\n}\n\n// GetPlan retrieves a specific Plan by his ID from the database\nfunc (db *Database) GetPlan(id string) (plans types.Plan) {\n\tdb.Joins(\"Lineage\").\n\t\tPreload(\"ParsedPlan\").\n\t\tPreload(\"ParsedPlan.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tPreload(\"ParsedPlan.Variables\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges.Change\").\n\t\tPreload(\"ParsedPlan.PlanOutputs\").\n\t\tPreload(\"ParsedPlan.PlanOutputs.Change\").\n\t\tPreload(\"ParsedPlan.PlanState\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tFind(&plans, `\"plans\".\"id\" = ?`, id)\n\n\treturn\n}\n\n// GetPlans retrieves all Plan of a lineage from the database\nfunc (db *Database) GetPlans(lineage, limitStr, pageStr string) (plans []types.Plan, page int, total int) {\n\tvar whereClause []interface{}\n\tvar whereClauseTotal string\n\tif lineage != \"\" {\n\t\twhereClause = append(whereClause, `\"Lineage\".\"value\" = ?`, lineage)\n\t\twhereClauseTotal = ` JOIN lineages on lineages.id=t.lineage_id WHERE lineages.value = ?`\n\t}\n\n\trow := db.Raw(\"SELECT count(*) FROM plans AS t\"+whereClauseTotal, lineage).Row()\n\tif err := row.Scan(&total); err != nil {\n\t\tlog.Error(err.Error())\n\t}\n\n\tvar limit int\n\tif limitStr == \"\" {\n\t\tlimit = -1\n\t} else {\n\t\tvar err error\n\t\tlimit, err = strconv.Atoi(limitStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans limit ignored: %v\", err)\n\t\t\tlimit = -1\n\t\t}\n\t}\n\n\tvar offset int\n\tif pageStr == \"\" {\n\t\toffset = -1\n\t} else {\n\t\tvar err error\n\t\tpage, err = strconv.Atoi(pageStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetPlans offset ignored: %v\", err)\n\t\t} else {\n\t\t\toffset = (page - 1) * pageSize\n\t\t}\n\t}\n\n\tdb.Joins(\"Lineage\").\n\t\tPreload(\"ParsedPlan\").\n\t\tPreload(\"ParsedPlan.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tPreload(\"ParsedPlan.Variables\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges\").\n\t\tPreload(\"ParsedPlan.PlanResourceChanges.Change\").\n\t\tPreload(\"ParsedPlan.PlanOutputs\").\n\t\tPreload(\"ParsedPlan.PlanOutputs.Change\").\n\t\tPreload(\"ParsedPlan.PlanState\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateOutputs\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateResources.PlanStateResourceAttributes\").\n\t\tPreload(\"ParsedPlan.PlanState.PlanStateValue.PlanStateModule.PlanStateModules\").\n\t\tOrder(\"created_at desc\").\n\t\tLimit(limit).\n\t\tOffset(offset).\n\t\tFind(&plans, whereClause...)\n\n\treturn\n}\n\n// GetLineages retrieves all Lineage from the database\nfunc (db *Database) GetLineages(limitStr string) (lineages []types.Lineage) {\n\tvar limit int\n\tif limitStr == \"\" {\n\t\tlimit = -1\n\t} else {\n\t\tvar err error\n\t\tlimit, err = strconv.Atoi(limitStr)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"GetLineages limit ignored: %v\", err)\n\t\t\tlimit = -1\n\t\t}\n\t}\n\n\tdb.Order(\"created_at desc\").\n\t\tLimit(limit).\n\t\tFind(&lineages)\n\treturn\n}\n\n// DefaultVersion returns the default VersionID for a given Lineage\n// Copied and adapted from github.com/hashicorp/terraform/command/jsonstate/state.go\nfunc (db *Database) DefaultVersion(lineage string) (version string, err error) {\n\tsqlQuery := \"SELECT versions.version_id FROM\" +\n\t\t\" (SELECT states.path, max(states.serial) as mx FROM states GROUP BY states.path) t\" +\n\t\t\" JOIN states ON t.path = states.path AND t.mx = states.serial\" +\n\t\t\" JOIN versions on states.version_id=versions.id\" +\n\t\t\" JOIN lineages on lineages.id=states.lineage_id\" +\n\t\t\" WHERE lineages.value = ?\" +\n\t\t\" ORDER BY versions.last_modified DESC\"\n\n\trow := db.Raw(sqlQuery, lineage).Row()\n\terr = row.Scan(&version)\n\treturn\n}\n\n// Close get generic database interface *sql.DB from the current *gorm.DB\n// and close it\nfunc (db *Database) Close() {\n\tsqlDb, err := db.DB.DB()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to terminate db instance: %v\\n\", err)\n\t}\n\tsqlDb.Close()\n}\n"], "filenames": ["db/db.go"], "buggy_code_start_loc": [373], "buggy_code_end_loc": [378], "fixing_code_start_loc": [373], "fixing_code_end_loc": [380], "type": "CWE-89", "message": "SQL Injection in GitHub repository camptocamp/terraboard prior to 2.2.0.", "other": {"cve": {"id": "CVE-2022-1883", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-25T09:15:08.110", "lastModified": "2022-06-03T14:05:34.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQL Injection in GitHub repository camptocamp/terraboard prior to 2.2.0."}, {"lang": "es", "value": "Una Inyecci\u00f3n SQL en el repositorio GitHub camptocamp/terraboard versiones anteriores a 2.2.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:camptocamp:terraboard:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.0", "matchCriteriaId": "F05076D3-60AE-4318-BEA3-73B7FFCAC9AC"}]}]}], "references": [{"url": "https://github.com/camptocamp/terraboard/commit/2a5dbaac015dc0714b41a59995e24f5767f89ddc", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a25d15bd-cd23-487e-85cd-587960f1b9e7", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/camptocamp/terraboard/commit/2a5dbaac015dc0714b41a59995e24f5767f89ddc"}}