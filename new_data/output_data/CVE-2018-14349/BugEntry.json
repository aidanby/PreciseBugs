{"buggy_code": ["/**\n * @file\n * Send/receive commands to/from an IMAP server\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2011 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_command Send/receive commands to/from an IMAP server\n *\n * Send/receive commands to/from an IMAP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"buffy.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_menu.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n\n#define IMAP_CMD_BUFSIZE 512\n\n/**\n * Capabilities - Server capabilities strings that we understand\n *\n * @note This must be kept in the same order as ImapCaps.\n *\n * @note Gmail documents one string but use another, so we support both.\n */\nstatic const char *const Capabilities[] = {\n  \"IMAP4\",     \"IMAP4rev1\",     \"STATUS\",      \"ACL\",\n  \"NAMESPACE\", \"AUTH=CRAM-MD5\", \"AUTH=GSSAPI\", \"AUTH=ANONYMOUS\",\n  \"STARTTLS\",  \"LOGINDISABLED\", \"IDLE\",        \"SASL-IR\",\n  \"ENABLE\",    \"X-GM-EXT-1\",    \"X-GM-EXT1\",   NULL,\n};\n\n/**\n * cmd_queue_full - Is the IMAP command queue full?\n * @param idata Server data\n * @retval true Queue is full\n */\nstatic bool cmd_queue_full(struct ImapData *idata)\n{\n  if ((idata->nextcmd + 1) % idata->cmdslots == idata->lastcmd)\n    return true;\n\n  return false;\n}\n\n/**\n * cmd_new - Create and queue a new command control block\n * @param idata IMAP data\n * @retval NULL if the pipeline is full\n * @retval ptr New command\n */\nstatic struct ImapCommand *cmd_new(struct ImapData *idata)\n{\n  struct ImapCommand *cmd = NULL;\n\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"IMAP command queue full\\n\");\n    return NULL;\n  }\n\n  cmd = idata->cmds + idata->nextcmd;\n  idata->nextcmd = (idata->nextcmd + 1) % idata->cmdslots;\n\n  snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", idata->seqno++);\n  if (idata->seqno > 9999)\n    idata->seqno = 0;\n\n  cmd->state = IMAP_CMD_NEW;\n\n  return cmd;\n}\n\n/**\n * cmd_queue - Add a IMAP command to the queue\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Server flags, e.g. #IMAP_CMD_POLL\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If the queue is full, attempts to drain it.\n */\nstatic int cmd_queue(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"Draining IMAP command pipeline\\n\");\n\n    const int rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));\n\n    if (rc < 0 && rc != -2)\n      return rc;\n  }\n\n  struct ImapCommand *cmd = cmd_new(idata);\n  if (!cmd)\n    return IMAP_CMD_BAD;\n\n  if (mutt_buffer_printf(idata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)\n    return IMAP_CMD_BAD;\n\n  return 0;\n}\n\n/**\n * cmd_handle_fatal - When ImapData is in fatal state, do what we can\n * @param idata Server data\n */\nstatic void cmd_handle_fatal(struct ImapData *idata)\n{\n  idata->status = IMAP_FATAL;\n\n  if ((idata->state >= IMAP_SELECTED) && (idata->reopen & IMAP_REOPEN_ALLOW))\n  {\n    mx_fastclose_mailbox(idata->ctx);\n    mutt_socket_close(idata->conn);\n    mutt_error(_(\"Mailbox %s@%s closed\"), idata->conn->account.login,\n               idata->conn->account.host);\n    idata->state = IMAP_DISCONNECTED;\n  }\n\n  imap_close_connection(idata);\n  if (!idata->recovering)\n  {\n    idata->recovering = true;\n    if (imap_conn_find(&idata->conn->account, 0))\n      mutt_clear_error();\n    idata->recovering = false;\n  }\n}\n\n/**\n * cmd_start - Start a new IMAP command\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Command flags, e.g. #IMAP_CMD_QUEUE\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_start(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (cmdstr && ((rc = cmd_queue(idata, cmdstr, flags)) < 0))\n    return rc;\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if (idata->cmdbuf->dptr == idata->cmdbuf->data)\n    return IMAP_CMD_BAD;\n\n  rc = mutt_socket_send_d(idata->conn, idata->cmdbuf->data,\n                          (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);\n  idata->cmdbuf->dptr = idata->cmdbuf->data;\n\n  /* unidle when command queue is flushed */\n  if (idata->state == IMAP_IDLE)\n    idata->state = IMAP_SELECTED;\n\n  return (rc < 0) ? IMAP_CMD_BAD : 0;\n}\n\n/**\n * cmd_status - parse response line for tagged OK/NO/BAD\n * @param s Status string from server\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_status(const char *s)\n{\n  s = imap_next_word((char *) s);\n\n  if (mutt_str_strncasecmp(\"OK\", s, 2) == 0)\n    return IMAP_CMD_OK;\n  if (mutt_str_strncasecmp(\"NO\", s, 2) == 0)\n    return IMAP_CMD_NO;\n\n  return IMAP_CMD_BAD;\n}\n\n/**\n * cmd_parse_expunge - Parse expunge command\n * @param idata Server data\n * @param s     String containing MSN of message to expunge\n *\n * cmd_parse_expunge: mark headers with new sequence ID and mark idata to be\n * reopened at our earliest convenience\n */\nstatic void cmd_parse_expunge(struct ImapData *idata, const char *s)\n{\n  unsigned int exp_msn;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling EXPUNGE\\n\");\n\n  if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > idata->max_msn)\n    return;\n\n  h = idata->msn_index[exp_msn - 1];\n  if (h)\n  {\n    /* imap_expunge_mailbox() will rewrite h->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    h->index = INT_MAX;\n    HEADER_DATA(h)->msn = 0;\n  }\n\n  /* decrement seqno of those above. */\n  for (unsigned int cur = exp_msn; cur < idata->max_msn; cur++)\n  {\n    h = idata->msn_index[cur];\n    if (h)\n      HEADER_DATA(h)->msn--;\n    idata->msn_index[cur - 1] = h;\n  }\n\n  idata->msn_index[idata->max_msn - 1] = NULL;\n  idata->max_msn--;\n\n  idata->reopen |= IMAP_EXPUNGE_PENDING;\n}\n\n/**\n * cmd_parse_fetch - Load fetch response into ImapData\n * @param idata Server data\n * @param s     String containing MSN of message to fetch\n *\n * Currently only handles unanticipated FETCH responses, and only FLAGS data.\n * We get these if another client has changed flags for a mailbox we've\n * selected.  Of course, a lot of code here duplicates code in message.c.\n */\nstatic void cmd_parse_fetch(struct ImapData *idata, char *s)\n{\n  unsigned int msn, uid;\n  struct Header *h = NULL;\n  int server_changes = 0;\n\n  mutt_debug(3, \"Handling FETCH\\n\");\n\n  if (mutt_str_atoui(s, &msn) < 0 || msn < 1 || msn > idata->max_msn)\n  {\n    mutt_debug(3, \"#1 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  h = idata->msn_index[msn - 1];\n  if (!h || !h->active)\n  {\n    mutt_debug(3, \"#2 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  mutt_debug(2, \"Message UID %u updated\\n\", HEADER_DATA(h)->uid);\n  /* skip FETCH */\n  s = imap_next_word(s);\n  s = imap_next_word(s);\n\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Malformed FETCH response\\n\");\n    return;\n  }\n  s++;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      imap_set_flags(idata, h, s, &server_changes);\n      if (server_changes)\n      {\n        /* If server flags could conflict with neomutt's flags, reopen the mailbox. */\n        if (h->changed)\n          idata->reopen |= IMAP_EXPUNGE_PENDING;\n        else\n          idata->check_status = IMAP_FLAGS_PENDING;\n      }\n      return;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &uid) < 0)\n      {\n        mutt_debug(2, \"Illegal UID.  Skipping update.\\n\");\n        return;\n      }\n      if (uid != HEADER_DATA(h)->uid)\n      {\n        mutt_debug(2, \"FETCH UID vs MSN mismatch.  Skipping update.\\n\");\n        return;\n      }\n      s = imap_next_word(s);\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      mutt_debug(2, \"Only handle FLAGS updates\\n\");\n      return;\n    }\n  }\n}\n\n/**\n * cmd_parse_capability - set capability bits according to CAPABILITY response\n * @param idata Server data\n * @param s     Command string with capabilities\n */\nstatic void cmd_parse_capability(struct ImapData *idata, char *s)\n{\n  mutt_debug(3, \"Handling CAPABILITY\\n\");\n\n  s = imap_next_word(s);\n  char *bracket = strchr(s, ']');\n  if (bracket)\n    *bracket = '\\0';\n  FREE(&idata->capstr);\n  idata->capstr = mutt_str_strdup(s);\n\n  memset(idata->capabilities, 0, sizeof(idata->capabilities));\n\n  while (*s)\n  {\n    for (int i = 0; i < CAPMAX; i++)\n    {\n      if (mutt_str_word_casecmp(Capabilities[i], s) == 0)\n      {\n        mutt_bit_set(idata->capabilities, i);\n        mutt_debug(4, \" Found capability \\\"%s\\\": %d\\n\", Capabilities[i], i);\n        break;\n      }\n    }\n    s = imap_next_word(s);\n  }\n}\n\n/**\n * cmd_parse_list - Parse a server LIST command (list mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_list(struct ImapData *idata, char *s)\n{\n  struct ImapList *list = NULL;\n  struct ImapList lb;\n  char delimbuf[5]; /* worst case: \"\\\\\"\\0 */\n  unsigned int litlen;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n    list = (struct ImapList *) idata->cmddata;\n  else\n    list = &lb;\n\n  memset(list, 0, sizeof(struct ImapList));\n\n  /* flags */\n  s = imap_next_word(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Bad LIST response\\n\");\n    return;\n  }\n  s++;\n  while (*s)\n  {\n    if (mutt_str_strncasecmp(s, \"\\\\NoSelect\", 9) == 0)\n      list->noselect = true;\n    else if (mutt_str_strncasecmp(s, \"\\\\NoInferiors\", 12) == 0)\n      list->noinferiors = true;\n    /* See draft-gahrns-imap-child-mailbox-?? */\n    else if (mutt_str_strncasecmp(s, \"\\\\HasNoChildren\", 14) == 0)\n      list->noinferiors = true;\n\n    s = imap_next_word(s);\n    if (*(s - 2) == ')')\n      break;\n  }\n\n  /* Delimiter */\n  if (mutt_str_strncasecmp(s, \"NIL\", 3) != 0)\n  {\n    delimbuf[0] = '\\0';\n    mutt_str_strcat(delimbuf, 5, s);\n    imap_unquote_string(delimbuf);\n    list->delim = delimbuf[0];\n  }\n\n  /* Name */\n  s = imap_next_word(s);\n  /* Notes often responds with literals here. We need a real tokenizer. */\n  if (imap_get_literal_count(s, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    list->name = idata->buf;\n  }\n  else\n  {\n    imap_unmunge_mbox_name(idata, s);\n    list->name = s;\n  }\n\n  if (list->name[0] == '\\0')\n  {\n    idata->delim = list->delim;\n    mutt_debug(3, \"Root delimiter: %c\\n\", idata->delim);\n  }\n}\n\n/**\n * cmd_parse_lsub - Parse a server LSUB (list subscribed mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}\n\n/**\n * cmd_parse_myrights - Set rights bits according to MYRIGHTS response\n * @param idata Server data\n * @param s     Command string with rights info\n */\nstatic void cmd_parse_myrights(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling MYRIGHTS\\n\");\n\n  s = imap_next_word((char *) s);\n  s = imap_next_word((char *) s);\n\n  /* zero out current rights set */\n  memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));\n\n  while (*s && !isspace((unsigned char) *s))\n  {\n    switch (*s)\n    {\n      case 'a':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_ADMIN);\n        break;\n      case 'e':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      case 'i':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);\n        break;\n      case 'k':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        break;\n      case 'l':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);\n        break;\n      case 'p':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);\n        break;\n      case 'r':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);\n        break;\n      case 's':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);\n        break;\n      case 't':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        break;\n      case 'w':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);\n        break;\n      case 'x':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n\n      /* obsolete rights */\n      case 'c':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n      case 'd':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      default:\n        mutt_debug(1, \"Unknown right: %c\\n\", *s);\n    }\n    s++;\n  }\n}\n\n/**\n * cmd_parse_search - store SEARCH response for later use\n * @param idata Server data\n * @param s     Command string with search results\n */\nstatic void cmd_parse_search(struct ImapData *idata, const char *s)\n{\n  unsigned int uid;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling SEARCH\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if (mutt_str_atoui(s, &uid) < 0)\n      continue;\n    h = (struct Header *) mutt_hash_int_find(idata->uid_hash, uid);\n    if (h)\n      h->matched = true;\n  }\n}\n\n/**\n * cmd_parse_status - Parse status from server\n * @param idata Server data\n * @param s     Command string with status info\n *\n * first cut: just do buffy update. Later we may wish to cache all mailbox\n * information, even that not desired by buffy\n */\nstatic void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    mailbox = idata->buf;\n    s = mailbox + litlen;\n    *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n\n/**\n * cmd_parse_enabled - Record what the server has enabled\n * @param idata Server data\n * @param s     Command string containing acceptable encodings\n */\nstatic void cmd_parse_enabled(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling ENABLED\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if ((mutt_str_strncasecmp(s, \"UTF8=ACCEPT\", 11) == 0) ||\n        (mutt_str_strncasecmp(s, \"UTF8=ONLY\", 9) == 0))\n    {\n      idata->unicode = 1;\n    }\n  }\n}\n\n/**\n * cmd_handle_untagged - fallback parser for otherwise unhandled messages\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int cmd_handle_untagged(struct ImapData *idata)\n{\n  unsigned int count = 0;\n  char *s = imap_next_word(idata->buf);\n  char *pn = imap_next_word(s);\n\n  if ((idata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))\n  {\n    pn = s;\n    s = imap_next_word(s);\n\n    /* EXISTS and EXPUNGE are always related to the SELECTED mailbox for the\n     * connection, so update that one.\n     */\n    if (mutt_str_strncasecmp(\"EXISTS\", s, 6) == 0)\n    {\n      mutt_debug(2, \"Handling EXISTS\\n\");\n\n      /* new mail arrived */\n      if (mutt_str_atoui(pn, &count) < 0)\n      {\n        mutt_debug(1, \"Malformed EXISTS: '%s'\\n\", pn);\n      }\n\n      if (!(idata->reopen & IMAP_EXPUNGE_PENDING) && count < idata->max_msn)\n      {\n        /* Notes 6.0.3 has a tendency to report fewer messages exist than\n         * it should. */\n        mutt_debug(1, \"Message count is out of sync\\n\");\n        return 0;\n      }\n      /* at least the InterChange server sends EXISTS messages freely,\n       * even when there is no new mail */\n      else if (count == idata->max_msn)\n        mutt_debug(3, \"superfluous EXISTS message.\\n\");\n      else\n      {\n        if (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n        {\n          mutt_debug(2, \"New mail in %s - %d messages total.\\n\", idata->mailbox, count);\n          idata->reopen |= IMAP_NEWMAIL_PENDING;\n        }\n        idata->new_mail_count = count;\n      }\n    }\n    /* pn vs. s: need initial seqno */\n    else if (mutt_str_strncasecmp(\"EXPUNGE\", s, 7) == 0)\n      cmd_parse_expunge(idata, pn);\n    else if (mutt_str_strncasecmp(\"FETCH\", s, 5) == 0)\n      cmd_parse_fetch(idata, pn);\n  }\n  else if (mutt_str_strncasecmp(\"CAPABILITY\", s, 10) == 0)\n    cmd_parse_capability(idata, s);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", s, 14) == 0)\n    cmd_parse_capability(idata, pn);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", pn, 14) == 0)\n    cmd_parse_capability(idata, imap_next_word(pn));\n  else if (mutt_str_strncasecmp(\"LIST\", s, 4) == 0)\n    cmd_parse_list(idata, s);\n  else if (mutt_str_strncasecmp(\"LSUB\", s, 4) == 0)\n    cmd_parse_lsub(idata, s);\n  else if (mutt_str_strncasecmp(\"MYRIGHTS\", s, 8) == 0)\n    cmd_parse_myrights(idata, s);\n  else if (mutt_str_strncasecmp(\"SEARCH\", s, 6) == 0)\n    cmd_parse_search(idata, s);\n  else if (mutt_str_strncasecmp(\"STATUS\", s, 6) == 0)\n    cmd_parse_status(idata, s);\n  else if (mutt_str_strncasecmp(\"ENABLED\", s, 7) == 0)\n    cmd_parse_enabled(idata, s);\n  else if (mutt_str_strncasecmp(\"BYE\", s, 3) == 0)\n  {\n    mutt_debug(2, \"Handling BYE\\n\");\n\n    /* check if we're logging out */\n    if (idata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS(s);\n    mutt_error(\"%s\", s);\n    cmd_handle_fatal(idata);\n\n    return -1;\n  }\n  else if (ImapServernoise && (mutt_str_strncasecmp(\"NO\", s, 2) == 0))\n  {\n    mutt_debug(2, \"Handling untagged NO\\n\");\n\n    /* Display the warning message from the server */\n    mutt_error(\"%s\", s + 3);\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_start - Given an IMAP command, send it to the server\n * @param idata  Server data\n * @param cmdstr Command string to send\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If cmdstr is NULL, sends queued commands.\n */\nint imap_cmd_start(struct ImapData *idata, const char *cmdstr)\n{\n  return cmd_start(idata, cmdstr, 0);\n}\n\n/**\n * imap_cmd_step - Reads server responses from an IMAP command\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * detects tagged completion response, handles untagged messages, can read\n * arbitrarily large strings (using malloc, so don't make it _too_ large!).\n */\nint imap_cmd_step(struct ImapData *idata)\n{\n  size_t len = 0;\n  int c;\n  int rc;\n  int stillrunning = 0;\n  struct ImapCommand *cmd = NULL;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return IMAP_CMD_BAD;\n  }\n\n  /* read into buffer, expanding buffer as necessary until we have a full\n   * line */\n  do\n  {\n    if (len == idata->blen)\n    {\n      mutt_mem_realloc(&idata->buf, idata->blen + IMAP_CMD_BUFSIZE);\n      idata->blen = idata->blen + IMAP_CMD_BUFSIZE;\n      mutt_debug(3, \"grew buffer to %u bytes\\n\", idata->blen);\n    }\n\n    /* back up over '\\0' */\n    if (len)\n      len--;\n    c = mutt_socket_readln(idata->buf + len, idata->blen - len, idata->conn);\n    if (c <= 0)\n    {\n      mutt_debug(1, \"Error reading server response.\\n\");\n      cmd_handle_fatal(idata);\n      return IMAP_CMD_BAD;\n    }\n\n    len += c;\n  }\n  /* if we've read all the way to the end of the buffer, we haven't read a\n   * full line (mutt_socket_readln strips the \\r, so we always have at least\n   * one character free when we've read a full line) */\n  while (len == idata->blen);\n\n  /* don't let one large string make cmd->buf hog memory forever */\n  if ((idata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))\n  {\n    mutt_mem_realloc(&idata->buf, IMAP_CMD_BUFSIZE);\n    idata->blen = IMAP_CMD_BUFSIZE;\n    mutt_debug(3, \"shrank buffer to %u bytes\\n\", idata->blen);\n  }\n\n  idata->lastread = time(NULL);\n\n  /* handle untagged messages. The caller still gets its shot afterwards. */\n  if (((mutt_str_strncmp(idata->buf, \"* \", 2) == 0) ||\n       (mutt_str_strncmp(imap_next_word(idata->buf), \"OK [\", 4) == 0)) &&\n      cmd_handle_untagged(idata))\n  {\n    return IMAP_CMD_BAD;\n  }\n\n  /* server demands a continuation response from us */\n  if (idata->buf[0] == '+')\n    return IMAP_CMD_RESPOND;\n\n  /* Look for tagged command completions.\n   *\n   * Some response handlers can end up recursively calling\n   * imap_cmd_step() and end up handling all tagged command\n   * completions.\n   * (e.g. FETCH->set_flag->set_header_color->~h pattern match.)\n   *\n   * Other callers don't even create an idata->cmds entry.\n   *\n   * For both these cases, we default to returning OK */\n  rc = IMAP_CMD_OK;\n  c = idata->lastcmd;\n  do\n  {\n    cmd = &idata->cmds[c];\n    if (cmd->state == IMAP_CMD_NEW)\n    {\n      if (mutt_str_strncmp(idata->buf, cmd->seq, SEQLEN) == 0)\n      {\n        if (!stillrunning)\n        {\n          /* first command in queue has finished - move queue pointer up */\n          idata->lastcmd = (idata->lastcmd + 1) % idata->cmdslots;\n        }\n        cmd->state = cmd_status(idata->buf);\n        /* bogus - we don't know which command result to return here. Caller\n         * should provide a tag. */\n        rc = cmd->state;\n      }\n      else\n        stillrunning++;\n    }\n\n    c = (c + 1) % idata->cmdslots;\n  } while (c != idata->nextcmd);\n\n  if (stillrunning)\n    rc = IMAP_CMD_CONTINUE;\n  else\n  {\n    mutt_debug(3, \"IMAP queue drained\\n\");\n    imap_cmd_finish(idata);\n  }\n\n  return rc;\n}\n\n/**\n * imap_code - Was the command successful\n * @param s IMAP command status\n * @retval 1 Command result was OK\n * @retval 0 If NO or BAD\n */\nbool imap_code(const char *s)\n{\n  return (cmd_status(s) == IMAP_CMD_OK);\n}\n\n/**\n * imap_cmd_trailer - Extra information after tagged command response if any\n * @param idata Server data\n * @retval ptr Extra command information (pointer into idata->buf)\n * @retval \"\"  Error (static string)\n */\nconst char *imap_cmd_trailer(struct ImapData *idata)\n{\n  static const char *notrailer = \"\";\n  const char *s = idata->buf;\n\n  if (!s)\n  {\n    mutt_debug(2, \"not a tagged response\\n\");\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s || ((mutt_str_strncasecmp(s, \"OK\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"NO\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"BAD\", 3) != 0)))\n  {\n    mutt_debug(2, \"not a command completion: %s\\n\", idata->buf);\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s)\n    return notrailer;\n\n  return s;\n}\n\n/**\n * imap_exec - Execute a command and wait for the response from the server\n * @param idata  IMAP data\n * @param cmdstr Command to execute\n * @param flags  Flags (see below)\n * @retval  0 Success\n * @retval -1 Failure\n * @retval -2 OK Failure\n *\n * Also, handle untagged responses.\n *\n * Flags:\n * * IMAP_CMD_FAIL_OK: the calling procedure can handle failure.\n *       This is used for checking for a mailbox on append and login\n * * IMAP_CMD_PASS: command contains a password. Suppress logging.\n * * IMAP_CMD_QUEUE: only queue command, do not execute.\n * * IMAP_CMD_POLL: poll the socket for a response before running imap_cmd_step.\n */\nint imap_exec(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  rc = cmd_start(idata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if ((flags & IMAP_CMD_POLL) && (ImapPollTimeout > 0) &&\n      (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(1);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  mutt_sig_allow_interrupt(0);\n\n  if (rc == IMAP_CMD_NO && (flags & IMAP_CMD_FAIL_OK))\n    return -2;\n\n  if (rc != IMAP_CMD_OK)\n  {\n    if ((flags & IMAP_CMD_FAIL_OK) && idata->status != IMAP_FATAL)\n      return -2;\n\n    mutt_debug(1, \"command failed: %s\\n\", idata->buf);\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_finish - Attempt to perform cleanup\n * @param idata Server data\n *\n * Attempts to perform cleanup (eg fetch new mail if detected, do expunge).\n * Called automatically by imap_cmd_step(), but may be called at any time.\n * Called by imap_check_mailbox() just before the index is refreshed, for\n * instance.\n */\nvoid imap_cmd_finish(struct ImapData *idata)\n{\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return;\n  }\n\n  if (!(idata->state >= IMAP_SELECTED) || idata->ctx->closing)\n    return;\n\n  if (idata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    unsigned int count = idata->new_mail_count;\n\n    if (!(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n        (idata->reopen & IMAP_NEWMAIL_PENDING) && count > idata->max_msn)\n    {\n      /* read new mail messages */\n      mutt_debug(2, \"Fetching new mail\\n\");\n      /* check_status: curs_main uses imap_check_mailbox to detect\n       *   whether the index needs updating */\n      idata->check_status = IMAP_NEWMAIL_PENDING;\n      imap_read_headers(idata, idata->max_msn + 1, count);\n    }\n    else if (idata->reopen & IMAP_EXPUNGE_PENDING)\n    {\n      mutt_debug(2, \"Expunging mailbox\\n\");\n      imap_expunge_mailbox(idata);\n      /* Detect whether we've gotten unexpected EXPUNGE messages */\n      if ((idata->reopen & IMAP_EXPUNGE_PENDING) && !(idata->reopen & IMAP_EXPUNGE_EXPECTED))\n        idata->check_status = IMAP_EXPUNGE_PENDING;\n      idata->reopen &=\n          ~(IMAP_EXPUNGE_PENDING | IMAP_NEWMAIL_PENDING | IMAP_EXPUNGE_EXPECTED);\n    }\n  }\n\n  idata->status = false;\n}\n\n/**\n * imap_cmd_idle - Enter the IDLE state\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nint imap_cmd_idle(struct ImapData *idata)\n{\n  int rc;\n\n  if (cmd_start(idata, \"IDLE\", IMAP_CMD_POLL) < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if ((ImapPollTimeout > 0) && (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_RESPOND)\n  {\n    /* successfully entered IDLE state */\n    idata->state = IMAP_IDLE;\n    /* queue automatic exit when next command is issued */\n    mutt_buffer_printf(idata->cmdbuf, \"DONE\\r\\n\");\n    rc = IMAP_CMD_OK;\n  }\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"error starting IDLE\\n\");\n    return -1;\n  }\n\n  return 0;\n}\n"], "fixing_code": ["/**\n * @file\n * Send/receive commands to/from an IMAP server\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2011 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_command Send/receive commands to/from an IMAP server\n *\n * Send/receive commands to/from an IMAP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"buffy.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_menu.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n\n#define IMAP_CMD_BUFSIZE 512\n\n/**\n * Capabilities - Server capabilities strings that we understand\n *\n * @note This must be kept in the same order as ImapCaps.\n *\n * @note Gmail documents one string but use another, so we support both.\n */\nstatic const char *const Capabilities[] = {\n  \"IMAP4\",     \"IMAP4rev1\",     \"STATUS\",      \"ACL\",\n  \"NAMESPACE\", \"AUTH=CRAM-MD5\", \"AUTH=GSSAPI\", \"AUTH=ANONYMOUS\",\n  \"STARTTLS\",  \"LOGINDISABLED\", \"IDLE\",        \"SASL-IR\",\n  \"ENABLE\",    \"X-GM-EXT-1\",    \"X-GM-EXT1\",   NULL,\n};\n\n/**\n * cmd_queue_full - Is the IMAP command queue full?\n * @param idata Server data\n * @retval true Queue is full\n */\nstatic bool cmd_queue_full(struct ImapData *idata)\n{\n  if ((idata->nextcmd + 1) % idata->cmdslots == idata->lastcmd)\n    return true;\n\n  return false;\n}\n\n/**\n * cmd_new - Create and queue a new command control block\n * @param idata IMAP data\n * @retval NULL if the pipeline is full\n * @retval ptr New command\n */\nstatic struct ImapCommand *cmd_new(struct ImapData *idata)\n{\n  struct ImapCommand *cmd = NULL;\n\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"IMAP command queue full\\n\");\n    return NULL;\n  }\n\n  cmd = idata->cmds + idata->nextcmd;\n  idata->nextcmd = (idata->nextcmd + 1) % idata->cmdslots;\n\n  snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", idata->seqno++);\n  if (idata->seqno > 9999)\n    idata->seqno = 0;\n\n  cmd->state = IMAP_CMD_NEW;\n\n  return cmd;\n}\n\n/**\n * cmd_queue - Add a IMAP command to the queue\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Server flags, e.g. #IMAP_CMD_POLL\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If the queue is full, attempts to drain it.\n */\nstatic int cmd_queue(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"Draining IMAP command pipeline\\n\");\n\n    const int rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));\n\n    if (rc < 0 && rc != -2)\n      return rc;\n  }\n\n  struct ImapCommand *cmd = cmd_new(idata);\n  if (!cmd)\n    return IMAP_CMD_BAD;\n\n  if (mutt_buffer_printf(idata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)\n    return IMAP_CMD_BAD;\n\n  return 0;\n}\n\n/**\n * cmd_handle_fatal - When ImapData is in fatal state, do what we can\n * @param idata Server data\n */\nstatic void cmd_handle_fatal(struct ImapData *idata)\n{\n  idata->status = IMAP_FATAL;\n\n  if ((idata->state >= IMAP_SELECTED) && (idata->reopen & IMAP_REOPEN_ALLOW))\n  {\n    mx_fastclose_mailbox(idata->ctx);\n    mutt_socket_close(idata->conn);\n    mutt_error(_(\"Mailbox %s@%s closed\"), idata->conn->account.login,\n               idata->conn->account.host);\n    idata->state = IMAP_DISCONNECTED;\n  }\n\n  imap_close_connection(idata);\n  if (!idata->recovering)\n  {\n    idata->recovering = true;\n    if (imap_conn_find(&idata->conn->account, 0))\n      mutt_clear_error();\n    idata->recovering = false;\n  }\n}\n\n/**\n * cmd_start - Start a new IMAP command\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Command flags, e.g. #IMAP_CMD_QUEUE\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_start(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (cmdstr && ((rc = cmd_queue(idata, cmdstr, flags)) < 0))\n    return rc;\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if (idata->cmdbuf->dptr == idata->cmdbuf->data)\n    return IMAP_CMD_BAD;\n\n  rc = mutt_socket_send_d(idata->conn, idata->cmdbuf->data,\n                          (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);\n  idata->cmdbuf->dptr = idata->cmdbuf->data;\n\n  /* unidle when command queue is flushed */\n  if (idata->state == IMAP_IDLE)\n    idata->state = IMAP_SELECTED;\n\n  return (rc < 0) ? IMAP_CMD_BAD : 0;\n}\n\n/**\n * cmd_status - parse response line for tagged OK/NO/BAD\n * @param s Status string from server\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_status(const char *s)\n{\n  s = imap_next_word((char *) s);\n\n  if (mutt_str_strncasecmp(\"OK\", s, 2) == 0)\n    return IMAP_CMD_OK;\n  if (mutt_str_strncasecmp(\"NO\", s, 2) == 0)\n    return IMAP_CMD_NO;\n\n  return IMAP_CMD_BAD;\n}\n\n/**\n * cmd_parse_expunge - Parse expunge command\n * @param idata Server data\n * @param s     String containing MSN of message to expunge\n *\n * cmd_parse_expunge: mark headers with new sequence ID and mark idata to be\n * reopened at our earliest convenience\n */\nstatic void cmd_parse_expunge(struct ImapData *idata, const char *s)\n{\n  unsigned int exp_msn;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling EXPUNGE\\n\");\n\n  if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > idata->max_msn)\n    return;\n\n  h = idata->msn_index[exp_msn - 1];\n  if (h)\n  {\n    /* imap_expunge_mailbox() will rewrite h->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    h->index = INT_MAX;\n    HEADER_DATA(h)->msn = 0;\n  }\n\n  /* decrement seqno of those above. */\n  for (unsigned int cur = exp_msn; cur < idata->max_msn; cur++)\n  {\n    h = idata->msn_index[cur];\n    if (h)\n      HEADER_DATA(h)->msn--;\n    idata->msn_index[cur - 1] = h;\n  }\n\n  idata->msn_index[idata->max_msn - 1] = NULL;\n  idata->max_msn--;\n\n  idata->reopen |= IMAP_EXPUNGE_PENDING;\n}\n\n/**\n * cmd_parse_fetch - Load fetch response into ImapData\n * @param idata Server data\n * @param s     String containing MSN of message to fetch\n *\n * Currently only handles unanticipated FETCH responses, and only FLAGS data.\n * We get these if another client has changed flags for a mailbox we've\n * selected.  Of course, a lot of code here duplicates code in message.c.\n */\nstatic void cmd_parse_fetch(struct ImapData *idata, char *s)\n{\n  unsigned int msn, uid;\n  struct Header *h = NULL;\n  int server_changes = 0;\n\n  mutt_debug(3, \"Handling FETCH\\n\");\n\n  if (mutt_str_atoui(s, &msn) < 0 || msn < 1 || msn > idata->max_msn)\n  {\n    mutt_debug(3, \"#1 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  h = idata->msn_index[msn - 1];\n  if (!h || !h->active)\n  {\n    mutt_debug(3, \"#2 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  mutt_debug(2, \"Message UID %u updated\\n\", HEADER_DATA(h)->uid);\n  /* skip FETCH */\n  s = imap_next_word(s);\n  s = imap_next_word(s);\n\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Malformed FETCH response\\n\");\n    return;\n  }\n  s++;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      imap_set_flags(idata, h, s, &server_changes);\n      if (server_changes)\n      {\n        /* If server flags could conflict with neomutt's flags, reopen the mailbox. */\n        if (h->changed)\n          idata->reopen |= IMAP_EXPUNGE_PENDING;\n        else\n          idata->check_status = IMAP_FLAGS_PENDING;\n      }\n      return;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &uid) < 0)\n      {\n        mutt_debug(2, \"Illegal UID.  Skipping update.\\n\");\n        return;\n      }\n      if (uid != HEADER_DATA(h)->uid)\n      {\n        mutt_debug(2, \"FETCH UID vs MSN mismatch.  Skipping update.\\n\");\n        return;\n      }\n      s = imap_next_word(s);\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      mutt_debug(2, \"Only handle FLAGS updates\\n\");\n      return;\n    }\n  }\n}\n\n/**\n * cmd_parse_capability - set capability bits according to CAPABILITY response\n * @param idata Server data\n * @param s     Command string with capabilities\n */\nstatic void cmd_parse_capability(struct ImapData *idata, char *s)\n{\n  mutt_debug(3, \"Handling CAPABILITY\\n\");\n\n  s = imap_next_word(s);\n  char *bracket = strchr(s, ']');\n  if (bracket)\n    *bracket = '\\0';\n  FREE(&idata->capstr);\n  idata->capstr = mutt_str_strdup(s);\n\n  memset(idata->capabilities, 0, sizeof(idata->capabilities));\n\n  while (*s)\n  {\n    for (int i = 0; i < CAPMAX; i++)\n    {\n      if (mutt_str_word_casecmp(Capabilities[i], s) == 0)\n      {\n        mutt_bit_set(idata->capabilities, i);\n        mutt_debug(4, \" Found capability \\\"%s\\\": %d\\n\", Capabilities[i], i);\n        break;\n      }\n    }\n    s = imap_next_word(s);\n  }\n}\n\n/**\n * cmd_parse_list - Parse a server LIST command (list mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_list(struct ImapData *idata, char *s)\n{\n  struct ImapList *list = NULL;\n  struct ImapList lb;\n  char delimbuf[5]; /* worst case: \"\\\\\"\\0 */\n  unsigned int litlen;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n    list = (struct ImapList *) idata->cmddata;\n  else\n    list = &lb;\n\n  memset(list, 0, sizeof(struct ImapList));\n\n  /* flags */\n  s = imap_next_word(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Bad LIST response\\n\");\n    return;\n  }\n  s++;\n  while (*s)\n  {\n    if (mutt_str_strncasecmp(s, \"\\\\NoSelect\", 9) == 0)\n      list->noselect = true;\n    else if (mutt_str_strncasecmp(s, \"\\\\NoInferiors\", 12) == 0)\n      list->noinferiors = true;\n    /* See draft-gahrns-imap-child-mailbox-?? */\n    else if (mutt_str_strncasecmp(s, \"\\\\HasNoChildren\", 14) == 0)\n      list->noinferiors = true;\n\n    s = imap_next_word(s);\n    if (*(s - 2) == ')')\n      break;\n  }\n\n  /* Delimiter */\n  if (mutt_str_strncasecmp(s, \"NIL\", 3) != 0)\n  {\n    delimbuf[0] = '\\0';\n    mutt_str_strcat(delimbuf, 5, s);\n    imap_unquote_string(delimbuf);\n    list->delim = delimbuf[0];\n  }\n\n  /* Name */\n  s = imap_next_word(s);\n  /* Notes often responds with literals here. We need a real tokenizer. */\n  if (imap_get_literal_count(s, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    list->name = idata->buf;\n  }\n  else\n  {\n    imap_unmunge_mbox_name(idata, s);\n    list->name = s;\n  }\n\n  if (list->name[0] == '\\0')\n  {\n    idata->delim = list->delim;\n    mutt_debug(3, \"Root delimiter: %c\\n\", idata->delim);\n  }\n}\n\n/**\n * cmd_parse_lsub - Parse a server LSUB (list subscribed mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}\n\n/**\n * cmd_parse_myrights - Set rights bits according to MYRIGHTS response\n * @param idata Server data\n * @param s     Command string with rights info\n */\nstatic void cmd_parse_myrights(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling MYRIGHTS\\n\");\n\n  s = imap_next_word((char *) s);\n  s = imap_next_word((char *) s);\n\n  /* zero out current rights set */\n  memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));\n\n  while (*s && !isspace((unsigned char) *s))\n  {\n    switch (*s)\n    {\n      case 'a':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_ADMIN);\n        break;\n      case 'e':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      case 'i':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);\n        break;\n      case 'k':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        break;\n      case 'l':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);\n        break;\n      case 'p':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);\n        break;\n      case 'r':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);\n        break;\n      case 's':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);\n        break;\n      case 't':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        break;\n      case 'w':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);\n        break;\n      case 'x':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n\n      /* obsolete rights */\n      case 'c':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n      case 'd':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      default:\n        mutt_debug(1, \"Unknown right: %c\\n\", *s);\n    }\n    s++;\n  }\n}\n\n/**\n * cmd_parse_search - store SEARCH response for later use\n * @param idata Server data\n * @param s     Command string with search results\n */\nstatic void cmd_parse_search(struct ImapData *idata, const char *s)\n{\n  unsigned int uid;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling SEARCH\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if (mutt_str_atoui(s, &uid) < 0)\n      continue;\n    h = (struct Header *) mutt_hash_int_find(idata->uid_hash, uid);\n    if (h)\n      h->matched = true;\n  }\n}\n\n/**\n * cmd_parse_status - Parse status from server\n * @param idata Server data\n * @param s     Command string with status info\n *\n * first cut: just do buffy update. Later we may wish to cache all mailbox\n * information, even that not desired by buffy\n */\nstatic void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    mailbox = idata->buf;\n    s = mailbox + litlen;\n    *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n\n/**\n * cmd_parse_enabled - Record what the server has enabled\n * @param idata Server data\n * @param s     Command string containing acceptable encodings\n */\nstatic void cmd_parse_enabled(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling ENABLED\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if ((mutt_str_strncasecmp(s, \"UTF8=ACCEPT\", 11) == 0) ||\n        (mutt_str_strncasecmp(s, \"UTF8=ONLY\", 9) == 0))\n    {\n      idata->unicode = 1;\n    }\n  }\n}\n\n/**\n * cmd_handle_untagged - fallback parser for otherwise unhandled messages\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int cmd_handle_untagged(struct ImapData *idata)\n{\n  unsigned int count = 0;\n  char *s = imap_next_word(idata->buf);\n  char *pn = imap_next_word(s);\n\n  if ((idata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))\n  {\n    pn = s;\n    s = imap_next_word(s);\n\n    /* EXISTS and EXPUNGE are always related to the SELECTED mailbox for the\n     * connection, so update that one.\n     */\n    if (mutt_str_strncasecmp(\"EXISTS\", s, 6) == 0)\n    {\n      mutt_debug(2, \"Handling EXISTS\\n\");\n\n      /* new mail arrived */\n      if (mutt_str_atoui(pn, &count) < 0)\n      {\n        mutt_debug(1, \"Malformed EXISTS: '%s'\\n\", pn);\n      }\n\n      if (!(idata->reopen & IMAP_EXPUNGE_PENDING) && count < idata->max_msn)\n      {\n        /* Notes 6.0.3 has a tendency to report fewer messages exist than\n         * it should. */\n        mutt_debug(1, \"Message count is out of sync\\n\");\n        return 0;\n      }\n      /* at least the InterChange server sends EXISTS messages freely,\n       * even when there is no new mail */\n      else if (count == idata->max_msn)\n        mutt_debug(3, \"superfluous EXISTS message.\\n\");\n      else\n      {\n        if (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n        {\n          mutt_debug(2, \"New mail in %s - %d messages total.\\n\", idata->mailbox, count);\n          idata->reopen |= IMAP_NEWMAIL_PENDING;\n        }\n        idata->new_mail_count = count;\n      }\n    }\n    /* pn vs. s: need initial seqno */\n    else if (mutt_str_strncasecmp(\"EXPUNGE\", s, 7) == 0)\n      cmd_parse_expunge(idata, pn);\n    else if (mutt_str_strncasecmp(\"FETCH\", s, 5) == 0)\n      cmd_parse_fetch(idata, pn);\n  }\n  else if (mutt_str_strncasecmp(\"CAPABILITY\", s, 10) == 0)\n    cmd_parse_capability(idata, s);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", s, 14) == 0)\n    cmd_parse_capability(idata, pn);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", pn, 14) == 0)\n    cmd_parse_capability(idata, imap_next_word(pn));\n  else if (mutt_str_strncasecmp(\"LIST\", s, 4) == 0)\n    cmd_parse_list(idata, s);\n  else if (mutt_str_strncasecmp(\"LSUB\", s, 4) == 0)\n    cmd_parse_lsub(idata, s);\n  else if (mutt_str_strncasecmp(\"MYRIGHTS\", s, 8) == 0)\n    cmd_parse_myrights(idata, s);\n  else if (mutt_str_strncasecmp(\"SEARCH\", s, 6) == 0)\n    cmd_parse_search(idata, s);\n  else if (mutt_str_strncasecmp(\"STATUS\", s, 6) == 0)\n    cmd_parse_status(idata, s);\n  else if (mutt_str_strncasecmp(\"ENABLED\", s, 7) == 0)\n    cmd_parse_enabled(idata, s);\n  else if (mutt_str_strncasecmp(\"BYE\", s, 3) == 0)\n  {\n    mutt_debug(2, \"Handling BYE\\n\");\n\n    /* check if we're logging out */\n    if (idata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS(s);\n    mutt_error(\"%s\", s);\n    cmd_handle_fatal(idata);\n\n    return -1;\n  }\n  else if (ImapServernoise && (mutt_str_strncasecmp(\"NO\", s, 2) == 0))\n  {\n    mutt_debug(2, \"Handling untagged NO\\n\");\n\n    /* Display the warning message from the server */\n    mutt_error(\"%s\", s + 2);\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_start - Given an IMAP command, send it to the server\n * @param idata  Server data\n * @param cmdstr Command string to send\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If cmdstr is NULL, sends queued commands.\n */\nint imap_cmd_start(struct ImapData *idata, const char *cmdstr)\n{\n  return cmd_start(idata, cmdstr, 0);\n}\n\n/**\n * imap_cmd_step - Reads server responses from an IMAP command\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * detects tagged completion response, handles untagged messages, can read\n * arbitrarily large strings (using malloc, so don't make it _too_ large!).\n */\nint imap_cmd_step(struct ImapData *idata)\n{\n  size_t len = 0;\n  int c;\n  int rc;\n  int stillrunning = 0;\n  struct ImapCommand *cmd = NULL;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return IMAP_CMD_BAD;\n  }\n\n  /* read into buffer, expanding buffer as necessary until we have a full\n   * line */\n  do\n  {\n    if (len == idata->blen)\n    {\n      mutt_mem_realloc(&idata->buf, idata->blen + IMAP_CMD_BUFSIZE);\n      idata->blen = idata->blen + IMAP_CMD_BUFSIZE;\n      mutt_debug(3, \"grew buffer to %u bytes\\n\", idata->blen);\n    }\n\n    /* back up over '\\0' */\n    if (len)\n      len--;\n    c = mutt_socket_readln(idata->buf + len, idata->blen - len, idata->conn);\n    if (c <= 0)\n    {\n      mutt_debug(1, \"Error reading server response.\\n\");\n      cmd_handle_fatal(idata);\n      return IMAP_CMD_BAD;\n    }\n\n    len += c;\n  }\n  /* if we've read all the way to the end of the buffer, we haven't read a\n   * full line (mutt_socket_readln strips the \\r, so we always have at least\n   * one character free when we've read a full line) */\n  while (len == idata->blen);\n\n  /* don't let one large string make cmd->buf hog memory forever */\n  if ((idata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))\n  {\n    mutt_mem_realloc(&idata->buf, IMAP_CMD_BUFSIZE);\n    idata->blen = IMAP_CMD_BUFSIZE;\n    mutt_debug(3, \"shrank buffer to %u bytes\\n\", idata->blen);\n  }\n\n  idata->lastread = time(NULL);\n\n  /* handle untagged messages. The caller still gets its shot afterwards. */\n  if (((mutt_str_strncmp(idata->buf, \"* \", 2) == 0) ||\n       (mutt_str_strncmp(imap_next_word(idata->buf), \"OK [\", 4) == 0)) &&\n      cmd_handle_untagged(idata))\n  {\n    return IMAP_CMD_BAD;\n  }\n\n  /* server demands a continuation response from us */\n  if (idata->buf[0] == '+')\n    return IMAP_CMD_RESPOND;\n\n  /* Look for tagged command completions.\n   *\n   * Some response handlers can end up recursively calling\n   * imap_cmd_step() and end up handling all tagged command\n   * completions.\n   * (e.g. FETCH->set_flag->set_header_color->~h pattern match.)\n   *\n   * Other callers don't even create an idata->cmds entry.\n   *\n   * For both these cases, we default to returning OK */\n  rc = IMAP_CMD_OK;\n  c = idata->lastcmd;\n  do\n  {\n    cmd = &idata->cmds[c];\n    if (cmd->state == IMAP_CMD_NEW)\n    {\n      if (mutt_str_strncmp(idata->buf, cmd->seq, SEQLEN) == 0)\n      {\n        if (!stillrunning)\n        {\n          /* first command in queue has finished - move queue pointer up */\n          idata->lastcmd = (idata->lastcmd + 1) % idata->cmdslots;\n        }\n        cmd->state = cmd_status(idata->buf);\n        /* bogus - we don't know which command result to return here. Caller\n         * should provide a tag. */\n        rc = cmd->state;\n      }\n      else\n        stillrunning++;\n    }\n\n    c = (c + 1) % idata->cmdslots;\n  } while (c != idata->nextcmd);\n\n  if (stillrunning)\n    rc = IMAP_CMD_CONTINUE;\n  else\n  {\n    mutt_debug(3, \"IMAP queue drained\\n\");\n    imap_cmd_finish(idata);\n  }\n\n  return rc;\n}\n\n/**\n * imap_code - Was the command successful\n * @param s IMAP command status\n * @retval 1 Command result was OK\n * @retval 0 If NO or BAD\n */\nbool imap_code(const char *s)\n{\n  return (cmd_status(s) == IMAP_CMD_OK);\n}\n\n/**\n * imap_cmd_trailer - Extra information after tagged command response if any\n * @param idata Server data\n * @retval ptr Extra command information (pointer into idata->buf)\n * @retval \"\"  Error (static string)\n */\nconst char *imap_cmd_trailer(struct ImapData *idata)\n{\n  static const char *notrailer = \"\";\n  const char *s = idata->buf;\n\n  if (!s)\n  {\n    mutt_debug(2, \"not a tagged response\\n\");\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s || ((mutt_str_strncasecmp(s, \"OK\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"NO\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"BAD\", 3) != 0)))\n  {\n    mutt_debug(2, \"not a command completion: %s\\n\", idata->buf);\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s)\n    return notrailer;\n\n  return s;\n}\n\n/**\n * imap_exec - Execute a command and wait for the response from the server\n * @param idata  IMAP data\n * @param cmdstr Command to execute\n * @param flags  Flags (see below)\n * @retval  0 Success\n * @retval -1 Failure\n * @retval -2 OK Failure\n *\n * Also, handle untagged responses.\n *\n * Flags:\n * * IMAP_CMD_FAIL_OK: the calling procedure can handle failure.\n *       This is used for checking for a mailbox on append and login\n * * IMAP_CMD_PASS: command contains a password. Suppress logging.\n * * IMAP_CMD_QUEUE: only queue command, do not execute.\n * * IMAP_CMD_POLL: poll the socket for a response before running imap_cmd_step.\n */\nint imap_exec(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  rc = cmd_start(idata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if ((flags & IMAP_CMD_POLL) && (ImapPollTimeout > 0) &&\n      (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(1);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  mutt_sig_allow_interrupt(0);\n\n  if (rc == IMAP_CMD_NO && (flags & IMAP_CMD_FAIL_OK))\n    return -2;\n\n  if (rc != IMAP_CMD_OK)\n  {\n    if ((flags & IMAP_CMD_FAIL_OK) && idata->status != IMAP_FATAL)\n      return -2;\n\n    mutt_debug(1, \"command failed: %s\\n\", idata->buf);\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_finish - Attempt to perform cleanup\n * @param idata Server data\n *\n * Attempts to perform cleanup (eg fetch new mail if detected, do expunge).\n * Called automatically by imap_cmd_step(), but may be called at any time.\n * Called by imap_check_mailbox() just before the index is refreshed, for\n * instance.\n */\nvoid imap_cmd_finish(struct ImapData *idata)\n{\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return;\n  }\n\n  if (!(idata->state >= IMAP_SELECTED) || idata->ctx->closing)\n    return;\n\n  if (idata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    unsigned int count = idata->new_mail_count;\n\n    if (!(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n        (idata->reopen & IMAP_NEWMAIL_PENDING) && count > idata->max_msn)\n    {\n      /* read new mail messages */\n      mutt_debug(2, \"Fetching new mail\\n\");\n      /* check_status: curs_main uses imap_check_mailbox to detect\n       *   whether the index needs updating */\n      idata->check_status = IMAP_NEWMAIL_PENDING;\n      imap_read_headers(idata, idata->max_msn + 1, count);\n    }\n    else if (idata->reopen & IMAP_EXPUNGE_PENDING)\n    {\n      mutt_debug(2, \"Expunging mailbox\\n\");\n      imap_expunge_mailbox(idata);\n      /* Detect whether we've gotten unexpected EXPUNGE messages */\n      if ((idata->reopen & IMAP_EXPUNGE_PENDING) && !(idata->reopen & IMAP_EXPUNGE_EXPECTED))\n        idata->check_status = IMAP_EXPUNGE_PENDING;\n      idata->reopen &=\n          ~(IMAP_EXPUNGE_PENDING | IMAP_NEWMAIL_PENDING | IMAP_EXPUNGE_EXPECTED);\n    }\n  }\n\n  idata->status = false;\n}\n\n/**\n * imap_cmd_idle - Enter the IDLE state\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nint imap_cmd_idle(struct ImapData *idata)\n{\n  int rc;\n\n  if (cmd_start(idata, \"IDLE\", IMAP_CMD_POLL) < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if ((ImapPollTimeout > 0) && (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_RESPOND)\n  {\n    /* successfully entered IDLE state */\n    idata->state = IMAP_IDLE;\n    /* queue automatic exit when next command is issued */\n    mutt_buffer_printf(idata->cmdbuf, \"DONE\\r\\n\");\n    rc = IMAP_CMD_OK;\n  }\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"error starting IDLE\\n\");\n    return -1;\n  }\n\n  return 0;\n}\n"], "filenames": ["imap/command.c"], "buggy_code_start_loc": [895], "buggy_code_end_loc": [896], "fixing_code_start_loc": [895], "fixing_code_end_loc": [896], "type": "CWE-20", "message": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/command.c mishandles a NO response without a message.", "other": {"cve": {"id": "CVE-2018-14349", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.230", "lastModified": "2020-05-20T01:47:08.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/command.c mishandles a NO response without a message."}, {"lang": "es", "value": "Se ha descubierto un problema en Mutt en versiones anteriores a la 1.10.1 y NeoMutt en versiones anteriores al 2018-07-16. imap/command.c gestiona de manera incorrecta una respuesta NO sin mensaje."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "2FA2C3A6-423C-4BE5-8FA7-0241384D58D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}], "references": [{"url": "http://www.mutt.org/news.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/neomutt/neomutt/commit/36a29280448097f34ce9c94606195f2ac643fed1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/muttmua/mutt/commit/9347b5c01dc52682cb6be11539d9b7ebceae4416", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/36a29280448097f34ce9c94606195f2ac643fed1"}}