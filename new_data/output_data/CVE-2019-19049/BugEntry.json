{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Self tests for device tree subsystem\n */\n\n#define pr_fmt(fmt) \"### dt-test ### \" fmt\n\n#include <linux/memblock.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/hashtable.h>\n#include <linux/libfdt.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n\n#include <linux/bitops.h>\n\n#include \"of_private.h\"\n\nstatic struct unittest_results {\n\tint passed;\n\tint failed;\n} unittest_results;\n\n#define unittest(result, fmt, ...) ({ \\\n\tbool failed = !(result); \\\n\tif (failed) { \\\n\t\tunittest_results.failed++; \\\n\t\tpr_err(\"FAIL %s():%i \" fmt, __func__, __LINE__, ##__VA_ARGS__); \\\n\t} else { \\\n\t\tunittest_results.passed++; \\\n\t\tpr_debug(\"pass %s():%i\\n\", __func__, __LINE__); \\\n\t} \\\n\tfailed; \\\n})\n\nstatic void __init of_unittest_find_node_by_name(void)\n{\n\tstruct device_node *np;\n\tconst char *options, *name;\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data\", name),\n\t\t\"find /testcase-data failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\t/* Test if trailing '/' works */\n\tnp = of_find_node_by_path(\"/testcase-data/\");\n\tunittest(!np, \"trailing '/' on /testcase-data/ should fail\\n\");\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data/phandle-tests/consumer-a\", name),\n\t\t\"find /testcase-data/phandle-tests/consumer-a failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\tnp = of_find_node_by_path(\"testcase-alias\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data\", name),\n\t\t\"find testcase-alias failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\t/* Test if trailing '/' works on aliases */\n\tnp = of_find_node_by_path(\"testcase-alias/\");\n\tunittest(!np, \"trailing '/' on testcase-alias/ should fail\\n\");\n\n\tnp = of_find_node_by_path(\"testcase-alias/phandle-tests/consumer-a\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data/phandle-tests/consumer-a\", name),\n\t\t\"find testcase-alias/phandle-tests/consumer-a failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\tnp = of_find_node_by_path(\"/testcase-data/missing-path\");\n\tunittest(!np, \"non-existent path returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"missing-alias\");\n\tunittest(!np, \"non-existent alias returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"testcase-alias/missing-path\");\n\tunittest(!np, \"non-existent alias with relative path returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:testoption\", &options);\n\tunittest(np && !strcmp(\"testoption\", options),\n\t\t \"option path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:test/option\", &options);\n\tunittest(np && !strcmp(\"test/option\", options),\n\t\t \"option path test, subcase #1 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data/testcase-device1:test/option\", &options);\n\tunittest(np && !strcmp(\"test/option\", options),\n\t\t \"option path test, subcase #2 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:testoption\", NULL);\n\tunittest(np, \"NULL option path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:testaliasoption\",\n\t\t\t\t       &options);\n\tunittest(np && !strcmp(\"testaliasoption\", options),\n\t\t \"option alias path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:test/alias/option\",\n\t\t\t\t       &options);\n\tunittest(np && !strcmp(\"test/alias/option\", options),\n\t\t \"option alias path test, subcase #1 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:testaliasoption\", NULL);\n\tunittest(np, \"NULL option alias path test failed\\n\");\n\tof_node_put(np);\n\n\toptions = \"testoption\";\n\tnp = of_find_node_opts_by_path(\"testcase-alias\", &options);\n\tunittest(np && !options, \"option clearing test failed\\n\");\n\tof_node_put(np);\n\n\toptions = \"testoption\";\n\tnp = of_find_node_opts_by_path(\"/\", &options);\n\tunittest(np && !options, \"option clearing root node test failed\\n\");\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_dynamic(void)\n{\n\tstruct device_node *np;\n\tstruct property *prop;\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\t/* Array of 4 properties for the purpose of testing */\n\tprop = kcalloc(4, sizeof(*prop), GFP_KERNEL);\n\tif (!prop) {\n\t\tunittest(0, \"kzalloc() failed\\n\");\n\t\treturn;\n\t}\n\n\t/* Add a new property - should pass*/\n\tprop->name = \"new-property\";\n\tprop->value = \"new-property-data\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_add_property(np, prop) == 0, \"Adding a new property failed\\n\");\n\n\t/* Try to add an existing property - should fail */\n\tprop++;\n\tprop->name = \"new-property\";\n\tprop->value = \"new-property-data-should-fail\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_add_property(np, prop) != 0,\n\t\t \"Adding an existing property should have failed\\n\");\n\n\t/* Try to modify an existing property - should pass */\n\tprop->value = \"modify-property-data-should-pass\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_update_property(np, prop) == 0,\n\t\t \"Updating an existing property should have passed\\n\");\n\n\t/* Try to modify non-existent property - should pass*/\n\tprop++;\n\tprop->name = \"modify-property\";\n\tprop->value = \"modify-missing-property-data-should-pass\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_update_property(np, prop) == 0,\n\t\t \"Updating a missing property should have passed\\n\");\n\n\t/* Remove property - should pass */\n\tunittest(of_remove_property(np, prop) == 0,\n\t\t \"Removing a property should have passed\\n\");\n\n\t/* Adding very large property - should pass */\n\tprop++;\n\tprop->name = \"large-property-PAGE_SIZEx8\";\n\tprop->length = PAGE_SIZE * 8;\n\tprop->value = kzalloc(prop->length, GFP_KERNEL);\n\tunittest(prop->value != NULL, \"Unable to allocate large buffer\\n\");\n\tif (prop->value)\n\t\tunittest(of_add_property(np, prop) == 0,\n\t\t\t \"Adding a large property should have passed\\n\");\n}\n\nstatic int __init of_unittest_check_node_linkage(struct device_node *np)\n{\n\tstruct device_node *child;\n\tint count = 0, rc;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (child->parent != np) {\n\t\t\tpr_err(\"Child node %pOFn links to wrong parent %pOFn\\n\",\n\t\t\t\t child, np);\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\trc = of_unittest_check_node_linkage(child);\n\t\tif (rc < 0)\n\t\t\tgoto put_child;\n\t\tcount += rc;\n\t}\n\n\treturn count + 1;\nput_child:\n\tof_node_put(child);\n\treturn rc;\n}\n\nstatic void __init of_unittest_check_tree_linkage(void)\n{\n\tstruct device_node *np;\n\tint allnode_count = 0, child_count;\n\n\tif (!of_root)\n\t\treturn;\n\n\tfor_each_of_allnodes(np)\n\t\tallnode_count++;\n\tchild_count = of_unittest_check_node_linkage(of_root);\n\n\tunittest(child_count > 0, \"Device node data structure is corrupted\\n\");\n\tunittest(child_count == allnode_count,\n\t\t \"allnodes list size (%i) doesn't match sibling lists size (%i)\\n\",\n\t\t allnode_count, child_count);\n\tpr_debug(\"allnodes list size (%i); sibling lists size (%i)\\n\", allnode_count, child_count);\n}\n\nstatic void __init of_unittest_printf_one(struct device_node *np, const char *fmt,\n\t\t\t\t\t  const char *expected)\n{\n\tunsigned char *buf;\n\tint buf_size;\n\tint size, i;\n\n\tbuf_size = strlen(expected) + 10;\n\tbuf = kmalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\t/* Baseline; check conversion with a large size limit */\n\tmemset(buf, 0xff, buf_size);\n\tsize = snprintf(buf, buf_size - 2, fmt, np);\n\n\t/* use strcmp() instead of strncmp() here to be absolutely sure strings match */\n\tunittest((strcmp(buf, expected) == 0) && (buf[size+1] == 0xff),\n\t\t\"sprintf failed; fmt='%s' expected='%s' rslt='%s'\\n\",\n\t\tfmt, expected, buf);\n\n\t/* Make sure length limits work */\n\tsize++;\n\tfor (i = 0; i < 2; i++, size--) {\n\t\t/* Clear the buffer, and make sure it works correctly still */\n\t\tmemset(buf, 0xff, buf_size);\n\t\tsnprintf(buf, size+1, fmt, np);\n\t\tunittest(strncmp(buf, expected, size) == 0 && (buf[size+1] == 0xff),\n\t\t\t\"snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\\n\",\n\t\t\tsize, fmt, expected, buf);\n\t}\n\tkfree(buf);\n}\n\nstatic void __init of_unittest_printf(void)\n{\n\tstruct device_node *np;\n\tconst char *full_name = \"/testcase-data/platform-tests/test-device@1/dev@100\";\n\tchar phandle_str[16] = \"\";\n\n\tnp = of_find_node_by_path(full_name);\n\tif (!np) {\n\t\tunittest(np, \"testcase data missing\\n\");\n\t\treturn;\n\t}\n\n\tnum_to_str(phandle_str, sizeof(phandle_str), np->phandle, 0);\n\n\tof_unittest_printf_one(np, \"%pOF\",  full_name);\n\tof_unittest_printf_one(np, \"%pOFf\", full_name);\n\tof_unittest_printf_one(np, \"%pOFn\", \"dev\");\n\tof_unittest_printf_one(np, \"%2pOFn\", \"dev\");\n\tof_unittest_printf_one(np, \"%5pOFn\", \"  dev\");\n\tof_unittest_printf_one(np, \"%pOFnc\", \"dev:test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFp\", phandle_str);\n\tof_unittest_printf_one(np, \"%pOFP\", \"dev@100\");\n\tof_unittest_printf_one(np, \"ABC %pOFP ABC\", \"ABC dev@100 ABC\");\n\tof_unittest_printf_one(np, \"%10pOFP\", \"   dev@100\");\n\tof_unittest_printf_one(np, \"%-10pOFP\", \"dev@100   \");\n\tof_unittest_printf_one(of_root, \"%pOFP\", \"/\");\n\tof_unittest_printf_one(np, \"%pOFF\", \"----\");\n\tof_unittest_printf_one(np, \"%pOFPF\", \"dev@100:----\");\n\tof_unittest_printf_one(np, \"%pOFPFPc\", \"dev@100:----:dev@100:test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFc\", \"test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFC\",\n\t\t\t\"\\\"test-sub-device\\\",\\\"test-compat2\\\",\\\"test-compat3\\\"\");\n}\n\nstruct node_hash {\n\tstruct hlist_node node;\n\tstruct device_node *np;\n};\n\nstatic DEFINE_HASHTABLE(phandle_ht, 8);\nstatic void __init of_unittest_check_phandles(void)\n{\n\tstruct device_node *np;\n\tstruct node_hash *nh;\n\tstruct hlist_node *tmp;\n\tint i, dup_count = 0, phandle_count = 0;\n\n\tfor_each_of_allnodes(np) {\n\t\tif (!np->phandle)\n\t\t\tcontinue;\n\n\t\thash_for_each_possible(phandle_ht, nh, node, np->phandle) {\n\t\t\tif (nh->np->phandle == np->phandle) {\n\t\t\t\tpr_info(\"Duplicate phandle! %i used by %pOF and %pOF\\n\",\n\t\t\t\t\tnp->phandle, nh->np, np);\n\t\t\t\tdup_count++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnh = kzalloc(sizeof(*nh), GFP_KERNEL);\n\t\tif (!nh)\n\t\t\treturn;\n\n\t\tnh->np = np;\n\t\thash_add(phandle_ht, &nh->node, np->phandle);\n\t\tphandle_count++;\n\t}\n\tunittest(dup_count == 0, \"Found %i duplicates in %i phandles\\n\",\n\t\t dup_count, phandle_count);\n\n\t/* Clean up */\n\thash_for_each_safe(phandle_ht, i, tmp, nh, node) {\n\t\thash_del(&nh->node);\n\t\tkfree(nh);\n\t}\n}\n\nstatic void __init of_unittest_parse_phandle_with_args(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\trc = of_count_phandle_with_args(np, \"phandle-list\", \"#phandle-cells\");\n\tunittest(rc == 7, \"of_count_phandle_with_args() returned %i, expected 7\\n\", rc);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_parse_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\t\"#phandle-cells\", i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 4);\n\t\t\tpassed &= (args.args[2] == 3);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 100);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\n\t/* Check for missing list property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list-missing\",\n\t\t\t\t\t\"#phandle-cells\", 0, &args);\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list-missing\",\n\t\t\t\t\t\"#phandle-cells\");\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\n\t/* Check for missing cells property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\"#phandle-cells-missing\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\"#phandle-cells-missing\");\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for bad phandle in list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t\"#phandle-cells\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t\"#phandle-cells\");\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for incorrectly formed argument list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list-bad-args\",\n\t\t\t\t\t\"#phandle-cells\", 1, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list-bad-args\",\n\t\t\t\t\t\"#phandle-cells\");\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n}\n\nstatic void __init of_unittest_parse_phandle_with_args_map(void)\n{\n\tstruct device_node *np, *p0, *p1, *p2, *p3;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-b\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp0 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider0\");\n\tif (!p0) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp1 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider1\");\n\tif (!p1) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp2 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider2\");\n\tif (!p2) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp3 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider3\");\n\tif (!p3) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\trc = of_count_phandle_with_args(np, \"phandle-list\", \"#phandle-cells\");\n\tunittest(rc == 7, \"of_count_phandle_with_args() returned %i, expected 7\\n\", rc);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_parse_phandle_with_args_map(np, \"phandle-list\",\n\t\t\t\t\t\t    \"phandle\", i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p1);\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p3);\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 2);\n\t\t\tpassed &= (args.args[1] == 5);\n\t\t\tpassed &= (args.args[2] == 3);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p0);\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p1);\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 3);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p0);\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p2);\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tpassed &= (args.args[1] == 0x20);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %s rc=%i\\n\",\n\t\t\t i, args.np->full_name, rc);\n\t}\n\n\t/* Check for missing list property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-missing\",\n\t\t\t\t\t    \"phandle\", 0, &args);\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\n\t/* Check for missing cells,map,mask property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list\",\n\t\t\t\t\t    \"phandle-missing\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for bad phandle in list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t    \"phandle\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for incorrectly formed argument list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-bad-args\",\n\t\t\t\t\t    \"phandle\", 1, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n}\n\nstatic void __init of_unittest_property_string(void)\n{\n\tconst char *strings[4];\n\tstruct device_node *np;\n\tint rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_err(\"No testcase data in device tree\\n\");\n\t\treturn;\n\t}\n\n\trc = of_property_match_string(np, \"phandle-list-names\", \"first\");\n\tunittest(rc == 0, \"first expected:0 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"second\");\n\tunittest(rc == 1, \"second expected:1 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"third\");\n\tunittest(rc == 2, \"third expected:2 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"fourth\");\n\tunittest(rc == -ENODATA, \"unmatched string; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"missing-property\", \"blah\");\n\tunittest(rc == -EINVAL, \"missing property; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"empty-property\", \"blah\");\n\tunittest(rc == -ENODATA, \"empty property; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"unterminated-string\", \"blah\");\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\n\t/* of_property_count_strings() tests */\n\trc = of_property_count_strings(np, \"string-property\");\n\tunittest(rc == 1, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"phandle-list-names\");\n\tunittest(rc == 3, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"unterminated-string\");\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"unterminated-string-list\");\n\tunittest(rc == -EILSEQ, \"unterminated string array; rc=%i\\n\", rc);\n\n\t/* of_property_read_string_index() tests */\n\trc = of_property_read_string_index(np, \"string-property\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"foobar\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"string-property\", 1, strings);\n\tunittest(rc == -ENODATA && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"first\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 1, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"second\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 2, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"third\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 3, strings);\n\tunittest(rc == -ENODATA && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"unterminated-string\", 0, strings);\n\tunittest(rc == -EILSEQ && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"unterminated-string-list\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"first\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"unterminated-string-list\", 2, strings); /* should fail */\n\tunittest(rc == -EILSEQ && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[1] = NULL;\n\n\t/* of_property_read_string_array() tests */\n\trc = of_property_read_string_array(np, \"string-property\", strings, 4);\n\tunittest(rc == 1, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_read_string_array(np, \"phandle-list-names\", strings, 4);\n\tunittest(rc == 3, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_read_string_array(np, \"unterminated-string\", strings, 4);\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\t/* -- An incorrectly formed string should cause a failure */\n\trc = of_property_read_string_array(np, \"unterminated-string-list\", strings, 4);\n\tunittest(rc == -EILSEQ, \"unterminated string array; rc=%i\\n\", rc);\n\t/* -- parsing the correctly formed strings should still work: */\n\tstrings[2] = NULL;\n\trc = of_property_read_string_array(np, \"unterminated-string-list\", strings, 2);\n\tunittest(rc == 2 && strings[2] == NULL, \"of_property_read_string_array() failure; rc=%i\\n\", rc);\n\tstrings[1] = NULL;\n\trc = of_property_read_string_array(np, \"phandle-list-names\", strings, 1);\n\tunittest(rc == 1 && strings[1] == NULL, \"Overwrote end of string array; rc=%i, str='%s'\\n\", rc, strings[1]);\n}\n\n#define propcmp(p1, p2) (((p1)->length == (p2)->length) && \\\n\t\t\t(p1)->value && (p2)->value && \\\n\t\t\t!memcmp((p1)->value, (p2)->value, (p1)->length) && \\\n\t\t\t!strcmp((p1)->name, (p2)->name))\nstatic void __init of_unittest_property_copy(void)\n{\n#ifdef CONFIG_OF_DYNAMIC\n\tstruct property p1 = { .name = \"p1\", .length = 0, .value = \"\" };\n\tstruct property p2 = { .name = \"p2\", .length = 5, .value = \"abcd\" };\n\tstruct property *new;\n\n\tnew = __of_prop_dup(&p1, GFP_KERNEL);\n\tunittest(new && propcmp(&p1, new), \"empty property didn't copy correctly\\n\");\n\tkfree(new->value);\n\tkfree(new->name);\n\tkfree(new);\n\n\tnew = __of_prop_dup(&p2, GFP_KERNEL);\n\tunittest(new && propcmp(&p2, new), \"non-empty property didn't copy correctly\\n\");\n\tkfree(new->value);\n\tkfree(new->name);\n\tkfree(new);\n#endif\n}\n\nstatic void __init of_unittest_changeset(void)\n{\n#ifdef CONFIG_OF_DYNAMIC\n\tstruct property *ppadd, padd = { .name = \"prop-add\", .length = 1, .value = \"\" };\n\tstruct property *ppname_n1,  pname_n1  = { .name = \"name\", .length = 3, .value = \"n1\"  };\n\tstruct property *ppname_n2,  pname_n2  = { .name = \"name\", .length = 3, .value = \"n2\"  };\n\tstruct property *ppname_n21, pname_n21 = { .name = \"name\", .length = 3, .value = \"n21\" };\n\tstruct property *ppupdate, pupdate = { .name = \"prop-update\", .length = 5, .value = \"abcd\" };\n\tstruct property *ppremove;\n\tstruct device_node *n1, *n2, *n21, *nchangeset, *nremove, *parent, *np;\n\tstruct of_changeset chgset;\n\n\tn1 = __of_node_dup(NULL, \"n1\");\n\tunittest(n1, \"testcase setup failure\\n\");\n\n\tn2 = __of_node_dup(NULL, \"n2\");\n\tunittest(n2, \"testcase setup failure\\n\");\n\n\tn21 = __of_node_dup(NULL, \"n21\");\n\tunittest(n21, \"testcase setup failure %p\\n\", n21);\n\n\tnchangeset = of_find_node_by_path(\"/testcase-data/changeset\");\n\tnremove = of_get_child_by_name(nchangeset, \"node-remove\");\n\tunittest(nremove, \"testcase setup failure\\n\");\n\n\tppadd = __of_prop_dup(&padd, GFP_KERNEL);\n\tunittest(ppadd, \"testcase setup failure\\n\");\n\n\tppname_n1  = __of_prop_dup(&pname_n1, GFP_KERNEL);\n\tunittest(ppname_n1, \"testcase setup failure\\n\");\n\n\tppname_n2  = __of_prop_dup(&pname_n2, GFP_KERNEL);\n\tunittest(ppname_n2, \"testcase setup failure\\n\");\n\n\tppname_n21 = __of_prop_dup(&pname_n21, GFP_KERNEL);\n\tunittest(ppname_n21, \"testcase setup failure\\n\");\n\n\tppupdate = __of_prop_dup(&pupdate, GFP_KERNEL);\n\tunittest(ppupdate, \"testcase setup failure\\n\");\n\n\tparent = nchangeset;\n\tn1->parent = parent;\n\tn2->parent = parent;\n\tn21->parent = n2;\n\n\tppremove = of_find_property(parent, \"prop-remove\", NULL);\n\tunittest(ppremove, \"failed to find removal prop\");\n\n\tof_changeset_init(&chgset);\n\n\tunittest(!of_changeset_attach_node(&chgset, n1), \"fail attach n1\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n1, ppname_n1), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_attach_node(&chgset, n2), \"fail attach n2\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n2, ppname_n2), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_detach_node(&chgset, nremove), \"fail remove node\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n21, ppname_n21), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_attach_node(&chgset, n21), \"fail attach n21\\n\");\n\n\tunittest(!of_changeset_add_property(&chgset, parent, ppadd), \"fail add prop prop-add\\n\");\n\tunittest(!of_changeset_update_property(&chgset, parent, ppupdate), \"fail update prop\\n\");\n\tunittest(!of_changeset_remove_property(&chgset, parent, ppremove), \"fail remove prop\\n\");\n\n\tunittest(!of_changeset_apply(&chgset), \"apply failed\\n\");\n\n\tof_node_put(nchangeset);\n\n\t/* Make sure node names are constructed correctly */\n\tunittest((np = of_find_node_by_path(\"/testcase-data/changeset/n2/n21\")),\n\t\t \"'%pOF' not added\\n\", n21);\n\tof_node_put(np);\n\n\tunittest(!of_changeset_revert(&chgset), \"revert failed\\n\");\n\n\tof_changeset_destroy(&chgset);\n#endif\n}\n\nstatic void __init of_unittest_parse_interrupts(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts0\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\tpassed &= !rc;\n\t\tpassed &= (args.args_count == 1);\n\t\tpassed &= (args.args[0] == (i + 1));\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts1\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 9);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 10);\n\t\t\tpassed &= (args.args[1] == 11);\n\t\t\tpassed &= (args.args[2] == 12);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 13);\n\t\t\tpassed &= (args.args[1] == 14);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tpassed &= (args.args[1] == 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_parse_interrupts_extended(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts-extended0\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 2);\n\t\t\tpassed &= (args.args[1] == 3);\n\t\t\tpassed &= (args.args[2] == 4);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 5);\n\t\t\tpassed &= (args.args[1] == 6);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 9);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 10);\n\t\t\tpassed &= (args.args[1] == 11);\n\t\t\tpassed &= (args.args[2] == 12);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 13);\n\t\t\tpassed &= (args.args[1] == 14);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n}\n\nstatic const struct of_device_id match_node_table[] = {\n\t{ .data = \"A\", .name = \"name0\", }, /* Name alone is lowest priority */\n\t{ .data = \"B\", .type = \"type1\", }, /* followed by type alone */\n\n\t{ .data = \"Ca\", .name = \"name2\", .type = \"type1\", }, /* followed by both together */\n\t{ .data = \"Cb\", .name = \"name2\", }, /* Only match when type doesn't match */\n\t{ .data = \"Cc\", .name = \"name2\", .type = \"type2\", },\n\n\t{ .data = \"E\", .compatible = \"compat3\" },\n\t{ .data = \"G\", .compatible = \"compat2\", },\n\t{ .data = \"H\", .compatible = \"compat2\", .name = \"name5\", },\n\t{ .data = \"I\", .compatible = \"compat2\", .type = \"type1\", },\n\t{ .data = \"J\", .compatible = \"compat2\", .type = \"type1\", .name = \"name8\", },\n\t{ .data = \"K\", .compatible = \"compat2\", .name = \"name9\", },\n\t{}\n};\n\nstatic struct {\n\tconst char *path;\n\tconst char *data;\n} match_node_tests[] = {\n\t{ .path = \"/testcase-data/match-node/name0\", .data = \"A\", },\n\t{ .path = \"/testcase-data/match-node/name1\", .data = \"B\", },\n\t{ .path = \"/testcase-data/match-node/a/name2\", .data = \"Ca\", },\n\t{ .path = \"/testcase-data/match-node/b/name2\", .data = \"Cb\", },\n\t{ .path = \"/testcase-data/match-node/c/name2\", .data = \"Cc\", },\n\t{ .path = \"/testcase-data/match-node/name3\", .data = \"E\", },\n\t{ .path = \"/testcase-data/match-node/name4\", .data = \"G\", },\n\t{ .path = \"/testcase-data/match-node/name5\", .data = \"H\", },\n\t{ .path = \"/testcase-data/match-node/name6\", .data = \"G\", },\n\t{ .path = \"/testcase-data/match-node/name7\", .data = \"I\", },\n\t{ .path = \"/testcase-data/match-node/name8\", .data = \"J\", },\n\t{ .path = \"/testcase-data/match-node/name9\", .data = \"K\", },\n};\n\nstatic void __init of_unittest_match_node(void)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *match;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(match_node_tests); i++) {\n\t\tnp = of_find_node_by_path(match_node_tests[i].path);\n\t\tif (!np) {\n\t\t\tunittest(0, \"missing testcase node %s\\n\",\n\t\t\t\tmatch_node_tests[i].path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = of_match_node(match_node_table, np);\n\t\tif (!match) {\n\t\t\tunittest(0, \"%s didn't match anything\\n\",\n\t\t\t\tmatch_node_tests[i].path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(match->data, match_node_tests[i].data) != 0) {\n\t\t\tunittest(0, \"%s got wrong match. expected %s, got %s\\n\",\n\t\t\t\tmatch_node_tests[i].path, match_node_tests[i].data,\n\t\t\t\t(const char *)match->data);\n\t\t\tcontinue;\n\t\t}\n\t\tunittest(1, \"passed\");\n\t}\n}\n\nstatic struct resource test_bus_res = {\n\t.start = 0xfffffff8,\n\t.end = 0xfffffff9,\n\t.flags = IORESOURCE_MEM,\n};\nstatic const struct platform_device_info test_bus_info = {\n\t.name = \"unittest-bus\",\n};\nstatic void __init of_unittest_platform_populate(void)\n{\n\tint irq, rc;\n\tstruct device_node *np, *child, *grandchild;\n\tstruct platform_device *pdev, *test_bus;\n\tconst struct of_device_id match[] = {\n\t\t{ .compatible = \"test-device\", },\n\t\t{}\n\t};\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tof_platform_default_populate(np, NULL, NULL);\n\n\t/* Test that a missing irq domain returns -EPROBE_DEFER */\n\tnp = of_find_node_by_path(\"/testcase-data/testcase-device1\");\n\tpdev = of_find_device_by_node(np);\n\tunittest(pdev, \"device 1 creation failed\\n\");\n\n\tif (!(of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)) {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tunittest(irq == -EPROBE_DEFER,\n\t\t\t \"device deferred probe failed - %d\\n\", irq);\n\n\t\t/* Test that a parsing failure does not return -EPROBE_DEFER */\n\t\tnp = of_find_node_by_path(\"/testcase-data/testcase-device2\");\n\t\tpdev = of_find_device_by_node(np);\n\t\tunittest(pdev, \"device 2 creation failed\\n\");\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tunittest(irq < 0 && irq != -EPROBE_DEFER,\n\t\t\t \"device parsing error failed - %d\\n\", irq);\n\t}\n\n\tnp = of_find_node_by_path(\"/testcase-data/platform-tests\");\n\tunittest(np, \"No testcase data in device tree\\n\");\n\tif (!np)\n\t\treturn;\n\n\ttest_bus = platform_device_register_full(&test_bus_info);\n\trc = PTR_ERR_OR_ZERO(test_bus);\n\tunittest(!rc, \"testbus registration failed; rc=%i\\n\", rc);\n\tif (rc) {\n\t\tof_node_put(np);\n\t\treturn;\n\t}\n\ttest_bus->dev.of_node = np;\n\n\t/*\n\t * Add a dummy resource to the test bus node after it is\n\t * registered to catch problems with un-inserted resources. The\n\t * DT code doesn't insert the resources, and it has caused the\n\t * kernel to oops in the past. This makes sure the same bug\n\t * doesn't crop up again.\n\t */\n\tplatform_device_add_resources(test_bus, &test_bus_res, 1);\n\n\tof_platform_populate(np, match, NULL, &test_bus->dev);\n\tfor_each_child_of_node(np, child) {\n\t\tfor_each_child_of_node(child, grandchild)\n\t\t\tunittest(of_find_device_by_node(grandchild),\n\t\t\t\t \"Could not create device for node '%pOFn'\\n\",\n\t\t\t\t grandchild);\n\t}\n\n\tof_platform_depopulate(&test_bus->dev);\n\tfor_each_child_of_node(np, child) {\n\t\tfor_each_child_of_node(child, grandchild)\n\t\t\tunittest(!of_find_device_by_node(grandchild),\n\t\t\t\t \"device didn't get destroyed '%pOFn'\\n\",\n\t\t\t\t grandchild);\n\t}\n\n\tplatform_device_unregister(test_bus);\n\tof_node_put(np);\n}\n\n/**\n *\tupdate_node_properties - adds the properties\n *\tof np into dup node (present in live tree) and\n *\tupdates parent of children of np to dup.\n *\n *\t@np:\tnode whose properties are being added to the live tree\n *\t@dup:\tnode present in live tree to be updated\n */\nstatic void update_node_properties(struct device_node *np,\n\t\t\t\t\tstruct device_node *dup)\n{\n\tstruct property *prop;\n\tstruct property *save_next;\n\tstruct device_node *child;\n\tint ret;\n\n\tfor_each_child_of_node(np, child)\n\t\tchild->parent = dup;\n\n\t/*\n\t * \"unittest internal error: unable to add testdata property\"\n\t *\n\t *    If this message reports a property in node '/__symbols__' then\n\t *    the respective unittest overlay contains a label that has the\n\t *    same name as a label in the live devicetree.  The label will\n\t *    be in the live devicetree only if the devicetree source was\n\t *    compiled with the '-@' option.  If you encounter this error,\n\t *    please consider renaming __all__ of the labels in the unittest\n\t *    overlay dts files with an odd prefix that is unlikely to be\n\t *    used in a real devicetree.\n\t */\n\n\t/*\n\t * open code for_each_property_of_node() because of_add_property()\n\t * sets prop->next to NULL\n\t */\n\tfor (prop = np->properties; prop != NULL; prop = save_next) {\n\t\tsave_next = prop->next;\n\t\tret = of_add_property(dup, prop);\n\t\tif (ret) {\n\t\t\tif (ret == -EEXIST && !strcmp(prop->name, \"name\"))\n\t\t\t\tcontinue;\n\t\t\tpr_err(\"unittest internal error: unable to add testdata property %pOF/%s\",\n\t\t\t       np, prop->name);\n\t\t}\n\t}\n}\n\n/**\n *\tattach_node_and_children - attaches nodes\n *\tand its children to live tree.\n *\tCAUTION: misleading function name - if node @np already exists in\n *\tthe live tree then children of @np are *not* attached to the live\n *\ttree.  This works for the current test devicetree nodes because such\n *\tnodes do not have child nodes.\n *\n *\t@np:\tNode to attach to live tree\n */\nstatic void attach_node_and_children(struct device_node *np)\n{\n\tstruct device_node *next, *dup, *child;\n\tunsigned long flags;\n\tconst char *full_name;\n\n\tfull_name = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\n\tif (!strcmp(full_name, \"/__local_fixups__\") ||\n\t    !strcmp(full_name, \"/__fixups__\"))\n\t\treturn;\n\n\tdup = of_find_node_by_path(full_name);\n\tkfree(full_name);\n\tif (dup) {\n\t\tupdate_node_properties(np, dup);\n\t\treturn;\n\t}\n\n\tchild = np->child;\n\tnp->child = NULL;\n\n\tmutex_lock(&of_mutex);\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tnp->sibling = np->parent->child;\n\tnp->parent->child = np;\n\tof_node_clear_flag(np, OF_DETACHED);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\t__of_attach_node_sysfs(np);\n\tmutex_unlock(&of_mutex);\n\n\twhile (child) {\n\t\tnext = child->sibling;\n\t\tattach_node_and_children(child);\n\t\tchild = next;\n\t}\n}\n\n/**\n *\tunittest_data_add - Reads, copies data from\n *\tlinked tree and attaches it to the live tree\n */\nstatic int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\t/*\n\t * __dtb_testcases_begin[] and __dtb_testcases_end[] are magically\n\t * created by cmd_dt_S_dtb in scripts/Makefile.lib\n\t */\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\n\t/* creating copy */\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\treturn -ENODATA;\n\t}\n\n\t/*\n\t * This lock normally encloses of_resolve_phandles()\n\t */\n\tof_overlay_mutex_lock();\n\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\n\t/* attach the sub-tree to live tree */\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\n\tof_overlay_mutex_unlock();\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF_OVERLAY\nstatic int __init overlay_data_apply(const char *overlay_name, int *overlay_id);\n\nstatic int unittest_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tif (np == NULL) {\n\t\tdev_err(dev, \"No OF data for device\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tof_platform_populate(np, NULL, NULL, &pdev->dev);\n\n\treturn 0;\n}\n\nstatic int unittest_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\treturn 0;\n}\n\nstatic const struct of_device_id unittest_match[] = {\n\t{ .compatible = \"unittest\", },\n\t{},\n};\n\nstatic struct platform_driver unittest_driver = {\n\t.probe\t\t\t= unittest_probe,\n\t.remove\t\t\t= unittest_remove,\n\t.driver = {\n\t\t.name\t\t= \"unittest\",\n\t\t.of_match_table\t= of_match_ptr(unittest_match),\n\t},\n};\n\n/* get the platform device instantiated at the path */\nstatic struct platform_device *of_path_to_platform_device(const char *path)\n{\n\tstruct device_node *np;\n\tstruct platform_device *pdev;\n\n\tnp = of_find_node_by_path(path);\n\tif (np == NULL)\n\t\treturn NULL;\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\n\treturn pdev;\n}\n\n/* find out if a platform device exists at that path */\nstatic int of_path_platform_device_exists(const char *path)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = of_path_to_platform_device(path);\n\tplatform_device_put(pdev);\n\treturn pdev != NULL;\n}\n\n#if IS_BUILTIN(CONFIG_I2C)\n\n/* get the i2c client device instantiated at the path */\nstatic struct i2c_client *of_path_to_i2c_client(const char *path)\n{\n\tstruct device_node *np;\n\tstruct i2c_client *client;\n\n\tnp = of_find_node_by_path(path);\n\tif (np == NULL)\n\t\treturn NULL;\n\n\tclient = of_find_i2c_device_by_node(np);\n\tof_node_put(np);\n\n\treturn client;\n}\n\n/* find out if a i2c client device exists at that path */\nstatic int of_path_i2c_client_exists(const char *path)\n{\n\tstruct i2c_client *client;\n\n\tclient = of_path_to_i2c_client(path);\n\tif (client)\n\t\tput_device(&client->dev);\n\treturn client != NULL;\n}\n#else\nstatic int of_path_i2c_client_exists(const char *path)\n{\n\treturn 0;\n}\n#endif\n\nenum overlay_type {\n\tPDEV_OVERLAY,\n\tI2C_OVERLAY\n};\n\nstatic int of_path_device_type_exists(const char *path,\n\t\tenum overlay_type ovtype)\n{\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\treturn of_path_platform_device_exists(path);\n\tcase I2C_OVERLAY:\n\t\treturn of_path_i2c_client_exists(path);\n\t}\n\treturn 0;\n}\n\nstatic const char *unittest_path(int nr, enum overlay_type ovtype)\n{\n\tconst char *base;\n\tstatic char buf[256];\n\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\tbase = \"/testcase-data/overlay-node/test-bus\";\n\t\tbreak;\n\tcase I2C_OVERLAY:\n\t\tbase = \"/testcase-data/overlay-node/test-bus/i2c-test-bus\";\n\t\tbreak;\n\tdefault:\n\t\tbuf[0] = '\\0';\n\t\treturn buf;\n\t}\n\tsnprintf(buf, sizeof(buf) - 1, \"%s/test-unittest%d\", base, nr);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\treturn buf;\n}\n\nstatic int of_unittest_device_exists(int unittest_nr, enum overlay_type ovtype)\n{\n\tconst char *path;\n\n\tpath = unittest_path(unittest_nr, ovtype);\n\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\treturn of_path_platform_device_exists(path);\n\tcase I2C_OVERLAY:\n\t\treturn of_path_i2c_client_exists(path);\n\t}\n\treturn 0;\n}\n\nstatic const char *overlay_name_from_nr(int nr)\n{\n\tstatic char buf[256];\n\n\tsnprintf(buf, sizeof(buf) - 1,\n\t\t\"overlay_%d\", nr);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\n\treturn buf;\n}\n\nstatic const char *bus_path = \"/testcase-data/overlay-node/test-bus\";\n\n/* it is guaranteed that overlay ids are assigned in sequence */\n#define MAX_UNITTEST_OVERLAYS\t256\nstatic unsigned long overlay_id_bits[BITS_TO_LONGS(MAX_UNITTEST_OVERLAYS)];\nstatic int overlay_first_id = -1;\n\nstatic void of_unittest_track_overlay(int id)\n{\n\tif (overlay_first_id < 0)\n\t\toverlay_first_id = id;\n\tid -= overlay_first_id;\n\n\t/* we shouldn't need that many */\n\tBUG_ON(id >= MAX_UNITTEST_OVERLAYS);\n\toverlay_id_bits[BIT_WORD(id)] |= BIT_MASK(id);\n}\n\nstatic void of_unittest_untrack_overlay(int id)\n{\n\tif (overlay_first_id < 0)\n\t\treturn;\n\tid -= overlay_first_id;\n\tBUG_ON(id >= MAX_UNITTEST_OVERLAYS);\n\toverlay_id_bits[BIT_WORD(id)] &= ~BIT_MASK(id);\n}\n\nstatic void of_unittest_destroy_tracked_overlays(void)\n{\n\tint id, ret, defers, ovcs_id;\n\n\tif (overlay_first_id < 0)\n\t\treturn;\n\n\t/* try until no defers */\n\tdo {\n\t\tdefers = 0;\n\t\t/* remove in reverse order */\n\t\tfor (id = MAX_UNITTEST_OVERLAYS - 1; id >= 0; id--) {\n\t\t\tif (!(overlay_id_bits[BIT_WORD(id)] & BIT_MASK(id)))\n\t\t\t\tcontinue;\n\n\t\t\tovcs_id = id + overlay_first_id;\n\t\t\tret = of_overlay_remove(&ovcs_id);\n\t\t\tif (ret == -ENODEV) {\n\t\t\t\tpr_warn(\"%s: no overlay to destroy for #%d\\n\",\n\t\t\t\t\t__func__, id + overlay_first_id);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret != 0) {\n\t\t\t\tdefers++;\n\t\t\t\tpr_warn(\"%s: overlay destroy failed for #%d\\n\",\n\t\t\t\t\t__func__, id + overlay_first_id);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toverlay_id_bits[BIT_WORD(id)] &= ~BIT_MASK(id);\n\t\t}\n\t} while (defers > 0);\n}\n\nstatic int __init of_unittest_apply_overlay(int overlay_nr, int *overlay_id)\n{\n\tconst char *overlay_name;\n\n\toverlay_name = overlay_name_from_nr(overlay_nr);\n\n\tif (!overlay_data_apply(overlay_name, overlay_id)) {\n\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\",\n\t\t\t\toverlay_name);\n\t\treturn -EFAULT;\n\t}\n\tof_unittest_track_overlay(*overlay_id);\n\n\treturn 0;\n}\n\n/* apply an overlay while checking before and after states */\nstatic int __init of_unittest_apply_overlay_check(int overlay_nr,\n\t\tint unittest_nr, int before, int after,\n\t\tenum overlay_type ovtype)\n{\n\tint ret, ovcs_id;\n\n\t/* unittest device must not be in before state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tovcs_id = 0;\n\tret = of_unittest_apply_overlay(overlay_nr, &ovcs_id);\n\tif (ret != 0) {\n\t\t/* of_unittest_apply_overlay already called unittest() */\n\t\treturn ret;\n\t}\n\n\t/* unittest device must be to set to after state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != after) {\n\t\tunittest(0, \"%s failed to create @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* apply an overlay and then revert it while checking before, after states */\nstatic int __init of_unittest_apply_revert_overlay_check(int overlay_nr,\n\t\tint unittest_nr, int before, int after,\n\t\tenum overlay_type ovtype)\n{\n\tint ret, ovcs_id;\n\n\t/* unittest device must be in before state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* apply the overlay */\n\tovcs_id = 0;\n\tret = of_unittest_apply_overlay(overlay_nr, &ovcs_id);\n\tif (ret != 0) {\n\t\t/* of_unittest_apply_overlay already called unittest() */\n\t\treturn ret;\n\t}\n\n\t/* unittest device must be in after state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != after) {\n\t\tunittest(0, \"%s failed to create @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_overlay_remove(&ovcs_id);\n\tif (ret != 0) {\n\t\tunittest(0, \"%s failed to be destroyed @\\\"%s\\\"\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype));\n\t\treturn ret;\n\t}\n\n\t/* unittest device must be again in before state */\n\tif (of_unittest_device_exists(unittest_nr, PDEV_OVERLAY) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* test activation of device */\nstatic void __init of_unittest_overlay_0(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 0);\n}\n\n/* test deactivation of device */\nstatic void __init of_unittest_overlay_1(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(1, 1, 1, 0, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 1);\n}\n\n/* test activation of device */\nstatic void __init of_unittest_overlay_2(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(2, 2, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 2);\n}\n\n/* test deactivation of device */\nstatic void __init of_unittest_overlay_3(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(3, 3, 1, 0, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 3);\n}\n\n/* test activation of a full device node */\nstatic void __init of_unittest_overlay_4(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(4, 4, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 4);\n}\n\n/* test overlay apply/revert sequence */\nstatic void __init of_unittest_overlay_5(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_revert_overlay_check(5, 5, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 5);\n}\n\n/* test overlay application in sequence */\nstatic void __init of_unittest_overlay_6(void)\n{\n\tint i, ov_id[2], ovcs_id;\n\tint overlay_nr = 6, unittest_nr = 6;\n\tint before = 0, after = 1;\n\tconst char *overlay_name;\n\n\t/* unittest device must be in before state */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= before) {\n\t\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* apply the overlays */\n\tfor (i = 0; i < 2; i++) {\n\n\t\toverlay_name = overlay_name_from_nr(overlay_nr + i);\n\n\t\tif (!overlay_data_apply(overlay_name, &ovcs_id)) {\n\t\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name);\n\t\t\treturn;\n\t\t}\n\t\tov_id[i] = ovcs_id;\n\t\tof_unittest_track_overlay(ov_id[i]);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* unittest device must be in after state */\n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= after) {\n\t\t\tunittest(0, \"overlay @\\\"%s\\\" failed @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 1; i >= 0; i--) {\n\t\tovcs_id = ov_id[i];\n\t\tif (of_overlay_remove(&ovcs_id)) {\n\t\t\tunittest(0, \"%s failed destroy @\\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY));\n\t\t\treturn;\n\t\t}\n\t\tof_unittest_untrack_overlay(ov_id[i]);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* unittest device must be again in before state */\n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= before) {\n\t\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tunittest(1, \"overlay test %d passed\\n\", 6);\n}\n\n/* test overlay application in sequence */\nstatic void __init of_unittest_overlay_8(void)\n{\n\tint i, ov_id[2], ovcs_id;\n\tint overlay_nr = 8, unittest_nr = 8;\n\tconst char *overlay_name;\n\n\t/* we don't care about device state in this test */\n\n\t/* apply the overlays */\n\tfor (i = 0; i < 2; i++) {\n\n\t\toverlay_name = overlay_name_from_nr(overlay_nr + i);\n\n\t\tif (!overlay_data_apply(overlay_name, &ovcs_id)) {\n\t\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name);\n\t\t\treturn;\n\t\t}\n\t\tov_id[i] = ovcs_id;\n\t\tof_unittest_track_overlay(ov_id[i]);\n\t}\n\n\t/* now try to remove first overlay (it should fail) */\n\tovcs_id = ov_id[0];\n\tif (!of_overlay_remove(&ovcs_id)) {\n\t\tunittest(0, \"%s was destroyed @\\\"%s\\\"\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr + 0),\n\t\t\t\tunittest_path(unittest_nr,\n\t\t\t\t\tPDEV_OVERLAY));\n\t\treturn;\n\t}\n\n\t/* removing them in order should work */\n\tfor (i = 1; i >= 0; i--) {\n\t\tovcs_id = ov_id[i];\n\t\tif (of_overlay_remove(&ovcs_id)) {\n\t\t\tunittest(0, \"%s not destroyed @\\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr,\n\t\t\t\t\t\tPDEV_OVERLAY));\n\t\t\treturn;\n\t\t}\n\t\tof_unittest_untrack_overlay(ov_id[i]);\n\t}\n\n\tunittest(1, \"overlay test %d passed\\n\", 8);\n}\n\n/* test insertion of a bus with parent devices */\nstatic void __init of_unittest_overlay_10(void)\n{\n\tint ret;\n\tchar *child_path;\n\n\t/* device should disable */\n\tret = of_unittest_apply_overlay_check(10, 10, 0, 1, PDEV_OVERLAY);\n\tif (unittest(ret == 0,\n\t\t\t\"overlay test %d failed; overlay application\\n\", 10))\n\t\treturn;\n\n\tchild_path = kasprintf(GFP_KERNEL, \"%s/test-unittest101\",\n\t\t\tunittest_path(10, PDEV_OVERLAY));\n\tif (unittest(child_path, \"overlay test %d failed; kasprintf\\n\", 10))\n\t\treturn;\n\n\tret = of_path_device_type_exists(child_path, PDEV_OVERLAY);\n\tkfree(child_path);\n\n\tunittest(ret, \"overlay test %d failed; no child device\\n\", 10);\n}\n\n/* test insertion of a bus with parent devices (and revert) */\nstatic void __init of_unittest_overlay_11(void)\n{\n\tint ret;\n\n\t/* device should disable */\n\tret = of_unittest_apply_revert_overlay_check(11, 11, 0, 1,\n\t\t\tPDEV_OVERLAY);\n\tunittest(ret == 0, \"overlay test %d failed; overlay apply\\n\", 11);\n}\n\n#if IS_BUILTIN(CONFIG_I2C) && IS_ENABLED(CONFIG_OF_OVERLAY)\n\nstruct unittest_i2c_bus_data {\n\tstruct platform_device\t*pdev;\n\tstruct i2c_adapter\tadap;\n};\n\nstatic int unittest_i2c_master_xfer(struct i2c_adapter *adap,\n\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct unittest_i2c_bus_data *std = i2c_get_adapdata(adap);\n\n\t(void)std;\n\n\treturn num;\n}\n\nstatic u32 unittest_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm unittest_i2c_algo = {\n\t.master_xfer\t= unittest_i2c_master_xfer,\n\t.functionality\t= unittest_i2c_functionality,\n};\n\nstatic int unittest_i2c_bus_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct unittest_i2c_bus_data *std;\n\tstruct i2c_adapter *adap;\n\tint ret;\n\n\tif (np == NULL) {\n\t\tdev_err(dev, \"No OF data for device\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tstd = devm_kzalloc(dev, sizeof(*std), GFP_KERNEL);\n\tif (!std)\n\t\treturn -ENOMEM;\n\n\t/* link them together */\n\tstd->pdev = pdev;\n\tplatform_set_drvdata(pdev, std);\n\n\tadap = &std->adap;\n\ti2c_set_adapdata(adap, std);\n\tadap->nr = -1;\n\tstrlcpy(adap->name, pdev->name, sizeof(adap->name));\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tadap->algo = &unittest_i2c_algo;\n\tadap->dev.parent = dev;\n\tadap->dev.of_node = dev->of_node;\n\tadap->timeout = 5 * HZ;\n\tadap->retries = 3;\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to add I2C adapter\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int unittest_i2c_bus_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct unittest_i2c_bus_data *std = platform_get_drvdata(pdev);\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\ti2c_del_adapter(&std->adap);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id unittest_i2c_bus_match[] = {\n\t{ .compatible = \"unittest-i2c-bus\", },\n\t{},\n};\n\nstatic struct platform_driver unittest_i2c_bus_driver = {\n\t.probe\t\t\t= unittest_i2c_bus_probe,\n\t.remove\t\t\t= unittest_i2c_bus_remove,\n\t.driver = {\n\t\t.name\t\t= \"unittest-i2c-bus\",\n\t\t.of_match_table\t= of_match_ptr(unittest_i2c_bus_match),\n\t},\n};\n\nstatic int unittest_i2c_dev_probe(struct i2c_client *client,\n\t\tconst struct i2c_device_id *id)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\n\tif (!np) {\n\t\tdev_err(dev, \"No OF node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\treturn 0;\n};\n\nstatic int unittest_i2c_dev_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id unittest_i2c_dev_id[] = {\n\t{ .name = \"unittest-i2c-dev\" },\n\t{ }\n};\n\nstatic struct i2c_driver unittest_i2c_dev_driver = {\n\t.driver = {\n\t\t.name = \"unittest-i2c-dev\",\n\t},\n\t.probe = unittest_i2c_dev_probe,\n\t.remove = unittest_i2c_dev_remove,\n\t.id_table = unittest_i2c_dev_id,\n};\n\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\nstatic int unittest_i2c_mux_select_chan(struct i2c_mux_core *muxc, u32 chan)\n{\n\treturn 0;\n}\n\nstatic int unittest_i2c_mux_probe(struct i2c_client *client,\n\t\tconst struct i2c_device_id *id)\n{\n\tint i, nchans;\n\tstruct device *dev = &client->dev;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct device_node *np = client->dev.of_node, *child;\n\tstruct i2c_mux_core *muxc;\n\tu32 reg, max_reg;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tif (!np) {\n\t\tdev_err(dev, \"No OF node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax_reg = (u32)-1;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_read_u32(child, \"reg\", &reg))\n\t\t\tcontinue;\n\t\tif (max_reg == (u32)-1 || reg > max_reg)\n\t\t\tmax_reg = reg;\n\t}\n\tnchans = max_reg == (u32)-1 ? 0 : max_reg + 1;\n\tif (nchans == 0) {\n\t\tdev_err(dev, \"No channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmuxc = i2c_mux_alloc(adap, dev, nchans, 0, 0,\n\t\t\t     unittest_i2c_mux_select_chan, NULL);\n\tif (!muxc)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < nchans; i++) {\n\t\tif (i2c_mux_add_adapter(muxc, 0, i, 0)) {\n\t\t\tdev_err(dev, \"Failed to register mux #%d\\n\", i);\n\t\t\ti2c_mux_del_adapters(muxc);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, muxc);\n\n\treturn 0;\n};\n\nstatic int unittest_i2c_mux_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\ti2c_mux_del_adapters(muxc);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id unittest_i2c_mux_id[] = {\n\t{ .name = \"unittest-i2c-mux\" },\n\t{ }\n};\n\nstatic struct i2c_driver unittest_i2c_mux_driver = {\n\t.driver = {\n\t\t.name = \"unittest-i2c-mux\",\n\t},\n\t.probe = unittest_i2c_mux_probe,\n\t.remove = unittest_i2c_mux_remove,\n\t.id_table = unittest_i2c_mux_id,\n};\n\n#endif\n\nstatic int of_unittest_overlay_i2c_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&unittest_i2c_dev_driver);\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c device driver\\n\"))\n\t\treturn ret;\n\n\tret = platform_driver_register(&unittest_i2c_bus_driver);\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c bus driver\\n\"))\n\t\treturn ret;\n\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\tret = i2c_add_driver(&unittest_i2c_mux_driver);\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c mux driver\\n\"))\n\t\treturn ret;\n#endif\n\n\treturn 0;\n}\n\nstatic void of_unittest_overlay_i2c_cleanup(void)\n{\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\ti2c_del_driver(&unittest_i2c_mux_driver);\n#endif\n\tplatform_driver_unregister(&unittest_i2c_bus_driver);\n\ti2c_del_driver(&unittest_i2c_dev_driver);\n}\n\nstatic void __init of_unittest_overlay_i2c_12(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(12, 12, 0, 1, I2C_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 12);\n}\n\n/* test deactivation of device */\nstatic void __init of_unittest_overlay_i2c_13(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(13, 13, 1, 0, I2C_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 13);\n}\n\n/* just check for i2c mux existence */\nstatic void of_unittest_overlay_i2c_14(void)\n{\n}\n\nstatic void __init of_unittest_overlay_i2c_15(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(15, 15, 0, 1, I2C_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 15);\n}\n\n#else\n\nstatic inline void of_unittest_overlay_i2c_14(void) { }\nstatic inline void of_unittest_overlay_i2c_15(void) { }\n\n#endif\n\nstatic void __init of_unittest_overlay(void)\n{\n\tstruct device_node *bus_np = NULL;\n\n\tif (platform_driver_register(&unittest_driver)) {\n\t\tunittest(0, \"could not register unittest driver\\n\");\n\t\tgoto out;\n\t}\n\n\tbus_np = of_find_node_by_path(bus_path);\n\tif (bus_np == NULL) {\n\t\tunittest(0, \"could not find bus_path \\\"%s\\\"\\n\", bus_path);\n\t\tgoto out;\n\t}\n\n\tif (of_platform_default_populate(bus_np, NULL, NULL)) {\n\t\tunittest(0, \"could not populate bus @ \\\"%s\\\"\\n\", bus_path);\n\t\tgoto out;\n\t}\n\n\tif (!of_unittest_device_exists(100, PDEV_OVERLAY)) {\n\t\tunittest(0, \"could not find unittest0 @ \\\"%s\\\"\\n\",\n\t\t\t\tunittest_path(100, PDEV_OVERLAY));\n\t\tgoto out;\n\t}\n\n\tif (of_unittest_device_exists(101, PDEV_OVERLAY)) {\n\t\tunittest(0, \"unittest1 @ \\\"%s\\\" should not exist\\n\",\n\t\t\t\tunittest_path(101, PDEV_OVERLAY));\n\t\tgoto out;\n\t}\n\n\tunittest(1, \"basic infrastructure of overlays passed\");\n\n\t/* tests in sequence */\n\tof_unittest_overlay_0();\n\tof_unittest_overlay_1();\n\tof_unittest_overlay_2();\n\tof_unittest_overlay_3();\n\tof_unittest_overlay_4();\n\tof_unittest_overlay_5();\n\tof_unittest_overlay_6();\n\tof_unittest_overlay_8();\n\n\tof_unittest_overlay_10();\n\tof_unittest_overlay_11();\n\n#if IS_BUILTIN(CONFIG_I2C)\n\tif (unittest(of_unittest_overlay_i2c_init() == 0, \"i2c init failed\\n\"))\n\t\tgoto out;\n\n\tof_unittest_overlay_i2c_12();\n\tof_unittest_overlay_i2c_13();\n\tof_unittest_overlay_i2c_14();\n\tof_unittest_overlay_i2c_15();\n\n\tof_unittest_overlay_i2c_cleanup();\n#endif\n\n\tof_unittest_destroy_tracked_overlays();\n\nout:\n\tof_node_put(bus_np);\n}\n\n#else\nstatic inline void __init of_unittest_overlay(void) { }\n#endif\n\n#ifdef CONFIG_OF_OVERLAY\n\n/*\n * __dtb_ot_begin[] and __dtb_ot_end[] are created by cmd_dt_S_dtb\n * in scripts/Makefile.lib\n */\n\n#define OVERLAY_INFO_EXTERN(name) \\\n\textern uint8_t __dtb_##name##_begin[]; \\\n\textern uint8_t __dtb_##name##_end[]\n\n#define OVERLAY_INFO(overlay_name, expected)             \\\n{\t.dtb_begin       = __dtb_##overlay_name##_begin, \\\n\t.dtb_end         = __dtb_##overlay_name##_end,   \\\n\t.expected_result = expected,                     \\\n\t.name            = #overlay_name,                \\\n}\n\nstruct overlay_info {\n\tuint8_t\t\t*dtb_begin;\n\tuint8_t\t\t*dtb_end;\n\tint\t\texpected_result;\n\tint\t\toverlay_id;\n\tchar\t\t*name;\n};\n\nOVERLAY_INFO_EXTERN(overlay_base);\nOVERLAY_INFO_EXTERN(overlay);\nOVERLAY_INFO_EXTERN(overlay_0);\nOVERLAY_INFO_EXTERN(overlay_1);\nOVERLAY_INFO_EXTERN(overlay_2);\nOVERLAY_INFO_EXTERN(overlay_3);\nOVERLAY_INFO_EXTERN(overlay_4);\nOVERLAY_INFO_EXTERN(overlay_5);\nOVERLAY_INFO_EXTERN(overlay_6);\nOVERLAY_INFO_EXTERN(overlay_7);\nOVERLAY_INFO_EXTERN(overlay_8);\nOVERLAY_INFO_EXTERN(overlay_9);\nOVERLAY_INFO_EXTERN(overlay_10);\nOVERLAY_INFO_EXTERN(overlay_11);\nOVERLAY_INFO_EXTERN(overlay_12);\nOVERLAY_INFO_EXTERN(overlay_13);\nOVERLAY_INFO_EXTERN(overlay_15);\nOVERLAY_INFO_EXTERN(overlay_bad_add_dup_node);\nOVERLAY_INFO_EXTERN(overlay_bad_add_dup_prop);\nOVERLAY_INFO_EXTERN(overlay_bad_phandle);\nOVERLAY_INFO_EXTERN(overlay_bad_symbol);\n\n/* entries found by name */\nstatic struct overlay_info overlays[] = {\n\tOVERLAY_INFO(overlay_base, -9999),\n\tOVERLAY_INFO(overlay, 0),\n\tOVERLAY_INFO(overlay_0, 0),\n\tOVERLAY_INFO(overlay_1, 0),\n\tOVERLAY_INFO(overlay_2, 0),\n\tOVERLAY_INFO(overlay_3, 0),\n\tOVERLAY_INFO(overlay_4, 0),\n\tOVERLAY_INFO(overlay_5, 0),\n\tOVERLAY_INFO(overlay_6, 0),\n\tOVERLAY_INFO(overlay_7, 0),\n\tOVERLAY_INFO(overlay_8, 0),\n\tOVERLAY_INFO(overlay_9, 0),\n\tOVERLAY_INFO(overlay_10, 0),\n\tOVERLAY_INFO(overlay_11, 0),\n\tOVERLAY_INFO(overlay_12, 0),\n\tOVERLAY_INFO(overlay_13, 0),\n\tOVERLAY_INFO(overlay_15, 0),\n\tOVERLAY_INFO(overlay_bad_add_dup_node, -EINVAL),\n\tOVERLAY_INFO(overlay_bad_add_dup_prop, -EINVAL),\n\tOVERLAY_INFO(overlay_bad_phandle, -EINVAL),\n\tOVERLAY_INFO(overlay_bad_symbol, -EINVAL),\n\t/* end marker */\n\t{.dtb_begin = NULL, .dtb_end = NULL, .expected_result = 0, .name = NULL}\n};\n\nstatic struct device_node *overlay_base_root;\n\nstatic void * __init dt_alloc_memory(u64 size, u64 align)\n{\n\tvoid *ptr = memblock_alloc(size, align);\n\n\tif (!ptr)\n\t\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx\\n\",\n\t\t      __func__, size, align);\n\n\treturn ptr;\n}\n\n/*\n * Create base device tree for the overlay unittest.\n *\n * This is called from very early boot code.\n *\n * Do as much as possible the same way as done in __unflatten_device_tree\n * and other early boot steps for the normal FDT so that the overlay base\n * unflattened tree will have the same characteristics as the real tree\n * (such as having memory allocated by the early allocator).  The goal\n * is to test \"the real thing\" as much as possible, and test \"test setup\n * code\" as little as possible.\n *\n * Have to stop before resolving phandles, because that uses kmalloc.\n */\nvoid __init unittest_unflatten_overlay_base(void)\n{\n\tstruct overlay_info *info;\n\tu32 data_size;\n\tvoid *new_fdt;\n\tu32 size;\n\tint found = 0;\n\tconst char *overlay_name = \"overlay_base\";\n\n\tfor (info = overlays; info && info->name; info++) {\n\t\tif (!strcmp(overlay_name, info->name)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\t\treturn;\n\t}\n\n\tinfo = &overlays[0];\n\n\tif (info->expected_result != -9999) {\n\t\tpr_err(\"No dtb 'overlay_base' to attach\\n\");\n\t\treturn;\n\t}\n\n\tdata_size = info->dtb_end - info->dtb_begin;\n\tif (!data_size) {\n\t\tpr_err(\"No dtb 'overlay_base' to attach\\n\");\n\t\treturn;\n\t}\n\n\tsize = fdt_totalsize(info->dtb_begin);\n\tif (size != data_size) {\n\t\tpr_err(\"dtb 'overlay_base' header totalsize != actual size\");\n\t\treturn;\n\t}\n\n\tnew_fdt = dt_alloc_memory(size, roundup_pow_of_two(FDT_V17_SIZE));\n\tif (!new_fdt) {\n\t\tpr_err(\"alloc for dtb 'overlay_base' failed\");\n\t\treturn;\n\t}\n\n\tmemcpy(new_fdt, info->dtb_begin, size);\n\n\t__unflatten_device_tree(new_fdt, NULL, &overlay_base_root,\n\t\t\t\tdt_alloc_memory, true);\n}\n\n/*\n * The purpose of of_unittest_overlay_data_add is to add an\n * overlay in the normal fashion.  This is a test of the whole\n * picture, instead of testing individual elements.\n *\n * A secondary purpose is to be able to verify that the contents of\n * /proc/device-tree/ contains the updated structure and values from\n * the overlay.  That must be verified separately in user space.\n *\n * Return 0 on unexpected error.\n */\nstatic int __init overlay_data_apply(const char *overlay_name, int *overlay_id)\n{\n\tstruct overlay_info *info;\n\tint found = 0;\n\tint ret;\n\tu32 size;\n\n\tfor (info = overlays; info && info->name; info++) {\n\t\tif (!strcmp(overlay_name, info->name)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\t\treturn 0;\n\t}\n\n\tsize = info->dtb_end - info->dtb_begin;\n\tif (!size)\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\n\tret = of_overlay_fdt_apply(info->dtb_begin, size, &info->overlay_id);\n\tif (overlay_id)\n\t\t*overlay_id = info->overlay_id;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpr_debug(\"%s applied\\n\", overlay_name);\n\nout:\n\tif (ret != info->expected_result)\n\t\tpr_err(\"of_overlay_fdt_apply() expected %d, ret=%d, %s\\n\",\n\t\t       info->expected_result, ret, overlay_name);\n\n\treturn (ret == info->expected_result);\n}\n\n/*\n * The purpose of of_unittest_overlay_high_level is to add an overlay\n * in the normal fashion.  This is a test of the whole picture,\n * instead of individual elements.\n *\n * The first part of the function is _not_ normal overlay usage; it is\n * finishing splicing the base overlay device tree into the live tree.\n */\nstatic __init void of_unittest_overlay_high_level(void)\n{\n\tstruct device_node *last_sibling;\n\tstruct device_node *np;\n\tstruct device_node *of_symbols;\n\tstruct device_node *overlay_base_symbols;\n\tstruct device_node **pprev;\n\tstruct property *prop;\n\n\tif (!overlay_base_root) {\n\t\tunittest(0, \"overlay_base_root not initialized\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Could not fixup phandles in unittest_unflatten_overlay_base()\n\t * because kmalloc() was not yet available.\n\t */\n\tof_overlay_mutex_lock();\n\tof_resolve_phandles(overlay_base_root);\n\tof_overlay_mutex_unlock();\n\n\n\t/*\n\t * do not allow overlay_base to duplicate any node already in\n\t * tree, this greatly simplifies the code\n\t */\n\n\t/*\n\t * remove overlay_base_root node \"__local_fixups\", after\n\t * being used by of_resolve_phandles()\n\t */\n\tpprev = &overlay_base_root->child;\n\tfor (np = overlay_base_root->child; np; np = np->sibling) {\n\t\tif (of_node_name_eq(np, \"__local_fixups__\")) {\n\t\t\t*pprev = np->sibling;\n\t\t\tbreak;\n\t\t}\n\t\tpprev = &np->sibling;\n\t}\n\n\t/* remove overlay_base_root node \"__symbols__\" if in live tree */\n\tof_symbols = of_get_child_by_name(of_root, \"__symbols__\");\n\tif (of_symbols) {\n\t\t/* will have to graft properties from node into live tree */\n\t\tpprev = &overlay_base_root->child;\n\t\tfor (np = overlay_base_root->child; np; np = np->sibling) {\n\t\t\tif (of_node_name_eq(np, \"__symbols__\")) {\n\t\t\t\toverlay_base_symbols = np;\n\t\t\t\t*pprev = np->sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpprev = &np->sibling;\n\t\t}\n\t}\n\n\tfor_each_child_of_node(overlay_base_root, np) {\n\t\tstruct device_node *base_child;\n\t\tfor_each_child_of_node(of_root, base_child) {\n\t\t\tif (!strcmp(np->full_name, base_child->full_name)) {\n\t\t\t\tunittest(0, \"illegal node name in overlay_base %pOFn\",\n\t\t\t\t\t np);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * overlay 'overlay_base' is not allowed to have root\n\t * properties, so only need to splice nodes into main device tree.\n\t *\n\t * root node of *overlay_base_root will not be freed, it is lost\n\t * memory.\n\t */\n\n\tfor (np = overlay_base_root->child; np; np = np->sibling)\n\t\tnp->parent = of_root;\n\n\tmutex_lock(&of_mutex);\n\n\tfor (last_sibling = np = of_root->child; np; np = np->sibling)\n\t\tlast_sibling = np;\n\n\tif (last_sibling)\n\t\tlast_sibling->sibling = overlay_base_root->child;\n\telse\n\t\tof_root->child = overlay_base_root->child;\n\n\tfor_each_of_allnodes_from(overlay_base_root, np)\n\t\t__of_attach_node_sysfs(np);\n\n\tif (of_symbols) {\n\t\tstruct property *new_prop;\n\t\tfor_each_property_of_node(overlay_base_symbols, prop) {\n\n\t\t\tnew_prop = __of_prop_dup(prop, GFP_KERNEL);\n\t\t\tif (!new_prop) {\n\t\t\t\tunittest(0, \"__of_prop_dup() of '%s' from overlay_base node __symbols__\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\tif (__of_add_property(of_symbols, new_prop)) {\n\t\t\t\t/* \"name\" auto-generated by unflatten */\n\t\t\t\tif (!strcmp(new_prop->name, \"name\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tunittest(0, \"duplicate property '%s' in overlay_base node __symbols__\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\tif (__of_add_property_sysfs(of_symbols, new_prop)) {\n\t\t\t\tunittest(0, \"unable to add property '%s' in overlay_base node __symbols__ to sysfs\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&of_mutex);\n\n\n\t/* now do the normal overlay usage test */\n\n\tunittest(overlay_data_apply(\"overlay\", NULL),\n\t\t \"Adding overlay 'overlay' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_add_dup_node\", NULL),\n\t\t \"Adding overlay 'overlay_bad_add_dup_node' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_add_dup_prop\", NULL),\n\t\t \"Adding overlay 'overlay_bad_add_dup_prop' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_phandle\", NULL),\n\t\t \"Adding overlay 'overlay_bad_phandle' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_symbol\", NULL),\n\t\t \"Adding overlay 'overlay_bad_symbol' failed\\n\");\n\n\treturn;\n\nerr_unlock:\n\tmutex_unlock(&of_mutex);\n}\n\n#else\n\nstatic inline __init void of_unittest_overlay_high_level(void) {}\n\n#endif\n\nstatic int __init of_unittest(void)\n{\n\tstruct device_node *np;\n\tint res;\n\n\t/* adding data for unittest */\n\n\tif (IS_ENABLED(CONFIG_UML))\n\t\tunittest_unflatten_overlay_base();\n\n\tres = unittest_data_add();\n\tif (res)\n\t\treturn res;\n\tif (!of_aliases)\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_info(\"No testcase data in device tree; not running tests\\n\");\n\t\treturn 0;\n\t}\n\tof_node_put(np);\n\n\tpr_info(\"start of unittest - you will see error messages\\n\");\n\tof_unittest_check_tree_linkage();\n\tof_unittest_check_phandles();\n\tof_unittest_find_node_by_name();\n\tof_unittest_dynamic();\n\tof_unittest_parse_phandle_with_args();\n\tof_unittest_parse_phandle_with_args_map();\n\tof_unittest_printf();\n\tof_unittest_property_string();\n\tof_unittest_property_copy();\n\tof_unittest_changeset();\n\tof_unittest_parse_interrupts();\n\tof_unittest_parse_interrupts_extended();\n\tof_unittest_match_node();\n\tof_unittest_platform_populate();\n\tof_unittest_overlay();\n\n\t/* Double check linkage after removing testcase data */\n\tof_unittest_check_tree_linkage();\n\n\tof_unittest_overlay_high_level();\n\n\tpr_info(\"end of unittest - %i passed, %i failed\\n\",\n\t\tunittest_results.passed, unittest_results.failed);\n\n\treturn 0;\n}\nlate_initcall(of_unittest);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Self tests for device tree subsystem\n */\n\n#define pr_fmt(fmt) \"### dt-test ### \" fmt\n\n#include <linux/memblock.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/hashtable.h>\n#include <linux/libfdt.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n\n#include <linux/bitops.h>\n\n#include \"of_private.h\"\n\nstatic struct unittest_results {\n\tint passed;\n\tint failed;\n} unittest_results;\n\n#define unittest(result, fmt, ...) ({ \\\n\tbool failed = !(result); \\\n\tif (failed) { \\\n\t\tunittest_results.failed++; \\\n\t\tpr_err(\"FAIL %s():%i \" fmt, __func__, __LINE__, ##__VA_ARGS__); \\\n\t} else { \\\n\t\tunittest_results.passed++; \\\n\t\tpr_debug(\"pass %s():%i\\n\", __func__, __LINE__); \\\n\t} \\\n\tfailed; \\\n})\n\nstatic void __init of_unittest_find_node_by_name(void)\n{\n\tstruct device_node *np;\n\tconst char *options, *name;\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data\", name),\n\t\t\"find /testcase-data failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\t/* Test if trailing '/' works */\n\tnp = of_find_node_by_path(\"/testcase-data/\");\n\tunittest(!np, \"trailing '/' on /testcase-data/ should fail\\n\");\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data/phandle-tests/consumer-a\", name),\n\t\t\"find /testcase-data/phandle-tests/consumer-a failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\tnp = of_find_node_by_path(\"testcase-alias\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data\", name),\n\t\t\"find testcase-alias failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\t/* Test if trailing '/' works on aliases */\n\tnp = of_find_node_by_path(\"testcase-alias/\");\n\tunittest(!np, \"trailing '/' on testcase-alias/ should fail\\n\");\n\n\tnp = of_find_node_by_path(\"testcase-alias/phandle-tests/consumer-a\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && !strcmp(\"/testcase-data/phandle-tests/consumer-a\", name),\n\t\t\"find testcase-alias/phandle-tests/consumer-a failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\tnp = of_find_node_by_path(\"/testcase-data/missing-path\");\n\tunittest(!np, \"non-existent path returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"missing-alias\");\n\tunittest(!np, \"non-existent alias returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"testcase-alias/missing-path\");\n\tunittest(!np, \"non-existent alias with relative path returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:testoption\", &options);\n\tunittest(np && !strcmp(\"testoption\", options),\n\t\t \"option path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:test/option\", &options);\n\tunittest(np && !strcmp(\"test/option\", options),\n\t\t \"option path test, subcase #1 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data/testcase-device1:test/option\", &options);\n\tunittest(np && !strcmp(\"test/option\", options),\n\t\t \"option path test, subcase #2 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:testoption\", NULL);\n\tunittest(np, \"NULL option path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:testaliasoption\",\n\t\t\t\t       &options);\n\tunittest(np && !strcmp(\"testaliasoption\", options),\n\t\t \"option alias path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:test/alias/option\",\n\t\t\t\t       &options);\n\tunittest(np && !strcmp(\"test/alias/option\", options),\n\t\t \"option alias path test, subcase #1 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:testaliasoption\", NULL);\n\tunittest(np, \"NULL option alias path test failed\\n\");\n\tof_node_put(np);\n\n\toptions = \"testoption\";\n\tnp = of_find_node_opts_by_path(\"testcase-alias\", &options);\n\tunittest(np && !options, \"option clearing test failed\\n\");\n\tof_node_put(np);\n\n\toptions = \"testoption\";\n\tnp = of_find_node_opts_by_path(\"/\", &options);\n\tunittest(np && !options, \"option clearing root node test failed\\n\");\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_dynamic(void)\n{\n\tstruct device_node *np;\n\tstruct property *prop;\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\t/* Array of 4 properties for the purpose of testing */\n\tprop = kcalloc(4, sizeof(*prop), GFP_KERNEL);\n\tif (!prop) {\n\t\tunittest(0, \"kzalloc() failed\\n\");\n\t\treturn;\n\t}\n\n\t/* Add a new property - should pass*/\n\tprop->name = \"new-property\";\n\tprop->value = \"new-property-data\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_add_property(np, prop) == 0, \"Adding a new property failed\\n\");\n\n\t/* Try to add an existing property - should fail */\n\tprop++;\n\tprop->name = \"new-property\";\n\tprop->value = \"new-property-data-should-fail\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_add_property(np, prop) != 0,\n\t\t \"Adding an existing property should have failed\\n\");\n\n\t/* Try to modify an existing property - should pass */\n\tprop->value = \"modify-property-data-should-pass\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_update_property(np, prop) == 0,\n\t\t \"Updating an existing property should have passed\\n\");\n\n\t/* Try to modify non-existent property - should pass*/\n\tprop++;\n\tprop->name = \"modify-property\";\n\tprop->value = \"modify-missing-property-data-should-pass\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_update_property(np, prop) == 0,\n\t\t \"Updating a missing property should have passed\\n\");\n\n\t/* Remove property - should pass */\n\tunittest(of_remove_property(np, prop) == 0,\n\t\t \"Removing a property should have passed\\n\");\n\n\t/* Adding very large property - should pass */\n\tprop++;\n\tprop->name = \"large-property-PAGE_SIZEx8\";\n\tprop->length = PAGE_SIZE * 8;\n\tprop->value = kzalloc(prop->length, GFP_KERNEL);\n\tunittest(prop->value != NULL, \"Unable to allocate large buffer\\n\");\n\tif (prop->value)\n\t\tunittest(of_add_property(np, prop) == 0,\n\t\t\t \"Adding a large property should have passed\\n\");\n}\n\nstatic int __init of_unittest_check_node_linkage(struct device_node *np)\n{\n\tstruct device_node *child;\n\tint count = 0, rc;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (child->parent != np) {\n\t\t\tpr_err(\"Child node %pOFn links to wrong parent %pOFn\\n\",\n\t\t\t\t child, np);\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\trc = of_unittest_check_node_linkage(child);\n\t\tif (rc < 0)\n\t\t\tgoto put_child;\n\t\tcount += rc;\n\t}\n\n\treturn count + 1;\nput_child:\n\tof_node_put(child);\n\treturn rc;\n}\n\nstatic void __init of_unittest_check_tree_linkage(void)\n{\n\tstruct device_node *np;\n\tint allnode_count = 0, child_count;\n\n\tif (!of_root)\n\t\treturn;\n\n\tfor_each_of_allnodes(np)\n\t\tallnode_count++;\n\tchild_count = of_unittest_check_node_linkage(of_root);\n\n\tunittest(child_count > 0, \"Device node data structure is corrupted\\n\");\n\tunittest(child_count == allnode_count,\n\t\t \"allnodes list size (%i) doesn't match sibling lists size (%i)\\n\",\n\t\t allnode_count, child_count);\n\tpr_debug(\"allnodes list size (%i); sibling lists size (%i)\\n\", allnode_count, child_count);\n}\n\nstatic void __init of_unittest_printf_one(struct device_node *np, const char *fmt,\n\t\t\t\t\t  const char *expected)\n{\n\tunsigned char *buf;\n\tint buf_size;\n\tint size, i;\n\n\tbuf_size = strlen(expected) + 10;\n\tbuf = kmalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\t/* Baseline; check conversion with a large size limit */\n\tmemset(buf, 0xff, buf_size);\n\tsize = snprintf(buf, buf_size - 2, fmt, np);\n\n\t/* use strcmp() instead of strncmp() here to be absolutely sure strings match */\n\tunittest((strcmp(buf, expected) == 0) && (buf[size+1] == 0xff),\n\t\t\"sprintf failed; fmt='%s' expected='%s' rslt='%s'\\n\",\n\t\tfmt, expected, buf);\n\n\t/* Make sure length limits work */\n\tsize++;\n\tfor (i = 0; i < 2; i++, size--) {\n\t\t/* Clear the buffer, and make sure it works correctly still */\n\t\tmemset(buf, 0xff, buf_size);\n\t\tsnprintf(buf, size+1, fmt, np);\n\t\tunittest(strncmp(buf, expected, size) == 0 && (buf[size+1] == 0xff),\n\t\t\t\"snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\\n\",\n\t\t\tsize, fmt, expected, buf);\n\t}\n\tkfree(buf);\n}\n\nstatic void __init of_unittest_printf(void)\n{\n\tstruct device_node *np;\n\tconst char *full_name = \"/testcase-data/platform-tests/test-device@1/dev@100\";\n\tchar phandle_str[16] = \"\";\n\n\tnp = of_find_node_by_path(full_name);\n\tif (!np) {\n\t\tunittest(np, \"testcase data missing\\n\");\n\t\treturn;\n\t}\n\n\tnum_to_str(phandle_str, sizeof(phandle_str), np->phandle, 0);\n\n\tof_unittest_printf_one(np, \"%pOF\",  full_name);\n\tof_unittest_printf_one(np, \"%pOFf\", full_name);\n\tof_unittest_printf_one(np, \"%pOFn\", \"dev\");\n\tof_unittest_printf_one(np, \"%2pOFn\", \"dev\");\n\tof_unittest_printf_one(np, \"%5pOFn\", \"  dev\");\n\tof_unittest_printf_one(np, \"%pOFnc\", \"dev:test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFp\", phandle_str);\n\tof_unittest_printf_one(np, \"%pOFP\", \"dev@100\");\n\tof_unittest_printf_one(np, \"ABC %pOFP ABC\", \"ABC dev@100 ABC\");\n\tof_unittest_printf_one(np, \"%10pOFP\", \"   dev@100\");\n\tof_unittest_printf_one(np, \"%-10pOFP\", \"dev@100   \");\n\tof_unittest_printf_one(of_root, \"%pOFP\", \"/\");\n\tof_unittest_printf_one(np, \"%pOFF\", \"----\");\n\tof_unittest_printf_one(np, \"%pOFPF\", \"dev@100:----\");\n\tof_unittest_printf_one(np, \"%pOFPFPc\", \"dev@100:----:dev@100:test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFc\", \"test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFC\",\n\t\t\t\"\\\"test-sub-device\\\",\\\"test-compat2\\\",\\\"test-compat3\\\"\");\n}\n\nstruct node_hash {\n\tstruct hlist_node node;\n\tstruct device_node *np;\n};\n\nstatic DEFINE_HASHTABLE(phandle_ht, 8);\nstatic void __init of_unittest_check_phandles(void)\n{\n\tstruct device_node *np;\n\tstruct node_hash *nh;\n\tstruct hlist_node *tmp;\n\tint i, dup_count = 0, phandle_count = 0;\n\n\tfor_each_of_allnodes(np) {\n\t\tif (!np->phandle)\n\t\t\tcontinue;\n\n\t\thash_for_each_possible(phandle_ht, nh, node, np->phandle) {\n\t\t\tif (nh->np->phandle == np->phandle) {\n\t\t\t\tpr_info(\"Duplicate phandle! %i used by %pOF and %pOF\\n\",\n\t\t\t\t\tnp->phandle, nh->np, np);\n\t\t\t\tdup_count++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnh = kzalloc(sizeof(*nh), GFP_KERNEL);\n\t\tif (!nh)\n\t\t\treturn;\n\n\t\tnh->np = np;\n\t\thash_add(phandle_ht, &nh->node, np->phandle);\n\t\tphandle_count++;\n\t}\n\tunittest(dup_count == 0, \"Found %i duplicates in %i phandles\\n\",\n\t\t dup_count, phandle_count);\n\n\t/* Clean up */\n\thash_for_each_safe(phandle_ht, i, tmp, nh, node) {\n\t\thash_del(&nh->node);\n\t\tkfree(nh);\n\t}\n}\n\nstatic void __init of_unittest_parse_phandle_with_args(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\trc = of_count_phandle_with_args(np, \"phandle-list\", \"#phandle-cells\");\n\tunittest(rc == 7, \"of_count_phandle_with_args() returned %i, expected 7\\n\", rc);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_parse_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\t\"#phandle-cells\", i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 4);\n\t\t\tpassed &= (args.args[2] == 3);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 100);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\n\t/* Check for missing list property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list-missing\",\n\t\t\t\t\t\"#phandle-cells\", 0, &args);\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list-missing\",\n\t\t\t\t\t\"#phandle-cells\");\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\n\t/* Check for missing cells property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\"#phandle-cells-missing\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\"#phandle-cells-missing\");\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for bad phandle in list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t\"#phandle-cells\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t\"#phandle-cells\");\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for incorrectly formed argument list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list-bad-args\",\n\t\t\t\t\t\"#phandle-cells\", 1, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list-bad-args\",\n\t\t\t\t\t\"#phandle-cells\");\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n}\n\nstatic void __init of_unittest_parse_phandle_with_args_map(void)\n{\n\tstruct device_node *np, *p0, *p1, *p2, *p3;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-b\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp0 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider0\");\n\tif (!p0) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp1 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider1\");\n\tif (!p1) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp2 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider2\");\n\tif (!p2) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp3 = of_find_node_by_path(\"/testcase-data/phandle-tests/provider3\");\n\tif (!p3) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\trc = of_count_phandle_with_args(np, \"phandle-list\", \"#phandle-cells\");\n\tunittest(rc == 7, \"of_count_phandle_with_args() returned %i, expected 7\\n\", rc);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_parse_phandle_with_args_map(np, \"phandle-list\",\n\t\t\t\t\t\t    \"phandle\", i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p1);\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p3);\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 2);\n\t\t\tpassed &= (args.args[1] == 5);\n\t\t\tpassed &= (args.args[2] == 3);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p0);\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p1);\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 3);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p0);\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p2);\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tpassed &= (args.args[1] == 0x20);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %s rc=%i\\n\",\n\t\t\t i, args.np->full_name, rc);\n\t}\n\n\t/* Check for missing list property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-missing\",\n\t\t\t\t\t    \"phandle\", 0, &args);\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\n\t/* Check for missing cells,map,mask property */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list\",\n\t\t\t\t\t    \"phandle-missing\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for bad phandle in list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t    \"phandle\", 0, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t/* Check for incorrectly formed argument list */\n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-bad-args\",\n\t\t\t\t\t    \"phandle\", 1, &args);\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n}\n\nstatic void __init of_unittest_property_string(void)\n{\n\tconst char *strings[4];\n\tstruct device_node *np;\n\tint rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_err(\"No testcase data in device tree\\n\");\n\t\treturn;\n\t}\n\n\trc = of_property_match_string(np, \"phandle-list-names\", \"first\");\n\tunittest(rc == 0, \"first expected:0 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"second\");\n\tunittest(rc == 1, \"second expected:1 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"third\");\n\tunittest(rc == 2, \"third expected:2 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"fourth\");\n\tunittest(rc == -ENODATA, \"unmatched string; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"missing-property\", \"blah\");\n\tunittest(rc == -EINVAL, \"missing property; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"empty-property\", \"blah\");\n\tunittest(rc == -ENODATA, \"empty property; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"unterminated-string\", \"blah\");\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\n\t/* of_property_count_strings() tests */\n\trc = of_property_count_strings(np, \"string-property\");\n\tunittest(rc == 1, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"phandle-list-names\");\n\tunittest(rc == 3, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"unterminated-string\");\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"unterminated-string-list\");\n\tunittest(rc == -EILSEQ, \"unterminated string array; rc=%i\\n\", rc);\n\n\t/* of_property_read_string_index() tests */\n\trc = of_property_read_string_index(np, \"string-property\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"foobar\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"string-property\", 1, strings);\n\tunittest(rc == -ENODATA && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"first\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 1, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"second\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 2, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"third\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 3, strings);\n\tunittest(rc == -ENODATA && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"unterminated-string\", 0, strings);\n\tunittest(rc == -EILSEQ && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"unterminated-string-list\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"first\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"unterminated-string-list\", 2, strings); /* should fail */\n\tunittest(rc == -EILSEQ && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[1] = NULL;\n\n\t/* of_property_read_string_array() tests */\n\trc = of_property_read_string_array(np, \"string-property\", strings, 4);\n\tunittest(rc == 1, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_read_string_array(np, \"phandle-list-names\", strings, 4);\n\tunittest(rc == 3, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_read_string_array(np, \"unterminated-string\", strings, 4);\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\t/* -- An incorrectly formed string should cause a failure */\n\trc = of_property_read_string_array(np, \"unterminated-string-list\", strings, 4);\n\tunittest(rc == -EILSEQ, \"unterminated string array; rc=%i\\n\", rc);\n\t/* -- parsing the correctly formed strings should still work: */\n\tstrings[2] = NULL;\n\trc = of_property_read_string_array(np, \"unterminated-string-list\", strings, 2);\n\tunittest(rc == 2 && strings[2] == NULL, \"of_property_read_string_array() failure; rc=%i\\n\", rc);\n\tstrings[1] = NULL;\n\trc = of_property_read_string_array(np, \"phandle-list-names\", strings, 1);\n\tunittest(rc == 1 && strings[1] == NULL, \"Overwrote end of string array; rc=%i, str='%s'\\n\", rc, strings[1]);\n}\n\n#define propcmp(p1, p2) (((p1)->length == (p2)->length) && \\\n\t\t\t(p1)->value && (p2)->value && \\\n\t\t\t!memcmp((p1)->value, (p2)->value, (p1)->length) && \\\n\t\t\t!strcmp((p1)->name, (p2)->name))\nstatic void __init of_unittest_property_copy(void)\n{\n#ifdef CONFIG_OF_DYNAMIC\n\tstruct property p1 = { .name = \"p1\", .length = 0, .value = \"\" };\n\tstruct property p2 = { .name = \"p2\", .length = 5, .value = \"abcd\" };\n\tstruct property *new;\n\n\tnew = __of_prop_dup(&p1, GFP_KERNEL);\n\tunittest(new && propcmp(&p1, new), \"empty property didn't copy correctly\\n\");\n\tkfree(new->value);\n\tkfree(new->name);\n\tkfree(new);\n\n\tnew = __of_prop_dup(&p2, GFP_KERNEL);\n\tunittest(new && propcmp(&p2, new), \"non-empty property didn't copy correctly\\n\");\n\tkfree(new->value);\n\tkfree(new->name);\n\tkfree(new);\n#endif\n}\n\nstatic void __init of_unittest_changeset(void)\n{\n#ifdef CONFIG_OF_DYNAMIC\n\tstruct property *ppadd, padd = { .name = \"prop-add\", .length = 1, .value = \"\" };\n\tstruct property *ppname_n1,  pname_n1  = { .name = \"name\", .length = 3, .value = \"n1\"  };\n\tstruct property *ppname_n2,  pname_n2  = { .name = \"name\", .length = 3, .value = \"n2\"  };\n\tstruct property *ppname_n21, pname_n21 = { .name = \"name\", .length = 3, .value = \"n21\" };\n\tstruct property *ppupdate, pupdate = { .name = \"prop-update\", .length = 5, .value = \"abcd\" };\n\tstruct property *ppremove;\n\tstruct device_node *n1, *n2, *n21, *nchangeset, *nremove, *parent, *np;\n\tstruct of_changeset chgset;\n\n\tn1 = __of_node_dup(NULL, \"n1\");\n\tunittest(n1, \"testcase setup failure\\n\");\n\n\tn2 = __of_node_dup(NULL, \"n2\");\n\tunittest(n2, \"testcase setup failure\\n\");\n\n\tn21 = __of_node_dup(NULL, \"n21\");\n\tunittest(n21, \"testcase setup failure %p\\n\", n21);\n\n\tnchangeset = of_find_node_by_path(\"/testcase-data/changeset\");\n\tnremove = of_get_child_by_name(nchangeset, \"node-remove\");\n\tunittest(nremove, \"testcase setup failure\\n\");\n\n\tppadd = __of_prop_dup(&padd, GFP_KERNEL);\n\tunittest(ppadd, \"testcase setup failure\\n\");\n\n\tppname_n1  = __of_prop_dup(&pname_n1, GFP_KERNEL);\n\tunittest(ppname_n1, \"testcase setup failure\\n\");\n\n\tppname_n2  = __of_prop_dup(&pname_n2, GFP_KERNEL);\n\tunittest(ppname_n2, \"testcase setup failure\\n\");\n\n\tppname_n21 = __of_prop_dup(&pname_n21, GFP_KERNEL);\n\tunittest(ppname_n21, \"testcase setup failure\\n\");\n\n\tppupdate = __of_prop_dup(&pupdate, GFP_KERNEL);\n\tunittest(ppupdate, \"testcase setup failure\\n\");\n\n\tparent = nchangeset;\n\tn1->parent = parent;\n\tn2->parent = parent;\n\tn21->parent = n2;\n\n\tppremove = of_find_property(parent, \"prop-remove\", NULL);\n\tunittest(ppremove, \"failed to find removal prop\");\n\n\tof_changeset_init(&chgset);\n\n\tunittest(!of_changeset_attach_node(&chgset, n1), \"fail attach n1\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n1, ppname_n1), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_attach_node(&chgset, n2), \"fail attach n2\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n2, ppname_n2), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_detach_node(&chgset, nremove), \"fail remove node\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n21, ppname_n21), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_attach_node(&chgset, n21), \"fail attach n21\\n\");\n\n\tunittest(!of_changeset_add_property(&chgset, parent, ppadd), \"fail add prop prop-add\\n\");\n\tunittest(!of_changeset_update_property(&chgset, parent, ppupdate), \"fail update prop\\n\");\n\tunittest(!of_changeset_remove_property(&chgset, parent, ppremove), \"fail remove prop\\n\");\n\n\tunittest(!of_changeset_apply(&chgset), \"apply failed\\n\");\n\n\tof_node_put(nchangeset);\n\n\t/* Make sure node names are constructed correctly */\n\tunittest((np = of_find_node_by_path(\"/testcase-data/changeset/n2/n21\")),\n\t\t \"'%pOF' not added\\n\", n21);\n\tof_node_put(np);\n\n\tunittest(!of_changeset_revert(&chgset), \"revert failed\\n\");\n\n\tof_changeset_destroy(&chgset);\n#endif\n}\n\nstatic void __init of_unittest_parse_interrupts(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts0\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\tpassed &= !rc;\n\t\tpassed &= (args.args_count == 1);\n\t\tpassed &= (args.args[0] == (i + 1));\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts1\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 9);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 10);\n\t\t\tpassed &= (args.args[1] == 11);\n\t\t\tpassed &= (args.args[2] == 12);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 13);\n\t\t\tpassed &= (args.args[1] == 14);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tpassed &= (args.args[1] == 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_parse_interrupts_extended(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts-extended0\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\t/* Test the values from tests-phandle.dtsi */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 2);\n\t\t\tpassed &= (args.args[1] == 3);\n\t\t\tpassed &= (args.args[2] == 4);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 5);\n\t\t\tpassed &= (args.args[1] == 6);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 9);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 10);\n\t\t\tpassed &= (args.args[1] == 11);\n\t\t\tpassed &= (args.args[2] == 12);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 13);\n\t\t\tpassed &= (args.args[1] == 14);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n}\n\nstatic const struct of_device_id match_node_table[] = {\n\t{ .data = \"A\", .name = \"name0\", }, /* Name alone is lowest priority */\n\t{ .data = \"B\", .type = \"type1\", }, /* followed by type alone */\n\n\t{ .data = \"Ca\", .name = \"name2\", .type = \"type1\", }, /* followed by both together */\n\t{ .data = \"Cb\", .name = \"name2\", }, /* Only match when type doesn't match */\n\t{ .data = \"Cc\", .name = \"name2\", .type = \"type2\", },\n\n\t{ .data = \"E\", .compatible = \"compat3\" },\n\t{ .data = \"G\", .compatible = \"compat2\", },\n\t{ .data = \"H\", .compatible = \"compat2\", .name = \"name5\", },\n\t{ .data = \"I\", .compatible = \"compat2\", .type = \"type1\", },\n\t{ .data = \"J\", .compatible = \"compat2\", .type = \"type1\", .name = \"name8\", },\n\t{ .data = \"K\", .compatible = \"compat2\", .name = \"name9\", },\n\t{}\n};\n\nstatic struct {\n\tconst char *path;\n\tconst char *data;\n} match_node_tests[] = {\n\t{ .path = \"/testcase-data/match-node/name0\", .data = \"A\", },\n\t{ .path = \"/testcase-data/match-node/name1\", .data = \"B\", },\n\t{ .path = \"/testcase-data/match-node/a/name2\", .data = \"Ca\", },\n\t{ .path = \"/testcase-data/match-node/b/name2\", .data = \"Cb\", },\n\t{ .path = \"/testcase-data/match-node/c/name2\", .data = \"Cc\", },\n\t{ .path = \"/testcase-data/match-node/name3\", .data = \"E\", },\n\t{ .path = \"/testcase-data/match-node/name4\", .data = \"G\", },\n\t{ .path = \"/testcase-data/match-node/name5\", .data = \"H\", },\n\t{ .path = \"/testcase-data/match-node/name6\", .data = \"G\", },\n\t{ .path = \"/testcase-data/match-node/name7\", .data = \"I\", },\n\t{ .path = \"/testcase-data/match-node/name8\", .data = \"J\", },\n\t{ .path = \"/testcase-data/match-node/name9\", .data = \"K\", },\n};\n\nstatic void __init of_unittest_match_node(void)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *match;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(match_node_tests); i++) {\n\t\tnp = of_find_node_by_path(match_node_tests[i].path);\n\t\tif (!np) {\n\t\t\tunittest(0, \"missing testcase node %s\\n\",\n\t\t\t\tmatch_node_tests[i].path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = of_match_node(match_node_table, np);\n\t\tif (!match) {\n\t\t\tunittest(0, \"%s didn't match anything\\n\",\n\t\t\t\tmatch_node_tests[i].path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(match->data, match_node_tests[i].data) != 0) {\n\t\t\tunittest(0, \"%s got wrong match. expected %s, got %s\\n\",\n\t\t\t\tmatch_node_tests[i].path, match_node_tests[i].data,\n\t\t\t\t(const char *)match->data);\n\t\t\tcontinue;\n\t\t}\n\t\tunittest(1, \"passed\");\n\t}\n}\n\nstatic struct resource test_bus_res = {\n\t.start = 0xfffffff8,\n\t.end = 0xfffffff9,\n\t.flags = IORESOURCE_MEM,\n};\nstatic const struct platform_device_info test_bus_info = {\n\t.name = \"unittest-bus\",\n};\nstatic void __init of_unittest_platform_populate(void)\n{\n\tint irq, rc;\n\tstruct device_node *np, *child, *grandchild;\n\tstruct platform_device *pdev, *test_bus;\n\tconst struct of_device_id match[] = {\n\t\t{ .compatible = \"test-device\", },\n\t\t{}\n\t};\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tof_platform_default_populate(np, NULL, NULL);\n\n\t/* Test that a missing irq domain returns -EPROBE_DEFER */\n\tnp = of_find_node_by_path(\"/testcase-data/testcase-device1\");\n\tpdev = of_find_device_by_node(np);\n\tunittest(pdev, \"device 1 creation failed\\n\");\n\n\tif (!(of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)) {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tunittest(irq == -EPROBE_DEFER,\n\t\t\t \"device deferred probe failed - %d\\n\", irq);\n\n\t\t/* Test that a parsing failure does not return -EPROBE_DEFER */\n\t\tnp = of_find_node_by_path(\"/testcase-data/testcase-device2\");\n\t\tpdev = of_find_device_by_node(np);\n\t\tunittest(pdev, \"device 2 creation failed\\n\");\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tunittest(irq < 0 && irq != -EPROBE_DEFER,\n\t\t\t \"device parsing error failed - %d\\n\", irq);\n\t}\n\n\tnp = of_find_node_by_path(\"/testcase-data/platform-tests\");\n\tunittest(np, \"No testcase data in device tree\\n\");\n\tif (!np)\n\t\treturn;\n\n\ttest_bus = platform_device_register_full(&test_bus_info);\n\trc = PTR_ERR_OR_ZERO(test_bus);\n\tunittest(!rc, \"testbus registration failed; rc=%i\\n\", rc);\n\tif (rc) {\n\t\tof_node_put(np);\n\t\treturn;\n\t}\n\ttest_bus->dev.of_node = np;\n\n\t/*\n\t * Add a dummy resource to the test bus node after it is\n\t * registered to catch problems with un-inserted resources. The\n\t * DT code doesn't insert the resources, and it has caused the\n\t * kernel to oops in the past. This makes sure the same bug\n\t * doesn't crop up again.\n\t */\n\tplatform_device_add_resources(test_bus, &test_bus_res, 1);\n\n\tof_platform_populate(np, match, NULL, &test_bus->dev);\n\tfor_each_child_of_node(np, child) {\n\t\tfor_each_child_of_node(child, grandchild)\n\t\t\tunittest(of_find_device_by_node(grandchild),\n\t\t\t\t \"Could not create device for node '%pOFn'\\n\",\n\t\t\t\t grandchild);\n\t}\n\n\tof_platform_depopulate(&test_bus->dev);\n\tfor_each_child_of_node(np, child) {\n\t\tfor_each_child_of_node(child, grandchild)\n\t\t\tunittest(!of_find_device_by_node(grandchild),\n\t\t\t\t \"device didn't get destroyed '%pOFn'\\n\",\n\t\t\t\t grandchild);\n\t}\n\n\tplatform_device_unregister(test_bus);\n\tof_node_put(np);\n}\n\n/**\n *\tupdate_node_properties - adds the properties\n *\tof np into dup node (present in live tree) and\n *\tupdates parent of children of np to dup.\n *\n *\t@np:\tnode whose properties are being added to the live tree\n *\t@dup:\tnode present in live tree to be updated\n */\nstatic void update_node_properties(struct device_node *np,\n\t\t\t\t\tstruct device_node *dup)\n{\n\tstruct property *prop;\n\tstruct property *save_next;\n\tstruct device_node *child;\n\tint ret;\n\n\tfor_each_child_of_node(np, child)\n\t\tchild->parent = dup;\n\n\t/*\n\t * \"unittest internal error: unable to add testdata property\"\n\t *\n\t *    If this message reports a property in node '/__symbols__' then\n\t *    the respective unittest overlay contains a label that has the\n\t *    same name as a label in the live devicetree.  The label will\n\t *    be in the live devicetree only if the devicetree source was\n\t *    compiled with the '-@' option.  If you encounter this error,\n\t *    please consider renaming __all__ of the labels in the unittest\n\t *    overlay dts files with an odd prefix that is unlikely to be\n\t *    used in a real devicetree.\n\t */\n\n\t/*\n\t * open code for_each_property_of_node() because of_add_property()\n\t * sets prop->next to NULL\n\t */\n\tfor (prop = np->properties; prop != NULL; prop = save_next) {\n\t\tsave_next = prop->next;\n\t\tret = of_add_property(dup, prop);\n\t\tif (ret) {\n\t\t\tif (ret == -EEXIST && !strcmp(prop->name, \"name\"))\n\t\t\t\tcontinue;\n\t\t\tpr_err(\"unittest internal error: unable to add testdata property %pOF/%s\",\n\t\t\t       np, prop->name);\n\t\t}\n\t}\n}\n\n/**\n *\tattach_node_and_children - attaches nodes\n *\tand its children to live tree.\n *\tCAUTION: misleading function name - if node @np already exists in\n *\tthe live tree then children of @np are *not* attached to the live\n *\ttree.  This works for the current test devicetree nodes because such\n *\tnodes do not have child nodes.\n *\n *\t@np:\tNode to attach to live tree\n */\nstatic void attach_node_and_children(struct device_node *np)\n{\n\tstruct device_node *next, *dup, *child;\n\tunsigned long flags;\n\tconst char *full_name;\n\n\tfull_name = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\n\tif (!strcmp(full_name, \"/__local_fixups__\") ||\n\t    !strcmp(full_name, \"/__fixups__\"))\n\t\treturn;\n\n\tdup = of_find_node_by_path(full_name);\n\tkfree(full_name);\n\tif (dup) {\n\t\tupdate_node_properties(np, dup);\n\t\treturn;\n\t}\n\n\tchild = np->child;\n\tnp->child = NULL;\n\n\tmutex_lock(&of_mutex);\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tnp->sibling = np->parent->child;\n\tnp->parent->child = np;\n\tof_node_clear_flag(np, OF_DETACHED);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\t__of_attach_node_sysfs(np);\n\tmutex_unlock(&of_mutex);\n\n\twhile (child) {\n\t\tnext = child->sibling;\n\t\tattach_node_and_children(child);\n\t\tchild = next;\n\t}\n}\n\n/**\n *\tunittest_data_add - Reads, copies data from\n *\tlinked tree and attaches it to the live tree\n */\nstatic int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\t/*\n\t * __dtb_testcases_begin[] and __dtb_testcases_end[] are magically\n\t * created by cmd_dt_S_dtb in scripts/Makefile.lib\n\t */\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\n\t/* creating copy */\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\tkfree(unittest_data);\n\t\treturn -ENODATA;\n\t}\n\n\t/*\n\t * This lock normally encloses of_resolve_phandles()\n\t */\n\tof_overlay_mutex_lock();\n\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\n\t/* attach the sub-tree to live tree */\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\n\tof_overlay_mutex_unlock();\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF_OVERLAY\nstatic int __init overlay_data_apply(const char *overlay_name, int *overlay_id);\n\nstatic int unittest_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tif (np == NULL) {\n\t\tdev_err(dev, \"No OF data for device\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tof_platform_populate(np, NULL, NULL, &pdev->dev);\n\n\treturn 0;\n}\n\nstatic int unittest_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\treturn 0;\n}\n\nstatic const struct of_device_id unittest_match[] = {\n\t{ .compatible = \"unittest\", },\n\t{},\n};\n\nstatic struct platform_driver unittest_driver = {\n\t.probe\t\t\t= unittest_probe,\n\t.remove\t\t\t= unittest_remove,\n\t.driver = {\n\t\t.name\t\t= \"unittest\",\n\t\t.of_match_table\t= of_match_ptr(unittest_match),\n\t},\n};\n\n/* get the platform device instantiated at the path */\nstatic struct platform_device *of_path_to_platform_device(const char *path)\n{\n\tstruct device_node *np;\n\tstruct platform_device *pdev;\n\n\tnp = of_find_node_by_path(path);\n\tif (np == NULL)\n\t\treturn NULL;\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\n\treturn pdev;\n}\n\n/* find out if a platform device exists at that path */\nstatic int of_path_platform_device_exists(const char *path)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = of_path_to_platform_device(path);\n\tplatform_device_put(pdev);\n\treturn pdev != NULL;\n}\n\n#if IS_BUILTIN(CONFIG_I2C)\n\n/* get the i2c client device instantiated at the path */\nstatic struct i2c_client *of_path_to_i2c_client(const char *path)\n{\n\tstruct device_node *np;\n\tstruct i2c_client *client;\n\n\tnp = of_find_node_by_path(path);\n\tif (np == NULL)\n\t\treturn NULL;\n\n\tclient = of_find_i2c_device_by_node(np);\n\tof_node_put(np);\n\n\treturn client;\n}\n\n/* find out if a i2c client device exists at that path */\nstatic int of_path_i2c_client_exists(const char *path)\n{\n\tstruct i2c_client *client;\n\n\tclient = of_path_to_i2c_client(path);\n\tif (client)\n\t\tput_device(&client->dev);\n\treturn client != NULL;\n}\n#else\nstatic int of_path_i2c_client_exists(const char *path)\n{\n\treturn 0;\n}\n#endif\n\nenum overlay_type {\n\tPDEV_OVERLAY,\n\tI2C_OVERLAY\n};\n\nstatic int of_path_device_type_exists(const char *path,\n\t\tenum overlay_type ovtype)\n{\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\treturn of_path_platform_device_exists(path);\n\tcase I2C_OVERLAY:\n\t\treturn of_path_i2c_client_exists(path);\n\t}\n\treturn 0;\n}\n\nstatic const char *unittest_path(int nr, enum overlay_type ovtype)\n{\n\tconst char *base;\n\tstatic char buf[256];\n\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\tbase = \"/testcase-data/overlay-node/test-bus\";\n\t\tbreak;\n\tcase I2C_OVERLAY:\n\t\tbase = \"/testcase-data/overlay-node/test-bus/i2c-test-bus\";\n\t\tbreak;\n\tdefault:\n\t\tbuf[0] = '\\0';\n\t\treturn buf;\n\t}\n\tsnprintf(buf, sizeof(buf) - 1, \"%s/test-unittest%d\", base, nr);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\treturn buf;\n}\n\nstatic int of_unittest_device_exists(int unittest_nr, enum overlay_type ovtype)\n{\n\tconst char *path;\n\n\tpath = unittest_path(unittest_nr, ovtype);\n\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\treturn of_path_platform_device_exists(path);\n\tcase I2C_OVERLAY:\n\t\treturn of_path_i2c_client_exists(path);\n\t}\n\treturn 0;\n}\n\nstatic const char *overlay_name_from_nr(int nr)\n{\n\tstatic char buf[256];\n\n\tsnprintf(buf, sizeof(buf) - 1,\n\t\t\"overlay_%d\", nr);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\n\treturn buf;\n}\n\nstatic const char *bus_path = \"/testcase-data/overlay-node/test-bus\";\n\n/* it is guaranteed that overlay ids are assigned in sequence */\n#define MAX_UNITTEST_OVERLAYS\t256\nstatic unsigned long overlay_id_bits[BITS_TO_LONGS(MAX_UNITTEST_OVERLAYS)];\nstatic int overlay_first_id = -1;\n\nstatic void of_unittest_track_overlay(int id)\n{\n\tif (overlay_first_id < 0)\n\t\toverlay_first_id = id;\n\tid -= overlay_first_id;\n\n\t/* we shouldn't need that many */\n\tBUG_ON(id >= MAX_UNITTEST_OVERLAYS);\n\toverlay_id_bits[BIT_WORD(id)] |= BIT_MASK(id);\n}\n\nstatic void of_unittest_untrack_overlay(int id)\n{\n\tif (overlay_first_id < 0)\n\t\treturn;\n\tid -= overlay_first_id;\n\tBUG_ON(id >= MAX_UNITTEST_OVERLAYS);\n\toverlay_id_bits[BIT_WORD(id)] &= ~BIT_MASK(id);\n}\n\nstatic void of_unittest_destroy_tracked_overlays(void)\n{\n\tint id, ret, defers, ovcs_id;\n\n\tif (overlay_first_id < 0)\n\t\treturn;\n\n\t/* try until no defers */\n\tdo {\n\t\tdefers = 0;\n\t\t/* remove in reverse order */\n\t\tfor (id = MAX_UNITTEST_OVERLAYS - 1; id >= 0; id--) {\n\t\t\tif (!(overlay_id_bits[BIT_WORD(id)] & BIT_MASK(id)))\n\t\t\t\tcontinue;\n\n\t\t\tovcs_id = id + overlay_first_id;\n\t\t\tret = of_overlay_remove(&ovcs_id);\n\t\t\tif (ret == -ENODEV) {\n\t\t\t\tpr_warn(\"%s: no overlay to destroy for #%d\\n\",\n\t\t\t\t\t__func__, id + overlay_first_id);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret != 0) {\n\t\t\t\tdefers++;\n\t\t\t\tpr_warn(\"%s: overlay destroy failed for #%d\\n\",\n\t\t\t\t\t__func__, id + overlay_first_id);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toverlay_id_bits[BIT_WORD(id)] &= ~BIT_MASK(id);\n\t\t}\n\t} while (defers > 0);\n}\n\nstatic int __init of_unittest_apply_overlay(int overlay_nr, int *overlay_id)\n{\n\tconst char *overlay_name;\n\n\toverlay_name = overlay_name_from_nr(overlay_nr);\n\n\tif (!overlay_data_apply(overlay_name, overlay_id)) {\n\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\",\n\t\t\t\toverlay_name);\n\t\treturn -EFAULT;\n\t}\n\tof_unittest_track_overlay(*overlay_id);\n\n\treturn 0;\n}\n\n/* apply an overlay while checking before and after states */\nstatic int __init of_unittest_apply_overlay_check(int overlay_nr,\n\t\tint unittest_nr, int before, int after,\n\t\tenum overlay_type ovtype)\n{\n\tint ret, ovcs_id;\n\n\t/* unittest device must not be in before state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tovcs_id = 0;\n\tret = of_unittest_apply_overlay(overlay_nr, &ovcs_id);\n\tif (ret != 0) {\n\t\t/* of_unittest_apply_overlay already called unittest() */\n\t\treturn ret;\n\t}\n\n\t/* unittest device must be to set to after state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != after) {\n\t\tunittest(0, \"%s failed to create @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* apply an overlay and then revert it while checking before, after states */\nstatic int __init of_unittest_apply_revert_overlay_check(int overlay_nr,\n\t\tint unittest_nr, int before, int after,\n\t\tenum overlay_type ovtype)\n{\n\tint ret, ovcs_id;\n\n\t/* unittest device must be in before state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* apply the overlay */\n\tovcs_id = 0;\n\tret = of_unittest_apply_overlay(overlay_nr, &ovcs_id);\n\tif (ret != 0) {\n\t\t/* of_unittest_apply_overlay already called unittest() */\n\t\treturn ret;\n\t}\n\n\t/* unittest device must be in after state */\n\tif (of_unittest_device_exists(unittest_nr, ovtype) != after) {\n\t\tunittest(0, \"%s failed to create @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_overlay_remove(&ovcs_id);\n\tif (ret != 0) {\n\t\tunittest(0, \"%s failed to be destroyed @\\\"%s\\\"\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype));\n\t\treturn ret;\n\t}\n\n\t/* unittest device must be again in before state */\n\tif (of_unittest_device_exists(unittest_nr, PDEV_OVERLAY) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* test activation of device */\nstatic void __init of_unittest_overlay_0(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 0);\n}\n\n/* test deactivation of device */\nstatic void __init of_unittest_overlay_1(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(1, 1, 1, 0, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 1);\n}\n\n/* test activation of device */\nstatic void __init of_unittest_overlay_2(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(2, 2, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 2);\n}\n\n/* test deactivation of device */\nstatic void __init of_unittest_overlay_3(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(3, 3, 1, 0, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 3);\n}\n\n/* test activation of a full device node */\nstatic void __init of_unittest_overlay_4(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(4, 4, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 4);\n}\n\n/* test overlay apply/revert sequence */\nstatic void __init of_unittest_overlay_5(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_revert_overlay_check(5, 5, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 5);\n}\n\n/* test overlay application in sequence */\nstatic void __init of_unittest_overlay_6(void)\n{\n\tint i, ov_id[2], ovcs_id;\n\tint overlay_nr = 6, unittest_nr = 6;\n\tint before = 0, after = 1;\n\tconst char *overlay_name;\n\n\t/* unittest device must be in before state */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= before) {\n\t\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* apply the overlays */\n\tfor (i = 0; i < 2; i++) {\n\n\t\toverlay_name = overlay_name_from_nr(overlay_nr + i);\n\n\t\tif (!overlay_data_apply(overlay_name, &ovcs_id)) {\n\t\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name);\n\t\t\treturn;\n\t\t}\n\t\tov_id[i] = ovcs_id;\n\t\tof_unittest_track_overlay(ov_id[i]);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* unittest device must be in after state */\n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= after) {\n\t\t\tunittest(0, \"overlay @\\\"%s\\\" failed @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 1; i >= 0; i--) {\n\t\tovcs_id = ov_id[i];\n\t\tif (of_overlay_remove(&ovcs_id)) {\n\t\t\tunittest(0, \"%s failed destroy @\\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY));\n\t\t\treturn;\n\t\t}\n\t\tof_unittest_untrack_overlay(ov_id[i]);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* unittest device must be again in before state */\n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= before) {\n\t\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tunittest(1, \"overlay test %d passed\\n\", 6);\n}\n\n/* test overlay application in sequence */\nstatic void __init of_unittest_overlay_8(void)\n{\n\tint i, ov_id[2], ovcs_id;\n\tint overlay_nr = 8, unittest_nr = 8;\n\tconst char *overlay_name;\n\n\t/* we don't care about device state in this test */\n\n\t/* apply the overlays */\n\tfor (i = 0; i < 2; i++) {\n\n\t\toverlay_name = overlay_name_from_nr(overlay_nr + i);\n\n\t\tif (!overlay_data_apply(overlay_name, &ovcs_id)) {\n\t\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name);\n\t\t\treturn;\n\t\t}\n\t\tov_id[i] = ovcs_id;\n\t\tof_unittest_track_overlay(ov_id[i]);\n\t}\n\n\t/* now try to remove first overlay (it should fail) */\n\tovcs_id = ov_id[0];\n\tif (!of_overlay_remove(&ovcs_id)) {\n\t\tunittest(0, \"%s was destroyed @\\\"%s\\\"\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr + 0),\n\t\t\t\tunittest_path(unittest_nr,\n\t\t\t\t\tPDEV_OVERLAY));\n\t\treturn;\n\t}\n\n\t/* removing them in order should work */\n\tfor (i = 1; i >= 0; i--) {\n\t\tovcs_id = ov_id[i];\n\t\tif (of_overlay_remove(&ovcs_id)) {\n\t\t\tunittest(0, \"%s not destroyed @\\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr,\n\t\t\t\t\t\tPDEV_OVERLAY));\n\t\t\treturn;\n\t\t}\n\t\tof_unittest_untrack_overlay(ov_id[i]);\n\t}\n\n\tunittest(1, \"overlay test %d passed\\n\", 8);\n}\n\n/* test insertion of a bus with parent devices */\nstatic void __init of_unittest_overlay_10(void)\n{\n\tint ret;\n\tchar *child_path;\n\n\t/* device should disable */\n\tret = of_unittest_apply_overlay_check(10, 10, 0, 1, PDEV_OVERLAY);\n\tif (unittest(ret == 0,\n\t\t\t\"overlay test %d failed; overlay application\\n\", 10))\n\t\treturn;\n\n\tchild_path = kasprintf(GFP_KERNEL, \"%s/test-unittest101\",\n\t\t\tunittest_path(10, PDEV_OVERLAY));\n\tif (unittest(child_path, \"overlay test %d failed; kasprintf\\n\", 10))\n\t\treturn;\n\n\tret = of_path_device_type_exists(child_path, PDEV_OVERLAY);\n\tkfree(child_path);\n\n\tunittest(ret, \"overlay test %d failed; no child device\\n\", 10);\n}\n\n/* test insertion of a bus with parent devices (and revert) */\nstatic void __init of_unittest_overlay_11(void)\n{\n\tint ret;\n\n\t/* device should disable */\n\tret = of_unittest_apply_revert_overlay_check(11, 11, 0, 1,\n\t\t\tPDEV_OVERLAY);\n\tunittest(ret == 0, \"overlay test %d failed; overlay apply\\n\", 11);\n}\n\n#if IS_BUILTIN(CONFIG_I2C) && IS_ENABLED(CONFIG_OF_OVERLAY)\n\nstruct unittest_i2c_bus_data {\n\tstruct platform_device\t*pdev;\n\tstruct i2c_adapter\tadap;\n};\n\nstatic int unittest_i2c_master_xfer(struct i2c_adapter *adap,\n\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct unittest_i2c_bus_data *std = i2c_get_adapdata(adap);\n\n\t(void)std;\n\n\treturn num;\n}\n\nstatic u32 unittest_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm unittest_i2c_algo = {\n\t.master_xfer\t= unittest_i2c_master_xfer,\n\t.functionality\t= unittest_i2c_functionality,\n};\n\nstatic int unittest_i2c_bus_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct unittest_i2c_bus_data *std;\n\tstruct i2c_adapter *adap;\n\tint ret;\n\n\tif (np == NULL) {\n\t\tdev_err(dev, \"No OF data for device\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tstd = devm_kzalloc(dev, sizeof(*std), GFP_KERNEL);\n\tif (!std)\n\t\treturn -ENOMEM;\n\n\t/* link them together */\n\tstd->pdev = pdev;\n\tplatform_set_drvdata(pdev, std);\n\n\tadap = &std->adap;\n\ti2c_set_adapdata(adap, std);\n\tadap->nr = -1;\n\tstrlcpy(adap->name, pdev->name, sizeof(adap->name));\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tadap->algo = &unittest_i2c_algo;\n\tadap->dev.parent = dev;\n\tadap->dev.of_node = dev->of_node;\n\tadap->timeout = 5 * HZ;\n\tadap->retries = 3;\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to add I2C adapter\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int unittest_i2c_bus_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct unittest_i2c_bus_data *std = platform_get_drvdata(pdev);\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\ti2c_del_adapter(&std->adap);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id unittest_i2c_bus_match[] = {\n\t{ .compatible = \"unittest-i2c-bus\", },\n\t{},\n};\n\nstatic struct platform_driver unittest_i2c_bus_driver = {\n\t.probe\t\t\t= unittest_i2c_bus_probe,\n\t.remove\t\t\t= unittest_i2c_bus_remove,\n\t.driver = {\n\t\t.name\t\t= \"unittest-i2c-bus\",\n\t\t.of_match_table\t= of_match_ptr(unittest_i2c_bus_match),\n\t},\n};\n\nstatic int unittest_i2c_dev_probe(struct i2c_client *client,\n\t\tconst struct i2c_device_id *id)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\n\tif (!np) {\n\t\tdev_err(dev, \"No OF node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\treturn 0;\n};\n\nstatic int unittest_i2c_dev_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id unittest_i2c_dev_id[] = {\n\t{ .name = \"unittest-i2c-dev\" },\n\t{ }\n};\n\nstatic struct i2c_driver unittest_i2c_dev_driver = {\n\t.driver = {\n\t\t.name = \"unittest-i2c-dev\",\n\t},\n\t.probe = unittest_i2c_dev_probe,\n\t.remove = unittest_i2c_dev_remove,\n\t.id_table = unittest_i2c_dev_id,\n};\n\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\nstatic int unittest_i2c_mux_select_chan(struct i2c_mux_core *muxc, u32 chan)\n{\n\treturn 0;\n}\n\nstatic int unittest_i2c_mux_probe(struct i2c_client *client,\n\t\tconst struct i2c_device_id *id)\n{\n\tint i, nchans;\n\tstruct device *dev = &client->dev;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct device_node *np = client->dev.of_node, *child;\n\tstruct i2c_mux_core *muxc;\n\tu32 reg, max_reg;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tif (!np) {\n\t\tdev_err(dev, \"No OF node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax_reg = (u32)-1;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_read_u32(child, \"reg\", &reg))\n\t\t\tcontinue;\n\t\tif (max_reg == (u32)-1 || reg > max_reg)\n\t\t\tmax_reg = reg;\n\t}\n\tnchans = max_reg == (u32)-1 ? 0 : max_reg + 1;\n\tif (nchans == 0) {\n\t\tdev_err(dev, \"No channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmuxc = i2c_mux_alloc(adap, dev, nchans, 0, 0,\n\t\t\t     unittest_i2c_mux_select_chan, NULL);\n\tif (!muxc)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < nchans; i++) {\n\t\tif (i2c_mux_add_adapter(muxc, 0, i, 0)) {\n\t\t\tdev_err(dev, \"Failed to register mux #%d\\n\", i);\n\t\t\ti2c_mux_del_adapters(muxc);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, muxc);\n\n\treturn 0;\n};\n\nstatic int unittest_i2c_mux_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\ti2c_mux_del_adapters(muxc);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id unittest_i2c_mux_id[] = {\n\t{ .name = \"unittest-i2c-mux\" },\n\t{ }\n};\n\nstatic struct i2c_driver unittest_i2c_mux_driver = {\n\t.driver = {\n\t\t.name = \"unittest-i2c-mux\",\n\t},\n\t.probe = unittest_i2c_mux_probe,\n\t.remove = unittest_i2c_mux_remove,\n\t.id_table = unittest_i2c_mux_id,\n};\n\n#endif\n\nstatic int of_unittest_overlay_i2c_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&unittest_i2c_dev_driver);\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c device driver\\n\"))\n\t\treturn ret;\n\n\tret = platform_driver_register(&unittest_i2c_bus_driver);\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c bus driver\\n\"))\n\t\treturn ret;\n\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\tret = i2c_add_driver(&unittest_i2c_mux_driver);\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c mux driver\\n\"))\n\t\treturn ret;\n#endif\n\n\treturn 0;\n}\n\nstatic void of_unittest_overlay_i2c_cleanup(void)\n{\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\ti2c_del_driver(&unittest_i2c_mux_driver);\n#endif\n\tplatform_driver_unregister(&unittest_i2c_bus_driver);\n\ti2c_del_driver(&unittest_i2c_dev_driver);\n}\n\nstatic void __init of_unittest_overlay_i2c_12(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(12, 12, 0, 1, I2C_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 12);\n}\n\n/* test deactivation of device */\nstatic void __init of_unittest_overlay_i2c_13(void)\n{\n\t/* device should disable */\n\tif (of_unittest_apply_overlay_check(13, 13, 1, 0, I2C_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 13);\n}\n\n/* just check for i2c mux existence */\nstatic void of_unittest_overlay_i2c_14(void)\n{\n}\n\nstatic void __init of_unittest_overlay_i2c_15(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(15, 15, 0, 1, I2C_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 15);\n}\n\n#else\n\nstatic inline void of_unittest_overlay_i2c_14(void) { }\nstatic inline void of_unittest_overlay_i2c_15(void) { }\n\n#endif\n\nstatic void __init of_unittest_overlay(void)\n{\n\tstruct device_node *bus_np = NULL;\n\n\tif (platform_driver_register(&unittest_driver)) {\n\t\tunittest(0, \"could not register unittest driver\\n\");\n\t\tgoto out;\n\t}\n\n\tbus_np = of_find_node_by_path(bus_path);\n\tif (bus_np == NULL) {\n\t\tunittest(0, \"could not find bus_path \\\"%s\\\"\\n\", bus_path);\n\t\tgoto out;\n\t}\n\n\tif (of_platform_default_populate(bus_np, NULL, NULL)) {\n\t\tunittest(0, \"could not populate bus @ \\\"%s\\\"\\n\", bus_path);\n\t\tgoto out;\n\t}\n\n\tif (!of_unittest_device_exists(100, PDEV_OVERLAY)) {\n\t\tunittest(0, \"could not find unittest0 @ \\\"%s\\\"\\n\",\n\t\t\t\tunittest_path(100, PDEV_OVERLAY));\n\t\tgoto out;\n\t}\n\n\tif (of_unittest_device_exists(101, PDEV_OVERLAY)) {\n\t\tunittest(0, \"unittest1 @ \\\"%s\\\" should not exist\\n\",\n\t\t\t\tunittest_path(101, PDEV_OVERLAY));\n\t\tgoto out;\n\t}\n\n\tunittest(1, \"basic infrastructure of overlays passed\");\n\n\t/* tests in sequence */\n\tof_unittest_overlay_0();\n\tof_unittest_overlay_1();\n\tof_unittest_overlay_2();\n\tof_unittest_overlay_3();\n\tof_unittest_overlay_4();\n\tof_unittest_overlay_5();\n\tof_unittest_overlay_6();\n\tof_unittest_overlay_8();\n\n\tof_unittest_overlay_10();\n\tof_unittest_overlay_11();\n\n#if IS_BUILTIN(CONFIG_I2C)\n\tif (unittest(of_unittest_overlay_i2c_init() == 0, \"i2c init failed\\n\"))\n\t\tgoto out;\n\n\tof_unittest_overlay_i2c_12();\n\tof_unittest_overlay_i2c_13();\n\tof_unittest_overlay_i2c_14();\n\tof_unittest_overlay_i2c_15();\n\n\tof_unittest_overlay_i2c_cleanup();\n#endif\n\n\tof_unittest_destroy_tracked_overlays();\n\nout:\n\tof_node_put(bus_np);\n}\n\n#else\nstatic inline void __init of_unittest_overlay(void) { }\n#endif\n\n#ifdef CONFIG_OF_OVERLAY\n\n/*\n * __dtb_ot_begin[] and __dtb_ot_end[] are created by cmd_dt_S_dtb\n * in scripts/Makefile.lib\n */\n\n#define OVERLAY_INFO_EXTERN(name) \\\n\textern uint8_t __dtb_##name##_begin[]; \\\n\textern uint8_t __dtb_##name##_end[]\n\n#define OVERLAY_INFO(overlay_name, expected)             \\\n{\t.dtb_begin       = __dtb_##overlay_name##_begin, \\\n\t.dtb_end         = __dtb_##overlay_name##_end,   \\\n\t.expected_result = expected,                     \\\n\t.name            = #overlay_name,                \\\n}\n\nstruct overlay_info {\n\tuint8_t\t\t*dtb_begin;\n\tuint8_t\t\t*dtb_end;\n\tint\t\texpected_result;\n\tint\t\toverlay_id;\n\tchar\t\t*name;\n};\n\nOVERLAY_INFO_EXTERN(overlay_base);\nOVERLAY_INFO_EXTERN(overlay);\nOVERLAY_INFO_EXTERN(overlay_0);\nOVERLAY_INFO_EXTERN(overlay_1);\nOVERLAY_INFO_EXTERN(overlay_2);\nOVERLAY_INFO_EXTERN(overlay_3);\nOVERLAY_INFO_EXTERN(overlay_4);\nOVERLAY_INFO_EXTERN(overlay_5);\nOVERLAY_INFO_EXTERN(overlay_6);\nOVERLAY_INFO_EXTERN(overlay_7);\nOVERLAY_INFO_EXTERN(overlay_8);\nOVERLAY_INFO_EXTERN(overlay_9);\nOVERLAY_INFO_EXTERN(overlay_10);\nOVERLAY_INFO_EXTERN(overlay_11);\nOVERLAY_INFO_EXTERN(overlay_12);\nOVERLAY_INFO_EXTERN(overlay_13);\nOVERLAY_INFO_EXTERN(overlay_15);\nOVERLAY_INFO_EXTERN(overlay_bad_add_dup_node);\nOVERLAY_INFO_EXTERN(overlay_bad_add_dup_prop);\nOVERLAY_INFO_EXTERN(overlay_bad_phandle);\nOVERLAY_INFO_EXTERN(overlay_bad_symbol);\n\n/* entries found by name */\nstatic struct overlay_info overlays[] = {\n\tOVERLAY_INFO(overlay_base, -9999),\n\tOVERLAY_INFO(overlay, 0),\n\tOVERLAY_INFO(overlay_0, 0),\n\tOVERLAY_INFO(overlay_1, 0),\n\tOVERLAY_INFO(overlay_2, 0),\n\tOVERLAY_INFO(overlay_3, 0),\n\tOVERLAY_INFO(overlay_4, 0),\n\tOVERLAY_INFO(overlay_5, 0),\n\tOVERLAY_INFO(overlay_6, 0),\n\tOVERLAY_INFO(overlay_7, 0),\n\tOVERLAY_INFO(overlay_8, 0),\n\tOVERLAY_INFO(overlay_9, 0),\n\tOVERLAY_INFO(overlay_10, 0),\n\tOVERLAY_INFO(overlay_11, 0),\n\tOVERLAY_INFO(overlay_12, 0),\n\tOVERLAY_INFO(overlay_13, 0),\n\tOVERLAY_INFO(overlay_15, 0),\n\tOVERLAY_INFO(overlay_bad_add_dup_node, -EINVAL),\n\tOVERLAY_INFO(overlay_bad_add_dup_prop, -EINVAL),\n\tOVERLAY_INFO(overlay_bad_phandle, -EINVAL),\n\tOVERLAY_INFO(overlay_bad_symbol, -EINVAL),\n\t/* end marker */\n\t{.dtb_begin = NULL, .dtb_end = NULL, .expected_result = 0, .name = NULL}\n};\n\nstatic struct device_node *overlay_base_root;\n\nstatic void * __init dt_alloc_memory(u64 size, u64 align)\n{\n\tvoid *ptr = memblock_alloc(size, align);\n\n\tif (!ptr)\n\t\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx\\n\",\n\t\t      __func__, size, align);\n\n\treturn ptr;\n}\n\n/*\n * Create base device tree for the overlay unittest.\n *\n * This is called from very early boot code.\n *\n * Do as much as possible the same way as done in __unflatten_device_tree\n * and other early boot steps for the normal FDT so that the overlay base\n * unflattened tree will have the same characteristics as the real tree\n * (such as having memory allocated by the early allocator).  The goal\n * is to test \"the real thing\" as much as possible, and test \"test setup\n * code\" as little as possible.\n *\n * Have to stop before resolving phandles, because that uses kmalloc.\n */\nvoid __init unittest_unflatten_overlay_base(void)\n{\n\tstruct overlay_info *info;\n\tu32 data_size;\n\tvoid *new_fdt;\n\tu32 size;\n\tint found = 0;\n\tconst char *overlay_name = \"overlay_base\";\n\n\tfor (info = overlays; info && info->name; info++) {\n\t\tif (!strcmp(overlay_name, info->name)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\t\treturn;\n\t}\n\n\tinfo = &overlays[0];\n\n\tif (info->expected_result != -9999) {\n\t\tpr_err(\"No dtb 'overlay_base' to attach\\n\");\n\t\treturn;\n\t}\n\n\tdata_size = info->dtb_end - info->dtb_begin;\n\tif (!data_size) {\n\t\tpr_err(\"No dtb 'overlay_base' to attach\\n\");\n\t\treturn;\n\t}\n\n\tsize = fdt_totalsize(info->dtb_begin);\n\tif (size != data_size) {\n\t\tpr_err(\"dtb 'overlay_base' header totalsize != actual size\");\n\t\treturn;\n\t}\n\n\tnew_fdt = dt_alloc_memory(size, roundup_pow_of_two(FDT_V17_SIZE));\n\tif (!new_fdt) {\n\t\tpr_err(\"alloc for dtb 'overlay_base' failed\");\n\t\treturn;\n\t}\n\n\tmemcpy(new_fdt, info->dtb_begin, size);\n\n\t__unflatten_device_tree(new_fdt, NULL, &overlay_base_root,\n\t\t\t\tdt_alloc_memory, true);\n}\n\n/*\n * The purpose of of_unittest_overlay_data_add is to add an\n * overlay in the normal fashion.  This is a test of the whole\n * picture, instead of testing individual elements.\n *\n * A secondary purpose is to be able to verify that the contents of\n * /proc/device-tree/ contains the updated structure and values from\n * the overlay.  That must be verified separately in user space.\n *\n * Return 0 on unexpected error.\n */\nstatic int __init overlay_data_apply(const char *overlay_name, int *overlay_id)\n{\n\tstruct overlay_info *info;\n\tint found = 0;\n\tint ret;\n\tu32 size;\n\n\tfor (info = overlays; info && info->name; info++) {\n\t\tif (!strcmp(overlay_name, info->name)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\t\treturn 0;\n\t}\n\n\tsize = info->dtb_end - info->dtb_begin;\n\tif (!size)\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\n\tret = of_overlay_fdt_apply(info->dtb_begin, size, &info->overlay_id);\n\tif (overlay_id)\n\t\t*overlay_id = info->overlay_id;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpr_debug(\"%s applied\\n\", overlay_name);\n\nout:\n\tif (ret != info->expected_result)\n\t\tpr_err(\"of_overlay_fdt_apply() expected %d, ret=%d, %s\\n\",\n\t\t       info->expected_result, ret, overlay_name);\n\n\treturn (ret == info->expected_result);\n}\n\n/*\n * The purpose of of_unittest_overlay_high_level is to add an overlay\n * in the normal fashion.  This is a test of the whole picture,\n * instead of individual elements.\n *\n * The first part of the function is _not_ normal overlay usage; it is\n * finishing splicing the base overlay device tree into the live tree.\n */\nstatic __init void of_unittest_overlay_high_level(void)\n{\n\tstruct device_node *last_sibling;\n\tstruct device_node *np;\n\tstruct device_node *of_symbols;\n\tstruct device_node *overlay_base_symbols;\n\tstruct device_node **pprev;\n\tstruct property *prop;\n\n\tif (!overlay_base_root) {\n\t\tunittest(0, \"overlay_base_root not initialized\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Could not fixup phandles in unittest_unflatten_overlay_base()\n\t * because kmalloc() was not yet available.\n\t */\n\tof_overlay_mutex_lock();\n\tof_resolve_phandles(overlay_base_root);\n\tof_overlay_mutex_unlock();\n\n\n\t/*\n\t * do not allow overlay_base to duplicate any node already in\n\t * tree, this greatly simplifies the code\n\t */\n\n\t/*\n\t * remove overlay_base_root node \"__local_fixups\", after\n\t * being used by of_resolve_phandles()\n\t */\n\tpprev = &overlay_base_root->child;\n\tfor (np = overlay_base_root->child; np; np = np->sibling) {\n\t\tif (of_node_name_eq(np, \"__local_fixups__\")) {\n\t\t\t*pprev = np->sibling;\n\t\t\tbreak;\n\t\t}\n\t\tpprev = &np->sibling;\n\t}\n\n\t/* remove overlay_base_root node \"__symbols__\" if in live tree */\n\tof_symbols = of_get_child_by_name(of_root, \"__symbols__\");\n\tif (of_symbols) {\n\t\t/* will have to graft properties from node into live tree */\n\t\tpprev = &overlay_base_root->child;\n\t\tfor (np = overlay_base_root->child; np; np = np->sibling) {\n\t\t\tif (of_node_name_eq(np, \"__symbols__\")) {\n\t\t\t\toverlay_base_symbols = np;\n\t\t\t\t*pprev = np->sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpprev = &np->sibling;\n\t\t}\n\t}\n\n\tfor_each_child_of_node(overlay_base_root, np) {\n\t\tstruct device_node *base_child;\n\t\tfor_each_child_of_node(of_root, base_child) {\n\t\t\tif (!strcmp(np->full_name, base_child->full_name)) {\n\t\t\t\tunittest(0, \"illegal node name in overlay_base %pOFn\",\n\t\t\t\t\t np);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * overlay 'overlay_base' is not allowed to have root\n\t * properties, so only need to splice nodes into main device tree.\n\t *\n\t * root node of *overlay_base_root will not be freed, it is lost\n\t * memory.\n\t */\n\n\tfor (np = overlay_base_root->child; np; np = np->sibling)\n\t\tnp->parent = of_root;\n\n\tmutex_lock(&of_mutex);\n\n\tfor (last_sibling = np = of_root->child; np; np = np->sibling)\n\t\tlast_sibling = np;\n\n\tif (last_sibling)\n\t\tlast_sibling->sibling = overlay_base_root->child;\n\telse\n\t\tof_root->child = overlay_base_root->child;\n\n\tfor_each_of_allnodes_from(overlay_base_root, np)\n\t\t__of_attach_node_sysfs(np);\n\n\tif (of_symbols) {\n\t\tstruct property *new_prop;\n\t\tfor_each_property_of_node(overlay_base_symbols, prop) {\n\n\t\t\tnew_prop = __of_prop_dup(prop, GFP_KERNEL);\n\t\t\tif (!new_prop) {\n\t\t\t\tunittest(0, \"__of_prop_dup() of '%s' from overlay_base node __symbols__\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\tif (__of_add_property(of_symbols, new_prop)) {\n\t\t\t\t/* \"name\" auto-generated by unflatten */\n\t\t\t\tif (!strcmp(new_prop->name, \"name\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tunittest(0, \"duplicate property '%s' in overlay_base node __symbols__\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\tif (__of_add_property_sysfs(of_symbols, new_prop)) {\n\t\t\t\tunittest(0, \"unable to add property '%s' in overlay_base node __symbols__ to sysfs\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&of_mutex);\n\n\n\t/* now do the normal overlay usage test */\n\n\tunittest(overlay_data_apply(\"overlay\", NULL),\n\t\t \"Adding overlay 'overlay' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_add_dup_node\", NULL),\n\t\t \"Adding overlay 'overlay_bad_add_dup_node' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_add_dup_prop\", NULL),\n\t\t \"Adding overlay 'overlay_bad_add_dup_prop' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_phandle\", NULL),\n\t\t \"Adding overlay 'overlay_bad_phandle' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_symbol\", NULL),\n\t\t \"Adding overlay 'overlay_bad_symbol' failed\\n\");\n\n\treturn;\n\nerr_unlock:\n\tmutex_unlock(&of_mutex);\n}\n\n#else\n\nstatic inline __init void of_unittest_overlay_high_level(void) {}\n\n#endif\n\nstatic int __init of_unittest(void)\n{\n\tstruct device_node *np;\n\tint res;\n\n\t/* adding data for unittest */\n\n\tif (IS_ENABLED(CONFIG_UML))\n\t\tunittest_unflatten_overlay_base();\n\n\tres = unittest_data_add();\n\tif (res)\n\t\treturn res;\n\tif (!of_aliases)\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_info(\"No testcase data in device tree; not running tests\\n\");\n\t\treturn 0;\n\t}\n\tof_node_put(np);\n\n\tpr_info(\"start of unittest - you will see error messages\\n\");\n\tof_unittest_check_tree_linkage();\n\tof_unittest_check_phandles();\n\tof_unittest_find_node_by_name();\n\tof_unittest_dynamic();\n\tof_unittest_parse_phandle_with_args();\n\tof_unittest_parse_phandle_with_args_map();\n\tof_unittest_printf();\n\tof_unittest_property_string();\n\tof_unittest_property_copy();\n\tof_unittest_changeset();\n\tof_unittest_parse_interrupts();\n\tof_unittest_parse_interrupts_extended();\n\tof_unittest_match_node();\n\tof_unittest_platform_populate();\n\tof_unittest_overlay();\n\n\t/* Double check linkage after removing testcase data */\n\tof_unittest_check_tree_linkage();\n\n\tof_unittest_overlay_high_level();\n\n\tpr_info(\"end of unittest - %i passed, %i failed\\n\",\n\t\tunittest_results.passed, unittest_results.failed);\n\n\treturn 0;\n}\nlate_initcall(of_unittest);\n"], "filenames": ["drivers/of/unittest.c"], "buggy_code_start_loc": [1209], "buggy_code_end_loc": [1209], "fixing_code_start_loc": [1210], "fixing_code_end_loc": [1211], "type": "CWE-401", "message": "** DISPUTED ** A memory leak in the unittest_data_add() function in drivers/of/unittest.c in the Linux kernel before 5.3.10 allows attackers to cause a denial of service (memory consumption) by triggering of_fdt_unflatten_tree() failures, aka CID-e13de8fe0d6a. NOTE: third parties dispute the relevance of this because unittest.c can only be reached during boot.", "other": {"cve": {"id": "CVE-2019-19049", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.640", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A memory leak in the unittest_data_add() function in drivers/of/unittest.c in the Linux kernel before 5.3.10 allows attackers to cause a denial of service (memory consumption) by triggering of_fdt_unflatten_tree() failures, aka CID-e13de8fe0d6a. NOTE: third parties dispute the relevance of this because unittest.c can only be reached during boot."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n unittest_data_add() en el archivo drivers/of/unittest.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.10, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n de_fdt_unflatten_tree(), tambi\u00e9n se conoce como CID-e13de8fe0d6a."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.10", "matchCriteriaId": "F30BED58-4FF3-46D2-A535-AC5A126D67A3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org"}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1157173", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.10", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/e13de8fe0d6a51341671bbe384826d527afe8d44", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e13de8fe0d6a51341671bbe384826d527afe8d44"}}