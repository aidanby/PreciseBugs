{"buggy_code": ["<?php\n/**\n * Body file for extension WikiSEO.\n *\n * @file\n * @ingroup Extensions\n */\n\nclass WikiSEO{\n\n\t//array of valid parameter names\n\tprotected static \t$valid_params = array(\n\t\t'title',\n\t\t'title_mode', //append, prepend, replace\n\t\t'title_separator',\n\t\t'keywords',\n\t\t'description',\n\t\t'google-site-verification',\n\t\t'og:image',\n\t\t'article:author',\n\t\t'article:publisher',\n\t\t'og:type',\n\t\t'og:site_name',\n\t\t'og:locale',\n\t\t'article:tag',\n\t\t'article:section',\n\t\t'fb:admins',\n\t\t'fb:app_id',\n\t\t'twitter:card',\n\t\t'twitter:site',\n\t\t'twitter:domain',\n\t\t'twitter:creator',\n\t\t'twitter:image:src',\n\t\t'twitter:description'\n\t\t);\n\n\tprotected static $tag_types = array(\n\t\t'title' => 'title',\n\t\t'keywords' => 'meta',\n\t\t'description' => 'meta',\n\t\t'google-site-verification' => 'meta',\n\t\t'og:image' => 'property',\n\t\t'article:author' => 'property',\n\t\t'article:publisher' => 'property',\n\t\t'og:type' => 'property',\n\t\t'og:site_name' => 'property',\n\t\t'og:locale' => 'property',\n\t\t'article:tag' => 'property',\n\t\t'article:section' => 'property',\n\t\t'fb:admins' => 'property',\n\t\t'fb:app_id' => 'property',\n\t\t'twitter:card' => 'meta',\n\t\t'twitter:site' => 'meta',\n\t\t'twitter:domain' => 'meta',\n\t\t'twitter:creator' => 'meta',\n\t\t'twitter:image:src' => 'meta',\n\t\t'twitter:description' => 'meta'\n\t);\n\t//valid title modes\n\tprotected static \t$valid_title_modes = array('prepend', 'append', 'replace');\n\t//allow other parameter names... these will be converted internally\n\tprotected static \t$convert_params = array(\n\t\t'metakeywords'=>'keywords',\n\t\t'metak'=>'keywords',\n\t\t'metadescription'=>'description',\n\t\t'metad'=>'description',\n\t\t'titlemode'=>'title_mode',\n\t\t'title mode'=>'title_mode'\n\t);\n\t//parameters which should be parsed if possible to allow for the expansion of templates\n\tprotected static  $parse_params = array('title', 'description', 'keywords');\n\n\t//the value for the html title tag\n\tprotected static \t$title = '';\n\t//prepend, append or replace the new title to the existing title\n\tprotected static \t$title_mode = 'replace';\n\t//the separator to use when using append or prepend modes\n\tprotected static  $title_separator = ' - ';\n\n\t//array of meta name values\n\tprotected static \t$meta = array();\n\t//array of meta property values\n\tprotected static \t$property = array();\n\n\t//do not allow this class to be instantiated, it is static\n\tprivate function __construct(){ }\n\n\tpublic static function init(Parser $wgParser){\n\n\t\t$wgParser->setHook( 'seo', 'WikiSEO::parserTag' );\n\t\t$wgParser->setFunctionHook( 'seo', 'WikiSEO::parserFunction' );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Parse the values input from the <seo> tag extension\n\t * @param String $text The text content of the tag\n\t * @param Array $params The HTML attributes of the tag\n\t * @param Parser $parser The active Parser instance\n\t * @return String The HTML comments of cached attributes\n\t */\n\tpublic static function parserTag( $text, $params = array(), Parser $parser ) {\n\n\t\t$params = self::processParams($params, $parser);\n\n    //ensure at least one of the required parameters has been set, otherwise display an error\n\t\tif( empty($params) ){\n    \treturn '<div class=\"errorbox\">' . wfMsgForContent('seo-empty-attr') . '</div>';\n    }\n\n\t  //render the tags\n    $html = self::renderParamsAsHtmlComments( $params );\n\n    return $html;\n\n\t}\n\n\t/**\n\t * Parse the values input from the {{#seo}} parser function\n\t * @param Parser $parser The active Parser instance\n\t * @return Array Parser options and the HTML comments of cached attributes\n\t */\n\tpublic static function parserFunction(Parser $parser ){\n\t\t$args = func_get_args();\n\t\t$args = array_slice($args, 1, count($args) );\n\t\t$params = array();\n\t\tforeach($args as $a){\n\t\t\tif(strpos($a, '=')){\n\t\t\t\t$exploded = explode('=', $a);\n\t\t\t\t$params[trim($exploded[0])] = trim($exploded[1]);\n\t\t\t}\n\t\t}\n\n\t\t$params = self::processParams($params, $parser);\n\n\t\tif( empty($params) ){\n\t\t\treturn '<div class=\"errorbox\">' . wfMsgForContent('seo-empty-attr') . '</div>';\n\t\t}\n\n\n\t\t$html = self::renderParamsAsHtmlComments( $params );\n\n\t\treturn array( $html, 'noparse' => true, 'isHTML' => true );\n\t}\n\n\t/**\n\t * Processes params (assumed valid) and sets them as class properties\n\t * @param Array $params Array of pre-validated params\n\t * @param Parser $parser If passed, the parser will be used to recursively parse all params\n\t * @return Array An array of processed params\n\t */\n\tprotected static function processParams($params, $parser=null){\n\n\t\t//correct params for compatibility with \"HTML Meta and Title\" extension\n\t\tforeach(self::$convert_params as $from => $to){\n\t\t\tif( isset($params[$from]) ){\n\t\t\t\t$params[$to] = $params[$from];\n\t\t\t\tunset($params[$from]);\n\t\t\t}\n\t\t}\n\n\t\t$processed = array();\n\n\t\t//ensure only valid parameter names are processed\n\t\tforeach(self::$valid_params as $p){\n\t\t\tif( isset($params[$p]) ){\n\t\t\t\t//if the parser has been passed and the param is parsable parse it, else simply assign it\n\t\t\t\t$processed[$p] = ($parser && in_array($p, self::$parse_params)) ? $parser->recursiveTagParse($params[$p]) : $params[$p];\n\t\t\t}\n\t\t}\n\t\t//set the processed values as class properties\n\t\tforeach($processed as $k => $v){\n\t\t\tif( $k==='title' ){\n\t\t\t\tself::$title = $v;\n\t\t\t}\n\t\t\telse\n\t\t\tif( $k==='title_mode' && in_array($v, self::$valid_title_modes) ){\n\t\t\t\tself::$title_mode = $v;\n\t\t\t}\n\t\t\telse\n\t\t\tif( $k === 'title_separator'){\n\t\t\t\tself::$title_separator = ' '.$v.' ';\n\t\t\t}\n\t\t\telse\n\t\t\tif( isset(self::$tag_types[$k]) && self::$tag_types[$k]==='meta' ){\n\t\t\t\tself::$meta[$k] = $v;\n\t\t\t}\n\t\t\telse\n\t\t\tif( isset(self::$tag_types[$k]) && self::$tag_types[$k]==='property'){\n\t\t\t\tself::$property[$k] = $v;\n\t\t\t}\n\t\t}\n\n\t\treturn $processed;\n\t}\n\n\t/**\n\t * Renders the parameters as HTML comment tags in order to cache them in the Wiki text.\n\t *\n\t * When MediaWiki caches pages it does not cache the contents of the <head> tag, so\n\t * to propagate the information in cached pages, the information is stored\n\t * as HTML comments in the Wiki text.\n\t *\n\t * @param Array $params Array of params to render into HTML comments\n\t * @return String A HTML string of comments\n\t */\n\tprotected static function renderParamsAsHtmlComments( $params ){\n\t\t$html = '';\n\t\tforeach($params as $k => $v){\n\t\t\t$html .= '<!-- WikiSEO:'.$k.';'.base64_encode($v).' -->';\n\t\t}\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Convert the attributed cached as HTML comments back into an attribute array\n\t *\n\t * This method is called by the OutputPageBeforeHTML hook\n\t *\n\t * @param OutputPage $out\n\t * @param String $text\n\t */\n\tpublic static function loadParamsFromWikitext( $out, &$text ) {\n\n    # Extract meta keywords\n    if (!preg_match_all(\n        '/<!-- WikiSEO:([:a-zA-Z_-]+);([0-9a-zA-Z\\\\+\\\\/]+=*) -->\\n?/m',\n        $text,\n        $matches,\n        PREG_SET_ORDER)\n    ){\n    \treturn true;\n   \t}\n\n   \tforeach($matches as $match){\n   \t\t$params[$match[1]] = base64_decode($match[2]);\n   \t\t$text = str_replace($match[0], '', $text);\n   \t}\n   \tself::processParams($params);\n \t\treturn true;\n\t}\n\n\t/**\n\t * Modify the HTML to set the relevant tags to the specified values\n\t *\n\t * This method is called by the BeforePageDisplay hook\n\t *\n\t * @param OutputPage $out\n\t */\n\tpublic static function modifyHTML ( $out ) {\n\t\t//set title\n\t\tif(!empty(self::$title)){\n\t\t\tswitch(self::$title_mode){\n\t\t\t\tcase 'append':\n\t\t\t\t\t$title = $out->getPageTitle() . self::$title_separator . self::$title;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'prepend':\n\t\t\t\t\t$title = self::$title . self::$title_separator . $out->getPageTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'replace':\n\t\t\t\tdefault:\n\t\t\t\t\t$title = self::$title;\n\t\t\t}\n\t\t\t$out->setHTMLTitle($title);\n\t\t}\n\t\t//set meta tags\n\t\tif(!empty(self::$meta)){\n\t\t\tforeach(self::$meta as $name => $content){\n\t\t\t\tif ($name == 'description') {\n\t\t\t\t\t$out->addMeta( $name, $content );\n\t\t\t\t\t$out->addMeta( \"twitter:description\", $content );\n\t\t\t\t\t$out->addHeadItem(\"og:description\", \"<meta property=\\\"og:description\\\" content=\\\"$content\\\" />\" . \"\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$out->addMeta( $name, $content );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t//set property tags\n\t\tif(!empty(self::$property)){\n\t\t\tforeach(self::$property as $property => $content){\n\t\t\t\t$out->addHeadItem(\"$property\", \"<meta property=\\\"$property\\\" content=\\\"$content\\\" />\" . \"\\n\");\n\t\t\t}\n\t\t}\n\n\t  return true;\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * Body file for extension WikiSEO.\n *\n * @file\n * @ingroup Extensions\n */\n\nclass WikiSEO{\n\n\t//array of valid parameter names\n\tprotected static \t$valid_params = array(\n\t\t'title',\n\t\t'title_mode', //append, prepend, replace\n\t\t'title_separator',\n\t\t'keywords',\n\t\t'description',\n\t\t'google-site-verification',\n\t\t'og:image',\n\t\t'article:author',\n\t\t'article:publisher',\n\t\t'og:type',\n\t\t'og:site_name',\n\t\t'og:locale',\n\t\t'article:tag',\n\t\t'article:section',\n\t\t'fb:admins',\n\t\t'fb:app_id',\n\t\t'twitter:card',\n\t\t'twitter:site',\n\t\t'twitter:domain',\n\t\t'twitter:creator',\n\t\t'twitter:image:src',\n\t\t'twitter:description'\n\t\t);\n\n\tprotected static $tag_types = array(\n\t\t'title' => 'title',\n\t\t'keywords' => 'meta',\n\t\t'description' => 'meta',\n\t\t'google-site-verification' => 'meta',\n\t\t'og:image' => 'property',\n\t\t'article:author' => 'property',\n\t\t'article:publisher' => 'property',\n\t\t'og:type' => 'property',\n\t\t'og:site_name' => 'property',\n\t\t'og:locale' => 'property',\n\t\t'article:tag' => 'property',\n\t\t'article:section' => 'property',\n\t\t'fb:admins' => 'property',\n\t\t'fb:app_id' => 'property',\n\t\t'twitter:card' => 'meta',\n\t\t'twitter:site' => 'meta',\n\t\t'twitter:domain' => 'meta',\n\t\t'twitter:creator' => 'meta',\n\t\t'twitter:image:src' => 'meta',\n\t\t'twitter:description' => 'meta'\n\t);\n\t//valid title modes\n\tprotected static \t$valid_title_modes = array('prepend', 'append', 'replace');\n\t//allow other parameter names... these will be converted internally\n\tprotected static \t$convert_params = array(\n\t\t'metakeywords'=>'keywords',\n\t\t'metak'=>'keywords',\n\t\t'metadescription'=>'description',\n\t\t'metad'=>'description',\n\t\t'titlemode'=>'title_mode',\n\t\t'title mode'=>'title_mode'\n\t);\n\t//parameters which should be parsed if possible to allow for the expansion of templates\n\tprotected static  $parse_params = array('title', 'description', 'keywords');\n\n\t//the value for the html title tag\n\tprotected static \t$title = '';\n\t//prepend, append or replace the new title to the existing title\n\tprotected static \t$title_mode = 'replace';\n\t//the separator to use when using append or prepend modes\n\tprotected static  $title_separator = ' - ';\n\n\t//array of meta name values\n\tprotected static \t$meta = array();\n\t//array of meta property values\n\tprotected static \t$property = array();\n\n\t//do not allow this class to be instantiated, it is static\n\tprivate function __construct(){ }\n\n\tpublic static function init(Parser $wgParser){\n\n\t\t$wgParser->setHook( 'seo', 'WikiSEO::parserTag' );\n\t\t$wgParser->setFunctionHook( 'seo', 'WikiSEO::parserFunction' );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Parse the values input from the <seo> tag extension\n\t * @param String $text The text content of the tag\n\t * @param Array $params The HTML attributes of the tag\n\t * @param Parser $parser The active Parser instance\n\t * @return String The HTML comments of cached attributes\n\t */\n\tpublic static function parserTag( $text, $params = array(), Parser $parser ) {\n\n\t\t$params = self::processParams($params, $parser);\n\n    //ensure at least one of the required parameters has been set, otherwise display an error\n\t\tif( empty($params) ){\n    \treturn '<div class=\"errorbox\">' . wfMsgForContent('seo-empty-attr') . '</div>';\n    }\n\n\t  //render the tags\n    $html = self::renderParamsAsHtmlComments( $params );\n\n    return $html;\n\n\t}\n\n\t/**\n\t * Parse the values input from the {{#seo}} parser function\n\t * @param Parser $parser The active Parser instance\n\t * @return Array Parser options and the HTML comments of cached attributes\n\t */\n\tpublic static function parserFunction(Parser $parser ){\n\t\t$args = func_get_args();\n\t\t$args = array_slice($args, 1, count($args) );\n\t\t$params = array();\n\t\tforeach($args as $a){\n\t\t\tif(strpos($a, '=')){\n\t\t\t\t$exploded = explode('=', $a);\n\t\t\t\t$params[trim($exploded[0])] = trim($exploded[1]);\n\t\t\t}\n\t\t}\n\n\t\t$params = self::processParams($params, $parser);\n\n\t\tif( empty($params) ){\n\t\t\treturn '<div class=\"errorbox\">' . wfMsgForContent('seo-empty-attr') . '</div>';\n\t\t}\n\n\n\t\t$html = self::renderParamsAsHtmlComments( $params );\n\n\t\treturn array( $html, 'noparse' => true, 'isHTML' => true );\n\t}\n\n\t/**\n\t * Processes params (assumed valid) and sets them as class properties\n\t * @param Array $params Array of pre-validated params\n\t * @param Parser $parser If passed, the parser will be used to recursively parse all params\n\t * @return Array An array of processed params\n\t */\n\tprotected static function processParams($params, $parser=null){\n\n\t\t//correct params for compatibility with \"HTML Meta and Title\" extension\n\t\tforeach(self::$convert_params as $from => $to){\n\t\t\tif( isset($params[$from]) ){\n\t\t\t\t$params[$to] = $params[$from];\n\t\t\t\tunset($params[$from]);\n\t\t\t}\n\t\t}\n\n\t\t$processed = array();\n\n\t\t//ensure only valid parameter names are processed\n\t\tforeach(self::$valid_params as $p){\n\t\t\tif( isset($params[$p]) ){\n\t\t\t\t//if the parser has been passed and the param is parsable parse it, else simply assign it\n\t\t\t\t$processed[$p] = ($parser && in_array($p, self::$parse_params)) ? $parser->recursiveTagParse($params[$p]) : $params[$p];\n\t\t\t}\n\t\t}\n\t\t//set the processed values as class properties\n\t\tforeach($processed as $k => $v){\n\t\t\tif( $k==='title' ){\n\t\t\t\tself::$title = $v;\n\t\t\t}\n\t\t\telse\n\t\t\tif( $k==='title_mode' && in_array($v, self::$valid_title_modes) ){\n\t\t\t\tself::$title_mode = $v;\n\t\t\t}\n\t\t\telse\n\t\t\tif( $k === 'title_separator'){\n\t\t\t\tself::$title_separator = ' '.$v.' ';\n\t\t\t}\n\t\t\telse\n\t\t\tif( isset(self::$tag_types[$k]) && self::$tag_types[$k]==='meta' ){\n\t\t\t\tself::$meta[$k] = $v;\n\t\t\t}\n\t\t\telse\n\t\t\tif( isset(self::$tag_types[$k]) && self::$tag_types[$k]==='property'){\n\t\t\t\tself::$property[$k] = $v;\n\t\t\t}\n\t\t}\n\n\t\treturn $processed;\n\t}\n\n\t/**\n\t * Renders the parameters as HTML comment tags in order to cache them in the Wiki text.\n\t *\n\t * When MediaWiki caches pages it does not cache the contents of the <head> tag, so\n\t * to propagate the information in cached pages, the information is stored\n\t * as HTML comments in the Wiki text.\n\t *\n\t * @param Array $params Array of params to render into HTML comments\n\t * @return String A HTML string of comments\n\t */\n\tprotected static function renderParamsAsHtmlComments( $params ){\n\t\t$html = '';\n\t\tforeach($params as $k => $v){\n\t\t\t$html .= '<!-- WikiSEO:'.$k.';'.base64_encode($v).' -->';\n\t\t}\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Convert the attributed cached as HTML comments back into an attribute array\n\t *\n\t * This method is called by the OutputPageBeforeHTML hook\n\t *\n\t * @param OutputPage $out\n\t * @param String $text\n\t */\n\tpublic static function loadParamsFromWikitext( $out, &$text ) {\n\n    # Extract meta keywords\n    if (!preg_match_all(\n        '/<!-- WikiSEO:([:a-zA-Z_-]+);([0-9a-zA-Z\\\\+\\\\/]+=*) -->\\n?/m',\n        $text,\n        $matches,\n        PREG_SET_ORDER)\n    ){\n    \treturn true;\n   \t}\n\n   \tforeach($matches as $match){\n   \t\t$params[$match[1]] = base64_decode($match[2]);\n   \t\t$text = str_replace($match[0], '', $text);\n   \t}\n   \tself::processParams($params);\n \t\treturn true;\n\t}\n\n\t/**\n\t * Modify the HTML to set the relevant tags to the specified values\n\t *\n\t * This method is called by the BeforePageDisplay hook\n\t *\n\t * @param OutputPage $out\n\t */\n\tpublic static function modifyHTML ( $out ) {\n\t\t//set title\n\t\tif(!empty(self::$title)){\n\t\t\tswitch(self::$title_mode){\n\t\t\t\tcase 'append':\n\t\t\t\t\t$title = $out->getPageTitle() . self::$title_separator . self::$title;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'prepend':\n\t\t\t\t\t$title = self::$title . self::$title_separator . $out->getPageTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'replace':\n\t\t\t\tdefault:\n\t\t\t\t\t$title = self::$title;\n\t\t\t}\n\t\t\t$out->setHTMLTitle($title);\n\t\t}\n\t\t//set meta tags\n\t\tif(!empty(self::$meta)){\n\t\t\tforeach(self::$meta as $name => $content){\n\t\t\t\tif ($name == 'description') {\n\t\t\t\t\t$out->addMeta( $name, $content );\n\t\t\t\t\t$out->addMeta( \"twitter:description\", $content );\n\t\t\t\t\t$out->addHeadItem(\"og:description\", Html::element( 'meta', array( 'property' => 'og:description', 'content' => $content ) ) . \"\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$out->addMeta( $name, $content );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t//set property tags\n\t\tif(!empty(self::$property)){\n\t\t\tforeach(self::$property as $property => $content){\n\t\t\t\t$out->addHeadItem(\"$property\", Html::element( 'meta', array( 'property' => $property, 'content' => $content ) ) . \"\\n\");\n\t\t\t}\n\t\t}\n\n\t  return true;\n\t}\n}\n"], "filenames": ["WikiSEO.body.php"], "buggy_code_start_loc": [273], "buggy_code_end_loc": [285], "fixing_code_start_loc": [273], "fixing_code_end_loc": [285], "type": "CWE-79", "message": "A vulnerability, which was classified as problematic, was found in tinymighty WikiSEO 1.2.1. This affects the function modifyHTML of the file WikiSEO.body.php of the component Meta Property Tag Handler. The manipulation of the argument content leads to cross site scripting. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 1.2.2 is able to address this issue. The name of the patch is 089a5797be612b18a820f9f1e6593ad9a91b1dba. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220215.", "other": {"cve": {"id": "CVE-2015-10073", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-06T20:15:10.667", "lastModified": "2023-02-14T02:16:06.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in tinymighty WikiSEO 1.2.1. This affects the function modifyHTML of the file WikiSEO.body.php of the component Meta Property Tag Handler. The manipulation of the argument content leads to cross site scripting. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 1.2.2 is able to address this issue. The name of the patch is 089a5797be612b18a820f9f1e6593ad9a91b1dba. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220215."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tinymighty:wikiseo:1.2.1:*:*:*:*:mediawiki:*:*", "matchCriteriaId": "C63A9742-8A22-4EEA-8D62-E2DF95133C64"}]}]}], "references": [{"url": "https://github.com/tinymighty/wiki-seo/commit/089a5797be612b18a820f9f1e6593ad9a91b1dba", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/tinymighty/wiki-seo/pull/21", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/tinymighty/wiki-seo/releases/tag/1.2.2", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.220215", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.220215", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tinymighty/wiki-seo/commit/089a5797be612b18a820f9f1e6593ad9a91b1dba"}}