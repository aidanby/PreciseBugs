{"buggy_code": ["/*\n *          GPAC - Multimedia Framework C SDK\n *\n *          Copyright (c) by  Falco (Ivan Vecera) 2006\n *          Copyright (c) Jean Le Feuvre - Telecom ParisTech 2018_2020\n *                  All rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/list.h>\n#include <gpac/internal/vobsub.h>\n\ntypedef struct _tag_lang_type\n{\n\tchar id[3];\n\tchar lang[4];\n} lang_type;\n\nstatic lang_type lang_table[] =\n{\n\t{\"--\", \"und\" },\n\t{\"aa\", \"aar\" },\n\t{\"ab\", \"abk\" },\n\t{\"af\", \"afr\" },\n\t{\"am\", \"amh\" },\n\t{\"ar\", \"ara\" },\n\t{\"as\", \"ast\" },\n\t{\"ay\", \"aym\" },\n\t{\"az\", \"aze\" },\n\t{\"ba\", \"bak\" },\n\t{\"be\", \"bel\" },\n\t{\"bg\", \"bul\" },\n\t{\"bh\", \"bih\" },\n\t{\"bi\", \"bis\" },\n\t{\"bn\", \"ben\" },\n\t{\"bo\", \"bod\" }, // was \"tib\" (Tibetan)\n\t{\"br\", \"bre\" },\n\t{\"ca\", \"cat\" },\n\t{\"cc\", \"und\" },\n\t{\"co\", \"cos\" },\n\t{\"cs\", \"ces\" }, // was \"cze\" (Czech)\n\t{\"cy\", \"cym\" }, // was \"wel\" (Welsh)\n\t{\"da\", \"dan\" },\n\t{\"de\", \"deu\" }, // was \"ger\" (German)\n\t{\"dz\", \"dzo\" },\n\t{\"el\", \"ell\" }, // was \"gre\" (Greek, Modern (1453-))\n\t{\"en\", \"eng\" },\n\t{\"eo\", \"epo\" },\n\t{\"es\", \"spa\" },\n\t{\"et\", \"est\" },\n\t{\"eu\", \"eus\" }, // was \"baq\" (Basque)\n\t{\"fa\", \"fas\" }, // was \"per\" (Persian)\n\t{\"fi\", \"fin\" },\n\t{\"fj\", \"fij\" },\n\t{\"fo\", \"fao\" },\n\t{\"fr\", \"fra\" }, // was \"fre\" (French)\n\t{\"fy\", \"fry\" },\n\t{\"ga\", \"gle\" },\n\t{\"gl\", \"glg\" },\n\t{\"gn\", \"grn\" },\n\t{\"gu\", \"guj\" },\n\t{\"ha\", \"hau\" },\n\t{\"he\", \"heb\" },\n\t{\"hi\", \"hin\" },\n\t{\"hr\", \"scr\" },\n\t{\"hu\", \"hun\" },\n\t{\"hy\", \"hye\" }, // was \"arm\" (Armenian)\n\t{\"ia\", \"ina\" },\n\t{\"id\", \"ind\" },\n\t{\"ik\", \"ipk\" },\n\t{\"is\", \"isl\" }, // was \"ice\" (Icelandic)\n\t{\"it\", \"ita\" },\n\t{\"iu\", \"iku\" },\n\t{\"ja\", \"jpn\" },\n\t{\"jv\", \"jav\" },\n\t{\"ka\", \"kat\" }, // was \"geo\" (Georgian)\n\t{\"kk\", \"kaz\" },\n\t{\"kl\", \"kal\" },\n\t{\"km\", \"khm\" },\n\t{\"kn\", \"kan\" },\n\t{\"ko\", \"kor\" },\n\t{\"ks\", \"kas\" },\n\t{\"ku\", \"kur\" },\n\t{\"ky\", \"kir\" },\n\t{\"la\", \"lat\" },\n\t{\"ln\", \"lin\" },\n\t{\"lo\", \"lao\" },\n\t{\"lt\", \"lit\" },\n\t{\"lv\", \"lav\" },\n\t{\"mg\", \"mlg\" },\n\t{\"mi\", \"mri\" }, // was \"mao\" (Maori)\n\t{\"mk\", \"mkd\" }, // was \"mac\" (Macedonian)\n\t{\"ml\", \"mlt\" },\n\t{\"mn\", \"mon\" },\n\t{\"mo\", \"mol\" },\n\t{\"mr\", \"mar\" },\n\t{\"ms\", \"msa\" }, // was \"may\" (Malay)\n\t{\"my\", \"mya\" }, // was \"bur\" (Burmese)\n\t{\"na\", \"nau\" },\n\t{\"ne\", \"nep\" },\n\t{\"nl\", \"nld\" }, // was \"dut\" (Dutch; Flemish)\n\t{\"no\", \"nor\" },\n\t{\"oc\", \"oci\" },\n\t{\"om\", \"orm\" },\n\t{\"or\", \"ori\" },\n\t{\"pa\", \"pan\" },\n\t{\"pl\", \"pol\" },\n\t{\"ps\", \"pus\" },\n\t{\"pt\", \"por\" },\n\t{\"qu\", \"que\" },\n\t{\"rm\", \"roh\" },\n\t{\"rn\", \"run\" },\n\t{\"ro\", \"ron\" }, // was \"rum\" (Romanian; Moldavian; Moldovan)\n\t{\"ru\", \"rus\" },\n\t{\"rw\", \"kin\" },\n\t{\"sa\", \"san\" },\n\t{\"sd\", \"snd\" },\n\t{\"sg\", \"sag\" },\n\t{\"sh\", \"scr\" },\n\t{\"si\", \"sin\" },\n\t{\"sk\", \"slk\" }, // was \"slo\" (Slovak)\n\t{\"sl\", \"slv\" },\n\t{\"sm\", \"smo\" },\n\t{\"sn\", \"sna\" },\n\t{\"so\", \"som\" },\n\t{\"sq\", \"sqi\" }, // was \"alb\" (Albanian)\n\t{\"sr\", \"srp\" },\n\t{\"ss\", \"ssw\" },\n\t{\"st\", \"sot\" },\n\t{\"su\", \"sun\" },\n\t{\"sv\", \"swe\" },\n\t{\"sw\", \"swa\" },\n\t{\"ta\", \"tam\" },\n\t{\"te\", \"tel\" },\n\t{\"tg\", \"tgk\" },\n\t{\"th\", \"tha\" },\n\t{\"ti\", \"tir\" },\n\t{\"tk\", \"tuk\" },\n\t{\"tl\", \"tgl\" },\n\t{\"tn\", \"tsn\" },\n\t{\"to\", \"tog\" },\n\t{\"tr\", \"tur\" },\n\t{\"ts\", \"tso\" },\n\t{\"tt\", \"tat\" },\n\t{\"tw\", \"twi\" },\n\t{\"ug\", \"uig\" },\n\t{\"uk\", \"ukr\" },\n\t{\"ur\", \"urd\" },\n\t{\"uz\", \"uzb\" },\n\t{\"vi\", \"vie\" },\n\t{\"vo\", \"vol\" },\n\t{\"wo\", \"wol\" },\n\t{\"xh\", \"xho\" },\n\t{\"yi\", \"yid\" },\n\t{\"yo\", \"yor\" },\n\t{\"za\", \"zha\" },\n\t{\"zh\", \"zho\" }, // was \"chi\" (Chinese)\n\t{\"zu\", \"zul\" }\n};\n\n\n\ns32 vobsub_lang_name(u16 id)\n{\n\tu16 lang_id;\n\ts32 i, count;\n\n\tcount = (sizeof(lang_table) / sizeof(lang_table[0]));\n\n\tfor (i = 0; i < count; i++) {\n\t\tlang_id = (lang_table[i].id[0]<<8) | lang_table[i].id[1];\n\n\t\tif (id == lang_id) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn 0; /* Undefined - und */\n}\n\nchar *vobsub_lang_id(char *name)\n{\n\ts32 i, count;\n\n\tcount = (sizeof(lang_table) / sizeof(lang_table[0]));\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!stricmp(lang_table[i].lang, name)) {\n\t\t\treturn lang_table[i].id;\n\t\t}\n\t}\n\n\treturn \"--\"; /* Undefined */\n}\n\nstatic char *strltrim(char *str)\n{\n\tif (str == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (*str) {\n\t\tif (!isspace(*str)) {\n\t\t\treturn str;\n\t\t}\n\t\tstr++;\n\t}\n\n\treturn str;\n}\n\nstatic char *strrtrim(char *str)\n{\n\tchar *end;\n\n\tif (str == NULL) {\n\t\treturn NULL;\n\t}\n\n\tend = str + strlen(str);\n\n\twhile (end-- > str) {\n\t\tif (!isspace(*end)) {\n\t\t\treturn str;\n\t\t}\n\t\t*end = '\\0';\n\t}\n\n\treturn str;\n}\n\nstatic char *strtrim(char *str)\n{\n\treturn strltrim(strrtrim(str));\n}\n\nGF_Err vobsub_read_idx(FILE *file, vobsub_file *vobsub, s32 *version)\n{\n\tchar  strbuf[256];\n\tchar *str, *pos, *entry;\n\ts32   line, id =-1, delay = 0;\n\tBool  error = 0;\n\n\tfor (line = 0; !error && gf_fgets(strbuf, sizeof(strbuf), file); line++)\n\t{\n\t\tstr = strtrim(strbuf);\n\n\t\tif (line == 0)\n\t\t{\n\t\t\tchar *buf = \"VobSub index file, v\";\n\n\t\t\tpos = strstr(str, buf);\n\t\t\tif (pos == NULL || sscanf(pos + strlen(buf), \"%d\", version) != 1 || *version > VOBSUBIDXVER)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (strlen(str) == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse if (str[0] == '#')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tpos = strchr(str, ':');\n\t\tif (pos == NULL || pos == str)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = str;\n\t\t*pos  = '\\0';\n\n\t\tstr = strtrim(pos + 1);\n\t\tif (strlen(str) == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stricmp(entry, \"size\") == 0)\n\t\t{\n\t\t\ts32 w, h;\n\t\t\tif (sscanf(str, \"%dx%d\", &w, &h) != 2)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\tvobsub->width  = w;\n\t\t\tvobsub->height = h;\n\t\t}\n\t\telse if (stricmp(entry, \"palette\") == 0)\n\t\t{\n\t\t\ts32 c;\n\t\t\tu8  palette[16][4];\n\n\t\t\tif (sscanf(str, \"%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\",\n\t\t\t           (u32 *) &palette[0], (u32 *) &palette[1], (u32 *) &palette[2], (u32 *) &palette[3],\n\t\t\t           (u32 *) &palette[4], (u32 *) &palette[5], (u32 *) &palette[6], (u32 *) &palette[7],\n\t\t\t           (u32 *) &palette[8], (u32 *) &palette[9], (u32 *) &palette[10], (u32 *) &palette[11],\n\t\t\t           (u32 *) &palette[12],(u32 *) &palette[13],(u32 *) &palette[14], (u32 *) &palette[15]) != 16)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (c = 0; c < 16; c++)\n\t\t\t{\n\t\t\t\tu8 r, g, b;\n\n\t\t\t\tr = palette[c][2];\n\t\t\t\tg = palette[c][1];\n\t\t\t\tb = palette[c][0];\n\t\t\t\tvobsub->palette[c][0] = 0;\n\t\t\t\tvobsub->palette[c][1] = (( 66 * r + 129 * g +  25 * b + 128 +  4096) >> 8) & 0xff;\n\t\t\t\tvobsub->palette[c][2] = ((112 * r -  94 * g -  18 * b + 128 + 32768) >> 8) & 0xff;\n\t\t\t\tvobsub->palette[c][3] = ((-38 * r -  74 * g + 112 * b + 128 + 32768) >> 8) & 0xff;\n\t\t\t}\n\t\t}\n\t\telse if (stricmp(entry, \"id\") == 0)\n\t\t{\n\t\t\tchar *buf = \"index:\";\n\t\t\ts32   lang_id;\n\n\t\t\tstrlwr(str);\n\t\t\tlang_id = ((str[0] & 0xff) << 8) | (str[1] & 0xff);\n\n\t\t\tpos = strstr(str, buf);\n\t\t\tif (pos == NULL)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sscanf(pos + strlen(buf), \"%d\", &id) != 1 || id < 0 || id >= 32)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvobsub->langs[id].id   = lang_id;\n\t\t\tvobsub->langs[id].name = lang_table[vobsub_lang_name((u16)lang_id)].lang;\n\t\t\tvobsub->langs[id].idx = id;\n\n\t\t\tvobsub->langs[id].subpos = gf_list_new();\n\t\t\tif (vobsub->langs[id].subpos == NULL)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdelay = 0;\n\t\t\tvobsub->num_langs++;\n\t\t}\n\t\telse if (id >= 0 && stricmp(entry, \"delay\") == 0)\n\t\t{\n\t\t\ts32  hh, mm, ss, ms;\n\t\t\tchar c;\n\t\t\ts32  sign = (str[0] == '-') ? -1 : 1;\n\n\t\t\tpos = str;\n\t\t\twhile (*pos == '-' || *pos == '+') pos++;\n\n\t\t\tif (sscanf(pos, \"%d%c%d%c%d%c%d\", &hh, &c, &mm, &c, &ss, &c, &ms) != 7)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdelay += (hh*60*60*1000 + mm*60*1000 + ss*1000 + ms) * sign;\n\t\t}\n\t\telse if (id >= 0 && stricmp(entry, \"timestamp\") == 0)\n\t\t{\n\t\t\tvobsub_pos *vspos;\n\t\t\ts32         sign;\n\t\t\tchar        c;\n\t\t\ts32         hh, mm, ss, ms;\n\t\t\tchar       *buf = \"filepos:\";\n\n\t\t\tvspos = (vobsub_pos*)gf_calloc(1, sizeof(vobsub_pos));\n\t\t\tif (vspos == NULL) {\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsign = (str[0] == '-') ? -1 : 1;\n\t\t\twhile (*str == '-' || *str == '+') str++;\n\n\t\t\tif (sscanf(str, \"%d%c%d%c%d%c%d\", &hh, &c, &mm, &c, &ss, &c, &ms) != 7)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvspos->start = (((hh*60 + mm)*60 + ss)*1000 + ms) * sign + delay;\n\n\t\t\tpos = strstr(str, buf);\n\t\t\tif (pos == NULL)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sscanf(pos + strlen(buf), LLX, &vspos->filepos) != 1)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (delay < 0 && gf_list_count(vobsub->langs[id].subpos) > 0)\n\t\t\t{\n\t\t\t\tvobsub_pos *vspos_next;\n\n\t\t\t\tvspos_next = (vobsub_pos*)gf_list_get(vobsub->langs[id].subpos, gf_list_count(vobsub->langs[id].subpos) - 1);\n\t\t\t\tif (vspos->start < vspos_next->start)\n\t\t\t\t{\n\t\t\t\t\tdelay += (s32)(vspos_next->start - vspos->start);\n\t\t\t\t\tvspos->start = vspos_next->start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gf_list_add(vobsub->langs[id].subpos, vspos) != GF_OK)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn error ? GF_CORRUPTED_DATA : GF_OK;\n}\n\nvoid vobsub_free(vobsub_file *vobsub)\n{\n\ts32 i;\n\n\tif (vobsub == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (vobsub->langs[i].subpos) {\n\t\t\tGF_List *list = vobsub->langs[i].subpos;\n\t\t\tvobsub_pos *vspos;\n\t\t\tu32 pos = 0;\n\n\t\t\tdo {\n\t\t\t\tvspos = (vobsub_pos*)gf_list_enum(list, &pos);\n\t\t\t\tgf_free(vspos);\n\t\t\t}\n\t\t\twhile (vspos != NULL);\n\n\t\t\tgf_list_del(list);\n\t\t}\n\t}\n\tgf_free(vobsub);\n}\n\nGF_Err vobsub_get_subpic_duration(u8 *_data, u32 psize, u32 dsize, u32 *duration)\n{\n\tu32 i, dcsq_stm, nxt_dcsq, start_stm, stop_stm;\n\tu8 *data = (u8 *)_data;\n\tstart_stm = 0;\n\tstop_stm  = 0;\n\tnxt_dcsq  = dsize;\n\n\tif (psize) do {\n\t\ti = nxt_dcsq;\n\t\tdcsq_stm = (data[i+0] << 8) | data[i+1];\n\t\tnxt_dcsq = (data[i+2] << 8) | data[i+3];\n\t\ti += 4;\n\n\t\tif (nxt_dcsq > psize || nxt_dcsq < dsize) {\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tu8  cmd;\n\t\t\tint len;\n\n\t\t\tcmd = data[i++];\n\t\t\tswitch (cmd)\n\t\t\t{\n\t\t\tcase 0x00:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x02:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tlen = 2;\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\t\tlen = 2;\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tlen = 6;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tlen = 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i + len > psize) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\n\t\t\ti += len;\n\n\t\t\tif (cmd == 0x00 || cmd == 0x01) {\n\t\t\t\t/* start normal or forced displaying */\n\t\t\t\tstart_stm = dcsq_stm * 1024;\n\t\t\t} else if (cmd == 0x02) {\n\t\t\t\t/* stop displaying */\n\t\t\t\tstop_stm = dcsq_stm * 1024;\n\t\t\t} else if (cmd > 0x06) {\n\t\t\t\t/* unknown command or end of control block */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (i <= nxt_dcsq && i < psize);\n\n\t*duration = stop_stm - start_stm;\n\n\treturn GF_OK;\n}\n\nGF_Err vobsub_packetize_subpicture(FILE *fsub, u64 pts, u8 *data, u32 dataSize)\n{\n\tu8\tbuf[0x800], ptsbuf[5];\n\tint\tput_pts = 1;\n\n\t/* Build PTS buffer */\n\tptsbuf[0] = (u8)(((pts >> 29) & 0x0e) | 0x21);\n\tptsbuf[1] = (u8)(((pts >> 22) & 0xff));\n\tptsbuf[2] = (u8)(((pts >> 14) & 0xfe) | 0x01);\n\tptsbuf[3] = (u8)(((pts >>  7) & 0xff));\n\tptsbuf[4] = (u8)(((pts <<  1) & 0xfe) | 0x01);\n\n\twhile (dataSize > 0) {\n\t\tu8\t*p;\n\t\tu32 padLen = 0;\n\t\tu32 dataLen = sizeof(buf);\n\t\tu32 packLen;\n\n\t\t/* Zerofill packet */\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tp = buf;\n\n\t\t/* Put pack header */\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x01;\n\t\t*p++ = 0xba;\n\t\t*p++ = 0x40;\n\n\t\t/* Jump to PES header */\n\t\tp += 9;\n\n\t\t/* Put PES header */\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x01;\n\t\t*p++ = 0xbd;\n\n\t\t/* Compute max size of content */\n\t\tdataLen -= 14; /* Pack header */\n\t\tdataLen -=  4; /* Start code + Stream ID */\n\t\tdataLen -=  2; /* PES packet size */\n\t\tdataLen -=  3; /* PES header extension */\n\t\tdataLen -= put_pts ? 5 : 0; /* PTS */\n\t\tdataLen -=  1; /* Substream ID */\n\n\t\t/* Check if the subpicture data fits in packet */\n\t\tif (dataSize <= dataLen) {\n\t\t\tpadLen  = dataLen - dataSize;\n\t\t\tdataLen = dataSize;\n\t\t}\n\n\t\t/* Compute and put packet size (PES header extension + PTS + Substream ID + data + padding) */\n\t\tpackLen = 3 + (put_pts ? 5 : 0) + 1 + dataLen + ((padLen < 6) ? padLen : 0);\n\t\t*p++ = (packLen >> 8) & 0xff;\n\t\t*p++ = packLen & 0xff;\n\n\t\t/* Put PES header extension */\n\t\t*p++ = 0x80;\n\t\t*p++ = put_pts ? 0x80 : 0x00;\n\t\t*p++ = (put_pts ? 5 : 0) + ((padLen < 6) ? padLen : 0);\n\n\t\t/* Put PTS */\n\t\tif (put_pts) {\n\t\t\t*p++ = ptsbuf[0];\n\t\t\t*p++ = ptsbuf[1];\n\t\t\t*p++ = ptsbuf[2];\n\t\t\t*p++ = ptsbuf[3];\n\t\t\t*p++ = ptsbuf[4];\n\t\t}\n\n\t\t/* Skip padding bytes */\n\t\tif (padLen < 6) {\n\t\t\tp += padLen;\n\t\t}\n\n\t\t/* Put Substream ID */\n\t\t*p++ = 0x20;\n\n\t\t/* Copy data into packet buffer */\n\t\tmemcpy(p, data, dataLen);\n\t\tp += dataLen;\n\n\t\t/* Put padding bytes if padding len >= 6 */\n\t\tif (padLen >= 6) {\n\t\t\tpadLen -= 6;\n\t\t\t*p++ = 0x00;\n\t\t\t*p++ = 0x00;\n\t\t\t*p++ = 0x01;\n\t\t\t*p++ = 0xbe;\n\t\t\t*p++ = (padLen >> 8) & 0xff;\n\t\t\t*p++ = padLen & 0xff;\n\t\t\tmemset(p, 0, padLen);\n\t\t}\n\n\t\t/* Write packet into file */\n\t\tif (gf_fwrite(buf, sizeof(buf), fsub) != sizeof(buf)) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\n\t\t/* Move data pointer... */\n\t\tdata += dataLen;\n\t\tdataSize -= dataLen;\n\n\t\t/* Next packet (if any) will not contain PTS */\n\t\tput_pts = 0;\n\t}\n\n\treturn GF_OK;\n}\n"], "fixing_code": ["/*\n *          GPAC - Multimedia Framework C SDK\n *\n *          Copyright (c) by  Falco (Ivan Vecera) 2006\n *          Copyright (c) Jean Le Feuvre - Telecom ParisTech 2018_2020\n *                  All rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/list.h>\n#include <gpac/internal/vobsub.h>\n\ntypedef struct _tag_lang_type\n{\n\tchar id[3];\n\tchar lang[4];\n} lang_type;\n\nstatic lang_type lang_table[] =\n{\n\t{\"--\", \"und\" },\n\t{\"aa\", \"aar\" },\n\t{\"ab\", \"abk\" },\n\t{\"af\", \"afr\" },\n\t{\"am\", \"amh\" },\n\t{\"ar\", \"ara\" },\n\t{\"as\", \"ast\" },\n\t{\"ay\", \"aym\" },\n\t{\"az\", \"aze\" },\n\t{\"ba\", \"bak\" },\n\t{\"be\", \"bel\" },\n\t{\"bg\", \"bul\" },\n\t{\"bh\", \"bih\" },\n\t{\"bi\", \"bis\" },\n\t{\"bn\", \"ben\" },\n\t{\"bo\", \"bod\" }, // was \"tib\" (Tibetan)\n\t{\"br\", \"bre\" },\n\t{\"ca\", \"cat\" },\n\t{\"cc\", \"und\" },\n\t{\"co\", \"cos\" },\n\t{\"cs\", \"ces\" }, // was \"cze\" (Czech)\n\t{\"cy\", \"cym\" }, // was \"wel\" (Welsh)\n\t{\"da\", \"dan\" },\n\t{\"de\", \"deu\" }, // was \"ger\" (German)\n\t{\"dz\", \"dzo\" },\n\t{\"el\", \"ell\" }, // was \"gre\" (Greek, Modern (1453-))\n\t{\"en\", \"eng\" },\n\t{\"eo\", \"epo\" },\n\t{\"es\", \"spa\" },\n\t{\"et\", \"est\" },\n\t{\"eu\", \"eus\" }, // was \"baq\" (Basque)\n\t{\"fa\", \"fas\" }, // was \"per\" (Persian)\n\t{\"fi\", \"fin\" },\n\t{\"fj\", \"fij\" },\n\t{\"fo\", \"fao\" },\n\t{\"fr\", \"fra\" }, // was \"fre\" (French)\n\t{\"fy\", \"fry\" },\n\t{\"ga\", \"gle\" },\n\t{\"gl\", \"glg\" },\n\t{\"gn\", \"grn\" },\n\t{\"gu\", \"guj\" },\n\t{\"ha\", \"hau\" },\n\t{\"he\", \"heb\" },\n\t{\"hi\", \"hin\" },\n\t{\"hr\", \"scr\" },\n\t{\"hu\", \"hun\" },\n\t{\"hy\", \"hye\" }, // was \"arm\" (Armenian)\n\t{\"ia\", \"ina\" },\n\t{\"id\", \"ind\" },\n\t{\"ik\", \"ipk\" },\n\t{\"is\", \"isl\" }, // was \"ice\" (Icelandic)\n\t{\"it\", \"ita\" },\n\t{\"iu\", \"iku\" },\n\t{\"ja\", \"jpn\" },\n\t{\"jv\", \"jav\" },\n\t{\"ka\", \"kat\" }, // was \"geo\" (Georgian)\n\t{\"kk\", \"kaz\" },\n\t{\"kl\", \"kal\" },\n\t{\"km\", \"khm\" },\n\t{\"kn\", \"kan\" },\n\t{\"ko\", \"kor\" },\n\t{\"ks\", \"kas\" },\n\t{\"ku\", \"kur\" },\n\t{\"ky\", \"kir\" },\n\t{\"la\", \"lat\" },\n\t{\"ln\", \"lin\" },\n\t{\"lo\", \"lao\" },\n\t{\"lt\", \"lit\" },\n\t{\"lv\", \"lav\" },\n\t{\"mg\", \"mlg\" },\n\t{\"mi\", \"mri\" }, // was \"mao\" (Maori)\n\t{\"mk\", \"mkd\" }, // was \"mac\" (Macedonian)\n\t{\"ml\", \"mlt\" },\n\t{\"mn\", \"mon\" },\n\t{\"mo\", \"mol\" },\n\t{\"mr\", \"mar\" },\n\t{\"ms\", \"msa\" }, // was \"may\" (Malay)\n\t{\"my\", \"mya\" }, // was \"bur\" (Burmese)\n\t{\"na\", \"nau\" },\n\t{\"ne\", \"nep\" },\n\t{\"nl\", \"nld\" }, // was \"dut\" (Dutch; Flemish)\n\t{\"no\", \"nor\" },\n\t{\"oc\", \"oci\" },\n\t{\"om\", \"orm\" },\n\t{\"or\", \"ori\" },\n\t{\"pa\", \"pan\" },\n\t{\"pl\", \"pol\" },\n\t{\"ps\", \"pus\" },\n\t{\"pt\", \"por\" },\n\t{\"qu\", \"que\" },\n\t{\"rm\", \"roh\" },\n\t{\"rn\", \"run\" },\n\t{\"ro\", \"ron\" }, // was \"rum\" (Romanian; Moldavian; Moldovan)\n\t{\"ru\", \"rus\" },\n\t{\"rw\", \"kin\" },\n\t{\"sa\", \"san\" },\n\t{\"sd\", \"snd\" },\n\t{\"sg\", \"sag\" },\n\t{\"sh\", \"scr\" },\n\t{\"si\", \"sin\" },\n\t{\"sk\", \"slk\" }, // was \"slo\" (Slovak)\n\t{\"sl\", \"slv\" },\n\t{\"sm\", \"smo\" },\n\t{\"sn\", \"sna\" },\n\t{\"so\", \"som\" },\n\t{\"sq\", \"sqi\" }, // was \"alb\" (Albanian)\n\t{\"sr\", \"srp\" },\n\t{\"ss\", \"ssw\" },\n\t{\"st\", \"sot\" },\n\t{\"su\", \"sun\" },\n\t{\"sv\", \"swe\" },\n\t{\"sw\", \"swa\" },\n\t{\"ta\", \"tam\" },\n\t{\"te\", \"tel\" },\n\t{\"tg\", \"tgk\" },\n\t{\"th\", \"tha\" },\n\t{\"ti\", \"tir\" },\n\t{\"tk\", \"tuk\" },\n\t{\"tl\", \"tgl\" },\n\t{\"tn\", \"tsn\" },\n\t{\"to\", \"tog\" },\n\t{\"tr\", \"tur\" },\n\t{\"ts\", \"tso\" },\n\t{\"tt\", \"tat\" },\n\t{\"tw\", \"twi\" },\n\t{\"ug\", \"uig\" },\n\t{\"uk\", \"ukr\" },\n\t{\"ur\", \"urd\" },\n\t{\"uz\", \"uzb\" },\n\t{\"vi\", \"vie\" },\n\t{\"vo\", \"vol\" },\n\t{\"wo\", \"wol\" },\n\t{\"xh\", \"xho\" },\n\t{\"yi\", \"yid\" },\n\t{\"yo\", \"yor\" },\n\t{\"za\", \"zha\" },\n\t{\"zh\", \"zho\" }, // was \"chi\" (Chinese)\n\t{\"zu\", \"zul\" }\n};\n\n\n\ns32 vobsub_lang_name(u16 id)\n{\n\tu16 lang_id;\n\ts32 i, count;\n\n\tcount = (sizeof(lang_table) / sizeof(lang_table[0]));\n\n\tfor (i = 0; i < count; i++) {\n\t\tlang_id = (lang_table[i].id[0]<<8) | lang_table[i].id[1];\n\n\t\tif (id == lang_id) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn 0; /* Undefined - und */\n}\n\nchar *vobsub_lang_id(char *name)\n{\n\ts32 i, count;\n\n\tcount = (sizeof(lang_table) / sizeof(lang_table[0]));\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!stricmp(lang_table[i].lang, name)) {\n\t\t\treturn lang_table[i].id;\n\t\t}\n\t}\n\n\treturn \"--\"; /* Undefined */\n}\n\nstatic char *strltrim(char *str)\n{\n\tif (str == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (*str) {\n\t\tif (!isspace(*str)) {\n\t\t\treturn str;\n\t\t}\n\t\tstr++;\n\t}\n\n\treturn str;\n}\n\nstatic char *strrtrim(char *str)\n{\n\tchar *end;\n\n\tif (str == NULL) {\n\t\treturn NULL;\n\t}\n\n\tend = str + strlen(str);\n\n\twhile (end-- > str) {\n\t\tif (!isspace(*end)) {\n\t\t\treturn str;\n\t\t}\n\t\t*end = '\\0';\n\t}\n\n\treturn str;\n}\n\nstatic char *strtrim(char *str)\n{\n\treturn strltrim(strrtrim(str));\n}\n\nGF_Err vobsub_read_idx(FILE *file, vobsub_file *vobsub, s32 *version)\n{\n\tchar  strbuf[257];\n\tchar *str, *pos, *entry;\n\ts32   line, id =-1, delay = 0;\n\tBool  error = 0;\n\n\tfor (line = 0; !error && gf_fgets(strbuf, 256, file); line++)\n\t{\n\t\t//make sure we are null-terminated - cf #2520\n\t\tstrbuf[256]=0;\n\t\tstr = strtrim(strbuf);\n\n\t\tif (line == 0)\n\t\t{\n\t\t\tchar *buf = \"VobSub index file, v\";\n\n\t\t\tpos = strstr(str, buf);\n\t\t\tif (pos == NULL || sscanf(pos + strlen(buf), \"%d\", version) != 1 || *version > VOBSUBIDXVER)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (strlen(str) == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse if (str[0] == '#')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tpos = strchr(str, ':');\n\t\tif (pos == NULL || pos == str)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = str;\n\t\t*pos  = '\\0';\n\n\t\tstr = strtrim(pos + 1);\n\t\tif (strlen(str) == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stricmp(entry, \"size\") == 0)\n\t\t{\n\t\t\ts32 w, h;\n\t\t\tif (sscanf(str, \"%dx%d\", &w, &h) != 2)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\tvobsub->width  = w;\n\t\t\tvobsub->height = h;\n\t\t}\n\t\telse if (stricmp(entry, \"palette\") == 0)\n\t\t{\n\t\t\ts32 c;\n\t\t\tu8  palette[16][4];\n\n\t\t\tif (sscanf(str, \"%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\",\n\t\t\t           (u32 *) &palette[0], (u32 *) &palette[1], (u32 *) &palette[2], (u32 *) &palette[3],\n\t\t\t           (u32 *) &palette[4], (u32 *) &palette[5], (u32 *) &palette[6], (u32 *) &palette[7],\n\t\t\t           (u32 *) &palette[8], (u32 *) &palette[9], (u32 *) &palette[10], (u32 *) &palette[11],\n\t\t\t           (u32 *) &palette[12],(u32 *) &palette[13],(u32 *) &palette[14], (u32 *) &palette[15]) != 16)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (c = 0; c < 16; c++)\n\t\t\t{\n\t\t\t\tu8 r, g, b;\n\n\t\t\t\tr = palette[c][2];\n\t\t\t\tg = palette[c][1];\n\t\t\t\tb = palette[c][0];\n\t\t\t\tvobsub->palette[c][0] = 0;\n\t\t\t\tvobsub->palette[c][1] = (( 66 * r + 129 * g +  25 * b + 128 +  4096) >> 8) & 0xff;\n\t\t\t\tvobsub->palette[c][2] = ((112 * r -  94 * g -  18 * b + 128 + 32768) >> 8) & 0xff;\n\t\t\t\tvobsub->palette[c][3] = ((-38 * r -  74 * g + 112 * b + 128 + 32768) >> 8) & 0xff;\n\t\t\t}\n\t\t}\n\t\telse if (stricmp(entry, \"id\") == 0)\n\t\t{\n\t\t\tchar *buf = \"index:\";\n\t\t\ts32   lang_id;\n\n\t\t\tstrlwr(str);\n\t\t\tlang_id = ((str[0] & 0xff) << 8) | (str[1] & 0xff);\n\n\t\t\tpos = strstr(str, buf);\n\t\t\tif (pos == NULL)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sscanf(pos + strlen(buf), \"%d\", &id) != 1 || id < 0 || id >= 32)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvobsub->langs[id].id   = lang_id;\n\t\t\tvobsub->langs[id].name = lang_table[vobsub_lang_name((u16)lang_id)].lang;\n\t\t\tvobsub->langs[id].idx = id;\n\n\t\t\tvobsub->langs[id].subpos = gf_list_new();\n\t\t\tif (vobsub->langs[id].subpos == NULL)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdelay = 0;\n\t\t\tvobsub->num_langs++;\n\t\t}\n\t\telse if (id >= 0 && stricmp(entry, \"delay\") == 0)\n\t\t{\n\t\t\ts32  hh, mm, ss, ms;\n\t\t\tchar c;\n\t\t\ts32  sign = (str[0] == '-') ? -1 : 1;\n\n\t\t\tpos = str;\n\t\t\twhile (*pos == '-' || *pos == '+') pos++;\n\n\t\t\tif (sscanf(pos, \"%d%c%d%c%d%c%d\", &hh, &c, &mm, &c, &ss, &c, &ms) != 7)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdelay += (hh*60*60*1000 + mm*60*1000 + ss*1000 + ms) * sign;\n\t\t}\n\t\telse if (id >= 0 && stricmp(entry, \"timestamp\") == 0)\n\t\t{\n\t\t\tvobsub_pos *vspos;\n\t\t\ts32         sign;\n\t\t\tchar        c;\n\t\t\ts32         hh, mm, ss, ms;\n\t\t\tchar       *buf = \"filepos:\";\n\n\t\t\tvspos = (vobsub_pos*)gf_calloc(1, sizeof(vobsub_pos));\n\t\t\tif (vspos == NULL) {\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsign = (str[0] == '-') ? -1 : 1;\n\t\t\twhile (*str == '-' || *str == '+') str++;\n\n\t\t\tif (sscanf(str, \"%d%c%d%c%d%c%d\", &hh, &c, &mm, &c, &ss, &c, &ms) != 7)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvspos->start = (((hh*60 + mm)*60 + ss)*1000 + ms) * sign + delay;\n\n\t\t\tpos = strstr(str, buf);\n\t\t\tif (pos == NULL)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sscanf(pos + strlen(buf), LLX, &vspos->filepos) != 1)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (delay < 0 && gf_list_count(vobsub->langs[id].subpos) > 0)\n\t\t\t{\n\t\t\t\tvobsub_pos *vspos_next;\n\n\t\t\t\tvspos_next = (vobsub_pos*)gf_list_get(vobsub->langs[id].subpos, gf_list_count(vobsub->langs[id].subpos) - 1);\n\t\t\t\tif (vspos->start < vspos_next->start)\n\t\t\t\t{\n\t\t\t\t\tdelay += (s32)(vspos_next->start - vspos->start);\n\t\t\t\t\tvspos->start = vspos_next->start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gf_list_add(vobsub->langs[id].subpos, vspos) != GF_OK)\n\t\t\t{\n\t\t\t\tgf_free(vspos);\n\t\t\t\terror = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn error ? GF_CORRUPTED_DATA : GF_OK;\n}\n\nvoid vobsub_free(vobsub_file *vobsub)\n{\n\ts32 i;\n\n\tif (vobsub == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (vobsub->langs[i].subpos) {\n\t\t\tGF_List *list = vobsub->langs[i].subpos;\n\t\t\tvobsub_pos *vspos;\n\t\t\tu32 pos = 0;\n\n\t\t\tdo {\n\t\t\t\tvspos = (vobsub_pos*)gf_list_enum(list, &pos);\n\t\t\t\tgf_free(vspos);\n\t\t\t}\n\t\t\twhile (vspos != NULL);\n\n\t\t\tgf_list_del(list);\n\t\t}\n\t}\n\tgf_free(vobsub);\n}\n\nGF_Err vobsub_get_subpic_duration(u8 *_data, u32 psize, u32 dsize, u32 *duration)\n{\n\tu32 i, dcsq_stm, nxt_dcsq, start_stm, stop_stm;\n\tu8 *data = (u8 *)_data;\n\tstart_stm = 0;\n\tstop_stm  = 0;\n\tnxt_dcsq  = dsize;\n\n\tif (psize) do {\n\t\ti = nxt_dcsq;\n\t\tdcsq_stm = (data[i+0] << 8) | data[i+1];\n\t\tnxt_dcsq = (data[i+2] << 8) | data[i+3];\n\t\ti += 4;\n\n\t\tif (nxt_dcsq > psize || nxt_dcsq < dsize) {\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tu8  cmd;\n\t\t\tint len;\n\n\t\t\tcmd = data[i++];\n\t\t\tswitch (cmd)\n\t\t\t{\n\t\t\tcase 0x00:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x02:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tlen = 2;\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\t\tlen = 2;\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tlen = 6;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tlen = 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i + len > psize) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\n\t\t\ti += len;\n\n\t\t\tif (cmd == 0x00 || cmd == 0x01) {\n\t\t\t\t/* start normal or forced displaying */\n\t\t\t\tstart_stm = dcsq_stm * 1024;\n\t\t\t} else if (cmd == 0x02) {\n\t\t\t\t/* stop displaying */\n\t\t\t\tstop_stm = dcsq_stm * 1024;\n\t\t\t} else if (cmd > 0x06) {\n\t\t\t\t/* unknown command or end of control block */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (i <= nxt_dcsq && i < psize);\n\n\t*duration = stop_stm - start_stm;\n\n\treturn GF_OK;\n}\n\nGF_Err vobsub_packetize_subpicture(FILE *fsub, u64 pts, u8 *data, u32 dataSize)\n{\n\tu8\tbuf[0x800], ptsbuf[5];\n\tint\tput_pts = 1;\n\n\t/* Build PTS buffer */\n\tptsbuf[0] = (u8)(((pts >> 29) & 0x0e) | 0x21);\n\tptsbuf[1] = (u8)(((pts >> 22) & 0xff));\n\tptsbuf[2] = (u8)(((pts >> 14) & 0xfe) | 0x01);\n\tptsbuf[3] = (u8)(((pts >>  7) & 0xff));\n\tptsbuf[4] = (u8)(((pts <<  1) & 0xfe) | 0x01);\n\n\twhile (dataSize > 0) {\n\t\tu8\t*p;\n\t\tu32 padLen = 0;\n\t\tu32 dataLen = sizeof(buf);\n\t\tu32 packLen;\n\n\t\t/* Zerofill packet */\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tp = buf;\n\n\t\t/* Put pack header */\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x01;\n\t\t*p++ = 0xba;\n\t\t*p++ = 0x40;\n\n\t\t/* Jump to PES header */\n\t\tp += 9;\n\n\t\t/* Put PES header */\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x00;\n\t\t*p++ = 0x01;\n\t\t*p++ = 0xbd;\n\n\t\t/* Compute max size of content */\n\t\tdataLen -= 14; /* Pack header */\n\t\tdataLen -=  4; /* Start code + Stream ID */\n\t\tdataLen -=  2; /* PES packet size */\n\t\tdataLen -=  3; /* PES header extension */\n\t\tdataLen -= put_pts ? 5 : 0; /* PTS */\n\t\tdataLen -=  1; /* Substream ID */\n\n\t\t/* Check if the subpicture data fits in packet */\n\t\tif (dataSize <= dataLen) {\n\t\t\tpadLen  = dataLen - dataSize;\n\t\t\tdataLen = dataSize;\n\t\t}\n\n\t\t/* Compute and put packet size (PES header extension + PTS + Substream ID + data + padding) */\n\t\tpackLen = 3 + (put_pts ? 5 : 0) + 1 + dataLen + ((padLen < 6) ? padLen : 0);\n\t\t*p++ = (packLen >> 8) & 0xff;\n\t\t*p++ = packLen & 0xff;\n\n\t\t/* Put PES header extension */\n\t\t*p++ = 0x80;\n\t\t*p++ = put_pts ? 0x80 : 0x00;\n\t\t*p++ = (put_pts ? 5 : 0) + ((padLen < 6) ? padLen : 0);\n\n\t\t/* Put PTS */\n\t\tif (put_pts) {\n\t\t\t*p++ = ptsbuf[0];\n\t\t\t*p++ = ptsbuf[1];\n\t\t\t*p++ = ptsbuf[2];\n\t\t\t*p++ = ptsbuf[3];\n\t\t\t*p++ = ptsbuf[4];\n\t\t}\n\n\t\t/* Skip padding bytes */\n\t\tif (padLen < 6) {\n\t\t\tp += padLen;\n\t\t}\n\n\t\t/* Put Substream ID */\n\t\t*p++ = 0x20;\n\n\t\t/* Copy data into packet buffer */\n\t\tmemcpy(p, data, dataLen);\n\t\tp += dataLen;\n\n\t\t/* Put padding bytes if padding len >= 6 */\n\t\tif (padLen >= 6) {\n\t\t\tpadLen -= 6;\n\t\t\t*p++ = 0x00;\n\t\t\t*p++ = 0x00;\n\t\t\t*p++ = 0x01;\n\t\t\t*p++ = 0xbe;\n\t\t\t*p++ = (padLen >> 8) & 0xff;\n\t\t\t*p++ = padLen & 0xff;\n\t\t\tmemset(p, 0, padLen);\n\t\t}\n\n\t\t/* Write packet into file */\n\t\tif (gf_fwrite(buf, sizeof(buf), fsub) != sizeof(buf)) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\n\t\t/* Move data pointer... */\n\t\tdata += dataLen;\n\t\tdataSize -= dataLen;\n\n\t\t/* Next packet (if any) will not contain PTS */\n\t\tput_pts = 0;\n\t}\n\n\treturn GF_OK;\n}\n"], "filenames": ["src/media_tools/vobsub.c"], "buggy_code_start_loc": [256], "buggy_code_end_loc": [262], "fixing_code_start_loc": [256], "fixing_code_end_loc": [265], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.2.2.", "other": {"cve": {"id": "CVE-2023-3523", "sourceIdentifier": "security@huntr.dev", "published": "2023-07-06T10:15:09.660", "lastModified": "2023-07-13T18:56:11.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.2.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.1", "matchCriteriaId": "047BC15F-5E51-48D9-B751-9DC9311FEBCF"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/64201a26476c12a7dbd7ffb5757743af6954db96", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/57e0be03-8484-415e-8b5c-c1fe4546eaac", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/64201a26476c12a7dbd7ffb5757743af6954db96"}}