{"buggy_code": ["'use strict'\n\n/**\n * Module dependencies\n */\nvar events = require('events')\nvar Store = require('./store')\nvar eos = require('end-of-stream')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  client.emit('packetsend', packet)\n\n  var result = mqttPacket.writeToStream(packet, client.stream)\n\n  if (!result && cb) {\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    cb()\n  }\n}\n\nfunction storeAndSend (client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop () {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  this.options.clientId = (typeof this.options.clientId === 'string') ? this.options.clientId : defaultId()\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = this.options.outgoingStore || new Store()\n  this.incomingStore = this.options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = this.options.queueQoSZero === undefined ? true : this.options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // MessageIDs starting with 1\n  this.nextId = Math.floor(Math.random() * 65535)\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // Mark connected on connect\n  this.on('connect', function () {\n    if (this.disconnected) {\n      return\n    }\n\n    this.connected = true\n    var outStore = null\n    outStore = this.outgoingStore.createStream()\n\n    // Control of stored messages\n    outStore.once('readable', function () {\n      function storeDeliver () {\n        var packet = outStore.read(1)\n        var cb\n\n        if (!packet) {\n          return\n        }\n\n        // Avoid unnecesary stream read operations when disconnected\n        if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n          outStore.read(0)\n          cb = that.outgoing[packet.messageId]\n          that.outgoing[packet.messageId] = function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n          that._sendPacket(packet)\n        } else if (outStore.destroy) {\n          outStore.destroy()\n        }\n      }\n      storeDeliver()\n    })\n    .on('error', this.emit.bind(this, 'error'))\n  })\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false\n    clearTimeout(this.connackTimer)\n  })\n\n  // Setup ping timer\n  this.on('connect', this._setupPingTimer)\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    deliver()\n  })\n\n  var firstConnection = true\n  // resubscribe\n  this.on('connect', function () {\n    if (!firstConnection &&\n        this.options.clean &&\n        Object.keys(this._resubscribeTopics).length > 0) {\n      if (this.options.resubscribe) {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      } else {\n        this._resubscribeTopics = {}\n      }\n    }\n\n    firstConnection = false\n  })\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n  })\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect)\n\n  events.EventEmitter.call(this)\n\n  this._setupStream()\n}\ninherits(MqttClient, events.EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  this._clearReconnect()\n\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    packets.push(packet)\n  })\n\n  function process () {\n    var packet = packets.shift()\n    var done = completeParse\n\n    if (packet) {\n      that._handlePacket(packet, process)\n    } else {\n      completeParse = null\n      done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    parser.parse(buf)\n    process()\n  }\n\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', nop)\n\n  // Echo stream close\n  eos(this.stream, this.emit.bind(this, 'close'))\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop\n      this._sendPacket(packet)\n      break\n    default:\n      this._sendPacket(packet, callback)\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = Array.prototype.slice.call(arguments)\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  var defaultOpts = { qos: 0 }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (that._resubscribeTopics[topic] < opts.qos ||\n          !that._resubscribeTopics.hasOwnProperty(topic) ||\n          resubscribe\n        ) {\n        subs.push({\n          topic: topic,\n          qos: opts.qos\n        })\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        if (that._resubscribeTopics[k] < obj[k] ||\n            !that._resubscribeTopics.hasOwnProperty(k) ||\n            resubscribe\n          ) {\n          subs.push({\n            topic: k,\n            qos: obj[k]\n          })\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        that._resubscribeTopics[sub.topic] = sub.qos\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = function (err, packet) {\n    if (!err) {\n      var granted = packet.granted\n      for (var i = 0; i < granted.length; i += 1) {\n        subs[i].qos = granted[i]\n      }\n    }\n\n    callback(err, subs)\n  }\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n\n  callback = callback || nop\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  this.outgoing[packet.messageId] = callback\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, cb) {\n  var that = this\n\n  if (typeof force === 'function') {\n    cb = force\n    force = false\n  }\n\n  function closeStores () {\n    that.disconnected = true\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(cb)\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores))\n  }\n\n  if (this.disconnecting) {\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid]\n  delete this.outgoing[mid]\n  this.outgoingStore.del({messageId: mid}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect')\n  this._setupStream()\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      this.emit('offline')\n      this.reconnecting = true\n    }\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  if (done) {\n    this.stream.on('close', done)\n  }\n\n  if (forced) {\n    this.stream.destroy()\n  } else {\n    this._sendPacket(\n      { cmd: 'disconnect' },\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n      this.queue.push({ packet: packet, cb: cb })\n    } else if (packet.qos > 0) {\n      this.outgoingStore.put(packet, function (err) {\n        if (err) {\n          return cb && cb(err)\n        }\n      })\n    } else if (cb) {\n      cb(new Error('No connection to broker'))\n    }\n\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  if (packet.cmd !== 'publish') {\n    sendPacket(this, packet, cb)\n    return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode\n  var errors = [\n    '',\n    'Unacceptable protocol version',\n    'Identifier rejected',\n    'Server unavailable',\n    'Bad username or password',\n    'Not authorized'\n  ]\n\n  clearTimeout(this.connackTimer)\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this.emit('connect', packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var mid = packet.messageId\n  var that = this\n\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function () {\n        that._sendPacket({cmd: 'pubrec', messageId: mid}, done)\n      })\n      break\n    case 1:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, function (err) {\n        if (err) {\n          return done && done(err)\n        }\n        // send 'puback' if the above 'handleMessage' method executed\n        // successfully.\n        that._sendPacket({cmd: 'puback', messageId: mid}, done)\n      })\n      break\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[mid]\n  var that = this\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      }\n\n      this._sendPacket(response)\n      break\n    case 'suback':\n      delete this.outgoing[mid]\n      if (packet.granted.length === 1 && (packet.granted[0] & 0x80) !== 0) {\n        // suback with Failure status\n        var topics = this.messageIdToTopic[mid]\n        if (topics) {\n          topics.forEach(function (topic) {\n            delete that._resubscribeTopics[topic]\n          })\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[mid]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  var mid = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: mid}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err && pub.cmd !== 'pubrel') {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.incomingStore.put(packet)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback && callback(err)\n        }\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _nextId\n */\nMqttClient.prototype._nextId = function () {\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int:\n  if (id === 65535) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\nmodule.exports = MqttClient\n", "'use strict'\n\nvar mqtt = require('..')\nvar should = require('should')\nvar fork = require('child_process').fork\nvar path = require('path')\nvar abstractClientTests = require('./abstract_client')\nvar net = require('net')\nvar eos = require('end-of-stream')\nvar Connection = require('mqtt-connection')\nvar Server = require('./server')\nvar port = 9876\nvar server\n\n/**\n * Test server\n */\nfunction buildServer () {\n  return new Server(function (client) {\n    client.on('connect', function (packet) {\n      if (packet.clientId === 'invalid') {\n        client.connack({returnCode: 2})\n      } else {\n        client.connack({returnCode: 0})\n      }\n    })\n\n    client.on('publish', function (packet) {\n      setImmediate(function () {\n        switch (packet.qos) {\n          case 0:\n            break\n          case 1:\n            client.puback(packet)\n            break\n          case 2:\n            client.pubrec(packet)\n            break\n        }\n      })\n    })\n\n    client.on('pubrel', function (packet) {\n      client.pubcomp(packet)\n    })\n\n    client.on('pubrec', function (packet) {\n      client.pubrel(packet)\n    })\n\n    client.on('pubcomp', function () {\n      // Nothing to be done\n    })\n\n    client.on('subscribe', function (packet) {\n      client.suback({\n        messageId: packet.messageId,\n        granted: packet.subscriptions.map(function (e) {\n          return e.qos\n        })\n      })\n    })\n\n    client.on('unsubscribe', function (packet) {\n      client.unsuback(packet)\n    })\n\n    client.on('pingreq', function () {\n      client.pingresp()\n    })\n  })\n}\n\nserver = buildServer().listen(port)\n\ndescribe('MqttClient', function () {\n  describe('creating', function () {\n    it('should allow instantiation of MqttClient without the \\'new\\' operator', function (done) {\n      should(function () {\n        var client\n        try {\n          client = mqtt.MqttClient(function () {\n            throw Error('break')\n          }, {})\n          client.end()\n        } catch (err) {\n          if (err.message !== 'break') {\n            throw err\n          }\n          done()\n        }\n      }).not.throw('Object #<Object> has no method \\'_setupStream\\'')\n    })\n  })\n\n  var config = { protocol: 'mqtt', port: port }\n  abstractClientTests(server, config)\n\n  describe('message ids', function () {\n    it('should increment the message id', function () {\n      var client = mqtt.connect(config)\n      var currentId = client._nextId()\n\n      client._nextId().should.equal(currentId + 1)\n      client.end()\n    })\n\n    it('should return 1 once the interal counter reached limit', function () {\n      var client = mqtt.connect(config)\n      client.nextId = 65535\n\n      client._nextId().should.equal(65535)\n      client._nextId().should.equal(1)\n      client.end()\n    })\n\n    it('should return 65535 for last message id once the interal counter reached limit', function () {\n      var client = mqtt.connect(config)\n      client.nextId = 65535\n\n      client._nextId().should.equal(65535)\n      client.getLastMessageId().should.equal(65535)\n      client._nextId().should.equal(1)\n      client.getLastMessageId().should.equal(1)\n      client.end()\n    })\n\n    it('should not throw an error if packet\\'s messageId is not found when receiving a pubrel packet', function (done) {\n      var server2 = new Server(function (c) {\n        c.on('connect', function (packet) {\n          c.connack({returnCode: 0})\n          c.pubrel({ messageId: Math.floor(Math.random() * 9000) + 1000 })\n        })\n      })\n\n      server2.listen(port + 49, function () {\n        var client = mqtt.connect({\n          port: port + 49,\n          host: 'localhost'\n        })\n\n        client.on('packetsend', function (packet) {\n          if (packet.cmd === 'pubcomp') {\n            client.end()\n            server2.close()\n            done()\n          }\n        })\n      })\n    })\n  })\n\n  describe('reconnecting', function () {\n    it('should attempt to reconnect once server is down', function (done) {\n      this.timeout(15000)\n\n      var innerServer = fork(path.join(__dirname, 'helpers', 'server_process.js'))\n      var client = mqtt.connect({ port: 3000, host: 'localhost', keepalive: 1 })\n\n      client.once('connect', function () {\n        innerServer.kill('SIGINT') // mocks server shutdown\n\n        client.once('close', function () {\n          should.exist(client.reconnectTimer)\n          client.end()\n          done()\n        })\n      })\n    })\n\n    it('should reconnect to multiple host-ports combination if servers is passed', function (done) {\n      this.timeout(15000)\n\n      var server2 = buildServer().listen(port + 42)\n\n      server2.on('client', function (c) {\n        c.stream.destroy()\n        server2.close()\n      })\n\n      server2.on('listening', function () {\n        var client = mqtt.connect({\n          servers: [\n            { port: port + 42, host: 'localhost' },\n            { port: port, host: 'localhost' }\n          ],\n          keepalive: 50\n        })\n\n        server.once('client', function () {\n          client.end()\n          done()\n        })\n\n        client.once('connect', function () {\n          client.stream.destroy()\n        })\n      })\n    })\n\n    it('should reconnect if a connack is not received in an interval', function (done) {\n      this.timeout(2000)\n\n      var server2 = net.createServer().listen(port + 43)\n\n      server2.on('connection', function (c) {\n        eos(c, function () {\n          server2.close()\n        })\n      })\n\n      server2.on('listening', function () {\n        var client = mqtt.connect({\n          servers: [\n            { port: port + 43, host: 'localhost_fake' },\n            { port: port, host: 'localhost' }\n          ],\n          connectTimeout: 500\n        })\n\n        server.once('client', function () {\n          client.end()\n          done()\n        })\n\n        client.once('connect', function () {\n          client.stream.destroy()\n        })\n      })\n    })\n\n    it('shoud not be cleared by the connack timer', function (done) {\n      this.timeout(4000)\n\n      var server2 = net.createServer().listen(port + 44)\n\n      server2.on('connection', function (c) {\n        c.destroy()\n      })\n\n      server2.once('listening', function () {\n        var reconnects = 0\n        var connectTimeout = 1000\n        var reconnectPeriod = 100\n        var expectedReconnects = Math.floor(connectTimeout / reconnectPeriod)\n        var client = mqtt.connect({\n          port: port + 44,\n          host: 'localhost',\n          connectTimeout: connectTimeout,\n          reconnectPeriod: reconnectPeriod\n        })\n\n        client.on('reconnect', function () {\n          reconnects++\n          if (reconnects >= expectedReconnects) {\n            client.end()\n            done()\n          }\n        })\n      })\n    })\n\n    it('shoud not keep requeueing the first message when offline', function (done) {\n      this.timeout(2500)\n\n      var server2 = buildServer().listen(port + 45)\n      var client = mqtt.connect({\n        port: port + 45,\n        host: 'localhost',\n        connectTimeout: 350,\n        reconnectPeriod: 300\n      })\n\n      server2.on('client', function (c) {\n        client.publish('hello', 'world', { qos: 1 }, function () {\n          c.destroy()\n          server2.close()\n          client.publish('hello', 'world', { qos: 1 })\n        })\n      })\n\n      setTimeout(function () {\n        if (client.queue.length === 0) {\n          client.end(true)\n          done()\n        } else {\n          client.end(true)\n        }\n      }, 2000)\n    })\n\n    it('should not send the same subcribe multiple times on a flaky connection', function (done) {\n      this.timeout(3500)\n\n      var KILL_COUNT = 4\n      var killedConnections = 0\n      var subIds = {}\n      var client = mqtt.connect({\n        port: port + 46,\n        host: 'localhost',\n        connectTimeout: 350,\n        reconnectPeriod: 300\n      })\n\n      var server2 = new Server(function (client) {\n        client.on('error', function () {})\n        client.on('connect', function (packet) {\n          if (packet.clientId === 'invalid') {\n            client.connack({returnCode: 2})\n          } else {\n            client.connack({returnCode: 0})\n          }\n        })\n      }).listen(port + 46)\n\n      server2.on('client', function (c) {\n        client.subscribe('topic', function () {\n          done()\n          client.end(true)\n          c.destroy()\n          server2.close()\n        })\n\n        c.on('subscribe', function (packet) {\n          if (killedConnections < KILL_COUNT) {\n            // Kill the first few sub attempts to simulate a flaky connection\n            killedConnections++\n            c.destroy()\n          } else {\n            // Keep track of acks\n            if (!subIds[packet.messageId]) {\n              subIds[packet.messageId] = 0\n            }\n            subIds[packet.messageId]++\n            if (subIds[packet.messageId] > 1) {\n              done(new Error('Multiple duplicate acked subscriptions received for messageId ' + packet.messageId))\n              client.end(true)\n              c.destroy()\n              server2.destroy()\n            }\n\n            c.suback({\n              messageId: packet.messageId,\n              granted: packet.subscriptions.map(function (e) {\n                return e.qos\n              })\n            })\n          }\n        })\n      })\n    })\n\n    it('should not fill the queue of subscribes if it cannot connect', function (done) {\n      this.timeout(2500)\n\n      var port2 = port + 48\n\n      var server2 = net.createServer(function (stream) {\n        var client = new Connection(stream)\n\n        client.on('error', function () {})\n        client.on('connect', function (packet) {\n          client.connack({returnCode: 0})\n          client.destroy()\n        })\n      })\n\n      server2.listen(port2, function () {\n        var client = mqtt.connect({\n          port: port2,\n          host: 'localhost',\n          connectTimeout: 350,\n          reconnectPeriod: 300\n        })\n\n        client.subscribe('hello')\n\n        setTimeout(function () {\n          client.queue.length.should.equal(1)\n          client.end()\n          done()\n        }, 1000)\n      })\n    })\n\n    it('should not send the same publish multiple times on a flaky connection', function (done) {\n      this.timeout(3500)\n\n      var KILL_COUNT = 4\n      var killedConnections = 0\n      var pubIds = {}\n      var client = mqtt.connect({\n        port: port + 47,\n        host: 'localhost',\n        connectTimeout: 350,\n        reconnectPeriod: 300\n      })\n\n      var server2 = net.createServer(function (stream) {\n        var client = new Connection(stream)\n        client.on('error', function () {})\n        client.on('connect', function (packet) {\n          if (packet.clientId === 'invalid') {\n            client.connack({returnCode: 2})\n          } else {\n            client.connack({returnCode: 0})\n          }\n        })\n\n        this.emit('client', client)\n      }).listen(port + 47)\n\n      server2.on('client', function (c) {\n        client.publish('topic', 'data', { qos: 1 }, function () {\n          done()\n          client.end(true)\n          c.destroy()\n          server2.destroy()\n        })\n\n        c.on('publish', function onPublish (packet) {\n          if (killedConnections < KILL_COUNT) {\n            // Kill the first few pub attempts to simulate a flaky connection\n            killedConnections++\n            c.destroy()\n\n            // to avoid receiving inflight messages\n            c.removeListener('publish', onPublish)\n          } else {\n            // Keep track of acks\n            if (!pubIds[packet.messageId]) {\n              pubIds[packet.messageId] = 0\n            }\n\n            pubIds[packet.messageId]++\n\n            if (pubIds[packet.messageId] > 1) {\n              done(new Error('Multiple duplicate acked publishes received for messageId ' + packet.messageId))\n              client.end(true)\n              c.destroy()\n              server2.destroy()\n            }\n\n            c.puback(packet)\n          }\n        })\n      })\n    })\n  })\n})\n"], "fixing_code": ["'use strict'\n\n/**\n * Module dependencies\n */\nvar events = require('events')\nvar Store = require('./store')\nvar eos = require('end-of-stream')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  client.emit('packetsend', packet)\n\n  var result = mqttPacket.writeToStream(packet, client.stream)\n\n  if (!result && cb) {\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    cb()\n  }\n}\n\nfunction storeAndSend (client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop () {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  this.options.clientId = (typeof this.options.clientId === 'string') ? this.options.clientId : defaultId()\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = this.options.outgoingStore || new Store()\n  this.incomingStore = this.options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = this.options.queueQoSZero === undefined ? true : this.options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // MessageIDs starting with 1\n  this.nextId = Math.floor(Math.random() * 65535)\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // Mark connected on connect\n  this.on('connect', function () {\n    if (this.disconnected) {\n      return\n    }\n\n    this.connected = true\n    var outStore = null\n    outStore = this.outgoingStore.createStream()\n\n    // Control of stored messages\n    outStore.once('readable', function () {\n      function storeDeliver () {\n        var packet = outStore.read(1)\n        var cb\n\n        if (!packet) {\n          return\n        }\n\n        // Avoid unnecesary stream read operations when disconnected\n        if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n          outStore.read(0)\n          cb = that.outgoing[packet.messageId]\n          that.outgoing[packet.messageId] = function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n          that._sendPacket(packet)\n        } else if (outStore.destroy) {\n          outStore.destroy()\n        }\n      }\n      storeDeliver()\n    })\n    .on('error', this.emit.bind(this, 'error'))\n  })\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false\n    clearTimeout(this.connackTimer)\n  })\n\n  // Setup ping timer\n  this.on('connect', this._setupPingTimer)\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    deliver()\n  })\n\n  var firstConnection = true\n  // resubscribe\n  this.on('connect', function () {\n    if (!firstConnection &&\n        this.options.clean &&\n        Object.keys(this._resubscribeTopics).length > 0) {\n      if (this.options.resubscribe) {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      } else {\n        this._resubscribeTopics = {}\n      }\n    }\n\n    firstConnection = false\n  })\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n  })\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect)\n\n  events.EventEmitter.call(this)\n\n  this._setupStream()\n}\ninherits(MqttClient, events.EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  this._clearReconnect()\n\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    process.nextTick(work)\n  }\n\n  function work () {\n    var packet = packets.shift()\n    var done = completeParse\n\n    if (packet) {\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      completeParse = null\n      done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    parser.parse(buf)\n    work()\n  }\n\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', nop)\n\n  // Echo stream close\n  eos(this.stream, this.emit.bind(this, 'close'))\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop\n      this._sendPacket(packet)\n      break\n    default:\n      this._sendPacket(packet, callback)\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = Array.prototype.slice.call(arguments)\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  var defaultOpts = { qos: 0 }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (that._resubscribeTopics[topic] < opts.qos ||\n          !that._resubscribeTopics.hasOwnProperty(topic) ||\n          resubscribe\n        ) {\n        subs.push({\n          topic: topic,\n          qos: opts.qos\n        })\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        if (that._resubscribeTopics[k] < obj[k] ||\n            !that._resubscribeTopics.hasOwnProperty(k) ||\n            resubscribe\n          ) {\n          subs.push({\n            topic: k,\n            qos: obj[k]\n          })\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        that._resubscribeTopics[sub.topic] = sub.qos\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = function (err, packet) {\n    if (!err) {\n      var granted = packet.granted\n      for (var i = 0; i < granted.length; i += 1) {\n        subs[i].qos = granted[i]\n      }\n    }\n\n    callback(err, subs)\n  }\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n\n  callback = callback || nop\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  this.outgoing[packet.messageId] = callback\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, cb) {\n  var that = this\n\n  if (typeof force === 'function') {\n    cb = force\n    force = false\n  }\n\n  function closeStores () {\n    that.disconnected = true\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(cb)\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores))\n  }\n\n  if (this.disconnecting) {\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid]\n  delete this.outgoing[mid]\n  this.outgoingStore.del({messageId: mid}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect')\n  this._setupStream()\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      this.emit('offline')\n      this.reconnecting = true\n    }\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  if (done) {\n    this.stream.on('close', done)\n  }\n\n  if (forced) {\n    this.stream.destroy()\n  } else {\n    this._sendPacket(\n      { cmd: 'disconnect' },\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n      this.queue.push({ packet: packet, cb: cb })\n    } else if (packet.qos > 0) {\n      this.outgoingStore.put(packet, function (err) {\n        if (err) {\n          return cb && cb(err)\n        }\n      })\n    } else if (cb) {\n      cb(new Error('No connection to broker'))\n    }\n\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  if (packet.cmd !== 'publish') {\n    sendPacket(this, packet, cb)\n    return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode\n  var errors = [\n    '',\n    'Unacceptable protocol version',\n    'Identifier rejected',\n    'Server unavailable',\n    'Bad username or password',\n    'Not authorized'\n  ]\n\n  clearTimeout(this.connackTimer)\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this.emit('connect', packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var mid = packet.messageId\n  var that = this\n\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function () {\n        that._sendPacket({cmd: 'pubrec', messageId: mid}, done)\n      })\n      break\n    case 1:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, function (err) {\n        if (err) {\n          return done && done(err)\n        }\n        // send 'puback' if the above 'handleMessage' method executed\n        // successfully.\n        that._sendPacket({cmd: 'puback', messageId: mid}, done)\n      })\n      break\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[mid]\n  var that = this\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      }\n\n      this._sendPacket(response)\n      break\n    case 'suback':\n      delete this.outgoing[mid]\n      if (packet.granted.length === 1 && (packet.granted[0] & 0x80) !== 0) {\n        // suback with Failure status\n        var topics = this.messageIdToTopic[mid]\n        if (topics) {\n          topics.forEach(function (topic) {\n            delete that._resubscribeTopics[topic]\n          })\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[mid]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  var mid = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: mid}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err && pub.cmd !== 'pubrel') {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.incomingStore.put(packet)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback && callback(err)\n        }\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _nextId\n */\nMqttClient.prototype._nextId = function () {\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int:\n  if (id === 65535) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\nmodule.exports = MqttClient\n", "'use strict'\n\nvar mqtt = require('..')\nvar should = require('should')\nvar fork = require('child_process').fork\nvar path = require('path')\nvar abstractClientTests = require('./abstract_client')\nvar net = require('net')\nvar eos = require('end-of-stream')\nvar mqttPacket = require('mqtt-packet')\nvar Buffer = require('safe-buffer').Buffer\nvar Duplex = require('readable-stream').Duplex\nvar Connection = require('mqtt-connection')\nvar Server = require('./server')\nvar port = 9876\nvar server\n\n/**\n * Test server\n */\nfunction buildServer () {\n  return new Server(function (client) {\n    client.on('connect', function (packet) {\n      if (packet.clientId === 'invalid') {\n        client.connack({returnCode: 2})\n      } else {\n        client.connack({returnCode: 0})\n      }\n    })\n\n    client.on('publish', function (packet) {\n      setImmediate(function () {\n        switch (packet.qos) {\n          case 0:\n            break\n          case 1:\n            client.puback(packet)\n            break\n          case 2:\n            client.pubrec(packet)\n            break\n        }\n      })\n    })\n\n    client.on('pubrel', function (packet) {\n      client.pubcomp(packet)\n    })\n\n    client.on('pubrec', function (packet) {\n      client.pubrel(packet)\n    })\n\n    client.on('pubcomp', function () {\n      // Nothing to be done\n    })\n\n    client.on('subscribe', function (packet) {\n      client.suback({\n        messageId: packet.messageId,\n        granted: packet.subscriptions.map(function (e) {\n          return e.qos\n        })\n      })\n    })\n\n    client.on('unsubscribe', function (packet) {\n      client.unsuback(packet)\n    })\n\n    client.on('pingreq', function () {\n      client.pingresp()\n    })\n  })\n}\n\nserver = buildServer().listen(port)\n\ndescribe('MqttClient', function () {\n  describe('creating', function () {\n    it('should allow instantiation of MqttClient without the \\'new\\' operator', function (done) {\n      should(function () {\n        var client\n        try {\n          client = mqtt.MqttClient(function () {\n            throw Error('break')\n          }, {})\n          client.end()\n        } catch (err) {\n          if (err.message !== 'break') {\n            throw err\n          }\n          done()\n        }\n      }).not.throw('Object #<Object> has no method \\'_setupStream\\'')\n    })\n  })\n\n  var config = { protocol: 'mqtt', port: port }\n  abstractClientTests(server, config)\n\n  describe('message ids', function () {\n    it('should increment the message id', function () {\n      var client = mqtt.connect(config)\n      var currentId = client._nextId()\n\n      client._nextId().should.equal(currentId + 1)\n      client.end()\n    })\n\n    it('should return 1 once the interal counter reached limit', function () {\n      var client = mqtt.connect(config)\n      client.nextId = 65535\n\n      client._nextId().should.equal(65535)\n      client._nextId().should.equal(1)\n      client.end()\n    })\n\n    it('should return 65535 for last message id once the interal counter reached limit', function () {\n      var client = mqtt.connect(config)\n      client.nextId = 65535\n\n      client._nextId().should.equal(65535)\n      client.getLastMessageId().should.equal(65535)\n      client._nextId().should.equal(1)\n      client.getLastMessageId().should.equal(1)\n      client.end()\n    })\n\n    it('should not throw an error if packet\\'s messageId is not found when receiving a pubrel packet', function (done) {\n      var server2 = new Server(function (c) {\n        c.on('connect', function (packet) {\n          c.connack({returnCode: 0})\n          c.pubrel({ messageId: Math.floor(Math.random() * 9000) + 1000 })\n        })\n      })\n\n      server2.listen(port + 49, function () {\n        var client = mqtt.connect({\n          port: port + 49,\n          host: 'localhost'\n        })\n\n        client.on('packetsend', function (packet) {\n          if (packet.cmd === 'pubcomp') {\n            client.end()\n            server2.close()\n            done()\n          }\n        })\n      })\n    })\n\n    it('should not go overflow if the TCP frame contains a lot of PUBLISH packets', function (done) {\n      var parser = mqttPacket.parser()\n      var count = 0\n      var max = 1000\n      var duplex = new Duplex({\n        read: function (n) {},\n        write: function (chunk, enc, cb) {\n          parser.parse(chunk)\n          cb() // nothing to do\n        }\n      })\n      var client = new mqtt.MqttClient(function () {\n        return duplex\n      }, {})\n\n      client.on('message', function (t, p, packet) {\n        if (++count === max) {\n          done()\n        }\n      })\n\n      parser.on('packet', function (packet) {\n        var packets = []\n\n        if (packet.cmd === 'connect') {\n          duplex.push(mqttPacket.generate({\n            cmd: 'connack',\n            sessionPresent: false,\n            returnCode: 0\n          }))\n\n          for (var i = 0; i < max; i++) {\n            packets.push(mqttPacket.generate({\n              cmd: 'publish',\n              topic: Buffer.from('hello'),\n              payload: Buffer.from('world'),\n              retain: false,\n              dup: false,\n              messageId: i + 1,\n              qos: 1\n            }))\n          }\n\n          duplex.push(Buffer.concat(packets))\n        }\n      })\n    })\n  })\n\n  describe('reconnecting', function () {\n    it('should attempt to reconnect once server is down', function (done) {\n      this.timeout(15000)\n\n      var innerServer = fork(path.join(__dirname, 'helpers', 'server_process.js'))\n      var client = mqtt.connect({ port: 3000, host: 'localhost', keepalive: 1 })\n\n      client.once('connect', function () {\n        innerServer.kill('SIGINT') // mocks server shutdown\n\n        client.once('close', function () {\n          should.exist(client.reconnectTimer)\n          client.end()\n          done()\n        })\n      })\n    })\n\n    it('should reconnect to multiple host-ports combination if servers is passed', function (done) {\n      this.timeout(15000)\n\n      var server2 = buildServer().listen(port + 42)\n\n      server2.on('client', function (c) {\n        c.stream.destroy()\n        server2.close()\n      })\n\n      server2.on('listening', function () {\n        var client = mqtt.connect({\n          servers: [\n            { port: port + 42, host: 'localhost' },\n            { port: port, host: 'localhost' }\n          ],\n          keepalive: 50\n        })\n\n        server.once('client', function () {\n          client.end()\n          done()\n        })\n\n        client.once('connect', function () {\n          client.stream.destroy()\n        })\n      })\n    })\n\n    it('should reconnect if a connack is not received in an interval', function (done) {\n      this.timeout(2000)\n\n      var server2 = net.createServer().listen(port + 43)\n\n      server2.on('connection', function (c) {\n        eos(c, function () {\n          server2.close()\n        })\n      })\n\n      server2.on('listening', function () {\n        var client = mqtt.connect({\n          servers: [\n            { port: port + 43, host: 'localhost_fake' },\n            { port: port, host: 'localhost' }\n          ],\n          connectTimeout: 500\n        })\n\n        server.once('client', function () {\n          client.end()\n          done()\n        })\n\n        client.once('connect', function () {\n          client.stream.destroy()\n        })\n      })\n    })\n\n    it('shoud not be cleared by the connack timer', function (done) {\n      this.timeout(4000)\n\n      var server2 = net.createServer().listen(port + 44)\n\n      server2.on('connection', function (c) {\n        c.destroy()\n      })\n\n      server2.once('listening', function () {\n        var reconnects = 0\n        var connectTimeout = 1000\n        var reconnectPeriod = 100\n        var expectedReconnects = Math.floor(connectTimeout / reconnectPeriod)\n        var client = mqtt.connect({\n          port: port + 44,\n          host: 'localhost',\n          connectTimeout: connectTimeout,\n          reconnectPeriod: reconnectPeriod\n        })\n\n        client.on('reconnect', function () {\n          reconnects++\n          if (reconnects >= expectedReconnects) {\n            client.end()\n            done()\n          }\n        })\n      })\n    })\n\n    it('shoud not keep requeueing the first message when offline', function (done) {\n      this.timeout(2500)\n\n      var server2 = buildServer().listen(port + 45)\n      var client = mqtt.connect({\n        port: port + 45,\n        host: 'localhost',\n        connectTimeout: 350,\n        reconnectPeriod: 300\n      })\n\n      server2.on('client', function (c) {\n        client.publish('hello', 'world', { qos: 1 }, function () {\n          c.destroy()\n          server2.close()\n          client.publish('hello', 'world', { qos: 1 })\n        })\n      })\n\n      setTimeout(function () {\n        if (client.queue.length === 0) {\n          client.end(true)\n          done()\n        } else {\n          client.end(true)\n        }\n      }, 2000)\n    })\n\n    it('should not send the same subcribe multiple times on a flaky connection', function (done) {\n      this.timeout(3500)\n\n      var KILL_COUNT = 4\n      var killedConnections = 0\n      var subIds = {}\n      var client = mqtt.connect({\n        port: port + 46,\n        host: 'localhost',\n        connectTimeout: 350,\n        reconnectPeriod: 300\n      })\n\n      var server2 = new Server(function (client) {\n        client.on('error', function () {})\n        client.on('connect', function (packet) {\n          if (packet.clientId === 'invalid') {\n            client.connack({returnCode: 2})\n          } else {\n            client.connack({returnCode: 0})\n          }\n        })\n      }).listen(port + 46)\n\n      server2.on('client', function (c) {\n        client.subscribe('topic', function () {\n          done()\n          client.end(true)\n          c.destroy()\n          server2.close()\n        })\n\n        c.on('subscribe', function (packet) {\n          if (killedConnections < KILL_COUNT) {\n            // Kill the first few sub attempts to simulate a flaky connection\n            killedConnections++\n            c.destroy()\n          } else {\n            // Keep track of acks\n            if (!subIds[packet.messageId]) {\n              subIds[packet.messageId] = 0\n            }\n            subIds[packet.messageId]++\n            if (subIds[packet.messageId] > 1) {\n              done(new Error('Multiple duplicate acked subscriptions received for messageId ' + packet.messageId))\n              client.end(true)\n              c.destroy()\n              server2.destroy()\n            }\n\n            c.suback({\n              messageId: packet.messageId,\n              granted: packet.subscriptions.map(function (e) {\n                return e.qos\n              })\n            })\n          }\n        })\n      })\n    })\n\n    it('should not fill the queue of subscribes if it cannot connect', function (done) {\n      this.timeout(2500)\n\n      var port2 = port + 48\n\n      var server2 = net.createServer(function (stream) {\n        var client = new Connection(stream)\n\n        client.on('error', function () {})\n        client.on('connect', function (packet) {\n          client.connack({returnCode: 0})\n          client.destroy()\n        })\n      })\n\n      server2.listen(port2, function () {\n        var client = mqtt.connect({\n          port: port2,\n          host: 'localhost',\n          connectTimeout: 350,\n          reconnectPeriod: 300\n        })\n\n        client.subscribe('hello')\n\n        setTimeout(function () {\n          client.queue.length.should.equal(1)\n          client.end()\n          done()\n        }, 1000)\n      })\n    })\n\n    it('should not send the same publish multiple times on a flaky connection', function (done) {\n      this.timeout(3500)\n\n      var KILL_COUNT = 4\n      var killedConnections = 0\n      var pubIds = {}\n      var client = mqtt.connect({\n        port: port + 47,\n        host: 'localhost',\n        connectTimeout: 350,\n        reconnectPeriod: 300\n      })\n\n      var server2 = net.createServer(function (stream) {\n        var client = new Connection(stream)\n        client.on('error', function () {})\n        client.on('connect', function (packet) {\n          if (packet.clientId === 'invalid') {\n            client.connack({returnCode: 2})\n          } else {\n            client.connack({returnCode: 0})\n          }\n        })\n\n        this.emit('client', client)\n      }).listen(port + 47)\n\n      server2.on('client', function (c) {\n        client.publish('topic', 'data', { qos: 1 }, function () {\n          done()\n          client.end(true)\n          c.destroy()\n          server2.destroy()\n        })\n\n        c.on('publish', function onPublish (packet) {\n          if (killedConnections < KILL_COUNT) {\n            // Kill the first few pub attempts to simulate a flaky connection\n            killedConnections++\n            c.destroy()\n\n            // to avoid receiving inflight messages\n            c.removeListener('publish', onPublish)\n          } else {\n            // Keep track of acks\n            if (!pubIds[packet.messageId]) {\n              pubIds[packet.messageId] = 0\n            }\n\n            pubIds[packet.messageId]++\n\n            if (pubIds[packet.messageId] > 1) {\n              done(new Error('Multiple duplicate acked publishes received for messageId ' + packet.messageId))\n              client.end(true)\n              c.destroy()\n              server2.destroy()\n            }\n\n            c.puback(packet)\n          }\n        })\n      })\n    })\n  })\n})\n"], "filenames": ["lib/client.js", "test/client.js"], "buggy_code_start_loc": [252, 9], "buggy_code_end_loc": [268, 148], "fixing_code_start_loc": [252, 10], "fixing_code_end_loc": [272, 200], "type": "CWE-674", "message": "MQTT.js 2.x.x prior to 2.15.0 issue in handling PUBLISH tickets may lead to an attacker causing a denial-of-service condition.", "other": {"cve": {"id": "CVE-2017-10910", "sourceIdentifier": "vultures@jpcert.or.jp", "published": "2017-12-28T02:29:03.427", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MQTT.js 2.x.x prior to 2.15.0 issue in handling PUBLISH tickets may lead to an attacker causing a denial-of-service condition."}, {"lang": "es", "value": "En MQTT.js en versiones 2.x.x anteriores a la 2.15.0 existe un problema en el manejo de tickets PUBLISH que puede dar lugar a que un atacante provoque una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mqtt.js_project:mqtt.js:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.15.0", "matchCriteriaId": "E8A5F4E8-D3B1-4F28-A0BB-74EC1F975F94"}]}]}], "references": [{"url": "https://github.com/mqttjs/MQTT.js/commit/403ba53b838f2d319a0c0505a045fe00239e9923", "source": "vultures@jpcert.or.jp", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mqttjs/MQTT.js/releases/tag/v2.15.0", "source": "vultures@jpcert.or.jp", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://jvn.jp/en/jp/JVN45494523/index.html", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/mqttjs/MQTT.js/commit/403ba53b838f2d319a0c0505a045fe00239e9923"}}