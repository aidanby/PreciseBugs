{"buggy_code": ["<?php\n/*\n SPDX-FileCopyrightText: \u00a9 2011-2012 Hewlett-Packard Development Company, L.P.\n SPDX-FileCopyrightText: \u00a9 2017 Siemens AG\n\n SPDX-License-Identifier: LGPL-2.1-only\n*/\n\n/**\n *  \\file\n *  \\brief This file contains common database functions.\n **/\n\n\n/**\n * \\brief Connect to database engine.\n *        This is a no-op if $PG_CONN already has a value.\n *\n * \\param string $sysconfdir fossology configuration directory (location of\n *             Db.conf)\n * \\param string $options an optional list of attributes for\n *             connecting to the database. E.g.:\n *   `\"dbname=text host=text user=text password=text\"`\n * \\param bool   $exitOnFail true (default) to print error and call exit on\n *                  failure false to return $PG_CONN === false on failure\n *\n * If $options is empty, then connection parameters will be read from Db.conf.\n *\n * \\return\n *   Success: $PG_CONN, the postgres connection object \\n\n *   Failure: Error message is printed\n **/\nfunction DBconnect($sysconfdir, $options=\"\", $exitOnFail=true)\n{\n  global $PG_CONN;\n\n  if (! empty($PG_CONN)) {\n    return $PG_CONN;\n  }\n\n  $path=\"$sysconfdir/Db.conf\";\n  if (empty($options)) {\n    $dbConf = file_get_contents($path);\n    if ($exitOnFail && (false === $dbConf)) {\n      $text = _(\"Could not connect to FOSSology database.\");\n      echo \"<h2>$text</h2>\";\n      echo _('permission denied for configuration file');\n      exit();\n    }\n    if (false === $dbConf) {\n      $PG_CONN = false;\n      return;\n    }\n    $options = $dbConf;\n  }\n  if (! empty($options)) {\n    $PG_CONN = pg_connect(str_replace(\";\", \" \", $options));\n  }\n\n  if (! empty($PG_CONN)) {\n    /* success */\n    return $PG_CONN;\n  }\n\n  if ($exitOnFail) {\n    $text = _(\"Could not connect to FOSSology database.\");\n    echo \"<h2>$text</h2>\";\n    exit();\n  }\n  $PG_CONN = false;\n}\n\n\n/**\n   \\brief Retrieve a single database record.\n\n   This function does a:\n   \\code\n   \"SELECT * from $Table $Where limit 1\"\n   \\endcode\n   and returns the result as an associative array.\n\n   \\param string $Table   Table name\n   \\param string $Where   SQL where clause e.g. `\"where uploadtree_pk=2\"`.\n                   Though a WHERE clause is the typical use, $Where\n                   can really be any options following the sql tablename.\n   \\return\n       Associative array for this record.\n       May be empty if no record found.\n **/\nfunction GetSingleRec($Table, $Where=\"\")\n{\n  global $PG_CONN;\n\n  $sql = \"SELECT * from $Table $Where limit 1\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n  $row = pg_fetch_assoc($result);\n  pg_free_result($result);\n  return $row;\n}\n\n\n/**\n * \\brief Create an associative array by using table\n *        rows to source the key/value pairs.\n *\n * \\param string $Table   tablename\n * \\param string $KeyCol  Key column name in $Table\n * \\param string $ValCol  Value column name in $Table\n * \\param string $Where   SQL where clause (optional)\n *                 This can really be any clause following the\n *                 table name in the sql\n *\n * \\return\n *  Array[Key] = Val for each row in the table.\n *  May be empty if no table rows or Where results\n *  in no rows.\n **/\nfunction DB2KeyValArray($Table, $KeyCol, $ValCol, $Where=\"\")\n{\n  global $PG_CONN;\n\n  $ResArray = array();\n\n  $sql = \"SELECT $KeyCol, $ValCol from $Table $Where\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n  while ($row = pg_fetch_assoc($result)) {\n    $ResArray[$row[$KeyCol]] = $row[$ValCol];\n  }\n  return $ResArray;\n}\n\n/**\n * \\brief Create an array by using table\n *        rows to source the values.\n *\n * \\param string $Table   tablename\n * \\param string $ValCol  Value column name in $Table\n * \\param string $Uniq    Sort out duplicates\n * \\param string $Where   SQL where clause (optional)\n *                 This can really be any clause following the\n *                 table name in the sql\n *\n * \\return\n *  Array[Key] = Val for each row in the table.\n *  May be empty if no table rows or Where results\n *  in no rows.\n **/\nfunction DB2ValArray($Table, $ValCol, $Uniq=false, $Where=\"\")\n{\n  global $PG_CONN;\n\n  $ResArray = array();\n\n  if ($Uniq) {\n    $sql = \"SELECT DISTINCT $ValCol from $Table $Where\";\n  } else {\n    $sql = \"SELECT $ValCol from $Table $Where\";\n  }\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n  $i = 0;\n  while ($row = pg_fetch_assoc($result)) {\n    $ResArray[$i] = $row[$ValCol];\n    ++ $i;\n  }\n  return $ResArray;\n}\n\n\n/**\n * \\brief Check the postgres result for unexpected errors.\n *  If found, treat them as fatal.\n *\n * \\param $result  command result object\n * \\param string $sql     SQL command (optional)\n * \\param string $filenm  File name (__FILE__)\n * \\param int    $lineno  Line number of the caller (__LINE__)\n *\n * \\return None, prints error, sql and line number, then exits(1)\n **/\nfunction DBCheckResult($result, $sql, $filenm, $lineno)\n{\n  global $PG_CONN;\n\n  if (! $result) {\n    echo \"<hr>File: $filenm, Line number: $lineno<br>\";\n    if (pg_connection_status($PG_CONN) === PGSQL_CONNECTION_OK) {\n      echo pg_last_error($PG_CONN);\n    } else {\n      echo \"FATAL: DB connection lost.\";\n    }\n    echo \"<br> $sql\";\n    debugbacktrace();\n    echo \"<hr>\";\n    exit(1);\n  }\n}\n\n\n/**\n * \\brief Check if table exists.\n * \\note This is postgresql specific.\n *\n * \\param string $tableName Table to check\n *\n * \\return 1 if table exists, 0 if not.\n**/\nfunction DB_TableExists($tableName)\n{\n  global $PG_CONN;\n  global $SysConf;\n\n  $sql = \"select count(*) as count from information_schema.tables where \"\n       . \"table_catalog='{$SysConf['DBCONF']['dbname']}' and table_name='$tableName'\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $count = $row['count'];\n  pg_free_result($result);\n  return($count);\n} /* DB_TableExists()  */\n\n\n/**\n * \\brief Check if a column exists.\n * \\note This is postgresql specific.\n *\n * \\param string $tableName Table to check in\n * \\param string $colName   Column to check\n * \\param string $DBName    Database name, default \"fossology\"\n *\n * \\return 1 if column exists, 0 if not.\n**/\nfunction DB_ColExists($tableName, $colName, $DBName='fossology')\n{\n  global $PG_CONN;\n\n  $sql = \"select count(*) as count from information_schema.columns where \"\n       . \"table_catalog='$DBName' and table_name='$tableName' and column_name='$colName'\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $count = $row['count'];\n  pg_free_result($result);\n  return($count);\n} /* DB_ColExists()  */\n\n\n/**\n * \\brief Check if a constraint exists.\n * \\note This is postgresql specific.\n *\n * \\param string $ConstraintName Constraint to check\n * \\param string $DBName         Database name, default \"fossology\"\n *\n * \\return True if constraint exists, False if not.\n**/\nfunction DB_ConstraintExists($ConstraintName, $DBName='fossology')\n{\n  global $PG_CONN;\n\n  $sql = \"select count(*) as count from information_schema.table_constraints \"\n       . \"where table_catalog='$DBName' and constraint_name='$ConstraintName' limit 1\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $count = $row['count'];\n  pg_free_result($result);\n  if ($count == 1) {\n    return true;\n  }\n  return False;\n} /* DB_ColExists()  */\n\n\n/**\n * \\brief Get last sequence number.\n *\n * This is typically used to get the primary key of a newly inserted record.\n * This must be called immediately after the insert.\n *\n * \\param string $seqname   Sequence Name of key just added\n * \\param string $tablename Table containing $seqname\n *\n * \\return Current sequence number (i.e. the primary key of the rec just added)\n**/\nfunction GetLastSeq($seqname, $tablename)\n{\n  global $PG_CONN;\n\n  $sql = \"SELECT currval('$seqname') as mykey FROM $tablename\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $mykey = $row[\"mykey\"];\n  pg_free_result($result);\n  return($mykey);\n}\n", "<?php\n/*\n SPDX-FileCopyrightText: \u00a9 2011-2013 Hewlett-Packard Development Company, L.P.\n\n SPDX-License-Identifier: GPL-2.0-only\n*/\n\nuse Fossology\\Lib\\Db\\DbManager;\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\n\ndefine(\"TITLE_FOCONFIG\", _(\"Configuration Variables\"));\n\n/**\n * \\class foconfig extend from FO_Plugin\n * \\brief display and set FOSSology configuration\n */\nclass foconfig extends FO_Plugin\n{\n  var $CreateAttempts = 0;\n  /** @var DbManager */\n  private $dbManager;\n\n  function __construct()\n  {\n    $this->Name       = \"foconfig\";\n    $this->Title      = TITLE_FOCONFIG;\n    $this->MenuList   = \"Admin::Customize\";\n    $this->DBaccess   = PLUGIN_DB_ADMIN;\n    $this->PluginLevel = 50;    // run before 'regular' plugins\n    parent::__construct();\n    $this->dbManager = $GLOBALS['container']->get('db.manager');\n  }\n\n  /**\n   * \\brief Generate HTML output.\n   */\n  function HTMLout()\n  {\n    global $PG_CONN;\n    $OutBuf=\"\";\n\n    /* get config rows from sysconfig table */\n    $sql = \"select * from sysconfig order by group_name, group_order\";\n    $result = pg_query($PG_CONN, $sql);\n    DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n    $Group = \"\";\n    $InputStyle = \"style='background-color:#dbf0f7'\";\n    $OutBuf .= '<style> table.myTable > tbody > tr:first-child > td:first-child{width:20%} </style>';\n    $OutBuf .= \"<form method='POST'>\";\n    while ($row = pg_fetch_assoc($result)) {\n      if ($Group != $row['group_name']) {\n        if ($Group) {\n          $OutBuf .= \"</table><br>\";\n        }\n        $Group = $row['group_name'];\n        $OutBuf .= '<table border=1 class=\"myTable table table-striped\" style=\"border-collapse: unset;\">';\n      }\n\n      $OutBuf .= \"<tr><td>$row[ui_label]</td><td>\";\n      switch ($row['vartype']) {\n        case CONFIG_TYPE_INT:\n        case CONFIG_TYPE_TEXT:\n          $ConfVal = htmlentities($row['conf_value']);\n          $OutBuf .= \"<INPUT type='text' name='new[$row[variablename]]' size='70' value='$ConfVal' title='$row[description]' $InputStyle>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_TEXTAREA:\n          $ConfVal = htmlentities($row['conf_value']);\n          $OutBuf .= \"<br><textarea name='new[$row[variablename]]' rows=3 cols=80 title='$row[description]' $InputStyle>$ConfVal</textarea>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_PASSWORD:\n          $ConfVal = htmlentities($row['conf_value']);\n          $OutBuf .= \"<INPUT type='password' name='new[$row[variablename]]' size='70' value='$ConfVal' title='$row[description]' $InputStyle>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_DROP:\n          $ConfVal = htmlentities($row['conf_value']);\n          $Options = explode(\"|\",$row['option_value']);\n          $OutBuf .= \"<select name='new[$row[variablename]]' title='$row[description]' $InputStyle>\";\n          foreach ($Options as $Option) {\n            $matches = array();\n            preg_match('/([ \\\\w]+)[{\u200b\u200b\u200b\u200b](.*)[}\u200b\u200b\u200b\u200b]/', $Option, $matches);\n            $Option_display = $matches[1];\n            $Option_value = $matches[2];\n            $OutBuf .= \"<option $InputStyle value='$Option_value' \";\n            if ($ConfVal == $Option_value) {\n              $OutBuf .= \"selected\";\n            }\n            $OutBuf .= \">$Option_display</option>\";\n          }\n          $OutBuf .= \"</select>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_BOOL:\n          $ConfVal = filter_var($row['conf_value'], FILTER_VALIDATE_BOOLEAN);\n          $checked = $ConfVal ? \"checked\" : \"\";\n          $ConfVal = $ConfVal ? \"true\" : \"false\";\n          $OutBuf .= \"<input type='checkbox' name='new[\" . $row['variablename'] .\n            \"]' id='\" . $row['variablename'] . \"' value='true' title='\" .\n            $row['description'] . \"' $InputStyle $checked />\";\n          $OutBuf .= \"<label for='\" . $row['variablename'] .\n            \"'>\" . $row['description'] . \"</label>\";\n          break;\n        default:\n          $OutBuf .= \"Invalid configuration variable. Unknown type.\";\n      }\n      $OutBuf .= \"</td></tr>\";\n      $OutBuf .= \"<INPUT type='hidden' name='old[$row[variablename]]' value='$ConfVal'>\";\n    }\n    $OutBuf .= \"</table>\";\n    pg_free_result($result);\n\n    $btnlabel = _(\"Update\");\n    $OutBuf .= \"<p><input type='submit' value='$btnlabel'>\";\n    $OutBuf .= \"</form>\";\n\n    return $OutBuf;\n  }\n\n  /**\n   * \\brief Generate output.\n   */\n  function Output()\n  {\n    if ($this->State != PLUGIN_STATE_READY) {\n      return;\n    }\n\n    $newarray = GetParm(\"new\", PARM_RAW);\n    $oldarray = GetParm(\"old\", PARM_RAW);\n\n    if (!empty($newarray)) {\n      // Get missing keys from new array (unchecked checkboxes are not sent)\n      $boolFalseArray = array_diff_key($oldarray, $newarray);\n      foreach ($boolFalseArray as $varname => $value) {\n        // Make sure it was boolean data\n        $isBoolean = $this->dbManager->getSingleRow(\"SELECT 1 FROM sysconfig \" .\n          \"WHERE variablename = $1 AND vartype = \" . CONFIG_TYPE_BOOL,\n          array($varname), __METHOD__ . '.checkIfBool');\n        if (! empty($isBoolean)) {\n          $newarray[$varname] = 'false';\n        }\n      }\n    }\n\n    /* Compare new and old array\n     * and update DB with new values */\n    $UpdateMsg = \"\";\n    $ErrorMsg=\"\";\n    if (! empty($newarray)) {\n      // Fetch endpoints from OIDC documentation\n      if (! empty($newarray[\"OidcDiscoveryURL\"]) &&\n          $newarray[\"OidcDiscoveryURL\"] != $oldarray[\"OidcDiscoveryURL\"]) {\n        $this->updateOidcEndpoints($newarray, $oldarray);\n      }\n      foreach ($newarray as $VarName => $VarValue) {\n        if ($VarValue != $oldarray[$VarName]) {\n          /* get validation_function row from sysconfig table */\n          $sys_array = $this->dbManager->getSingleRow(\"select validation_function, ui_label from sysconfig where variablename=$1\",array($VarName),__METHOD__.'.getVarNameData');\n          $validation_function = $sys_array['validation_function'];\n          $ui_label = $sys_array['ui_label'];\n          $is_empty = empty($validation_function);\n          /* 1. the validation_function is empty\n           2. the validation_function is not empty, and after checking, the value is valid\n          update sysconfig table\n          */\n          if ($is_empty || (! $is_empty && (1 == $validation_function($VarValue)))) {\n            $this->dbManager->getSingleRow(\n              \"update sysconfig set conf_value=$1 where variablename=$2\",\n              array($VarValue, $VarName), __METHOD__ . '.setVarNameData');\n            if (! empty($UpdateMsg)) {\n              $UpdateMsg .= \", \";\n            }\n            $UpdateMsg .= $VarName;\n          } else if (! $is_empty && (0 == $validation_function($VarValue))) {\n            /*\n             * the validation_function is not empty, but after checking, the value\n             * is invalid\n             */\n            if (! strcmp($validation_function, 'check_boolean')) {\n              $warning_msg = _(\n                \"Error: You set $ui_label to $VarValue. Valid  values are 'true' and 'false'.\");\n              echo \"<script>alert('$warning_msg');</script>\";\n            } else if (strpos($validation_function, \"url\")) {\n              $warning_msg = _(\n                \"Error: $ui_label $VarValue, is not a reachable URL.\");\n              echo \"<script>alert('$warning_msg');</script>\";\n            }\n\n            if (! empty($ErrorMsg)) {\n              $ErrorMsg .= \", \";\n            }\n            $ErrorMsg .= $VarName;\n\n          }\n        }\n      }\n      if (! empty($UpdateMsg)) {\n        $UpdateMsg .= _(\" updated.\");\n      }\n      if (! empty($ErrorMsg)) {\n        $ErrorMsg .= _(\" Error occurred.\");\n      }\n    }\n\n    $OutBuf = '';\n    if ($this->OutputType == 'HTML') {\n      $OutBuf .= \"<div>\";\n      if ($UpdateMsg) {\n        $OutBuf .= \"<span style='background-color:#99FF99'>$UpdateMsg</style>\";\n      }\n      if ($ErrorMsg) {\n        $OutBuf .= \"<span style='background-color:#FF8181'>$ErrorMsg</style><hr>\";\n      }\n      $OutBuf .= \"</div> <hr>\";\n      $OutBuf .= $this->HTMLout();\n    }\n    $this->vars['content'] = $OutBuf;\n  }\n\n  /**\n   * @brief Update OIDC endpoints from OIDC discovery document\n   *\n   * Fetch the OIDC discovery document and replace the old values of required\n   * endpoints. Update the values in the newarray.\n   * The function simply returns in case of error.\n   *\n   * @param[in,out] array $newarray Array with new values\n   * @param[in,out] array $oldarray Array with old values\n   */\n  private function updateOidcEndpoints(&$newarray, &$oldarray)\n  {\n    global $SysConf;\n    $client = new Client();\n    $proxy = [];\n    if (array_key_exists('http_proxy', $SysConf['FOSSOLOGY']) &&\n        ! empty($SysConf['FOSSOLOGY']['http_proxy'])) {\n      $proxy['http'] = $SysConf['FOSSOLOGY']['http_proxy'];\n    }\n    if (array_key_exists('https_proxy', $SysConf['FOSSOLOGY']) &&\n        ! empty($SysConf['FOSSOLOGY']['https_proxy'])) {\n      $proxy['https'] = $SysConf['FOSSOLOGY']['https_proxy'];\n    }\n    if (array_key_exists('no_proxy', $SysConf['FOSSOLOGY']) &&\n        ! empty($SysConf['FOSSOLOGY']['no_proxy'])) {\n      $proxy['no'] = explode(',', $SysConf['FOSSOLOGY']['no_proxy']);\n    }\n    try {\n      $res = $client->request(\"GET\", $newarray[\"OidcDiscoveryURL\"], [\n        \"proxy\" => $proxy\n      ]);\n    } catch (RequestException $e) {\n      return;\n    }\n    if ($res->getStatusCode() !== 200) {\n      return;\n    }\n    $body = (string)$res->getBody();\n    $body = json_decode($body, true);\n    // Reset old values to make sure the update happens\n    $oldarray[\"OidcIssuer\"] = \"\";\n    $oldarray[\"OidcAuthorizeURL\"] = \"\";\n    $oldarray[\"OidcAccessTokenURL\"] = \"\";\n    $oldarray[\"OidcResourceURL\"] = \"\";\n    $oldarray[\"OidcJwksURL\"] = \"\";\n    $newarray[\"OidcIssuer\"] = $body[\"issuer\"];\n    $newarray[\"OidcAuthorizeURL\"] = $body[\"authorization_endpoint\"];\n    $newarray[\"OidcAccessTokenURL\"] = $body[\"token_endpoint\"];\n    $newarray[\"OidcResourceURL\"] = $body[\"userinfo_endpoint\"];\n    $newarray[\"OidcJwksURL\"] = $body[\"jwks_uri\"];\n  }\n}\n\n$NewPlugin = new foconfig;\n$NewPlugin->Initialize();"], "fixing_code": ["<?php\n/*\n SPDX-FileCopyrightText: \u00a9 2011-2012 Hewlett-Packard Development Company, L.P.\n SPDX-FileCopyrightText: \u00a9 2017 Siemens AG\n\n SPDX-License-Identifier: LGPL-2.1-only\n*/\n\n/**\n *  \\file\n *  \\brief This file contains common database functions.\n **/\n\n\n/**\n * \\brief Connect to database engine.\n *        This is a no-op if $PG_CONN already has a value.\n *\n * \\param string $sysconfdir fossology configuration directory (location of\n *             Db.conf)\n * \\param string $options an optional list of attributes for\n *             connecting to the database. E.g.:\n *   `\"dbname=text host=text user=text password=text\"`\n * \\param bool   $exitOnFail true (default) to print error and call exit on\n *                  failure false to return $PG_CONN === false on failure\n *\n * If $options is empty, then connection parameters will be read from Db.conf.\n *\n * \\return\n *   Success: $PG_CONN, the postgres connection object \\n\n *   Failure: Error message is printed\n **/\nfunction DBconnect($sysconfdir, $options=\"\", $exitOnFail=true)\n{\n  global $PG_CONN;\n\n  if (! empty($PG_CONN)) {\n    return $PG_CONN;\n  }\n\n  $path=\"$sysconfdir/Db.conf\";\n  if (empty($options)) {\n    $dbConf = file_get_contents($path);\n    if ($exitOnFail && (false === $dbConf)) {\n      $text = _(\"Could not connect to FOSSology database.\");\n      echo \"<h2>$text</h2>\";\n      echo _('permission denied for configuration file');\n      exit();\n    }\n    if (false === $dbConf) {\n      $PG_CONN = false;\n      return;\n    }\n    $options = $dbConf;\n  }\n  if (! empty($options)) {\n    $PG_CONN = pg_connect(str_replace(\";\", \" \", $options));\n  }\n\n  if (! empty($PG_CONN)) {\n    /* success */\n    return $PG_CONN;\n  }\n\n  if ($exitOnFail) {\n    $text = _(\"Could not connect to FOSSology database.\");\n    echo \"<h2>$text</h2>\";\n    exit();\n  }\n  $PG_CONN = false;\n}\n\n\n/**\n   \\brief Retrieve a single database record.\n\n   This function does a:\n   \\code\n   \"SELECT * from $Table $Where limit 1\"\n   \\endcode\n   and returns the result as an associative array.\n\n   \\param string $Table   Table name\n   \\param string $Where   SQL where clause e.g. `\"where uploadtree_pk=2\"`.\n                   Though a WHERE clause is the typical use, $Where\n                   can really be any options following the sql tablename.\n   \\return\n       Associative array for this record.\n       May be empty if no record found.\n **/\nfunction GetSingleRec($Table, $Where=\"\")\n{\n  global $PG_CONN;\n\n  $sql = \"SELECT * from $Table $Where limit 1\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n  $row = pg_fetch_assoc($result);\n  pg_free_result($result);\n  return $row;\n}\n\n\n/**\n * \\brief Create an associative array by using table\n *        rows to source the key/value pairs.\n *\n * \\param string $Table   tablename\n * \\param string $KeyCol  Key column name in $Table\n * \\param string $ValCol  Value column name in $Table\n * \\param string $Where   SQL where clause (optional)\n *                 This can really be any clause following the\n *                 table name in the sql\n *\n * \\return\n *  Array[Key] = Val for each row in the table.\n *  May be empty if no table rows or Where results\n *  in no rows.\n **/\nfunction DB2KeyValArray($Table, $KeyCol, $ValCol, $Where=\"\")\n{\n  global $PG_CONN;\n\n  $ResArray = array();\n\n  $sql = \"SELECT $KeyCol, $ValCol from $Table $Where\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n  while ($row = pg_fetch_assoc($result)) {\n    $ResArray[$row[$KeyCol]] = $row[$ValCol];\n  }\n  return $ResArray;\n}\n\n/**\n * \\brief Create an array by using table\n *        rows to source the values.\n *\n * \\param string $Table   tablename\n * \\param string $ValCol  Value column name in $Table\n * \\param string $Uniq    Sort out duplicates\n * \\param string $Where   SQL where clause (optional)\n *                 This can really be any clause following the\n *                 table name in the sql\n *\n * \\return\n *  Array[Key] = Val for each row in the table.\n *  May be empty if no table rows or Where results\n *  in no rows.\n **/\nfunction DB2ValArray($Table, $ValCol, $Uniq=false, $Where=\"\")\n{\n  global $PG_CONN;\n\n  $ResArray = array();\n\n  if ($Uniq) {\n    $sql = \"SELECT DISTINCT $ValCol from $Table $Where\";\n  } else {\n    $sql = \"SELECT $ValCol from $Table $Where\";\n  }\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n  $i = 0;\n  while ($row = pg_fetch_assoc($result)) {\n    $ResArray[$i] = $row[$ValCol];\n    ++ $i;\n  }\n  return $ResArray;\n}\n\n\n/**\n * \\brief Check the postgres result for unexpected errors.\n *  If found, treat them as fatal.\n *\n * \\param $result  command result object\n * \\param string $sql     SQL command (optional)\n * \\param string $filenm  File name (__FILE__)\n * \\param int    $lineno  Line number of the caller (__LINE__)\n *\n * \\return None, prints error, sql and line number, then exits(1)\n **/\nfunction DBCheckResult($result, $sql, $filenm, $lineno)\n{\n  global $PG_CONN;\n\n  if (! $result) {\n    echo \"<hr>File: $filenm, Line number: $lineno<br>\";\n    if (pg_connection_status($PG_CONN) === PGSQL_CONNECTION_OK) {\n      echo pg_last_error($PG_CONN);\n    } else {\n      echo \"FATAL: DB connection lost.\";\n    }\n    echo \"<br> \".htmlspecialchars($sql);\n    debugbacktrace();\n    echo \"<hr>\";\n    exit(1);\n  }\n}\n\n\n/**\n * \\brief Check if table exists.\n * \\note This is postgresql specific.\n *\n * \\param string $tableName Table to check\n *\n * \\return 1 if table exists, 0 if not.\n**/\nfunction DB_TableExists($tableName)\n{\n  global $PG_CONN;\n  global $SysConf;\n\n  $sql = \"select count(*) as count from information_schema.tables where \"\n       . \"table_catalog='{$SysConf['DBCONF']['dbname']}' and table_name='$tableName'\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $count = $row['count'];\n  pg_free_result($result);\n  return($count);\n} /* DB_TableExists()  */\n\n\n/**\n * \\brief Check if a column exists.\n * \\note This is postgresql specific.\n *\n * \\param string $tableName Table to check in\n * \\param string $colName   Column to check\n * \\param string $DBName    Database name, default \"fossology\"\n *\n * \\return 1 if column exists, 0 if not.\n**/\nfunction DB_ColExists($tableName, $colName, $DBName='fossology')\n{\n  global $PG_CONN;\n\n  $sql = \"select count(*) as count from information_schema.columns where \"\n       . \"table_catalog='$DBName' and table_name='$tableName' and column_name='$colName'\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $count = $row['count'];\n  pg_free_result($result);\n  return($count);\n} /* DB_ColExists()  */\n\n\n/**\n * \\brief Check if a constraint exists.\n * \\note This is postgresql specific.\n *\n * \\param string $ConstraintName Constraint to check\n * \\param string $DBName         Database name, default \"fossology\"\n *\n * \\return True if constraint exists, False if not.\n**/\nfunction DB_ConstraintExists($ConstraintName, $DBName='fossology')\n{\n  global $PG_CONN;\n\n  $sql = \"select count(*) as count from information_schema.table_constraints \"\n       . \"where table_catalog='$DBName' and constraint_name='$ConstraintName' limit 1\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $count = $row['count'];\n  pg_free_result($result);\n  if ($count == 1) {\n    return true;\n  }\n  return False;\n} /* DB_ColExists()  */\n\n\n/**\n * \\brief Get last sequence number.\n *\n * This is typically used to get the primary key of a newly inserted record.\n * This must be called immediately after the insert.\n *\n * \\param string $seqname   Sequence Name of key just added\n * \\param string $tablename Table containing $seqname\n *\n * \\return Current sequence number (i.e. the primary key of the rec just added)\n**/\nfunction GetLastSeq($seqname, $tablename)\n{\n  global $PG_CONN;\n\n  $sql = \"SELECT currval('$seqname') as mykey FROM $tablename\";\n  $result = pg_query($PG_CONN, $sql);\n  DBCheckResult($result, $sql, __FILE__, __LINE__);\n  $row = pg_fetch_assoc($result);\n  $mykey = $row[\"mykey\"];\n  pg_free_result($result);\n  return($mykey);\n}\n", "<?php\n/*\n SPDX-FileCopyrightText: \u00a9 2011-2013 Hewlett-Packard Development Company, L.P.\n\n SPDX-License-Identifier: GPL-2.0-only\n*/\n\nuse Fossology\\Lib\\Db\\DbManager;\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\RequestException;\n\ndefine(\"TITLE_FOCONFIG\", _(\"Configuration Variables\"));\n\n/**\n * \\class foconfig extend from FO_Plugin\n * \\brief display and set FOSSology configuration\n */\nclass foconfig extends FO_Plugin\n{\n  var $CreateAttempts = 0;\n  /** @var DbManager */\n  private $dbManager;\n\n  function __construct()\n  {\n    $this->Name       = \"foconfig\";\n    $this->Title      = TITLE_FOCONFIG;\n    $this->MenuList   = \"Admin::Customize\";\n    $this->DBaccess   = PLUGIN_DB_ADMIN;\n    $this->PluginLevel = 50;    // run before 'regular' plugins\n    parent::__construct();\n    $this->dbManager = $GLOBALS['container']->get('db.manager');\n  }\n\n  /**\n   * \\brief Generate HTML output.\n   */\n  function HTMLout()\n  {\n    global $PG_CONN;\n    $OutBuf=\"\";\n\n    /* get config rows from sysconfig table */\n    $sql = \"select * from sysconfig order by group_name, group_order\";\n    $result = pg_query($PG_CONN, $sql);\n    DBCheckResult($result, $sql, __FILE__, __LINE__);\n\n    $Group = \"\";\n    $InputStyle = \"style='background-color:#dbf0f7'\";\n    $OutBuf .= '<style> table.myTable > tbody > tr:first-child > td:first-child{width:20%} </style>';\n    $OutBuf .= \"<form method='POST'>\";\n    while ($row = pg_fetch_assoc($result)) {\n      if ($Group != $row['group_name']) {\n        if ($Group) {\n          $OutBuf .= \"</table><br>\";\n        }\n        $Group = $row['group_name'];\n        $OutBuf .= '<table border=1 class=\"myTable table table-striped\" style=\"border-collapse: unset;\">';\n      }\n\n      $OutBuf .= \"<tr><td>$row[ui_label]</td><td>\";\n      switch ($row['vartype']) {\n        case CONFIG_TYPE_INT:\n        case CONFIG_TYPE_TEXT:\n          $ConfVal = htmlentities($row['conf_value']);\n          $OutBuf .= \"<INPUT type='text' name='new[$row[variablename]]' size='70' value='$ConfVal' title='$row[description]' $InputStyle>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_TEXTAREA:\n          $ConfVal = htmlentities($row['conf_value']);\n          $OutBuf .= \"<br><textarea name='new[$row[variablename]]' rows=3 cols=80 title='$row[description]' $InputStyle>$ConfVal</textarea>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_PASSWORD:\n          $ConfVal = htmlentities($row['conf_value']);\n          $OutBuf .= \"<INPUT type='password' name='new[$row[variablename]]' size='70' value='$ConfVal' title='$row[description]' $InputStyle>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_DROP:\n          $ConfVal = htmlentities($row['conf_value']);\n          $Options = explode(\"|\",$row['option_value']);\n          $OutBuf .= \"<select name='new[$row[variablename]]' title='$row[description]' $InputStyle>\";\n          foreach ($Options as $Option) {\n            $matches = array();\n            preg_match('/([ \\\\w]+)[{\u200b\u200b\u200b\u200b](.*)[}\u200b\u200b\u200b\u200b]/', $Option, $matches);\n            $Option_display = $matches[1];\n            $Option_value = $matches[2];\n            $OutBuf .= \"<option $InputStyle value='$Option_value' \";\n            if ($ConfVal == $Option_value) {\n              $OutBuf .= \"selected\";\n            }\n            $OutBuf .= \">$Option_display</option>\";\n          }\n          $OutBuf .= \"</select>\";\n          $OutBuf .= \"<br>$row[description]\";\n          break;\n        case CONFIG_TYPE_BOOL:\n          $ConfVal = filter_var($row['conf_value'], FILTER_VALIDATE_BOOLEAN);\n          $checked = $ConfVal ? \"checked\" : \"\";\n          $ConfVal = $ConfVal ? \"true\" : \"false\";\n          $OutBuf .= \"<input type='checkbox' name='new[\" . $row['variablename'] .\n            \"]' id='\" . $row['variablename'] . \"' value='true' title='\" .\n            $row['description'] . \"' $InputStyle $checked />\";\n          $OutBuf .= \"<label for='\" . $row['variablename'] .\n            \"'>\" . $row['description'] . \"</label>\";\n          break;\n        default:\n          $OutBuf .= \"Invalid configuration variable. Unknown type.\";\n      }\n      $OutBuf .= \"</td></tr>\";\n      $OutBuf .= \"<INPUT type='hidden' name='old[$row[variablename]]' value='$ConfVal'>\";\n    }\n    $OutBuf .= \"</table>\";\n    pg_free_result($result);\n\n    $btnlabel = _(\"Update\");\n    $OutBuf .= \"<p><input type='submit' value='$btnlabel'>\";\n    $OutBuf .= \"</form>\";\n\n    return $OutBuf;\n  }\n\n  /**\n   * \\brief Generate output.\n   */\n  function Output()\n  {\n    if ($this->State != PLUGIN_STATE_READY) {\n      return;\n    }\n\n    $newarray = GetParm(\"new\", PARM_RAW);\n    $oldarray = GetParm(\"old\", PARM_RAW);\n\n    if (!empty($newarray)) {\n      // Get missing keys from new array (unchecked checkboxes are not sent)\n      $boolFalseArray = array_diff_key($oldarray, $newarray);\n      foreach ($boolFalseArray as $varname => $value) {\n        // Make sure it was boolean data\n        $isBoolean = $this->dbManager->getSingleRow(\"SELECT 1 FROM sysconfig \" .\n          \"WHERE variablename = $1 AND vartype = \" . CONFIG_TYPE_BOOL,\n          array($varname), __METHOD__ . '.checkIfBool');\n        if (! empty($isBoolean)) {\n          $newarray[$varname] = 'false';\n        }\n      }\n    }\n\n    /* Compare new and old array\n     * and update DB with new values */\n    $UpdateMsg = \"\";\n    $ErrorMsg=\"\";\n    if (! empty($newarray)) {\n      // Fetch endpoints from OIDC documentation\n      if (! empty($newarray[\"OidcDiscoveryURL\"]) &&\n          $newarray[\"OidcDiscoveryURL\"] != $oldarray[\"OidcDiscoveryURL\"]) {\n        $this->updateOidcEndpoints($newarray, $oldarray);\n      }\n      foreach ($newarray as $VarName => $VarValue) {\n        if ($VarValue != $oldarray[$VarName]) {\n          /* get validation_function row from sysconfig table */\n          $sys_array = $this->dbManager->getSingleRow(\"select validation_function, ui_label from sysconfig where variablename=$1\",array($VarName),__METHOD__.'.getVarNameData');\n          $validation_function = $sys_array['validation_function'];\n          $ui_label = $sys_array['ui_label'];\n          $is_empty = empty($validation_function);\n          /* 1. the validation_function is empty\n           2. the validation_function is not empty, and after checking, the value is valid\n          update sysconfig table\n          */\n          if ($is_empty || (! $is_empty && (1 == $validation_function($VarValue)))) {\n            $this->dbManager->getSingleRow(\n              \"update sysconfig set conf_value=$1 where variablename=$2\",\n              array($VarValue, $VarName), __METHOD__ . '.setVarNameData');\n            if (! empty($UpdateMsg)) {\n              $UpdateMsg .= \", \";\n            }\n            $UpdateMsg .= $VarName;\n          } else if (! $is_empty && (0 == $validation_function($VarValue))) {\n            /*\n             * the validation_function is not empty, but after checking, the value\n             * is invalid\n             */\n            if (! strcmp($validation_function, 'check_boolean')) {\n              $warning_msg = _(\n                \"Error: You set $ui_label to \".htmlspecialchars($VarValue).\". Valid  values are 'true' and 'false'.\");\n              echo \"<script>alert('$warning_msg');</script>\";\n            } else if (strpos($validation_function, \"url\")) {\n              $warning_msg = _(\n                \"Error: $ui_label \".htmlspecialchars($VarValue).\", is not a reachable URL.\");\n              echo \"<script>alert('$warning_msg');</script>\";\n            }\n\n            if (! empty($ErrorMsg)) {\n              $ErrorMsg .= \", \";\n            }\n            $ErrorMsg .= $VarName;\n\n          }\n        }\n      }\n      if (! empty($UpdateMsg)) {\n        $UpdateMsg .= _(\" updated.\");\n      }\n      if (! empty($ErrorMsg)) {\n        $ErrorMsg .= _(\" Error occurred.\");\n      }\n    }\n\n    $OutBuf = '';\n    if ($this->OutputType == 'HTML') {\n      $OutBuf .= \"<div>\";\n      if ($UpdateMsg) {\n        $OutBuf .= \"<span style='background-color:#99FF99'>$UpdateMsg</style>\";\n      }\n      if ($ErrorMsg) {\n        $OutBuf .= \"<span style='background-color:#FF8181'>$ErrorMsg</style><hr>\";\n      }\n      $OutBuf .= \"</div> <hr>\";\n      $OutBuf .= $this->HTMLout();\n    }\n    $this->vars['content'] = $OutBuf;\n  }\n\n  /**\n   * @brief Update OIDC endpoints from OIDC discovery document\n   *\n   * Fetch the OIDC discovery document and replace the old values of required\n   * endpoints. Update the values in the newarray.\n   * The function simply returns in case of error.\n   *\n   * @param[in,out] array $newarray Array with new values\n   * @param[in,out] array $oldarray Array with old values\n   */\n  private function updateOidcEndpoints(&$newarray, &$oldarray)\n  {\n    global $SysConf;\n    $client = new Client();\n    $proxy = [];\n    if (array_key_exists('http_proxy', $SysConf['FOSSOLOGY']) &&\n        ! empty($SysConf['FOSSOLOGY']['http_proxy'])) {\n      $proxy['http'] = $SysConf['FOSSOLOGY']['http_proxy'];\n    }\n    if (array_key_exists('https_proxy', $SysConf['FOSSOLOGY']) &&\n        ! empty($SysConf['FOSSOLOGY']['https_proxy'])) {\n      $proxy['https'] = $SysConf['FOSSOLOGY']['https_proxy'];\n    }\n    if (array_key_exists('no_proxy', $SysConf['FOSSOLOGY']) &&\n        ! empty($SysConf['FOSSOLOGY']['no_proxy'])) {\n      $proxy['no'] = explode(',', $SysConf['FOSSOLOGY']['no_proxy']);\n    }\n    try {\n      $res = $client->request(\"GET\", $newarray[\"OidcDiscoveryURL\"], [\n        \"proxy\" => $proxy\n      ]);\n    } catch (RequestException $e) {\n      return;\n    }\n    if ($res->getStatusCode() !== 200) {\n      return;\n    }\n    $body = (string)$res->getBody();\n    $body = json_decode($body, true);\n    // Reset old values to make sure the update happens\n    $oldarray[\"OidcIssuer\"] = \"\";\n    $oldarray[\"OidcAuthorizeURL\"] = \"\";\n    $oldarray[\"OidcAccessTokenURL\"] = \"\";\n    $oldarray[\"OidcResourceURL\"] = \"\";\n    $oldarray[\"OidcJwksURL\"] = \"\";\n    $newarray[\"OidcIssuer\"] = $body[\"issuer\"];\n    $newarray[\"OidcAuthorizeURL\"] = $body[\"authorization_endpoint\"];\n    $newarray[\"OidcAccessTokenURL\"] = $body[\"token_endpoint\"];\n    $newarray[\"OidcResourceURL\"] = $body[\"userinfo_endpoint\"];\n    $newarray[\"OidcJwksURL\"] = $body[\"jwks_uri\"];\n  }\n}\n\n$NewPlugin = new foconfig;\n$NewPlugin->Initialize();"], "filenames": ["src/lib/php/common-db.php", "src/www/ui/admin-config.php"], "buggy_code_start_loc": [198, 185], "buggy_code_end_loc": [199, 190], "fixing_code_start_loc": [198, 185], "fixing_code_end_loc": [199, 190], "type": "CWE-79", "message": "A vulnerability has been found in fossology and classified as problematic. This vulnerability affects unknown code. The manipulation of the argument sql/VarValue leads to cross site scripting. The attack can be initiated remotely. The name of the patch is 8e0eba001662c7eb35f045b70dd458a4643b4553. It is recommended to apply a patch to fix this issue. VDB-217426 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4875", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-04T22:15:09.093", "lastModified": "2023-01-11T01:50:28.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in fossology and classified as problematic. This vulnerability affects unknown code. The manipulation of the argument sql/VarValue leads to cross site scripting. The attack can be initiated remotely. The name of the patch is 8e0eba001662c7eb35f045b70dd458a4643b4553. It is recommended to apply a patch to fix this issue. VDB-217426 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.4, "baseSeverity": "LOW"}, "exploitabilityScore": 0.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:M/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "MULTIPLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 6.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:fossology:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-01-02", "matchCriteriaId": "1E4F3644-CC46-42BB-B818-97126B2DE870"}]}]}], "references": [{"url": "https://github.com/fossology/fossology/commit/8e0eba001662c7eb35f045b70dd458a4643b4553", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fossology/fossology/pull/2356", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217426", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217426", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fossology/fossology/commit/8e0eba001662c7eb35f045b70dd458a4643b4553"}}