{"buggy_code": ["<?php\n// +-----------------------------------------------------------------------+\n// | Piwigo - a PHP based photo gallery                                    |\n// +-----------------------------------------------------------------------+\n// | Copyright(C) 2008-2016 Piwigo Team                  http://piwigo.org |\n// | Copyright(C) 2003-2008 PhpWebGallery Team    http://phpwebgallery.net |\n// | Copyright(C) 2002-2003 Pierrick LE GALL   http://le-gall.net/pierrick |\n// +-----------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify  |\n// | it under the terms of the GNU General Public License as published by  |\n// | the Free Software Foundation                                          |\n// |                                                                       |\n// | This program is distributed in the hope that it will be useful, but   |\n// | WITHOUT ANY WARRANTY; without even the implied warranty of            |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      |\n// | General Public License for more details.                              |\n// |                                                                       |\n// | You should have received a copy of the GNU General Public License     |\n// | along with this program; if not, write to the Free Software           |\n// | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, |\n// | USA.                                                                  |\n// +-----------------------------------------------------------------------+\n\n/**\n * @package functions\\search\n */\n\n\n/**\n * Returns search rules stored into a serialized array in \"search\"\n * table. Each search rules set is numericaly identified.\n *\n * @param int $search_id\n * @return array\n */\nfunction get_search_array($search_id)\n{\n  if (!is_numeric($search_id))\n  {\n    die('Search id must be an integer');\n  }\n\n  $query = '\nSELECT rules\n  FROM '.SEARCH_TABLE.'\n  WHERE id = '.$search_id.'\n;';\n  list($serialized_rules) = pwg_db_fetch_row(pwg_query($query));\n\n  return unserialize($serialized_rules);\n}\n\n/**\n * Returns the SQL clause for a search.\n * Transforms the array returned by get_search_array() into SQL sub-query.\n *\n * @param array $search\n * @return string\n */\nfunction get_sql_search_clause($search)\n{\n  // SQL where clauses are stored in $clauses array during query\n  // construction\n  $clauses = array();\n\n  foreach (array('file','name','comment','author') as $textfield)\n  {\n    if (isset($search['fields'][$textfield]))\n    {\n      $local_clauses = array();\n      foreach ($search['fields'][$textfield]['words'] as $word)\n      {\n        if ('author' == $textfield)\n        {\n          $local_clauses[] = $textfield.\"='\".$word.\"'\";\n        }\n        else\n        {\n          $local_clauses[] = $textfield.\" LIKE '%\".$word.\"%'\";\n        }\n      }\n\n      // adds brackets around where clauses\n      $local_clauses = prepend_append_array_items($local_clauses, '(', ')');\n\n      $clauses[] = implode(\n        ' '.$search['fields'][$textfield]['mode'].' ',\n        $local_clauses\n        );\n    }\n  }\n\n  if (isset($search['fields']['allwords']) and count($search['fields']['allwords']['fields']) > 0)\n  {\n    $fields = array('file', 'name', 'comment');\n\n    if (isset($search['fields']['allwords']['fields']) and count($search['fields']['allwords']['fields']) > 0)\n    {\n      $fields = array_intersect($fields, $search['fields']['allwords']['fields']);\n    }\n\n    // in the OR mode, request bust be :\n    // ((field1 LIKE '%word1%' OR field2 LIKE '%word1%')\n    // OR (field1 LIKE '%word2%' OR field2 LIKE '%word2%'))\n    //\n    // in the AND mode :\n    // ((field1 LIKE '%word1%' OR field2 LIKE '%word1%')\n    // AND (field1 LIKE '%word2%' OR field2 LIKE '%word2%'))\n    $word_clauses = array();\n    foreach ($search['fields']['allwords']['words'] as $word)\n    {\n      $field_clauses = array();\n      foreach ($fields as $field)\n      {\n        $field_clauses[] = $field.\" LIKE '%\".$word.\"%'\";\n      }\n      // adds brackets around where clauses\n      $word_clauses[] = implode(\n        \"\\n          OR \",\n        $field_clauses\n        );\n    }\n\n    array_walk(\n      $word_clauses,\n      create_function('&$s','$s=\"(\".$s.\")\";')\n      );\n\n    // make sure the \"mode\" is either OR or AND\n    if ($search['fields']['allwords']['mode'] != 'AND' and $search['fields']['allwords']['mode'] != 'OR')\n    {\n      $search['fields']['allwords']['mode'] = 'AND';\n    }\n\n    $clauses[] = \"\\n         \".\n      implode(\n        \"\\n         \". $search['fields']['allwords']['mode']. \"\\n         \",\n        $word_clauses\n        );\n  }\n\n  foreach (array('date_available', 'date_creation') as $datefield)\n  {\n    if (isset($search['fields'][$datefield]))\n    {\n      $clauses[] = $datefield.\" = '\".$search['fields'][$datefield]['date'].\"'\";\n    }\n\n    foreach (array('after','before') as $suffix)\n    {\n      $key = $datefield.'-'.$suffix;\n\n      if (isset($search['fields'][$key]))\n      {\n        $clauses[] = $datefield.\n          ($suffix == 'after'             ? ' >' : ' <').\n          ($search['fields'][$key]['inc'] ? '='  : '').\n          \" '\".$search['fields'][$key]['date'].\"'\";\n      }\n    }\n  }\n\n  if (isset($search['fields']['cat']))\n  {\n    if ($search['fields']['cat']['sub_inc'])\n    {\n      // searching all the categories id of sub-categories\n      $cat_ids = get_subcat_ids($search['fields']['cat']['words']);\n    }\n    else\n    {\n      $cat_ids = $search['fields']['cat']['words'];\n    }\n\n    $local_clause = 'category_id IN ('.implode(',', $cat_ids).')';\n    $clauses[] = $local_clause;\n  }\n\n  // adds brackets around where clauses\n  $clauses = prepend_append_array_items($clauses, '(', ')');\n\n  $where_separator =\n    implode(\n      \"\\n    \".$search['mode'].' ',\n      $clauses\n      );\n\n  $search_clause = $where_separator;\n\n  return $search_clause;\n}\n\n/**\n * Returns the list of items corresponding to the advanced search array.\n *\n * @param array $search\n * @param string $images_where optional additional restriction on images table\n * @return array\n */\nfunction get_regular_search_results($search, $images_where='')\n{\n  global $conf, $logger;\n\n  $logger->debug(__FUNCTION__, 'search', $search);\n  \n  $forbidden = get_sql_condition_FandF(\n        array\n          (\n            'forbidden_categories' => 'category_id',\n            'visible_categories' => 'category_id',\n            'visible_images' => 'id'\n          ),\n        \"\\n  AND\"\n    );\n\n  $items = array();\n  $tag_items = array();\n\n  if (isset($search['fields']['search_in_tags']))\n  {\n    $word_clauses = array();\n    foreach ($search['fields']['allwords']['words'] as $word)\n    {\n      $word_clauses[] = \"name LIKE '%\".$word.\"%'\";\n    }\n\n    $query = '\nSELECT\n    id\n  FROM '.TAGS_TABLE.'\n  WHERE '.implode(' OR ', $word_clauses).'\n;';\n    $tag_ids = query2array($query, null, 'id');\n\n    $search_in_tags_items = get_image_ids_for_tags($tag_ids, 'OR');\n\n    $logger->debug(__FUNCTION__.' '.count($search_in_tags_items).' items in $search_in_tags_items');\n  }\n  \n  if (isset($search['fields']['tags']))\n  {\n    $tag_items = get_image_ids_for_tags(\n      $search['fields']['tags']['words'],\n      $search['fields']['tags']['mode']\n      );\n    \n    $logger->debug(__FUNCTION__.' '.count($tag_items).' items in $tag_items');\n  }\n\n  $search_clause = get_sql_search_clause($search);\n\n  if (!empty($search_clause))\n  {\n    $query = '\nSELECT DISTINCT(id)\n  FROM '.IMAGES_TABLE.' i\n    INNER JOIN '.IMAGE_CATEGORY_TABLE.' AS ic ON id = ic.image_id\n  WHERE '.$search_clause;\n    if (!empty($images_where))\n    {\n      $query .= \"\\n  AND \".$images_where;\n    }\n    $query .= $forbidden.'\n  '.$conf['order_by'];\n    $items = array_from_query($query, 'id');\n    \n    $logger->debug(__FUNCTION__.' '.count($items).' items in $items');\n  }\n\n  if (isset($search_in_tags_items))\n  {\n    $items = array_unique(\n      array_merge(\n        $items,\n        $search_in_tags_items\n        )\n      );\n  }\n\n  if ( !empty($tag_items) )\n  {\n    switch ($search['mode'])\n    {\n      case 'AND':\n        if (empty($search_clause) and !isset($search_in_tags_items))\n        {\n          $items = $tag_items;\n        }\n        else\n        {\n          $items = array_values( array_intersect($items, $tag_items) );\n        }\n        break;\n      case 'OR':\n        $items = array_unique(\n          array_merge(\n            $items,\n            $tag_items\n            )\n          );\n        break;\n    }\n  }\n\n  return $items;\n}\n\n\n\ndefine('QST_QUOTED',         0x01);\ndefine('QST_NOT',            0x02);\ndefine('QST_OR',             0x04);\ndefine('QST_WILDCARD_BEGIN', 0x08);\ndefine('QST_WILDCARD_END',   0x10);\ndefine('QST_WILDCARD', QST_WILDCARD_BEGIN|QST_WILDCARD_END);\ndefine('QST_BREAK',          0x20);\n\n/**\n * A search scope applies to a single token and restricts the search to a subset of searchable fields.\n */\nclass QSearchScope\n{\n  var $id;\n  var $aliases;\n  var $is_text;\n  var $nullable;\n\n  function __construct($id, $aliases, $nullable=false, $is_text=true)\n  {\n    $this->id = $id;\n    $this->aliases = $aliases;\n    $this->is_text = $is_text;\n    $this->nullable =$nullable;\n  }\n\n  function parse($token)\n  {\n    if (!$this->nullable && 0==strlen($token->term))\n      return false;\n    return true;\n  }\n  \n  function process_char(&$ch, &$crt_token)\n  {\n    return false;\n  }\n}\n\nclass QNumericRangeScope extends QSearchScope\n{\n  private $epsilon;\n  function __construct($id, $aliases, $nullable=false, $epsilon=0)\n  {\n    parent::__construct($id, $aliases, $nullable, false);\n    $this->epsilon = $epsilon;\n  }\n\n  function parse($token)\n  {\n    $str = $token->term;\n    $strict = array(0,0);\n    if ( ($pos = strpos($str, '..')) !== false)\n      $range = array( substr($str,0,$pos), substr($str, $pos+2));\n    elseif ('>' == @$str[0])// ratio:>1\n    {\n      $range = array( substr($str,1), '');\n      $strict[0] = 1;\n    }\n    elseif ('<' == @$str[0]) // size:<5mp\n    {\n      $range = array('', substr($str,1));\n      $strict[1] = 1;\n    }\n    elseif( ($token->modifier & QST_WILDCARD_BEGIN) )\n      $range = array('', $str);\n    elseif( ($token->modifier & QST_WILDCARD_END) )\n      $range = array($str, '');\n    else\n      $range = array($str, $str);\n\n    foreach ($range as $i =>&$val)\n    {\n      if (preg_match('#^(-?[0-9.]+)/([0-9.]+)$#i', $val, $matches))\n      {\n        $val = floatval($matches[1]/$matches[2]);\n      }\n      elseif (preg_match('/^(-?[0-9.]+)([km])?/i', $val, $matches))\n      {\n        $val = floatval($matches[1]);\n        if (isset($matches[2]))\n        {\n          if ($matches[2]=='k' || $matches[2]=='K')\n          {\n            $val *= 1000;\n            if ($i) $val += 999;\n          }\n          if ($matches[2]=='m' || $matches[2]=='M')\n          {\n            $val *= 1000000;\n            if ($i) $val += 999999;\n          }\n        }\n      }\n      else\n        $val = '';\n      if (is_numeric($val))\n      {\n        if ($i ^ $strict[$i])\n          $val += $this->epsilon;\n        else\n          $val -= $this->epsilon;\n      }\n    }\n\n    if (!$this->nullable && $range[0]=='' && $range[1] == '')\n      return false;\n    $token->scope_data = array( 'range'=>$range, 'strict'=>$strict );\n    return true;\n  }\n\n  function get_sql($field, $token)\n  {\n    $clauses = array();\n    if ($token->scope_data['range'][0]!='')\n      $clauses[] = $field.' >'.($token->scope_data['strict'][0]?'':'=').$token->scope_data['range'][0].' ';\n    if ($token->scope_data['range'][1]!='')\n      $clauses[] = $field.' <'.($token->scope_data['strict'][1]?'':'=').$token->scope_data['range'][1].' ';\n\n    if (empty($clauses))\n    {\n      if ($token->modifier & QST_WILDCARD)\n        return $field.' IS NOT NULL';\n      else\n        return $field.' IS NULL';\n    }\n    return '('.implode(' AND ', $clauses).')';\n  }\n}\n\n\nclass QDateRangeScope extends QSearchScope\n{\n  function __construct($id, $aliases, $nullable=false)\n  {\n    parent::__construct($id, $aliases, $nullable, false);\n  }\n\n  function parse($token)\n  {\n    $str = $token->term;\n    $strict = array(0,0);\n    if ( ($pos = strpos($str, '..')) !== false)\n      $range = array( substr($str,0,$pos), substr($str, $pos+2));\n    elseif ('>' == @$str[0])\n    {\n      $range = array( substr($str,1), '');\n      $strict[0] = 1;\n    }\n    elseif ('<' == @$str[0])\n    {\n      $range = array('', substr($str,1));\n      $strict[1] = 1;\n    }\n    elseif( ($token->modifier & QST_WILDCARD_BEGIN) )\n      $range = array('', $str);\n    elseif( ($token->modifier & QST_WILDCARD_END) )\n      $range = array($str, '');\n    else\n      $range = array($str, $str);\n\n    foreach ($range as $i =>&$val)\n    {\n      if (preg_match('/([0-9]{4})-?((?:1[0-2])|(?:0?[1-9]))?-?((?:(?:[1-3][0-9])|(?:0?[1-9])))?/', $val, $matches))\n      {\n        array_shift($matches);\n        if (!isset($matches[1]))\n          $matches[1] = ($i ^ $strict[$i]) ? 12 : 1;\n        if (!isset($matches[2]))\n          $matches[2] = ($i ^ $strict[$i]) ? 31 : 1;\n        $val = implode('-', $matches);\n        if ($i ^ $strict[$i])\n          $val .= ' 23:59:59';\n      }\n      elseif (strlen($val))\n        return false;\n    }\n\n    if (!$this->nullable && $range[0]=='' && $range[1] == '')\n      return false;\n\n    $token->scope_data = $range;\n    return true;\n  }\n\n  function get_sql($field, $token)\n  {\n    $clauses = array();\n    if ($token->scope_data[0]!='')\n      $clauses[] = $field.' >= \\'' . $token->scope_data[0].'\\'';\n    if ($token->scope_data[1]!='')\n      $clauses[] = $field.' <= \\'' . $token->scope_data[1].'\\'';\n\n    if (empty($clauses))\n    {\n      if ($token->modifier & QST_WILDCARD)\n        return $field.' IS NOT NULL';\n      else\n        return $field.' IS NULL';\n    }\n    return '('.implode(' AND ', $clauses).')';\n  }\n}\n\n/**\n * Analyzes and splits the quick/query search query $q into tokens.\n * q='john bill' => 2 tokens 'john' 'bill'\n * Special characters for MySql full text search (+,<,>,~) appear in the token modifiers.\n * The query can contain a phrase: 'Pierre \"New York\"' will return 'pierre' qnd 'new york'.\n *\n * @param string $q\n */\n\n/** Represents a single word or quoted phrase to be searched.*/\nclass QSingleToken\n{\n  var $is_single = true;\n  var $modifier;\n  var $term; /* the actual word/phrase string*/\n  var $variants = array();\n  var $scope;\n\n  var $scope_data;\n  var $idx;\n\n  function __construct($term, $modifier, $scope)\n  {\n    $this->term = $term;\n    $this->modifier = $modifier;\n    $this->scope = $scope;\n  }\n\n  function __toString()\n  {\n    $s = '';\n    if (isset($this->scope))\n      $s .= $this->scope->id .':';\n    if ($this->modifier & QST_WILDCARD_BEGIN)\n      $s .= '*';\n    if ($this->modifier & QST_QUOTED)\n      $s .= '\"';\n    $s .= $this->term;\n    if ($this->modifier & QST_QUOTED)\n      $s .= '\"';\n    if ($this->modifier & QST_WILDCARD_END)\n      $s .= '*';\n    return $s;\n  }\n}\n\n/** Represents an expression of several words or sub expressions to be searched.*/\nclass QMultiToken\n{\n  var $is_single = false;\n  var $modifier;\n  var $tokens = array(); // the actual array of QSingleToken or QMultiToken\n\n  function __toString()\n  {\n    $s = '';\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      $modifier = $this->tokens[$i]->modifier;\n      if ($i)\n        $s .= ' ';\n      if ($modifier & QST_OR)\n        $s .= 'OR ';\n      if ($modifier & QST_NOT)\n        $s .= 'NOT ';\n      if (! ($this->tokens[$i]->is_single) )\n      {\n        $s .= '(';\n        $s .= $this->tokens[$i];\n        $s .= ')';\n      }\n      else\n      {\n        $s .= $this->tokens[$i];\n      }\n    }\n    return $s;\n  }\n\n  private function push(&$token, &$modifier, &$scope)\n  {\n    if (strlen($token) || (isset($scope) && $scope->nullable))\n    {\n      if (isset($scope))\n        $modifier |= QST_BREAK;\n      $this->tokens[] = new QSingleToken($token, $modifier, $scope);\n    }\n    $token = \"\";\n    $modifier = 0;\n    $scope = null;\n  }\n\n  /**\n  * Parses the input query string by tokenizing the input, generating the modifiers (and/or/not/quotation/wildcards...).\n  * Recursivity occurs when parsing ()\n  * @param string $q the actual query to be parsed\n  * @param int $qi the character index in $q where to start parsing\n  * @param int $level the depth from root in the tree (number of opened and unclosed opening brackets)\n  */\n  protected function parse_expression($q, &$qi, $level, $root)\n  {\n    $crt_token = \"\";\n    $crt_modifier = 0;\n    $crt_scope = null;\n\n    for ($stop=false; !$stop && $qi<strlen($q); $qi++)\n    {\n      $ch = $q[$qi];\n      if ( ($crt_modifier&QST_QUOTED)==0)\n      {\n        switch ($ch)\n        {\n          case '(':\n            if (strlen($crt_token))\n              $this->push($crt_token, $crt_modifier, $crt_scope);\n            $sub = new QMultiToken;\n            $qi++;\n            $sub->parse_expression($q, $qi, $level+1, $root);\n            $sub->modifier = $crt_modifier;\n            if (isset($crt_scope) && $crt_scope->is_text)\n            {\n              $sub->apply_scope($crt_scope); // eg. 'tag:(John OR Bill)'\n            }\n            $this->tokens[] = $sub;\n            $crt_modifier = 0;\n            $crt_scope = null;\n            break;\n          case ')':\n            if ($level>0)\n              $stop = true;\n            break;\n          case ':':\n            $scope = @$root->scopes[strtolower($crt_token)];\n            if (!isset($scope) || isset($crt_scope))\n            { // white space\n              $this->push($crt_token, $crt_modifier, $crt_scope);\n            }\n            else\n            {\n              $crt_token = \"\";\n              $crt_scope = $scope;\n            }\n            break;\n          case '\"':\n            if (strlen($crt_token))\n              $this->push($crt_token, $crt_modifier, $crt_scope);\n            $crt_modifier |= QST_QUOTED;\n            break;\n          case '-':\n            if (strlen($crt_token) || isset($crt_scope))\n              $crt_token .= $ch;\n            else\n              $crt_modifier |= QST_NOT;\n            break;\n          case '*':\n            if (strlen($crt_token))\n              $crt_token .= $ch; // wildcard end later\n            else\n              $crt_modifier |= QST_WILDCARD_BEGIN;\n            break;\n          case '.':\n            if (isset($crt_scope) && !$crt_scope->is_text)\n            {\n              $crt_token .= $ch;\n              break;\n            }\n            if (strlen($crt_token) && preg_match('/[0-9]/', substr($crt_token,-1))\n              && $qi+1<strlen($q) && preg_match('/[0-9]/', $q[$qi+1]))\n            {// dot between digits is not a separator e.g. F2.8\n              $crt_token .= $ch;\n              break;\n            }\n            // else white space go on..\n          default:\n            if (!$crt_scope || !$crt_scope->process_char($ch, $crt_token))\n            {\n              if (strpos(' ,.;!?', $ch)!==false)\n              { // white space\n                $this->push($crt_token, $crt_modifier, $crt_scope);\n              }\n              else\n                $crt_token .= $ch;\n            }\n            break;\n        }\n      }\n      else\n      {// quoted\n        if ($ch=='\"')\n        {\n          if ($qi+1 < strlen($q) && $q[$qi+1]=='*')\n          {\n            $crt_modifier |= QST_WILDCARD_END;\n            $qi++;\n          }\n          $this->push($crt_token, $crt_modifier, $crt_scope);\n        }\n        else\n          $crt_token .= $ch;\n      }\n    }\n\n    $this->push($crt_token, $crt_modifier, $crt_scope);\n\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      $token = $this->tokens[$i];\n      $remove = false;\n      if ($token->is_single)\n      {\n        if ( ($token->modifier & QST_QUOTED)==0\n          && substr($token->term, -1)=='*' )\n        {\n          $token->term = rtrim($token->term, '*');\n          $token->modifier |= QST_WILDCARD_END;\n        }\n\n        if ( !isset($token->scope)\n          && ($token->modifier & (QST_QUOTED|QST_WILDCARD))==0 )\n        {\n          if ('not' == strtolower($token->term))\n          {\n            if ($i+1 < count($this->tokens))\n              $this->tokens[$i+1]->modifier |= QST_NOT;\n            $token->term = \"\";\n          }\n          if ('or' == strtolower($token->term))\n          {\n            if ($i+1 < count($this->tokens))\n              $this->tokens[$i+1]->modifier |= QST_OR;\n            $token->term = \"\";\n          }\n          if ('and' == strtolower($token->term))\n          {\n            $token->term = \"\";\n          }\n        }\n\n        if (!strlen($token->term)\n          && (!isset($token->scope) || !$token->scope->nullable) )\n        {\n          $remove = true;\n        }\n\n        if ( isset($token->scope)\n          && !$token->scope->parse($token))\n          $remove = true;\n      }\n      elseif (!count($token->tokens))\n      {\n          $remove = true;\n      }\n      if ($remove)\n      {\n        array_splice($this->tokens, $i, 1);\n        if ($i<count($this->tokens) && $this->tokens[$i]->is_single)\n        {\n          $this->tokens[$i]->modifier |= QST_BREAK;\n        }\n        $i--;\n      }\n    }\n\n    if ($level>0 && count($this->tokens) && $this->tokens[0]->is_single)\n    {\n      $this->tokens[0]->modifier |= QST_BREAK;\n    }\n  }\n\n  /**\n  * Applies recursively a search scope to all sub single tokens. We allow 'tag:(John Bill)' but we cannot evaluate\n  * scopes on expressions so we rewrite as '(tag:John tag:Bill)'\n  */\n  private function apply_scope(QSearchScope $scope)\n  {\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      if ($this->tokens[$i]->is_single)\n      {\n        if (!isset($this->tokens[$i]->scope))\n          $this->tokens[$i]->scope = $scope;\n      }\n      else\n        $this->tokens[$i]->apply_scope($scope);\n    }\n  }\n\n  private static function priority($modifier)\n  {\n    return $modifier & QST_OR ? 0 :1;\n  }\n\n  /* because evaluations occur left to right, we ensure that 'a OR b c d' is interpreted as 'a OR (b c d)'*/\n  protected function check_operator_priority()\n  {\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      if (!$this->tokens[$i]->is_single)\n        $this->tokens[$i]->check_operator_priority();\n      if ($i==1)\n        $crt_prio = self::priority($this->tokens[$i]->modifier);\n      if ($i<=1)\n        continue;\n      $prio = self::priority($this->tokens[$i]->modifier);\n      if ($prio > $crt_prio)\n      {// e.g. 'a OR b c d' i=2, operator(c)=AND -> prio(AND) > prio(OR) = operator(b)\n        $term_count = 2; // at least b and c to be regrouped\n        for ($j=$i+1; $j<count($this->tokens); $j++)\n        {\n          if (self::priority($this->tokens[$j]->modifier) >= $prio)\n            $term_count++; // also take d\n          else\n            break;\n        }\n\n        $i--; // move pointer to b\n        // crate sub expression (b c d)\n        $sub = new QMultiToken;\n        $sub->tokens = array_splice($this->tokens, $i, $term_count);\n\n        // rewrite ourseleves as a (b c d)\n        array_splice($this->tokens, $i, 0, array($sub));\n        $sub->modifier = $sub->tokens[0]->modifier & QST_OR;\n        $sub->tokens[0]->modifier &= ~QST_OR;\n\n        $sub->check_operator_priority();\n      }\n      else\n        $crt_prio = $prio;\n    }\n  }\n}\n\nclass QExpression extends QMultiToken\n{\n  var $scopes = array();\n  var $stokens = array();\n  var $stoken_modifiers = array();\n\n  function __construct($q, $scopes)\n  {\n    foreach ($scopes as $scope)\n    {\n      $this->scopes[$scope->id] = $scope;\n      foreach ($scope->aliases as $alias)\n        $this->scopes[strtolower($alias)] = $scope;\n    }\n    $i = 0;\n    $this->parse_expression($q, $i, 0, $this);\n    //manipulate the tree so that 'a OR b c' is the same as 'b c OR a'\n    $this->check_operator_priority();\n    $this->build_single_tokens($this, 0);\n  }\n\n  private function build_single_tokens(QMultiToken $expr, $this_is_not)\n  {\n    for ($i=0; $i<count($expr->tokens); $i++)\n    {\n      $token = $expr->tokens[$i];\n      $crt_is_not = ($token->modifier ^ $this_is_not) & QST_NOT; // no negation OR double negation -> no negation;\n\n      if ($token->is_single)\n      {\n        $token->idx = count($this->stokens);\n        $this->stokens[] = $token;\n\n        $modifier = $token->modifier;\n        if ($crt_is_not)\n          $modifier |= QST_NOT;\n        else\n          $modifier &= ~QST_NOT;\n        $this->stoken_modifiers[] = $modifier;\n      }\n      else\n        $this->build_single_tokens($token, $crt_is_not);\n    }\n  }\n}\n\n/**\n  Structure of results being filled from different tables\n*/\nclass QResults\n{\n  var $all_tags;\n  var $tag_ids;\n  var $tag_iids;\n  var $images_iids;\n  var $iids;\n}\n\nfunction qsearch_get_text_token_search_sql($token, $fields)\n{\n  $clauses = array();\n  $variants = array_merge(array($token->term), $token->variants);\n  $fts = array();\n  foreach ($variants as $variant)\n  {\n    $use_ft = mb_strlen($variant)>3;\n    if ($token->modifier & QST_WILDCARD_BEGIN)\n      $use_ft = false;\n    if ($token->modifier & (QST_QUOTED|QST_WILDCARD_END) == (QST_QUOTED|QST_WILDCARD_END))\n      $use_ft = false;\n\n    if ($use_ft)\n    {\n      $max = max( array_map( 'mb_strlen',\n        preg_split('/['.preg_quote('-\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~','/').']+/', $variant)\n        ) );\n      if ($max<4)\n        $use_ft = false;\n    }\n\n    if (!$use_ft)\n    {// odd term or too short for full text search; fallback to regex but unfortunately this is diacritic/accent sensitive\n      $pre = ($token->modifier & QST_WILDCARD_BEGIN) ? '' : '[[:<:]]';\n      $post = ($token->modifier & QST_WILDCARD_END) ? '' : '[[:>:]]';\n      foreach( $fields as $field)\n        $clauses[] = $field.' REGEXP \\''.$pre.addslashes(preg_quote($variant)).$post.'\\'';\n    }\n    else\n    {\n      $ft = $variant;\n      if ($token->modifier & QST_QUOTED)\n        $ft = '\"'.$ft.'\"';\n      if ($token->modifier & QST_WILDCARD_END)\n        $ft .= '*';\n      $fts[] = $ft;\n    }\n  }\n\n  if (count($fts))\n  {\n    $clauses[] = 'MATCH('.implode(', ',$fields).') AGAINST( \\''.addslashes(implode(' ',$fts)).'\\' IN BOOLEAN MODE)';\n  }\n  return $clauses;\n}\n\nfunction qsearch_get_images(QExpression $expr, QResults $qsr)\n{\n  $qsr->images_iids = array_fill(0, count($expr->stokens), array());\n\n  $query_base = 'SELECT id from '.IMAGES_TABLE.' i WHERE\n';\n  for ($i=0; $i<count($expr->stokens); $i++)\n  {\n    $token = $expr->stokens[$i];\n    $scope_id = isset($token->scope) ? $token->scope->id : 'photo';\n    $clauses = array();\n\n    $like = addslashes($token->term);\n    $like = str_replace( array('%','_'), array('\\\\%','\\\\_'), $like); // escape LIKE specials %_\n    $file_like = 'CONVERT(file, CHAR) LIKE \\'%'.$like.'%\\'';\n\n    switch ($scope_id)\n    {\n      case 'photo':\n        $clauses[] = $file_like;\n        $clauses = array_merge($clauses, qsearch_get_text_token_search_sql($token, array('name','comment')));\n        break;\n\n      case 'file':\n        $clauses[] = $file_like;\n        break;\n      case 'author':\n        if ( strlen($token->term) )\n          $clauses = array_merge($clauses, qsearch_get_text_token_search_sql($token, array('author')));\n        elseif ($token->modifier & QST_WILDCARD)\n          $clauses[] = 'author IS NOT NULL';\n        else\n          $clauses[] = 'author IS NULL';\n        break;\n      case 'width':\n      case 'height':\n        $clauses[] = $token->scope->get_sql($scope_id, $token);\n        break;\n      case 'ratio':\n        $clauses[] = $token->scope->get_sql('width/height', $token);\n        break;\n      case 'size':\n        $clauses[] = $token->scope->get_sql('width*height', $token);\n        break;\n      case 'hits':\n        $clauses[] = $token->scope->get_sql('hit', $token);\n        break;\n      case 'score':\n        $clauses[] = $token->scope->get_sql('rating_score', $token);\n        break;\n      case 'filesize':\n        $clauses[] = $token->scope->get_sql('1024*filesize', $token);\n        break;\n      case 'created':\n        $clauses[] = $token->scope->get_sql('date_creation', $token);\n        break;\n      case 'posted':\n        $clauses[] = $token->scope->get_sql('date_available', $token);\n        break;\n      case 'id':\n        $clauses[] = $token->scope->get_sql($scope_id, $token);\n        break;\n      default:\n        // allow plugins to have their own scope with columns added in db by themselves\n        $clauses = trigger_change('qsearch_get_images_sql_scopes', $clauses, $token, $expr);\n        break;\n    }\n    if (!empty($clauses))\n    {\n      $query = $query_base.'('.implode(\"\\n OR \", $clauses).')';\n      $qsr->images_iids[$i] = query2array($query,null,'id');\n    }\n  }\n}\n\nfunction qsearch_get_tags(QExpression $expr, QResults $qsr)\n{\n  $token_tag_ids = $qsr->tag_iids = array_fill(0, count($expr->stokens), array() );\n  $all_tags = array();\n\n  for ($i=0; $i<count($expr->stokens); $i++)\n  {\n    $token = $expr->stokens[$i];\n    if (isset($token->scope) && 'tag' != $token->scope->id)\n      continue;\n    if (empty($token->term))\n      continue;\n\n    $clauses = qsearch_get_text_token_search_sql( $token, array('name'));\n    $query = 'SELECT * FROM '.TAGS_TABLE.'\nWHERE ('. implode(\"\\n OR \",$clauses) .')';\n    $result = pwg_query($query);\n    while ($tag = pwg_db_fetch_assoc($result))\n    {\n      $token_tag_ids[$i][] = $tag['id'];\n      $all_tags[$tag['id']] = $tag;\n    }\n  }\n\n  // check adjacent short words\n  for ($i=0; $i<count($expr->stokens)-1; $i++)\n  {\n    if ( (strlen($expr->stokens[$i]->term)<=3 || strlen($expr->stokens[$i+1]->term)<=3)\n      && (($expr->stoken_modifiers[$i] & (QST_QUOTED|QST_WILDCARD)) == 0)\n      && (($expr->stoken_modifiers[$i+1] & (QST_BREAK|QST_QUOTED|QST_WILDCARD)) == 0) )\n    {\n      $common = array_intersect( $token_tag_ids[$i], $token_tag_ids[$i+1] );\n      if (count($common))\n      {\n        $token_tag_ids[$i] = $token_tag_ids[$i+1] = $common;\n      }\n    }\n  }\n\n  // get images\n  $positive_ids = $not_ids = array();\n  for ($i=0; $i<count($expr->stokens); $i++)\n  {\n    $tag_ids = $token_tag_ids[$i];\n    $token = $expr->stokens[$i];\n\n    if (!empty($tag_ids))\n    {\n      $query = '\nSELECT image_id FROM '.IMAGE_TAG_TABLE.'\n  WHERE tag_id IN ('.implode(',',$tag_ids).')\n  GROUP BY image_id';\n      $qsr->tag_iids[$i] = query2array($query, null, 'image_id');\n      if ($expr->stoken_modifiers[$i]&QST_NOT)\n        $not_ids = array_merge($not_ids, $tag_ids);\n      else\n      {\n        if (strlen($token->term)>2 || count($expr->stokens)==1 || isset($token->scope) || ($token->modifier&(QST_WILDCARD|QST_QUOTED)) )\n        {// add tag ids to list only if the word is not too short (such as de / la /les ...)\n          $positive_ids = array_merge($positive_ids, $tag_ids);\n        }\n      }\n    }\n    elseif (isset($token->scope) && 'tag' == $token->scope->id && strlen($token->term)==0)\n    {\n      if ($token->modifier & QST_WILDCARD)\n      {// eg. 'tag:*' returns all tagged images\n        $qsr->tag_iids[$i] = query2array('SELECT DISTINCT image_id FROM '.IMAGE_TAG_TABLE, null, 'image_id');\n      }\n      else\n      {// eg. 'tag:' returns all untagged images\n        $qsr->tag_iids[$i] = query2array('SELECT id FROM '.IMAGES_TABLE.' LEFT JOIN '.IMAGE_TAG_TABLE.' ON id=image_id WHERE image_id IS NULL', null, 'id');\n      }\n    }\n  }\n\n  $all_tags = array_intersect_key($all_tags, array_flip( array_diff($positive_ids, $not_ids) ) );\n  usort($all_tags, 'tag_alpha_compare');\n  foreach ( $all_tags as &$tag )\n  {\n    $tag['name'] = trigger_change('render_tag_name', $tag['name'], $tag);\n  }\n  $qsr->all_tags = $all_tags;\n  $qsr->tag_ids = $token_tag_ids;\n}\n\n\n\nfunction qsearch_eval(QMultiToken $expr, QResults $qsr, &$qualifies, &$ignored_terms)\n{\n  $qualifies = false; // until we find at least one positive term\n  $ignored_terms = array();\n\n  $ids = $not_ids = array();\n\n  for ($i=0; $i<count($expr->tokens); $i++)\n  {\n    $crt = $expr->tokens[$i];\n    if ($crt->is_single)\n    {\n      $crt_ids = $qsr->iids[$crt->idx] = array_unique( array_merge($qsr->images_iids[$crt->idx], $qsr->tag_iids[$crt->idx]) );\n      $crt_qualifies = count($crt_ids)>0 || count($qsr->tag_ids[$crt->idx])>0;\n      $crt_ignored_terms = $crt_qualifies ? array() : array((string)$crt);\n    }\n    else\n      $crt_ids = qsearch_eval($crt, $qsr, $crt_qualifies, $crt_ignored_terms);\n\n    $modifier = $crt->modifier;\n    if ($modifier & QST_NOT)\n      $not_ids = array_unique( array_merge($not_ids, $crt_ids));\n    else\n    {\n      $ignored_terms = array_merge($ignored_terms, $crt_ignored_terms);\n      if ($modifier & QST_OR)\n      {\n        $ids = array_unique( array_merge($ids, $crt_ids) );\n        $qualifies |= $crt_qualifies;\n      }\n      elseif ($crt_qualifies)\n      {\n        if ($qualifies)\n          $ids = array_intersect($ids, $crt_ids);\n        else\n          $ids = $crt_ids;\n        $qualifies = true;\n      }\n    }\n  }\n\n  if (count($not_ids))\n    $ids = array_diff($ids, $not_ids);\n  return $ids;\n}\n\n\n/**\n * Returns the search results corresponding to a quick/query search.\n * A quick/query search returns many items (search is not strict), but results\n * are sorted by relevance unless $super_order_by is true. Returns:\n *  array (\n *    'items' => array of matching images\n *    'qs'    => array(\n *      'unmatched_terms' => array of terms from the input string that were not matched\n *      'matching_tags' => array of matching tags\n *      'matching_cats' => array of matching categories\n *      'matching_cats_no_images' =>array(99) - matching categories without images\n *      )\n *    )\n *\n * @param string $q\n * @param bool $super_order_by\n * @param string $images_where optional additional restriction on images table\n * @return array\n */\nfunction get_quick_search_results($q, $options)\n{\n  global $persistent_cache, $conf, $user;\n\n  $cache_key = $persistent_cache->make_key( array(\n    strtolower($q),\n    $conf['order_by'],\n    $user['id'],$user['cache_update_time'],\n    isset($options['permissions']) ? (boolean)$options['permissions'] : true,\n    isset($options['images_where']) ? $options['images_where'] : '',\n    ) );\n  if ($persistent_cache->get($cache_key, $res))\n  {\n    return $res;\n  }\n\n  $res = get_quick_search_results_no_cache($q, $options);\n\n  if ( count($res['items']) )\n  {// cache the results only if not empty - otherwise it is useless\n    $persistent_cache->set($cache_key, $res, 300);\n  }\n  return $res;\n}\n\n/**\n * @see get_quick_search_results but without result caching\n */\nfunction get_quick_search_results_no_cache($q, $options)\n{\n  global $conf;\n\n  $q = trim(stripslashes($q));\n  $search_results =\n    array(\n      'items' => array(),\n      'qs' => array('q'=>$q),\n    );\n\n  $q = trigger_change('qsearch_pre', $q);\n\n  $scopes = array();\n  $scopes[] = new QSearchScope('tag', array('tags'));\n  $scopes[] = new QSearchScope('photo', array('photos'));\n  $scopes[] = new QSearchScope('file', array('filename'));\n  $scopes[] = new QSearchScope('author', array(), true);\n  $scopes[] = new QNumericRangeScope('width', array());\n  $scopes[] = new QNumericRangeScope('height', array());\n  $scopes[] = new QNumericRangeScope('ratio', array(), false, 0.001);\n  $scopes[] = new QNumericRangeScope('size', array());\n  $scopes[] = new QNumericRangeScope('filesize', array());\n  $scopes[] = new QNumericRangeScope('hits', array('hit', 'visit', 'visits'));\n  $scopes[] = new QNumericRangeScope('score', array('rating'), true);\n  $scopes[] = new QNumericRangeScope('id', array());\n\n  $createdDateAliases = array('taken', 'shot');\n  $postedDateAliases = array('added');\n  if ($conf['calendar_datefield'] == 'date_creation')\n    $createdDateAliases[] = 'date';\n  else\n    $postedDateAliases[] = 'date';\n  $scopes[] = new QDateRangeScope('created', $createdDateAliases, true);\n  $scopes[] = new QDateRangeScope('posted', $postedDateAliases);\n\n  // allow plugins to add their own scopes\n  $scopes = trigger_change('qsearch_get_scopes', $scopes);\n  $expression = new QExpression($q, $scopes);\n\n  // get inflections for terms\n  $inflector = null;\n  $lang_code = substr(get_default_language(),0,2);\n  @include_once(PHPWG_ROOT_PATH.'include/inflectors/'.$lang_code.'.php');\n  $class_name = 'Inflector_'.$lang_code;\n  if (class_exists($class_name))\n  {\n    $inflector = new $class_name;\n    foreach( $expression->stokens as $token)\n    {\n      if (isset($token->scope) && !$token->scope->is_text)\n        continue;\n      if (strlen($token->term)>2\n        && ($token->modifier & (QST_QUOTED|QST_WILDCARD))==0\n        && strcspn($token->term, '\\'0123456789') == strlen($token->term) )\n      {\n        $token->variants = array_unique( array_diff( $inflector->get_variants($token->term), array($token->term) ) );\n      }\n    }\n  }\n\n\n  trigger_notify('qsearch_expression_parsed', $expression);\n//var_export($expression);\n\n  if (count($expression->stokens)==0)\n  {\n    return $search_results;\n  }\n  $qsr = new QResults;\n  qsearch_get_tags($expression, $qsr);\n  qsearch_get_images($expression, $qsr);\n\n  // allow plugins to evaluate their own scopes\n  trigger_notify('qsearch_before_eval', $expression, $qsr);\n\n  $ids = qsearch_eval($expression, $qsr, $tmp, $search_results['qs']['unmatched_terms']);\n\n  $debug[] = \"<!--\\nparsed: \".$expression;\n  $debug[] = count($expression->stokens).' tokens';\n  for ($i=0; $i<count($expression->stokens); $i++)\n  {\n    $debug[] = $expression->stokens[$i].': '.count($qsr->tag_ids[$i]).' tags, '.count($qsr->tag_iids[$i]).' tiids, '.count($qsr->images_iids[$i]).' iiids, '.count($qsr->iids[$i]).' iids'\n      .' modifier:'.dechex($expression->stoken_modifiers[$i])\n      .( !empty($expression->stokens[$i]->variants) ? ' variants: '.implode(', ',$expression->stokens[$i]->variants): '');\n  }\n  $debug[] = 'before perms '.count($ids);\n\n  $search_results['qs']['matching_tags'] = $qsr->all_tags;\n  $search_results = trigger_change('qsearch_results', $search_results, $expression, $qsr);\n\n  global $template;\n\n  if (empty($ids))\n  {\n    $debug[] = '-->';\n    $template->append('footer_elements', implode(\"\\n\", $debug) );\n    return $search_results;\n  }\n\n  $permissions = !isset($options['permissions']) ? true : $options['permissions'];\n\n  $where_clauses = array();\n  $where_clauses[]='i.id IN ('. implode(',', $ids) . ')';\n  if (!empty($options['images_where']))\n  {\n    $where_clauses[]='('.$options['images_where'].')';\n  }\n  if ($permissions)\n  {\n    $where_clauses[] = get_sql_condition_FandF(\n        array\n          (\n            'forbidden_categories' => 'category_id',\n            'forbidden_images' => 'i.id'\n          ),\n        null,true\n      );\n  }\n\n  $query = '\nSELECT DISTINCT(id) FROM '.IMAGES_TABLE.' i';\n  if ($permissions)\n  {\n    $query .= '\n    INNER JOIN '.IMAGE_CATEGORY_TABLE.' AS ic ON id = ic.image_id';\n  }\n  $query .= '\n  WHERE '.implode(\"\\n AND \", $where_clauses).\"\\n\".\n  $conf['order_by'];\n\n  $ids = query2array($query, null, 'id');\n\n  $debug[] = count($ids).' final photo count -->';\n  $template->append('footer_elements', implode(\"\\n\", $debug) );\n\n  $search_results['items'] = $ids;\n  return $search_results;\n}\n\n/**\n * Returns an array of 'items' corresponding to the search id.\n * It can be either a quick search or a regular search.\n *\n * @param int $search_id\n * @param bool $super_order_by\n * @param string $images_where optional aditional restriction on images table\n * @return array\n */\nfunction get_search_results($search_id, $super_order_by, $images_where='')\n{\n  $search = get_search_array($search_id);\n  if ( !isset($search['q']) )\n  {\n    $result['items'] = get_regular_search_results($search, $images_where);\n    return $result;\n  }\n  else\n  {\n    return get_quick_search_results($search['q'], array('super_order_by'=>$super_order_by, 'images_where'=>$images_where) );\n  }\n}\n\n?>\n"], "fixing_code": ["<?php\n// +-----------------------------------------------------------------------+\n// | Piwigo - a PHP based photo gallery                                    |\n// +-----------------------------------------------------------------------+\n// | Copyright(C) 2008-2016 Piwigo Team                  http://piwigo.org |\n// | Copyright(C) 2003-2008 PhpWebGallery Team    http://phpwebgallery.net |\n// | Copyright(C) 2002-2003 Pierrick LE GALL   http://le-gall.net/pierrick |\n// +-----------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify  |\n// | it under the terms of the GNU General Public License as published by  |\n// | the Free Software Foundation                                          |\n// |                                                                       |\n// | This program is distributed in the hope that it will be useful, but   |\n// | WITHOUT ANY WARRANTY; without even the implied warranty of            |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      |\n// | General Public License for more details.                              |\n// |                                                                       |\n// | You should have received a copy of the GNU General Public License     |\n// | along with this program; if not, write to the Free Software           |\n// | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, |\n// | USA.                                                                  |\n// +-----------------------------------------------------------------------+\n\n/**\n * @package functions\\search\n */\n\n\n/**\n * Returns search rules stored into a serialized array in \"search\"\n * table. Each search rules set is numericaly identified.\n *\n * @param int $search_id\n * @return array\n */\nfunction get_search_array($search_id)\n{\n  if (!is_numeric($search_id))\n  {\n    die('Search id must be an integer');\n  }\n\n  $query = '\nSELECT rules\n  FROM '.SEARCH_TABLE.'\n  WHERE id = '.$search_id.'\n;';\n  list($serialized_rules) = pwg_db_fetch_row(pwg_query($query));\n\n  return unserialize($serialized_rules);\n}\n\n/**\n * Returns the SQL clause for a search.\n * Transforms the array returned by get_search_array() into SQL sub-query.\n *\n * @param array $search\n * @return string\n */\nfunction get_sql_search_clause($search)\n{\n  // SQL where clauses are stored in $clauses array during query\n  // construction\n  $clauses = array();\n\n  foreach (array('file','name','comment','author') as $textfield)\n  {\n    if (isset($search['fields'][$textfield]))\n    {\n      $local_clauses = array();\n      foreach ($search['fields'][$textfield]['words'] as $word)\n      {\n        if ('author' == $textfield)\n        {\n          $local_clauses[] = $textfield.\"='\".$word.\"'\";\n        }\n        else\n        {\n          $local_clauses[] = $textfield.\" LIKE '%\".$word.\"%'\";\n        }\n      }\n\n      // adds brackets around where clauses\n      $local_clauses = prepend_append_array_items($local_clauses, '(', ')');\n\n      $clauses[] = implode(\n        ' '.$search['fields'][$textfield]['mode'].' ',\n        $local_clauses\n        );\n    }\n  }\n\n  if (isset($search['fields']['allwords']) and count($search['fields']['allwords']['fields']) > 0)\n  {\n    $fields = array('file', 'name', 'comment');\n\n    if (isset($search['fields']['allwords']['fields']) and count($search['fields']['allwords']['fields']) > 0)\n    {\n      $fields = array_intersect($fields, $search['fields']['allwords']['fields']);\n    }\n\n    // in the OR mode, request bust be :\n    // ((field1 LIKE '%word1%' OR field2 LIKE '%word1%')\n    // OR (field1 LIKE '%word2%' OR field2 LIKE '%word2%'))\n    //\n    // in the AND mode :\n    // ((field1 LIKE '%word1%' OR field2 LIKE '%word1%')\n    // AND (field1 LIKE '%word2%' OR field2 LIKE '%word2%'))\n    $word_clauses = array();\n    foreach ($search['fields']['allwords']['words'] as $word)\n    {\n      $field_clauses = array();\n      foreach ($fields as $field)\n      {\n        $field_clauses[] = $field.\" LIKE '%\".$word.\"%'\";\n      }\n      // adds brackets around where clauses\n      $word_clauses[] = implode(\n        \"\\n          OR \",\n        $field_clauses\n        );\n    }\n\n    array_walk(\n      $word_clauses,\n      create_function('&$s','$s=\"(\".$s.\")\";')\n      );\n\n    // make sure the \"mode\" is either OR or AND\n    if ($search['fields']['allwords']['mode'] != 'AND' and $search['fields']['allwords']['mode'] != 'OR')\n    {\n      $search['fields']['allwords']['mode'] = 'AND';\n    }\n\n    $clauses[] = \"\\n         \".\n      implode(\n        \"\\n         \". $search['fields']['allwords']['mode']. \"\\n         \",\n        $word_clauses\n        );\n  }\n\n  foreach (array('date_available', 'date_creation') as $datefield)\n  {\n    if (isset($search['fields'][$datefield]))\n    {\n      $clauses[] = $datefield.\" = '\".$search['fields'][$datefield]['date'].\"'\";\n    }\n\n    foreach (array('after','before') as $suffix)\n    {\n      $key = $datefield.'-'.$suffix;\n\n      if (isset($search['fields'][$key]))\n      {\n        $clauses[] = $datefield.\n          ($suffix == 'after'             ? ' >' : ' <').\n          ($search['fields'][$key]['inc'] ? '='  : '').\n          \" '\".$search['fields'][$key]['date'].\"'\";\n      }\n    }\n  }\n\n  if (isset($search['fields']['cat']))\n  {\n    if ($search['fields']['cat']['sub_inc'])\n    {\n      // searching all the categories id of sub-categories\n      $cat_ids = get_subcat_ids($search['fields']['cat']['words']);\n    }\n    else\n    {\n      $cat_ids = $search['fields']['cat']['words'];\n    }\n\n    $local_clause = 'category_id IN ('.implode(',', $cat_ids).')';\n    $clauses[] = $local_clause;\n  }\n\n  // adds brackets around where clauses\n  $clauses = prepend_append_array_items($clauses, '(', ')');\n\n  $where_separator =\n    implode(\n      \"\\n    \".$search['mode'].' ',\n      $clauses\n      );\n\n  $search_clause = $where_separator;\n\n  return $search_clause;\n}\n\n/**\n * Returns the list of items corresponding to the advanced search array.\n *\n * @param array $search\n * @param string $images_where optional additional restriction on images table\n * @return array\n */\nfunction get_regular_search_results($search, $images_where='')\n{\n  global $conf, $logger;\n\n  $logger->debug(__FUNCTION__, 'search', $search);\n  \n  $forbidden = get_sql_condition_FandF(\n        array\n          (\n            'forbidden_categories' => 'category_id',\n            'visible_categories' => 'category_id',\n            'visible_images' => 'id'\n          ),\n        \"\\n  AND\"\n    );\n\n  $items = array();\n  $tag_items = array();\n\n  if (isset($search['fields']['search_in_tags']))\n  {\n    $word_clauses = array();\n    foreach ($search['fields']['allwords']['words'] as $word)\n    {\n      $word_clauses[] = \"name LIKE '%\".$word.\"%'\";\n    }\n\n    $query = '\nSELECT\n    id\n  FROM '.TAGS_TABLE.'\n  WHERE '.implode(' OR ', $word_clauses).'\n;';\n    $tag_ids = query2array($query, null, 'id');\n\n    $search_in_tags_items = get_image_ids_for_tags($tag_ids, 'OR');\n\n    $logger->debug(__FUNCTION__.' '.count($search_in_tags_items).' items in $search_in_tags_items');\n  }\n  \n  if (isset($search['fields']['tags']))\n  {\n    $tag_items = get_image_ids_for_tags(\n      $search['fields']['tags']['words'],\n      $search['fields']['tags']['mode']\n      );\n    \n    $logger->debug(__FUNCTION__.' '.count($tag_items).' items in $tag_items');\n  }\n\n  $search_clause = get_sql_search_clause($search);\n\n  if (!empty($search_clause))\n  {\n    $query = '\nSELECT DISTINCT(id)\n  FROM '.IMAGES_TABLE.' i\n    INNER JOIN '.IMAGE_CATEGORY_TABLE.' AS ic ON id = ic.image_id\n  WHERE '.$search_clause;\n    if (!empty($images_where))\n    {\n      $query .= \"\\n  AND \".$images_where;\n    }\n    $query .= $forbidden.'\n  '.$conf['order_by'];\n    $items = array_from_query($query, 'id');\n    \n    $logger->debug(__FUNCTION__.' '.count($items).' items in $items');\n  }\n\n  if (isset($search_in_tags_items))\n  {\n    $items = array_unique(\n      array_merge(\n        $items,\n        $search_in_tags_items\n        )\n      );\n  }\n\n  if ( !empty($tag_items) )\n  {\n    switch ($search['mode'])\n    {\n      case 'AND':\n        if (empty($search_clause) and !isset($search_in_tags_items))\n        {\n          $items = $tag_items;\n        }\n        else\n        {\n          $items = array_values( array_intersect($items, $tag_items) );\n        }\n        break;\n      case 'OR':\n        $items = array_unique(\n          array_merge(\n            $items,\n            $tag_items\n            )\n          );\n        break;\n    }\n  }\n\n  return $items;\n}\n\n\n\ndefine('QST_QUOTED',         0x01);\ndefine('QST_NOT',            0x02);\ndefine('QST_OR',             0x04);\ndefine('QST_WILDCARD_BEGIN', 0x08);\ndefine('QST_WILDCARD_END',   0x10);\ndefine('QST_WILDCARD', QST_WILDCARD_BEGIN|QST_WILDCARD_END);\ndefine('QST_BREAK',          0x20);\n\n/**\n * A search scope applies to a single token and restricts the search to a subset of searchable fields.\n */\nclass QSearchScope\n{\n  var $id;\n  var $aliases;\n  var $is_text;\n  var $nullable;\n\n  function __construct($id, $aliases, $nullable=false, $is_text=true)\n  {\n    $this->id = $id;\n    $this->aliases = $aliases;\n    $this->is_text = $is_text;\n    $this->nullable =$nullable;\n  }\n\n  function parse($token)\n  {\n    if (!$this->nullable && 0==strlen($token->term))\n      return false;\n    return true;\n  }\n  \n  function process_char(&$ch, &$crt_token)\n  {\n    return false;\n  }\n}\n\nclass QNumericRangeScope extends QSearchScope\n{\n  private $epsilon;\n  function __construct($id, $aliases, $nullable=false, $epsilon=0)\n  {\n    parent::__construct($id, $aliases, $nullable, false);\n    $this->epsilon = $epsilon;\n  }\n\n  function parse($token)\n  {\n    $str = $token->term;\n    $strict = array(0,0);\n    if ( ($pos = strpos($str, '..')) !== false)\n      $range = array( substr($str,0,$pos), substr($str, $pos+2));\n    elseif ('>' == @$str[0])// ratio:>1\n    {\n      $range = array( substr($str,1), '');\n      $strict[0] = 1;\n    }\n    elseif ('<' == @$str[0]) // size:<5mp\n    {\n      $range = array('', substr($str,1));\n      $strict[1] = 1;\n    }\n    elseif( ($token->modifier & QST_WILDCARD_BEGIN) )\n      $range = array('', $str);\n    elseif( ($token->modifier & QST_WILDCARD_END) )\n      $range = array($str, '');\n    else\n      $range = array($str, $str);\n\n    foreach ($range as $i =>&$val)\n    {\n      if (preg_match('#^(-?[0-9.]+)/([0-9.]+)$#i', $val, $matches))\n      {\n        $val = floatval($matches[1]/$matches[2]);\n      }\n      elseif (preg_match('/^(-?[0-9.]+)([km])?/i', $val, $matches))\n      {\n        $val = floatval($matches[1]);\n        if (isset($matches[2]))\n        {\n          if ($matches[2]=='k' || $matches[2]=='K')\n          {\n            $val *= 1000;\n            if ($i) $val += 999;\n          }\n          if ($matches[2]=='m' || $matches[2]=='M')\n          {\n            $val *= 1000000;\n            if ($i) $val += 999999;\n          }\n        }\n      }\n      else\n        $val = '';\n      if (is_numeric($val))\n      {\n        if ($i ^ $strict[$i])\n          $val += $this->epsilon;\n        else\n          $val -= $this->epsilon;\n      }\n    }\n\n    if (!$this->nullable && $range[0]=='' && $range[1] == '')\n      return false;\n    $token->scope_data = array( 'range'=>$range, 'strict'=>$strict );\n    return true;\n  }\n\n  function get_sql($field, $token)\n  {\n    $clauses = array();\n    if ($token->scope_data['range'][0]!='')\n      $clauses[] = $field.' >'.($token->scope_data['strict'][0]?'':'=').$token->scope_data['range'][0].' ';\n    if ($token->scope_data['range'][1]!='')\n      $clauses[] = $field.' <'.($token->scope_data['strict'][1]?'':'=').$token->scope_data['range'][1].' ';\n\n    if (empty($clauses))\n    {\n      if ($token->modifier & QST_WILDCARD)\n        return $field.' IS NOT NULL';\n      else\n        return $field.' IS NULL';\n    }\n    return '('.implode(' AND ', $clauses).')';\n  }\n}\n\n\nclass QDateRangeScope extends QSearchScope\n{\n  function __construct($id, $aliases, $nullable=false)\n  {\n    parent::__construct($id, $aliases, $nullable, false);\n  }\n\n  function parse($token)\n  {\n    $str = $token->term;\n    $strict = array(0,0);\n    if ( ($pos = strpos($str, '..')) !== false)\n      $range = array( substr($str,0,$pos), substr($str, $pos+2));\n    elseif ('>' == @$str[0])\n    {\n      $range = array( substr($str,1), '');\n      $strict[0] = 1;\n    }\n    elseif ('<' == @$str[0])\n    {\n      $range = array('', substr($str,1));\n      $strict[1] = 1;\n    }\n    elseif( ($token->modifier & QST_WILDCARD_BEGIN) )\n      $range = array('', $str);\n    elseif( ($token->modifier & QST_WILDCARD_END) )\n      $range = array($str, '');\n    else\n      $range = array($str, $str);\n\n    foreach ($range as $i =>&$val)\n    {\n      if (preg_match('/([0-9]{4})-?((?:1[0-2])|(?:0?[1-9]))?-?((?:(?:[1-3][0-9])|(?:0?[1-9])))?/', $val, $matches))\n      {\n        array_shift($matches);\n        if (!isset($matches[1]))\n          $matches[1] = ($i ^ $strict[$i]) ? 12 : 1;\n        if (!isset($matches[2]))\n          $matches[2] = ($i ^ $strict[$i]) ? 31 : 1;\n        $val = implode('-', $matches);\n        if ($i ^ $strict[$i])\n          $val .= ' 23:59:59';\n      }\n      elseif (strlen($val))\n        return false;\n    }\n\n    if (!$this->nullable && $range[0]=='' && $range[1] == '')\n      return false;\n\n    $token->scope_data = $range;\n    return true;\n  }\n\n  function get_sql($field, $token)\n  {\n    $clauses = array();\n    if ($token->scope_data[0]!='')\n      $clauses[] = $field.' >= \\'' . $token->scope_data[0].'\\'';\n    if ($token->scope_data[1]!='')\n      $clauses[] = $field.' <= \\'' . $token->scope_data[1].'\\'';\n\n    if (empty($clauses))\n    {\n      if ($token->modifier & QST_WILDCARD)\n        return $field.' IS NOT NULL';\n      else\n        return $field.' IS NULL';\n    }\n    return '('.implode(' AND ', $clauses).')';\n  }\n}\n\n/**\n * Analyzes and splits the quick/query search query $q into tokens.\n * q='john bill' => 2 tokens 'john' 'bill'\n * Special characters for MySql full text search (+,<,>,~) appear in the token modifiers.\n * The query can contain a phrase: 'Pierre \"New York\"' will return 'pierre' qnd 'new york'.\n *\n * @param string $q\n */\n\n/** Represents a single word or quoted phrase to be searched.*/\nclass QSingleToken\n{\n  var $is_single = true;\n  var $modifier;\n  var $term; /* the actual word/phrase string*/\n  var $variants = array();\n  var $scope;\n\n  var $scope_data;\n  var $idx;\n\n  function __construct($term, $modifier, $scope)\n  {\n    $this->term = $term;\n    $this->modifier = $modifier;\n    $this->scope = $scope;\n  }\n\n  function __toString()\n  {\n    $s = '';\n    if (isset($this->scope))\n      $s .= $this->scope->id .':';\n    if ($this->modifier & QST_WILDCARD_BEGIN)\n      $s .= '*';\n    if ($this->modifier & QST_QUOTED)\n      $s .= '\"';\n    $s .= $this->term;\n    if ($this->modifier & QST_QUOTED)\n      $s .= '\"';\n    if ($this->modifier & QST_WILDCARD_END)\n      $s .= '*';\n    return $s;\n  }\n}\n\n/** Represents an expression of several words or sub expressions to be searched.*/\nclass QMultiToken\n{\n  var $is_single = false;\n  var $modifier;\n  var $tokens = array(); // the actual array of QSingleToken or QMultiToken\n\n  function __toString()\n  {\n    $s = '';\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      $modifier = $this->tokens[$i]->modifier;\n      if ($i)\n        $s .= ' ';\n      if ($modifier & QST_OR)\n        $s .= 'OR ';\n      if ($modifier & QST_NOT)\n        $s .= 'NOT ';\n      if (! ($this->tokens[$i]->is_single) )\n      {\n        $s .= '(';\n        $s .= $this->tokens[$i];\n        $s .= ')';\n      }\n      else\n      {\n        $s .= $this->tokens[$i];\n      }\n    }\n    return $s;\n  }\n\n  private function push(&$token, &$modifier, &$scope)\n  {\n    if (strlen($token) || (isset($scope) && $scope->nullable))\n    {\n      if (isset($scope))\n        $modifier |= QST_BREAK;\n      $this->tokens[] = new QSingleToken($token, $modifier, $scope);\n    }\n    $token = \"\";\n    $modifier = 0;\n    $scope = null;\n  }\n\n  /**\n  * Parses the input query string by tokenizing the input, generating the modifiers (and/or/not/quotation/wildcards...).\n  * Recursivity occurs when parsing ()\n  * @param string $q the actual query to be parsed\n  * @param int $qi the character index in $q where to start parsing\n  * @param int $level the depth from root in the tree (number of opened and unclosed opening brackets)\n  */\n  protected function parse_expression($q, &$qi, $level, $root)\n  {\n    $crt_token = \"\";\n    $crt_modifier = 0;\n    $crt_scope = null;\n\n    for ($stop=false; !$stop && $qi<strlen($q); $qi++)\n    {\n      $ch = $q[$qi];\n      if ( ($crt_modifier&QST_QUOTED)==0)\n      {\n        switch ($ch)\n        {\n          case '(':\n            if (strlen($crt_token))\n              $this->push($crt_token, $crt_modifier, $crt_scope);\n            $sub = new QMultiToken;\n            $qi++;\n            $sub->parse_expression($q, $qi, $level+1, $root);\n            $sub->modifier = $crt_modifier;\n            if (isset($crt_scope) && $crt_scope->is_text)\n            {\n              $sub->apply_scope($crt_scope); // eg. 'tag:(John OR Bill)'\n            }\n            $this->tokens[] = $sub;\n            $crt_modifier = 0;\n            $crt_scope = null;\n            break;\n          case ')':\n            if ($level>0)\n              $stop = true;\n            break;\n          case ':':\n            $scope = @$root->scopes[strtolower($crt_token)];\n            if (!isset($scope) || isset($crt_scope))\n            { // white space\n              $this->push($crt_token, $crt_modifier, $crt_scope);\n            }\n            else\n            {\n              $crt_token = \"\";\n              $crt_scope = $scope;\n            }\n            break;\n          case '\"':\n            if (strlen($crt_token))\n              $this->push($crt_token, $crt_modifier, $crt_scope);\n            $crt_modifier |= QST_QUOTED;\n            break;\n          case '-':\n            if (strlen($crt_token) || isset($crt_scope))\n              $crt_token .= $ch;\n            else\n              $crt_modifier |= QST_NOT;\n            break;\n          case '*':\n            if (strlen($crt_token))\n              $crt_token .= $ch; // wildcard end later\n            else\n              $crt_modifier |= QST_WILDCARD_BEGIN;\n            break;\n          case '.':\n            if (isset($crt_scope) && !$crt_scope->is_text)\n            {\n              $crt_token .= $ch;\n              break;\n            }\n            if (strlen($crt_token) && preg_match('/[0-9]/', substr($crt_token,-1))\n              && $qi+1<strlen($q) && preg_match('/[0-9]/', $q[$qi+1]))\n            {// dot between digits is not a separator e.g. F2.8\n              $crt_token .= $ch;\n              break;\n            }\n            // else white space go on..\n          default:\n            if (!$crt_scope || !$crt_scope->process_char($ch, $crt_token))\n            {\n              if (strpos(' ,.;!?', $ch)!==false)\n              { // white space\n                $this->push($crt_token, $crt_modifier, $crt_scope);\n              }\n              else\n                $crt_token .= $ch;\n            }\n            break;\n        }\n      }\n      else\n      {// quoted\n        if ($ch=='\"')\n        {\n          if ($qi+1 < strlen($q) && $q[$qi+1]=='*')\n          {\n            $crt_modifier |= QST_WILDCARD_END;\n            $qi++;\n          }\n          $this->push($crt_token, $crt_modifier, $crt_scope);\n        }\n        else\n          $crt_token .= $ch;\n      }\n    }\n\n    $this->push($crt_token, $crt_modifier, $crt_scope);\n\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      $token = $this->tokens[$i];\n      $remove = false;\n      if ($token->is_single)\n      {\n        if ( ($token->modifier & QST_QUOTED)==0\n          && substr($token->term, -1)=='*' )\n        {\n          $token->term = rtrim($token->term, '*');\n          $token->modifier |= QST_WILDCARD_END;\n        }\n\n        if ( !isset($token->scope)\n          && ($token->modifier & (QST_QUOTED|QST_WILDCARD))==0 )\n        {\n          if ('not' == strtolower($token->term))\n          {\n            if ($i+1 < count($this->tokens))\n              $this->tokens[$i+1]->modifier |= QST_NOT;\n            $token->term = \"\";\n          }\n          if ('or' == strtolower($token->term))\n          {\n            if ($i+1 < count($this->tokens))\n              $this->tokens[$i+1]->modifier |= QST_OR;\n            $token->term = \"\";\n          }\n          if ('and' == strtolower($token->term))\n          {\n            $token->term = \"\";\n          }\n        }\n\n        if (!strlen($token->term)\n          && (!isset($token->scope) || !$token->scope->nullable) )\n        {\n          $remove = true;\n        }\n\n        if ( isset($token->scope)\n          && !$token->scope->parse($token))\n          $remove = true;\n      }\n      elseif (!count($token->tokens))\n      {\n          $remove = true;\n      }\n      if ($remove)\n      {\n        array_splice($this->tokens, $i, 1);\n        if ($i<count($this->tokens) && $this->tokens[$i]->is_single)\n        {\n          $this->tokens[$i]->modifier |= QST_BREAK;\n        }\n        $i--;\n      }\n    }\n\n    if ($level>0 && count($this->tokens) && $this->tokens[0]->is_single)\n    {\n      $this->tokens[0]->modifier |= QST_BREAK;\n    }\n  }\n\n  /**\n  * Applies recursively a search scope to all sub single tokens. We allow 'tag:(John Bill)' but we cannot evaluate\n  * scopes on expressions so we rewrite as '(tag:John tag:Bill)'\n  */\n  private function apply_scope(QSearchScope $scope)\n  {\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      if ($this->tokens[$i]->is_single)\n      {\n        if (!isset($this->tokens[$i]->scope))\n          $this->tokens[$i]->scope = $scope;\n      }\n      else\n        $this->tokens[$i]->apply_scope($scope);\n    }\n  }\n\n  private static function priority($modifier)\n  {\n    return $modifier & QST_OR ? 0 :1;\n  }\n\n  /* because evaluations occur left to right, we ensure that 'a OR b c d' is interpreted as 'a OR (b c d)'*/\n  protected function check_operator_priority()\n  {\n    for ($i=0; $i<count($this->tokens); $i++)\n    {\n      if (!$this->tokens[$i]->is_single)\n        $this->tokens[$i]->check_operator_priority();\n      if ($i==1)\n        $crt_prio = self::priority($this->tokens[$i]->modifier);\n      if ($i<=1)\n        continue;\n      $prio = self::priority($this->tokens[$i]->modifier);\n      if ($prio > $crt_prio)\n      {// e.g. 'a OR b c d' i=2, operator(c)=AND -> prio(AND) > prio(OR) = operator(b)\n        $term_count = 2; // at least b and c to be regrouped\n        for ($j=$i+1; $j<count($this->tokens); $j++)\n        {\n          if (self::priority($this->tokens[$j]->modifier) >= $prio)\n            $term_count++; // also take d\n          else\n            break;\n        }\n\n        $i--; // move pointer to b\n        // crate sub expression (b c d)\n        $sub = new QMultiToken;\n        $sub->tokens = array_splice($this->tokens, $i, $term_count);\n\n        // rewrite ourseleves as a (b c d)\n        array_splice($this->tokens, $i, 0, array($sub));\n        $sub->modifier = $sub->tokens[0]->modifier & QST_OR;\n        $sub->tokens[0]->modifier &= ~QST_OR;\n\n        $sub->check_operator_priority();\n      }\n      else\n        $crt_prio = $prio;\n    }\n  }\n}\n\nclass QExpression extends QMultiToken\n{\n  var $scopes = array();\n  var $stokens = array();\n  var $stoken_modifiers = array();\n\n  function __construct($q, $scopes)\n  {\n    foreach ($scopes as $scope)\n    {\n      $this->scopes[$scope->id] = $scope;\n      foreach ($scope->aliases as $alias)\n        $this->scopes[strtolower($alias)] = $scope;\n    }\n    $i = 0;\n    $this->parse_expression($q, $i, 0, $this);\n    //manipulate the tree so that 'a OR b c' is the same as 'b c OR a'\n    $this->check_operator_priority();\n    $this->build_single_tokens($this, 0);\n  }\n\n  private function build_single_tokens(QMultiToken $expr, $this_is_not)\n  {\n    for ($i=0; $i<count($expr->tokens); $i++)\n    {\n      $token = $expr->tokens[$i];\n      $crt_is_not = ($token->modifier ^ $this_is_not) & QST_NOT; // no negation OR double negation -> no negation;\n\n      if ($token->is_single)\n      {\n        $token->idx = count($this->stokens);\n        $this->stokens[] = $token;\n\n        $modifier = $token->modifier;\n        if ($crt_is_not)\n          $modifier |= QST_NOT;\n        else\n          $modifier &= ~QST_NOT;\n        $this->stoken_modifiers[] = $modifier;\n      }\n      else\n        $this->build_single_tokens($token, $crt_is_not);\n    }\n  }\n}\n\n/**\n  Structure of results being filled from different tables\n*/\nclass QResults\n{\n  var $all_tags;\n  var $tag_ids;\n  var $tag_iids;\n  var $images_iids;\n  var $iids;\n}\n\nfunction qsearch_get_text_token_search_sql($token, $fields)\n{\n  $clauses = array();\n  $variants = array_merge(array($token->term), $token->variants);\n  $fts = array();\n  foreach ($variants as $variant)\n  {\n    $use_ft = mb_strlen($variant)>3;\n    if ($token->modifier & QST_WILDCARD_BEGIN)\n      $use_ft = false;\n    if ($token->modifier & (QST_QUOTED|QST_WILDCARD_END) == (QST_QUOTED|QST_WILDCARD_END))\n      $use_ft = false;\n\n    if ($use_ft)\n    {\n      $max = max( array_map( 'mb_strlen',\n        preg_split('/['.preg_quote('-\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~','/').']+/', $variant)\n        ) );\n      if ($max<4)\n        $use_ft = false;\n    }\n\n    if (!$use_ft)\n    {// odd term or too short for full text search; fallback to regex but unfortunately this is diacritic/accent sensitive\n      $pre = ($token->modifier & QST_WILDCARD_BEGIN) ? '' : '[[:<:]]';\n      $post = ($token->modifier & QST_WILDCARD_END) ? '' : '[[:>:]]';\n      foreach( $fields as $field)\n        $clauses[] = $field.' REGEXP \\''.$pre.addslashes(preg_quote($variant)).$post.'\\'';\n    }\n    else\n    {\n      $ft = $variant;\n      if ($token->modifier & QST_QUOTED)\n        $ft = '\"'.$ft.'\"';\n      if ($token->modifier & QST_WILDCARD_END)\n        $ft .= '*';\n      $fts[] = $ft;\n    }\n  }\n\n  if (count($fts))\n  {\n    $clauses[] = 'MATCH('.implode(', ',$fields).') AGAINST( \\''.addslashes(implode(' ',$fts)).'\\' IN BOOLEAN MODE)';\n  }\n  return $clauses;\n}\n\nfunction qsearch_get_images(QExpression $expr, QResults $qsr)\n{\n  $qsr->images_iids = array_fill(0, count($expr->stokens), array());\n\n  $query_base = 'SELECT id from '.IMAGES_TABLE.' i WHERE\n';\n  for ($i=0; $i<count($expr->stokens); $i++)\n  {\n    $token = $expr->stokens[$i];\n    $scope_id = isset($token->scope) ? $token->scope->id : 'photo';\n    $clauses = array();\n\n    $like = addslashes($token->term);\n    $like = str_replace( array('%','_'), array('\\\\%','\\\\_'), $like); // escape LIKE specials %_\n    $file_like = 'CONVERT(file, CHAR) LIKE \\'%'.$like.'%\\'';\n\n    switch ($scope_id)\n    {\n      case 'photo':\n        $clauses[] = $file_like;\n        $clauses = array_merge($clauses, qsearch_get_text_token_search_sql($token, array('name','comment')));\n        break;\n\n      case 'file':\n        $clauses[] = $file_like;\n        break;\n      case 'author':\n        if ( strlen($token->term) )\n          $clauses = array_merge($clauses, qsearch_get_text_token_search_sql($token, array('author')));\n        elseif ($token->modifier & QST_WILDCARD)\n          $clauses[] = 'author IS NOT NULL';\n        else\n          $clauses[] = 'author IS NULL';\n        break;\n      case 'width':\n      case 'height':\n        $clauses[] = $token->scope->get_sql($scope_id, $token);\n        break;\n      case 'ratio':\n        $clauses[] = $token->scope->get_sql('width/height', $token);\n        break;\n      case 'size':\n        $clauses[] = $token->scope->get_sql('width*height', $token);\n        break;\n      case 'hits':\n        $clauses[] = $token->scope->get_sql('hit', $token);\n        break;\n      case 'score':\n        $clauses[] = $token->scope->get_sql('rating_score', $token);\n        break;\n      case 'filesize':\n        $clauses[] = $token->scope->get_sql('1024*filesize', $token);\n        break;\n      case 'created':\n        $clauses[] = $token->scope->get_sql('date_creation', $token);\n        break;\n      case 'posted':\n        $clauses[] = $token->scope->get_sql('date_available', $token);\n        break;\n      case 'id':\n        $clauses[] = $token->scope->get_sql($scope_id, $token);\n        break;\n      default:\n        // allow plugins to have their own scope with columns added in db by themselves\n        $clauses = trigger_change('qsearch_get_images_sql_scopes', $clauses, $token, $expr);\n        break;\n    }\n    if (!empty($clauses))\n    {\n      $query = $query_base.'('.implode(\"\\n OR \", $clauses).')';\n      $qsr->images_iids[$i] = query2array($query,null,'id');\n    }\n  }\n}\n\nfunction qsearch_get_tags(QExpression $expr, QResults $qsr)\n{\n  $token_tag_ids = $qsr->tag_iids = array_fill(0, count($expr->stokens), array() );\n  $all_tags = array();\n\n  for ($i=0; $i<count($expr->stokens); $i++)\n  {\n    $token = $expr->stokens[$i];\n    if (isset($token->scope) && 'tag' != $token->scope->id)\n      continue;\n    if (empty($token->term))\n      continue;\n\n    $clauses = qsearch_get_text_token_search_sql( $token, array('name'));\n    $query = 'SELECT * FROM '.TAGS_TABLE.'\nWHERE ('. implode(\"\\n OR \",$clauses) .')';\n    $result = pwg_query($query);\n    while ($tag = pwg_db_fetch_assoc($result))\n    {\n      $token_tag_ids[$i][] = $tag['id'];\n      $all_tags[$tag['id']] = $tag;\n    }\n  }\n\n  // check adjacent short words\n  for ($i=0; $i<count($expr->stokens)-1; $i++)\n  {\n    if ( (strlen($expr->stokens[$i]->term)<=3 || strlen($expr->stokens[$i+1]->term)<=3)\n      && (($expr->stoken_modifiers[$i] & (QST_QUOTED|QST_WILDCARD)) == 0)\n      && (($expr->stoken_modifiers[$i+1] & (QST_BREAK|QST_QUOTED|QST_WILDCARD)) == 0) )\n    {\n      $common = array_intersect( $token_tag_ids[$i], $token_tag_ids[$i+1] );\n      if (count($common))\n      {\n        $token_tag_ids[$i] = $token_tag_ids[$i+1] = $common;\n      }\n    }\n  }\n\n  // get images\n  $positive_ids = $not_ids = array();\n  for ($i=0; $i<count($expr->stokens); $i++)\n  {\n    $tag_ids = $token_tag_ids[$i];\n    $token = $expr->stokens[$i];\n\n    if (!empty($tag_ids))\n    {\n      $query = '\nSELECT image_id FROM '.IMAGE_TAG_TABLE.'\n  WHERE tag_id IN ('.implode(',',$tag_ids).')\n  GROUP BY image_id';\n      $qsr->tag_iids[$i] = query2array($query, null, 'image_id');\n      if ($expr->stoken_modifiers[$i]&QST_NOT)\n        $not_ids = array_merge($not_ids, $tag_ids);\n      else\n      {\n        if (strlen($token->term)>2 || count($expr->stokens)==1 || isset($token->scope) || ($token->modifier&(QST_WILDCARD|QST_QUOTED)) )\n        {// add tag ids to list only if the word is not too short (such as de / la /les ...)\n          $positive_ids = array_merge($positive_ids, $tag_ids);\n        }\n      }\n    }\n    elseif (isset($token->scope) && 'tag' == $token->scope->id && strlen($token->term)==0)\n    {\n      if ($token->modifier & QST_WILDCARD)\n      {// eg. 'tag:*' returns all tagged images\n        $qsr->tag_iids[$i] = query2array('SELECT DISTINCT image_id FROM '.IMAGE_TAG_TABLE, null, 'image_id');\n      }\n      else\n      {// eg. 'tag:' returns all untagged images\n        $qsr->tag_iids[$i] = query2array('SELECT id FROM '.IMAGES_TABLE.' LEFT JOIN '.IMAGE_TAG_TABLE.' ON id=image_id WHERE image_id IS NULL', null, 'id');\n      }\n    }\n  }\n\n  $all_tags = array_intersect_key($all_tags, array_flip( array_diff($positive_ids, $not_ids) ) );\n  usort($all_tags, 'tag_alpha_compare');\n  foreach ( $all_tags as &$tag )\n  {\n    $tag['name'] = trigger_change('render_tag_name', $tag['name'], $tag);\n  }\n  $qsr->all_tags = $all_tags;\n  $qsr->tag_ids = $token_tag_ids;\n}\n\n\n\nfunction qsearch_eval(QMultiToken $expr, QResults $qsr, &$qualifies, &$ignored_terms)\n{\n  $qualifies = false; // until we find at least one positive term\n  $ignored_terms = array();\n\n  $ids = $not_ids = array();\n\n  for ($i=0; $i<count($expr->tokens); $i++)\n  {\n    $crt = $expr->tokens[$i];\n    if ($crt->is_single)\n    {\n      $crt_ids = $qsr->iids[$crt->idx] = array_unique( array_merge($qsr->images_iids[$crt->idx], $qsr->tag_iids[$crt->idx]) );\n      $crt_qualifies = count($crt_ids)>0 || count($qsr->tag_ids[$crt->idx])>0;\n      $crt_ignored_terms = $crt_qualifies ? array() : array((string)$crt);\n    }\n    else\n      $crt_ids = qsearch_eval($crt, $qsr, $crt_qualifies, $crt_ignored_terms);\n\n    $modifier = $crt->modifier;\n    if ($modifier & QST_NOT)\n      $not_ids = array_unique( array_merge($not_ids, $crt_ids));\n    else\n    {\n      $ignored_terms = array_merge($ignored_terms, $crt_ignored_terms);\n      if ($modifier & QST_OR)\n      {\n        $ids = array_unique( array_merge($ids, $crt_ids) );\n        $qualifies |= $crt_qualifies;\n      }\n      elseif ($crt_qualifies)\n      {\n        if ($qualifies)\n          $ids = array_intersect($ids, $crt_ids);\n        else\n          $ids = $crt_ids;\n        $qualifies = true;\n      }\n    }\n  }\n\n  if (count($not_ids))\n    $ids = array_diff($ids, $not_ids);\n  return $ids;\n}\n\n\n/**\n * Returns the search results corresponding to a quick/query search.\n * A quick/query search returns many items (search is not strict), but results\n * are sorted by relevance unless $super_order_by is true. Returns:\n *  array (\n *    'items' => array of matching images\n *    'qs'    => array(\n *      'unmatched_terms' => array of terms from the input string that were not matched\n *      'matching_tags' => array of matching tags\n *      'matching_cats' => array of matching categories\n *      'matching_cats_no_images' =>array(99) - matching categories without images\n *      )\n *    )\n *\n * @param string $q\n * @param bool $super_order_by\n * @param string $images_where optional additional restriction on images table\n * @return array\n */\nfunction get_quick_search_results($q, $options)\n{\n  global $persistent_cache, $conf, $user;\n\n  $cache_key = $persistent_cache->make_key( array(\n    strtolower($q),\n    $conf['order_by'],\n    $user['id'],$user['cache_update_time'],\n    isset($options['permissions']) ? (boolean)$options['permissions'] : true,\n    isset($options['images_where']) ? $options['images_where'] : '',\n    ) );\n  if ($persistent_cache->get($cache_key, $res))\n  {\n    return $res;\n  }\n\n  $res = get_quick_search_results_no_cache($q, $options);\n\n  if ( count($res['items']) )\n  {// cache the results only if not empty - otherwise it is useless\n    $persistent_cache->set($cache_key, $res, 300);\n  }\n  return $res;\n}\n\n/**\n * @see get_quick_search_results but without result caching\n */\nfunction get_quick_search_results_no_cache($q, $options)\n{\n  global $conf;\n\n  $q = trim(stripslashes($q));\n  $search_results =\n    array(\n      'items' => array(),\n      'qs' => array('q'=>$q),\n    );\n\n  $q = trigger_change('qsearch_pre', $q);\n\n  $scopes = array();\n  $scopes[] = new QSearchScope('tag', array('tags'));\n  $scopes[] = new QSearchScope('photo', array('photos'));\n  $scopes[] = new QSearchScope('file', array('filename'));\n  $scopes[] = new QSearchScope('author', array(), true);\n  $scopes[] = new QNumericRangeScope('width', array());\n  $scopes[] = new QNumericRangeScope('height', array());\n  $scopes[] = new QNumericRangeScope('ratio', array(), false, 0.001);\n  $scopes[] = new QNumericRangeScope('size', array());\n  $scopes[] = new QNumericRangeScope('filesize', array());\n  $scopes[] = new QNumericRangeScope('hits', array('hit', 'visit', 'visits'));\n  $scopes[] = new QNumericRangeScope('score', array('rating'), true);\n  $scopes[] = new QNumericRangeScope('id', array());\n\n  $createdDateAliases = array('taken', 'shot');\n  $postedDateAliases = array('added');\n  if ($conf['calendar_datefield'] == 'date_creation')\n    $createdDateAliases[] = 'date';\n  else\n    $postedDateAliases[] = 'date';\n  $scopes[] = new QDateRangeScope('created', $createdDateAliases, true);\n  $scopes[] = new QDateRangeScope('posted', $postedDateAliases);\n\n  // allow plugins to add their own scopes\n  $scopes = trigger_change('qsearch_get_scopes', $scopes);\n  $expression = new QExpression($q, $scopes);\n\n  // get inflections for terms\n  $inflector = null;\n  $lang_code = substr(get_default_language(),0,2);\n  @include_once(PHPWG_ROOT_PATH.'include/inflectors/'.$lang_code.'.php');\n  $class_name = 'Inflector_'.$lang_code;\n  if (class_exists($class_name))\n  {\n    $inflector = new $class_name;\n    foreach( $expression->stokens as $token)\n    {\n      if (isset($token->scope) && !$token->scope->is_text)\n        continue;\n      if (strlen($token->term)>2\n        && ($token->modifier & (QST_QUOTED|QST_WILDCARD))==0\n        && strcspn($token->term, '\\'0123456789') == strlen($token->term) )\n      {\n        $token->variants = array_unique( array_diff( $inflector->get_variants($token->term), array($token->term) ) );\n      }\n    }\n  }\n\n\n  trigger_notify('qsearch_expression_parsed', $expression);\n//var_export($expression);\n\n  if (count($expression->stokens)==0)\n  {\n    return $search_results;\n  }\n  $qsr = new QResults;\n  qsearch_get_tags($expression, $qsr);\n  qsearch_get_images($expression, $qsr);\n\n  // allow plugins to evaluate their own scopes\n  trigger_notify('qsearch_before_eval', $expression, $qsr);\n\n  $ids = qsearch_eval($expression, $qsr, $tmp, $search_results['qs']['unmatched_terms']);\n\n  $debug[] = \"<!--\\nparsed: \".htmlspecialchars($expression);\n  $debug[] = count($expression->stokens).' tokens';\n  for ($i=0; $i<count($expression->stokens); $i++)\n  {\n    $debug[] = htmlspecialchars($expression->stokens[$i]).': '.count($qsr->tag_ids[$i]).' tags, '.count($qsr->tag_iids[$i]).' tiids, '.count($qsr->images_iids[$i]).' iiids, '.count($qsr->iids[$i]).' iids'\n      .' modifier:'.dechex($expression->stoken_modifiers[$i])\n      .( !empty($expression->stokens[$i]->variants) ? ' variants: '.htmlspecialchars(implode(', ',$expression->stokens[$i]->variants)): '');\n  }\n  $debug[] = 'before perms '.count($ids);\n\n  $search_results['qs']['matching_tags'] = $qsr->all_tags;\n  $search_results = trigger_change('qsearch_results', $search_results, $expression, $qsr);\n\n  global $template;\n\n  if (empty($ids))\n  {\n    $debug[] = '-->';\n    $template->append('footer_elements', implode(\"\\n\", $debug) );\n    return $search_results;\n  }\n\n  $permissions = !isset($options['permissions']) ? true : $options['permissions'];\n\n  $where_clauses = array();\n  $where_clauses[]='i.id IN ('. implode(',', $ids) . ')';\n  if (!empty($options['images_where']))\n  {\n    $where_clauses[]='('.$options['images_where'].')';\n  }\n  if ($permissions)\n  {\n    $where_clauses[] = get_sql_condition_FandF(\n        array\n          (\n            'forbidden_categories' => 'category_id',\n            'forbidden_images' => 'i.id'\n          ),\n        null,true\n      );\n  }\n\n  $query = '\nSELECT DISTINCT(id) FROM '.IMAGES_TABLE.' i';\n  if ($permissions)\n  {\n    $query .= '\n    INNER JOIN '.IMAGE_CATEGORY_TABLE.' AS ic ON id = ic.image_id';\n  }\n  $query .= '\n  WHERE '.implode(\"\\n AND \", $where_clauses).\"\\n\".\n  $conf['order_by'];\n\n  $ids = query2array($query, null, 'id');\n\n  $debug[] = count($ids).' final photo count -->';\n  $template->append('footer_elements', implode(\"\\n\", $debug) );\n\n  $search_results['items'] = $ids;\n  return $search_results;\n}\n\n/**\n * Returns an array of 'items' corresponding to the search id.\n * It can be either a quick search or a regular search.\n *\n * @param int $search_id\n * @param bool $super_order_by\n * @param string $images_where optional aditional restriction on images table\n * @return array\n */\nfunction get_search_results($search_id, $super_order_by, $images_where='')\n{\n  $search = get_search_array($search_id);\n  if ( !isset($search['q']) )\n  {\n    $result['items'] = get_regular_search_results($search, $images_where);\n    return $result;\n  }\n  else\n  {\n    return get_quick_search_results($search['q'], array('super_order_by'=>$super_order_by, 'images_where'=>$images_where) );\n  }\n}\n\n?>\n"], "filenames": ["include/functions_search.inc.php"], "buggy_code_start_loc": [1287], "buggy_code_end_loc": [1294], "fixing_code_start_loc": [1287], "fixing_code_end_loc": [1294], "type": "CWE-79", "message": "Cross Site Scripting (XSS) exists in Piwigo before 2.8.3 via a crafted search expression to include/functions_search.inc.php.", "other": {"cve": {"id": "CVE-2016-10513", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-10T20:29:00.210", "lastModified": "2017-10-20T14:36:12.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross Site Scripting (XSS) exists in Piwigo before 2.8.3 via a crafted search expression to include/functions_search.inc.php."}, {"lang": "es", "value": "Existe Cross-Site Scripting (XSS) en Piwigo en versiones anteriores a la 2.8.3 mediante una expresi\u00f3n de b\u00fasqueda manipulada en include/functions_search.inc.php."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:piwigo:piwigo:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.2", "matchCriteriaId": "6A4BE149-A8CA-4C7D-9A2F-0ACAEEFB375A"}]}]}], "references": [{"url": "http://piwigo.org/releases/2.8.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/Piwigo/Piwigo/commit/9a93d1f44b06605af84520509e7a0e8b64ab0c05", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Piwigo/Piwigo/issues/548", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Piwigo/Piwigo/commit/9a93d1f44b06605af84520509e7a0e8b64ab0c05"}}