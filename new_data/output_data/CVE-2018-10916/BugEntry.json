{"buggy_code": ["/*\n * lftp - file transfer program\n *\n * Copyright (c) 1996-2017 by Alexander V. Lukyanov (lav@yars.free.net)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <mbswidth.h>\n#include \"MirrorJob.h\"\n#include \"CmdExec.h\"\n#include \"rmJob.h\"\n#include \"mvJob.h\"\n#include \"ChmodJob.h\"\n#include \"mkdirJob.h\"\n#include \"misc.h\"\n#include \"plural.h\"\n#include \"FindJob.h\"\n#include \"url.h\"\n#include \"CopyJob.h\"\n#include \"pgetJob.h\"\n#include \"log.h\"\n\n#define set_state(s) do { state=(s); \\\n   Log::global->Format(11,\"mirror(%p) enters state %s\\n\", this, #s); } while(0)\n#define waiting_num waiting.count()\n#define transfer_count root_mirror->root_transfer_count\n\nxstring& MirrorJob::FormatStatus(xstring& s,int v,const char *tab)\n{\n   if(Done())\n      goto final;\n\n   switch(state)\n   {\n   case(INITIAL_STATE):\n   case(FINISHING):\n   case(DONE):\n   case(WAITING_FOR_TRANSFER):\n   case(TARGET_REMOVE_OLD):\n   case(TARGET_REMOVE_OLD_FIRST):\n   case(TARGET_CHMOD):\n   case(TARGET_MKDIR):\n   case(SOURCE_REMOVING_SAME):\n   case(LAST_EXEC):\n      break;\n\n   case(MAKE_TARGET_DIR):\n      s.appendf(\"\\tmkdir `%s' [%s]\\n\",target_dir.get(),target_session->CurrentStatus());\n      break;\n\n   case(CHANGING_DIR_SOURCE):\n   case(CHANGING_DIR_TARGET):\n      if(target_session->IsOpen())\n\t s.appendf(\"\\tcd `%s' [%s]\\n\",target_dir.get(),target_session->CurrentStatus());\n      if(source_session->IsOpen())\n\t s.appendf(\"\\tcd `%s' [%s]\\n\",source_dir.get(),source_session->CurrentStatus());\n      break;\n\n   case(GETTING_LIST_INFO):\n      if(target_list_info)\n      {\n\t if(target_relative_dir)\n\t    s.appendf(\"\\t%s: %s\\n\",target_relative_dir.get(),target_list_info->Status());\n\t else\n\t    s.appendf(\"\\t%s\\n\",target_list_info->Status());\n      }\n      if(source_list_info)\n      {\n\t if(source_relative_dir)\n\t    s.appendf(\"\\t%s: %s\\n\",source_relative_dir.get(),source_list_info->Status());\n\t else\n\t    s.appendf(\"\\t%s\\n\",source_list_info->Status());\n      }\n      break;\n   }\n   return s;\n\nfinal:\n   if(stats.dirs>0)\n      s.appendf(plural(\"%sTotal: %d director$y|ies$, %d file$|s$, %d symlink$|s$\\n\",\n\t\t     stats.dirs,stats.tot_files,stats.tot_symlinks),\n\t tab,stats.dirs,stats.tot_files,stats.tot_symlinks);\n   if(stats.new_files || stats.new_symlinks)\n      s.appendf(plural(\"%sNew: %d file$|s$, %d symlink$|s$\\n\",\n\t\t     stats.new_files,stats.new_symlinks),\n\t tab,stats.new_files,stats.new_symlinks);\n   if(stats.mod_files || stats.mod_symlinks)\n      s.appendf(plural(\"%sModified: %d file$|s$, %d symlink$|s$\\n\",\n\t\t     stats.mod_files,stats.mod_symlinks),\n\t tab,stats.mod_files,stats.mod_symlinks);\n   if(stats.bytes)\n      s.appendf(\"%s%s\\n\",tab,CopyJob::FormatBytesTimeRate(stats.bytes,transfer_time_elapsed));\n   if(stats.del_dirs || stats.del_files || stats.del_symlinks)\n      s.appendf(plural(FlagSet(DELETE) ?\n\t       \"%sRemoved: %d director$y|ies$, %d file$|s$, %d symlink$|s$\\n\"\n\t      :\"%sTo be removed: %d director$y|ies$, %d file$|s$, %d symlink$|s$\\n\",\n\t      stats.del_dirs,stats.del_files,stats.del_symlinks),\n\t tab,stats.del_dirs,stats.del_files,stats.del_symlinks);\n   if(stats.error_count)\n      s.appendf(plural(\"%s%d error$|s$ detected\\n\",stats.error_count),\n\t       tab,stats.error_count);\n   return s;\n}\n\nvoid  MirrorJob::ShowRunStatus(const SMTaskRef<StatusLine>& s)\n{\n   int w=s->GetWidthDelayed();\n   switch(state)\n   {\n   case(INITIAL_STATE):\n      break;\n\n   // these have a sub-job\n   case(WAITING_FOR_TRANSFER):\n   case(TARGET_REMOVE_OLD):\n   case(TARGET_REMOVE_OLD_FIRST):\n   case(TARGET_CHMOD):\n   case(TARGET_MKDIR):\n   case(SOURCE_REMOVING_SAME):\n   case(FINISHING):\n   case(DONE):\n   case(LAST_EXEC):\n      Job::ShowRunStatus(s);\n      break;\n\n   case(MAKE_TARGET_DIR):\n      s->Show(\"mkdir `%s' [%s]\",target_dir.get(),target_session->CurrentStatus());\n      break;\n\n   case(CHANGING_DIR_SOURCE):\n   case(CHANGING_DIR_TARGET):\n      if(target_session->IsOpen() && (!source_session->IsOpen() || now%4>=2))\n\t s->Show(\"cd `%s' [%s]\",target_dir.get(),target_session->CurrentStatus());\n      else if(source_session->IsOpen())\n\t s->Show(\"cd `%s' [%s]\",source_dir.get(),source_session->CurrentStatus());\n      break;\n\n   case(GETTING_LIST_INFO):\n      if(target_list_info && (!source_list_info || now%4>=2))\n      {\n\t const char *status=target_list_info->Status();\n\t int status_w=mbswidth(status, 0);\n\t int dw=w-status_w;\n\t if(dw<20)\n\t    dw=20;\n\t if(target_relative_dir)\n\t    s->Show(\"%s: %s\",squeeze_file_name(target_relative_dir,dw),status);\n\t else\n\t    s->Show(\"%s\",status);\n      }\n      else if(source_list_info)\n      {\n\t const char *status=source_list_info->Status();\n\t int status_w=mbswidth(status, 0);\n\t int dw=w-status_w;\n\t if(dw<20)\n\t    dw=20;\n\t if(source_relative_dir)\n\t    s->Show(\"%s: %s\",squeeze_file_name(source_relative_dir,dw),status);\n\t else\n\t    s->Show(\"%s\",status);\n      }\n      break;\n   }\n}\n\nxstring& MirrorJob::FormatShortStatus(xstring& s)\n{\n   if(bytes_to_transfer>0 && (!parent_mirror || parent_mirror->bytes_to_transfer!=bytes_to_transfer)) {\n      long long curr_bytes_transferred=GetBytesCount();\n      if(parent_mirror)\n         curr_bytes_transferred+=bytes_transferred;\n      s.appendf(\"%s/%s (%d%%)\",\n\t xhuman(curr_bytes_transferred),xhuman(bytes_to_transfer),\n\t percent(curr_bytes_transferred,bytes_to_transfer));\n      double rate=GetTransferRate();\n      if(rate>=1)\n\t s.append(' ').append(Speedometer::GetStrProper(rate));\n   }\n   return s;\n}\n\nvoid MirrorJob::TransferStarted(CopyJob *cp)\n{\n   if(transfer_count==0)\n      root_mirror->transfer_start_ts=now;\n   JobStarted(cp);\n}\nvoid MirrorJob::JobStarted(Job *j)\n{\n   AddWaiting(j);\n   transfer_count++;\n}\nvoid MirrorJob::TransferFinished(Job *j)\n{\n   long long bytes_count=j->GetBytesCount();\n   AddBytesTransferred(bytes_count);\n   stats.bytes+=bytes_count;\n   stats.time +=j->GetTimeSpent();\n   if(j->ExitCode()==0 && verbose_report>=2) {\n      xstring finished;\n      const xstring& cmd=j->GetCmdLine();\n      if(cmd[0]=='\\\\')\n\t finished.append(cmd+1,cmd.length()-1);\n      else\n\t finished.append(cmd);\n      const xstring& rate=Speedometer::GetStrProper(j->GetTransferRate());\n      if(rate.length()>0)\n\t finished.append(\" (\").append(rate).append(')');\n      if(!(FlagSet(SCAN_ALL_FIRST) && finished.begins_with(\"mirror\")))\n\t Report(_(\"Finished %s\"),finished.get());\n   }\n   JobFinished(j);\n   if(transfer_count==0)\n      root_mirror->transfer_time_elapsed += now-root_mirror->transfer_start_ts;\n}\nvoid MirrorJob::JobFinished(Job *j)\n{\n   if(j->ExitCode()!=0)\n      stats.error_count++;\n   RemoveWaiting(j);\n   Delete(j);\n   assert(transfer_count>0);\n   transfer_count--;\n}\n\noff_t MirrorJob::GetBytesCount()\n{\n   long long bytes_count=Job::GetBytesCount();\n   if(!parent_mirror) {\n      // bytes_transferred is cumulative over the mirror tree,\n      // add it on the top only\n      bytes_count+=bytes_transferred;\n   }\n   return bytes_count;\n}\ndouble MirrorJob::GetTimeSpent()\n{\n   double t=transfer_time_elapsed;\n   if(transfer_count>0)\n      t+=now-root_mirror->transfer_start_ts;\n   return t;\n}\n\nvoid  MirrorJob::HandleFile(FileInfo *file)\n{\n   int\t res;\n   struct stat st;\n\n   // TODO: get rid of local hacks.\n\n   const char *dst_name=file->name;\n   if(FlagSet(TARGET_FLAT))\n      dst_name=basename_ptr(dst_name);\n\n   // dir_name returns pointer to static data - need to dup it.\n   const char *source_name=dir_file(source_dir,file->name);\n   source_name=alloca_strdup(source_name);\n   const char *target_name=dir_file(target_dir,dst_name);\n   target_name=alloca_strdup(target_name);\n\n   const char *source_name_rel=dir_file(source_relative_dir,file->name);\n   source_name_rel=alloca_strdup(source_name_rel);\n   const char *target_name_rel=dir_file(target_relative_dir,dst_name);\n   target_name_rel=alloca_strdup(target_name_rel);\n\n   FileInfo::type filetype=FileInfo::NORMAL;\n   if(file->Has(file->TYPE))\n      filetype=file->filetype;\n   else\n   {\n      FileInfo *target=target_set->FindByName(file->name);\n      if(target && target->Has(target->TYPE))\n\t filetype=target->filetype;\n   }\n\n   switch(filetype)\n   {\n      case(FileInfo::NORMAL):\n      case(FileInfo::REDIRECT):\n      {\n\t bool remove_target=false;\n\t bool cont_this=false;\n\t bool use_pget=(pget_n>1) && target_is_local;\n\t if(file->Has(file->SIZE) && file->size<pget_minchunk*2)\n\t    use_pget=false;\n\t if(target_is_local)\n\t {\n\t    if(lstat(target_name,&st)!=-1)\n\t    {\n\t       // few safety checks.\n\t       FileInfo *old=new_files_set->FindByName(file->name);\n\t       if(old)\n\t\t  goto skip;  // file has appeared after mirror start\n\t       old=old_files_set->FindByName(file->name);\n\t       if(old && ((old->Has(old->SIZE) && old->size!=st.st_size)\n\t\t\t||(old->Has(old->DATE) && old->date!=st.st_mtime)))\n\t\t  goto skip;  // the file has changed after mirror start\n\t       if(!script_only && access(target_name,W_OK)==-1)\n\t       {\n\t\t  // try to enable write access.\n\t\t  chmod(target_name,st.st_mode|0200);\n\t       }\n\t    }\n\t }\n\t FileInfo *old=target_set->FindByName(FileCopy::TempFileName(file->name));\n\t if(old)\n\t {\n\t    if(FlagSet(CONTINUE)\n\t    && old->Has(file->TYPE) && old->filetype==old->NORMAL\n\t    && (FlagSet(IGNORE_TIME) ||\n\t\t(file->Has(file->DATE) && old->Has(old->DATE)\n\t\t&& file->date + file->date.ts_prec < old->date - old->date.ts_prec))\n\t    && file->Has(file->SIZE) && old->Has(old->SIZE)\n\t    && file->size >= old->size)\n\t    {\n\t       cont_this=true;\n\t       stats.mod_files++;\n\t    }\n\t    else if(!to_rm_mismatched->FindByName(file->name))\n\t    {\n\t       if(!FlagSet(OVERWRITE)) {\n\t\t  remove_target=true;\n\t\t  Report(_(\"Removing old file `%s'\"),target_name_rel);\n\t       } else {\n\t\t  Report(_(\"Overwriting old file `%s'\"),target_name_rel);\n\t       }\n\t       stats.mod_files++;\n\t    }\n\t    else\n\t       stats.new_files++;\n\t }\n\t else if(FlagSet(ONLY_EXISTING))\n\t {\n\t    Report(_(\"Skipping file `%s' (only-existing)\"),source_name_rel);\n\t    goto skip;\n\t }\n\t else\n\t    stats.new_files++;\n\n\t Report(_(\"Transferring file `%s'\"),source_name_rel);\n\n\t if(script)\n\t {\n\t    ArgV args(use_pget?\"pget\":\"get\");\n\t    if(use_pget)\n\t    {\n\t       args.Append(\"-n\");\n\t       args.Append(pget_n);\n\t    }\n\t    if(cont_this)\n\t       args.Append(\"-c\");\n\t    if(remove_target)\n\t       args.Append(\"-e\");\n\t    if(FlagSet(ASCII))\n\t       args.Append(\"-a\");\n\t    if(remove_source_files)\n\t       args.Append(\"-E\");\n\t    args.Append(\"-O\");\n\t    args.Append(target_is_local?target_dir.get()\n\t\t\t:target_session->GetConnectURL().get());\n\t    args.Append(source_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t    if(script_only)\n\t       goto skip;\n\t }\n\n\t FileCopyPeer *src_peer=0;\n\t if(source_is_local)\n\t    src_peer=new FileCopyPeerFDStream(new FileStream(source_name,O_RDONLY),FileCopyPeer::GET);\n\t else\n\t    src_peer=new FileCopyPeerFA(source_session->Clone(),file->name,FA::RETRIEVE);\n\n\t FileCopyPeer *dst_peer=0;\n\t if(target_is_local)\n\t    dst_peer=new FileCopyPeerFDStream(new FileStream(target_name,O_WRONLY|O_CREAT|(cont_this?0:O_TRUNC)),FileCopyPeer::PUT);\n\t else\n\t    dst_peer=new FileCopyPeerFA(target_session->Clone(),dst_name,FA::STORE);\n\n\t FileCopy *c=FileCopy::New(src_peer,dst_peer,cont_this);\n\t if(remove_source_files)\n\t    c->RemoveSourceLater();\n\t if(remove_target)\n\t    c->RemoveTargetFirst();\n\t if(FlagSet(ASCII))\n\t    c->Ascii();\n\t CopyJob *cp=(use_pget ? new pgetJob(c,file->name,pget_n) : new CopyJob(c,file->name,\"mirror\"));\n\t if(file->Has(file->DATE))\n\t    cp->SetDate(file->date);\n\t if(file->Has(file->SIZE) && !FlagSet(IGNORE_SIZE))\n\t    cp->SetSize(file->size);\n\t TransferStarted(cp);\n\t cp->cmdline.vset(\"\\\\transfer `\",source_name_rel,\"'\",NULL);\n\n\t set_state(WAITING_FOR_TRANSFER);\n\t break;\n      }\n      case(FileInfo::DIRECTORY):\n      {\n\t if(recursion_mode==RECURSION_NEVER || FlagSet(NO_RECURSION))\n\t    goto skip;\n\n\t bool create_target_subdir=true;\n\t const FileInfo *old=0;\n\n\t if(FlagSet(TARGET_FLAT)) {\n\t    create_target_subdir=false;\n\t    target_name=target_dir;\n\t    goto do_submirror;\n\t }\n\n\t if(target_set)\n\t    old=target_set->FindByName(file->name);\n\t if(!old)\n\t {\n\t    if(FlagSet(ONLY_EXISTING))\n\t    {\n\t       Report(_(\"Skipping directory `%s' (only-existing)\"),target_name_rel);\n\t       goto skip;\n\t    }\n\t }\n\t else if(old->TypeIs(old->DIRECTORY))\n\t {\n\t    create_target_subdir=false;\n\t }\n\t if(target_is_local && !script_only)\n\t {\n\t    if((FlagSet(RETR_SYMLINKS)?stat:lstat)(target_name,&st)!=-1)\n\t    {\n\t       if(S_ISDIR(st.st_mode))\n\t       {\n\t\t  // try to enable write access\n\t\t  // only if not enabled as chmod can clear sgid flags on directories\n\t\t  if(st.st_mode!=(st.st_mode|0700))\n\t\t     chmod(target_name,st.st_mode|0700);\n\t\t  create_target_subdir=false;\n\t       }\n\t       else\n\t       {\n\t\t  Report(_(\"Removing old local file `%s'\"),target_name_rel);\n\t\t  if(remove(target_name)==-1)\n\t\t  {\n\t\t     eprintf(\"mirror: remove(%s): %s\\n\",target_name,strerror(errno));\n\t\t     goto skip;\n\t\t  }\n\t\t  create_target_subdir=true;\n\t       }\n\t    }\n\t }\n\n      do_submirror:\n\t // launch sub-mirror\n\t MirrorJob *mj=new MirrorJob(this,\n\t    source_session->Clone(),target_session->Clone(),\n\t    source_name,target_name);\n\t AddWaiting(mj);\n\t mj->cmdline.vset(\"\\\\mirror `\",source_name_rel,\"'\",NULL);\n\n\t mj->source_relative_dir.set(source_name_rel);\n\t mj->target_relative_dir.set(target_name_rel);\n\n\t mj->create_target_dir=create_target_subdir;\n\n\t if(verbose_report>=3) {\n\t    if(FlagSet(SCAN_ALL_FIRST))\n\t       Report(_(\"Scanning directory `%s'\"),mj->target_relative_dir.get());\n\t    else\n\t       Report(_(\"Mirroring directory `%s'\"),mj->target_relative_dir.get());\n\t }\n\n\t break;\n      }\n      case(FileInfo::SYMLINK):\n      {\n\t if(FlagSet(NO_SYMLINKS))\n\t    goto skip;\n\n\t if(!file->symlink)\n\t    goto skip;\n\n\t if(!target_is_local)\n\t {\n\t    if(script)\n\t    {\n\t       ArgV args(\"ln\");\n\t       args.Append(\"-s\");\n\t       args.Append(file->symlink);\n\t       args.Append(target_name);\n\t       xstring_ca cmd(args.CombineQuoted());\n\t       fprintf(script,\"%s\\n\",cmd.get());\n\t       if(script_only)\n\t\t  goto skip;\n\t    }\n\t    bool remove_target=false;\n\t    FileInfo *old=target_set->FindByName(file->name);\n\t    if(old && !to_rm_mismatched->FindByName(file->name))\n\t    {\n\t       Report(_(\"Removing old file `%s'\"),target_name_rel);\n\t       remove_target=true;\n\t       stats.mod_symlinks++;\n\t    }\n\t    else\n\t       stats.new_symlinks++;\n\t    Report(_(\"Making symbolic link `%s' to `%s'\"),target_name_rel,file->symlink.get());\n\t    mvJob *j=new mvJob(target_session->Clone(),file->symlink,target_name,FA::SYMLINK);\n\t    if(remove_target)\n\t       j->RemoveTargetFirst();\n\t    JobStarted(j);\n\t    RemoveSourceLater(file);\n\t    break;\n\t }\n\n\t if(script)\n\t {\n\t    ArgV args(\"shell\");\n\t    args.Append(\"ln\");\n\t    args.Append(\"-sf\");\n\t    args.Append(shell_encode(file->symlink));\n\t    args.Append(shell_encode(target_name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t    if(script_only)\n\t       goto skip;\n\t }\n\n\t struct stat st;\n\t if(lstat(target_name,&st)!=-1)\n\t {\n\t    Report(_(\"Removing old local file `%s'\"),target_name_rel);\n\t    stats.mod_symlinks++;\n\t    if(remove(target_name)==-1)\n\t    {\n\t       eprintf(\"mirror: remove(%s): %s\\n\",target_name,strerror(errno));\n\t       goto skip;\n\t    }\n\t }\n\t else\n\t {\n\t    if(FlagSet(ONLY_EXISTING))\n\t    {\n\t       Report(_(\"Skipping symlink `%s' (only-existing)\"),target_name_rel);\n\t       goto skip;\n\t    }\n\t    stats.new_symlinks++;\n\t }\n\t Report(_(\"Making symbolic link `%s' to `%s'\"),target_name_rel,file->symlink.get());\n\t res=symlink(file->symlink,target_name);\n\t if(res==-1)\n\t    eprintf(\"mirror: symlink(%s): %s\\n\",target_name,strerror(errno));\n\t RemoveSourceLater(file);\n\t break;\n      }\n   case FileInfo::UNKNOWN:\n      break;\n   }\nskip:\n   return;\n}\n\nvoid  MirrorJob::InitSets()\n{\n   if(FlagSet(TARGET_FLAT) && !parent_mirror && target_set)\n      source_set->Sort(FileSet::BYNAME_FLAT);\n\n   source_set->Count(NULL,&stats.tot_files,&stats.tot_symlinks,&stats.tot_files);\n\n   to_rm=new FileSet(target_set);\n   to_rm->SubtractAny(source_set);\n\n   if(FlagSet(DELETE_EXCLUDED) && target_set_excluded)\n      to_rm->Merge(target_set_excluded);\n\n   to_transfer=new FileSet(source_set);\n\n   if(!FlagSet(TRANSFER_ALL)) {\n      same=new FileSet(source_set);\n\n      int ignore=0;\n      if(FlagSet(ONLY_NEWER))\n\t ignore|=FileInfo::IGNORE_SIZE_IF_OLDER|FileInfo::IGNORE_DATE_IF_OLDER;\n      if(!FlagSet(UPLOAD_OLDER) && strcmp(target_session->GetProto(),\"file\"))\n\t ignore|=FileInfo::IGNORE_DATE_IF_OLDER;\n      if(FlagSet(IGNORE_TIME))\n\t ignore|=FileInfo::DATE;\n      if(FlagSet(IGNORE_SIZE))\n\t ignore|=FileInfo::SIZE;\n      to_transfer->SubtractSame(target_set,ignore);\n\n      same->SubtractAny(to_transfer);\n   }\n\n   if(newer_than!=NO_DATE)\n      to_transfer->SubtractNotNewerThan(newer_than);\n   if(older_than!=NO_DATE)\n      to_transfer->SubtractNotOlderThan(older_than);\n   if(size_range)\n      to_transfer->SubtractSizeOutside(size_range);\n\n   if(FlagSet(SCAN_ALL_FIRST)) {\n      to_mkdir=new FileSet(to_transfer);\n      to_mkdir->SubtractNotDirs();\n      to_mkdir->SubtractAny(target_set);\n   }\n\n   switch(recursion_mode) {\n   case RECURSION_NEVER:\n      to_transfer->SubtractDirs();\n      break;\n   case RECURSION_MISSING:\n      to_transfer->SubtractDirs(target_set);\n      break;\n   case RECURSION_NEWER:\n      to_transfer->SubtractNotOlderDirs(target_set);\n      break;\n   case RECURSION_ALWAYS:\n      break;\n   }\n\n   if(skip_noaccess)\n      to_transfer->ExcludeUnaccessible(source_session->GetUser());\n\n   new_files_set=new FileSet(to_transfer);\n   new_files_set->SubtractAny(target_set);\n   old_files_set=new FileSet(target_set);\n   old_files_set->SubtractNotIn(to_transfer);\n\n   to_rm_mismatched=new FileSet(old_files_set);\n   to_rm_mismatched->SubtractSameType(to_transfer);\n   to_rm_mismatched->SubtractNotDirs();\n\n   if(!FlagSet(DELETE))\n      to_transfer->SubtractAny(to_rm_mismatched);\n\n   if(FlagSet(TARGET_FLAT) && !parent_mirror && target_set) {\n      source_set->Unsort();\n      to_transfer->UnsortFlat();\n      to_transfer->SubtractDirs();\n      same->UnsortFlat();\n      to_mkdir->Empty();\n      new_files_set->UnsortFlat();\n   }\n\n   const char *sort_by=ResMgr::Query(\"mirror:sort-by\",0);\n   bool desc=strstr(sort_by,\"-desc\");\n   if(!strncmp(sort_by,\"name\",4))\n      to_transfer->SortByPatternList(ResMgr::Query(\"mirror:order\",0));\n   else if(!strncmp(sort_by,\"date\",4))\n      to_transfer->Sort(FileSet::BYDATE);\n   else if(!strncmp(sort_by,\"size\",4))\n      to_transfer->Sort(FileSet::BYSIZE,false,true);\n   if(desc)\n      to_transfer->ReverseSort();\n\n   int dir_count=0;\n   if(to_mkdir) {\n      to_mkdir->Count(&dir_count,NULL,NULL,NULL);\n      only_dirs = (dir_count==to_mkdir->count());\n   } else {\n      to_transfer->Count(&dir_count,NULL,NULL,NULL);\n      only_dirs = (dir_count==to_transfer->count());\n   }\n}\n\n/* root_transfer_count of child mirrors contains the value to add or\n   subtract from transfer_count when doing \"cd\", \"mkdir\", \"ls\" on the source\n   or target directories. This would prevent other mirrors (siblings, etc)\n   from starting more jobs.\n\n   root_transfer_count is initialized once in ctor, so that change of\n   mirror:parallel-directories setting won't disbalance the count.\n*/\nvoid MirrorJob::MirrorStarted()\n{\n   if(!parent_mirror)\n      return;\n   transfer_count+=root_transfer_count;\n}\nvoid MirrorJob::MirrorFinished()\n{\n   if(!parent_mirror)\n      return;\n   assert(transfer_count>=root_transfer_count);\n   transfer_count-=root_transfer_count;\n}\n\nvoid MirrorJob::HandleChdir(FileAccessRef& session, int &redirections)\n{\n   if(!session->IsOpen())\n      return;\n   int res=session->Done();\n   if(res<0)\n   {\n      if(res==FA::FILE_MOVED)\n      {\n\t // cd to another url.\n\t const char *loc_c=session->GetNewLocation();\n\t int max_redirections=ResMgr::Query(\"xfer:max-redirections\",0);\n\t if(loc_c && max_redirections>0)\n\t {\n\t    if(++redirections>max_redirections)\n\t       goto cd_err_normal;\n\t    eprintf(_(\"%s: received redirection to `%s'\\n\"),\"mirror\",loc_c);\n\n\t    char *loc=alloca_strdup(loc_c);\n\t    ParsedURL u(loc,true);\n\n\t    bool is_file=(last_char(loc)!='/');\n\t    if(!u.proto)\n\t    {\n\t       FileAccess::Path new_cwd(session->GetNewCwd());\n\t       new_cwd.Change(0,is_file,loc);\n\t       session->PathVerify(new_cwd);\n\t       session->Roll();\n\t       return;\n\t    }\n\t    session->Close(); // loc_c is no longer valid.\n\t    session=FA::New(&u);\n\t    FileAccess::Path new_cwd(u.path,is_file,url::path_ptr(loc));\n\t    session->PathVerify(new_cwd);\n\t    return;\n\t }\n      }\n   cd_err_normal:\n      if(session==target_session && (script_only || FlagSet(SCAN_ALL_FIRST)))\n      {\n\t char *dir=alloca_strdup(session->GetFile());\n\t session->Close();\n\t session->Chdir(dir,false);\n\t no_target_dir=true;\n\t return;\n      }\n      if(session==source_session && create_target_dir\n      && !FlagSet(NO_EMPTY_DIRS) && !skip_noaccess && parent_mirror)\n      {\n\t // create target dir even if failed to cd to source dir.\n\t if(script)\n\t    fprintf(script,\"mkdir %s\\n\",target_session->GetFileURL(target_dir).get());\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"mkdir\");\n\t    a->Append(target_dir);\n\t    mkdirJob *mkj=new mkdirJob(target_session->Clone(),a);\n\t    a->CombineTo(mkj->cmdline);\n\t    JobStarted(mkj);\n\t }\n      }\n      remove_this_source_dir=false;\n      eprintf(\"mirror: %s\\n\",session->StrError(res));\n      stats.error_count++;\n      MirrorFinished();\n      set_state(FINISHING);\n      source_session->Close();\n      target_session->Close();\n      return;\n   }\n   if(res==FA::OK)\n      session->Close();\n}\nvoid MirrorJob::HandleListInfoCreation(const FileAccessRef& session,SMTaskRef<ListInfo>& list_info,const char *relative_dir)\n{\n   if(state!=GETTING_LIST_INFO)\n      return;\n\n   if(session==target_session && no_target_dir)\n   {\n      target_set=new FileSet();\n      return;\n   }\n\n   list_info=session->MakeListInfo();\n   if(list_info==0)\n   {\n      eprintf(_(\"mirror: protocol `%s' is not suitable for mirror\\n\"),\n\t       session->GetProto());\n      MirrorFinished();\n      set_state(FINISHING);\n      return;\n   }\n   list_info->UseCache(use_cache);\n   int need=FileInfo::ALL_INFO;\n   if(FlagSet(IGNORE_TIME))\n      need&=~FileInfo::DATE;\n   if(FlagSet(IGNORE_SIZE))\n      need&=~FileInfo::SIZE;\n   list_info->Need(need);\n   if(FlagSet(RETR_SYMLINKS))\n      list_info->FollowSymlinks();\n\n   list_info->SetExclude(relative_dir,top_exclude?top_exclude:exclude);\n   list_info->Roll();\n}\n\nvoid MirrorJob::HandleListInfo(SMTaskRef<ListInfo>& list_info, Ref<FileSet>& set, Ref<FileSet> *fsx)\n{\n   if(!list_info)\n      return;\n   if(!list_info->Done())\n      return;\n   if(list_info->Error())\n   {\n      eprintf(\"mirror: %s\\n\",list_info->ErrorText());\n      stats.error_count++;\n      MirrorFinished();\n      set_state(FINISHING);\n      source_list_info=0;\n      target_list_info=0;\n      return;\n   }\n   set=list_info->GetResult();\n   if(fsx)\n      *fsx=list_info->GetExcluded();\n   list_info=0;\n   set->ExcludeDots(); // don't need .. and .\n}\n\nint   MirrorJob::Do()\n{\n   int\t res;\n   int\t m=STALL;\n   FileInfo *file;\n   Job\t *j;\n\n   switch(state)\n   {\n   case(INITIAL_STATE):\n      remove_this_source_dir=(remove_source_dirs && source_dir.last_char()!='/');\n      if(!strcmp(target_dir,\".\") || !strcmp(target_dir,\"..\") || (FlagSet(SCAN_ALL_FIRST) && parent_mirror))\n\t create_target_dir=false;\n\n      source_session->Chdir(source_dir);\n      source_redirections=0;\n      source_session->Roll();\n      set_state(CHANGING_DIR_SOURCE);\n      m=MOVED;\n      /*fallthrough*/\n   case(CHANGING_DIR_SOURCE):\n      HandleChdir(source_session,source_redirections);\n      if(state!=CHANGING_DIR_SOURCE)\n\t return MOVED;\n      if(source_session->IsOpen())\n\t return m;\n\n      source_dir.set(source_session->GetCwd().GetDirectory());\n\n   pre_MAKE_TARGET_DIR:\n   {\n      if(!create_target_dir)\n\t goto pre_CHANGING_DIR_TARGET;\n      if(target_is_local)\n      {\n\t struct stat st;\n\t if((FlagSet(RETR_SYMLINKS)?stat:lstat)(target_dir,&st)!=-1)\n\t {\n\t    if(S_ISDIR(st.st_mode))\n\t    {\n\t       // try to enable write access\n\t       // only if not enabled as chmod can clear sgid flags on directories\n\t       if(!script_only && (st.st_mode!=(st.st_mode|0700)))\n\t\t  chmod(target_dir,st.st_mode|0700);\n\t       create_target_dir=false;\n\t       goto pre_CHANGING_DIR_TARGET;\n\t    }\n\t    else\n\t    {\n\t       Report(_(\"Removing old local file `%s'\"),target_dir.get());\n\t       if(script)\n\t       {\n\t\t  ArgV args(\"rm\");\n\t\t  args.Append(target_session->GetFileURL(target_dir));\n\t\t  xstring_ca cmd(args.CombineQuoted());\n\t\t  fprintf(script,\"%s\\n\",cmd.get());\n\t       }\n\t       if(!script_only)\n\t       {\n\t\t  if(remove(target_dir)==-1)\n\t\t     eprintf(\"mirror: remove(%s): %s\\n\",target_dir.get(),strerror(errno));\n\t       }\n\t    }\n\t }\n      }\n\n      if(FlagSet(DEPTH_FIRST))\n\t goto pre_GETTING_LIST_INFO;\n\n      if(target_relative_dir)\n\t Report(_(\"Making directory `%s'\"),target_relative_dir.get());\n      bool mkdir_p=(parent_mirror==0 || parent_mirror->create_target_dir);\n      if(script)\n      {\n\t ArgV args(\"mkdir\");\n\t if(mkdir_p)\n\t    args.Append(\"-p\");\n\t args.Append(target_session->GetFileURL(target_dir));\n\t xstring_ca cmd(args.CombineQuoted());\n\t fprintf(script,\"%s\\n\",cmd.get());\n\t if(script_only)\n\t    goto pre_CHANGING_DIR_TARGET;\n      }\n      target_session->Mkdir(target_dir,mkdir_p);\n      set_state(MAKE_TARGET_DIR);\n      m=MOVED;\n   }\n      /*fallthrough*/\n   case(MAKE_TARGET_DIR):\n      res=target_session->Done();\n      if(res==FA::IN_PROGRESS)\n\t return m;\n      target_session->Close();\n      create_target_dir=false;\n\n   pre_CHANGING_DIR_TARGET:\n      target_session->Chdir(target_dir);\n      target_redirections=0;\n      target_session->Roll();\n      set_state(CHANGING_DIR_TARGET);\n      m=MOVED;\n      /*fallthrough*/\n   case(CHANGING_DIR_TARGET):\n      HandleChdir(target_session,target_redirections);\n      if(state!=CHANGING_DIR_TARGET)\n\t return MOVED;\n      if(target_session->IsOpen())\n\t return m;\n      create_target_dir=false;\n\n      target_dir.set(target_session->GetCwd().GetDirectory());\n\n   pre_GETTING_LIST_INFO:\n      set_state(GETTING_LIST_INFO);\n      m=MOVED;\n      if(!source_set)\n\t HandleListInfoCreation(source_session,source_list_info,source_relative_dir);\n      if(!target_set && !create_target_dir\n      && (!FlagSet(DEPTH_FIRST) || FlagSet(ONLY_EXISTING))\n      && !(FlagSet(TARGET_FLAT) && parent_mirror))\n\t HandleListInfoCreation(target_session,target_list_info,target_relative_dir);\n      if(state!=GETTING_LIST_INFO)\n      {\n\t source_list_info=0;\n\t target_list_info=0;\n      }\n      return m;\t  // give time to other tasks\n   case(GETTING_LIST_INFO):\n      HandleListInfo(source_list_info,source_set);\n      HandleListInfo(target_list_info,target_set,&target_set_excluded);\n      if(state!=GETTING_LIST_INFO)\n\t return MOVED;\n      if(source_list_info || target_list_info)\n\t return m;\n\n      MirrorFinished(); // leave room for transfers.\n\n      if(FlagSet(DEPTH_FIRST) && source_set && !target_set)\n      {\n\t // transfer directories first\n\t InitSets();\n\t to_transfer->Unsort();\n\t to_transfer->SubtractNotDirs();\n\t goto pre_WAITING_FOR_TRANSFER;\n      }\n\n      // now we have both target and source file sets.\n      if(parent_mirror)\n\t stats.dirs++;\n\n      if(FlagSet(SCAN_ALL_FIRST) && parent_mirror)\n      {\n\t source_set->PrependPath(source_relative_dir);\n\t if(root_mirror->source_set_recursive)\n\t    root_mirror->source_set_recursive->Merge(source_set);\n\t else\n\t    root_mirror->source_set_recursive=source_set.borrow();\n\t if(target_set) {\n\t    target_set->PrependPath(target_relative_dir);\n\t    if(root_mirror->target_set_recursive)\n\t       root_mirror->target_set_recursive->Merge(target_set);\n\t    else\n\t       root_mirror->target_set_recursive=target_set.borrow();\n\t }\n\t if(target_set_excluded) {\n\t    target_set_excluded->PrependPath(target_relative_dir);\n\t    if(root_mirror->target_set_excluded)\n\t       root_mirror->target_set_excluded->Merge(target_set_excluded);\n\t    else\n\t       root_mirror->target_set_excluded=target_set_excluded.borrow();\n\t }\n\t root_mirror->stats.dirs++;\n\t transfer_count++; // parent mirror will decrement it.\n\t goto pre_DONE;\n      }\n\n      if(source_set_recursive) {\n\t source_set->Merge(source_set_recursive);\n\t source_set_recursive=0;\n      }\n      if(target_set_recursive) {\n\t target_set->Merge(target_set_recursive);\n\t target_set_recursive=0;\n      }\n      InitSets();\n\n      to_transfer->CountBytes(&bytes_to_transfer);\n      if(parent_mirror)\n\t parent_mirror->AddBytesToTransfer(bytes_to_transfer);\n\n      to_rm->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);\n      to_rm->rewind();\n      to_rm_mismatched->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);\n      to_rm_mismatched->rewind();\n\n      target_set->Merge(target_set_excluded);\n      target_set_excluded=0;\n\n      set_state(TARGET_REMOVE_OLD_FIRST);\n      goto TARGET_REMOVE_OLD_FIRST_label;\n\n   pre_TARGET_MKDIR:\n      if(!to_mkdir)\n\t goto pre_WAITING_FOR_TRANSFER;\n      to_mkdir->rewind();\n      set_state(TARGET_MKDIR);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_MKDIR):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==TARGET_MKDIR)\n      {\n\t file=to_mkdir->curr();\n\t if(!file)\n\t    goto pre_WAITING_FOR_TRANSFER;\n\t to_mkdir->next();\n\t if(!file->TypeIs(file->DIRECTORY))\n\t    continue;\n\t if(script)\n\t    fprintf(script,\"mkdir %s\\n\",target_session->GetFileURL(file->name).get());\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"mkdir\");\n\t    a->Append(file->name);\n\t    mkdirJob *mkj=new mkdirJob(target_session->Clone(),a);\n\t    a->CombineTo(mkj->cmdline);\n\t    JobStarted(mkj);\n\t    m=MOVED;\n\t }\n      }\n      break;\n\n   pre_WAITING_FOR_TRANSFER:\n      to_transfer->rewind();\n      set_state(WAITING_FOR_TRANSFER);\n      m=MOVED;\n      /*fallthrough*/\n   case(WAITING_FOR_TRANSFER):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t TransferFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==WAITING_FOR_TRANSFER)\n      {\n\t file=to_transfer->curr();\n\t if(!file)\n\t {\n\t    // go to the next step only when all transfers have finished\n\t    if(waiting_num>0)\n\t       break;\n\t    if(FlagSet(DEPTH_FIRST))\n\t    {\n\t       // we have been in the depth, don't go there again\n\t       SetFlags(DEPTH_FIRST,false);\n\t       SetFlags(NO_RECURSION,true);\n\n\t       // if we have not created any subdirs and there are only subdirs,\n\t       // then the directory would be empty - skip it.\n\t       if(FlagSet(NO_EMPTY_DIRS) && stats.dirs==0 && only_dirs)\n\t\t  goto pre_FINISHING_FIX_LOCAL;\n\n\t       MirrorStarted();\n\t       goto pre_MAKE_TARGET_DIR;\n\t    }\n\t    goto pre_TARGET_REMOVE_OLD;\n\t }\n\t HandleFile(file);\n\t to_transfer->next();\n\t m=MOVED;\n      }\n      break;\n\n   pre_TARGET_REMOVE_OLD:\n      if(FlagSet(REMOVE_FIRST))\n\t goto pre_TARGET_CHMOD;\n      set_state(TARGET_REMOVE_OLD);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_REMOVE_OLD):\n   case(TARGET_REMOVE_OLD_FIRST):\n   TARGET_REMOVE_OLD_FIRST_label:\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && (state==TARGET_REMOVE_OLD || state==TARGET_REMOVE_OLD_FIRST))\n      {\n\t file=0;\n\t if(!file && state==TARGET_REMOVE_OLD_FIRST)\n\t {\n\t    file=to_rm_mismatched->curr();\n\t    to_rm_mismatched->next();\n\t }\n\t if(!file && (state==TARGET_REMOVE_OLD || FlagSet(REMOVE_FIRST)))\n\t {\n\t    file=to_rm->curr();\n\t    to_rm->next();\n\t }\n\t if(!file)\n\t {\n\t    if(waiting_num>0)\n\t       break;\n\t    if(state==TARGET_REMOVE_OLD)\n\t       goto pre_TARGET_CHMOD;\n\t    goto pre_TARGET_MKDIR;\n\t }\n\t if(!FlagSet(DELETE))\n\t {\n\t    if(FlagSet(REPORT_NOT_DELETED))\n\t    {\n\t       const char *target_name_rel=dir_file(target_relative_dir,file->name);\n\t       if(file->TypeIs(file->DIRECTORY))\n\t\t  Report(_(\"Old directory `%s' is not removed\"),target_name_rel);\n\t       else\n\t\t  Report(_(\"Old file `%s' is not removed\"),target_name_rel);\n\t    }\n\t    continue;\n\t }\n\t if(script)\n\t {\n\t    ArgV args(\"rm\");\n\t    if(file->TypeIs(file->DIRECTORY))\n\t    {\n\t       if(recursion_mode==RECURSION_NEVER)\n\t\t  args.setarg(0,\"rmdir\");\n\t       else\n\t\t  args.Append(\"-r\");\n\t    }\n\t    args.Append(target_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rm\");\n\t    args->Append(file->name);\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(target_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    JobStarted(j);\n\t    if(file->TypeIs(file->DIRECTORY))\n\t    {\n\t       if(recursion_mode==RECURSION_NEVER)\n\t       {\n\t\t  args->setarg(0,\"rmdir\");\n\t\t  j->Rmdir();\n\t       }\n\t       else\n\t\t  j->Recurse();\n\t    }\n\t }\n\t const char *target_name_rel=dir_file(target_relative_dir,file->name);\n\t if(file->TypeIs(file->DIRECTORY))\n\t    Report(_(\"Removing old directory `%s'\"),target_name_rel);\n\t else\n\t    Report(_(\"Removing old file `%s'\"),target_name_rel);\n      }\n      break;\n\n   pre_TARGET_CHMOD:\n      if(FlagSet(NO_PERMS))\n\t goto pre_FINISHING_FIX_LOCAL;\n\n      to_transfer->rewind();\n      if(FlagSet(TARGET_FLAT))\n\t to_transfer->Sort(FileSet::BYNAME_FLAT);\n      set_state(TARGET_CHMOD);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_CHMOD):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==TARGET_CHMOD)\n      {\n\t file=to_transfer->curr();\n\t if(!file)\n\t    goto pre_FINISHING_FIX_LOCAL;\n\t to_transfer->next();\n\t if(file->TypeIs(file->SYMLINK))\n\t    continue;\n\t if(!file->Has(file->MODE))\n\t    continue;\n\t mode_t mode_mask=get_mode_mask();\n\t mode_t def_mode=(file->TypeIs(file->DIRECTORY)?0775:0664)&~mode_mask;\n\t if(target_is_local && file->mode==def_mode)\n\t {\n\t    struct stat st;\n\t    if(!target_is_local || lstat(dir_file(target_dir,file->name),&st)==-1)\n\t       continue;\n\t    if((st.st_mode&07777)==(file->mode&~mode_mask))\n\t       continue;\n\t }\n\t FileInfo *target=target_set->FindByName(file->name);\n\t if(target && target->filetype==file->DIRECTORY && file->filetype==file->DIRECTORY\n\t && target->mode==(file->mode&~mode_mask) && (target->mode&0200))\n\t    continue;\n\t if(script)\n\t {\n\t    ArgV args(\"chmod\");\n\t    args.Append(xstring::format(\"%03lo\",(unsigned long)(file->mode&~mode_mask)));\n\t    args.Append(target_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"chmod\");\n\t    a->Append(file->name);\n\t    a->seek(1);\n\t    ChmodJob *cj=new ChmodJob(target_session->Clone(),\n\t\t\t\t file->mode&~mode_mask,a);\n\t    a->CombineTo(cj->cmdline);\n\t    if(!verbose_report)\n\t       cj->BeQuiet(); // chmod is not supported on all servers; be quiet.\n\t    JobStarted(cj);\n\t    m=MOVED;\n\t }\n      }\n      break;\n\n   pre_FINISHING_FIX_LOCAL:\n      if(target_is_local && !script_only)     // FIXME\n      {\n\t const bool flat=FlagSet(TARGET_FLAT);\n\t to_transfer->Sort(FileSet::BYNAME_FLAT);\n\t to_transfer->LocalUtime(target_dir,/*only_dirs=*/true,flat);\n\t if(FlagSet(ALLOW_CHOWN))\n\t    to_transfer->LocalChown(target_dir,flat);\n\t if(!FlagSet(NO_PERMS) && same)\n\t    same->LocalChmod(target_dir,get_mode_mask(),flat);\n\t if(FlagSet(ALLOW_CHOWN) && same)\n\t    same->LocalChown(target_dir,flat);\n      }\n      if(remove_source_files && (same || to_rm_src))\n\t goto pre_SOURCE_REMOVING_SAME;\n   pre_FINISHING:\n      set_state(FINISHING);\n      m=MOVED;\n      /*fallthrough*/\n   case(FINISHING):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(waiting_num>0)\n\t break;\n\n      // all jobs finished.\n      if(remove_this_source_dir) {\n\t // remove source directory once.\n\t remove_this_source_dir=false;\n\t if(script)\n\t {\n\t    ArgV args(\"rmdir\");\n\t    args.Append(source_session->GetFileURL(source_dir));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rmdir\");\n\t    args->Append(source_dir);\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(source_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    j->Rmdir();\n\t    JobStarted(j);\n\t }\n\t if(source_relative_dir)\n\t    Report(_(\"Removing source directory `%s'\"),source_relative_dir.get());\n\t m=MOVED;\n\t break;\n      }\n\n      // all jobs finished and src dir removed, if needed.\n\n      transfer_count++; // parent mirror will decrement it.\n      if(parent_mirror)\n\t parent_mirror->stats.Add(stats);\n      else\n      {\n\t if(stats.HaveSomethingDone(flags) && on_change)\n\t {\n\t    CmdExec *exec=new CmdExec(source_session->Clone(),0);\n\t    AddWaiting(exec);\n\t    exec->FeedCmd(on_change);\n\t    exec->FeedCmd(\"\\n\");\n\t    set_state(LAST_EXEC);\n\t    break;\n\t }\n      }\n      goto pre_DONE;\n\n   pre_SOURCE_REMOVING_SAME:\n      if(!same)\n\t same=to_rm_src.borrow();\n      else if(to_rm_src)\n\t same->Merge(to_rm_src);\n      same->rewind();\n      set_state(SOURCE_REMOVING_SAME);\n      m=MOVED;\n      /*fallthrough*/\n   case(SOURCE_REMOVING_SAME):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==SOURCE_REMOVING_SAME)\n      {\n\t file=same->curr();\n\t same->next();\n\t if(!file)\n\t    goto pre_FINISHING;\n\t if(file->TypeIs(file->DIRECTORY))\n\t    continue;\n\t if(script)\n\t {\n\t    ArgV args(\"rm\");\n\t    args.Append(source_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rm\");\n\t    args->Append(file->name);\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(source_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    JobStarted(j);\n\t }\n\t const char *source_name_rel=dir_file(source_relative_dir,file->name);\n\t Report(_(\"Removing source file `%s'\"),source_name_rel);\n      }\n      break;\n\n   case(LAST_EXEC):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t RemoveWaiting(j);\n\t Delete(j);\n\t m=MOVED;\n      }\n      if(waiting_num>0)\n\t break;\n   pre_DONE:\n      set_state(DONE);\n      m=MOVED;\n      bytes_transferred=0;\n      if(!parent_mirror && FlagSet(LOOP) && stats.HaveSomethingDone(flags) && !stats.error_count)\n      {\n\t PrintStatus(0,\"\");\n\t printf(_(\"Retrying mirror...\\n\"));\n\t stats.Reset();\n\t source_set=0;\n\t target_set=0;\n\t goto pre_GETTING_LIST_INFO;\n      }\n      /*fallthrough*/\n   case(DONE):\n      break;\n   }\n   // give direct parent priority over grand-parents.\n   if(transfer_count<parallel && parent_mirror)\n      m|=parent_mirror->Roll();\n   return m;\n}\n\nMirrorJob::MirrorJob(MirrorJob *parent,\n   FileAccess *source,FileAccess *target,\n   const char *new_source_dir,const char *new_target_dir)\n :\n   bytes_transferred(0), bytes_to_transfer(0),\n   source_dir(new_source_dir), target_dir(new_target_dir),\n   transfer_time_elapsed(0), root_transfer_count(0),\n   verbose_report(0),\n   parent_mirror(parent), root_mirror(parent?parent->root_mirror:this)\n{\n\n   source_session=source;\n   target_session=target;\n   // TODO: get rid of this.\n   source_is_local=!strcmp(source_session->GetProto(),\"file\");\n   target_is_local=!strcmp(target_session->GetProto(),\"file\");\n\n   create_target_dir=true;\n   no_target_dir=false;\n   remove_this_source_dir=false;\n\n   flags=0;\n   recursion_mode=RECURSION_ALWAYS;\n   max_error_count=0;\n\n   exclude=0;\n\n   set_state(INITIAL_STATE);\n\n   newer_than=NO_DATE;\n   older_than=NO_DATE;\n   size_range=0;\n\n   script=0;\n   script_only=false;\n   script_needs_closing=false;\n\n   use_cache=false;\n   remove_source_files=false;\n   remove_source_dirs=false;\n   skip_noaccess=false;\n\n   parallel=1;\n   pget_n=1;\n   pget_minchunk=0x10000;\n\n   source_redirections=0;\n   target_redirections=0;\n\n   if(parent_mirror)\n   {\n      bool parallel_dirs=ResMgr::QueryBool(\"mirror:parallel-directories\",0);\n      // If parallel_dirs is true, allow parent mirror to continue\n      // processing other directories, otherwise block it until we\n      // get file sets and start transfers.\n      // See also comment at MirrorJob::MirrorStarted().\n      root_transfer_count=parallel_dirs?1:1024;\n\n      // inherit flags and other things\n      SetFlags(parent->flags,1);\n      UseCache(parent->use_cache);\n\n      SetExclude(parent->exclude);\n\n      verbose_report=parent->verbose_report;\n      newer_than=parent->newer_than;\n      older_than=parent->older_than;\n      size_range=parent->size_range;\n      parallel=parent->parallel;\n      pget_n=parent->pget_n;\n      pget_minchunk=parent->pget_minchunk;\n      remove_source_files=parent->remove_source_files;\n      remove_source_dirs=parent->remove_source_dirs;\n      skip_noaccess=parent->skip_noaccess;\n      no_target_dir=parent->no_target_dir;\n      recursion_mode=parent->recursion_mode;\n\n      script=parent->script;\n      script_needs_closing=false;\n      script_name.set(parent->script_name);\n      script_only=parent->script_only;\n\n      max_error_count=parent->max_error_count;\n   }\n   MirrorStarted();\n}\n\nMirrorJob::~MirrorJob()\n{\n   if(script && script_needs_closing)\n      fclose(script);\n}\n\nvoid MirrorJob::va_Report(const char *fmt,va_list v)\n{\n   if(parent_mirror)\n   {\n      parent_mirror->va_Report(fmt,v);\n      return;\n   }\n\n   if(verbose_report)\n   {\n      pid_t p=tcgetpgrp(fileno(stdout));\n      if(p>0 && p!=getpgrp())\n\t return;\n\n      vfprintf(stdout,fmt,v);\n      printf(\"\\n\");\n      fflush(stdout);\n   }\n}\n\nvoid MirrorJob::Report(const char *fmt,...)\n{\n   va_list v;\n   va_start(v,fmt);\n\n   va_Report(fmt,v);\n\n   va_end(v);\n}\n\nextern \"C\" {\n#include \"parse-datetime.h\"\n}\nvoid MirrorJob::SetNewerThan(const char *f)\n{\n   struct timespec ts;\n   if(parse_datetime(&ts,f,0))\n   {\n      newer_than=ts.tv_sec;\n      return;\n   }\n   struct stat st;\n   if(stat(f,&st)==-1)\n   {\n      perror(f);\n      return;\n   }\n   newer_than=st.st_mtime;\n}\nvoid MirrorJob::SetOlderThan(const char *f)\n{\n   struct timespec ts;\n   if(parse_datetime(&ts,f,0))\n   {\n      older_than=ts.tv_sec;\n      return;\n   }\n   struct stat st;\n   if(stat(f,&st)==-1)\n   {\n      perror(f);\n      return;\n   }\n   older_than=st.st_mtime;\n}\n\nmode_t MirrorJob::get_mode_mask()\n{\n   mode_t mode_mask=0;\n   if(!FlagSet(ALLOW_SUID))\n      mode_mask|=S_ISUID|S_ISGID;\n   if(!FlagSet(NO_UMASK))\n   {\n      if(target_is_local)\n      {\n\t mode_t u=umask(022); // get+set\n\t umask(u);\t      // retore\n\t mode_mask|=u;\n      }\n      else\n\t mode_mask|=022;   // sane default.\n   }\n   return mode_mask;\n}\n\nvoid MirrorJob::Fg()\n{\n   Job::Fg();\n   source_session->SetPriority(1);\n   target_session->SetPriority(1);\n}\nvoid MirrorJob::Bg()\n{\n   source_session->SetPriority(0);\n   target_session->SetPriority(0);\n   Job::Bg();\n}\n\nMirrorJob::Statistics::Statistics()\n{\n   Reset();\n   error_count=0;\n   bytes=0;\n   time=0;\n}\nvoid MirrorJob::Statistics::Reset()\n{\n   tot_files=new_files=mod_files=del_files=\n   tot_symlinks=new_symlinks=mod_symlinks=del_symlinks=\n   dirs=del_dirs=0;\n}\nvoid MirrorJob::Statistics::Add(const Statistics &s)\n{\n   tot_files   +=s.tot_files;\n   new_files   +=s.new_files;\n   mod_files   +=s.mod_files;\n   del_files   +=s.del_files;\n   tot_symlinks+=s.tot_symlinks;\n   new_symlinks+=s.new_symlinks;\n   mod_symlinks+=s.mod_symlinks;\n   del_symlinks+=s.del_symlinks;\n   dirs        +=s.dirs;\n   del_dirs    +=s.del_dirs;\n   error_count +=s.error_count;\n   bytes       +=s.bytes;\n   time\t       +=s.time;\n}\nbool MirrorJob::Statistics::HaveSomethingDone(unsigned flags)\n{\n   bool del=(flags&MirrorJob::DELETE);\n   return new_files|mod_files|(del_files*del)|new_symlinks|mod_symlinks|(del_symlinks*del)|(del_dirs*del);\n}\n\nconst char *MirrorJob::SetScriptFile(const char *n)\n{\n   script_name.set(n);\n   if(strcmp(n,\"-\"))\n   {\n      script=fopen(n,\"w\");\n      if(!script)\n\t return xstring::format(\"%s: %s\",n,strerror(errno));\n      setvbuf(script,NULL,_IOLBF,0);\n      script_needs_closing=true;\n   }\n   else\n   {\n      script=stdout;\n      script_needs_closing=false;\n   }\n   return 0;\n}\n\nvoid MirrorJob::SetOnChange(const char *oc)\n{\n   on_change.set(oc);\n}\n\nconst char *MirrorJob::AddPattern(Ref<PatternSet>& exclude,char opt,const char *optarg)\n{\n   PatternSet::Type type=\n      (opt=='x'||opt=='X'||opt=='\\0'?PatternSet::EXCLUDE:PatternSet::INCLUDE);\n   PatternSet::Pattern *pattern=0;\n   if(opt=='x' || opt=='i')\n   {\n      Ref<PatternSet::Regex> rx(new PatternSet::Regex(optarg));\n      if(rx->Error())\n\t return xstring::get_tmp(rx->ErrorText());\n      pattern=rx.borrow();\n   }\n   else if(opt=='X' || opt=='I')\n   {\n      pattern=new PatternSet::Glob(optarg);\n   }\n   if(!exclude)\n   {\n      const char *default_exclude=ResMgr::Query(\"mirror:exclude-regex\",0);\n      const char *default_include=ResMgr::Query(\"mirror:include-regex\",0);\n\n      // don't create default pattern set if not needed\n      if(!pattern && !(default_exclude && *default_exclude))\n\t return NULL;\n\n      exclude=new PatternSet;\n      /* Make default_exclude the first pattern so that it can be\n       * overridden by --include later, and do that only when first\n       * explicit pattern is for exclusion - otherwise all files are\n       * excluded by default and no default exclusion is needed. */\n      if(type==PatternSet::EXCLUDE && default_exclude && *default_exclude)\n      {\n\t exclude->Add(type,new PatternSet::Regex(default_exclude));\n\t if(default_include && *default_include)\n\t    exclude->Add(PatternSet::INCLUDE,new PatternSet::Regex(default_include));\n      }\n   }\n   if(pattern)\n      exclude->Add(type,pattern);\n\n   return NULL; // no error\n}\n\nconst char *MirrorJob::AddPatternsFrom(Ref<PatternSet>& exclude,char opt,const char *file)\n{\n   FILE *f=fopen(file,\"r\");\n   if(!f)\n      return xstring::format(\"%s: %s\",file,strerror(errno));\n\n   xstring line;\n   const char *err=0;\n   int c;\n   while(!feof(f)) {\n      line.truncate();\n      while((c=getc(f))!=EOF && c!='\\n')\n\t line.append(c);\n      if(line.length()>0) {\n\t err=AddPattern(exclude,opt,line);\n\t if(err)\n\t    break;\n      }\n   }\n\n   fclose(f);\n   return err;\n}\n\nconst char *MirrorJob::SetRecursionMode(const char *m)\n{\n   struct { const char name[8]; recursion_mode_t mode; } map[]={\n      {\"always\", RECURSION_ALWAYS},\n      {\"never\",  RECURSION_NEVER},\n      {\"missing\",RECURSION_MISSING},\n      {\"newer\",  RECURSION_NEWER},\n   };\n   unsigned i;\n   for(i=0; i<sizeof(map)/sizeof(map[0]); i++) {\n      if(!strcasecmp(m,map[i].name)) {\n\t recursion_mode=map[i].mode;\n\t return 0;\n      }\n   }\n   xstring list(map[0].name);\n   for(i=1; i<sizeof(map)/sizeof(map[0]); i++)\n      list.append(\", \").append(map[i].name);\n   return xstring::format(_(\"%s must be one of: %s\"),\"--recursion\",list.get());\n}\n\nCMD(mirror)\n{\n#define args (parent->args)\n#define eprintf parent->eprintf\n   enum {\n      OPT_ALLOW_CHOWN,\n      OPT_DELETE_FIRST,\n      OPT_IGNORE_SIZE,\n      OPT_IGNORE_TIME,\n      OPT_LOOP,\n      OPT_MAX_ERRORS,\n      OPT_NO_DEREFERENCE,\n      OPT_NO_SYMLINKS,\n      OPT_NO_UMASK,\n      OPT_OLDER_THAN,\n      OPT_ONLY_MISSING,\n      OPT_ONLY_EXISTING,\n      OPT_PERMS,\n      OPT_REMOVE_SOURCE_FILES,\n      OPT_REMOVE_SOURCE_DIRS,\n      OPT_SCRIPT,\n      OPT_SCRIPT_ONLY,\n      OPT_SIZE_RANGE,\n      OPT_USE_CACHE,\n      OPT_USE_PGET_N,\n      OPT_SKIP_NOACCESS,\n      OPT_ON_CHANGE,\n      OPT_NO_EMPTY_DIRS,\n      OPT_DEPTH_FIRST,\n      OPT_ASCII,\n      OPT_SCAN_ALL_FIRST,\n      OPT_OVERWRITE,\n      OPT_NO_OVERWRITE,\n      OPT_RECURSION,\n      OPT_UPLOAD_OLDER,\n      OPT_TRANSFER_ALL,\n      OPT_TARGET_FLAT,\n      OPT_DELETE_EXCLUDED,\n   };\n   static const struct option mirror_opts[]=\n   {\n      {\"delete\",no_argument,0,'e'},\n      {\"allow-suid\",no_argument,0,'s'},\n      {\"allow-chown\",no_argument,0,OPT_ALLOW_CHOWN},\n      {\"include\",required_argument,0,'i'},\n      {\"exclude\",required_argument,0,'x'},\n      {\"include-glob\",required_argument,0,'I'},\n      {\"exclude-glob\",required_argument,0,'X'},\n      {\"include-rx-from\",required_argument,0,'i'+'f'},\n      {\"exclude-rx-from\",required_argument,0,'x'+'f'},\n      {\"include-glob-from\",required_argument,0,'I'+'f'},\n      {\"exclude-glob-from\",required_argument,0,'X'+'f'},\n      {\"only-newer\",no_argument,0,'n'},\n      {\"no-recursion\",no_argument,0,'r'},\n      {\"no-perms\",no_argument,0,'p'},\n      {\"perms\",no_argument,0,OPT_PERMS},\n      {\"no-umask\",no_argument,0,OPT_NO_UMASK},\n      {\"continue\",no_argument,0,'c'},\n      {\"reverse\",no_argument,0,'R'},\n      {\"verbose\",optional_argument,0,'v'},\n      {\"newer-than\",required_argument,0,'N'},\n      {\"file\",required_argument,0,'f'},\n      {\"directory\",required_argument,0,'F'},\n      {\"older-than\",required_argument,0,OPT_OLDER_THAN},\n      {\"size-range\",required_argument,0,OPT_SIZE_RANGE},\n      {\"dereference\",no_argument,0,'L'},\n      {\"no-dereference\",no_argument,0,OPT_NO_DEREFERENCE},\n      {\"use-cache\",no_argument,0,OPT_USE_CACHE},\n      {\"Remove-source-files\",no_argument,0,OPT_REMOVE_SOURCE_FILES},\n      {\"Remove-source-dirs\",no_argument,0,OPT_REMOVE_SOURCE_DIRS},\n      {\"Move\",no_argument,0,OPT_REMOVE_SOURCE_DIRS},\n      {\"parallel\",optional_argument,0,'P'},\n      {\"ignore-time\",no_argument,0,OPT_IGNORE_TIME},\n      {\"ignore-size\",no_argument,0,OPT_IGNORE_SIZE},\n      {\"only-missing\",no_argument,0,OPT_ONLY_MISSING},\n      {\"only-existing\",no_argument,0,OPT_ONLY_EXISTING},\n      {\"log\",required_argument,0,OPT_SCRIPT},\n      {\"script\",    required_argument,0,OPT_SCRIPT_ONLY},\n      {\"just-print\",optional_argument,0,OPT_SCRIPT_ONLY},\n      {\"dry-run\",   optional_argument,0,OPT_SCRIPT_ONLY},\n      {\"delete-first\",no_argument,0,OPT_DELETE_FIRST},\n      {\"use-pget-n\",optional_argument,0,OPT_USE_PGET_N},\n      {\"no-symlinks\",no_argument,0,OPT_NO_SYMLINKS},\n      {\"loop\",no_argument,0,OPT_LOOP},\n      {\"max-errors\",required_argument,0,OPT_MAX_ERRORS},\n      {\"skip-noaccess\",no_argument,0,OPT_SKIP_NOACCESS},\n      {\"on-change\",required_argument,0,OPT_ON_CHANGE},\n      {\"no-empty-dirs\",no_argument,0,OPT_NO_EMPTY_DIRS},\n      {\"depth-first\",no_argument,0,OPT_DEPTH_FIRST},\n      {\"ascii\",no_argument,0,OPT_ASCII},\n      {\"target-directory\",required_argument,0,'O'},\n      {\"destination-directory\",required_argument,0,'O'},\n      {\"scan-all-first\",no_argument,0,OPT_SCAN_ALL_FIRST},\n      {\"overwrite\",no_argument,0,OPT_OVERWRITE},\n      {\"no-overwrite\",no_argument,0,OPT_NO_OVERWRITE},\n      {\"recursion\",required_argument,0,OPT_RECURSION},\n      {\"upload-older\",no_argument,0,OPT_UPLOAD_OLDER},\n      {\"transfer-all\",no_argument,0,OPT_TRANSFER_ALL},\n      {\"flat\",no_argument,0,OPT_TARGET_FLAT},\n      {\"delete-excluded\",no_argument,0,OPT_DELETE_EXCLUDED},\n      {0}\n   };\n\n   int opt;\n   unsigned flags=0;\n   int max_error_count=0;\n\n   bool use_cache=false;\n\n   FileAccessRef source_session;\n   FileAccessRef target_session;\n\n   int\t verbose=0;\n   const char *newer_than=0;\n   const char *older_than=0;\n   Ref<Range> size_range;\n   bool  remove_source_files=false;\n   bool  remove_source_dirs=false;\n   bool\t skip_noaccess=ResMgr::QueryBool(\"mirror:skip-noaccess\",0);\n   int\t parallel=-1;\n   int\t use_pget=-1;\n   bool\t reverse=false;\n   bool\t script_only=false;\n   bool\t no_empty_dirs=ResMgr::QueryBool(\"mirror:no-empty-dirs\",0);\n   const char *script_file=0;\n   const char *on_change=0;\n   const char *recursion_mode=0;\n   bool single_file=false;\n   bool single_dir=false;\n\n   Ref<PatternSet> exclude;\n   Ref<PatternSet> top_exclude;\n\n   if(!ResMgr::QueryBool(\"mirror:set-permissions\",0))\n      flags|=MirrorJob::NO_PERMS;\n   if(ResMgr::QueryBool(\"mirror:dereference\",0))\n      flags|=MirrorJob::RETR_SYMLINKS;\n   if(ResMgr::QueryBool(\"mirror:overwrite\",0))\n      flags|=MirrorJob::OVERWRITE;\n\n   const char *source_dir=NULL;\n   const char *target_dir=NULL;\n\n   args->rewind();\n   while((opt=args->getopt_long(\"esi:x:I:X:nrpcRvN:LP:af:F:O:\",mirror_opts,0))!=EOF)\n   {\n      switch(opt)\n      {\n      case('e'):\n\t flags|=MirrorJob::DELETE;\n\t break;\n      case('s'):\n\t flags|=MirrorJob::ALLOW_SUID;\n\t break;\n      case(OPT_ALLOW_CHOWN):\n\t flags|=MirrorJob::ALLOW_CHOWN;\n\t break;\n      case('a'):\n\t flags|=MirrorJob::ALLOW_SUID|MirrorJob::ALLOW_CHOWN|MirrorJob::NO_UMASK;\n\t break;\n      case('r'):\n\t recursion_mode=\"never\";\n\t break;\n      case('n'):\n\t flags|=MirrorJob::ONLY_NEWER;\n\t break;\n      case('p'):\n\t flags|=MirrorJob::NO_PERMS;\n\t break;\n      case(OPT_PERMS):\n\t flags&=~MirrorJob::NO_PERMS;\n\t break;\n      case('c'):\n\t flags|=MirrorJob::CONTINUE;\n\t break;\n      case('x'):\n      case('i'):\n      case('X'):\n      case('I'):\n      {\n\t const char *err=MirrorJob::AddPattern(exclude,opt,optarg);\n\t if(err)\n\t {\n\t    eprintf(\"%s: %s\\n\",args->a0(),err);\n\t    goto no_job;\n\t }\n\t break;\n      }\n      case('x'+'f'):\n      case('i'+'f'):\n      case('X'+'f'):\n      case('I'+'f'):\n      {\n\t const char *err=MirrorJob::AddPatternsFrom(exclude,opt-'f',optarg);\n\t if(err)\n\t {\n\t    eprintf(\"%s: %s\\n\",args->a0(),err);\n\t    goto no_job;\n\t }\n\t break;\n      }\n      case('R'):\n\t reverse=true;\n\t break;\n      case('L'):\n\t flags|=MirrorJob::RETR_SYMLINKS;\n\t break;\n      case(OPT_NO_DEREFERENCE):\n\t flags&=~MirrorJob::RETR_SYMLINKS;\n\t break;\n      case('v'):\n\t if(optarg)\n\t    verbose=atoi(optarg);\n\t else\n\t    verbose++;\n\t if(verbose>1)\n\t    flags|=MirrorJob::REPORT_NOT_DELETED;\n\t break;\n      case('N'):\n\t newer_than=optarg;\n\t break;\n      case('f'): // mirror for a single file (or glob pattern).\n\t single_file=true;\n\t /*fallthrough*/\n      case('F'): // mirror for a single directory (or glob pattern).\n      {\n\t xstring pattern(basename_ptr(optarg));\n\t if(opt=='F') {\n\t    single_dir=true;\n\t    if(pattern.last_char()!='/')\n\t       pattern.append('/');\n\t }\n\t if(!top_exclude)\n\t    top_exclude=new PatternSet();\n\t top_exclude->Add(PatternSet::INCLUDE,new PatternSet::Glob(pattern));\n\t const char *dir=dirname(optarg);\n\t if(source_dir && strcmp(source_dir,dir)) {\n\t    eprintf(_(\"%s: multiple --file or --directory options must have the same base directory\\n\"),args->a0());\n\t    goto no_job;\n\t }\n\t if(!source_dir)\n\t    source_dir=alloca_strdup(dir); // save the temp string\n\t break;\n      }\n      case('O'):\n\t target_dir=optarg;\n\t break;\n      case(OPT_OLDER_THAN):\n\t older_than=optarg;\n\t break;\n      case(OPT_SIZE_RANGE):\n\t size_range=new Range(optarg);\n\t if(size_range->Error())\n\t {\n\t    eprintf(\"%s: --size-range \\\"%s\\\": %s\\n\",\n\t       args->a0(),optarg,size_range->ErrorText());\n\t    goto no_job;\n\t }\n\t break;\n      case(OPT_NO_UMASK):\n\t flags|=MirrorJob::NO_UMASK;\n\t break;\n      case(OPT_USE_CACHE):\n\t use_cache=true;\n\t break;\n      case(OPT_REMOVE_SOURCE_FILES):\n\t remove_source_files=true;\n\t break;\n      case(OPT_REMOVE_SOURCE_DIRS):\n\t remove_source_dirs=true;\n\t break;\n      case(OPT_IGNORE_TIME):\n\t flags|=MirrorJob::IGNORE_TIME;\n\t break;\n      case(OPT_IGNORE_SIZE):\n\t flags|=MirrorJob::IGNORE_SIZE;\n\t break;\n      case(OPT_ONLY_MISSING):\n\t flags|=MirrorJob::IGNORE_TIME|MirrorJob::IGNORE_SIZE;\n\t break;\n      case('P'):\n\t if(optarg)\n\t    parallel=atoi(optarg);\n\t else\n\t    parallel=3;\n\t break;\n      case(OPT_USE_PGET_N):\n\t if(optarg)\n\t    use_pget=atoi(optarg);\n\t else\n\t    use_pget=3;\n\t break;\n      case(OPT_SCRIPT_ONLY):\n\t script_only=true;\n      case(OPT_SCRIPT):\n\t script_file=optarg;\n\t if(script_file==0)\n\t    script_file=\"-\";\n\t break;\n      case(OPT_DELETE_FIRST):\n\t flags|=MirrorJob::REMOVE_FIRST|MirrorJob::DELETE;\n\t break;\n      case(OPT_NO_SYMLINKS):\n\t flags|=MirrorJob::NO_SYMLINKS;\n\t break;\n      case(OPT_LOOP):\n\t flags|=MirrorJob::LOOP;\n\t break;\n      case(OPT_MAX_ERRORS):\n\t max_error_count=atoi(optarg);\n\t break;\n      case(OPT_SKIP_NOACCESS):\n\t skip_noaccess=true;\n\t break;\n      case(OPT_ON_CHANGE):\n\t on_change=optarg;\n\t break;\n      case(OPT_ONLY_EXISTING):\n\t flags|=MirrorJob::ONLY_EXISTING;\n\t break;\n      case(OPT_NO_EMPTY_DIRS):\n\t no_empty_dirs=true;\n\t break;\n      case(OPT_DEPTH_FIRST):\n\t flags|=MirrorJob::DEPTH_FIRST;\n\t break;\n      case(OPT_SCAN_ALL_FIRST):\n\t flags|=MirrorJob::SCAN_ALL_FIRST|MirrorJob::DEPTH_FIRST;\n\t break;\n      case(OPT_ASCII):\n\t flags|=MirrorJob::ASCII|MirrorJob::IGNORE_SIZE;\n\t break;\n      case(OPT_OVERWRITE):\n\t flags|=MirrorJob::OVERWRITE;\n\t break;\n      case(OPT_NO_OVERWRITE):\n\t flags&=~MirrorJob::OVERWRITE;\n\t break;\n      case(OPT_RECURSION):\n\t recursion_mode=optarg;\n\t break;\n      case(OPT_UPLOAD_OLDER):\n\t flags|=MirrorJob::UPLOAD_OLDER;\n\t break;\n      case(OPT_TRANSFER_ALL):\n\t flags|=MirrorJob::TRANSFER_ALL;\n\t break;\n      case(OPT_TARGET_FLAT):\n\t flags|=MirrorJob::TARGET_FLAT|MirrorJob::SCAN_ALL_FIRST|MirrorJob::DEPTH_FIRST;\n\t break;\n      case(OPT_DELETE_EXCLUDED):\n\t flags|=MirrorJob::DELETE_EXCLUDED;\n\t break;\n      case('?'):\n\t eprintf(_(\"Try `help %s' for more information.\\n\"),args->a0());\n      no_job:\n\t return 0;\n      }\n   }\n\n   if(exclude && xstrcasecmp(recursion_mode,\"never\"))\n   {\n      /* Users usually don't want to exclude all directories when recursing */\n      if(exclude->GetFirstType()==PatternSet::INCLUDE)\n\t exclude->AddFirst(PatternSet::INCLUDE,new PatternSet::Regex(\"/$\"));\n   }\n\n   /* add default exclusion if no explicit patterns were specified */\n   if(!exclude)\n      MirrorJob::AddPattern(exclude,'\\0',0);\n\n   args->back();\n\n   const char *arg=args->getnext();\n   if(arg)\n   {\n      if(source_dir)\n      {\n\t eprintf(_(\"%s: ambiguous source directory (`%s' or `%s'?)\\n\"),args->a0(),\n\t    source_dir,arg);\n\t goto no_job;\n      }\n      source_dir=arg;\n      ParsedURL source_url(source_dir);\n      if(source_url.proto && source_url.path)\n      {\n\t source_session=FileAccess::New(&source_url);\n\t if(!source_session)\n\t {\n\t    eprintf(\"%s: %s%s\\n\",args->a0(),source_url.proto.get(),\n\t\t     _(\" - not supported protocol\"));\n\t    goto no_job;\n\t }\n\t source_dir=alloca_strdup(source_url.path);\n      }\n      arg=args->getnext();\n      if(arg)\n      {\n\t if(target_dir)\n\t {\n\t    eprintf(_(\"%s: ambiguous target directory (`%s' or `%s'?)\\n\"),args->a0(),\n\t       target_dir,arg);\n\t    goto no_job;\n\t }\n\t target_dir=arg;\n\t ParsedURL target_url(target_dir);\n\t if(target_url.proto && target_url.path)\n\t {\n\t    target_session=FileAccess::New(&target_url);\n\t    if(!target_session)\n\t    {\n\t       eprintf(\"%s: %s%s\\n\",args->a0(),target_url.proto.get(),\n\t\t\t_(\" - not supported protocol\"));\n\t       goto no_job;\n\t    }\n\t    target_dir=alloca_strdup(target_url.path);\n\t }\n\t if(last_char(arg)=='/' && basename_ptr(arg)[0]!='/' && last_char(source_dir)!='/')\n\t {\n\t    // user wants source dir name appended.\n\t    const char *base=basename_ptr(source_dir);\n\t    if(base[0]!='/' && strcmp(base,basename_ptr(arg))) {\n\t       target_dir=xstring::cat(target_dir,base,NULL);\n\t       target_dir=alloca_strdup(target_dir); // save the buffer\n\t    }\n\t }\n      }\n      else\n      {\n\t target_dir=basename_ptr(source_dir);\n\t if(target_dir[0]=='/')\n\t    target_dir=\".\";\n\t else if(target_dir[0]=='~') {\n\t    target_dir=dir_file(\".\",target_dir);\n\t    target_dir=alloca_strdup(target_dir); // save the buffer\n\t }\n      }\n   }\n\n   if(!source_dir) {\n      if(ResMgr::QueryBool(\"mirror:require-source\",0)) {\n\t eprintf(_(\"%s: source directory is required (mirror:require-source is set)\\n\"),args->a0());\n\t return 0;\n      }\n      source_dir=\".\";\n   }\n   if(!target_dir)\n      target_dir=\".\";\n\n   if(!reverse)\n   {\n      if(!source_session)\n\t source_session=parent->session->Clone();\n      if(!target_session)\n\t target_session=FileAccess::New(\"file\");\n   }\n   else //reverse\n   {\n      if(!source_session)\n\t source_session=FileAccess::New(\"file\");\n      if(!target_session)\n\t target_session=parent->session->Clone();\n   }\n\n   if(no_empty_dirs)\n      flags|=MirrorJob::NO_EMPTY_DIRS|MirrorJob::DEPTH_FIRST;\n\n   if(recursion_mode && strcasecmp(recursion_mode,\"always\")\n   && (flags&MirrorJob::DEPTH_FIRST)) {\n      eprintf(\"%s: --recursion-mode=%s conflicts with other specified options\\n\",\n\t args->a0(),recursion_mode);\n      return 0;\n   }\n\n   if(parallel<0) {\n      int parallel1=ResMgr::Query(\"mirror:parallel-transfer-count\",source_session->GetHostName());\n      int parallel2=ResMgr::Query(\"mirror:parallel-transfer-count\",target_session->GetHostName());\n      if(parallel1>0)\n\t parallel=parallel1;\n      if(parallel2>0 && (parallel<0 || parallel>parallel2))\n\t parallel=parallel2;\n   }\n   if(use_pget<0) {\n      int use_pget1=ResMgr::Query(\"mirror:use-pget-n\",source_session->GetHostName());\n      int use_pget2=ResMgr::Query(\"mirror:use-pget-n\",target_session->GetHostName());\n      if(use_pget1>0)\n\t use_pget=use_pget1;\n      if(use_pget2>0 && (use_pget<0 || use_pget>use_pget2))\n\t use_pget=use_pget2;\n   }\n\n   JobRef<MirrorJob> j(new MirrorJob(0,source_session.borrow(),target_session.borrow(),source_dir,target_dir));\n   j->SetFlags(flags,1);\n   j->SetVerbose(verbose);\n   j->SetExclude(exclude.borrow());\n   j->SetTopExclude(top_exclude.borrow());\n\n   if(newer_than)\n      j->SetNewerThan(newer_than);\n   if(older_than)\n      j->SetOlderThan(older_than);\n   if(size_range)\n      j->SetSizeRange(size_range.borrow());\n   j->UseCache(use_cache);\n   if(remove_source_files)\n      j->RemoveSourceFiles();\n   if(remove_source_dirs)\n      j->RemoveSourceDirs();\n   if(skip_noaccess)\n      j->SkipNoAccess();\n   if(parallel<0)\n      parallel=0;\n   if(parallel>64)\n      parallel=64;   // a (in)sane limit.\n   if(parallel)\n      j->SetParallel(parallel);\n   if(use_pget>1 && !(flags&MirrorJob::ASCII))\n      j->SetPGet(use_pget);\n\n   if(!recursion_mode && single_file && !single_dir)\n      recursion_mode=\"never\";\n\n   if(recursion_mode) {\n      const char *err=j->SetRecursionMode(recursion_mode);\n      if(err) {\n\t eprintf(\"%s: %s\\n\",args->a0(),err);\n\t return 0;\n      }\n   }\n   if(script_file)\n   {\n      const char *err=j->SetScriptFile(script_file);\n      if(err)\n      {\n\t eprintf(\"%s: %s\\n\",args->a0(),err);\n\t return 0;\n      }\n   }\n   if(script_only)\n   {\n      j->ScriptOnly();\n      if(!script_file)\n\t j->SetScriptFile(\"-\");\n   }\n   j->SetMaxErrorCount(max_error_count);\n   if(on_change)\n      j->SetOnChange(on_change);\n\n   return j.borrow();\n\n#undef args\n}\n\n#include \"modconfig.h\"\n#ifndef MODULE_CMD_MIRROR\n# define module_init cmd_mirror_module_init\n#endif\nCDECL void module_init()\n{\n   CmdExec::RegisterCommand(\"mirror\",cmd_mirror,0,\n      N_(\"\\n\"\n\t \"Mirror specified remote directory to local directory\\n\"\n\t \"\\n\"\n\t \" -R, --reverse          reverse mirror (put files)\\n\"\n\t \"Lots of other options are documented in the man page lftp(1).\\n\"\n\t \"\\n\"\n\t \"When using -R, the first directory is local and the second is remote.\\n\"\n\t \"If the second directory is omitted, basename of the first directory is used.\\n\"\n\t \"If both directories are omitted, current local and remote directories are used.\\n\"\n\t \"\\n\"\n\t \"See the man page lftp(1) for a complete documentation.\\n\"\n      )\n   );\n}\n"], "fixing_code": ["/*\n * lftp - file transfer program\n *\n * Copyright (c) 1996-2017 by Alexander V. Lukyanov (lav@yars.free.net)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <mbswidth.h>\n#include \"MirrorJob.h\"\n#include \"CmdExec.h\"\n#include \"rmJob.h\"\n#include \"mvJob.h\"\n#include \"ChmodJob.h\"\n#include \"mkdirJob.h\"\n#include \"misc.h\"\n#include \"plural.h\"\n#include \"FindJob.h\"\n#include \"url.h\"\n#include \"CopyJob.h\"\n#include \"pgetJob.h\"\n#include \"log.h\"\n\n#define set_state(s) do { state=(s); \\\n   Log::global->Format(11,\"mirror(%p) enters state %s\\n\", this, #s); } while(0)\n#define waiting_num waiting.count()\n#define transfer_count root_mirror->root_transfer_count\n\nxstring& MirrorJob::FormatStatus(xstring& s,int v,const char *tab)\n{\n   if(Done())\n      goto final;\n\n   switch(state)\n   {\n   case(INITIAL_STATE):\n   case(FINISHING):\n   case(DONE):\n   case(WAITING_FOR_TRANSFER):\n   case(TARGET_REMOVE_OLD):\n   case(TARGET_REMOVE_OLD_FIRST):\n   case(TARGET_CHMOD):\n   case(TARGET_MKDIR):\n   case(SOURCE_REMOVING_SAME):\n   case(LAST_EXEC):\n      break;\n\n   case(MAKE_TARGET_DIR):\n      s.appendf(\"\\tmkdir `%s' [%s]\\n\",target_dir.get(),target_session->CurrentStatus());\n      break;\n\n   case(CHANGING_DIR_SOURCE):\n   case(CHANGING_DIR_TARGET):\n      if(target_session->IsOpen())\n\t s.appendf(\"\\tcd `%s' [%s]\\n\",target_dir.get(),target_session->CurrentStatus());\n      if(source_session->IsOpen())\n\t s.appendf(\"\\tcd `%s' [%s]\\n\",source_dir.get(),source_session->CurrentStatus());\n      break;\n\n   case(GETTING_LIST_INFO):\n      if(target_list_info)\n      {\n\t if(target_relative_dir)\n\t    s.appendf(\"\\t%s: %s\\n\",target_relative_dir.get(),target_list_info->Status());\n\t else\n\t    s.appendf(\"\\t%s\\n\",target_list_info->Status());\n      }\n      if(source_list_info)\n      {\n\t if(source_relative_dir)\n\t    s.appendf(\"\\t%s: %s\\n\",source_relative_dir.get(),source_list_info->Status());\n\t else\n\t    s.appendf(\"\\t%s\\n\",source_list_info->Status());\n      }\n      break;\n   }\n   return s;\n\nfinal:\n   if(stats.dirs>0)\n      s.appendf(plural(\"%sTotal: %d director$y|ies$, %d file$|s$, %d symlink$|s$\\n\",\n\t\t     stats.dirs,stats.tot_files,stats.tot_symlinks),\n\t tab,stats.dirs,stats.tot_files,stats.tot_symlinks);\n   if(stats.new_files || stats.new_symlinks)\n      s.appendf(plural(\"%sNew: %d file$|s$, %d symlink$|s$\\n\",\n\t\t     stats.new_files,stats.new_symlinks),\n\t tab,stats.new_files,stats.new_symlinks);\n   if(stats.mod_files || stats.mod_symlinks)\n      s.appendf(plural(\"%sModified: %d file$|s$, %d symlink$|s$\\n\",\n\t\t     stats.mod_files,stats.mod_symlinks),\n\t tab,stats.mod_files,stats.mod_symlinks);\n   if(stats.bytes)\n      s.appendf(\"%s%s\\n\",tab,CopyJob::FormatBytesTimeRate(stats.bytes,transfer_time_elapsed));\n   if(stats.del_dirs || stats.del_files || stats.del_symlinks)\n      s.appendf(plural(FlagSet(DELETE) ?\n\t       \"%sRemoved: %d director$y|ies$, %d file$|s$, %d symlink$|s$\\n\"\n\t      :\"%sTo be removed: %d director$y|ies$, %d file$|s$, %d symlink$|s$\\n\",\n\t      stats.del_dirs,stats.del_files,stats.del_symlinks),\n\t tab,stats.del_dirs,stats.del_files,stats.del_symlinks);\n   if(stats.error_count)\n      s.appendf(plural(\"%s%d error$|s$ detected\\n\",stats.error_count),\n\t       tab,stats.error_count);\n   return s;\n}\n\nvoid  MirrorJob::ShowRunStatus(const SMTaskRef<StatusLine>& s)\n{\n   int w=s->GetWidthDelayed();\n   switch(state)\n   {\n   case(INITIAL_STATE):\n      break;\n\n   // these have a sub-job\n   case(WAITING_FOR_TRANSFER):\n   case(TARGET_REMOVE_OLD):\n   case(TARGET_REMOVE_OLD_FIRST):\n   case(TARGET_CHMOD):\n   case(TARGET_MKDIR):\n   case(SOURCE_REMOVING_SAME):\n   case(FINISHING):\n   case(DONE):\n   case(LAST_EXEC):\n      Job::ShowRunStatus(s);\n      break;\n\n   case(MAKE_TARGET_DIR):\n      s->Show(\"mkdir `%s' [%s]\",target_dir.get(),target_session->CurrentStatus());\n      break;\n\n   case(CHANGING_DIR_SOURCE):\n   case(CHANGING_DIR_TARGET):\n      if(target_session->IsOpen() && (!source_session->IsOpen() || now%4>=2))\n\t s->Show(\"cd `%s' [%s]\",target_dir.get(),target_session->CurrentStatus());\n      else if(source_session->IsOpen())\n\t s->Show(\"cd `%s' [%s]\",source_dir.get(),source_session->CurrentStatus());\n      break;\n\n   case(GETTING_LIST_INFO):\n      if(target_list_info && (!source_list_info || now%4>=2))\n      {\n\t const char *status=target_list_info->Status();\n\t int status_w=mbswidth(status, 0);\n\t int dw=w-status_w;\n\t if(dw<20)\n\t    dw=20;\n\t if(target_relative_dir)\n\t    s->Show(\"%s: %s\",squeeze_file_name(target_relative_dir,dw),status);\n\t else\n\t    s->Show(\"%s\",status);\n      }\n      else if(source_list_info)\n      {\n\t const char *status=source_list_info->Status();\n\t int status_w=mbswidth(status, 0);\n\t int dw=w-status_w;\n\t if(dw<20)\n\t    dw=20;\n\t if(source_relative_dir)\n\t    s->Show(\"%s: %s\",squeeze_file_name(source_relative_dir,dw),status);\n\t else\n\t    s->Show(\"%s\",status);\n      }\n      break;\n   }\n}\n\nxstring& MirrorJob::FormatShortStatus(xstring& s)\n{\n   if(bytes_to_transfer>0 && (!parent_mirror || parent_mirror->bytes_to_transfer!=bytes_to_transfer)) {\n      long long curr_bytes_transferred=GetBytesCount();\n      if(parent_mirror)\n         curr_bytes_transferred+=bytes_transferred;\n      s.appendf(\"%s/%s (%d%%)\",\n\t xhuman(curr_bytes_transferred),xhuman(bytes_to_transfer),\n\t percent(curr_bytes_transferred,bytes_to_transfer));\n      double rate=GetTransferRate();\n      if(rate>=1)\n\t s.append(' ').append(Speedometer::GetStrProper(rate));\n   }\n   return s;\n}\n\nvoid MirrorJob::TransferStarted(CopyJob *cp)\n{\n   if(transfer_count==0)\n      root_mirror->transfer_start_ts=now;\n   JobStarted(cp);\n}\nvoid MirrorJob::JobStarted(Job *j)\n{\n   AddWaiting(j);\n   transfer_count++;\n}\nvoid MirrorJob::TransferFinished(Job *j)\n{\n   long long bytes_count=j->GetBytesCount();\n   AddBytesTransferred(bytes_count);\n   stats.bytes+=bytes_count;\n   stats.time +=j->GetTimeSpent();\n   if(j->ExitCode()==0 && verbose_report>=2) {\n      xstring finished;\n      const xstring& cmd=j->GetCmdLine();\n      if(cmd[0]=='\\\\')\n\t finished.append(cmd+1,cmd.length()-1);\n      else\n\t finished.append(cmd);\n      const xstring& rate=Speedometer::GetStrProper(j->GetTransferRate());\n      if(rate.length()>0)\n\t finished.append(\" (\").append(rate).append(')');\n      if(!(FlagSet(SCAN_ALL_FIRST) && finished.begins_with(\"mirror\")))\n\t Report(_(\"Finished %s\"),finished.get());\n   }\n   JobFinished(j);\n   if(transfer_count==0)\n      root_mirror->transfer_time_elapsed += now-root_mirror->transfer_start_ts;\n}\nvoid MirrorJob::JobFinished(Job *j)\n{\n   if(j->ExitCode()!=0)\n      stats.error_count++;\n   RemoveWaiting(j);\n   Delete(j);\n   assert(transfer_count>0);\n   transfer_count--;\n}\n\noff_t MirrorJob::GetBytesCount()\n{\n   long long bytes_count=Job::GetBytesCount();\n   if(!parent_mirror) {\n      // bytes_transferred is cumulative over the mirror tree,\n      // add it on the top only\n      bytes_count+=bytes_transferred;\n   }\n   return bytes_count;\n}\ndouble MirrorJob::GetTimeSpent()\n{\n   double t=transfer_time_elapsed;\n   if(transfer_count>0)\n      t+=now-root_mirror->transfer_start_ts;\n   return t;\n}\n\nvoid  MirrorJob::HandleFile(FileInfo *file)\n{\n   int\t res;\n   struct stat st;\n\n   // TODO: get rid of local hacks.\n\n   const char *dst_name=file->name;\n   if(FlagSet(TARGET_FLAT))\n      dst_name=basename_ptr(dst_name);\n\n   // dir_name returns pointer to static data - need to dup it.\n   const char *source_name=dir_file(source_dir,file->name);\n   source_name=alloca_strdup(source_name);\n   const char *target_name=dir_file(target_dir,dst_name);\n   target_name=alloca_strdup(target_name);\n\n   const char *source_name_rel=dir_file(source_relative_dir,file->name);\n   source_name_rel=alloca_strdup(source_name_rel);\n   const char *target_name_rel=dir_file(target_relative_dir,dst_name);\n   target_name_rel=alloca_strdup(target_name_rel);\n\n   FileInfo::type filetype=FileInfo::NORMAL;\n   if(file->Has(file->TYPE))\n      filetype=file->filetype;\n   else\n   {\n      FileInfo *target=target_set->FindByName(file->name);\n      if(target && target->Has(target->TYPE))\n\t filetype=target->filetype;\n   }\n\n   switch(filetype)\n   {\n      case(FileInfo::NORMAL):\n      case(FileInfo::REDIRECT):\n      {\n\t bool remove_target=false;\n\t bool cont_this=false;\n\t bool use_pget=(pget_n>1) && target_is_local;\n\t if(file->Has(file->SIZE) && file->size<pget_minchunk*2)\n\t    use_pget=false;\n\t if(target_is_local)\n\t {\n\t    if(lstat(target_name,&st)!=-1)\n\t    {\n\t       // few safety checks.\n\t       FileInfo *old=new_files_set->FindByName(file->name);\n\t       if(old)\n\t\t  goto skip;  // file has appeared after mirror start\n\t       old=old_files_set->FindByName(file->name);\n\t       if(old && ((old->Has(old->SIZE) && old->size!=st.st_size)\n\t\t\t||(old->Has(old->DATE) && old->date!=st.st_mtime)))\n\t\t  goto skip;  // the file has changed after mirror start\n\t       if(!script_only && access(target_name,W_OK)==-1)\n\t       {\n\t\t  // try to enable write access.\n\t\t  chmod(target_name,st.st_mode|0200);\n\t       }\n\t    }\n\t }\n\t FileInfo *old=target_set->FindByName(FileCopy::TempFileName(file->name));\n\t if(old)\n\t {\n\t    if(FlagSet(CONTINUE)\n\t    && old->Has(file->TYPE) && old->filetype==old->NORMAL\n\t    && (FlagSet(IGNORE_TIME) ||\n\t\t(file->Has(file->DATE) && old->Has(old->DATE)\n\t\t&& file->date + file->date.ts_prec < old->date - old->date.ts_prec))\n\t    && file->Has(file->SIZE) && old->Has(old->SIZE)\n\t    && file->size >= old->size)\n\t    {\n\t       cont_this=true;\n\t       stats.mod_files++;\n\t    }\n\t    else if(!to_rm_mismatched->FindByName(file->name))\n\t    {\n\t       if(!FlagSet(OVERWRITE)) {\n\t\t  remove_target=true;\n\t\t  Report(_(\"Removing old file `%s'\"),target_name_rel);\n\t       } else {\n\t\t  Report(_(\"Overwriting old file `%s'\"),target_name_rel);\n\t       }\n\t       stats.mod_files++;\n\t    }\n\t    else\n\t       stats.new_files++;\n\t }\n\t else if(FlagSet(ONLY_EXISTING))\n\t {\n\t    Report(_(\"Skipping file `%s' (only-existing)\"),source_name_rel);\n\t    goto skip;\n\t }\n\t else\n\t    stats.new_files++;\n\n\t Report(_(\"Transferring file `%s'\"),source_name_rel);\n\n\t if(script)\n\t {\n\t    ArgV args(use_pget?\"pget\":\"get\");\n\t    if(use_pget)\n\t    {\n\t       args.Append(\"-n\");\n\t       args.Append(pget_n);\n\t    }\n\t    if(cont_this)\n\t       args.Append(\"-c\");\n\t    if(remove_target)\n\t       args.Append(\"-e\");\n\t    if(FlagSet(ASCII))\n\t       args.Append(\"-a\");\n\t    if(remove_source_files)\n\t       args.Append(\"-E\");\n\t    args.Append(\"-O\");\n\t    args.Append(target_is_local?target_dir.get()\n\t\t\t:target_session->GetConnectURL().get());\n\t    args.Append(source_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t    if(script_only)\n\t       goto skip;\n\t }\n\n\t FileCopyPeer *src_peer=0;\n\t if(source_is_local)\n\t    src_peer=new FileCopyPeerFDStream(new FileStream(source_name,O_RDONLY),FileCopyPeer::GET);\n\t else\n\t    src_peer=new FileCopyPeerFA(source_session->Clone(),file->name,FA::RETRIEVE);\n\n\t FileCopyPeer *dst_peer=0;\n\t if(target_is_local)\n\t    dst_peer=new FileCopyPeerFDStream(new FileStream(target_name,O_WRONLY|O_CREAT|(cont_this?0:O_TRUNC)),FileCopyPeer::PUT);\n\t else\n\t    dst_peer=new FileCopyPeerFA(target_session->Clone(),dst_name,FA::STORE);\n\n\t FileCopy *c=FileCopy::New(src_peer,dst_peer,cont_this);\n\t if(remove_source_files)\n\t    c->RemoveSourceLater();\n\t if(remove_target)\n\t    c->RemoveTargetFirst();\n\t if(FlagSet(ASCII))\n\t    c->Ascii();\n\t CopyJob *cp=(use_pget ? new pgetJob(c,file->name,pget_n) : new CopyJob(c,file->name,\"mirror\"));\n\t if(file->Has(file->DATE))\n\t    cp->SetDate(file->date);\n\t if(file->Has(file->SIZE) && !FlagSet(IGNORE_SIZE))\n\t    cp->SetSize(file->size);\n\t TransferStarted(cp);\n\t cp->cmdline.vset(\"\\\\transfer `\",source_name_rel,\"'\",NULL);\n\n\t set_state(WAITING_FOR_TRANSFER);\n\t break;\n      }\n      case(FileInfo::DIRECTORY):\n      {\n\t if(recursion_mode==RECURSION_NEVER || FlagSet(NO_RECURSION))\n\t    goto skip;\n\n\t bool create_target_subdir=true;\n\t const FileInfo *old=0;\n\n\t if(FlagSet(TARGET_FLAT)) {\n\t    create_target_subdir=false;\n\t    target_name=target_dir;\n\t    goto do_submirror;\n\t }\n\n\t if(target_set)\n\t    old=target_set->FindByName(file->name);\n\t if(!old)\n\t {\n\t    if(FlagSet(ONLY_EXISTING))\n\t    {\n\t       Report(_(\"Skipping directory `%s' (only-existing)\"),target_name_rel);\n\t       goto skip;\n\t    }\n\t }\n\t else if(old->TypeIs(old->DIRECTORY))\n\t {\n\t    create_target_subdir=false;\n\t }\n\t if(target_is_local && !script_only)\n\t {\n\t    if((FlagSet(RETR_SYMLINKS)?stat:lstat)(target_name,&st)!=-1)\n\t    {\n\t       if(S_ISDIR(st.st_mode))\n\t       {\n\t\t  // try to enable write access\n\t\t  // only if not enabled as chmod can clear sgid flags on directories\n\t\t  if(st.st_mode!=(st.st_mode|0700))\n\t\t     chmod(target_name,st.st_mode|0700);\n\t\t  create_target_subdir=false;\n\t       }\n\t       else\n\t       {\n\t\t  Report(_(\"Removing old local file `%s'\"),target_name_rel);\n\t\t  if(remove(target_name)==-1)\n\t\t  {\n\t\t     eprintf(\"mirror: remove(%s): %s\\n\",target_name,strerror(errno));\n\t\t     goto skip;\n\t\t  }\n\t\t  create_target_subdir=true;\n\t       }\n\t    }\n\t }\n\n      do_submirror:\n\t // launch sub-mirror\n\t MirrorJob *mj=new MirrorJob(this,\n\t    source_session->Clone(),target_session->Clone(),\n\t    source_name,target_name);\n\t AddWaiting(mj);\n\t mj->cmdline.vset(\"\\\\mirror `\",source_name_rel,\"'\",NULL);\n\n\t mj->source_relative_dir.set(source_name_rel);\n\t mj->target_relative_dir.set(target_name_rel);\n\n\t mj->create_target_dir=create_target_subdir;\n\n\t if(verbose_report>=3) {\n\t    if(FlagSet(SCAN_ALL_FIRST))\n\t       Report(_(\"Scanning directory `%s'\"),mj->target_relative_dir.get());\n\t    else\n\t       Report(_(\"Mirroring directory `%s'\"),mj->target_relative_dir.get());\n\t }\n\n\t break;\n      }\n      case(FileInfo::SYMLINK):\n      {\n\t if(FlagSet(NO_SYMLINKS))\n\t    goto skip;\n\n\t if(!file->symlink)\n\t    goto skip;\n\n\t if(!target_is_local)\n\t {\n\t    if(script)\n\t    {\n\t       ArgV args(\"ln\");\n\t       args.Append(\"-s\");\n\t       args.Append(file->symlink);\n\t       args.Append(target_name);\n\t       xstring_ca cmd(args.CombineQuoted());\n\t       fprintf(script,\"%s\\n\",cmd.get());\n\t       if(script_only)\n\t\t  goto skip;\n\t    }\n\t    bool remove_target=false;\n\t    FileInfo *old=target_set->FindByName(file->name);\n\t    if(old && !to_rm_mismatched->FindByName(file->name))\n\t    {\n\t       Report(_(\"Removing old file `%s'\"),target_name_rel);\n\t       remove_target=true;\n\t       stats.mod_symlinks++;\n\t    }\n\t    else\n\t       stats.new_symlinks++;\n\t    Report(_(\"Making symbolic link `%s' to `%s'\"),target_name_rel,file->symlink.get());\n\t    mvJob *j=new mvJob(target_session->Clone(),file->symlink,target_name,FA::SYMLINK);\n\t    if(remove_target)\n\t       j->RemoveTargetFirst();\n\t    JobStarted(j);\n\t    RemoveSourceLater(file);\n\t    break;\n\t }\n\n\t if(script)\n\t {\n\t    ArgV args(\"shell\");\n\t    args.Append(\"ln\");\n\t    args.Append(\"-sf\");\n\t    args.Append(shell_encode(file->symlink));\n\t    args.Append(shell_encode(target_name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t    if(script_only)\n\t       goto skip;\n\t }\n\n\t struct stat st;\n\t if(lstat(target_name,&st)!=-1)\n\t {\n\t    Report(_(\"Removing old local file `%s'\"),target_name_rel);\n\t    stats.mod_symlinks++;\n\t    if(remove(target_name)==-1)\n\t    {\n\t       eprintf(\"mirror: remove(%s): %s\\n\",target_name,strerror(errno));\n\t       goto skip;\n\t    }\n\t }\n\t else\n\t {\n\t    if(FlagSet(ONLY_EXISTING))\n\t    {\n\t       Report(_(\"Skipping symlink `%s' (only-existing)\"),target_name_rel);\n\t       goto skip;\n\t    }\n\t    stats.new_symlinks++;\n\t }\n\t Report(_(\"Making symbolic link `%s' to `%s'\"),target_name_rel,file->symlink.get());\n\t res=symlink(file->symlink,target_name);\n\t if(res==-1)\n\t    eprintf(\"mirror: symlink(%s): %s\\n\",target_name,strerror(errno));\n\t RemoveSourceLater(file);\n\t break;\n      }\n   case FileInfo::UNKNOWN:\n      break;\n   }\nskip:\n   return;\n}\n\nvoid  MirrorJob::InitSets()\n{\n   if(FlagSet(TARGET_FLAT) && !parent_mirror && target_set)\n      source_set->Sort(FileSet::BYNAME_FLAT);\n\n   source_set->Count(NULL,&stats.tot_files,&stats.tot_symlinks,&stats.tot_files);\n\n   to_rm=new FileSet(target_set);\n   to_rm->SubtractAny(source_set);\n\n   if(FlagSet(DELETE_EXCLUDED) && target_set_excluded)\n      to_rm->Merge(target_set_excluded);\n\n   to_transfer=new FileSet(source_set);\n\n   if(!FlagSet(TRANSFER_ALL)) {\n      same=new FileSet(source_set);\n\n      int ignore=0;\n      if(FlagSet(ONLY_NEWER))\n\t ignore|=FileInfo::IGNORE_SIZE_IF_OLDER|FileInfo::IGNORE_DATE_IF_OLDER;\n      if(!FlagSet(UPLOAD_OLDER) && strcmp(target_session->GetProto(),\"file\"))\n\t ignore|=FileInfo::IGNORE_DATE_IF_OLDER;\n      if(FlagSet(IGNORE_TIME))\n\t ignore|=FileInfo::DATE;\n      if(FlagSet(IGNORE_SIZE))\n\t ignore|=FileInfo::SIZE;\n      to_transfer->SubtractSame(target_set,ignore);\n\n      same->SubtractAny(to_transfer);\n   }\n\n   if(newer_than!=NO_DATE)\n      to_transfer->SubtractNotNewerThan(newer_than);\n   if(older_than!=NO_DATE)\n      to_transfer->SubtractNotOlderThan(older_than);\n   if(size_range)\n      to_transfer->SubtractSizeOutside(size_range);\n\n   if(FlagSet(SCAN_ALL_FIRST)) {\n      to_mkdir=new FileSet(to_transfer);\n      to_mkdir->SubtractNotDirs();\n      to_mkdir->SubtractAny(target_set);\n   }\n\n   switch(recursion_mode) {\n   case RECURSION_NEVER:\n      to_transfer->SubtractDirs();\n      break;\n   case RECURSION_MISSING:\n      to_transfer->SubtractDirs(target_set);\n      break;\n   case RECURSION_NEWER:\n      to_transfer->SubtractNotOlderDirs(target_set);\n      break;\n   case RECURSION_ALWAYS:\n      break;\n   }\n\n   if(skip_noaccess)\n      to_transfer->ExcludeUnaccessible(source_session->GetUser());\n\n   new_files_set=new FileSet(to_transfer);\n   new_files_set->SubtractAny(target_set);\n   old_files_set=new FileSet(target_set);\n   old_files_set->SubtractNotIn(to_transfer);\n\n   to_rm_mismatched=new FileSet(old_files_set);\n   to_rm_mismatched->SubtractSameType(to_transfer);\n   to_rm_mismatched->SubtractNotDirs();\n\n   if(!FlagSet(DELETE))\n      to_transfer->SubtractAny(to_rm_mismatched);\n\n   if(FlagSet(TARGET_FLAT) && !parent_mirror && target_set) {\n      source_set->Unsort();\n      to_transfer->UnsortFlat();\n      to_transfer->SubtractDirs();\n      same->UnsortFlat();\n      to_mkdir->Empty();\n      new_files_set->UnsortFlat();\n   }\n\n   const char *sort_by=ResMgr::Query(\"mirror:sort-by\",0);\n   bool desc=strstr(sort_by,\"-desc\");\n   if(!strncmp(sort_by,\"name\",4))\n      to_transfer->SortByPatternList(ResMgr::Query(\"mirror:order\",0));\n   else if(!strncmp(sort_by,\"date\",4))\n      to_transfer->Sort(FileSet::BYDATE);\n   else if(!strncmp(sort_by,\"size\",4))\n      to_transfer->Sort(FileSet::BYSIZE,false,true);\n   if(desc)\n      to_transfer->ReverseSort();\n\n   int dir_count=0;\n   if(to_mkdir) {\n      to_mkdir->Count(&dir_count,NULL,NULL,NULL);\n      only_dirs = (dir_count==to_mkdir->count());\n   } else {\n      to_transfer->Count(&dir_count,NULL,NULL,NULL);\n      only_dirs = (dir_count==to_transfer->count());\n   }\n}\n\n/* root_transfer_count of child mirrors contains the value to add or\n   subtract from transfer_count when doing \"cd\", \"mkdir\", \"ls\" on the source\n   or target directories. This would prevent other mirrors (siblings, etc)\n   from starting more jobs.\n\n   root_transfer_count is initialized once in ctor, so that change of\n   mirror:parallel-directories setting won't disbalance the count.\n*/\nvoid MirrorJob::MirrorStarted()\n{\n   if(!parent_mirror)\n      return;\n   transfer_count+=root_transfer_count;\n}\nvoid MirrorJob::MirrorFinished()\n{\n   if(!parent_mirror)\n      return;\n   assert(transfer_count>=root_transfer_count);\n   transfer_count-=root_transfer_count;\n}\n\nvoid MirrorJob::HandleChdir(FileAccessRef& session, int &redirections)\n{\n   if(!session->IsOpen())\n      return;\n   int res=session->Done();\n   if(res<0)\n   {\n      if(res==FA::FILE_MOVED)\n      {\n\t // cd to another url.\n\t const char *loc_c=session->GetNewLocation();\n\t int max_redirections=ResMgr::Query(\"xfer:max-redirections\",0);\n\t if(loc_c && max_redirections>0)\n\t {\n\t    if(++redirections>max_redirections)\n\t       goto cd_err_normal;\n\t    eprintf(_(\"%s: received redirection to `%s'\\n\"),\"mirror\",loc_c);\n\n\t    char *loc=alloca_strdup(loc_c);\n\t    ParsedURL u(loc,true);\n\n\t    bool is_file=(last_char(loc)!='/');\n\t    if(!u.proto)\n\t    {\n\t       FileAccess::Path new_cwd(session->GetNewCwd());\n\t       new_cwd.Change(0,is_file,loc);\n\t       session->PathVerify(new_cwd);\n\t       session->Roll();\n\t       return;\n\t    }\n\t    session->Close(); // loc_c is no longer valid.\n\t    session=FA::New(&u);\n\t    FileAccess::Path new_cwd(u.path,is_file,url::path_ptr(loc));\n\t    session->PathVerify(new_cwd);\n\t    return;\n\t }\n      }\n   cd_err_normal:\n      if(session==target_session && (script_only || FlagSet(SCAN_ALL_FIRST)))\n      {\n\t char *dir=alloca_strdup(session->GetFile());\n\t session->Close();\n\t session->Chdir(dir,false);\n\t no_target_dir=true;\n\t return;\n      }\n      if(session==source_session && create_target_dir\n      && !FlagSet(NO_EMPTY_DIRS) && !skip_noaccess && parent_mirror)\n      {\n\t // create target dir even if failed to cd to source dir.\n\t if(script)\n\t    fprintf(script,\"mkdir %s\\n\",target_session->GetFileURL(target_dir).get());\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"mkdir\");\n\t    a->Append(target_dir);\n\t    mkdirJob *mkj=new mkdirJob(target_session->Clone(),a);\n\t    a->CombineTo(mkj->cmdline);\n\t    JobStarted(mkj);\n\t }\n      }\n      remove_this_source_dir=false;\n      eprintf(\"mirror: %s\\n\",session->StrError(res));\n      stats.error_count++;\n      MirrorFinished();\n      set_state(FINISHING);\n      source_session->Close();\n      target_session->Close();\n      return;\n   }\n   if(res==FA::OK)\n      session->Close();\n}\nvoid MirrorJob::HandleListInfoCreation(const FileAccessRef& session,SMTaskRef<ListInfo>& list_info,const char *relative_dir)\n{\n   if(state!=GETTING_LIST_INFO)\n      return;\n\n   if(session==target_session && no_target_dir)\n   {\n      target_set=new FileSet();\n      return;\n   }\n\n   list_info=session->MakeListInfo();\n   if(list_info==0)\n   {\n      eprintf(_(\"mirror: protocol `%s' is not suitable for mirror\\n\"),\n\t       session->GetProto());\n      MirrorFinished();\n      set_state(FINISHING);\n      return;\n   }\n   list_info->UseCache(use_cache);\n   int need=FileInfo::ALL_INFO;\n   if(FlagSet(IGNORE_TIME))\n      need&=~FileInfo::DATE;\n   if(FlagSet(IGNORE_SIZE))\n      need&=~FileInfo::SIZE;\n   list_info->Need(need);\n   if(FlagSet(RETR_SYMLINKS))\n      list_info->FollowSymlinks();\n\n   list_info->SetExclude(relative_dir,top_exclude?top_exclude:exclude);\n   list_info->Roll();\n}\n\nvoid MirrorJob::HandleListInfo(SMTaskRef<ListInfo>& list_info, Ref<FileSet>& set, Ref<FileSet> *fsx)\n{\n   if(!list_info)\n      return;\n   if(!list_info->Done())\n      return;\n   if(list_info->Error())\n   {\n      eprintf(\"mirror: %s\\n\",list_info->ErrorText());\n      stats.error_count++;\n      MirrorFinished();\n      set_state(FINISHING);\n      source_list_info=0;\n      target_list_info=0;\n      return;\n   }\n   set=list_info->GetResult();\n   if(fsx)\n      *fsx=list_info->GetExcluded();\n   list_info=0;\n   set->ExcludeDots(); // don't need .. and .\n}\n\nint   MirrorJob::Do()\n{\n   int\t res;\n   int\t m=STALL;\n   FileInfo *file;\n   Job\t *j;\n\n   switch(state)\n   {\n   case(INITIAL_STATE):\n      remove_this_source_dir=(remove_source_dirs && source_dir.last_char()!='/');\n      if(!strcmp(target_dir,\".\") || !strcmp(target_dir,\"..\") || (FlagSet(SCAN_ALL_FIRST) && parent_mirror))\n\t create_target_dir=false;\n\n      source_session->Chdir(source_dir);\n      source_redirections=0;\n      source_session->Roll();\n      set_state(CHANGING_DIR_SOURCE);\n      m=MOVED;\n      /*fallthrough*/\n   case(CHANGING_DIR_SOURCE):\n      HandleChdir(source_session,source_redirections);\n      if(state!=CHANGING_DIR_SOURCE)\n\t return MOVED;\n      if(source_session->IsOpen())\n\t return m;\n\n      source_dir.set(source_session->GetCwd().GetDirectory());\n\n   pre_MAKE_TARGET_DIR:\n   {\n      if(!create_target_dir)\n\t goto pre_CHANGING_DIR_TARGET;\n      if(target_is_local)\n      {\n\t struct stat st;\n\t if((FlagSet(RETR_SYMLINKS)?stat:lstat)(target_dir,&st)!=-1)\n\t {\n\t    if(S_ISDIR(st.st_mode))\n\t    {\n\t       // try to enable write access\n\t       // only if not enabled as chmod can clear sgid flags on directories\n\t       if(!script_only && (st.st_mode!=(st.st_mode|0700)))\n\t\t  chmod(target_dir,st.st_mode|0700);\n\t       create_target_dir=false;\n\t       goto pre_CHANGING_DIR_TARGET;\n\t    }\n\t    else\n\t    {\n\t       Report(_(\"Removing old local file `%s'\"),target_dir.get());\n\t       if(script)\n\t       {\n\t\t  ArgV args(\"rm\");\n\t\t  args.Append(target_session->GetFileURL(target_dir));\n\t\t  xstring_ca cmd(args.CombineQuoted());\n\t\t  fprintf(script,\"%s\\n\",cmd.get());\n\t       }\n\t       if(!script_only)\n\t       {\n\t\t  if(remove(target_dir)==-1)\n\t\t     eprintf(\"mirror: remove(%s): %s\\n\",target_dir.get(),strerror(errno));\n\t       }\n\t    }\n\t }\n      }\n\n      if(FlagSet(DEPTH_FIRST))\n\t goto pre_GETTING_LIST_INFO;\n\n      if(target_relative_dir)\n\t Report(_(\"Making directory `%s'\"),target_relative_dir.get());\n      bool mkdir_p=(parent_mirror==0 || parent_mirror->create_target_dir);\n      if(script)\n      {\n\t ArgV args(\"mkdir\");\n\t if(mkdir_p)\n\t    args.Append(\"-p\");\n\t args.Append(target_session->GetFileURL(target_dir));\n\t xstring_ca cmd(args.CombineQuoted());\n\t fprintf(script,\"%s\\n\",cmd.get());\n\t if(script_only)\n\t    goto pre_CHANGING_DIR_TARGET;\n      }\n      target_session->Mkdir(target_dir,mkdir_p);\n      set_state(MAKE_TARGET_DIR);\n      m=MOVED;\n   }\n      /*fallthrough*/\n   case(MAKE_TARGET_DIR):\n      res=target_session->Done();\n      if(res==FA::IN_PROGRESS)\n\t return m;\n      target_session->Close();\n      create_target_dir=false;\n\n   pre_CHANGING_DIR_TARGET:\n      target_session->Chdir(target_dir);\n      target_redirections=0;\n      target_session->Roll();\n      set_state(CHANGING_DIR_TARGET);\n      m=MOVED;\n      /*fallthrough*/\n   case(CHANGING_DIR_TARGET):\n      HandleChdir(target_session,target_redirections);\n      if(state!=CHANGING_DIR_TARGET)\n\t return MOVED;\n      if(target_session->IsOpen())\n\t return m;\n      create_target_dir=false;\n\n      target_dir.set(target_session->GetCwd().GetDirectory());\n\n   pre_GETTING_LIST_INFO:\n      set_state(GETTING_LIST_INFO);\n      m=MOVED;\n      if(!source_set)\n\t HandleListInfoCreation(source_session,source_list_info,source_relative_dir);\n      if(!target_set && !create_target_dir\n      && (!FlagSet(DEPTH_FIRST) || FlagSet(ONLY_EXISTING))\n      && !(FlagSet(TARGET_FLAT) && parent_mirror))\n\t HandleListInfoCreation(target_session,target_list_info,target_relative_dir);\n      if(state!=GETTING_LIST_INFO)\n      {\n\t source_list_info=0;\n\t target_list_info=0;\n      }\n      return m;\t  // give time to other tasks\n   case(GETTING_LIST_INFO):\n      HandleListInfo(source_list_info,source_set);\n      HandleListInfo(target_list_info,target_set,&target_set_excluded);\n      if(state!=GETTING_LIST_INFO)\n\t return MOVED;\n      if(source_list_info || target_list_info)\n\t return m;\n\n      MirrorFinished(); // leave room for transfers.\n\n      if(FlagSet(DEPTH_FIRST) && source_set && !target_set)\n      {\n\t // transfer directories first\n\t InitSets();\n\t to_transfer->Unsort();\n\t to_transfer->SubtractNotDirs();\n\t goto pre_WAITING_FOR_TRANSFER;\n      }\n\n      // now we have both target and source file sets.\n      if(parent_mirror)\n\t stats.dirs++;\n\n      if(FlagSet(SCAN_ALL_FIRST) && parent_mirror)\n      {\n\t source_set->PrependPath(source_relative_dir);\n\t if(root_mirror->source_set_recursive)\n\t    root_mirror->source_set_recursive->Merge(source_set);\n\t else\n\t    root_mirror->source_set_recursive=source_set.borrow();\n\t if(target_set) {\n\t    target_set->PrependPath(target_relative_dir);\n\t    if(root_mirror->target_set_recursive)\n\t       root_mirror->target_set_recursive->Merge(target_set);\n\t    else\n\t       root_mirror->target_set_recursive=target_set.borrow();\n\t }\n\t if(target_set_excluded) {\n\t    target_set_excluded->PrependPath(target_relative_dir);\n\t    if(root_mirror->target_set_excluded)\n\t       root_mirror->target_set_excluded->Merge(target_set_excluded);\n\t    else\n\t       root_mirror->target_set_excluded=target_set_excluded.borrow();\n\t }\n\t root_mirror->stats.dirs++;\n\t transfer_count++; // parent mirror will decrement it.\n\t goto pre_DONE;\n      }\n\n      if(source_set_recursive) {\n\t source_set->Merge(source_set_recursive);\n\t source_set_recursive=0;\n      }\n      if(target_set_recursive) {\n\t target_set->Merge(target_set_recursive);\n\t target_set_recursive=0;\n      }\n      InitSets();\n\n      to_transfer->CountBytes(&bytes_to_transfer);\n      if(parent_mirror)\n\t parent_mirror->AddBytesToTransfer(bytes_to_transfer);\n\n      to_rm->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);\n      to_rm->rewind();\n      to_rm_mismatched->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);\n      to_rm_mismatched->rewind();\n\n      target_set->Merge(target_set_excluded);\n      target_set_excluded=0;\n\n      set_state(TARGET_REMOVE_OLD_FIRST);\n      goto TARGET_REMOVE_OLD_FIRST_label;\n\n   pre_TARGET_MKDIR:\n      if(!to_mkdir)\n\t goto pre_WAITING_FOR_TRANSFER;\n      to_mkdir->rewind();\n      set_state(TARGET_MKDIR);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_MKDIR):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==TARGET_MKDIR)\n      {\n\t file=to_mkdir->curr();\n\t if(!file)\n\t    goto pre_WAITING_FOR_TRANSFER;\n\t to_mkdir->next();\n\t if(!file->TypeIs(file->DIRECTORY))\n\t    continue;\n\t if(script)\n\t    fprintf(script,\"mkdir %s\\n\",target_session->GetFileURL(file->name).get());\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"mkdir\");\n\t    a->Append(file->name);\n\t    mkdirJob *mkj=new mkdirJob(target_session->Clone(),a);\n\t    a->CombineTo(mkj->cmdline);\n\t    JobStarted(mkj);\n\t    m=MOVED;\n\t }\n      }\n      break;\n\n   pre_WAITING_FOR_TRANSFER:\n      to_transfer->rewind();\n      set_state(WAITING_FOR_TRANSFER);\n      m=MOVED;\n      /*fallthrough*/\n   case(WAITING_FOR_TRANSFER):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t TransferFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==WAITING_FOR_TRANSFER)\n      {\n\t file=to_transfer->curr();\n\t if(!file)\n\t {\n\t    // go to the next step only when all transfers have finished\n\t    if(waiting_num>0)\n\t       break;\n\t    if(FlagSet(DEPTH_FIRST))\n\t    {\n\t       // we have been in the depth, don't go there again\n\t       SetFlags(DEPTH_FIRST,false);\n\t       SetFlags(NO_RECURSION,true);\n\n\t       // if we have not created any subdirs and there are only subdirs,\n\t       // then the directory would be empty - skip it.\n\t       if(FlagSet(NO_EMPTY_DIRS) && stats.dirs==0 && only_dirs)\n\t\t  goto pre_FINISHING_FIX_LOCAL;\n\n\t       MirrorStarted();\n\t       goto pre_MAKE_TARGET_DIR;\n\t    }\n\t    goto pre_TARGET_REMOVE_OLD;\n\t }\n\t HandleFile(file);\n\t to_transfer->next();\n\t m=MOVED;\n      }\n      break;\n\n   pre_TARGET_REMOVE_OLD:\n      if(FlagSet(REMOVE_FIRST))\n\t goto pre_TARGET_CHMOD;\n      set_state(TARGET_REMOVE_OLD);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_REMOVE_OLD):\n   case(TARGET_REMOVE_OLD_FIRST):\n   TARGET_REMOVE_OLD_FIRST_label:\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && (state==TARGET_REMOVE_OLD || state==TARGET_REMOVE_OLD_FIRST))\n      {\n\t file=0;\n\t if(!file && state==TARGET_REMOVE_OLD_FIRST)\n\t {\n\t    file=to_rm_mismatched->curr();\n\t    to_rm_mismatched->next();\n\t }\n\t if(!file && (state==TARGET_REMOVE_OLD || FlagSet(REMOVE_FIRST)))\n\t {\n\t    file=to_rm->curr();\n\t    to_rm->next();\n\t }\n\t if(!file)\n\t {\n\t    if(waiting_num>0)\n\t       break;\n\t    if(state==TARGET_REMOVE_OLD)\n\t       goto pre_TARGET_CHMOD;\n\t    goto pre_TARGET_MKDIR;\n\t }\n\t if(!FlagSet(DELETE))\n\t {\n\t    if(FlagSet(REPORT_NOT_DELETED))\n\t    {\n\t       const char *target_name_rel=dir_file(target_relative_dir,file->name);\n\t       if(file->TypeIs(file->DIRECTORY))\n\t\t  Report(_(\"Old directory `%s' is not removed\"),target_name_rel);\n\t       else\n\t\t  Report(_(\"Old file `%s' is not removed\"),target_name_rel);\n\t    }\n\t    continue;\n\t }\n\t bool use_rmdir = (file->TypeIs(file->DIRECTORY)\n\t\t\t   && recursion_mode==RECURSION_NEVER);\n\t if(script)\n\t {\n\t    ArgV args(use_rmdir?\"rmdir\":\"rm\");\n\t    if(file->TypeIs(file->DIRECTORY) && !use_rmdir)\n\t       args.Append(\"-r\");\n\t    args.Append(target_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(use_rmdir?\"rmdir\":\"rm\");\n\t    args->Append(dir_file(\".\",file->name));\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(target_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    JobStarted(j);\n\t    if(file->TypeIs(file->DIRECTORY))\n\t    {\n\t       if(recursion_mode==RECURSION_NEVER)\n\t\t  j->Rmdir();\n\t       else\n\t\t  j->Recurse();\n\t    }\n\t }\n\t const char *target_name_rel=dir_file(target_relative_dir,file->name);\n\t if(file->TypeIs(file->DIRECTORY))\n\t    Report(_(\"Removing old directory `%s'\"),target_name_rel);\n\t else\n\t    Report(_(\"Removing old file `%s'\"),target_name_rel);\n      }\n      break;\n\n   pre_TARGET_CHMOD:\n      if(FlagSet(NO_PERMS))\n\t goto pre_FINISHING_FIX_LOCAL;\n\n      to_transfer->rewind();\n      if(FlagSet(TARGET_FLAT))\n\t to_transfer->Sort(FileSet::BYNAME_FLAT);\n      set_state(TARGET_CHMOD);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_CHMOD):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==TARGET_CHMOD)\n      {\n\t file=to_transfer->curr();\n\t if(!file)\n\t    goto pre_FINISHING_FIX_LOCAL;\n\t to_transfer->next();\n\t if(file->TypeIs(file->SYMLINK))\n\t    continue;\n\t if(!file->Has(file->MODE))\n\t    continue;\n\t mode_t mode_mask=get_mode_mask();\n\t mode_t def_mode=(file->TypeIs(file->DIRECTORY)?0775:0664)&~mode_mask;\n\t if(target_is_local && file->mode==def_mode)\n\t {\n\t    struct stat st;\n\t    if(!target_is_local || lstat(dir_file(target_dir,file->name),&st)==-1)\n\t       continue;\n\t    if((st.st_mode&07777)==(file->mode&~mode_mask))\n\t       continue;\n\t }\n\t FileInfo *target=target_set->FindByName(file->name);\n\t if(target && target->filetype==file->DIRECTORY && file->filetype==file->DIRECTORY\n\t && target->mode==(file->mode&~mode_mask) && (target->mode&0200))\n\t    continue;\n\t if(script)\n\t {\n\t    ArgV args(\"chmod\");\n\t    args.Append(xstring::format(\"%03lo\",(unsigned long)(file->mode&~mode_mask)));\n\t    args.Append(target_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"chmod\");\n\t    a->Append(dir_file(\".\",file->name));\n\t    a->seek(1);\n\t    ChmodJob *cj=new ChmodJob(target_session->Clone(),\n\t\t\t\t file->mode&~mode_mask,a);\n\t    a->CombineTo(cj->cmdline);\n\t    if(!verbose_report)\n\t       cj->BeQuiet(); // chmod is not supported on all servers; be quiet.\n\t    JobStarted(cj);\n\t    m=MOVED;\n\t }\n      }\n      break;\n\n   pre_FINISHING_FIX_LOCAL:\n      if(target_is_local && !script_only)     // FIXME\n      {\n\t const bool flat=FlagSet(TARGET_FLAT);\n\t to_transfer->Sort(FileSet::BYNAME_FLAT);\n\t to_transfer->LocalUtime(target_dir,/*only_dirs=*/true,flat);\n\t if(FlagSet(ALLOW_CHOWN))\n\t    to_transfer->LocalChown(target_dir,flat);\n\t if(!FlagSet(NO_PERMS) && same)\n\t    same->LocalChmod(target_dir,get_mode_mask(),flat);\n\t if(FlagSet(ALLOW_CHOWN) && same)\n\t    same->LocalChown(target_dir,flat);\n      }\n      if(remove_source_files && (same || to_rm_src))\n\t goto pre_SOURCE_REMOVING_SAME;\n   pre_FINISHING:\n      set_state(FINISHING);\n      m=MOVED;\n      /*fallthrough*/\n   case(FINISHING):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(waiting_num>0)\n\t break;\n\n      // all jobs finished.\n      if(remove_this_source_dir) {\n\t // remove source directory once.\n\t remove_this_source_dir=false;\n\t if(script)\n\t {\n\t    ArgV args(\"rmdir\");\n\t    args.Append(source_session->GetFileURL(source_dir));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rmdir\");\n\t    args->Append(source_dir);\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(source_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    j->Rmdir();\n\t    JobStarted(j);\n\t }\n\t if(source_relative_dir)\n\t    Report(_(\"Removing source directory `%s'\"),source_relative_dir.get());\n\t m=MOVED;\n\t break;\n      }\n\n      // all jobs finished and src dir removed, if needed.\n\n      transfer_count++; // parent mirror will decrement it.\n      if(parent_mirror)\n\t parent_mirror->stats.Add(stats);\n      else\n      {\n\t if(stats.HaveSomethingDone(flags) && on_change)\n\t {\n\t    CmdExec *exec=new CmdExec(source_session->Clone(),0);\n\t    AddWaiting(exec);\n\t    exec->FeedCmd(on_change);\n\t    exec->FeedCmd(\"\\n\");\n\t    set_state(LAST_EXEC);\n\t    break;\n\t }\n      }\n      goto pre_DONE;\n\n   pre_SOURCE_REMOVING_SAME:\n      if(!same)\n\t same=to_rm_src.borrow();\n      else if(to_rm_src)\n\t same->Merge(to_rm_src);\n      same->rewind();\n      set_state(SOURCE_REMOVING_SAME);\n      m=MOVED;\n      /*fallthrough*/\n   case(SOURCE_REMOVING_SAME):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==SOURCE_REMOVING_SAME)\n      {\n\t file=same->curr();\n\t same->next();\n\t if(!file)\n\t    goto pre_FINISHING;\n\t if(file->TypeIs(file->DIRECTORY))\n\t    continue;\n\t if(script)\n\t {\n\t    ArgV args(\"rm\");\n\t    args.Append(source_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rm\");\n\t    args->Append(dir_file(\".\",file->name));\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(source_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    JobStarted(j);\n\t }\n\t const char *source_name_rel=dir_file(source_relative_dir,file->name);\n\t Report(_(\"Removing source file `%s'\"),source_name_rel);\n      }\n      break;\n\n   case(LAST_EXEC):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t RemoveWaiting(j);\n\t Delete(j);\n\t m=MOVED;\n      }\n      if(waiting_num>0)\n\t break;\n   pre_DONE:\n      set_state(DONE);\n      m=MOVED;\n      bytes_transferred=0;\n      if(!parent_mirror && FlagSet(LOOP) && stats.HaveSomethingDone(flags) && !stats.error_count)\n      {\n\t PrintStatus(0,\"\");\n\t printf(_(\"Retrying mirror...\\n\"));\n\t stats.Reset();\n\t source_set=0;\n\t target_set=0;\n\t goto pre_GETTING_LIST_INFO;\n      }\n      /*fallthrough*/\n   case(DONE):\n      break;\n   }\n   // give direct parent priority over grand-parents.\n   if(transfer_count<parallel && parent_mirror)\n      m|=parent_mirror->Roll();\n   return m;\n}\n\nMirrorJob::MirrorJob(MirrorJob *parent,\n   FileAccess *source,FileAccess *target,\n   const char *new_source_dir,const char *new_target_dir)\n :\n   bytes_transferred(0), bytes_to_transfer(0),\n   source_dir(new_source_dir), target_dir(new_target_dir),\n   transfer_time_elapsed(0), root_transfer_count(0),\n   verbose_report(0),\n   parent_mirror(parent), root_mirror(parent?parent->root_mirror:this)\n{\n\n   source_session=source;\n   target_session=target;\n   // TODO: get rid of this.\n   source_is_local=!strcmp(source_session->GetProto(),\"file\");\n   target_is_local=!strcmp(target_session->GetProto(),\"file\");\n\n   create_target_dir=true;\n   no_target_dir=false;\n   remove_this_source_dir=false;\n\n   flags=0;\n   recursion_mode=RECURSION_ALWAYS;\n   max_error_count=0;\n\n   exclude=0;\n\n   set_state(INITIAL_STATE);\n\n   newer_than=NO_DATE;\n   older_than=NO_DATE;\n   size_range=0;\n\n   script=0;\n   script_only=false;\n   script_needs_closing=false;\n\n   use_cache=false;\n   remove_source_files=false;\n   remove_source_dirs=false;\n   skip_noaccess=false;\n\n   parallel=1;\n   pget_n=1;\n   pget_minchunk=0x10000;\n\n   source_redirections=0;\n   target_redirections=0;\n\n   if(parent_mirror)\n   {\n      bool parallel_dirs=ResMgr::QueryBool(\"mirror:parallel-directories\",0);\n      // If parallel_dirs is true, allow parent mirror to continue\n      // processing other directories, otherwise block it until we\n      // get file sets and start transfers.\n      // See also comment at MirrorJob::MirrorStarted().\n      root_transfer_count=parallel_dirs?1:1024;\n\n      // inherit flags and other things\n      SetFlags(parent->flags,1);\n      UseCache(parent->use_cache);\n\n      SetExclude(parent->exclude);\n\n      verbose_report=parent->verbose_report;\n      newer_than=parent->newer_than;\n      older_than=parent->older_than;\n      size_range=parent->size_range;\n      parallel=parent->parallel;\n      pget_n=parent->pget_n;\n      pget_minchunk=parent->pget_minchunk;\n      remove_source_files=parent->remove_source_files;\n      remove_source_dirs=parent->remove_source_dirs;\n      skip_noaccess=parent->skip_noaccess;\n      no_target_dir=parent->no_target_dir;\n      recursion_mode=parent->recursion_mode;\n\n      script=parent->script;\n      script_needs_closing=false;\n      script_name.set(parent->script_name);\n      script_only=parent->script_only;\n\n      max_error_count=parent->max_error_count;\n   }\n   MirrorStarted();\n}\n\nMirrorJob::~MirrorJob()\n{\n   if(script && script_needs_closing)\n      fclose(script);\n}\n\nvoid MirrorJob::va_Report(const char *fmt,va_list v)\n{\n   if(parent_mirror)\n   {\n      parent_mirror->va_Report(fmt,v);\n      return;\n   }\n\n   if(verbose_report)\n   {\n      pid_t p=tcgetpgrp(fileno(stdout));\n      if(p>0 && p!=getpgrp())\n\t return;\n\n      vfprintf(stdout,fmt,v);\n      printf(\"\\n\");\n      fflush(stdout);\n   }\n}\n\nvoid MirrorJob::Report(const char *fmt,...)\n{\n   va_list v;\n   va_start(v,fmt);\n\n   va_Report(fmt,v);\n\n   va_end(v);\n}\n\nextern \"C\" {\n#include \"parse-datetime.h\"\n}\nvoid MirrorJob::SetNewerThan(const char *f)\n{\n   struct timespec ts;\n   if(parse_datetime(&ts,f,0))\n   {\n      newer_than=ts.tv_sec;\n      return;\n   }\n   struct stat st;\n   if(stat(f,&st)==-1)\n   {\n      perror(f);\n      return;\n   }\n   newer_than=st.st_mtime;\n}\nvoid MirrorJob::SetOlderThan(const char *f)\n{\n   struct timespec ts;\n   if(parse_datetime(&ts,f,0))\n   {\n      older_than=ts.tv_sec;\n      return;\n   }\n   struct stat st;\n   if(stat(f,&st)==-1)\n   {\n      perror(f);\n      return;\n   }\n   older_than=st.st_mtime;\n}\n\nmode_t MirrorJob::get_mode_mask()\n{\n   mode_t mode_mask=0;\n   if(!FlagSet(ALLOW_SUID))\n      mode_mask|=S_ISUID|S_ISGID;\n   if(!FlagSet(NO_UMASK))\n   {\n      if(target_is_local)\n      {\n\t mode_t u=umask(022); // get+set\n\t umask(u);\t      // retore\n\t mode_mask|=u;\n      }\n      else\n\t mode_mask|=022;   // sane default.\n   }\n   return mode_mask;\n}\n\nvoid MirrorJob::Fg()\n{\n   Job::Fg();\n   source_session->SetPriority(1);\n   target_session->SetPriority(1);\n}\nvoid MirrorJob::Bg()\n{\n   source_session->SetPriority(0);\n   target_session->SetPriority(0);\n   Job::Bg();\n}\n\nMirrorJob::Statistics::Statistics()\n{\n   Reset();\n   error_count=0;\n   bytes=0;\n   time=0;\n}\nvoid MirrorJob::Statistics::Reset()\n{\n   tot_files=new_files=mod_files=del_files=\n   tot_symlinks=new_symlinks=mod_symlinks=del_symlinks=\n   dirs=del_dirs=0;\n}\nvoid MirrorJob::Statistics::Add(const Statistics &s)\n{\n   tot_files   +=s.tot_files;\n   new_files   +=s.new_files;\n   mod_files   +=s.mod_files;\n   del_files   +=s.del_files;\n   tot_symlinks+=s.tot_symlinks;\n   new_symlinks+=s.new_symlinks;\n   mod_symlinks+=s.mod_symlinks;\n   del_symlinks+=s.del_symlinks;\n   dirs        +=s.dirs;\n   del_dirs    +=s.del_dirs;\n   error_count +=s.error_count;\n   bytes       +=s.bytes;\n   time\t       +=s.time;\n}\nbool MirrorJob::Statistics::HaveSomethingDone(unsigned flags)\n{\n   bool del=(flags&MirrorJob::DELETE);\n   return new_files|mod_files|(del_files*del)|new_symlinks|mod_symlinks|(del_symlinks*del)|(del_dirs*del);\n}\n\nconst char *MirrorJob::SetScriptFile(const char *n)\n{\n   script_name.set(n);\n   if(strcmp(n,\"-\"))\n   {\n      script=fopen(n,\"w\");\n      if(!script)\n\t return xstring::format(\"%s: %s\",n,strerror(errno));\n      setvbuf(script,NULL,_IOLBF,0);\n      script_needs_closing=true;\n   }\n   else\n   {\n      script=stdout;\n      script_needs_closing=false;\n   }\n   return 0;\n}\n\nvoid MirrorJob::SetOnChange(const char *oc)\n{\n   on_change.set(oc);\n}\n\nconst char *MirrorJob::AddPattern(Ref<PatternSet>& exclude,char opt,const char *optarg)\n{\n   PatternSet::Type type=\n      (opt=='x'||opt=='X'||opt=='\\0'?PatternSet::EXCLUDE:PatternSet::INCLUDE);\n   PatternSet::Pattern *pattern=0;\n   if(opt=='x' || opt=='i')\n   {\n      Ref<PatternSet::Regex> rx(new PatternSet::Regex(optarg));\n      if(rx->Error())\n\t return xstring::get_tmp(rx->ErrorText());\n      pattern=rx.borrow();\n   }\n   else if(opt=='X' || opt=='I')\n   {\n      pattern=new PatternSet::Glob(optarg);\n   }\n   if(!exclude)\n   {\n      const char *default_exclude=ResMgr::Query(\"mirror:exclude-regex\",0);\n      const char *default_include=ResMgr::Query(\"mirror:include-regex\",0);\n\n      // don't create default pattern set if not needed\n      if(!pattern && !(default_exclude && *default_exclude))\n\t return NULL;\n\n      exclude=new PatternSet;\n      /* Make default_exclude the first pattern so that it can be\n       * overridden by --include later, and do that only when first\n       * explicit pattern is for exclusion - otherwise all files are\n       * excluded by default and no default exclusion is needed. */\n      if(type==PatternSet::EXCLUDE && default_exclude && *default_exclude)\n      {\n\t exclude->Add(type,new PatternSet::Regex(default_exclude));\n\t if(default_include && *default_include)\n\t    exclude->Add(PatternSet::INCLUDE,new PatternSet::Regex(default_include));\n      }\n   }\n   if(pattern)\n      exclude->Add(type,pattern);\n\n   return NULL; // no error\n}\n\nconst char *MirrorJob::AddPatternsFrom(Ref<PatternSet>& exclude,char opt,const char *file)\n{\n   FILE *f=fopen(file,\"r\");\n   if(!f)\n      return xstring::format(\"%s: %s\",file,strerror(errno));\n\n   xstring line;\n   const char *err=0;\n   int c;\n   while(!feof(f)) {\n      line.truncate();\n      while((c=getc(f))!=EOF && c!='\\n')\n\t line.append(c);\n      if(line.length()>0) {\n\t err=AddPattern(exclude,opt,line);\n\t if(err)\n\t    break;\n      }\n   }\n\n   fclose(f);\n   return err;\n}\n\nconst char *MirrorJob::SetRecursionMode(const char *m)\n{\n   struct { const char name[8]; recursion_mode_t mode; } map[]={\n      {\"always\", RECURSION_ALWAYS},\n      {\"never\",  RECURSION_NEVER},\n      {\"missing\",RECURSION_MISSING},\n      {\"newer\",  RECURSION_NEWER},\n   };\n   unsigned i;\n   for(i=0; i<sizeof(map)/sizeof(map[0]); i++) {\n      if(!strcasecmp(m,map[i].name)) {\n\t recursion_mode=map[i].mode;\n\t return 0;\n      }\n   }\n   xstring list(map[0].name);\n   for(i=1; i<sizeof(map)/sizeof(map[0]); i++)\n      list.append(\", \").append(map[i].name);\n   return xstring::format(_(\"%s must be one of: %s\"),\"--recursion\",list.get());\n}\n\nCMD(mirror)\n{\n#define args (parent->args)\n#define eprintf parent->eprintf\n   enum {\n      OPT_ALLOW_CHOWN,\n      OPT_DELETE_FIRST,\n      OPT_IGNORE_SIZE,\n      OPT_IGNORE_TIME,\n      OPT_LOOP,\n      OPT_MAX_ERRORS,\n      OPT_NO_DEREFERENCE,\n      OPT_NO_SYMLINKS,\n      OPT_NO_UMASK,\n      OPT_OLDER_THAN,\n      OPT_ONLY_MISSING,\n      OPT_ONLY_EXISTING,\n      OPT_PERMS,\n      OPT_REMOVE_SOURCE_FILES,\n      OPT_REMOVE_SOURCE_DIRS,\n      OPT_SCRIPT,\n      OPT_SCRIPT_ONLY,\n      OPT_SIZE_RANGE,\n      OPT_USE_CACHE,\n      OPT_USE_PGET_N,\n      OPT_SKIP_NOACCESS,\n      OPT_ON_CHANGE,\n      OPT_NO_EMPTY_DIRS,\n      OPT_DEPTH_FIRST,\n      OPT_ASCII,\n      OPT_SCAN_ALL_FIRST,\n      OPT_OVERWRITE,\n      OPT_NO_OVERWRITE,\n      OPT_RECURSION,\n      OPT_UPLOAD_OLDER,\n      OPT_TRANSFER_ALL,\n      OPT_TARGET_FLAT,\n      OPT_DELETE_EXCLUDED,\n   };\n   static const struct option mirror_opts[]=\n   {\n      {\"delete\",no_argument,0,'e'},\n      {\"allow-suid\",no_argument,0,'s'},\n      {\"allow-chown\",no_argument,0,OPT_ALLOW_CHOWN},\n      {\"include\",required_argument,0,'i'},\n      {\"exclude\",required_argument,0,'x'},\n      {\"include-glob\",required_argument,0,'I'},\n      {\"exclude-glob\",required_argument,0,'X'},\n      {\"include-rx-from\",required_argument,0,'i'+'f'},\n      {\"exclude-rx-from\",required_argument,0,'x'+'f'},\n      {\"include-glob-from\",required_argument,0,'I'+'f'},\n      {\"exclude-glob-from\",required_argument,0,'X'+'f'},\n      {\"only-newer\",no_argument,0,'n'},\n      {\"no-recursion\",no_argument,0,'r'},\n      {\"no-perms\",no_argument,0,'p'},\n      {\"perms\",no_argument,0,OPT_PERMS},\n      {\"no-umask\",no_argument,0,OPT_NO_UMASK},\n      {\"continue\",no_argument,0,'c'},\n      {\"reverse\",no_argument,0,'R'},\n      {\"verbose\",optional_argument,0,'v'},\n      {\"newer-than\",required_argument,0,'N'},\n      {\"file\",required_argument,0,'f'},\n      {\"directory\",required_argument,0,'F'},\n      {\"older-than\",required_argument,0,OPT_OLDER_THAN},\n      {\"size-range\",required_argument,0,OPT_SIZE_RANGE},\n      {\"dereference\",no_argument,0,'L'},\n      {\"no-dereference\",no_argument,0,OPT_NO_DEREFERENCE},\n      {\"use-cache\",no_argument,0,OPT_USE_CACHE},\n      {\"Remove-source-files\",no_argument,0,OPT_REMOVE_SOURCE_FILES},\n      {\"Remove-source-dirs\",no_argument,0,OPT_REMOVE_SOURCE_DIRS},\n      {\"Move\",no_argument,0,OPT_REMOVE_SOURCE_DIRS},\n      {\"parallel\",optional_argument,0,'P'},\n      {\"ignore-time\",no_argument,0,OPT_IGNORE_TIME},\n      {\"ignore-size\",no_argument,0,OPT_IGNORE_SIZE},\n      {\"only-missing\",no_argument,0,OPT_ONLY_MISSING},\n      {\"only-existing\",no_argument,0,OPT_ONLY_EXISTING},\n      {\"log\",required_argument,0,OPT_SCRIPT},\n      {\"script\",    required_argument,0,OPT_SCRIPT_ONLY},\n      {\"just-print\",optional_argument,0,OPT_SCRIPT_ONLY},\n      {\"dry-run\",   optional_argument,0,OPT_SCRIPT_ONLY},\n      {\"delete-first\",no_argument,0,OPT_DELETE_FIRST},\n      {\"use-pget-n\",optional_argument,0,OPT_USE_PGET_N},\n      {\"no-symlinks\",no_argument,0,OPT_NO_SYMLINKS},\n      {\"loop\",no_argument,0,OPT_LOOP},\n      {\"max-errors\",required_argument,0,OPT_MAX_ERRORS},\n      {\"skip-noaccess\",no_argument,0,OPT_SKIP_NOACCESS},\n      {\"on-change\",required_argument,0,OPT_ON_CHANGE},\n      {\"no-empty-dirs\",no_argument,0,OPT_NO_EMPTY_DIRS},\n      {\"depth-first\",no_argument,0,OPT_DEPTH_FIRST},\n      {\"ascii\",no_argument,0,OPT_ASCII},\n      {\"target-directory\",required_argument,0,'O'},\n      {\"destination-directory\",required_argument,0,'O'},\n      {\"scan-all-first\",no_argument,0,OPT_SCAN_ALL_FIRST},\n      {\"overwrite\",no_argument,0,OPT_OVERWRITE},\n      {\"no-overwrite\",no_argument,0,OPT_NO_OVERWRITE},\n      {\"recursion\",required_argument,0,OPT_RECURSION},\n      {\"upload-older\",no_argument,0,OPT_UPLOAD_OLDER},\n      {\"transfer-all\",no_argument,0,OPT_TRANSFER_ALL},\n      {\"flat\",no_argument,0,OPT_TARGET_FLAT},\n      {\"delete-excluded\",no_argument,0,OPT_DELETE_EXCLUDED},\n      {0}\n   };\n\n   int opt;\n   unsigned flags=0;\n   int max_error_count=0;\n\n   bool use_cache=false;\n\n   FileAccessRef source_session;\n   FileAccessRef target_session;\n\n   int\t verbose=0;\n   const char *newer_than=0;\n   const char *older_than=0;\n   Ref<Range> size_range;\n   bool  remove_source_files=false;\n   bool  remove_source_dirs=false;\n   bool\t skip_noaccess=ResMgr::QueryBool(\"mirror:skip-noaccess\",0);\n   int\t parallel=-1;\n   int\t use_pget=-1;\n   bool\t reverse=false;\n   bool\t script_only=false;\n   bool\t no_empty_dirs=ResMgr::QueryBool(\"mirror:no-empty-dirs\",0);\n   const char *script_file=0;\n   const char *on_change=0;\n   const char *recursion_mode=0;\n   bool single_file=false;\n   bool single_dir=false;\n\n   Ref<PatternSet> exclude;\n   Ref<PatternSet> top_exclude;\n\n   if(!ResMgr::QueryBool(\"mirror:set-permissions\",0))\n      flags|=MirrorJob::NO_PERMS;\n   if(ResMgr::QueryBool(\"mirror:dereference\",0))\n      flags|=MirrorJob::RETR_SYMLINKS;\n   if(ResMgr::QueryBool(\"mirror:overwrite\",0))\n      flags|=MirrorJob::OVERWRITE;\n\n   const char *source_dir=NULL;\n   const char *target_dir=NULL;\n\n   args->rewind();\n   while((opt=args->getopt_long(\"esi:x:I:X:nrpcRvN:LP:af:F:O:\",mirror_opts,0))!=EOF)\n   {\n      switch(opt)\n      {\n      case('e'):\n\t flags|=MirrorJob::DELETE;\n\t break;\n      case('s'):\n\t flags|=MirrorJob::ALLOW_SUID;\n\t break;\n      case(OPT_ALLOW_CHOWN):\n\t flags|=MirrorJob::ALLOW_CHOWN;\n\t break;\n      case('a'):\n\t flags|=MirrorJob::ALLOW_SUID|MirrorJob::ALLOW_CHOWN|MirrorJob::NO_UMASK;\n\t break;\n      case('r'):\n\t recursion_mode=\"never\";\n\t break;\n      case('n'):\n\t flags|=MirrorJob::ONLY_NEWER;\n\t break;\n      case('p'):\n\t flags|=MirrorJob::NO_PERMS;\n\t break;\n      case(OPT_PERMS):\n\t flags&=~MirrorJob::NO_PERMS;\n\t break;\n      case('c'):\n\t flags|=MirrorJob::CONTINUE;\n\t break;\n      case('x'):\n      case('i'):\n      case('X'):\n      case('I'):\n      {\n\t const char *err=MirrorJob::AddPattern(exclude,opt,optarg);\n\t if(err)\n\t {\n\t    eprintf(\"%s: %s\\n\",args->a0(),err);\n\t    goto no_job;\n\t }\n\t break;\n      }\n      case('x'+'f'):\n      case('i'+'f'):\n      case('X'+'f'):\n      case('I'+'f'):\n      {\n\t const char *err=MirrorJob::AddPatternsFrom(exclude,opt-'f',optarg);\n\t if(err)\n\t {\n\t    eprintf(\"%s: %s\\n\",args->a0(),err);\n\t    goto no_job;\n\t }\n\t break;\n      }\n      case('R'):\n\t reverse=true;\n\t break;\n      case('L'):\n\t flags|=MirrorJob::RETR_SYMLINKS;\n\t break;\n      case(OPT_NO_DEREFERENCE):\n\t flags&=~MirrorJob::RETR_SYMLINKS;\n\t break;\n      case('v'):\n\t if(optarg)\n\t    verbose=atoi(optarg);\n\t else\n\t    verbose++;\n\t if(verbose>1)\n\t    flags|=MirrorJob::REPORT_NOT_DELETED;\n\t break;\n      case('N'):\n\t newer_than=optarg;\n\t break;\n      case('f'): // mirror for a single file (or glob pattern).\n\t single_file=true;\n\t /*fallthrough*/\n      case('F'): // mirror for a single directory (or glob pattern).\n      {\n\t xstring pattern(basename_ptr(optarg));\n\t if(opt=='F') {\n\t    single_dir=true;\n\t    if(pattern.last_char()!='/')\n\t       pattern.append('/');\n\t }\n\t if(!top_exclude)\n\t    top_exclude=new PatternSet();\n\t top_exclude->Add(PatternSet::INCLUDE,new PatternSet::Glob(pattern));\n\t const char *dir=dirname(optarg);\n\t if(source_dir && strcmp(source_dir,dir)) {\n\t    eprintf(_(\"%s: multiple --file or --directory options must have the same base directory\\n\"),args->a0());\n\t    goto no_job;\n\t }\n\t if(!source_dir)\n\t    source_dir=alloca_strdup(dir); // save the temp string\n\t break;\n      }\n      case('O'):\n\t target_dir=optarg;\n\t break;\n      case(OPT_OLDER_THAN):\n\t older_than=optarg;\n\t break;\n      case(OPT_SIZE_RANGE):\n\t size_range=new Range(optarg);\n\t if(size_range->Error())\n\t {\n\t    eprintf(\"%s: --size-range \\\"%s\\\": %s\\n\",\n\t       args->a0(),optarg,size_range->ErrorText());\n\t    goto no_job;\n\t }\n\t break;\n      case(OPT_NO_UMASK):\n\t flags|=MirrorJob::NO_UMASK;\n\t break;\n      case(OPT_USE_CACHE):\n\t use_cache=true;\n\t break;\n      case(OPT_REMOVE_SOURCE_FILES):\n\t remove_source_files=true;\n\t break;\n      case(OPT_REMOVE_SOURCE_DIRS):\n\t remove_source_dirs=true;\n\t break;\n      case(OPT_IGNORE_TIME):\n\t flags|=MirrorJob::IGNORE_TIME;\n\t break;\n      case(OPT_IGNORE_SIZE):\n\t flags|=MirrorJob::IGNORE_SIZE;\n\t break;\n      case(OPT_ONLY_MISSING):\n\t flags|=MirrorJob::IGNORE_TIME|MirrorJob::IGNORE_SIZE;\n\t break;\n      case('P'):\n\t if(optarg)\n\t    parallel=atoi(optarg);\n\t else\n\t    parallel=3;\n\t break;\n      case(OPT_USE_PGET_N):\n\t if(optarg)\n\t    use_pget=atoi(optarg);\n\t else\n\t    use_pget=3;\n\t break;\n      case(OPT_SCRIPT_ONLY):\n\t script_only=true;\n      case(OPT_SCRIPT):\n\t script_file=optarg;\n\t if(script_file==0)\n\t    script_file=\"-\";\n\t break;\n      case(OPT_DELETE_FIRST):\n\t flags|=MirrorJob::REMOVE_FIRST|MirrorJob::DELETE;\n\t break;\n      case(OPT_NO_SYMLINKS):\n\t flags|=MirrorJob::NO_SYMLINKS;\n\t break;\n      case(OPT_LOOP):\n\t flags|=MirrorJob::LOOP;\n\t break;\n      case(OPT_MAX_ERRORS):\n\t max_error_count=atoi(optarg);\n\t break;\n      case(OPT_SKIP_NOACCESS):\n\t skip_noaccess=true;\n\t break;\n      case(OPT_ON_CHANGE):\n\t on_change=optarg;\n\t break;\n      case(OPT_ONLY_EXISTING):\n\t flags|=MirrorJob::ONLY_EXISTING;\n\t break;\n      case(OPT_NO_EMPTY_DIRS):\n\t no_empty_dirs=true;\n\t break;\n      case(OPT_DEPTH_FIRST):\n\t flags|=MirrorJob::DEPTH_FIRST;\n\t break;\n      case(OPT_SCAN_ALL_FIRST):\n\t flags|=MirrorJob::SCAN_ALL_FIRST|MirrorJob::DEPTH_FIRST;\n\t break;\n      case(OPT_ASCII):\n\t flags|=MirrorJob::ASCII|MirrorJob::IGNORE_SIZE;\n\t break;\n      case(OPT_OVERWRITE):\n\t flags|=MirrorJob::OVERWRITE;\n\t break;\n      case(OPT_NO_OVERWRITE):\n\t flags&=~MirrorJob::OVERWRITE;\n\t break;\n      case(OPT_RECURSION):\n\t recursion_mode=optarg;\n\t break;\n      case(OPT_UPLOAD_OLDER):\n\t flags|=MirrorJob::UPLOAD_OLDER;\n\t break;\n      case(OPT_TRANSFER_ALL):\n\t flags|=MirrorJob::TRANSFER_ALL;\n\t break;\n      case(OPT_TARGET_FLAT):\n\t flags|=MirrorJob::TARGET_FLAT|MirrorJob::SCAN_ALL_FIRST|MirrorJob::DEPTH_FIRST;\n\t break;\n      case(OPT_DELETE_EXCLUDED):\n\t flags|=MirrorJob::DELETE_EXCLUDED;\n\t break;\n      case('?'):\n\t eprintf(_(\"Try `help %s' for more information.\\n\"),args->a0());\n      no_job:\n\t return 0;\n      }\n   }\n\n   if(exclude && xstrcasecmp(recursion_mode,\"never\"))\n   {\n      /* Users usually don't want to exclude all directories when recursing */\n      if(exclude->GetFirstType()==PatternSet::INCLUDE)\n\t exclude->AddFirst(PatternSet::INCLUDE,new PatternSet::Regex(\"/$\"));\n   }\n\n   /* add default exclusion if no explicit patterns were specified */\n   if(!exclude)\n      MirrorJob::AddPattern(exclude,'\\0',0);\n\n   args->back();\n\n   const char *arg=args->getnext();\n   if(arg)\n   {\n      if(source_dir)\n      {\n\t eprintf(_(\"%s: ambiguous source directory (`%s' or `%s'?)\\n\"),args->a0(),\n\t    source_dir,arg);\n\t goto no_job;\n      }\n      source_dir=arg;\n      ParsedURL source_url(source_dir);\n      if(source_url.proto && source_url.path)\n      {\n\t source_session=FileAccess::New(&source_url);\n\t if(!source_session)\n\t {\n\t    eprintf(\"%s: %s%s\\n\",args->a0(),source_url.proto.get(),\n\t\t     _(\" - not supported protocol\"));\n\t    goto no_job;\n\t }\n\t source_dir=alloca_strdup(source_url.path);\n      }\n      arg=args->getnext();\n      if(arg)\n      {\n\t if(target_dir)\n\t {\n\t    eprintf(_(\"%s: ambiguous target directory (`%s' or `%s'?)\\n\"),args->a0(),\n\t       target_dir,arg);\n\t    goto no_job;\n\t }\n\t target_dir=arg;\n\t ParsedURL target_url(target_dir);\n\t if(target_url.proto && target_url.path)\n\t {\n\t    target_session=FileAccess::New(&target_url);\n\t    if(!target_session)\n\t    {\n\t       eprintf(\"%s: %s%s\\n\",args->a0(),target_url.proto.get(),\n\t\t\t_(\" - not supported protocol\"));\n\t       goto no_job;\n\t    }\n\t    target_dir=alloca_strdup(target_url.path);\n\t }\n\t if(last_char(arg)=='/' && basename_ptr(arg)[0]!='/' && last_char(source_dir)!='/')\n\t {\n\t    // user wants source dir name appended.\n\t    const char *base=basename_ptr(source_dir);\n\t    if(base[0]!='/' && strcmp(base,basename_ptr(arg))) {\n\t       target_dir=xstring::cat(target_dir,base,NULL);\n\t       target_dir=alloca_strdup(target_dir); // save the buffer\n\t    }\n\t }\n      }\n      else\n      {\n\t target_dir=basename_ptr(source_dir);\n\t if(target_dir[0]=='/')\n\t    target_dir=\".\";\n\t else if(target_dir[0]=='~') {\n\t    target_dir=dir_file(\".\",target_dir);\n\t    target_dir=alloca_strdup(target_dir); // save the buffer\n\t }\n      }\n   }\n\n   if(!source_dir) {\n      if(ResMgr::QueryBool(\"mirror:require-source\",0)) {\n\t eprintf(_(\"%s: source directory is required (mirror:require-source is set)\\n\"),args->a0());\n\t return 0;\n      }\n      source_dir=\".\";\n   }\n   if(!target_dir)\n      target_dir=\".\";\n\n   if(!reverse)\n   {\n      if(!source_session)\n\t source_session=parent->session->Clone();\n      if(!target_session)\n\t target_session=FileAccess::New(\"file\");\n   }\n   else //reverse\n   {\n      if(!source_session)\n\t source_session=FileAccess::New(\"file\");\n      if(!target_session)\n\t target_session=parent->session->Clone();\n   }\n\n   if(no_empty_dirs)\n      flags|=MirrorJob::NO_EMPTY_DIRS|MirrorJob::DEPTH_FIRST;\n\n   if(recursion_mode && strcasecmp(recursion_mode,\"always\")\n   && (flags&MirrorJob::DEPTH_FIRST)) {\n      eprintf(\"%s: --recursion-mode=%s conflicts with other specified options\\n\",\n\t args->a0(),recursion_mode);\n      return 0;\n   }\n\n   if(parallel<0) {\n      int parallel1=ResMgr::Query(\"mirror:parallel-transfer-count\",source_session->GetHostName());\n      int parallel2=ResMgr::Query(\"mirror:parallel-transfer-count\",target_session->GetHostName());\n      if(parallel1>0)\n\t parallel=parallel1;\n      if(parallel2>0 && (parallel<0 || parallel>parallel2))\n\t parallel=parallel2;\n   }\n   if(use_pget<0) {\n      int use_pget1=ResMgr::Query(\"mirror:use-pget-n\",source_session->GetHostName());\n      int use_pget2=ResMgr::Query(\"mirror:use-pget-n\",target_session->GetHostName());\n      if(use_pget1>0)\n\t use_pget=use_pget1;\n      if(use_pget2>0 && (use_pget<0 || use_pget>use_pget2))\n\t use_pget=use_pget2;\n   }\n\n   JobRef<MirrorJob> j(new MirrorJob(0,source_session.borrow(),target_session.borrow(),source_dir,target_dir));\n   j->SetFlags(flags,1);\n   j->SetVerbose(verbose);\n   j->SetExclude(exclude.borrow());\n   j->SetTopExclude(top_exclude.borrow());\n\n   if(newer_than)\n      j->SetNewerThan(newer_than);\n   if(older_than)\n      j->SetOlderThan(older_than);\n   if(size_range)\n      j->SetSizeRange(size_range.borrow());\n   j->UseCache(use_cache);\n   if(remove_source_files)\n      j->RemoveSourceFiles();\n   if(remove_source_dirs)\n      j->RemoveSourceDirs();\n   if(skip_noaccess)\n      j->SkipNoAccess();\n   if(parallel<0)\n      parallel=0;\n   if(parallel>64)\n      parallel=64;   // a (in)sane limit.\n   if(parallel)\n      j->SetParallel(parallel);\n   if(use_pget>1 && !(flags&MirrorJob::ASCII))\n      j->SetPGet(use_pget);\n\n   if(!recursion_mode && single_file && !single_dir)\n      recursion_mode=\"never\";\n\n   if(recursion_mode) {\n      const char *err=j->SetRecursionMode(recursion_mode);\n      if(err) {\n\t eprintf(\"%s: %s\\n\",args->a0(),err);\n\t return 0;\n      }\n   }\n   if(script_file)\n   {\n      const char *err=j->SetScriptFile(script_file);\n      if(err)\n      {\n\t eprintf(\"%s: %s\\n\",args->a0(),err);\n\t return 0;\n      }\n   }\n   if(script_only)\n   {\n      j->ScriptOnly();\n      if(!script_file)\n\t j->SetScriptFile(\"-\");\n   }\n   j->SetMaxErrorCount(max_error_count);\n   if(on_change)\n      j->SetOnChange(on_change);\n\n   return j.borrow();\n\n#undef args\n}\n\n#include \"modconfig.h\"\n#ifndef MODULE_CMD_MIRROR\n# define module_init cmd_mirror_module_init\n#endif\nCDECL void module_init()\n{\n   CmdExec::RegisterCommand(\"mirror\",cmd_mirror,0,\n      N_(\"\\n\"\n\t \"Mirror specified remote directory to local directory\\n\"\n\t \"\\n\"\n\t \" -R, --reverse          reverse mirror (put files)\\n\"\n\t \"Lots of other options are documented in the man page lftp(1).\\n\"\n\t \"\\n\"\n\t \"When using -R, the first directory is local and the second is remote.\\n\"\n\t \"If the second directory is omitted, basename of the first directory is used.\\n\"\n\t \"If both directories are omitted, current local and remote directories are used.\\n\"\n\t \"\\n\"\n\t \"See the man page lftp(1) for a complete documentation.\\n\"\n      )\n   );\n}\n"], "filenames": ["src/MirrorJob.cc"], "buggy_code_start_loc": [1166], "buggy_code_end_loc": [1384], "fixing_code_start_loc": [1167], "fixing_code_end_loc": [1378], "type": "CWE-20", "message": "It has been discovered that lftp up to and including version 4.8.3 does not properly sanitize remote file names, leading to a loss of integrity on the local system when reverse mirroring is used. A remote attacker may trick a user to use reverse mirroring on an attacker controlled FTP server, resulting in the removal of all files in the current working directory of the victim's system.", "other": {"cve": {"id": "CVE-2018-10916", "sourceIdentifier": "secalert@redhat.com", "published": "2018-08-01T14:29:00.440", "lastModified": "2019-04-02T18:29:01.457", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "It has been discovered that lftp up to and including version 4.8.3 does not properly sanitize remote file names, leading to a loss of integrity on the local system when reverse mirroring is used. A remote attacker may trick a user to use reverse mirroring on an attacker controlled FTP server, resulting in the removal of all files in the current working directory of the victim's system."}, {"lang": "es", "value": "Se ha descubierto que lftp hasta e incluyendo la versi\u00f3n 4.8.3 no sanea adecuadamente los nombres de archivo remoto, lo que conduce a la p\u00e9rdida de integridad en el sistema local cuando se usa la replicaci\u00f3n inversa. Un atacante remoto podr\u00eda enga\u00f1ar a un usuario para que emplee replicaci\u00f3n inversa en un servidor FTP controlado por el atacante, lo que resulta en la eliminaci\u00f3n de todos los archivos en el directorio de trabajo actual del sistema de la v\u00edctima."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 7.8, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lftp_project:lftp:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.3", "matchCriteriaId": "93C6C713-A121-4AE0-ABFA-7E2BA667BEA9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.3:*:*:*:*:*:*:*", "matchCriteriaId": "5F65DAB0-3DAD-49FF-BC73-3581CC3D5BF3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-03/msg00036.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00010.html", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2018-10916", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/lavv17/lftp/commit/a27e07d90a4608ceaf928b1babb27d4d803e1992", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lavv17/lftp/issues/452", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3731-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lavv17/lftp/commit/a27e07d90a4608ceaf928b1babb27d4d803e1992"}}