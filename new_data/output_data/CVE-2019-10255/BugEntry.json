{"buggy_code": ["\"\"\"Tornado handlers for logging into the notebook.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\nimport os\n\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\nimport uuid\n\nfrom tornado.escape import url_escape\n\nfrom .security import passwd_check, set_password\n\nfrom ..base.handlers import IPythonHandler\n\n\nclass LoginHandler(IPythonHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + '/').startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        return passwd_check(a, b)\n    \n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        new_password = self.get_argument('new_password', default=u'')\n\n\n        \n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and self.settings.get('allow_password_change'):\n                    config_dir = self.settings.get('config_dir')\n                    config_file = os.path.join(config_dir, 'jupyter_notebook_config.json')\n                    set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid credentials'})\n                return\n\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        cookie_options.setdefault('path', handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n\n        Origin check should be skipped for token-authenticated requests.\n\n        Returns:\n        - True, if Handler must check for valid CORS origin.\n        - False, if Handler should skip origin check since requests are token-authenticated.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.\n\n        Login with a token is used to signal certain things, such as:\n\n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})\n            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\n        \n        Returns:\n        - uuid if authenticated\n        - None if not\n        \"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the notebook application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The notebook server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n"], "fixing_code": ["\"\"\"Tornado handlers for logging into the notebook.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\nimport os\n\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\nimport uuid\n\nfrom tornado.escape import url_escape\n\nfrom .security import passwd_check, set_password\n\nfrom ..base.handlers import IPythonHandler\n\n\nclass LoginHandler(IPythonHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + '/').startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        return passwd_check(a, b)\n    \n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        new_password = self.get_argument('new_password', default=u'')\n\n\n        \n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and self.settings.get('allow_password_change'):\n                    config_dir = self.settings.get('config_dir')\n                    config_file = os.path.join(config_dir, 'jupyter_notebook_config.json')\n                    set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid credentials'})\n                return\n\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        cookie_options.setdefault('path', handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n\n        Origin check should be skipped for token-authenticated requests.\n\n        Returns:\n        - True, if Handler must check for valid CORS origin.\n        - False, if Handler should skip origin check since requests are token-authenticated.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.\n\n        Login with a token is used to signal certain things, such as:\n\n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})\n            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\n        \n        Returns:\n        - uuid if authenticated\n        - None if not\n        \"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the notebook application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The notebook server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n"], "filenames": ["notebook/auth/login.py"], "buggy_code_start_loc": [41], "buggy_code_end_loc": [41], "fixing_code_start_loc": [42], "fixing_code_end_loc": [46], "type": "CWE-601", "message": "An Open Redirect vulnerability for all browsers in Jupyter Notebook before 5.7.7 and some browsers (Chrome, Firefox) in JupyterHub before 0.9.5 allows crafted links to the login page, which will redirect to a malicious site after successful login. Servers running on a base_url prefix are not affected.", "other": {"cve": {"id": "CVE-2019-10255", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-28T16:29:00.567", "lastModified": "2019-04-12T03:29:00.323", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An Open Redirect vulnerability for all browsers in Jupyter Notebook before 5.7.7 and some browsers (Chrome, Firefox) in JupyterHub before 0.9.5 allows crafted links to the login page, which will redirect to a malicious site after successful login. Servers running on a base_url prefix are not affected."}, {"lang": "es", "value": "Una vulnerabilidad de redirecci\u00f3n abierta para todos los navegadores en Jupyter Notebook, en versiones anteriores a la 5.7.7, y en algunos navegadores (Chrome, Firefox) en JupyterHub, en versiones anteriores a la 0.9.5, permite que los enlaces manipulados accedan a la p\u00e1gina de inicio de sesi\u00f3n, lo que redirigir\u00e1 a un sitio malicioso despu\u00e9s de un inicio de sesi\u00f3n exitoso. No se ven afectados los servidores que ejecutan un prefijo \"base_url\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:jupyterhub:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.5", "matchCriteriaId": "BD187FC8-D1B3-44B8-92EB-9EDD35DA60D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.7", "matchCriteriaId": "791BCAA5-DEE0-4ACC-A6B1-5CBE021E33C9"}]}]}], "references": [{"url": "https://blog.jupyter.org/open-redirect-vulnerability-in-jupyter-jupyterhub-adf43583f1e4", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/jupyter/notebook/commit/08c4c898182edbe97aadef1815cce50448f975cb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyter/notebook/commit/70fe9f0ddb3023162ece21fbb77d5564306b913b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyter/notebook/commit/d65328d4841892b412aef9015165db1eb029a8ed", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyter/notebook/compare/05aa4b2...16cf97c", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UP5RLEES2JBBNSNLBR65XM6PCD4EMF7D/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VMDPJBVXOVO6LYGAT46VZNHH6JKSCURO/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/jupyter/notebook/commit/08c4c898182edbe97aadef1815cce50448f975cb"}}