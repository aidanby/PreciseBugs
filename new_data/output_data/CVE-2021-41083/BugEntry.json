{"buggy_code": ["#!/usr/bin/perl\npackage DADA::App;\nuse base 'CGI::Application';\n\nuse CGI::Application::Plugin::RateLimit;\n\n#use CGI::Application::Plugin::DebugScreen;\n\nuse strict;\n\n\n\nBEGIN {\n    if ( $] > 5.008 ) {\n        require Errno;\n        require Config;\n    }\n}\nuse FindBin;\nuse lib \"$FindBin::Bin/../\";\nuse lib \"$FindBin::Bin/../../\";\nuse lib \"$FindBin::Bin/../../../\";\nuse lib \"$FindBin::Bin/../DADA/perllib\";\n\nuse Encode qw(encode decode);\nuse POSIX; \n\nBEGIN {\n    my $b__dir = ( getpwuid($>) )[7] . '/perl';\n    push @INC, $b__dir . '5/lib/perl5',\n      $b__dir . '5/lib/perl5/x86_64-linux-thread-multi', $b__dir . 'lib',\n      map { $b__dir . $_ } @INC;\n}\n$ENV{PATH} = \"/bin:/usr/bin\";\ndelete @ENV{ 'IFS', 'CDPATH', 'ENV', 'BASH_ENV' };\n\n#---------------------------------------------------------------------#\nuse Carp qw(carp croak);\n# $CARP::Verbose = 1;\n# use Devel::Confess; \n\n#---------------------------------------------------------------------#\n\nuse DADA::Config 11.0.0;\n\nuse DADA::App::ScreenCache;\nmy $c = DADA::App::ScreenCache->new;\nuse DADA::App::Guts;\nuse DADA::MailingList::Subscribers;\nuse Try::Tiny;\nuse DADA::Template::HTML;\nuse DADA::Template::Widgets;\n\n#---------------------------------------------------------------------#\n\nsub cgiapp_init {\n\n    $CGI::Application::LIST_CONTEXT_WARN = 0;\n\n    my $self = shift;\n    $self->query->charset($DADA::Config::HTML_CHARSET);\n\n    # Kinda Weird.\n    $DADA::Template::Widgets::q = $self->query;\n    $DADA::Template::HTML::q    = $self->query;\n\n}\n\nsub cgiapp_prerun {\n    my ( $self, $output_ref ) = @_;\n\t$self->header_props(\n\t    -charset         => $DADA::Config::HTML_CHARSET,\n\t    -Pragma          => 'no-cache', \n\t    '-Cache-control' => 'max-age=0, no-cache, no-store, must-revalidate',\n\t\t-Expires         => 'Wed, 11 Jan 1984 05:00:00 GMT',\t\t\n\t);\n}\n\nsub cgiapp_postrun {\n    my ( $self, $output_ref ) = @_;\n    $$output_ref = safely_encode($$output_ref);\n}\n\nsub setup {\n\n    my $self = shift;\n\n    $self->start_mode('default');\n    $self->mode_param('flavor');\n    $self->error_mode('yikes');\n\n# So, maybe the, \"schedules\" runmode should be something quite random, that can also be reset?\n# And then implement some sort of limit on how many times a schedule can be run?\n# And then, and then! Have a screen showing:\n# * an example cronjob\n# * a way to force the schedule to run\n# *\n\n    my $sched_flavor =\n      $DADA::Config::SCHEDULED_JOBS_OPTIONS->{scheduled_jobs_flavor};\n\n    $self->run_modes(\n\t\n\t \t\"AUTOLOAD\"                 => \\&unknown_param,\n\t \n        'plugins'                  => \\&plugins,\n        $sched_flavor              => \\&schedules,\n        'scheduled_jobs'           => \\&scheduled_jobs,\n        'default'                  => \\&default,\n        'subscribe'                => \\&subscribe,\n        'restful_subscribe'        => \\&restful_subscribe,\n\t\t'subscribe_landing'        => \\&subscribe_landing, \n\t\t'modal_subscribe_landing'  => \\&modal_subscribe_landing, \n        'api'                      => \\&api,\n        'token'                    => \\&token,\n\t\t'post_token'               => \\&post_token, \n        'unsubscribe'              => \\&unsubscribe,\n        'unsubscription_request'   => \\&unsubscription_request,\n        'unsubscribe_email_lookup' => \\&unsubscribe_email_lookup,\n        'report_abuse'             => \\&report_abuse,\n        'login'                    => \\&login,\n        'logout'                   => \\&logout,\n        #'log_into_another_list'    => \\&log_into_another_list,\n        'change_login'             => \\&change_login,\n        'new_list'                 => \\&new_list,\n        'change_info'              => \\&change_info,\n\t\t'is_valid_url'             => \\&is_valid_url, \n\t\t'manage_privacy_policy'    => \\&manage_privacy_policy, \n\t\t'manage_list_consent'      => \\&manage_list_consent,\n        'html_code'                => \\&html_code,\n        'preview_jquery_plugin_subscription_form' => \\&preview_jquery_plugin_subscription_form,\n\t\t'preview_subscription_form'               => \\&preview_subscription_form, \n\t\t'preview_minimal_subscription_form'       => \\&preview_minimal_subscription_form, \n\t\t'preview_modal_subscribe_landing_code'    => \\&preview_modal_subscribe_landing_code,\n        'admin_help'                    => \\&admin_help,\n        'delete_list'                   => \\&delete_list,\n        'view_list'                     => \\&view_list,\n        'mass_update_profiles'          => \\&mass_update_profiles,\n        'domain_breakdown_json'         => \\&domain_breakdown_json,\n        'search_list_auto_complete'     => \\&search_list_auto_complete,\n        'list_activity'                 => \\&list_activity,\n        'sub_unsub_trends_json'         => \\&sub_unsub_trends_json,\n\t\t'recent_subscription_activity'  => \\&recent_subscription_activity, \n        'view_bounce_history'           => \\&view_bounce_history,\n        'subscription_requests'         => \\&subscription_requests,\n        'unsubscription_requests'       => \\&unsubscription_requests,\n        'remove_all_subscribers'        => \\&remove_all_subscribers,\n        'membership'                    => \\&membership,\n        'also_member_of'                => \\&also_member_of,\n        'admin_change_profile_password' => \\&admin_change_profile_password,\n        'admin_profile_delivery_preferences' => \\&admin_profile_delivery_preferences,\n        'validate_update_email'          => \\&validate_update_email,\n        'validate_remove_email'          => \\&validate_remove_email,\n        'mailing_list_history'           => \\&mailing_list_history,\n        'membership_activity'            => \\&membership_activity,\n        'export_membership_history'      => \\&export_membership_history,\n        'add'                            => \\&add,\n        'check_status'                   => \\&check_status,\n        'email_password'                 => \\&email_password,\n\t\t'post_email_password'            => \\&post_email_password, \n        'add_email'                      => \\&add_email,\n        'delete_email'                   => \\&delete_email,\n        'subscription_options'           => \\&subscription_options,\n\t\t'admin_menu_notifications'       => \\&admin_menu_notifications, \n        'send_email'                     => \\&send_email,\n\t\t'image_drag_and_drop'            => \\&image_drag_and_drop, \n\t\t'no_draft_available'             => \\&no_draft_available, \n        'email_message_preview'          => \\&email_message_preview,\n        'send_email_button_widget'        => \\&send_email_button_widget,\n        'mass_mailing_schedules_preview'  => \\&mass_mailing_schedules_preview,\n\t\t'mass_mailing_schedules_preview_calendar' => \\&mass_mailing_schedules_preview_calendar,\n\t\t'mass_mailing_schedules_preview_calendar_json' => \\&mass_mailing_schedules_preview_calendar_json, \n        'draft_message_values'            => \\&draft_message_values,\n        'ckeditor_template_tag_list'      => \\&ckeditor_template_tag_list,\n        'draft_saved_notification'        => \\&draft_saved_notification,\n        'drafts'                          => \\&drafts,\n\t\t'preview_draft'                   => \\&preview_draft, \n        'delete_drafts'                   => \\&delete_drafts,\n        'create_from_stationery'          => \\&create_from_stationery,\n       # 'message_body_help'               => \\&message_body_help,\n        #'url_message_body_help'           => \\&url_message_body_help,\n        'preview_message_receivers'       => \\&preview_message_receivers,\n        'sending_monitor'                 => \\&sending_monitor,\n        'print_mass_mailing_log'          => \\&print_mass_mailing_log,\n        'remove_subscribers'              => \\&remove_subscribers,\n        'process_bouncing_addresses'      => \\&process_bouncing_addresses,\n        'edit_template'                   => \\&edit_template,\n        'view_archive'                    => \\&view_archive,\n        'display_message_source'          => \\&display_message_source,\n        'purge_all_archives'              => \\&purge_all_archives,\n        'delete_archive'                  => \\&delete_archive,\n        'edit_archived_msg'               => \\&edit_archived_msg,\n        'archive'                         => \\&list_archive,\n        'archive_bare'                    => \\&archive_bare,\n        'archive_rss'                     => \\&archive_rss,\n        'archive_atom'                    => \\&archive_atom,\n        'manage_script'                   => \\&manage_script,\n        'change_password'                 => \\&change_password,\n        'text_list'                       => \\&text_list,\n        'archive_options'                 => \\&archive_options,\n        'adv_archive_options'             => \\&adv_archive_options,\n        'back_link'                       => \\&back_link,\n\t\t'edit_type'                       => \\&edit_type,\n        'email_themes'                    => \\&email_themes, \n\t\t'edit_html_type'                  => \\&edit_html_type,\n        'list_options'                    => \\&list_options,\n        'web_services'                    => \\&web_services,\n        'mail_sending_options'            => \\&mail_sending_options,\n        'amazon_ses_verify_email'         => \\&amazon_ses_verify_email,\n        'amazon_ses_get_stats'            => \\&amazon_ses_get_stats,\n        'mailing_sending_mass_mailing_options' =>\n          \\&mailing_sending_mass_mailing_options,\n        'previewBatchSendingSpeed'      => \\&previewBatchSendingSpeed,\n        'mail_sending_advanced_options' => \\&mail_sending_advanced_options,\n        'filter_using_black_list'       => \\&filter_using_black_list,\n        'search_archive'                => \\&search_archive,\n        'send_archive'                  => \\&send_archive,\n        'list_invite'                   => \\&list_invite,\n        'mass_mailing_options'          => \\&mass_mailing_options,\n        'pass_gen'                      => \\&pass_gen,\n        'feature_set'                   => \\&feature_set,\n        'profile_fields'                => \\&profile_fields,\n        'mail_sending_options_test'     => \\&mail_sending_options_test,\n        'author'                        => \\&author,\n        'list'                          => \\&list_page,\n\t\t'privacy_policy'                => \\&list_privacy_policy, \n        'setup_info'                    => \\&setup_info,\n        'reset_cipher_keys'             => \\&reset_cipher_keys,\n        'restore_lists'                 => \\&restore_lists,\n        'r'                             => \\&redirection,\n        'post_redirection'              => \\&post_redirection, \n\t\t'subscriber_help'               => \\&subscriber_help,\n        'show_img'                      => \\&show_img,\n        'file_attachment'               => \\&file_attachment,\n        'm_o_c'                         => \\&m_o_c,\n        'img'                           => \\&img,\n        'js'                            => \\&js,\n        'css'                           => \\&css,\n        'ver'                           => \\&ver,\n        'resend_conf'                   => \\&resend_conf,\n        'show_error'                    => \\&show_error,\n        'subscription_form_html'        => \\&subscription_form_html,\n        'profile_activate'              => \\&profile_activate,\n\t\t'post_profile_activate'         => \\&post_profile_activate, \n        'profile_register'              => \\&profile_register,\n        'profile_reset_password'        => \\&profile_reset_password,\n\t\t'post_profile_reset_password'   => \\&post_profile_reset_password, \n        'profile_update_email'          => \\&profile_update_email,\n        'profile_login'                 => \\&profile_login,\n        'profile_logout'                => \\&profile_logout,\n        'profile'                       => \\&profile,\n        'also_save_for_settings'        => \\&also_save_for_settings,\n        'transform_to_pro'              => \\&transform_to_pro,\n        'yikes'                         => \\&yikes,\n        'rate_limit_reached'            => \\&rate_limit_reached,\n\t\t'status_405'                    => \\&status_405, \n\n# These handled the oldstyle confirmation. For some backwards compat, I've changed\n# them so that there's at least a shim to the new system,\n#\n#\t'n'                          =>    \\&confirm,\n        's'                          => \\&subscribe,\n        'u'                          => \\&unsubscribe,\n        'outdated_subscription_urls' => \\&outdated_subscription_urls,\n\n        # This is the new system\n        't' => \\&token,\n\n        # This doesn't really happen, anymore:\n        'ur'                               => \\&outdated_subscription_urls,\n        'send_email_testsuite'             => \\&send_email_testsuite,\n        $DADA::Config::ADMIN_FLAVOR_NAME   => \\&admin,\n        $DADA::Config::SIGN_IN_FLAVOR_NAME => \\&sign_in,\n\n        bridge_inject => \\&bridge_inject,\n    );\n\n    # ...inject?\n    if ( !$ENV{GATEWAY_INTERFACE} ) {\n\n        my $inject;\n        my $run_list;\n        require Getopt::Long;\n        Getopt::Long::GetOptions(\n            \"inject\" => \\$inject,\n            \"list=s\" => \\$run_list,\n        );\n        if ($inject) {\n\n            # $ENV{CGI_APP_RETURN_ONLY} = 1;\n\n            if ($run_list) {\n                $self->param( 'run_list', $run_list );\n                $self->start_mode('bridge_inject');\n            }\n            else {\n                # Well, that won't work.\n            }\n        }\n        else {\n            # Do watcha did before.\n        }\n    }\n\n    my $rate_limit = undef;\n\n    if ( $DADA::Config::RATE_LIMITING->{enabled} == 1\n        && exists( $ENV{GATEWAY_INTERFACE} ) )\n    {\n\n        require DADA::App::DBIHandle;\n        my $dbi_handle = DADA::App::DBIHandle->new;\n\t\tmy $dbh = undef; \n\t\t\n\t\tmy $dbi_handle_check = 1; \n\t    try {\n\t       $dbh =  $dbi_handle->dbh_obj;\n\t\t\n\t    } catch {\n\t\t\twarn $_; \n\t\t\t$dbi_handle_check = 0; \n\t    };\n\t\tif($dbi_handle_check == 0){ \n\t        return $self->sql_connect_error(); \n\t\t}\n\t\t\n        # call this in your setup routine to set\n        my $rate_limit = $self->rate_limit();\n\t\tmy $remote_addr = $ENV{REMOTE_ADDR}; # I can't think of any reason this should log anonymously.  \n\t\t\n        $rate_limit->identity_callback( sub { return $remote_addr } );\n\n        # set the database handle to use\n        $rate_limit->dbh($dbh);\n        $rate_limit->table( $DADA::Config::SQL_PARAMS{rate_limit_hits_table} );\n\n        my $pm_prefs = {\n            timeframe => $DADA::Config::RATE_LIMITING->{timeframe} . 'm',\n            max_hits  => $DADA::Config::RATE_LIMITING->{max_hits},\n        };\n\n        $rate_limit->protected_modes(\n            $sched_flavor                      => $pm_prefs,\n            subscribe                          => $pm_prefs,\n            restful_subscribe                  => $pm_prefs,\n            \n\t\t\ttoken                              => $pm_prefs,\n\t\t\tpost_token                         => $pm_prefs,\n\t\t\t\n\t\t\temail_password                     => $pm_prefs,\n\t\t\tprofile_reset_password             => $pm_prefs,\n            unsubscribe                        => $pm_prefs,\n            unsubscription_request             => $pm_prefs,\n            login                              => $pm_prefs,\n            #log_into_another_list              => $pm_prefs,\n            pass_gen                           => $pm_prefs,\n            file_attachment                    => $pm_prefs,\n            profile_activate                   => $pm_prefs,\n            profile_register                   => $pm_prefs,\n            profile_reset_password             => $pm_prefs,\n            profile_update_email               => $pm_prefs,\n            profile_login                      => $pm_prefs,\n            profile_logout                     => $pm_prefs,\n            profile                            => $pm_prefs,\n            's'                                => $pm_prefs,\n            u                                  => $pm_prefs,\n            outdated_subscription_urls         => $pm_prefs,\n            t                                  => $pm_prefs,\n            ur                                 => $pm_prefs,\n\t\t\tsend_archive                       => $pm_prefs,\n            $DADA::Config::ADMIN_FLAVOR_NAME   => $pm_prefs,\n            $DADA::Config::SIGN_IN_FLAVOR_NAME => $pm_prefs,\n        );\n\n        # call this runmode when a violation is detected\n        $rate_limit->violation_mode('rate_limit_reached');\n    }\n}\n\nsub teardown {\n    my $self = shift;\n\t\n    if ( $DADA::Config::SCHEDULED_JOBS_OPTIONS->{run_at_teardown} == 1 ) {\n        $self->run_pseudo_cron();\n    }\n}\n\n\n\nsub run_pseudo_cron {\n\n    my $self = shift;\n\n    #\treturn\n    #\t\tif $DADA::Config::SCHEDULED_JOBS_OPTIONS->{run_at_teardown} != 1;\n\n    # should this be something that's forked?\n    my @lists = available_lists( -In_Order => 1 );\n\n    return\n      unless scalar @lists >= 1;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $lists[0] } );\n\n    my $scheduled_jobs_last_ran = $ls->param('scheduled_jobs_last_ran') || 0;\n    my $time                    = time;\n\tmy $seven_and_a_half        = int($scheduled_jobs_last_ran) + (( 7.5 * 60 )); \n\tmy $hour                    = int($scheduled_jobs_last_ran) + (( 60 * 60 )); \n\t\n    if ( (int($time) > $seven_and_a_half) || $scheduled_jobs_last_ran == 0 ) {\n        \n\t\t# This gets a little crazy in the logs: \n\t\t# warn 'running scheduled jobs at teardown @ ' . scalar( localtime() );\n\t\t\n\t\tif(int($time) > $hour ) { \n\t\t\twarn 'scheduled jobs haven\\'t run in over an hour (double-check that the cronjob is set!) - running now: ' . scalar( localtime() );\n\t\t}\n\t\t\n        $self->schedules({-at_teardown => 1});\n    }\n    else {\n        #...\n\t\t# warn 'no.';\n    }\n}\n\n\n\n\nsub yikes {\n\n    my $self  = shift;\n    my $error = shift;\n\n    warn $error;\n\n    my $TIME = scalar( localtime() );\n\n    $self->header_props( -status => '500' );\n\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Yikes! App/Server Problem!</h1>\n<p>We apologize, but the server encountered a problem when attempting to complete its task.</p> \n<p>More information about this error may be available in the <em>program's own error log</em>.</p> \n<p><a href=\"mailto:$ENV{SERVER_ADMIN}\">Contact the Server Admin</a></p>\n<p>Time of error: <strong>$TIME</strong></p> \t\n\n\n\n</div>\n</body> \n</html> \n};\n\n}\n\n\n\n\nsub status_405 {\n\n    my $self  = shift;\n    my $error = shift;\n\n    warn $error;\n\n    my $TIME = scalar( localtime() );\n\n    $self->header_props( -status => '500' );\n\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>405 Method Not Allowed</h1>\n<p>&nbsp;</p>\n<p>More information about this error may be available in the <em>program's own error log</em>.</p> \n<p><a href=\"mailto:$ENV{SERVER_ADMIN}\">Contact the Server Admin</a></p>\n<p>Time of error: <strong>$TIME</strong></p> \t\n\n\n\n</div>\n</body> \n</html> \n};\n\n}\n\n\nsub rate_limit_reached {\n\n    my $self = shift;\n    sleep(30);\n\t\n    $self->header_props( -status => '429' );\n\t\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Rate Limit Reached!</h1>\n<p>We apologize, but you have reached the limit of requests allowed. Please try again in a few minutes. \n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n</div>\n\n</body> \n</html> \n};\n\n}\n\nsub sql_connect_error {\n\n    my $self = shift;\n    sleep(5);\n\t\n    $self->header_props( -status => '503' );\t\n\t$self->header_add('Retry-After' => 3600);\n\t\n\t\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Error: SQL Server Connection</h1>\n<p>We apologize, there is a problem talking to the SQL Server.  \n\n<p>More information about this problem may be available in the <em>program's own error log</em>.</p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n</div>\n\n</body> \n</html> \n};\n\n}\n\n\nsub unknown_param { \n\n    my $self = shift;\n\tmy $rm   = shift; \n\t\n\twarn 'unknown param called: \"' \n\t. $rm \n\t. '\" REMOTE HOST: ' \n\t.  $ENV{'REMOTE_HOST'} \n\t. ' REMOTE_ADDR: ' \n\t. $ENV{'REMOTE_ADDR'}; \n\t\n    sleep(5);\n\t\n    $self->header_props( -status => '404' );\n\t\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Unknown Flavor</h1>\n<p>We apologize, but the resource you're looking for does not exist.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n</div>\n\n</body> \n</html> \n};\n\n}\n\nsub default {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n    if ( DADA::App::Guts::install_dir_around() == 1 ) {\n        return user_error( { -error => 'install_dir_still_around' } );\n    }\n\n    # SQL backed working?\n    my $dbi_handle;\n    require DADA::App::DBIHandle;\n\n    $dbi_handle = DADA::App::DBIHandle->new;\n\t\n\tmy $dbi_handle_check = 1; \n    try {\n        $dbi_handle->dbh_obj;\n\t\t\n    } catch {\n\t\twarn $_; \n\t\t$dbi_handle_check = 0; \n    };\n\t\n\tif($dbi_handle_check == 0){ \n        return $self->sql_connect_error(); \n\t}\n\t\n    if ( DADA::App::Guts::SQL_check_setup() == 0 ) {\n        return user_error( { -error => 'bad_SQL_setup' } );\n    }\n    require DADA::MailingList::Settings;\n    my @available_lists;\n    try {\n        @available_lists = available_lists( -In_Order => 1 );\n    }\n    catch {\n        return user_error(\n            {\n                -error         => 'sql_connect_error',\n                -error_Message => $_\n            }\n        );\n    };\n\n    @available_lists = available_lists( -In_Order => 1 );\n\n    if (   ( $DADA::Config::DEFAULT_SCREEN ne '' )\n        && ( $q->param('flavor') ne 'default' )\n        && ( $#available_lists >= 0 ) )\n    {\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::DEFAULT_SCREEN );\n        return;\n    }\n\n    if ( !$available_lists[0] ) {\n        my $auth_state;\n        if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n            require DADA::Security::SimpleAuthStringState;\n            my $sast = DADA::Security::SimpleAuthStringState->new;\n            $auth_state = $sast->make_state;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'congrats_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    havent_agreed => (\n                        ( xss_filter( scalar $q->param('agree') ) eq 'no' )\n                        ? 1\n                        : 0\n                    ),\n                    auth_state => $auth_state,\n                },\n            }\n        );\n        return $scrn;\n    }\n\n    if (   $q->param('error_invalid_list') != 1\n        && ( !$c->profile_on )\n        && ( $c->is_cached('default.scrn') ) )\n    {\n        return $c->cached('default.scrn');\n    }\n\n    my $scrn = DADA::Template::Widgets::default_screen(\n        {\n            -email              => scalar $q->param('email'),\n            -list               => scalar $q->param('list'),\n            -error_invalid_list => scalar $q->param('error_invalid_list'),\n        }\n    );\n    if (  !$c->profile_on\n        && $available_lists[0]\n        && $q->param('error_invalid_list') != 1 )\n    {\n        $c->cache( 'default.scrn', \\$scrn );\n    }\n    return $scrn;\n\n}\n\nsub list_page {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\n    my $list = $q->param('list');\n    require DADA::MailingList::Settings;\n\n    if ( !defined( $q->param('email') )\n        && ( $q->param('error_no_email') != 1 ) )\n    {\n        if ( !$c->profile_on && $c->is_cached( 'list/' . $list . '.scrn' ) ) {\n            return $c->cached( 'list/' . $list . '.scrn' );\n        }\n    }\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $scrn = DADA::Template::Widgets::list_page(\n        -list           => $list,\n        -cgi_obj        => $q,\n        -email          => scalar $q->param('email'),\n        -error_no_email => scalar $q->param('error_no_email') || 0,\n    );\n    if (   !$c->profile_on\n        && !defined( $q->param('email') )\n        && ( $q->param('error_no_email') != 1 ) )\n    {\n        $c->cache( 'list/' . $list . '.scrn', \\$scrn );\n    }\n    return $scrn;\n\n}\n\n\nsub list_privacy_policy {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $list = $q->param('list');\n\t\n\t\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\t\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n\trequire DADA::MailingList::PrivacyPolicyManager;\n\tmy $ppm = DADA::MailingList::PrivacyPolicyManager->new; \n\tmy $pp_data = $ppm->latest_privacy_policy({-list => $list});\n\tif(!exists($pp_data->{privacy_policy})){ \n\t\tmy $new_pp_id = $ppm->add(\n\t\t\t{ \n\t\t\t\t-list           => $list, \n\t\t\t\t-privacy_policy => $ls->param('privacy_policy'), \n\t\t\t}\n\t\t); \n\t\t$pp_data = $ppm->latest_privacy_policy({-list => $list});\n\t}\n\tmy $saved_privacy_policy = $pp_data->{privacy_policy};\n\t$saved_privacy_policy = markdown_to_html({-str => $saved_privacy_policy});\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'list_privacy_policy.tmpl',\n            -expr           => 1,\n            -with           => 'list',\n\t\t\t-vars           => {\n\t\t\t\tprivacy_policy_date  => $pp_data->{timestamp},\n\t\t\t\tsaved_privacy_policy => $saved_privacy_policy, \n\t\t\t},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\nsub admin {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my @available_lists = available_lists();\n    if ( ( $#available_lists < 0 ) ) {\n        return $self->default();\n    }\n\n    if ( DADA::App::Guts::install_dir_around() == 1 ) {\n        return user_error( { -error => 'install_dir_still_around' } );\n    }\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'admin',\n      );\n\n    if ($checksout) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::DEFAULT_ADMIN_SCREEN );\n        return;\n    }\n    else {\n\n        my $login_widget = $q->param('login_widget') // $DADA::Config::LOGIN_WIDGET;\n\n        my $scrn = DADA::Template::Widgets::admin(\n            {\n                -cgi_obj => $q,\n                -vars    => {\n                    login_widget => $login_widget,\n                }\n            }\n        );\n\n        return $scrn;\n    }\n}\n\nsub sign_in {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( DADA::App::Guts::install_dir_around() == 1 ) {\n        return user_error( { -error => 'install_dir_still_around' } );\n    }\n\n    my $list                = $q->param('list');\n    my $list_password_reset = $q->param(\"list_password_reset\") || 0;\n    my $list_exists         = check_if_list_exists( -List => $list, );\n\n    if ( $list_exists >= 1 ) {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'sign_in',\n          );\n        if ( $checksout && $admin_list eq $list ) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::DEFAULT_ADMIN_SCREEN );\n        }\n        else {\n            my $auth_state;\n            if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n                require DADA::Security::SimpleAuthStringState;\n                my $sast = DADA::Security::SimpleAuthStringState->new;\n                $auth_state = $sast->make_state;\n            }\n\n            require DADA::MailingList::Settings;\n\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'list_login_form.tmpl',\n                    -expr           => 1,\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        flavor_sign_in      => 1,\n                        auth_state          => $auth_state,\n                        login_widget        => 'hidden_field',\n                        selected_list       => $list,\n                        list_password_reset => $list_password_reset,\n                    },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n\n        my $login_widget = $q->param('login_widget')\n          || $DADA::Config::LOGIN_WIDGET;\n        my $scrn = DADA::Template::Widgets::admin(\n            {\n                -cgi_obj => $q,\n                -vars    => {\n                    login_widget => $login_widget\n                },\n            }\n        );\n        return $scrn;\n    }\n\n}\n\n\nsub admin_menu_notifications { \n\n    my $self = shift;\n    my $q    = $self->query();\n\tmy $r = {}; \n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) = check_list_security( -cgi_obj => $q, );\n    if ($checksout) {\n\t\t$r->{drafts}                               = $self->admin_menu_drafts_notification(); \n\t\t$r->{sending_monitor}                      = $self->admin_menu_mailing_monitor_notification(); \n\t\t$r->{view_list}                            = $self->admin_menu_subscriber_count_notification(); \n\t\t$r->{change_info}                         = $self->admin_menu_change_info_notification();\n\t\t$r->{view_archive}                         = $self->admin_menu_archive_count_notification(); \n\t\t$r->{mail_sending_options}                 = $self->admin_menu_mail_sending_options_notification(); \n\t\t$r->{mailing_sending_mass_mailing_options} = $self->admin_menu_mailing_sending_mass_mailing_options_notification();\n\t\t$r->{email_themes}                         = $self->admin_menu_email_themes_notification();\n\t\t$r->{profile_fields}                       = $self->admin_menu_profiles_notification();\n\t\t$r->{bounce_handler}                       = $self->admin_menu_bounce_handler_notification();\n\t\t$r->{tracker}                              = $self->admin_menu_tracker_notification();\n\t\t$r->{bridge}                               = $self->admin_menu_bridge_notification();\n\n\t    require JSON;\n\t    my $json = JSON->new->allow_nonref;\n\t\n\t    my $headers = { -type => 'application/json', };\n\t    my $body = $json->encode( $r );\n\n\t    $self->header_props(%$headers);\n\n\t    return $body;\n\t}\n\telse { \n\t\treturn $error_msg;\n\t}\n\t\n}\nsub admin_menu_drafts_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::MessageDrafts;\n\n            my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n            my $num_drafts     = $d->count( { -role => 'draft' } );\n            my $num_stationery = $d->count( { -role => 'stationery' } );\n            my $num_shedules   = $d->count( { -role => 'schedule' } );\n\n            if (   $num_drafts > 0\n                || $num_stationery > 0\n                || $num_shedules > 0 )\n            {\n                return\n                    commify($num_drafts) . ','\n                  . commify($num_stationery) . ','\n                  . commify($num_shedules);\n            }\n        }\n    }\n    catch {\n        warn\n\"Problems filling out the 'Sending Monitor' admin menu item with interesting bits of information about the mailouts: $_\";\n    };\n\n}\n\nsub admin_menu_mailing_monitor_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n\n            my $list = $admin_list;\n            require DADA::Mail::MailOut;\n            my @mailouts =\n              DADA::Mail::MailOut::current_mailouts( { -list => $list } );\n            my $list_mailouts = $#mailouts + 1;\n\n            my (\n                $monitor_mailout_report, $total_mailouts,\n                $active_mailouts,        $paused_mailouts,\n                $queued_mailouts,        $inactive_mailouts\n              )\n              = DADA::Mail::MailOut::monitor_mailout(\n                {\n                    -verbose => 0,\n                    -list    => $list,\n                    -action  => 0,\n                }\n              );\n            return $list_mailouts . '/' . $total_mailouts;\n        }\n    }\n    catch {\n        warn\n\"Problems filling out the 'Sending Monitor' admin menu item with interesting bits of information about the mailouts: $_\";\n    };\n}\n\nsub admin_menu_subscriber_count_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Subscribers;\n            my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n            my $num = $lh->num_subscribers();\n            if ( $num > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0';\n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\n\nsub admin_menu_change_info_notification { \n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n            return $ls->param('list_owner_email') . ' / ' . $ls->param('admin_email');\n        }\n\t} catch { \n\t\n\t};\n} \n\nsub admin_menu_archive_count_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Archives;\n            my $lh = DADA::MailingList::Archives->new( { -list => $list } );\n            my $num = $lh->num_archives();\n            if ( $num > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0';\n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_mail_sending_options_notification {\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        my $rs = '';\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n            if ( $ls->param('sending_method') eq 'sendmail' ) {\n                $rs = 'sendmail';\n            }\n            elsif ( $ls->param('sending_method') eq 'smtp' ) {\n                $rs = 'SMTP';\n            }\n            elsif ( $ls->param('sending_method') eq 'amazon_ses' ) {\n                $rs = 'Amazon SES';\n            }\n        }\n        return $rs;\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_mailing_sending_mass_mailing_options_notification {\n    my $self = shift;\n    my $q    = $self->query();\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::Mail::MailOut;\n            my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n\t\t\t\n\t\t\t require DADA::MailingList::Settings; \n\t\t\t my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\t\t\n\t\t\t\n            my ( $batch_sending_enabled, $batch_size, $batch_wait ) = $mo->batch_params();\n            my $per_sec  = $batch_size / $batch_wait;\n            my $per_hour = int( $per_sec * 60 * 60 + .5 )\n              ; # DEV .5 is some sort of rounding thing (with int). That's wrong.\n\t\t\t  \n\t\t\tif(     $ls->param('sending_method') eq 'amazon_ses'\n\t\t\t\t&&  $ls->param('amazon_ses_auto_batch_settings') == 1\n\t\t\t\t&&  $batch_sending_enabled == 1\n\t\t\t){ \n\t\t\t\t\t\n\t\t\t\tmy $per_hour_thirded; \t\t\t\n\t\t\t\t$per_sec = ($batch_size / $batch_wait) - ($batch_size - $batch_wait);\n\t\t\t\t$per_hour = int( $per_sec * 60 * 60 + .5 );\n\n\t\t\t\t$per_hour_thirded = int(($per_hour * 3) + .5); \n\t\t\t\t$per_hour_thirded  = commify($per_hour_thirded);\n\t            $per_hour = commify($per_hour);\n\t\t\t\t\n\t\t\t\t return $per_hour . '/hr - ' . $per_hour_thirded . '/hr'; \n\t\t\t\t\n\t\t\t}\n\t\t\telse {  \n\t            if ( $batch_sending_enabled == 1 ) {\n\t                return commify($per_hour) . '/hr';\n\t            }\n\t            else {\n\t                return '';\n\t            }\t\t\t\n\t\t\t} \n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_profiles_notification { \n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            require DADA::ProfileFieldsManager;\n\t\t\tmy $fields = DADA::ProfileFieldsManager->new->fields;\n\t\t\tmy $num = scalar @$fields; \n            if ($num  > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0'; \n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_email_themes_notification {\n    my $self = shift;\n    my $q    = $self->query();\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\t\tmy $tn = $ls->param('email_theme_name') || 'default';\n\t\t\t$tn =~ s/_/ /g; \n\t\t\t$tn = join \" \", map {ucfirst} split \" \", $tn;\n\t\t\treturn $tn;\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\n\nsub admin_menu_bounce_handler_notification {\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::App::BounceHandler::ScoreKeeper;\n            my $bsk =\n              DADA::App::BounceHandler::ScoreKeeper->new( { -list => $list } );\n            my $num = $bsk->num_scorecard_rows;\n            if ( $num > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0'; \n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_tracker_notification {\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        my $rs = '';\n        if ($checksout) {\n            require DADA::Logging::Clickthrough;\n            my $rd = DADA::Logging::Clickthrough->new({-list => $admin_list});\n            my ( $total, $msg_ids ) = $rd->get_all_mids; \n            if ( $total > 0 ) {\n                return commify($total);\n            }\n\t\t\telse { \n\t\t\t\treturn '0'; \n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_bridge_notification {\n    my $self = shift;\n    my $q    = $self->query();\n    my $r;\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        my $rs = '';\n        if ($checksout) {\n\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n            $r = $ls->param('discussion_pop_email');\n\n            if ( $ls->param('disable_discussion_sending') == 1 ) {\n                $r .= ' (disabled)';\n            }\n            return $r;\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\n\nsub image_drag_and_drop {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $r = {};\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) {\n        $r = {\n            uploaded => 0,\n            error    => {\n                message => \"Permission Denied - security check failed!\",\n            }\n        };\n    }\n    else {\n\n\t\tmy $list = $admin_list; \n        my ( $status, $message, $filename, $width, $height ) =\n          $self->drag_and_drop_file_upload($list);\n\n        my $subfolder = 'files';\n        if ( $filename =~ m/\\.(jpg|jpeg|png|gif)$/ ) {\n            $subfolder = 'images';\n        }\n\n        # warn 'got back, ' . Dumper([$status, $message, $filename]);\n\n        if ( $status == 1 ) {\n\n            $r = {\n                uploaded => 1,\n                fileName => $filename,\n                url      => $DADA::Config::SUPPORT_FILES->{url}\n                  . '/file_uploads/'\n                  . $subfolder . '/'\n                  . $filename,\n            };\n\n            if ($message) {\n                $r->{error}->{message} = $message;\n            }\n            if ($width) {\n                $r->{width} = $width;\n            }\n            if ($height) {\n                $r->{height} = $height;\n            }\n\n        }\n        else {\n            $r = {\n                uploaded => 0,\n                error    => {\n                    message => $message\n                },\n            };\n\n        }\n    }\n\n    $self->header_props( -type => 'application/json' );\n\n    my $body = $json->encode($r);\n\n    # warn '$r' . Dumper($r);\n    # warn '$body' . $body;\n\n    return $body;\n\n}\n\nsub drag_and_drop_file_upload {\n\n    my $self = shift;\n\tmy $list = shift; \n    my $q    = $self->query();\n\n    my $fh = $q->upload('file_were_uploading');\n\t\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $message = undef;\n\n    my $filename = $q->param('file_were_uploading');\n\t   $filename = $filename;  #?\n\t   $filename =~ s!^.*(\\\\|\\/)!!;\n    \n\t\n\t#use Data::Dumper; \n\t#my %headers = map { $_ => $q->http($_) } $q->http();\n\t#for my $header ( keys %headers ) {\n\t#    warn \"$header: $headers{$header}\";\n\t#}\n\t#warn '$fh: ' . Dumper($fh);\n\t#warn 'uploadInfo' . Dumper($q->uploadInfo($fh)); \n\t#warn '$q' . Dumper($q);\n\t#warn '$filename: ' . $filename; \n\t\t\n    if ( !$filename ) {\n        return ( 0, 'No file name passed?', undef, undef, undef );\n    }\n\t\t\n\t# Bad Hombres:\n    my @bad_fn = qw(\n\t\texe com msi bat cgi pl \n\t\tphp phps phtml php3 php4 \n\t\tphp5 php6 py pyc pyo \n\t\tpcgi pcgi3 pcgi4 pcgi5 pchi6\n\t);\n\t\n\tmy $bad_fn = {}; \n\tfor(@bad_fn){$bad_fn->{'.' . $_} = 1};\n\tmy ($ext) = $filename =~ /(\\.[^.]+)$/;\n\t\t\n\tif(exists($bad_fn->{$ext})){ \n        return ( 0, 'Problems with the upload: unsupported file type', undef, undef, undef );\n\t}\n\n    my $subfolder = 'files';\n    if ( $filename =~ m/\\.(jpg|jpeg|png|gif)$/ ) {\n        $subfolder = 'images';\n    }\n\t\n\tcreate_dir($DADA::Config::SUPPORT_FILES->{dir} . '/' . 'file_uploads');\n\tmy $upload_dir = make_safer($DADA::Config::SUPPORT_FILES->{dir} . '/' . 'file_uploads' . '/' . $subfolder);\n\tcreate_dir($upload_dir);\n\n\tmy $save_fp = new_image_file_path($filename, $upload_dir);\n\t\n\t\n    open( OUTFILE, '>', $save_fp )\n      or die( \"can't write to \" . $save_fp . \": $!\" );\n\n    while ( my $bytesread = read( $fh, my $buffer, 1024 ) ) {\n        print OUTFILE $buffer \n\t\t\tor die $!;\n    }\n    close(OUTFILE) \n\t\tor die $!;\n    chmod( $DADA::Config::FILE_CHMOD, $save_fp );\n\n    if ( $filename =~ m/\\.(jpg|jpeg|png|gif)$/ ) {\n\t\tif($ls->param('resize_drag_and_drop_images') == 1){\n\t\t\trequire DADA::App::ResizeImages; \t\t\t\t\n\t\t\tmy ($rs_status, $rs_path, $rs_width, $rs_height) = DADA::App::ResizeImages::resize_image(\n\t\t\t\t{ \n\t\t\t\t\t-width          => $ls->param('email_image_width_limit'), \n\t\t\t\t\t-file_path      => $save_fp, \n\t\t\t\t}\t\n\t\t\t);\n\n            $message = 'Image resized and saved at, ' . $rs_path;\n\t\t\t\n\t\t\tmy ($n_filepath, $n_filename) = path_and_file($rs_path);\t\t\t\t\n\t\t\t\n\t\t\t$n_filename = uriescape($n_filename);\n\t\t\t\n            return ( 1, $message, $n_filename, $rs_width, $rs_height );\t\n        } \n\t\telse { \n\t\t\n\t\t\t# No Resize\n\t\t\t$filename = uriescape($filename);\n\t        return ( 1, $message, $filename );\n\t\t}\n\t}\n\telse { \n\t\t$filename = uriescape($filename);\n        return ( 0, 'Problems with the upload: unsupported file type', undef, undef, undef );\n\t}\n}\n\n\n\n\nsub no_draft_available { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\t\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'no_draft_available.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                screen                  => 'no_draft_available',\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n}\n\n\nsub email_message_preview {\n\n#\twarn 'email_message_preview';\n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n\trequire DADA::MailingList::Settings;\n\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\n    require DADA::ProfileFieldsManager;\n    my $pfm               = DADA::ProfileFieldsManager->new;\n    my $fields_attr       = $pfm->get_all_field_attributes;\n    my $subscriber_fields = $pfm->fields;\n\n\t# This should really be set to whatever the test email is set to... \n    my $fake_sub_info = { 'subscriber.email' => 'user@example.com', };\n    for (@$subscriber_fields) {\n        $fake_sub_info->{ 'subscriber.' . $_ } = $fields_attr->{$_}->{label},;\n    }\n\t\n\t# Other things need to be filled in, like the usubscription link \n\t# which, strangely, doesn't show up!? (expand macro tags, or something?)\n\n\tmy $fake_vars = {};\n    $fake_vars->{'list_unsubscribe_link'} = $DADA::Config::PROGRAM_URL . '/t/'  . 'CONFIRMATION_TOKEN' . '/';\n\t$fake_vars->{'sender.email'} = $ls->param('list_owner_email');\t\n\t\n\t\n\t$fake_vars->{message_id} = 'PREVIEW_MESSAGE_ID';\n\t\n\t\n\t# warn q{$fake_vars->{'list_unsubscribe_link'}} . $fake_vars->{'list_unsubscribe_link'}; \n\t\n\tmy $r  = {}; \n\tmy $vs = undef; \n\t\n\t\n\tmy $from_id = 1; \n\tmy $id               = $q->param('id') || undef;\n\tmy $email_theme_name = $q->param('email_theme_name') || undef;\n\t\n\tif(!defined($id) && defined($email_theme_name)) { \n\t\t$from_id = 0; \n\t}\n\telse { \n\t\t$from_id = 1; \n\t}\n\tif($from_id == 1){\n\t    \n\t\trequire DADA::App::EmailMessagePreview;\n\t    my $daemp = DADA::App::EmailMessagePreview->new;\n\t    $r     = $daemp->fetch( $id );\n\t}\n\telse { \n\t\trequire DADA::App::EmailThemes; \n\t\tmy $em = DADA::App::EmailThemes->new(\n\t\t\t{\n\t\t\t\t-list       => $list, \n\t\t\t\t-theme_name => $email_theme_name, \n\t\t\t}\n\t\t);\n\t\tmy $etp = $em->fetch('preview'); \n\t\t$r = { \n\t\t\tvars => {Subject => 'Preview Subject', 'X-Preheader' => 'Preview Preheader'},\n\t\t\thtml => $etp->{html},\n\t\t}\n\t}\n\t\n\t$vs = $r->{vars}->{Subject};\n\t\n\tmy $status = 1; \n\tmy $errors = undef; \n\t\n\tmy $subject = undef; \n\ttry {\n\t    $subject = DADA::Template::Widgets::screen(\n\t        {\n\t            -data                     => \\$vs,\n\t            -expr                     => 1,\n\t            -vars                     => {%$fake_sub_info, %$fake_vars},\n\t            -list_settings_vars_param => {\n\t                -list   => $list,\n\t                -dot_it => 1,\n\t            },\n\t        }\n\t    );\n\t} catch { \n\t\t$status = 0; \n\t\t$errors .= $_; \n\t};\n\t\n    $fake_sub_info->{'email.subject'}   = $subject;\n    $fake_sub_info->{'email.preheader'} = $r->{vars}->{'X-Preheader'};\n\t\n\t\n\tmy $scrn = undef; \n\tmy $msg  = $r->{html};\n\tmy $returning_plaintext = 0; \n\t\n\tif(length($msg) <= 0) {\n\t\t$msg = $r->{plaintext};\n\t\t$returning_plaintext = 1; \n\t}\n\t\n\ttry {\n\t    $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -data                     => \\$msg, \n\t            -expr                     => 1,\n\t            -vars                     => {%$fake_sub_info, %$fake_vars},\n\t            -list_settings_vars_param => {\n\t                -list   => $list,\n\t                -dot_it => 1,\n\t            },\t\n\t\t\t\t(($returning_plaintext == 0) ? (\n                -webify_these => [\n                    qw(\n                      list_settings.info\n                      list_settings.privacy_policy\n                      list_settings.physical_address\n                      )\n                ],) : () )\n\t        }\n\t    );\n\t} catch { \n\t\t$status = 0; \n\t\t$errors .= $_; \n\t};\n\tif($returning_plaintext == 1){ \n\t\t$self->header_props(-type => 'text/plain');\n\t}\n\n\tif($status == 1){\n\t\treturn $scrn;\n\t}\n\telse { \n\t\treturn $errors; \n\t}\n}\n\nsub send_email_button_widget {\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    my $draft_role      = $q->param('draft_role')      || 'draft';\n    my $archive_no_send = $q->param('archive_no_send') || 0;\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'send_email_button_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                draft_role      => $draft_role,\n                archive_no_send => $archive_no_send,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\nsub mass_mailing_schedules_preview {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    my $errors = {};\n    my $status = 1;\n\n    my $schedule_activated = $q->param('schedule_activated') || 0;\n    my $schedule_type      = $q->param('schedule_type')      || undef;\n\n    my $schedule_single_displaydatetime = undef;\n    my $schedule_single_ctime           = undef;\n\n    if ( $schedule_type eq 'single' ) {\n        $schedule_single_displaydatetime =\n          $q->param('schedule_single_displaydatetime') || undef;\n        if ( !$schedule_single_displaydatetime ) {\n            $status = 0;\n            $errors->{missing_information};\n        }\n\n  # warn '$schedule_single_displaydatetime ' . $schedule_single_displaydatetime;\n        $schedule_single_ctime =\n          displaytime_to_ctime($schedule_single_displaydatetime);\n    }\n\n    my $day_set = undef;\n    my $dates   = [];\n    my $errors  = undef;\n\n    my $start = undef;\n    my $end   = undef;\n\n    my $rd   = [];\n    my $days = {\n        7 => 'Sunday',\n        1 => 'Monday',\n        2 => 'Tuesday',\n        3 => 'Wednesday',\n        4 => 'Thursday',\n        5 => 'Friday',\n        6 => 'Saturday',\n    };\n\n    my $schedule_recurring_displaydatetime_start = undef;\n    my $schedule_recurring_displaydatetime_end   = undef;\n    my $schedule_recurring_ctime_start           = undef;\n    my $schedule_recurring_ctime_end             = undef;\n    my $schedule_recurring_display_hms           = undef;\n    my $schedule_recurring_hms                   = undef;\n    my @schedule_recurring_days                  = undef;\n\n    if ( $schedule_type eq 'recurring' ) {\n\n        $schedule_recurring_displaydatetime_start =\n          $q->param('schedule_recurring_displaydatetime_start') || undef;\n        $schedule_recurring_displaydatetime_end =\n          $q->param('schedule_recurring_displaydatetime_end') || undef;\n        $schedule_recurring_display_hms =\n          $q->param('schedule_recurring_display_hms') || undef;\n        $schedule_recurring_ctime_start =\n          displaytime_to_ctime($schedule_recurring_displaydatetime_start);\n        $schedule_recurring_ctime_end =\n          displaytime_to_ctime($schedule_recurring_displaydatetime_end);\n        @schedule_recurring_days = $q->multi_param('schedule_recurring_days');\n        $schedule_recurring_hms =\n          display_hms_to_hms($schedule_recurring_display_hms);\n\n        if ( !( scalar DADA::App::Guts::can_use_datetime() ) ) {\n            $status = 0;\n            $errors->{datetime} = 1;\n        }\n        elsif (\n            $schedule_recurring_ctime_start > $schedule_recurring_ctime_end )\n        {\n            $status = 0;\n            $errors->{schedule_recurring_dates_wrong} = 1;\n        }\n        elsif (!$schedule_recurring_displaydatetime_start\n            || !$schedule_recurring_displaydatetime_start\n            || !$schedule_recurring_display_hms\n            || ( scalar @schedule_recurring_days <= 0 ) )\n        {\n            $status = 0;\n            $errors->{missing_information} = 1;\n        }\n        else {\n\n            for (@schedule_recurring_days) {\n                push(\n                    @$rd,\n                    {\n                        day  => $_,\n                        name => $days->{$_},\n                    }\n                );\n            }\n            $schedule_recurring_ctime_start += $schedule_recurring_hms;\n            $schedule_recurring_ctime_end   += $schedule_recurring_hms;\n\n            try {\n                require DateTime;\n                require DateTime::Event::Recurrence;\n                $start =\n                  DateTime->from_epoch(\n                    epoch => $schedule_recurring_ctime_start );\n                $end =\n                  DateTime->from_epoch(\n                    epoch => $schedule_recurring_ctime_end );\n            }\n            catch {\n                warn $_;\n                $errors .= $_;\n            };\n            my ( $hours, $minutes, $seconds ) =\n              split( ':', $schedule_recurring_display_hms );\n        }\n    }\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'mass_mailing_schedules_preview.tmpl',\n            -expr   => 1,\n            -vars   => {\n                status => $status,\n\n                #   errors                             => $errors,\n                schedule_activated => $schedule_activated,\n                schedule_type      => $schedule_type,\n\n                schedule_single_ctime => $schedule_single_ctime,\n                schedule_single_localtime =>\n                  ctime_to_localtime($schedule_single_ctime),\n                schedule_single_displaydatetime =>\n                  $schedule_single_displaydatetime,\n\n                schedule_recurring_hms => $schedule_recurring_hms,\n                schedule_recurring_display_hms =>\n                  $schedule_recurring_display_hms,\n\n                schedule_recurring_displaydatetime_start =>\n                  $schedule_recurring_displaydatetime_start,\n                schedule_recurring_displaydatetime_end =>\n                  $schedule_recurring_displaydatetime_end,\n\n                schedule_recurring_localtime_start =>\n                  ctime_to_localtime($schedule_recurring_ctime_start),\n                schedule_recurring_localtime_end =>\n                  ctime_to_localtime($schedule_recurring_ctime_end),\n\n                schedule_recurring_days => $rd,\n                num_recurring_days      => scalar @$rd,\n\n                #  dates                              => $dates,\n\n                schedule_last_checked_ago => formatted_runtime(\n                    time - $ls->param('schedule_last_checked_time')\n                ),\n\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub mass_mailing_schedules_preview_calendar {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\tmy $draft_id = $q->param('draft_id');\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\t\n    my $list = $admin_list;\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'mass_mailing_schedules_preview_calendar.tmpl',\n            -expr   => 1,\n            -vars   => {\n                draft_id => $draft_id,\n            }\n        }\n    );\n    return $scrn;\n}\n\nsub mass_mailing_schedules_preview_calendar_json {\n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n\tmy $draft_id = $q->param('draft_id');\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\t\n    my $list = $admin_list;\n\t#warn '$list: ' .  $list; \n\n\t\n\trequire DADA::MailingList::MessageDrafts; \n\tmy $dmlmd = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n    my $q_draft = $dmlmd->fetch(\n        {\n            -id     => $draft_id,\n            -role   => 'schedule',\n        }\n    );\n\t\n\trequire DADA::MailingList::Schedules; \n\tmy $dmls = DADA::MailingList::Schedules->new({-list => $list});\n\tmy $json = $dmls->recurring_schedule_times_json({ \t\n\t    -recurring_time => $q_draft->param('schedule_recurring_display_hms'),\n\t\t-weeks          => [$q_draft->multi_param('schedule_recurring_weeks')],\n\t    -days           => [$q_draft->multi_param('schedule_recurring_days')],\n\t    -start          => $q_draft->param('schedule_recurring_ctime_start'),\n\t    -end            => $q_draft->param('schedule_recurring_ctime_end'),\n\t}); \n\t\n    my $headers = { -type => 'application/json', };\n\t$self->header_props(%$headers);\n\treturn $json; \n\t\n}\n\nsub draft_message_values {\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n\n    my ( $headers, $body ) = $ms->draft_message_values(\n        {\n            -cgi_obj => $q,\n        }\n    );\n\n    #    require Data::Dumper;\n    #    warn Data::Dumper::Dumper(\n    #        {\n    #            headers => $headers,\n    #            body    => $body,\n    #        }\n    #    );\n    if ( keys %$headers ) {\n        $self->header_props(%$headers);\n    }\n    return $body;\n\n}\n\nsub datetime_to_ctime {\n    my $datetime = shift;\n\n    #    warn '$datetime ' . $datetime;\n    require Time::Local;\n    my ( $date, $time ) = split( ' ', $datetime );\n    my ( $year, $month,  $day )    = split( '-', $date );\n    my ( $hour, $minute, $second ) = split( ':', $time );\n    $second = int( $second - 0.5 );    # no idea.\n    my $time =\n      Time::Local::timelocal( $second, $minute, $hour, $day, $month - 1,\n        $year );\n\n    return $time;\n}\n\nsub datetime_to_localtime {\n    my $datetime = shift;\n    my $time     = datetime_to_ctime($datetime);\n    return scalar( localtime($time) );\n}\n\nsub ckeditor_template_tag_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    my $strings = [];\n\n    require DADA::ProfileFieldsManager;\n    my $pfm         = DADA::ProfileFieldsManager->new;\n    my $fields_attr = $pfm->get_all_field_attributes;\n\n    push( @$strings, { name => 'Profile Fields', } );\n    push(\n        @$strings,\n        {\n            name  => 'Email Address',\n            value => '<!-- tmpl_var subscriber.email -->',\n        }\n    );\n    push(\n        @$strings,\n        {\n            name  => 'Email Name',\n            value => '<!-- tmpl_var subscriber.email_name -->',\n        }\n    );\n\n    push(\n        @$strings,\n        {\n            name  => 'Email Domain',\n            value => '<!-- tmpl_var subscriber.email_domain -->',\n        }\n    );\n\n    foreach my $field ( @{ $pfm->fields } ) {\n        push(\n            @$strings,\n            {\n                name  => $fields_attr->{$field}->{label},\n                value => '<!-- tmpl_var subscriber.' . $field . ' -->',\n            }\n        );\n    }\n\n    my $settings = [\n        {\n            name => 'List Settings'\n        },\n        {\n            name  => 'List Name',\n            value => '<!-- tmpl_var list_settings.list_name -->',\n        },\n        {\n            name  => 'List Owner Email Address',\n            value => '<!-- tmpl_var list_settings.list_owner_email -->',\n        },\n        {\n            name  => 'Mailing List Description',\n            value => '<!-- tmpl_var list_settings.info -->',\n        },\n        {\n            name  => 'Mailing List Privacy Policy',\n            value => '<!-- tmpl_var list_settings.privacy_policy -->',\n        },\n        {\n            name  => 'Physical Address',\n            value => '<!-- tmpl_var list_settings.physical_address -->',\n        },\n    ];\n    push( @$strings, @$settings );\n\n    push( @$strings, { name => 'Loops/Conditionals', } );\n    push(\n        @$strings,\n        {\n            name  => 'loop...',\n            value => '<!-- tmpl_loop field_name --><!-- /tmpl_loop -->',\n        }\n    );\n    push(\n        @$strings,\n        {\n            name  => 'if...',\n            value => '<!-- tmpl_if field_name --><!-- /tmpl_if -->',\n        }\n    );\n    push(\n        @$strings,\n        {\n            name  => 'unless...',\n            value => '<!-- tmpl_unless field_name --><!-- /tmpl_unless -->',\n        }\n    );\n\n    my $headers = { -type => 'application/json', };\n    my $body = $json->encode( { strings => $strings } );\n\n    $self->header_props(%$headers);\n\n    return $body;\n\n}\n\nsub draft_saved_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $role = $q->param('role');\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'draft_saved_notification_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                role => $role,\n            }\n        }\n    );\n    return $scrn;\n}\n\nsub drafts {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'drafts'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    my $delete_draft = $q->param('delete_draft') || 0;\n\n    require DADA::MailingList::MessageDrafts;\n    my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n\n    my $di  = [];\n    my $si  = [];\n    my $sci = [];\n\n    $di  = $d->draft_index( { -role => 'draft' } );\n    $si  = $d->draft_index( { -role => 'stationery' } );\n    $sci = $d->draft_index( { -role => 'schedule' } );\n\n    #use Data::Dumper;\n    #return '<pre>' . Data::Dumper::Dumper($sci);\n\n    my $sci_active   = [];\n    my $sci_inactive = [];\n    for (@$sci) {\n        if ( $_->{schedule_activated} == 1 ) {\n            push( @$sci_active, $_ );\n        }\n        else {\n            push( @$sci_inactive, $_ );\n        }\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'drafts.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -expr => 1,\n            -vars => {\n                screen                  => 'drafts',\n                delete_draft            => $delete_draft,\n                draft_index             => $di,\n                stationery_index        => $si,\n                active_schedule_index   => $sci_active,\n                inactive_schedule_index => $sci_inactive,\n                num_drafts              => scalar(@$di),\n                num_stationery          => scalar(@$si),\n                num_schedules           => scalar(@$sci),\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\nsub preview_draft { \n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'drafts'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\t\n\t\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n    \n\ttry {\n\t\tmy $r = $ms->preview_draft(\n\t        {\n\t            -cgi_obj     => $q,\n\t        }\n\t    );\n\t\n\t\tif($r->{status} == 0){\n\t\t\t$self->header_props(-type => 'text/html');\n\t\t\treturn \"<p><strong>Problems with creating preview:</strong></p><pre> \" . $r->{errors} . '</pre>';\n\t\t}\n\t\telsif($r->{status} == 1){ \n\t\t\t$q->param('id', $r->{id});\n\t\t\t$q->param('flavor', 'email_message_preview');\n\t\t\treturn $self->email_message_preview(); \n\t\t}\n\t}\n\tcatch { \n\t\t$self->header_props(-type => 'text/plain');\n\t\treturn \"Problems creating preview: $_\";\n\t};\n}\n\n\n\nsub delete_drafts {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my @draft_ids = $q->multi_param('draft_ids');\n\n    require DADA::MailingList::MessageDrafts;\n    my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n\n    foreach my $id (@draft_ids) {\n        $d->remove($id);\n    }\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor=drafts&delete_draft=1' );\n\n}\n\nsub create_from_stationery {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list     = $admin_list;\n    my $draft_id = $q->param('draft_id');\n    my $screen   = $q->param('screen');\n\n    require DADA::MailingList::MessageDrafts;\n    my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n    my $new_id =\n      $d->create_from_stationery( { -id => $draft_id, -screen => $screen } );\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor='\n          . $screen\n          . '&draft_id='\n          . $new_id );\n\n}\n\n#sub message_body_help {\n#\n#    my $self = shift;\n#    my $q    = $self->query();\n#\n#    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n#      check_list_security( -cgi_obj => $q, );\n#    if ( !$checksout ) { return $error_msg; }\n#\n#    my $body = DADA::Template::Widgets::screen(\n#        { -screen => 'send_email_message_body_help_widget.tmpl', } );\n#    return $body;\n# }\n#sub url_message_body_help {\n#\n#    my $self = shift;\n#    my $q    = $self->query();\n#\n#    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n#      check_list_security( -cgi_obj => $q );\n#    if ( !$checksout ) { return $error_msg; }\n#    return (\n#        {},\n#        DADA::Template::Widgets::screen(\n#            { -screen => 'send_url_email_message_body_help_widget.tmpl', }\n#        )\n#    );\n#}\n\nsub preview_message_receivers {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $r;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    require DADA::MailingList::Settings;\n    my $list   = $admin_list;\n    my $lh     = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $fields = [];\n\n    # Extra, special one...\n    push( @$fields, { name => 'subscriber.email' } );\n    for my $field ( @{ $lh->subscriber_fields( { -dotted => 1 } ) } ) {\n        push( @$fields, { name => $field } );\n    }\n    my $naked_fields = $lh->subscriber_fields( { -dotted => 0 } );\n    my $undotted_fields = [];\n\n    # Extra, special one...\n    push( @$undotted_fields, { name => 'email', label => 'Email Address' } );\n    for my $undotted_field ( @{$naked_fields} ) {\n        push( @$undotted_fields, { name => $undotted_field } );\n    }\n\n    my $partial_sending = partial_sending_query_to_params( $q, $naked_fields );\n\n    my $order_by  = 'email';\n    my $order_dir = 'desc';\n\n    if ( exists( $partial_sending->{'subscriber.timestamp'}->{-value} ) ) {\n        $order_by  => 'timestamp';\n        $order_dir => 'desc';\n    }\n    my ( $fancy_r, $fancy_c );\n\n    if ( keys %$partial_sending ) {\n        ( $fancy_r, $fancy_c ) = $lh->fancy_list(\n            {\n                -partial_listing       => $partial_sending,\n                -type                  => 'list',\n                -show_list_column      => 1,\n                -show_timestamp_column => 1,\n                -order_by              => $order_by,\n                -order_dir             => $order_dir,\n            }\n        );\n        $r .= $fancy_r;\n    }\n    else {\n        \n        $r .= $q->p(\n            $q->em(\n                    'All '\n                  . $q->strong( commify( $lh->num_subscribers ) )\n                  . ' Subscribers of your mailing list will receive this message.'\n            )\n        );\n    \n    }\n    return $r;\n\n}\n\nsub sending_monitor_index {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'sending_monitor'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $mailout_status = [];\n    my @lists;\n\n    # If we're logged in as dada root, we see all the mass mailings going on.\n    if ( $root_login == 1 ) {\n        @lists = available_lists();\n    }\n    else {\n        # If not, only the current list.\n        @lists = ($list);\n    }\n\n    for my $l_list (@lists) {\n        my @mailouts = DADA::Mail::MailOut::current_mailouts(\n            {\n                -list     => $l_list,\n                -order_by => 'creation',\n            }\n        );\n        for my $mo (@mailouts) {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $l_list } );\n            $mailout->associate( $mo->{id}, $mo->{type} );\n            my $status = $mailout->status();\n            require DADA::MailingList::Settings;\n            my $l_ls = DADA::MailingList::Settings->new( { -list => $l_list } );\n            push(\n                @$mailout_status,\n                {\n                    %$status,\n                    list          => $l_list,\n                    current_list  => ( ( $list eq $l_list ) ? 1 : 0 ),\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL,\n                    Subject =>\n                      safely_decode( $status->{email_fields}->{Subject}, 1 ),\n                    status_bar_width => int( $status->{percent_done} ) * 1,\n                    negative_status_bar_width => 100 -\n                      ( int( $status->{percent_done} ) * 1 ),\n                    message_id   => $mo->{id},\n                    message_type => $mo->{type},\n                    mailing_started =>\n                      scalar( localtime( $status->{first_access} ) ),\n                    mailout_stale => $status->{mailout_stale},\n                    %{ $l_ls->params },\n                }\n            );\n        }\n    }\n\n    my (\n        $monitor_mailout_report, $total_mailouts,  $active_mailouts,\n        $paused_mailouts,        $queued_mailouts, $inactive_mailouts\n      )\n      = DADA::Mail::MailOut::monitor_mailout(\n        {\n            -verbose => 0,\n            ( $root_login == 1 ) ? () : ( -list => $list )\n        }\n      );\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'sending_monitor_index_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                screen                 => 'sending_monitor',\n                killed_it              => scalar $q->param('killed_it') ? 1 : 0,\n                mailout_status         => $mailout_status,\n                monitor_mailout_report => $monitor_mailout_report,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub sending_monitor {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'sending_monitor'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    require DADA::MailingList::Settings;\n    require DADA::Mail::MailOut;\n\n    my $list = $admin_list;\n\n    my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n    my ( $batching_enabled, $batch_size, $batch_wait ) = $mo->batch_params;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    # munging the message id.\n    # kinda dumb, but it's sort of up in the air,\n    # on how the message id comes to us,\n    # so we have to be *real* careful to get it to a state\n    # that we *need* it in.\n\n    my $id = DADA::App::Guts::strip( scalar $q->param('id') );\n    $id =~ s/\\@/_at_/g;\n    $id =~ s/\\>|\\<//g;\n\n    if ( !$q->param('id') ) {\n        return $self->sending_monitor_index();\n    }\n\t\n\tmy $draft_id = $q->param('draft_id');\n\t# warn '$draft_id: ' . $draft_id; \n\t\n\t\n\t\n\t\n    # 10 is the factory default setting to wait per batch.\n    # Let's not refresh an faster, or we'll never have time\n    # to read the actual screen.\n\n    my $refresh_after = 10;\n    if ( $refresh_after < $batch_wait ) {\n        $refresh_after = $batch_wait;\n    }\n\n    # Type ala, list, invitation list, etc\n    my $type = $q->param('type');\n    $type = xss_filter( DADA::App::Guts::strip($type) );\n\t# warn '$type: '  . $type; \n\n\n    my $restart_count = $q->param('restart_count') || 0;\n\n    require DADA::Mail::Send;\n    my $mh = DADA::Mail::Send->new(\n        {\n            -list   => $list,\n            -ls_obj => $ls,\n        }\n    );\n\n    my $auto_pickup = 0;\n\n    # Kill - the, [Stop] button was pressed. Pressed really hard.\n\n    if ( $q->param('process') eq 'kill' ) {\n\n        if ( DADA::Mail::MailOut::mailout_exists( $list, $id, $type ) == 1 ) {\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $mailout->clean_up;\n        }\n        else {\n            warn \"mailout $id does NOT exists! What's going on?!\";\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( \n\t\t\t-url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&killed_it=1' \n\t\t\t  . '&draft_id=' . $draft_id\n\t\t\t  );\n\n    }\n    elsif ( $q->param('process') eq 'pause' ) {\n\n        if ( DADA::Mail::MailOut::mailout_exists( $list, $id, $type ) == 1 ) {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $mailout->pause();\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=sending_monitor&id='\n                  . $id\n                  . '&type='\n                  . $type\n                  . '&paused_it=1'\n\t\t\t\t  . '&draft_id=' . $draft_id\n\t\t\t);\n        }\n        else {\n            die \"mass mailing does NOT exists! What's going on?!\";\n        }\n\n    }\n    elsif ( $q->param('process') eq 'resume' ) {\n\n        if ( DADA::Mail::MailOut::mailout_exists( $list, $id, $type ) == 1 ) {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $mailout->resume();\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=sending_monitor&id='\n                  . $id\n                  . '&type='\n                  . $type\n                  . '&resume_it=1'\n\t\t\t\t  . '&draft_id=' . $draft_id\n\t\t\t );\n\n        }\n        else {\n\n            die \"mass mailing does NOT exists! What's going on?!\";\n\n        }\n\n# Restart is usually called by the program itself, automagically via a redirect if DADA::Mail::MailOut says we should restart.\n    }\n    elsif ( $q->param('process') eq 'restart' ) {\n\n        my $restart_time = 1;\n\n        # Let's make sure that restart worked...\n        my $should_be_restarted = 0;\n        eval {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $should_be_restarted = $mailout->should_be_restarted;\n            if ( $should_be_restarted == 1 ) {\n                $mh->restart_mass_send( $id, $type );\n                sleep(5);\n            }\n        };\n\n        my $refresh_url;\n        if ( $should_be_restarted == 1 ) {\n            $refresh_url =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&id='\n              . $id\n              . '&type='\n              . $type\n              . ' &restart_count='\n              . $restart_count\n\t\t\t  . '&draft_id=' . $draft_id; \n        }\n        else {\n            $refresh_url =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&id='\n              . $id\n              . '&type='\n              . $type\n\t\t\t  . '&draft_id=' . $draft_id; \n        }\n        my $r = \"<html>\n                <head>\n\n                 <script type=\\\"text/javascript\\\">\n\n                 function refreshpage(sec) {\n\t\t\t\t\tvar refreshafter = sec/1 * 1000;\n\t\t\t\t\tsetTimeout(function() {\t\t\t\t\n\t\t\t\t\t\twindow.location.replace('$refresh_url')\n\t\t\t\t\t},\n\t\t\t\t\trefreshafter);\n                }\n\n\t\t        refreshpage(5);\n\t\t\t\t\n                </script>\n\n\n                 </head>\n                 <body>\n                 \";\n        return ( {}, $r );\n\n        # If not...\n        if ($@) {\n            my $r = \"<h1>Problems Reloading!:</h1><pre>$@</pre>\";\n\n            # We're going to refresh, see if it gets better.\n            $restart_time = 5;\n        }\n\n        if ( $should_be_restarted == 1 ) {\n\n            # Provide a link in case browser redirect is working\n            warn 'Reloading Message from Mailing Monitor';\n            $r .= '<a href=\"' . $refresh_url . '\">Reloading Mailing...</a>';\n        }\n        else {\n            warn 'Refreshing Screen from Mailing Monitor';\n            $r .= '<a href=\"' . $refresh_url . '\">Refreshing Screen....</a>';\n        }\n        $r .= \"\n\n        <script type=\\\"text/javascript\\\">\n        refreshpage($restart_time);\n        </script>\n        </body>\n       </html>\";\n\n        return ( {}, $r );\n    }\n    elsif ( $q->param('process') eq 'ajax' ) {\n\n        my $mailout                = undef;\n        my $status                 = {};\n        my $mailout_exists         = 0;\n        my $mailout_exists         = 0;\n        my $my_test_mailout_exists = 0;\n        eval {\n            $my_test_mailout_exists =\n              DADA::Mail::MailOut::mailout_exists( $list, $id, $type );\n        };\n\n        if ( !$@ ) {\n            $mailout_exists = $my_test_mailout_exists;\n        }\n\t\t\n\t\t# warn '$mailout_exists: ' . $mailout_exists; \n\t\t\n        if ($mailout_exists) {\n\t\t\t\n            $mailout_exists = 1;\n            $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $status = $mailout->status();\n\t\t\t\n\t\t\t# require Data::Dumper; \n\t\t\t#warn 'status: ' . Data::Dumper::Dumper($status);\n\n        }\n        else {\n\t\t\t# warn 'nope.';\n            # Nothing - I believe this is handled in the template.\n\n        }\n\n        my (\n            $monitor_mailout_report, $total_mailouts,\n            $active_mailouts,        $paused_mailouts,\n            $queued_mailouts,        $inactive_mailouts\n          )\n          = DADA::Mail::MailOut::monitor_mailout(\n            {\n                -verbose => 0,\n                -list    => $list\n            }\n          );\n\n       #warn '$status->{should_be_restarted} ' . $status->{should_be_restarted};\n       #warn q{$ls->param('auto_pickup_dropped_mailings') }\n       #  . $ls->param('auto_pickup_dropped_mailings');\n       #warn '$restart_count' . $restart_count;\n       #warn '$status->{mailout_stale}' . $status->{mailout_stale};\n       #warn '$active_mailouts' . $active_mailouts;\n\n        if (\n            $status->{should_be_restarted} == 1 &&    # It's dead in the water.\n            $ls->param('auto_pickup_dropped_mailings') == 1\n            &&    # Auto Pickup is turned on...\n             # $status->{total_sending_out_num} - $status->{total_sent_out} >  0 && # There's more subscribers to send out to\n            $restart_count <= 0 &&    # We haven't *just* restarted this thing\n            $status->{mailout_stale} != 1\n            && # The mailout hasn't been sitting around too long without being restarted,\n            $active_mailouts <\n            $DADA::Config::MAILOUT_AT_ONCE_LIMIT # There's not already too many mailouts going out.\n          )\n        {\n\n            # warn \"Yes, we need to restart!\";\n\n   # Whew! Take that for making sure that the damn thing is supposed to be sent.\n\n            my $reload_url =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&id='\n              . $id\n\t\t\t  . '&draft_id=' . $draft_id\n              . '&process=restart&type='\n              . $type\n              . '&restart_count=1';\n\n            my $r = \"<script type=\\\"text/javascript\\\"> \n\t\t\twindow.location.replace('$reload_url'); \n\t\t\t</script>\";\n            return ( {}, $r );\n        }\n        else {\n\n            # warn \"No, no need to restart.\";\n            $restart_count = 0;\n        }\n\n        my $sending_status = [];\n        for ( keys %$status ) {\n            next if $_ eq 'email_fields';\n            push( @$sending_status, { key => $_, value => $status->{$_} } );\n        }\n\n# If we're... say... 2x a batch setting and NOTHING has been sent,\n# let's say a mailing will be automatically started in... time since last - wait time.\n\n        my $will_restart_in = undef;\n\n        # $batch_wait\n        if ( time - $status->{last_access} > ( $batch_wait * 1.5 ) ) {\n            my $tardy_threshold = $batch_wait * 3;\n\n            if ( $tardy_threshold < 60 ) {\n                $tardy_threshold = 60;\n            }\n\n            $will_restart_in =\n              $tardy_threshold - ( time - $status->{last_access} );\n            if ( $will_restart_in >= 1 ) {\n                $will_restart_in = formatted_runtime($will_restart_in);\n            }\n            else {\n                $will_restart_in = undef;\n            }\n        }\n\n        my $hourly_rate = 0;\n        if ( $status->{mailing_time} > 0 ) {\n            $hourly_rate = commify(\n                int(\n                    ( $status->{total_sent_out} / $status->{mailing_time} ) *\n                      60 * 60 + .5\n                )\n            );\n        }\n\n        my $header_subject_label = DADA::Template::Widgets::screen(\n            {\n                -data => \\$status->{email_fields}->{Subject},\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n                -subscriber_vars_param => {\n                    -use_fallback_vars => 1,\n                    -list              => $list,\n                },\n                -decode_before => 1,\n            }\n        );\n\n       \n\t    # I can basically know if this is a test message if: \n\t\t# the draft is still around... \n\t\t\n\t\tmy $mass_mailing_has_draft = 0; \n\t\tmy $draft_url              = ''; \n\t\tif($draft_id){ \n            require DADA::MailingList::MessageDrafts;\n            my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n\t\t\tif($d->id_exists($draft_id)){ \n\t\t\t\tmy $q_draft = $d->fetch({-id => $draft_id});\n\t\t\t\t$mass_mailing_has_draft = 1; \n\t\t\t\t$draft_url = $DADA::Config::S_PROGRAM_URL \n\t\t\t\t. '?flavor=send_email'\n\t\t\t\t. '&draft_id='   . $draft_id\n\t\t\t\t. '&draft_role=' . $q_draft->param('_internal_draft_role');\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t    my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'sending_monitor_screen.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    screen                 => 'sending_monitor',\n                    mailout_exists         => $mailout_exists,\n                    message_id             => DADA::App::Guts::strip($id),\n\t\t\t\t\tdraft_id                    => $draft_id, \n\t\t\t\t\tmass_mailing_has_draft      => $mass_mailing_has_draft, \n\t\t\t\t\tdraft_url                   => $draft_url,    \n                    message_type           => scalar $q->param('type'),\n                    total_sent_out         => $status->{total_sent_out},\n                    total_sending_out_num  => $status->{total_sending_out_num},\n                    mailing_time           => $status->{mailing_time},\n                    mailing_time_formatted => $status->{mailing_time_formatted},\n                    hourly_rate            => $hourly_rate,\n                    percent_done           => $status->{percent_done},\n                    status_bar_width => int( $status->{percent_done} ) * 5,\n                    negative_status_bar_width => 500 -\n                      ( int( $status->{percent_done} ) * 5 ),\n                    need_to_send_out => (\n                        $status->{total_sending_out_num} -\n                          $status->{total_sent_out}\n                    ),\n                    time_since_last_sendout => formatted_runtime(\n                        ( time - int( $status->{last_sent} ) )\n                    ),\n                    its_killed => $status->{should_be_restarted},\n                    header_subject =>\n                      safely_decode( $status->{email_fields}->{Subject}, 1 ),\n                    header_subject_label =>\n                      ( length($header_subject_label) > 50 )\n                    ? ( substr( $header_subject_label, 0, 49 ) . '...' )\n                    : ($header_subject_label),\n                    auto_pickup_dropped_mailings =>\n                      $ls->param('auto_pickup_dropped_mailings'),\n                    sending_done => ( $status->{percent_done} < 100 ) ? 0 : 1,\n                    refresh_after  => $refresh_after,\n                    killed_it      => scalar $q->param('killed_it') ? 1 : 0,\n                    sending_status => $sending_status,\n                    is_paused      => $status->{paused} > 0 ? 1 : 0,\n                    paused         => $status->{paused},\n                    queue          => $status->{queue},\n                    queued_mailout => $status->{queued_mailout},\n                    queue_place    => ( $status->{queue_place} + 1 )\n                    ,    # adding one since humans like counting from, \"1\"\n                    queue_total => ( $status->{queue_total} + 1 )\n                    ,    # adding one since humans like counting from, \"1\"\n                    status_mailout_stale => $status->{mailout_stale},\n                    MAILOUT_AT_ONCE_LIMIT =>\n                      $DADA::Config::MAILOUT_AT_ONCE_LIMIT,\n                    will_restart_in => $will_restart_in,\n                    integrity_check => $status->{integrity_check},\n                },\n            }\n        );\n\n        return $scrn;\n    }\n    else {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'sending_monitor_container_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen        => 'sending_monitor',\n                    message_id    => DADA::App::Guts::strip($id),\n\t\t\t\t\tdraft_id      => $draft_id,\n                    message_type  => scalar $q->param('type'),\n                    refresh_after => $refresh_after,\n'list_settings.tracker_show_message_reports_in_mailing_monitor'\n                      => $ls->param(\n                        'tracker_show_message_reports_in_mailing_monitor'),\n                    list_type_isa_list => ( $q->param('type') eq 'list' )\n                    ? 1\n                    : 0,\n                }\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub print_mass_mailing_log {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'sending_monitor'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $id   = $q->param('id');\n    my $type = $q->param('type');\n\n    my $list = $admin_list;\n\n    require DADA::Mail::MailOut;\n    my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n    $mailout->associate( $id, $type );\n    $self->header_props( { -type => 'text/plain' } );\n    return $mailout->return_log;\n}\n\nsub send_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $Ext_Request = undef;\n    if ( defined( $self->param('Ext_Request') ) ) {\n        $Ext_Request = $self->param('Ext_Request');\n    }\n\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n    my ( $headers, $body ) = $ms->send_email(\n        {\n            -cgi_obj     => $q,\n            -Ext_Request => $Ext_Request,\n            -root_login  => $root_login,\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub list_invite {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'add'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n\n    my $Ext_Request = undef;\n    if ( defined( $self->param('Ext_Request') ) ) {\n        $Ext_Request = $self->param('Ext_Request');\n    }\n\n    my ( $headers, $body ) = $ms->list_invite(\n        {\n            -cgi_obj     => $q,\n            -Ext_Request => $Ext_Request,\n            -root_login  => $root_login,\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub mass_mailing_options {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list    = $admin_list;\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\n    if ( !$process ) {\n\n        my $can_use_css_inliner = 1;\n        try {\n            require CSS::Inliner;\n        }\n        catch {\n            $can_use_css_inliner = 0;\n        };\n\t\t\n\t\tmy $currently_selected_layout = $ls->param('mass_mailing_default_layout') || undef; \n\t\tif(!defined($currently_selected_layout)) { \n\t\t\tif($ls->param('group_list') == 1 && $ls->param('disable_discussion_sending') != 1){ \n\t\t\t\t$currently_selected_layout = 'discussion'; \n\t\t\t}\n\t\t\telse { \n\t\t\t\t$currently_selected_layout = 'default'; \n\t\t\t}\n\t\t}\n\t\t\n        my %wysiwyg_vars = DADA::Template::Widgets::make_wysiwyg_vars($list);\n\t\t\n\t\trequire HTML::Menu::Select;\n\t\tmy $email_image_width_limit_pop_menu = HTML::Menu::Select::popup_menu(\n          {\n              name    => 'email_image_width_limit',\n              id      => 'email_image_width_limit',\n              default => $ls->param('email_image_width_limit'),\n              values => [qw(240 320 480 580 640 800 1024)],\n          }\n        );\n\t\t\n\t\tmy $email_message_size_limit_popup_menu = HTML::Menu::Select::popup_menu(\n        {\n            name    => 'email_message_size_limit',\n            id      => 'email_message_size_limit',\n            default => $ls->param('email_message_size_limit'),\n            values => [qw(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 25 30 35 40 50)],\n        }\n      );\n\t\t\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'mass_mailing_options_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n\t\t\t\t\t\n\t\t\t\t\tscreen                  => 'mass_mailing_options',\n\t\t\t\t\t\n                    root_login                => $root_login,\n                    done                      => $done,\n                    can_use_css_inliner       => $can_use_css_inliner,\n\t\t\t\t\t\n\t\t\t\t\tcan_use_Image_Scale       => scalar can_use_Image_Scale(),\n\t\t\t\t\tcan_use_Image_Resize      => scalar can_use_Image_Resize(),\n\t\t\t\t\tcan_use_Image_Magick      => scalar can_use_Image_Magick(),\n\t\t\t\t\t\n\t\t\t\t\tcurrently_selected_layout => $currently_selected_layout, \n\t\t\t\t\t\n                    ckeditor_enabled =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}\n                      ->{enabled},\n                    ckeditor_url =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url},\n\n                    tiny_mce_enabled =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}\n                      ->{enabled},\n                    tiny_mce_url =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url},\n                    \n\t\t\t\t\temail_image_width_limit_pop_menu => \n\t\t\t\t\t\t$email_image_width_limit_pop_menu, \n\t\t\t\t\t\t\n\t\t\t\t\temail_message_size_limit_popup_menu => \n\t\t\t\t\t\t$email_message_size_limit_popup_menu,\n\t\t\t\t\t\n\t\t\t\t\t%wysiwyg_vars,\n\t\t\t\t\t\n\t\t\t\t\t\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    mass_mailing_convert_plaintext_to_html      => 0,\n                    mass_mailing_block_css_to_inline_css        => 0,\n\t\t\t\t\temail_embed_images_as_attachments           => 0,\n\t\t\t\t\tresize_drag_and_drop_images                 => 0, \n\t\t\t\t\temail_resize_embedded_images                => 0,\n\t\t\t\t\temail_image_width_limit                     => 0,\n\t\t\t\t\tenable_file_attachments_in_editor           => 0,  \n\t\t\t\t\temail_limit_message_size                    => 0, \n\t\t\t\t\temail_message_size_limit                    => 0, \n\t\t\t\t\tmass_mailing_use_list_unsubscribe_headers   => 0,\n\t\t\t\t\tmass_mailing_remove_javascript              => 0, \n                \tmass_mailing_default_layout                 => undef, \n\t\t\t\t\tmass_mailing_save_sent_drafts_as_stationery => 0, \n\t\t\t\t\tmass_mailing_show_by_default_type           => undef, \n                    use_wysiwyg_editor                          => 'none',\n\t\t\t\t\tmass_mailing_show_previews_in               => undef,\n\t\t\t\t},\n                -also_save_for => $also_save_for_list,\n            }\n        );\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=mass_mailing_options&done=1' );\n    }\n\n}\n\n\nsub is_valid_url { \n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\tmy $enabled = $q->param('enabled')  // 1; \n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_info'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n\tmy $url = $q->param('check_url');\n\n    my ( $content, $res, $md5 ) = grab_url( { -url => $url } );\n    \n  \t$self->header_props( -type => 'text/plain' );\n   \n\tif ( $res->is_success ) {\n\t\treturn \"true\";\n\t}\n\telse {\n\t\tif($enabled == 0){\n\t\t\t#return $res->message;\n\t\t\treturn \"true\";\n\t\t}\n\t\telse { \n\t\t\treturn \"false\";\n\t\t}\n\t}\n}\n\nsub change_info {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_info'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $list_name        = $q->param('list_name')        || undef;\n    my $list_owner_email = $q->param('list_owner_email') || undef;\n    my $admin_email      = $q->param('admin_email')      || undef;\n    my $info             = $q->param('info')             || undef;\n    my $physical_address = $q->param('physical_address') || undef;\n    my $done             = $q->param('done')             || undef;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n\n\t\n    require DADA::App::AmazonSES;\n    my $ses = DADA::App::AmazonSES->new;\n\n\tmy $check_ses_verification; \t\n\tif($ls->param('sending_method') eq 'amazon_ses'){ \n\t\t$check_ses_verification = 1; \n\t}\n\telsif(\n\t\t$ls->param('sending_method') eq 'smtp'\n\t    && $ls->param('smtp_server') =~ m/amazonaws\\.com/\n\t\t&& $ses->has_ses_options_set == 1\n\t){ \n\t\t$check_ses_verification = 1; \t\n\t}\n\telse { \n\t\t$check_ses_verification = 0;\n\t}\n\n\tmy $ses_params = {};\n\t\t\n    if ($check_ses_verification == 1){\n        $ses_params->{using_ses} = 1;\n        $ses_params->{list_owner_ses_verified}     = $ses->sender_verified( $ls->param('list_owner_email') );\n        $ses_params->{list_admin_ses_verified}     = $ses->sender_verified( $ls->param('admin_email') );\n        $ses_params->{discussion_pop_ses_verified} = $ses->sender_verified( $ls->param('discussion_pop_email') );\n    }\n    my $errors = 0;\n    my $flags  = {};\n\n    if ($process) {\n        ( $errors, $flags ) = check_list_setup(\n            -fields => {\n                list             => $list,\n                list_name        => $list_name,\n                list_owner_email => $list_owner_email,\n                admin_email      => $admin_email,\n                info             => $info,\n                physical_address => $physical_address,\n            },\n            -new_list => 'no',\n        );\n    }\n\n    undef $process\n      if $errors >= 1;\n\n    if ( !$process ) {\n\n        my $err_word = 'was';\n        $err_word = 'were'\n          if $errors && $errors > 1;\n\n        my $errors_ending = '';\n        $errors_ending = 's'\n          if $errors && $errors > 1;\n\n        my $flags_list_name = $flags->{list_name} || 0;\n\n        my $flags_list_name_bad_characters = $flags->{list_name_bad_characters}\n          || 0;\n\n        my $flags_invalid_list_owner_email = $flags->{invalid_list_owner_email}\n          || 0;\n        my $flags_list_info        = $flags->{list_info}        || 0;\n        my $flags_physical_address = $flags->{physical_address} || 0;\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'change_info_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen        => 'change_info',\n                    done          => $done,\n                    errors        => $errors,\n                    errors_ending => $errors_ending,\n                    err_word      => $err_word,\n                    list          => $list,\n                    list_name     => $list_name ? $list_name\n                    : $ls->param('list_name'),\n                    list_owner_email => $list_owner_email ? $list_owner_email\n                    : $ls->param('list_owner_email'),\n                    admin_email => $admin_email ? $admin_email\n                    : $ls->param('admin_email'),\n                    info => $info ? $info : $ls->param('info'),\n                    physical_address => $physical_address ? $physical_address\n                    : $ls->param('physical_address'),\n                    \n\t\t\t\t\tPLUGINS_ENABLED_bounce_handler => $DADA::Config::PLUGINS_ENABLED->{bounce_handler},\n\t\t\t\t\tBounce_Handler_Address         => $DADA::Config::PLUGIN_CONFIGS->{Bounce_Handler}->{Address},\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tflags_list_name => $flags_list_name,\n                    flags_invalid_list_owner_email =>\n                      $flags_invalid_list_owner_email,\n                    flags_list_info        => $flags_list_info,\n                    flags_physical_address => $flags_physical_address,\n                    flags_list_name_bad_characters =>\n                      $flags_list_name_bad_characters,\n                    %$ses_params,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        $admin_email = $list_owner_email\n          unless defined($admin_email);\n\n        $ls->save(\n            {\n                -settings => {\n                    list_owner_email     => strip($list_owner_email),\n                    admin_email          => strip($admin_email),\n                    list_name            => $list_name,\n                    info                 => $info,\n                    physical_address     => $physical_address,\n\t\t\t\t\tlist_phone_number    => xss_filter( strip( scalar $q->param('list_phone_number') ) ),\n                    logo_image_url       => xss_filter( strip( scalar $q->param('logo_image_url') ) ),\n                    website_url          => xss_filter( strip( scalar $q->param('website_url') )),\n\t\t\t\t\tfacebook_page_url    => xss_filter( strip( scalar $q->param('facebook_page_url') )),\n                    youtube_url          => xss_filter( strip( scalar $q->param('youtube_url') )),\n                    twitter_url          => xss_filter( strip( scalar $q->param('twitter_url') ) ),\n                    instagram_url        => xss_filter( strip( scalar $q->param('instagram_url') )),\n\t\t\t\t\twhatsapp_number      => xss_filter( strip( scalar $q->param('whatsapp_number') )),\n\t\t\t\t\tcustom_url_color     => xss_filter( strip( scalar $q->param('custom_url_color') )),\n\t\t\t\t\tcustom_url_label     => xss_filter( strip( scalar $q->param('custom_url_label') )),\n\t\t\t\t\tcustom_url           => xss_filter( strip( scalar $q->param('custom_url') )),\n\t\n\t\t\t\t\t\n\t\t\t\t\t\n                }\n            }\n        );\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=change_info&done=1' );\n    }\n}\n\nsub manage_privacy_policy { \n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done             = $q->param('done')             || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'manage_privacy_policy'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $privacy_policy   = $q->param('privacy_policy')   || undef;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\t\t\n\t\t# grab the most recent privacy policy from the db. \n\t\t# if it's not set, set it, then try to grab it again. \n\t\trequire DADA::MailingList::PrivacyPolicyManager;\n\t\tmy $ppm = DADA::MailingList::PrivacyPolicyManager->new; \n\t\tmy $pp_data = $ppm->latest_privacy_policy({-list => $list});\n\t\tif(!exists($pp_data->{privacy_policy})){ \n\t\t\tmy $new_pp_id = $ppm->add(\n\t\t\t\t{ \n\t\t\t\t\t-list           => $list, \n\t\t\t\t\t-privacy_policy => $ls->param('privacy_policy'), \n\t\t\t\t}\n\t\t\t); \n\t\t\t$pp_data = $ppm->latest_privacy_policy({-list => $list});\n\t\t}\n\t\tmy $saved_privacy_policy = $pp_data->{privacy_policy};\n\t\t\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'manage_privacy_policy.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen        => 'manage_privacy_policy',\n                    done          => $done,\n                    privacy_policy => $saved_privacy_policy,\n                 },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\t\t\n\t\trequire DADA::MailingList::PrivacyPolicyManager;\n\t\tmy $ppm = DADA::MailingList::PrivacyPolicyManager->new; \n\t\tmy $new_pp_id = $ppm->add(\n\t\t\t{ \n\t\t\t\t-list           => $list, \n\t\t\t\t-privacy_policy => $privacy_policy, \n\t\t\t}\n\t\t); \t\t\n\t\tmy $pp_data = $ppm->latest_privacy_policy(\n\t\t\t{\n\t\t\t\t-list => $list,\n\t\t\t}\n\t\t);\n\t\t\n\t\t# Yeah, we save the privacy policy twice. \n        $ls->save(\n            {\n                -settings => {\n                    privacy_policy       => $pp_data->{privacy_policy},\n                }\n            }\n        );\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=manage_privacy_policy&done=1' );\n    }\n\n}\n\nsub manage_list_consent { \n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'manage_list_consent',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n\t\n    require DADA::MailingList::Settings;\n\tmy $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\n\t\n\tif($process eq 'add_consent'){ \n\t\trequire DADA::MailingList::Consents; \n\t\tmy $new_consent = $q->param('new_consent') || undef; \n\t\trequire DADA::MailingList::Consents; \n\t\tmy $con = DADA::MailingList::Consents->new; \n\t\tmy $new_id = $con->add(\n\t\t\t{ \n\t\t\t\t-list    => $list, \n\t\t\t\t-consent => $new_consent,\n\t\t\t}\n\t\t); \n\t\tcarp 'new consent id: ' . $new_id;\n\t\t\n\t\t# And once that's done, we grab any consents already saved \n\t\t# (that's just ina  particular setting)\n\t\t# Add this new one to the lsit, \n\t\t# THen save it back? \n\t\t# Which format? \n\t\t\n\t\tmy $consent_ids = $ls->param('list_consent_ids'); \n\t\tmy $cids = $con->thawish_for_reading($consent_ids);\n\t\t\n\t\t\n\t\tpush(@$cids, $new_id); \n\t\t\n\t\tmy $freeze = $con->freezish_for_saving($cids);\n\t\t\n\t\t\n\t\t$ls->save(\n\t\t\t{\n\t\t\t\t-settings => {\n\t\t\t\t\tlist_consent_ids => $freeze, \n\t\t\t\t}\n\t\t\t}\t\n\t\t);\n\t\t\n\t\t$c->flush;\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=manage_list_consent;done=1;new_id=' . $new_id);\n\t\t\t  \n\t    return; \n\n\t}\n\telsif($process eq 'remove_list_consent'){ \n\t\t\n\t\tmy $id = $q->param('id');\n\n\t\trequire DADA::MailingList::Consents; \n\t\tmy $con = DADA::MailingList::Consents->new; \t\t\n\t\tmy $consent_ids = $ls->param('list_consent_ids'); \n\t\tmy $cids = $con->thawish_for_reading($consent_ids);\n\t\t\t\n\t\tmy $new_cids = []; \n\t\tfor(@$cids){ \n\t\t\tif($_ == $id){ \n\t\t\t\t# ... \n\t\t\t}\n\t\t\telse { \n\t\t\t\tpush(@$new_cids, $_);\n\t\t\t}\n\t\t}\n\t\tmy $freeze = $con->freezish_for_saving($new_cids);\n\t\t\n\t\t$ls->save(\n\t\t\t{\n\t\t\t\t-settings => {\n\t\t\t\t\tlist_consent_ids => $freeze, \n\t\t\t\t}\n\t\t\t}\t\n\t\t);\n\t\t$c->flush;\n\t\t\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=manage_list_consent;done=1;removed_id=' . $id);\n\t\t\t  \n\t    return; \n\t\t\n\t}\n\t\n\tmy $con = DADA::MailingList::Consents->new; \n\t\n\tuse DADA::MailingList::Consents; \n\tmy $consents = $con->give_me_all_consents($ls); \n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'manage_list_consent.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -expr => 1,\n            -vars => {\n\t\t\t\tconsents => $consents, \n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n}\n\nsub change_password {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $process          = $q->param('process')          || undef;\n\tmy $recaptcha_failed = $q->param('recaptcha_failed') || 0;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_password',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::Security::Password;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'change_password_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen     => 'change_password',\n                    root_login => $root_login,\n\t\t\t\t\trecaptcha_failed => $recaptcha_failed, \n\t\t\t\t\t\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\t\t\n\t\t\n\t\tif (can_use_Google_reCAPTCHA() == 1 ) {\n\t        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\t\t\tif($captcha_status == 0){ \n\t            $q->delete('process');\n\t\t\t\t$q->param('recaptcha_failed', 1);\n\t\t\t\treturn $self->change_password; \n\t\t\t}\n\t\t\telse { \n\t\t\t\t#...\n\t\t\t}\n\t\t}\n\n        my $old_password       = $q->param('old_password');\n        my $new_password       = $q->param('new_password');\n        my $again_new_password = $q->param('again_new_password');\n\n        if ( $root_login != 1 ) {\n            my $password_check =\n              DADA::Security::Password::check_password( $ls->param('password'),\n                $old_password );\n            if ( $password_check != 1 ) {\n                return (\n                    {},\n                    user_error(\n                        {\n                            -list  => $list,\n                            -error => \"invalid_password\"\n                        }\n                    )\n                );\n            }\n        }\n\n        $new_password       = strip($new_password);\n        $again_new_password = strip($again_new_password);\n\n        if (   $new_password ne $again_new_password\n            || $new_password eq \"\" )\n        {\n            return (\n                {},\n                user_error(\n                    {\n                        -list  => $list,\n                        -error => \"list_pass_no_match\"\n                    }\n                )\n            );\n        }\n\n        $ls->save(\n            {\n                -settings => {\n                    password => $new_password\n                }\n            }\n        );\n\n# -no_list_security_check, because the list password's changed, it wouldn't pass it anyways...\n        my ( $headers, $body ) = $self->logout(\n            -no_list_security_check => 1,\n            -redirect_url           => $DADA::Config::S_PROGRAM_URL\n              . '?flavor='\n              . $DADA::Config::SIGN_IN_FLAVOR_NAME\n              . '&list='\n              . $list,\n        );\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub delete_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'delete_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $process          = $q->param('process')          || undef;\n\tmy $recaptcha_failed = $q->param('recaptcha_failed') || 0;\n\t\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_list_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list                     => $list,\n                -vars                     => { \n\t\t\t\t\tscreen           => 'delete_list', \n\t\t\t\t\trecaptcha_failed => $recaptcha_failed, \n\t\t\t\t},\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\t\t\n\t\tif (can_use_Google_reCAPTCHA() == 1 ) {\n\t        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\t\t\tif($captcha_status == 0){ \n\t            $q->delete('process');\n\t\t\t\t$q->param('recaptcha_failed', 1);\n\t\t\t\treturn $self->delete_list; \n\t\t\t}\n\t\t\telse { \n\t\t\t\t#...\n\t\t\t}\n\t\t}\n\t\t\n        require DADA::MailingList;\n        DADA::MailingList::Remove(\n            {\n                -name => $list,\n            }\n        );\n        $c->flush;\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_list_success_screen.tmpl',\n                -with           => 'list',\n                -wrapper_params => {\n                    -Use_Custom => 0,\n                },\n            }\n        );\n\n\n        require DADA::App::Session;\n        my $dada_session = DADA::App::Session->new( -List => $list );\n        my $logout_cookie = $dada_session->logout_cookie( -cgi_obj => $q );\n\n        $self->header_props( -cookie => $logout_cookie, );\n        return $scrn;\n    }\n}\n\nsub list_options {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'list_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done')    || undef;\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $can_use_mx_lookup = 0;\n\n    eval { require Net::DNS; };\n    if ( !$@ ) {\n        $can_use_mx_lookup = 1;\n    }\n\n    my $can_use_StopForumSpam = can_use_StopForumSpam();\n\n    my $can_use_captcha       = can_use_Google_reCAPTCHA();\t\n\tmy $using_captcha_on_initial_subscribe_form = 0; \n\tif(\n\t\t$can_use_captcha                                          == 1 \n\t\t&& $ls->param('enable_captcha_on_initial_subscribe_form') == 1\n\t){ \n\t\t$using_captcha_on_initial_subscribe_form = 1; \n\t}\n\n    if ( !$process ) {\n        require HTML::Menu::Select;\n        my $send_subscription_notice_to_popup_menu =\n          HTML::Menu::Select::popup_menu(\n            {\n                name    => 'send_subscription_notice_to',\n                id      => 'send_subscription_notice_to',\n                default => $ls->param('send_subscription_notice_to'),\n                labels  => {\n                    list         => 'Your Subscribers',\n                    'list_owner' => 'The List Owner',\n                    'alt'        => 'Other:'\n                },\n                values => [qw(list list_owner alt)],\n            }\n          );\n        my $send_unsubscription_notice_to_popup_menu =\n          HTML::Menu::Select::popup_menu(\n            {\n                name    => 'send_unsubscription_notice_to',\n                id      => 'send_unsubscription_notice_to',\n                default => $ls->param('send_unsubscription_notice_to'),\n                labels  => {\n                    list         => 'Your Subscribers',\n                    'list_owner' => 'The List Owner',\n                    'alt'        => 'Other:'\n                },\n                values => [qw(list list_owner alt)],\n            }\n          );\n        my $send_admin_unsubscription_notice_to_popup_menu =\n          HTML::Menu::Select::popup_menu(\n            {\n                name    => 'send_admin_unsubscription_notice_to',\n                id      => 'send_admin_unsubscription_notice_to',\n                default => $ls->param('send_admin_unsubscription_notice_to'),\n                labels  => {\n                    list         => 'Your Subscribers',\n                    'list_owner' => 'The List Owner',\n                    'alt'        => 'Other:'\n                },\n                values => [qw(list list_owner alt)],\n            }\n          );\n\t\t    \n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'list_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -list => $list,\n                -vars => {\n                    screen                => 'list_options',\n                    title                 => 'Options',\n                    done                  => $done,\n                    root_login            => $root_login,\n                    can_use_mx_lookup     => $can_use_mx_lookup,\n                    can_use_captcha       => $can_use_captcha,\n\t\t\t\t\tusing_captcha_on_initial_subscribe_form => $using_captcha_on_initial_subscribe_form, \n                    can_use_StopForumSpam => $can_use_StopForumSpam,\n                    send_subscription_notice_to_popup_menu =>\n                      $send_subscription_notice_to_popup_menu,\n                    send_unsubscription_notice_to_popup_menu =>\n                      $send_unsubscription_notice_to_popup_menu,\n                    send_admin_unsubscription_notice_to_popup_menu =>\n                      $send_admin_unsubscription_notice_to_popup_menu,\n                    list_owner_email_anonystar_address =>\n                      DADA::App::Guts::anonystar_address_encode(\n                        $ls->param('list_owner_email')\n                      ),\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        if ( $q->param('anyone_can_subscribe') == 1 ) {\n            $q->param( 'invite_only_list', 0 );\n        }\n        else {\n            $q->param( 'invite_only_list', 1 );\n        }\n\n        my $list               = $admin_list;\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    private_list                                            => 0,\n                    hide_list                                               => 0,\n\t\t\t\t\tshow_request_removal_links                              => 0, \n                    closed_list                                             => 0,\n                    invite_only_list                                        => 0,\n                    get_sub_notice                                          => 0,\n                    get_unsub_notice                                        => 0,\n                    enable_closed_loop_opt_in                               => 0,\n\t\t\t\t\tenable_captcha_on_initial_subscribe_form                => 0,\n                    send_unsub_success_email                                => 0,\n                    send_sub_success_email                                  => 0,\n                    send_newest_archive                                     => 0,\n                    mx_check                                                => 0,\n                    limit_sub_confirm                                       => 0,\n                    limit_sub_confirm_use_captcha                           => 0,\n                    enable_sub_confirm_stopforumspam_protection             => 0,\n                    enable_sub_confirm_suspicious_activity_by_ip_protection => 0,\n                    email_your_subscribed_msg                               => 0,\n                    email_you_are_not_subscribed_msg                        => 0,\n                    use_alt_url_sub_confirm_success                         => 0,\n                    alt_url_sub_confirm_success                             => '',\n                    alt_url_sub_confirm_success_w_qs                        => 0,\n                    alt_url_sub_confirm_success_show_in_modal_window        => 0, \n\t\t\t\t\tuse_alt_url_sub_confirm_failed                          => 0,\n                    alt_url_sub_confirm_failed                              => '',\n                    alt_url_sub_confirm_failed_w_qs                         => 0,\n\t\t\t\t\talt_url_sub_confirm_failed_show_in_modal_window         => 0, \n                    use_alt_url_sub_success                                 => 0,\n                    alt_url_sub_success                                     => '',\n                    alt_url_sub_success_w_qs                                => 0,\n                    use_alt_url_sub_failed                                  => 0,\n                    alt_url_sub_failed                                      => '',\n                    alt_url_sub_failed_w_qs                                 => 0,\n                    use_alt_url_subscription_approval_step                  => 0,\n                    alt_url_subscription_approval_step                      => '',\n                    alt_url_subscription_approval_step_w_qs                 => 0,\n                    use_alt_url_unsub_success                               => 0,\n                    alt_url_unsub_success                                   => '',\n                    alt_url_unsub_success_w_qs                              => 0,\n                    unsub_show_email_hint                                   => 0,\n                    # one_click_unsubscribe                                   => 0,\n\t\t\t\t\tcompleting_the_unsubscription                           => undef, \n                    enable_subscription_approval_step                       => 0,\n                    enable_mass_subscribe                                   => 0,\n                    enable_mass_subscribe_only_w_root_login                 => 0,\n                    send_subscribed_by_list_owner_message                   => 0,\n                    send_unsubscribed_by_list_owner_message                 => 0,\n                    send_last_archived_msg_mass_mailing                     => 0,\n                    captcha_sub                                             => 0,\n                    send_subscription_notice_to                             => undef,\n                    send_unsubscription_notice_to                           => undef,\n                    alt_send_unsubscription_notice_to                       => undef,\n                    alt_send_subscription_notice_to                         => undef,\n                    alt_send_admin_unsubscription_notice_to                 => undef,\n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=list_options&done=1' );\n    }\n}\n\n\n\n\nsub subscribe_landing { \n\n\t #how does this work for private and/or hidding lists? \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\tmy $list  = $q->param('list')  || undef; \n\tmy $email = $q->param('email') || undef; \n\t\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        {\n            -list                 => $list,\n\t\t\t-email                => $email, \n        }\n    );\n\t\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'subscribe_landing.tmpl',\n            -expr           => 1,\n            -with           => 'list',\n\t\t\t-vars           => {\n\t\t\t\tcan_use_JSON      => scalar DADA::App::Guts::can_use_JSON(),\n\t\t\t\tsubscription_form => $subscription_form,\n\t\t\t},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n\n}\n\n\nsub modal_subscribe_landing { \n\n\t #how does this work for private and/or hidding lists? \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\tmy $list  = $q->param('list')  || undef; \n\tmy $email = $q->param('email') || undef; \n\t\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        {\n            -list                 => $list,\n\t\t\t-email                => $email, \n\t\t\t-form_target          => '_blank',\n        }\n    );\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen         => 'modal_subscribe_landing.tmpl',\n            -expr           => 1,\n           # -with           => 'list',\n\t\t\t-vars           => {\n\t\t\t\tcan_use_JSON      => scalar DADA::App::Guts::can_use_JSON(),\n\t\t\t\tsubscription_form => $subscription_form,\n\t\t\t\tload_captcha_js => 1, \n\t\t\t\tload_colorbox => 1, \n\t\t\t\t\n\t\t\t\tinclude_jquery_lib   =>  1,\n                include_app_user_js  => 1,\n\t\t\t\t# I don't know why you have to all this atm\n\n                add_app_css          =>  1,\n\t\t\t\t\n\t\t\t\t\n\t\t\t},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n\n}\n\n\n\n\nsub api {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $dp = $q->url || $DADA::Config::PROGRAM_URL;\n    $dp =~ s/^(http:\\/\\/|https:\\/\\/)(.*?)\\//\\//;\n\n    my $info = $q->path_info();\n\n    $info =~ s/^$dp//;\n\n    # script name should be something like:\n    # /cgi-bin/dada/mail.cgi\n    $info =~ s/^$ENV{SCRIPT_NAME}//i;\n    $info =~ s/(^\\/|\\/$)//g;    #get rid of fore and aft slashes\n\n    # seriously, this shouldn't be needed:\n    $info =~ s/^dada\\/mail\\.cgi//;\n\n    my ( $pi_flavor, $pi_list, $pi_service, $pi_public_key, $pi_digest ) =\n      split( '/', $info );\n\n# https://metacpan.org/pod/distribution/CGI/lib/CGI.pod#FETCHING-ENVIRONMENT-VARIABLES\n# https://stackoverflow.com/questions/7362932/perl-equivalent-of-php-auth-pw\n# HTTP_AUTHORIZATION\n    my %incoming_headers = map { $_ => $q->http($_) } $q->http();\n    if ( $DADA::Config::DEBUG_TRACE->{DADA_App_WebServices} == 1 ) {\n        warn \"Incoming Headers for API call:\";\n       \trequire Data::Dumper;\n        warn Data::Dumper::Dumper( {%incoming_headers} );\n    }\n\n    if ( !defined($pi_public_key) && !defined($pi_digest) ) {\n        my $auth_h = $incoming_headers{HTTP_AUTHORIZATION};\n        $auth_h =~ s/^hmac //;\n        ( $pi_public_key, $pi_digest ) = split( ':', $auth_h );\n    }\n    if ( !defined( $q->param('nonce') ) && $ENV{REQUEST_METHOD} eq 'GET' ) {\n        $q->param( 'nonce', $incoming_headers{'HTTP_X_DADA_NONCE'} );\n    }\n\n    $q->delete('flavor');    # ... probably.\n\n    require DADA::App::WebServices;\n    my $ws = DADA::App::WebServices->new;\n    my ( $headers, $body ) = $ws->request(\n        {\n            -list       => $pi_list,\n            -service    => $pi_service,\n            -public_key => $pi_public_key,\n            -digest     => $pi_digest,\n            -cgi_obj    => $q,\n        }\n    );\n\n    if ( keys %$headers ) {\n        $self->header_props(%$headers);\n    }\n    return $body;\n}\n\nsub web_services {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'web_services'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( length( $ls->param('public_api_key') ) <= 0\n        || $process eq 'reset_keys' )\n    {\n        require DADA::Security::Password;\n        $ls->save(\n            {\n                -settings => {\n                    public_api_key =>\n                      DADA::Security::Password::generate_rand_string(\n                        undef, 21\n                      )\n                }\n            }\n        );\n        undef $ls;\n        $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    }\n    if ( length( $ls->param('private_api_key') ) <= 0\n        || $process eq 'reset_keys' )\n    {\n        require DADA::Security::Password;\n        $ls->save(\n            {\n                -settings => {\n                    private_api_key =>\n                      DADA::Security::Password::generate_rand_string(\n                        undef, 41\n                      )\n                }\n            }\n        );\n        undef $ls;\n        $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    }\n    my $keys_reset = 0;\n    if ( $process eq 'reset_keys' ) {\n        $keys_reset = 1;\n\t\t\n        my ( $headers, $body ) = $self->logout(\n            -no_list_security_check => 1,\n            -redirect_url           => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=web_services'\n              . '&list='\n              . $list,\n        );\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'web_services.tmpl',\n            -with           => 'admin',\n            -expr           => 1,\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                root_login => $root_login,\n\t\t\t\t\n                keys_reset => $keys_reset,\n\t\t\t\tGLOBAL_API_OPTIONS_enabled => $DADA::Config::GLOBAL_API_OPTIONS->{enabled}, \n\t\t\t\tGLOBAL_API_OPTIONS_public_key => $DADA::Config::GLOBAL_API_OPTIONS->{public_key}, \n\t\t\t\tGLOBAL_API_OPTIONS_private_key => $DADA::Config::GLOBAL_API_OPTIONS->{private_key}, \n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub mail_sending_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $ses_params = {};\n    if (\n        $ls->param('sending_method') eq 'amazon_ses'\n        || (   $ls->param('sending_method') eq 'smtp'\n            && $ls->param('smtp_server') =~ m/amazonaws\\.com/ )\n      )\n    {\n        $ses_params->{using_ses} = 1;\n        require DADA::App::AmazonSES;\n        my $ses = DADA::App::AmazonSES->new;\n        $ses_params->{list_owner_ses_verified} =\n          $ses->sender_verified( $ls->param('list_owner_email') );\n        $ses_params->{list_admin_ses_verified} =\n          $ses->sender_verified( $ls->param('admin_email') );\n        $ses_params->{discussion_pop_ses_verified} =\n          $ses->sender_verified( $ls->param('discussion_pop_email') );\n    }\n    if ( !$process ) {\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        require DADA::Security::Password;\n\n        my $decrypted_sasl_pass = '';\n        if ( $ls->param('sasl_smtp_password') ) {\n            $decrypted_sasl_pass =\n              DADA::Security::Password::cipher_decrypt(\n                $ls->param('cipher_key'),\n                $ls->param('sasl_smtp_password') );\n        }\n\n\n# DEV: This is really strange, since if Net::SMTP isn't available, SMTP sending is completely broken.\n        my $can_use_net_smtp = 0;\n        eval { require Net::SMTP };\n        if ( !$@ ) {\n            $can_use_net_smtp = 1;\n        }\n\n        my $mechanism_popup;\n        require HTML::Menu::Select;\n\n        if ($can_use_net_smtp) {\n            $mechanism_popup = HTML::Menu::Select::popup_menu(\n                {\n                    name    => 'sasl_auth_mechanism',\n                    id      => 'sasl_auth_mechanism',\n                    default => $ls->param('sasl_auth_mechanism'),\n                    values  => [qw(AUTO PLAIN LOGIN DIGEST-MD5 CRAM-MD5)],\n                }\n            );\n        }\n\n        my $wrong_uid = 0;\n        $wrong_uid = 1\n          if $< != $>;\n\n        my $no_smtp_server_set = 0;\n        if (  !$ls->param('smtp_server')\n            && $ls->param('sending_method') eq \"smtp\" )\n        {\n            $no_smtp_server_set = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'mail_sending_options_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen             => 'mail_sending_options',\n                    done               => $done,\n                    root_login         => $root_login,\n                    no_smtp_server_set => $no_smtp_server_set,\n                    mechanism_popup    => $mechanism_popup,\n                    can_use_IO_Socket_SSL => DADA::App::Guts::can_use_IO_Socket_SSL(),\n                    wrong_uid            => $wrong_uid,\n                    f_flag_settings      => $DADA::Config::MAIL_SETTINGS . ' -f'\n                      . $ls->param('admin_email'),\n\n                    use_sasl_smtp_auth => scalar $q->param('use_sasl_smtp_auth')\n                    ? scalar $q->param('use_sasl_smtp_auth')\n                    : $ls->param('use_sasl_smtp_auth'),\n\n                    sasl_auth_mechanism =>\n                      scalar $q->param('sasl_auth_mechanism')\n                    ? scalar $q->param('sasl_auth_mechanism')\n                    : $ls->param('sasl_auth_mechanism'),\n                    sasl_smtp_username => scalar $q->param('sasl_smtp_username')\n                    ? scalar $q->param('sasl_smtp_username')\n                    : $ls->param('sasl_smtp_username'),\n                    sasl_smtp_password => scalar $q->param('sasl_smtp_password')\n                    ? scalar $q->param('sasl_smtp_password')\n                    : $decrypted_sasl_pass,\n\n                    amazon_ses_requirements_widget =>\n                      DADA::Template::Widgets::amazon_ses_requirements_widget(),\n                    %$ses_params,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n\t\t\t\t\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    sending_method       => undef,\n                    add_sendmail_f_flag  => 0,\n                    set_smtp_sender      => 0,\n                    smtp_server          => undef,\n\n                    use_smtp_ssl         => 0,\n                    sasl_auth_mechanism  => undef,\n                    use_sasl_smtp_auth   => 0,\n\t\t\t\t\t\n\t\t\t\t\tsmtp_starttls        => 0, \n                    smtp_ssl_verify_mode => 0, \n\t\t\t\t\tsasl_smtp_username   => undef,\n                    sasl_smtp_password   => undef,\n                    smtp_port            => undef,\n                },\n                -also_save_for => $also_save_for_list,\n            }, \n        );\n        if ( $q->param('no_redirect') == 1 ) {\n            return undef;    # I mean, I guess...\n        }\n        else {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=mail_sending_options&done=1' );\n\n        }\n    }\n}\n\nsub mailing_sending_mass_mailing_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n    my $done    = $q->param('done');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mailing_sending_mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        require DADA::Mail::MailOut;\n        my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n        my ( $batch_sending_enabled, $batch_size, $batch_wait ) =\n          $mo->batch_params();\n\n        my $show_amazon_ses_options = 0;\n        my $type_of_service         = 'ses';\n        my $can_use_Amazon_SES      = scalar DADA::App::Guts::can_use_Amazon_SES();\n\t\t\n\t\tif ($can_use_Amazon_SES == 1) { \n\t\t\t\n\t\t\trequire DADA::App::AmazonSES;\n\t\t\tmy $ses = DADA::App::AmazonSES->new;\n\n\t\t\tif(\n\t\t\t\t(\n\t\t\t\t\t$ls->param('sending_method') eq 'amazon_ses'\n\t\t\t\t)\n\t\t\t||\n\t\t\t\t(\n\t\t\t\t\t$ls->param('sending_method') eq 'smtp'\n\t\t\t\t\t&& $ls->param('smtp_server') =~ m/amazonaws\\.com/\n\t\t\t\t\t&& $ses->has_ses_options_set == 1\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t$show_amazon_ses_options = 1;\n\t\t\t}\n\t\t}\n\t\t\n        my @message_amount = ( 1 .. 180 );\n        unshift( @message_amount, $batch_size );\n\n        my @message_wait = (\n            1 .. 60, 70,  80,  90,  100, 110, 110, 120,\n            130,     140, 150, 160, 170, 180\n        );\n\n        unshift( @message_wait, $batch_wait );\n        my @message_label = (1);\n        my %label_label = ( 1 => 'second(s)', );\n\n        require HTML::Menu::Select;\n        my $mass_send_amount_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => \"mass_send_amount\",\n                id    => \"mass_send_amount\",\n                value => [@message_amount],\n                class => 'previewBatchSendingSpeed',\n            }\n        );\n\n        my $bulk_sleep_amount_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => \"bulk_sleep_amount\",\n                id    => \"bulk_sleep_amount\",\n                value => [@message_wait],\n                class => 'previewBatchSendingSpeed',\n            }\n        );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'mailing_sending_mass_mailing_options_screen.tmpl',\n                -with   => 'admin',\n                -expr   => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen     => 'mailing_sending_mass_mailing_options',\n                    done       => $done,\n                    root_login => $root_login,\n                    batch_sending_enabled   => $batch_sending_enabled,\n                    mass_send_amount_menu   => $mass_send_amount_menu,\n                    bulk_sleep_amount_menu  => $bulk_sleep_amount_menu,\n                    batch_size              => $batch_size,\n                    batch_wait              => $batch_wait,\n                    show_amazon_ses_options => $show_amazon_ses_options,\n                    type_of_service         => $type_of_service,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    mass_send_amount                => undef,\n                    bulk_sleep_amount               => undef,\n                    enable_bulk_batching            => 0,\n                    adjust_batch_sleep_time         => 0,\n                    get_finished_notification       => 0,\n                    auto_pickup_dropped_mailings    => 0,\n                    smtp_connection_per_batch       => 0,\n                    mass_mailing_send_to_list_owner => 0,\n                    amazon_ses_auto_batch_settings  => 0,\n                    mass_mailing_save_logs          => 0,\n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=mailing_sending_mass_mailing_options&done=1' );\n    }\n}\n\nsub amazon_ses_verify_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $valid_email = 1;\n    my $status      = undef;\n    my $result      = undef;\n    my $amazon_ses_verify_email =\n      xss_filter( strip( scalar $q->param('amazon_ses_verify_email') ) );\n    if ( check_for_valid_email($amazon_ses_verify_email) == 1 ) {\n        $valid_email = 0;\n    }\n    else {\n        require DADA::App::AmazonSES;\n        my $ses = DADA::App::AmazonSES->new;\n        ( $status, $result ) =\n          $ses->verify_sender( { -email => $amazon_ses_verify_email } );\n    }\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'amazon_ses_verify_email_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                amazon_ses_verify_email => $amazon_ses_verify_email,\n                valid_email             => $valid_email,\n                status                  => $status,\n                result                  => $result,\n            }\n        }\n    );\n    return $body;\n}\n\nsub amazon_ses_get_stats {\n\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    require DADA::App::AmazonSES;\n    my $ses = DADA::App::AmazonSES->new;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mailing_sending_mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if (\n        (\n\t\t\t$ls->param('sending_method') eq 'amazon_ses'\n\t\t)\n\t||\n\t\t(   \n\t\t\t$ls->param('sending_method') eq 'smtp'\n            && $ls->param('smtp_server') =~ m/amazonaws\\.com/\n        \t&& $ses->has_ses_options_set == 1\n      \t  )\n\t){\t\n        my $status                           = undef;\n        my $SentLast24Hours                  = undef;\n        my $Max24HourSend                    = undef;\n        my $MaxSendRate                      = undef;\n        my $allowed_sending_quota_percentage = undef;\n\n        my $using_ses = 0;\n        my $using_man = 0;\n\n        if (\n            (\n\t\t\t\t$ls->param('sending_method') eq 'amazon_ses'\n\t\t\t)\n\t\t||\n\t\t\t(   \n\t\t\t\t$ls->param('sending_method') eq 'smtp'\n                && $ls->param('smtp_server') =~ m/amazonaws\\.com/\n            \t&& $ses->has_ses_options_set == 1\n          \t  )\n\t\t){\t\n\t\t\t( $status, $SentLast24Hours, $Max24HourSend, $MaxSendRate ) = $ses->get_stats;\n\t\t\t$allowed_sending_quota_percentage = $ses->allowed_sending_quota_percentage;\n\t\t\t$using_ses = 1;\n        }\n\n        my $body = DADA::Template::Widgets::screen(\n            {\n                -screen => 'amazon_ses_get_stats_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    status          => $status,\n                    has_ses_options => $ses->has_ses_options_set,\n                    MaxSendRate     => commify($MaxSendRate),\n                    Max24HourSend   => commify($Max24HourSend),\n                    SentLast24Hours => commify($SentLast24Hours),\n                    allowed_sending_quota_percentage =>$allowed_sending_quota_percentage,\n                    using_ses => $using_ses,\n                    using_man => $using_man,\n                }\n            }\n        );\n        return $body;\n    }\n    else {\n        return undef;\n    }\n\n}\n\nsub previewBatchSendingSpeed {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mailing_sending_mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $enable_bulk_batching =\n      xss_filter( scalar $q->param('enable_bulk_batching') );\n    my $mass_send_amount  = xss_filter( scalar $q->param('mass_send_amount') );\n    my $bulk_sleep_amount = xss_filter( scalar $q->param('bulk_sleep_amount') );\n    my $amazon_ses_auto_batch_settings = xss_filter( scalar $q->param('amazon_ses_auto_batch_settings') );\n\n    my $per_hour         = 0;\n\tmy $per_hour_thirded;\n    my $num_subs         = 0;\n    my $time_to_send     = 0;\n\tmy $time_to_send_thirded; \n    my $somethings_wrong = 0;\n\n    if ( $enable_bulk_batching == 1 ) {\n\n        if ( $amazon_ses_auto_batch_settings == 1 ) {\n            require DADA::Mail::MailOut;\n            my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n            my $enabled;\n            ( $enabled, $mass_send_amount, $bulk_sleep_amount ) =\n              $mo->batch_params( { -amazon_ses_auto_batch_settings => 1 } );\n        }\n\n        if ( $bulk_sleep_amount > 0 && $mass_send_amount > 0 ) {\n\n\t\t\tmy $per_sec; \n\t\t\n\t\t\t\n\t\t\tif ( $amazon_ses_auto_batch_settings == 1 ) {\n\t\t\t\t# This adds a second to each message sent, less the time spend sleeping\n\t\t\t\t# This is to take into consideration how long a message actually takes to send\n\t\t\t\t# to the service. \n\t\t\t\t$per_sec = ($mass_send_amount / $bulk_sleep_amount) - ($mass_send_amount - $bulk_sleep_amount);\n            }\n\t\t\telse { \n\t\t\t\t$per_sec = ($mass_send_amount / $bulk_sleep_amount);\n\t\t\t}\n\t\t\t$per_hour =\n              int( $per_sec * 60 * 60 + .5 )\n              ; # DEV .5 is some sort of rounding thing (with int). That's wrong.\n\n            $num_subs = $lh->num_subscribers;\n            my $total_hours = 0;\n            if ( $num_subs > 0 && $per_hour > 0 ) {\n                $total_hours = $lh->num_subscribers / $per_hour;\n            }\n\n\t\t\t$per_hour_thirded = int(($per_hour * 3) + .5); \n\t\t\t$per_hour_thirded  = commify($per_hour_thirded);\n            $per_hour = commify($per_hour);\n            $num_subs = commify($num_subs);\n\n            $time_to_send = formatted_runtime( $total_hours * 60 * 60 );\n\t\t\t\n\t\t\tif ( $amazon_ses_auto_batch_settings == 1 ) {\n\t\t\t\n\t\t\t\t$time_to_send_thirded = formatted_runtime( ($total_hours/3) * 60 * 60 );\n\t\t\t}\n\t\t\t\n\n        }\n        else {\n            $somethings_wrong = 1;\n        }\n    }\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'previewBatchSendingSpeed_widget.tmpl',\n            -vars   => {\n\t\t\t\tamazon_ses_auto_batch_settings => $amazon_ses_auto_batch_settings, \n                enable_bulk_batching           => $enable_bulk_batching,\n                per_hour                       => $per_hour,\n\t\t\t\tper_hour_thirded               => $per_hour_thirded, \n                num_subscribers                => $num_subs,\n                time_to_send                   => $time_to_send,\n\t\t\t\ttime_to_send_thirded           => $time_to_send_thirded, \n                somethings_wrong               => $somethings_wrong,\n            }\n        }\n    );\n    return $body;\n\n}\n\nsub mail_sending_advanced_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n    my $done    = $q->param('done');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_advanced_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::Security::Password;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        require HTML::Menu::Select;\n        unshift( @DADA::Config::CHARSETS, $ls->param('charset') );\n        my $precedence_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => \"precedence\",\n                id      => \"precedence\",\n                value   => [@DADA::Config::PRECEDENCES],\n                default => $ls->param('precedence'),\n            }\n        );\n\n        my $priority_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => \"priority\",\n                id      => \"priority\",\n                value   => [ keys %DADA::Config::PRIORITIES ],\n                labels  => \\%DADA::Config::PRIORITIES,\n                default => $ls->param('priority'),\n            }\n        );\n\n        my $charset_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => 'charset',\n                id    => 'charset',\n                value => [@DADA::Config::CHARSETS],\n            }\n        );\n\n        my $plaintext_encoding_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'plaintext_encoding',\n                id      => 'plaintext_encoding',\n                value   => [@DADA::Config::CONTENT_TRANSFER_ENCODINGS],\n                default => $ls->param('plaintext_encoding'),\n            }\n        );\n\n        my $html_encoding_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'html_encoding',\n                id      => 'html_encoding',\n                value   => [@DADA::Config::CONTENT_TRANSFER_ENCODINGS],\n                default => $ls->param('html_encoding'),\n            }\n        );\n\n        my $can_mime_encode = 1;\n        eval { require MIME::EncWords; };\n        if ($@) {\n            $can_mime_encode = 0;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'mail_sending_advanced_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen                => 'mail_sending_advanced_options',\n                    title                 => 'Advanced Options',\n                    done                  => $done,\n                    root_login            => $root_login,\n                    precedence_popup_menu => $precedence_popup_menu,\n                    priority_popup_menu   => $priority_popup_menu,\n                    charset_popup_menu    => $charset_popup_menu,\n                    plaintext_encoding_popup_menu =>\n                      $plaintext_encoding_popup_menu,\n                    html_encoding_popup_menu => $html_encoding_popup_menu,\n                    can_mime_encode          => $can_mime_encode,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    precedence                   => undef,\n                    priority                     => undef,\n                    charset                      => undef,\n                    plaintext_encoding           => undef,\n                    html_encoding                => undef,\n                    verp_return_path             => 0,\n                }\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=mail_sending_advanced_options&done=1' );\n\n    }\n}\n\nsub mail_sending_options_test {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    $q->param( 'no_redirect', 1 );\n\n    # Saves the params passed\n    $self->mail_sending_options();\n\n    require DADA::Mail::Send;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $admin_list } );\n\n    my $mh = DADA::Mail::Send->new(\n        {\n            -list   => $list,\n            -ls_obj => $ls,\n        }\n    );\n\n    my ( $results, $lines, $report );\n    eval { ( $results, $lines, $report ) = $mh->mail_sending_options_test; };\n    if ($@) {\n        $results .= $@;\n    }\n\n    $results =~ s/\\</&lt;/g;\n    $results =~ s/\\>/&gt;/g;\n\n    my $ht_report = [];\n\n    for my $f (@$report) {\n\n        my $s_f = $f->{line};\n        $s_f =~ s{Net\\:\\:SMTP(.*?)\\)}{};\n        push( @$ht_report, { SMTP_command => $s_f, message => $f->{message} } );\n    }\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'mail_sending_options_test_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                report  => $ht_report,\n                raw_log => $results,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $body;\n\n}\n\nsub view_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $add_email_count =\n      xss_filter( scalar $q->param('add_email_count') ) || 0;\n    my $update_email_count =\n      xss_filter( scalar $q->param('update_email_count') ) || 0;\n    my $skipped_email_count =\n      xss_filter( scalar $q->param('skipped_email_count') )\n      || 0;\n    my $delete_email_count =\n      xss_filter( scalar $q->param('delete_email_count') ) || 0;\n    my $black_list_add = xss_filter( scalar $q->param('black_list_add') ) || 0;\n    my $approved_count = xss_filter( scalar $q->param('approved_count') ) || 0;\n    my $denied_count   = xss_filter( scalar $q->param('denied_count') )   || 0;\n    my $bounced_list_moved_to_list_count =\n      xss_filter( scalar $q->param('bounced_list_moved_to_list_count') ) || 0;\n    my $bounced_list_removed_from_list =\n      xss_filter( scalar $q->param('bounced_list_removed_from_list') ) || 0;\n    my $updated_addresses =\n      xss_filter( scalar $q->param('updated_addresses') ) || 0;\n    my $type  = xss_filter( scalar $q->param('type') )  || 'list';\n    my $query = xss_filter( scalar $q->param('query') ) || undef;\n\n    my $order_by = $q->param('order_by') || $ls->param('view_list_order_by');\n    my $order_dir = $q->param('order_dir')\n      || lc( $ls->param('view_list_order_by_direction') );\n\n    my $mode            = xss_filter( scalar $q->param('mode') ) || 'view';\n    my $page            = xss_filter( scalar $q->param('page') ) || 1;\n    my $advanced_search = $q->param('advanced_search')           || 0;\n    my $advanced_query  = $q->param('advanced_query')            || undef;\n\n    if ( $mode ne 'viewport' ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -list           => $list,\n                -screen         => 'view_list_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen          => 'view_list',\n                    flavor          => 'view_list',\n                    root_login      => $root_login,\n                    type            => $type,\n                    page            => $page,\n                    query           => $query,\n                    order_by        => $order_by,\n                    order_dir       => $order_dir,\n                    advanced_search => $advanced_search,\n                    advanced_query  => $advanced_query,\n\n                    add_email_count     => $add_email_count,\n                    update_email_count  => $update_email_count,\n                    skipped_email_count => $skipped_email_count,\n                    delete_email_count  => $delete_email_count,\n                    black_list_add      => $black_list_add,\n                    approved_count      => $approved_count,\n                    denied_count        => $denied_count,\n                    bounced_list_moved_to_list_count =>\n                      $bounced_list_moved_to_list_count,\n                    bounced_list_removed_from_list =>\n                      $bounced_list_removed_from_list,\n                    updated_addresses => $updated_addresses,\n                    type_title        => $DADA::Config::LIST_TYPES->{$type},\n\n                },\n            }\n        );\n\n        return $scrn;\n    }\n    else {\n\n        # DEV: Yup. Forgot what this was for.\n        if ( defined( $q->param('list') ) ) {\n            if ( $list ne $q->param('list') ) {\n\n# I should look instead to see if we're logged in view ROOT and then just\n# *Switch* the login. Brilliant! --- maybe I don't want to switch lists automatically - without\n# someone perhaps knowing that THAT's what I did...\n                my ( $headers, $body ) =\n                  $self->logout(\n                    -redirect_url => $DADA::Config::S_PROGRAM_URL . '?'\n                      . $q->query_string(), );\n\n                if ( keys %$headers ) {\n                    $self->header_props(%$headers);\n                }\n                return $body;\n            }\n        }\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n        my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n        my $num_subscribers = $lh->num_subscribers( { -type => $type } );\n\n        my $show_bounced_list = 0;\n        if (   $lh->num_subscribers( { -type => 'bounced_list' } ) > 0\n            || $ls->param('bounce_handler_when_threshold_reached') eq\n            'move_to_bounced_sublist' )\n        {\n            $show_bounced_list = 1;\n        }\n\n        my $subscribers = [];\n\n        require Data::Pageset;\n        my $page_info    = undef;\n        my $pages_in_set = [];\n        my $total_num    = 0;\n\n        # warn '$query ' . $query;\n        # warn '$advanced_query ' . $advanced_query;\n        # warn ' $advanced_search' . $advanced_search;\n\n        if ( $query || $advanced_query ) {\n\n            if ( $advanced_search == 1 ) {\n                open my $fh, '<', \\$advanced_query || die $!;\n                require CGI;\n                my $new_q = CGI->new($fh);\n                $new_q->charset($DADA::Config::HTML_CHARSET);\n\n                $new_q = decode_cgi_obj($new_q);\n                my $partial_sending = partial_sending_query_to_params($new_q);\n\n                ( $total_num, $subscribers ) = $lh->search_list(\n                    {\n                        -partial_listing => $partial_sending,\n                        -type            => $type,\n                        -start           => ( $page - 1 ),\n                        '-length'  => $ls->param('view_list_subscriber_number'),\n                        -order_by  => $order_by,\n                        -order_dir => $order_dir,\n\n                    }\n                );\n            }\n            else {\n\n                ( $total_num, $subscribers ) = $lh->search_list(\n                    {\n                        -query     => $query,\n                        -type      => $type,\n                        -start     => ( $page - 1 ),\n                        '-length'  => $ls->param('view_list_subscriber_number'),\n                        -order_by  => $order_by,\n                        -order_dir => $order_dir,\n\n                    }\n                );\n            }\n            $page_info = Data::Pageset->new(\n                {\n                    total_entries => $total_num,\n                    entries_per_page =>\n                      $ls->param('view_list_subscriber_number'),\n                    current_page  => $page,\n                    mode          => 'slide',    # default fixed\n                    pages_per_set => 10,\n                }\n            );\n\n        }\n        else {\n            $subscribers = $lh->subscription_list(\n                {\n                    -type  => $type,\n                    -start => ( $page - 1 )\n                    , # this really should be just, $page, but subscription_list() would have to be updated, which will break a lot of things...\n                    '-length'  => $ls->param('view_list_subscriber_number'),\n                    -order_by  => $order_by,\n                    -order_dir => $order_dir,\n\n                    #-show_list_column      => 0,\n                    #-show_timestamp_column => 0,\n                }\n            );\n            $total_num = $num_subscribers;\n            $page_info = Data::Pageset->new(\n                {\n                    total_entries => $num_subscribers,\n                    entries_per_page =>\n                      $ls->param('view_list_subscriber_number'),\n                    current_page  => $page,\n                    mode          => 'slide',    # default fixed\n                    pages_per_set => 10,\n                }\n            );\n\n        }\n\n        foreach my $page_num ( @{ $page_info->pages_in_set() } ) {\n            if ( $page_num == $page_info->current_page() ) {\n                push( @$pages_in_set,\n                    { page => $page_num, on_current_page => 1 } );\n            }\n            else {\n                push( @$pages_in_set,\n                    { page => $page_num, on_current_page => undef } );\n            }\n        }\n\n        require DADA::ProfileFieldsManager;\n        my $pfm         = DADA::ProfileFieldsManager->new;\n        my $fields_attr = $pfm->get_all_field_attributes;\n\n        my $field_names = [];\n        my $undotted_fields = [ { name => 'email', label => 'Email Address' } ];\n        for ( @{ $lh->subscriber_fields } ) {\n            push(\n                @$field_names,\n                {\n                    name          => $_,\n                    label         => $fields_attr->{$_}->{label},\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL\n                },\n            );\n            push(\n                @$undotted_fields,\n                {\n                    name          => $_,\n                    label         => $fields_attr->{$_}->{label},\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL\n                },\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -list   => $list,\n                -screen => 'view_list_viewport_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    can_have_subscriber_fields => 1,\n                    screen                     => 'view_list',\n                    flavor                     => 'view_list',\n                    root_login                 => $root_login,\n\n                    type       => $type,\n                    type_title => $DADA::Config::LIST_TYPES->{$type},\n\n                    first            => $page_info->first,\n                    last             => $page_info->last,\n                    first_page       => $page_info->first_page,\n                    last_page        => $page_info->last_page,\n                    next_page        => $page_info->next_page,\n                    previous_page    => $page_info->previous_page,\n                    page             => $page_info->current_page,\n                    show_list_column => 0,\n                    show_timestamp_column =>\n                      $ls->param('view_list_show_timestamp_col'),\n                    field_names     => $field_names,\n                    undotted_fields => $undotted_fields,\n\n                    pages_in_set        => $pages_in_set,\n                    num_subscribers     => commify($num_subscribers),\n                    total_num           => $total_num,\n                    total_num_commified => commify($total_num),\n                    subscribers         => $subscribers,\n                    query               => $query,\n                    advanced_search     => $advanced_search,\n                    advanced_query      => $advanced_query,\n                    order_by            => $order_by,\n                    order_dir           => $order_dir,\n\n                    show_bounced_list => $show_bounced_list,\n\n                    GLOBAL_BLACK_LIST  => $DADA::Config::GLOBAL_BLACK_LIST,\n                    GLOBAL_UNSUBSCRIBE => $DADA::Config::GLOBAL_UNSUBSCRIBE,\n\n                    can_use_global_black_list => $lh->can_use_global_black_list,\n                    can_use_global_unsubscribe =>\n                      $lh->can_use_global_unsubscribe,\n\n                    can_filter_subscribers_through_blacklist =>\n                      $lh->can_filter_subscribers_through_blacklist,\n\n                    flavor_is_view_list => 1,\n                    list_subscribers_num =>\n                      scalar commify(\n                        $lh->num_subscribers( { -type => 'list' } ) ),\n                    black_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'black_list' } )\n                    ),\n                    white_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'white_list' } )\n                    ),\n                    authorized_senders_num => scalar commify(\n                        $lh->num_subscribers(\n                            { -type => 'authorized_senders' }\n                        )\n                    ),\n                    moderators_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'moderators' } )\n                    ),\n\t\t\t\t\t\n                    requires_moderation_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'requires_moderation' } )\n                    ),\n\t\t\t\t\t\n                    sub_request_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'sub_request_list' } )\n                    ),\n                    unsub_request_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers(\n                            { -type => 'unsub_request_list' }\n                        )\n                    ),\n                    bounced_list_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'bounced_list' } )\n                    ),\n\t\t\t\t\t\n\t\t\t\t\tignore_bounces_list_num => \n\t\t\t\t\t\tscalar commify(\n\t\t\t\t\t\t\t$lh->num_subscribers( { -type => 'ignore_bounces_list' } )\n\t\t\t\t\t), \n\t\t\t\t\t\n                    sub_confirm_list_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'sub_confirm_list' } )\n                    ),\n\t\t\t\t\t\n                    test_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'test_list' } ) \n\t\t\t\t\t),\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub mass_update_profiles {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $ls   = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh   = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $update_fields = {};\n\n    for my $field ( @{ $lh->subscriber_fields() } ) {\n        if ( $q->param( 'update.' . $field ) == 1 ) {\n            $update_fields->{$field} = $q->param($field);\n        }\n    }\n\n    my $advanced_query =\n      xss_filter( scalar $q->param('advanced_query') ) || undef;\n    open my $fh, '<', \\$advanced_query || die $!;\n    require CGI;\n    my $new_q = CGI->new($fh);\n    $new_q->charset($DADA::Config::HTML_CHARSET);\n    $new_q = decode_cgi_obj($new_q);\n    my $partial_listing = partial_sending_query_to_params($new_q);\n\n    my $updated = $lh->update_profiles(\n        {\n\n            -update_fields   => $update_fields,\n            -partial_listing => $partial_listing,\n\n        }\n    );\n\n    # And then, we're return with a search query, to show the results:\n    $q->param( 'updated_addresses', $updated );\n    $q->param( 'advanced_search',   1 );\n    $q->param( 'done',              1 );\n\n    undef($new_q);\n    require CGI;\n    $new_q = CGI->new;\n    $new_q->charset($DADA::Config::HTML_CHARSET);\n    $new_q->delete_all;\n\n    #    $new_q->param('favorite_color.operator', '=');\n    #    $new_q->param('favorite_color.value', 'mauve');\n\n    for my $field (%$update_fields) {\n        $new_q->param( $field . '.operator', '=' );\n        $new_q->param( $field . '.value',    $update_fields->{$field} );\n    }\n\n    my $new_advanced_search_query = $new_q->query_string();\n    $new_advanced_search_query =~ s/\\;/\\&/g;\n\n    $q->param( 'advanced_query', $new_advanced_search_query );\n\n    return $self->view_list();\n}\n\nsub domain_breakdown_json {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $type = $q->param('type') || 'list';\n\n    require DADA::MailingList::Subscribers;\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $headers = {\n        '-Cache-Control' => 'no-cache, must-revalidate',\n        -expires         => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        -type            => 'application/json',\n    };\n    my $body = $lh->domain_stats_json(\n        {\n            -type     => $type,\n            -count    => 15,\n            -printout => 0,\n        }\n    );\n\n    if ( keys %$headers ) {\n        $self->header_props(%$headers);\n    }\n    return $body;\n}\n\nsub search_list_auto_complete {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $query = xss_filter( scalar $q->param('query') ) || undef;\n    my $type  = xss_filter( scalar $q->param('type') )  || 'list';\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my ( $total_num, $subscribers ) = $lh->search_list(\n        {\n            -query    => $query,\n            -type     => $type,\n            '-length' => 10,\n        }\n    );\n\n    my $r = [];\n    for my $result (@$subscribers) {\n        push( @$r, { 'email' => $result->{email} } );\n    }\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    $self->header_props( -type => 'application/json' );\n    return $json->encode($r);\n\n}\n\nsub list_activity {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'list_activity'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\t\n    my $body = DADA::Template::Widgets::wrap_screen(\n        {\n            -list           => $list,\n            -screen         => 'list_activity_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -expr => 1,\n        }\n    );\n    return $body;\n\n}\n\nsub sub_unsub_trends_json {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'list_activity'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $days = xss_filter(\n\t\tstrip(\n\t\t\tscalar $q->param('days')\n\t\t)\n\t);\n\n   # require DADA::App::LogSearch;\n   # my $dals = DADA::App::LogSearch->new;\n\n    my $headers = {\n        '-Cache-Control' => 'no-cache, must-revalidate',\n        -expires         => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        -type            => 'application/json',\n    };\n\t\n\tmy $dmlch = DADA::MailingList::ConsentActivity->new; \n\tmy $r = $dmlch->sub_unsub_trends_json(\n        {\n            -list     => $list,\n            -printout => 0,\n            -days     => $days,\n        }\n    );\n\n    $self->header_props(%$headers);\n    return $r;\n}\n\nsub recent_subscription_activity { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n\t\n    my $days = xss_filter(\n\t\tstrip(\n\t\t\tscalar $q->param('days')\n\t\t)\n\t) || 30; \n\t\n\trequire DADA::MailingList::ConsentActivity; \n\tmy $dmlch = DADA::MailingList::ConsentActivity->new; \n\tmy $r = $dmlch->list_activity( \n\t\t{ \n\t\t\t-list => $list, \n\t\t\t-days => $days, \n\t\t} \n\t);\n\t\n\tmy $i;\n    for ( $i = 0 ; $i <= ( scalar(@$r) - 1 ) ; $i++ ) {\n        $r->[$i]->{show_email} = 1;\n    }\n\t\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -list   => $list,\n            -screen => 'filtered_list_activity_widget.tmpl',\n            -vars => { \n\t\t\t\thistory => $r, \n\t\t\t},\n            -expr => 1,\n        }\n    );\n    return $body;\n\n}\n\nsub view_bounce_history {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $return_to      = $q->param('return_to') || 'view_list';\n    my $return_address = $q->param('return_address') || undef;\n\n    require DADA::App::BounceHandler::Logs;\n    my $bhl     = DADA::App::BounceHandler::Logs->new;\n    my $results = $bhl->search(\n        {\n            -query => scalar $q->param('email'),\n            -list  => $list,\n            -file  => $DADA::Config::LOGS . '/bounces.txt',\n        }\n    );\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'bounce_search_results_modal_menu.tmpl',\n            -vars   => {\n                search_results => $results,\n                total_bounces  => scalar(@$results),\n                email          => scalar $q->param('email'),\n                type           => 'bounced_list',\n                return_to      => $return_to,\n                return_address => $return_address,\n            }\n        }\n    );\n    return $body;\n}\n\nsub subscription_requests {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    #?\n    if ( defined( $q->param('list') ) ) {\n        if ( $list ne $q->param('list') ) {\n            my ( $headers, $body ) =\n              $self->logout( -redirect_url => $DADA::Config::S_PROGRAM_URL . '?'\n                  . $q->query_string(), );\n            if ( keys %$headers ) {\n                $self->header_props(%$headers);\n            }\n            return $body;\n        }\n    }\n\n    my @address        = $q->multi_param('address');\n    my $return_to      = $q->param('return_to') || '';\n    my $return_address = $q->param('return_address') || '';\n\n    my $count = 0;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( $q->param('process') =~ m/approve/i ) {\n\n        for my $email (@address) {\n            $lh->move_subscriber(\n                {\n                    -email     => $email,\n                    -from      => 'sub_request_list',\n                    -to        => 'list',\n                    -mode      => 'writeover',\n                    -confirmed => 1,\n                }\n            );\n\t\t\t# The address shouldn't be on this list, but I guess it doesn't hurt to remove it here, too: \n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n\n            my $new_pass    = '';\n            my $new_profile = 0;\n            if (   $DADA::Config::PROFILE_OPTIONS->{enabled} == 1) {\n\n                # Make a profile, if needed,\n                require DADA::Profile;\n                my $prof =\n                  DADA::Profile->new( { -email => $email } );\n                if ( !$prof->exists ) {\n                    $new_profile = 1;\n                    $new_pass    = $prof->_rand_str(8);\n                    $prof->insert(\n                        {\n                            -password  => $new_pass,\n                            -activated => 1,\n                        }\n                    );\n                }\n\n                # / Make a profile, if needed,\n            }\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n            $dap->send_subscribed_message(\n                {\n                    -email => $email,\n                    -vars  => {\n                        new_profile        => $new_profile,\n                        'profile.email'    => $email,\n                        'profile.password' => $new_pass,\n                    }\n                }\n            );\n            $count++;\n        }\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&approved_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n    }\n    elsif ( $q->param('process') =~ m/deny/i ) {\n        for my $email (@address) {\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_request_list',\n                }\n            );\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n            $dap->send_subscription_request_denied_message(\n                {\n                    -email => $email,\n                }\n            );\n            $count++;\n        }\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&denied_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n\n    }\n    else {\n        die \"unknown process!\";\n    }\n\n}\n\nsub unsubscription_requests {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n#    #?\n#    if ( defined( $q->param('list') ) ) {\n#        if ( $list ne $q->param('list') ) {\n#            my ( $headers, $body ) =\n#              $self->logout( -redirect_url => $DADA::Config::S_PROGRAM_URL . '?' . $q->query_string(), );\n#            if ( keys %$headers ) {\n#                $self->header_props(%$headers);\n#            }\n#            return $body;\n#        }\n#    }\n\n    my @address        = $q->multi_param('address');\n    my $return_to      = $q->param('return_to') || '';\n    my $return_address = $q->param('return_address') || '';\n\n    my $count = 0;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( $q->param('process') =~ m/approve/i ) {\n\n        # go!\n        my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n            {\n                -addresses        => [@address],\n                -type             => 'list',\n                -validation_check => 0,\n            }\n        );\n\n        for my $email (@address) {\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_request_list',\n                }\n            );\n\t\t\t\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n\t\t\t\n\t\t\t\n\t\t\tif($ls->param('send_unsubscribed_by_list_owner_message') == 1){\n\t\t\t\t\n\t\t\t\t# warn 'sending send_unsubscribed_message'; \n\t\t\t\t$dap->send_unsubscribed_message(\n\t                {\n\t                    -email  => $email,\n\t                }\n\t            );\n\t\t\t}\n\t\t\telse { \n\t\t\t\t#warn 'SKIPPING sending send_unsubscribed_by_list_owner_message'; \n\t\t\t}\n        }\n\n        $count = int($count) + int($d_count);\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&approved_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n    }\n    elsif ( $q->param('process') =~ m/deny/i ) {\n        for my $email (@address) {\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_request_list',\n                }\n            );\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n            $dap->send_unsubscription_request_denied_message(\n                {\n                    -email => $email,\n                }\n            );\n            $count++;\n        }\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&denied_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n\n    }\n    else {\n        die \"unknown process!\";\n    }\n\n}\n\nsub remove_all_subscribers {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    # This needs that email notification as well...\n    # I need to first, clone the list and then do my thing.\n    # Cloning will be really be resource intensive, so we can't do\n    # checks on each address,\n    # maybe the only check we'll do is to see if anything currently exists.\n    # If there is? Don't do the clone.\n    # If there isn't Do the clone\n    # maybe have a parameter saying what to do on an error.\n    # or just return undef.\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $black_list_add = 0;\n\n    my $type = xss_filter( scalar $q->param('type') );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::App::MassSend;\n    if ( $type eq 'list' ) {\n        if ( $ls->param('send_unsubscribed_by_list_owner_message') == 1 ) {\n            require DADA::App::MassSend;\n            eval {\n                my $dam = DADA::App::MassSend->new( { -list => $list } );\n                $dam->just_unsubscribed_mass_mailing(\n                    {\n                        -send_to_everybody => 1,\n                    }\n                );\n            };\n            if ($@) {\n                carp $@;\n            }\n        }\n\n        if (   $ls->param('black_list') == 1\n            && $ls->param('add_unsubs_to_black_list') == 1 )\n        {\n            $black_list_add = $lh->copy_all_subscribers(\n                {\n                    -from => 'list',\n                    -to   => 'black_list',\n                }\n            );\n        }\n\n    }\n\n    my $count = $lh->remove_all_subscribers( { -type => $type, } );\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor=view_list&delete_email_count='\n          . $count\n          . '&type='\n          . $type\n          . '&black_list_add='\n          . $black_list_add );\n\n}\n\nsub filter_using_black_list {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'filter_using_black_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    if ( !$process ) {\n\n        my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        my $filtered = $lh->filter_list_through_blacklist;\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -list           => $list,\n                -screen         => 'filter_using_black_list.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => { filtered => $filtered, },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub membership {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( !defined( $q->param('email') ) ) {\n        $self->view_list();\n    }\n    my $type = $q->param('type') || 'list';\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $process = $q->param('process')                    || undef;\n    my $done    = $q->param('done')                       || undef;\n    my $query   = xss_filter( scalar $q->param('query') ) || undef;\n    my $page    = xss_filter( scalar $q->param('page') )  || 1;\n    my $type    = xss_filter( scalar $q->param('type') );\n\n    my $order_by = $q->param('order_by') || $ls->param('view_list_order_by');\n    my $order_dir = $q->param('order_dir')\n      || lc( $ls->param('view_list_order_by_direction') );\n\n    my $add_email_count    = $q->param('add_email_count')    || 0;\n    my $delete_email_count = $q->param('delete_email_count') || 0;\n    my $black_list_add     = $q->param('black_list_add')     || 0;\n    my $approved_count     = $q->param('approved_count')     || 0;\n    my $denied_count       = $q->param('denied_count')       || 0;\n    my $bounced_list_moved_to_list_count =\n      $q->param('bounced_list_moved_to_list_count') || 0;\n    my $bounced_list_removed_from_list =\n      $q->param('bounced_list_removed_from_list') || 0;\n    my $update_email_count = $q->param('update_email_count') || 0;\n    my $profile_exists = 0;\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -email => scalar $q->param('email') } );\n\n    if ($prof) {\n        $profile_exists = $prof->exists;\n    }\n    if ($process) {\n        if ( $root_login != 1 && $ls->param('allow_profile_editing') != 1 ) {\n            die\n\"You must be logged in with the Dada Mail Root Password to be able to edit a Subscriber's Profile Fields.\";\n        }\n        my $new_fields = {};\n        for my $nfield ( @{ $lh->subscriber_fields() } ) {\n            if ( defined( $q->param($nfield) ) ) {\n                $new_fields->{$nfield} = $q->param($nfield);\n            }\n        }\n\n        my $fields = DADA::Profile::Fields->new;\n        $fields->insert(\n            {\n                -email  => scalar $q->param('email'),\n                -fields => $new_fields,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=membership&email='\n              . scalar( $q->param('email') )\n              . '&type='\n              . $type\n              . '&done=1' );\n    }\n    else {\n\n        my $fields = [];\n\n        my $subscriber_info = {};\n\n# this is a hack - if type has nothing, this fails, so we fill it in with, \"list\"\n        if ( !defined($type) || $type eq '' ) { $type = 'list'; }\n        $subscriber_info =\n          $lh->get_subscriber( { -email => scalar $q->param('email') } );\n\n        # DEV: This is repeated quite a bit...\n        require DADA::ProfileFieldsManager;\n        my $pfm         = DADA::ProfileFieldsManager->new;\n        my $fields_attr = $pfm->get_all_field_attributes;\n        for my $field ( @{ $lh->subscriber_fields() } ) {\n            push(\n                @$fields,\n                {\n                    name     => $field,\n                    value    => $subscriber_info->{$field},\n                    label    => $fields_attr->{$field}->{label},\n                    required => $fields_attr->{$field}->{required},\n                }\n            );\n        }\n\n        my $subscribed_to_lt = {};\n        for ( @{ $lh->member_of( { -email => scalar $q->param('email') } ) } ) {\n            $subscribed_to_lt->{$_} = 1;\n        }\n\n        my %add_list_types = %{ DADA::App::Guts::list_types() };\n\n        my $add_to = {\n            list                => 1,\n\t\t\ttest_list           => 1,\n            black_list          => 1,\n            white_list          => 1,\n            authorized_senders  => 1,\n            moderators          => 1,\n\t\t\tignore_bounces_list => 1, \n        };\n\n        # Except when, it's already a part of that sublist:\n        for ( keys %$subscribed_to_lt ) {\n            delete( $add_to->{$_} );    # if $subscribed_to_lt->{$_} == 1;\n        }\n\n        # Or if it's blacklisted... can't add!\n        if ( $ls->param('closed_list') == 1 ) {\n            delete( $add_to->{list} );\n        }\n        if (   $ls->param('black_list') == 1\n            && $ls->param('allow_admin_to_subscribe_blacklisted') != 1\n            && $subscribed_to_lt->{black_list} == 1 )\n        {\n            delete( $add_to->{list} );\n        }\n        if (   $ls->param('enable_subscription_approval_step')\n            && $subscribed_to_lt->{sub_request_list} )\n        {\n            delete( $add_to->{list} );\n        }\n\n        # if Authorized Senders isn't active, well, let's not allow to be added:\n        if ( $ls->param('enable_authorized_sending') == 1 ) {\n\n            #...\n        }\n        else {\n            delete( $add_to->{authorized_senders} );\n        }\n\n        # if Moderators isn't active, well, let's not allow to be added:\n        if ( $ls->param('enable_moderation') == 1 ) {\n\n            #...\n        }\n        else {\n            delete( $add_to->{moderators} );\n        }\n\n        # Same with the white list\n        if ( $ls->param('enable_white_list') == 1 ) {\n\n            #...\n        }\n        else {\n            delete( $add_to->{white_list} );\n\n        }\n\n\t\t# guess add a thingy where we do not allow adds to this unless the bounce handler is running.. \n\t\t# and the option to use this guy is enabled. ignore_bounces_list\n\n        my $is_bouncing_address = 0;\n        my $bouncing_info       = '';\n        if ( $subscribed_to_lt->{bounced_list} == 1 ) {\n            $is_bouncing_address = 1;\n\n        }\n\n        require HTML::Menu::Select;\n        my $add_to_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'type',\n                id      => 'type_add',\n                default => 'list',\n                values  => [ keys %$add_to ],\n                labels  => \\%add_list_types,\n            }\n        );\n\n        # Only if black list is enabled and they're not currently subscribed.\n        if ( $ls->param('black_list') == 1 && $subscribed_to_lt->{list} != 1 ) {\n\n            # ...\n        }\n        else {\n            delete( $add_to->{black_list} );\n        }\n\n        my $member_of   = [];\n        my $remove_from = [];\n        my $list_types  = DADA::App::Guts::list_types();\n\n        foreach (%$subscribed_to_lt) {\n            if ( $_ =~\nm/^(list|test_list|black_list|white_list|authorized_senders|moderators|requires_moderation|bounced_list|ignore_bounces_list|sub_confirm_list)$/\n              )\n            {\n                push( @$member_of,\n                    { type => $_, type_title => $list_types->{$_} } );\n                push( @$remove_from, $_ );\n            }\n        }\n\n        require HTML::Menu::Select;\n        my $remove_from_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name   => 'type_remove',\n                id     => 'type_remove',\n                values => $remove_from,\n                labels => $list_types,\n            }\n        );\n\n        my @update_option_values = ( ':all', ( keys %$subscribed_to_lt ) );\n        my %update_option_labels = ( ':all' => 'All Sublists', $list_types );\n        my $update_address_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name   => 'type_update',\n                id     => 'type_update',\n                values => [@update_option_values],\n                labels => {%update_option_labels},\n            }\n        );\n\n        my $subscribed_to_list = 0;\n        if ( $subscribed_to_lt->{list} == 1 ) {\n            $subscribed_to_list = 1;\n\n        }\n\n        my $subscribed_to_sub_request_list = 0;\n        if ( $subscribed_to_lt->{sub_request_list} == 1 ) {\n            $subscribed_to_sub_request_list = 1;\n        }\n\n        my $subscribed_to_sub_confirm_list = 0;\n        if ( $subscribed_to_lt->{sub_confirm_list} == 1 ) {\n            $subscribed_to_sub_confirm_list = 1;\n        }\n\n        require DADA::Profile::Settings;\n        my $dps = DADA::Profile::Settings->new({-list => $list});\n        my $s   = $dps->fetch(\n            {\n                -email => scalar $q->param('email'),\n            }\n        );\n        my $delivery_prefs = $s->{delivery_prefs} || 'individual';\n        my $digest_timeframe =\n          formatted_runtime( $ls->param('digest_schedule') );\t\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'membership_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    done              => $done,\n                    email             => scalar $q->param('email'),\n                    type              => $type,\n                    page              => $page,\n                    query             => $query,\n                    order_by          => $order_by,\n                    order_dir         => $order_dir,\n                    type_title        => $DADA::Config::LIST_TYPES->{$type},\n                    fields            => $fields,\n                    root_login        => $root_login,\n                    profile_exists    => $profile_exists,\n                    add_to_popup_menu => $add_to_popup_menu,\n                    update_address_popup_menu => $update_address_popup_menu,\n                    remove_from_popup_menu    => $remove_from_popup_menu,\n                    remove_from_num           => scalar(@$remove_from),\n                    member_of                 => $member_of,\n                    is_bouncing_address       => $is_bouncing_address,\n                    rand_string               => generate_rand_string_md5(),\n                    member_of_num             => scalar(@$remove_from),\n                    add_to_num                => scalar( keys %$add_to ),\n                    subscribed_to_list        => $subscribed_to_list,\n                    subscribed_to_sub_request_list =>\n                      $subscribed_to_sub_request_list,\n                    subscribed_to_sub_confirm_list =>\n                      $subscribed_to_sub_confirm_list,\n\n                    add_email_count    => $add_email_count,\n                    delete_email_count => $delete_email_count,\n                    black_list_add     => $black_list_add,\n                    approved_count     => $approved_count,\n                    denied_count       => $denied_count,\n                    bounced_list_moved_to_list_count =>\n                      $bounced_list_moved_to_list_count,\n                    bounced_list_removed_from_list =>\n                      $bounced_list_removed_from_list,\n\n                    can_have_subscriber_fields =>\n                      $lh->can_have_subscriber_fields,\n\n                    delivery_prefs   => $delivery_prefs,\n                    digest_timeframe => $digest_timeframe,\n\n                    update_email_count => $update_email_count,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub validate_update_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Subscribers;\n    require DADA::MailingList::Subscriber::Validate;\n    require DADA::MailingList::Settings;\n\n    my $list_types = DADA::App::Guts::list_types();\n\n    my %error_title = (\n        invalid_email    => 'Invalid Email Address',\n        subscribed       => 'Already Subscribed',\n        mx_lookup_failed => 'MX Lookup Failed',\n        black_listed     => 'Black Listed',\n        not_white_listed => 'Not on the White List',\n    );\n\n    my $for_all_lists     = $q->param('for_all_lists') || 0;\n    my $lists_to_validate = [];\n    my $email             = cased( xss_filter( scalar $q->param('email') ) );\n    my $updated_email =\n      cased( xss_filter( scalar $q->param('updated_email') ) );\n    my $process = $q->param('process') || 0;\n\n    my $list_lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    # not sure where I'm going with, with, \"can_have_subscriber_fields\"\n    if ( $list_lh->can_have_subscriber_fields ) {\n        if ( $for_all_lists == 1 && $root_login == 1 ) {\n            require DADA::Profile;\n            my $prof = DADA::Profile->new( { -email => $email } );\n            $lists_to_validate = $prof->subscribed_to;\n        }\n        else {\n            push( @$lists_to_validate, $list );\n        }\n    }\n    else {\n        push( @$lists_to_validate, $list );\n    }\n\n    # old address\n\n    if ( $process != 1 ) {\n\n        my $list_validations = [];\n        my $none_validated   = 1;\n\n        for my $to_validate_list (@$lists_to_validate) {\n\n            my $type_reports = [];\n\n            my $lh = DADA::MailingList::Subscribers->new(\n                { -list => $to_validate_list } );\n            my $sv = DADA::MailingList::Subscriber::Validate->new(\n                { -list => $to_validate_list } );\n            my $ls = DADA::MailingList::Settings->new(\n                { -list => $to_validate_list } );\n\n            for my $type (\n                @{\n                    $lh->member_of(\n                        {\n                            -email => $email,\n                            -types => [\n                                qw(list black_list test_list white_list authorized_senders moderators requires_moderation ignore_bounces_list)\n                            ],\n                        }\n                    )\n                }\n              )\n            {\n                my $sublists = [];\n\n                # new address\n                my ( $sub_status, $sub_errors ) = $sv->subscription_check(\n                    {\n                        -email => $updated_email,\n                        -type  => $type,\n                        -skip  => [\n                            'closed_list',\n                            'over_subscription_quota',\n                            'already_sent_sub_confirmation',\n                            'invite_only_list',\n                            'profile_fields',\n                            'stop_forum_spam_check_failed',\n                            'suspicious_activity_by_ip_check_failed',\n\t\t\t\t\t\t\t'captcha_challenge_failed',\n\t\t\t\t\t\t\t'list_consent_check',\n                            (\n                                $ls->param(\n                                    'allow_admin_to_subscribe_blacklisted') == 1\n                            ) ? ( 'black_listed', ) : (),\n                        ],\n                    }\n                );\n\n                if ( $sub_status == 1 && $none_validated == 1 ) {\n                    $none_validated = 0;\n                }\n                my $errors = [];\n                for ( keys %$sub_errors ) {\n                    push( @$errors,\n                        { error => $_, error_title => $error_title{$_} } );\n                }\n\n                $sublists = {\n                    type                 => $type,\n                    type_label           => $list_types->{$type},\n                    status               => $sub_status,\n                    errors               => $errors,\n                    'list_settings.list' => $ls->param('list'),\n\n                };\n                push( @$type_reports, $sublists );\n            }\n\n            push(\n                @$list_validations,\n                {\n                    'list_settings.list'      => $ls->param('list'),\n                    'list_settings.list_name' => $ls->param('list_name'),\n                    sublists                  => $type_reports\n                },\n            );\n\n        }\n\n        require Data::Dumper;\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'validate_update_email_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    email                  => $email,\n                    updated_email          => $updated_email,\n                    update_list_validation => $list_validations,\n                    none_validated         => $none_validated,\n                    validate_dump => Data::Dumper::Dumper($list_validations),\n\n                    #all_list_status       => $all_list_status,\n                    #all_list_reports      => $all_list_reports,\n                    #for_all_lists         => $for_all_lists,\n                    #root_login            => $root_login,\n\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n        my @update_list   = $q->multi_param('update_list');\n        my $total_u_count = 0;\n\n        foreach my $update_list (@update_list) {\n            my ( $u_list, $u_type ) = split( ':', $update_list, 2 );\n            my $lh =\n              DADA::MailingList::Subscribers->new( { -list => $u_list } );\n            my ($u_count) = $lh->admin_update_address(\n                {\n                    -email            => $email,\n                    -updated_email    => $updated_email,\n                    -type             => $u_type,\n                    -validation_check => 0,\n                }\n            );\n            $total_u_count = $total_u_count + $u_count;\n\n        }\n\n        my $return_to      = 'membership';\n        my $return_address = $updated_email;\n\n        my $qs =\n          'flavor=' \n\t\t  . $return_to \n\t\t  . '&update_email_count=' \n\t\t  . $total_u_count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props(\n\t\t\t-url => $DADA::Config::S_PROGRAM_URL . '?' . $qs\n\t\t);\n    }\n\n}\n\nsub also_member_of {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list  = $admin_list;\n    my $email = xss_filter( scalar $q->param('email') );\n    my $type  = xss_filter( scalar $q->param('type') ) || 'list';\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $mto = 0;\n\n    my @also_subscribed_to = $lh->also_subscribed_to(\n        {\n            -email => $email,\n            -types =>\n              [qw(list black_list white_list authorized_senders moderators ignore_bounces_list)],\n        }\n    );\n    if ( scalar @also_subscribed_to > 0 ) {\n        $mto = 1;\n    }\n    require JSON;\n    my $json    = JSON->new->allow_nonref;\n    my $headers = { -type => 'application/json' };\n    my $body    = $json->encode(\n        {\n            also_member_of => int($mto)\n        }\n    );\n    $self->header_props(%$headers);\n    return $body;\n}\n\nsub validate_remove_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list             = $admin_list;\n    my $type             = xss_filter( scalar $q->param('type') );\n    my $email            = xss_filter( scalar $q->param('email') );\n    my $process          = xss_filter( scalar $q->param('process') ) || 0;\n    my @remove_from_list = $q->multi_param('remove_from_list');\n    my $return_to        = xss_filter( scalar $q->param('return_to') ) || 0;\n\n\n    my $for_multiple_lists =\n      xss_filter( scalar $q->param('for_multiple_lists') ) || 0;\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n        my @lists = ($list);\n        if ( $for_multiple_lists == 1 ) {\n            my @also_subscribed_to = $lh->also_subscribed_to(\n                {\n                    -email => $email,\n                    -types => [\n                        qw(\n\t\t\t\t\t\t\tlist \n\t\t\t\t\t\t\tblack_list \n\t\t\t\t\t\t\twhite_list \n\t\t\t\t\t\t\tauthorized_senders \n\t\t\t\t\t\t\tmoderators \n\t\t\t\t\t\t\trequires_moderation \n\t\t\t\t\t\t\tsub_confirm_list \n\t\t\t\t\t\t\tignore_bounces_list\n\t\t\t\t\t\t)\n                    ],\n                }\n            );\n            @lists = ( @lists, @also_subscribed_to );\n        }\n\n        my $subscribed_lists = [];\n\n        my $list_types = DADA::App::Guts::list_types();\n\n\t\n\n        foreach my $tmp_list (@lists) {\n            my $tmp_ls =\n              DADA::MailingList::Settings->new( { -list => $tmp_list } );\n            my $tmp_lh =\n              DADA::MailingList::Subscribers->new( { -list => $tmp_list } );\n\n            my $sublists = [];\n            for my $sublist (\n                @{\n                    $tmp_lh->member_of(\n                        {\n                            -email => $email,\n                            -types => [\n                                qw(list black_list white_list authorized_senders moderators requires_moderation  sub_confirm_list ignore_bounces_list)\n                            ],\n                        }\n                    )\n                }\n              )\n            {\n                push(\n                    @$sublists,\n                    {\n                        type                 => $sublist,\n                        type_label           => $list_types->{$sublist},\n                        'list_settings.list' => $tmp_ls->param('list'),\n                        'list_settings.list_name' =>\n                          $tmp_ls->param('list_name'),\n                    }\n                );\n            }\n\n            push(\n                @$subscribed_lists,\n                {\n                    'list_settings.list'      => $tmp_ls->param('list'),\n                    'list_settings.list_name' => $tmp_ls->param('list_name'),\n                    sublists                  => $sublists,\n                }\n            );\n        }\n\n        require Data::Dumper;\n        my $subscribed_lists_dump = Data::Dumper::Dumper($subscribed_lists);\n\n        my $body = DADA::Template::Widgets::screen(\n            {\n                -screen => 'validate_remove_email_widget.tmpl',\n                -vars   => {\n                    email                 => $email,\n                    list_type             => $type,\n                    list_type_label       => $list_types->{$type},\n                    for_multiple_lists    => $for_multiple_lists,\n                    subscribed_lists      => $subscribed_lists,\n                    subscribed_lists_dump => $subscribed_lists_dump,\n                }\n            }\n        );\n\n        return $body;\n    }\n    else {\n\n        my $full_d_count  = 0;\n        my $full_bl_count = 0;\n        foreach my $remove_list (@remove_from_list) {\n            my ( $r_list, $r_type ) = split( ':', $remove_list, 2 );\n            my $lh =\n              DADA::MailingList::Subscribers->new( { -list => $r_list } );\n            my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n                {\n                    -addresses        => [$email],\n                    -type             => $r_type,\n                    -validation_check => 0,\n                }\n            );\n            $full_d_count  = $full_d_count + $d_count;\n            $full_bl_count = $full_bl_count + $bl_count;\n        }\n\n        my $return_address = $email;\n\n        my $qs =\n            'flavor='\n          . $return_to\n          . '&delete_email_count='\n          . $full_d_count\n          . '&type=' . ''\n          . '&black_list_add='\n          . $full_bl_count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n    }\n}\n\nsub mailing_list_history {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list  = $admin_list;\n    my $email = xss_filter( scalar $q->param('email') );\n    my $mode  = xss_filter( scalar $q->param('mode') ) || 'html';\n\n\t# consent\n  \trequire DADA::MailingList::ConsentActivity; \n  \tmy $dmlch = DADA::MailingList::ConsentActivity->new; \n\n    if ( $mode eq 'html' ) {\n\n\t  \tmy $consent_history = $dmlch->consent_history_report({\n\t  \t\t-list  => $list, \n\t  \t\t-email  => scalar $q->param('email'), \n\t  \t});\n\t\t\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'filtered_list_consent_activity_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    consent_history => $consent_history,\n                },\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $mode eq 'export_csv' ) {\n\n\n\t  \tmy $consent_history_csv = $dmlch->consent_history_report({\n\t  \t\t-list  => $list, \n\t  \t\t-email  => scalar $q->param('email'), \n\t\t\t-as_csv => 1, \n\t  \t});\n\t\t\n\t\t# /consent\n\t\t#require Data::Dumper; \n\t\t#my $consent_history_str = Data::Dumper::Dumper($consent_history);\n\t\t\n        my $headers = {\n            -attachment => 'membership_history-' . $list . '-' . time . '.csv',\n            -type       => 'text/csv',\n        };\n        $self->header_props(%$headers);\n        return $consent_history_csv;\n\t\t\n=pod\n\t\t\n\t\t\n\t\t\n        require Text::CSV;\n        my $csv = Text::CSV->new($DADA::Config::TEXT_CSV_PARAMS);\n        my $fh  = \\*STDOUT;\n\n        my $headers = {\n            -attachment => 'membership_history-' . $list . '-' . time . '.csv',\n            -type       => 'text/csv',\n        };\n\n        my $body;\n        my @cols = qw(\n          date\n          list\n          list_name\n          ip\n          email\n          type\n          type_title\n          action\n          updated_email\n        );\n\n        my $status = $csv->combine(@cols);\n        $body .= $csv->string() . \"\\n\";\n\n        for my $line (@$r) {\n            my @lines = ();\n            foreach (@cols) {\n                push( @lines, $line->{$_} );\n            }\n            $status = $csv->combine(@lines);\n            $body .= $csv->string() . \"\\n\";\n        }\n\n        $self->header_props(%$headers);\n        return $body;\n\t\t\n=cut\n\t\t\n    }\n}\n\nsub membership_activity {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list  = $admin_list;\n    my $email = xss_filter( scalar $q->param('email') );\n    my $mode  = xss_filter( scalar $q->param('mode') ) || 'html';\n\n    if ( $mode eq 'html' ) {\n        require DADA::Logging::Clickthrough;\n        my $rd = DADA::Logging::Clickthrough->new( { -list => $list } );\n\n        require DADA::MailingList::Archives;\n        my $ma = DADA::MailingList::Archives->new( { -list => $list } );\n\n        my $activity_tables = [];\n        my ( $total, $mids ) = $rd->get_all_mids;\n        foreach my $mid (@$mids) {\n            my $plugin_url = $DADA::Config::S_PROGRAM_URL . '/plugins/tracker';\n            my $activity_table =\n              $rd->message_individual_email_activity_report_table(\n                {\n                    -mid        => $mid,\n                    -email      => $email,\n                    -plugin_url => $plugin_url,\n\n                }\n              );\n\n            my $archive_exists  = 0;\n            my $archive_subject = '';\n            if ( $ma->check_if_entry_exists($mid) ) {\n                $archive_exists  = 1;\n                $archive_subject = $ma->get_archive_subject($mid);\n            }\n\n            push(\n                @$activity_tables,\n                {\n                    activity_table  => $activity_table,\n                    archive_exists  => $archive_exists,\n                    archive_subject => $archive_subject,\n                    mid             => $mid,\n                }\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'membership_activity_screen.tmpl',\n                -vars   => { activity_tables => $activity_tables, },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $at_email = $email;\n        $at_email =~ s/\\@/_at_/;\n\n        require DADA::Logging::Clickthrough;\n        my $rd = DADA::Logging::Clickthrough->new( { -list => $list } );\n\n        require Text::CSV;\n        my $csv = Text::CSV->new($DADA::Config::TEXT_CSV_PARAMS);\n\n        my $fh = \\*STDOUT;\n\n        my $headers = {\n            -attachment => 'membership_activity-'\n              . $at_email . '-'\n              . $list . '-'\n              . time . '.csv',\n            -type => 'text/csv',\n        };\n        my $body;\n\n        #\t\ttimestamp\n        #\t\ttime\n        #\t\tevent_label\n\n        my @cols = qw(\n          ctime\n          mid\n          email\n          ip\n          event\n          url\n        );\n\n        my $status = $csv->combine(@cols);\n        $body .= $csv->string() . \"\\n\";\n\n        my ( $total, $mids ) = $rd->get_all_mids;\n        foreach my $mid (@$mids) {\n\n            my $report = $rd->message_individual_email_activity_report(\n                {\n                    -mid   => $mid,\n                    -email => $email,\n                }\n            );\n\n            for my $line (@$report) {\n                my @lines = ();\n                foreach (@cols) {\n                    if ( $_ eq 'email' ) {\n                        push( @lines, $email );\n                    }\n                    elsif ( $_ eq 'mid' ) {\n                        push( @lines, $mid );\n                    }\n                    else {\n                        push( @lines, $line->{$_} );\n                    }\n                }\n                my $status = $csv->combine(@lines);\n                $body .= $csv->string() . \"\\n\";\n            }\n        }\n        $self->header_props(%$headers);\n        return $body;\n    }\n}\n\nsub admin_change_profile_password {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list             = $admin_list;\n    my $profile_password = xss_filter( scalar $q->param('profile_password') );\n    my $email            = xss_filter( scalar $q->param('email') );\n    my $type             = xss_filter( scalar $q->param('type') );\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -email => $email } );\n\n    if ( $prof->exists ) {\n\n        $prof->update( { -password => $profile_password, } );\n\n        # Reactivate the Account. ?\n        $prof->activate();\n    }\n    else {\n        $prof->insert(\n            {\n                -password  => $profile_password,\n                -activated => 1,\n            }\n        );\n    }\n\n    # DEV: This is going to get repeated quite a bit..\n    require DADA::Profile::Htpasswd;\n    foreach my $p_list ( @{ $prof->subscribed_to } ) {\n        my $htp = DADA::Profile::Htpasswd->new( { -list => $p_list } );\n        for my $id ( @{ $htp->get_all_ids } ) {\n            $htp->setup_directory( { -id => $id } );\n        }\n    }\n    #\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor=membership&email='\n          . uriescape($email)\n          . '&type='\n          . $type\n          . '&done=1' );\n\n}\n\nsub admin_profile_delivery_preferences {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n\n    my $email = xss_filter( scalar $q->param('email') );\n    my $list = $admin_list;    #xss_filter( scalar $q->param('list') );\n    my $delivery_prefs = xss_filter( scalar $q->param('delivery_prefs') );\n    my $type           = xss_filter( scalar $q->param('type') );\n    my $process        = xss_filter( scalar $q->param('process') );\n\n    if ( !$checksout ) {\n\n        if ( $process eq 'ajax' ) {\n\n            require JSON;\n            my $json = JSON->new->allow_nonref;\n\n            $self->header_props( -type => 'application/json' );\n            my $r = $json->encode(\n                {\n                    status => 0,\n                    error  => $error_msg\n                }\n            );\n            return $r;\n\n        }\n        else {\n            return $error_msg;\n        }\n    }\n\n    my $params = {\n        -email   => $email,\n        -setting => 'delivery_prefs',\n        -value   => $delivery_prefs,\n    };\n\n    require DADA::Profile::Settings;\n \tmy $dps = DADA::Profile::Settings->new({-list => $list});\n    my $r   = $dps->save($params);\n\n    if ( $process eq 'ajax' ) {\n        require JSON;\n        my $json = JSON->new->allow_nonref;\n\n        $self->header_props( -type => 'application/json' );\n        return $json->encode(\n            {\n                status => 1,\n            }\n        );\n\n    }\n    else {\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=membership&email='\n              . uriescape($email)\n              . '&type='\n              . $type\n              . '&done=1' );\n    }\n}\n\nsub add {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'add'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list   = $admin_list;\n    my $chrome = $q->param('chrome');\n    if ( $chrome ne '0' ) { $chrome = 1; }\n\n    my $type           = $q->param('type')           || 'list';\n    my $return_to      = $q->param('return_to')      || '';\n    my $return_address = $q->param('return_address') || '';\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( $q->param('process') ) {\n\n        if ( $q->param('method') eq 'via_add_one' ) {\n\n# We're going to fake the, \"via_textarea\", buy just make a CSV file, and plunking it\n# in the, \"new_emails\" CGI param. (Hehehe);\n\n            my @columns = ();\n            push( @columns, xss_filter( scalar $q->param('email') ) );\n            for ( @{ $lh->subscriber_fields() } ) {\n                push( @columns, xss_filter( scalar $q->param($_) ) );\n            }\n            if ( $type eq 'list' && $lh->can_have_subscriber_fields ) {\n                push( @columns,\n                    xss_filter( scalar $q->param('profile_password') ) );\n            }\n\n            require Text::CSV;\n            my $csv = Text::CSV->new($DADA::Config::TEXT_CSV_PARAMS);\n\n            my $status =\n              $csv->combine(@columns);    # combine columns into a string\n            my $line = $csv->string();    # get the combined string\n\n            $q->param( 'new_emails', $line );\n            $q->param( 'method',     'via_textarea' );\n\n            # End shienanengans.\n\n        }\n\n        if ( $q->param('method') eq 'via_file_upload' ) {\n            if ( strip( scalar $q->param('new_email_file') ) eq '' ) {\n\n                $self->header_type('redirect');\n                $self->header_props(\n                    -url => $DADA::Config::S_PROGRAM_URL . '?flavor=add' );\n            }\n        }\n        elsif ( $q->param('method') eq 'via_textarea' ) {\n            if ( strip( scalar $q->param('new_emails') ) eq '' ) {\n                $self->header_type('redirect');\n                $self->header_props(\n                    -url => $DADA::Config::S_PROGRAM_URL . '?flavor=add' );\n            }\n        }\n\n        # DEV: This whole building of query string is much too messy.\n        my $qs =\n            '&type='\n          . scalar( $q->param('type') )\n          . '&new_email_file='\n          . uriescape( scalar( $q->param('new_email_file') ) );\n\n        if ( DADA::App::Guts::strip( scalar $q->param('new_emails') ) ne \"\" ) {\n\n          # DEV: why is it, \"new_emails.txt\"? Is that supposed to be a variable?\n            my $outfile =\n              make_safer( $DADA::Config::TMP . '/'\n                  . scalar( $q->param('rand_string') ) . '-'\n                  . 'new_emails.txt' );\n\n            open( OUTFILE, '>:encoding(UTF-8)', $outfile )\n              or die \"can't write to \" . $outfile . \": $!\";\n\n            # DEV: TODO encoding?\n            print OUTFILE $q->param('new_emails');\n            close(OUTFILE);\n            chmod( $DADA::Config::FILE_CHMOD, $outfile );\n\n          # DEV: why is it, \"new_emails.txt\"? Is that supposed to be a variable?\n            my $redirect =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=add_email&fn='\n              . scalar( $q->param('rand_string') ) . '-'\n              . 'new_emails.txt'\n              . $qs\n              . '&return_to='\n              . $return_to\n              . '&return_address='\n              . uriescape($return_address)\n              . '&chrome='\n              . $chrome;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $redirect );\n\n        }\n        else {\n\n            if ( $q->param('method') eq 'via_file_upload' ) {\n                $self->_upload_that_file($q);\n            }\n            my $filename = $q->param('new_email_file');\n            $filename =~ s!^.*(\\\\|\\/)!!;\n\n            $filename = uriescape($filename);\n\n            my $redirect =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=add_email&fn='\n              . scalar( $q->param('rand_string') ) . '-'\n              . $filename\n              . $qs;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $redirect );\n\n        }\n    }\n    else {\n        require DADA::MailingList::Settings;\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        my $num_subscribers            = $lh->num_subscribers();\n        my $subscription_quota_reached = 0;\n        if ( $type eq 'list' ) {\n            if (   $ls->param('use_subscription_quota') == 1\n                && ( $num_subscribers >= $ls->param('subscription_quota') )\n                && ( $num_subscribers + $ls->param('subscription_quota') > 1 ) )\n            {\n                $subscription_quota_reached = 1;\n            }\n            elsif (defined($DADA::Config::SUBSCRIPTION_QUOTA)\n                && $DADA::Config::SUBSCRIPTION_QUOTA > 0\n                && $num_subscribers >= $DADA::Config::SUBSCRIPTION_QUOTA )\n            {\n                $subscription_quota_reached = 1;\n            }\n        }\n\t\t\n\t\t# I reuse, \"$subscription_quota_reached\" here: \n\t\tif (\n\t\t\t\t $type eq 'test_list' \n\t\t\t && $ls->param('enable_test_list_address_limit')\n\t\t ) {\n\n\t        my $num_subscribers            = $lh->num_subscribers({-type => $type});\n\t\t\tif($num_subscribers >= $ls->param('test_list_address_limit')){ \n\t\t\t\t$subscription_quota_reached = 1; \n\t\t\t}\n\t\t}\n\t\t\n        require HTML::Menu::Select;\n        my $view_list_type_switch_widget = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'type',\n                values  => [ keys %{ DADA::App::Guts::list_types() } ],\n                labels  => DADA::App::Guts::list_types(),\n                default => $type,\n            }\n        );\n\n        my $rand_string = generate_rand_string_md5();\n\n        my $fields = [];\n\n        # DEV: This is repeated quite a bit...\n        require DADA::ProfileFieldsManager;\n        my $pfm         = DADA::ProfileFieldsManager->new;\n        my $fields_attr = $pfm->get_all_field_attributes;\n        for my $field ( @{ $lh->subscriber_fields() } ) {\n            push(\n                @$fields,\n                {\n                    name     => $field,\n                    label    => $fields_attr->{$field}->{label},\n                    required => $fields_attr->{$field}->{required},\n                }\n            );\n        }\n\n        my $list_is_closed = 0;\n        if (   $type eq 'list'\n            && $ls->param('closed_list') == 1 )\n        {\n            $list_is_closed = 1;\n        }\n\t\t\n        my $show_bounced_list = 0;\n        if (   $lh->num_subscribers( { -type => 'bounced_list' } ) > 0\n            || $ls->param('bounce_handler_when_threshold_reached') eq\n            'move_to_bounced_sublist' )\n        {\n            $show_bounced_list = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'add_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen                     => 'add',\n                    root_login                 => $root_login,\n                    subscription_quota_reached => $subscription_quota_reached,\n                    num_subscribers            => $num_subscribers,\n                    SUBSCRIPTION_QUOTA => $DADA::Config::SUBSCRIPTION_QUOTA,\n                    type               => $type,\n                    type_title         => $DADA::Config::LIST_TYPES->{$type},\n                    flavor             => 'add',\n                    rand_string        => $rand_string,\n                    \n\t\t\t\t\tlist_subscribers_num =>\n                      scalar $lh->num_subscribers( { -type => 'list' } ),\n\t\t\t\t\t  \n  \t\t\t\t\ttest_list_subscribers_num =>\n                        scalar $lh->num_subscribers( { -type => 'test_list' } ),\n                    \n\t\t\t\t\tblack_list_subscribers_num =>\n                      scalar $lh->num_subscribers( { -type => 'black_list' } ),\n                    \n\t\t\t\t\twhite_list_subscribers_num =>\n                      scalar $lh->num_subscribers( { -type => 'white_list' } ),\n                    \n\t\t\t\t\tauthorized_senders_num =>\n                      scalar $lh->num_subscribers( { -type => 'authorized_senders' } ),\n                    \n                  moderators_num => scalar commify(\n                      $lh->num_subscribers( { -type => 'moderators' } )\n                  ),\n\t\t\t\t\n\t\t\t\t\trequires_moderation_num => scalar commify(\n\t\t\t\t\t\t$lh->num_subscribers( { -type => 'requires_moderation' } )\n\t\t\t\t\t),\n\t\t\t\t\t  \n\t\t\t\t\tbounced_list_num =>\n                      scalar $lh->num_subscribers( { -type => 'bounced_list' } ),\n\t\t\t\t\t\n\t\t\t\t\tignore_bounces_list_num => \n\t\t\t\t\t\tscalar $lh->num_subscribers( { -type => 'ignore_bounces_list' } ),\n\t\t\t\t\t\t\n\t\t\t\t\tshow_bounced_list => $show_bounced_list,\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t  \n                    fields => $fields,\n                    can_have_subscriber_fields =>\n                      $lh->can_have_subscriber_fields,\n                    list_is_closed => $list_is_closed,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n\n}\n\nsub check_status {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    my $filename = $q->param('new_email_file');\n    $filename =~ s{^(.*)\\/}{};\n    $filename = uriescape($filename);\n\n    if ( !-e $DADA::Config::TMP . '/' . $filename . '-meta.txt' ) {\n        warn \"no meta file at: \"\n          . $DADA::Config::TMP . '/'\n          . $filename\n          . '-meta.txt';\n        my $json = JSON->new->allow_nonref;\n        $self->header_props( -type => 'application/json' );\n        return $json->encode(\n            { percent => 0, content_length => 0, bytes_read => 0 } );\n    }\n    else {\n\n        chmod( $DADA::Config::FILE_CHMOD,\n            make_safer( $DADA::Config::TMP . '/' . $filename . '-meta.txt' ) );\n\n        open my $META, '<',\n          make_safer( $DADA::Config::TMP . '/' . $filename . '-meta.txt' )\n          or die $!;\n\n        my $s = do { local $/; <$META> };\n\n        my ( $bytes_read, $content_length, $per ) = split( '-', $s, 3 );\n        if ( $per == 99 ) { $per = 100 }\n        close($META);\n\n        my $json = JSON->new->allow_nonref;\n        $self->header_props( -type => 'application/json' );\n        return $json->encode(\n            {\n                bytes_read     => $bytes_read,\n                content_length => $content_length,\n                percent        => int($per),\n            }\n        );\n    }\n}\n\nsub dump_meta_file {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $filename = $q->param('new_email_file');\n    $filename =~ s{^(.*)\\/}{};\n    $filename = uriescape($filename);\n\n    my $full_path_to_filename =\n      make_safer( $DADA::Config::TMP . '/' . $filename . '-meta.txt' );\n\n    if ( !-e $full_path_to_filename ) {\n\n    }\n    else {\n\n        my $chmod_check =\n          chmod( $DADA::Config::FILE_CHMOD, $full_path_to_filename );\n        if ( $chmod_check != 1 ) {\n            warn \"could not chmod '$full_path_to_filename' correctly.\";\n        }\n\n        my $unlink_check = unlink($full_path_to_filename);\n        if ( $unlink_check != 1 ) {\n            warn \"deleting meta file didn't work for: \"\n              . $full_path_to_filename;\n        }\n    }\n}\n\nsub _upload_that_file {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    #DEV: move\n    my $fh = $q->upload('new_email_file');\n\n\n\n#\tmy %headers = map { $_ => $q->http($_) } $q->http();\n#\tfor my $header ( keys %headers ) {\n#\t    warn \"$header: $headers{$header}\";\n#\t}\t\n#\tuse Data::Dumper; \n#\twarn '$fh: ' . Dumper($fh);\n#\twarn 'uploadInfo' . Dumper($q->uploadInfo($fh)); \n#\twarn '$q' . Dumper($q);\n\n    my $filename = $q->param('new_email_file');\n    $filename =~ s!^.*(\\\\|\\/)!!;\n\n    $filename = uriescape($filename);\n\n\n\t# warn '$filename: ' . $filename; \n\t\n    # warn '$filename ' . $filename;\n\n    # warn '$q->param(\\'rand_string\\') '    . $q->param('rand_string');\n    # warn '$q->param(\\'new_email_file\\') ' . $q->param('new_email_file');\n    return '' if !$filename;\n\n    my $outfile =\n      make_safer( $DADA::Config::TMP . '/'\n          . scalar( $q->param('rand_string') ) . '-'\n          . $filename );\n\n    # warn ' $outfile ' . $outfile;\n\n    open( OUTFILE, '>:encoding(UTF-8)', $outfile )\n      or die( \"can't write to \" . $outfile . \": $!\" );\n\n    while ( my $bytesread = read( $fh, my $buffer, 1024 ) ) {\n\n\t\t# This safely_decode call makes sense, as it wouldn't have been touched \n\t\t# by the normal thing that decodes stuff...\n        print OUTFILE safely_decode($buffer);\n    }\n\n    close(OUTFILE);\n    chmod( $DADA::Config::FILE_CHMOD, $outfile );\n\n}\n\nsub add_email {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $type    = $q->param('type') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'add_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $return_to      = $q->param('return_to')      || '';\n    my $return_address = $q->param('return_address') || '';\n    my $chrome         = $q->param('chrome');\n    if ( $chrome ne '0' ) { $chrome = 1; }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    require DADA::ProfileFieldsManager;\n    my $pfm        = DADA::ProfileFieldsManager->new;\n    my $field_atts = $pfm->get_all_field_attributes;\n\n    my $lh = DADA::MailingList::Subscribers->new(\n        {\n            -list     => $list,\n            -dpfm_obj => $pfm,\n        }\n    );\n    my $subscriber_fields = $lh->subscriber_fields;\n\n    if ( !$process ) {\n\n        my $new_emails_fn = $q->param('fn');\n\n        my $new_emails = [];\n        my $new_info   = [];\n\n        if ( $ls->param('use_add_list_import_limit') == 1 ) {\n\t\t\tmy $num_file_lines = 0; \n\t\t\tmy $had_problems = 0; \n\t\t\tmy $scrn; \n\t\t\ttry {\n            \t$num_file_lines =\n              \tDADA::App::Guts::num_file_lines($new_emails_fn);\n\t\t\t} catch {\n\t\t\t\t$had_problems = 1; \n\t            my $error = $_;\n\t               $scrn = DADA::Template::Widgets::wrap_screen(\n\t                {\n\t                    -screen         => 'add_email_error_screen.tmpl',\n\t                    -with           => 'admin',\n\t                    -wrapper_params => {\n\t                        -Root_Login => $root_login,\n\t                        -List       => $list,\n\t                    },\n\t                    -expr                     => 1,\n\t                    -vars                     => { error => $error },\n\t                    -list_settings_vars_param => {\n\t                        -list   => $list,\n\t                        -dot_it => 1,\n\t                    },\n\t                }\n\t            );\n        \t};\n\t\t\tif($had_problems == 1){ \n\t\t\t\treturn $scrn;\n\t\t\t}\n\n            if ( $num_file_lines > $ls->param('add_list_import_limit') ) {\n                my $error = 'over_add_list_import_limit';\n\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen         => 'add_email_error_screen.tmpl',\n                        -with           => 'admin',\n                        -wrapper_params => {\n                            -Root_Login => $root_login,\n                            -List       => $list,\n                        },\n                        -expr                     => 1,\n                        -vars                     => { error => $error },\n                        -list_settings_vars_param => {\n                            -list   => $list,\n                            -dot_it => 1,\n                        },\n                    }\n                );\n                return $scrn;\n            }\n        }\n \n\t\tmy $had_problems = 0; \n\t\tmy $scrn; \n\t\t\n        try {\n            ($new_emails) = DADA::App::Guts::csv_subscriber_parse( $admin_list,\n                $new_emails_fn );\n        }\n        catch {\n\t\t\t$had_problems  = 1; \n            my $error = $_;\n            $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'add_email_error_screen.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -expr                     => 1,\n                    -vars                     => { error => $error },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n           \n        };\n\t\tif($had_problems == 1){ \n\t\t\treturn $scrn;\n\t\t}\n\n        my ( $not_members, $invalid_email, $subscribed, $black_listed,\n            $not_white_listed, $invalid_profile_fields )\n          = $lh->filter_subscribers_massaged_for_ht(\n            {\n                -emails => $new_emails,\n                -type   => $type,\n            }\n          );\n\n        my $num_subscribers = $lh->num_subscribers({ -type => $type });\n\n# and for some reason, this is its own subroutine...\n# This is down here, so the status bar won't disapear before this page is loaded (or the below redirect)\n        $self->dump_meta_file();\n\n        # This is to see if we're already over quota:\n        my $subscription_quota_reached = 0;\n        if ( $type eq 'list' ) {\n            if (   $ls->param('use_subscription_quota') == 1\n                && ( $num_subscribers >= $ls->param('subscription_quota') )\n                && ( $num_subscribers + $ls->param('subscription_quota') > 1 ) )\n            {\n                $subscription_quota_reached = 1;\n            }\n            elsif (defined($DADA::Config::SUBSCRIPTION_QUOTA)\n                && $DADA::Config::SUBSCRIPTION_QUOTA > 0\n                && $num_subscribers >= $DADA::Config::SUBSCRIPTION_QUOTA )\n            {\n                $subscription_quota_reached = 1;\n            }\n        }\n        if ($subscription_quota_reached) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=add&type=list' );\n            return;\n        }\n\n        my $going_over_quota = 0;\n        if ( $type eq 'list' ) {\n            if ( $ls->param('use_subscription_quota') == 1\n                && ( $num_subscribers + scalar(@$not_members) ) >\n                $ls->param('subscription_quota') )\n            {\n                $going_over_quota = 1;\n            }\n            elsif (defined($DADA::Config::SUBSCRIPTION_QUOTA)\n                && $DADA::Config::SUBSCRIPTION_QUOTA > 0\n                && ( $num_subscribers + scalar(@$not_members) ) >\n                $DADA::Config::SUBSCRIPTION_QUOTA )\n            {\n                $going_over_quota = 1;\n            }\n        }\n\t\t\n\t\t# Tester List has a quota limit too:\n        if ( $type eq 'test_list' ) {\n            if ( $ls->param('enable_test_list_address_limit') == 1\n                && ( $num_subscribers + scalar(@$not_members) ) >\n                $ls->param('test_list_address_limit') )\n            {\n                $going_over_quota = 1;\n            }\n        }\n\t\t\n        my $addresses_to_add = 0;\n        if ( exists( $not_members->[0] ) ) {\n            $addresses_to_add = 1;\n        }\n\n        my $field_names = [];\n\n        # if($type eq 'list') {\n        for (@$subscriber_fields) {\n            push(\n                @$field_names,\n\n                {\n                    name  => $_,\n                    label => $field_atts->{$_}->{label},\n                }\n            );\n        }\n\n        #    }\n\n        if (   $type eq 'list'\n            && $ls->param('closed_list') == 1 )\n        {\n            die \"Your list is currently CLOSED to subscribers.\";\n        }\n\n        # If we're using the black list, but\n        # the list owner is allowed to subscribed blacklisted addresses,\n        # we have to communicate that to the template:\n        if (   $ls->param('black_list') == 1\n            && $ls->param('allow_admin_to_subscribe_blacklisted') == 1 )\n        {\n            for (@$black_listed) {\n                $_->{'list_settings.allow_admin_to_subscribe_blacklisted'} = 1;\n            }\n        }\n\n        my $show_invitation_button = 0;\n        my $show_update_button     = 0;\n        my $show_add_button        = 0;\n\n        if ( $type eq 'list' ) {\n            if ( scalar(@$not_members) > 0 ) {\n                $show_invitation_button = 1;\n            }\n            elsif ( scalar(@$black_listed) > 0\n                && $ls->param('allow_admin_to_subscribe_blacklisted') == 1 )\n            {\n                $show_invitation_button = 1;\n            }\n            elsif (\n                scalar($invalid_profile_fields) > 0\n                && (   $root_login == 1\n                    || $ls->param('allow_profile_editing') == 1 )\n              )\n            {\n                $show_invitation_button = 1;\n            }\n\n            if (\n                     scalar( @$not_members  ) < 1 \n                && ( \n\t\t\t\tscalar( @$black_listed ) < 1\n                && $ls->param('allow_admin_to_subscribe_blacklisted') == 1 )\n                && scalar(@$subscribed) > 1\n                && (   $root_login == 1\n                    || $ls->param('allow_profile_editing') == 1 )\n              )\n            {\n                $show_update_button = 1;\n            }\n            else {\n                $show_add_button = 1;\n            }\n        }\n\n        my %vars = (\n\n            show_invitation_button => $show_invitation_button,\n            show_update_button     => $show_update_button,\n            show_add_button        => $show_add_button,\n\n            can_have_subscriber_fields => $lh->can_have_subscriber_fields,\n            going_over_quota           => $going_over_quota,\n            field_names                => $field_names,\n            subscribed                 => $subscribed,\n            not_members                => $not_members,\n            black_listed               => $black_listed,\n            not_white_listed           => $not_white_listed,\n            invalid_email              => $invalid_email,\n            invalid_profile_fields     => $invalid_profile_fields,\n            type                       => $type,\n            type_title                 => $DADA::Config::LIST_TYPES->{$type},\n            root_login                 => $root_login,\n            return_to                  => $return_to,\n            return_address             => $return_address,\n            chrome                     => $chrome,\n        );\n\n        my $scrn;\n        if ( $chrome == 1 ) {\n            $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'add_email_screen.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -expr                     => 1,\n                    -vars                     => { %vars, },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n        }\n        else {\n            $scrn = DADA::Template::Widgets::screen(\n                {\n                    -screen                   => 'add_email_screen.tmpl',\n                    -expr                     => 1,\n                    -vars                     => { %vars, },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n        }\n        return $scrn;\n    }\n    else {\n\n        my $update_email_count = 0;\n\n        if ( $type eq 'list' ) {\n            if ( $process =~ m/subscribe|invit|update/i ) {\n\n   # This is what updates already existing profile fields and profile passwords;\n   #\n                my @update_fields_address =\n                  $q->multi_param(\"update_fields_address\");\n\n                # This is a lot of code, to set one thing:\n                my $subscribed_fields_options_mode =\n                  $q->param('subscribed_fields_options_mode')\n                  || 'writeover_inc_password';\n                my $spass_om = 'writeover';\n                if (\n                    $subscribed_fields_options_mode eq 'writeover_ex_password' )\n                {\n                    $spass_om = 'preserve_if_defined';\n                }\n\n                #/\n\n                my $update_email_count = 0;\n\n                # Change from csv to a complex data structure.\n                my @munged_update_addresses = ();\n                for my $ua (@update_fields_address) {\n                    push( @munged_update_addresses, $lh->csv_to_cds($ua) );\n                }\n\n                require DADA::Profiles;\n                my $dp                 = DADA::Profiles->new;\n                my $update_email_count = $dp->update(\n                    {\n                        -addresses       => [@munged_update_addresses],\n                        -password_policy => $spass_om,\n                    }\n                );\n            }\n        }\n\n        if ( $process =~ /invit/i ) {\n            $self->list_invite();\n        }\n        else {\n\n            if ( $type eq 'list' ) {\n                unless (\n                    $ls->param('enable_mass_subscribe') == 1\n                    && (   $root_login == 1\n                        || $ls->param('enable_mass_subscribe_only_w_root_login')\n                        != 1 )\n                  )\n                {\n                    die \"Mass Subscribing via the List Control Panel has been disabled.\";\n                }\n            }\n\t\t\t\n\n            my @address = $q->multi_param(\"address\");\n\n\n\n            \n\t\t\t# Tester List has a quota limit too:\n\t        if ( $type eq 'test_list' ) {\n\t            if ( $ls->param('enable_test_list_address_limit') == 1\n\t                && ( $lh->num_subscribers({-type => 'test_list'}) + scalar(@address) ) >\n\t                $ls->param('test_list_address_limit') )\n\t            {\n\t                my $error = 'over_add_list_import_limit';\n\n\t                my $scrn = DADA::Template::Widgets::wrap_screen(\n\t                    {\n\t                        -screen         => 'add_email_error_screen.tmpl',\n\t                        -with           => 'admin',\n\t                        -wrapper_params => {\n\t                            -Root_Login => $root_login,\n\t                            -List       => $list,\n\t                        },\n\t                        -expr                     => 1,\n\t                        -vars                     => { error => $error },\n\t                        -list_settings_vars_param => {\n\t                            -list   => $list,\n\t                            -dot_it => 1,\n\t                        },\n\t                    }\n\t                );\n\t                return $scrn;\n\t            }\n\t\t\t}\n\t\t\t#/ Tester List has a quota limit too:\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tmy @munged_add_addresses = ();\n            for my $a (@address) {\n                push( @munged_add_addresses, $lh->csv_to_cds($a) );\n            }\n            undef(@address);\n\n            my $not_members_fields_options_mode =\n              $q->param('not_members_fields_options_mode');\n\n            my ( $new_email_count, $skipped_email_count ) =\n              $lh->add_subscribers(\n                {\n                    -addresses           => [@munged_add_addresses],\n                    -fields_options_mode => $not_members_fields_options_mode,\n                    -type                => $type,\n                }\n              );\n\n            my $flavor_to_return_to = 'view_list';\n            if ( $return_to eq 'membership' ) {    # or, others...\n                $flavor_to_return_to = $return_to;\n            }\n\n            my $qs =\n                'flavor='\n              . $flavor_to_return_to\n              . '&add_email_count='\n              . $new_email_count\n              . '&skipped_email_count='\n              . $skipped_email_count\n              . '&update_email_count='\n              . $update_email_count\n              . '&type='\n              . $type;\n\n            if ( $return_to eq 'membership' ) {\n                $qs .= '&email=' . uriescape($return_address);\n            }\n\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n\n        }\n    }\n}\n\nsub delete_email {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'delete_email',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $type = $q->param('type') || 'list';\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_email_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen                    => 'delete_email',\n                    title                     => 'Remove',\n                    can_use_global_black_list => $lh->can_use_global_black_list,\n                    can_use_global_unsubscribe =>\n                      $lh->can_use_global_unsubscribe,\n                    list_type_isa_list => ( $type eq 'list' ) ? 1 : 0,\n                    list_type_isa_black_list => ( $type eq 'black_list' ) ? 1\n                    : 0,\n                    list_type_isa_authorized_senders =>\n                      ( $type eq 'authorized_senders' ) ? 1 : 0,\n                    list_type_isa_moderators => ( $type eq 'moderators' ) ? 1\n                    : 0,\n                    list_type_isa_white_list => ( $type eq 'white_list' ) ? 1\n                    : 0,\n                    type       => $type,\n                    type_title => $DADA::Config::LIST_TYPES->{$type},\n                    flavor     => 'delete_email',\n                    list_subscribers_num =>\n                      $lh->num_subscribers( { -type => 'list' } ),\n                    test_list_subscribers_num =>\n                        $lh->num_subscribers( { -type => 'test_list' } ),\n\t\t\t\t\tblack_list_subscribers_num =>\n                      $lh->num_subscribers( { -type => 'black_list' } ),\n                    white_list_subscribers_num =>\n                      $lh->num_subscribers( { -type => 'white_list' } ),\n                    authorized_senders_num =>\n                      $lh->num_subscribers( { -type => 'authorized_senders' } ),\n\t\t\t\t\t  \n                      moderators_num => scalar commify(\n                          $lh->num_subscribers( { -type => 'moderators' } )\n                      ),\n\t\t\t\t\t\n\t\t\t\t\t  \n                      requires_moderation_num => scalar commify(\n                          $lh->num_subscribers( { -type => 'requires_moderation' } )\n                      ),\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        my $delete_list       = undef;\n        my $delete_email_file = $q->param('delete_email_file');\n        if ($delete_email_file) {\n            my $new_file = $self->file_upload('delete_email_file');\n            open( UPLOADED, \"$new_file\" )\n              or die $!;\n            $delete_list = do { local $/; <UPLOADED> };\n            close(UPLOADED);\n        }\n        else {\n            $delete_list = $q->param('delete_list');\n        }\n\n        my $outfile_filename =\n          generate_rand_string_md5() . '-' . 'remove_emails.txt';\n        my $outfile =\n          make_safer( $DADA::Config::TMP . '/' . $outfile_filename );\n\n        #DEV: encoding?\n        open( my $fh, '>' . $outfile )\n          or die( \"can't write to \" . $outfile . \": $!\" );\n        print $fh $delete_list;\n        close($fh);\n        chmod( $DADA::Config::FILE_CHMOD, $outfile );\n\n        my $new_emails = [];\n        my $new_info   = [];\n        ( $new_emails, $new_info ) =\n          DADA::App::Guts::csv_subscriber_parse( $admin_list,\n            $outfile_filename );\n\n        my ( $not_members, $invalid_email, $subscribed, $black_listed,\n            $not_white_listed, $invalid_profile_fields )\n          = $lh->filter_subscribers_massaged_for_ht(\n            {\n                -emails                       => $new_emails,\n                -type                         => $type,\n                -treat_profile_fields_special => 0,\n\n            }\n          );\n\n        #        use Data::Dumper;\n        #        warn Dumper({\n        #             not_members => $not_members,\n        #             invalid_email => $invalid_email,\n        #             subscribed => $subscribed,\n        #             black_listed => $black_listed,\n        #             not_white_listed => $not_white_listed,\n        #             invalid_profile_fields => $invalid_profile_fields,\n        #        });\n\n        my $have_subscribed_addresses = 0;\n        $have_subscribed_addresses = 1\n          if $subscribed->[0];\n\n        my $addresses_to_remove = [];\n        push( @$addresses_to_remove, { email => $_->{email} } )\n          for @$subscribed;\n\n        my $not_subscribed_addresses = [];\n        push( @$not_subscribed_addresses, { email => $_->{email} } )\n          for @$not_members;\n\n        my $have_invalid_addresses = 0;\n        $have_invalid_addresses = 1\n          if $invalid_email->[0];\n\n        my $invalid_addresses = [];\n        push( @$invalid_addresses, { email => $_->{email} } )\n          for @$invalid_email;\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_email_screen_filtered.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    have_subscribed_addresses => $have_subscribed_addresses,\n                    addresses_to_remove       => $addresses_to_remove,\n                    not_subscribed_addresses  => $not_subscribed_addresses,\n                    have_invalid_addresses    => $have_invalid_addresses,\n                    invalid_addresses         => $invalid_addresses,\n\n                    type       => $type,\n                    type_title => $DADA::Config::LIST_TYPES->{$type},\n\n                },\n            }\n        );\n\n        return $scrn;\n    }\n}\n\nsub subscription_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'subscription_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my @d_quota_values = qw(1 10 25 50 100 150 200 250 300 350 400 450 500 600\n      700 800 900 1000 1500 2000 2500 3000 3500 4000 4500\n      5000 5500 6000 6500 7000 7500 8000 8500 9000 9500\n      10000 11000 12000 13000 14000 15000 16000 17000\n      18000 19000 20000 30000 40000 50000 60000 70000\n      80000 90000 100000 200000 300000 400000 500000\n      600000 700000 800000 900000 1000000\n    );\n\n\tif (strip($DADA::Config::SUBSCRIPTION_QUOTA) eq '') {\n \t   $DADA::Config::SUBSCRIPTION_QUOTA = undef\n\t}\n    \n    my @quota_values;\n\n\t# no idea. \n    if ( defined($DADA::Config::SUBSCRIPTION_QUOTA) \n\t\t&&       $DADA::Config::SUBSCRIPTION_QUOTA > 0 ) {\n        for (@d_quota_values) {\n            if ( $_ < $DADA::Config::SUBSCRIPTION_QUOTA ) {\n                push( @quota_values, $_ );\n            }\n        }\n        push( @quota_values, $DADA::Config::SUBSCRIPTION_QUOTA );\n\n    }\n    else {\n        @quota_values = @d_quota_values;\n    }\n\n    # Now that's a weird line (now)\n    unshift( @quota_values, $ls->param('subscription_quota') );\n\n    if ( !$process ) {\n\n        require DADA::ProfileFieldsManager;\n        my $dpfm = DADA::ProfileFieldsManager->new;\n        require DADA::Profile::Fields;\n        my $dpf = DADA::Profile::Fields->new;\n\n        my $view_list_order_by_menu           = '';\n        my $view_list_order_by_direction_menu = '';\n        require HTML::Menu::Select;\n\n        if ( $dpf->can_have_subscriber_fields ) {\n\n            my $field_atts      = $dpfm->get_all_field_attributes;\n            my $pf_field_labels = {};\n            for ( keys %{$field_atts} ) {\n                $pf_field_labels->{$_} = $field_atts->{$_}->{label};\n            }\n            my $field_values = $dpfm->fields;\n            unshift( @$field_values, 'timestamp' );\n            unshift( @$field_values, 'email' );\n\n            $pf_field_labels->{timestamp} = 'Subscription Date';\n            $pf_field_labels->{email}     = 'Email Address';\n\n            $view_list_order_by_menu = HTML::Menu::Select::popup_menu(\n                {\n                    name    => 'view_list_order_by',\n                    id      => 'view_list_order_by',\n                    values  => $field_values,\n                    labels  => $pf_field_labels,\n                    default => $ls->param('view_list_order_by'),\n                }\n            );\n            $view_list_order_by_direction_menu = HTML::Menu::Select::popup_menu(\n                {\n                    name    => 'view_list_order_by_direction',\n                    id      => 'view_list_order_by_direction',\n                    values  => [ 'ASC', 'DESC' ],\n                    labels  => { ASC => 'Ascending', DESC => 'Descending' },\n                    default => $ls->param('view_list_order_by_direction'),\n                }\n            );\n        }\n        my $subscription_quota_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'subscription_quota',\n                id      => 'subscription_quota',\n                values  => [@quota_values],\n                default => $ls->param('subscription_quota'),\n            }\n        );\n\t\t\n\t\tmy $test_list_address_limit_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'test_list_address_limit',\n                id      => 'test_list_address_limit',\n                values  => [(1,2,3,4,5,6,7,8,9,10,15,20,25,30,40,50,60,70,80,90,100)],\n                default => $ls->param('test_list_address_limit'),\n            }\n\t\t);\n\n        my @list_amount = (\n            3,     5,    10,   25,   50,    100,   150,   200,\n            250,   300,  350,  400,  450,   500,   550,   600,\n            650,   700,  750,  800,  850,   900,   950,   1000,\n            2000,  3000, 4000, 5000, 10000, 15000, 20000, 25000,\n            50000, 100000\n        );\n        require HTML::Menu::Select;\n        my $vlsn_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'view_list_subscriber_number',\n                values  => [@list_amount],\n                default => $ls->param('view_list_subscriber_number'),\n            }\n        );\n\n        my $add_list_import_limit_menu = HTML::Menu::Select::popup_menu(\n            {\n                name   => 'add_list_import_limit',\n                values => [\n                    qw(100 200 300 400 500 600 750 1000 1500 2000 2500 3000 5000 7500 10000)\n                ],\n                default => $ls->param('add_list_import_limit'),\n            }\n        );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'subscription_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    screen                  => 'subscription_options',\n                    title                   => 'Subscriber Options',\n                    done                    => $done,\n                    root_login              => $root_login,\n                    subscription_quota_menu => $subscription_quota_menu,\n                    can_have_subscriber_fields =>\n                      $dpf->can_have_subscriber_fields,\n                    vlsn_menu               => $vlsn_menu,\n                    view_list_order_by_menu => $view_list_order_by_menu,\n                    view_list_order_by_direction_menu =>\n                      $view_list_order_by_direction_menu,\n                    add_list_import_limit_menu => $add_list_import_limit_menu,\n                    SUBSCRIPTION_QUOTA => $DADA::Config::SUBSCRIPTION_QUOTA,\n                    commified_subscription_quota =>\n                      commify( int($DADA::Config::SUBSCRIPTION_QUOTA) ),\n                \t  test_list_address_limit_menu => $test_list_address_limit_menu, \n\t\t\t\t},\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    view_list_subscriber_number                      => undef,\n                    view_list_show_timestamp_col                     => 0,\n                    view_list_order_by                               => undef,\n                    view_list_order_by_direction                     => undef,\n                    view_list_show_sub_confirm_list                  => 0,\n\t\t\t\t\tview_list_enable_delete_all_button               => 0,\n                    use_add_list_import_limit                        => 0,\n                    add_list_import_limit                            => undef,\n                    allow_profile_editing                            => 0,\n                    use_subscription_quota                           => 0,\n                    subscription_quota                               => undef,\n                    black_list                                       => 0,\n                    add_unsubs_to_black_list                         => 0,\n                    allow_blacklisted_to_subscribe                   => 0,\n                    allow_admin_to_subscribe_blacklisted             => 0,\n                    enable_white_list                                => 0,\n\t\t\t\t\tenable_test_list                                 => 0,\n\t\t\t\t\tenable_test_list_address_limit                   => 0,\n\t\t\t\t\ttest_list_address_limit                          => undef,\n                    invites_check_for_already_invited                => 0,\n                    invites_prohibit_reinvites                       => 0,\n\t\t\t\t\tinvites_show_profile_fields_in_subscription_form => 0, \n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=subscription_options&done=1' );\n    }\n\n}\n\nsub view_archive {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_archive'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $admin_list } );\n\n    # let's get some info on this archive, shall we?\n    require DADA::MailingList::Archives;\n\n    my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n    my $entries = $archive->get_archive_entries();\n\n    #if we don't have nothin, print the index,\n\n    my $id = $q->param('id') || undef;\n\n    unless ( defined($id) ) {\n\n        my $start = int( $q->param('start') ) || 0;\n\n        if (\n            !$c->profile_on\n            && $c->is_cached(\n                $list . '.admin.view_archive.index.' . $start . '.scrn'\n            )\n          )\n        {\n            return $c->cached(\n                $list . '.admin.view_archive.index.' . $start . '.scrn' );\n        }\n\n        my $ht_entries = [];\n\n        my $th_entries = [];\n\n        my ( $begin, $stop ) = $archive->create_index($start);\n        my $i;\n        my $stopped_at = $begin;\n\n        my @archive_nums;\n        my @archive_links;\n\n        for ( $i = $begin ; $i <= $stop ; $i++ ) {\n\n            next if !defined( $entries->[$i] );\n\n            my $entry = $entries->[$i];\n\n            #for $entry (@$entries){\n            my ( $subject, $message, $format, $raw_msg ) =\n              $archive->get_archive_info($entry);\n\n            my $pretty_subject = pretty($subject);\n\n            my $header_from = undef;\n            if ($raw_msg) {\n                $header_from =\n                  $archive->get_header( -header => 'From', -key => $entry );\n\n                # The SPAM ME NOT Encoding's a little fucked for this, anyways,\n                # We should only encode the actual address, anyways. Hmm...\n                # $header_from    = spam_me_not_encode($header_from);\n            }\n            else {\n                $header_from = '-';\n            }\n\n            my $date = date_this(\n                -Packed_Date => $entry,\n                -All         => 1\n            );\n\n            my $message_blurb = $archive->message_blurb( -key => $entry );\n            $message_blurb =~ s/\\n|\\r/ /g;\n\n            push(\n                @$ht_entries,\n\n                {\n                    id            => $entry,\n                    date          => $date,\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL,\n                    subject       => $pretty_subject,\n                    from          => $header_from,\n                    message_blurb => $message_blurb,\n                }\n            );\n\n            $stopped_at++;\n\n        }\n\n        my $index_nav = $archive->create_index_nav( $stopped_at, 1 );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'view_archive_index_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -list => $list,\n                -vars => {\n                    can_use_JSON => scalar DADA::App::Guts::can_use_JSON(),\n                    screen       => 'view_archive',\n                    title        => 'View Archive',\n\t\t\t\t\tPLUGINS_ENABLED_tracker => $DADA::Config::PLUGINS_ENABLED->{tracker},\n                    index_list   => $ht_entries,\n                    list_name    => $ls->param('list_name'),\n                    index_nav    => $index_nav,\n\n                },\n            }\n        );\n\n        if ( !$c->profile_on ) {    # that's it?\n            $c->cache( $list . '.admin.view_archive.index.' . $start . '.scrn',\n                \\$scrn );\n        }\n        return $scrn;\n    }\n    else {\n\n        #check to see if $id is a real id key\n        my $entry_exists = $archive->check_if_entry_exists($id);\n\n        if ( $entry_exists <= 0 ) {\n            return user_error(\n                { -list => $list, -error => \"no_archive_entry\" } );\n        }\n\n        my $scrn = '';\n\n        my ( $subject, $message, $format ) = $archive->get_archive_info($id);\n\n        my $cal_date = date_this(\n            -Packed_Date => $archive->_massaged_key($id),\n            -All         => 1\n        );\n\n        my $nav_table = $archive->make_nav_table(\n            -Id       => $id,\n            -List     => $ls->param('list'),\n            -Function => \"admin\"\n        );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'view_archive_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    id      => $id,\n                    subject => $subject,\n                    date    => $cal_date,\n                    can_display_message_source =>\n                      $archive->can_display_message_source,\n                    nav_table => $nav_table,\n\t\t\t\t\tPLUGINS_ENABLED_tracker => $DADA::Config::PLUGINS_ENABLED->{tracker},\n\t\t\t\t\t\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub display_message_source {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'display_message_source'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n\n    my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n    if ( $la->check_if_entry_exists( $q->param('id') ) ) {\n\n        if ( $la->can_display_message_source ) {\n\n            $self->header_props( { -type => 'text/plain' } );\n            return $la->message_source( $q->param('id') );\n\n        }\n        else {\n\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => \"no_support_for_displaying_message_source\"\n                }\n            );\n        }\n\n    }\n    else {\n        return user_error( { -list => $list, -error => \"no_archive_entry\" } );\n    }\n\n}\n\nsub delete_archive {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'delete_archive'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list    = $admin_list;\n    my @address = $q->multi_param(\"address\");\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n\n    my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n    $archive->delete_archive(@address);\n\n    $self->header_type('redirect');\n    $self->header_props(\n        -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n\n}\n\nsub purge_all_archives {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'purge_all_archives'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n    my $ah = DADA::MailingList::Archives->new( { -list => $list } );\n\n    $ah->delete_all_archive_entries();\n\n    $self->header_type('redirect');\n    $self->header_props(\n        -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n\n}\n\nsub archive_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'archive_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $can_use_captcha = can_use_Google_reCAPTCHA();\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'archive_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -expr => 1,\n                -vars => {\n                    screen          => 'archive_options',\n                    title           => 'Archive Options',\n                    root_login      => $root_login,\n                    list            => $list,\n                    done            => $done,\n                    can_use_captcha => $can_use_captcha,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    show_archives                          => 0,\n                    archives_available_only_to_subscribers => 0,\n                    archive_messages                       => 0,\n                    archive_subscribe_form                 => 0,\n                    archive_search_form                    => 0,\n                    archive_send_form                      => 0,\n                    captcha_archive_send_form              => 0,\n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=archive_options&done=1' );\n    }\n}\n\nsub adv_archive_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'adv_archive_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n    my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my @index_this = (\n            $ls->param('archive_index_count'),\n            1 .. 10, 15, 20, 25, 30, 40, 50, 75, 100\n        );\n\n        require HTML::Menu::Select;\n        my $archive_index_count_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => 'archive_index_count',\n                id    => 'archive_index_count',\n                value => [@index_this],\n            }\n        );\n\t\t\n\t\t\n\t\tmy $remove_after_timespan_vals = [\n\t\t'1m',\n\t\t'2m',\n\t\t'3m',\n\t\t'4m',\n\t\t'5m',\n\t\t'6m',\n\t\t'7m',\n\t\t'8m',\n\t\t'9m',\n\t\t'10m',\n\t\t'11m',\n\t\t'1y',\n\t\t'2y',\n\t\t'3y',\n\t\t'4y',\n\t\t'5y'];\n\t\n\t\tmy $remove_after_timespan_ops = { \n\t\t\t'1m'  => '1 month',\n\t\t\t'2m'  => '2 months',\n\t\t\t'3m'  => '3 months',\n\t\t\t'4m'  => '4 months',\n\t\t\t'5m'  => '5 months',\n\t\t\t'6m'  => '6 months',\n\t\t\t'7m'  => '7 months',\n\t\t\t'8m'  => '8 months',\n\t\t\t'9m'  => '9 months',\n\t\t\t'10m' => '10 months',\n\t\t\t'11m' => '11 months',\n\t\t\t'1y'  => '1 year',\n\t\t\t'2y'  => '2 years',\n\t\t\t'3y'  => '3 years',\n\t\t\t'4y'  => '4 years',\n\t\t\t'5y'  => '5 years',\n\t\t};\n\t\tmy $archive_auto_remove_after_timespan_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => 'archive_auto_remove_after_timespan',\n                id    => 'archive_auto_remove_after_timespan',\n                values => $remove_after_timespan_vals,\n\t\t\t\tlabels => $remove_after_timespan_ops, \n\t\t\t\tdefault => $ls->param('archive_auto_remove_after_timespan'), \n\t\t\t}\n        );\n\n        my $ping_sites = [];\n        for (@DADA::Config::PING_URLS) {\n\n            push(\n                @$ping_sites,\n                {\n\n                    ping_url => $_\n                }\n            );\n        }\n\n        my $can_use_xml_rpc = 1;\n\n        eval { require XMLRPC::Lite };\n        if ($@) {\n            $can_use_xml_rpc = 0;\n        }\n\n        my $can_use_html_scrubber = 1;\n        try {\n            require HTML::Scrubber;\n        }\n        catch {\n            carp \"HTML::Scrubber not working correctly?:\" . substr($_, 0, 100) . '...';\n            $can_use_html_scrubber = 0;\n        };\n\n        my $gravatar_img_url     = '';\n        my $can_use_gravatar_url = 1;\n        try {\n            require Gravatar::URL;\n        }\n        catch {\n            $can_use_gravatar_url = 0;\n        };\n\n        if ( $can_use_gravatar_url == 1 ) {\n            $gravatar_img_url = gravatar_img_url(\n                {\n                    -email                => $ls->param('list_owner_email'),\n                    -default_gravatar_url => $ls->param('default_gravatar_url'),\n                }\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'adv_archive_options_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen                                  => 'adv_archive_options',\n                    title                                   => 'Advanced Options',\n                    root_login                              => $root_login,\n                    done                                    => $done,\n                    archive_index_count_menu                => $archive_index_count_menu,\n                    list                                    => $list,\n                    ping_sites                              => $ping_sites,\n                    can_use_xml_rpc                         => $can_use_xml_rpc,\n                    can_use_html_scrubber                   => $can_use_html_scrubber,\n                    can_display_attachments                 => $la->can_display_attachments,\n                    can_use_gravatar_url                    => $can_use_gravatar_url,\n                    gravatar_img_url                        => $gravatar_img_url,\n\t\t\t\t\tarchive_auto_remove_after_timespan_menu => $archive_auto_remove_after_timespan_menu, \n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    sort_archives_in_reverse           => 0,\n                    archive_show_year                  => 0,\n                    archive_show_month                 => 0,\n                    archive_show_day                   => 0,\n                    archive_show_hour_and_minute       => 0,\n                    archive_show_second                => 0,\n                    archive_index_count                => 10,\n                    publish_archives_rss               => 0,\n                    ping_archives_rss                  => 0,\n                    html_archives_in_iframe            => 0,\n                    disable_archive_js                 => 0,\n                    style_quoted_archive_text          => 0,\n                    display_attachments                => 0,\n                    add_subscribe_form_to_feeds        => 0,\n                    add_social_bookmarking_badges      => 0,\n                    archive_protect_email              => undef,\n                    enable_gravatars                   => 0,\n                    default_gravatar_url               => '',\n\t\t\t\t\tarchive_auto_remove                => 0,\n\t\t\t\t\tarchive_auto_remove_after_timespan => 0, \n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=adv_archive_options&done=1' );\n    }\n}\n\nsub edit_archived_msg {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    require DADA::Template::HTML;\n    require DADA::MailingList::Settings;\n\n    require DADA::MailingList::Archives;\n\n    require DADA::Mail::Send;\n\n    require MIME::Parser;\n\n    my $parser = new MIME::Parser;\n    $parser = optimize_mime_parser($parser);\n\n    my $skel = [];\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_archived_msg'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $ls   = DADA::MailingList::Settings->new( { -list => $list } );\n    my $mh   = DADA::Mail::Send->new(\n        {\n            -list   => $list,\n            -ls_obj => $ls,\n        }\n    );\n    my $ah = DADA::MailingList::Archives->new( { -list => $list } );\n\n    edit_archived_msg_main();\n\n    #---------------------------------------------------------------------#\n\n    sub edit_archived_msg_main {\n\n        if ( $q->param('process') eq 'prefs' ) {\n            return prefs();\n        }\n        else {\n\n            if ( $q->param('process') ) {\n                return edit_archive();\n            }\n            else {\n                return view();\n            }\n        }\n    }\n\n    sub view {\n\n        require HTML::Menu::Select;\n        my $D_Content_Types = [ 'text/plain', 'text/html' ];\n\n        my %Headers_To_Edit;\n\n        my $parser = new MIME::Parser;\n        $parser = optimize_mime_parser($parser);\n\n        my $id = $q->param('id');\n\n        if ( !$id ) {\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n        }\n\n        if ( $ah->check_if_entry_exists($id) <= 0 ) {\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n        }\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $ah->get_archive_info($id);\n\n        # do I need this?\n        $raw_msg ||= $ah->_bs_raw_msg( $subject, $message, $format );\n        $raw_msg =~ s/Content\\-Type/Content-type/;\n        $raw_msg = safely_encode($raw_msg);\n\n        my $entity;\n        eval { $entity = $parser->parse_data($raw_msg); };\n\n        my $form_blob = '';\n        make_skeleton($entity);\n\n        for ( split( ',', $ls->param('editable_headers') ) ) {\n            $Headers_To_Edit{$_} = 1;\n        }\n\n        for my $tb (@$skel) {\n\n            my @c = split( '-', $tb->{address} );\n            my $bqc = $#c - 1;\n\n            for ( 0 .. $bqc ) {\n                $form_blob .=\n'<div style=\"padding-left: 30px; border-left:1px solid #ccc\">';\n            }\n\n            if ( $tb->{address} eq '0' ) {\n                $form_blob .= '<table  width=\"100%\">';\n\n                # head of the message!\n                my %headers =\n                  $mh->return_headers( $tb->{entity}->head->original_text );\n                for my $h (@DADA::Config::EMAIL_HEADERS_ORDER) {\n                    if ( $headers{$h} ) {\n                        if ( $Headers_To_Edit{$h} == 1 ) {\n\n                            $form_blob .= qq{\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t <td>\n\t\t\t\t\t\t\t\t  <p>\n\t\t\t\t\t\t\t\t   <label for=\"$h\">\n\t\t\t\t\t\t\t\t\t$h: </label>\n\t\t\t\t\t\t\t\t  </p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"99%\">\n\t\t\t\t\t\t\t};\n\n                            if (   $DADA::Config::ARCHIVE_DB_TYPE eq 'Db'\n                                && $h eq 'Content-type' )\n                            {\n                                push( @{$D_Content_Types}, $headers{$h} );\n                                $form_blob .= $q->p(\n                                    HTML::Menu::Select::popup_menu(\n                                        {\n                                            values  => $D_Content_Types,\n                                            id      => $h,\n                                            name    => $h,\n                                            default => $headers{$h}\n                                        }\n                                    )\n                                );\n                            }\n                            else {\n                                my $value = $headers{$h};\n                                if ( $h =~ m/To|From|Cc|Reply\\-To|Subject/ ){\n                                    $value = $ah->_decode_header($value);\n                                }\n\t\t\t\t\t\t\t\t$form_blob .= $q->p(\n                                \t$q->textfield(\n\t                                    -value => $value,\n\t                                    -id    => $h,\n\t                                    -name  => $h,\n\t                                    -class => 'full'\n                                \t)\n\t\t\t\t\t\t\t\t);\n                            }\n                            $form_blob .= '</td></tr>';\n                        }\n\n                    }\n\n                }\n                $form_blob .= '</table>';\n            }\n            my ( $type, $subtype ) =\n              split( '/', $tb->{entity}->head->mime_type );\n\n            $form_blob .= $q->p( $q->strong('Content Type: '),\n                $tb->{entity}->head->mime_type );\n\n            if ( $tb->{body} ) {\n\n                if (   $type =~ /^(text|message)$/\n                    && $tb->{entity}->head->get('content-disposition') !~\n                    m/attach/i )\n                {    # text: display it...\n\n                    # Needs to be WYSIWYG Editor-ized\n                    $form_blob .= $q->p(\n                        $q->textarea(\n                            -value => safely_decode(\n                                $tb->{entity}->bodyhandle->as_string\n                            ),\n                            -rows => 15,\n                            -name => $tb->{address}\n                        )\n                    );\n\n                }\n                else {\n\n                    $form_blob .=\n                      '<div style=\"border: 1px solid #000;padding: 5px\">';\n\n                    my $name =\n                         $tb->{entity}->head->mime_attr(\"content-type.name\")\n                      || $tb->{entity}\n                      ->head->mime_attr(\"content-disposition.filename\");\n\n                    my $attachment_url;\n\n                    if ($name) {\n                        $attachment_url =\n                            $DADA::Config::S_PROGRAM_URL\n                          . '?flavor=file_attachment&list='\n                          . $list . '&id='\n                          . $id\n                          . '&filename='\n                          . $name\n                          . '&mode=inline';\n                    }\n                    else {\n\n                        $name = 'Untitled.';\n\n                        my $m_cid = $tb->{entity}->head->get('content-id');\n                        $m_cid =~ s/^\\<|\\>$//g;\n\n                        $attachment_url =\n                            $DADA::Config::S_PROGRAM_URL\n                          . '?flavor=show_img&list='\n                          . $list . '&id='\n                          . $id . '&cid='\n                          . $m_cid;\n\n                    }\n\n                    $form_blob .= $q->p(\n                        $q->strong('Attachment: '),\n                        $q->a(\n                            { -href => $attachment_url, -target => '_blank' },\n                            $name\n                        )\n                    );\n\n                    $form_blob .= '<table  style=\"padding:5px\">';\n\n                    $form_blob .= '<tr><td>';\n\n                    if ( $type =~ /^image/ && $subtype =~ m/gif|jpg|jpeg|png/ )\n                    {\n                        $form_blob .= $q->p(\n                            $q->a(\n                                {\n                                    -href   => $attachment_url,\n                                    -target => '_blank'\n                                },\n                                $q->img(\n                                    {\n                                        -src   => $attachment_url,\n                                        -width => '100'\n                                    }\n                                )\n                            )\n                        );\n                    }\n                    else {\n\n#$form_blob .=  $q->p($q->a({-href => $attachment_url, -target => '_blank'}, $q->strong('Attachment: ' ), $q->a({-href => $attachment_url, -target => '_blank'}, $name)));\n                    }\n                    $form_blob .= '</td><td>';\n\n                    $form_blob .= $q->p(\n                        $q->checkbox(\n                            -name  => 'delete_' . $tb->{address},\n                            -id    => 'delete_' . $tb->{address},\n                            -value => 1,\n                            -label => ''\n                        ),\n                        $q->label(\n                            { '-for' => 'delete_' . $tb->{address} },\n                            'Remove From Message'\n                        )\n                    );\n                    $form_blob .= $q->p( $q->strong('Update:'),\n                        $q->filefield( -name => 'upload_' . $tb->{address} ) );\n\n                    $form_blob .= '</td></tr></table>';\n\n                    $form_blob .= '</div>';\n\n                }\n            }\n\n            for ( 0 .. $bqc ) {\n                $form_blob .= '</div>';\n            }\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_archived_msg.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    subject => $subject,\n                    big_blob_of_form_widgets_to_edit_an_archived_message =>\n                      $form_blob,\n                    can_display_message_source =>\n                      $ah->can_display_message_source,\n                    id   => $id,\n                    done => scalar $q->param('done'),\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n\n                },\n            }\n        );\n        return $scrn;\n    }\n\n    sub prefs {\n\n        if ( $q->param('process_prefs') ) {\n\n            my $the_id = $q->param('id');\n\n            my $editable_headers = join( ',', $q->param('editable_header') );\n            $ls->save(\n                {\n                    -settings => {\n                        editable_headers => $editable_headers,\n                    }\n                }\n            );\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=edit_archived_msg&process=prefs&done=1&id='\n                  . $the_id );\n\n        }\n        else {\n\n            my %editable_headers;\n            $editable_headers{$_} = 1\n              for ( split( ',', $ls->param('editable_headers') ) );\n\n            my $edit_headers_menu = [];\n            for (@DADA::Config::EMAIL_HEADERS_ORDER) {\n\n                push( @$edit_headers_menu,\n                    { name => $_, editable => $editable_headers{$_} } );\n            }\n\n            my $the_id = $q->param('id');\n            my $done   = $q->param('done');\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'edit_archived_msg_prefs_screen.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -vars => {\n                        edit_headers_menu => $edit_headers_menu,\n                        done              => $done,\n                        id                => $the_id,\n                    },\n                }\n            );\n            return $scrn;\n        }\n\n    }\n\n    sub edit_archive {\n\n        my $id = $q->param('id');\n\n        my $parser = new MIME::Parser;\n        $parser = optimize_mime_parser($parser);\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $ah->get_archive_info($id);\n\n        $raw_msg ||= $ah->_bs_raw_msg( $subject, $message, $format );\n        $raw_msg =~ s/Content\\-Type/Content-type/;\n        $raw_msg = safely_encode($raw_msg);\n\n        my $entity;\n\n        eval { $entity = $parser->parse_data($raw_msg) };\n\n        my $throwaway = undef;\n\n        ( $entity, $throwaway ) = edit($entity);\n\n        # not sure if this, \"if\" is needed.\n        if ( $DADA::Config::ARCHIVE_DB_TYPE eq 'Db' ) {\n            $ah->set_archive_info(\n                $id,\n                $entity->head->get( 'Subject', 0 ),\n                undef,\n                $entity->head->get( 'Content-type', 0 ),\n                safely_decode( $entity->as_string )\n            );\n        }\n        else {\n\n            $ah->set_archive_info( $id, $entity->head->get( 'Subject', 0 ),\n                undef, undef, safely_decode( $entity->as_string ) );\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=edit_archived_msg&id='\n              . $id\n              . '&done=1' );\n\n    }\n\n    sub make_skeleton {\n\n        my ( $entity, $name ) = @_;\n        defined($name) or $name = \"0\";\n\n        my $IO;\n\n        # Output the body:\n        my @parts = $entity->parts;\n        if (@parts) {\n\n            push( @$skel, { address => $name, entity => $entity } );\n\n            # multipart...\n            my $i;\n            for $i ( 0 .. $#parts ) {    # dump each part...\n                make_skeleton( $parts[$i], ( \"$name\\-\" . ($i) ) );\n            }\n\n        }\n        else {                           # single part...\n            push( @$skel, { address => $name, entity => $entity, body => 1 } );\n\n        }\n    }\n\n    sub edit {\n\n        my ( $entity, $name ) = @_;\n        defined($name) or $name = \"0\";\n        my $IO;\n\n        my %Headers_To_Edit;\n\n        if ( $name eq '0' ) {\n\n            for ( split( ',', $ls->param('editable_headers') ) ) {\n                $Headers_To_Edit{$_} = 1;\n            }\n\n            require DADA::App::FormatMessages;\n            my $fm = DADA::App::FormatMessages->new( -List => $list );\n\n            for my $h (@DADA::Config::EMAIL_HEADERS_ORDER) {\n                if ( $Headers_To_Edit{$h} == 1 ) {\n                    my $value = $q->param($h);\n\n                    # Dum, what to do here?\n                    if ( $h =~ m/To|From|Cc|Reply\\-To|Subject/ ) {\n                        $value = $fm->_encode_header( $h, $value );\n                    }\n                    $entity->head->replace( $h, $value );\n                }\n            }\n        }\n\n        my @parts = ();\n        if ( defined($entity) ) {\n            @parts = $entity->parts;\n        }\n        else {\n\n            #...\n        }\n\n        if (@parts) {\n\n            my %ditch = ();\n\n            # multipart...\n            my $i;\n            for $i ( 0 .. $#parts ) {\n                my $name_is;\n                ( $parts[$i], $name_is ) =\n                  edit( $parts[$i], ( \"$name\\-\" . ($i) ) );\n\n                if ( $q->param( 'delete_' . $name_is ) == 1 ) {\n                    $ditch{$i} = 1;\n\n                }\n                else {\n                    $ditch{$i} = 0;\n                }\n            }\n\n            my @new_parts;\n            my $ii;\n            for $ii ( 0 .. $#parts ) {\n                if ( $ditch{$ii} == 1 ) {\n\n                    # don't push it.\n                }\n                else {\n\n                    push( @new_parts, $parts[$ii] );\n                }\n            }\n\n            $entity->parts( \\@new_parts );\n\n            $entity->sync_headers(\n                'Length'      => 'COMPUTE',\n                'Nonstandard' => 'ERASE'\n            );\n\n        }\n        else {\n            if ( $q->param( 'delete_' . $name ) == 1 ) {\n\n                # Well, just leave it alone!\n                return ( $entity, $name );\n            }\n            else {\n\n                # Uh, this means it's some sort of text, apparrently.\n                my $content = $q->param($name);\n                $content =~ s/\\r\\n/\\n/g;\n                if ($content) {\n\n                    # DEV: encoding?\n                    my $body = $entity->bodyhandle;\n                    my $io   = $body->open('w');\n                    $io->print($content);\n                    $io->close;\n                }\n                else {\n                    my $body = $entity->bodyhandle;\n                    my $io   = $body->open('w');\n                    $io->print('!!!DELETE PART!!!');\n                    $io->close;\n\n                    # This is what should do the actual deleting.\n                    $q->param( 'delete_' . $name, 1 );\n                }\n\n                my $cid;\n                $cid = $entity->head->get('content-id') || undef;\n                if ( $q->param( 'upload_' . $name ) ) {\n                    $entity = get_from_upload( $name, $cid,\n                        $entity->head->get('content-disposition') );\n                }\n\n                $entity->sync_headers(\n                    'Length'      => 'COMPUTE',\n                    'Nonstandard' => 'ERASE'\n                );\n\n                return ( $entity, $name );\n            }\n        }\n\n        return ( $entity, $name );\n\n    }\n\n    sub get_from_upload {\n\n        my $name        = shift;\n        my $cid         = shift;\n        my $disposition = shift || 'attachment';\n\n        my $filename = $self->file_upload( 'upload_' . $name );\n        my $data;\n\n        my $nice_filename = $q->param( 'upload_' . $name );\n\n        require MIME::Entity;\n        my $ent = MIME::Entity->build(\n            Path        => $filename,\n            Filename    => $nice_filename,\n            Encoding    => \"base64\",\n            Disposition => $disposition,\n            Type        => find_attachment_type($filename),\n            Id          => $cid,\n        );\n        return $ent;\n\n    }\n\n}\n\nsub html_code {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $jquery_head_code = DADA::Template::Widgets::screen(\n        {\n            -screen                   => 'jquery_subscription_form_head.tmpl',\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    my $jquery_body_code = DADA::Template::Widgets::screen(\n        {\n            -screen => 'jquery_subscription_form_body.tmpl',\n            -vars   => {\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    {\n                        -list          => $list,\n                        -ignore_cgi    => 1,\n                        -show_fieldset => 0,\n                        -subscription_form_id => 'dada_mail_modal_subscription_form'\n                    }\n                )\n            }\n        }\n    );\n\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'html_code_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                screen            => 'html_code',\n                list              => $list,\n                jquery_head_code  => $jquery_head_code,\n                jquery_body_code  => $jquery_body_code,\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    { \n\t\t\t\t\t\t-list => $list, \n\t\t\t\t\t\t-ignore_cgi => 1, \n\t\t\t\t\t\t-show_fieldset => 0, \n\t\t\t\t\t\t-add_recaptcha_js => 1,\n\t\t\t\t\t}\n                ),\n                minimal_subscription_form =>\n                  DADA::Template::Widgets::subscription_form(\n                    {\n                        -list          => $list,\n                        -form_type     => 'minimal',\n                        -ignore_cgi    => 1,\n                        -show_fieldset => 0,\n\t\t\t\t\t\t-add_recaptcha_js => 1,\n\t\t\t\t\t\t\n                    }\n                  ),\n\t\t\t\t  form_fields_example =>\n                  DADA::Template::Widgets::subscription_form(\n                    {\n                        -list          => $list,\n                        -form_type     => 'form_fields_example',\n                        -ignore_cgi    => 1,\n                        -show_fieldset => 0,\n\t\t\t\t\t\t-add_recaptcha_js => 1,\n                    }\n                  ),\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub preview_subscription_form { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        { \n\t\t\t-list             => $list, \n\t\t\t-ignore_cgi       => 1, \n\t\t\t-show_fieldset    => 0, \n\t\t\t-add_recaptcha_js => 1,\n\t\t}\n    );\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_subscription_form_screen.tmpl',\n            -vars   => {\n               subscription_form => $subscription_form, \n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\nsub preview_modal_subscribe_landing_code { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_modal_subscribe_landing_code_screen.tmpl',\n            -vars   => {},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\n\nsub preview_minimal_subscription_form { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n    my $minimal_subscription_form = DADA::Template::Widgets::subscription_form(\n        { \n\t\t\t-list             => $list, \n\t\t\t-ignore_cgi       => 1, \n\t\t\t-show_fieldset    => 0, \n\t\t\t-add_recaptcha_js => 1,\n\t\t\t-form_type        => 'minimal',\n\t\t}\n    );\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_minimal_subscription_form_screen.tmpl',\n            -vars   => {\n               minimal_subscription_form => $minimal_subscription_form,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\n\n\nsub preview_jquery_plugin_subscription_form {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $jquery_subscription_form_body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'jquery_subscription_form_body.tmpl',\n            -vars   => {\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    {\n                        -list                 => $list,\n                        -ignore_cgi           => 1,\n                        -show_fieldset        => 0,\n                        -subscription_form_id => 'dada_mail_modal_subscription_form', \n  \t\t\t\t\t\t-add_recaptcha_js     => 0,\n                    }\n                )\n            }\n        }\n    );\n\n    my $jquery_subscription_form_head = DADA::Template::Widgets::screen(\n        {\n            -screen                   => 'jquery_subscription_form_head.tmpl',\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_jquery_plugin_subscription_form.tmpl',\n            -vars   => {\n                jquery_subscription_form_head => $jquery_subscription_form_head,\n                jquery_subscription_form_body => $jquery_subscription_form_body,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub edit_template {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('don') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_template'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $raw_template     = DADA::Template::HTML::default_template();\n    my $default_template = default_template(\n        {\n            -Use_Custom => 0\n        }\n    );\n\n    if ( !$process ) {\n\t\t\n\t\t# This test is pretty primative. \n\t\t\n        my $content_tag_found_in_template         = 0;\n        my $content_tag_found_in_url_template     = 0;\n        my $content_tag_found_in_default_template = 0;\n\n        my $header_content_tag_found_in_template         = 0;\n        my $header_content_tag_found_in_url_template     = 0;\n        my $header_content_tag_found_in_default_template = 0;\n\t\t\n        my $content_tag        = quotemeta('<!-- tmpl_var content -->');\n        my $header_content_tag = quotemeta('<!-- tmpl_var header_content -->');\n\n        if (   $DADA::Config::TEMPLATE_OPTIONS->{user}->{enabled} == 1\n            && $DADA::Config::TEMPLATE_OPTIONS->{user}->{mode} eq 'magic' )\n        {\n            if ( $raw_template =~ m/$content_tag/ ) {\n                $content_tag_found_in_default_template = 1;\n            }\n            else {\n\t\t\t\t# srsrly wtf: \n                my $list_template_body_code_block =\n                  DADA::Template::Widgets::_raw_screen(\n                    {\n                        -screen => 'list_template_body_code_block.tmpl'\n                    }\n                  );\n                if ( $list_template_body_code_block =~ m/$content_tag/ ) {\n                    $content_tag_found_in_default_template = 1;\n                }\n            }\n        }\n        else {\n            if ( $raw_template =~ m/$content_tag/ ) {\n                $content_tag_found_in_default_template = 1;\n            }\n            if ( $raw_template =~ m/$header_content_tag/ ) {\n                $header_content_tag_found_in_default_template = 1;\n            }\n        }\n\n        # .tmpl\n\n        my $edit_this_template = $default_template . \"\\n\";\n        if ( check_if_template_exists( -List => $list ) >= 1 ) {\n            $edit_this_template = open_template( -List => $list ) . \"\\n\";\n        }\n        if ( $edit_this_template =~ m/$content_tag/ ) {\n            $content_tag_found_in_template = 1;\n        }\n\t\t\n        if ( $edit_this_template =~ m/$header_content_tag/ ) {\n            $header_content_tag_found_in_template = 1;\n        }\n\n        my $get_template_data_from_default_template = 0;\n        $get_template_data_from_default_template = 1\n          if $ls->param('get_template_data') eq 'from_default_template';\n\n        my $get_template_data_from_template_file = 0;\n        $get_template_data_from_template_file = 1\n          if $ls->param('get_template_data') eq 'from_template_file';\n\n        my $get_template_data_from_url = 0;\n        $get_template_data_from_url = 1\n          if $ls->param('get_template_data') eq 'from_url';\n\n        my $can_use_lwp_simple;\n        eval { require LWP::Simple; };\n        $can_use_lwp_simple = 1\n          if !$@;\n\n        my $template_saved = 0;\n        if ( -e $DADA::Config::TEMPLATES . '/' . $list . '.template' ) {\n            $template_saved = 1;\n        }\n        my $template_url_check = 1;\n\n        if ( $get_template_data_from_url == 1 ) {\n\n            if ( $can_use_lwp_simple == 1 ) {\n                eval {\n                    $LWP::Simple::ua->agent( 'Mozilla/5.0 (compatible; '\n                          . $DADA::CONFIG::PROGRAM_NAME\n                          . ')' );\n                };\n                if ( LWP::Simple::get( $ls->param('url_template') ) ) {\n                    my $tmp_tmpl =\n                      LWP::Simple::get( $ls->param('url_template') );\n                    if ( $tmp_tmpl =~ m/$content_tag/ ) {\n                        $content_tag_found_in_url_template = 1;\n                    }\n\t\t\t\t\t\n                    if ( $tmp_tmpl =~ m/$header_content_tag/ ) {\n                        $header_content_tag_found_in_url_template = 1;\n                    }\n\t\t\t\t\t\n                }\n                else {\n\n                    $template_url_check = 0;\n\n                }\n            }\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_template_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen                     => 'edit_template',\n                    done                       => $done,\n                    root_login                 => $root_login,\n                    edit_this_template         => $edit_this_template,\n                    get_template_data_from_url => $get_template_data_from_url,\n                    get_template_data_from_template_file =>\n                      $get_template_data_from_template_file,\n                    get_template_data_from_default_template =>\n                      $get_template_data_from_default_template,\n                    can_use_lwp_simple => $can_use_lwp_simple,\n                    default_template   => $default_template,\n                    template_url_check => $template_url_check,\n                    template_saved     => $template_saved,\n                    content_tag_found_in_template =>\n                      $content_tag_found_in_template,\n                    content_tag_found_in_url_template =>\n                      $content_tag_found_in_url_template,\n                    content_tag_found_in_default_template =>\n                      $content_tag_found_in_default_template,\n\t\t\t\t\t  \n\t\t\t\t  header_content_tag_found_in_template     => $header_content_tag_found_in_template,\n\t\t\t\t  header_content_tag_found_in_url_template => $header_content_tag_found_in_url_template,\n\t\t\t\t\t  \n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        if ( $process eq \"preview template\" ) {\n\n            my $template_info;\n            my $test_header;\n            my $test_footer;\n\n            if ( $q->param('get_template_data') eq 'from_default_template' ) {\n                $template_info = $raw_template;\n            }\n            elsif ( $q->param('get_template_data') eq 'from_url' ) {\n                eval { require LWP::Simple; };\n                if ( !$@ ) {\n                    eval {\n                        $LWP::Simple::ua->agent( 'Mozilla/5.0 (compatible; '\n                              . $DADA::CONFIG::PROGRAM_NAME\n                              . ')' );\n                    };\n                    $template_info =\n                      LWP::Simple::get( $q->param('url_template') );\n                }\n            }\n            else {\n                $template_info = $q->param(\"template_info\");\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen                   => 'preview_template.tmpl',\n                    -with                     => 'list',\n                    -wrapper_params           => { -data => \\$template_info, },\n                    -vars                     => { title => 'Preview', },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n            return $scrn;\n        }\n        else {\n\n            my $template_info = $q->param(\"template_info\");\n\n            $ls->save_w_params(\n                {\n                    -associate => $q,\n                    -settings  => {\n                        url_template      => '',\n                        get_template_data => '',\n                    }\n                }\n            );\n\n            make_template( { -List => $list, -Template => $template_info } );\n\n            $c->flush;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=edit_template&done=1' );\n\n        }\n    }\n}\n\n\nsub edit_type {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) = check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_type'\n    );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::App::FormatMessages;\n    my $dfm = DADA::App::FormatMessages->new( -List => $list );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_type_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen => 'edit_type',\n                    title  => 'Email Templates',\n\t\t\t\t\troot_login => $root_login, \n                    done   => $done,\n\n                    unsub_link_found_in_pt_mlm =>\n                      $dfm->can_find_unsub_link( { -str => $ls->param('mailing_list_message') } ),\n                    unsub_link_found_in_html_mlm =>\n                      $dfm->can_find_unsub_link( { -str => $ls->param('mailing_list_message_html') } ),\n                    message_body_tag_found_in_pt_mlm =>\n                      $dfm->can_find_message_body_tag( { -str => $ls->param('mailing_list_message') } ),\n                    message_body_tag_found_in_html_mlm =>\n                      $dfm->can_find_message_body_tag( { -str => $ls->param('mailing_list_message_html') } ),\n                },\n                -list_settings_vars       => $ls->get( -all_settings => 1 ),\n                -list_settings_vars_param => { -dot_it               => 1, },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        for (\n            qw(\n            mailing_list_message_from_phrase\n            mailing_list_message_to_phrase\n            mailing_list_message_subject\n            mailing_list_message\n            mailing_list_message_html\n            )\n          )\n        {\n\n            # a very odd place to put this, but, hey,  easy enough.\n            if ( $q->param('revert') ) {\n                $q->delete($_);\n            }\n            else {\n                my $tmp_setting = $q->param($_);\n                   $tmp_setting =~ s/\\r\\n/\\n/g;\n                   $q->param( $_, $tmp_setting );\n            }\n        }\n\n\t\tmy $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    mailing_list_message_from_phrase            => undef,\n                    mailing_list_message_to_phrase              => undef,\n                    mailing_list_message_subject                => undef,\n                    mailing_list_message                        => undef,\n                    mailing_list_message_html                   => undef,\n                }, \n\t\t\t\t-also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?flavor=edit_type&done=1' );\n    }\n}\n\n\n\nsub back_link {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'back_link'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'back_link_screen.tmpl',\n                -list           => $list,\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen => 'back_link',\n                    done =>\n                      ( ( $q->param('done') ) ? ( $q->param('done') ) : (0) ),\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    back_link_website_name => '',\n                    back_link_website_url  => '',\n                }\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props(\n            -url => $DADA::Config::S_PROGRAM_URL . '?flavor=back_link&done=1' );\n\n    }\n}\n\n\nsub email_themes  { \n\n\tmy $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my $done = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'email_themes'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\t\t\n\t\t\n\t\trequire DADA::App::EmailThemes; \n\t\tmy $dap = DADA::App::EmailThemes->new({-list => $list});\n\t\tmy $at = $dap->available_themes(); \n\t\tmy $at_labels = {}; \n\t\tforeach(@$at){ \n\t\t\tmy $l = $_; \n\t\t\t$l =~ s/_/ /g; \n\t\t\t$l = join \" \", map {ucfirst} split \" \", $l;\n\t\t\t$at_labels->{$_} = $l;\n\t\t}\n\t\t\n\t\tmy $default_theme = $ls->param('email_theme_name') || 'default';\n\t\t\n        require HTML::Menu::Select;\n\t\tmy $email_theme_name_widget = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'email_theme_name',\n                id      => 'email_theme_name',\n                default => $default_theme,\n                labels  => $at_labels,\n                values => $at,\n            }\n          );\n\t\t  \n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'email_themes_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen     => 'email_themes',\n                    title      => 'Email Themes',\n                    root_login => $root_login,\n                    done       => $done,\n\t\t\t\t\temail_theme_name_widget => $email_theme_name_widget, \n                },\n                -list_settings_vars       => $ls->get( -all_settings => 1 ),\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\t\t\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    email_theme_name         => undef,\n                }, \n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=email_themes&done=1' );\n    }\n}\n\n\n\nsub edit_html_type {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my $done = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_html_type'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        #use Data::Dumper;\n        #die Dumper($ls->get(-dotted => 1, -all_settings => 1));\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_html_type_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen     => 'edit_html_type',\n                    title      => 'HTML Screen Templates',\n                    root_login => $root_login,\n                    done       => $done,\n                },\n                -list_settings_vars       => $ls->get( -all_settings => 1 ),\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        for (\n            qw(\n            html_confirmation_message\n            html_subscribed_message\n            html_subscription_request_message\n            html_unsubscribed_message\n            )\n          )\n        {\n            my $tmp_setting = $q->param($_);\n            $tmp_setting =~ s/\\r\\n/\\n/g;\n            $q->param( $_, $tmp_setting );\n        }\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n\t\t\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    html_confirmation_message         => '',\n                    html_subscribed_message           => '',\n                    html_subscription_request_message => '',\n                    html_unsubscribed_message         => '',\n                },\n\t\t\t\t -also_save_for => $also_save_for_list,\n            },\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=edit_html_type&done=1' );\n    }\n}\n\nsub manage_script {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'manage_script'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list               = $admin_list;\n    my $more_info          = $q->param('more_info') || 0;\n    my $sendmail_locations = `whereis sendmail`;\n    my $curl_location      = `which curl`;\n    my $wget_location      = `which wget`;\n\n    my $at_incs = [];\n\n    for (@INC) {\n        if ( $_ !~ /^\\./ ) {\n            push( @$at_incs, { name => $_ } );\n        }\n    }\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'manage_script_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -list => $list,\n            -vars => {\n                more_info          => $more_info,\n                smtp_server        => $ls->param('smtp_server'),\n                server_software    => $q->server_software(),\n                operating_system   => $^O,\n                perl_version       => $],\n                sendmail_locations => $sendmail_locations,\n                at_incs            => $at_incs,\n                list_owner_email   => $ls->param('list_owner_email'),\n                curl_location      => $curl_location,\n                wget_location      => $wget_location,\n            },\n        }\n    );\n\n    return $scrn;\n\n}\n\nsub feature_set {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'feature_set'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Template::Widgets::Admin_Menu;\n\n    if ( !$process ) {\n\n        my $feature_set_menu =\n          DADA::Template::Widgets::Admin_Menu::make_feature_menu( $ls->get );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'feature_set_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    screen           => 'feature_set',\n                    done             => ( defined($done) ) ? 1 : 0,\n                    feature_set_menu => $feature_set_menu,\n                    disabled_screen_view_hide =>\n                      ( $ls->param('disabled_screen_view') eq 'hide' ) ? 1 : 0,\n                    disabled_screen_view_grey_out =>\n                      ( $ls->param('disabled_screen_view') eq 'grey_out' )\n                    ? 1\n                    : 0,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my @params = $q->param;\n        my %param_hash;\n        for (@params) {\n            next if $_ eq 'disabled_screen_view';    # special case.\n            $param_hash{$_} = $q->param($_);\n        }\n\n        my $save_set =\n          DADA::Template::Widgets::Admin_Menu::create_save_set( \\%param_hash );\n\n        my $disabled_screen_view     = $q->param('disabled_screen_view');\n        my $list_control_panel_style = $q->param('list_control_panel_style')\n          // 'top_bar';\n\n        $ls->save(\n            {\n                -settings => {\n                    admin_menu               => $save_set,\n                    disabled_screen_view     => $disabled_screen_view,\n                    list_control_panel_style => $list_control_panel_style,\n                }\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=feature_set&done=1' );\n\n    }\n}\n\n\n\nsub profile_fields {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'profile_fields'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::ProfileFieldsManager;\n    my $pfm = DADA::ProfileFieldsManager->new;\n\n    require DADA::Profile::Fields;\n    my $dpf = DADA::Profile::Fields->new;\n\n    if ( $dpf->can_have_subscriber_fields == 0 ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'profile_fields_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen => 'profile_fields',\n                    title  => 'Profile Fields',\n                    can_have_subscriber_fields =>\n                      $dpf->can_have_subscriber_fields,\n\n                },\n            }\n        );\n        return $scrn;\n    }\n\n    # But, if we do....\n    my $subscriber_fields = $pfm->fields;\n    my $fields_attr       = $pfm->get_all_field_attributes;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $field_status        = 1;\n    my $field_error_details = {\n        field_blank            => 0,\n        field_name_too_long    => 0,\n        slashes_in_field_name  => 0,\n        weird_characters       => 0,\n        quotes                 => 0,\n        field_exists           => 0,\n        spaces                 => 0,\n        field_is_special_field => 0,\n    };\n    my %flattened_field_errors = ();\n\n    my $edit_field = xss_filter( scalar $q->param('edit_field') );\n\n    my $field                = '';\n    my $fallback_field_value = '';\n    my $field_label          = '';\n    my $field_required       = 0;\n\n    if ( $edit_field == 1 ) {\n        $field                = xss_filter( scalar $q->param('field') );\n        $fallback_field_value = $fields_attr->{$field}->{fallback_value};\n        $field_label          = $fields_attr->{$field}->{label};\n        $field_required       = $fields_attr->{$field}->{required};\n    }\n    else {\n        $field = xss_filter( scalar $q->param('field') );\n        $fallback_field_value =\n          xss_filter( scalar $q->param('fallback_field_value') );\n        $field_label = xss_filter( scalar $q->param('field_label') );\n        $field_required = $q->param('field_required') || 0;\n        if ( $field_required ne \"1\" && $field_required ne \"0\" ) {\n            die \"field_required needs to be either 1, or 0!\";\n            $field_required = 0;\n        }\n    }\n\n    if ( !$root_login && defined($process) ) {\n        die \"You need to log into the list with the root pass to do that!\";\n    }\n    if ( $process eq 'edit_field_order' ) {\n        my $dir = $q->param('direction') || 'down';\n        $pfm->change_field_order(\n            {\n                -field     => $field,\n                -direction => $dir,\n            }\n        );\n        $c->flush;\n\n        $self->header_type('redirect');\n        $self->header_props(\n            -url => $DADA::Config::S_PROGRAM_URL . '?flavor=profile_fields' );\n\n    }\n    if ( $process eq 'delete_field' ) {\n        ###\n        $pfm->remove_field( { -field => $field } );\n        $c->flush;\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=profile_fields;deletion=1;working_field='\n              . $field\n              . ';field_changes=1' );\n\n    }\n    elsif ( $process eq 'add_field' ) {\n\n        ( $field_status, $field_error_details ) =\n          $pfm->validate_field_name( { -field => $field } );\n\n        if ( $field_status == 1 ) {\n            $pfm->add_field(\n                {\n                    -field          => $field,\n                    -fallback_value => $fallback_field_value,\n                    -label          => $field_label,\n                    -required       => $field_required,\n                }\n            );\n\n            $c->flush;\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=profile_fields;addition=1;working_field='\n                  . $field\n                  . ';field_changes=1' );\n\n        }\n        else {\n# Else, I guess for now, we'll show the template and have the errors print out there...\n            for (%$field_error_details) {\n                $flattened_field_errors{ 'field_error_' . $_ } =\n                  $field_error_details->{$_};\n            }\n\n        }\n    }\n    elsif ( $process eq 'edit_field' ) {\n\n        my $orig_field = xss_filter( scalar $q->param('orig_field') );\n\n        #old name\t\t\t# new name\n        if ( $orig_field eq $field ) {\n            ( $field_status, $field_error_details ) =\n              $pfm->validate_field_name(\n                { -field => $field, -skip => [qw(field_exists)] } );\n        }\n        else {\n            ( $field_status, $field_error_details ) =\n              $pfm->validate_field_name( { -field => $field } );\n        }\n        if ( $field_status == 1 ) {\n\n            $pfm->remove_field_attributes( { -field => $orig_field } );\n\n            if ( $orig_field eq $field ) {\n\n                # ...\n            }\n            else {\n                $pfm->edit_field_name(\n                    { -old_name => $orig_field, -new_name => $field } );\n                my $meta =\n                  $ls->param('tracker_update_profile_fields_ip_dada_meta');\n                if ( length($meta) > 4 ) {\n                    my $thawed_gip = $ls->_dd_thaw($meta);\n                    $thawed_gip->{$field} = $thawed_gip->{$orig_field};\n                    delete( $thawed_gip->{$orig_field} );\n                    $ls->save(\n                        {\n                            -settings => {\n                                tracker_update_profile_fields_ip_dada_meta =>\n                                  $ls->_dd_freeze($thawed_gip)\n                            }\n                        }\n                    );\n                }\n            }\n            $pfm->save_field_attributes(\n                {\n                    -field          => $field,\n                    -fallback_value => $fallback_field_value,\n                    -label          => $field_label,\n                    -required       => $field_required,\n                }\n            );\n            $c->flush;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=profile_fields;edited=1;working_field='\n                  . $field\n                  . ';field_changes=1' );\n        }\n        else {\n# Else, I guess for now, we'll show the template and have the errors print out there...\n            $edit_field = 1;\n            $field      = xss_filter( scalar $q->param('orig_field') );\n\n            for (%$field_error_details) {\n                $flattened_field_errors{ 'field_error_' . $_ } =\n                  $field_error_details->{$_};\n            }\n        }\n    }\n\n    my $can_move_columns =\n      ( $DADA::Config::SQL_PARAMS{dbtype} eq 'mysql' ) ? 1 : 0;\n\n    my $named_subscriber_fields = [];\n\n    for (@$subscriber_fields) {\n        push(\n            @$named_subscriber_fields,\n            {\n                field            => $_,\n                fallback_value   => $fields_attr->{$_}->{fallback_value},\n                label            => $fields_attr->{$_}->{label},\n                required         => $fields_attr->{$_}->{required},\n                root_login       => $root_login,\n                can_move_columns => $can_move_columns,\n            }\n        );\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'profile_fields_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n\n            -vars => {\n\n                screen => 'profile_fields',\n                title  => 'Profile Fields',\n\n                edit_field => $edit_field,\n                fields     => $named_subscriber_fields,\n\n                field_status         => $field_status,\n                field                => $field,\n                fallback_field_value => $fallback_field_value,\n                field_label          => $field_label,\n                field_required       => $field_required,\n\n                can_have_subscriber_fields => $dpf->can_have_subscriber_fields,\n\n                root_login => $root_login,\n\n                HIDDEN_SUBSCRIBER_FIELDS_PREFIX =>\n                  $DADA::Config::HIDDEN_SUBSCRIBER_FIELDS_PREFIX,\n\n                using_SQLite => $DADA::Config::SQL_PARAMS{dbtype} eq 'SQLite' ? 1 : 0,\n                field_changes =>\n                  xss_filter( scalar $q->param('field_changes') ),\n                working_field =>\n                  xss_filter( scalar $q->param('working_field') ),\n                deletion => xss_filter( scalar $q->param('deletion') ),\n                addition => xss_filter( scalar $q->param('addition') ),\n                edited   => xss_filter( scalar $q->param('edited') ),\n\n                can_move_columns => $can_move_columns,\n\n                %flattened_field_errors,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub subscribe {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\n\t# We're not going to accept GET requests:\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->subscribe_landing(); \n\t}\n\t\n\t\n    my %args = ( -html_output => 1, @_ );\n\n\tmy $skip_tests = [];\n\tif(exists($args{-skip_tests})){ \n\t\t$skip_tests = $args{-skip_tests};\n\t}\n\t\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->subscribe(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n\t\t\t-skip_tests  => $skip_tests, \n        }\n    );\n\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n}\n\nsub restful_subscribe {\n\n    my $self = shift;\n    my $q    = $self->query();\n    try {\n        require JSON;\n    }\n    catch {\n        warn 'Perl CPAN module: JSON is required!';\n        die '425';\n    };\n\n    my $json = JSON->new->allow_nonref;\n\n    my $using_jsonp = 0;\n\n    if ( $q->param('_method') eq 'GET' && $q->url_param('callback') ) {\n\n        # that's OK - it's a jsonp call.\n        $using_jsonp = 1;\n\n    }\n    elsif ($DADA::Config::S_PROGRAM_URL =~ m/\\?$/\n        && $q->param('_method') eq 'GET'\n        && $q->param('callback') )\n    {\n\n     # this is a messy workaround.\n     # If $S_PROGRAM_URL has a trailing, \"?\", it means something a little weird,\n     # as the PATH_INFO is read from the QUERY_STRING, then parsed.\n     # url_param()'s don't work like that, so we have to read it from param()\n        $using_jsonp = 1;\n\n    }\n    elsif ( $q->content_type =~ m/application\\/json/ ) {\n\n        # That's OK too - we support getting the params you send us in POST\n\n    }\n    elsif ( !$q->content_type || $q->content_type =~ m/text\\/html/ ) {\n\n        # RTFM!\n        my $api_doc_url =\n'https://dadamailproject.com/d/COOKBOOK-subscriptions.pod.html#restful_api';\n        return\n            '<p>API Documentation: <a href=\"'\n          . $api_doc_url . '\"/>'\n          . $api_doc_url\n          . '</a></p>';\n\n    }\n    else {\n\n        die '425';\n\n    }\n\n    my $new_q = undef;\n    if ( $using_jsonp == 0 ) {\n        my $post_data = $q->param('POSTDATA');\n        my $data      = undef;\n        try {\n            $data = $json->decode($post_data);\n        }\n        catch {\n            # What should really be done is to return a custom json doc\n            # saying there was a problem with the POSTDATA - essentially, it\n            # would be blank.\n            warn 'problems decoding POSTDATA: ' . $_;\n            warn 'POSTDATA looks like this: ' . $data;\n            die '400';\n        };\n\n        require CGI;\n        $new_q = CGI->new;\n        $new_q->charset($DADA::Config::HTML_CHARSET);\n\n        $new_q->delete_all;\n\n        $new_q->param( 'list',   $data->{list} );\n        $new_q->param( 'email',  $data->{email} );\n        $new_q->param( 'flavor', 'subscribe' );\n\n        require DADA::ProfileFieldsManager;\n        my $pfm = DADA::ProfileFieldsManager->new;\n\n        # Profile Fields\n        for ( @{ $pfm->fields } ) {\n            if ( exists( $data->{fields}->{$_} ) ) {\n                $new_q->param( $_, $data->{fields}->{$_} );\n            }\n        }\n    }\n    else {\n        $new_q = $q;\n    }\n\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n\n    my $callback = undef;\n    if ($using_jsonp) {\n\n        # Messy workaround again:\n        if ( $DADA::Config::S_PROGRAM_URL =~ m/\\?$/ ) {\n            $callback = xss_filter( strip( $q->param('callback') ) );\n        }\n        else {\n            $callback = xss_filter( strip( $q->url_param('callback') ) );\n        }\n    }\n\n    my $headers = {};\n    if ($using_jsonp) {\n        $headers = {\n            -type                           => 'application/javascript',\n            '-Access-Control-Allow-Origin'  => '*',\n            '-Access-Control-Allow-Methods' => 'POST',\n            '-Cache-Control'                => 'no-cache, must-revalidate',\n            -expires                        => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        };\n\n    }\n    else {\n        $headers = {\n            -type            => 'application/json',\n            '-Cache-Control' => 'no-cache, must-revalidate',\n            -expires         => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        };\n    }\n\n    my ( $throwaway_headers, $body ) = $das->subscribe(\n        {\n            -cgi_obj     => $new_q,\n            -return_json => 1,\n        }\n    );\n\n    #\twarn \"\\$callback\\n\" . $callback;\n    #\twarn \"\\$headers\\n\" . $headers;\n\n    if ($using_jsonp) {\n        $self->header_props(%$headers);\n        return $callback . '(' . $body . ');';\n    }\n    else {\n        $self->header_props(%$headers);\n        return $body;\n    }\n}\n\nsub unsubscribe {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->unsubscribe(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n}\n\nsub unsubscription_request {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->unsubscription_request(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n}\n\nsub unsubscribe_email_lookup {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->unsubscribe_email_lookup(\n        {\n            -cgi_obj => $q,\n        }\n    );\n    $self->header_props(%$headers);\n    return $body;\n\n}\n\nsub outdated_subscription_urls {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    if ( check_if_list_exists( -List => $list ) == 0 ) {\n        undef($list);\n        return $self->default();\n    }\n\n    my $orig_flavor = $q->param('orig_flavor') || undef;\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen => 'outdated_subscription_urls_screen.tmpl',\n            -with   => 'list',\n            -list   => $list,\n            -expr   => 1,\n\n#\t\t-list_settings_vars_param => {-list => $list,},\n#\t\t-subscriber_vars_param    => {-list => $list, -email => $email, -type => 'list'},\n\n            -vars => {\n                show_profile_widget => 0,\n                orig_flavor         => $orig_flavor,\n\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    {\n                        -list       => $list,\n                        -email      => $email,\n                        -magic_form => 0,\n                    },\n                ),\n                unsubscription_form =>\n                  DADA::Template::Widgets::unsubscription_form(\n                    {\n                        -list  => $list,\n                        -email => $email,\n                    },\n                  ),\n            }\n        }\n    );\n    return $scrn;\n}\n\n\nsub token { \n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n\n\t# I'm fine with this check, as the whole reason for this is to \n\t# ONLY accept request via POST: \n\t#\n\t# There are some exceptions, where \"token\" is used as a flavor of the form - this \n\t# should handle those exceptions as well, so long as the form's action is, \"POST\":\n\t\n\tif($q->request_method() =~ m/POST/i){\n\t\t# is this ever called with args?\n\t\treturn $self->post_token(%args); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_token_get.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\ttoken => $q->param('token'), \n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \n\t}\n\t\n}\nsub post_token {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->token(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n        }\n    );\n\n    # use Data::Dumper;\n    # warn Dumper({headers => $headers, body => $body});\n\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub report_abuse {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $report_abuse_token = $q->param('report_abuse_token');\n    my $process = $q->param('process') || 0;\n\n    require DADA::App::Subscriptions::ConfirmationTokens;\n    my $ct = DADA::App::Subscriptions::ConfirmationTokens->new();\n\n    if ( $ct->exists($report_abuse_token) ) {\n        my $data = $ct->fetch($report_abuse_token);\n\n        if ( $data->{data}->{flavor} eq 'report_abuse' ) {\n\n            my $list = $data->{data}->{list};\n\n            if ( $process != 1 ) {\n\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen => 'report_abuse.tmpl',\n                        -with   => 'list',\n                        -vars   => {\n                            report_abuse_token => $report_abuse_token,\n                        },\n                        -list_settings_vars_param =>\n                          { -list => $list, -dot_it => 1 },\n                    }\n                );\n                return $scrn;\n            }\n            else {\n\n                my $abuse_report_details = $q->param('abuse_report_details');\n                $abuse_report_details =~ s/\\r\\n/\\n/g;\n\n                my $email = $data->{email};\n\n                #use Data::Dumper;\n                #warn Dumper($data);\n\n                # Email the Abuse Report\n                require DADA::App::Messages;\n                my $dap = DADA::App::Messages->new( { -list => $list } );\n                $dap->send_abuse_report(\n                    {\n                        -email                => $email,\n                        -abuse_report_details => $abuse_report_details,\n                    }\n                );\n\n                # (log the actual report?)\n                # ... #\n                #\n\n                # Log it for the Tracker\n                require DADA::Logging::Clickthrough;\n                my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n                $r->abuse_log(\n                    {\n                        -email => $email,\n                        -mid   => $data->{data}->{mid},\n\n                        # -details => unique_id to some sort of report table...\n                    }\n                );\n\n                $ct->remove_by_token($report_abuse_token);\n\n                # Tell 'em it worked!\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen => 'report_abuse_complete.tmpl',\n                        -with   => 'list',\n                        -vars   => {},\n                        -list_settings_vars_param =>\n                          { -list => $list, -dot_it => 1 },\n                    }\n                );\n                return $scrn;\n\n            }\n        }\n        else {\n            return user_error( { -error => 'token_problem' } );\n        }\n    }\n    else {\n        return user_error( { -error => 'token_problem' } );\n    }\n}\n\nsub resend_conf {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $can_use_captcha = 0;\n\n    if ( $ls->param('limit_sub_confirm_use_captcha') == 1 ) {\n        $can_use_captcha = can_use_Google_reCAPTCHA();\n    }\n    if ( $can_use_captcha == 1 ) {\n        $self->resend_conf_captcha();\n    }\n    else {\n        $self->resend_conf_no_captcha();\n    }\n\n}\n\nsub resend_conf_captcha {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    my $admin_override = $q->param('admin_override') || 0;\n    my $admin_override_enabled = 0;\n    my ( $admin_list, $root_login, $checksout, $error_msg );\n    if ( $admin_override == 1 ) {\n        ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'view_list'\n          );\n        if ( !$checksout ) {\n            return $error_msg;\n        }\n        else {\n            $admin_override_enabled = 1;\n        }\n    }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $captcha_worked = 0;\n    my $captcha_auth   = 1;\n\n    my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\n    if ( $admin_override_enabled != 1 ) {\n        if ( !$crf ) {\n            $captcha_worked = 0;\n        }\n        else {\n\t\t\t\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n            if ( $captcha_status == 1 ) {\n                $captcha_auth   = 1;\n                $captcha_worked = 1;\n            }\n            else {\n                $captcha_worked = 0;\n                $captcha_auth   = 0;\n            }\n        }\n    }\n    if ( $captcha_worked == 1 || $admin_override_enabled == 1 ) {\n        if ( $q->param('rm') eq 's' ) {\n\n            # so, what's $sub_info for?!\n            my $sub_info = $lh->get_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n            for ( keys %{$sub_info} ) {\n                next if $_ eq 'email';\n                next if $_ eq 'email_name';\n                next if $_ eq 'email_domain';\n                $q->param( $_, $sub_info->{$_} );\n            }\n\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list'\n                }\n            );\n            $q->param( 'list',  $list );\n            $q->param( 'email', $email );\n            $q->delete(\n                'flavor',\n\t\t\t\t'rm',\n                'g-recaptcha-response',\n\t\t\t\t'token',\n            );\n            $q->param( 'flavor', 's' );\n\t\t\t\n\t\t\tmy $skip_tests = [\n\t\t\t\t'captcha_challenge_failed', \n\t\t\t\t'list_consent_check', \n\t\t\t];\n\t\t\t\n\t\t\t\n            $self->subscribe(-skip_tests => $skip_tests);\n\n        }\n        elsif ( $q->param('rm') eq 'unsubscription_request' ) {\n\n            # I like the idea better that we call the function directly...\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_confirm_list'\n                }\n            );\n            $q->param( 'list',   $list );\n            $q->param( 'email',  $email );\n            $q->param( 'flavor', 'unsubscription_request' );\n            $self->unsubscription_request();\n        }\n    }\n    else {\n        my $error = '';\n        if ( $q->param('rm') eq 's' ) {\n            $error = 'already_sent_sub_confirmation';\n        }\n        elsif ( $q->param('rm') eq 'unsubscription_request' ) {\n            $error = 'already_sent_unsub_confirmation';\n        }\n        else {\n            die 'unknown $rm!';\n        }\n\t\t\n\t\t\n        return user_error(\n            {\n                -error => $error,\n                -list  => $list,\n                -email => $email,\n                -vars  => { \n\t\t\t\t\tcan_use_captcha => 1, \n\t\t\t\t\tcaptcha_auth    => $captcha_auth,\n\t\t\t\t},\n            }\n        );\n    }\n\n}\n\nsub resend_conf_no_captcha {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    my $list_exists = check_if_list_exists( -List => $list, );\n\n    my $admin_override = $q->param('admin_override') || 0;\n    my $admin_override_enabled = 0;\n    my ( $admin_list, $root_login, $checksout, $error_msg );\n    if ( $admin_override == 1 ) {\n        ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'view_list'\n          );\n        if ( !$checksout ) {\n            return $error_msg;\n        }\n        else {\n            $admin_override_enabled = 1;\n        }\n    }\n\n    if ( $list_exists == 0 ) {\n        return $self->default();\n    }\n    if ( !$email ) {\n        $q->param( 'error_no_email', 1 );\n        return $self->list_page();\n    }\n    if (   $q->param('rm') ne 's'\n        && $q->param('rm') ne 'u' )\n    {\n        return $self->default();\n    }\n    if ( $q->request_method() !~ m/POST/i && $admin_override_enabled != 1 ) {\n        return $self->default();\n    }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my ( $sec, $min, $hour, $day, $month, $year ) =\n      (localtime)[ 0, 1, 2, 3, 4, 5 ];\n\n# This is just really broken... should be a CAPTCHA...\n# I'm assuming this happens if we FAILED this test below (1 = failure for check_email_pin)\n#\n\n    my $cep_results = DADA::App::Guts::check_email_pin(\n        -Email => $month . '.' . $day . '.' . $email,\n        -Pin   => xss_filter( scalar $q->param('auth_code') ),\n        -List  => $list,\n    );\n\n    if ( $cep_results == 0 && $admin_override_enabled != 1 ) {\n        my ( $e_day, $e_month, $e_stuff ) = split( '.', $email );\n\n        #  Ah, I see, it only is blocked for a... day?\n        if ( $e_day != $day || $e_month != $month ) {\n\n            # a stale blocking thingy.\n            if ( $q->param('rm') eq 's' ) {\n                my $rm_status = $lh->remove_subscriber(\n                    {\n                        -email => $email,\n                        -type  => 'sub_confirm_list'\n                    }\n                );\n            }\n            elsif ( $q->param('rm') eq 'u' ) {\n\n                my $rm_status = $lh->remove_subscriber(\n                    {\n                        -email => $email,\n                        -type  => 'unsub_confirm_list'\n                    }\n                );\n            }\n        }\n        return $self->list_page();\n    }\n    else {\n\n        if ( $q->param('rm') eq 's' ) {\n            my $sub_info = $lh->get_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list'\n                }\n            );\n            $q->param( 'list',   $list );\n            $q->param( 'email',  $email );\n            $q->param( 'flavor', 's' );\n          \t\n\t\t\tmy $skip_tests = [\n\t\t\t\t'list_consent_check', \n\t\t\t];\n            $self->subscribe(-skip_tests => $skip_tests);\n\t\t\t\n        }\n        elsif ( $q->param('rm') eq 'u' ) {\n\n            # I like the idea better that we call the function directly...\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_confirm_list'\n                }\n            );\n            $q->param( 'list',   $list );\n            $q->param( 'email',  $email );\n            $q->param( 'flavor', 'unsubscription_request' );\n            $self->unsubscription_request();\n        }\n    }\n}\n\nsub show_error {\n\n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $email = xss_filter( scalar $q->param('email') ) || undef;\n    my $error = xss_filter( scalar $q->param('error') ) || undef;\n    my $list  = xss_filter( scalar $q->param('list') )  || undef;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $list_exists = check_if_list_exists( -List => $list, );\n    if ( $list_exists == 0 ) {\n\t\t\n        return $self->default();\n    }\n    if ( !$email ) {\n        $q->param( 'error_no_email', 1 );\n        return $self->list_page();\n    }\n\n    if ( \n\t$error ne 'already_sent_sub_confirmation'\n\t&& \n\t$error ne 'captcha_challenge_failed') {\n        return $self->default();\n    }\n\n    require DADA::App::Error;\n    my $error_msg = DADA::App::Error::cgi_user_error(\n        {\n            -list  => $list,\n            -error => $error,\n            -email => $email,\n        }\n    );\n    return $error_msg;\n\n}\n\nsub text_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'text_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $ls   = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh   = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $type = $q->param('type') || 'list';\n    my $query = xss_filter( scalar $q->param('query') ) || undef;\n    my $advanced_search =\n      xss_filter( scalar $q->param('advanced_search') ) || 0;\n    my $advanced_query =\n      xss_filter( scalar $q->param('advanced_query') ) || undef;\n    my $order_by = $q->param('order_by') || $ls->param('view_list_order_by');\n    my $order_dir = $q->param('order_dir')\n      || lc( $ls->param('view_list_order_by_direction') );\n\n    my $show_timestamp_column = $q->param('show_timestamp_column') || 0;\n    my $show_delivery_prefs_column =\n      $q->param('show_delivery_prefs_column') || 0;\n    my $show_profile_fields = $q->param('show_profile_fields') || 0;\n\n    my $partial_listing = {};\n    if ($advanced_query) {\n        if ( $advanced_search == 1 ) {\n            open my $fh, '<', \\$advanced_query || die $!;\n            require CGI;\n            my $new_q = CGI->new($fh);\n            $new_q->charset($DADA::Config::HTML_CHARSET);\n            $new_q           = decode_cgi_obj($new_q);\n            $partial_listing = partial_sending_query_to_params($new_q);\n        }\n    }\n\n    my $email;\n\n    my $headers = {\n        -attachment => $list . '-' . $type . '.csv',\n        -type       => 'text/csv',\n    };\n    my $body;\n    if ($advanced_query) {\n        $body = $lh->print_out_list(\n            {\n                -type                       => $type,\n                -order_by                   => $order_by,\n                -order_dir                  => $order_dir,\n                -partial_listing            => $partial_listing,\n                -show_timestamp_column      => $show_timestamp_column,\n                -show_delivery_prefs_column => $show_delivery_prefs_column,\n                -show_profile_fields        => $show_profile_fields,\n                -print_out                  => 0,\n            }\n        );\n    }\n    else {\n        $body = $lh->print_out_list(\n            {\n                -type                       => $type,\n                -query                      => $query,\n                -order_by                   => $order_by,\n                -order_dir                  => $order_dir,\n                -show_timestamp_column      => $show_timestamp_column,\n                -show_delivery_prefs_column => $show_delivery_prefs_column,\n                -show_profile_fields        => $show_profile_fields,\n                -print_out                  => 0,\n            }\n        );\n    }\n    $self->header_props(%$headers);\n    return $body;\n}\n\n\n\n\n\nsub new_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\t# GET request not allowed. \n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\t\n    require DADA::Security::Password;\n    my $root_password    = $q->param('root_password');\n    my $agree            = $q->param('agree');\n    my $process          = $q->param('process');\n    my $help             = $q->param('help');\n    my $list             = $q->param('list');\n    my $list_name        = $q->param('list_name')        || undef;\n    my $list_owner_email = $q->param('list_owner_email') || undef;\n    my $admin_email      = $q->param('admin_email')      || undef;\n    my $privacy_policy   = $q->param('privacy_policy')   || undef;\n    my $consent          = $q->param('consent')          || undef;\n    my $info             = $q->param('info')             || undef;\n    my $physical_address = $q->param('physical_address') || undef;\n    my $password         = $q->param('password')         || undef;\n    my $retype_password  = $q->param('retype_password')  || undef;\n\n    my $send_new_list_welcome_email =\n      $q->param('send_new_list_welcome_email') || 0;\n    my $send_new_list_welcome_email_with_list_pass =\n      $q->param('send_new_list_welcome_email_with_list_pass') || 0;\n\n    if ( !$process ) {\n\n        my $errors = shift;\n        my $flags  = shift;\n        my $pw_check;\n\n        require DADA::Security::SimpleAuthStringState;\n        my $sast       = DADA::Security::SimpleAuthStringState->new;\n        my $auth_state = $q->param('auth_state');\n\n        if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n            if ( $sast->check_state($auth_state) != 1 ) {\n                return user_error(\n                    { -list => undef, -error => 'incorrect_login_url' } );\n            }\n\n        }\n\n        if ( !$errors && can_use_Google_reCAPTCHA() == 1 ) {\n\n            my $crf =\n              xss_filter( scalar $q->param('g-recaptcha-response') ) || undef;\n            my $captcha_status = validate_recaptcha(\n                {\n                    -response    => $crf,\n                    -remote_addr => $ENV{'REMOTE_ADDR'},\n                }\n            );\n            if ( $captcha_status == 0 ) {\n                return user_error(\n                    {\n                        -list  => $list,\n                        -error => 'list_cp_login_recaptcha_failed',\n                    }\n                );\n            }\n        }\n\n        if ( !$DADA::Config::PROGRAM_ROOT_PASSWORD ) {\n            return user_error(\n                { -list => $list, -error => \"no_root_password\" } );\n        }\n        elsif ( $DADA::Config::ROOT_PASS_IS_ENCRYPTED == 1 ) {\n\n            #encrypted password check\n            $pw_check =\n              DADA::Security::Password::check_password(\n                $DADA::Config::PROGRAM_ROOT_PASSWORD,\n                $root_password );\n        }\n        else {\n            # unencrypted password check\n            if ( $DADA::Config::PROGRAM_ROOT_PASSWORD eq $root_password ) {\n                $pw_check = 1;\n            }\n        }\n\n        if ( $pw_check == 1 ) {\n\n            my @t_lists = available_lists();\n\n            $agree = 'yes' if $errors;\n\n            if ( ( !$t_lists[0] ) && ( $agree ne 'yes' ) && ( !$process ) ) {\n                $self->header_type('redirect');\n                $self->header_props(\n                    -url => $DADA::Config::S_PROGRAM_URL . '?agree=no' );\n            }\n\n            if ( strip($DADA::Config::LIST_QUOTA) eq '' ) {\n                $DADA::Config::LIST_QUOTA = undef;\n            }\n\n            # Special:\n            if ( $DADA::Config::LIST_QUOTA == 0 ) {\n                $DADA::Config::LIST_QUOTA = undef;\n            }\n            if ( defined($DADA::Config::LIST_QUOTA)\n                && ( ( $#t_lists + 1 ) >= $DADA::Config::LIST_QUOTA ) )\n            {\n                return user_error(\n                    { -list => $list, -error => \"over_list_quota\" } );\n            }\n\n            if ( !$t_lists[0] ) {\n                $help = 1;\n            }\n\n            my $ending   = undef;\n            my $err_word = undef;\n\n            if ($errors) {\n                $ending   = '';\n                $err_word = 'was';\n                $ending   = 's'    if $errors > 1;\n                $err_word = 'were' if $errors > 1;\n            }\n\n            my @available_lists = DADA::App::Guts::available_lists();\n            my $lists_exist     = $#available_lists + 1;\n\n            my $list_popup_menu = DADA::Template::Widgets::list_popup_menu(\n                -show_hidden         => 1,\n                -name                => 'clone_settings_from_this_list',\n                -empty_list_check    => 1,\n                -show_list_shortname => 1,\n            );\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'new_list_screen.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        errors                   => $errors,\n                        ending                   => $ending,\n                        err_word                 => $err_word,\n                        help                     => $help,\n                        root_password            => $root_password,\n                        flags_list_name          => $flags->{list_name},\n                        list_name                => $list_name,\n                        flags_list_exists        => $flags->{list_exists},\n                        flags_list               => $flags->{list},\n                        flags_shortname_too_long =>\n                          $flags->{shortname_too_long},\n                        flags_slashes_in_name  => $flags->{slashes_in_name},\n                        flags_weird_characters => $flags->{weird_characters},\n                        flags_quotes           => $flags->{quotes},\n                        list                   => $list,\n                        flags_password         => $flags->{password},\n                        password               => $password,\n\n                        flags_password_is_root_password =>\n                          $flags->{password_is_root_password},\n\n                        flags_retype_password => $flags->{retype_password},\n                        flags_password_ne_retype_password =>\n                          $flags->{password_ne_retype_password},\n                        retype_password                => $retype_password,\n                        flags_invalid_list_owner_email =>\n                          $flags->{invalid_list_owner_email},\n                        list_owner_email     => $list_owner_email,\n                        flags_list_info      => $flags->{list_info},\n                        info                 => $info,\n                        flags_privacy_policy => $flags->{privacy_policy},\n                        privacy_policy       => $privacy_policy,\n\n                        consent       => $consent,\n                        flags_consent => $flags->{consent},\n\n                        flags_physical_address => $flags->{physical_address},\n                        physical_address       => $physical_address,\n                        flags_list_name_bad_characters =>\n                          $flags->{list_name_bad_characters},\n\n                        lists_exist     => $lists_exist,\n                        list_popup_menu => $list_popup_menu,\n                        auth_state      => $sast->make_state,\n\n                    },\n                }\n            );\n\n            if ($errors) {\n\n# This fills in the advanced options form fields. Above also fills in other fields just\n# by setting the vars in via HTML::Template - so we have a mix of two techniques.\n# If there is another pass to this, it's probably best to consilidate on the below technique.\n\n                require CGI;\n                my $fif_q = CGI->new;\n                $fif_q->charset($DADA::Config::HTML_CHARSET);\n                $fif_q->delete_all;\n\n                $fif_q->param( 'clone_settings',\n                    scalar $q->param('clone_settings') );\n                $fif_q->param( 'clone_settings_from_this_list',\n                    scalar $q->param('clone_settings_from_this_list') );\n                $fif_q->param(\n                    'send_new_list_welcome_email',\n                    $send_new_list_welcome_email\n                );\n                $fif_q->param(\n                    'send_new_list_welcome_email_with_list_pass',\n                    $send_new_list_welcome_email_with_list_pass\n                );\n\n                require HTML::FillInForm::Lite;\n                my $h = HTML::FillInForm::Lite->new();\n                $scrn = $h->fill( \\$scrn, $fif_q );\n            }\n\n            return $scrn;\n\n        }\n        else {\n            require DADA::Template::Widgets;\n            return DADA::Template::Widgets::admin(\n                {\n                    -cgi_obj => $q,\n                    -vars    => {\n                        errors     => [ { error => 'invalid_root_password' } ],\n                        error_with => 'new_list',\n                    }\n                }\n            );\n\n        }\n    }\n    else {\n        chomp($list);\n        $list =~ s/^\\s+//;\n        $list =~ s/\\s+$//;\n\n        # $list =~ s/ /_/g; # What?\n\n        my $list_exists = check_if_list_exists( -List => $list );\n        my ( $list_errors, $flags ) = check_list_setup(\n            -fields => {\n                list             => $list,\n                list_name        => $list_name,\n                list_owner_email => $list_owner_email,\n                password         => $password,\n                retype_password  => $retype_password,\n                info             => $info,\n                privacy_policy   => $privacy_policy,\n                physical_address => $physical_address,\n                consent          => $consent,\n            }\n        );\n\n        if ( $list_errors >= 1 ) {\n            undef($process);\n            $q->delete('process');\n\n            $self->new_list( $list_errors, $flags );\n\n        }\n        elsif ( $list_exists >= 1 ) {\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => \"list_already_exists\"\n                }\n            );\n        }\n        else {\n\n            $list_owner_email = lc_email($list_owner_email);\n\n            my $new_info = {\n\n                #\tlist             =>   $list,\n                list_owner_email => $list_owner_email,\n                list_name        => $list_name,\n                password         => $password,\n                info             => $info,\n                physical_address => $physical_address,\n                privacy_policy   => $privacy_policy,\n                consent          => $consent,\n\n            };\n\n            require DADA::MailingList;\n            my $ls;\n            if ( $q->param('clone_settings') == 1 ) {\n                $ls = DADA::MailingList::Create(\n                    {\n                        -list     => $list,\n                        -settings => $new_info,\n                        -clone    => xss_filter(\n                            scalar $q->param('clone_settings_from_this_list')\n                        ),\n                    }\n                );\n            }\n            else {\n                $ls = DADA::MailingList::Create(\n                    {\n                        -list     => $list,\n                        -settings => $new_info,\n                    }\n                );\n            }\n\n            my $status;\n\n            if ( $DADA::Config::LOG{list_lives} ) {\n                require DADA::Logging::Usage;\n                my $log = new DADA::Logging::Usage;\n                $log->mj_log(\n                    $list,\n                    'List Created',\n                    \"remote_host:$ENV{REMOTE_HOST},\"\n                      . \"ip_address:$ENV{REMOTE_ADDR}\"\n                );\n            }\n\n            my $escaped_list = uriescape( $ls->param('list') );\n\n            my $auth_state;\n\n            if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n                require DADA::Security::SimpleAuthStringState;\n                my $sast = DADA::Security::SimpleAuthStringState->new;\n                $auth_state = $sast->make_state;\n            }\n\n            if ( $q->param('send_new_list_welcome_email') == 1 ) {\n                try {\n                    require DADA::App::Messages;\n                    my $dap = DADA::App::Messages->new(\n                        {\n                            -list => $ls->param('list'),\n                        }\n                    );\n\n                    # seems dumb to be passing this around, if we don't need to:\n                    my $send_new_list_created_notification_vars = {};\n\n                    if ( $send_new_list_welcome_email_with_list_pass == 1 ) {\n                        $send_new_list_created_notification_vars = {\n                            send_new_list_welcome_email_with_list_pass => 1,\n                            list_password => $password,\n                        };\n                    }\n                    else {\n                        $send_new_list_created_notification_vars = {\n                            send_new_list_welcome_email_with_list_pass => 0,\n                            list_password                              => undef,\n                        };\n                    }\n\n                    $dap->send_new_list_created_notification(\n                        {\n                            -vars => $send_new_list_created_notification_vars\n                        }\n                    );\n                }\n                catch {\n                    warn 'problems sending send_new_list_created_notification: '\n                      . $_;\n                };\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'new_list_created_screen.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n\n                        login_widget  => 'hidden_field',\n                        selected_list => $ls->param('list'),\n                        auth_state    => $auth_state,\n\n                        list_name        => $ls->param('list_name'),\n                        list             => $ls->param('list'),\n                        escaped_list     => $escaped_list,\n                        list_owner_email => $ls->param('list_owner_email'),\n                        info             => $ls->param('info'),\n                        privacy_policy   => $ls->param('privacy_policy'),\n                        physical_address => $ls->param('physical_address'),\n                    },\n                }\n            );\n            return $scrn;\n\n        }\n    }\n}\n\n\nsub list_archive {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    # are we dealing with a real list?\n    my $list_exists = check_if_list_exists( -List => $list, );\n\n    if ( $list_exists == 0 ) {\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL );\n\t\treturn;\n\n    }\n\n    my $id = $q->param('id') || undef;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -from_session => 1 } );\n    my $allowed_to_view_archives = 1;\n    if ($prof) {\n        $allowed_to_view_archives =\n          $prof->allowed_to_view_archives( { -list => $list, } );\n    }\n    if ( $allowed_to_view_archives == 0 ) {\n        return user_error(\n            { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n    }\n\n    my $start = int( $q->param('start') ) || 0;\n\n    if ( $ls->param('show_archives') == 0 ) {\n        return user_error( { -list => $list, -error => \"no_show_archives\" } );\n    }\n\n    require DADA::MailingList::Archives;\n\n    my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n    my $entries = $archive->get_archive_entries();\n\n###### These are all little thingies.\n\n    my $archive_send_form = '';\n    $archive_send_form = DADA::Template::Widgets::archive_send_form(\n        $list,\n        $id,\n        xss_filter( scalar $q->param('send_archive_errors') ),\n        $ls->param('captcha_archive_send_form'),\n        xss_filter( scalar $q->param('captcha_fail') )\n    ) if $ls->param('archive_send_form') == 1 && defined($id);\n\n    my $nav_table = '';\n    $nav_table =\n      $archive->make_nav_table( -Id => $id, -List => $ls->param('list') )\n      if defined($id);\n\n    my $archive_subscribe_form = \"\";\n\n    if ( $ls->param('hide_list') ne \"1\" ) {\n\n        # DEV: This takes the cake for worst hack I have found... today.\n        my $info = '<!-- tmpl_var list_settings.info -->';\n        $info = DADA::Template::Widgets::screen(\n            {\n                -data                     => \\$info,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [qw(list_settings.info)],\n            }\n        );\n\n        unless ( $ls->param('archive_subscribe_form') eq \"0\" ) {\n\n            $archive_subscribe_form =\n              DADA::Template::Widgets::subscription_form(\n                {\n                    -list       => $ls->param('list'),\n                    -email      => $email,\n                }\n              );\n        }\n    }\n\n    my $archive_widgets = {\n        archive_send_form    => $archive_send_form,\n        nav_table            => $nav_table,\n        publish_archives_rss => $ls->param('publish_archives_rss') ? 1 : 0,\n        subscription_form    => $archive_subscribe_form,\n    };\n\n    #/##### These are all little thingies.\n\n    if ( !$id ) {\n\n        if (  !$c->profile_on\n            && $c->is_cached( 'archive/' . $list . '/' . $start . '.scrn' ) )\n        {\n            return $c->cached( 'archive/' . $list . '/' . $start . '.scrn' );\n\n        }\n\n        my $th_entries = [];\n\n        my ( $begin, $stop ) = $archive->create_index($start);\n        my $i;\n        my $stopped_at = $begin;\n        my $num        = $begin;\n\n        $num++;\n        my @archive_nums;\n        my @archive_links;\n\n        # iterate and save\n        for ( $i = $begin ; $i <= $stop ; $i++ ) {\n            my $link;\n\n            if ( defined( $entries->[$i] ) ) {\n\n                my ( $subject, $message, $format, $raw_msg ) =\n                  $archive->get_archive_info( $entries->[$i] );\n\n                # DEV: This is stupid, and I don't think it's a great idea.\n                # $subject = safely_decode($subject);\n                $subject = DADA::Template::Widgets::screen(\n                    {\n                        -data                     => \\$subject,\n                        -vars                     => $ls->get,\n                        -list_settings_vars       => $ls->get,\n                        -list_settings_vars_param => { -dot_it => 1 },\n                        -subscriber_vars_param =>\n                          { -use_fallback_vars => 1, -list => $list },\n                    },\n\n                );\n\n                # this is so atrocious.\n                my $date = date_this(\n                    -Packed_Date => $archive->_massaged_key( $entries->[$i] ),\n                    -Write_Month => $ls->param('archive_show_month'),\n                    -Write_Day   => $ls->param('archive_show_day'),\n                    -Write_Year  => $ls->param('archive_show_year'),\n                    -Write_H_And_M =>\n                      $ls->param('archive_show_hour_and_minute'),\n                    -Write_Second => $ls->param('archive_show_second'),\n                );\n                my $header_from      = undef;\n                my $orig_header_from = undef;\n\n                if ($raw_msg) {\n                    $header_from = $archive->get_header(\n                        -header => 'From',\n                        -key    => $entries->[$i]\n                    );\n                    $orig_header_from = $header_from;\n                }\n\n                my $can_use_gravatar_url = 1;\n                my $gravatar_img_url     = undef;\n                my $show_gravatar        = 0;\n\n                if ( $ls->param('enable_gravatars') ) {\n\n                    try {\n                        require Gravatar::URL\n                    }\n                    catch {\n                        $can_use_gravatar_url = 0;\n                    };\n\n                    if ( $can_use_gravatar_url == 1 ) {\n                        my $header_address = $archive->sender_address(\n                            {\n                                -id => $entries->[$i],\n                            }\n                        );\n                        $gravatar_img_url = gravatar_img_url(\n                            {\n                                -email => $header_address,\n                                -default_gravatar_url =>\n                                  $ls->param('default_gravatar_url'),\n                            }\n                        );\n\n                    }\n                    else {\n                        $can_use_gravatar_url = 0;\n                    }\n                    if (   $ls->param('enable_gravatars') == 1\n                        && $can_use_gravatar_url == 1\n                        && defined(gravatar_img_url) )\n                    {\n                        $show_gravatar = 1;\n                    }\n\n                }\n\n                my $entry = {\n                    id               => $entries->[$i],\n                    date             => $date,\n                    subject          => $subject,\n                    'format'         => $format,\n                    list             => $list,\n                    uri_escaped_list => uriescape($list),\n                    PROGRAM_URL      => $DADA::Config::PROGRAM_URL,\n                    message_blurb =>\n                      $archive->message_blurb( -key => $entries->[$i] ),\n                    show_gravatar        => $show_gravatar,\n                    can_use_gravatar_url => $can_use_gravatar_url,\n                    gravatar_img_url     => $gravatar_img_url,\n\n                };\n\n                $stopped_at++;\n                push( @archive_nums,  $num );\n                push( @archive_links, $link );\n                $num++;\n\n                push( @$th_entries, $entry );\n\n            }\n        }\n\n        my $ii;\n        for ( $ii = 0 ; $ii <= $#archive_links ; $ii++ ) {\n\n            my $bullet = $archive_nums[$ii];\n\n            #fix if we're doing reverse chronologic\n            $bullet = ( ( $#{$entries} + 1 ) - ( $archive_nums[$ii] ) + 1 )\n              if ( $ls->param('sort_archives_in_reverse') == 1 );\n\n            # yeah, whatever.\n            $th_entries->[$ii]->{bullet} = $bullet;\n\n        }\n\n        my $index_nav = $archive->create_index_nav($stopped_at);\n\n        require DADA::Profile;\n        my $prof = DADA::Profile->new( { -from_session => 1 } );\n        my $allowed_to_view_archives = 1;\n        if ($prof) {\n            $allowed_to_view_archives =\n              $prof->allowed_to_view_archives( { -list => $list, } );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'list_archive_index_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    list                     => $list,\n                    list_name                => $ls->param('list_name'),\n                    entries                  => $th_entries,\n                    index_nav                => $index_nav,\n                    flavor_archive           => 1,\n                    allowed_to_view_archives => $allowed_to_view_archives,\n                    publish_archives_rss => $ls->param('publish_archives_rss')\n                    ? 1\n                    : 0,\n\n                    %$archive_widgets,\n\n                },\n\n                -list_settings_vars       => $ls->get,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [\n                    qw(list_settings.discussion_pop_email list_settings.list_owner_email list_settings.info list_settings.privacy_policy )\n                ],\n\n            }\n        );\n        if ( !$c->profile_on ) {\n            $c->cache( 'archive/' . $list . '/' . $start . '.scrn', \\$scrn );\n        }\n        return $scrn;\n\n    }\n    else {    # There's an id...\n\n\t\n        $id = $archive->newest_entry if $id =~ /newest/i;\n        $id = $archive->oldest_entry if $id =~ /oldest/i;\n\t\t\n\t\tif($id eq 'PREVIEW_MESSAGE_ID'){ \t\t\t\n\t\t\t\n\t\t    my $scrn = DADA::Template::Widgets::wrap_screen(\n\t\t        {\n\t\t            -screen => 'archive_screen_preview_placeholder.tmpl',\n\t\t            -with   => 'list',\n\t\t            -vars   => {},\n\t\t            -list_settings_vars_param => {\n\t\t                -list   => $list,\n\t\t                -dot_it => 1,\n\t\t            },\n\t\t        }\n\t\t    );\n\t\t\treturn $scrn;\n\t\t}\n\n\n        if ( $q->param('extran') ) {\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::PROGRAM_URL\n                  . '/archive/'\n                  . $ls->param('list') . '/'\n                  . $id\n                  . '/' );\n        }\n\n        if ( $id !~ m/(\\d+)/g ) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::PROGRAM_URL\n                  . '/archive/'\n                  . $ls->param('list')\n                  . '/' );\n        }\n\n        $id = $archive->_massaged_key($id);\n\n        if (   $ls->param('archive_send_form') != 1\n            && $ls->param('captcha_archive_send_form') != 1 )\n        {\n\n            if (  !$c->profile_on\n                && $c->is_cached( 'archive/' . $list . '/' . $id . '.scrn' ) )\n            {\n                require DADA::Logging::Clickthrough;\n                my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n                $r->view_archive_log( { -mid => $id, } );\n                return $c->cached( 'archive/' . $list . '/' . $id . '.scrn' );\n            }\n        }\n\n        my $entry_exists = $archive->check_if_entry_exists($id);\n        if ( $entry_exists <= 0 ) {\n            return user_error(\n                { -list => $list, -error => \"no_archive_entry\" } );\n        }\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $archive->get_archive_info($id);\n\n        # DEV: This is stupid, and I don't think it's a great idea.\n        $subject = $archive->_parse_in_list_info( -data => $subject );\n\n        # That. Sucked.\n\n        my ( $massaged_message_for_display, $content_type ) =\n          $archive->massaged_msg_for_display(\n            { -key => $id, -body_only => 1 } );\n\n        my $show_iframe = $ls->param('html_archives_in_iframe') || 0;\n        if ( $content_type eq 'text/plain' ) {\n            $show_iframe = 0;\n        }\n\n        my $header_from      = undef;\n        my $orig_header_from = undef;\n\n        #my $header_date    = undef;\n        my $header_subject = undef;\n\n        my $in_reply_to_id;\n        my $in_reply_to_subject;\n\n        if ($raw_msg) {\n            $header_from =\n              $archive->get_header( -header => 'From', -key => $id );\n            $orig_header_from = $header_from;\n\n            # DEV: This logic should not be here...\n\n            # DEV: This is stupid, and I don't think it's a great idea.\n            $header_from =\n              $archive->_parse_in_list_info( -data => $header_from );\n\n\t\t\tif ( $ls->param('archive_protect_email') eq 'break' ) {\n                $header_from = encode_html_entities( break_encode($header_from),\n                    , \"\\200-\\377\" );\n            }\n            elsif ( $ls->param('archive_protect_email') eq 'spam_me_not' ) {\n                $header_from = spam_me_not_encode($header_from);\n            }\n            else {\n                $header_from = xss_filter( encode_html_entities($header_from),,\n                    \"\\200-\\377\" );\n            }\n\n            $header_subject =\n              $archive->get_header( -header => 'Subject', -key => $id );\n\n            $header_subject =~ s/\\r|\\n/ /g;\n            if ( !$header_subject ) {\n                $header_subject = $DADA::Config::EMAIL_HEADERS{Subject};\n            }\n\n            ( $in_reply_to_id, $in_reply_to_subject ) =\n              $archive->in_reply_to_info( -key => $id );\n\n            # DEV: This is stupid, and I don't think it's a great idea.\n            $header_subject =\n              $archive->_parse_in_list_info( -data => $header_subject );\n            $in_reply_to_subject =\n              $archive->_parse_in_list_info( -data => $in_reply_to_subject );\n\n            # That. Sucked.\n            $header_subject      = $header_subject;\n            $in_reply_to_subject = $in_reply_to_subject;\n\n        }\n\n        my $attachments =\n          ( $ls->param('display_attachments') == 1 )\n          ? $archive->attachment_list($id)\n          : [];\n\n        # this is so atrocious.\n        my $date = date_this(\n            -Packed_Date   => $id,\n            -Write_Month   => $ls->param('archive_show_month'),\n            -Write_Day     => $ls->param('archive_show_day'),\n            -Write_Year    => $ls->param('archive_show_year'),\n            -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n            -Write_Second  => $ls->param('archive_show_second'),\n        );\n\n        my $show_gravatar        = 0;\n        my $gravatar_img_url     = undef;\n        my $can_use_gravatar_url = 1;\n\n        if ( $ls->param('enable_gravatars') ) {\n            try {\n                require Gravatar::URL\n            }\n            catch {\n                $can_use_gravatar_url = 0;\n            };\n            if ( $can_use_gravatar_url == 1 ) {\n                my $header_address = $archive->sender_address(\n                    {\n                        -id => $id,\n                    }\n                );\n                $gravatar_img_url = gravatar_img_url(\n                    {\n                        -email => $header_address,\n                        -default_gravatar_url =>\n                          $ls->param('default_gravatar_url'),\n                    }\n                );\n            }\n            else {\n                $can_use_gravatar_url = 0;\n            }\n        }\n        if (   $ls->param('enable_gravatars') == 1\n            && $can_use_gravatar_url == 1\n            && defined(gravatar_img_url) )\n        {\n            $show_gravatar = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'list_archive_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    list      => $list,\n                    list_name => $ls->param('list_name'),\n                    id        => $id,\n\n                    # DEV. OK - riddle ME why there's two of these...\n                    header_subject => $header_subject,\n                    subject        => $subject,\n\n                    js_enc_subject      => js_enc($header_subject),\n                    uri_encoded_subject => uriescape($header_subject),\n                    uri_encoded_url     => uriescape(\n                            $DADA::Config::PROGRAM_URL\n                          . '/archive/'\n                          . $list . '/'\n                          . $id . '/'\n                    ),\n                    archived_msg_url => $DADA::Config::PROGRAM_NAME\n                      . '/archive/'\n                      . $list . '/'\n                      . $id . '/',\n                    massaged_msg_for_display => $massaged_message_for_display,\n                    send_archive_success =>\n                      scalar $q->param('send_archive_success')\n                    ? $q->param('send_archive_success')\n                    : undef,\n                    send_archive_errors =>\n                      scalar $q->param('send_archive_errors')\n                    ? $q->param('send_archive_errors')\n                    : undef,\n                    show_iframe     => $show_iframe,\n                    discussion_list => ( $ls->param('group_list') == 1 ) ? 1\n                    : 0,\n\n                    header_from         => $header_from,\n                    in_reply_to_id      => $in_reply_to_id,\n                    in_reply_to_subject => xss_filter($in_reply_to_subject),\n                    attachments         => $attachments,\n                    date                => $date,\n                    add_social_bookmarking_badges =>\n                      $ls->param('add_social_bookmarking_badges'),\n                    show_gravatar        => $show_gravatar,\n                    can_use_gravatar_url => $can_use_gravatar_url,\n                    gravatar_img_url     => $gravatar_img_url,\n                    %$archive_widgets,\n\n                },\n                -list_settings_vars       => $ls->get,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [\n                    qw(list_settings.discussion_pop_email list_settings.list_owner_email list_settings.info list_settings.privacy_policy )\n                ],\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n            }\n        );\n\n        require DADA::Logging::Clickthrough;\n        my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n        $r->view_archive_log( { -mid => $id, } );\n        if (  !$c->profile_on\n            && $ls->param('archive_send_form') != 1\n            && $ls->param('captcha_archive_send_form') != 1 )\n        {\n            $c->cache( 'archive/' . $list . '/' . $id . '.scrn', \\$scrn );\n\n        }\n        return $scrn;\n    }\n\n}\n\nsub archive_bare {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $list = $q->param('list');\n\n    if ( $q->param('admin') ) {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'view_archive'\n          );\n        if ( !$checksout ) { return $error_msg; }\n        $list = $admin_list;\n    }\n\n    my $id = $q->param('id') || undef;\n\n    if (\n        $c->is_cached(\n                'archive_bare.'\n              . $list . '.'\n              . $id . '.'\n              . scalar( $q->param('admin') ) . '.scrn'\n        )\n      )\n    {\n        return $c->cached( 'archive_bare.'\n              . $list . '.'\n              . $id . '.'\n              . scalar( $q->param('admin') )\n              . '.scrn' );\n    }\n\n    require DADA::MailingList::Archives;\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n    if ( !$q->param('admin') ) {\n        if ( $ls->param('show_archives') == 0 ) {\n            return user_error(\n                { -list => $list, -error => \"no_show_archives\" } );\n        }\n        require DADA::Profile;\n        my $prof = DADA::Profile->new( { -from_session => 1 } );\n        my $allowed_to_view_archives = 1;\n        if ($prof) {\n            $allowed_to_view_archives =\n              $prof->allowed_to_view_archives( { -list => $list, } );\n        }\n\n        if ( $allowed_to_view_archives == 0 ) {\n            return user_error(\n                { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n        }\n    }\n    if ( $la->check_if_entry_exists($id) <= 0 ) {\n        return user_error( { -list => $list, -error => \"no_archive_entry\" } );\n    }\n\n    my $scrn = $la->massaged_msg_for_display( { -key => $id } );\n    $c->cache(\n        'archive_bare.'\n          . $list . '.'\n          . $id . '.'\n          . scalar( $q->param('admin') ) . '.scrn',\n        \\$scrn\n    );\n    return $scrn;\n\n}\n\nsub search_archive {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    if ( check_if_list_exists( -List => $list ) <= 0 ) {\n        return user_error( { -list => $list, -error => \"no_list\" } );\n    }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( $ls->param('show_archives') == 0 ) {\n        return user_error( { -list => $list, -error => \"no_show_archives\" } );\n    }\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -from_session => 1 } );\n    my $allowed_to_view_archives = 1;\n    if ($prof) {\n        $allowed_to_view_archives =\n          $prof->allowed_to_view_archives( { -list => $list, } );\n    }\n\n    if ( $allowed_to_view_archives == 0 ) {\n        return user_error(\n            { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n    }\n\n    my $keyword = $q->param('keyword');\n    $keyword = xss_filter($keyword);\n\n    if ( $keyword =~ m/^[A-Za-z]+$/ ) {    # just words, basically.\n        if (  !$c->profile_on\n            && $c->is_cached( $list . '.search_archive.' . $keyword . '.scrn' )\n          )\n        {\n            return $c->cached(\n                $list . '.search_archive.' . $keyword . '.scrn' );\n        }\n    }\n\n    require DADA::MailingList::Archives;\n\n    my $archive      = DADA::MailingList::Archives->new( { -list => $list } );\n    my $entries      = $archive->get_archive_entries();\n    my $ending       = \"\";\n    my $count        = 0;\n    my $ht_summaries = [];\n\n    my $search_results = $archive->search_entries($keyword);\n\n    if ( exists( $search_results->[0] ) && ( @$search_results[0] ne \"\" ) ) {\n\n        $count  = $#{$search_results} + 1;\n        $ending = 's'\n          if exists( $search_results->[1] );\n\n        my $summaries =\n          $archive->make_search_summary( $keyword, $search_results );\n\n        for (@$search_results) {\n\n            my ( $subject, $message, $format ) = $archive->get_archive_info($_);\n            my $date = date_this(\n                -Packed_Date   => $_,\n                -Write_Month   => $ls->param('archive_show_month'),\n                -Write_Day     => $ls->param('archive_show_day'),\n                -Write_Year    => $ls->param('archive_show_year'),\n                -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n                -Write_Second  => $ls->param('archive_show_second'),\n            );\n\n            push(\n                @$ht_summaries,\n                {\n                    summary => $summaries->{$_},\n                    subject =>\n                      $archive->_parse_in_list_info( -data => $subject ),\n                    date        => $date,\n                    id          => $_,\n                    PROGRAM_URL => $DADA::Config::PROGRAM_URL,\n                    list        => uriescape($list),\n                }\n            );\n\n        }\n    }\n\n    my $archive_subscribe_form = '';\n    if ( $ls->param('hide_list') ne \"1\" ) {\n\n        # DEV: This takes the cake for worst hack I have found... today.\n        my $info = '<!-- tmpl_var list_settings.info -->';\n        $info = DADA::Template::Widgets::screen(\n            {\n                -data                     => \\$info,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [qw(list_settings.info)],\n            }\n        );\n\n        unless ( $ls->param('archive_subscribe_form') == 0 ) {\n            $archive_subscribe_form =\n              DADA::Template::Widgets::subscription_form(\n                {\n                    -list       => $ls->param('list'),\n                    -email      => $email,\n                }\n              );\n        }\n\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen => 'search_archive_screen.tmpl',\n            -with   => 'list',\n            -vars   => {\n                list_name         => $ls->param('list_name'),\n                uriescape_list    => uriescape($list),\n                list              => $list,\n                count             => $count,\n                ending            => $ending,\n                keyword           => $keyword,\n                summaries         => $ht_summaries,\n                search_results    => $ht_summaries->[0] ? 1 : 0,\n                subscription_form => $archive_subscribe_form,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n\n    if ( !$c->profile_on && $keyword =~ m/^[A-Za-z]+$/ )\n    {    # just words, basically.\n        $c->cache( $list . '.search_archive.' . $keyword . '.scrn', \\$scrn );\n    }\n    return $scrn;\n\n}\n\nsub send_archive {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $entry      = xss_filter( scalar $q->param('entry') );\n    my $from_email = xss_filter( scalar $q->param('from_email') );\n    my $to_email   = xss_filter( scalar $q->param('to_email') );\n    my $note       = xss_filter( scalar $q->param('note') );\n    my $list       = $q->param('list');\n\n\n\t# We're not going to accept GET requests:\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->default();\n\t}\n\n    my $errors = 0;\n\n    my $list_exists = check_if_list_exists( -List => $list );\n\n    if ( $list_exists <= 0 ) {\n        return user_error( { -list => $list, -error => \"no_list\" } );\n    }\n\n    if ( check_for_valid_email($to_email) == 1 ) {\n        $errors++;\n    }\n\n    if ( check_for_valid_email($from_email) == 1 ) {\n        $errors++;\n    }\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -from_session => 1 } );\n    my $allowed_to_view_archives = 1;\n    if ($prof) {\n        $allowed_to_view_archives =\n          $prof->allowed_to_view_archives( { -list => $list, } );\n    }\n\n    if ( $allowed_to_view_archives == 0 ) {\n        return user_error(\n            { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n    }\n\n    # CAPTCHA STUFF\n\n    my $captcha_fail    = 0;\n    my $can_use_captcha = can_use_Google_reCAPTCHA();\n    if ( \n\t\t   $ls->param('captcha_archive_send_form') == 1 \n\t\t&& $can_use_captcha == 1 \n\t) {\n\n        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t{\n\t\t\t\t -response    => $crf, \n\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t}\n\t\t);\n\n        if ( $captcha_status != 1 ) {\n            $errors++;\n            $captcha_fail = 1;\n        }        \n    }\n\n    if ( $ls->param('archive_send_form') != 1 ) {\n        $errors++;\n    }\n\n    if ( $errors > 0 ) {\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL\n              . '?flavor=archive&list='\n              . $list . '&id='\n              . $entry\n              . '&send_archive_errors='\n              . $errors\n              . '&captcha_fail='\n              . $captcha_fail );\n\n    }\n    else {\n\n        require DADA::MailingList::Archives;\n\n        my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n\n        if ( $entry =~ /newest/i ) {\n            $entry = $archive->newest_entry;\n        }\n        elsif ( $entry =~ /oldest/i ) {\n            $entry = $archive->oldest_entry;\n        }\n\n        my $archive_message_url =\n          $DADA::Config::PROGRAM_URL . '/archive/' . $list . '/' . $entry . '/';\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $archive->get_archive_info($entry);\n        chomp($subject);\n\n        # DEV: This is stupid, and I don't think it's a great idea.\n        $subject = $archive->_parse_in_list_info( -data => $subject );\n        ### /\n\t\t\n\t\trequire DADA::App::EmailThemes; \n\t\tmy $em = DADA::App::EmailThemes->new(\n\t\t\t{ \n\t\t\t\t-list      => $list,\n\t\t\t}\n\t\t);\n\t\tmy $etp = $em->fetch('send_archive_message');\n\t\t\n        require DADA::App::FormatMessages;\n        my $fm = DADA::App::FormatMessages->new( -List => $list );\n\t\t\n        require MIME::Entity;\n\n        # DEV: This should really be moved to DADA::App::Messages...\n        my $msg = MIME::Entity->build(\n            From => $fm->format_phrase_address(\n\t\t\t\t$etp->{vars}->{from_phrase}, \n\t\t\t\t$ls->param('list_owner_email'),\n\t\t\t), \n            To => $fm->format_phrase_address(\n\t\t\t\t$etp->{vars}->{to_phrase}, \n\t\t\t\t$to_email\n\t\t\t),\t\n            Subject => $etp->{vars}->{subject},\n            Type    => 'multipart/mixed',\n        );\n\n        my $pt = MIME::Entity->build(\n            Type     => 'text/plain',\n            Data     => $etp->{plaintext},\n            Encoding => $ls->param('plaintext_encoding')\n        );\n\n        my $html = MIME::Entity->build(\n            Type     => 'text/html',\n            Data     => $etp->{html},\n            Encoding => $ls->param('html_encoding'),\n        );\n\t\t\n        my $ma = MIME::Entity->build(\n\t\t\tType => 'multipart/alternative'\n\t\t);\n        $ma->add_part($pt);\n        $ma->add_part($html);\n\n        $msg->add_part($ma);\n\n        my $a_msg;\n\n        #... sort of weird.\n        if ($raw_msg) {\n\n            $a_msg = MIME::Entity->build(\n                Type        => 'message/rfc822',\n                Disposition => \"inline\",\n                Data => $archive->massage_msg_for_resending( -key => $entry ),\n            );\n\n        }\n        else {\n\n            $a_msg = MIME::Entity->build(\n                Type        => 'message/rfc822',\n                Disposition => \"inline\",\n                Type        => $format,\n                Data        => $message\n            );\n        }\n\n        $msg->add_part($a_msg);\n\n        require DADA::App::FormatMessages;\n        my $fm = DADA::App::FormatMessages->new( -List => $list );\n        $fm->use_email_templates(0);\n        $fm->use_header_info(1);\n\n        $msg = $fm->format_message(\n            {\n                -entity => $msg,\n            }\n        );\n\n        my ( $e_name, $e_domain ) = split( '@', $to_email, 2 );\n        my $entity = $fm->email_template(\n            {\n                -entity => $msg,\n                -list_settings_vars_param => { -list => $list, },\n                -vars                     => {\n                    from_email                => $from_email,\n                    to_email                  => $to_email,\n                    note                      => $note,\n                    archive_message_url       => $archive_message_url,\n                    archived_message_subject  => $subject,\n                    'subscriber.email_name'   => $e_name,\n                    'subscriber.email_domain' => $e_domain,\n                },\n            }\n        );\n\t\tundef($msg);\n        my $n_msg = safely_decode( $entity->as_string );\n        my ( $header_str, $body_str ) = split( \"\\n\\n\", $n_msg, 2 );\n\n        require DADA::Mail::Send;\n        my $mh = DADA::Mail::Send->new(\n            {\n                -list   => $list,\n                -ls_obj => $ls,\n            }\n        );\n\n        $mh->send( $mh->return_headers($header_str), Body => $body_str, );\n\n        require DADA::Logging::Clickthrough;\n        my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n        $r->forward_to_a_friend_log( { -mid => $entry, } );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL\n              . '?flavor=archive&list='\n              . $list . '&id='\n              . $entry\n              . '&send_archive_success=1' );\n\n    }\n}\n\nsub archive_rss {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = (\n        -type => 'rss',\n        @_\n    );\n    my $list = $q->param('list');\n\n    my $list_exists = check_if_list_exists( -List => $list );\n\n    if ( $list_exists == 0 ) {\n\n    }\n    else {\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        if ( $ls->param('show_archives') == 0 ) {\n\n        }\n        else {\n\n            require DADA::Profile;\n            my $prof = DADA::Profile->new( { -from_session => 1 } );\n            my $allowed_to_view_archives = 1;\n            if ($prof) {\n                $allowed_to_view_archives =\n                  $prof->allowed_to_view_archives( { -list => $list, } );\n            }\n\n            if ( $allowed_to_view_archives == 0 ) {\n                return '';\n            }\n\n            if ( $ls->param('publish_archives_rss') == 0 ) {\n\n            }\n            else {\n\n                if ( $args{-type} eq 'rss' ) {\n\n                    if ( $c->is_cached( 'archive_rss/' . $list ) ) {\n                        return $c->cached( 'archive_rss/' . $list . '.scrn' );\n                    }\n                    require DADA::MailingList::Archives;\n                    my $archive =\n                      DADA::MailingList::Archives->new( { -list => $list } );\n                    my $scrn = $archive->rss_index();\n                    $c->cache( 'archive_rss/' . $list . '.scrn', \\$scrn );\n                    my $headers = { -type => 'application/xml' };\n\n                    $self->header_props(%$headers);\n                    return $scrn;\n\n                }\n                elsif ( $args{-type} eq 'atom' ) {\n                    if ( $c->is_cached( 'archive_atom/' . $list ) ) {\n                        return $c->cached( 'archive_atom/' . $list . '.scrn' );\n                    }\n                    else {\n                        require DADA::MailingList::Archives;\n                        my $archive = DADA::MailingList::Archives->new(\n                            { -list => $list } );\n                        my $scrn = $archive->atom_index();\n                        $c->cache( 'archive_atom/' . $list . '.scrn', \\$scrn );\n                        my $headers = { -type => 'application/xml' };\n                        $self->header_props(%$headers);\n                        return $scrn;\n                    }\n                }\n                else {\n                    warn \"wrong type of feed asked for: \"\n                      . $args{-type} . ' - '\n                      . $!;\n                }\n            }\n        }\n    }\n}\n\nsub archive_atom {\n\n    my $self = shift;\n    my $q    = $self->query();\n    return $self->archive_rss( -type => 'atom' );\n}\n\n\n\n\n\n\nsub email_password { \n    my $self = shift;\n    my $q    = $self->query();\n\t\t\n\tif($q->request_method() =~ m/POST/i){\n\t\treturn $self->post_email_password(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_email_password.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\tlist         => $q->param('list'),\n\t\t\t\t\tpass_auth_id => $q->param('pass_auth_id'),\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n\n}\n\n\n\n\nsub post_email_password {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $list = $q->param('list');\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Security::Password;\n   # warn q{$q->param('pass_auth_id')} . $q->param('pass_auth_id');\n   # warn q{$ls->param('pass_auth_id')} . $ls->param('pass_auth_id');\n\n    if (   ( $ls->param('pass_auth_id') ne \"\" )\n        && ( defined( $ls->param('pass_auth_id') ) )\n        && ( $q->param('pass_auth_id') eq $ls->param('pass_auth_id') ) )\n    {\n\n        my $new_password = DADA::Security::Password::generate_password();\n\t\t\n        $ls->save(\n            {\n                -settings => {\n                    password     => $new_password,\n                    pass_auth_id => ''\n                }\n            }\n        );\n\n        require DADA::App::Messages;\n        my $dap = DADA::App::Messages->new( { -list => $list } );\n        $dap->send_out_message(\n            {\n                -message => 'list_password_reset_message',\n                -email   => $ls->param('list_owner_email'),\n\t\t\t\t-tmpl_params => {\n\t                -list_settings_vars_param => { -list => $list },\n\t                -vars    => {\n\t\t\t\t\t\tnew_password => $new_password,\n\t                },\n\t\t\t\t},\n            },\n        );\n\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->mj_log(\n            $list,\n            'List Password Reset',\n            \"remote_host:$ENV{REMOTE_HOST}, ip_address:\" \n\t\t\t. $ENV{REMOTE_ADDR}\n        ) if $DADA::Config::LOG{list_lives};\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor='\n              . $DADA::Config::SIGN_IN_FLAVOR_NAME\n              . '&list='\n              . $list\n              . '&list_password_reset=1' );\n    }\n    else {\n\n\t\t# Gotta put v3 in here - probably take it from Validate.pm\n\n\n        if ( can_use_Google_reCAPTCHA() ) {\n            \t\t\t\n\t        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\n            if ( $captcha_status == 0 ) {\n\t\t\t\t\n                require DADA::Template::Widgets;\n                return DADA::Template::Widgets::admin(\n                    {\n                        -cgi_obj => $q,\n                        -vars    => {\n                            selected_list   => $list,\n                            invalid_captcha => 1,\n                            errors => [ { error => 'invalid_password' } ],\n                        }\n                    }\n                );\n            }\n        }\n\n        my $random_string = DADA::Security::Password::generate_rand_string();\n\n        $ls->save(\n            {\n                -settings => {\n                    pass_auth_id => $random_string,\n                }\n            }\n        );\n\n        require DADA::App::Messages;\n        my $dap = DADA::App::Messages->new( { -list => $list } );\n        $dap->send_out_message(\n            {\n                -message => 'list_password_reset_confirmation_message',\n                -email   => $ls->param('list_owner_email'),\n\t\t\t\t-tmpl_params => {\n\t                -list_settings_vars_param => { -list => $list },\n\t                -vars    => {\n\t                    random_string => $random_string,\n\t                    REMOTE_HOST   => $ENV{REMOTE_HOST},\n\t                    REMOTE_ADDR   => $ENV{REMOTE_ADDR},\n\t                },\n\t\t\t\t},\n            },\n        );\n\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->mj_log(\n            $list,\n            'Sent Password Change Confirmation',\n            \"remote_host:$ENV{REMOTE_HOST}, ip_address:\" . $ENV{REMOTE_ADDR}\n        ) if $DADA::Config::LOG{list_lives};\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'list_password_confirmation_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    REMOTE_HOST => $ENV{REMOTE_HOST},\n                    REMOTE_ADDR => $ENV{REMOTE_ADDR},\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            },\n        );\n        return $scrn;\n    }\n}\n\nsub login {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $referer = $q->param('referer') || $DADA::Config::DEFAULT_ADMIN_SCREEN;\n    my $admin_password = $q->param('admin_password') || \"\";\n    my $admin_list     = $q->param('admin_list')     || \"\";\n    my $auth_state     = $q->param('auth_state')     || undef;\n\n    my $try_referer = $referer;\n\n    $try_referer =~ s/(^http\\:\\/\\/|^https\\:\\/\\/)//;\n    $try_referer =~ s/^www//;\n\n    my $reg_try_referer = quotemeta($try_referer);\n    if ( $DADA::Config::PROGRAM_URL =~ m/$reg_try_referer$/ ) {\n        $referer = $DADA::Config::DEFAULT_ADMIN_SCREEN;\n    }\n\n    my $list = $admin_list;\n\t\n\t# GET request not allowed. \n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\n    if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n        require DADA::Security::SimpleAuthStringState;\n        my $sast = DADA::Security::SimpleAuthStringState->new;\n        if ( $sast->check_state($auth_state) != 1 ) {\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => 'incorrect_login_url',\n                }\n            );\n        }\n    }\n    \n\t# Also, if we're to put this on the admin login form: \n    if (can_use_Google_reCAPTCHA() == 1 ) {\n\n        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t{\n\t\t\t\t -response    => $crf, \n\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t}\n\t\t);\n\t\tif($captcha_status == 0){ \n            return user_error(\n                {\n                    -list  => $list,\n                    -error => 'list_cp_login_recaptcha_failed',\n                }\n            );\n\t\t}\n\t}\n\n\n\n    my $cookie;\n\n    if ( check_if_list_exists( -List => $list ) >= 1 ) {\n\n        require DADA::Security::Password;\n        require DADA::App::Session;\n        my $dada_session = DADA::App::Session->new();\n\n        if ( $dada_session->logged_into_diff_list( -cgi_obj => $q ) != 1 ) {\n\n            my $login_cookies = $dada_session->login_cookies(\n                -cgi_obj  => $q,\n                -list     => $list,\n                -password => $admin_password\n            );\n\n            # not cached atm\n            # require DADA::App::ScreenCache;\n            # my $c = DADA::App::ScreenCache->new;\n            # $c->remove( 'login_switch_widget.' . $list . '.scrn' );\n\n            if ( $DADA::Config::LOG{logins} ) {\n                require DADA::Logging::Usage;\n                my $log = new DADA::Logging::Usage;\n                my $rh  = $ENV{REMOTE_HOST} || '';\n                my $ra  = $ENV{REMOTE_ADDR} || '';\n\n                $log->mj_log( $admin_list, 'login',\n                    'remote_host:' . $rh . ', ip_address:' . $ra );\n            }\n\n           # my $cookies = [ $dumb_cookie, @$login_cookies ];\n            my $headers = {\n                -cookie  => $login_cookies,\n                -nph     => $DADA::Config::NPH,\n                -Refresh => '0; URL=' . $referer\n            };\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -with           => 'list',\n                    -screen         => 'logging_in_screen.tmpl',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        show_profile_widget => 0,\n                        referer             => $referer,\n                    },\n                }\n            );\n\n            $dada_session->remove_old_session_files();\n\n            $self->header_props(%$headers);\n            $scrn;\n        }\n        else {\n\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => \"logged_into_different_list\",\n                }\n            );\n        }\n\n    }\n    else {\n        return user_error(\n            {\n                -list  => $list,\n                -error => \"no_list\",\n            }\n        );\n    }\n}\n\nsub logout {\n\n    my $self = shift;\n\n    my $q = $self->query();\n\n    my $headers = {};\n    my $body    = undef;\n\n\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\t\n    my %args = (\n        -redirect               => 1,\n        -redirect_url           => $DADA::Config::DEFAULT_LOGOUT_SCREEN,\n        -no_list_security_check => 0,\n        @_\n    );\n\n    my $admin_list;\n    my $root_login;\n\n    my $list_exists = check_if_list_exists( -List => $admin_list );\n\n    # I don't quite even understand why there's this check...\n    if ( $args{-no_list_security_check} == 0 ) {\n        if ( $list_exists == 1 ) {\n            my ( $admin_list, $root_login, $checksout, $error_msg ) =\n              check_list_security(\n                -cgi_obj  => $q,\n                -Function => 'logout'\n              );\n            if ( !$checksout ) { return $error_msg; }\n        }\n    }\n\n    # not cached atm\n    #require DADA::App::ScreenCache;\n    #my $c = DADA::App::ScreenCache->new;\n    #$c->remove( 'login_switch_widget.' . $admin_list . '.scrn' );\n\n    my $l_list = $admin_list;\n\n    my $location = $args{-redirect_url};\n\n    if ( $q->param('login_url') ) {\n        $location = $q->param('login_url');\n    }\n\n    if ( $DADA::Config::LOG{logins} != 0 ) {\n\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->mj_log( $l_list, 'logout',\n            \"remote_host:$ENV{REMOTE_HOST}, ip_address:$ENV{REMOTE_ADDR}\" );\n\n    }\n\n    require DADA::App::Session;\n    my $dada_session = DADA::App::Session->new( -List => $l_list );\n    my $logout_cookies = $dada_session->logout_cookie( -cgi_obj => $q );\n\n    if ( $args{-redirect} == 1 ) {\n\n        $headers = {\n            -cookie  => $logout_cookies,\n            -nph     => $DADA::Config::NPH,\n            -Refresh => '0; URL=' . $location,\n        };\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -with           => 'list',\n                -screen         => 'logging_out_screen.tmpl',\n                -wrapper_params => {\n                    -Use_Custom => 0,\n                },\n                -vars => {\n                    show_profile_widget => 0,\n                    location            => $location,\n                },\n            }\n        );\n\n        # Probably not setting up the header_props here, yey?\n\t\t$self->header_props({});\n        $self->header_props(%$headers);\n\t\t#return $scrn; \n        return ( $headers, $scrn );\n    }\n    else {\n        return $logout_cookies;    #DEV: not sure about this one...\n    }\n\n}\n\n#sub log_into_another_list {\n#\n#    my $self = shift;\n#    my $q    = $self->query();\n#\n#    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n#      check_list_security(\n#        -cgi_obj  => $q,\n#        -Function => 'log_into_another_list'\n#      );\n#    if ( !$checksout ) { return $error_msg; }\n#\n#    $self->logout( -redirect_url => $DADA::Config::PROGRAM_URL\n#          . '?flavor='\n#          . $DADA::Config::SIGN_IN_FLAVOR_NAME, );\n#\n#}\n\nsub change_login {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_login'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    die \"only for root logins!\"\n      if !$root_login;\n\n    require DADA::App::Session;\n    my $dada_session = DADA::App::Session->new();\n\n    my $change_to_list = $q->param('change_to_list');\n    my $location       = $q->param('location');\n    if ( $location !~ m/^http/ ) {\n        $location = 'http' . $location;\n    }\n\n    # DEV: Ooh. This is messy.\n    $location =~ s/(\\;|\\&)done\\=1$//;\n    $location =~ s/(\\;|\\&)delete_email_count\\=(.*?)$//;\n    $location =~ s/(\\;|\\&)email_count\\=(.*?)$//;\n\n    $location =~ s/f\\=add_email\\&fn\\=(.*?)(\\&)/f\\=add\\2/;\n\n    my $new_cookies = $dada_session->change_login(\n\t\t-cgi_obj => $q, \n\t\t-list    => $change_to_list\n\t);\n\n    # not cached atm\n    # require DADA::App::ScreenCache;\n    # my $c = DADA::App::ScreenCache->new;\n    # $c->remove( 'login_switch_widget.' . $change_to_list . '.scrn' );\n\n\t#$q->delete_all();\n\n\n\t\n    my $headers = {\n        -cookie  => $new_cookies,\n        -nph     => $DADA::Config::NPH,\n        -Refresh => '0; URL=' . $location\n    };\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -with           => 'list',\n            -screen         => 'logging_switch_screen.tmpl',\n            -wrapper_params => {\n                -Use_Custom => 0,\n            },\n            -vars => {\n                show_profile_widget => 0,\n                location            => $location,\n            },\n        }\n    );\n\t$self->header_props({});\n    $self->header_props(%$headers);\n    return $scrn;\n}\n\nsub remove_subscribers {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $type = $q->param('type');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $return_to      = $q->param('return_to') || '';\n    my $return_address = $q->param('return_address') || '';\n    my @address        = $q->multi_param('address');\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n        {\n            -addresses        => [@address],\n            -type             => $type,\n            -validation_check => 0,\n        }\n    );\n\n    my $flavor_to_return_to = 'view_list';\n    if ( $return_to eq 'membership' ) {    # or, others...\n        $flavor_to_return_to = $return_to;\n    }\n\n    my $qs =\n\n      'flavor='\n      . $flavor_to_return_to\n      . '&delete_email_count='\n      . $d_count\n      . '&type='\n      . $type\n      . '&black_list_add='\n      . $bl_count;\n\n    if ( $return_to eq 'membership' ) {\n        $qs .= '&email=' . uriescape($return_address);\n    }\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n}\n\nsub process_bouncing_addresses {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my @address = $q->multi_param('address');\n    my $type    = $q->param('type');\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $return_to      = $q->param('return_to')      || 'view_list';\n    my $return_address = $q->param('return_address') || undef;\n\n    if ( $q->param('process') =~ m/remove/i ) {\n        my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n            {\n                -addresses => [@address],\n                -type      => 'bounced_list',\n            }\n        );\n        my $uri =\n            $DADA::Config::S_PROGRAM_URL\n          . '?flavor='\n          . $return_to\n          . '&bounced_list_removed_from_list='\n          . $d_count\n          . '&type='\n          . $type\n          . '&black_list_add='\n          . $bl_count\n          . '&email='\n          . uriescape($return_address);\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $uri );\n\n    }\n    elsif ( $q->param('process') =~ m/move/i ) {\n\n        my $m_count = 0;\n\n        for my $address (@address) {\n            $lh->move_subscriber(\n                {\n                    -email => $address,\n                    -from  => 'bounced_list',\n                    -to    => 'list',\n                    -mode  => 'writeover',\n                }\n            );\n            $m_count++;\n        }\n\n# maybe if the bounce_list num_subscribers count is 0, we just go to the view_list screen.\n        my $uri =\n            $DADA::Config::S_PROGRAM_URL\n          . '?flavor='\n          . $return_to\n          . '&type='\n          . $type\n          . '&bounced_list_moved_to_list_count='\n          . $m_count\n          . '&email='\n          . uriescape($return_address);\n        $self->header_type('redirect');\n        $self->header_props( -url => $uri );\n\n    }\n    else {\n        croak \"I'm not sure what I'm supposed to do!\";\n    }\n}\n\nsub find_attachment_type {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $filename = shift;\n    my $a_type;\n\n    my $attach_name = $filename;\n    $attach_name =~ s!^.*(\\\\|\\/)!!;\n    $attach_name =~ s/\\s/%20/g;\n\n    my $file_ending = $attach_name;\n    $file_ending =~ s/.*\\.//;\n\n\ttry {\n\t    require MIME::Types;\n\t    require MIME::Type;\n\t    my ( $mimetype, $encoding ) = MIME::Types::by_suffix($filename);\n\t    $a_type = $mimetype\n\t\t\tif ( $mimetype && $mimetype =~ /^\\S+\\/\\S+$/ );    ### sanity check\n\t} catch { \n\t\t#...\n\t};\n\n\tif(!$a_type){\n        if ( exists( $DADA::Config::MIME_TYPES{ '.' . lc($file_ending) } ) ) {\n            $a_type = $DADA::Config::MIME_TYPES{ '.' . lc($file_ending) };\n        }\n        else {\n            $a_type = $DADA::Config::DEFAULT_MIME_TYPE;\n        }\n    }\n\t\n    if ( !$a_type ) {\n        warn\n\"attachment MIME Type never figured out, letting MIME::Lite handle this...\";\n        $a_type = 'AUTO';\n    }\n\n    return $a_type;\n}\n\nsub file_upload {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $upload_file = shift;\n    require CGI;\n    my $fu = CGI->new;\n    $fu->charset($DADA::Config::HTML_CHARSET);\n    my $file = $fu->param($upload_file);\n    if ( $file ne \"\" ) {\n        my $fileName = $file;\n        $fileName =~ s!^.*(\\\\|\\/)!!;\n\n        $fileName = uriescape($fileName);\n\n        my $outfile =\n          make_safer( $DADA::Config::TMP . '/' . time . '_' . $fileName );\n\n        open( OUTFILE, '>' . $outfile )\n          or warn( \"can't write to '\" . $outfile . \"' because: $!\" );\n        while ( my $bytesread = read( $file, my $buffer, 1024 ) ) {\n            print OUTFILE $buffer;\n        }\n        close(OUTFILE);\n        chmod( $DADA::Config::FILE_CHMOD, $outfile );\n        return $outfile;\n    }\n\n}\n\nsub pass_gen {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $pw = $q->param('pw');\n\n    if ( !$pw ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'pass_gen_screen.tmpl',\n                -with   => 'list',\n                -expr   => 1,\n                -vars   => {},\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        require DADA::Security::Password;\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'pass_gen_process_screen.tmpl',\n                -with   => 'list',\n                -expr   => 1,\n                -vars   => {\n                    encrypted_password =>\n                      DADA::Security::Password::encrypt_passwd($pw),\n                },\n            }\n        );\n        return $scrn;\n    }\n\n}\n\nsub setup_info {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $root_password = $q->param('root_password') || '';\n\n    my $from_control_panel = 0;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'setup_info',\n      );\n    my $list = undef;\n    if ( $checksout == 1 && $root_password eq '' ) {\n        $from_control_panel = 1;\n        $list               = $admin_list;\n    }\n\n    if ( $checksout == 1 || root_password_verification($root_password) == 1 ) {\n\n# If we have a .dada_config file, this is a contemporary installation, we'll say.\n        my $c_install = 0;\n\n        # Not sure why I should do this check at all, if the \"auto\" dealy\n        # could be set, anyways,\n        if (\n            (\n                   -e $DADA::Config::PROGRAM_CONFIG_FILE_DIR\n                && -d $DADA::Config::PROGRAM_CONFIG_FILE_DIR\n            )\n            || $DADA::Config::PROGRAM_CONFIG_FILE_DIR eq 'auto'\n          )\n        {\n            if ( -e $DADA::Config::CONFIG_FILE ) {\n                $c_install = 1;\n            }\n        }\n\n        my $config_file_contents = undef;\n        if ( -e $DADA::Config::CONFIG_FILE ) {\n            $config_file_contents =\n              DADA::Template::Widgets::_slurp($DADA::Config::CONFIG_FILE);\n        }\n        my $config_pm_file_contents =\n          DADA::Template::Widgets::_slurp('DADA/Config.pm');\n\n        my $files_var_exist = 0;\n        if ( -e $DADA::Config::FILES ) {\n            $files_var_exist = 1;\n        }\n\n        my $config_vals = [];\n\n        for (@DADA::Config::EXPORT_OK) {\n            my $orig_name = $_;\n            $_ =~ s/^(\\$|\\@|\\%)//;\n            my $sigil = $1;\n\n            require Data::Dumper;\n\n            my $var_val = undef;\n            if ( $sigil eq '$' ) {\n                $var_val = Data::Dumper::Dumper( ${ $DADA::Config::{$_} } );\n            }\n            elsif ( $sigil eq '@' ) {\n                $var_val = Data::Dumper::Dumper( \\@{ $DADA::Config::{$_} } );\n            }\n            elsif ( $sigil eq '%' ) {\n                $var_val = Data::Dumper::Dumper( \\%{ $DADA::Config::{$_} } );\n            }\n            else {\n                $var_val = '???';\n            }\n\n            #$var_val =~ s/^(.*?)\\'//m;\n            $var_val =~ s/^\\$VAR(.*?)\\= //;\n            $var_val =~ s/^\\'//;\n            $var_val =~ s/(\\';|\\'$)$//;\n            $var_val =~ s/\\;$//;\n\n            push( @$config_vals, { name => $orig_name, value => $var_val } );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'setup_info_screen.tmpl',\n                (\n                    $from_control_panel == 1\n                    ? (\n                        -with           => 'admin',\n                        -wrapper_params => {\n                            -Root_Login => $root_login,\n                            -List       => $list,\n                        },\n                      )\n                    : ( -with => 'list', )\n                ),\n                -vars => {\n                    FILES => $DADA::Config::FILES,\n                    PROGRAM_ROOT_PASSWORD =>\n                      $DADA::Config::PROGRAM_ROOT_PASSWORD,\n                    MAILPROG => $DADA::Config::MAILPROG,\n                    PROGRAM_CONFIG_FILE_DIR =>\n                      $DADA::Config::PROGRAM_CONFIG_FILE_DIR,\n                    PROGRAM_ERROR_LOG       => $DADA::Config::PROGRAM_ERROR_LOG,\n                    screen                  => 'setup_info',\n                    c_install               => $c_install,\n                    config_file_contents    => $config_file_contents,\n                    config_pm_file_contents => $config_pm_file_contents,\n                    files_var_exist         => $files_var_exist,\n                    config_vals             => $config_vals,\n\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        if ( $from_control_panel == 1 ) {\n\n            # just doin' this again, w/o the manual override:\n            my ( $admin_list, $root_login, $checksout, $error_msg ) =\n              check_list_security(\n                -cgi_obj  => $q,\n                -Function => 'setup_info',\n              );\n            if ( !$checksout ) { return $error_msg; }\n        }\n        else {\n\n            my $guess = $DADA::Config::PROGRAM_URL;\n            $guess = $q->script_name()\n              if $DADA::Config::PROGRAM_URL eq \"\"\n              || $DADA::Config::PROGRAM_URL eq\n              'https://www.changetoyoursite.com/cgi-bin/dada/mail.cgi'\n              ;    # default.\n\n            my $incorrect_root_password = $root_password ? 1 : 0;\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'setup_info_login_screen.tmpl',\n                    -with   => 'list',\n                    -vars   => {\n                        program_url_guess       => $guess,\n                        incorrect_root_password => $incorrect_root_password,\n                        PROGRAM_URL             => $DADA::Config::PROGRAM_URL,\n                        S_PROGRAM_URL           => $DADA::Config::S_PROGRAM_URL,\n                    },\n                }\n            );\n            return $scrn;\n        }\n\n    }\n\n}\n\nsub reset_cipher_keys {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $root_password   = $q->param('root_password');\n    my $root_pass_check = root_password_verification($root_password);\n\n    if ( $root_pass_check == 1 ) {\n        require DADA::Security::Password;\n        my @lists = available_lists();\n\n        require DADA::MailingList::Settings;\n\n        for (@lists) {\n            my $ls = DADA::MailingList::Settings->new( { -list => $_ } );\n            $ls->save(\n                {\n                    -settings => {\n                        cipher_key =>\n                          DADA::Security::Password::make_cipher_key()\n                    }\n                }\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            -screen => 'reset_cipher_keys_process.tmpl',\n            -with   => 'list',\n        );\n        return $scrn;\n\n    }\n    else {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            -screen => 'reset_cipher_keys.tmpl',\n            -with   => 'list',\n        );\n        return $scrn;\n    }\n\n}\n\nsub restore_lists {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n\n    if ( root_password_verification( $q->param('root_password') ) ) {\n\n        require DADA::MailingList::Settings;\n\n        require DADA::MailingList::Archives;\n\n        # No SQL veresion, so don't worry about handing over the dbi handle...\n\n        my @lists = available_lists();\n\n        if ( $process eq 'true' ) {\n\n            my $report = '';\n\n            my %restored;\n            for my $r_list (@lists) {\n                if (   $q->param( 'restore_' . $r_list . '_settings' )\n                    && $q->param( 'restore_' . $r_list . '_settings' ) == 1 )\n                {\n                    my $ls =\n                      DADA::MailingList::Settings->new( { -list => $r_list } );\n                    $ls->{ignore_open_db_error} = 1;\n                    $report .=\n                      $ls->restoreFromFile(\n                        $q->param( 'settings_' . $r_list . '_version' ) );\n                }\n            }\n            for my $r_list (@lists) {\n                if (   $q->param( 'restore_' . $r_list . '_archives' )\n                    && $q->param( 'restore_' . $r_list . '_archives' ) == 1 )\n                {\n                    my $ls =\n                      DADA::MailingList::Settings->new( { -list => $r_list } );\n                    $ls->{ignore_open_db_error} = 1;\n                    my $la = DADA::MailingList::Archives->new(\n                        { -list => $r_list, -ignore_open_db_error => 1 } );\n                    $report .=\n                      $la->restoreFromFile(\n                        $q->param( 'archives_' . $r_list . '_version' ) );\n                }\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'restore_lists_complete.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                }\n            );\n            return $scrn;\n\n        }\n        else {\n\n            my $backup_hist = {};\n            for my $l (@lists) {\n                my $ls = DADA::MailingList::Settings->new( { -list => $l } );\n                $ls->{ignore_open_db_error} = 1;\n                my $la =\n                  DADA::MailingList::Archives->new(\n                    { -list => $l, -ignore_open_db_error => 1 } )\n                  ;    #yeah, it's diff from MailingList::Settings - I'm stupid.\n\n                $backup_hist->{$l}->{settings} = $ls->backupDirs\n                  if $ls->uses_backupDirs;\n                $backup_hist->{$l}->{archives} = $la->backupDirs\n                  if $la->uses_backupDirs;\n\n            }\n\n            my $restore_list_options = '';\n\n            #    labels are for the popup menus, that's it    #\n            my $labels = {};\n\n            #use Data::Dumper;\n            for my $l ( sort keys %$backup_hist ) {\n\n                for my $bu ( @{ $backup_hist->{$l}->{settings} } ) {\n                    my ( $time_stamp, $appended ) = ( '', '' );\n                    if ( $bu->{dir} =~ /\\./ ) {\n                        ( $time_stamp, $appended ) =\n                          split( /\\./, $bu->{dir}, 2 );\n                    }\n                    else {\n                        $time_stamp = $bu->{dir};\n                    }\n\n                    $labels->{$l}->{settings}->{ $bu->{dir} } =\n                        scalar( localtime($time_stamp) ) . ' ('\n                      . $bu->{count}\n                      . ' entries)';\n\n                }\n\n                for my $bu ( @{ $backup_hist->{$l}->{archives} } ) {\n\n                    my ( $time_stamp, $appended ) = ( '', '' );\n                    if ( $bu->{dir} =~ /\\./ ) {\n                        ( $time_stamp, $appended ) =\n                          split( /\\./, $bu->{dir}, 2 );\n                    }\n                    else {\n                        $time_stamp = $bu->{dir};\n                    }\n\n                    $labels->{$l}->{archives}->{ $bu->{dir} } =\n                        scalar( localtime($time_stamp) ) . ' ('\n                      . $bu->{count}\n                      . ' entries)';\n\n                }\n                for my $bu ( @{ $backup_hist->{$l}->{schedules} } ) {\n\n                    my ( $time_stamp, $appended ) = ( '', '' );\n                    if ( $bu->{dir} =~ /\\./ ) {\n                        ( $time_stamp, $appended ) =\n                          split( /\\./, $bu->{dir}, 2 );\n                    }\n                    else {\n                        $time_stamp = $bu->{dir};\n                    }\n\n                    $labels->{$l}->{schedules}->{ $bu->{dir} } =\n                        scalar( localtime($time_stamp) ) . ' ('\n                      . $bu->{count}\n                      . ' entries)';\n\n                }\n            }\n\n            #\n\n            for my $f_list ( keys %$backup_hist ) {\n\n                $restore_list_options .=\n                  $q->start_table( { -cellpadding => 5 } );\n                $restore_list_options .= $q->h3($f_list);\n\n                $restore_list_options .= $q->Tr(\n                    $q->td(\n                        { -valign => 'top' },\n                        [\n                            ( $q->p( $q->strong('Restore?') ) ),\n                            ( $q->p( $q->strong('Backup Version*:') ) ),\n                        ]\n                    )\n                );\n\n                for my $t ( 'settings', 'archives', 'schedules' ) {\n\n                    #\t\trequire Data::Dumper;\n                    #\t\tdie Data::Dumper::Dumper(%labels);\n                    my $vals = [];\n                    for my $d ( @{ $backup_hist->{$f_list}->{$t} } ) {\n                        push( @$vals, $d->{dir} );\n                    }\n\n                    $restore_list_options .= $q->Tr(\n                        $q->td(\n                            [\n                                (\n                                    $q->p(\n                                        $q->checkbox(\n                                            -name => 'restore_'\n                                              . $f_list . '_'\n                                              . $t,\n                                            -id => 'restore_'\n                                              . $f_list . '_'\n                                              . $t,\n                                            -value => 1,\n                                            -label => ' ',\n                                        ),\n                                        '<label for=\"'\n                                          . 'restore_'\n                                          . $f_list . '_'\n                                          . $t . '\">'\n                                          . $t\n                                          . '</label>'\n                                    )\n                                ),\n\n                                ( scalar @{ $backup_hist->{$f_list}->{$t} } )\n                                ? (\n\n                                    (\n                                        '<p>'\n                                          . HTML::Menu::Select::popup_menu(\n                                            {\n                                                name => $t . '_'\n                                                  . $f_list\n                                                  . '_version',\n                                                values => $vals,\n                                                labels =>\n                                                  $labels->{$f_list}->{$t},\n                                            }\n                                          )\n                                          . '</p>'\n                                    ),\n\n                                  )\n                                : (\n\n                                    (\n                                        $q->p(\n                                            { -class => 'error' },\n                                            '-- No Backup Information Found --'\n                                        ),\n                                        $q->hidden(\n                                            -name => $t . '_'\n                                              . $f_list\n                                              . '_version',\n                                            -value => 'just_remove_blank'\n                                        )\n                                    ),\n                                ),\n                            ]\n                        )\n                    );\n                    $vals = [];\n\n                }\n                $restore_list_options .= '</table>';\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'restore_lists_options_screen.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        restore_list_options => $restore_list_options,\n                        root_password =>\n                          xss_filter( scalar $q->param('root_password') ),\n                    }\n                }\n            );\n            return $scrn;\n\n        }\n\n    }\n    else {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            { -screen => 'restore_lists_screen.tmpl', -with => 'list', } );\n        return $scrn;\n    }\n\n}\n\nsub subscription_form_html {\n\n    my $self                 = shift;\n    my $q                    = $self->query();\n    my $list                 = $q->param('list');\n    my $subscription_form_id = $q->param('subscription_form_id')\n      || 'jquery_subscription_form';\n\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        {\n            -subscription_form_id => $subscription_form_id,\n            -show_fieldset        => 0,\n            -magic_form           => 0,\n            ( defined($list) ? ( -list => $list, ) : () )\n        }\n    );\n    if ( $q->param('_method') eq 'GET' && $q->param('callback') ) {\n\n        my $headers = {\n            -type                           => 'application/javascript',\n            '-Access-Control-Allow-Origin'  => '*',\n            '-Access-Control-Allow-Methods' => 'POST',\n            '-Cache-Control'                => 'no-cache, must-revalidate',\n            -expires                        => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        };\n\n        my $callback = xss_filter( strip( $q->url_param('callback') ) );\n        require JSON;\n        my $json = JSON->new->allow_nonref;\n        my $r   = $json->encode( { subscription_form => $subscription_form } );\n\n        $self->header_props(%$headers);\n        return $callback . '(' . $r . ');';\n    }\n    else {\n        return $subscription_form;\n    }\n}\n\nsub subscriber_help {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $list = $q->param('list');\n\n    if ( !$list ) {\n        return $self->default();\n    }\n\n    if ( check_if_list_exists( -List => $list ) == 0 ) {\n        undef($list);\n        return $self->default();\n    }\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen => 'subscriber_help_screen.tmpl',\n            -with   => 'list',\n            -vars   => {\n                list      => $list,\n                list_name => $ls->param('list_name'),\n                list_owner_email =>\n                  spam_me_not_encode( $ls->param('list_owner_email') ),\n            }\n        }\n    );\n    return $scrn;\n\n}\n\nsub show_img {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    $self->file_attachment( -inline_image_mode => 1 );\n}\n\nsub file_attachment {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $list = $q->param('list');\n\n    # Weird:\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email',\n      );\n\n    #if(!$checksout){ return $error_msg; }\n\n    my %args = (\n        -inline_image_mode => 0,\n        @_\n    );\n\n    my $id = $q->param('id') || undef;\n\n    if ( check_if_list_exists( -List => $list ) == 1 ) {\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        if ( $ls->param('show_archives') == 1 || $checksout == 1 ) {\n\n            if ( $ls->param('display_attachments') == 1 || $checksout == 1 ) {\n\n                require DADA::MailingList::Archives;\n\n                my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n                if ( $la->can_display_attachments ) {\n\n                    if ( $la->check_if_entry_exists( $q->param('id') ) ) {\n\n                        if ( $args{-inline_image_mode} == 1 ) {\n\n#  if (\n#      $c->is_cached(\n#          'view_inline_attachment.' . $list . '.' . $id . '.' . scalar($q->param('cid')) . '.cid'\n#      )\n#    )\n#  {\n#      return $c->cached(\n#          'view_inline_attachment.' . $list . '.' . $id . '.' . scalar($q->param('cid')) . '.cid' );\n#  }\n                            my ( $h, $scrn ) = $la->view_inline_attachment(\n                                -id  => scalar $q->param('id'),\n                                -cid => scalar $q->param('cid')\n                            );\n\n# Bettin' that it's binary (or at least, unencoded)\n# $c->cache( 'view_inline_attachment.' . $list . '.' . $id . '.' . scalar($q->param('cid')) . '.cid',\n#        \\$scrn );\n#    return $scrn;\n\n                            $self->header_props($h);\n                            return $scrn;\n\n                        }\n                        else {\n#if (\n#    $c->is_cached(\n#        'view_file_attachment.' . $list . '.' . $id . '.' . scalar($q->param('filename'))\n#    )\n#  )\n#{\n#    return $c->cached(\n#        'view_file_attachment.' . $list . '.' . $id . '.' . scalar($q->param('filename') ));\n#}\n#else {\n\n                            my ( $h, $scrn ) = $la->view_file_attachment(\n                                -id       => scalar $q->param('id'),\n                                -filename => scalar $q->param('filename')\n                            );\n\n#$c->cache( 'view_file_attachment.' . $list . '.' . $id . '.' . scalar($q->param('filename')),\n#    \\$scrn );\n\n# Binary. Well, actually, *probably* - how would you figure out the content-type of an attached file?\n                            $self->header_props($h);\n                            return $scrn;\n\n                            #}\n                        }\n\n                    }\n                    else {\n                        return user_error(\n                            { -list => $list, -error => \"no_archive_entry\" } );\n                    }\n\n                }\n                else {\n                    return user_error(\n                        { -list => $list, -error => \"no_display_attachments\" }\n                    );\n                }\n\n            }\n            else {\n                return user_error(\n                    { -list => $list, -error => \"no_display_attachments\" } );\n            }\n\n        }\n        else {\n            return user_error(\n                { -list => $list, -error => \"no_show_archives\" } );\n        }\n\n    }\n    else {\n        return user_error( { -list => $list, -error => 'no_list' } );\n    }\n\n}\n\n\n\n\nsub redirection { \n    my $self = shift;\n    my $q    = $self->query();\n\t\n\n    if ( check_if_list_exists( -List => $q->param('list') ) == 0 ) {\n\t\treturn $self->default();\n    }\n\trequire DADA::MailingList::Settings; \n\tmy $ls = DADA::MailingList::Settings->new({-list => $q->param('list')});\n\t\n\t \n\tif(\n\t\t   $q->request_method() =~ m/POST/i\n\t\t|| $ls->param('tracker_protect_tracked_links_from_prefetching') != 1\n\t){\n\t\treturn $self->post_redirection(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_redirection.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\t\n\t\t\t\t\tlist   => $q->param('list'),\n\t\t\t\t\tkey    => $q->param('key'),\n\t\t\t\t\temail  => $q->param('email'),\n\t\t\t\t\t\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n\n}\n\n\n\n\nsub post_redirection {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    #\tuse Data::Dumper;\n    #\tdie Dumper([$q->param('key'), $q->param('email')] );\n    require DADA::Logging::Clickthrough;\n    my $r =\n      DADA::Logging::Clickthrough->new( { -list => scalar $q->param('list') } );\n    if ( defined( $q->param('key') ) ) {\n\n        my ( $mid, $url, $atts ) = $r->fetch( $q->param('key') );\n\n        if ( defined($mid) && defined($url) ) {\n            $r->r_log(\n                {\n                    -mid   => $mid,\n                    -url   => $url,\n                    -atts  => $atts,\n                    -email => scalar $q->param('email'),\n                }\n            );\n        }\n        if ($url) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $url );\n        }\n        else {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::PROGRAM_URL );\n        }\n    }\n    else {\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL );\n    }\n}\n\nsub m_o_c {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $list = xss_filter( scalar $q->param('list') );\n\n    if ( check_if_list_exists( -List => $list ) == 0 ) {\n        carp \"list: '$list' does not exist, aborted logging of open message\\n\"\n          . 'path_info(): '\n          . $q->path_info();\n\n    }\n    else {\n        require DADA::Logging::Clickthrough;\n        my $r = DADA::Logging::Clickthrough->new(\n            { -list => scalar $q->param('list') } );\n        if ( defined( $q->param('mid') ) ) {\n\n            $r->open_log(\n                {\n                    -mid   => scalar $q->param('mid'),\n                    -email => scalar $q->param('email'),\n                }\n            );\n        }\n    }\n    require MIME::Base64;\n    my $headers = {\n        -type            => 'image/png',\n        '-Cache-Control' => 'no-cache, max-age=0',\n\n        # '-Content-Length' => 0,\n    };\n\n    # a simple, 1px png image.\n    my $str = <<EOF\niVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAMAAAAoyzS7AAAABGdBTUEAANbY1E9YMgAAABl0RVh0\nU29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAGUExURf///wAAAFXC034AAAABdFJOUwBA\n5thmAAAADElEQVR42mJgAAgwAAACAAFPbVnhAAAAAElFTkSuQmCC\nEOF\n      ;\n    $self->header_props(%$headers);\n    return MIME::Base64::decode_base64($str);\n\n}\n\nsub css {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    # Backwards compat -\n    my $headers = { -type => 'text/css' };\n\n    if ( $q->param('css_file') eq 'dada_mail.css' ) {\n\n        my $body = DADA::Template::Widgets::_raw_screen(\n            {\n                -screen => $DADA::Config::SUPPORT_FILES->{dir}\n                  . '/static/css/dada_mail.css'\n            }\n        );\n\n        $self->header_props(%$headers);\n        return $body;\n    }\n    else {\n        $self->header_props(%$headers);\n    }\n}\n\nsub ver {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    return $DADA::Config::VER;\n}\n\nsub author {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    return \"Dada Mail is originally written by Justin Simoni\";\n\n}\n\nsub profile_login {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $whole_url = $q->url( -path_info => 1, -query => 0 );\n    if ( exists( $ENV{QUERY_STRING} ) ) {\n        if ( length( $ENV{QUERY_STRING} ) > 0 ) {\n            $whole_url .= '?' . $ENV{QUERY_STRING};\n        }\n    }\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n\n    }\n\n    if ( $DADA::Config::PROFILE_OPTIONS->{enabled} != 1 ) {\n        return $self->default();\n    }\n    require DADA::Profile;\n    ###\n    my $all_errors = [];\n    my $named_errs = {};\n    my $errors     = $q->param('errors');\n    for (@$errors) {\n        $named_errs->{ 'error_' . $_ } = 1;\n        push( @$all_errors, { error => $_ } );\n    }\n    ###\n\n    require DADA::Profile::Session;\n    my $prof_sess = DADA::Profile::Session->new;\n\n    if ( $q->param('process') != 1 ) {\n\n        if (   $prof_sess->is_logged_in( { -cgi_obj => $q } )\n            && $q->param('logged_out') != 1 )\n        {\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::PROGRAM_URL . '/profile/' );\n        }\n        else {\n            my $scrn              = '';\n            my $using_captcha     = 0;\n\n            if ( $DADA::Config::PROFILE_OPTIONS->{enable_captcha} == 1 ) {\n                $using_captcha = can_use_Google_reCAPTCHA();\n            }\n\n            $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'profile_login.tmpl',\n                    -with   => 'list',\n                    -expr   => 1,\n                    -vars   => {\n                        errors => $all_errors,\n                        %$named_errs,\n\n                        email => xss_filter( scalar $q->param('email') )\n                          || '',\n                        login_email =>\n                          xss_filter( scalar $q->param('login_email') )\n                          || '',\n                        register_email =>\n                          xss_filter( scalar $q->param('register_email') )\n                          || '',\n                        reset_email =>\n                          xss_filter( scalar $q->param('reset_email') )\n                          || '',\n                        register_email_again => xss_filter(\n                            scalar $q->param('register_email_again')\n                          )\n                          || '',\n\n                        error_profile_login =>\n                          scalar $q->param('error_profile_login') || '',\n                        error_profile_register =>\n                          scalar $q->param('error_profile_register') || '',\n                        error_profile_activate =>\n                          scalar $q->param('error_profile_activate') || '',\n                        error_profile_reset_password =>\n                          scalar $q->param('error_profile_reset_password')\n                          || '',\n                        password_changed => scalar $q->param('password_changed')\n                          || '',\n                        logged_out => scalar $q->param('logged_out') || '',\n                        can_use_captcha => $using_captcha,\n                        welcome         => scalar $q->param('welcome') || '',\n                        removal         => scalar $q->param('removal') || '',\n                        WHOLE_URL       => $whole_url,\n\t\t\t\t\t\t\n\t\t\t\t\t\t# This should probably be deprecated, as I'm handling this in \n\t\t\t\t\t\t# DADA::Template::Widgets, now\n                        %{ DADA::Profile::feature_enabled() }\n                    },\n\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n        my ( $status, $errors ) = $prof_sess->validate_profile_login(\n            {\n                -email    => xss_filter( scalar $q->param('login_email') ),\n                -password => xss_filter( scalar $q->param('login_password') ),\n\n            },\n        );\n\n        if ( $status == 1 ) {\n            my $cookie = $prof_sess->login(\n                {\n                    -email => xss_filter( scalar $q->param('login_email') ),\n                    -password =>\n                      xss_filter( scalar $q->param('login_password') ),\n                },\n            );\n\n            #DEV: encoding?\n            my $headers = {\n                -cookie  => [$cookie],\n                -nph     => $DADA::Config::NPH,\n                -Refresh => '0; URL='\n                  . $DADA::Config::PROGRAM_URL\n                  . '/profile/'\n            };\n            my $body = $q->start_html(\n                -title   => 'Logging in...',\n                -BGCOLOR => '#FFFFFF'\n            );\n            $body .= $q->p(\n                $q->a(\n                    { -href => $DADA::Config::PROGRAM_URL . '/profile/' },\n                    'Logging in...'\n                )\n            );\n            $body .= $q->end_html();\n\n            $self->header_props(%$headers);\n            return $body;\n        }\n        else {\n            my $p_errors = [];\n            for ( keys %$errors ) {\n                if ( $errors->{$_} == 1 ) {\n                    push( @$p_errors, $_ );\n                }\n            }\n            $q->param( 'errors',              $p_errors );\n            $q->param( 'process',             0 );\n            $q->param( 'error_profile_login', 1 );\n            return $self->profile_login();\n        }\n    }\n\n}\n\nsub profile_register {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1 ) {\n        return $self->default();\n    }\n\n    require DADA::Profile;\n    if ( !DADA::Profile::feature_enabled('register') == 1 ) {\n        return $self->default();\n    }\n\n    my $register_email =\n      strip( cased( xss_filter( scalar $q->param('register_email') ) ) );\n    my $register_email_again =\n      strip( cased( xss_filter( scalar $q->param('register_email_again') ) ) );\n    my $register_password =\n      strip( xss_filter( scalar $q->param('register_password') ) );\n\n    my $prof = DADA::Profile->new( { -email => $register_email } );\n\n    if ( $prof->exists()\n        && !$prof->is_activated() )\n    {\n        $prof->remove();\n    }\n\n    my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n    my ( $status, $errors ) = $prof->is_valid_registration(\n        {\n            -email                     => $register_email,\n            -email_again               => $register_email_again,\n            -password                  => $register_password,\n            -recaptcha_response_field  => $crf,\n        }\n    );\n\n    if ( $status == 0 ) {\n        my $p_errors = [];\n        for ( keys %$errors ) {\n            if ( $errors->{$_} == 1 ) {\n                push( @$p_errors, $_ );\n            }\n        }\n        $q->param( 'errors',                 $p_errors );\n        $q->param( 'error_profile_register', 1 );\n        return $self->profile_login();\n\n    }\n    else {\n        $prof->setup_profile( { -password => $register_password, } );\n        my $scrn = '';\n\n        $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'profile_register.tmpl',\n                -with   => 'list',\n                -vars   => {\n\n                    'profile.email' => $register_email,\n                }\n            }\n        );\n        return $scrn;\n\n    }\n}\n\n\n\n\nsub profile_activate { \n    my $self = shift;\n    my $q    = $self->query();\n\t\n\tif($q->request_method() =~ m/POST/i){\n\t\treturn $self->post_redirection(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_profile_activate.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\temail => $q->param('email'),\n\t\t\t\t\tauth_code => $q->param('auth_code'),\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n}\n\n\n\n\nsub post_profile_activate {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\n    require DADA::Profile;\n    if ( !DADA::Profile::feature_enabled('register') == 1 ) {\n        return $self->default();\n    }\n\t\n\t\n\tmy $email     = strip( cased( xss_filter( scalar $q->param('email') ) ) );\n    my $auth_code = xss_filter( scalar $q->param('auth_code') );\n\n    my $prof = DADA::Profile->new( { -email => $email } );\n\n    if ( $email && $auth_code ) {\n        my ( $status, $errors ) = $prof->is_valid_activation(\n            {\n                -auth_code => xss_filter( scalar $q->param('auth_code') ) || '',\n            }\n        );\n        if ( $status == 1 ) {\n            $prof->activate;\n            my $profile = $prof->get;\n            $q->param( 'welcome', 1 );\n            return $self->profile_login();\n        }\n        else {\n            my $p_errors = [];\n            for ( keys %$errors ) {\n                if ( $errors->{$_} == 1 ) {\n                    push( @$p_errors, $_ );\n                }\n            }\n            $q->param( 'errors', $p_errors );\n            $q->param( 'error_invalid_auth_code',\n                $errors->{invalid_auth_code} );\n            $q->param( 'error_profile_activate', 1 );\n            return $self->profile_login();\n        }\n    }\n    else {\n        return 'no email or auth code!';\n    }\n}\n\nsub profile {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $whole_url = $q->url( -path_info => 1, -query => 0 );\n    if ( exists( $ENV{QUERY_STRING} ) ) {\n        if ( length( $ENV{QUERY_STRING} ) > 0 ) {\n            $whole_url .= '?' . $ENV{QUERY_STRING};\n        }\n    }\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\n    require DADA::Profile::Session;\n    my $prof_sess = DADA::Profile::Session->new;\n\n    if ( $prof_sess->is_logged_in( { -cgi_obj => $q } ) ) {\n        my $email = $prof_sess->get( { -cgi_obj => $q } );\n\n        require DADA::Profile::Fields;\n        require DADA::Profile;\n\n        my $prof = DADA::Profile->new( { -email => $email } );\n        my $dpf = DADA::Profile::Fields->new( { -email => $email } );\n        my $subscriber_fields =\n          $dpf->{manager}->fields( { -show_hidden_fields => 0, } );\n        my $field_attr   = $dpf->{manager}->get_all_field_attributes;\n        my $email_fields = $dpf->get;\n\n        if ( $q->param('process') eq 'edit_subscriber_fields' ) {\n\n            my $edited = {};\n            for (@$subscriber_fields) {\n                $edited->{$_} = xss_filter( scalar $q->param($_) );\n\n                # This is better than nothing, but it's very lazy -\n                # Make sure that the length is less than 10k.\n                if ( length( $edited->{$_} ) > 10240 ) {\n\n                    # Sigh.\n                    die $DADA::CONFIG::PROGRAM_NAME . ' '\n                      . $DADA::Config::VER\n                      . ' Error! Attempting to save Profile Field with too large of a value!';\n                }\n            }\n\n# DEV: This is somewhat of a hack - so that we don't writeover hidden fields, we re-add them, here\n# A little kludgey.\n\n            for my $field (\n                @{ $dpf->{manager}->fields( { -show_hidden_fields => 1 } ) } )\n            {\n                if ( $field =~\n                    m/^$DADA::Config::HIDDEN_SUBSCRIBER_FIELDS_PREFIX/ )\n                {\n                    $edited->{$field} = $email_fields->{$field},;\n                }\n            }\n            $dpf->insert( { -fields => $edited, } );\n\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::PROGRAM_URL . '?flavor=profile&edit=1' );\n        }\n        elsif ( $q->param('process') eq 'change_password' ) {\n\n            if ( !DADA::Profile::feature_enabled('change_password') == 1 ) {\n\n                # warn 'feature disabled.';\n                return $self->default();\n            }\n            else {\n                #                # warn 'feature enabled!';\n            }\n\n            my $new_password = xss_filter( scalar $q->param('password') );\n            my $again_new_password =\n              xss_filter( scalar $q->param('again_password') );\n\n# DEV: See?! Why are we doing this manually? Can we use is_valid_registration() perhaps?\n            if ( length($new_password) > 0\n                && $new_password eq $again_new_password )\n            {\n                $prof->update( { -password => $new_password, } );\n                $q->param( 'password_changed', 1 );\n                $q->delete('process');\n\n                require DADA::Profile::Session;\n                my $prof_sess = DADA::Profile::Session->new->logout;\n\n                # DEV: This is going to get repeated quite a bit..\n                require DADA::Profile::Htpasswd;\n                foreach my $p_list ( @{ $prof->subscribed_to } ) {\n                    my $htp =\n                      DADA::Profile::Htpasswd->new( { -list => $p_list } );\n                    for my $id ( @{ $htp->get_all_ids } ) {\n                        $htp->setup_directory( { -id => $id } );\n                    }\n                }\n                #\n                return $self->profile_login();\n\n            }\n            else {\n                $q->param( 'errors',                 1 );\n                $q->param( 'errors_change_password', 1 );\n                $q->delete('process');\n                return $self->profile();\n            }\n\n        }\n        elsif ( $q->param('process') eq 'update_email' ) {\n\n            if ( !DADA::Profile::feature_enabled('update_email_address') == 1 )\n            {\n\n                return $self->default();\n            }\n\n # So, send the confirmation email for update to the NEW email address?\n # What if the OLD email address is activated? Guess we'll have to go with the\n # NEW email address. The only problem is if someone gains access to the account\n # changes the address as their own, etc.\n # But, they'd still need access to the account...\n\n            # So,\n            # * Send confirmation out\n            # * Display report if there are any problems.\n            #\n            # Old AND New address subscribed to a list:\n            #\n            # At the moment, if a subscriber is already subscribed, we\n            # can give the option (only option) to remove the old address\n            # And keep the current address :\n            #\n            # New Address isn't allowed to subscribe\n            #\n            # Keep old address, profile for old address will be gone\n            # Option to unsubscribe old address\n            # Option to tell list owner to unsubscribe old address? (Perhaps)\n            #\n\n            # If we haven't confirmed....\n\n            # Check to make sure the email address is valid.\n\n            # Valid? OK! send the confirmaiton email\n\n            # Not Valid? Geez we better tell someone.\n            my $updated_email =\n              cased( xss_filter( scalar $q->param('updated_email') ) );\n\n            # Oh. What if there is already a profile for this address?\n\n            my ( $status, $errors ) = $prof->is_valid_update_profile_email(\n                { -updated_email => $updated_email, } );\n            if ( $status == 0 ) {\n\n                my $p_errors = [];\n                for ( keys %$errors ) {\n                    if ( $errors->{$_} == 1 ) {\n\n                        #push(@$p_errors, $_);\n                        $q->param( 'error_' . $_, 1 );\n                    }\n                }\n\n                #\t$q->param('errors',              $p_errors);\n                $q->param( 'errors',              1 );\n                $q->param( 'process',             0 );\n                $q->param( 'errors_update_email', 1 );\n                $q->param( 'updated_email',       $updated_email );\n                return $self->profile();\n            }\n            else {\n\n                $prof->confirm_update_profile_email(\n                    { -updated_email => $updated_email, } );\n\n                my $info = $prof->get( { -dotted => 1 } );\n                my $scrn = '';\n\n                $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -with   => 'list',\n                        -screen => 'profile_update_email_auth_send.tmpl',\n                        -vars   => { %$info, }\n                    }\n                );\n                return $scrn;\n            }\n\n            # Oh! We've confirmed?\n\n# We've got to make sure that we can switch the email address in each\n# various list - perhaps the new address is blacklisted? Ack. that would be stinky\n# Another problem: What if the new email address is already subscribed?\n# May need a, \"replace\" function.\n# Sigh...\n\n            # That's it.\n        }\n        elsif ( $q->param('process') eq 'delete_profile' ) {\n\n            if ( !DADA::Profile::feature_enabled('delete_profile') == 1 ) {\n                return $self->default();\n            }\n            else {\n                $prof_sess->logout;\n                $prof->remove;\n\n                undef $prof;\n                undef $prof_sess;\n\n                $q->param( 'flavor',  'profile_login' );\n                $q->param( 'removal', 1 );\n\n                return $self->profile_login();\n            }\n        }\n        elsif ( $q->param('process') eq 'profile_delivery_preferences' ) {\n            my $list = xss_filter( scalar $q->param('list') );\n            my $delivery_prefs =\n              xss_filter( scalar $q->param('delivery_prefs') );\n\n            require DADA::Profile::Settings;\n            my $dps = DADA::Profile::Settings->new({-list => $list});\n            my $r   = $dps->save(\n                {\n                    -email   => $email,\n                    -setting => 'delivery_prefs',\n                    -value   => $delivery_prefs,\n                }\n            );\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::PROGRAM_URL . '?flavor=profile&edit=1' );\n\n        }\n        else {\n\n            my $fields = [];\n            for my $field (@$subscriber_fields) {\n                push(\n                    @$fields,\n                    {\n                        name     => $field,\n                        label    => $field_attr->{$field}->{label},\n                        value    => $email_fields->{$field},\n                        required => $field_attr->{$field}->{required},\n                    }\n                );\n            }\n\n            my $subscriptions =\n              $prof->subscribed_to( { -html_tmpl_params => 1 } ),\n              my $filled          = [];\n            my $has_subscriptions = 0;\n\n            my $protected_directories = [];\n\n            for my $i (@$subscriptions) {\n\n                if ( $i->{subscribed} == 1 ) {\n                    $has_subscriptions = 1;\n                }\n\n                require DADA::MailingList::Settings;\n                my $ls =\n                  DADA::MailingList::Settings->new( { -list => $i->{list} } );\n\n                # Ack, this is very awkward:\n\n                #  Ack, this is very awkward:\n\n                my $li = DADA::Template::Widgets::webify_and_santize(\n                    {\n                        -vars        => $ls->get( -dotted => 1 ),\n                        -to_sanitize => [\n                            qw(list_settings.list_owner_email list_settings.info list_settings.privacy_policy )\n                        ],\n                    }\n                );\n\n                require DADA::Profile::Htpasswd;\n                my $htp =\n                  DADA::Profile::Htpasswd->new( { -list => $i->{list} } );\n                my $l_p_d = $htp->get_all_entries;\n                if ( scalar(@$l_p_d) > 0 ) {\n                    @$protected_directories =\n                      ( @$protected_directories, @$l_p_d );\n                }\n\n                require DADA::App::Subscriptions::Unsub;\n                my $dasu = DADA::App::Subscriptions::Unsub->new(\n                    { -list => $i->{list} } );\n                my $unsub_link = $dasu->unsub_link(\n                    { -email => $email, -mid => '00000000000000' } );\n\n                my $digest_timeframe =\n                  formatted_runtime( $ls->param('digest_schedule') );\n\n                require DADA::Profile::Settings;\n                my $dps = DADA::Profile::Settings->new(\t\n\t\t\t\t\t{\n\t\t\t\t\t\t-list => $i->{list}\n\t\t\t\t\t}\n\t\t\t\t);\n                my $s   = $dps->fetch(\n                    {\n                        -email => $email,\n                    }\n                );\n                my $delivery_prefs = $s->{delivery_prefs} || 'individual';\n                push(\n                    @$filled,\n                    {\n                        %{$i},\n                        %{$li},\n                        PROGRAM_URL           => $DADA::Config::PROGRAM_URL,\n                        list_unsubscribe_link => $unsub_link,\n                        digest_timeframe      => $digest_timeframe,\n                        delivery_prefs        => $delivery_prefs,\n                    }\n                );\n            }\n\n            my $scrn = '';\n\n            $scrn .= DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'profile_home.tmpl',\n                    -with   => 'list',\n                    -expr   => 1,\n                    -vars   => {\n                        errors => scalar $q->param('errors')\n                          || 0,\n                        'profile.email'   => $email,\n                        subscriber_fields => $fields,\n                        subscriptions     => $filled,\n                        has_subscriptions => $has_subscriptions,\n                        welcome           => scalar $q->param('welcome')\n                          || '',\n                        edit => scalar $q->param('edit')\n                          || '',\n                        errors_change_password =>\n                          scalar $q->param('errors_change_password')\n                          || '',\n                        errors_update_email =>\n                          scalar $q->param('errors_update_email')\n                          || '',\n                        error_invalid_email =>\n                          scalar $q->param('error_invalid_email')\n                          || '',\n                        error_profile_exists =>\n                          scalar $q->param('error_profile_exists')\n                          || '',\n                        updated_email => scalar $q->param('updated_email')\n                          || '',\n\n                        gravators_enabled =>\n                          $DADA::Config::PROFILE_OPTIONS->{gravatar_options}\n                          ->{enable_gravators},\n                        gravatar_img_url =>\n                          gravatar_img_url( { -email => $email, } ),\n                        protected_directories => $protected_directories,\n                        WHOLE_URL             => $whole_url,\n                        %{ DADA::Profile::feature_enabled() },\n\n                    }\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n        $q->param( 'error_profile_login', 1 );\n        $q->param( 'errors', ['not_logged_in'] );\n        return $self->profile_login();\n    }\n\n}\n\nsub profile_logout {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\n    require DADA::Profile::Session;\n    my $prof_sess = DADA::Profile::Session->new;\n\n    $prof_sess->logout;\n    my $redirect_to =\n      $DADA::Config::PROGRAM_URL . '?flavor=profile_login&logged_out=1';\n\n    #if ( $q->referer() && $q->referer() !~ m/\\/profile\\// ) {\n    #    $redirect_to = $q->referer();\n    #}\n    my $headers = {\n        -cookie  => [ $prof_sess->logout_cookie ],\n        -nph     => $DADA::Config::NPH,\n        -Refresh => '0; URL=' . $redirect_to,\n    };\n    my $body = $q->start_html(\n        -title   => 'Logging Out...',\n        -BGCOLOR => '#FFFFFF'\n    );\n    $body .= $q->p( $q->a( { -href => $redirect_to }, 'Logging Out...' ) );\n    $body .= $q->end_html();\n\n    $self->header_props(%$headers);\n    return $body;\n}\n\n\n\n\n\nsub profile_reset_password { \n    my $self = shift;\n    my $q    = $self->query();\n\t\n\tif($q->request_method() =~ m/POST/i){\n\t\treturn $self->post_profile_reset_password(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_profile_reset_password.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\temail     => $q->param('email'),\n\t\t\t\t\tauth_code => $q->param('auth_code'),\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n}\n\n\n\n\nsub post_profile_reset_password {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $email = $q->param('email');\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\n    require DADA::Profile;\n    if ( !DADA::Profile::feature_enabled('password_reset') == 1 ) {\n        return $self->default();\n    }\n\n    my $reset_email = cased( xss_filter( scalar $q->param('reset_email') ) );\n    my $auth_code = xss_filter( scalar $q->param('auth_code') ) || undef;\n\n    if ($auth_code) {\n        $reset_email = $email;\n    }\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -email => $reset_email } );\n\n    if ($reset_email) {\n\n        my $password = xss_filter( scalar $q->param('password') ) || undef;\n\n        if ($auth_code) {\n            my ( $status, $errors ) =\n              $prof->is_valid_activation( { -auth_code => $auth_code, } );\n            if ( $status == 1 ) {\n                if ( !$password ) {\n\n                    my $scrn = DADA::Template::Widgets::wrap_screen(\n                        {\n                            -screen => 'profile_reset_password.tmpl',\n                            -with   => 'list',\n                            -vars   => {\n                                email     => $reset_email,\n                                auth_code => $auth_code,\n                            }\n                        }\n                    );\n                    return $scrn;\n                }\n                else {\n                    # Reset the Password\n                    $prof->update( { -password => $password, } );\n\n                    # Reactivate the Account\n                    $prof->activate();\n\n             # Log The person in.\n             # Probably pass the needed stuff to profile_login via CGI's param()\n                    $q->param( 'login_email',    $reset_email );\n                    $q->param( 'login_password', $password );\n                    $q->param( 'process',        1 );\n\n                    # and just called the subroutine itself. Hazzah!\n                    return $self->profile_login();\n\n                    # Go home, kiss the wife.\n                }\n            }\n            else {\n\n                my $p_errors = [];\n                for ( keys %$errors ) {\n                    if ( $errors->{$_} == 1 ) {\n                        push( @$p_errors, $_ );\n                        $q->param( 'error_' . $_, 1 );\n                    }\n                }\n                $q->param( 'error_profile_reset_password', 1 );\n                $q->param( 'errors',                       $p_errors );\n                return $self->profile_login();\n            }\n        }\n        else {\n\n            if ( $prof->exists() ) {\n\n                $prof->send_profile_reset_password_email();\n                $prof->activate;\n\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen => 'profile_reset_password_confirm.tmpl',\n                        -with   => 'list',\n                        -vars   => {\n                            email           => $reset_email,\n                            'profile.email' => $reset_email,\n                        }\n                    }\n                );\n                return $scrn;\n            }\n            else {\n                $q->param( 'error_profile_reset_password', 1 );\n                $q->param( 'error_unknown_user',           1 );\n                $q->param( 'errors', ['unknown_user'] );\n                $q->param( 'email', $reset_email );\n                return $self->profile_login();\n            }\n        }\n    }\n    else {\n\n        $self->header_type('redirect');\n        $self->header_props(\n            -url => $DADA::Config::PROGRAM_URL . '/profile_login/' );\n    }\n}\n\nsub profile_update_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $auth_code = xss_filter( scalar $q->param('auth_code') );\n    my $email     = cased( xss_filter( scalar $q->param('email') ) );\n    my $confirmed = xss_filter( scalar $q->param('confirmed') );\n\n    require DADA::Profile;\n\n    if ( !DADA::Profile::feature_enabled('update_email_address') == 1 ) {\n        return $self->default();\n    }\n\n    my $prof = DADA::Profile->new( { -email => $email } );\n    my $info = $prof->get;\n\n    my ( $status, $errors ) = $prof->is_valid_update_profile_activation(\n        { -update_email_auth_code => $auth_code, } );\n\n    if ( $status == 1 ) {\n\n        my $profile_info = $prof->get( { -dotted => 1 } );\n        my $subs = $prof->profile_update_email_report;\n\n        #require Data::Dumper;\n        #die Data::Dumper::Dumper($subs);\n        if ( $confirmed == 1 ) {\n\n            # This should probably go in the update_email method...\n            require DADA::MailingList::Subscribers;\n            for my $in_list (@$subs) {\n                my $lh = DADA::MailingList::Subscribers->new(\n                    { -list => $in_list->{'list_settings.list'}, } );\n                $lh->remove_subscriber(\n                    {\n                        -email => cased( $profile_info->{'profile.email'} ),\n                        -type  => 'list'\n                    }\n                );\n                $lh->add_subscriber(\n                    {\n                        -email =>\n                          cased( $profile_info->{'profile.update_email'} ),\n                        -type => 'list'\n                    }\n                );\n\t\t\t\t$prof->update_email({-list => $in_list->{'list_settings.list'}});\n            }\n           \n\t\t   \n            #/ This should probably go in the update_email method...\n\t\t\t\n            $prof->send_update_email_notification(\n                { -prev_email => cased( $profile_info->{'profile.email'} ), } );\n\n            # Now, just log us in:\n            require DADA::Profile::Session;\n            my $prof_sess = DADA::Profile::Session->new;\n            if ( $prof_sess->is_logged_in ) {\n                $prof_sess->logout;\n            }\n            undef $prof_sess;\n\n            my $prof_sess = DADA::Profile::Session->new;\n            my $cookie    = $prof_sess->login(\n                {\n                    -email   => $profile_info->{'profile.update_email'},\n                    -no_pass => 1,\n                }\n            );\n\n            my $headers = {\n                -cookie  => [$cookie],\n                -nph     => $DADA::Config::NPH,\n                -Refresh => '0; URL='\n                  . $DADA::Config::PROGRAM_URL\n                  . '/profile/'\n            };\n            my $body = $q->start_html(\n                -title   => 'Logging in...',\n                -BGCOLOR => '#FFFFFF'\n            );\n            $body .= $q->p(\n                $q->a(\n                    { -href => $DADA::Config::PROGRAM_URL . '/profile/' },\n                    'Logging in...'\n                )\n            );\n            $body .= $q->end_html();\n\n            $self->header_props(%$headers);\n            return $body;\n        }\n        else {\n\n            # I should probably also just, log this person in...\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'profile_update_email_confirm.tmpl',\n                    -with   => 'list',\n                    -vars   => {\n                        auth_code     => $auth_code,\n                        subscriptions => $subs,\n                        %$profile_info,\n                    },\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n\n        # DEV: Currently there is no description of what the error is, just\n        # that, \"there is one\". Perhaps change that?\n        #\n\n        my $ht_errors = [];\n        for ( keys %$errors ) {\n            push( @$ht_errors, { name => $_, value => $errors->{$_} } );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'profile_update_email_error.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    errors => $ht_errors,\n                },\n            }\n        );\n        return $scrn;\n\n    }\n}\n\nsub also_save_for_settings {\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      DADA::App::Guts::check_list_security( -cgi_obj => $q, );\n    if ( $root_login != 1 ) {\n        return \"\";\n    }\n    else {\n        my $list = $admin_list;\n        my $form_id = $q->param('form_id') // undef;\n\n        my $ht_lists = [];\n        my @lists    = available_lists();\n        foreach (@lists) {\n            my $ls = DADA::MailingList::Settings->new( { -list => $_ } );\n            push(\n                @$ht_lists,\n                $ls->get(\n                    {\n                        #-dotted => 1\n                    }\n                )\n            );\n        }\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'also_save_for_settings.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    current_list => $list,\n                    lists        => $ht_lists,\n                    form_id      => $form_id,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub transform_to_pro {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'transform_to_pro'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'transform_to_pro.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -expr => 1,\n                -vars => {\n                    screen => 'transform_to_pro',\n                    title  => 'Transform into Pro Dada',\n                    list   => $list,\n                    done   => $done,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $process eq 'verify' ) {\n\n        my ( $cstatus, $cerrors, $receipt ) = $self->contact_mothership(\n            {\n                action            => 'verify',\n                pro_dada_username => $q->param('pro_dada_username'),\n                pro_dada_password => $q->param('pro_dada_password'),\n            }\n        );\n\n        my $ht_errors = {};\n        if ( keys %$cerrors ) {\n            $ht_errors->{ 'error_' . $_ } = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'transform_to_pro_verify.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    list              => $list,\n                    status            => $cstatus,\n                    pro_dada_username => $q->param('pro_dada_username'),\n                    pro_dada_password => $q->param('pro_dada_password'),\n                    error_code        => Data::Dumper::Dumper(\n                        {\n                            status  => $cstatus,\n                            errors  => $cerrors,\n                            receipt => $receipt\n                        }\n                    ),\n                    %{$ht_errors},\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $process eq 'upgrade' ) {\n\n        my ( $cstatus, $cerrors, $receipt ) = $self->contact_mothership(\n            {\n                action            => 'transform',\n                pro_dada_username => $q->param('pro_dada_username'),\n                pro_dada_password => $q->param('pro_dada_password'),\n            }\n        );\n\n        if ( $cstatus == 0 ) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=transform_to_pro&process=failure' );\n            return;\n        }\n\n        my $config_file       = make_safer($DADA::Config::CONFIG_FILE);\n        my $pro_dada_username = $q->param('pro_dada_username');\n\n        my $config_chunk = qq{\n\t\t\t\n\t\t\t\n# Thank you for being a Pro Dada customer, $pro_dada_username!\n# RECEIPT: $receipt\n\\$PROGRAM_NAME                 = 'Pro Dada';\n\\$GIVE_PROPS_IN_EMAIL          = 0;\n\\$GIVE_PROPS_IN_HTML           = 0;\n\\$GIVE_PROPS_IN_ADMIN          = 0;\n\\$GIVE_PROPS_IN_SUBSCRIBE_FORM = 0;\n\\$PROGRAM_IMG_FILENAME         = 'pro_dada_mail_logo.png';\n\\$LIST_QUOTA                   = 0;\n\\$SUBSCRIPTION_QUOTA           = 0;\n\n};\n        my $status = 1;\n        my $error  = undef;\n        try {\n\n            # Let's be careful about this:\n            my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst )\n              = localtime(time);\n            my $timestamp =\n              sprintf( \"%4d-%02d-%02d\", $year + 1900, $mon + 1, $mday ) . '-'\n              . time;\n            my $config_file_backup =\n              make_safer( $config_file . '-backup-' . $timestamp );\n            require File::Copy;\n            my $r = File::Copy::copy( $config_file, $config_file_backup )\n              or warn\n\"Copy failed - From: $config_file, To: $config_file_backup, Error:$!\";\n\n            open my $config, '>>', $config_file or die $!;\n            print $config $config_chunk or die $!;\n            close $config or die;\n        }\n        catch {\n            $status = 0;\n            $error  = $_;\n            warn $_;\n        };\n        if ( $status == 1 ) {\n\n            $c->flush;\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=transform_to_pro&process=success' );\n        }\n        else {\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'transform_to_pro_failure.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -expr => 1,\n                    -vars => {\n                        list => $list,\n\n                        # receipt         => $receipt,\n\n                    },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n\n                }\n            );\n            return $scrn;\n        }\n    }\n    elsif ( $process eq 'success' ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'transform_to_pro_success.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    list => $list,\n\n                    # receipt         => $receipt,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $process eq 'failure' ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'transform_to_pro_failure.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    list => $list,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    else {\n        return \"unknown process - huh?\"\n\n    }\n\n}\n\n# Need to send back a recipt number\nsub contact_mothership {\n    my $self = shift;\n    my ($args) = @_;\n\n    my $status  = 0;\n    my $errors  = {};\n    my $receipt = 'UNDEFINED';\n\n    my $gargs = {};\n    for (\n        qw(\n        action\n        pro_dada_username\n        pro_dada_password\n        )\n      )\n    {\n        $gargs->{$_} = $args->{$_};\n    }\n    try {\n        require JSON;\n        require HTTP::Request;\n        require HTTP::Request::Common;\n        require LWP::UserAgent;\n\n        my $ua = LWP::UserAgent->new;\n\n        my $json = JSON->new->allow_nonref;\n\n        $gargs->{rm} = 'verify_pro_dada_user_status';\n\n        my $ver = $DADA::Config::VER;\n        $ver =~ s/ (.*?)$//;\n        $gargs->{program_version} = $ver;\n        $gargs->{program_url}     = $DADA::Config::PROGRAM_URL;\n\n        my $response = $ua->request(\n            HTTP::Request::Common::POST(\n                'https://dadamailproject.com/pro_dada/cpdus.cgi',\n                content => $gargs,\n            )\n        );\n\n        if ( $response->is_success ) {\n            my $r = $json->utf8->decode( $response->decoded_content );\n\n            # print Dumper($r);\n            if ( $r->{status} == 1 ) {\n\n                # print \"Success!\\n\";\n            }\n            else {\n                # print \"Problems!\\n\";\n            }\n            $status  = $r->{status};\n            $errors  = $r->{errors};\n            $receipt = $r->{receipt};\n        }\n        else {\n            die 'problem with Pro Dada account verification'\n              . $response->decoded_content;\n        }\n    }\n    catch {\n        #warn $_;\n        $status = 0;\n        $errors->{communication_problem} = 1;\n    };\n    return ( $status, $errors, $receipt );\n}\n\n\n\nsub plugins {\n    my $self   = shift;\n    my $q      = $self->query();\n    my $plugin = $q->param('plugin');\n    my ( $headers, $body );\n    if ( exists( $DADA::Config::PLUGINS_ENABLED->{$plugin} ) ) {\n        if ( $DADA::Config::PLUGINS_ENABLED->{$plugin} != 1 ) {\n            return 'Plugin disabled.';\n        }\n        eval {\n            require 'plugins/' . $plugin;\n            ( $headers, $body ) =\n              $DADA::Config::PLUGIN_RUNMODES->{$plugin}->{run}->($q);\n        };\n        if ( !$@ ) {\n            if ( exists( $headers->{-redirect_uri} ) ) {\n                $self->header_type('redirect');\n                $self->header_props( -url => $headers->{-redirect_uri} );\n            }\n            else {\n                if ( keys %$headers ) {\n                    $self->header_props(%$headers);\n                }\n                return $body;\n            }\n        }\n        else {\n            return ($@);\n        }\n    }\n    else {\n        return \"plugin not registered.\";\n    }\n\n}\n\nsub bridge_inject {\n\n    my $self = shift;\n    my $r;\n\n    $ENV{CGI_APP_RETURN_ONLY} = 1;\n\n    if ( $DADA::Config::PLUGINS_ENABLED->{bridge} != 1 ) {\n        return 'Plugin disabled.';\n    }\n    my $run_list = $self->param('run_list');\n\n    if ( !defined($run_list) ) {\n        $r .= 'No List Defined.';\n    }\n    require 'plugins/bridge';\n\n# One problem with this is that we don't know the encoding of the message.\n# If it's 8bit, and ISO-whatever, we're in trouble\n# We could read the full msg in, and change the encoding, THEN Tag the message in that encoding.\n# Sounds message.\n\n    require DADA::Security::Password;\n    my $filename =\n        $DADA::Config::TMP\n      . \"/tmp_file\"\n      . DADA::Security::Password::generate_rand_string() . \"-\"\n      . time . \".txt\";\n    open my $tmp_file, '>:encoding(' . $DADA::Config::HTML_CHARSET . ')',\n      $filename\n      or die $!;\n\n#   open my $tmp_file2, '>:encoding(' . $DADA::Config::HTML_CHARSET . ')', $filename . '2' or die $!;\n\n    my $msg;\n\n    # binmode(STDIN,  \":utf8\");\n    # binmode STDIN;\n    while ( my $line = <STDIN> ) {\n\n        #        $line = safely_decode($line);\n        #        $line = safely_encode($line);\n\n        print $tmp_file $line;\n\n        #        print $tmp_file2 $line;\n    }\n    close $tmp_file or die $!;\n\n    #   close $tmp_file2 or die $!;\n\n    chmod( $DADA::Config::FILE_CHMOD, $filename );\n\n    $r .= bridge::inject_msg(\n        {\n            -filename => $filename,\n            -list     => $run_list,\n        }\n    );\n\n}\n\nsub schedules {\n\n    # Just need to document this\n    # and figure out inject stuff.... sigh.\n\n    my $self = shift;\n\tmy ($args) = @_; \n\tif(!exists($args->{-at_teardown})){ \n\t\t$args->{-at_teardown} = 0; \n\t}\n\t\n    my $q    = $self->query;\n\n    my $t = time;\n    my $tz = strftime(\"%Z\", localtime()); \n\n\n    my $list         = $q->param('list')         || '_all';\n    my $schedule     = $q->param('schedule')     || '_all';\n    my $output_mode  = $q->param('output_mode')  || '_verbose';\n    my $for_colorbox = $q->param('for_colorbox') || 0;\n\n    my $r;\n    $r .= \"Started: \" . scalar localtime($t) . ' ' . $tz .\"\\n\";\n\t\n\t$r .= 'PID: ' . \"$$\\n\";\n\t\t\n\tmy $user = $ENV{ LOGNAME } || $ENV{ USER } || $ENV{ USERNAME } || getlogin || getpwuid( $< );\n\t\n\t\n\tif(defined($user)) {\n\t\t$r .= 'Running as uid:, ' . $user . \"\\n\";\n\t}\n\telse  {\n\t\t$r .= 'Running as unknown uid' . \"\\n\";\n\t}\n\t\n\tif($args->{-at_teardown} == 1){ \n\t\t$r .= \"Running after regular script execution.\\n\";\n\t}\n\telse { \n\t\t$r .= \"Running as dedicated schedule.\\n\";\t\t\n\t}\n\n    require DADA::App::ScheduledTasks;\n    my $dast = DADA::App::ScheduledTasks->new;\n\n    my $lock = $dast->lock_file();\n    if ( !defined($lock) ) {\n\t\t$r .= \"Scheduled Tasks may be running in a different process, stopping.\\n\";\n\t\twarn \"PID: $$ Scheduled Tasks may be running in a different process, stopping.\\n\";\n\t\t\n    }\n\telse {\n\t\t\n\t    if ( $schedule eq '_all' ) {\n\t        $r .= \"\\nMonitor:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->mass_mailing_monitor($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\n\t        $r .= \"Mass Mailing Schedules:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->scheduled_mass_mailings($list);\n\t        } catch {\n\t        \t$r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\n\t        $r .= \"Rate Limits:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->expire_rate_limit_checks($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\n\t        $r .= \"Cleaning Out MIME Cache:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->clean_out_mime_cache();\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\t\n\t        $r .= \"\\nRemoving old archive messages:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_archive_messages($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\t\n\t        $r .= \"\\nRemoving old tracker data:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_tracker_data($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\t\n\n\t        $r .= \"\\nSending Analytics Email Notification:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->send_analytics_email_notification($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\t\t  \n\n\t        for my $plugin ( keys %$DADA::Config::PLUGINS_ENABLED ) {\n\t            if ( exists( $DADA::Config::PLUGINS_ENABLED->{$plugin} ) ) {\n\t                next if ( $DADA::Config::PLUGINS_ENABLED->{$plugin} != 1 );\n\t                next\n\t                  if !\n\t                  exists(\n\t                    $DADA::Config::PLUGIN_RUNMODES->{$plugin}->{sched_run} );\n\t                $r .= \"Plugin: $plugin\\n\" . '-' x 72 . \"\\n\";\n\t                try {\n\t                    require 'plugins/' . $plugin;\n\t                    $r .= $DADA::Config::PLUGIN_RUNMODES->{$plugin}->{sched_run}\n\t                      ->($list);\n\t                }\n\t                catch {\n\t                    $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t                };\n\t            }\n\t        }\n\t    }\n\t    elsif ( $schedule eq 'mass_mailing_monitor' ) {\n\t        $r .= \"Monitor:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->mass_mailing_monitor($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'rate_limit_checks' ) {\n\t        $r .= \"Rate Limits:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->expire_rate_limit_checks($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'mime_cache' ) {\n\t        $r .= \"Cleaning Out MIME Cache:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->clean_out_mime_cache();\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'remove_old_archive_messages' ) {\n\t        $r .= \"Removing out old archive messages:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_archive_messages($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'remove_old_tracker_data' ) {\n\t        $r .= \"Removing out old tracker data:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_tracker_data($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\n\t    elsif ( $schedule eq 'send_analytics_email_notification' ) {\n\t        $r .= \"Sending Analytics Email Notification:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->send_analytics_email_notification($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'scheduled_mass_mailings' ) {\n\t        $r .= \"Mass Mailing Schedules:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->scheduled_mass_mailings($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ($schedule eq 'bridge'\n\t        || $schedule eq 'bounce_handler' )\n\t    {\n\t        if ( $DADA::Config::PLUGINS_ENABLED->{$schedule} != 1 ) {\n\n\t            #....\n\t        }\n\t        else {\n\n\t            $r .= \"Plugin: $schedule\\n\" . '-' x 72 . \"\\n\";\n\n\t            try {\n\t                require 'plugins/' . $schedule;\n\t                $r .= $DADA::Config::PLUGIN_RUNMODES->{$schedule}->{sched_run}\n\t                  ->($list);\n\t            }\n\t            catch {\n\t                $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t            };\n\t        }\n\t    }\n\t    else {\n\t        $r .= 'No such schedule:\"' . $schedule . '\"';\n\t    }\n\t}\n\t\n\tif(defined($lock)){\n\t\t$dast->unlock_file($lock);\n\t}\n\t\n\tundef($dast);\n\t\n    my $end_t   = time;\n    my $total_t = $end_t - $t;\n    $r .= \"Finished: \" . scalar localtime($end_t) . ' ' . $tz . \"\\n\";\n    $r .= \"Total processing time: \" . formatted_runtime($total_t) . \"\\n\";\n\n    if ( $DADA::Config::SCHEDULED_JOBS_OPTIONS->{'log'} == 1 ) {\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->cron_log($r);\n    }\n\n    my @lists = available_lists( -In_Order => 1 );\n    if ( scalar @lists >= 1 ) {\n        require DADA::MailingList::Settings;\n        my $ls = DADA::MailingList::Settings->new( { -list => $lists[0] } );\n        $ls->save(\n            {\n                -settings => {\n                    scheduled_jobs_last_ran => time,\n                }\n            }\n        );\n    }\n\n    if ( $output_mode ne '_silent' ) {\n        $self->header_props( { -type => 'text/plain' } );\n        if ( $for_colorbox == 1 ) {\n            return '<pre><small>' . $r . '</small></pre>';\n        }\n        else {\n            # $ENV{CGI_APP_RETURN_ONLY} = 1;\n            return $r;\n        }\n    }\n    else {\n        return '';\n    }\n}\n\nsub scheduled_jobs {\n\n    my $self = shift;\n    my $q    = $self->query;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $curl_location = `which curl`;\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'scheduled_jobs.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $admin_list,\n            },\n            -expr => 1,\n            -vars => {\n                scheduled_jobs_flavor => $DADA::Config::SCHEDULED_JOBS_OPTIONS\n                  ->{scheduled_jobs_flavor},\n                curl_location => $curl_location,\n            },\n        }\n    );\n}\n\nsub DESTROY {\n\n    # warn 'DADA::App::DESTROY called.';\n}\n\nsub END { }\n\n1;\n\n__END__\n\n=pod\n\n=head1 COPYRIGHT\n\nCopyright (c) 1999 - 2020 Justin Simoni All rights reserved. \n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n=cut\n\n", "package DADA::Profile::Session;\n\nuse lib qw (../../ ../../../DADA/perllib);\nuse strict;\nuse Carp qw(carp croak);\nuse DADA::Config;\nuse DADA::App::Guts; \nuse CGI::Session;\nCGI::Session->name('dada_profile');\nuse Carp qw(carp croak); \n\nmy $t = $DADA::Config::DEBUG_TRACE->{DADA_Profile_Session};\n\nsub new {\n\n    my $class = shift;\n    my ($args) = @_;\n\n    my $self = {};\n    bless $self, $class;\n    $self->_init($args);\n    return $self;\n\n}\n\nsub _init {\n\n    my $self = shift;\n    my ($args) = @_;\n    $self->{list} = $args->{ -list };\n\tmy $dbh     = undef; \n\tmy $dbi_obj = undef; \n\t\t\n    require DADA::App::DBIHandle;\n       $dbi_obj = DADA::App::DBIHandle->new;\n       $dbh     = $dbi_obj->dbh_obj; \n\t\n    # http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session.pm\n\n\n        if ( $DADA::Config::SQL_PARAMS{dbtype} eq 'Pg' ) {\n\n# http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session/Driver/postgresql.pm\n            $self->{dsn}      = 'driver:PostgreSQL';\n            $self->{dsn_args} = {\n\n                Handle    => $dbh,\n                TableName => $DADA::Config::SQL_PARAMS{session_table},\n\n            };\n\n        }\n        elsif ( $DADA::Config::SQL_PARAMS{dbtype} eq 'mysql' ) {\n\n  # http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session/Driver/mysql.pm\n            $self->{dsn}      = 'driver:mysql';\n            $self->{dsn_args} = {\n\n                Handle    => $dbh,\n                TableName => $DADA::Config::SQL_PARAMS{session_table},\n\n            };\n\n        }\n        elsif ( $DADA::Config::SQL_PARAMS{dbtype} eq 'SQLite' ) {\n\n            # http://search.cpan.org/~bmoyles/CGI-Session-SQLite/SQLite.pm\n            $self->{dsn} =\n              'driver:SQLite:'\n              ;    # . ':' . $DADA::Config::FILES . '/' . $database;;\n            $self->{dsn_args} = {\n\n                Handle => $dbh,\n\t\t\t\tTableName => $DADA::Config::SQL_PARAMS{session_table},\n\n            };\n\n        }\n}\n\nsub _login_cookie {\n\n    my $self = shift;\n    my ($args) = @_;\n\n\trequire CGI; \n    my $q = new CGI; \n\n    my $cookie;\n\n    require CGI::Session;\n\n    my $session = new CGI::Session( $self->{dsn}, $q, $self->{dsn_args} );\n\n    $session->param( 'email',      cased($args->{ -email }) );\n    $session->param( '_logged_in', 1 );\n\n    $session->expire( $DADA::Config::COOKIE_PARAMS{ -expires } );\n    $session->expire( '_logged_in', $DADA::Config::COOKIE_PARAMS{ -expires } );\n\n    $cookie = $q->cookie( \n\t\t%{$DADA::Config::PROFILE_OPTIONS->{cookie_params}},\n\t\t-value => $session->id, \n\t\t($DADA::Config::PROGRAM_URL =~ m/^https/) ? (\n\t\t\t-secure  => 1,\n\t\t) : ()\n\t\t\n\t\t);\n\n    # My proposal to address the situation is quit relying on flush() happen\n    # automatically, and recommend that people use an explicit flush()\n    # instead, which works reliably for everyone.\n    $session->flush();\n\n    return $cookie;\n}\n\nsub login {\n\n\n    my $self = shift;\n    my ($args) = @_;\n\n\trequire CGI; \n\tmy $q = new CGI; \n\n    my ( $status, $errors ) = $self->validate_profile_login($args);\n    if ( $status == 0 ) {\n        croak \"login failed.\";\n    }\n    else {\n        my $cookie = $self->_login_cookie($args);\n        return $cookie;\n    }\n}\n\nsub logout {\n\n    my $self = shift;\n    my ($args) = @_;\n\n\trequire CGI; \n\tmy $q = new CGI; \n\n    if ( $self->is_logged_in($args) ) {\n        my $s = new CGI::Session( $self->{dsn}, $q, $self->{dsn_args} );\n        $s->delete;\n        $s->flush;\n        return 1;\n    }\n    else {\n        carp 'profile was never logged in!';\n        return 0;\n    }\n}\n\nsub logout_cookie { \n\n\tmy $self = shift; \n\t\n\trequire CGI; \n\tmy $q = new CGI;\n\t\n\tmy $cookie = $q->cookie(\n\t\t\t\t-name    =>  $DADA::Config::PROFILE_OPTIONS->{cookie_params}->{-name},\n\t\t\t\t-value   =>  '',\n\t\t\t\t-path    =>  '/',\n\t);\n\treturn $cookie;\n}\n\n\nsub validate_profile_login {\n    my $self = shift;\n    my ($args) = @_;\n\t\n\t$args->{ -email } = cased($args->{ -email });\n\t\n    my $status = 1;\n    my $errors = {\n        unknown_user   => 0,\n        incorrect_pass => 0,\n    };\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new(\n\t\t{ \n\t\t\t-email => $args->{ -email } \n\t\t} \n\t);\n    \n    \n\tif ( $prof->exists == 1 ) {\n        # ...\n    }\n    else {\n        $status = 0;\n        $errors->{unknown_user} = 1;\n    }\n\t\n\tif($args->{-no_pass} == 1){ \n\t\t# ... \n\t}\n\telse { \n \t   if ( $prof->is_valid_password($args) ) {\n\n\t        # ...\n\t    }\n\t    else {\n\t        $status = 0;\n\t        $errors->{incorrect_pass} = 1;\n\t\n\t    }\n\t}\n\n    return ( $status, $errors );\n\n}\n\nsub is_logged_in {\n\n    my $self = shift;\n    my ($args) = @_;\n    my $q;\n    if ( exists( $args->{ -cgi_obj } ) ) {\n        $q = $args->{ -cgi_obj };\n    }\n    else {\n        require CGI;\n        $q = new CGI;\n\n    }\n    my $s = CGI::Session->load( $self->{dsn}, $q, $self->{dsn_args} )\n      or croak 'failed to load session: ' . CGI::Session->errstr();\n\n    if ( $s->is_expired ) {\n        return 0;\n    }\n\n    if ( $s->is_empty ) {\n        return 0;\n    }\n\n    if ( $s->param('_logged_in') == 1 ) {\n\t\n\t\t# Something's wrong with this, but I don't know yet, yet: \n\t\t# \n\t\t#require DADA::Profile;\n\t    #my $prof = DADA::Profile->new( { -email => $self->get }  );\n\t\t#\n\t    #if ( $prof->exists == 1 ) {\n\t    #   return 1;\n\t    #}\n\t    #else {\n\t    #     return 0;\n\t    #}\n\t\treturn 1; \n    }\n    else {\n        return 0;\n    }\n\n}\n\nsub get {\n\n    my $self = shift;\n    my ($args) = @_;\n    my $q;\n    require CGI;\n    $q = new CGI;\n    require CGI::Session;\n\n    my $session = new CGI::Session( $self->{dsn}, $q, $self->{dsn_args} );\n    return $session->param('email');\n\n}\n\nsub reset_password {} # ??? \n\n1;\n\n\n=pod\n\n=head1 NAME \n\nDADA::Profile::Session\n\n=head1 SYNOPSIS\n\n=head1 DESCRIPTION\n\n=head1 Public Methods\n\n=head2 new\n\n\tmy $prof_sess = DADA::Profile::Session->new\n\nC<new> returns a DADA::Profile::Session object. \n\nC<new> does not take any parameters and returns a C<DADA::Profile::Session> object. \n\n=head2 login\n\n\tmy $cookie = $prof_sess->login(\n\t\t{ \n\t\t\t-email    => scalar $q->param('email'),\n\t\t\t-password => scalar $q->param('password'), \n\t\t},\n\t);\n\nC<login> saves the session information for the profile, as well as returns a cookie, so that the state can be fetched later. \n\nIt requires two arguments: \n\nC<-email> should hold the email address associated with the profile that you'd like to login. \n\nC<-password> should hold the correct password associated with the user. \n\nThis method will croak if the login information (user/password) is incorrect. Use C<validate_profile_login()> before trying to login. \n\n=head2 logout\n\n $prof_sess->logout;\n\nC<logout> removes the session state information. It'll return C<1> on success and C<0> on failure. Usually, a failure will happen \nif the profile is not actually logged in. \n\n=head2 validate_profile_login\n\n\tmy ($status, $errors) = $prof_sess->validate_profile_login(\n\t\t{ \n\t\t\t-email    => scalar $q->param('email'),\n\t\t\t-password => scalar $q->param('password'), \n\t\t\n\t\t},\n\t);\n\nC<validate_profile_login> is used to make sure the login information you give is valid. \n\nIt requires two parameters: \n\nC<-email> should be the email address associated with the profile. \n\nC<-password> should be the profile associated with the profile. \n\nIt'll return a two-element array. The first is the status and will be set to either, \nC<1> or C<0>, with C<1> meaning that no problems were encountered. If the status is set \nto, C<0>, then problems were encountered. Any problems will be described in the second element of the \narray. This should be a hashref of key/value pairs. The keys will describe the error and the value would \nbe set to, C<1> if the error was found. \n\nHere's the following keys that may be returned: \n\n=over\n\n=item * unknown_user\n\nThe email address passed in, C<-email> doesn't have a profile. \n\n=item * incorrect_pass\n\nThe password passed in, C<-password> isn't correct for the email address passed in, C<-email> \n\n=back\n\n=head2 is_logged_in\n\n my $logged_in = $prof_sess->is_logged_in; \n\nC<is_logged_in> returns C<1> if a profile is logged in, or C<0> if it is not. \n\nC<is_logged_in> does not need any arguments. \n\n=head2 get \n\n my $email = $prof_sess->get; \n\nC<get> returns the email address associated with the profile that is logged in. \n\nMost likely, if the profile is not logged in, C<undef> will be returned. \n\n=head1 AUTHOR\n\nJustin Simoni https://dadamailproject.com\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (c) 1999 - 2020 Justin Simoni All rights reserved. \n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, \nBoston, MA  02111-1307, USA.\n\n=cut \n\n\n", "package DADA::Template::Widgets;\nuse lib qw(\n\t../../../ \n\t../../../DADA/perllib\n); \n\nuse Encode; \nuse Try::Tiny; \nuse Carp qw(croak carp); \n\nuse DADA::Config qw(!:DEFAULT);  \n\nuse constant HAS_HTML_TEMPLATE_PRO => eval { require HTML::Template::Pro; 1; }; \n\nmy $TMP_TIME = undef; \nuse POSIX; \n\nBEGIN {\n   if($] > 5.008){\n      require Errno;\n      require Config;\n   }\n}\n\n\nuse DADA::App::Guts; \nmy $q; \n\nlame_init(); \n\nmy $wierd_abs_path = __FILE__; \n   $wierd_abs_path =~ s{^/}{}g;\n\nmy @guesses; \nmy $Templates; \n\nif(! $DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH ){ \n\n\teval { require File::Spec };\n\t\n\tif(!$@){\n\n\t   $Templates  =  File::Spec->rel2abs($wierd_abs_path);\n\t   $Templates  =~ s/DADA\\/Template\\/Widgets\\.pm$//g;\n\t   $Templates  =~ s/\\/$//; # cut off the first slash, if it's there; \n\t   $Templates .= '/templates';\n\t   \n\t    push(@guesses, $Templates); \n\t   \n\t}elsif($@){\n\n\t carp \"$DADA::Config::PROGRAM_NAME warning: File::Spec isn't working correctly: \". $@;\n\t carp 'You may want to setup the, \"$DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH \" Config variable!';\n\t \n\t} else{ \n\t\n\t\t$Templates = $DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH ;\n    \tpush(@guesses, $Templates);\n\t}\n\t\n}else{ \n\t\n\t$Templates = $DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH ;\n    push(@guesses, $Templates);\n\n}\n\t\t\nmy $second_guess_template  = $wierd_abs_path; \n   $second_guess_template  =~ s/DADA\\/Template\\/Widgets\\.pm$//g;\n   $second_guess_template  =~ s/\\/$//;\n   $second_guess_template .= '/templates';\n   $second_guess_template  = '/' . $second_guess_template;\n\n\tpush(@guesses, $second_guess_template);\n\n\n\tmy $getpwuid_call; \n\teval { $getpwuid_call = ( getpwuid $> )[7] };\n\tif(!$@){ \n\t\t# They're called guess, right? right...\n\t\tpush(@guesses, $getpwuid_call . '/cgi-bin/dada/templates');\n\t\tpush(@guesses, $getpwuid_call . '/public_html/cgi-bin/templates');\n\t\tpush(@guesses, $getpwuid_call . '/public_html/dada/templates');\n\t}\n\nrequire Exporter; \n\nuse vars (@ISA, @EXPORT); \n\n@ISA    = qw(Exporter);  \n@EXPORT = qw( \n \ntemplates_dir\npriority_popup_menu\nlist_popup_menu\nlist_popup_login_form\ndefault_screen\nsend_url_email_screen\nlogin_switch_widget\nscreen\nabsolute_path\nsubscription_form\nunsubscription_form\narchive_send_form\nprofile_widget\n_raw_screen\n);\n\nuse strict; \nuse vars qw( @EXPORT );\n\nmy %Global_Template_Variables = (\ncomment                     => 0, \n\nSUPPORT_FILES_URL           => $DADA::Config::SUPPORT_FILES->{url}, \nkcfinder_enabled            => $DADA::Config::FILE_BROWSER_OPTIONS->{kcfinder}->{enabled},\ncore5_filemanager_enabled   => $DADA::Config::FILE_BROWSER_OPTIONS->{core5_filemanager}->{enabled},\nrich_filemanager_enabled    => $DADA::Config::FILE_BROWSER_OPTIONS->{rich_filemanager}->{enabled},\n\t\t\nROOT_PASS_IS_ENCRYPTED       => $DADA::Config::ROOT_PASS_IS_ENCRYPTED, \nPROGRAM_NAME                 => $DADA::Config::PROGRAM_NAME, \nPROGRAM_URL                  => $DADA::Config::PROGRAM_URL,\nS_PROGRAM_URL                => $DADA::Config::S_PROGRAM_URL,\nS_PROGRAM_URL_base64_encoded => encode_html_entities($DADA::Config::S_PROGRAM_URL, '\\W'), \n\nSIGN_IN_FLAVOR_NAME    => $DADA::Config::SIGN_IN_FLAVOR_NAME, \nDISABLE_OUTSIDE_LOGINS => $DADA::Config::DISABLE_OUTSIDE_LOGINS, \n\nADMIN_FLAVOR_NAME      => $DADA::Config::ADMIN_FLAVOR_NAME, \nHELP_LINKS_URL         => $DADA::Config::HELP_LINKS_URL, \nMAILPROG               => $DADA::Config::MAILPROG,\nFILES                  => $DADA::Config::FILES, \nTEMPLATES              => $DADA::Config::TEMPLATES,\nVER                    => $DADA::Config::VER, \n\nDATA_CACHE             => $DADA::Config::DATA_CACHE, \n\n\n# CAPTCHA!\ncaptcha_params_recaptcha_type     => $DADA::Config::RECAPTCHA_PARAMS->{recaptcha_type},\ncaptcha_params_v2_public_key      => $DADA::Config::RECAPTCHA_PARAMS->{v2}->{public_key},\ncaptcha_params_v2_private_key     => $DADA::Config::RECAPTCHA_PARAMS->{v2}->{private_key},\ncaptcha_params_v3_public_key      => $DADA::Config::RECAPTCHA_PARAMS->{v3}->{public_key},\ncaptcha_params_v3_private_key     => $DADA::Config::RECAPTCHA_PARAMS->{v3}->{private_key},\n\ncan_use_Google_reCAPTCHA_v2       => scalar DADA::App::Guts::can_use_Google_reCAPTCHA_v2(), \ncan_use_Google_reCAPTCHA_v3       => scalar DADA::App::Guts::can_use_Google_reCAPTCHA_v3(), \n\n\nGIVE_PROPS_IN_HTML             => $DADA::Config::GIVE_PROPS_IN_HTML, \nGIVE_PROPS_IN_SUBSCRIBE_FORM   => $DADA::Config::GIVE_PROPS_IN_SUBSCRIBE_FORM, \nGIVE_PROPS_IN_ADMIN            => $DADA::Config::GIVE_PROPS_IN_ADMIN, \nGIVE_PROPS_IN_EMAIL            => $DADA::Config::GIVE_PROPS_IN_EMAIL, \n          \n\t\t  \nGLOBAL_UNSUBSCRIBE             => $DADA::Config::GLOBAL_UNSUBSCRIBE,                     \nGLOBAL_BLACK_LIST              => $DADA::Config::GLOBAL_BLACK_LIST,             \n\nDEFAULT_ADMIN_SCREEN           => $DADA::Config::DEFAULT_ADMIN_SCREEN, \nMAIL_SETTINGS                  => $DADA::Config::MAIL_SETTINGS, \nMASS_MAIL_SETTINGS             => $DADA::Config::MASS_MAIL_SETTINGS, \nVER                            => $DADA::Config::VER, \n                               \n                               \nENV_SCRIPT_URI                 => $ENV{SCRIPT_URI}, \nENV_SERVER_ADMIN               => $ENV{SERVER_ADMIN},\nHELP_LINKS_URL                 => $DADA::Config::HELP_LINKS_URL, \nHTML_CHARSET                   => $DADA::Config::HTML_CHARSET, \nPROFILE_ENABLED                => $DADA::Config::PROFILE_OPTIONS->{enabled}, \nENFORCE_CLOSED_LOOP_OPT_IN     => $DADA::Config::ENFORCE_CLOSED_LOOP_OPT_IN != 1 ? 0 : 1, \nSUBSCRIPTION_QUOTA             => $DADA::Config::SUBSCRIPTION_QUOTA, \nPROGRAM_IMG_FILENAME           => $DADA::Config::PROGRAM_IMG_FILENAME, \n\nGOOGLE_MAPS_API_PARAMS_api_key                => $DADA::Config::GOOGLE_MAPS_API_PARAMS->{api_key}, \nPII_OPTIONS_ip_address_logging_style          => $DADA::Config::PII_OPTIONS->{ip_address_logging_style}, \nPII_OPTIONS_allow_logging_emails_in_analytics => $DADA::Config::PII_OPTIONS->{allow_logging_emails_in_analytics}, \n\n\n\n\n\n# DEV: Cough! Kludge! Cough!\nLEFT_BRACKET                  => '[',\nRIGHT_BRACKET                 => ']',\nLT_CHAR                       => '<', \nGT_CHAR                       => '>',    \nTEST_UTF_VALUE                => \"\\x{a1}\\x{2122}\\x{a3}\\x{a2}\\x{221e}\\x{a7}\\x{b6}\\x{2022}\\x{aa}\\x{ba}\",        \n\n\n# Random hacks for MS Word, Outlook (sigh)\n#\n# [ 2030573 ] Dadamail 3.0 strips out [endif]\n# http://sourceforge.net/tracker/index.php?func=detail&aid=2030573&group_id=13002&atid=113002\n#\nendif                         => '[endif]',    \n#\n# /Random hacks for MS Word, Outlook (sigh)\n\n(\n    ($DADA::Config::CPAN_DEBUG_SETTINGS{HTML_TEMPLATE} == 1) ? \n        (debug => 1, ) :\n        ()\n), \n\n(\n\t\n\t($DADA::Config::SHOW_ADMIN_LINK eq \"1\") ?\n\t\t(SHOW_ADMIN_LINK  => 1,) : \n\t\t(SHOW_ADMIN_LINK  =>  0,),\n), \n\n                    \n(\n\t\n\t($DADA::Config::SHOW_HELP_LINKS eq \"1\") ?\n\t\t(SHOW_HELP_LINKS  => 1,) : \n\t\t(SHOW_HELP_LINKS  =>  0,),\n),\n\n\n); \n\nmy %WYSIWYG_Vars = WYSIWG_Vars(); \n%Global_Template_Variables = (%Global_Template_Variables, %WYSIWYG_Vars); \n\nsub WYSIWG_Vars { \n\tmy %Vars = (\n\t\tCKEDITOR_URL  => undef, \n\t\tTINY_MCE_URL  => undef, \n\t); \n\t# And test that I can get to the URL - our that at least it's a valid URL... \n\t\n\tif($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{enabled} == 1 \n\t\t&& defined($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url})\n\t\t&& isa_url($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url})\n\t\t){ \n\t\t$Vars{CKEDITOR_URL} = $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url}; \n\t}\n\tif($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{enabled} == 1 \n\t\t&& defined($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url})\n\t\t&& isa_url($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url})\n\t){ \n\t\t$Vars{TINY_MCE_URL} = $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url}; \n\t}\n\t\n#\tuse Data::Dumper; \n#\tdie Dumper({%Vars}); \n\treturn %Vars;\n}\n\n\nsub make_wysiwyg_vars { \n\t\n\tmy $list = shift; \n\tmy %WYSIWG_Vars = WYSIWG_Vars(); \n\trequire DADA::MailingList::Settings; \n\tmy $ls = DADA::MailingList::Settings->new({-list => $list});\n\tmy %vars = ();\n\t\n\t \n\tif($ls->param('use_wysiwyg_editor') eq 'ckeditor' && defined($WYSIWG_Vars{CKEDITOR_URL})) { \n\t\t$vars{using_ckeditor} = 1; \n\t}\n\telsif($ls->param('use_wysiwyg_editor') eq 'tiny_mce' && defined($WYSIWG_Vars{TINY_MCE_URL})) { \n\t\t$vars{using_tiny_mce} = 1; \t\t\n\t}\n\telse { \n\t\t$vars{using_no_wysiwyg_editor} = 1; \n\t}\n\t\n#\tuse Data::Dumper; \n#\tdie Dumper({%vars}); \n\treturn %vars; \n\n}\nif($Global_Template_Variables{PROGRAM_URL} eq 'https://www.changetoyoursite.com/cgi-bin/dada/mail.cgi'){ \n\n\t$Global_Template_Variables{PROGRAM_URL} = $q->url; \n\t# Well, what if we're running as the installer?\n\tif($Global_Template_Variables{PROGRAM_URL} =~ m/installer\\/install\\.cgi$/){ \n\t\t$Global_Template_Variables{PROGRAM_URL} =~ s{installer\\/install\\.cgi}{mail.cgi};\n\t}\n}\nif($Global_Template_Variables{S_PROGRAM_URL} eq 'https://www.changetoyoursite.com/cgi-bin/dada/mail.cgi'){ \n\t$Global_Template_Variables{S_PROGRAM_URL} = $Global_Template_Variables{PROGRAM_URL}; \n}\nmy %Global_Template_Options = (\n\t\t# DEV: Dude, it's no wonder any templates are ever found.  \t\t\n\t\tpath              => [\n\t\t\t\t\t\t\t\t$DADA::Config::TEMPLATES, \n\t\t\t\t\t\t\t\t$DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH, \n\t\t\t\t\t\t\t\t@guesses, \n\t\t\t\t\t\t\t\t'templates', \n\t\t\t\t\t\t\t\t'Templates/templates', \n\t\t\t\t\t\t\t\t'DADA/Templates/templates', \n\t\t\t\t\t\t\t\t'../DADA/Templates/templates',\n\t\t\t\t\t\t\t\t'../../DADA/Templates/templates',\n\t\t\t\t\t\t\t],\n\t\tdie_on_bad_params => 0,\t\n\t\tloop_context_vars => 1, \t\t\t\t\t\t\t\t\t\n);\n\nmy %_ht_tmpl_set_params = (); \n\t\t\t\t\t\t\t\t\t\t\t\n=pod\n\n=head1 Name\n\nDADA::Template::Widgets\n\n=head1 Description\n\nHolds commonly used HTML 'widgets'\n\n=head1 Subroutines\n\n=cut\n\n\n=pod\n\n=head2 list_popup_menu\n\nreturns a popup menu holding all the list names as labels and \nlist shortnames as values\n\n=cut\n\n\nsub priority_popup_menu { \n\n\tmy $li       = shift; \n\tmy $default = shift || undef;\n\t\n\t\n\tif(! defined($default)){ \n\t\t$default = $li->{priority};\n\t}\n\trequire HTML::Menu::Select; \n    my $priority_popup_menu = HTML::Menu::Select::popup_menu(\n\t\t\t\t\t\t\t  \t\t{ \n\t\t\t\t\t\t\t\t\t\tname     => 'X-Priority',\n\t\t\t\t\t\t\t\t\t\tid       => 'X-Priority',\n\t                                    values   =>[keys %DADA::Config::PRIORITIES],\n\t                                    labels   => \\%DADA::Config::PRIORITIES,\n\t                                    default  =>  $default, \n                              \t\t}\n\t\t\t\t\t\t\t  \t);\n\treturn $priority_popup_menu; \n\t\n}\n\n\n\n\nsub list_popup_menu { \n\n\t\n\trequire HTML::Menu::Select; \n\tmy $r = undef; \n\t\n\tmy %args = (\n\t\t-show_hidden         => 0,\n\t\t-name                => 'list',\n\t\t-empty_list_check    => 0, \n\t\t-as_checkboxes       => 0, \n\t\t-show_list_shortname => 0, \n\t\t-selected_list       => undef, \n\t\t-disable_invite_only => 0, \n\t    @_\n\t); \n\tmy $labels     = {}; \n\tmy $attributes = {};\n\t \n\trequire DADA::MailingList::Settings; \n\t\n\tmy @lists = available_lists(-Dont_Die => 1); \n\n\t \n\treturn undef if scalar @lists <= 0;\n\t\n\tmy $l_count = 0; \n\t\n\t# This needs its own method...\n\t\tforeach my $list( @lists ){\n\t\t\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\t\tnext if \n\t\t\t\t$args{-show_hidden} == 0 \n\t\t\t\t&& ($ls->param('hide_list') == 1 \n\t\t\t\t&& $ls->param('private_list') == 1); \n\t\t\t\t\n\t\t\tif($args{-show_list_shortname} == 1){ \n\t\t\t\t$labels->{$list} = $ls->param('list_name') . ' (' . $list . ')';\n\t\t\t}\n\t\t\telse { \n\t\t\t\t$labels->{$list} = $ls->param('list_name');\n\t\t\t}\n\n\t\t\tif($args{-disable_invite_only} == 1){\n\n\t\t\t\tif($ls->param('invite_only_list') == 1){ \n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t$labels->{$list} .= ' - by Invitation Only';\n\t\t\t\t\t$attributes->{$list}->{disabled} = \"disabled\";\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(\t$args{-selected_list} eq $list \n\t\t\t\t\t&& $ls->param('invite_only_list') != 1\n\t\t\t\t){ \n\t\t\t\t\t$attributes->{$list}->{selected} = \"selected\";\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { \n\t\t\t\tif(\t$args{-selected_list} eq $list \n\t\t\t\t){ \n\t\t\t\t\t$attributes->{$list}->{selected} = \"selected\";\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t$l_count++;\n\t\t}\n\t\tmy @opt_labels = sort { uc($labels->{$a}) cmp uc($labels->{$b}) } keys %$labels;\n\t#\t\t\t\t\t\t\t\t#\t\n\t\n\tif($l_count <= 0 && $args{-empty_list_check} == 1){ \n\t\n\t    return undef; \n\t}\n\t\n\tif($args{-as_checkboxes} == 1){ \n        $r =  $q->checkbox_group(\n                                   -name      => $args{-name}, \n\t\t\t\t\t\t\t\t   -id        => 'ddm_' . $args{-name}, \n                                  '-values'   => [@opt_labels],\n                                   -labels    => $labels,\n                                   -columns   => 2, \n\t\t\t\t\t\t\t\t   -default  => [$args{-selected_list}],\n                                 );\t\t\t\t \t\n\t\n\t}\n\telse { \n\t\t\n\t\tif(scalar @opt_labels == 0){ \n\t\t\treturn undef; \n\t\t}\n        $r = HTML::Menu::Select::popup_menu(\n\t\t\t {\n\t\t\t\tname       => $args{-name}, \n\t\t\t\tid         => 'ddm_' . $args{-name}, \n\t\t\t\tvalues     => [@opt_labels],\n\t\t\t\tlabels     => $labels,\n#\t\t\t\tdefault    => [],\n\t\t\t\tattributes => $attributes,\n\t\t\t}\n\t\t ); \n    }\n\t\n\t\n\treturn $r; \n\t\n}\n\n\n\n\nsub list_popup_login_form { \n\t\n\tmy %args = (\n\t\t-show_hidden => 0, \n\t\t-auth_state  => undef, \n\t\t@_,\n\t); \n\t\n\tmy $url             = $ENV{SCRIPT_URI} || $q->url(); \n\tmy $referer         = $ENV{HTTP_REFERER}; \n\tmy $query_string    = $ENV{QUERY_STRING}; \n\tmy $path_info       = $ENV{PATH_INFO}; \n\t\n\tmy $list_popup_menu = list_popup_menu(\n\t\t\t\t\t\t\t-name   \t         => 'admin_list', \n\t\t\t\t   \t\t    -show_hidden         => $args{-show_hidden},\n\t\t\t\t   \t\t    -empty_list_check    => 1, \n\t\t\t\t\t\t\t-show_list_shortname => 1, \n\t\t\t\t   \t\t   );\n\n\t\tif(show_login_list_textbox() == 1){ \n\t\t\treturn screen( \n\t\t\t\t{ \n\t\t\t\t\t-screen => 'text_box_login_form.tmpl', \n\t\t\t        -vars   => { \n\n\t\t\t            list_popup_menu => $list_popup_menu, \n\t                    auth_state      => $args{-auth_state},\n\t\t\t\t\t\treferer         => $referer, \n\t\t\t\t\t\turl             => $url, \n\t\t\t\t\t\tquery_string    => $query_string, \n\t\t\t\t\t\tpath_info       => $path_info, \n\t\t\t\t\t\tshow_other_link => _show_other_link(),  \n\t\t\t\t    }\n\t\t\t\t},\t\n\t\t\t);\n\t\t}\n\t\telse { \n\t\t\t\t\t\t  \t\t                 \n\t\t\treturn screen(\n\t\t\t    {\n\t\t\t        -screen => 'list_popup_login_form.tmpl',\t\t\n\t\t\t        -vars   => { \n\t\t            \n\t\t\t            list_popup_menu => $list_popup_menu, \n\t                    auth_state      => $args{-auth_state},\n\t\t\t\t\t\treferer         => $referer, \n\t\t\t\t\t\turl             => $url, \n\t\t\t\t\t\tquery_string    => $query_string, \n\t\t\t\t\t\tpath_info       => $path_info, \n\t\t\t\t\t\tshow_other_link => _show_other_link(),  \n\t\t\t\t    }\n\t\t\t\t}\n\t\t    ); \n\t}\n}\n\n\n\n\n\n\nsub default_screen {\n\t\n\tmy ($args) = @_; \t\n#        -show_hidden        => undef,\n#        -name               => undef,\n#        -email              => undef,\n#        -error_invalid_list => 0,\n\n    require DADA::MailingList::Settings;\n    require DADA::MailingList::Archives;\n\n    my $subscriber_fields;\n    my @list_information = ();\n    my $reusable_parser  = undef;\n\n    # Keeps count of how many visible lists are printed out;\n    my $l_count = 0;\n\n    my $labels = {};\n    foreach my $l ( available_lists() ) {\n\n        # This is a weird placement...\n        if ( !$subscriber_fields ) {\n            require DADA::MailingList::Subscribers;\n            my $lh = DADA::MailingList::Subscribers->new( { -list => $l } );\n            $subscriber_fields = $lh->subscriber_fields(\n\t\t\t\t{\n\t\t\t\t\t-show_hidden_fields => 0,\n\t\t\t\t}\n\t\t\t);\n        }\n\n        # /This is a weird placement...\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $l } );\n        if($ls->param('hide_list') == 1 && $ls->param('private_list') == 1){ \n            next; \n        }\n        else {\n            $labels->{$l} = $ls->param('list_name');\n            $l_count++;\n        }\n    }\n    my @list_in_list_name_order =\n      sort { uc( $labels->{$a} ) cmp uc( $labels->{$b} ) } keys %$labels;\n\n    foreach my $list (@list_in_list_name_order) {\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n        my $all_list_info        = $ls->get;\n        my $all_list_info_dotted = $ls->get( -dotted => 1 );\n\n\t\tmy $ah = undef; \n\t\tif($ls->param('show_archives') == 1){   \n\n\t        $ah = DADA::MailingList::Archives->new(\n\t            {\n\t                -list => $list,\n\t                ( ($reusable_parser) ? ( -parser => $reusable_parser ) : () )\n\t            }\n\t        );\n\t\t}\n\t\t\n        unless($ls->param('hide_list') == 1 && $ls->param('private_list') == 1){ \n            $l_count++;\n\n            # This is strange...\n            $all_list_info_dotted->{'list_settings.info'} =\n              markdown_to_html({-str => $all_list_info_dotted->{'list_settings.info'} });\n            $all_list_info_dotted->{'list_settings.info'} =\n              _email_protect({-string => $all_list_info_dotted->{'list_settings.info'}} );\n\n  \t\t\tmy $ne; \n  \t\t\tmy $subject; \n  \t\t\tif($ls->param('show_archives') == 1){   \n              \t$ne      = $ah->newest_entry;\n              \t$subject = $ah->get_archive_subject($ne);\n                  $subject = $ah->_parse_in_list_info( -data => $subject );\n\n  \t\t\t   # this is so atrocious.\n  \t            $all_list_info_dotted->{latest_archive_date} = date_this(\n  \t           -Packed_Date   => $ne,\n  \t           -Write_Month   => $ls->param('archive_show_month'),\n  \t           -Write_Day     => $ls->param('archive_show_day'),\n  \t           -Write_Year    => $ls->param('archive_show_year'),\n  \t           -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n  \t           -Write_Second  => $ls->param('archive_show_second')\n  \t           );\n\t\t\t   \n  \t\t\t\t  $all_list_info_dotted->{latest_archive_id} = $ne;\n  \t            # These two things are sort of strange.\n  \t            $all_list_info_dotted->{latest_archive_blurb} =\n  \t              $ah->message_blurb();\n  \t            $all_list_info_dotted->{latest_archive_subject} = $subject;\n  \t\t\t}\n\t\t\n\t\t\n            push ( @list_information, $all_list_info_dotted );\n  \t\t\tif($ls->param('show_archives') == 1){   \n  \t\t\t\t$reusable_parser = $ah->{parser} if !$reusable_parser;\n  \t\t\t}\n        }\n    }\n\n    my $visible_lists = 1;\n    if ( $l_count == 0 ) {\n        $visible_lists = 0;\n    }\n\n    my $named_subscriber_fields = [];\n    foreach (@$subscriber_fields) {\n        push ( @$named_subscriber_fields, { name => $_ } );\n    }\n\n    my $list_popup_menu = list_popup_menu(\n        -email               => $args->{email},\n        -list                => $args->{list},\n\t\t-disable_invite_only => 1, \n    );\n\n\treturn wrap_screen(\n        {\n\t\t\t-with   => 'list', \n            -screen => 'default_screen.tmpl',\n            -vars   => {\n\t\t\t\tcan_use_JSON       => scalar DADA::App::Guts::can_use_JSON(), \n                list_popup_menu    => $list_popup_menu,\n                email              => $args->{ -email },\n                list_information   => \\@list_information,\n                visible_lists      => $visible_lists,\n                error_invalid_list => $args->{ -error_invalid_list },\n                fields             => $named_subscriber_fields,\n                #subscription_form  => scalar subscription_form(),\n            },\n        }\n    );\n}\n\nsub list_page { \n\n\tmy %args = (-list           => undef, \n\t\t\t    -email          => undef, \n\t\t\t\t-error_no_email => undef, \n\t\t\t\t-cgi_obj        => undef, \n\t\t\t\t@_);\n    \n\trequire DADA::MailingList::Settings; \n\t\n\tmy $ls = DADA::MailingList::Settings->new({-list => $args{-list}}); \n\n    my $html_archive_list = html_archive_list($args{-list}); \n\t\n\trequire DADA::Profile; \n\tmy $prof = DADA::Profile->new(\n\t\t{\n\t\t\t-from_session => 1, \n\t\t}\n\t); \n\tmy $allowed_to_view_archives = 1;\n\tif($prof) { \n\t\t$allowed_to_view_archives = $prof->allowed_to_view_archives(\n\t\t\t{\n\t\t\t\t-list         => $args{-list},\n\t\t\t}\n\t\t);\n\t}\n\t\n\t\n\t# So, how does, \"wrap_screen\" embed variables? \n\t# In other words, how do I show the list name in the title? That's important. \n\t\n    my $template = wrap_screen(\n        {\n        -with                     => 'list', \n        -screen                   => 'list_page_screen.tmpl',\n        -list_settings_vars       => $ls->get,\n        -list_settings_vars_param => {\n\t\t\t-dot_it => 1\n\t\t\t-list   => $args{-list}, # this is redundant, but important for email protection.\n\t\t },\n\n        -vars                     => \n        { \n\t\t\tcan_use_JSON              => scalar DADA::App::Guts::can_use_JSON(), \n            subscription_form         => subscription_form({-list => $args{-list}, -email => $args{-email}}), \n            error_no_email            => $args{-error_no_email}, \n            html_archive_list         => $html_archive_list, \n\t\t\tallowed_to_view_archives  => $allowed_to_view_archives,  \n        },\n        \n        -webify_and_santize_these => [qw(\n\t\t\tlist_settings.discussion_pop_email\n\t\t\tlist_settings.list_owner_email\n\t\t\tlist_settings.info list_settings.privacy_policy\n\t\t)], \n        \n        }\n    ); \n\n    return $template; \n\n}\n\n\n\n\nsub admin {\n\tmy ($args) = @_; \n\t\n\tif(! exists($args->{-vars}) ){ \n\t\t$args->{-vars} = {};\n\t}\n\t\n\tif(! exists($args->{-vars}->{login_widget}) ){ \n\t\t$args->{-vars}->{login_widget} = $DADA::Config::LOGIN_WIDGET;\n\t}\n\t\n\tif(\n\t\tcheck_if_list_exists( -List => $args->{-vars}->{selected_list}) >= 1\n\t\t&& _is_hidden($args->{-vars}->{selected_list})\n\t\n\t){ \n\t\t$args->{-vars}->{login_widget} = 'text_box'; \n\t}\n\t\n    my @available_lists = available_lists();\n\t\n    my $list_max_reached = 0;\n\t\n\tif(strip($DADA::Config::LIST_QUOTA) eq '') {\n\t\t$DADA::Config::LIST_QUOTA = undef;\n    } \n\t# Special: \n\tif($DADA::Config::LIST_QUOTA == 0){ \n\t\t$DADA::Config::LIST_QUOTA = undef;\n\t}\n    if (   defined($DADA::Config::LIST_QUOTA)\n        && ( \n\t\t\t( $#available_lists + 1 ) >= $DADA::Config::LIST_QUOTA \n\t\t) \n\t\t\n\t\t) {\n        $list_max_reached = 1;\n    }\n\n    my $list_popup_menu = list_popup_menu(\n        -name                => 'admin_list',\n        -show_hidden         => 0,\n        -empty_list_check    => 1,\n        -show_list_shortname => 1,\n\t\t-selected_list       => $args->{-vars}->{selected_list},\n    );\n\tif(!defined($list_popup_menu)) {\n\t\t$args->{-vars}->{login_widget} = 'text_box';\n\t}\n\n    my $auth_state;\n\t\n    if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n        require DADA::Security::SimpleAuthStringState;\n        my $sast = DADA::Security::SimpleAuthStringState->new;\n        $auth_state = $sast->make_state;\n    }\n\n\tmy $show_another_link = _show_other_link(); \n\t\n\tmy $logged_out = $args->{-cgi_obj}->param('logged_out') // 0; \n\t\n\tmy $show_2col_view = 0; \n\tmy $tmp_vars = $args->{-vars};\n\tif(\texists($tmp_vars->{errors})\t){ \n\t\tfor my $err(@{$tmp_vars->{errors}}){ \n\t\t\tif($err->{error} eq 'invalid_password'){ \n\t\t\t\t$show_2col_view = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n    return wrap_screen(\n        {\n            -screen         => 'admin_screen.tmpl',\n            -with           => 'list',\n            -wrapper_params => {\n                -Use_Custom => 0,\n            },\n            -vars => {\n\t\t\t\tlogged_out              => $logged_out, \n                list_popup_menu         => $list_popup_menu,\n                list_max_reached        => $list_max_reached,\n                auth_state              => $auth_state,\n                show_other_link         => $show_another_link,\n\t\t\t\t%{$args->{-vars}},\n            },\n        }\n    );\n}\n\n\nsub _is_hidden { \n    require DADA::MailingList::Settings; \n    my $list = shift; \n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n        return 1\n            if $ls->param('hide_list') == 1  && $ls->param('private_list') == 1; \t\t\n    return 0; \n}\nsub _show_other_link { \n\n    require DADA::MailingList::Settings; \n    \n    \n    # Basically, if there's at least one list that's hidden, we show the \n    # More... link. \n        \n    foreach my $list(available_lists(-Dont_Die => 1) ){\n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n        return 1\n            if $ls->param('hide_list') == 1  && $ls->param('private_list') == 1; \n\t}\n\t\t\t\n    return 0; \n    \n}\n\n\n\n\nsub show_login_list_textbox { \n\t\n\t# This means, if all the lists are hidden, we have to show the \n\t# text login box. Yup. \n\t#\n\t\n\trequire DADA::MailingList::Settings; \n    \n    foreach my $list(available_lists(-Dont_Die => 1) ){\n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n        return 0\n            if $ls->param('hide_list') == 1  && $ls->param('private_list') == 1; \n\t}\n\t\t\t\n    return 1;\n\t\n}\n\n\n\n\nsub html_archive_list { \n\n\t#  DEV: god, what a mess...\n\t#\n\tmy $list = shift; \n\tmy $t    = \"\";\n\t\n\trequire DADA::MailingList::Archives; \n\trequire DADA::MailingList::Settings;\n\n\t\n\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\n\treturn '' \n\t\tif $ls->param('show_archives') != 1;\n\t\n\trequire DADA::Profile; \n\tmy $prof = DADA::Profile->new(\n\t\t{\n\t\t\t-from_session => 1, \n\t\t}\n\t); \n\tmy $allowed_to_view_archives = 1;\n\tif($prof) { \n\t\t$allowed_to_view_archives = $prof->allowed_to_view_archives(\n\t\t\t{\n\t\t\t\t-list         => $list, \n\t\t\t}\n\t\t);\n\t}\n\tif($allowed_to_view_archives == 1){ \n\t\t\n\t\tmy $archive = DADA::MailingList::Archives->new({-list => $list}); \n\t\tmy $entries = $archive->get_archive_entries(); \n\t\n\t\n\t\tif(defined($entries->[0])) { \n\t\n\n\t        my ($begin, $stop) = $archive->create_index(0);\n\t        my $i;\n\t        my $stopped_at = $begin;\n\t        my $num = $begin;\n        \n\t        $num++; \n\t        my @archive_nums; \n\t        my @archive_links; \n\t        my $th_entries = []; \n    \n        \n        \n\t        # iterate and save\n\t        for($i = $begin; $i <=$stop; $i++){ \n\t            my $link; \n            \n\t            if(defined($entries->[$i])){\n                \n\t                my ($subject, $message, $format, $raw_msg) = $archive->get_archive_info($entries->[$i]); \n                \n                \n\t                 # THis is stupid: \n\t                 # DEV: This is stupid, and I don't think it's a great idea. \n\t                    $subject = DADA::Template::Widgets::screen(\n\t                        {\n\t                        -data                    => \\$subject, \n\t                        -vars                     => $ls->get, \n\t                        -list_settings_vars       => $ls->get, \n\t                        -list_settings_vars_param => {-dot_it => 1},                    \n\t\t\t\t\t\t\t-subscriber_vars_param    => {-use_fallback_vars => 1, -list => $ls->param('list')},\n\n\t                        }\n\t                    ); \n\t                    # That. Sucked.\n                \n                \n\t                # this is so atrocious.\n\t                my $date = date_this(\n\t                -Packed_Date   => $entries->[$i],\n\t                -Write_Month   => $ls->param('archive_show_month'),\n\t                -Write_Day     => $ls->param('archive_show_day'),\n\t                -Write_Year    => $ls->param('archive_show_year'),\n\t                -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n\t                -Write_Second  => $ls->param('archive_show_second')\n\t                );\n\t\t\t\t\t\n\t\t\t\t\tmy $header_from      = undef;\n\t                my $orig_header_from = undef;\n\n\t                if ($raw_msg) {\n\t                    $header_from = $archive->get_header(\n\t                        -header => 'From',\n\t                        -key    => $entries->[$i]\n\t                    );\n\t                    $orig_header_from = $header_from;\n\t                }\n\t\n\t\t\t\t\tmy $can_use_gravatar_url = 0;\n\t                my $gravatar_img_url     = '';\n\n\t                if ( $ls->param('enable_gravatars') ) {\n\n\t                    eval { require Gravatar::URL };\n\t                    if ( !$@ ) {\n\t                        $can_use_gravatar_url = 1;\n\n\n                                my $header_address = $archive->sender_address(\n                                 {\n                                        -id => $entries->[$i],\n                                    }\n                            ); \n                            $gravatar_img_url = gravatar_img_url(\n                                {\n                                    -email                => $header_address,\n                                    -default_gravatar_url => $ls->param('default_gravatar_url'),\n                                }\n                            );\n\t                    }\n\t                    else {\n\t                        $can_use_gravatar_url = 0;\n\t                    }\n\t                }\n\t\t                \t\n   # die $archive->message_blurb(-key => $entries->[$i]); \n\t                my $entry = { \t\t\t\t\n\t                        id               => $entries->[$i], \n    \n\t                        date             => $date, \n\t                        subject          => $subject,\n\t                       'format'          => $format, \n\t                        list             => $list, \n\t                        uri_escaped_list => uriescape($list),\n\t                        PROGRAM_URL      => $DADA::Config::PROGRAM_URL, \n\t\t                    'list_settings.enable_gravatars' =>\n\t\t                      $ls->param('enable_gravatars'),\n\t\t                    can_use_gravatar_url => $can_use_gravatar_url,\n\t\t                    gravatar_img_url     => $gravatar_img_url,\n\t\n\t                        message_blurb    => $archive->message_blurb(-key => $entries->[$i]),\n\t                    }; \n                \n\t                $stopped_at++;\n\t                push(@archive_nums, $num); \n\t                push(@archive_links, $link); \n\t                $num++;\n    \n    \n\t                push(@$th_entries, $entry); \n                    \n\t            }\n\t        } \n    \n\t        my $ii; \n        \n\t        for($ii=0;$ii<=$#archive_links; $ii++){ \n    \n\t            my $bullet = $archive_nums[$ii];\n            \n\t            #fix if we're doing reverse chronologic \n\t            $bullet = (($#{$entries}+1) - ($archive_nums[$ii]) +1) \n\t                if($ls->param('sort_archives_in_reverse') == 1);\n    \n\t            # yeah, whatever. \n\t            $th_entries->[$ii]->{bullet} = $bullet; \n            \n\t        }\n    \t\n\n\n        $t .= screen({-screen => 'archive_list_widget.tmpl', \n                     -vars => {\n                                entries              => $th_entries,\n                                list                 => $list, \n                                list_name            => $ls->param('list_name'), \n                                publish_archives_rss => ($ls->param('publish_archives_rss')) ? 1: 0, \n                                index_nav            => $archive->create_index_nav($stopped_at), \n                               allowed_to_view_archives => 1, \n\t\t\t\t\t\t\t}\n                    });  \n \n\t\t\t}\n\t}\n\telse { \n\t\t$t = screen({-screen => 'archive_list_widget.tmpl', \n                     -vars => {\n                                entries              => [],\n                                list                 => $list, \n                                list_name            => $ls->param('list_name'), \n                                publish_archives_rss => 0,\n                                index_nav            => '', \n                                search_form          => '', \n\t\t\t\t\t\t\t\tallowed_to_view_archives => 0, \n                               }\n                    });  \n\n\t}\n\t\n\treturn $t; \n\n}\n\n\n\n\nsub login_switch_widget { \n\n\tmy $args = shift; \n\t\n\tcroak \"no list!\" if ! $args->{-list};\n\t\n\trequire DADA::MailingList::Settings; \n\n\tmy $location = $q->self_url || $DADA::Config::S_PROGRAM_URL . '?flavor=' . $args->{-f}; \n\t   $location =~ s/^http//; \n\t\n    require  DADA::App::ScreenCache; \n    my $c  = DADA::App::ScreenCache->new; \n    \n #   if($c->is_cached('login_switch_widget.' . $args->{-list} . '.scrn')){ \n #       my $lsw = $c->pass('login_switch_widget.' . $args->{-list} . '.scrn');\n #          $lsw =~ s/\\[LOCATION\\]/$location/g; \n #          return $lsw; \n #     }\n\n    my $scrn; \n    my $lists = []; \n    \n\tforeach my $list(available_lists(-In_Order => 1)){\n\t\t\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\t\tmy $logged_in = 0; \n\t\t\tif($list eq $args->{-list}){ \n\t\t\t   $logged_in = 1;  \n\t\t\t}\n\t\t\tpush(\n\t\t\t    @$lists, \n\t\t\t    {\n\t\t\t        'list_settings.list'      => $list, \n\t\t\t        'list_settings.list_name' => $ls->param('list_name'), \n\t\t\t        location                  => $location, \n\t\t\t        logged_in                 => $logged_in, \n\t\t\t\t\tS_PROGRAM_URL             => $DADA::Config::S_PROGRAM_URL, \n\t\t\t\t\tPROGRAM_URL               => $DADA::Config::PROGRAM_URL, \n\t\t\t\t\t\n\t\t\t    }\n\t\t\t); \n\t}\n\n\treturn DADA::Template::Widgets::screen(\n\t\t\t\t{\n\t\t\t\t    -screen => 'login_switch_widget.tmpl',\n\t\t\t\t    -vars   => { \n\t\t\t\t        lists => $lists, \n\t\t\t\t    },\n\t\t\t\t}\n\t\t\t); \n\t\n\t\n\t\n#\t$c->cache('login_switch_widget.' . $args->{-list} . '.scrn', \\$scrn);\t\n#\t$scrn =~ s/\\[LOCATION\\]/$location/g; \n # return $scrn; \n\n}\n\nsub login_switch_popup_menu_widget { \n\n\tmy $args = shift; \n\t\n\tcroak \"no list!\" if ! $args->{-list};\n\t\n\trequire DADA::MailingList::Settings; \n\n\tmy $location = $q->self_url || $DADA::Config::S_PROGRAM_URL . '?flavor=' . $args->{-f}; \n\n    require  DADA::App::ScreenCache; \n    my $c  = DADA::App::ScreenCache->new; \n    \n    #if($c->is_cached('login_switch_widget.' . $args->{-list} . '.scrn')){ \n    #    my $lsw = $c->pass('login_switch_widget.' . $args->{-list} . '.scrn');\n    #       $lsw =~ s/\\[LOCATION\\]/$location/g; \n    #       return $lsw; \n    #  }\n\n    my $scrn; \n    \n\n\tmy @lists = available_lists(-In_Order => 1); \n\tmy %label = (); \n\t\n\t# DEV TODO - This needs its own METHOD!!!\n\t\n\tforeach my $list( @lists ){\n\t\t\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\t\t$label{$list} = $ls->param('list_name') . ' (' . $list . ')'; \n\t\t\t\n\t}\n\t\n\t$label{$args->{-list}} = '----------'; \n\t\n\trequire HTML::Menu::Select;\n\tmy $login_switch_popup_menu = HTML::Menu::Select::popup_menu(\n\t\t{\n\t\t\tname    => 'change_to_list', \n\t\t\tid      => 'change_to_list', \n\t\t\tvalue   => [@lists], \n\t\t\tdefault => $args->{-list},\n\t\t\tlabels  => {%label}, \n\t\t}\n\t);\n\t\t\n\tmy $num_lists = scalar @lists; \n\treturn DADA::Template::Widgets::screen(\n\t\t{\n\t\t    -screen => 'login_switch_popup_menu_widget.tmpl',\n\t\t\t-vars   => { \n\t\t\t\tnum_lists               => $num_lists, \n\t\t\t\tlogin_switch_popup_menu => $login_switch_popup_menu, \n\t\t        location                => $location, \n\t\t    },\n\t\t}\n\t);\n}\n\n\n\n\nsub archive_send_form { \n\n\tmy ($list, $id, $errors, $captcha_archive_send_form, $captcha_fail) = @_; \n\n    my $CAPTCHA_string = '';\n    # ?!?!\n    $captcha_fail = defined $captcha_fail ? $captcha_fail : 0;\n\n    my $can_use_captcha = can_use_Google_reCAPTCHA_v2(); \t\n\t$can_use_captcha = 0 \n\t\tif length($DADA::Config::RECAPTCHA_PARAMS->{v2}->{public_key}) <= 0;\n\t$can_use_captcha = 0 \n\t\tif length($DADA::Config::RECAPTCHA_PARAMS->{v2}->{private_key}) <= 0;\n\t\n    if($captcha_archive_send_form == 1 && $can_use_captcha == 1){ \n            my $captcha_worked = 0; \n            my $captcha_auth   = 1; \n\n            require DADA::Security::AuthenCAPTCHA::Google_reCAPTCHA; \n            my $cap = DADA::Security::AuthenCAPTCHA::Google_reCAPTCHA->new; \n               $CAPTCHA_string = $cap->get_html();  \n    }\n\n\treturn DADA::Template::Widgets::screen(\n\t\t\t\t{\n\t\t\t\t    -screen => 'send_archive_form_widget.tmpl',\n\t\t\t\t    -vars   => { \n\t\t\t\t        send_archive_form_error => $errors, \n\t\t\t\t        list                    => $list, \n\t\t\t\t        id                      => $id, \n\t        \n\t\t\t\t        # CAPTCHA stuff\n\t\t\t\t\t    can_use_captcha => $can_use_captcha, \n\t\t\t\t        CAPTCHA_string  => $CAPTCHA_string,\n\t\t\t\t        captcha_fail    => $captcha_fail, \n\t\t\t\t    },\n\t\t\t\t}\n\t\t\t); \n}\n\n\n\nsub profile_widget {\n\n\tmy ($args) = @_; \n\tmy $prof_sess_obj = undef; \n\t\n\tif(defined($args->{-prof_sess_obj})){ \n\t\t$prof_sess_obj = $args->{-prof_sess_obj};\n\t}\n\t\n\t\n    my $scr              = '';\n    my $email            = '';\n    my $is_logged_in     = 0;\n    my $profiles_enabled = $DADA::Config::PROFILE_OPTIONS->{enabled};\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1)\n    {\n        $profiles_enabled = 0;\n    }\n    else {\n\t\tif(defined($prof_sess_obj)){ \n\t\t\tif ( $prof_sess_obj->is_logged_in( { -cgi_obj => $q } ) ) {\n                $is_logged_in = 1;\n                $email = $prof_sess_obj->get( { -cgi_obj => $q } );\n\t\t\t}\n\t\t}\n\t\telse {\n\t        require DADA::Profile;\n\t        my $dp = DADA::Profile->new( { -from_session => 1 } );\n\t        if ($dp) {\n\t            require DADA::Profile::Session;\n\t            require CGI;\n\t            my $prof_sess = DADA::Profile::Session->new;\n\t            if ( $prof_sess->is_logged_in( { -cgi_obj => $q } ) ) {\n\t                $is_logged_in = 1;\n\t                $email = $prof_sess->get( { -cgi_obj => $q } );\n\t            }\n\t        }\n\t\t}\n    }\n\n    return screen(\n        {\n            -screen => 'profile_widget.tmpl',\n            -vars   => {\n                profiles_enabled  => $profiles_enabled,\n                is_logged_in      => $is_logged_in,\n                'profile.email'   => $email,\n                gravators_enabled => $DADA::Config::PROFILE_OPTIONS->{gravatar_options}->{enable_gravators},\n                gravatar_img_url => gravatar_img_url(\n                    {\n                        -email                => $email,\n                        -size => 45,\n                    }\n                ),\n\n            }\n        }\n    );\n\n}\n\n\nsub amazon_ses_requirements_widget { \n\t\n\tmy $amazon_ses_required_modules = [ \n\t\t{module => 'Cwd',             installed => 1}, \n\t\t{module => 'Digest::SHA',     installed => 1}, \n\t\t{module => 'URI::Escape',     installed => 1}, \n\t\t{module => 'MIME::Base64',    installed => 1}, \t\n\t\t{module => 'Crypt::SSLeay',   installed => 1}, \t\n\t\t{module => 'XML::LibXML',     installed => 1},\n\t\t{module => 'LWP',             installed => 1}, \n\t\t{module => 'AWS::Signature4', installed => 1},\n#\t\t{module => 'Some::Unknown::Module',       installed => 1}, \n\t];\n\n\n\tmy $amazon_ses_has_needed_cpan_modules = 1; \n\ttry {\n\t\trequire Cwd;\n\t} catch { \n\t\t$amazon_ses_required_modules->[0]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire Digest::SHA;\n\t} catch { \n\t\t$amazon_ses_required_modules->[1]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire URI::Escape;\n\t} catch { \n\t\t$amazon_ses_required_modules->[2]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire MIME::Base64;\n\t} catch { \n\t\t$amazon_ses_required_modules->[3]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire Crypt::SSLeay;\n\t} catch { \n\t\t$amazon_ses_required_modules->[4]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire XML::LibXML;\n\t} catch { \n\t\t$amazon_ses_required_modules->[5]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0; \n\t};\n\teval {require LWP;};\n\tif($@){\n\t\t$amazon_ses_required_modules->[6]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0; \n\t}\n\t\n\ttry {\n\t\trequire AWS::Signature4;\n\t} catch { \n\t\t$amazon_ses_required_modules->[7]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\t\n#\ttry {\n#\t\trequire Some::Unknown::Module;\n#\t} catch { \n#\t\t$amazon_ses_required_modules->[7]->{installed}           = 0;\n#\t\t$amazon_ses_has_needed_cpan_modules = 0; \n#\t};\n\t\n\t\n\t\n\treturn screen(\n\t\t{\n\t\t\t-screen => 'amazon_ses_requirements_widget.tmpl',\n\t\t\t-vars   => {\n\t\t\t\tamazon_ses_has_needed_cpan_modules  => $amazon_ses_has_needed_cpan_modules, \n\t\t\t\tamazon_ses_required_modules         => $amazon_ses_required_modules, \n\t\t\t}\n\t\t}\n\t);\n\t\n}\n\n\n\n\n\n\n\n=pod\n\n=head2 screen\n\nC<screen()> is a slight wrapper around the HTML::Template module. See: \n\nL<http://search.cpan.org/~samtregar/HTML-Template/Template.pm>\n\nC<screen> has somewhat of a similar API, but a bit simplier - for example, it also \nincludes support for HTML::Template::Expr: \n\nL<http://search.cpan.org/~samtregar/HTML-Template-Expr/Expr.pm>\n\nwith just a parameter change. The default is to use HTML::Template. \nNo other HTML::Template::* modules are used. \n\nI won't delve into great detail on how to make a HTML::Template or HTML::Template::Expr template, \nbut I would encourage you to look into the docs for the two above modules for the jist. Any valid \nHTML::Template and/or HTML::Template::Expr template can be used for C<screen>.\n\nFinally screen has some (always optional) hooks into Dada Mail's Settings and Subscribers backends, \nso you may tell C<screen> to use that information, instead of passing things in the C<-vars> paramter. \n\nAnyways: \n\n require DADA::Template::Widgets; \n print DADA::Template::Widgets::screen(\\\n    {\n    # ...\n    }\n ); \n\nC<screen> returns back a string with the final result of the template and basically what \nB<HTML::Template>'s C<output> will return. No post processing is done after that. \n\nGetting data to screen can be done in basically two ways: \n\nVia the C<-data> parameter: \n\n my $scalar = 'This is my information!'; \n print DADA::Template::Widgets::screen(\n    {\n        -data => \\$scalar,\n    }\n ); \n\nThe information in B<-data> needs to be a reference to a scalar value. In B<H::T>, it maps to the C<scalarref> parameter. \n\nVia the C<-screen> parameter: \n\n print DADA::Template::Widgets::screen(\n    {\n        -screen => 'somefile.tmpl',\n    }\n );\n\nwhich should be a filename to whatever template you'd like to use. \n\nIn B<H::T>, it maps to the C<filename> parameter. \n\n\nVariables to be used in the template can be passed using the, C<-vars> parameter, which maps to the, \nB<H::T> parameter, C<param>. C<-vars> should hold a reference to a hash: \n\n my $scalar = 'I wanted to say: <!-- tmpl_var var1 -->'; \n print DADA::Template::Widgets::screen(\n    {\n        -data => \\$scalar,\n        -vars   => {var1 => \"This!\"}, \n    }\n );\n\nThis will print:\n\n I wanted to say: This!\n\n\nAnd that's basically screen. Learn HTML::Template and memorize the mappings and you'll be right at home. \n\nA few things to mention: \n\nMany of the Dada Mail modules require you to pass a B<listshortname> some where - C<screen> doesn't,\nand this is by design - it attempts to be separate from any Dada Mail backend or information inside. \n\nThere are hooks in C<screen> to pass variables in the template from the settings and subscriber \nbackend, but they're limited and absolutely optional, but are handy for shortcuts and hey, what isn't \nprogramming but shortcuts?\n\nTo tell C<screen> to use a specific subscriber information, you have two different methods. \n\nThe first is to give the parameters to *which* subscriber to use, via the C<-subscriber_vars_param>: \n\n print DADA::Template::Widgets::screen(\n    {\n    -subscriber_vars_param => \n        {\n            -list  => 'listshortname', \n            -email => 'this@example.com', \n            -type  => 'list',\n        }\n    }\n );\n\nThis will basically have C<screen> call the B<DADA::MailingList::Subscribers::*> C<get_subscriber> \nmethod and pass the parameters set in this hashref. It's best to make sure the subscriber I<exists>, \nor you may run into trouble.\n\nThe subscriber information will be passed to B<HTML::Template> via its C<param> method. The name of \nthe parameters will be appended with, B<subscriber.>, so as not to clobber any other variables you're \npassing, so if you have a field named, \"first_name\", you can use a template var that looks like this: \n\n <!-- tmpl_var subscriber.first_name --> \n\nor: \n\n [subscriber.first_name]\n\nThe following won't work: \n\n <!-- tmpl_var first_name --> \n\n [first_name]\n\nB<Note:> that this dot notation isn't using B<HTML::Template::Plugin::Dot>, but is just a variable \nnaming convention, to give the subscriber information some sort of namespace.\n\n\nThe other magical thing that will happen, is that you'll get a new variable to be used in your template\ncalled, B<subscriber>, which is a array ref of hashrefs with name/value pairs for all your subscriber \nfields. So, this'll allow you to do something like this: \n\n <!-- tmpl_loop subscriber --> \n \n  <!-- tmpl_var name -->: <!-- tmpl_value -->\n \n <!--/tmpl_loop-->\n\nand this will loop over your Profile Fields. \n\nIf you'd like, you can also pass the Profile Fields information yourself - this may be useful if\nyou're in some sort of recursive subroutine, or if you already have the information on hand. You may\ndo so by passing the, C<-subscriber_vars> parameter, I<instead> of the C<-subscriber_vars_param>\nparameter, like so: \n\n use DADA::MailingList::Subscribers; \n my $lh = DADA::MailingList::Subscribers->new({-list => 'listshortname'}); \n \n my $subscriber = $lh->get_subscriber(\n                      {\n                         -email  => 'this@example.com', \n                         -type   => 'list', \n                         -dotted => 1, \n                       }\n                   ); \n \n use DADA::Template::Widgets; \n print DADA::Template::Widgets::screen(\n \n           { \n                -subscriber_vars => $subscriber,\n           }\n       ); \n\nThe, B<subscriber> variable will still be magically created for you. \n\nThe B<-subscriber_vars> parameter is also a way to override what gets printed for the, B<subscriber.> \nvariables, since nothing is done to check the validity of what you're passing. So, keep that in mind - \nall these are shortcuts and syntactic sugar. And we I<like> sugar. \n\n\n\nA similar thing can be used to retrieve the list settings of a particular list: \n\n print DADA::Template::Widgets::screen(\n    {\n    -list_settings_vars_param => \n        {\n            -list  => 'listshortname', \n        }\n    }\n );\n\nor:\n\n use DADA::MailingList::Settings; \n my $ls = DADA::MailingList::Settings->new({-list => 'mylist'}); \n \n my $list_settings = $ls->get(\n                         -dotted => 1, \n                     ); \n \n use DADA::Template::Widgets; \n print DADA::Template::Widgets::screen(\n \n           { \n                -list_settings_vars => $list_settings,\n           }\n       ); \n\nThis will even work, as well in a template: \n\n <!-- tmpl_loop list_settings --> \n \n    <!-- tmpl_var name -->: <!-- tmpl_var value -->\n \n <!-- /tmpl_loop -->\n\nAgain, much of this is syntactical sugar and magic, but a lot of it is to keep organized the various\nsources of your template data. Only at the very final time is all this information folded into itself. \n\nThe precendence for these various variables is: \n\n=over\n\n=item * -list_settings_vars\n\n=item * -subscriber _vars\n\n=item * -vars\n\n=back\n\nWhich means, if you (for whatever weird reason) want to override anything in either the \nB<-list_settings_vars> or B<-subscriber_vars>, you can in B<-vars>\n\n=cut\n\n\n\n\n\nsub screen {  \n\t\n    my ($args) = @_; \n\n    if (! exists($args->{-screen}) && ! exists($args->{-data})){ \n        croak \"no -screen! or -data!\";\n    }\n    \n    if(! exists($args->{-vars})){ \n        $args->{-vars} = {};\n    }\n    \n    # This is for mispelings: \n\tforeach('-list_settings_param', 'list_settings_param', 'list_settings_vars_params', '-list_settings_vars_params', 'list_settings_params', '-list_settings_params'){ \n\t\tif(exists($args->{$_})){ \n\t\t\tcroak \"Incorrect parameter passed to DADA::Template::Widgets:'$_'. Did you mean to pass, '-list_settings_vars_param'? $@\";\n\t\t}\n\t}\n\n\n\n    if(\n        exists($args->{-list_settings_vars})       || \n        exists($args->{-list_settings_vars_param})\n    ){ \n    \n        if( !exists($args->{-list_settings_vars_param}) ){ \n            # Well, nothing. \n            $args->{-list_settings_vars_param} = {}; \n        }\n        else { \n            \n            if(\n                !exists($args->{-list_settings_vars})      &&  # Don't write over something that's already there. \n                 exists($args->{-list_settings_vars_param})    # This is a rehash of the last if() statement, but it's here, for clarity...\n            ){             \n                require DADA::MailingList::Settings; \n                my $ls = DADA::MailingList::Settings->new(\n\t\t\t\t\t\t\t{\n                             \t-list => $args->{-list_settings_vars_param}->{-list},\n                         \t}\n\t\t\t\t\t\t); \n                $args->{-list_settings_vars} = $ls->get(-dotted => 1);                \n                \n                if( !exists($args->{-list_settings_vars_param}->{-i_know_what_im_doing}) ){                     \n                    # this is to get really naughty bits out: \n                    foreach(qw(\n                        password\n                        sasl_smtp_password\n                        pass_auth_id\n                        discussion_pop_password\n                        pop3_username\n                        sasl_smtp_username\n                        discussion_pop_username\n                        cipher_key\n                        \n                    )){ \n                        if(exists($args->{-list_settings_vars}->{'list_settings.' . $_})){ \n                            delete($args->{-list_settings_vars}->{'list_settings.' . $_}); \n                        }  \n                    }\n                }\n            }\n       }\n       \n       if(!exists($args->{-list_settings_vars_param}->{-dot_it})){\n            $args->{-list_settings_vars_param}->{-dot_it} = 0; \n       }\n\n\n       if($args->{-list_settings_vars_param}->{-dot_it} == 1){\n            \n            my $new = {}; \n            \n            while (my ($k, $v) = each(%{$args->{-list_settings_vars}})){\n                if($k =~ m/^list_settings\\./){ \n                    $new->{$k} = $v \n                }\n                else { \n                    $new->{'list_settings.' . $k} = $v; \n                }       \n            }\n            \n            $args->{-list_settings_vars} = $new;         \n       }\n\n\n\n      if(!exists($args->{-vars}->{list_settings})){\n        \n            $args->{-vars}->{list_settings} = [];\n            foreach(keys %{$args->{-list_settings_vars}}){ \n                my $nk = $_; \n                $nk =~ s/list_settings\\.//; \n                push( @{$args->{-vars}->{list_settings}}, {name => $nk, value => $args->{-list_settings_vars}->{$_}});   \n            }\n        }\n    }\n    else { \n        $args->{-list_settings_vars}       = {};\n        $args->{-list_settings_vars_param} = {};\n    }\n    \n    if(\n        exists($args->{-subscriber_vars})       || \n        exists($args->{-subscriber_vars_param})\n    ){ \n        \n        my ($subscriber_vars, $subscriber_loop_vars) = subscriber_vars($args); \n        $args->{-subscriber_vars}    = $subscriber_vars; \n        $args->{-vars}->{subscriber} = $subscriber_loop_vars;  \n        \n    } # exists($args->{-subscriber_vars}) || exists($args->{-subscriber_vars_param})\n    else { \n        $args->{-subscriber_vars}       = {};\n        $args->{-subscriber_vars_param} = {};\n    }\n    \n    \n\t###\n\n\tif($DADA::Config::PROFILE_OPTIONS->{enabled} == 1){ \n\t\tif(\n\t\t     exists($args->{-profile_vars})       || \n\t\t     exists($args->{-profile_vars_param})\n\t\t ){ \n \n\t\t     if( !exists($args->{-profile_vars_param}) ){ \n\t\t         # Well, nothing. \n\t\t         $args->{-profile_vars_param} = {}; \n\t\t     }\n\t\t     else { \n         \n\t\t         if(\n\t\t             !exists($args->{-profile_vars})      &&  # Don't write over something that's already there. \n\t\t              exists($args->{-profile_vars_param})    # This is a rehash of the last if() statement, but it's here, for clarity...\n\t\t         ){  \n\t\t\t\t\tif(exists($args->{-profile_vars_param}->{-email})){ \n\t\t\t\t         require DADA::Profile; \n\t\t\t\t\t\t my $prof = DADA::Profile->new(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t-email => $args->{-profile_vars_param}->{-email},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif($prof->exists){ \n\t\t\t             $args->{-profile_vars} = $prof->get(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t-dotted => 1,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t        \t}\n\t\t\t\t\t\telse { \n\t\t\t\t\t\t\t$args->{-profile_vars} = {};\n\t\t\t\t\t\t}\n\t\t\t         }\n\t\t\t\t}\n\t\t    }\n    \n\n\t\t   if(!exists($args->{-vars}->{profile})){\n     \n\t\t         $args->{-vars}->{profile} = [];\n\t\t         foreach(keys %{$args->{-profile_vars}}){ \n\t\t             my $nk = $_; \n\t\t             $nk =~ s/profile\\.//; \n\t\t             push( @{$args->{-vars}->{profile}}, {name => $nk, value => $args->{-profile_vars}->{$_}});   \n\t\t         }\n\t\t     }\n\t\t }\n\t\t else { \n\t\t     $args->{-profile_vars}       = {};\n\t\t     $args->{-profile_vars_param} = {};\n\t\t }\n\t}\n\telse { \n\t\t$args->{-profile_vars}       = {};\n\t    $args->{-profile_vars_param} = {};\n\t}\n\n\tif(exists($args->{-time})){ \n\t\t$TMP_TIME = $args->{-time};\n\t}\n\n\n    \n     my $template_vars = {}; \n        %$template_vars = (%{$args->{-list_settings_vars}}, %{$args->{-subscriber_vars}}, %{$args->{-profile_vars}}, %{$args->{-vars}}); \n\n\t\n\t\t\t\n\t\t\n    if(exists($args->{-webify_and_santize_these})){ \n\t\tif(exists($args->{-list_settings_vars_param}->{-list})) { \n\t\t\t$template_vars = webify_and_santize(\n\t            {\n\t                -to_sanitize => $args->{-webify_and_santize_these},\n\t                -vars        => $template_vars,\n\t\t\t\t\t-list        => $args->{-list_settings_vars_param}->{-list},\n\n\t            }\n\t        );\n\t\t}\n\t\telse { \n\t\t\t$template_vars = webify_and_santize(\n\t            {\n\t                -to_sanitize => $args->{-webify_and_santize_these},\n\t                -vars        => $template_vars,\n\n\t            }\n\t        );\t\t\t\n\t\t}\n\t\t\n\n    }\n\n\n\n\t\t\n\tif(exists($args->{-webify_these})){ \n\t\tforeach(@{$args->{-webify_these}}){ \n\t    \t$template_vars->{$_} = markdown_to_html(\n\t\t\t\t{\n\t\t\t\t\t-str    => $template_vars->{$_},\n\t\t\t\t\t-method => 'fast', \n\t\t\t\t}\n\t\t\t);\n\t    }\n\t}\n\n\n\t# Which templating engine to use? \n\t#\n\tmy $template; \t\n\tmy $filters = []; \n\n \tif(exists($args->{-screen})){\n\t\t\n\t\tpush(@$filters, \n\t\t\t\t{ \n\t\t\t\t\tsub    => \\&decode_str,\n\t\t\t\t\tformat => 'scalar' \n\t\t\t\t}\n\t\t); \n\t}\n\tpush(@$filters, \n\t    { \n\t\t\tsub => \\&hack_in_tmpl_set_support,\n\t\t\tformat => 'scalar' \n\t\t},\n\t);\n\tpush(@$filters, \n\t    { \n\t\t\tsub => \\&filter_time_piece,\n\t\t\tformat => 'scalar' \n\t\t},\n\t);\n\t \n\t# This is very strange - but filters break images (binary stuff) \n\tif(exists($args->{-img})){ \n\t\tif($args->{-img} == 1){ \n\t\t\t$filters = [];\n\t\t}\n\t}\n\t\n\trequire HTML::Template::MyExpr;\n\t\n\tif(exists($args->{-screen})){ \n\t\t$template = HTML::Template::MyExpr->new(\n\t\t\t%Global_Template_Options, \n\t\t\tfilename => $args->{-screen},\n\t\t\tfilter   => $filters, \n\t\t);\n\t}elsif(exists($args->{-data})){ \n\t\t\n\t\tif($args->{-decode_before} == 1){ \n\t\t\t${$args->{-data}} = safely_decode(${$args->{-data}}, 1); \n\t\t}\n\t\t$template = HTML::Template::MyExpr->new(\n\t\t\t%Global_Template_Options, \n\t\t\tscalarref => $args->{-data},\n\t\t\tfilter    => $filters, \n\t\t);\n\t}else{ \n\t\tcroak \"you MUST pass either a scarlarref in, '-data' or a filename in, '-screen'!\"; \n\t}\n\n\n\tmy %date_params = date_params(); \n\tmy %profile_settings_vars = profile_settings_vars();\n\tmy %final_params = (\n\t\t%Global_Template_Variables,\t\t\n\t\t%profile_settings_vars,\t\t\t\n\t\t%date_params,\n\t\t%$template_vars,\n\t\t%_ht_tmpl_set_params,\n\t);\n\tif(exists($args->{-list})){ \n\t\t$final_params{list} =  $args->{-list};  \n\t}\n\t\n   $template->param(%final_params); \n\t%_ht_tmpl_set_params = (); \n\tif(exists($args->{-return_params})){ \n\t\tif($args->{-return_params} == 1){ \t\t\n\t\t\treturn ($template->output(), {%final_params});\t\n\t\t}\n\t\telse { \t\t\t\t\t \n\t\t\treturn $template->output();\n\t\t}\n\t}\n\telse { \n\t\treturn $template->output();\n\t}\n}\n\n\n\nsub subscriber_vars {\n    \n    my ($args) = @_;\n     \n    if(!exists($args->{-subscriber_vars_param})){ \n        $args->{-subscriber_vars_param} = {}; \n    }\n    else { \n\n        if(\n            !exists($args->{-subscriber_vars})       &&  # Don't write over something that's already there. \n             exists($args->{-subscriber_vars_param})     # This is a rehash of the last if() statement, but it's here, for clarity...\n        ){       \n\n\n      \t\tif(\n    \t\t\texists($args->{-subscriber_vars_param}->{-email}) &&\n    \t\t\texists($args->{-subscriber_vars_param}->{-type})\n    \t\t){ \n\n        \t    require  DADA::MailingList::Subscribers;     \n\n                my $lh = DADA::MailingList::Subscribers->new(\n    \t\t\t\t\t\t{\n                            \t-list => $args->{-subscriber_vars_param}->{-list},\n                         \t}\n    \t\t\t\t\t); \n\n    \t\t\t# What happens if we pass an email address that's not valid? \n    \t\t\teval { \n                    $args->{-subscriber_vars} = $lh->get_subscriber(\n                                                    {\n                                                        -email  => $args->{-subscriber_vars_param}->{-email}, \n                                                        -type   => $args->{-subscriber_vars_param}->{-type},\n                                                        -dotted => 1, \n                                                    }\n                                                ); \n    \t\t\t};\n    \t\t\tif($@){ \n    \t\t\t\t$args->{-subscriber_vars} = {};\n    \t\t\t\tcarp $@; \n    \t\t\t}\n            }\n\n        } #if(!exists($args->{-subscriber_vars})){ \n\n    \t\tif(exists($args->{-subscriber_vars_param}->{-use_fallback_vars})){ \n    \t\t\tif($args->{-subscriber_vars_param}->{-use_fallback_vars} == 1){ \n\n    \t\t\t\trequire DADA::MailingList::Subscribers;\n    \t\t\t  \tmy $lh = DADA::MailingList::Subscribers->new(\n    \t\t\t\t\t\t\t{\n                                \t-list => $args->{-subscriber_vars_param}->{-list},\n                             \t}\n    \t\t\t\t\t\t);\n\n    \t\t\t\t\t\tmy $field_attrs = $lh->get_all_field_attributes; \n    \t\t\t\t\t\tmy $fallback_vars = {}; \n    \t\t\t\t\t\tforeach(keys %$field_attrs){ \n    \t\t\t\t\t\t\t$fallback_vars->{'subscriber.' . $_} = $field_attrs->{$_}->{fallback_value};\n    \t\t\t\t\t\t}\n    \t\t\t\t# This is sort of an odd placement for this, but I'm not sure \n    \t\t\t\t# Where I want this yet...  (perhaps $lh->get_fallback_values ?)\n\n    \t\t\t\t\tif(!exists($args->{-subscriber_vars}->{'subscriber.email'})){ \n    \t\t\t\t\t\t$fallback_vars->{'subscriber.email'} = 'example@example.com'; \n    \t\t\t\t\t}\n    \t\t\t\t\tmy ($name, $domain) = split('@', $fallback_vars->{'subscriber.email'}, 2); \n    \t\t\t\t\t$fallback_vars->{'subscriber.email_name'}   = $name; \n    \t\t\t\t\t$fallback_vars->{'subscriber.email_domain'} = $domain; \n    \t\t\t\t### /\n\n    \t\t\t\tforeach(keys %$fallback_vars){ \n    \t\t\t\t\tif(! exists($args->{-subscriber_vars}->{$_})){ \t\n    \t\t\t\t\t\t#warn \"I'm putting in a fallback field $_ that equals: \" . $fallback_vars->{$_}; \n    \t\t\t\t\t\t$args->{-subscriber_vars}->{$_} = $fallback_vars->{$_};\n    \t\t\t\t\t}\t\n    \t\t\t\t\telse  { \n    \t\t\t\t\t\t#warn \"no need for the fallback var! We're good with: \" . $args->{-subscriber_vars}->{$_}; \n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t}\t\n\n    \t\t}#if(exists($args->{-subscriber_vars_param}->{-use_fallback_vars}){\n\n\n    \tif(exists($args->{-subscriber_vars_param}->{-use_fallback_vars})){ \n    \t\tif($args->{-subscriber_vars_param}->{-use_fallback_vars} == 1){ \n    \t\t\t# DEV: This is a really really REALLY good place to put an optimization - \n    \t\t\t# No caching is currently done, either by this module, or another. \n    \t\t\t# That's no good! \n    \t\t\t# At the very least, we could put caching in \n    \t\t\t# DADA::ProfileFieldsManager and just keep that around... \n    \t\t\t# Ugh. \n    \t\t\t# \n    \t\t\t# Updated: At least in the mass mailing stuff, -use_fallback_vars param is not called, \n    \t\t\t# The fallback field stuff is done with a cached copy of DADA::ProfileFieldsManager\n    \t\t\t# That's a good thing.\n\n    \t\t\trequire DADA::MailingList::Subscribers;\n    \t\t  \tmy $lh = DADA::MailingList::Subscribers->new(\n    \t\t\t\t\t\t{\n                            \t-list => $args->{-subscriber_vars_param}->{-list},\n                         \t}\n    \t\t\t\t\t);\n\n    \t\t\t\t\tmy $fallback_vars = $lh->get_all_field_attributes; \n\n    \t\t\t# This is sort of an odd placement for this, but I'm not sure \n    \t\t\t# Where I want this yet...  (perhaps $lh->get_fallback_values ?)\n    \t\t\t\t$fallback_vars->{'subscriber.email'}        = 'example@example.com'; \n    \t\t\t    $fallback_vars->{'subscriber.email_name'}   = 'example'; \n    \t\t\t    $fallback_vars->{'subscriber.email_domain'} = 'example.com';    \n    \t\t\t### /\n\n    \t\t\tforeach(keys %$fallback_vars){ \n    \t\t\t\tif(! exists($args->{-subscriber_vars}->{$_})){ \n    \t\t\t\t\t$args->{-subscriber_vars}->{$_} = $fallback_vars->{$_};\n    \t\t\t\t}\t\n    \t\t\t}\n    \t\t}\t\n\n    \t}#if(exists($args->{-subscriber_vars_param}->{-use_fallback_vars}){\n\n    } #if(!exists($args->{-subscriber_vars_param})){ \n\n\n    if( !exists($args->{-vars}->{subscriber}) ){\n\n        $args->{-vars}->{subscriber} = [];\n\n        if(exists($args->{-subscriber_vars_param}->{-in_order})){ \n            foreach(sort %{$args->{-subscriber_vars}}){ \n                my $nk = $_; \n                $nk =~ s/subscriber\\.//; \n                push( @{$args->{-vars}->{subscriber}}, {name => $nk, value => $args->{-subscriber_vars}->{$_}});\n            }\n        }\n        else { \n            foreach(keys %{$args->{-subscriber_vars}}){ \n                my $nk = $_; \n                   $nk =~ s/subscriber\\.//; \n                push( @{$args->{-vars}->{subscriber}}, {name => $nk, value => $args->{-subscriber_vars}->{$_}});\n            }\n        } #if(exists($args->{-subscriber_vars_param}->{-in_order})){ \n    } #if( !exists($args->{-vars}->{subscriber}) ){\n\n    return ($args->{-subscriber_vars}, $args->{-vars}->{subscriber}); \n\n}\n\nsub date_params { \n\t\n\tmy $time = shift || $TMP_TIME || time;\n\t\n\tmy %params = ();\n\t \n\t\n\t# Anything more than this, and I should probably use \n\t# DateTime or something. \n\t# Don't want to for performance reasons\n\t# OR, use Time::Piece and probably remove some bugs I've created. \n\t#\n\t# 0 1 2 3 4 5 6 7 8\n\t# $mday = '17'; (Date)\n\t# $wday = '1' (Monday)\n\t# $yday =  289the day of the year (ie: in 365 days, this is the nth day\")\n    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =\n    \tlocaltime($time);\t\n\n    my $months = [\n\tqw(\n        January  \n        February \n        March    \n        April    \n        May      \n        June     \n        July     \n        August   \n        September\n        October  \n        November \n        December \n\t)\n    ];           \n\n\n    my $abbr_months = [\n\tqw(\n        Jan\n        Feb\n        Mar    \n        Apr    \n        May      \n        Jun     \n        Jul     \n        Aug   \n        Sep\n        Oct \n        Nov\n        Dec \n\t)\n    ];\n\n\t\n\tmy $days = [\n\tqw( \n\t\tSunday   \n\t\tMonday   \n\t\tTuesday  \n\t\tWednesday\n\t\tThursday \n\t\tFriday   \n\t\tSaturday    \n\t)\n\t];\n\n\tmy $abbr_days = [\n\tqw( \n\t\tSun\n\t\tMon   \n\t\tTue  \n\t\tWed\n\t\tThu \n\t\tFri   \n\t\tSat    \n\t)\n\t];\n\t\n\t\n\tmy $mail_day_values = {\n\t\t1  => '1st', \n\t\t2  => '2nd', \n\t\t3  => '3rd', \n\t\t4  => '4th', \n\t\t5  => '5th',\n\t\t6  => '6th', \n\t\t7  => '7th', \n\t\t8  => '8th', \n\t\t9  => '9th', \n\t\t10 => '10th', \n\t\t11 => '11th',\n\t\t12 => '12th', \n\t\t13 => '13th', \n\t\t14 => '14th', \n\t\t15 => '15th', \n\t\t16 => '16th', \n\t\t17 => '17th', \n\t\t18 => '18th', \n\t\t19 => '19th', \n\t\t20 => '20th', \n\t\t21 => '21st', \n\t\t22 => '22nd', \n\t\t23 => '23rd', \n\t\t24 => '24th', \n\t\t25 => '25th', \n\t\t26 => '26th', \n\t\t27 => '27th', \n\t\t28 => '28th', \n\t\t29 => '29th', \n\t\t30 => '30th', \n\t\t31 => '31st',\n\t};\n\t\n    $params{'date.time'}                 = $time;\n    $params{'date.localtime'}            = scalar( localtime($time) );\n    $params{'date'}                      = $params{'date.localtime'};\n    $params{'date.month'}                = $mon + 1;\n    $params{'date.named_month'}          = $months->[$mon];\n    $params{'date.padded_month'}         = sprintf( \"%02d\", $mon + 1 );\n    $params{'date.abbr_named_month'}     = $abbr_months->[$mon];\n    $params{'date.day'}                  = $mday;\n    $params{'date.day_of_the_week'}      = $days->[$wday];\n    $params{'date.padded_day'}           = sprintf( \"%02d\", $mday );\n    $params{'date.abbr_day_of_the_week'} = $abbr_days->[$wday];\n    $params{'date.nth_day'}              = $mail_day_values->{$mday};\n    $params{'date.year'}                 = $year += 1900;\n    $params{'date.abbr_year'}            = sprintf( \"%02d\", $year % 100 );\n\t$params{'date.24_time'}              = sprintf(\"%02d:%02d:%02d\", $hour, $min, $sec);\n\t$params{'date.timezone'}             = strftime(\"%Z\", localtime()); \n\t\n\treturn %params;\n\t\n}\n\n\nsub profile_settings_vars { \n\t\n\tmy %vars = (\n\t\t'profile_settings.enabled' => $DADA::Config::PROFILE_OPTIONS->{enabled},\n\t\t\n\t\t# backwards compat.: \n\t\tPROFILE_ENABLED            => $DADA::Config::PROFILE_OPTIONS->{enabled},\n\t\t# are we really going to use these?\n\t\t#'profile.email'                            => $DADA::Config::PROFILE_OPTIONS->{profile_email},\n\t\t#'profile.enable_captcha'                   => $DADA::Config::PROFILE_OPTIONS->{enable_captcha},\n\t\t\n\t\t\n\t); \n\tfor(qw(\n\t\t register                  \n\t\t password_reset            \n\t\t profile_fields            \n\t\t mailing_list_subscriptions\n\t\t protected_directories     \n\t\t update_email_address      \n\t\t change_password           \n\t\t delete_profile            \n\t)){ \n\t\tif(exists($DADA::Config::PROFILE_OPTIONS->{features}->{$_})){ \n\t\t\t$vars{'profile_settings.' . $_} = $DADA::Config::PROFILE_OPTIONS->{features}->{$_}; \n\t\t}\n\t}\n\t\n\treturn %vars;\n}\n\n\n=pod\n\n=head2 wrap_screen\n\n\tmy $scrn = wrap_screen(\n\t\t{ \n\t\t\t-with => 'list', # or, 'admin', \n\t\t\t-screen => 'some_screen.tmpl', # or, \"-data => \\$some_data, \n\t\t\t# ... other options\n\t\t}\n\t); \n\nC<wrap_screen> allows you to wrap either one of the two templates (currently) \nthat Dada Mail uses to wrap other template in: C<list_template.tmpl> and\nC<admin_template.tmpl>. \n\nIt takes the same options as, C<screen> and adds a few of its own: \n\nC<-with> is required and should be set to either, C<list>, or C<admin>, depending on \nwhether you want to wrap the template in either the list or admin template. \n\nC<-wrapper_params> can also be passed and the value of its parameters (confusingly)\nwill be different, depending on if you're using C<list> or, C<admin> for, C<-with>\n\nFor, C<list>:\n\n=over\n\n=item * any parameter you would usually send to DADA::Template::HTML::list_template()\n\nExample: \n\n\tmy $scrn = DADA::Template::Widgets::wrap_screen(\n\t\t{\n\t\t\t-screen => 'preview_template.tmpl',\n\t\t\t-with   => 'list', \n\t\t\t-wrapper_params => { \n\t\t\t\t-data => \\$template_info, # This is the actual template we'll be using! \n\t\t\t},\n\t\t}\n\t);\n\n=back\n\nFor, C<admin> \n\n=over\n\n=item * any parameter you would usually send to, DADA::Template::HTML::admin_template\n\n\tmy $scrn .= DADA::Template::Widgets::wrap_screen(\n\t\t{\n\t\t\t-screen => 'sending_monitor_index_screen.tmpl',\n            -with   => 'admin', \n\t\t\t-wrapper_params => { \n\t\t\t\t-Root_Login => 1,\n\t\t\t\t-List       => 'my_list',  \n\t\t\t},\n\t\t\t# ... \n\t\t}\n\t);\n\n=back\n\n=cut \n\n\nsub wrap_screen { \n\t\t\n\tmy ($args) = @_; \n\n\tif(!exists($args->{-with})){ \n\t\tcroak \"you must pass the, '-with' parameter\"; \n\t}\n\telse { \n\t\tif($args->{-with} !~ m/^(list|admin)$/){ \n\t\t\tcroak \"'-with' parameter must be either, 'list' or, 'admin'\";\n\t\t}\n\t}\n\tmy $with = $args->{-with}; \n\t# I'd rather not have this passed to, screen(); \n\tdelete $args->{-with}; \n\t\n\t# I need params from the first template passed. \n\t$args->{-return_params} = 1;\n\tmy ($tmpl, $params) = screen($args);\n\n\t# \"content\" is passed to the wrapper template\n\tmy $vars = { \n\t\tcontent => $tmpl, \n\t};\n\tfor(qw(title show_profile_widget load_wysiwyg_editor load_google_viz load_colorbox load_captcha_js load_jquery_validate load_datetimepicker SUPPORT_FILES_URL)){ \n\t\tif(exists($params->{$_})){ \n\t\t\t# variables within variables... \n\t\t\t$vars->{$_} = $params->{$_}; \n\t\t\tif($vars->{$_} =~ m/\\<\\!\\-- tmpl_/){\n\t\t\t\t$vars->{$_} = screen({-data => \\$vars->{$_}, -vars => $params}); \n\t\t\t}\n\t\t}\n\t}\t \n\t\n\tif($with eq 'list'){ \n\t\n\t\t# list_template is the wrapper template - it calls, screen()\n\t\t# This will aggravate you, as I'm aggravated by it - there's 3 ways to send the listshortname to screen()\n\t\t# And list_template() here has one way, so we have to figure out where, \"list\" is, and use it. \n\t\t# Here we go: \n\t\tmy $list_param = undef; \n\t\tif(exists($args->{-list})){ \n\t\t\t$list_param =  $args->{-list}; \n\t\t}\n\t\telsif(exists($args->{-list_settings_vars})){\n\t\t\tif(exists($args->{-list_settings_vars}->{list})){ \n\t\t\t\t$list_param =  $args->{-list_settings_vars}->{list}; \n\t\t\t}\n\t\t\telsif(exists($args->{-list_settings_vars}->{'list_settings.list'})){ \n\t\t\t\t$list_param =  $args->{-list_settings_vars}->{'list_settings.list'}; \n\t\t\t}\t\n\t\t}\n\t\telsif(exists($args->{-list_settings_vars_param}->{-list})){\n\t\t\t$list_param = $args->{-list_settings_vars_param}->{-list}; \n\t\t}\n\t\t\n\t\trequire DADA::Template::HTML; \t\n\t\tmy $template = DADA::Template::HTML::list_template(\n\t\t\t%{$args->{-wrapper_params}}, # This is currently, \"blank\" - where is put in here - header_params? \n\t\t\t-vars => $vars,\t\t\t\t \n\t\t\t-Part => 'full', \n\t\t\t-List => $list_param, \n\t\t\t); \t\t\t\n\t\treturn $template; \n\t}\n\telsif($with eq 'admin'){ \n\t\tmy %wysiwyg_vars = ();\n\t\tif(exists($args->{-wrapper_params}->{-List})){ \n\t\t\t%wysiwyg_vars = DADA::Template::Widgets::make_wysiwyg_vars($args->{-wrapper_params}->{-List});  \n\t\t\t$vars = {(%$vars, %wysiwyg_vars)};\n\t\t}\n\t\trequire DADA::Template::HTML; \t\n\t\tmy $template = DADA::Template::HTML::admin_template(\n\t\t\t%{$args->{-wrapper_params}}, \n\t\t\t-vars => $vars,\t\t\t\t \t\t\t\t\t\t \n\t\t\t-Part => 'full', \n\t\t\t); \n\t\treturn $template;\n\t}\n\telse { \n\t\t# I think it may be impossible to get here. \n\t\tdie \"only 'list' and 'admin' wrapping is currently supported.\"; \n\t}\n}\n\nsub validate_screen { \n\tmy ($args) = @_; \n\t\n\t# use Data::Dumper; \n\t# carp '$args' . Dumper($args); \n\t\n\tmy $r      = 1; \n\tmy $errors = undef; \n\tmy $scrn   = undef; \n\ttry { \n\t\t$scrn = screen({%$args}); \n\t} catch {\n\t\t# warn 'validate_screen FAILED!';\n\t\t# warn $_; \n\t\t$r      = 0; \n\t\t$errors = $_; \n\t};\n\t# warn 'validate_screen PASSED!';\n\treturn ($r, $errors); \n}\n\nsub decode_str { \n\tmy $ref = shift;\n \t   ${$ref} = safely_decode(${$ref}); \n}\n\nsub not_defined { \n    my $ref = shift;\n#    use Data::Dumper; \n#    warn Dumper($ref); \n    \n    if(ref($ref) eq 'ARRAY'){\n        return 1 if defined($ref->[0]); \n    }\n    else { \n        return 1 if ! defined($ref); \n    }\n    return 0;\n}\nsub hack_in_tmpl_set_support {\n    my $text_ref = shift;\n\n    my $match = qr/\\<\\!\\-\\- tmpl_set name\\=\\\"(.*?)\\\" value\\=\\\"(.*?)\\\" \\-\\-\\>/;\n\t\t\t\t\t#\t<!-- set name=\"one\" value=\"two\" -->\n    my @taglist = $$text_ref =~ m/$match/gi;\n    while (@taglist) {\n        my ( $t, $v ) = ( shift @taglist, shift @taglist );\t\t\n\t\t$_ht_tmpl_set_params{$t} = $v;\n    }\n\n    $$text_ref =~ s/$match//gi;\n}\n\nsub filter_time_piece {\n\t\n    my $text_ref = shift;\n\tmy $time     = $TMP_TIME || time; \n\t\n    my $match = qr/\\<\\!\\-\\- tmpl_strftime (.*?) \\-\\-\\>/;\n    \n\tmy @taglist = (); \n\t@taglist = $$text_ref =~ m/$match/gi;\n    \n\tmy $can_use_time_piece = 1;\n\tmy $can_use_posix      = 1; ; \n\tmy $t                  = undef; \n\tif(exists($taglist[0])){  \n\t\t\n\t\ttry { \n\t\t\trequire Time::Piece; \n\t\t\t#$t = Time::Piece->new;\n\t\t     $t = Time::Piece::localtime($time);\n\t\t} catch {\n\t\t\t$can_use_time_piece = 0; \n\t\t\tcarp \"Time::Piece doesn't work!? $_\"; \n\t\t};\n\t\t\n\t\tif($can_use_time_piece == 0){ \n\t\t\t# I mean, who knows. \n\t\t\ttry { \n\t\t\t\trequire POSIX; \n\t\t\t\tPOSIX::->import( 'strftime' );\n\t\t\t} catch {\n\t\t\t\t$can_use_posix = 0; \n\t\t\t};\n\t\t}\n\t\tif($can_use_time_piece == 0 && $can_use_posix == 0){ \n\t\t\tcroak '<!-- tmpl_var tmpl_strftime [...] --> tags unsupported! Install Time::Piece!'; \n\t\t}\n\t\t\n\t\twhile (@taglist) {\n\t\t\t # I have no understanding of this, rather than, my $format(@taglist) { } \n\t\t\tmy $format = shift @taglist;\n\t\t\t\n\t\t\tmy $formatted_time = undef; \n\t\t\t\n\t\t\tif($can_use_time_piece) { \n\t\t\t\t$formatted_time = $t->strftime($format);\n\t\t\t}\n\t\t\telse { \n\t\t\t\tmy ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($time);\n\t\t\t\t$formatted_time = POSIX::strftime($format, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst );\n\t\t\t}\n\t\t\tmy $formatted_match = quotemeta(\"<!-- tmpl_strftime $format -->\");\n\t\t\t$$text_ref =~ s/$formatted_match/$formatted_time/gi;\n\t    }\n\n\t}\n   \n}\n\n\nsub webify_and_santize { \n\n    my ($args) = @_; \n    \n    if(!exists($args->{-vars})){ \n        die \"need to pass, -vars\"; \n    }\n    \n    if(!exists($args->{-to_sanitize})){ \n        die \"need to pass, -to_sanitize\"; \n    }\n    \n\tif(! exists($args->{-list})){ \n\t\t$args->{-list} = undef; \n\t}\n    foreach(@{$args->{-to_sanitize}}){ \n    \n        \n\t\t\n\t\t# Markdown seems to wrap all strings in <p> tags\n\t\tif(\n\t\t\t   $_ eq 'list_settings.discussion_pop_email'\n\t\t\t|| $_ eq 'discussion_pop_email'\n\t\t\t|| $_ eq 'list_settings.list_owner_email'\t\t\t\n\t\t\t|| $_ eq 'list_settings.list_owner_email'\t\t\t\n\t\t\t|| $_ eq 'list_owner_email'\t\t\t\n\t\t\t|| $_ eq 'list_settings.admin_email'\t\t\t\n\t\t\t|| $_ eq 'admin_email'\t\t\t\n\t\t){\n\t\t\tplaintext_to_html({-str => $args->{-vars}->{$_}});\n\t\t}\n\t\telse { \n\t        $args->{-vars}->{$_} = markdown_to_html({-str =>$args->{-vars}->{$_}});\n\t\t}\n\t\t\n        $args->{-vars}->{$_} = _email_protect(\n\t\t\t{\n\t\t\t\t-string => $args->{-vars}->{$_},\n\t\t\t\t-list   => $args->{-list}, #?\n\t\t\t}\n\t\t);\n\t\t\n          \n        \n    }\n    \n    return $args->{-vars};\n    \n}\n\n\n\n\nsub _email_protect { \n    \n\tmy ($args) = @_; \n    my $str  = $args->{-string};\n \tmy $list = undef; \n\tmy $ls   = undef; \n    if(exists($args->{-list}) && $args->{-list} ne undef){ \n\t\t$list = $args->{-list};\n\t\trequire DADA::MailingList::Settings; \n\t\t$ls = DADA::MailingList::Settings->new({-list => $list});\n\t}\n    \n\n    # strange module - API based on File::Find I guess.\n\trequire Email::Find;\n \tmy $found_addresses = []; \n   \n\tmy $finder = Email::Find->new(sub {\n\t\t\t\t\t\t\t\t\tmy($email, $orig_email) = @_;\n\t\t\t\t\t\t\t\t\tpush(@$found_addresses, $orig_email); \n\t\t\t\t\t\t\t\t\treturn $orig_email; \n\t\t\t\t\t\t\t\t});\n\t$finder->find(\\$str); \n\t\n\tforeach my $fa (@$found_addresses){ \t\n\t\tif($list){ \t\t\t\n\t\t\tif($ls->param('archive_protect_email') eq 'spam_me_not'){ \t\t\n\t            my $pe = spam_me_not_encode($fa);\n\t            my $le = quotemeta($fa); \n\t            $str =~ s/$le/$pe/g;   \n\t        }\n\t\t}\n\t\telse { \n\t\t\t my $pe = spam_me_not_encode($fa);\n\t         my $le = quotemeta($fa); \n\t         $str =~ s/$le/$pe/g;\n\t\t}\n\t}\n\n    return $str; \n }\n\n\n\n\nsub subscription_form { \n\n   \n    my ($args) = @_; \n\t\n    my $list = undef; \n\tif(exists($args->{-list})){ \n\t\t$list = $args->{-list};\n\t}\n    \n    if(! exists($args->{-form_type})){ \n\t\t$args->{-form_type} = 'full';\n\t}\n\n    if(! exists($args->{-script_url})){ \n        $args->{-script_url} = $DADA::Config::PROGRAM_URL; \n    }\n    \n        \n    if(! exists($args->{-multiple_lists})){ \n        $args->{-multiple_lists} = 0; \n    }\n\n\tif(! exists($args->{-show_fields})){ \n\t\t$args->{-show_fields} = 1; \n\t}\n\t\n\tif(! exists($args->{-magic_form})){\n    \t$args->{-magic_form} = 1; \n\t}\n\n\tif(! exists($args->{-show_fieldset})) { \n\t\t$args->{-show_fieldset} = 1;\n\t}\n\t\n\tif(! exists($args->{-subscription_form_id})) { \n\t\t$args->{-subscription_form_id} = undef;\n\t}\n\t\n\tif(! exists($args->{-add_recaptcha_js})) { \n\t\t$args->{-add_recaptcha_js} = 0;\n\t}\n\t\n\tif(! exists($args->{-form_target})) { \n\t\t$args->{-form_target} = '_self';\n\t}\t\n\n    my @available_lists = available_lists(-Dont_Die => 1); \n    if(! $available_lists[0]){ \n        return ''; \n    }\n    \n    \n    require DADA::ProfileFieldsManager; \n    my $pfm               = DADA::ProfileFieldsManager->new; \n\tmy $subscriber_fields = $pfm->fields(\n\t\t{\n\t\t\t-show_hidden_fields => 0,\n\t\t}\n\t);\n\t\t\n\tmy $field_attrs       = $pfm->get_all_field_attributes;\n\t\n\tmy $named_subscriber_fields = [];\n\n\tforeach(@$subscriber_fields){ \n\t    push(\n\t\t\t@$named_subscriber_fields, \n\t\t\t\t{\n\t\t\t\t\tname        => $_, \n\t\t\t\t\tpretty_name => $field_attrs->{$_}->{label},\n\t\t\t\t\tlabel       => $field_attrs->{$_}->{label},\n\t\t\t\t\trequired    => $field_attrs->{$_}->{required},\n\t\t\t\t}\n\t\t\t)\n\t}\n\t\n\tif(! exists ($args->{-ignore_cgi}) && $args->{-ignore_cgi} != 1){ \n           foreach(qw(email list )){ \n            if(! exists ( $args->{'-' . $_} ) && defined($q->param($_))){ \n                $args->{'-' . $_} = xss_filter($q->param($_));\n            }\n        }\n        \n        my $i = 0; \n        foreach my $sf(@$subscriber_fields){ \n            if(defined($q->param($sf))){ \n                $named_subscriber_fields->[$i]->{given_value} = xss_filter($q->param($sf));\n            }\n            $i++;\n        }\n        undef($i);\n\n\t\t$args->{-profile_logged_in} = 0; \n\n\t\tif (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1)\n\t    {\n\t\t\t# ... \n\t\t}\t\t\n    }\n\n    if(\n\t\t$list && \n\t\tcheck_if_list_exists( -List=> $list, -Dont_Die  => 1) > 0\n\t){ \n\t\n\t\trequire DADA::MailingList::Settings; \n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n  \n\t\t# This is so that we don't show the entire form, if we don't have to:\n\t\tif(\n\t\t\t(\n\t\t\t\t$ls->param('invite_only_list') == 1\n\t\t\t&&  $ls->param('closed_list') == 1\n\t\t\t) \n\t\t){ \n\t\t\tif($ls->param('invites_show_profile_fields_in_subscription_form') == 1){ \n\t\t\t\t$args->{-show_fields} = 1;\n\t\t\t}\n\t\t\telse { \n\t\t\t\t$args->{-show_fields} = 0;\n\t\t\t} \n\t\t}\n\t\t\n\t\tmy $tmpl_name = 'subscription_form_widget.tmpl'; \n\t\tif($args->{-form_type} eq 'minimal'){ \n \t\t\t$tmpl_name = 'minimal_subscription_form.tmpl'; \n\t\t}\n\t\telsif($args->{-form_type} eq 'form_fields_example'){ \n \t\t\t$tmpl_name = 'subscription_form_fields_example.tmpl'; \n\t\t}\n\t\t\n\t\trequire DADA::MailingList::Consents; \n\t\tmy $con           = DADA::MailingList::Consents->new; \n\t\tmy $list_consents = $con->give_me_all_consents($ls); \n\t\t\t\t\n        return screen({\n            -screen => $tmpl_name, \n            -vars   => {\n\t\t\t\t\t\t\tform_target              => $args->{-form_target},  \n\t\t\t\t\t\t\tcan_use_JSON             => scalar DADA::App::Guts::can_use_JSON(), \n                            single_list              => 1, \n                            subscriber_fields        => $named_subscriber_fields,\n                            list                     => $list, \n                            email                    => $args->{-email},\n                            script_url               => $args->{-script_url}, \n\t\t\t\t\t\t\tshow_fields              => $args->{-show_fields}, \n\t\t\t\t\t\t\tprofile_logged_in        => $args->{-profile_logged_in}, \n\t\t\t\t\t\t\tsubscription_form_id     => $args->{-subscription_form_id}, \n\t\t\t\t\t\t\tshow_fieldset            => $args->{-show_fieldset}, \n\t\t\t\t\t\t\tadd_recaptcha_js         => $args->{-add_recaptcha_js}, \n\t\t\t\t\t\t\tlist_consents            => $list_consents, \t\t\t\t\t\n\t\t\t\t\t\t\t\n                        },\n\t\t\t\t\t\t-list_settings_vars_param => {\n\t\t\t\t\t\t\t-list    => $list,\n\t\t\t\t\t\t\t-dot_it => 1,\n\t\t\t\t\t\t},\n                    });  \n  \n    }\n    else { \n\t\t\n\t\tmy $enable_captcha_on_initial_subscribe_form = 0; \n\t\t\n\t\t# Eek, this is a hack, kinda: \n\t\tif($args->{-multiple_lists} == 1){ \n\t\t\trequire DADA::MailingList::Settings; \n\t\t\tmy @lists = available_lists(-Dont_Die => 1); \n\t\t\tforeach my $mlist(@lists){ \n\t\t\t\tmy $mls = DADA::MailingList::Settings->new({-list => $mlist}); \n\t\t\t\tif($mls->param('enable_captcha_on_initial_subscribe_form') == 1){\n\t\t\t\t\t $enable_captcha_on_initial_subscribe_form = 1; \n\t\t\t\t}\n\t\t\t\tlast; \n\t\t\t}\n\t\t}\n\t\t\n\t\treturn screen({\n            -screen => 'subscription_form_widget.tmpl', \n            -vars   => {\n\t\t\t\tform_target              => $args->{-form_target},  \n\t            single_list              => 0, \n\t            subscriber_fields        => $named_subscriber_fields,\n\t            list                     => $list, \n\t            email                    => $args->{-email},\n\t            list_popup_menu          => list_popup_menu(-disable_invite_only => 1),\n\t            list_checkbox_menu       => list_popup_menu(-as_checkboxes => 1), \n\t            multiple_lists           => $args->{-multiple_lists}, \n\t            script_url               => $args->{-script_url}, \n\t\t\t\tshow_fields              => $args->{-show_fields}, \n\t\t\t\tprofile_logged_in        => $args->{-profile_logged_in}, \n\t\t\t\tsubscription_form_id     => $args->{-subscription_form_id}, \n\t\t\t\tshow_fieldset            => $args->{-show_fieldset}, \n\t\t\t\tadd_recaptcha_js         => $args->{-add_recaptcha_js}, \n\t\t\t\t'list_settings.enable_captcha_on_initial_subscribe_form' \n\t\t\t\t\t=> $enable_captcha_on_initial_subscribe_form, \n\t\t\t}\n    \t});      \n    }\n\n}\n\n\n\nsub unsubscription_form { \n\t\n\t\n    my ($args) = @_; \n    \n\tif(! exists($args->{-list})) { \n\t\tcroak \"you MUST pass a, '-list'\"; \n\t}\n\tmy $list_exists = check_if_list_exists( -List=> $args->{-list}, -Dont_Die  => 1) || 0;\n\t\n\tif($list_exists == 0){ \n\t\tcroak \"list,  '\" .  $args->{-list} . \"' does not exist.\"; \n\n\t}\n\telse { \n\t\n\t\treturn screen({\n\t        -screen => 'unsubscription_form_widget.tmpl', \n\t        -vars   => {\n                       \n\t                        list                     => $args->{-list}, \n\t                        email                    => $args->{-email},\n\t                    },\n\t\t\t\t\t\t-list_settings_vars_param => {\n\t\t\t\t\t\t\t-list    => $args->{-list},\n\t\t\t\t\t\t\t-dot_it => 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t\n\t                }\n\t\t);  \n\t}\n}\n\n\n\n\nsub file_path { \n\n    my $fn   = shift; \n    if(!$fn){ \n        croak \"You did not pass a filename as the sole argument!!!\"; \n    }\n    my $path = undef; \n    \n    foreach my $path(@{$Global_Template_Options{path}}){ \n        if(-e $path . '/' . $fn){ \n            return $path . '/' . $fn;\n        }\n    }\n}\n\n\n\nsub _raw_screen { \n\t\n\tmy ($args) = @_; \n\t\n\tmy $screen = $args->{-screen}; \n\t\n\t\n\tmy $path = file_path($screen);\n\t\n\tif($path){ \n\t\tif($args->{-encoding} == 0) {  \n\t\t\treturn _slurp_raw($path);\n\t\t}\n\t\telse { \n\t\t\treturn _slurp($path);\n\t\t\t\n\t\t}\n\t}\n\telse { \n\t\tcarp \"cannot find, $screen to open!\"; \n\t\treturn undef; \n\t}\n}\n\n\n\nsub _slurp { \n\t\n\t\tmy ($file) = @_;\n\n        local($/) = wantarray ? $/ : undef;\n        local(*F);\n        my $r;\n        my (@r);\n\n\t\t$file = make_safer($file); \n        open(F, '<:encoding(' . $DADA::Config::HTML_CHARSET .')', $file) || die \"open $file: $!\";\n        @r = <F>;\n        close(F) || die \"close $file: $!\";\n\n        return $r[0] unless wantarray;\n        return @r;\n\n}\n\nsub _slurp_raw { \n\tmy ($file) = @_;\n\n    local($/) = wantarray ? $/ : undef;\n    local(*F);\n    my $r;\n    my (@r);\n\n\t$file = make_safer($file); \n    open(F, '<', $file) || die \"open $file: $!\";\n    @r = <F>;\n    close(F) || die \"close $file: $!\";\n\n    return $r[0] unless wantarray;\n    return @r;\n}\n\n\n\n# This is a bad idea - better to just OO this module... \nsub lame_init(){ \n    if(!defined($q)){ \n        require CGI;\n        $q = CGI->new();\n    }\n}\n\n\n1;\n\n\n\n\n=pod\n\n=head1 COPYRIGHT\n\nCopyright (c) 1999 - 2020 Justin Simoni \nhttps://justinsimoni.com \nAll rights reserved. \n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n=cut\n", "<!-- begin profile_home.tmpl --> \n\n<!-- tmpl_set name=\"title\" value=\"Profile\" --> \n\n<div id=\"profile_home\"></div>\n\n\n\n\n<script type=\"text/javascript\">\n\tfunction confirm_profile_removal(form_name) {\n        \n    \n\t    var confirm_msg =  \"Are you sure you want to \";\n\t        confirm_msg += \" remove this profile?\";\n\t        confirm_msg += \" This profile removal cannot be undone.\";\n\t    if(!confirm(confirm_msg)){\n\t        alert('Profile not removed.');\n\t        return false;\n\t    }    \n\t}\n</script> \n\n\n\n\n<!-- tmpl_if welcome --> \n    <div class=\"alert-box info radius\">\n\t     Welcome to your Profile. From here, you may subscribe/unsubscribe \n\t     to the available mailing lists, as well as update your subscription \n\t    information.\n\t</div> \n<!-- /tmpl_if --> \n<!-- tmpl_if edit --> \n    <div class=\"alert-box info radius\">\n       Changes have been saved.\n    </div>\n<!-- /tmpl_if --> \n\n\n<!-- tmpl_if errors --> \n    <div class=\"alert-box warning radius\">\n    <p> \n        <strong>There was an error with your last request:</strong>\n    </p> \n\n    <!-- tmpl_if errors_change_password --> \n        <p>Your Password:</p>\n        <ul> \n            <li>\n                Make sure that you re-typed your password correctly. \n        </li> \n        </ul> \n\n    <!-- /tmpl_if -->\n\n    <!-- tmpl_if errors_update_email --> \n        <p>\n            Update Your Profile Email: \n        </p>\n        <ul> \n        <!-- tmpl_if error_invalid_email --> \n            <li>\n                The email address you submitted was not valid.\n            </li> \n        <!-- /tmpl_if --> \n    \n        <!-- tmpl_if error_profile_exists --> \n            <li>\n                     A Profile already exists for the email address, <!-- tmpl_var updated_email -->.\n            </li> \n        <!-- /tmpl_if --> \n        </ul> \n    <!-- /tmpl_if --> \n</div>\n\n<!-- /tmpl_if --> \n\n\n\n\n\n\n<div class=\"row\">\n\t<div class=\"small-12 columns\">\n\t\t<ul class=\"tabs show-for-medium-up\" data-tab=\"\">\n\t\t\t\n\t\t\t<!-- tmpl_if expr=\"profile_feature_mailing_list_subscriptions == 1\" -->\n\t\t\t\t<li class=\"tab-title active\">\n\t\t\t\t\t<a href=\"#mailing_list_subscriptions\">\n\t\t\t\t\t\tSubscriptions\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if --> \n\t\t\t\n\t\t\t<!-- tmpl_if expr=\"profile_feature_profile_fields == 1\" -->\n\t\t\t\t<!-- tmpl_if subscriber_fields -->\n\t\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t\t<a href=\"#profile_fields\">\n\t\t\t\t\t\t\tProfile Fields\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</li>\n\t\t\t\t<!-- /tmpl_if --> \n\t\t\t<!-- /tmpl_if --> \n\t\t\t\n\t\t\t<!-- tmpl_if protected_directories --> \n\t\t\t\t<!-- tmpl_if expr=\"profile_feature_protected_directories == 1\" -->\n\t\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t\t<a href=\"#protected_directories\">\n\t\t\t\t\t\t\tProtected Directories\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</li>\n\t\t\t\t<!-- /tmpl_if --> \n\t\t\t<!-- /tmpl_if --> \n\n\t\t    <!-- tmpl_if expr=\"profile_feature_update_email_address == 1\" -->\t\t\t\n\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t<a href=\"#update_email_address\">\n\t\t\t\t\t\tUpdate Address\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if --> \n\n\n\t\t\t<!-- tmpl_if expr=\"profile_feature_change_password == 1\" -->\n\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t<a href=\"#change_password\">\n\t\t\t\t\t\tPassword\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if --> \n\n\n\t\t    <!-- tmpl_if expr=\"profile_feature_delete_profile == 1\" -->\t\t\t\n\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t<a href=\"#delete_profile\">\n\t\t\t\t\t\tDelete\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t    <!-- /tmpl_if -->\n\t\t</ul>\n\t\t\n\t\t<dl class=\"accordion\" data-accordion=\"\">\n\t\t\t<dd class=\"accordion-navigation\">\n\n\t\t\t \t<!-- tmpl_if expr=\"profile_feature_mailing_list_subscriptions == 1\" -->\n\t\t\t\t\n\t\t\t\t\t<a href=\"#mailing_list_subscriptions\" class=\"show-for-small-only\">\n\t\t\t\t\t\tSubscriptions\n\t\t\t\t\t</a>\n\t\t\t\t\t\n\t\t\t\t\t<div id=\"mailing_list_subscriptions\" class=\"content active\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t                \n\t\t\t\t\t\t\t<!-- tmpl_if has_subscriptions --> \n\t\t\t                    <!-- ... -->\n\t\t\t                <!-- tmpl_else --> \n\t\t\t                    <div class=\"alert-box info radius\">\n\t\t\t                        You are not currently subscribed to any mailing list.\n\t\t\t\t\t\t\t\t</div>\n\t\t\t                <!-- /tmpl_if --> \n\n\t\t\t                <!-- tmpl_loop subscriptions --> \n\t\t\t                    <!-- tmpl_if subscribed --> \n\t\t\t                        <h2>\n\t\t\t                            <a href=\"<!-- tmpl_var PROGRAM_URL -->/list/<!-- tmpl_var list_settings.list -->\">\n\t\t\t                                <!-- tmpl_var list_settings.list_name --> \n\t\t\t                            </a>\n\t\t\t                        </h2>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<div class=\"alert-box info radius\">\n\t\t\t\t\t\t\t\t\t\t\t<ul> \n\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if list_settings.private_list --> \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list is a private mailing list. There may be additional steps in order to join, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tand the List Owner controls who may leave the mailing list. \n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_else --> \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t    \t\t\tThis mailing list is a public mailing list - anyone may join or leave, at any time.\n\t\t\t\t\t\t\t\t\t\t    \t</li>\t\t\n\t\t\t\t\t\t\t\t\t\t    <!-- /tmpl_if -->\n\n\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if list_settings.enable_subscription_approval_step --> \n\t\t\t\t\t\t\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list requires approval from the List Owner, before subscriptions are finalized.\n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t\t\t<!-- /tmpl_if --> \n\n\t\t\t\t\t\t\t\t\t\t    <!-- tmpl_if list_settings.group_list --> \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list is a group discussion list\n     \n\t\t\t\t\t\t\t\t\t\t            <!-- tmpl_if list_settings.enable_moderation --> \n\t\t\t\t\t\t\t\t\t\t                (moderated)\n\t\t\t\t\t\t\t\t\t\t            <!-- tmpl_else -->\n\t\t\t\t\t\t\t\t\t\t                (unmoderated)\n\t\t\t\t\t\t\t\t\t\t            <!-- /tmpl_if --> \n\t\t\t\t\t\t\t\t\t\t        </li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- this is strange, as the bare link will be wrapped with a HTML link --> \n\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Start a new thread, email: <!-- tmpl_var list_settings.discussion_pop_email --></p>\n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\n\t\t\t\t\t\t\t\t\t\t    <!-- tmpl_else --> \n    \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t         <p>\n\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list is announce-only.\n\t\t\t\t\t\t\t\t\t\t         </p>\n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\n\n\t\t\t\t\t\t\t\t\t\t     <!-- /tmpl_if --> \n\t\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n                                                        \n\t\t\t                        <div class=\"panel\"> \n\t\t\t                            <p>\n\t\t\t                                <!-- tmpl_var list_settings.info -->\n\t\t\t                            </p>\n\t\t\t\t\t\t\t\t\t</div> \n\t\t\t                      \n\n\t\t\t                        <ul>\n\t\t\t\t                        <li>\n\t\t\t\t                            <p>\n\t\t\t\t                                <a href=\"<!-- tmpl_var PROGRAM_URL -->/archive/<!-- tmpl_var list_settings.list -->\">\n\t\t\t\t                                    View Archives\n\t\t\t\t                                </a>\n\t\t\t\t                            </p>\n\t\t\t\t                        </li>\n\t\t\t\t                        </ul>\n\t\t\t\t                            <p>\n\t\t\t\t                                <a href=\"<!-- tmpl_var list_unsubscribe_link -->\" class=\"button\">\n\t\t\t\t                                    <!-- tmpl_if list_settings.private_list -->\n\t\t\t\t                                          Request to be removed from <!-- tmpl_var list_settings.list_name -->                  \n\t\t\t\t                                    <!-- tmpl_else --> \n\t\t\t\t                                        Unsubscribe from <!-- tmpl_var list_settings.list_name -->\n\t\t\t\t                                    <!-- /tmpl_if -->\n\t\t\t\t                                </a>\n\t\t\t\t                            </p>\n\t\t\t\t                  \n\t\t\t\t                    \n    \n    \n<!-- tmpl_if list_settings.digest_enable -->\n    <fieldset>\n        <legend>Delivery Preferences:</legend>\n        <form action=\"<!-- tmpl_var S_PROGRAM_URL -->\" method=\"post\"> \n\n            <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n            <input type=\"hidden\" name=\"process\"  value=\"profile_delivery_preferences\" > \n            <input type=\"hidden\" name=\"list\"     value=\"<!-- tmpl_var list_settings.list -->\" > \n\n\t\t\t<div class=\"row\">\n\t\t\t\t<div class=\"small-10 medium-5 large-4 columns\">\t \n\t\t\t\t\t\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t                    <label for=\"delivery_prefs_individual\">\n\t\t\t                    <input \n\t\t\t\t\t\t\t\t\ttype=\"radio\" \n\t\t\t\t\t\t\t\t\tname=\"delivery_prefs\" \n\t\t\t\t\t\t\t\t\tvalue=\"individual\" \n\t\t\t\t\t\t\t\t\tid=\"delivery_prefs_individual\" \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if expr=\"delivery_prefs eq 'individual'\" -->checked=\"checked\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t\t>\n\t\t                            Receive Individual Messages\n\t                        </label>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t                    <label for=\"delivery_prefs_digest\">\t\t\t\t\t\n\t\t\t                    <input \n\t\t\t\t\t\t\t\t\ttype=\"radio\" \n\t\t\t\t\t\t\t\t\tname=\"delivery_prefs\" \n\t\t\t\t\t\t\t\t\tvalue=\"digest\" \n\t\t\t\t\t\t\t\t\tid=\"delivery_prefs_digest\" \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if expr=\"delivery_prefs eq 'digest'\" -->checked=\"checked\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t>\n\t\t                        Receive Messages in a Digest (<!-- tmpl_var digest_timeframe -->)\n\t\t                    </label> \n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t                    <label for=\"delivery_prefs_hold\">\n\t\t                    \t<input \n\t\t\t\t\t\t\t\t\ttype=\"radio\" \n\t\t\t\t\t\t\t\t\tname=\"delivery_prefs\" \n\t\t\t\t\t\t\t\t\tvalue=\"hold\" \n\t\t\t\t\t\t\t\t\tid=\"delivery_prefs_hold\" \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if expr=\"delivery_prefs eq 'hold'\" -->checked=\"checked\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t>\n\t\t                            Hold Mailings (vacation, etc)     \n\t\t                    </label> \n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t<input type=\"submit\" value=\"Save Delivery Preferences\" class=\"success button expand\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div> \n\t\t\t\t</div>\n\t\t\t</div> \n        </form>\n    </fieldset>\n<!-- /tmpl_if --> \n    \n    \n\t\t\t\t                    <!-- tmpl_if comment --> \n\t\t\t\t                        <!-- tmpl_if list_owner --> \n\t\t\t\t                            <div class=\"alert-box info radius\"> \n\t\t\t\t                                You are the List Owner. \n\t\t\t\t                                <a href=\"<!-- tmpl_var S_PROGRAM_URL -->/sign_in/<!-- tmpl_var list_settings.list -->/\"> \n\t\t\t\t                                    Login...\n\t\t\t\t                                </a>  \n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t                        <!-- /tmpl_if -->\n\t\t\t\t                     <!-- /tmpl_if -->\n\t\t\t\t                <!-- /tmpl_if --> \n\t\t\t\t            <!-- /tmpl_loop -->\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\n\t\t\t\t<!-- /tmpl_if --><!-- profile_feature_mailing_list_subscriptions -->\n\t\t\t    \n\t\t\t\t\n\t\t\t\t<!-- tmpl_if expr=\"profile_feature_profile_fields == 1\" -->\n\t\t\t        <!-- tmpl_if subscriber_fields -->\n\t\t\t\t\n\t\t\t\t\t\t<a href=\"#profile_fields\" class=\"show-for-small-only\">\n\t\t\t\t\t\t\tProfile Fields\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<div id=\"profile_fields\" class=\"content\">\n\t\t\t\t\t\t\t<div class=\"content-box section-box\">\n\n\t\t\t\t                <form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" id=\"membership_profile_fields\"> \n\t\t\t\t                    <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n\t\t\t\t                    <input type=\"hidden\" name=\"process\"  value=\"edit_subscriber_fields\" > \n\t\t\t\t                    <!-- tmpl_loop subscriber_fields --> \n\n\t\t\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"large-3 medium-3 columns\">\n\t\t\t\t\t\t\t\t\t\t\t\t<label \n\t\t\t\t\t\t\t\t\t\t\t\t\tfor=\"<!-- tmpl_var name escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"medium-text-right\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t                        <!-- tmpl_if label --> \n\t\t\t\t\t\t\t                            <!-- tmpl_var label escape=HTML -->: \n\t\t\t\t\t\t\t                        <!-- tmpl_else --> \n\t\t\t\t\t\t\t                            <!-- tmpl_var name escape=HTML -->: \n\t\t\t\t\t\t\t                        <!-- /tmpl_if -->\n\t\t\t\t\t\t                        </label>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"large-9 medium-9 columns\">\n\t\t\t\t\t\t                        <input \n\t\t\t\t\t\t\t\t\t\t\t\t\ttype=\"text\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tname=\"<!-- tmpl_var name escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tid=\"<!-- tmpl_var name escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var value escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if required -->required<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if required -->placeholder=\"(required)\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t                    <!-- /tmpl_loop -->\n\t\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t\t<input type=\"submit\" value=\"Update Information\" class=\"success button expand\"> \n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t                </form>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t        <!-- /tmpl_if -->\n\t\t\t    <!-- /tmpl_if--><!-- profile_feature_profile_fields -->\n\t\t\t\t\n\t\t\t    <!-- tmpl_if protected_directories --> \n\t\t\t        <!-- tmpl_if expr=\"profile_feature_protected_directories == 1\" -->    \t\t\t\t\n\t\t\t\t\t\t<a href=\"#protected_directories\" class=\"show-for-small-only\">\n\t\t\t\t\t\t\tProtected Directories\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<div id=\"protected_directories\" class=\"content\">\n\t\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t                    <p>Access these directories with your Profile Username/Password.\n\t\t\t                    <ul>        \n\t\t\t                        <!-- tmpl_loop protected_directories --> \n\t\t\t                            <p>\n\t\t\t                                <li>\n\t\t\t                                    <strong>\n\t\t\t                                        <a href=\"<!-- tmpl_var url -->\" target=\"_blank\"><!-- tmpl_var name --></a>\n\t\t\t                                    </strong> \n\t\t\t                                </li>\n\t\t\t                            </p>\n\t\t\t                        <!-- /tmpl_loop --> \n\t\t\t                    </ul>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t        <!-- /tmpl_if --> \n\t\t\t    <!-- /tmpl_if -->\n\t\t\t\t\n\t\t\t    <!-- tmpl_if expr=\"profile_feature_update_email_address == 1\" -->\n\t\t\t\t\n\t\t\t\t\t<a href=\"#update_email_address\" class=\"show-for-small-only\">\n\t\t\t\t\t\tUpdate Address\n\t\t\t\t\t</a>\n\t\t\t\t\t<div id=\"update_email_address\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t\t\t\t\t\n\t\t\t\t            <div class=\"alert-box warning radius\">\n\t\t\t\t                The Profile Email Address and Subscriptions using your current email address (<!-- tmpl_var profile.email -->) \n\t\t\t\t                will be replaced with this new email address, where it's allowed: \n\t\t\t\t\t\t\t</div>\n\t\t\t\t            <form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\"> \n\t\t\t\t                <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n\t\t\t\t                <input type=\"hidden\" name=\"process\"  value=\"update_email\" >\n\t\t\t                    <!-- tmpl_if errors_update_email --> \n\t\t\t                        <!-- tmpl_if error_invalid_email --> \n\t\t\t                            <p class=\"error\"> \n\t\t\t                                * The email address you submitted is not valid.\n\t\t\t                            </p> \n\t\t\t                        <!-- /tmpl_if --> \n\n\t\t\t                        <!-- tmpl_if error_profile_exists --> \n\t\t\t                            <p class=\"error\"> \n\t\t\t                                * A Profile already exists for the email address, <!-- tmpl_var updated_email -->.\n\t\t\t                            </p> \n\t\t\t                        <!-- /tmpl_if --> \n\t\t\t                    <!-- tmpl_else --> \n\t\t\t                    <!-- /tmpl_if -->\n\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<label for=\"updated_email\" class=\"label_profile_fields\">\n\t\t\t\t\t\t\t\t\t\t\tYour New Profile Email Address: \n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input type=\"text\" name=\"updated_email\" id=\"updated_email\" value=\"\" >\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<input type=\"submit\"  class=\"success button\" value=\"Confirm and Update Your New Profile Email Address\" > \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\t\n\t\t\t\t\t\t\t</form>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t<!-- /tmpl_if --><!-- profile_feature_update_email_address -->\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t    <!-- tmpl_if expr=\"profile_feature_change_password == 1\" -->\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t<a href=\"#change_password\" class=\"show-for-small-only\">\n\t\t\t\t\t\tPassword\n\t\t\t\t\t</a>\n\t\t\t\t\t\n\t\t\t\t\t<div id=\"change_password\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t<form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\"> \n\t\t\t\t                <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n\t\t\t\t                <input type=\"hidden\" name=\"process\"  value=\"change_password\" >\n\n\t\t\t\t                <!-- tmpl_if errors_change_password --> \n\t\t\t\t                        <p class=\"error\">\n\t\t\t\t                            Make sure that you re-typed your password correctly. \n\t\t\t\t                        </p>\n\t\t\t\t                <!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"password\" class=\"label_profile_fields\">\n\t\t\t\t\t                 \t   New Password \n\t\t\t\t\t                    </label>\n\t\t\t\t\t\t\t\t\t\t<input type=\"password\" name=\"password\" id=\"password\" value=\"\"  >\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"again_password\" class=\"label_profile_fields\">\n\t\t\t\t\t                    New Password Again: \n\t\t\t\t\t                    </label>\n\t\t\t\t\t                    <input type=\"password\" name=\"again_password\" id=\"again_password\" value=\"\"  >\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\t\n\t\t\t\t                \t\t<input type=\"submit\"   class=\"success button\"  value=\"Change Password\" > \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t            </form>\t\t\t\t\t\t\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t    <!-- /tmpl_if --><!-- profile_feature_change_password -->\n\t\t\t\t\n\t\t\t\t\n\t\t\t    <!-- tmpl_if expr=\"profile_feature_delete_profile == 1\" -->\t\t\t\n\t\t\t\t\t<a href=\"#delete_profile\" class=\"show-for-small-only\">\n\t\t\t\t\t\tDelete\n\t\t\t\t\t</a>\n\t\t\t\t\t<div id=\"delete_profile\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t\t            <form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\"> \n\t\t\t\t                <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n\t\t\t\t                <input type=\"hidden\" name=\"process\"  value=\"delete_profile\" >\n        \n\t\t\t\t\t\t\t\t<div class=\"alert-box info radius\">\n\t\t\t\t\t\t\t        Deleting your profile will remove all your profile information, but \n\t\t\t\t                    all your subscriptions to subscribed mailing lists will remain.\n\t\t\t\t\t\t\t\t</div> \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t                <input type=\"submit\" value=\"Delete Your Profile\" class=\"alert button\" onclick=\"return confirm_profile_removal(this.form);\" > \n        \n\t\t\t\t\t\t\t</form>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t    <!-- /tmpl_if -->\n\t\t\t\t\n\t\t\t</dd>\n\t\t</dl>\n\t</div>\n</div>\n\n\n\n\n\n<!-- end profile_home.tmpl --> ", "<!-- being profile_login.tmpl --> \n\n<!-- tmpl_set name=\"title\" value=\"Profile Login\" --> \n<!-- tmpl_set name=\"show_profile_widget\" value=\"0\" --> \n<!-- tmpl_set name=\"load_captcha_js\" value=\"1\" --> \n\n<div id=\"profile_login_registration\"></div>\n\n<!-- tmpl_if removal --> \n\t<div class=\"alert-box info radius\">\n\t\tYour Profile has been removed.\n\t</div> \n<!-- /tmpl_if --> \n\n<!-- tmpl_if welcome --> \n\t<div class=\"alert-box info radius\">\n\t\tYou have been successfully registered! Please log in with your Profile email address and password:\n\t</div> \n<!-- /tmpl_if --> \n\n<!-- tmpl_if logged_out --> \n\t<div class=\"alert-box info radius\">\n\t\tYou have logged out. \n\t</div> \n<!-- /tmpl_if --> \n\n<!-- tmpl_if password_changed --> \n\t<div class=\"alert-box info radius\">\n\t\tYou've successfully changed your Profile password ! Please log in again:\n\t</div> \n<!-- /tmpl_if --> \n\n\n\n\t\t\t\t<!-- tmpl_if comment --> \n\t\t\t\t\t<!-- tmpl_if errors --> \n\t\t\t\t\t\t<h3>YOU HAVE ERRORS!!!</h3> \n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t<!-- tmpl_loop errors --> \n\t\t\t\t\t\t\t<li><p><!-- tmpl_var error --></p></li>\n\t\t\t\t\t\t<!-- /tmpl_loop --> \n\t\t\t\t\t\t</ul>\n\t\t\t\t\t<!-- /tmpl_if --> \n\n\t\t\t\t\t<h3>error_profile_login: <!-- tmpl_var error_profile_login --> </h3> \n\t\t\t\t\t<h3>error_profile_register: <!-- tmpl_var error_profile_register --></h3>\n\t\t\t\t\t<hr > \n\t\t\t\t\t<hr > \n\t\t\t\t\t<hr > \n\t\t\t\t<!-- /tmpl_if --> \n\n\n\n\n<!-- tmpl_if errors --> \n\t<div class=\"alert-box warning radius\">\n\n\t<p>\n\t\t<strong>\n\t\t\tProblems with your Request:\n\t\t</strong>\n\t</p>\n\t\n\t<ul> \n\t<!-- tmpl_if error_profile_login --> \n\t\t<li>\n\t\t\tPlease log into your Profile.\n\t\t</li>\n\t<!-- /tmpl_if --> \n\t<!-- tmpl_if error_profile_activate --> \n\t\t<!-- tmpl_if error_invalid_auth_code -->                 \n\t\t\t<li>\n\t\t\t\tYour Registration Authorization Code does not seem to be valid. Make sure to copy/paste the entire registration link. \n\t\t\t</li>\n\t\t<!-- /tmpl_if -->  \n\t<!-- /tmpl_if -->\n\n\t<!-- tmpl_if error_profile_register --> \n\t\t<!-- tmpl_if error_invalid_email -->\n\t\t\t<li>\n\t\t\t\tThe email address you've entered is not valid.\n\t\t\t</li>        \n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_password_blank --> \n\t\t\t<li>\n\t\t\t\tYou forgot to enter a password.\n\t\t\t</li>\n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_email_no_match --> \t\n\t\t\t<li>\n\t\t\t\tThe email addresses you've entered do not match.\n\t\t\t</li>        \n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_captcha_failed --> \n\t\t\t<li>\n\t\t\t\tSorry, reCAPTCHA failed. \n\t\t\t</li>\n\t\t<!-- /tmpl_if --> \n\n\t\t<!-- tmpl_if error_profile_exists -->\n\t\t\t<li>\n\t\t\t\tA Profile for this address already exists. Please log in, or reset your Profile Password.\n\t\t\t</li>        \n\t\t<!-- /tmpl_if --> \n\t<!-- /tmpl_if --> \n\n\t<!-- tmpl_if error_profile_login --> \n\t\t<!-- tmpl_if errors_not_logged_in -->     \n\t\t<li>\n\t\t\tYou'll have to log in, before you may access your Profile.\n\t\t</li>\n\t\t<!-- /tmpl_if -->             \n\t\t<!-- tmpl_if error_unknown_user --> \n\t\t\t<!-- tmpl_if profile_settings.register -->\n\t\t\t\t<li>\n\t\t\t\t\tProfile User Unknown - have you registered?\n\t\t\t\t</li>\n\t\t\t<!-- tmpl_else -->\n\t\t\t\t<li>\n\t\t\t\t\tProfile User Unknown - self-registration is also disabled.\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if -->\n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_incorrect_pass --> \n\t\t\t<li>\n\t\t\t\tIncorrect Password.\n\t\t\t</li>\n\t\t<!-- /tmpl_if --> \n\t\t</ul> \n\t<!-- /tmpl_if --> \n\n\t<!-- tmpl_if error_profile_reset_password --> \n\t\t<!-- tmpl_if error_invalid_auth_code --> \n\t\t\t<li>\n\t\t\t\tAuthorization Code is not valid. Make sure to copy/paste the entire password reset link. \n\t\t\t</li> \n\t\t<!-- /tmpl_if --> \n\n\t\t<!-- tmpl_if error_unknown_user --> \n\t\t\t<li>\n\t\t\t\tProfile User Unknown - have you registered?\n\t\t\t</li> \n\t\t<!-- /tmpl_if -->\n\t<!-- /tmpl_if -->\n\t\t</ul>\n\t</div> \n<!-- /tmpl_if --> \n\n\n\n\n<div class=\"alert-box info radius\"> \n\t<p>\n\t\t<!-- tmpl_var PROGRAM_NAME --> Profiles allow you to view and work with all \n\t\tyour <!-- tmpl_var PROGRAM_NAME --> subscriptions.\n\t</p>\n\t<p>\n\t\tHaving a profile and being logged in also allows you to view subscriber-only archives.\n\t</p>\n</div> \n\n\n\n<div class=\"row\">\n  <div class=\"small-12 columns\">\n    <ul class=\"tabs show-for-medium-up\" data-tab>\n      <li class=\"tab-title active\"><a href=\"#profile_login\">Login</a></li>\n\t\t \n\t\t  <!-- tmpl_if profile_settings.password_reset -->\n\t\t \t <li class=\"tab-title\"><a href=\"#profile_password_reset\">Reset Password</a></li>\n\t\t  <!-- /tmpl_if -->\n\t   \n\t\t  <!-- tmpl_if profile_settings.register -->\n\t      \t\t<li class=\"tab-title\"><a href=\"#profile_register\">Register</a></li>\n\t\t  <!-- /tmpl_if -->\t\n\t\n\t</ul>\n\n\t<dl class=\"accordion\" data-accordion>\n\t\n\t\t<dd class=\"accordion-navigation\">\n\t\t\t<a href=\"#profile_login\" class=\"show-for-small-only\">Login</a>\n\t\t\t<div id=\"profile_login\" class=\"content active\">\n\t\t\t\t<div class=\"content-box section-box\">\n\n\n\n\t\t\t\t\t<form \n\t\t\t\t\t\taction=\"<!-- tmpl_var PROGRAM_URL -->\" \n\t\t\t\t\t\tmethod=\"post\" \n\t\t\t\t\t\taccept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" \n\t\t\t\t\t\tid=\"profile_login\"\n\t\t\t\t\t> \n\t\t\t\t\t\t<input type=\"hidden\" name=\"flavor\" value=\"profile_login\" > \n\t\t\t\t\t\t<input type=\"hidden\" name=\"process\" value=\"1\" > \n\t\t\t\t\t\t\n\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t<label for=\"login_email\">\n\t\t\t\t\t\t\t\t\tEmail Address\n\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\ttype=\"email\" \n\t\t\t\t\t\t\t\t\tname=\"login_email\" \n\t\t\t\t\t\t\t\t\tid=\"login_email\" \n\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var login_email escape=\"HTML\" -->\"\n\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t<label for=\"login_password\">\n\t\t\t\t\t\t\t\t\tPassword\n\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\ttype=\"password\" \n\t\t\t\t\t\t\t\t\tname=\"login_password\" \n\t\t\t\t\t\t\t\t\tid=\"login_password\" \n\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t<input type=\"submit\" class=\"button expand\" value=\"Log Into Your Profile\" > \n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</form>\n    \t\t\t</div>\n\t\t\t</div>\n\t\t\n\t\t <!-- tmpl_if profile_settings.password_reset -->\n\t\t\n\t\t\t\t<a href=\"#profile_password_reset\" class=\"show-for-small-only\">Reset Password</a>\n\t\t\t\t<div id=\"profile_password_reset\" class=\"content\">\n\t\t\t\t\t<div class=\"content-box section-box\">\n\n\n\n\n\n\t\t\t\t\t\t<form \n\t\t\t\t\t\t\taction=\"<!-- tmpl_var PROGRAM_URL -->\" \n\t\t\t\t\t\t\tmethod=\"post\" \n\t\t\t\t\t\t\taccept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" \n\t\t\t\t\t\t\tid=\"profile_reset_password\"\n\t\t\t\t\t\t> \n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"flavor\" value='profile_reset_password' > \n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t<label for=\"reset_email\">\n\t\t\t\t\t\t\t\t\t\tEmail Address\n\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\ttype=\"text\" \n\t\t\t\t\t\t\t\t\t\tid=\"reset_email\" \n\t\t\t\t\t\t\t\t\t\tname=\"reset_email\" \n\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var reset_email escape=HTML -->\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t<input type=\"submit\" class=\"button expand\" value=\"Reset Your Profile Password\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div> \n\t\t\t\t\t\t</form>\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t    \t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t\n\t\t\t<!-- /tmpl_if -->\n\t\t\t\n\t\t\t <!-- tmpl_if profile_settings.register -->\n\t\t\t\n\t\t\t\t\t<a href=\"#profile_register\" class=\"show-for-small-only\">Register</a>\n\t\t\t\t\t<div id=\"profile_register\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\n\n\t\t\t\t\t\t\t<div class=\"alert-box info radius\">\n\t\t\t\t\t\t\t\tRegister a Profile to easily manage all your <!-- PROGRAM_NAME --> Subscriptions.\n\t\t\t\t\t\t\t</div> \n\n\t\t\t\t\t\t\t<form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" id=\"profile_register\"> \n\t\t\t\t\t\t\t\t<input type=\"hidden\" name=\"flavor\" value=\"profile_register\" > \n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"register_email\">\n\t\t\t\t\t\t\t\t\t\t\tEmail Address\n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"email\" \n\t\t\t\t\t\t\t\t\t\t\tname=\"register_email\" \n\t\t\t\t\t\t\t\t\t\t\tid=\"register_email\" \n\t\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var register_email escape=HTML -->\"\n\t\t\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"register_email_again\" >\n\t\t\t\t\t\t\t\t\t\t\tEmail Address (again)\n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"email\" \n\t\t\t\t\t\t\t\t\t\t\tname=\"register_email_again\" \n\t\t\t\t\t\t\t\t\t\t\tid=\"register_email_again\" \n\t\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var register_email_again -->\"\n\t\t\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"register_password\" >\n\t\t\t\t\t\t\t\t\t\t\tPassword\n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"password\" \n\t\t\t\t\t\t\t\t\t\t\tname=\"register_password\" \n\t\t\t\t\t\t\t\t\t\t\tid=\"register_password\" \n\t\t\t\t\t\t\t\t\t\t > \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<!-- tmpl_if can_use_captcha --> \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if can_use_Google_reCAPTCHA_v2 --> \n\t\t\t\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t\t\t\t<div \n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"g-recaptcha\" \n\t\t\t\t\t\t\t\t\t\t\t\tid=\"profile_login_gr\"\n\t\t\t\t\t\t\t\t\t\t\t></div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<!-- /tmpl_if --> \n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<!-- tmpl_if can_use_Google_reCAPTCHA_v3 -->\t\t\t\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"hidden\"\n\t\t\t\t\t\t\t\t\t\t\tid=\"g-recaptcha-response_profile_login\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"g-recaptcha-response\"\n\t\t\t\t\t\t\t\t\t\t\tname=\"g-recaptcha-response\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t<!-- /tmpl_if --> \n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"submit\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"button expand\"\n\t\t\t\t\t\t\t\t\t\t\tvalue=\"Register a New Profile\"\n\t\t\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</form> \n\n\t\t        </div>\n\t\t\t\t\t</div>\n\t\t\t\n\t\t\t<!-- /tmpl_if -->\n\n\t\t</dd>\n\t</dl>\n\n\n\n\n\n\t</div>\n</div>\n<!-- end profile_login.tmpl --> "], "fixing_code": ["#!/usr/bin/perl\npackage DADA::App;\nuse base 'CGI::Application';\n\nuse CGI::Application::Plugin::RateLimit;\n\n#use CGI::Application::Plugin::DebugScreen;\n\nuse strict;\n\n\n\nBEGIN {\n    if ( $] > 5.008 ) {\n        require Errno;\n        require Config;\n    }\n}\nuse FindBin;\nuse lib \"$FindBin::Bin/../\";\nuse lib \"$FindBin::Bin/../../\";\nuse lib \"$FindBin::Bin/../../../\";\nuse lib \"$FindBin::Bin/../DADA/perllib\";\n\nuse Encode qw(encode decode);\nuse POSIX; \n\nBEGIN {\n    my $b__dir = ( getpwuid($>) )[7] . '/perl';\n    push @INC, $b__dir . '5/lib/perl5',\n      $b__dir . '5/lib/perl5/x86_64-linux-thread-multi', $b__dir . 'lib',\n      map { $b__dir . $_ } @INC;\n}\n$ENV{PATH} = \"/bin:/usr/bin\";\ndelete @ENV{ 'IFS', 'CDPATH', 'ENV', 'BASH_ENV' };\n\n#---------------------------------------------------------------------#\nuse Carp qw(carp croak);\n# $CARP::Verbose = 1;\n# use Devel::Confess; \n\n#---------------------------------------------------------------------#\n\nuse DADA::Config 11.0.0;\n\nuse DADA::App::ScreenCache;\nmy $c = DADA::App::ScreenCache->new;\nuse DADA::App::Guts;\nuse DADA::MailingList::Subscribers;\nuse Try::Tiny;\nuse DADA::Template::HTML;\nuse DADA::Template::Widgets;\n\n#---------------------------------------------------------------------#\n\nsub cgiapp_init {\n\n    $CGI::Application::LIST_CONTEXT_WARN = 0;\n\n    my $self = shift;\n    $self->query->charset($DADA::Config::HTML_CHARSET);\n\n    # Kinda Weird.\n    $DADA::Template::Widgets::q = $self->query;\n    $DADA::Template::HTML::q    = $self->query;\n\n}\n\nsub cgiapp_prerun {\n    my ( $self, $output_ref ) = @_;\n\t$self->header_props(\n\t    -charset         => $DADA::Config::HTML_CHARSET,\n\t    -Pragma          => 'no-cache', \n\t    '-Cache-control' => 'max-age=0, no-cache, no-store, must-revalidate',\n\t\t-Expires         => 'Wed, 11 Jan 1984 05:00:00 GMT',\t\t\n\t);\n}\n\nsub cgiapp_postrun {\n    my ( $self, $output_ref ) = @_;\n    $$output_ref = safely_encode($$output_ref);\n}\n\nsub setup {\n\n    my $self = shift;\n\n    $self->start_mode('default');\n    $self->mode_param('flavor');\n    $self->error_mode('yikes');\n\n# So, maybe the, \"schedules\" runmode should be something quite random, that can also be reset?\n# And then implement some sort of limit on how many times a schedule can be run?\n# And then, and then! Have a screen showing:\n# * an example cronjob\n# * a way to force the schedule to run\n# *\n\n    my $sched_flavor =\n      $DADA::Config::SCHEDULED_JOBS_OPTIONS->{scheduled_jobs_flavor};\n\n    $self->run_modes(\n\t\n\t \t\"AUTOLOAD\"                 => \\&unknown_param,\n\t \n        'plugins'                  => \\&plugins,\n        $sched_flavor              => \\&schedules,\n        'scheduled_jobs'           => \\&scheduled_jobs,\n        'default'                  => \\&default,\n        'subscribe'                => \\&subscribe,\n        'restful_subscribe'        => \\&restful_subscribe,\n\t\t'subscribe_landing'        => \\&subscribe_landing, \n\t\t'modal_subscribe_landing'  => \\&modal_subscribe_landing, \n        'api'                      => \\&api,\n        'token'                    => \\&token,\n\t\t'post_token'               => \\&post_token, \n        'unsubscribe'              => \\&unsubscribe,\n        'unsubscription_request'   => \\&unsubscription_request,\n        'unsubscribe_email_lookup' => \\&unsubscribe_email_lookup,\n        'report_abuse'             => \\&report_abuse,\n        'login'                    => \\&login,\n        'logout'                   => \\&logout,\n        #'log_into_another_list'    => \\&log_into_another_list,\n        'change_login'             => \\&change_login,\n        'new_list'                 => \\&new_list,\n        'change_info'              => \\&change_info,\n\t\t'is_valid_url'             => \\&is_valid_url, \n\t\t'manage_privacy_policy'    => \\&manage_privacy_policy, \n\t\t'manage_list_consent'      => \\&manage_list_consent,\n        'html_code'                => \\&html_code,\n        'preview_jquery_plugin_subscription_form' => \\&preview_jquery_plugin_subscription_form,\n\t\t'preview_subscription_form'               => \\&preview_subscription_form, \n\t\t'preview_minimal_subscription_form'       => \\&preview_minimal_subscription_form, \n\t\t'preview_modal_subscribe_landing_code'    => \\&preview_modal_subscribe_landing_code,\n        'admin_help'                    => \\&admin_help,\n        'delete_list'                   => \\&delete_list,\n        'view_list'                     => \\&view_list,\n        'mass_update_profiles'          => \\&mass_update_profiles,\n        'domain_breakdown_json'         => \\&domain_breakdown_json,\n        'search_list_auto_complete'     => \\&search_list_auto_complete,\n        'list_activity'                 => \\&list_activity,\n        'sub_unsub_trends_json'         => \\&sub_unsub_trends_json,\n\t\t'recent_subscription_activity'  => \\&recent_subscription_activity, \n        'view_bounce_history'           => \\&view_bounce_history,\n        'subscription_requests'         => \\&subscription_requests,\n        'unsubscription_requests'       => \\&unsubscription_requests,\n        'remove_all_subscribers'        => \\&remove_all_subscribers,\n        'membership'                    => \\&membership,\n        'also_member_of'                => \\&also_member_of,\n        'admin_change_profile_password' => \\&admin_change_profile_password,\n        'admin_profile_delivery_preferences' => \\&admin_profile_delivery_preferences,\n        'validate_update_email'          => \\&validate_update_email,\n        'validate_remove_email'          => \\&validate_remove_email,\n        'mailing_list_history'           => \\&mailing_list_history,\n        'membership_activity'            => \\&membership_activity,\n        'export_membership_history'      => \\&export_membership_history,\n        'add'                            => \\&add,\n        'check_status'                   => \\&check_status,\n        'email_password'                 => \\&email_password,\n\t\t'post_email_password'            => \\&post_email_password, \n        'add_email'                      => \\&add_email,\n        'delete_email'                   => \\&delete_email,\n        'subscription_options'           => \\&subscription_options,\n\t\t'admin_menu_notifications'       => \\&admin_menu_notifications, \n        'send_email'                     => \\&send_email,\n\t\t'image_drag_and_drop'            => \\&image_drag_and_drop, \n\t\t'no_draft_available'             => \\&no_draft_available, \n        'email_message_preview'          => \\&email_message_preview,\n        'send_email_button_widget'        => \\&send_email_button_widget,\n        'mass_mailing_schedules_preview'  => \\&mass_mailing_schedules_preview,\n\t\t'mass_mailing_schedules_preview_calendar' => \\&mass_mailing_schedules_preview_calendar,\n\t\t'mass_mailing_schedules_preview_calendar_json' => \\&mass_mailing_schedules_preview_calendar_json, \n        'draft_message_values'            => \\&draft_message_values,\n        'ckeditor_template_tag_list'      => \\&ckeditor_template_tag_list,\n        'draft_saved_notification'        => \\&draft_saved_notification,\n        'drafts'                          => \\&drafts,\n\t\t'preview_draft'                   => \\&preview_draft, \n        'delete_drafts'                   => \\&delete_drafts,\n        'create_from_stationery'          => \\&create_from_stationery,\n       # 'message_body_help'               => \\&message_body_help,\n        #'url_message_body_help'           => \\&url_message_body_help,\n        'preview_message_receivers'       => \\&preview_message_receivers,\n        'sending_monitor'                 => \\&sending_monitor,\n        'print_mass_mailing_log'          => \\&print_mass_mailing_log,\n        'remove_subscribers'              => \\&remove_subscribers,\n        'process_bouncing_addresses'      => \\&process_bouncing_addresses,\n        'edit_template'                   => \\&edit_template,\n        'view_archive'                    => \\&view_archive,\n        'display_message_source'          => \\&display_message_source,\n        'purge_all_archives'              => \\&purge_all_archives,\n        'delete_archive'                  => \\&delete_archive,\n        'edit_archived_msg'               => \\&edit_archived_msg,\n        'archive'                         => \\&list_archive,\n        'archive_bare'                    => \\&archive_bare,\n        'archive_rss'                     => \\&archive_rss,\n        'archive_atom'                    => \\&archive_atom,\n        'manage_script'                   => \\&manage_script,\n        'change_password'                 => \\&change_password,\n        'text_list'                       => \\&text_list,\n        'archive_options'                 => \\&archive_options,\n        'adv_archive_options'             => \\&adv_archive_options,\n        'back_link'                       => \\&back_link,\n\t\t'edit_type'                       => \\&edit_type,\n        'email_themes'                    => \\&email_themes, \n\t\t'edit_html_type'                  => \\&edit_html_type,\n        'list_options'                    => \\&list_options,\n        'web_services'                    => \\&web_services,\n        'mail_sending_options'            => \\&mail_sending_options,\n        'amazon_ses_verify_email'         => \\&amazon_ses_verify_email,\n        'amazon_ses_get_stats'            => \\&amazon_ses_get_stats,\n        'mailing_sending_mass_mailing_options' =>\n          \\&mailing_sending_mass_mailing_options,\n        'previewBatchSendingSpeed'      => \\&previewBatchSendingSpeed,\n        'mail_sending_advanced_options' => \\&mail_sending_advanced_options,\n        'filter_using_black_list'       => \\&filter_using_black_list,\n        'search_archive'                => \\&search_archive,\n        'send_archive'                  => \\&send_archive,\n        'list_invite'                   => \\&list_invite,\n        'mass_mailing_options'          => \\&mass_mailing_options,\n        'pass_gen'                      => \\&pass_gen,\n        'feature_set'                   => \\&feature_set,\n        'profile_fields'                => \\&profile_fields,\n        'mail_sending_options_test'     => \\&mail_sending_options_test,\n        'author'                        => \\&author,\n        'list'                          => \\&list_page,\n\t\t'privacy_policy'                => \\&list_privacy_policy, \n        'setup_info'                    => \\&setup_info,\n        'reset_cipher_keys'             => \\&reset_cipher_keys,\n        'restore_lists'                 => \\&restore_lists,\n        'r'                             => \\&redirection,\n        'post_redirection'              => \\&post_redirection, \n\t\t'subscriber_help'               => \\&subscriber_help,\n        'show_img'                      => \\&show_img,\n        'file_attachment'               => \\&file_attachment,\n        'm_o_c'                         => \\&m_o_c,\n        'img'                           => \\&img,\n        'js'                            => \\&js,\n        'css'                           => \\&css,\n        'ver'                           => \\&ver,\n        'resend_conf'                   => \\&resend_conf,\n        'show_error'                    => \\&show_error,\n        'subscription_form_html'        => \\&subscription_form_html,\n        'profile_activate'              => \\&profile_activate,\n\t\t'post_profile_activate'         => \\&post_profile_activate, \n        'profile_register'              => \\&profile_register,\n        'profile_reset_password'        => \\&profile_reset_password,\n\t\t'post_profile_reset_password'   => \\&post_profile_reset_password, \n        'profile_update_email'          => \\&profile_update_email,\n        'profile_login'                 => \\&profile_login,\n        'profile_logout'                => \\&profile_logout,\n        'profile'                       => \\&profile,\n        'also_save_for_settings'        => \\&also_save_for_settings,\n        'transform_to_pro'              => \\&transform_to_pro,\n        'yikes'                         => \\&yikes,\n        'rate_limit_reached'            => \\&rate_limit_reached,\n\t\t'status_405'                    => \\&status_405, \n\n# These handled the oldstyle confirmation. For some backwards compat, I've changed\n# them so that there's at least a shim to the new system,\n#\n#\t'n'                          =>    \\&confirm,\n        's'                          => \\&subscribe,\n        'u'                          => \\&unsubscribe,\n        'outdated_subscription_urls' => \\&outdated_subscription_urls,\n\n        # This is the new system\n        't' => \\&token,\n\n        # This doesn't really happen, anymore:\n        'ur'                               => \\&outdated_subscription_urls,\n        'send_email_testsuite'             => \\&send_email_testsuite,\n        $DADA::Config::ADMIN_FLAVOR_NAME   => \\&admin,\n        $DADA::Config::SIGN_IN_FLAVOR_NAME => \\&sign_in,\n\n        bridge_inject => \\&bridge_inject,\n    );\n\n    # ...inject?\n    if ( !$ENV{GATEWAY_INTERFACE} ) {\n\n        my $inject;\n        my $run_list;\n        require Getopt::Long;\n        Getopt::Long::GetOptions(\n            \"inject\" => \\$inject,\n            \"list=s\" => \\$run_list,\n        );\n        if ($inject) {\n\n            # $ENV{CGI_APP_RETURN_ONLY} = 1;\n\n            if ($run_list) {\n                $self->param( 'run_list', $run_list );\n                $self->start_mode('bridge_inject');\n            }\n            else {\n                # Well, that won't work.\n            }\n        }\n        else {\n            # Do watcha did before.\n        }\n    }\n\n    my $rate_limit = undef;\n\n    if ( $DADA::Config::RATE_LIMITING->{enabled} == 1\n        && exists( $ENV{GATEWAY_INTERFACE} ) )\n    {\n\n        require DADA::App::DBIHandle;\n        my $dbi_handle = DADA::App::DBIHandle->new;\n\t\tmy $dbh = undef; \n\t\t\n\t\tmy $dbi_handle_check = 1; \n\t    try {\n\t       $dbh =  $dbi_handle->dbh_obj;\n\t\t\n\t    } catch {\n\t\t\twarn $_; \n\t\t\t$dbi_handle_check = 0; \n\t    };\n\t\tif($dbi_handle_check == 0){ \n\t        return $self->sql_connect_error(); \n\t\t}\n\t\t\n        # call this in your setup routine to set\n        my $rate_limit = $self->rate_limit();\n\t\tmy $remote_addr = $ENV{REMOTE_ADDR}; # I can't think of any reason this should log anonymously.  \n\t\t\n        $rate_limit->identity_callback( sub { return $remote_addr } );\n\n        # set the database handle to use\n        $rate_limit->dbh($dbh);\n        $rate_limit->table( $DADA::Config::SQL_PARAMS{rate_limit_hits_table} );\n\n        my $pm_prefs = {\n            timeframe => $DADA::Config::RATE_LIMITING->{timeframe} . 'm',\n            max_hits  => $DADA::Config::RATE_LIMITING->{max_hits},\n        };\n\n        $rate_limit->protected_modes(\n            $sched_flavor                      => $pm_prefs,\n            subscribe                          => $pm_prefs,\n            restful_subscribe                  => $pm_prefs,\n            \n\t\t\ttoken                              => $pm_prefs,\n\t\t\tpost_token                         => $pm_prefs,\n\t\t\t\n\t\t\temail_password                     => $pm_prefs,\n\t\t\tprofile_reset_password             => $pm_prefs,\n            unsubscribe                        => $pm_prefs,\n            unsubscription_request             => $pm_prefs,\n            login                              => $pm_prefs,\n            #log_into_another_list              => $pm_prefs,\n            pass_gen                           => $pm_prefs,\n            file_attachment                    => $pm_prefs,\n            profile_activate                   => $pm_prefs,\n            profile_register                   => $pm_prefs,\n            profile_reset_password             => $pm_prefs,\n            profile_update_email               => $pm_prefs,\n            profile_login                      => $pm_prefs,\n            profile_logout                     => $pm_prefs,\n            profile                            => $pm_prefs,\n            's'                                => $pm_prefs,\n            u                                  => $pm_prefs,\n            outdated_subscription_urls         => $pm_prefs,\n            t                                  => $pm_prefs,\n            ur                                 => $pm_prefs,\n\t\t\tsend_archive                       => $pm_prefs,\n            $DADA::Config::ADMIN_FLAVOR_NAME   => $pm_prefs,\n            $DADA::Config::SIGN_IN_FLAVOR_NAME => $pm_prefs,\n        );\n\n        # call this runmode when a violation is detected\n        $rate_limit->violation_mode('rate_limit_reached');\n    }\n}\n\nsub teardown {\n    my $self = shift;\n\t\n    if ( $DADA::Config::SCHEDULED_JOBS_OPTIONS->{run_at_teardown} == 1 ) {\n        $self->run_pseudo_cron();\n    }\n}\n\n\n\nsub run_pseudo_cron {\n\n    my $self = shift;\n\n    #\treturn\n    #\t\tif $DADA::Config::SCHEDULED_JOBS_OPTIONS->{run_at_teardown} != 1;\n\n    # should this be something that's forked?\n    my @lists = available_lists( -In_Order => 1 );\n\n    return\n      unless scalar @lists >= 1;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $lists[0] } );\n\n    my $scheduled_jobs_last_ran = $ls->param('scheduled_jobs_last_ran') || 0;\n    my $time                    = time;\n\tmy $seven_and_a_half        = int($scheduled_jobs_last_ran) + (( 7.5 * 60 )); \n\tmy $hour                    = int($scheduled_jobs_last_ran) + (( 60 * 60 )); \n\t\n    if ( (int($time) > $seven_and_a_half) || $scheduled_jobs_last_ran == 0 ) {\n        \n\t\t# This gets a little crazy in the logs: \n\t\t# warn 'running scheduled jobs at teardown @ ' . scalar( localtime() );\n\t\t\n\t\tif(int($time) > $hour ) { \n\t\t\twarn 'scheduled jobs haven\\'t run in over an hour (double-check that the cronjob is set!) - running now: ' . scalar( localtime() );\n\t\t}\n\t\t\n        $self->schedules({-at_teardown => 1});\n    }\n    else {\n        #...\n\t\t# warn 'no.';\n    }\n}\n\n\n\n\nsub yikes {\n\n    my $self  = shift;\n    my $error = shift;\n\n    warn $error;\n\n    my $TIME = scalar( localtime() );\n\n    $self->header_props( -status => '500' );\n\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Yikes! App/Server Problem!</h1>\n<p>We apologize, but the server encountered a problem when attempting to complete its task.</p> \n<p>More information about this error may be available in the <em>program's own error log</em>.</p> \n<p><a href=\"mailto:$ENV{SERVER_ADMIN}\">Contact the Server Admin</a></p>\n<p>Time of error: <strong>$TIME</strong></p> \t\n\n\n\n</div>\n</body> \n</html> \n};\n\n}\n\n\n\n\nsub status_405 {\n\n    my $self  = shift;\n    my $error = shift;\n\n    warn $error;\n\n    my $TIME = scalar( localtime() );\n\n    $self->header_props( -status => '500' );\n\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>405 Method Not Allowed</h1>\n<p>&nbsp;</p>\n<p>More information about this error may be available in the <em>program's own error log</em>.</p> \n<p><a href=\"mailto:$ENV{SERVER_ADMIN}\">Contact the Server Admin</a></p>\n<p>Time of error: <strong>$TIME</strong></p> \t\n\n\n\n</div>\n</body> \n</html> \n};\n\n}\n\n\nsub rate_limit_reached {\n\n    my $self = shift;\n    sleep(30);\n\t\n    $self->header_props( -status => '429' );\n\t\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Rate Limit Reached!</h1>\n<p>We apologize, but you have reached the limit of requests allowed. Please try again in a few minutes. \n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n</div>\n\n</body> \n</html> \n};\n\n}\n\nsub sql_connect_error {\n\n    my $self = shift;\n    sleep(5);\n\t\n    $self->header_props( -status => '503' );\t\n\t$self->header_add('Retry-After' => 3600);\n\t\n\t\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Error: SQL Server Connection</h1>\n<p>We apologize, there is a problem talking to the SQL Server.  \n\n<p>More information about this problem may be available in the <em>program's own error log</em>.</p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n</div>\n\n</body> \n</html> \n};\n\n}\n\n\nsub unknown_param { \n\n    my $self = shift;\n\tmy $rm   = shift; \n\t\n\twarn 'unknown param called: \"' \n\t. $rm \n\t. '\" REMOTE HOST: ' \n\t.  $ENV{'REMOTE_HOST'} \n\t. ' REMOTE_ADDR: ' \n\t. $ENV{'REMOTE_ADDR'}; \n\t\n    sleep(5);\n\t\n    $self->header_props( -status => '404' );\n\t\n    return qq{\n<html>\n<head></head>\n<body>\n<div style=\"padding:5px;border:3px dotted #ccc; font-family:helvetica; font-size:.7em; line-height:150%; width:600px;margin-left:auto;margin-right:auto;margin-top:100px;\">\n<img alt=\"Dada Mail\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAC\nWCAMAAAAL34HQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAxQTFRFCAgIXV\n1dp6en/f39XG2aJgAAAqpJREFUeNrs3OGO4yAMBOB0+/7vvFWRLMtjjAkEqDT5dddyy1fJNwSH7vU+8\nrrIWsX6+15k/TTr+l6v12s6jqxlrA/oUtdEHFm7WKXOyPotltZ8CmuijKw1LCks7ZiVFGQtYOlocF8n\n63CWZAGWkbxF1uGsYGEW1mBGkPUoyw13fJesY1k6GuKyWxoQZM0I9ya6t9TIeojV3KPWsqNwydrOisP\nduKWSPn+4l/tkTWc1w702Rm+QyNrIaoZ7HB/3GkxkzWVl2rW1lgRZJ7Ay4a6Lzx1G1kZWJtx18XVth8\noqrh+R6iffZE1hJcM9sxgj64KrTCf1R9YUVibcm9Ggb5qFheMxhsgaZwVLr2tyh5UBWiYv4mcoY8iax\ncr8nzcmd5ihaGLtB5I1yJK1sxkNGZOulQyrfAyyBll4jieYT48pk5lTlfqD6c0PWY+ycNZaN0EPKOML\nSGK9ycIP3MgtsjpTHnG1w3baoUsK+w7mmNeEOwiyOnc+meDQ9WFYZhssAl2R2Xt5snpYZv02/YKgIkv\ncByxcKrDmyJrIynTtyw/VT8Jilukc+TfcZC1hmfN2+q8Bq3yAaU9fyRpjmcR3tzqi1JVH1mks3KCaZq\nIkSNfXSMhaw9IpgEeZcQdF1oGs2taldivcdQaIrC2sN3yfGXdK+W/JkrWLFfeG+pYQss5gjVxk3WaZj\noNOcPf15ADsYtQmImucVfvVAKYb2OwbmplqveDgOTdZt1lB8z1o6WLX3sxE1kaWbqPXWLX2vXvjRdbT\nLHcCt27co1c4mKz1rGAC8wr+Agi3EN1FAlmNpZqsuyw32bEa8EGXW4LN2sKnLGTdY8Xh7tbN1bqSrOh\nZNVlpFpYOHkw3LPNPZBuD05C1niXvmeM4Zkwt94NmrjnpRdZcFvtbv8z6F2AA/5G8jEIpBJoAAAAASU\nVORK5CYII=\" style=\"float:left;padding:10px\"/></p>\n<h1>Unknown Flavor</h1>\n<p>We apologize, but the resource you're looking for does not exist.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n</div>\n\n</body> \n</html> \n};\n\n}\n\nsub default {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n    if ( DADA::App::Guts::install_dir_around() == 1 ) {\n        return user_error( { -error => 'install_dir_still_around' } );\n    }\n\n    # SQL backed working?\n    my $dbi_handle;\n    require DADA::App::DBIHandle;\n\n    $dbi_handle = DADA::App::DBIHandle->new;\n\t\n\tmy $dbi_handle_check = 1; \n    try {\n        $dbi_handle->dbh_obj;\n\t\t\n    } catch {\n\t\twarn $_; \n\t\t$dbi_handle_check = 0; \n    };\n\t\n\tif($dbi_handle_check == 0){ \n        return $self->sql_connect_error(); \n\t}\n\t\n    if ( DADA::App::Guts::SQL_check_setup() == 0 ) {\n        return user_error( { -error => 'bad_SQL_setup' } );\n    }\n    require DADA::MailingList::Settings;\n    my @available_lists;\n    try {\n        @available_lists = available_lists( -In_Order => 1 );\n    }\n    catch {\n        return user_error(\n            {\n                -error         => 'sql_connect_error',\n                -error_Message => $_\n            }\n        );\n    };\n\n    @available_lists = available_lists( -In_Order => 1 );\n\n    if (   ( $DADA::Config::DEFAULT_SCREEN ne '' )\n        && ( $q->param('flavor') ne 'default' )\n        && ( $#available_lists >= 0 ) )\n    {\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::DEFAULT_SCREEN );\n        return;\n    }\n\n    if ( !$available_lists[0] ) {\n        my $auth_state;\n        if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n            require DADA::Security::SimpleAuthStringState;\n            my $sast = DADA::Security::SimpleAuthStringState->new;\n            $auth_state = $sast->make_state;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'congrats_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    havent_agreed => (\n                        ( xss_filter( scalar $q->param('agree') ) eq 'no' )\n                        ? 1\n                        : 0\n                    ),\n                    auth_state => $auth_state,\n                },\n            }\n        );\n        return $scrn;\n    }\n\n    if (   $q->param('error_invalid_list') != 1\n        && ( !$c->profile_on )\n        && ( $c->is_cached('default.scrn') ) )\n    {\n        return $c->cached('default.scrn');\n    }\n\n    my $scrn = DADA::Template::Widgets::default_screen(\n        {\n            -email              => scalar $q->param('email'),\n            -list               => scalar $q->param('list'),\n            -error_invalid_list => scalar $q->param('error_invalid_list'),\n        }\n    );\n    if (  !$c->profile_on\n        && $available_lists[0]\n        && $q->param('error_invalid_list') != 1 )\n    {\n        $c->cache( 'default.scrn', \\$scrn );\n    }\n    return $scrn;\n\n}\n\nsub list_page {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\n    my $list = $q->param('list');\n    require DADA::MailingList::Settings;\n\n    if ( !defined( $q->param('email') )\n        && ( $q->param('error_no_email') != 1 ) )\n    {\n        if ( !$c->profile_on && $c->is_cached( 'list/' . $list . '.scrn' ) ) {\n            return $c->cached( 'list/' . $list . '.scrn' );\n        }\n    }\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $scrn = DADA::Template::Widgets::list_page(\n        -list           => $list,\n        -cgi_obj        => $q,\n        -email          => scalar $q->param('email'),\n        -error_no_email => scalar $q->param('error_no_email') || 0,\n    );\n    if (   !$c->profile_on\n        && !defined( $q->param('email') )\n        && ( $q->param('error_no_email') != 1 ) )\n    {\n        $c->cache( 'list/' . $list . '.scrn', \\$scrn );\n    }\n    return $scrn;\n\n}\n\n\nsub list_privacy_policy {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $list = $q->param('list');\n\t\n\t\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\t\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n\trequire DADA::MailingList::PrivacyPolicyManager;\n\tmy $ppm = DADA::MailingList::PrivacyPolicyManager->new; \n\tmy $pp_data = $ppm->latest_privacy_policy({-list => $list});\n\tif(!exists($pp_data->{privacy_policy})){ \n\t\tmy $new_pp_id = $ppm->add(\n\t\t\t{ \n\t\t\t\t-list           => $list, \n\t\t\t\t-privacy_policy => $ls->param('privacy_policy'), \n\t\t\t}\n\t\t); \n\t\t$pp_data = $ppm->latest_privacy_policy({-list => $list});\n\t}\n\tmy $saved_privacy_policy = $pp_data->{privacy_policy};\n\t$saved_privacy_policy = markdown_to_html({-str => $saved_privacy_policy});\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'list_privacy_policy.tmpl',\n            -expr           => 1,\n            -with           => 'list',\n\t\t\t-vars           => {\n\t\t\t\tprivacy_policy_date  => $pp_data->{timestamp},\n\t\t\t\tsaved_privacy_policy => $saved_privacy_policy, \n\t\t\t},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\nsub admin {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my @available_lists = available_lists();\n    if ( ( $#available_lists < 0 ) ) {\n        return $self->default();\n    }\n\n    if ( DADA::App::Guts::install_dir_around() == 1 ) {\n        return user_error( { -error => 'install_dir_still_around' } );\n    }\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'admin',\n      );\n\n    if ($checksout) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::DEFAULT_ADMIN_SCREEN );\n        return;\n    }\n    else {\n\n        my $login_widget = $q->param('login_widget') // $DADA::Config::LOGIN_WIDGET;\n\n        my $scrn = DADA::Template::Widgets::admin(\n            {\n                -cgi_obj => $q,\n                -vars    => {\n                    login_widget => $login_widget,\n                }\n            }\n        );\n\n        return $scrn;\n    }\n}\n\nsub sign_in {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( DADA::App::Guts::install_dir_around() == 1 ) {\n        return user_error( { -error => 'install_dir_still_around' } );\n    }\n\n    my $list                = $q->param('list');\n    my $list_password_reset = $q->param(\"list_password_reset\") || 0;\n    my $list_exists         = check_if_list_exists( -List => $list, );\n\n    if ( $list_exists >= 1 ) {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'sign_in',\n          );\n        if ( $checksout && $admin_list eq $list ) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::DEFAULT_ADMIN_SCREEN );\n        }\n        else {\n            my $auth_state;\n            if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n                require DADA::Security::SimpleAuthStringState;\n                my $sast = DADA::Security::SimpleAuthStringState->new;\n                $auth_state = $sast->make_state;\n            }\n\n            require DADA::MailingList::Settings;\n\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'list_login_form.tmpl',\n                    -expr           => 1,\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        flavor_sign_in      => 1,\n                        auth_state          => $auth_state,\n                        login_widget        => 'hidden_field',\n                        selected_list       => $list,\n                        list_password_reset => $list_password_reset,\n                    },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n\n        my $login_widget = $q->param('login_widget')\n          || $DADA::Config::LOGIN_WIDGET;\n        my $scrn = DADA::Template::Widgets::admin(\n            {\n                -cgi_obj => $q,\n                -vars    => {\n                    login_widget => $login_widget\n                },\n            }\n        );\n        return $scrn;\n    }\n\n}\n\n\nsub admin_menu_notifications { \n\n    my $self = shift;\n    my $q    = $self->query();\n\tmy $r = {}; \n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) = check_list_security( -cgi_obj => $q, );\n    if ($checksout) {\n\t\t$r->{drafts}                               = $self->admin_menu_drafts_notification(); \n\t\t$r->{sending_monitor}                      = $self->admin_menu_mailing_monitor_notification(); \n\t\t$r->{view_list}                            = $self->admin_menu_subscriber_count_notification(); \n\t\t$r->{change_info}                         = $self->admin_menu_change_info_notification();\n\t\t$r->{view_archive}                         = $self->admin_menu_archive_count_notification(); \n\t\t$r->{mail_sending_options}                 = $self->admin_menu_mail_sending_options_notification(); \n\t\t$r->{mailing_sending_mass_mailing_options} = $self->admin_menu_mailing_sending_mass_mailing_options_notification();\n\t\t$r->{email_themes}                         = $self->admin_menu_email_themes_notification();\n\t\t$r->{profile_fields}                       = $self->admin_menu_profiles_notification();\n\t\t$r->{bounce_handler}                       = $self->admin_menu_bounce_handler_notification();\n\t\t$r->{tracker}                              = $self->admin_menu_tracker_notification();\n\t\t$r->{bridge}                               = $self->admin_menu_bridge_notification();\n\n\t    require JSON;\n\t    my $json = JSON->new->allow_nonref;\n\t\n\t    my $headers = { -type => 'application/json', };\n\t    my $body = $json->encode( $r );\n\n\t    $self->header_props(%$headers);\n\n\t    return $body;\n\t}\n\telse { \n\t\treturn $error_msg;\n\t}\n\t\n}\nsub admin_menu_drafts_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::MessageDrafts;\n\n            my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n            my $num_drafts     = $d->count( { -role => 'draft' } );\n            my $num_stationery = $d->count( { -role => 'stationery' } );\n            my $num_shedules   = $d->count( { -role => 'schedule' } );\n\n            if (   $num_drafts > 0\n                || $num_stationery > 0\n                || $num_shedules > 0 )\n            {\n                return\n                    commify($num_drafts) . ','\n                  . commify($num_stationery) . ','\n                  . commify($num_shedules);\n            }\n        }\n    }\n    catch {\n        warn\n\"Problems filling out the 'Sending Monitor' admin menu item with interesting bits of information about the mailouts: $_\";\n    };\n\n}\n\nsub admin_menu_mailing_monitor_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n\n            my $list = $admin_list;\n            require DADA::Mail::MailOut;\n            my @mailouts =\n              DADA::Mail::MailOut::current_mailouts( { -list => $list } );\n            my $list_mailouts = $#mailouts + 1;\n\n            my (\n                $monitor_mailout_report, $total_mailouts,\n                $active_mailouts,        $paused_mailouts,\n                $queued_mailouts,        $inactive_mailouts\n              )\n              = DADA::Mail::MailOut::monitor_mailout(\n                {\n                    -verbose => 0,\n                    -list    => $list,\n                    -action  => 0,\n                }\n              );\n            return $list_mailouts . '/' . $total_mailouts;\n        }\n    }\n    catch {\n        warn\n\"Problems filling out the 'Sending Monitor' admin menu item with interesting bits of information about the mailouts: $_\";\n    };\n}\n\nsub admin_menu_subscriber_count_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Subscribers;\n            my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n            my $num = $lh->num_subscribers();\n            if ( $num > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0';\n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\n\nsub admin_menu_change_info_notification { \n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n            return $ls->param('list_owner_email') . ' / ' . $ls->param('admin_email');\n        }\n\t} catch { \n\t\n\t};\n} \n\nsub admin_menu_archive_count_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Archives;\n            my $lh = DADA::MailingList::Archives->new( { -list => $list } );\n            my $num = $lh->num_archives();\n            if ( $num > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0';\n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_mail_sending_options_notification {\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        my $rs = '';\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n            if ( $ls->param('sending_method') eq 'sendmail' ) {\n                $rs = 'sendmail';\n            }\n            elsif ( $ls->param('sending_method') eq 'smtp' ) {\n                $rs = 'SMTP';\n            }\n            elsif ( $ls->param('sending_method') eq 'amazon_ses' ) {\n                $rs = 'Amazon SES';\n            }\n        }\n        return $rs;\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_mailing_sending_mass_mailing_options_notification {\n    my $self = shift;\n    my $q    = $self->query();\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::Mail::MailOut;\n            my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n\t\t\t\n\t\t\t require DADA::MailingList::Settings; \n\t\t\t my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\t\t\n\t\t\t\n            my ( $batch_sending_enabled, $batch_size, $batch_wait ) = $mo->batch_params();\n            my $per_sec  = $batch_size / $batch_wait;\n            my $per_hour = int( $per_sec * 60 * 60 + .5 )\n              ; # DEV .5 is some sort of rounding thing (with int). That's wrong.\n\t\t\t  \n\t\t\tif(     $ls->param('sending_method') eq 'amazon_ses'\n\t\t\t\t&&  $ls->param('amazon_ses_auto_batch_settings') == 1\n\t\t\t\t&&  $batch_sending_enabled == 1\n\t\t\t){ \n\t\t\t\t\t\n\t\t\t\tmy $per_hour_thirded; \t\t\t\n\t\t\t\t$per_sec = ($batch_size / $batch_wait) - ($batch_size - $batch_wait);\n\t\t\t\t$per_hour = int( $per_sec * 60 * 60 + .5 );\n\n\t\t\t\t$per_hour_thirded = int(($per_hour * 3) + .5); \n\t\t\t\t$per_hour_thirded  = commify($per_hour_thirded);\n\t            $per_hour = commify($per_hour);\n\t\t\t\t\n\t\t\t\t return $per_hour . '/hr - ' . $per_hour_thirded . '/hr'; \n\t\t\t\t\n\t\t\t}\n\t\t\telse {  \n\t            if ( $batch_sending_enabled == 1 ) {\n\t                return commify($per_hour) . '/hr';\n\t            }\n\t            else {\n\t                return '';\n\t            }\t\t\t\n\t\t\t} \n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_profiles_notification { \n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            require DADA::ProfileFieldsManager;\n\t\t\tmy $fields = DADA::ProfileFieldsManager->new->fields;\n\t\t\tmy $num = scalar @$fields; \n            if ($num  > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0'; \n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_email_themes_notification {\n    my $self = shift;\n    my $q    = $self->query();\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\t\tmy $tn = $ls->param('email_theme_name') || 'default';\n\t\t\t$tn =~ s/_/ /g; \n\t\t\t$tn = join \" \", map {ucfirst} split \" \", $tn;\n\t\t\treturn $tn;\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\n\nsub admin_menu_bounce_handler_notification {\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        if ($checksout) {\n            my $list = $admin_list;\n            require DADA::App::BounceHandler::ScoreKeeper;\n            my $bsk =\n              DADA::App::BounceHandler::ScoreKeeper->new( { -list => $list } );\n            my $num = $bsk->num_scorecard_rows;\n            if ( $num > 0 ) {\n                return commify($num);\n            }\n\t\t\telse { \n\t\t\t\treturn '0'; \n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_tracker_notification {\n    my $self = shift;\n    my $q    = $self->query();\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        my $rs = '';\n        if ($checksout) {\n            require DADA::Logging::Clickthrough;\n            my $rd = DADA::Logging::Clickthrough->new({-list => $admin_list});\n            my ( $total, $msg_ids ) = $rd->get_all_mids; \n            if ( $total > 0 ) {\n                return commify($total);\n            }\n\t\t\telse { \n\t\t\t\treturn '0'; \n\t\t\t}\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\nsub admin_menu_bridge_notification {\n    my $self = shift;\n    my $q    = $self->query();\n    my $r;\n\n    try {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security( -cgi_obj => $q, );\n        my $rs = '';\n        if ($checksout) {\n\n            my $list = $admin_list;\n            require DADA::MailingList::Settings;\n            my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n            $r = $ls->param('discussion_pop_email');\n\n            if ( $ls->param('disable_discussion_sending') == 1 ) {\n                $r .= ' (disabled)';\n            }\n            return $r;\n        }\n    }\n    catch {\n        carp($_);\n        return '';\n    };\n}\n\n\nsub image_drag_and_drop {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $r = {};\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) {\n        $r = {\n            uploaded => 0,\n            error    => {\n                message => \"Permission Denied - security check failed!\",\n            }\n        };\n    }\n    else {\n\n\t\tmy $list = $admin_list; \n        my ( $status, $message, $filename, $width, $height ) =\n          $self->drag_and_drop_file_upload($list);\n\n        my $subfolder = 'files';\n        if ( $filename =~ m/\\.(jpg|jpeg|png|gif)$/ ) {\n            $subfolder = 'images';\n        }\n\n        # warn 'got back, ' . Dumper([$status, $message, $filename]);\n\n        if ( $status == 1 ) {\n\n            $r = {\n                uploaded => 1,\n                fileName => $filename,\n                url      => $DADA::Config::SUPPORT_FILES->{url}\n                  . '/file_uploads/'\n                  . $subfolder . '/'\n                  . $filename,\n            };\n\n            if ($message) {\n                $r->{error}->{message} = $message;\n            }\n            if ($width) {\n                $r->{width} = $width;\n            }\n            if ($height) {\n                $r->{height} = $height;\n            }\n\n        }\n        else {\n            $r = {\n                uploaded => 0,\n                error    => {\n                    message => $message\n                },\n            };\n\n        }\n    }\n\n    $self->header_props( -type => 'application/json' );\n\n    my $body = $json->encode($r);\n\n    # warn '$r' . Dumper($r);\n    # warn '$body' . $body;\n\n    return $body;\n\n}\n\nsub drag_and_drop_file_upload {\n\n    my $self = shift;\n\tmy $list = shift; \n    my $q    = $self->query();\n\n    my $fh = $q->upload('file_were_uploading');\n\t\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $message = undef;\n\n    my $filename = $q->param('file_were_uploading');\n\t   $filename = $filename;  #?\n\t   $filename =~ s!^.*(\\\\|\\/)!!;\n    \n\t\n\t#use Data::Dumper; \n\t#my %headers = map { $_ => $q->http($_) } $q->http();\n\t#for my $header ( keys %headers ) {\n\t#    warn \"$header: $headers{$header}\";\n\t#}\n\t#warn '$fh: ' . Dumper($fh);\n\t#warn 'uploadInfo' . Dumper($q->uploadInfo($fh)); \n\t#warn '$q' . Dumper($q);\n\t#warn '$filename: ' . $filename; \n\t\t\n    if ( !$filename ) {\n        return ( 0, 'No file name passed?', undef, undef, undef );\n    }\n\t\t\n\t# Bad Hombres:\n    my @bad_fn = qw(\n\t\texe com msi bat cgi pl \n\t\tphp phps phtml php3 php4 \n\t\tphp5 php6 py pyc pyo \n\t\tpcgi pcgi3 pcgi4 pcgi5 pchi6\n\t);\n\t\n\tmy $bad_fn = {}; \n\tfor(@bad_fn){$bad_fn->{'.' . $_} = 1};\n\tmy ($ext) = $filename =~ /(\\.[^.]+)$/;\n\t\t\n\tif(exists($bad_fn->{$ext})){ \n        return ( 0, 'Problems with the upload: unsupported file type', undef, undef, undef );\n\t}\n\n    my $subfolder = 'files';\n    if ( $filename =~ m/\\.(jpg|jpeg|png|gif)$/ ) {\n        $subfolder = 'images';\n    }\n\t\n\tcreate_dir($DADA::Config::SUPPORT_FILES->{dir} . '/' . 'file_uploads');\n\tmy $upload_dir = make_safer($DADA::Config::SUPPORT_FILES->{dir} . '/' . 'file_uploads' . '/' . $subfolder);\n\tcreate_dir($upload_dir);\n\n\tmy $save_fp = new_image_file_path($filename, $upload_dir);\n\t\n\t\n    open( OUTFILE, '>', $save_fp )\n      or die( \"can't write to \" . $save_fp . \": $!\" );\n\n    while ( my $bytesread = read( $fh, my $buffer, 1024 ) ) {\n        print OUTFILE $buffer \n\t\t\tor die $!;\n    }\n    close(OUTFILE) \n\t\tor die $!;\n    chmod( $DADA::Config::FILE_CHMOD, $save_fp );\n\n    if ( $filename =~ m/\\.(jpg|jpeg|png|gif)$/ ) {\n\t\tif($ls->param('resize_drag_and_drop_images') == 1){\n\t\t\trequire DADA::App::ResizeImages; \t\t\t\t\n\t\t\tmy ($rs_status, $rs_path, $rs_width, $rs_height) = DADA::App::ResizeImages::resize_image(\n\t\t\t\t{ \n\t\t\t\t\t-width          => $ls->param('email_image_width_limit'), \n\t\t\t\t\t-file_path      => $save_fp, \n\t\t\t\t}\t\n\t\t\t);\n\n            $message = 'Image resized and saved at, ' . $rs_path;\n\t\t\t\n\t\t\tmy ($n_filepath, $n_filename) = path_and_file($rs_path);\t\t\t\t\n\t\t\t\n\t\t\t$n_filename = uriescape($n_filename);\n\t\t\t\n            return ( 1, $message, $n_filename, $rs_width, $rs_height );\t\n        } \n\t\telse { \n\t\t\n\t\t\t# No Resize\n\t\t\t$filename = uriescape($filename);\n\t        return ( 1, $message, $filename );\n\t\t}\n\t}\n\telse { \n\t\t$filename = uriescape($filename);\n        return ( 0, 'Problems with the upload: unsupported file type', undef, undef, undef );\n\t}\n}\n\n\n\n\nsub no_draft_available { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\t\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'no_draft_available.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                screen                  => 'no_draft_available',\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n}\n\n\nsub email_message_preview {\n\n#\twarn 'email_message_preview';\n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n\trequire DADA::MailingList::Settings;\n\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\n    require DADA::ProfileFieldsManager;\n    my $pfm               = DADA::ProfileFieldsManager->new;\n    my $fields_attr       = $pfm->get_all_field_attributes;\n    my $subscriber_fields = $pfm->fields;\n\n\t# This should really be set to whatever the test email is set to... \n    my $fake_sub_info = { 'subscriber.email' => 'user@example.com', };\n    for (@$subscriber_fields) {\n        $fake_sub_info->{ 'subscriber.' . $_ } = $fields_attr->{$_}->{label},;\n    }\n\t\n\t# Other things need to be filled in, like the usubscription link \n\t# which, strangely, doesn't show up!? (expand macro tags, or something?)\n\n\tmy $fake_vars = {};\n    $fake_vars->{'list_unsubscribe_link'} = $DADA::Config::PROGRAM_URL . '/t/'  . 'CONFIRMATION_TOKEN' . '/';\n\t$fake_vars->{'sender.email'} = $ls->param('list_owner_email');\t\n\t\n\t\n\t$fake_vars->{message_id} = 'PREVIEW_MESSAGE_ID';\n\t\n\t\n\t# warn q{$fake_vars->{'list_unsubscribe_link'}} . $fake_vars->{'list_unsubscribe_link'}; \n\t\n\tmy $r  = {}; \n\tmy $vs = undef; \n\t\n\t\n\tmy $from_id = 1; \n\tmy $id               = $q->param('id') || undef;\n\tmy $email_theme_name = $q->param('email_theme_name') || undef;\n\t\n\tif(!defined($id) && defined($email_theme_name)) { \n\t\t$from_id = 0; \n\t}\n\telse { \n\t\t$from_id = 1; \n\t}\n\tif($from_id == 1){\n\t    \n\t\trequire DADA::App::EmailMessagePreview;\n\t    my $daemp = DADA::App::EmailMessagePreview->new;\n\t    $r     = $daemp->fetch( $id );\n\t}\n\telse { \n\t\trequire DADA::App::EmailThemes; \n\t\tmy $em = DADA::App::EmailThemes->new(\n\t\t\t{\n\t\t\t\t-list       => $list, \n\t\t\t\t-theme_name => $email_theme_name, \n\t\t\t}\n\t\t);\n\t\tmy $etp = $em->fetch('preview'); \n\t\t$r = { \n\t\t\tvars => {Subject => 'Preview Subject', 'X-Preheader' => 'Preview Preheader'},\n\t\t\thtml => $etp->{html},\n\t\t}\n\t}\n\t\n\t$vs = $r->{vars}->{Subject};\n\t\n\tmy $status = 1; \n\tmy $errors = undef; \n\t\n\tmy $subject = undef; \n\ttry {\n\t    $subject = DADA::Template::Widgets::screen(\n\t        {\n\t            -data                     => \\$vs,\n\t            -expr                     => 1,\n\t            -vars                     => {%$fake_sub_info, %$fake_vars},\n\t            -list_settings_vars_param => {\n\t                -list   => $list,\n\t                -dot_it => 1,\n\t            },\n\t        }\n\t    );\n\t} catch { \n\t\t$status = 0; \n\t\t$errors .= $_; \n\t};\n\t\n    $fake_sub_info->{'email.subject'}   = $subject;\n    $fake_sub_info->{'email.preheader'} = $r->{vars}->{'X-Preheader'};\n\t\n\t\n\tmy $scrn = undef; \n\tmy $msg  = $r->{html};\n\tmy $returning_plaintext = 0; \n\t\n\tif(length($msg) <= 0) {\n\t\t$msg = $r->{plaintext};\n\t\t$returning_plaintext = 1; \n\t}\n\t\n\ttry {\n\t    $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -data                     => \\$msg, \n\t            -expr                     => 1,\n\t            -vars                     => {%$fake_sub_info, %$fake_vars},\n\t            -list_settings_vars_param => {\n\t                -list   => $list,\n\t                -dot_it => 1,\n\t            },\t\n\t\t\t\t(($returning_plaintext == 0) ? (\n                -webify_these => [\n                    qw(\n                      list_settings.info\n                      list_settings.privacy_policy\n                      list_settings.physical_address\n                      )\n                ],) : () )\n\t        }\n\t    );\n\t} catch { \n\t\t$status = 0; \n\t\t$errors .= $_; \n\t};\n\tif($returning_plaintext == 1){ \n\t\t$self->header_props(-type => 'text/plain');\n\t}\n\n\tif($status == 1){\n\t\treturn $scrn;\n\t}\n\telse { \n\t\treturn $errors; \n\t}\n}\n\nsub send_email_button_widget {\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    my $draft_role      = $q->param('draft_role')      || 'draft';\n    my $archive_no_send = $q->param('archive_no_send') || 0;\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'send_email_button_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                draft_role      => $draft_role,\n                archive_no_send => $archive_no_send,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\nsub mass_mailing_schedules_preview {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    my $errors = {};\n    my $status = 1;\n\n    my $schedule_activated = $q->param('schedule_activated') || 0;\n    my $schedule_type      = $q->param('schedule_type')      || undef;\n\n    my $schedule_single_displaydatetime = undef;\n    my $schedule_single_ctime           = undef;\n\n    if ( $schedule_type eq 'single' ) {\n        $schedule_single_displaydatetime =\n          $q->param('schedule_single_displaydatetime') || undef;\n        if ( !$schedule_single_displaydatetime ) {\n            $status = 0;\n            $errors->{missing_information};\n        }\n\n  # warn '$schedule_single_displaydatetime ' . $schedule_single_displaydatetime;\n        $schedule_single_ctime =\n          displaytime_to_ctime($schedule_single_displaydatetime);\n    }\n\n    my $day_set = undef;\n    my $dates   = [];\n    my $errors  = undef;\n\n    my $start = undef;\n    my $end   = undef;\n\n    my $rd   = [];\n    my $days = {\n        7 => 'Sunday',\n        1 => 'Monday',\n        2 => 'Tuesday',\n        3 => 'Wednesday',\n        4 => 'Thursday',\n        5 => 'Friday',\n        6 => 'Saturday',\n    };\n\n    my $schedule_recurring_displaydatetime_start = undef;\n    my $schedule_recurring_displaydatetime_end   = undef;\n    my $schedule_recurring_ctime_start           = undef;\n    my $schedule_recurring_ctime_end             = undef;\n    my $schedule_recurring_display_hms           = undef;\n    my $schedule_recurring_hms                   = undef;\n    my @schedule_recurring_days                  = undef;\n\n    if ( $schedule_type eq 'recurring' ) {\n\n        $schedule_recurring_displaydatetime_start =\n          $q->param('schedule_recurring_displaydatetime_start') || undef;\n        $schedule_recurring_displaydatetime_end =\n          $q->param('schedule_recurring_displaydatetime_end') || undef;\n        $schedule_recurring_display_hms =\n          $q->param('schedule_recurring_display_hms') || undef;\n        $schedule_recurring_ctime_start =\n          displaytime_to_ctime($schedule_recurring_displaydatetime_start);\n        $schedule_recurring_ctime_end =\n          displaytime_to_ctime($schedule_recurring_displaydatetime_end);\n        @schedule_recurring_days = $q->multi_param('schedule_recurring_days');\n        $schedule_recurring_hms =\n          display_hms_to_hms($schedule_recurring_display_hms);\n\n        if ( !( scalar DADA::App::Guts::can_use_datetime() ) ) {\n            $status = 0;\n            $errors->{datetime} = 1;\n        }\n        elsif (\n            $schedule_recurring_ctime_start > $schedule_recurring_ctime_end )\n        {\n            $status = 0;\n            $errors->{schedule_recurring_dates_wrong} = 1;\n        }\n        elsif (!$schedule_recurring_displaydatetime_start\n            || !$schedule_recurring_displaydatetime_start\n            || !$schedule_recurring_display_hms\n            || ( scalar @schedule_recurring_days <= 0 ) )\n        {\n            $status = 0;\n            $errors->{missing_information} = 1;\n        }\n        else {\n\n            for (@schedule_recurring_days) {\n                push(\n                    @$rd,\n                    {\n                        day  => $_,\n                        name => $days->{$_},\n                    }\n                );\n            }\n            $schedule_recurring_ctime_start += $schedule_recurring_hms;\n            $schedule_recurring_ctime_end   += $schedule_recurring_hms;\n\n            try {\n                require DateTime;\n                require DateTime::Event::Recurrence;\n                $start =\n                  DateTime->from_epoch(\n                    epoch => $schedule_recurring_ctime_start );\n                $end =\n                  DateTime->from_epoch(\n                    epoch => $schedule_recurring_ctime_end );\n            }\n            catch {\n                warn $_;\n                $errors .= $_;\n            };\n            my ( $hours, $minutes, $seconds ) =\n              split( ':', $schedule_recurring_display_hms );\n        }\n    }\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'mass_mailing_schedules_preview.tmpl',\n            -expr   => 1,\n            -vars   => {\n                status => $status,\n\n                #   errors                             => $errors,\n                schedule_activated => $schedule_activated,\n                schedule_type      => $schedule_type,\n\n                schedule_single_ctime => $schedule_single_ctime,\n                schedule_single_localtime =>\n                  ctime_to_localtime($schedule_single_ctime),\n                schedule_single_displaydatetime =>\n                  $schedule_single_displaydatetime,\n\n                schedule_recurring_hms => $schedule_recurring_hms,\n                schedule_recurring_display_hms =>\n                  $schedule_recurring_display_hms,\n\n                schedule_recurring_displaydatetime_start =>\n                  $schedule_recurring_displaydatetime_start,\n                schedule_recurring_displaydatetime_end =>\n                  $schedule_recurring_displaydatetime_end,\n\n                schedule_recurring_localtime_start =>\n                  ctime_to_localtime($schedule_recurring_ctime_start),\n                schedule_recurring_localtime_end =>\n                  ctime_to_localtime($schedule_recurring_ctime_end),\n\n                schedule_recurring_days => $rd,\n                num_recurring_days      => scalar @$rd,\n\n                #  dates                              => $dates,\n\n                schedule_last_checked_ago => formatted_runtime(\n                    time - $ls->param('schedule_last_checked_time')\n                ),\n\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub mass_mailing_schedules_preview_calendar {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\tmy $draft_id = $q->param('draft_id');\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\t\n    my $list = $admin_list;\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'mass_mailing_schedules_preview_calendar.tmpl',\n            -expr   => 1,\n            -vars   => {\n                draft_id => $draft_id,\n            }\n        }\n    );\n    return $scrn;\n}\n\nsub mass_mailing_schedules_preview_calendar_json {\n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n\tmy $draft_id = $q->param('draft_id');\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\t\n    my $list = $admin_list;\n\t#warn '$list: ' .  $list; \n\n\t\n\trequire DADA::MailingList::MessageDrafts; \n\tmy $dmlmd = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n    my $q_draft = $dmlmd->fetch(\n        {\n            -id     => $draft_id,\n            -role   => 'schedule',\n        }\n    );\n\t\n\trequire DADA::MailingList::Schedules; \n\tmy $dmls = DADA::MailingList::Schedules->new({-list => $list});\n\tmy $json = $dmls->recurring_schedule_times_json({ \t\n\t    -recurring_time => $q_draft->param('schedule_recurring_display_hms'),\n\t\t-weeks          => [$q_draft->multi_param('schedule_recurring_weeks')],\n\t    -days           => [$q_draft->multi_param('schedule_recurring_days')],\n\t    -start          => $q_draft->param('schedule_recurring_ctime_start'),\n\t    -end            => $q_draft->param('schedule_recurring_ctime_end'),\n\t}); \n\t\n    my $headers = { -type => 'application/json', };\n\t$self->header_props(%$headers);\n\treturn $json; \n\t\n}\n\nsub draft_message_values {\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n\n    my ( $headers, $body ) = $ms->draft_message_values(\n        {\n            -cgi_obj => $q,\n        }\n    );\n\n    #    require Data::Dumper;\n    #    warn Data::Dumper::Dumper(\n    #        {\n    #            headers => $headers,\n    #            body    => $body,\n    #        }\n    #    );\n    if ( keys %$headers ) {\n        $self->header_props(%$headers);\n    }\n    return $body;\n\n}\n\nsub datetime_to_ctime {\n    my $datetime = shift;\n\n    #    warn '$datetime ' . $datetime;\n    require Time::Local;\n    my ( $date, $time ) = split( ' ', $datetime );\n    my ( $year, $month,  $day )    = split( '-', $date );\n    my ( $hour, $minute, $second ) = split( ':', $time );\n    $second = int( $second - 0.5 );    # no idea.\n    my $time =\n      Time::Local::timelocal( $second, $minute, $hour, $day, $month - 1,\n        $year );\n\n    return $time;\n}\n\nsub datetime_to_localtime {\n    my $datetime = shift;\n    my $time     = datetime_to_ctime($datetime);\n    return scalar( localtime($time) );\n}\n\nsub ckeditor_template_tag_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    my $strings = [];\n\n    require DADA::ProfileFieldsManager;\n    my $pfm         = DADA::ProfileFieldsManager->new;\n    my $fields_attr = $pfm->get_all_field_attributes;\n\n    push( @$strings, { name => 'Profile Fields', } );\n    push(\n        @$strings,\n        {\n            name  => 'Email Address',\n            value => '<!-- tmpl_var subscriber.email -->',\n        }\n    );\n    push(\n        @$strings,\n        {\n            name  => 'Email Name',\n            value => '<!-- tmpl_var subscriber.email_name -->',\n        }\n    );\n\n    push(\n        @$strings,\n        {\n            name  => 'Email Domain',\n            value => '<!-- tmpl_var subscriber.email_domain -->',\n        }\n    );\n\n    foreach my $field ( @{ $pfm->fields } ) {\n        push(\n            @$strings,\n            {\n                name  => $fields_attr->{$field}->{label},\n                value => '<!-- tmpl_var subscriber.' . $field . ' -->',\n            }\n        );\n    }\n\n    my $settings = [\n        {\n            name => 'List Settings'\n        },\n        {\n            name  => 'List Name',\n            value => '<!-- tmpl_var list_settings.list_name -->',\n        },\n        {\n            name  => 'List Owner Email Address',\n            value => '<!-- tmpl_var list_settings.list_owner_email -->',\n        },\n        {\n            name  => 'Mailing List Description',\n            value => '<!-- tmpl_var list_settings.info -->',\n        },\n        {\n            name  => 'Mailing List Privacy Policy',\n            value => '<!-- tmpl_var list_settings.privacy_policy -->',\n        },\n        {\n            name  => 'Physical Address',\n            value => '<!-- tmpl_var list_settings.physical_address -->',\n        },\n    ];\n    push( @$strings, @$settings );\n\n    push( @$strings, { name => 'Loops/Conditionals', } );\n    push(\n        @$strings,\n        {\n            name  => 'loop...',\n            value => '<!-- tmpl_loop field_name --><!-- /tmpl_loop -->',\n        }\n    );\n    push(\n        @$strings,\n        {\n            name  => 'if...',\n            value => '<!-- tmpl_if field_name --><!-- /tmpl_if -->',\n        }\n    );\n    push(\n        @$strings,\n        {\n            name  => 'unless...',\n            value => '<!-- tmpl_unless field_name --><!-- /tmpl_unless -->',\n        }\n    );\n\n    my $headers = { -type => 'application/json', };\n    my $body = $json->encode( { strings => $strings } );\n\n    $self->header_props(%$headers);\n\n    return $body;\n\n}\n\nsub draft_saved_notification {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $role = $q->param('role');\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'draft_saved_notification_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                role => $role,\n            }\n        }\n    );\n    return $scrn;\n}\n\nsub drafts {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'drafts'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\n    my $delete_draft = $q->param('delete_draft') || 0;\n\n    require DADA::MailingList::MessageDrafts;\n    my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n\n    my $di  = [];\n    my $si  = [];\n    my $sci = [];\n\n    $di  = $d->draft_index( { -role => 'draft' } );\n    $si  = $d->draft_index( { -role => 'stationery' } );\n    $sci = $d->draft_index( { -role => 'schedule' } );\n\n    #use Data::Dumper;\n    #return '<pre>' . Data::Dumper::Dumper($sci);\n\n    my $sci_active   = [];\n    my $sci_inactive = [];\n    for (@$sci) {\n        if ( $_->{schedule_activated} == 1 ) {\n            push( @$sci_active, $_ );\n        }\n        else {\n            push( @$sci_inactive, $_ );\n        }\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'drafts.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -expr => 1,\n            -vars => {\n                screen                  => 'drafts',\n                delete_draft            => $delete_draft,\n                draft_index             => $di,\n                stationery_index        => $si,\n                active_schedule_index   => $sci_active,\n                inactive_schedule_index => $sci_inactive,\n                num_drafts              => scalar(@$di),\n                num_stationery          => scalar(@$si),\n                num_schedules           => scalar(@$sci),\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\nsub preview_draft { \n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'drafts'\n      );\n    if ( !$checksout ) { return $error_msg; }\n    my $list = $admin_list;\n\t\n\t\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n    \n\ttry {\n\t\tmy $r = $ms->preview_draft(\n\t        {\n\t            -cgi_obj     => $q,\n\t        }\n\t    );\n\t\n\t\tif($r->{status} == 0){\n\t\t\t$self->header_props(-type => 'text/html');\n\t\t\treturn \"<p><strong>Problems with creating preview:</strong></p><pre> \" . $r->{errors} . '</pre>';\n\t\t}\n\t\telsif($r->{status} == 1){ \n\t\t\t$q->param('id', $r->{id});\n\t\t\t$q->param('flavor', 'email_message_preview');\n\t\t\treturn $self->email_message_preview(); \n\t\t}\n\t}\n\tcatch { \n\t\t$self->header_props(-type => 'text/plain');\n\t\treturn \"Problems creating preview: $_\";\n\t};\n}\n\n\n\nsub delete_drafts {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my @draft_ids = $q->multi_param('draft_ids');\n\n    require DADA::MailingList::MessageDrafts;\n    my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n\n    foreach my $id (@draft_ids) {\n        $d->remove($id);\n    }\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor=drafts&delete_draft=1' );\n\n}\n\nsub create_from_stationery {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list     = $admin_list;\n    my $draft_id = $q->param('draft_id');\n    my $screen   = $q->param('screen');\n\n    require DADA::MailingList::MessageDrafts;\n    my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n    my $new_id =\n      $d->create_from_stationery( { -id => $draft_id, -screen => $screen } );\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor='\n          . $screen\n          . '&draft_id='\n          . $new_id );\n\n}\n\n#sub message_body_help {\n#\n#    my $self = shift;\n#    my $q    = $self->query();\n#\n#    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n#      check_list_security( -cgi_obj => $q, );\n#    if ( !$checksout ) { return $error_msg; }\n#\n#    my $body = DADA::Template::Widgets::screen(\n#        { -screen => 'send_email_message_body_help_widget.tmpl', } );\n#    return $body;\n# }\n#sub url_message_body_help {\n#\n#    my $self = shift;\n#    my $q    = $self->query();\n#\n#    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n#      check_list_security( -cgi_obj => $q );\n#    if ( !$checksout ) { return $error_msg; }\n#    return (\n#        {},\n#        DADA::Template::Widgets::screen(\n#            { -screen => 'send_url_email_message_body_help_widget.tmpl', }\n#        )\n#    );\n#}\n\nsub preview_message_receivers {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $r;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security( -cgi_obj => $q, );\n    if ( !$checksout ) { return $error_msg; }\n\n    require DADA::MailingList::Settings;\n    my $list   = $admin_list;\n    my $lh     = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $fields = [];\n\n    # Extra, special one...\n    push( @$fields, { name => 'subscriber.email' } );\n    for my $field ( @{ $lh->subscriber_fields( { -dotted => 1 } ) } ) {\n        push( @$fields, { name => $field } );\n    }\n    my $naked_fields = $lh->subscriber_fields( { -dotted => 0 } );\n    my $undotted_fields = [];\n\n    # Extra, special one...\n    push( @$undotted_fields, { name => 'email', label => 'Email Address' } );\n    for my $undotted_field ( @{$naked_fields} ) {\n        push( @$undotted_fields, { name => $undotted_field } );\n    }\n\n    my $partial_sending = partial_sending_query_to_params( $q, $naked_fields );\n\n    my $order_by  = 'email';\n    my $order_dir = 'desc';\n\n    if ( exists( $partial_sending->{'subscriber.timestamp'}->{-value} ) ) {\n        $order_by  => 'timestamp';\n        $order_dir => 'desc';\n    }\n    my ( $fancy_r, $fancy_c );\n\n    if ( keys %$partial_sending ) {\n        ( $fancy_r, $fancy_c ) = $lh->fancy_list(\n            {\n                -partial_listing       => $partial_sending,\n                -type                  => 'list',\n                -show_list_column      => 1,\n                -show_timestamp_column => 1,\n                -order_by              => $order_by,\n                -order_dir             => $order_dir,\n            }\n        );\n        $r .= $fancy_r;\n    }\n    else {\n        \n        $r .= $q->p(\n            $q->em(\n                    'All '\n                  . $q->strong( commify( $lh->num_subscribers ) )\n                  . ' Subscribers of your mailing list will receive this message.'\n            )\n        );\n    \n    }\n    return $r;\n\n}\n\nsub sending_monitor_index {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'sending_monitor'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $mailout_status = [];\n    my @lists;\n\n    # If we're logged in as dada root, we see all the mass mailings going on.\n    if ( $root_login == 1 ) {\n        @lists = available_lists();\n    }\n    else {\n        # If not, only the current list.\n        @lists = ($list);\n    }\n\n    for my $l_list (@lists) {\n        my @mailouts = DADA::Mail::MailOut::current_mailouts(\n            {\n                -list     => $l_list,\n                -order_by => 'creation',\n            }\n        );\n        for my $mo (@mailouts) {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $l_list } );\n            $mailout->associate( $mo->{id}, $mo->{type} );\n            my $status = $mailout->status();\n            require DADA::MailingList::Settings;\n            my $l_ls = DADA::MailingList::Settings->new( { -list => $l_list } );\n            push(\n                @$mailout_status,\n                {\n                    %$status,\n                    list          => $l_list,\n                    current_list  => ( ( $list eq $l_list ) ? 1 : 0 ),\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL,\n                    Subject =>\n                      safely_decode( $status->{email_fields}->{Subject}, 1 ),\n                    status_bar_width => int( $status->{percent_done} ) * 1,\n                    negative_status_bar_width => 100 -\n                      ( int( $status->{percent_done} ) * 1 ),\n                    message_id   => $mo->{id},\n                    message_type => $mo->{type},\n                    mailing_started =>\n                      scalar( localtime( $status->{first_access} ) ),\n                    mailout_stale => $status->{mailout_stale},\n                    %{ $l_ls->params },\n                }\n            );\n        }\n    }\n\n    my (\n        $monitor_mailout_report, $total_mailouts,  $active_mailouts,\n        $paused_mailouts,        $queued_mailouts, $inactive_mailouts\n      )\n      = DADA::Mail::MailOut::monitor_mailout(\n        {\n            -verbose => 0,\n            ( $root_login == 1 ) ? () : ( -list => $list )\n        }\n      );\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'sending_monitor_index_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                screen                 => 'sending_monitor',\n                killed_it              => scalar $q->param('killed_it') ? 1 : 0,\n                mailout_status         => $mailout_status,\n                monitor_mailout_report => $monitor_mailout_report,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub sending_monitor {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'sending_monitor'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    require DADA::MailingList::Settings;\n    require DADA::Mail::MailOut;\n\n    my $list = $admin_list;\n\n    my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n    my ( $batching_enabled, $batch_size, $batch_wait ) = $mo->batch_params;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    # munging the message id.\n    # kinda dumb, but it's sort of up in the air,\n    # on how the message id comes to us,\n    # so we have to be *real* careful to get it to a state\n    # that we *need* it in.\n\n    my $id = DADA::App::Guts::strip( scalar $q->param('id') );\n    $id =~ s/\\@/_at_/g;\n    $id =~ s/\\>|\\<//g;\n\n    if ( !$q->param('id') ) {\n        return $self->sending_monitor_index();\n    }\n\t\n\tmy $draft_id = $q->param('draft_id');\n\t# warn '$draft_id: ' . $draft_id; \n\t\n\t\n\t\n\t\n    # 10 is the factory default setting to wait per batch.\n    # Let's not refresh an faster, or we'll never have time\n    # to read the actual screen.\n\n    my $refresh_after = 10;\n    if ( $refresh_after < $batch_wait ) {\n        $refresh_after = $batch_wait;\n    }\n\n    # Type ala, list, invitation list, etc\n    my $type = $q->param('type');\n    $type = xss_filter( DADA::App::Guts::strip($type) );\n\t# warn '$type: '  . $type; \n\n\n    my $restart_count = $q->param('restart_count') || 0;\n\n    require DADA::Mail::Send;\n    my $mh = DADA::Mail::Send->new(\n        {\n            -list   => $list,\n            -ls_obj => $ls,\n        }\n    );\n\n    my $auto_pickup = 0;\n\n    # Kill - the, [Stop] button was pressed. Pressed really hard.\n\n    if ( $q->param('process') eq 'kill' ) {\n\n        if ( DADA::Mail::MailOut::mailout_exists( $list, $id, $type ) == 1 ) {\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $mailout->clean_up;\n        }\n        else {\n            warn \"mailout $id does NOT exists! What's going on?!\";\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( \n\t\t\t-url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&killed_it=1' \n\t\t\t  . '&draft_id=' . $draft_id\n\t\t\t  );\n\n    }\n    elsif ( $q->param('process') eq 'pause' ) {\n\n        if ( DADA::Mail::MailOut::mailout_exists( $list, $id, $type ) == 1 ) {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $mailout->pause();\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=sending_monitor&id='\n                  . $id\n                  . '&type='\n                  . $type\n                  . '&paused_it=1'\n\t\t\t\t  . '&draft_id=' . $draft_id\n\t\t\t);\n        }\n        else {\n            die \"mass mailing does NOT exists! What's going on?!\";\n        }\n\n    }\n    elsif ( $q->param('process') eq 'resume' ) {\n\n        if ( DADA::Mail::MailOut::mailout_exists( $list, $id, $type ) == 1 ) {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $mailout->resume();\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=sending_monitor&id='\n                  . $id\n                  . '&type='\n                  . $type\n                  . '&resume_it=1'\n\t\t\t\t  . '&draft_id=' . $draft_id\n\t\t\t );\n\n        }\n        else {\n\n            die \"mass mailing does NOT exists! What's going on?!\";\n\n        }\n\n# Restart is usually called by the program itself, automagically via a redirect if DADA::Mail::MailOut says we should restart.\n    }\n    elsif ( $q->param('process') eq 'restart' ) {\n\n        my $restart_time = 1;\n\n        # Let's make sure that restart worked...\n        my $should_be_restarted = 0;\n        eval {\n\n            my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $should_be_restarted = $mailout->should_be_restarted;\n            if ( $should_be_restarted == 1 ) {\n                $mh->restart_mass_send( $id, $type );\n                sleep(5);\n            }\n        };\n\n        my $refresh_url;\n        if ( $should_be_restarted == 1 ) {\n            $refresh_url =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&id='\n              . $id\n              . '&type='\n              . $type\n              . ' &restart_count='\n              . $restart_count\n\t\t\t  . '&draft_id=' . $draft_id; \n        }\n        else {\n            $refresh_url =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&id='\n              . $id\n              . '&type='\n              . $type\n\t\t\t  . '&draft_id=' . $draft_id; \n        }\n        my $r = \"<html>\n                <head>\n\n                 <script type=\\\"text/javascript\\\">\n\n                 function refreshpage(sec) {\n\t\t\t\t\tvar refreshafter = sec/1 * 1000;\n\t\t\t\t\tsetTimeout(function() {\t\t\t\t\n\t\t\t\t\t\twindow.location.replace('$refresh_url')\n\t\t\t\t\t},\n\t\t\t\t\trefreshafter);\n                }\n\n\t\t        refreshpage(5);\n\t\t\t\t\n                </script>\n\n\n                 </head>\n                 <body>\n                 \";\n        return ( {}, $r );\n\n        # If not...\n        if ($@) {\n            my $r = \"<h1>Problems Reloading!:</h1><pre>$@</pre>\";\n\n            # We're going to refresh, see if it gets better.\n            $restart_time = 5;\n        }\n\n        if ( $should_be_restarted == 1 ) {\n\n            # Provide a link in case browser redirect is working\n            warn 'Reloading Message from Mailing Monitor';\n            $r .= '<a href=\"' . $refresh_url . '\">Reloading Mailing...</a>';\n        }\n        else {\n            warn 'Refreshing Screen from Mailing Monitor';\n            $r .= '<a href=\"' . $refresh_url . '\">Refreshing Screen....</a>';\n        }\n        $r .= \"\n\n        <script type=\\\"text/javascript\\\">\n        refreshpage($restart_time);\n        </script>\n        </body>\n       </html>\";\n\n        return ( {}, $r );\n    }\n    elsif ( $q->param('process') eq 'ajax' ) {\n\n        my $mailout                = undef;\n        my $status                 = {};\n        my $mailout_exists         = 0;\n        my $mailout_exists         = 0;\n        my $my_test_mailout_exists = 0;\n        eval {\n            $my_test_mailout_exists =\n              DADA::Mail::MailOut::mailout_exists( $list, $id, $type );\n        };\n\n        if ( !$@ ) {\n            $mailout_exists = $my_test_mailout_exists;\n        }\n\t\t\n\t\t# warn '$mailout_exists: ' . $mailout_exists; \n\t\t\n        if ($mailout_exists) {\n\t\t\t\n            $mailout_exists = 1;\n            $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n            $mailout->associate( $id, $type );\n            $status = $mailout->status();\n\t\t\t\n\t\t\t# require Data::Dumper; \n\t\t\t#warn 'status: ' . Data::Dumper::Dumper($status);\n\n        }\n        else {\n\t\t\t# warn 'nope.';\n            # Nothing - I believe this is handled in the template.\n\n        }\n\n        my (\n            $monitor_mailout_report, $total_mailouts,\n            $active_mailouts,        $paused_mailouts,\n            $queued_mailouts,        $inactive_mailouts\n          )\n          = DADA::Mail::MailOut::monitor_mailout(\n            {\n                -verbose => 0,\n                -list    => $list\n            }\n          );\n\n       #warn '$status->{should_be_restarted} ' . $status->{should_be_restarted};\n       #warn q{$ls->param('auto_pickup_dropped_mailings') }\n       #  . $ls->param('auto_pickup_dropped_mailings');\n       #warn '$restart_count' . $restart_count;\n       #warn '$status->{mailout_stale}' . $status->{mailout_stale};\n       #warn '$active_mailouts' . $active_mailouts;\n\n        if (\n            $status->{should_be_restarted} == 1 &&    # It's dead in the water.\n            $ls->param('auto_pickup_dropped_mailings') == 1\n            &&    # Auto Pickup is turned on...\n             # $status->{total_sending_out_num} - $status->{total_sent_out} >  0 && # There's more subscribers to send out to\n            $restart_count <= 0 &&    # We haven't *just* restarted this thing\n            $status->{mailout_stale} != 1\n            && # The mailout hasn't been sitting around too long without being restarted,\n            $active_mailouts <\n            $DADA::Config::MAILOUT_AT_ONCE_LIMIT # There's not already too many mailouts going out.\n          )\n        {\n\n            # warn \"Yes, we need to restart!\";\n\n   # Whew! Take that for making sure that the damn thing is supposed to be sent.\n\n            my $reload_url =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=sending_monitor&id='\n              . $id\n\t\t\t  . '&draft_id=' . $draft_id\n              . '&process=restart&type='\n              . $type\n              . '&restart_count=1';\n\n            my $r = \"<script type=\\\"text/javascript\\\"> \n\t\t\twindow.location.replace('$reload_url'); \n\t\t\t</script>\";\n            return ( {}, $r );\n        }\n        else {\n\n            # warn \"No, no need to restart.\";\n            $restart_count = 0;\n        }\n\n        my $sending_status = [];\n        for ( keys %$status ) {\n            next if $_ eq 'email_fields';\n            push( @$sending_status, { key => $_, value => $status->{$_} } );\n        }\n\n# If we're... say... 2x a batch setting and NOTHING has been sent,\n# let's say a mailing will be automatically started in... time since last - wait time.\n\n        my $will_restart_in = undef;\n\n        # $batch_wait\n        if ( time - $status->{last_access} > ( $batch_wait * 1.5 ) ) {\n            my $tardy_threshold = $batch_wait * 3;\n\n            if ( $tardy_threshold < 60 ) {\n                $tardy_threshold = 60;\n            }\n\n            $will_restart_in =\n              $tardy_threshold - ( time - $status->{last_access} );\n            if ( $will_restart_in >= 1 ) {\n                $will_restart_in = formatted_runtime($will_restart_in);\n            }\n            else {\n                $will_restart_in = undef;\n            }\n        }\n\n        my $hourly_rate = 0;\n        if ( $status->{mailing_time} > 0 ) {\n            $hourly_rate = commify(\n                int(\n                    ( $status->{total_sent_out} / $status->{mailing_time} ) *\n                      60 * 60 + .5\n                )\n            );\n        }\n\n        my $header_subject_label = DADA::Template::Widgets::screen(\n            {\n                -data => \\$status->{email_fields}->{Subject},\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n                -subscriber_vars_param => {\n                    -use_fallback_vars => 1,\n                    -list              => $list,\n                },\n                -decode_before => 1,\n            }\n        );\n\n       \n\t    # I can basically know if this is a test message if: \n\t\t# the draft is still around... \n\t\t\n\t\tmy $mass_mailing_has_draft = 0; \n\t\tmy $draft_url              = ''; \n\t\tif($draft_id){ \n            require DADA::MailingList::MessageDrafts;\n            my $d = DADA::MailingList::MessageDrafts->new( { -list => $list } );\n\t\t\tif($d->id_exists($draft_id)){ \n\t\t\t\tmy $q_draft = $d->fetch({-id => $draft_id});\n\t\t\t\t$mass_mailing_has_draft = 1; \n\t\t\t\t$draft_url = $DADA::Config::S_PROGRAM_URL \n\t\t\t\t. '?flavor=send_email'\n\t\t\t\t. '&draft_id='   . $draft_id\n\t\t\t\t. '&draft_role=' . $q_draft->param('_internal_draft_role');\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t    my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'sending_monitor_screen.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    screen                 => 'sending_monitor',\n                    mailout_exists         => $mailout_exists,\n                    message_id             => DADA::App::Guts::strip($id),\n\t\t\t\t\tdraft_id                    => $draft_id, \n\t\t\t\t\tmass_mailing_has_draft      => $mass_mailing_has_draft, \n\t\t\t\t\tdraft_url                   => $draft_url,    \n                    message_type           => scalar $q->param('type'),\n                    total_sent_out         => $status->{total_sent_out},\n                    total_sending_out_num  => $status->{total_sending_out_num},\n                    mailing_time           => $status->{mailing_time},\n                    mailing_time_formatted => $status->{mailing_time_formatted},\n                    hourly_rate            => $hourly_rate,\n                    percent_done           => $status->{percent_done},\n                    status_bar_width => int( $status->{percent_done} ) * 5,\n                    negative_status_bar_width => 500 -\n                      ( int( $status->{percent_done} ) * 5 ),\n                    need_to_send_out => (\n                        $status->{total_sending_out_num} -\n                          $status->{total_sent_out}\n                    ),\n                    time_since_last_sendout => formatted_runtime(\n                        ( time - int( $status->{last_sent} ) )\n                    ),\n                    its_killed => $status->{should_be_restarted},\n                    header_subject =>\n                      safely_decode( $status->{email_fields}->{Subject}, 1 ),\n                    header_subject_label =>\n                      ( length($header_subject_label) > 50 )\n                    ? ( substr( $header_subject_label, 0, 49 ) . '...' )\n                    : ($header_subject_label),\n                    auto_pickup_dropped_mailings =>\n                      $ls->param('auto_pickup_dropped_mailings'),\n                    sending_done => ( $status->{percent_done} < 100 ) ? 0 : 1,\n                    refresh_after  => $refresh_after,\n                    killed_it      => scalar $q->param('killed_it') ? 1 : 0,\n                    sending_status => $sending_status,\n                    is_paused      => $status->{paused} > 0 ? 1 : 0,\n                    paused         => $status->{paused},\n                    queue          => $status->{queue},\n                    queued_mailout => $status->{queued_mailout},\n                    queue_place    => ( $status->{queue_place} + 1 )\n                    ,    # adding one since humans like counting from, \"1\"\n                    queue_total => ( $status->{queue_total} + 1 )\n                    ,    # adding one since humans like counting from, \"1\"\n                    status_mailout_stale => $status->{mailout_stale},\n                    MAILOUT_AT_ONCE_LIMIT =>\n                      $DADA::Config::MAILOUT_AT_ONCE_LIMIT,\n                    will_restart_in => $will_restart_in,\n                    integrity_check => $status->{integrity_check},\n                },\n            }\n        );\n\n        return $scrn;\n    }\n    else {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'sending_monitor_container_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen        => 'sending_monitor',\n                    message_id    => DADA::App::Guts::strip($id),\n\t\t\t\t\tdraft_id      => $draft_id,\n                    message_type  => scalar $q->param('type'),\n                    refresh_after => $refresh_after,\n'list_settings.tracker_show_message_reports_in_mailing_monitor'\n                      => $ls->param(\n                        'tracker_show_message_reports_in_mailing_monitor'),\n                    list_type_isa_list => ( $q->param('type') eq 'list' )\n                    ? 1\n                    : 0,\n                }\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub print_mass_mailing_log {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'sending_monitor'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $id   = $q->param('id');\n    my $type = $q->param('type');\n\n    my $list = $admin_list;\n\n    require DADA::Mail::MailOut;\n    my $mailout = DADA::Mail::MailOut->new( { -list => $list } );\n    $mailout->associate( $id, $type );\n    $self->header_props( { -type => 'text/plain' } );\n    return $mailout->return_log;\n}\n\nsub send_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $Ext_Request = undef;\n    if ( defined( $self->param('Ext_Request') ) ) {\n        $Ext_Request = $self->param('Ext_Request');\n    }\n\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n    my ( $headers, $body ) = $ms->send_email(\n        {\n            -cgi_obj     => $q,\n            -Ext_Request => $Ext_Request,\n            -root_login  => $root_login,\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub list_invite {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'add'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::App::MassSend;\n    my $ms = DADA::App::MassSend->new( { -list => $list } );\n\n    my $Ext_Request = undef;\n    if ( defined( $self->param('Ext_Request') ) ) {\n        $Ext_Request = $self->param('Ext_Request');\n    }\n\n    my ( $headers, $body ) = $ms->list_invite(\n        {\n            -cgi_obj     => $q,\n            -Ext_Request => $Ext_Request,\n            -root_login  => $root_login,\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub mass_mailing_options {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list    = $admin_list;\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\n    if ( !$process ) {\n\n        my $can_use_css_inliner = 1;\n        try {\n            require CSS::Inliner;\n        }\n        catch {\n            $can_use_css_inliner = 0;\n        };\n\t\t\n\t\tmy $currently_selected_layout = $ls->param('mass_mailing_default_layout') || undef; \n\t\tif(!defined($currently_selected_layout)) { \n\t\t\tif($ls->param('group_list') == 1 && $ls->param('disable_discussion_sending') != 1){ \n\t\t\t\t$currently_selected_layout = 'discussion'; \n\t\t\t}\n\t\t\telse { \n\t\t\t\t$currently_selected_layout = 'default'; \n\t\t\t}\n\t\t}\n\t\t\n        my %wysiwyg_vars = DADA::Template::Widgets::make_wysiwyg_vars($list);\n\t\t\n\t\trequire HTML::Menu::Select;\n\t\tmy $email_image_width_limit_pop_menu = HTML::Menu::Select::popup_menu(\n          {\n              name    => 'email_image_width_limit',\n              id      => 'email_image_width_limit',\n              default => $ls->param('email_image_width_limit'),\n              values => [qw(240 320 480 580 640 800 1024)],\n          }\n        );\n\t\t\n\t\tmy $email_message_size_limit_popup_menu = HTML::Menu::Select::popup_menu(\n        {\n            name    => 'email_message_size_limit',\n            id      => 'email_message_size_limit',\n            default => $ls->param('email_message_size_limit'),\n            values => [qw(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 25 30 35 40 50)],\n        }\n      );\n\t\t\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'mass_mailing_options_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n\t\t\t\t\t\n\t\t\t\t\tscreen                  => 'mass_mailing_options',\n\t\t\t\t\t\n                    root_login                => $root_login,\n                    done                      => $done,\n                    can_use_css_inliner       => $can_use_css_inliner,\n\t\t\t\t\t\n\t\t\t\t\tcan_use_Image_Scale       => scalar can_use_Image_Scale(),\n\t\t\t\t\tcan_use_Image_Resize      => scalar can_use_Image_Resize(),\n\t\t\t\t\tcan_use_Image_Magick      => scalar can_use_Image_Magick(),\n\t\t\t\t\t\n\t\t\t\t\tcurrently_selected_layout => $currently_selected_layout, \n\t\t\t\t\t\n                    ckeditor_enabled =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}\n                      ->{enabled},\n                    ckeditor_url =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url},\n\n                    tiny_mce_enabled =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}\n                      ->{enabled},\n                    tiny_mce_url =>\n                      $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url},\n                    \n\t\t\t\t\temail_image_width_limit_pop_menu => \n\t\t\t\t\t\t$email_image_width_limit_pop_menu, \n\t\t\t\t\t\t\n\t\t\t\t\temail_message_size_limit_popup_menu => \n\t\t\t\t\t\t$email_message_size_limit_popup_menu,\n\t\t\t\t\t\n\t\t\t\t\t%wysiwyg_vars,\n\t\t\t\t\t\n\t\t\t\t\t\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    mass_mailing_convert_plaintext_to_html      => 0,\n                    mass_mailing_block_css_to_inline_css        => 0,\n\t\t\t\t\temail_embed_images_as_attachments           => 0,\n\t\t\t\t\tresize_drag_and_drop_images                 => 0, \n\t\t\t\t\temail_resize_embedded_images                => 0,\n\t\t\t\t\temail_image_width_limit                     => 0,\n\t\t\t\t\tenable_file_attachments_in_editor           => 0,  \n\t\t\t\t\temail_limit_message_size                    => 0, \n\t\t\t\t\temail_message_size_limit                    => 0, \n\t\t\t\t\tmass_mailing_use_list_unsubscribe_headers   => 0,\n\t\t\t\t\tmass_mailing_remove_javascript              => 0, \n                \tmass_mailing_default_layout                 => undef, \n\t\t\t\t\tmass_mailing_save_sent_drafts_as_stationery => 0, \n\t\t\t\t\tmass_mailing_show_by_default_type           => undef, \n                    use_wysiwyg_editor                          => 'none',\n\t\t\t\t\tmass_mailing_show_previews_in               => undef,\n\t\t\t\t},\n                -also_save_for => $also_save_for_list,\n            }\n        );\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=mass_mailing_options&done=1' );\n    }\n\n}\n\n\nsub is_valid_url { \n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\tmy $enabled = $q->param('enabled')  // 1; \n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_info'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n\tmy $url = $q->param('check_url');\n\n    my ( $content, $res, $md5 ) = grab_url( { -url => $url } );\n    \n  \t$self->header_props( -type => 'text/plain' );\n   \n\tif ( $res->is_success ) {\n\t\treturn \"true\";\n\t}\n\telse {\n\t\tif($enabled == 0){\n\t\t\t#return $res->message;\n\t\t\treturn \"true\";\n\t\t}\n\t\telse { \n\t\t\treturn \"false\";\n\t\t}\n\t}\n}\n\nsub change_info {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_info'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $list_name        = $q->param('list_name')        || undef;\n    my $list_owner_email = $q->param('list_owner_email') || undef;\n    my $admin_email      = $q->param('admin_email')      || undef;\n    my $info             = $q->param('info')             || undef;\n    my $physical_address = $q->param('physical_address') || undef;\n    my $done             = $q->param('done')             || undef;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n\n\t\n    require DADA::App::AmazonSES;\n    my $ses = DADA::App::AmazonSES->new;\n\n\tmy $check_ses_verification; \t\n\tif($ls->param('sending_method') eq 'amazon_ses'){ \n\t\t$check_ses_verification = 1; \n\t}\n\telsif(\n\t\t$ls->param('sending_method') eq 'smtp'\n\t    && $ls->param('smtp_server') =~ m/amazonaws\\.com/\n\t\t&& $ses->has_ses_options_set == 1\n\t){ \n\t\t$check_ses_verification = 1; \t\n\t}\n\telse { \n\t\t$check_ses_verification = 0;\n\t}\n\n\tmy $ses_params = {};\n\t\t\n    if ($check_ses_verification == 1){\n        $ses_params->{using_ses} = 1;\n        $ses_params->{list_owner_ses_verified}     = $ses->sender_verified( $ls->param('list_owner_email') );\n        $ses_params->{list_admin_ses_verified}     = $ses->sender_verified( $ls->param('admin_email') );\n        $ses_params->{discussion_pop_ses_verified} = $ses->sender_verified( $ls->param('discussion_pop_email') );\n    }\n    my $errors = 0;\n    my $flags  = {};\n\n    if ($process) {\n        ( $errors, $flags ) = check_list_setup(\n            -fields => {\n                list             => $list,\n                list_name        => $list_name,\n                list_owner_email => $list_owner_email,\n                admin_email      => $admin_email,\n                info             => $info,\n                physical_address => $physical_address,\n            },\n            -new_list => 'no',\n        );\n    }\n\n    undef $process\n      if $errors >= 1;\n\n    if ( !$process ) {\n\n        my $err_word = 'was';\n        $err_word = 'were'\n          if $errors && $errors > 1;\n\n        my $errors_ending = '';\n        $errors_ending = 's'\n          if $errors && $errors > 1;\n\n        my $flags_list_name = $flags->{list_name} || 0;\n\n        my $flags_list_name_bad_characters = $flags->{list_name_bad_characters}\n          || 0;\n\n        my $flags_invalid_list_owner_email = $flags->{invalid_list_owner_email}\n          || 0;\n        my $flags_list_info        = $flags->{list_info}        || 0;\n        my $flags_physical_address = $flags->{physical_address} || 0;\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'change_info_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen        => 'change_info',\n                    done          => $done,\n                    errors        => $errors,\n                    errors_ending => $errors_ending,\n                    err_word      => $err_word,\n                    list          => $list,\n                    list_name     => $list_name ? $list_name\n                    : $ls->param('list_name'),\n                    list_owner_email => $list_owner_email ? $list_owner_email\n                    : $ls->param('list_owner_email'),\n                    admin_email => $admin_email ? $admin_email\n                    : $ls->param('admin_email'),\n                    info => $info ? $info : $ls->param('info'),\n                    physical_address => $physical_address ? $physical_address\n                    : $ls->param('physical_address'),\n                    \n\t\t\t\t\tPLUGINS_ENABLED_bounce_handler => $DADA::Config::PLUGINS_ENABLED->{bounce_handler},\n\t\t\t\t\tBounce_Handler_Address         => $DADA::Config::PLUGIN_CONFIGS->{Bounce_Handler}->{Address},\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tflags_list_name => $flags_list_name,\n                    flags_invalid_list_owner_email =>\n                      $flags_invalid_list_owner_email,\n                    flags_list_info        => $flags_list_info,\n                    flags_physical_address => $flags_physical_address,\n                    flags_list_name_bad_characters =>\n                      $flags_list_name_bad_characters,\n                    %$ses_params,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        $admin_email = $list_owner_email\n          unless defined($admin_email);\n\n        $ls->save(\n            {\n                -settings => {\n                    list_owner_email     => strip($list_owner_email),\n                    admin_email          => strip($admin_email),\n                    list_name            => $list_name,\n                    info                 => $info,\n                    physical_address     => $physical_address,\n\t\t\t\t\tlist_phone_number    => xss_filter( strip( scalar $q->param('list_phone_number') ) ),\n                    logo_image_url       => xss_filter( strip( scalar $q->param('logo_image_url') ) ),\n                    website_url          => xss_filter( strip( scalar $q->param('website_url') )),\n\t\t\t\t\tfacebook_page_url    => xss_filter( strip( scalar $q->param('facebook_page_url') )),\n                    youtube_url          => xss_filter( strip( scalar $q->param('youtube_url') )),\n                    twitter_url          => xss_filter( strip( scalar $q->param('twitter_url') ) ),\n                    instagram_url        => xss_filter( strip( scalar $q->param('instagram_url') )),\n\t\t\t\t\twhatsapp_number      => xss_filter( strip( scalar $q->param('whatsapp_number') )),\n\t\t\t\t\tcustom_url_color     => xss_filter( strip( scalar $q->param('custom_url_color') )),\n\t\t\t\t\tcustom_url_label     => xss_filter( strip( scalar $q->param('custom_url_label') )),\n\t\t\t\t\tcustom_url           => xss_filter( strip( scalar $q->param('custom_url') )),\n\t\n\t\t\t\t\t\n\t\t\t\t\t\n                }\n            }\n        );\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=change_info&done=1' );\n    }\n}\n\nsub manage_privacy_policy { \n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done             = $q->param('done')             || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'manage_privacy_policy'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $privacy_policy   = $q->param('privacy_policy')   || undef;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\t\t\n\t\t# grab the most recent privacy policy from the db. \n\t\t# if it's not set, set it, then try to grab it again. \n\t\trequire DADA::MailingList::PrivacyPolicyManager;\n\t\tmy $ppm = DADA::MailingList::PrivacyPolicyManager->new; \n\t\tmy $pp_data = $ppm->latest_privacy_policy({-list => $list});\n\t\tif(!exists($pp_data->{privacy_policy})){ \n\t\t\tmy $new_pp_id = $ppm->add(\n\t\t\t\t{ \n\t\t\t\t\t-list           => $list, \n\t\t\t\t\t-privacy_policy => $ls->param('privacy_policy'), \n\t\t\t\t}\n\t\t\t); \n\t\t\t$pp_data = $ppm->latest_privacy_policy({-list => $list});\n\t\t}\n\t\tmy $saved_privacy_policy = $pp_data->{privacy_policy};\n\t\t\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'manage_privacy_policy.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen        => 'manage_privacy_policy',\n                    done          => $done,\n                    privacy_policy => $saved_privacy_policy,\n                 },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\t\t\n\t\trequire DADA::MailingList::PrivacyPolicyManager;\n\t\tmy $ppm = DADA::MailingList::PrivacyPolicyManager->new; \n\t\tmy $new_pp_id = $ppm->add(\n\t\t\t{ \n\t\t\t\t-list           => $list, \n\t\t\t\t-privacy_policy => $privacy_policy, \n\t\t\t}\n\t\t); \t\t\n\t\tmy $pp_data = $ppm->latest_privacy_policy(\n\t\t\t{\n\t\t\t\t-list => $list,\n\t\t\t}\n\t\t);\n\t\t\n\t\t# Yeah, we save the privacy policy twice. \n        $ls->save(\n            {\n                -settings => {\n                    privacy_policy       => $pp_data->{privacy_policy},\n                }\n            }\n        );\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=manage_privacy_policy&done=1' );\n    }\n\n}\n\nsub manage_list_consent { \n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'manage_list_consent',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n\t\n    require DADA::MailingList::Settings;\n\tmy $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\t\n\t\n\tif($process eq 'add_consent'){ \n\t\trequire DADA::MailingList::Consents; \n\t\tmy $new_consent = $q->param('new_consent') || undef; \n\t\trequire DADA::MailingList::Consents; \n\t\tmy $con = DADA::MailingList::Consents->new; \n\t\tmy $new_id = $con->add(\n\t\t\t{ \n\t\t\t\t-list    => $list, \n\t\t\t\t-consent => $new_consent,\n\t\t\t}\n\t\t); \n\t\tcarp 'new consent id: ' . $new_id;\n\t\t\n\t\t# And once that's done, we grab any consents already saved \n\t\t# (that's just ina  particular setting)\n\t\t# Add this new one to the lsit, \n\t\t# THen save it back? \n\t\t# Which format? \n\t\t\n\t\tmy $consent_ids = $ls->param('list_consent_ids'); \n\t\tmy $cids = $con->thawish_for_reading($consent_ids);\n\t\t\n\t\t\n\t\tpush(@$cids, $new_id); \n\t\t\n\t\tmy $freeze = $con->freezish_for_saving($cids);\n\t\t\n\t\t\n\t\t$ls->save(\n\t\t\t{\n\t\t\t\t-settings => {\n\t\t\t\t\tlist_consent_ids => $freeze, \n\t\t\t\t}\n\t\t\t}\t\n\t\t);\n\t\t\n\t\t$c->flush;\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=manage_list_consent;done=1;new_id=' . $new_id);\n\t\t\t  \n\t    return; \n\n\t}\n\telsif($process eq 'remove_list_consent'){ \n\t\t\n\t\tmy $id = $q->param('id');\n\n\t\trequire DADA::MailingList::Consents; \n\t\tmy $con = DADA::MailingList::Consents->new; \t\t\n\t\tmy $consent_ids = $ls->param('list_consent_ids'); \n\t\tmy $cids = $con->thawish_for_reading($consent_ids);\n\t\t\t\n\t\tmy $new_cids = []; \n\t\tfor(@$cids){ \n\t\t\tif($_ == $id){ \n\t\t\t\t# ... \n\t\t\t}\n\t\t\telse { \n\t\t\t\tpush(@$new_cids, $_);\n\t\t\t}\n\t\t}\n\t\tmy $freeze = $con->freezish_for_saving($new_cids);\n\t\t\n\t\t$ls->save(\n\t\t\t{\n\t\t\t\t-settings => {\n\t\t\t\t\tlist_consent_ids => $freeze, \n\t\t\t\t}\n\t\t\t}\t\n\t\t);\n\t\t$c->flush;\n\t\t\n\t\t\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=manage_list_consent;done=1;removed_id=' . $id);\n\t\t\t  \n\t    return; \n\t\t\n\t}\n\t\n\tmy $con = DADA::MailingList::Consents->new; \n\t\n\tuse DADA::MailingList::Consents; \n\tmy $consents = $con->give_me_all_consents($ls); \n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'manage_list_consent.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -expr => 1,\n            -vars => {\n\t\t\t\tconsents => $consents, \n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n}\n\nsub change_password {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $process          = $q->param('process')          || undef;\n\tmy $recaptcha_failed = $q->param('recaptcha_failed') || 0;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_password',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::Security::Password;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'change_password_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen     => 'change_password',\n                    root_login => $root_login,\n\t\t\t\t\trecaptcha_failed => $recaptcha_failed, \n\t\t\t\t\t\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\t\t\n\t\t\n\t\tif (can_use_Google_reCAPTCHA() == 1 ) {\n\t        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\t\t\tif($captcha_status == 0){ \n\t            $q->delete('process');\n\t\t\t\t$q->param('recaptcha_failed', 1);\n\t\t\t\treturn $self->change_password; \n\t\t\t}\n\t\t\telse { \n\t\t\t\t#...\n\t\t\t}\n\t\t}\n\n        my $old_password       = $q->param('old_password');\n        my $new_password       = $q->param('new_password');\n        my $again_new_password = $q->param('again_new_password');\n\n        if ( $root_login != 1 ) {\n            my $password_check =\n              DADA::Security::Password::check_password( $ls->param('password'),\n                $old_password );\n            if ( $password_check != 1 ) {\n                return (\n                    {},\n                    user_error(\n                        {\n                            -list  => $list,\n                            -error => \"invalid_password\"\n                        }\n                    )\n                );\n            }\n        }\n\n        $new_password       = strip($new_password);\n        $again_new_password = strip($again_new_password);\n\n        if (   $new_password ne $again_new_password\n            || $new_password eq \"\" )\n        {\n            return (\n                {},\n                user_error(\n                    {\n                        -list  => $list,\n                        -error => \"list_pass_no_match\"\n                    }\n                )\n            );\n        }\n\n        $ls->save(\n            {\n                -settings => {\n                    password => $new_password\n                }\n            }\n        );\n\n# -no_list_security_check, because the list password's changed, it wouldn't pass it anyways...\n        my ( $headers, $body ) = $self->logout(\n            -no_list_security_check => 1,\n            -redirect_url           => $DADA::Config::S_PROGRAM_URL\n              . '?flavor='\n              . $DADA::Config::SIGN_IN_FLAVOR_NAME\n              . '&list='\n              . $list,\n        );\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub delete_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'delete_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $process          = $q->param('process')          || undef;\n\tmy $recaptcha_failed = $q->param('recaptcha_failed') || 0;\n\t\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_list_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list                     => $list,\n                -vars                     => { \n\t\t\t\t\tscreen           => 'delete_list', \n\t\t\t\t\trecaptcha_failed => $recaptcha_failed, \n\t\t\t\t},\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\t\t\n\t\tif (can_use_Google_reCAPTCHA() == 1 ) {\n\t        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\t\t\tif($captcha_status == 0){ \n\t            $q->delete('process');\n\t\t\t\t$q->param('recaptcha_failed', 1);\n\t\t\t\treturn $self->delete_list; \n\t\t\t}\n\t\t\telse { \n\t\t\t\t#...\n\t\t\t}\n\t\t}\n\t\t\n        require DADA::MailingList;\n        DADA::MailingList::Remove(\n            {\n                -name => $list,\n            }\n        );\n        $c->flush;\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_list_success_screen.tmpl',\n                -with           => 'list',\n                -wrapper_params => {\n                    -Use_Custom => 0,\n                },\n            }\n        );\n\n\n        require DADA::App::Session;\n        my $dada_session = DADA::App::Session->new( -List => $list );\n        my $logout_cookie = $dada_session->logout_cookie( -cgi_obj => $q );\n\n        $self->header_props( -cookie => $logout_cookie, );\n        return $scrn;\n    }\n}\n\nsub list_options {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'list_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done')    || undef;\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $can_use_mx_lookup = 0;\n\n    eval { require Net::DNS; };\n    if ( !$@ ) {\n        $can_use_mx_lookup = 1;\n    }\n\n    my $can_use_StopForumSpam = can_use_StopForumSpam();\n\n    my $can_use_captcha       = can_use_Google_reCAPTCHA();\t\n\tmy $using_captcha_on_initial_subscribe_form = 0; \n\tif(\n\t\t$can_use_captcha                                          == 1 \n\t\t&& $ls->param('enable_captcha_on_initial_subscribe_form') == 1\n\t){ \n\t\t$using_captcha_on_initial_subscribe_form = 1; \n\t}\n\n    if ( !$process ) {\n        require HTML::Menu::Select;\n        my $send_subscription_notice_to_popup_menu =\n          HTML::Menu::Select::popup_menu(\n            {\n                name    => 'send_subscription_notice_to',\n                id      => 'send_subscription_notice_to',\n                default => $ls->param('send_subscription_notice_to'),\n                labels  => {\n                    list         => 'Your Subscribers',\n                    'list_owner' => 'The List Owner',\n                    'alt'        => 'Other:'\n                },\n                values => [qw(list list_owner alt)],\n            }\n          );\n        my $send_unsubscription_notice_to_popup_menu =\n          HTML::Menu::Select::popup_menu(\n            {\n                name    => 'send_unsubscription_notice_to',\n                id      => 'send_unsubscription_notice_to',\n                default => $ls->param('send_unsubscription_notice_to'),\n                labels  => {\n                    list         => 'Your Subscribers',\n                    'list_owner' => 'The List Owner',\n                    'alt'        => 'Other:'\n                },\n                values => [qw(list list_owner alt)],\n            }\n          );\n        my $send_admin_unsubscription_notice_to_popup_menu =\n          HTML::Menu::Select::popup_menu(\n            {\n                name    => 'send_admin_unsubscription_notice_to',\n                id      => 'send_admin_unsubscription_notice_to',\n                default => $ls->param('send_admin_unsubscription_notice_to'),\n                labels  => {\n                    list         => 'Your Subscribers',\n                    'list_owner' => 'The List Owner',\n                    'alt'        => 'Other:'\n                },\n                values => [qw(list list_owner alt)],\n            }\n          );\n\t\t    \n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'list_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -list => $list,\n                -vars => {\n                    screen                => 'list_options',\n                    title                 => 'Options',\n                    done                  => $done,\n                    root_login            => $root_login,\n                    can_use_mx_lookup     => $can_use_mx_lookup,\n                    can_use_captcha       => $can_use_captcha,\n\t\t\t\t\tusing_captcha_on_initial_subscribe_form => $using_captcha_on_initial_subscribe_form, \n                    can_use_StopForumSpam => $can_use_StopForumSpam,\n                    send_subscription_notice_to_popup_menu =>\n                      $send_subscription_notice_to_popup_menu,\n                    send_unsubscription_notice_to_popup_menu =>\n                      $send_unsubscription_notice_to_popup_menu,\n                    send_admin_unsubscription_notice_to_popup_menu =>\n                      $send_admin_unsubscription_notice_to_popup_menu,\n                    list_owner_email_anonystar_address =>\n                      DADA::App::Guts::anonystar_address_encode(\n                        $ls->param('list_owner_email')\n                      ),\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        if ( $q->param('anyone_can_subscribe') == 1 ) {\n            $q->param( 'invite_only_list', 0 );\n        }\n        else {\n            $q->param( 'invite_only_list', 1 );\n        }\n\n        my $list               = $admin_list;\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    private_list                                            => 0,\n                    hide_list                                               => 0,\n\t\t\t\t\tshow_request_removal_links                              => 0, \n                    closed_list                                             => 0,\n                    invite_only_list                                        => 0,\n                    get_sub_notice                                          => 0,\n                    get_unsub_notice                                        => 0,\n                    enable_closed_loop_opt_in                               => 0,\n\t\t\t\t\tenable_captcha_on_initial_subscribe_form                => 0,\n                    send_unsub_success_email                                => 0,\n                    send_sub_success_email                                  => 0,\n                    send_newest_archive                                     => 0,\n                    mx_check                                                => 0,\n                    limit_sub_confirm                                       => 0,\n                    limit_sub_confirm_use_captcha                           => 0,\n                    enable_sub_confirm_stopforumspam_protection             => 0,\n                    enable_sub_confirm_suspicious_activity_by_ip_protection => 0,\n                    email_your_subscribed_msg                               => 0,\n                    email_you_are_not_subscribed_msg                        => 0,\n                    use_alt_url_sub_confirm_success                         => 0,\n                    alt_url_sub_confirm_success                             => '',\n                    alt_url_sub_confirm_success_w_qs                        => 0,\n                    alt_url_sub_confirm_success_show_in_modal_window        => 0, \n\t\t\t\t\tuse_alt_url_sub_confirm_failed                          => 0,\n                    alt_url_sub_confirm_failed                              => '',\n                    alt_url_sub_confirm_failed_w_qs                         => 0,\n\t\t\t\t\talt_url_sub_confirm_failed_show_in_modal_window         => 0, \n                    use_alt_url_sub_success                                 => 0,\n                    alt_url_sub_success                                     => '',\n                    alt_url_sub_success_w_qs                                => 0,\n                    use_alt_url_sub_failed                                  => 0,\n                    alt_url_sub_failed                                      => '',\n                    alt_url_sub_failed_w_qs                                 => 0,\n                    use_alt_url_subscription_approval_step                  => 0,\n                    alt_url_subscription_approval_step                      => '',\n                    alt_url_subscription_approval_step_w_qs                 => 0,\n                    use_alt_url_unsub_success                               => 0,\n                    alt_url_unsub_success                                   => '',\n                    alt_url_unsub_success_w_qs                              => 0,\n                    unsub_show_email_hint                                   => 0,\n                    # one_click_unsubscribe                                   => 0,\n\t\t\t\t\tcompleting_the_unsubscription                           => undef, \n                    enable_subscription_approval_step                       => 0,\n                    enable_mass_subscribe                                   => 0,\n                    enable_mass_subscribe_only_w_root_login                 => 0,\n                    send_subscribed_by_list_owner_message                   => 0,\n                    send_unsubscribed_by_list_owner_message                 => 0,\n                    send_last_archived_msg_mass_mailing                     => 0,\n                    captcha_sub                                             => 0,\n                    send_subscription_notice_to                             => undef,\n                    send_unsubscription_notice_to                           => undef,\n                    alt_send_unsubscription_notice_to                       => undef,\n                    alt_send_subscription_notice_to                         => undef,\n                    alt_send_admin_unsubscription_notice_to                 => undef,\n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=list_options&done=1' );\n    }\n}\n\n\n\n\nsub subscribe_landing { \n\n\t #how does this work for private and/or hidding lists? \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\tmy $list  = $q->param('list')  || undef; \n\tmy $email = $q->param('email') || undef; \n\t\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        {\n            -list                 => $list,\n\t\t\t-email                => $email, \n        }\n    );\n\t\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'subscribe_landing.tmpl',\n            -expr           => 1,\n            -with           => 'list',\n\t\t\t-vars           => {\n\t\t\t\tcan_use_JSON      => scalar DADA::App::Guts::can_use_JSON(),\n\t\t\t\tsubscription_form => $subscription_form,\n\t\t\t},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n\n}\n\n\nsub modal_subscribe_landing { \n\n\t #how does this work for private and/or hidding lists? \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    if ( DADA::App::Guts::check_setup() == 0 ) {\n        return user_error( { -error => 'bad_setup' } );\n    }\n\n    if ( check_if_list_exists( -List => scalar $q->param('list') ) == 0 ) {\n        $q->delete('list');\n        return $self->default();\n    }\n\tmy $list  = $q->param('list')  || undef; \n\tmy $email = $q->param('email') || undef; \n\t\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        {\n            -list                 => $list,\n\t\t\t-email                => $email, \n\t\t\t-form_target          => '_blank',\n        }\n    );\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen         => 'modal_subscribe_landing.tmpl',\n            -expr           => 1,\n           # -with           => 'list',\n\t\t\t-vars           => {\n\t\t\t\tcan_use_JSON      => scalar DADA::App::Guts::can_use_JSON(),\n\t\t\t\tsubscription_form => $subscription_form,\n\t\t\t\tload_captcha_js => 1, \n\t\t\t\tload_colorbox => 1, \n\t\t\t\t\n\t\t\t\tinclude_jquery_lib   =>  1,\n                include_app_user_js  => 1,\n\t\t\t\t# I don't know why you have to all this atm\n\n                add_app_css          =>  1,\n\t\t\t\t\n\t\t\t\t\n\t\t\t},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\t\n\n}\n\n\n\n\nsub api {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $dp = $q->url || $DADA::Config::PROGRAM_URL;\n    $dp =~ s/^(http:\\/\\/|https:\\/\\/)(.*?)\\//\\//;\n\n    my $info = $q->path_info();\n\n    $info =~ s/^$dp//;\n\n    # script name should be something like:\n    # /cgi-bin/dada/mail.cgi\n    $info =~ s/^$ENV{SCRIPT_NAME}//i;\n    $info =~ s/(^\\/|\\/$)//g;    #get rid of fore and aft slashes\n\n    # seriously, this shouldn't be needed:\n    $info =~ s/^dada\\/mail\\.cgi//;\n\n    my ( $pi_flavor, $pi_list, $pi_service, $pi_public_key, $pi_digest ) =\n      split( '/', $info );\n\n# https://metacpan.org/pod/distribution/CGI/lib/CGI.pod#FETCHING-ENVIRONMENT-VARIABLES\n# https://stackoverflow.com/questions/7362932/perl-equivalent-of-php-auth-pw\n# HTTP_AUTHORIZATION\n    my %incoming_headers = map { $_ => $q->http($_) } $q->http();\n    if ( $DADA::Config::DEBUG_TRACE->{DADA_App_WebServices} == 1 ) {\n        warn \"Incoming Headers for API call:\";\n       \trequire Data::Dumper;\n        warn Data::Dumper::Dumper( {%incoming_headers} );\n    }\n\n    if ( !defined($pi_public_key) && !defined($pi_digest) ) {\n        my $auth_h = $incoming_headers{HTTP_AUTHORIZATION};\n        $auth_h =~ s/^hmac //;\n        ( $pi_public_key, $pi_digest ) = split( ':', $auth_h );\n    }\n    if ( !defined( $q->param('nonce') ) && $ENV{REQUEST_METHOD} eq 'GET' ) {\n        $q->param( 'nonce', $incoming_headers{'HTTP_X_DADA_NONCE'} );\n    }\n\n    $q->delete('flavor');    # ... probably.\n\n    require DADA::App::WebServices;\n    my $ws = DADA::App::WebServices->new;\n    my ( $headers, $body ) = $ws->request(\n        {\n            -list       => $pi_list,\n            -service    => $pi_service,\n            -public_key => $pi_public_key,\n            -digest     => $pi_digest,\n            -cgi_obj    => $q,\n        }\n    );\n\n    if ( keys %$headers ) {\n        $self->header_props(%$headers);\n    }\n    return $body;\n}\n\nsub web_services {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'web_services'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( length( $ls->param('public_api_key') ) <= 0\n        || $process eq 'reset_keys' )\n    {\n        require DADA::Security::Password;\n        $ls->save(\n            {\n                -settings => {\n                    public_api_key =>\n                      DADA::Security::Password::generate_rand_string(\n                        undef, 21\n                      )\n                }\n            }\n        );\n        undef $ls;\n        $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    }\n    if ( length( $ls->param('private_api_key') ) <= 0\n        || $process eq 'reset_keys' )\n    {\n        require DADA::Security::Password;\n        $ls->save(\n            {\n                -settings => {\n                    private_api_key =>\n                      DADA::Security::Password::generate_rand_string(\n                        undef, 41\n                      )\n                }\n            }\n        );\n        undef $ls;\n        $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    }\n    my $keys_reset = 0;\n    if ( $process eq 'reset_keys' ) {\n        $keys_reset = 1;\n\t\t\n        my ( $headers, $body ) = $self->logout(\n            -no_list_security_check => 1,\n            -redirect_url           => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=web_services'\n              . '&list='\n              . $list,\n        );\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'web_services.tmpl',\n            -with           => 'admin',\n            -expr           => 1,\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                root_login => $root_login,\n\t\t\t\t\n                keys_reset => $keys_reset,\n\t\t\t\tGLOBAL_API_OPTIONS_enabled => $DADA::Config::GLOBAL_API_OPTIONS->{enabled}, \n\t\t\t\tGLOBAL_API_OPTIONS_public_key => $DADA::Config::GLOBAL_API_OPTIONS->{public_key}, \n\t\t\t\tGLOBAL_API_OPTIONS_private_key => $DADA::Config::GLOBAL_API_OPTIONS->{private_key}, \n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub mail_sending_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $ses_params = {};\n    if (\n        $ls->param('sending_method') eq 'amazon_ses'\n        || (   $ls->param('sending_method') eq 'smtp'\n            && $ls->param('smtp_server') =~ m/amazonaws\\.com/ )\n      )\n    {\n        $ses_params->{using_ses} = 1;\n        require DADA::App::AmazonSES;\n        my $ses = DADA::App::AmazonSES->new;\n        $ses_params->{list_owner_ses_verified} =\n          $ses->sender_verified( $ls->param('list_owner_email') );\n        $ses_params->{list_admin_ses_verified} =\n          $ses->sender_verified( $ls->param('admin_email') );\n        $ses_params->{discussion_pop_ses_verified} =\n          $ses->sender_verified( $ls->param('discussion_pop_email') );\n    }\n    if ( !$process ) {\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        require DADA::Security::Password;\n\n        my $decrypted_sasl_pass = '';\n        if ( $ls->param('sasl_smtp_password') ) {\n            $decrypted_sasl_pass =\n              DADA::Security::Password::cipher_decrypt(\n                $ls->param('cipher_key'),\n                $ls->param('sasl_smtp_password') );\n        }\n\n\n# DEV: This is really strange, since if Net::SMTP isn't available, SMTP sending is completely broken.\n        my $can_use_net_smtp = 0;\n        eval { require Net::SMTP };\n        if ( !$@ ) {\n            $can_use_net_smtp = 1;\n        }\n\n        my $mechanism_popup;\n        require HTML::Menu::Select;\n\n        if ($can_use_net_smtp) {\n            $mechanism_popup = HTML::Menu::Select::popup_menu(\n                {\n                    name    => 'sasl_auth_mechanism',\n                    id      => 'sasl_auth_mechanism',\n                    default => $ls->param('sasl_auth_mechanism'),\n                    values  => [qw(AUTO PLAIN LOGIN DIGEST-MD5 CRAM-MD5)],\n                }\n            );\n        }\n\n        my $wrong_uid = 0;\n        $wrong_uid = 1\n          if $< != $>;\n\n        my $no_smtp_server_set = 0;\n        if (  !$ls->param('smtp_server')\n            && $ls->param('sending_method') eq \"smtp\" )\n        {\n            $no_smtp_server_set = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'mail_sending_options_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen             => 'mail_sending_options',\n                    done               => $done,\n                    root_login         => $root_login,\n                    no_smtp_server_set => $no_smtp_server_set,\n                    mechanism_popup    => $mechanism_popup,\n                    can_use_IO_Socket_SSL => DADA::App::Guts::can_use_IO_Socket_SSL(),\n                    wrong_uid            => $wrong_uid,\n                    f_flag_settings      => $DADA::Config::MAIL_SETTINGS . ' -f'\n                      . $ls->param('admin_email'),\n\n                    use_sasl_smtp_auth => scalar $q->param('use_sasl_smtp_auth')\n                    ? scalar $q->param('use_sasl_smtp_auth')\n                    : $ls->param('use_sasl_smtp_auth'),\n\n                    sasl_auth_mechanism =>\n                      scalar $q->param('sasl_auth_mechanism')\n                    ? scalar $q->param('sasl_auth_mechanism')\n                    : $ls->param('sasl_auth_mechanism'),\n                    sasl_smtp_username => scalar $q->param('sasl_smtp_username')\n                    ? scalar $q->param('sasl_smtp_username')\n                    : $ls->param('sasl_smtp_username'),\n                    sasl_smtp_password => scalar $q->param('sasl_smtp_password')\n                    ? scalar $q->param('sasl_smtp_password')\n                    : $decrypted_sasl_pass,\n\n                    amazon_ses_requirements_widget =>\n                      DADA::Template::Widgets::amazon_ses_requirements_widget(),\n                    %$ses_params,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n\t\t\t\t\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    sending_method       => undef,\n                    add_sendmail_f_flag  => 0,\n                    set_smtp_sender      => 0,\n                    smtp_server          => undef,\n\n                    use_smtp_ssl         => 0,\n                    sasl_auth_mechanism  => undef,\n                    use_sasl_smtp_auth   => 0,\n\t\t\t\t\t\n\t\t\t\t\tsmtp_starttls        => 0, \n                    smtp_ssl_verify_mode => 0, \n\t\t\t\t\tsasl_smtp_username   => undef,\n                    sasl_smtp_password   => undef,\n                    smtp_port            => undef,\n                },\n                -also_save_for => $also_save_for_list,\n            }, \n        );\n        if ( $q->param('no_redirect') == 1 ) {\n            return undef;    # I mean, I guess...\n        }\n        else {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=mail_sending_options&done=1' );\n\n        }\n    }\n}\n\nsub mailing_sending_mass_mailing_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n    my $done    = $q->param('done');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mailing_sending_mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        require DADA::Mail::MailOut;\n        my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n        my ( $batch_sending_enabled, $batch_size, $batch_wait ) =\n          $mo->batch_params();\n\n        my $show_amazon_ses_options = 0;\n        my $type_of_service         = 'ses';\n        my $can_use_Amazon_SES      = scalar DADA::App::Guts::can_use_Amazon_SES();\n\t\t\n\t\tif ($can_use_Amazon_SES == 1) { \n\t\t\t\n\t\t\trequire DADA::App::AmazonSES;\n\t\t\tmy $ses = DADA::App::AmazonSES->new;\n\n\t\t\tif(\n\t\t\t\t(\n\t\t\t\t\t$ls->param('sending_method') eq 'amazon_ses'\n\t\t\t\t)\n\t\t\t||\n\t\t\t\t(\n\t\t\t\t\t$ls->param('sending_method') eq 'smtp'\n\t\t\t\t\t&& $ls->param('smtp_server') =~ m/amazonaws\\.com/\n\t\t\t\t\t&& $ses->has_ses_options_set == 1\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t$show_amazon_ses_options = 1;\n\t\t\t}\n\t\t}\n\t\t\n        my @message_amount = ( 1 .. 180 );\n        unshift( @message_amount, $batch_size );\n\n        my @message_wait = (\n            1 .. 60, 70,  80,  90,  100, 110, 110, 120,\n            130,     140, 150, 160, 170, 180\n        );\n\n        unshift( @message_wait, $batch_wait );\n        my @message_label = (1);\n        my %label_label = ( 1 => 'second(s)', );\n\n        require HTML::Menu::Select;\n        my $mass_send_amount_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => \"mass_send_amount\",\n                id    => \"mass_send_amount\",\n                value => [@message_amount],\n                class => 'previewBatchSendingSpeed',\n            }\n        );\n\n        my $bulk_sleep_amount_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => \"bulk_sleep_amount\",\n                id    => \"bulk_sleep_amount\",\n                value => [@message_wait],\n                class => 'previewBatchSendingSpeed',\n            }\n        );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'mailing_sending_mass_mailing_options_screen.tmpl',\n                -with   => 'admin',\n                -expr   => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen     => 'mailing_sending_mass_mailing_options',\n                    done       => $done,\n                    root_login => $root_login,\n                    batch_sending_enabled   => $batch_sending_enabled,\n                    mass_send_amount_menu   => $mass_send_amount_menu,\n                    bulk_sleep_amount_menu  => $bulk_sleep_amount_menu,\n                    batch_size              => $batch_size,\n                    batch_wait              => $batch_wait,\n                    show_amazon_ses_options => $show_amazon_ses_options,\n                    type_of_service         => $type_of_service,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    mass_send_amount                => undef,\n                    bulk_sleep_amount               => undef,\n                    enable_bulk_batching            => 0,\n                    adjust_batch_sleep_time         => 0,\n                    get_finished_notification       => 0,\n                    auto_pickup_dropped_mailings    => 0,\n                    smtp_connection_per_batch       => 0,\n                    mass_mailing_send_to_list_owner => 0,\n                    amazon_ses_auto_batch_settings  => 0,\n                    mass_mailing_save_logs          => 0,\n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=mailing_sending_mass_mailing_options&done=1' );\n    }\n}\n\nsub amazon_ses_verify_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $valid_email = 1;\n    my $status      = undef;\n    my $result      = undef;\n    my $amazon_ses_verify_email =\n      xss_filter( strip( scalar $q->param('amazon_ses_verify_email') ) );\n    if ( check_for_valid_email($amazon_ses_verify_email) == 1 ) {\n        $valid_email = 0;\n    }\n    else {\n        require DADA::App::AmazonSES;\n        my $ses = DADA::App::AmazonSES->new;\n        ( $status, $result ) =\n          $ses->verify_sender( { -email => $amazon_ses_verify_email } );\n    }\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'amazon_ses_verify_email_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                amazon_ses_verify_email => $amazon_ses_verify_email,\n                valid_email             => $valid_email,\n                status                  => $status,\n                result                  => $result,\n            }\n        }\n    );\n    return $body;\n}\n\nsub amazon_ses_get_stats {\n\n    my $self = shift;\n    my $q    = $self->query();\n\t\n    require DADA::App::AmazonSES;\n    my $ses = DADA::App::AmazonSES->new;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mailing_sending_mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if (\n        (\n\t\t\t$ls->param('sending_method') eq 'amazon_ses'\n\t\t)\n\t||\n\t\t(   \n\t\t\t$ls->param('sending_method') eq 'smtp'\n            && $ls->param('smtp_server') =~ m/amazonaws\\.com/\n        \t&& $ses->has_ses_options_set == 1\n      \t  )\n\t){\t\n        my $status                           = undef;\n        my $SentLast24Hours                  = undef;\n        my $Max24HourSend                    = undef;\n        my $MaxSendRate                      = undef;\n        my $allowed_sending_quota_percentage = undef;\n\n        my $using_ses = 0;\n        my $using_man = 0;\n\n        if (\n            (\n\t\t\t\t$ls->param('sending_method') eq 'amazon_ses'\n\t\t\t)\n\t\t||\n\t\t\t(   \n\t\t\t\t$ls->param('sending_method') eq 'smtp'\n                && $ls->param('smtp_server') =~ m/amazonaws\\.com/\n            \t&& $ses->has_ses_options_set == 1\n          \t  )\n\t\t){\t\n\t\t\t( $status, $SentLast24Hours, $Max24HourSend, $MaxSendRate ) = $ses->get_stats;\n\t\t\t$allowed_sending_quota_percentage = $ses->allowed_sending_quota_percentage;\n\t\t\t$using_ses = 1;\n        }\n\n        my $body = DADA::Template::Widgets::screen(\n            {\n                -screen => 'amazon_ses_get_stats_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    status          => $status,\n                    has_ses_options => $ses->has_ses_options_set,\n                    MaxSendRate     => commify($MaxSendRate),\n                    Max24HourSend   => commify($Max24HourSend),\n                    SentLast24Hours => commify($SentLast24Hours),\n                    allowed_sending_quota_percentage =>$allowed_sending_quota_percentage,\n                    using_ses => $using_ses,\n                    using_man => $using_man,\n                }\n            }\n        );\n        return $body;\n    }\n    else {\n        return undef;\n    }\n\n}\n\nsub previewBatchSendingSpeed {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mailing_sending_mass_mailing_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $enable_bulk_batching =\n      xss_filter( scalar $q->param('enable_bulk_batching') );\n    my $mass_send_amount  = xss_filter( scalar $q->param('mass_send_amount') );\n    my $bulk_sleep_amount = xss_filter( scalar $q->param('bulk_sleep_amount') );\n    my $amazon_ses_auto_batch_settings = xss_filter( scalar $q->param('amazon_ses_auto_batch_settings') );\n\n    my $per_hour         = 0;\n\tmy $per_hour_thirded;\n    my $num_subs         = 0;\n    my $time_to_send     = 0;\n\tmy $time_to_send_thirded; \n    my $somethings_wrong = 0;\n\n    if ( $enable_bulk_batching == 1 ) {\n\n        if ( $amazon_ses_auto_batch_settings == 1 ) {\n            require DADA::Mail::MailOut;\n            my $mo = DADA::Mail::MailOut->new( { -list => $list } );\n            my $enabled;\n            ( $enabled, $mass_send_amount, $bulk_sleep_amount ) =\n              $mo->batch_params( { -amazon_ses_auto_batch_settings => 1 } );\n        }\n\n        if ( $bulk_sleep_amount > 0 && $mass_send_amount > 0 ) {\n\n\t\t\tmy $per_sec; \n\t\t\n\t\t\t\n\t\t\tif ( $amazon_ses_auto_batch_settings == 1 ) {\n\t\t\t\t# This adds a second to each message sent, less the time spend sleeping\n\t\t\t\t# This is to take into consideration how long a message actually takes to send\n\t\t\t\t# to the service. \n\t\t\t\t$per_sec = ($mass_send_amount / $bulk_sleep_amount) - ($mass_send_amount - $bulk_sleep_amount);\n            }\n\t\t\telse { \n\t\t\t\t$per_sec = ($mass_send_amount / $bulk_sleep_amount);\n\t\t\t}\n\t\t\t$per_hour =\n              int( $per_sec * 60 * 60 + .5 )\n              ; # DEV .5 is some sort of rounding thing (with int). That's wrong.\n\n            $num_subs = $lh->num_subscribers;\n            my $total_hours = 0;\n            if ( $num_subs > 0 && $per_hour > 0 ) {\n                $total_hours = $lh->num_subscribers / $per_hour;\n            }\n\n\t\t\t$per_hour_thirded = int(($per_hour * 3) + .5); \n\t\t\t$per_hour_thirded  = commify($per_hour_thirded);\n            $per_hour = commify($per_hour);\n            $num_subs = commify($num_subs);\n\n            $time_to_send = formatted_runtime( $total_hours * 60 * 60 );\n\t\t\t\n\t\t\tif ( $amazon_ses_auto_batch_settings == 1 ) {\n\t\t\t\n\t\t\t\t$time_to_send_thirded = formatted_runtime( ($total_hours/3) * 60 * 60 );\n\t\t\t}\n\t\t\t\n\n        }\n        else {\n            $somethings_wrong = 1;\n        }\n    }\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'previewBatchSendingSpeed_widget.tmpl',\n            -vars   => {\n\t\t\t\tamazon_ses_auto_batch_settings => $amazon_ses_auto_batch_settings, \n                enable_bulk_batching           => $enable_bulk_batching,\n                per_hour                       => $per_hour,\n\t\t\t\tper_hour_thirded               => $per_hour_thirded, \n                num_subscribers                => $num_subs,\n                time_to_send                   => $time_to_send,\n\t\t\t\ttime_to_send_thirded           => $time_to_send_thirded, \n                somethings_wrong               => $somethings_wrong,\n            }\n        }\n    );\n    return $body;\n\n}\n\nsub mail_sending_advanced_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n    my $done    = $q->param('done');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_advanced_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::Security::Password;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        require HTML::Menu::Select;\n        unshift( @DADA::Config::CHARSETS, $ls->param('charset') );\n        my $precedence_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => \"precedence\",\n                id      => \"precedence\",\n                value   => [@DADA::Config::PRECEDENCES],\n                default => $ls->param('precedence'),\n            }\n        );\n\n        my $priority_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => \"priority\",\n                id      => \"priority\",\n                value   => [ keys %DADA::Config::PRIORITIES ],\n                labels  => \\%DADA::Config::PRIORITIES,\n                default => $ls->param('priority'),\n            }\n        );\n\n        my $charset_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => 'charset',\n                id    => 'charset',\n                value => [@DADA::Config::CHARSETS],\n            }\n        );\n\n        my $plaintext_encoding_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'plaintext_encoding',\n                id      => 'plaintext_encoding',\n                value   => [@DADA::Config::CONTENT_TRANSFER_ENCODINGS],\n                default => $ls->param('plaintext_encoding'),\n            }\n        );\n\n        my $html_encoding_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'html_encoding',\n                id      => 'html_encoding',\n                value   => [@DADA::Config::CONTENT_TRANSFER_ENCODINGS],\n                default => $ls->param('html_encoding'),\n            }\n        );\n\n        my $can_mime_encode = 1;\n        eval { require MIME::EncWords; };\n        if ($@) {\n            $can_mime_encode = 0;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'mail_sending_advanced_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen                => 'mail_sending_advanced_options',\n                    title                 => 'Advanced Options',\n                    done                  => $done,\n                    root_login            => $root_login,\n                    precedence_popup_menu => $precedence_popup_menu,\n                    priority_popup_menu   => $priority_popup_menu,\n                    charset_popup_menu    => $charset_popup_menu,\n                    plaintext_encoding_popup_menu =>\n                      $plaintext_encoding_popup_menu,\n                    html_encoding_popup_menu => $html_encoding_popup_menu,\n                    can_mime_encode          => $can_mime_encode,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    precedence                   => undef,\n                    priority                     => undef,\n                    charset                      => undef,\n                    plaintext_encoding           => undef,\n                    html_encoding                => undef,\n                    verp_return_path             => 0,\n                }\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=mail_sending_advanced_options&done=1' );\n\n    }\n}\n\nsub mail_sending_options_test {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'mail_sending_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    $q->param( 'no_redirect', 1 );\n\n    # Saves the params passed\n    $self->mail_sending_options();\n\n    require DADA::Mail::Send;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $admin_list } );\n\n    my $mh = DADA::Mail::Send->new(\n        {\n            -list   => $list,\n            -ls_obj => $ls,\n        }\n    );\n\n    my ( $results, $lines, $report );\n    eval { ( $results, $lines, $report ) = $mh->mail_sending_options_test; };\n    if ($@) {\n        $results .= $@;\n    }\n\n    $results =~ s/\\</&lt;/g;\n    $results =~ s/\\>/&gt;/g;\n\n    my $ht_report = [];\n\n    for my $f (@$report) {\n\n        my $s_f = $f->{line};\n        $s_f =~ s{Net\\:\\:SMTP(.*?)\\)}{};\n        push( @$ht_report, { SMTP_command => $s_f, message => $f->{message} } );\n    }\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'mail_sending_options_test_widget.tmpl',\n            -expr   => 1,\n            -vars   => {\n                report  => $ht_report,\n                raw_log => $results,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $body;\n\n}\n\nsub view_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $add_email_count =\n      xss_filter( scalar $q->param('add_email_count') ) || 0;\n    my $update_email_count =\n      xss_filter( scalar $q->param('update_email_count') ) || 0;\n    my $skipped_email_count =\n      xss_filter( scalar $q->param('skipped_email_count') )\n      || 0;\n    my $delete_email_count =\n      xss_filter( scalar $q->param('delete_email_count') ) || 0;\n    my $black_list_add = xss_filter( scalar $q->param('black_list_add') ) || 0;\n    my $approved_count = xss_filter( scalar $q->param('approved_count') ) || 0;\n    my $denied_count   = xss_filter( scalar $q->param('denied_count') )   || 0;\n    my $bounced_list_moved_to_list_count =\n      xss_filter( scalar $q->param('bounced_list_moved_to_list_count') ) || 0;\n    my $bounced_list_removed_from_list =\n      xss_filter( scalar $q->param('bounced_list_removed_from_list') ) || 0;\n    my $updated_addresses =\n      xss_filter( scalar $q->param('updated_addresses') ) || 0;\n    my $type  = xss_filter( scalar $q->param('type') )  || 'list';\n    my $query = xss_filter( scalar $q->param('query') ) || undef;\n\n    my $order_by = $q->param('order_by') || $ls->param('view_list_order_by');\n    my $order_dir = $q->param('order_dir')\n      || lc( $ls->param('view_list_order_by_direction') );\n\n    my $mode            = xss_filter( scalar $q->param('mode') ) || 'view';\n    my $page            = xss_filter( scalar $q->param('page') ) || 1;\n    my $advanced_search = $q->param('advanced_search')           || 0;\n    my $advanced_query  = $q->param('advanced_query')            || undef;\n\n    if ( $mode ne 'viewport' ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -list           => $list,\n                -screen         => 'view_list_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen          => 'view_list',\n                    flavor          => 'view_list',\n                    root_login      => $root_login,\n                    type            => $type,\n                    page            => $page,\n                    query           => $query,\n                    order_by        => $order_by,\n                    order_dir       => $order_dir,\n                    advanced_search => $advanced_search,\n                    advanced_query  => $advanced_query,\n\n                    add_email_count     => $add_email_count,\n                    update_email_count  => $update_email_count,\n                    skipped_email_count => $skipped_email_count,\n                    delete_email_count  => $delete_email_count,\n                    black_list_add      => $black_list_add,\n                    approved_count      => $approved_count,\n                    denied_count        => $denied_count,\n                    bounced_list_moved_to_list_count =>\n                      $bounced_list_moved_to_list_count,\n                    bounced_list_removed_from_list =>\n                      $bounced_list_removed_from_list,\n                    updated_addresses => $updated_addresses,\n                    type_title        => $DADA::Config::LIST_TYPES->{$type},\n\n                },\n            }\n        );\n\n        return $scrn;\n    }\n    else {\n\n        # DEV: Yup. Forgot what this was for.\n        if ( defined( $q->param('list') ) ) {\n            if ( $list ne $q->param('list') ) {\n\n# I should look instead to see if we're logged in view ROOT and then just\n# *Switch* the login. Brilliant! --- maybe I don't want to switch lists automatically - without\n# someone perhaps knowing that THAT's what I did...\n                my ( $headers, $body ) =\n                  $self->logout(\n                    -redirect_url => $DADA::Config::S_PROGRAM_URL . '?'\n                      . $q->query_string(), );\n\n                if ( keys %$headers ) {\n                    $self->header_props(%$headers);\n                }\n                return $body;\n            }\n        }\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n        my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n        my $num_subscribers = $lh->num_subscribers( { -type => $type } );\n\n        my $show_bounced_list = 0;\n        if (   $lh->num_subscribers( { -type => 'bounced_list' } ) > 0\n            || $ls->param('bounce_handler_when_threshold_reached') eq\n            'move_to_bounced_sublist' )\n        {\n            $show_bounced_list = 1;\n        }\n\n        my $subscribers = [];\n\n        require Data::Pageset;\n        my $page_info    = undef;\n        my $pages_in_set = [];\n        my $total_num    = 0;\n\n        # warn '$query ' . $query;\n        # warn '$advanced_query ' . $advanced_query;\n        # warn ' $advanced_search' . $advanced_search;\n\n        if ( $query || $advanced_query ) {\n\n            if ( $advanced_search == 1 ) {\n                open my $fh, '<', \\$advanced_query || die $!;\n                require CGI;\n                my $new_q = CGI->new($fh);\n                $new_q->charset($DADA::Config::HTML_CHARSET);\n\n                $new_q = decode_cgi_obj($new_q);\n                my $partial_sending = partial_sending_query_to_params($new_q);\n\n                ( $total_num, $subscribers ) = $lh->search_list(\n                    {\n                        -partial_listing => $partial_sending,\n                        -type            => $type,\n                        -start           => ( $page - 1 ),\n                        '-length'  => $ls->param('view_list_subscriber_number'),\n                        -order_by  => $order_by,\n                        -order_dir => $order_dir,\n\n                    }\n                );\n            }\n            else {\n\n                ( $total_num, $subscribers ) = $lh->search_list(\n                    {\n                        -query     => $query,\n                        -type      => $type,\n                        -start     => ( $page - 1 ),\n                        '-length'  => $ls->param('view_list_subscriber_number'),\n                        -order_by  => $order_by,\n                        -order_dir => $order_dir,\n\n                    }\n                );\n            }\n            $page_info = Data::Pageset->new(\n                {\n                    total_entries => $total_num,\n                    entries_per_page =>\n                      $ls->param('view_list_subscriber_number'),\n                    current_page  => $page,\n                    mode          => 'slide',    # default fixed\n                    pages_per_set => 10,\n                }\n            );\n\n        }\n        else {\n            $subscribers = $lh->subscription_list(\n                {\n                    -type  => $type,\n                    -start => ( $page - 1 )\n                    , # this really should be just, $page, but subscription_list() would have to be updated, which will break a lot of things...\n                    '-length'  => $ls->param('view_list_subscriber_number'),\n                    -order_by  => $order_by,\n                    -order_dir => $order_dir,\n\n                    #-show_list_column      => 0,\n                    #-show_timestamp_column => 0,\n                }\n            );\n            $total_num = $num_subscribers;\n            $page_info = Data::Pageset->new(\n                {\n                    total_entries => $num_subscribers,\n                    entries_per_page =>\n                      $ls->param('view_list_subscriber_number'),\n                    current_page  => $page,\n                    mode          => 'slide',    # default fixed\n                    pages_per_set => 10,\n                }\n            );\n\n        }\n\n        foreach my $page_num ( @{ $page_info->pages_in_set() } ) {\n            if ( $page_num == $page_info->current_page() ) {\n                push( @$pages_in_set,\n                    { page => $page_num, on_current_page => 1 } );\n            }\n            else {\n                push( @$pages_in_set,\n                    { page => $page_num, on_current_page => undef } );\n            }\n        }\n\n        require DADA::ProfileFieldsManager;\n        my $pfm         = DADA::ProfileFieldsManager->new;\n        my $fields_attr = $pfm->get_all_field_attributes;\n\n        my $field_names = [];\n        my $undotted_fields = [ { name => 'email', label => 'Email Address' } ];\n        for ( @{ $lh->subscriber_fields } ) {\n            push(\n                @$field_names,\n                {\n                    name          => $_,\n                    label         => $fields_attr->{$_}->{label},\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL\n                },\n            );\n            push(\n                @$undotted_fields,\n                {\n                    name          => $_,\n                    label         => $fields_attr->{$_}->{label},\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL\n                },\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -list   => $list,\n                -screen => 'view_list_viewport_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    can_have_subscriber_fields => 1,\n                    screen                     => 'view_list',\n                    flavor                     => 'view_list',\n                    root_login                 => $root_login,\n\n                    type       => $type,\n                    type_title => $DADA::Config::LIST_TYPES->{$type},\n\n                    first            => $page_info->first,\n                    last             => $page_info->last,\n                    first_page       => $page_info->first_page,\n                    last_page        => $page_info->last_page,\n                    next_page        => $page_info->next_page,\n                    previous_page    => $page_info->previous_page,\n                    page             => $page_info->current_page,\n                    show_list_column => 0,\n                    show_timestamp_column =>\n                      $ls->param('view_list_show_timestamp_col'),\n                    field_names     => $field_names,\n                    undotted_fields => $undotted_fields,\n\n                    pages_in_set        => $pages_in_set,\n                    num_subscribers     => commify($num_subscribers),\n                    total_num           => $total_num,\n                    total_num_commified => commify($total_num),\n                    subscribers         => $subscribers,\n                    query               => $query,\n                    advanced_search     => $advanced_search,\n                    advanced_query      => $advanced_query,\n                    order_by            => $order_by,\n                    order_dir           => $order_dir,\n\n                    show_bounced_list => $show_bounced_list,\n\n                    GLOBAL_BLACK_LIST  => $DADA::Config::GLOBAL_BLACK_LIST,\n                    GLOBAL_UNSUBSCRIBE => $DADA::Config::GLOBAL_UNSUBSCRIBE,\n\n                    can_use_global_black_list => $lh->can_use_global_black_list,\n                    can_use_global_unsubscribe =>\n                      $lh->can_use_global_unsubscribe,\n\n                    can_filter_subscribers_through_blacklist =>\n                      $lh->can_filter_subscribers_through_blacklist,\n\n                    flavor_is_view_list => 1,\n                    list_subscribers_num =>\n                      scalar commify(\n                        $lh->num_subscribers( { -type => 'list' } ) ),\n                    black_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'black_list' } )\n                    ),\n                    white_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'white_list' } )\n                    ),\n                    authorized_senders_num => scalar commify(\n                        $lh->num_subscribers(\n                            { -type => 'authorized_senders' }\n                        )\n                    ),\n                    moderators_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'moderators' } )\n                    ),\n\t\t\t\t\t\n                    requires_moderation_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'requires_moderation' } )\n                    ),\n\t\t\t\t\t\n                    sub_request_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'sub_request_list' } )\n                    ),\n                    unsub_request_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers(\n                            { -type => 'unsub_request_list' }\n                        )\n                    ),\n                    bounced_list_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'bounced_list' } )\n                    ),\n\t\t\t\t\t\n\t\t\t\t\tignore_bounces_list_num => \n\t\t\t\t\t\tscalar commify(\n\t\t\t\t\t\t\t$lh->num_subscribers( { -type => 'ignore_bounces_list' } )\n\t\t\t\t\t), \n\t\t\t\t\t\n                    sub_confirm_list_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'sub_confirm_list' } )\n                    ),\n\t\t\t\t\t\n                    test_list_subscribers_num => scalar commify(\n                        $lh->num_subscribers( { -type => 'test_list' } ) \n\t\t\t\t\t),\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub mass_update_profiles {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $ls   = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh   = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $update_fields = {};\n\n    for my $field ( @{ $lh->subscriber_fields() } ) {\n        if ( $q->param( 'update.' . $field ) == 1 ) {\n            $update_fields->{$field} = $q->param($field);\n        }\n    }\n\n    my $advanced_query =\n      xss_filter( scalar $q->param('advanced_query') ) || undef;\n    open my $fh, '<', \\$advanced_query || die $!;\n    require CGI;\n    my $new_q = CGI->new($fh);\n    $new_q->charset($DADA::Config::HTML_CHARSET);\n    $new_q = decode_cgi_obj($new_q);\n    my $partial_listing = partial_sending_query_to_params($new_q);\n\n    my $updated = $lh->update_profiles(\n        {\n\n            -update_fields   => $update_fields,\n            -partial_listing => $partial_listing,\n\n        }\n    );\n\n    # And then, we're return with a search query, to show the results:\n    $q->param( 'updated_addresses', $updated );\n    $q->param( 'advanced_search',   1 );\n    $q->param( 'done',              1 );\n\n    undef($new_q);\n    require CGI;\n    $new_q = CGI->new;\n    $new_q->charset($DADA::Config::HTML_CHARSET);\n    $new_q->delete_all;\n\n    #    $new_q->param('favorite_color.operator', '=');\n    #    $new_q->param('favorite_color.value', 'mauve');\n\n    for my $field (%$update_fields) {\n        $new_q->param( $field . '.operator', '=' );\n        $new_q->param( $field . '.value',    $update_fields->{$field} );\n    }\n\n    my $new_advanced_search_query = $new_q->query_string();\n    $new_advanced_search_query =~ s/\\;/\\&/g;\n\n    $q->param( 'advanced_query', $new_advanced_search_query );\n\n    return $self->view_list();\n}\n\nsub domain_breakdown_json {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $type = $q->param('type') || 'list';\n\n    require DADA::MailingList::Subscribers;\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $headers = {\n        '-Cache-Control' => 'no-cache, must-revalidate',\n        -expires         => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        -type            => 'application/json',\n    };\n    my $body = $lh->domain_stats_json(\n        {\n            -type     => $type,\n            -count    => 15,\n            -printout => 0,\n        }\n    );\n\n    if ( keys %$headers ) {\n        $self->header_props(%$headers);\n    }\n    return $body;\n}\n\nsub search_list_auto_complete {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $query = xss_filter( scalar $q->param('query') ) || undef;\n    my $type  = xss_filter( scalar $q->param('type') )  || 'list';\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my ( $total_num, $subscribers ) = $lh->search_list(\n        {\n            -query    => $query,\n            -type     => $type,\n            '-length' => 10,\n        }\n    );\n\n    my $r = [];\n    for my $result (@$subscribers) {\n        push( @$r, { 'email' => $result->{email} } );\n    }\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    $self->header_props( -type => 'application/json' );\n    return $json->encode($r);\n\n}\n\nsub list_activity {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'list_activity'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\t\n    my $body = DADA::Template::Widgets::wrap_screen(\n        {\n            -list           => $list,\n            -screen         => 'list_activity_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -expr => 1,\n        }\n    );\n    return $body;\n\n}\n\nsub sub_unsub_trends_json {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'list_activity'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $days = xss_filter(\n\t\tstrip(\n\t\t\tscalar $q->param('days')\n\t\t)\n\t);\n\n   # require DADA::App::LogSearch;\n   # my $dals = DADA::App::LogSearch->new;\n\n    my $headers = {\n        '-Cache-Control' => 'no-cache, must-revalidate',\n        -expires         => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        -type            => 'application/json',\n    };\n\t\n\tmy $dmlch = DADA::MailingList::ConsentActivity->new; \n\tmy $r = $dmlch->sub_unsub_trends_json(\n        {\n            -list     => $list,\n            -printout => 0,\n            -days     => $days,\n        }\n    );\n\n    $self->header_props(%$headers);\n    return $r;\n}\n\nsub recent_subscription_activity { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n\t\n    my $days = xss_filter(\n\t\tstrip(\n\t\t\tscalar $q->param('days')\n\t\t)\n\t) || 30; \n\t\n\trequire DADA::MailingList::ConsentActivity; \n\tmy $dmlch = DADA::MailingList::ConsentActivity->new; \n\tmy $r = $dmlch->list_activity( \n\t\t{ \n\t\t\t-list => $list, \n\t\t\t-days => $days, \n\t\t} \n\t);\n\t\n\tmy $i;\n    for ( $i = 0 ; $i <= ( scalar(@$r) - 1 ) ; $i++ ) {\n        $r->[$i]->{show_email} = 1;\n    }\n\t\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -list   => $list,\n            -screen => 'filtered_list_activity_widget.tmpl',\n            -vars => { \n\t\t\t\thistory => $r, \n\t\t\t},\n            -expr => 1,\n        }\n    );\n    return $body;\n\n}\n\nsub view_bounce_history {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $return_to      = $q->param('return_to') || 'view_list';\n    my $return_address = $q->param('return_address') || undef;\n\n    require DADA::App::BounceHandler::Logs;\n    my $bhl     = DADA::App::BounceHandler::Logs->new;\n    my $results = $bhl->search(\n        {\n            -query => scalar $q->param('email'),\n            -list  => $list,\n            -file  => $DADA::Config::LOGS . '/bounces.txt',\n        }\n    );\n\n    my $body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'bounce_search_results_modal_menu.tmpl',\n            -vars   => {\n                search_results => $results,\n                total_bounces  => scalar(@$results),\n                email          => scalar $q->param('email'),\n                type           => 'bounced_list',\n                return_to      => $return_to,\n                return_address => $return_address,\n            }\n        }\n    );\n    return $body;\n}\n\nsub subscription_requests {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    #?\n    if ( defined( $q->param('list') ) ) {\n        if ( $list ne $q->param('list') ) {\n            my ( $headers, $body ) =\n              $self->logout( -redirect_url => $DADA::Config::S_PROGRAM_URL . '?'\n                  . $q->query_string(), );\n            if ( keys %$headers ) {\n                $self->header_props(%$headers);\n            }\n            return $body;\n        }\n    }\n\n    my @address        = $q->multi_param('address');\n    my $return_to      = $q->param('return_to') || '';\n    my $return_address = $q->param('return_address') || '';\n\n    my $count = 0;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( $q->param('process') =~ m/approve/i ) {\n\n        for my $email (@address) {\n            $lh->move_subscriber(\n                {\n                    -email     => $email,\n                    -from      => 'sub_request_list',\n                    -to        => 'list',\n                    -mode      => 'writeover',\n                    -confirmed => 1,\n                }\n            );\n\t\t\t# The address shouldn't be on this list, but I guess it doesn't hurt to remove it here, too: \n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n\n            my $new_pass    = '';\n            my $new_profile = 0;\n            if (   $DADA::Config::PROFILE_OPTIONS->{enabled} == 1) {\n\n                # Make a profile, if needed,\n                require DADA::Profile;\n                my $prof =\n                  DADA::Profile->new( { -email => $email } );\n                if ( !$prof->exists ) {\n                    $new_profile = 1;\n                    $new_pass    = $prof->_rand_str(8);\n                    $prof->insert(\n                        {\n                            -password  => $new_pass,\n                            -activated => 1,\n                        }\n                    );\n                }\n\n                # / Make a profile, if needed,\n            }\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n            $dap->send_subscribed_message(\n                {\n                    -email => $email,\n                    -vars  => {\n                        new_profile        => $new_profile,\n                        'profile.email'    => $email,\n                        'profile.password' => $new_pass,\n                    }\n                }\n            );\n            $count++;\n        }\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&approved_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n    }\n    elsif ( $q->param('process') =~ m/deny/i ) {\n        for my $email (@address) {\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_request_list',\n                }\n            );\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n            $dap->send_subscription_request_denied_message(\n                {\n                    -email => $email,\n                }\n            );\n            $count++;\n        }\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&denied_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n\n    }\n    else {\n        die \"unknown process!\";\n    }\n\n}\n\nsub unsubscription_requests {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n#    #?\n#    if ( defined( $q->param('list') ) ) {\n#        if ( $list ne $q->param('list') ) {\n#            my ( $headers, $body ) =\n#              $self->logout( -redirect_url => $DADA::Config::S_PROGRAM_URL . '?' . $q->query_string(), );\n#            if ( keys %$headers ) {\n#                $self->header_props(%$headers);\n#            }\n#            return $body;\n#        }\n#    }\n\n    my @address        = $q->multi_param('address');\n    my $return_to      = $q->param('return_to') || '';\n    my $return_address = $q->param('return_address') || '';\n\n    my $count = 0;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( $q->param('process') =~ m/approve/i ) {\n\n        # go!\n        my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n            {\n                -addresses        => [@address],\n                -type             => 'list',\n                -validation_check => 0,\n            }\n        );\n\n        for my $email (@address) {\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_request_list',\n                }\n            );\n\t\t\t\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n\t\t\t\n\t\t\t\n\t\t\tif($ls->param('send_unsubscribed_by_list_owner_message') == 1){\n\t\t\t\t\n\t\t\t\t# warn 'sending send_unsubscribed_message'; \n\t\t\t\t$dap->send_unsubscribed_message(\n\t                {\n\t                    -email  => $email,\n\t                }\n\t            );\n\t\t\t}\n\t\t\telse { \n\t\t\t\t#warn 'SKIPPING sending send_unsubscribed_by_list_owner_message'; \n\t\t\t}\n        }\n\n        $count = int($count) + int($d_count);\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&approved_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n    }\n    elsif ( $q->param('process') =~ m/deny/i ) {\n        for my $email (@address) {\n            $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_request_list',\n                }\n            );\n            require DADA::App::Messages;\n            my $dap = DADA::App::Messages->new( { -list => $list } );\n            $dap->send_unsubscription_request_denied_message(\n                {\n                    -email => $email,\n                }\n            );\n            $count++;\n        }\n\n        my $flavor_to_return_to = 'view_list';\n        if ( $return_to eq 'membership' ) {    # or, others...\n            $flavor_to_return_to = $return_to;\n        }\n\n        my $qs = 'f='\n          . $flavor_to_return_to\n          . '&type='\n          . scalar( $q->param('type') )\n          . '&denied_count='\n          . $count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n\n    }\n    else {\n        die \"unknown process!\";\n    }\n\n}\n\nsub remove_all_subscribers {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    # This needs that email notification as well...\n    # I need to first, clone the list and then do my thing.\n    # Cloning will be really be resource intensive, so we can't do\n    # checks on each address,\n    # maybe the only check we'll do is to see if anything currently exists.\n    # If there is? Don't do the clone.\n    # If there isn't Do the clone\n    # maybe have a parameter saying what to do on an error.\n    # or just return undef.\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $black_list_add = 0;\n\n    my $type = xss_filter( scalar $q->param('type') );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::App::MassSend;\n    if ( $type eq 'list' ) {\n        if ( $ls->param('send_unsubscribed_by_list_owner_message') == 1 ) {\n            require DADA::App::MassSend;\n            eval {\n                my $dam = DADA::App::MassSend->new( { -list => $list } );\n                $dam->just_unsubscribed_mass_mailing(\n                    {\n                        -send_to_everybody => 1,\n                    }\n                );\n            };\n            if ($@) {\n                carp $@;\n            }\n        }\n\n        if (   $ls->param('black_list') == 1\n            && $ls->param('add_unsubs_to_black_list') == 1 )\n        {\n            $black_list_add = $lh->copy_all_subscribers(\n                {\n                    -from => 'list',\n                    -to   => 'black_list',\n                }\n            );\n        }\n\n    }\n\n    my $count = $lh->remove_all_subscribers( { -type => $type, } );\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor=view_list&delete_email_count='\n          . $count\n          . '&type='\n          . $type\n          . '&black_list_add='\n          . $black_list_add );\n\n}\n\nsub filter_using_black_list {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'filter_using_black_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    if ( !$process ) {\n\n        my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        my $filtered = $lh->filter_list_through_blacklist;\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -list           => $list,\n                -screen         => 'filter_using_black_list.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => { filtered => $filtered, },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub membership {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if ( !defined( $q->param('email') ) ) {\n        $self->view_list();\n    }\n    my $type = $q->param('type') || 'list';\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $process = $q->param('process')                    || undef;\n    my $done    = $q->param('done')                       || undef;\n    my $query   = xss_filter( scalar $q->param('query') ) || undef;\n    my $page    = xss_filter( scalar $q->param('page') )  || 1;\n    my $type    = xss_filter( scalar $q->param('type') );\n\n    my $order_by = $q->param('order_by') || $ls->param('view_list_order_by');\n    my $order_dir = $q->param('order_dir')\n      || lc( $ls->param('view_list_order_by_direction') );\n\n    my $add_email_count    = $q->param('add_email_count')    || 0;\n    my $delete_email_count = $q->param('delete_email_count') || 0;\n    my $black_list_add     = $q->param('black_list_add')     || 0;\n    my $approved_count     = $q->param('approved_count')     || 0;\n    my $denied_count       = $q->param('denied_count')       || 0;\n    my $bounced_list_moved_to_list_count =\n      $q->param('bounced_list_moved_to_list_count') || 0;\n    my $bounced_list_removed_from_list =\n      $q->param('bounced_list_removed_from_list') || 0;\n    my $update_email_count = $q->param('update_email_count') || 0;\n    my $profile_exists = 0;\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -email => scalar $q->param('email') } );\n\n    if ($prof) {\n        $profile_exists = $prof->exists;\n    }\n    if ($process) {\n        if ( $root_login != 1 && $ls->param('allow_profile_editing') != 1 ) {\n            die\n\"You must be logged in with the Dada Mail Root Password to be able to edit a Subscriber's Profile Fields.\";\n        }\n        my $new_fields = {};\n        for my $nfield ( @{ $lh->subscriber_fields() } ) {\n            if ( defined( $q->param($nfield) ) ) {\n                $new_fields->{$nfield} = $q->param($nfield);\n            }\n        }\n\n        my $fields = DADA::Profile::Fields->new;\n        $fields->insert(\n            {\n                -email  => scalar $q->param('email'),\n                -fields => $new_fields,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=membership&email='\n              . scalar( $q->param('email') )\n              . '&type='\n              . $type\n              . '&done=1' );\n    }\n    else {\n\n        my $fields = [];\n\n        my $subscriber_info = {};\n\n# this is a hack - if type has nothing, this fails, so we fill it in with, \"list\"\n        if ( !defined($type) || $type eq '' ) { $type = 'list'; }\n        $subscriber_info =\n          $lh->get_subscriber( { -email => scalar $q->param('email') } );\n\n        # DEV: This is repeated quite a bit...\n        require DADA::ProfileFieldsManager;\n        my $pfm         = DADA::ProfileFieldsManager->new;\n        my $fields_attr = $pfm->get_all_field_attributes;\n        for my $field ( @{ $lh->subscriber_fields() } ) {\n            push(\n                @$fields,\n                {\n                    name     => $field,\n                    value    => $subscriber_info->{$field},\n                    label    => $fields_attr->{$field}->{label},\n                    required => $fields_attr->{$field}->{required},\n                }\n            );\n        }\n\n        my $subscribed_to_lt = {};\n        for ( @{ $lh->member_of( { -email => scalar $q->param('email') } ) } ) {\n            $subscribed_to_lt->{$_} = 1;\n        }\n\n        my %add_list_types = %{ DADA::App::Guts::list_types() };\n\n        my $add_to = {\n            list                => 1,\n\t\t\ttest_list           => 1,\n            black_list          => 1,\n            white_list          => 1,\n            authorized_senders  => 1,\n            moderators          => 1,\n\t\t\tignore_bounces_list => 1, \n        };\n\n        # Except when, it's already a part of that sublist:\n        for ( keys %$subscribed_to_lt ) {\n            delete( $add_to->{$_} );    # if $subscribed_to_lt->{$_} == 1;\n        }\n\n        # Or if it's blacklisted... can't add!\n        if ( $ls->param('closed_list') == 1 ) {\n            delete( $add_to->{list} );\n        }\n        if (   $ls->param('black_list') == 1\n            && $ls->param('allow_admin_to_subscribe_blacklisted') != 1\n            && $subscribed_to_lt->{black_list} == 1 )\n        {\n            delete( $add_to->{list} );\n        }\n        if (   $ls->param('enable_subscription_approval_step')\n            && $subscribed_to_lt->{sub_request_list} )\n        {\n            delete( $add_to->{list} );\n        }\n\n        # if Authorized Senders isn't active, well, let's not allow to be added:\n        if ( $ls->param('enable_authorized_sending') == 1 ) {\n\n            #...\n        }\n        else {\n            delete( $add_to->{authorized_senders} );\n        }\n\n        # if Moderators isn't active, well, let's not allow to be added:\n        if ( $ls->param('enable_moderation') == 1 ) {\n\n            #...\n        }\n        else {\n            delete( $add_to->{moderators} );\n        }\n\n        # Same with the white list\n        if ( $ls->param('enable_white_list') == 1 ) {\n\n            #...\n        }\n        else {\n            delete( $add_to->{white_list} );\n\n        }\n\n\t\t# guess add a thingy where we do not allow adds to this unless the bounce handler is running.. \n\t\t# and the option to use this guy is enabled. ignore_bounces_list\n\n        my $is_bouncing_address = 0;\n        my $bouncing_info       = '';\n        if ( $subscribed_to_lt->{bounced_list} == 1 ) {\n            $is_bouncing_address = 1;\n\n        }\n\n        require HTML::Menu::Select;\n        my $add_to_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'type',\n                id      => 'type_add',\n                default => 'list',\n                values  => [ keys %$add_to ],\n                labels  => \\%add_list_types,\n            }\n        );\n\n        # Only if black list is enabled and they're not currently subscribed.\n        if ( $ls->param('black_list') == 1 && $subscribed_to_lt->{list} != 1 ) {\n\n            # ...\n        }\n        else {\n            delete( $add_to->{black_list} );\n        }\n\n        my $member_of   = [];\n        my $remove_from = [];\n        my $list_types  = DADA::App::Guts::list_types();\n\n        foreach (%$subscribed_to_lt) {\n            if ( $_ =~\nm/^(list|test_list|black_list|white_list|authorized_senders|moderators|requires_moderation|bounced_list|ignore_bounces_list|sub_confirm_list)$/\n              )\n            {\n                push( @$member_of,\n                    { type => $_, type_title => $list_types->{$_} } );\n                push( @$remove_from, $_ );\n            }\n        }\n\n        require HTML::Menu::Select;\n        my $remove_from_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name   => 'type_remove',\n                id     => 'type_remove',\n                values => $remove_from,\n                labels => $list_types,\n            }\n        );\n\n        my @update_option_values = ( ':all', ( keys %$subscribed_to_lt ) );\n        my %update_option_labels = ( ':all' => 'All Sublists', $list_types );\n        my $update_address_popup_menu = HTML::Menu::Select::popup_menu(\n            {\n                name   => 'type_update',\n                id     => 'type_update',\n                values => [@update_option_values],\n                labels => {%update_option_labels},\n            }\n        );\n\n        my $subscribed_to_list = 0;\n        if ( $subscribed_to_lt->{list} == 1 ) {\n            $subscribed_to_list = 1;\n\n        }\n\n        my $subscribed_to_sub_request_list = 0;\n        if ( $subscribed_to_lt->{sub_request_list} == 1 ) {\n            $subscribed_to_sub_request_list = 1;\n        }\n\n        my $subscribed_to_sub_confirm_list = 0;\n        if ( $subscribed_to_lt->{sub_confirm_list} == 1 ) {\n            $subscribed_to_sub_confirm_list = 1;\n        }\n\n        require DADA::Profile::Settings;\n        my $dps = DADA::Profile::Settings->new({-list => $list});\n        my $s   = $dps->fetch(\n            {\n                -email => scalar $q->param('email'),\n            }\n        );\n        my $delivery_prefs = $s->{delivery_prefs} || 'individual';\n        my $digest_timeframe =\n          formatted_runtime( $ls->param('digest_schedule') );\t\n\t\t\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'membership_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    done              => $done,\n                    email             => scalar $q->param('email'),\n                    type              => $type,\n                    page              => $page,\n                    query             => $query,\n                    order_by          => $order_by,\n                    order_dir         => $order_dir,\n                    type_title        => $DADA::Config::LIST_TYPES->{$type},\n                    fields            => $fields,\n                    root_login        => $root_login,\n                    profile_exists    => $profile_exists,\n                    add_to_popup_menu => $add_to_popup_menu,\n                    update_address_popup_menu => $update_address_popup_menu,\n                    remove_from_popup_menu    => $remove_from_popup_menu,\n                    remove_from_num           => scalar(@$remove_from),\n                    member_of                 => $member_of,\n                    is_bouncing_address       => $is_bouncing_address,\n                    rand_string               => generate_rand_string_md5(),\n                    member_of_num             => scalar(@$remove_from),\n                    add_to_num                => scalar( keys %$add_to ),\n                    subscribed_to_list        => $subscribed_to_list,\n                    subscribed_to_sub_request_list =>\n                      $subscribed_to_sub_request_list,\n                    subscribed_to_sub_confirm_list =>\n                      $subscribed_to_sub_confirm_list,\n\n                    add_email_count    => $add_email_count,\n                    delete_email_count => $delete_email_count,\n                    black_list_add     => $black_list_add,\n                    approved_count     => $approved_count,\n                    denied_count       => $denied_count,\n                    bounced_list_moved_to_list_count =>\n                      $bounced_list_moved_to_list_count,\n                    bounced_list_removed_from_list =>\n                      $bounced_list_removed_from_list,\n\n                    can_have_subscriber_fields =>\n                      $lh->can_have_subscriber_fields,\n\n                    delivery_prefs   => $delivery_prefs,\n                    digest_timeframe => $digest_timeframe,\n\n                    update_email_count => $update_email_count,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub validate_update_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Subscribers;\n    require DADA::MailingList::Subscriber::Validate;\n    require DADA::MailingList::Settings;\n\n    my $list_types = DADA::App::Guts::list_types();\n\n    my %error_title = (\n        invalid_email    => 'Invalid Email Address',\n        subscribed       => 'Already Subscribed',\n        mx_lookup_failed => 'MX Lookup Failed',\n        black_listed     => 'Black Listed',\n        not_white_listed => 'Not on the White List',\n    );\n\n    my $for_all_lists     = $q->param('for_all_lists') || 0;\n    my $lists_to_validate = [];\n    my $email             = cased( xss_filter( scalar $q->param('email') ) );\n    my $updated_email =\n      cased( xss_filter( scalar $q->param('updated_email') ) );\n    my $process = $q->param('process') || 0;\n\n    my $list_lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    # not sure where I'm going with, with, \"can_have_subscriber_fields\"\n    if ( $list_lh->can_have_subscriber_fields ) {\n        if ( $for_all_lists == 1 && $root_login == 1 ) {\n            require DADA::Profile;\n            my $prof = DADA::Profile->new( { -email => $email } );\n            $lists_to_validate = $prof->subscribed_to;\n        }\n        else {\n            push( @$lists_to_validate, $list );\n        }\n    }\n    else {\n        push( @$lists_to_validate, $list );\n    }\n\n    # old address\n\n    if ( $process != 1 ) {\n\n        my $list_validations = [];\n        my $none_validated   = 1;\n\n        for my $to_validate_list (@$lists_to_validate) {\n\n            my $type_reports = [];\n\n            my $lh = DADA::MailingList::Subscribers->new(\n                { -list => $to_validate_list } );\n            my $sv = DADA::MailingList::Subscriber::Validate->new(\n                { -list => $to_validate_list } );\n            my $ls = DADA::MailingList::Settings->new(\n                { -list => $to_validate_list } );\n\n            for my $type (\n                @{\n                    $lh->member_of(\n                        {\n                            -email => $email,\n                            -types => [\n                                qw(list black_list test_list white_list authorized_senders moderators requires_moderation ignore_bounces_list)\n                            ],\n                        }\n                    )\n                }\n              )\n            {\n                my $sublists = [];\n\n                # new address\n                my ( $sub_status, $sub_errors ) = $sv->subscription_check(\n                    {\n                        -email => $updated_email,\n                        -type  => $type,\n                        -skip  => [\n                            'closed_list',\n                            'over_subscription_quota',\n                            'already_sent_sub_confirmation',\n                            'invite_only_list',\n                            'profile_fields',\n                            'stop_forum_spam_check_failed',\n                            'suspicious_activity_by_ip_check_failed',\n\t\t\t\t\t\t\t'captcha_challenge_failed',\n\t\t\t\t\t\t\t'list_consent_check',\n                            (\n                                $ls->param(\n                                    'allow_admin_to_subscribe_blacklisted') == 1\n                            ) ? ( 'black_listed', ) : (),\n                        ],\n                    }\n                );\n\n                if ( $sub_status == 1 && $none_validated == 1 ) {\n                    $none_validated = 0;\n                }\n                my $errors = [];\n                for ( keys %$sub_errors ) {\n                    push( @$errors,\n                        { error => $_, error_title => $error_title{$_} } );\n                }\n\n                $sublists = {\n                    type                 => $type,\n                    type_label           => $list_types->{$type},\n                    status               => $sub_status,\n                    errors               => $errors,\n                    'list_settings.list' => $ls->param('list'),\n\n                };\n                push( @$type_reports, $sublists );\n            }\n\n            push(\n                @$list_validations,\n                {\n                    'list_settings.list'      => $ls->param('list'),\n                    'list_settings.list_name' => $ls->param('list_name'),\n                    sublists                  => $type_reports\n                },\n            );\n\n        }\n\n        require Data::Dumper;\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'validate_update_email_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    email                  => $email,\n                    updated_email          => $updated_email,\n                    update_list_validation => $list_validations,\n                    none_validated         => $none_validated,\n                    validate_dump => Data::Dumper::Dumper($list_validations),\n\n                    #all_list_status       => $all_list_status,\n                    #all_list_reports      => $all_list_reports,\n                    #for_all_lists         => $for_all_lists,\n                    #root_login            => $root_login,\n\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n        my @update_list   = $q->multi_param('update_list');\n        my $total_u_count = 0;\n\n        foreach my $update_list (@update_list) {\n            my ( $u_list, $u_type ) = split( ':', $update_list, 2 );\n            my $lh =\n              DADA::MailingList::Subscribers->new( { -list => $u_list } );\n            my ($u_count) = $lh->admin_update_address(\n                {\n                    -email            => $email,\n                    -updated_email    => $updated_email,\n                    -type             => $u_type,\n                    -validation_check => 0,\n                }\n            );\n            $total_u_count = $total_u_count + $u_count;\n\n        }\n\n        my $return_to      = 'membership';\n        my $return_address = $updated_email;\n\n        my $qs =\n          'flavor=' \n\t\t  . $return_to \n\t\t  . '&update_email_count=' \n\t\t  . $total_u_count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props(\n\t\t\t-url => $DADA::Config::S_PROGRAM_URL . '?' . $qs\n\t\t);\n    }\n\n}\n\nsub also_member_of {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list  = $admin_list;\n    my $email = xss_filter( scalar $q->param('email') );\n    my $type  = xss_filter( scalar $q->param('type') ) || 'list';\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $mto = 0;\n\n    my @also_subscribed_to = $lh->also_subscribed_to(\n        {\n            -email => $email,\n            -types =>\n              [qw(list black_list white_list authorized_senders moderators ignore_bounces_list)],\n        }\n    );\n    if ( scalar @also_subscribed_to > 0 ) {\n        $mto = 1;\n    }\n    require JSON;\n    my $json    = JSON->new->allow_nonref;\n    my $headers = { -type => 'application/json' };\n    my $body    = $json->encode(\n        {\n            also_member_of => int($mto)\n        }\n    );\n    $self->header_props(%$headers);\n    return $body;\n}\n\nsub validate_remove_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list             = $admin_list;\n    my $type             = xss_filter( scalar $q->param('type') );\n    my $email            = xss_filter( scalar $q->param('email') );\n    my $process          = xss_filter( scalar $q->param('process') ) || 0;\n    my @remove_from_list = $q->multi_param('remove_from_list');\n    my $return_to        = xss_filter( scalar $q->param('return_to') ) || 0;\n\n\n    my $for_multiple_lists =\n      xss_filter( scalar $q->param('for_multiple_lists') ) || 0;\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n        my @lists = ($list);\n        if ( $for_multiple_lists == 1 ) {\n            my @also_subscribed_to = $lh->also_subscribed_to(\n                {\n                    -email => $email,\n                    -types => [\n                        qw(\n\t\t\t\t\t\t\tlist \n\t\t\t\t\t\t\tblack_list \n\t\t\t\t\t\t\twhite_list \n\t\t\t\t\t\t\tauthorized_senders \n\t\t\t\t\t\t\tmoderators \n\t\t\t\t\t\t\trequires_moderation \n\t\t\t\t\t\t\tsub_confirm_list \n\t\t\t\t\t\t\tignore_bounces_list\n\t\t\t\t\t\t)\n                    ],\n                }\n            );\n            @lists = ( @lists, @also_subscribed_to );\n        }\n\n        my $subscribed_lists = [];\n\n        my $list_types = DADA::App::Guts::list_types();\n\n\t\n\n        foreach my $tmp_list (@lists) {\n            my $tmp_ls =\n              DADA::MailingList::Settings->new( { -list => $tmp_list } );\n            my $tmp_lh =\n              DADA::MailingList::Subscribers->new( { -list => $tmp_list } );\n\n            my $sublists = [];\n            for my $sublist (\n                @{\n                    $tmp_lh->member_of(\n                        {\n                            -email => $email,\n                            -types => [\n                                qw(list black_list white_list authorized_senders moderators requires_moderation  sub_confirm_list ignore_bounces_list)\n                            ],\n                        }\n                    )\n                }\n              )\n            {\n                push(\n                    @$sublists,\n                    {\n                        type                 => $sublist,\n                        type_label           => $list_types->{$sublist},\n                        'list_settings.list' => $tmp_ls->param('list'),\n                        'list_settings.list_name' =>\n                          $tmp_ls->param('list_name'),\n                    }\n                );\n            }\n\n            push(\n                @$subscribed_lists,\n                {\n                    'list_settings.list'      => $tmp_ls->param('list'),\n                    'list_settings.list_name' => $tmp_ls->param('list_name'),\n                    sublists                  => $sublists,\n                }\n            );\n        }\n\n        require Data::Dumper;\n        my $subscribed_lists_dump = Data::Dumper::Dumper($subscribed_lists);\n\n        my $body = DADA::Template::Widgets::screen(\n            {\n                -screen => 'validate_remove_email_widget.tmpl',\n                -vars   => {\n                    email                 => $email,\n                    list_type             => $type,\n                    list_type_label       => $list_types->{$type},\n                    for_multiple_lists    => $for_multiple_lists,\n                    subscribed_lists      => $subscribed_lists,\n                    subscribed_lists_dump => $subscribed_lists_dump,\n                }\n            }\n        );\n\n        return $body;\n    }\n    else {\n\n        my $full_d_count  = 0;\n        my $full_bl_count = 0;\n        foreach my $remove_list (@remove_from_list) {\n            my ( $r_list, $r_type ) = split( ':', $remove_list, 2 );\n            my $lh =\n              DADA::MailingList::Subscribers->new( { -list => $r_list } );\n            my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n                {\n                    -addresses        => [$email],\n                    -type             => $r_type,\n                    -validation_check => 0,\n                }\n            );\n            $full_d_count  = $full_d_count + $d_count;\n            $full_bl_count = $full_bl_count + $bl_count;\n        }\n\n        my $return_address = $email;\n\n        my $qs =\n            'flavor='\n          . $return_to\n          . '&delete_email_count='\n          . $full_d_count\n          . '&type=' . ''\n          . '&black_list_add='\n          . $full_bl_count;\n\n        if ( $return_to eq 'membership' ) {\n            $qs .= '&email=' . uriescape($return_address);\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n    }\n}\n\nsub mailing_list_history {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list  = $admin_list;\n    my $email = xss_filter( scalar $q->param('email') );\n    my $mode  = xss_filter( scalar $q->param('mode') ) || 'html';\n\n\t# consent\n  \trequire DADA::MailingList::ConsentActivity; \n  \tmy $dmlch = DADA::MailingList::ConsentActivity->new; \n\n    if ( $mode eq 'html' ) {\n\n\t  \tmy $consent_history = $dmlch->consent_history_report({\n\t  \t\t-list  => $list, \n\t  \t\t-email  => scalar $q->param('email'), \n\t  \t});\n\t\t\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'filtered_list_consent_activity_widget.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    consent_history => $consent_history,\n                },\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $mode eq 'export_csv' ) {\n\n\n\t  \tmy $consent_history_csv = $dmlch->consent_history_report({\n\t  \t\t-list  => $list, \n\t  \t\t-email  => scalar $q->param('email'), \n\t\t\t-as_csv => 1, \n\t  \t});\n\t\t\n\t\t# /consent\n\t\t#require Data::Dumper; \n\t\t#my $consent_history_str = Data::Dumper::Dumper($consent_history);\n\t\t\n        my $headers = {\n            -attachment => 'membership_history-' . $list . '-' . time . '.csv',\n            -type       => 'text/csv',\n        };\n        $self->header_props(%$headers);\n        return $consent_history_csv;\n\t\t\n=pod\n\t\t\n\t\t\n\t\t\n        require Text::CSV;\n        my $csv = Text::CSV->new($DADA::Config::TEXT_CSV_PARAMS);\n        my $fh  = \\*STDOUT;\n\n        my $headers = {\n            -attachment => 'membership_history-' . $list . '-' . time . '.csv',\n            -type       => 'text/csv',\n        };\n\n        my $body;\n        my @cols = qw(\n          date\n          list\n          list_name\n          ip\n          email\n          type\n          type_title\n          action\n          updated_email\n        );\n\n        my $status = $csv->combine(@cols);\n        $body .= $csv->string() . \"\\n\";\n\n        for my $line (@$r) {\n            my @lines = ();\n            foreach (@cols) {\n                push( @lines, $line->{$_} );\n            }\n            $status = $csv->combine(@lines);\n            $body .= $csv->string() . \"\\n\";\n        }\n\n        $self->header_props(%$headers);\n        return $body;\n\t\t\n=cut\n\t\t\n    }\n}\n\nsub membership_activity {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list  = $admin_list;\n    my $email = xss_filter( scalar $q->param('email') );\n    my $mode  = xss_filter( scalar $q->param('mode') ) || 'html';\n\n    if ( $mode eq 'html' ) {\n        require DADA::Logging::Clickthrough;\n        my $rd = DADA::Logging::Clickthrough->new( { -list => $list } );\n\n        require DADA::MailingList::Archives;\n        my $ma = DADA::MailingList::Archives->new( { -list => $list } );\n\n        my $activity_tables = [];\n        my ( $total, $mids ) = $rd->get_all_mids;\n        foreach my $mid (@$mids) {\n            my $plugin_url = $DADA::Config::S_PROGRAM_URL . '/plugins/tracker';\n            my $activity_table =\n              $rd->message_individual_email_activity_report_table(\n                {\n                    -mid        => $mid,\n                    -email      => $email,\n                    -plugin_url => $plugin_url,\n\n                }\n              );\n\n            my $archive_exists  = 0;\n            my $archive_subject = '';\n            if ( $ma->check_if_entry_exists($mid) ) {\n                $archive_exists  = 1;\n                $archive_subject = $ma->get_archive_subject($mid);\n            }\n\n            push(\n                @$activity_tables,\n                {\n                    activity_table  => $activity_table,\n                    archive_exists  => $archive_exists,\n                    archive_subject => $archive_subject,\n                    mid             => $mid,\n                }\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'membership_activity_screen.tmpl',\n                -vars   => { activity_tables => $activity_tables, },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $at_email = $email;\n        $at_email =~ s/\\@/_at_/;\n\n        require DADA::Logging::Clickthrough;\n        my $rd = DADA::Logging::Clickthrough->new( { -list => $list } );\n\n        require Text::CSV;\n        my $csv = Text::CSV->new($DADA::Config::TEXT_CSV_PARAMS);\n\n        my $fh = \\*STDOUT;\n\n        my $headers = {\n            -attachment => 'membership_activity-'\n              . $at_email . '-'\n              . $list . '-'\n              . time . '.csv',\n            -type => 'text/csv',\n        };\n        my $body;\n\n        #\t\ttimestamp\n        #\t\ttime\n        #\t\tevent_label\n\n        my @cols = qw(\n          ctime\n          mid\n          email\n          ip\n          event\n          url\n        );\n\n        my $status = $csv->combine(@cols);\n        $body .= $csv->string() . \"\\n\";\n\n        my ( $total, $mids ) = $rd->get_all_mids;\n        foreach my $mid (@$mids) {\n\n            my $report = $rd->message_individual_email_activity_report(\n                {\n                    -mid   => $mid,\n                    -email => $email,\n                }\n            );\n\n            for my $line (@$report) {\n                my @lines = ();\n                foreach (@cols) {\n                    if ( $_ eq 'email' ) {\n                        push( @lines, $email );\n                    }\n                    elsif ( $_ eq 'mid' ) {\n                        push( @lines, $mid );\n                    }\n                    else {\n                        push( @lines, $line->{$_} );\n                    }\n                }\n                my $status = $csv->combine(@lines);\n                $body .= $csv->string() . \"\\n\";\n            }\n        }\n        $self->header_props(%$headers);\n        return $body;\n    }\n}\n\nsub admin_change_profile_password {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list             = $admin_list;\n    my $profile_password = xss_filter( scalar $q->param('profile_password') );\n    my $email            = xss_filter( scalar $q->param('email') );\n    my $type             = xss_filter( scalar $q->param('type') );\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -email => $email } );\n\n    if ( $prof->exists ) {\n\n        $prof->update( { -password => $profile_password, } );\n\n        # Reactivate the Account. ?\n        $prof->activate();\n    }\n    else {\n        $prof->insert(\n            {\n                -password  => $profile_password,\n                -activated => 1,\n            }\n        );\n    }\n\n    # DEV: This is going to get repeated quite a bit..\n    require DADA::Profile::Htpasswd;\n    foreach my $p_list ( @{ $prof->subscribed_to } ) {\n        my $htp = DADA::Profile::Htpasswd->new( { -list => $p_list } );\n        for my $id ( @{ $htp->get_all_ids } ) {\n            $htp->setup_directory( { -id => $id } );\n        }\n    }\n    #\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n          . '?flavor=membership&email='\n          . uriescape($email)\n          . '&type='\n          . $type\n          . '&done=1' );\n\n}\n\nsub admin_profile_delivery_preferences {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'membership'\n      );\n\n    my $email = xss_filter( scalar $q->param('email') );\n    my $list = $admin_list;    #xss_filter( scalar $q->param('list') );\n    my $delivery_prefs = xss_filter( scalar $q->param('delivery_prefs') );\n    my $type           = xss_filter( scalar $q->param('type') );\n    my $process        = xss_filter( scalar $q->param('process') );\n\n    if ( !$checksout ) {\n\n        if ( $process eq 'ajax' ) {\n\n            require JSON;\n            my $json = JSON->new->allow_nonref;\n\n            $self->header_props( -type => 'application/json' );\n            my $r = $json->encode(\n                {\n                    status => 0,\n                    error  => $error_msg\n                }\n            );\n            return $r;\n\n        }\n        else {\n            return $error_msg;\n        }\n    }\n\n    my $params = {\n        -email   => $email,\n        -setting => 'delivery_prefs',\n        -value   => $delivery_prefs,\n    };\n\n    require DADA::Profile::Settings;\n \tmy $dps = DADA::Profile::Settings->new({-list => $list});\n    my $r   = $dps->save($params);\n\n    if ( $process eq 'ajax' ) {\n        require JSON;\n        my $json = JSON->new->allow_nonref;\n\n        $self->header_props( -type => 'application/json' );\n        return $json->encode(\n            {\n                status => 1,\n            }\n        );\n\n    }\n    else {\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=membership&email='\n              . uriescape($email)\n              . '&type='\n              . $type\n              . '&done=1' );\n    }\n}\n\nsub add {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'add'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list   = $admin_list;\n    my $chrome = $q->param('chrome');\n    if ( $chrome ne '0' ) { $chrome = 1; }\n\n    my $type           = $q->param('type')           || 'list';\n    my $return_to      = $q->param('return_to')      || '';\n    my $return_address = $q->param('return_address') || '';\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( $q->param('process') ) {\n\n        if ( $q->param('method') eq 'via_add_one' ) {\n\n# We're going to fake the, \"via_textarea\", buy just make a CSV file, and plunking it\n# in the, \"new_emails\" CGI param. (Hehehe);\n\n            my @columns = ();\n            push( @columns, xss_filter( scalar $q->param('email') ) );\n            for ( @{ $lh->subscriber_fields() } ) {\n                push( @columns, xss_filter( scalar $q->param($_) ) );\n            }\n            if ( $type eq 'list' && $lh->can_have_subscriber_fields ) {\n                push( @columns,\n                    xss_filter( scalar $q->param('profile_password') ) );\n            }\n\n            require Text::CSV;\n            my $csv = Text::CSV->new($DADA::Config::TEXT_CSV_PARAMS);\n\n            my $status =\n              $csv->combine(@columns);    # combine columns into a string\n            my $line = $csv->string();    # get the combined string\n\n            $q->param( 'new_emails', $line );\n            $q->param( 'method',     'via_textarea' );\n\n            # End shienanengans.\n\n        }\n\n        if ( $q->param('method') eq 'via_file_upload' ) {\n            if ( strip( scalar $q->param('new_email_file') ) eq '' ) {\n\n                $self->header_type('redirect');\n                $self->header_props(\n                    -url => $DADA::Config::S_PROGRAM_URL . '?flavor=add' );\n            }\n        }\n        elsif ( $q->param('method') eq 'via_textarea' ) {\n            if ( strip( scalar $q->param('new_emails') ) eq '' ) {\n                $self->header_type('redirect');\n                $self->header_props(\n                    -url => $DADA::Config::S_PROGRAM_URL . '?flavor=add' );\n            }\n        }\n\n        # DEV: This whole building of query string is much too messy.\n        my $qs =\n            '&type='\n          . scalar( $q->param('type') )\n          . '&new_email_file='\n          . uriescape( scalar( $q->param('new_email_file') ) );\n\n        if ( DADA::App::Guts::strip( scalar $q->param('new_emails') ) ne \"\" ) {\n\n          # DEV: why is it, \"new_emails.txt\"? Is that supposed to be a variable?\n            my $outfile =\n              make_safer( $DADA::Config::TMP . '/'\n                  . scalar( $q->param('rand_string') ) . '-'\n                  . 'new_emails.txt' );\n\n            open( OUTFILE, '>:encoding(UTF-8)', $outfile )\n              or die \"can't write to \" . $outfile . \": $!\";\n\n            # DEV: TODO encoding?\n            print OUTFILE $q->param('new_emails');\n            close(OUTFILE);\n            chmod( $DADA::Config::FILE_CHMOD, $outfile );\n\n          # DEV: why is it, \"new_emails.txt\"? Is that supposed to be a variable?\n            my $redirect =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=add_email&fn='\n              . scalar( $q->param('rand_string') ) . '-'\n              . 'new_emails.txt'\n              . $qs\n              . '&return_to='\n              . $return_to\n              . '&return_address='\n              . uriescape($return_address)\n              . '&chrome='\n              . $chrome;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $redirect );\n\n        }\n        else {\n\n            if ( $q->param('method') eq 'via_file_upload' ) {\n                $self->_upload_that_file($q);\n            }\n            my $filename = $q->param('new_email_file');\n            $filename =~ s!^.*(\\\\|\\/)!!;\n\n            $filename = uriescape($filename);\n\n            my $redirect =\n                $DADA::Config::S_PROGRAM_URL\n              . '?flavor=add_email&fn='\n              . scalar( $q->param('rand_string') ) . '-'\n              . $filename\n              . $qs;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $redirect );\n\n        }\n    }\n    else {\n        require DADA::MailingList::Settings;\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        my $num_subscribers            = $lh->num_subscribers();\n        my $subscription_quota_reached = 0;\n        if ( $type eq 'list' ) {\n            if (   $ls->param('use_subscription_quota') == 1\n                && ( $num_subscribers >= $ls->param('subscription_quota') )\n                && ( $num_subscribers + $ls->param('subscription_quota') > 1 ) )\n            {\n                $subscription_quota_reached = 1;\n            }\n            elsif (defined($DADA::Config::SUBSCRIPTION_QUOTA)\n                && $DADA::Config::SUBSCRIPTION_QUOTA > 0\n                && $num_subscribers >= $DADA::Config::SUBSCRIPTION_QUOTA )\n            {\n                $subscription_quota_reached = 1;\n            }\n        }\n\t\t\n\t\t# I reuse, \"$subscription_quota_reached\" here: \n\t\tif (\n\t\t\t\t $type eq 'test_list' \n\t\t\t && $ls->param('enable_test_list_address_limit')\n\t\t ) {\n\n\t        my $num_subscribers            = $lh->num_subscribers({-type => $type});\n\t\t\tif($num_subscribers >= $ls->param('test_list_address_limit')){ \n\t\t\t\t$subscription_quota_reached = 1; \n\t\t\t}\n\t\t}\n\t\t\n        require HTML::Menu::Select;\n        my $view_list_type_switch_widget = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'type',\n                values  => [ keys %{ DADA::App::Guts::list_types() } ],\n                labels  => DADA::App::Guts::list_types(),\n                default => $type,\n            }\n        );\n\n        my $rand_string = generate_rand_string_md5();\n\n        my $fields = [];\n\n        # DEV: This is repeated quite a bit...\n        require DADA::ProfileFieldsManager;\n        my $pfm         = DADA::ProfileFieldsManager->new;\n        my $fields_attr = $pfm->get_all_field_attributes;\n        for my $field ( @{ $lh->subscriber_fields() } ) {\n            push(\n                @$fields,\n                {\n                    name     => $field,\n                    label    => $fields_attr->{$field}->{label},\n                    required => $fields_attr->{$field}->{required},\n                }\n            );\n        }\n\n        my $list_is_closed = 0;\n        if (   $type eq 'list'\n            && $ls->param('closed_list') == 1 )\n        {\n            $list_is_closed = 1;\n        }\n\t\t\n        my $show_bounced_list = 0;\n        if (   $lh->num_subscribers( { -type => 'bounced_list' } ) > 0\n            || $ls->param('bounce_handler_when_threshold_reached') eq\n            'move_to_bounced_sublist' )\n        {\n            $show_bounced_list = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'add_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen                     => 'add',\n                    root_login                 => $root_login,\n                    subscription_quota_reached => $subscription_quota_reached,\n                    num_subscribers            => $num_subscribers,\n                    SUBSCRIPTION_QUOTA => $DADA::Config::SUBSCRIPTION_QUOTA,\n                    type               => $type,\n                    type_title         => $DADA::Config::LIST_TYPES->{$type},\n                    flavor             => 'add',\n                    rand_string        => $rand_string,\n                    \n\t\t\t\t\tlist_subscribers_num =>\n                      scalar $lh->num_subscribers( { -type => 'list' } ),\n\t\t\t\t\t  \n  \t\t\t\t\ttest_list_subscribers_num =>\n                        scalar $lh->num_subscribers( { -type => 'test_list' } ),\n                    \n\t\t\t\t\tblack_list_subscribers_num =>\n                      scalar $lh->num_subscribers( { -type => 'black_list' } ),\n                    \n\t\t\t\t\twhite_list_subscribers_num =>\n                      scalar $lh->num_subscribers( { -type => 'white_list' } ),\n                    \n\t\t\t\t\tauthorized_senders_num =>\n                      scalar $lh->num_subscribers( { -type => 'authorized_senders' } ),\n                    \n                  moderators_num => scalar commify(\n                      $lh->num_subscribers( { -type => 'moderators' } )\n                  ),\n\t\t\t\t\n\t\t\t\t\trequires_moderation_num => scalar commify(\n\t\t\t\t\t\t$lh->num_subscribers( { -type => 'requires_moderation' } )\n\t\t\t\t\t),\n\t\t\t\t\t  \n\t\t\t\t\tbounced_list_num =>\n                      scalar $lh->num_subscribers( { -type => 'bounced_list' } ),\n\t\t\t\t\t\n\t\t\t\t\tignore_bounces_list_num => \n\t\t\t\t\t\tscalar $lh->num_subscribers( { -type => 'ignore_bounces_list' } ),\n\t\t\t\t\t\t\n\t\t\t\t\tshow_bounced_list => $show_bounced_list,\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t  \n                    fields => $fields,\n                    can_have_subscriber_fields =>\n                      $lh->can_have_subscriber_fields,\n                    list_is_closed => $list_is_closed,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n\n}\n\nsub check_status {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    require JSON;\n    my $json = JSON->new->allow_nonref;\n\n    my $filename = $q->param('new_email_file');\n    $filename =~ s{^(.*)\\/}{};\n    $filename = uriescape($filename);\n\n    if ( !-e $DADA::Config::TMP . '/' . $filename . '-meta.txt' ) {\n        warn \"no meta file at: \"\n          . $DADA::Config::TMP . '/'\n          . $filename\n          . '-meta.txt';\n        my $json = JSON->new->allow_nonref;\n        $self->header_props( -type => 'application/json' );\n        return $json->encode(\n            { percent => 0, content_length => 0, bytes_read => 0 } );\n    }\n    else {\n\n        chmod( $DADA::Config::FILE_CHMOD,\n            make_safer( $DADA::Config::TMP . '/' . $filename . '-meta.txt' ) );\n\n        open my $META, '<',\n          make_safer( $DADA::Config::TMP . '/' . $filename . '-meta.txt' )\n          or die $!;\n\n        my $s = do { local $/; <$META> };\n\n        my ( $bytes_read, $content_length, $per ) = split( '-', $s, 3 );\n        if ( $per == 99 ) { $per = 100 }\n        close($META);\n\n        my $json = JSON->new->allow_nonref;\n        $self->header_props( -type => 'application/json' );\n        return $json->encode(\n            {\n                bytes_read     => $bytes_read,\n                content_length => $content_length,\n                percent        => int($per),\n            }\n        );\n    }\n}\n\nsub dump_meta_file {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $filename = $q->param('new_email_file');\n    $filename =~ s{^(.*)\\/}{};\n    $filename = uriescape($filename);\n\n    my $full_path_to_filename =\n      make_safer( $DADA::Config::TMP . '/' . $filename . '-meta.txt' );\n\n    if ( !-e $full_path_to_filename ) {\n\n    }\n    else {\n\n        my $chmod_check =\n          chmod( $DADA::Config::FILE_CHMOD, $full_path_to_filename );\n        if ( $chmod_check != 1 ) {\n            warn \"could not chmod '$full_path_to_filename' correctly.\";\n        }\n\n        my $unlink_check = unlink($full_path_to_filename);\n        if ( $unlink_check != 1 ) {\n            warn \"deleting meta file didn't work for: \"\n              . $full_path_to_filename;\n        }\n    }\n}\n\nsub _upload_that_file {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    #DEV: move\n    my $fh = $q->upload('new_email_file');\n\n\n\n#\tmy %headers = map { $_ => $q->http($_) } $q->http();\n#\tfor my $header ( keys %headers ) {\n#\t    warn \"$header: $headers{$header}\";\n#\t}\t\n#\tuse Data::Dumper; \n#\twarn '$fh: ' . Dumper($fh);\n#\twarn 'uploadInfo' . Dumper($q->uploadInfo($fh)); \n#\twarn '$q' . Dumper($q);\n\n    my $filename = $q->param('new_email_file');\n    $filename =~ s!^.*(\\\\|\\/)!!;\n\n    $filename = uriescape($filename);\n\n\n\t# warn '$filename: ' . $filename; \n\t\n    # warn '$filename ' . $filename;\n\n    # warn '$q->param(\\'rand_string\\') '    . $q->param('rand_string');\n    # warn '$q->param(\\'new_email_file\\') ' . $q->param('new_email_file');\n    return '' if !$filename;\n\n    my $outfile =\n      make_safer( $DADA::Config::TMP . '/'\n          . scalar( $q->param('rand_string') ) . '-'\n          . $filename );\n\n    # warn ' $outfile ' . $outfile;\n\n    open( OUTFILE, '>:encoding(UTF-8)', $outfile )\n      or die( \"can't write to \" . $outfile . \": $!\" );\n\n    while ( my $bytesread = read( $fh, my $buffer, 1024 ) ) {\n\n\t\t# This safely_decode call makes sense, as it wouldn't have been touched \n\t\t# by the normal thing that decodes stuff...\n        print OUTFILE safely_decode($buffer);\n    }\n\n    close(OUTFILE);\n    chmod( $DADA::Config::FILE_CHMOD, $outfile );\n\n}\n\nsub add_email {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $type    = $q->param('type') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'add_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $return_to      = $q->param('return_to')      || '';\n    my $return_address = $q->param('return_address') || '';\n    my $chrome         = $q->param('chrome');\n    if ( $chrome ne '0' ) { $chrome = 1; }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    require DADA::ProfileFieldsManager;\n    my $pfm        = DADA::ProfileFieldsManager->new;\n    my $field_atts = $pfm->get_all_field_attributes;\n\n    my $lh = DADA::MailingList::Subscribers->new(\n        {\n            -list     => $list,\n            -dpfm_obj => $pfm,\n        }\n    );\n    my $subscriber_fields = $lh->subscriber_fields;\n\n    if ( !$process ) {\n\n        my $new_emails_fn = $q->param('fn');\n\n        my $new_emails = [];\n        my $new_info   = [];\n\n        if ( $ls->param('use_add_list_import_limit') == 1 ) {\n\t\t\tmy $num_file_lines = 0; \n\t\t\tmy $had_problems = 0; \n\t\t\tmy $scrn; \n\t\t\ttry {\n            \t$num_file_lines =\n              \tDADA::App::Guts::num_file_lines($new_emails_fn);\n\t\t\t} catch {\n\t\t\t\t$had_problems = 1; \n\t            my $error = $_;\n\t               $scrn = DADA::Template::Widgets::wrap_screen(\n\t                {\n\t                    -screen         => 'add_email_error_screen.tmpl',\n\t                    -with           => 'admin',\n\t                    -wrapper_params => {\n\t                        -Root_Login => $root_login,\n\t                        -List       => $list,\n\t                    },\n\t                    -expr                     => 1,\n\t                    -vars                     => { error => $error },\n\t                    -list_settings_vars_param => {\n\t                        -list   => $list,\n\t                        -dot_it => 1,\n\t                    },\n\t                }\n\t            );\n        \t};\n\t\t\tif($had_problems == 1){ \n\t\t\t\treturn $scrn;\n\t\t\t}\n\n            if ( $num_file_lines > $ls->param('add_list_import_limit') ) {\n                my $error = 'over_add_list_import_limit';\n\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen         => 'add_email_error_screen.tmpl',\n                        -with           => 'admin',\n                        -wrapper_params => {\n                            -Root_Login => $root_login,\n                            -List       => $list,\n                        },\n                        -expr                     => 1,\n                        -vars                     => { error => $error },\n                        -list_settings_vars_param => {\n                            -list   => $list,\n                            -dot_it => 1,\n                        },\n                    }\n                );\n                return $scrn;\n            }\n        }\n \n\t\tmy $had_problems = 0; \n\t\tmy $scrn; \n\t\t\n        try {\n            ($new_emails) = DADA::App::Guts::csv_subscriber_parse( $admin_list,\n                $new_emails_fn );\n        }\n        catch {\n\t\t\t$had_problems  = 1; \n            my $error = $_;\n            $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'add_email_error_screen.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -expr                     => 1,\n                    -vars                     => { error => $error },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n           \n        };\n\t\tif($had_problems == 1){ \n\t\t\treturn $scrn;\n\t\t}\n\n        my ( $not_members, $invalid_email, $subscribed, $black_listed,\n            $not_white_listed, $invalid_profile_fields )\n          = $lh->filter_subscribers_massaged_for_ht(\n            {\n                -emails => $new_emails,\n                -type   => $type,\n            }\n          );\n\n        my $num_subscribers = $lh->num_subscribers({ -type => $type });\n\n# and for some reason, this is its own subroutine...\n# This is down here, so the status bar won't disapear before this page is loaded (or the below redirect)\n        $self->dump_meta_file();\n\n        # This is to see if we're already over quota:\n        my $subscription_quota_reached = 0;\n        if ( $type eq 'list' ) {\n            if (   $ls->param('use_subscription_quota') == 1\n                && ( $num_subscribers >= $ls->param('subscription_quota') )\n                && ( $num_subscribers + $ls->param('subscription_quota') > 1 ) )\n            {\n                $subscription_quota_reached = 1;\n            }\n            elsif (defined($DADA::Config::SUBSCRIPTION_QUOTA)\n                && $DADA::Config::SUBSCRIPTION_QUOTA > 0\n                && $num_subscribers >= $DADA::Config::SUBSCRIPTION_QUOTA )\n            {\n                $subscription_quota_reached = 1;\n            }\n        }\n        if ($subscription_quota_reached) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=add&type=list' );\n            return;\n        }\n\n        my $going_over_quota = 0;\n        if ( $type eq 'list' ) {\n            if ( $ls->param('use_subscription_quota') == 1\n                && ( $num_subscribers + scalar(@$not_members) ) >\n                $ls->param('subscription_quota') )\n            {\n                $going_over_quota = 1;\n            }\n            elsif (defined($DADA::Config::SUBSCRIPTION_QUOTA)\n                && $DADA::Config::SUBSCRIPTION_QUOTA > 0\n                && ( $num_subscribers + scalar(@$not_members) ) >\n                $DADA::Config::SUBSCRIPTION_QUOTA )\n            {\n                $going_over_quota = 1;\n            }\n        }\n\t\t\n\t\t# Tester List has a quota limit too:\n        if ( $type eq 'test_list' ) {\n            if ( $ls->param('enable_test_list_address_limit') == 1\n                && ( $num_subscribers + scalar(@$not_members) ) >\n                $ls->param('test_list_address_limit') )\n            {\n                $going_over_quota = 1;\n            }\n        }\n\t\t\n        my $addresses_to_add = 0;\n        if ( exists( $not_members->[0] ) ) {\n            $addresses_to_add = 1;\n        }\n\n        my $field_names = [];\n\n        # if($type eq 'list') {\n        for (@$subscriber_fields) {\n            push(\n                @$field_names,\n\n                {\n                    name  => $_,\n                    label => $field_atts->{$_}->{label},\n                }\n            );\n        }\n\n        #    }\n\n        if (   $type eq 'list'\n            && $ls->param('closed_list') == 1 )\n        {\n            die \"Your list is currently CLOSED to subscribers.\";\n        }\n\n        # If we're using the black list, but\n        # the list owner is allowed to subscribed blacklisted addresses,\n        # we have to communicate that to the template:\n        if (   $ls->param('black_list') == 1\n            && $ls->param('allow_admin_to_subscribe_blacklisted') == 1 )\n        {\n            for (@$black_listed) {\n                $_->{'list_settings.allow_admin_to_subscribe_blacklisted'} = 1;\n            }\n        }\n\n        my $show_invitation_button = 0;\n        my $show_update_button     = 0;\n        my $show_add_button        = 0;\n\n        if ( $type eq 'list' ) {\n            if ( scalar(@$not_members) > 0 ) {\n                $show_invitation_button = 1;\n            }\n            elsif ( scalar(@$black_listed) > 0\n                && $ls->param('allow_admin_to_subscribe_blacklisted') == 1 )\n            {\n                $show_invitation_button = 1;\n            }\n            elsif (\n                scalar($invalid_profile_fields) > 0\n                && (   $root_login == 1\n                    || $ls->param('allow_profile_editing') == 1 )\n              )\n            {\n                $show_invitation_button = 1;\n            }\n\n            if (\n                     scalar( @$not_members  ) < 1 \n                && ( \n\t\t\t\tscalar( @$black_listed ) < 1\n                && $ls->param('allow_admin_to_subscribe_blacklisted') == 1 )\n                && scalar(@$subscribed) > 1\n                && (   $root_login == 1\n                    || $ls->param('allow_profile_editing') == 1 )\n              )\n            {\n                $show_update_button = 1;\n            }\n            else {\n                $show_add_button = 1;\n            }\n        }\n\n        my %vars = (\n\n            show_invitation_button => $show_invitation_button,\n            show_update_button     => $show_update_button,\n            show_add_button        => $show_add_button,\n\n            can_have_subscriber_fields => $lh->can_have_subscriber_fields,\n            going_over_quota           => $going_over_quota,\n            field_names                => $field_names,\n            subscribed                 => $subscribed,\n            not_members                => $not_members,\n            black_listed               => $black_listed,\n            not_white_listed           => $not_white_listed,\n            invalid_email              => $invalid_email,\n            invalid_profile_fields     => $invalid_profile_fields,\n            type                       => $type,\n            type_title                 => $DADA::Config::LIST_TYPES->{$type},\n            root_login                 => $root_login,\n            return_to                  => $return_to,\n            return_address             => $return_address,\n            chrome                     => $chrome,\n        );\n\n        my $scrn;\n        if ( $chrome == 1 ) {\n            $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'add_email_screen.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -expr                     => 1,\n                    -vars                     => { %vars, },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n        }\n        else {\n            $scrn = DADA::Template::Widgets::screen(\n                {\n                    -screen                   => 'add_email_screen.tmpl',\n                    -expr                     => 1,\n                    -vars                     => { %vars, },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n        }\n        return $scrn;\n    }\n    else {\n\n        my $update_email_count = 0;\n\n        if ( $type eq 'list' ) {\n            if ( $process =~ m/subscribe|invit|update/i ) {\n\n   # This is what updates already existing profile fields and profile passwords;\n   #\n                my @update_fields_address =\n                  $q->multi_param(\"update_fields_address\");\n\n                # This is a lot of code, to set one thing:\n                my $subscribed_fields_options_mode =\n                  $q->param('subscribed_fields_options_mode')\n                  || 'writeover_inc_password';\n                my $spass_om = 'writeover';\n                if (\n                    $subscribed_fields_options_mode eq 'writeover_ex_password' )\n                {\n                    $spass_om = 'preserve_if_defined';\n                }\n\n                #/\n\n                my $update_email_count = 0;\n\n                # Change from csv to a complex data structure.\n                my @munged_update_addresses = ();\n                for my $ua (@update_fields_address) {\n                    push( @munged_update_addresses, $lh->csv_to_cds($ua) );\n                }\n\n                require DADA::Profiles;\n                my $dp                 = DADA::Profiles->new;\n                my $update_email_count = $dp->update(\n                    {\n                        -addresses       => [@munged_update_addresses],\n                        -password_policy => $spass_om,\n                    }\n                );\n            }\n        }\n\n        if ( $process =~ /invit/i ) {\n            $self->list_invite();\n        }\n        else {\n\n            if ( $type eq 'list' ) {\n                unless (\n                    $ls->param('enable_mass_subscribe') == 1\n                    && (   $root_login == 1\n                        || $ls->param('enable_mass_subscribe_only_w_root_login')\n                        != 1 )\n                  )\n                {\n                    die \"Mass Subscribing via the List Control Panel has been disabled.\";\n                }\n            }\n\t\t\t\n\n            my @address = $q->multi_param(\"address\");\n\n\n\n            \n\t\t\t# Tester List has a quota limit too:\n\t        if ( $type eq 'test_list' ) {\n\t            if ( $ls->param('enable_test_list_address_limit') == 1\n\t                && ( $lh->num_subscribers({-type => 'test_list'}) + scalar(@address) ) >\n\t                $ls->param('test_list_address_limit') )\n\t            {\n\t                my $error = 'over_add_list_import_limit';\n\n\t                my $scrn = DADA::Template::Widgets::wrap_screen(\n\t                    {\n\t                        -screen         => 'add_email_error_screen.tmpl',\n\t                        -with           => 'admin',\n\t                        -wrapper_params => {\n\t                            -Root_Login => $root_login,\n\t                            -List       => $list,\n\t                        },\n\t                        -expr                     => 1,\n\t                        -vars                     => { error => $error },\n\t                        -list_settings_vars_param => {\n\t                            -list   => $list,\n\t                            -dot_it => 1,\n\t                        },\n\t                    }\n\t                );\n\t                return $scrn;\n\t            }\n\t\t\t}\n\t\t\t#/ Tester List has a quota limit too:\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tmy @munged_add_addresses = ();\n            for my $a (@address) {\n                push( @munged_add_addresses, $lh->csv_to_cds($a) );\n            }\n            undef(@address);\n\n            my $not_members_fields_options_mode =\n              $q->param('not_members_fields_options_mode');\n\n            my ( $new_email_count, $skipped_email_count ) =\n              $lh->add_subscribers(\n                {\n                    -addresses           => [@munged_add_addresses],\n                    -fields_options_mode => $not_members_fields_options_mode,\n                    -type                => $type,\n                }\n              );\n\n            my $flavor_to_return_to = 'view_list';\n            if ( $return_to eq 'membership' ) {    # or, others...\n                $flavor_to_return_to = $return_to;\n            }\n\n            my $qs =\n                'flavor='\n              . $flavor_to_return_to\n              . '&add_email_count='\n              . $new_email_count\n              . '&skipped_email_count='\n              . $skipped_email_count\n              . '&update_email_count='\n              . $update_email_count\n              . '&type='\n              . $type;\n\n            if ( $return_to eq 'membership' ) {\n                $qs .= '&email=' . uriescape($return_address);\n            }\n\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n\n        }\n    }\n}\n\nsub delete_email {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'delete_email',\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $type = $q->param('type') || 'list';\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_email_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    screen                    => 'delete_email',\n                    title                     => 'Remove',\n                    can_use_global_black_list => $lh->can_use_global_black_list,\n                    can_use_global_unsubscribe =>\n                      $lh->can_use_global_unsubscribe,\n                    list_type_isa_list => ( $type eq 'list' ) ? 1 : 0,\n                    list_type_isa_black_list => ( $type eq 'black_list' ) ? 1\n                    : 0,\n                    list_type_isa_authorized_senders =>\n                      ( $type eq 'authorized_senders' ) ? 1 : 0,\n                    list_type_isa_moderators => ( $type eq 'moderators' ) ? 1\n                    : 0,\n                    list_type_isa_white_list => ( $type eq 'white_list' ) ? 1\n                    : 0,\n                    type       => $type,\n                    type_title => $DADA::Config::LIST_TYPES->{$type},\n                    flavor     => 'delete_email',\n                    list_subscribers_num =>\n                      $lh->num_subscribers( { -type => 'list' } ),\n                    test_list_subscribers_num =>\n                        $lh->num_subscribers( { -type => 'test_list' } ),\n\t\t\t\t\tblack_list_subscribers_num =>\n                      $lh->num_subscribers( { -type => 'black_list' } ),\n                    white_list_subscribers_num =>\n                      $lh->num_subscribers( { -type => 'white_list' } ),\n                    authorized_senders_num =>\n                      $lh->num_subscribers( { -type => 'authorized_senders' } ),\n\t\t\t\t\t  \n                      moderators_num => scalar commify(\n                          $lh->num_subscribers( { -type => 'moderators' } )\n                      ),\n\t\t\t\t\t\n\t\t\t\t\t  \n                      requires_moderation_num => scalar commify(\n                          $lh->num_subscribers( { -type => 'requires_moderation' } )\n                      ),\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        my $delete_list       = undef;\n        my $delete_email_file = $q->param('delete_email_file');\n        if ($delete_email_file) {\n            my $new_file = $self->file_upload('delete_email_file');\n            open( UPLOADED, \"$new_file\" )\n              or die $!;\n            $delete_list = do { local $/; <UPLOADED> };\n            close(UPLOADED);\n        }\n        else {\n            $delete_list = $q->param('delete_list');\n        }\n\n        my $outfile_filename =\n          generate_rand_string_md5() . '-' . 'remove_emails.txt';\n        my $outfile =\n          make_safer( $DADA::Config::TMP . '/' . $outfile_filename );\n\n        #DEV: encoding?\n        open( my $fh, '>' . $outfile )\n          or die( \"can't write to \" . $outfile . \": $!\" );\n        print $fh $delete_list;\n        close($fh);\n        chmod( $DADA::Config::FILE_CHMOD, $outfile );\n\n        my $new_emails = [];\n        my $new_info   = [];\n        ( $new_emails, $new_info ) =\n          DADA::App::Guts::csv_subscriber_parse( $admin_list,\n            $outfile_filename );\n\n        my ( $not_members, $invalid_email, $subscribed, $black_listed,\n            $not_white_listed, $invalid_profile_fields )\n          = $lh->filter_subscribers_massaged_for_ht(\n            {\n                -emails                       => $new_emails,\n                -type                         => $type,\n                -treat_profile_fields_special => 0,\n\n            }\n          );\n\n        #        use Data::Dumper;\n        #        warn Dumper({\n        #             not_members => $not_members,\n        #             invalid_email => $invalid_email,\n        #             subscribed => $subscribed,\n        #             black_listed => $black_listed,\n        #             not_white_listed => $not_white_listed,\n        #             invalid_profile_fields => $invalid_profile_fields,\n        #        });\n\n        my $have_subscribed_addresses = 0;\n        $have_subscribed_addresses = 1\n          if $subscribed->[0];\n\n        my $addresses_to_remove = [];\n        push( @$addresses_to_remove, { email => $_->{email} } )\n          for @$subscribed;\n\n        my $not_subscribed_addresses = [];\n        push( @$not_subscribed_addresses, { email => $_->{email} } )\n          for @$not_members;\n\n        my $have_invalid_addresses = 0;\n        $have_invalid_addresses = 1\n          if $invalid_email->[0];\n\n        my $invalid_addresses = [];\n        push( @$invalid_addresses, { email => $_->{email} } )\n          for @$invalid_email;\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'delete_email_screen_filtered.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    have_subscribed_addresses => $have_subscribed_addresses,\n                    addresses_to_remove       => $addresses_to_remove,\n                    not_subscribed_addresses  => $not_subscribed_addresses,\n                    have_invalid_addresses    => $have_invalid_addresses,\n                    invalid_addresses         => $invalid_addresses,\n\n                    type       => $type,\n                    type_title => $DADA::Config::LIST_TYPES->{$type},\n\n                },\n            }\n        );\n\n        return $scrn;\n    }\n}\n\nsub subscription_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'subscription_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my @d_quota_values = qw(1 10 25 50 100 150 200 250 300 350 400 450 500 600\n      700 800 900 1000 1500 2000 2500 3000 3500 4000 4500\n      5000 5500 6000 6500 7000 7500 8000 8500 9000 9500\n      10000 11000 12000 13000 14000 15000 16000 17000\n      18000 19000 20000 30000 40000 50000 60000 70000\n      80000 90000 100000 200000 300000 400000 500000\n      600000 700000 800000 900000 1000000\n    );\n\n\tif (strip($DADA::Config::SUBSCRIPTION_QUOTA) eq '') {\n \t   $DADA::Config::SUBSCRIPTION_QUOTA = undef\n\t}\n    \n    my @quota_values;\n\n\t# no idea. \n    if ( defined($DADA::Config::SUBSCRIPTION_QUOTA) \n\t\t&&       $DADA::Config::SUBSCRIPTION_QUOTA > 0 ) {\n        for (@d_quota_values) {\n            if ( $_ < $DADA::Config::SUBSCRIPTION_QUOTA ) {\n                push( @quota_values, $_ );\n            }\n        }\n        push( @quota_values, $DADA::Config::SUBSCRIPTION_QUOTA );\n\n    }\n    else {\n        @quota_values = @d_quota_values;\n    }\n\n    # Now that's a weird line (now)\n    unshift( @quota_values, $ls->param('subscription_quota') );\n\n    if ( !$process ) {\n\n        require DADA::ProfileFieldsManager;\n        my $dpfm = DADA::ProfileFieldsManager->new;\n        require DADA::Profile::Fields;\n        my $dpf = DADA::Profile::Fields->new;\n\n        my $view_list_order_by_menu           = '';\n        my $view_list_order_by_direction_menu = '';\n        require HTML::Menu::Select;\n\n        if ( $dpf->can_have_subscriber_fields ) {\n\n            my $field_atts      = $dpfm->get_all_field_attributes;\n            my $pf_field_labels = {};\n            for ( keys %{$field_atts} ) {\n                $pf_field_labels->{$_} = $field_atts->{$_}->{label};\n            }\n            my $field_values = $dpfm->fields;\n            unshift( @$field_values, 'timestamp' );\n            unshift( @$field_values, 'email' );\n\n            $pf_field_labels->{timestamp} = 'Subscription Date';\n            $pf_field_labels->{email}     = 'Email Address';\n\n            $view_list_order_by_menu = HTML::Menu::Select::popup_menu(\n                {\n                    name    => 'view_list_order_by',\n                    id      => 'view_list_order_by',\n                    values  => $field_values,\n                    labels  => $pf_field_labels,\n                    default => $ls->param('view_list_order_by'),\n                }\n            );\n            $view_list_order_by_direction_menu = HTML::Menu::Select::popup_menu(\n                {\n                    name    => 'view_list_order_by_direction',\n                    id      => 'view_list_order_by_direction',\n                    values  => [ 'ASC', 'DESC' ],\n                    labels  => { ASC => 'Ascending', DESC => 'Descending' },\n                    default => $ls->param('view_list_order_by_direction'),\n                }\n            );\n        }\n        my $subscription_quota_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'subscription_quota',\n                id      => 'subscription_quota',\n                values  => [@quota_values],\n                default => $ls->param('subscription_quota'),\n            }\n        );\n\t\t\n\t\tmy $test_list_address_limit_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'test_list_address_limit',\n                id      => 'test_list_address_limit',\n                values  => [(1,2,3,4,5,6,7,8,9,10,15,20,25,30,40,50,60,70,80,90,100)],\n                default => $ls->param('test_list_address_limit'),\n            }\n\t\t);\n\n        my @list_amount = (\n            3,     5,    10,   25,   50,    100,   150,   200,\n            250,   300,  350,  400,  450,   500,   550,   600,\n            650,   700,  750,  800,  850,   900,   950,   1000,\n            2000,  3000, 4000, 5000, 10000, 15000, 20000, 25000,\n            50000, 100000\n        );\n        require HTML::Menu::Select;\n        my $vlsn_menu = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'view_list_subscriber_number',\n                values  => [@list_amount],\n                default => $ls->param('view_list_subscriber_number'),\n            }\n        );\n\n        my $add_list_import_limit_menu = HTML::Menu::Select::popup_menu(\n            {\n                name   => 'add_list_import_limit',\n                values => [\n                    qw(100 200 300 400 500 600 750 1000 1500 2000 2500 3000 5000 7500 10000)\n                ],\n                default => $ls->param('add_list_import_limit'),\n            }\n        );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'subscription_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    screen                  => 'subscription_options',\n                    title                   => 'Subscriber Options',\n                    done                    => $done,\n                    root_login              => $root_login,\n                    subscription_quota_menu => $subscription_quota_menu,\n                    can_have_subscriber_fields =>\n                      $dpf->can_have_subscriber_fields,\n                    vlsn_menu               => $vlsn_menu,\n                    view_list_order_by_menu => $view_list_order_by_menu,\n                    view_list_order_by_direction_menu =>\n                      $view_list_order_by_direction_menu,\n                    add_list_import_limit_menu => $add_list_import_limit_menu,\n                    SUBSCRIPTION_QUOTA => $DADA::Config::SUBSCRIPTION_QUOTA,\n                    commified_subscription_quota =>\n                      commify( int($DADA::Config::SUBSCRIPTION_QUOTA) ),\n                \t  test_list_address_limit_menu => $test_list_address_limit_menu, \n\t\t\t\t},\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    view_list_subscriber_number                      => undef,\n                    view_list_show_timestamp_col                     => 0,\n                    view_list_order_by                               => undef,\n                    view_list_order_by_direction                     => undef,\n                    view_list_show_sub_confirm_list                  => 0,\n\t\t\t\t\tview_list_enable_delete_all_button               => 0,\n                    use_add_list_import_limit                        => 0,\n                    add_list_import_limit                            => undef,\n                    allow_profile_editing                            => 0,\n                    use_subscription_quota                           => 0,\n                    subscription_quota                               => undef,\n                    black_list                                       => 0,\n                    add_unsubs_to_black_list                         => 0,\n                    allow_blacklisted_to_subscribe                   => 0,\n                    allow_admin_to_subscribe_blacklisted             => 0,\n                    enable_white_list                                => 0,\n\t\t\t\t\tenable_test_list                                 => 0,\n\t\t\t\t\tenable_test_list_address_limit                   => 0,\n\t\t\t\t\ttest_list_address_limit                          => undef,\n                    invites_check_for_already_invited                => 0,\n                    invites_prohibit_reinvites                       => 0,\n\t\t\t\t\tinvites_show_profile_fields_in_subscription_form => 0, \n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=subscription_options&done=1' );\n    }\n\n}\n\nsub view_archive {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_archive'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $admin_list } );\n\n    # let's get some info on this archive, shall we?\n    require DADA::MailingList::Archives;\n\n    my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n    my $entries = $archive->get_archive_entries();\n\n    #if we don't have nothin, print the index,\n\n    my $id = $q->param('id') || undef;\n\n    unless ( defined($id) ) {\n\n        my $start = int( $q->param('start') ) || 0;\n\n        if (\n            !$c->profile_on\n            && $c->is_cached(\n                $list . '.admin.view_archive.index.' . $start . '.scrn'\n            )\n          )\n        {\n            return $c->cached(\n                $list . '.admin.view_archive.index.' . $start . '.scrn' );\n        }\n\n        my $ht_entries = [];\n\n        my $th_entries = [];\n\n        my ( $begin, $stop ) = $archive->create_index($start);\n        my $i;\n        my $stopped_at = $begin;\n\n        my @archive_nums;\n        my @archive_links;\n\n        for ( $i = $begin ; $i <= $stop ; $i++ ) {\n\n            next if !defined( $entries->[$i] );\n\n            my $entry = $entries->[$i];\n\n            #for $entry (@$entries){\n            my ( $subject, $message, $format, $raw_msg ) =\n              $archive->get_archive_info($entry);\n\n            my $pretty_subject = pretty($subject);\n\n            my $header_from = undef;\n            if ($raw_msg) {\n                $header_from =\n                  $archive->get_header( -header => 'From', -key => $entry );\n\n                # The SPAM ME NOT Encoding's a little fucked for this, anyways,\n                # We should only encode the actual address, anyways. Hmm...\n                # $header_from    = spam_me_not_encode($header_from);\n            }\n            else {\n                $header_from = '-';\n            }\n\n            my $date = date_this(\n                -Packed_Date => $entry,\n                -All         => 1\n            );\n\n            my $message_blurb = $archive->message_blurb( -key => $entry );\n            $message_blurb =~ s/\\n|\\r/ /g;\n\n            push(\n                @$ht_entries,\n\n                {\n                    id            => $entry,\n                    date          => $date,\n                    S_PROGRAM_URL => $DADA::Config::S_PROGRAM_URL,\n                    subject       => $pretty_subject,\n                    from          => $header_from,\n                    message_blurb => $message_blurb,\n                }\n            );\n\n            $stopped_at++;\n\n        }\n\n        my $index_nav = $archive->create_index_nav( $stopped_at, 1 );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'view_archive_index_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -list => $list,\n                -vars => {\n                    can_use_JSON => scalar DADA::App::Guts::can_use_JSON(),\n                    screen       => 'view_archive',\n                    title        => 'View Archive',\n\t\t\t\t\tPLUGINS_ENABLED_tracker => $DADA::Config::PLUGINS_ENABLED->{tracker},\n                    index_list   => $ht_entries,\n                    list_name    => $ls->param('list_name'),\n                    index_nav    => $index_nav,\n\n                },\n            }\n        );\n\n        if ( !$c->profile_on ) {    # that's it?\n            $c->cache( $list . '.admin.view_archive.index.' . $start . '.scrn',\n                \\$scrn );\n        }\n        return $scrn;\n    }\n    else {\n\n        #check to see if $id is a real id key\n        my $entry_exists = $archive->check_if_entry_exists($id);\n\n        if ( $entry_exists <= 0 ) {\n            return user_error(\n                { -list => $list, -error => \"no_archive_entry\" } );\n        }\n\n        my $scrn = '';\n\n        my ( $subject, $message, $format ) = $archive->get_archive_info($id);\n\n        my $cal_date = date_this(\n            -Packed_Date => $archive->_massaged_key($id),\n            -All         => 1\n        );\n\n        my $nav_table = $archive->make_nav_table(\n            -Id       => $id,\n            -List     => $ls->param('list'),\n            -Function => \"admin\"\n        );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'view_archive_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    id      => $id,\n                    subject => $subject,\n                    date    => $cal_date,\n                    can_display_message_source =>\n                      $archive->can_display_message_source,\n                    nav_table => $nav_table,\n\t\t\t\t\tPLUGINS_ENABLED_tracker => $DADA::Config::PLUGINS_ENABLED->{tracker},\n\t\t\t\t\t\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub display_message_source {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'display_message_source'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n\n    my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n    if ( $la->check_if_entry_exists( $q->param('id') ) ) {\n\n        if ( $la->can_display_message_source ) {\n\n            $self->header_props( { -type => 'text/plain' } );\n            return $la->message_source( $q->param('id') );\n\n        }\n        else {\n\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => \"no_support_for_displaying_message_source\"\n                }\n            );\n        }\n\n    }\n    else {\n        return user_error( { -list => $list, -error => \"no_archive_entry\" } );\n    }\n\n}\n\nsub delete_archive {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'delete_archive'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list    = $admin_list;\n    my @address = $q->multi_param(\"address\");\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n\n    my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n    $archive->delete_archive(@address);\n\n    $self->header_type('redirect');\n    $self->header_props(\n        -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n\n}\n\nsub purge_all_archives {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'purge_all_archives'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n    my $ah = DADA::MailingList::Archives->new( { -list => $list } );\n\n    $ah->delete_all_archive_entries();\n\n    $self->header_type('redirect');\n    $self->header_props(\n        -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n\n}\n\nsub archive_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'archive_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $can_use_captcha = can_use_Google_reCAPTCHA();\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'archive_options_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -expr => 1,\n                -vars => {\n                    screen          => 'archive_options',\n                    title           => 'Archive Options',\n                    root_login      => $root_login,\n                    list            => $list,\n                    done            => $done,\n                    can_use_captcha => $can_use_captcha,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    show_archives                          => 0,\n                    archives_available_only_to_subscribers => 0,\n                    archive_messages                       => 0,\n                    archive_subscribe_form                 => 0,\n                    archive_search_form                    => 0,\n                    archive_send_form                      => 0,\n                    captcha_archive_send_form              => 0,\n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=archive_options&done=1' );\n    }\n}\n\nsub adv_archive_options {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'adv_archive_options'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::MailingList::Archives;\n    my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my @index_this = (\n            $ls->param('archive_index_count'),\n            1 .. 10, 15, 20, 25, 30, 40, 50, 75, 100\n        );\n\n        require HTML::Menu::Select;\n        my $archive_index_count_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => 'archive_index_count',\n                id    => 'archive_index_count',\n                value => [@index_this],\n            }\n        );\n\t\t\n\t\t\n\t\tmy $remove_after_timespan_vals = [\n\t\t'1m',\n\t\t'2m',\n\t\t'3m',\n\t\t'4m',\n\t\t'5m',\n\t\t'6m',\n\t\t'7m',\n\t\t'8m',\n\t\t'9m',\n\t\t'10m',\n\t\t'11m',\n\t\t'1y',\n\t\t'2y',\n\t\t'3y',\n\t\t'4y',\n\t\t'5y'];\n\t\n\t\tmy $remove_after_timespan_ops = { \n\t\t\t'1m'  => '1 month',\n\t\t\t'2m'  => '2 months',\n\t\t\t'3m'  => '3 months',\n\t\t\t'4m'  => '4 months',\n\t\t\t'5m'  => '5 months',\n\t\t\t'6m'  => '6 months',\n\t\t\t'7m'  => '7 months',\n\t\t\t'8m'  => '8 months',\n\t\t\t'9m'  => '9 months',\n\t\t\t'10m' => '10 months',\n\t\t\t'11m' => '11 months',\n\t\t\t'1y'  => '1 year',\n\t\t\t'2y'  => '2 years',\n\t\t\t'3y'  => '3 years',\n\t\t\t'4y'  => '4 years',\n\t\t\t'5y'  => '5 years',\n\t\t};\n\t\tmy $archive_auto_remove_after_timespan_menu = HTML::Menu::Select::popup_menu(\n            {\n                name  => 'archive_auto_remove_after_timespan',\n                id    => 'archive_auto_remove_after_timespan',\n                values => $remove_after_timespan_vals,\n\t\t\t\tlabels => $remove_after_timespan_ops, \n\t\t\t\tdefault => $ls->param('archive_auto_remove_after_timespan'), \n\t\t\t}\n        );\n\n        my $ping_sites = [];\n        for (@DADA::Config::PING_URLS) {\n\n            push(\n                @$ping_sites,\n                {\n\n                    ping_url => $_\n                }\n            );\n        }\n\n        my $can_use_xml_rpc = 1;\n\n        eval { require XMLRPC::Lite };\n        if ($@) {\n            $can_use_xml_rpc = 0;\n        }\n\n        my $can_use_html_scrubber = 1;\n        try {\n            require HTML::Scrubber;\n        }\n        catch {\n            carp \"HTML::Scrubber not working correctly?:\" . substr($_, 0, 100) . '...';\n            $can_use_html_scrubber = 0;\n        };\n\n        my $gravatar_img_url     = '';\n        my $can_use_gravatar_url = 1;\n        try {\n            require Gravatar::URL;\n        }\n        catch {\n            $can_use_gravatar_url = 0;\n        };\n\n        if ( $can_use_gravatar_url == 1 ) {\n            $gravatar_img_url = gravatar_img_url(\n                {\n                    -email                => $ls->param('list_owner_email'),\n                    -default_gravatar_url => $ls->param('default_gravatar_url'),\n                }\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'adv_archive_options_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen                                  => 'adv_archive_options',\n                    title                                   => 'Advanced Options',\n                    root_login                              => $root_login,\n                    done                                    => $done,\n                    archive_index_count_menu                => $archive_index_count_menu,\n                    list                                    => $list,\n                    ping_sites                              => $ping_sites,\n                    can_use_xml_rpc                         => $can_use_xml_rpc,\n                    can_use_html_scrubber                   => $can_use_html_scrubber,\n                    can_display_attachments                 => $la->can_display_attachments,\n                    can_use_gravatar_url                    => $can_use_gravatar_url,\n                    gravatar_img_url                        => $gravatar_img_url,\n\t\t\t\t\tarchive_auto_remove_after_timespan_menu => $archive_auto_remove_after_timespan_menu, \n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    sort_archives_in_reverse           => 0,\n                    archive_show_year                  => 0,\n                    archive_show_month                 => 0,\n                    archive_show_day                   => 0,\n                    archive_show_hour_and_minute       => 0,\n                    archive_show_second                => 0,\n                    archive_index_count                => 10,\n                    publish_archives_rss               => 0,\n                    ping_archives_rss                  => 0,\n                    html_archives_in_iframe            => 0,\n                    disable_archive_js                 => 0,\n                    style_quoted_archive_text          => 0,\n                    display_attachments                => 0,\n                    add_subscribe_form_to_feeds        => 0,\n                    add_social_bookmarking_badges      => 0,\n                    archive_protect_email              => undef,\n                    enable_gravatars                   => 0,\n                    default_gravatar_url               => '',\n\t\t\t\t\tarchive_auto_remove                => 0,\n\t\t\t\t\tarchive_auto_remove_after_timespan => 0, \n                },\n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=adv_archive_options&done=1' );\n    }\n}\n\nsub edit_archived_msg {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    require DADA::Template::HTML;\n    require DADA::MailingList::Settings;\n\n    require DADA::MailingList::Archives;\n\n    require DADA::Mail::Send;\n\n    require MIME::Parser;\n\n    my $parser = new MIME::Parser;\n    $parser = optimize_mime_parser($parser);\n\n    my $skel = [];\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_archived_msg'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $ls   = DADA::MailingList::Settings->new( { -list => $list } );\n    my $mh   = DADA::Mail::Send->new(\n        {\n            -list   => $list,\n            -ls_obj => $ls,\n        }\n    );\n    my $ah = DADA::MailingList::Archives->new( { -list => $list } );\n\n    edit_archived_msg_main();\n\n    #---------------------------------------------------------------------#\n\n    sub edit_archived_msg_main {\n\n        if ( $q->param('process') eq 'prefs' ) {\n            return prefs();\n        }\n        else {\n\n            if ( $q->param('process') ) {\n                return edit_archive();\n            }\n            else {\n                return view();\n            }\n        }\n    }\n\n    sub view {\n\n        require HTML::Menu::Select;\n        my $D_Content_Types = [ 'text/plain', 'text/html' ];\n\n        my %Headers_To_Edit;\n\n        my $parser = new MIME::Parser;\n        $parser = optimize_mime_parser($parser);\n\n        my $id = $q->param('id');\n\n        if ( !$id ) {\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n        }\n\n        if ( $ah->check_if_entry_exists($id) <= 0 ) {\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::S_PROGRAM_URL . '?flavor=view_archive' );\n        }\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $ah->get_archive_info($id);\n\n        # do I need this?\n        $raw_msg ||= $ah->_bs_raw_msg( $subject, $message, $format );\n        $raw_msg =~ s/Content\\-Type/Content-type/;\n        $raw_msg = safely_encode($raw_msg);\n\n        my $entity;\n        eval { $entity = $parser->parse_data($raw_msg); };\n\n        my $form_blob = '';\n        make_skeleton($entity);\n\n        for ( split( ',', $ls->param('editable_headers') ) ) {\n            $Headers_To_Edit{$_} = 1;\n        }\n\n        for my $tb (@$skel) {\n\n            my @c = split( '-', $tb->{address} );\n            my $bqc = $#c - 1;\n\n            for ( 0 .. $bqc ) {\n                $form_blob .=\n'<div style=\"padding-left: 30px; border-left:1px solid #ccc\">';\n            }\n\n            if ( $tb->{address} eq '0' ) {\n                $form_blob .= '<table  width=\"100%\">';\n\n                # head of the message!\n                my %headers =\n                  $mh->return_headers( $tb->{entity}->head->original_text );\n                for my $h (@DADA::Config::EMAIL_HEADERS_ORDER) {\n                    if ( $headers{$h} ) {\n                        if ( $Headers_To_Edit{$h} == 1 ) {\n\n                            $form_blob .= qq{\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t <td>\n\t\t\t\t\t\t\t\t  <p>\n\t\t\t\t\t\t\t\t   <label for=\"$h\">\n\t\t\t\t\t\t\t\t\t$h: </label>\n\t\t\t\t\t\t\t\t  </p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"99%\">\n\t\t\t\t\t\t\t};\n\n                            if (   $DADA::Config::ARCHIVE_DB_TYPE eq 'Db'\n                                && $h eq 'Content-type' )\n                            {\n                                push( @{$D_Content_Types}, $headers{$h} );\n                                $form_blob .= $q->p(\n                                    HTML::Menu::Select::popup_menu(\n                                        {\n                                            values  => $D_Content_Types,\n                                            id      => $h,\n                                            name    => $h,\n                                            default => $headers{$h}\n                                        }\n                                    )\n                                );\n                            }\n                            else {\n                                my $value = $headers{$h};\n                                if ( $h =~ m/To|From|Cc|Reply\\-To|Subject/ ){\n                                    $value = $ah->_decode_header($value);\n                                }\n\t\t\t\t\t\t\t\t$form_blob .= $q->p(\n                                \t$q->textfield(\n\t                                    -value => $value,\n\t                                    -id    => $h,\n\t                                    -name  => $h,\n\t                                    -class => 'full'\n                                \t)\n\t\t\t\t\t\t\t\t);\n                            }\n                            $form_blob .= '</td></tr>';\n                        }\n\n                    }\n\n                }\n                $form_blob .= '</table>';\n            }\n            my ( $type, $subtype ) =\n              split( '/', $tb->{entity}->head->mime_type );\n\n            $form_blob .= $q->p( $q->strong('Content Type: '),\n                $tb->{entity}->head->mime_type );\n\n            if ( $tb->{body} ) {\n\n                if (   $type =~ /^(text|message)$/\n                    && $tb->{entity}->head->get('content-disposition') !~\n                    m/attach/i )\n                {    # text: display it...\n\n                    # Needs to be WYSIWYG Editor-ized\n                    $form_blob .= $q->p(\n                        $q->textarea(\n                            -value => safely_decode(\n                                $tb->{entity}->bodyhandle->as_string\n                            ),\n                            -rows => 15,\n                            -name => $tb->{address}\n                        )\n                    );\n\n                }\n                else {\n\n                    $form_blob .=\n                      '<div style=\"border: 1px solid #000;padding: 5px\">';\n\n                    my $name =\n                         $tb->{entity}->head->mime_attr(\"content-type.name\")\n                      || $tb->{entity}\n                      ->head->mime_attr(\"content-disposition.filename\");\n\n                    my $attachment_url;\n\n                    if ($name) {\n                        $attachment_url =\n                            $DADA::Config::S_PROGRAM_URL\n                          . '?flavor=file_attachment&list='\n                          . $list . '&id='\n                          . $id\n                          . '&filename='\n                          . $name\n                          . '&mode=inline';\n                    }\n                    else {\n\n                        $name = 'Untitled.';\n\n                        my $m_cid = $tb->{entity}->head->get('content-id');\n                        $m_cid =~ s/^\\<|\\>$//g;\n\n                        $attachment_url =\n                            $DADA::Config::S_PROGRAM_URL\n                          . '?flavor=show_img&list='\n                          . $list . '&id='\n                          . $id . '&cid='\n                          . $m_cid;\n\n                    }\n\n                    $form_blob .= $q->p(\n                        $q->strong('Attachment: '),\n                        $q->a(\n                            { -href => $attachment_url, -target => '_blank' },\n                            $name\n                        )\n                    );\n\n                    $form_blob .= '<table  style=\"padding:5px\">';\n\n                    $form_blob .= '<tr><td>';\n\n                    if ( $type =~ /^image/ && $subtype =~ m/gif|jpg|jpeg|png/ )\n                    {\n                        $form_blob .= $q->p(\n                            $q->a(\n                                {\n                                    -href   => $attachment_url,\n                                    -target => '_blank'\n                                },\n                                $q->img(\n                                    {\n                                        -src   => $attachment_url,\n                                        -width => '100'\n                                    }\n                                )\n                            )\n                        );\n                    }\n                    else {\n\n#$form_blob .=  $q->p($q->a({-href => $attachment_url, -target => '_blank'}, $q->strong('Attachment: ' ), $q->a({-href => $attachment_url, -target => '_blank'}, $name)));\n                    }\n                    $form_blob .= '</td><td>';\n\n                    $form_blob .= $q->p(\n                        $q->checkbox(\n                            -name  => 'delete_' . $tb->{address},\n                            -id    => 'delete_' . $tb->{address},\n                            -value => 1,\n                            -label => ''\n                        ),\n                        $q->label(\n                            { '-for' => 'delete_' . $tb->{address} },\n                            'Remove From Message'\n                        )\n                    );\n                    $form_blob .= $q->p( $q->strong('Update:'),\n                        $q->filefield( -name => 'upload_' . $tb->{address} ) );\n\n                    $form_blob .= '</td></tr></table>';\n\n                    $form_blob .= '</div>';\n\n                }\n            }\n\n            for ( 0 .. $bqc ) {\n                $form_blob .= '</div>';\n            }\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_archived_msg.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    subject => $subject,\n                    big_blob_of_form_widgets_to_edit_an_archived_message =>\n                      $form_blob,\n                    can_display_message_source =>\n                      $ah->can_display_message_source,\n                    id   => $id,\n                    done => scalar $q->param('done'),\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n\n                },\n            }\n        );\n        return $scrn;\n    }\n\n    sub prefs {\n\n        if ( $q->param('process_prefs') ) {\n\n            my $the_id = $q->param('id');\n\n            my $editable_headers = join( ',', $q->param('editable_header') );\n            $ls->save(\n                {\n                    -settings => {\n                        editable_headers => $editable_headers,\n                    }\n                }\n            );\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=edit_archived_msg&process=prefs&done=1&id='\n                  . $the_id );\n\n        }\n        else {\n\n            my %editable_headers;\n            $editable_headers{$_} = 1\n              for ( split( ',', $ls->param('editable_headers') ) );\n\n            my $edit_headers_menu = [];\n            for (@DADA::Config::EMAIL_HEADERS_ORDER) {\n\n                push( @$edit_headers_menu,\n                    { name => $_, editable => $editable_headers{$_} } );\n            }\n\n            my $the_id = $q->param('id');\n            my $done   = $q->param('done');\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'edit_archived_msg_prefs_screen.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -vars => {\n                        edit_headers_menu => $edit_headers_menu,\n                        done              => $done,\n                        id                => $the_id,\n                    },\n                }\n            );\n            return $scrn;\n        }\n\n    }\n\n    sub edit_archive {\n\n        my $id = $q->param('id');\n\n        my $parser = new MIME::Parser;\n        $parser = optimize_mime_parser($parser);\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $ah->get_archive_info($id);\n\n        $raw_msg ||= $ah->_bs_raw_msg( $subject, $message, $format );\n        $raw_msg =~ s/Content\\-Type/Content-type/;\n        $raw_msg = safely_encode($raw_msg);\n\n        my $entity;\n\n        eval { $entity = $parser->parse_data($raw_msg) };\n\n        my $throwaway = undef;\n\n        ( $entity, $throwaway ) = edit($entity);\n\n        # not sure if this, \"if\" is needed.\n        if ( $DADA::Config::ARCHIVE_DB_TYPE eq 'Db' ) {\n            $ah->set_archive_info(\n                $id,\n                $entity->head->get( 'Subject', 0 ),\n                undef,\n                $entity->head->get( 'Content-type', 0 ),\n                safely_decode( $entity->as_string )\n            );\n        }\n        else {\n\n            $ah->set_archive_info( $id, $entity->head->get( 'Subject', 0 ),\n                undef, undef, safely_decode( $entity->as_string ) );\n        }\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=edit_archived_msg&id='\n              . $id\n              . '&done=1' );\n\n    }\n\n    sub make_skeleton {\n\n        my ( $entity, $name ) = @_;\n        defined($name) or $name = \"0\";\n\n        my $IO;\n\n        # Output the body:\n        my @parts = $entity->parts;\n        if (@parts) {\n\n            push( @$skel, { address => $name, entity => $entity } );\n\n            # multipart...\n            my $i;\n            for $i ( 0 .. $#parts ) {    # dump each part...\n                make_skeleton( $parts[$i], ( \"$name\\-\" . ($i) ) );\n            }\n\n        }\n        else {                           # single part...\n            push( @$skel, { address => $name, entity => $entity, body => 1 } );\n\n        }\n    }\n\n    sub edit {\n\n        my ( $entity, $name ) = @_;\n        defined($name) or $name = \"0\";\n        my $IO;\n\n        my %Headers_To_Edit;\n\n        if ( $name eq '0' ) {\n\n            for ( split( ',', $ls->param('editable_headers') ) ) {\n                $Headers_To_Edit{$_} = 1;\n            }\n\n            require DADA::App::FormatMessages;\n            my $fm = DADA::App::FormatMessages->new( -List => $list );\n\n            for my $h (@DADA::Config::EMAIL_HEADERS_ORDER) {\n                if ( $Headers_To_Edit{$h} == 1 ) {\n                    my $value = $q->param($h);\n\n                    # Dum, what to do here?\n                    if ( $h =~ m/To|From|Cc|Reply\\-To|Subject/ ) {\n                        $value = $fm->_encode_header( $h, $value );\n                    }\n                    $entity->head->replace( $h, $value );\n                }\n            }\n        }\n\n        my @parts = ();\n        if ( defined($entity) ) {\n            @parts = $entity->parts;\n        }\n        else {\n\n            #...\n        }\n\n        if (@parts) {\n\n            my %ditch = ();\n\n            # multipart...\n            my $i;\n            for $i ( 0 .. $#parts ) {\n                my $name_is;\n                ( $parts[$i], $name_is ) =\n                  edit( $parts[$i], ( \"$name\\-\" . ($i) ) );\n\n                if ( $q->param( 'delete_' . $name_is ) == 1 ) {\n                    $ditch{$i} = 1;\n\n                }\n                else {\n                    $ditch{$i} = 0;\n                }\n            }\n\n            my @new_parts;\n            my $ii;\n            for $ii ( 0 .. $#parts ) {\n                if ( $ditch{$ii} == 1 ) {\n\n                    # don't push it.\n                }\n                else {\n\n                    push( @new_parts, $parts[$ii] );\n                }\n            }\n\n            $entity->parts( \\@new_parts );\n\n            $entity->sync_headers(\n                'Length'      => 'COMPUTE',\n                'Nonstandard' => 'ERASE'\n            );\n\n        }\n        else {\n            if ( $q->param( 'delete_' . $name ) == 1 ) {\n\n                # Well, just leave it alone!\n                return ( $entity, $name );\n            }\n            else {\n\n                # Uh, this means it's some sort of text, apparrently.\n                my $content = $q->param($name);\n                $content =~ s/\\r\\n/\\n/g;\n                if ($content) {\n\n                    # DEV: encoding?\n                    my $body = $entity->bodyhandle;\n                    my $io   = $body->open('w');\n                    $io->print($content);\n                    $io->close;\n                }\n                else {\n                    my $body = $entity->bodyhandle;\n                    my $io   = $body->open('w');\n                    $io->print('!!!DELETE PART!!!');\n                    $io->close;\n\n                    # This is what should do the actual deleting.\n                    $q->param( 'delete_' . $name, 1 );\n                }\n\n                my $cid;\n                $cid = $entity->head->get('content-id') || undef;\n                if ( $q->param( 'upload_' . $name ) ) {\n                    $entity = get_from_upload( $name, $cid,\n                        $entity->head->get('content-disposition') );\n                }\n\n                $entity->sync_headers(\n                    'Length'      => 'COMPUTE',\n                    'Nonstandard' => 'ERASE'\n                );\n\n                return ( $entity, $name );\n            }\n        }\n\n        return ( $entity, $name );\n\n    }\n\n    sub get_from_upload {\n\n        my $name        = shift;\n        my $cid         = shift;\n        my $disposition = shift || 'attachment';\n\n        my $filename = $self->file_upload( 'upload_' . $name );\n        my $data;\n\n        my $nice_filename = $q->param( 'upload_' . $name );\n\n        require MIME::Entity;\n        my $ent = MIME::Entity->build(\n            Path        => $filename,\n            Filename    => $nice_filename,\n            Encoding    => \"base64\",\n            Disposition => $disposition,\n            Type        => find_attachment_type($filename),\n            Id          => $cid,\n        );\n        return $ent;\n\n    }\n\n}\n\nsub html_code {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $jquery_head_code = DADA::Template::Widgets::screen(\n        {\n            -screen                   => 'jquery_subscription_form_head.tmpl',\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    my $jquery_body_code = DADA::Template::Widgets::screen(\n        {\n            -screen => 'jquery_subscription_form_body.tmpl',\n            -vars   => {\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    {\n                        -list          => $list,\n                        -ignore_cgi    => 1,\n                        -show_fieldset => 0,\n                        -subscription_form_id => 'dada_mail_modal_subscription_form'\n                    }\n                )\n            }\n        }\n    );\n\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'html_code_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -vars => {\n                screen            => 'html_code',\n                list              => $list,\n                jquery_head_code  => $jquery_head_code,\n                jquery_body_code  => $jquery_body_code,\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    { \n\t\t\t\t\t\t-list => $list, \n\t\t\t\t\t\t-ignore_cgi => 1, \n\t\t\t\t\t\t-show_fieldset => 0, \n\t\t\t\t\t\t-add_recaptcha_js => 1,\n\t\t\t\t\t}\n                ),\n                minimal_subscription_form =>\n                  DADA::Template::Widgets::subscription_form(\n                    {\n                        -list          => $list,\n                        -form_type     => 'minimal',\n                        -ignore_cgi    => 1,\n                        -show_fieldset => 0,\n\t\t\t\t\t\t-add_recaptcha_js => 1,\n\t\t\t\t\t\t\n                    }\n                  ),\n\t\t\t\t  form_fields_example =>\n                  DADA::Template::Widgets::subscription_form(\n                    {\n                        -list          => $list,\n                        -form_type     => 'form_fields_example',\n                        -ignore_cgi    => 1,\n                        -show_fieldset => 0,\n\t\t\t\t\t\t-add_recaptcha_js => 1,\n                    }\n                  ),\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub preview_subscription_form { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        { \n\t\t\t-list             => $list, \n\t\t\t-ignore_cgi       => 1, \n\t\t\t-show_fieldset    => 0, \n\t\t\t-add_recaptcha_js => 1,\n\t\t}\n    );\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_subscription_form_screen.tmpl',\n            -vars   => {\n               subscription_form => $subscription_form, \n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\nsub preview_modal_subscribe_landing_code { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_modal_subscribe_landing_code_screen.tmpl',\n            -vars   => {},\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\n\nsub preview_minimal_subscription_form { \n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\t\n    my $minimal_subscription_form = DADA::Template::Widgets::subscription_form(\n        { \n\t\t\t-list             => $list, \n\t\t\t-ignore_cgi       => 1, \n\t\t\t-show_fieldset    => 0, \n\t\t\t-add_recaptcha_js => 1,\n\t\t\t-form_type        => 'minimal',\n\t\t}\n    );\n\t\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_minimal_subscription_form_screen.tmpl',\n            -vars   => {\n               minimal_subscription_form => $minimal_subscription_form,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n}\n\n\n\n\nsub preview_jquery_plugin_subscription_form {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'html_code'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    my $jquery_subscription_form_body = DADA::Template::Widgets::screen(\n        {\n            -screen => 'jquery_subscription_form_body.tmpl',\n            -vars   => {\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    {\n                        -list                 => $list,\n                        -ignore_cgi           => 1,\n                        -show_fieldset        => 0,\n                        -subscription_form_id => 'dada_mail_modal_subscription_form', \n  \t\t\t\t\t\t-add_recaptcha_js     => 0,\n                    }\n                )\n            }\n        }\n    );\n\n    my $jquery_subscription_form_head = DADA::Template::Widgets::screen(\n        {\n            -screen                   => 'jquery_subscription_form_head.tmpl',\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n\n    my $scrn = DADA::Template::Widgets::screen(\n        {\n            -screen => 'preview_jquery_plugin_subscription_form.tmpl',\n            -vars   => {\n                jquery_subscription_form_head => $jquery_subscription_form_head,\n                jquery_subscription_form_body => $jquery_subscription_form_body,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub edit_template {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('don') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_template'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $raw_template     = DADA::Template::HTML::default_template();\n    my $default_template = default_template(\n        {\n            -Use_Custom => 0\n        }\n    );\n\n    if ( !$process ) {\n\t\t\n\t\t# This test is pretty primative. \n\t\t\n        my $content_tag_found_in_template         = 0;\n        my $content_tag_found_in_url_template     = 0;\n        my $content_tag_found_in_default_template = 0;\n\n        my $header_content_tag_found_in_template         = 0;\n        my $header_content_tag_found_in_url_template     = 0;\n        my $header_content_tag_found_in_default_template = 0;\n\t\t\n        my $content_tag        = quotemeta('<!-- tmpl_var content -->');\n        my $header_content_tag = quotemeta('<!-- tmpl_var header_content -->');\n\n        if (   $DADA::Config::TEMPLATE_OPTIONS->{user}->{enabled} == 1\n            && $DADA::Config::TEMPLATE_OPTIONS->{user}->{mode} eq 'magic' )\n        {\n            if ( $raw_template =~ m/$content_tag/ ) {\n                $content_tag_found_in_default_template = 1;\n            }\n            else {\n\t\t\t\t# srsrly wtf: \n                my $list_template_body_code_block =\n                  DADA::Template::Widgets::_raw_screen(\n                    {\n                        -screen => 'list_template_body_code_block.tmpl'\n                    }\n                  );\n                if ( $list_template_body_code_block =~ m/$content_tag/ ) {\n                    $content_tag_found_in_default_template = 1;\n                }\n            }\n        }\n        else {\n            if ( $raw_template =~ m/$content_tag/ ) {\n                $content_tag_found_in_default_template = 1;\n            }\n            if ( $raw_template =~ m/$header_content_tag/ ) {\n                $header_content_tag_found_in_default_template = 1;\n            }\n        }\n\n        # .tmpl\n\n        my $edit_this_template = $default_template . \"\\n\";\n        if ( check_if_template_exists( -List => $list ) >= 1 ) {\n            $edit_this_template = open_template( -List => $list ) . \"\\n\";\n        }\n        if ( $edit_this_template =~ m/$content_tag/ ) {\n            $content_tag_found_in_template = 1;\n        }\n\t\t\n        if ( $edit_this_template =~ m/$header_content_tag/ ) {\n            $header_content_tag_found_in_template = 1;\n        }\n\n        my $get_template_data_from_default_template = 0;\n        $get_template_data_from_default_template = 1\n          if $ls->param('get_template_data') eq 'from_default_template';\n\n        my $get_template_data_from_template_file = 0;\n        $get_template_data_from_template_file = 1\n          if $ls->param('get_template_data') eq 'from_template_file';\n\n        my $get_template_data_from_url = 0;\n        $get_template_data_from_url = 1\n          if $ls->param('get_template_data') eq 'from_url';\n\n        my $can_use_lwp_simple;\n        eval { require LWP::Simple; };\n        $can_use_lwp_simple = 1\n          if !$@;\n\n        my $template_saved = 0;\n        if ( -e $DADA::Config::TEMPLATES . '/' . $list . '.template' ) {\n            $template_saved = 1;\n        }\n        my $template_url_check = 1;\n\n        if ( $get_template_data_from_url == 1 ) {\n\n            if ( $can_use_lwp_simple == 1 ) {\n                eval {\n                    $LWP::Simple::ua->agent( 'Mozilla/5.0 (compatible; '\n                          . $DADA::CONFIG::PROGRAM_NAME\n                          . ')' );\n                };\n                if ( LWP::Simple::get( $ls->param('url_template') ) ) {\n                    my $tmp_tmpl =\n                      LWP::Simple::get( $ls->param('url_template') );\n                    if ( $tmp_tmpl =~ m/$content_tag/ ) {\n                        $content_tag_found_in_url_template = 1;\n                    }\n\t\t\t\t\t\n                    if ( $tmp_tmpl =~ m/$header_content_tag/ ) {\n                        $header_content_tag_found_in_url_template = 1;\n                    }\n\t\t\t\t\t\n                }\n                else {\n\n                    $template_url_check = 0;\n\n                }\n            }\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_template_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen                     => 'edit_template',\n                    done                       => $done,\n                    root_login                 => $root_login,\n                    edit_this_template         => $edit_this_template,\n                    get_template_data_from_url => $get_template_data_from_url,\n                    get_template_data_from_template_file =>\n                      $get_template_data_from_template_file,\n                    get_template_data_from_default_template =>\n                      $get_template_data_from_default_template,\n                    can_use_lwp_simple => $can_use_lwp_simple,\n                    default_template   => $default_template,\n                    template_url_check => $template_url_check,\n                    template_saved     => $template_saved,\n                    content_tag_found_in_template =>\n                      $content_tag_found_in_template,\n                    content_tag_found_in_url_template =>\n                      $content_tag_found_in_url_template,\n                    content_tag_found_in_default_template =>\n                      $content_tag_found_in_default_template,\n\t\t\t\t\t  \n\t\t\t\t  header_content_tag_found_in_template     => $header_content_tag_found_in_template,\n\t\t\t\t  header_content_tag_found_in_url_template => $header_content_tag_found_in_url_template,\n\t\t\t\t\t  \n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        if ( $process eq \"preview template\" ) {\n\n            my $template_info;\n            my $test_header;\n            my $test_footer;\n\n            if ( $q->param('get_template_data') eq 'from_default_template' ) {\n                $template_info = $raw_template;\n            }\n            elsif ( $q->param('get_template_data') eq 'from_url' ) {\n                eval { require LWP::Simple; };\n                if ( !$@ ) {\n                    eval {\n                        $LWP::Simple::ua->agent( 'Mozilla/5.0 (compatible; '\n                              . $DADA::CONFIG::PROGRAM_NAME\n                              . ')' );\n                    };\n                    $template_info =\n                      LWP::Simple::get( $q->param('url_template') );\n                }\n            }\n            else {\n                $template_info = $q->param(\"template_info\");\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen                   => 'preview_template.tmpl',\n                    -with                     => 'list',\n                    -wrapper_params           => { -data => \\$template_info, },\n                    -vars                     => { title => 'Preview', },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n                }\n            );\n            return $scrn;\n        }\n        else {\n\n            my $template_info = $q->param(\"template_info\");\n\n            $ls->save_w_params(\n                {\n                    -associate => $q,\n                    -settings  => {\n                        url_template      => '',\n                        get_template_data => '',\n                    }\n                }\n            );\n\n            make_template( { -List => $list, -Template => $template_info } );\n\n            $c->flush;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=edit_template&done=1' );\n\n        }\n    }\n}\n\n\nsub edit_type {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) = check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_type'\n    );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::App::FormatMessages;\n    my $dfm = DADA::App::FormatMessages->new( -List => $list );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_type_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen => 'edit_type',\n                    title  => 'Email Templates',\n\t\t\t\t\troot_login => $root_login, \n                    done   => $done,\n\n                    unsub_link_found_in_pt_mlm =>\n                      $dfm->can_find_unsub_link( { -str => $ls->param('mailing_list_message') } ),\n                    unsub_link_found_in_html_mlm =>\n                      $dfm->can_find_unsub_link( { -str => $ls->param('mailing_list_message_html') } ),\n                    message_body_tag_found_in_pt_mlm =>\n                      $dfm->can_find_message_body_tag( { -str => $ls->param('mailing_list_message') } ),\n                    message_body_tag_found_in_html_mlm =>\n                      $dfm->can_find_message_body_tag( { -str => $ls->param('mailing_list_message_html') } ),\n                },\n                -list_settings_vars       => $ls->get( -all_settings => 1 ),\n                -list_settings_vars_param => { -dot_it               => 1, },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        for (\n            qw(\n            mailing_list_message_from_phrase\n            mailing_list_message_to_phrase\n            mailing_list_message_subject\n            mailing_list_message\n            mailing_list_message_html\n            )\n          )\n        {\n\n            # a very odd place to put this, but, hey,  easy enough.\n            if ( $q->param('revert') ) {\n                $q->delete($_);\n            }\n            else {\n                my $tmp_setting = $q->param($_);\n                   $tmp_setting =~ s/\\r\\n/\\n/g;\n                   $q->param( $_, $tmp_setting );\n            }\n        }\n\n\t\tmy $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    mailing_list_message_from_phrase            => undef,\n                    mailing_list_message_to_phrase              => undef,\n                    mailing_list_message_subject                => undef,\n                    mailing_list_message                        => undef,\n                    mailing_list_message_html                   => undef,\n                }, \n\t\t\t\t-also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?flavor=edit_type&done=1' );\n    }\n}\n\n\n\nsub back_link {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'back_link'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'back_link_screen.tmpl',\n                -list           => $list,\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen => 'back_link',\n                    done =>\n                      ( ( $q->param('done') ) ? ( $q->param('done') ) : (0) ),\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    back_link_website_name => '',\n                    back_link_website_url  => '',\n                }\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props(\n            -url => $DADA::Config::S_PROGRAM_URL . '?flavor=back_link&done=1' );\n\n    }\n}\n\n\nsub email_themes  { \n\n\tmy $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my $done = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'email_themes'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\t\t\n\t\t\n\t\trequire DADA::App::EmailThemes; \n\t\tmy $dap = DADA::App::EmailThemes->new({-list => $list});\n\t\tmy $at = $dap->available_themes(); \n\t\tmy $at_labels = {}; \n\t\tforeach(@$at){ \n\t\t\tmy $l = $_; \n\t\t\t$l =~ s/_/ /g; \n\t\t\t$l = join \" \", map {ucfirst} split \" \", $l;\n\t\t\t$at_labels->{$_} = $l;\n\t\t}\n\t\t\n\t\tmy $default_theme = $ls->param('email_theme_name') || 'default';\n\t\t\n        require HTML::Menu::Select;\n\t\tmy $email_theme_name_widget = HTML::Menu::Select::popup_menu(\n            {\n                name    => 'email_theme_name',\n                id      => 'email_theme_name',\n                default => $default_theme,\n                labels  => $at_labels,\n                values => $at,\n            }\n          );\n\t\t  \n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'email_themes_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen     => 'email_themes',\n                    title      => 'Email Themes',\n                    root_login => $root_login,\n                    done       => $done,\n\t\t\t\t\temail_theme_name_widget => $email_theme_name_widget, \n                },\n                -list_settings_vars       => $ls->get( -all_settings => 1 ),\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\t\t\n        my $also_save_for_list = $ls->also_save_for_list($q);\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    email_theme_name         => undef,\n                }, \n                -also_save_for => $also_save_for_list,\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=email_themes&done=1' );\n    }\n}\n\n\n\nsub edit_html_type {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my $done = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'edit_html_type'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n\n        #use Data::Dumper;\n        #die Dumper($ls->get(-dotted => 1, -all_settings => 1));\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'edit_html_type_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -list => $list,\n                -vars => {\n                    screen     => 'edit_html_type',\n                    title      => 'HTML Screen Templates',\n                    root_login => $root_login,\n                    done       => $done,\n                },\n                -list_settings_vars       => $ls->get( -all_settings => 1 ),\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        for (\n            qw(\n            html_confirmation_message\n            html_subscribed_message\n            html_subscription_request_message\n            html_unsubscribed_message\n            )\n          )\n        {\n            my $tmp_setting = $q->param($_);\n            $tmp_setting =~ s/\\r\\n/\\n/g;\n            $q->param( $_, $tmp_setting );\n        }\n\n        my $also_save_for_list = $ls->also_save_for_list($q);\n\t\t\n        $ls->save_w_params(\n            {\n                -associate => $q,\n                -settings  => {\n                    html_confirmation_message         => '',\n                    html_subscribed_message           => '',\n                    html_subscription_request_message => '',\n                    html_unsubscribed_message         => '',\n                },\n\t\t\t\t -also_save_for => $also_save_for_list,\n            },\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=edit_html_type&done=1' );\n    }\n}\n\nsub manage_script {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'manage_script'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list               = $admin_list;\n    my $more_info          = $q->param('more_info') || 0;\n    my $sendmail_locations = `whereis sendmail`;\n    my $curl_location      = `which curl`;\n    my $wget_location      = `which wget`;\n\n    my $at_incs = [];\n\n    for (@INC) {\n        if ( $_ !~ /^\\./ ) {\n            push( @$at_incs, { name => $_ } );\n        }\n    }\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'manage_script_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n            -list => $list,\n            -vars => {\n                more_info          => $more_info,\n                smtp_server        => $ls->param('smtp_server'),\n                server_software    => $q->server_software(),\n                operating_system   => $^O,\n                perl_version       => $],\n                sendmail_locations => $sendmail_locations,\n                at_incs            => $at_incs,\n                list_owner_email   => $ls->param('list_owner_email'),\n                curl_location      => $curl_location,\n                wget_location      => $wget_location,\n            },\n        }\n    );\n\n    return $scrn;\n\n}\n\nsub feature_set {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'feature_set'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Template::Widgets::Admin_Menu;\n\n    if ( !$process ) {\n\n        my $feature_set_menu =\n          DADA::Template::Widgets::Admin_Menu::make_feature_menu( $ls->get );\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'feature_set_screen.tmpl',\n                -with           => 'admin',\n                -expr           => 1,\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -vars => {\n                    screen           => 'feature_set',\n                    done             => ( defined($done) ) ? 1 : 0,\n                    feature_set_menu => $feature_set_menu,\n                    disabled_screen_view_hide =>\n                      ( $ls->param('disabled_screen_view') eq 'hide' ) ? 1 : 0,\n                    disabled_screen_view_grey_out =>\n                      ( $ls->param('disabled_screen_view') eq 'grey_out' )\n                    ? 1\n                    : 0,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            }\n        );\n        return $scrn;\n    }\n    else {\n\n        my @params = $q->param;\n        my %param_hash;\n        for (@params) {\n            next if $_ eq 'disabled_screen_view';    # special case.\n            $param_hash{$_} = $q->param($_);\n        }\n\n        my $save_set =\n          DADA::Template::Widgets::Admin_Menu::create_save_set( \\%param_hash );\n\n        my $disabled_screen_view     = $q->param('disabled_screen_view');\n        my $list_control_panel_style = $q->param('list_control_panel_style')\n          // 'top_bar';\n\n        $ls->save(\n            {\n                -settings => {\n                    admin_menu               => $save_set,\n                    disabled_screen_view     => $disabled_screen_view,\n                    list_control_panel_style => $list_control_panel_style,\n                }\n            }\n        );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=feature_set&done=1' );\n\n    }\n}\n\n\n\nsub profile_fields {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'profile_fields'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n\n    require DADA::ProfileFieldsManager;\n    my $pfm = DADA::ProfileFieldsManager->new;\n\n    require DADA::Profile::Fields;\n    my $dpf = DADA::Profile::Fields->new;\n\n    if ( $dpf->can_have_subscriber_fields == 0 ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'profile_fields_screen.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -vars => {\n                    screen => 'profile_fields',\n                    title  => 'Profile Fields',\n                    can_have_subscriber_fields =>\n                      $dpf->can_have_subscriber_fields,\n\n                },\n            }\n        );\n        return $scrn;\n    }\n\n    # But, if we do....\n    my $subscriber_fields = $pfm->fields;\n    my $fields_attr       = $pfm->get_all_field_attributes;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $field_status        = 1;\n    my $field_error_details = {\n        field_blank            => 0,\n        field_name_too_long    => 0,\n        slashes_in_field_name  => 0,\n        weird_characters       => 0,\n        quotes                 => 0,\n        field_exists           => 0,\n        spaces                 => 0,\n        field_is_special_field => 0,\n    };\n    my %flattened_field_errors = ();\n\n    my $edit_field = xss_filter( scalar $q->param('edit_field') );\n\n    my $field                = '';\n    my $fallback_field_value = '';\n    my $field_label          = '';\n    my $field_required       = 0;\n\n    if ( $edit_field == 1 ) {\n        $field                = xss_filter( scalar $q->param('field') );\n        $fallback_field_value = $fields_attr->{$field}->{fallback_value};\n        $field_label          = $fields_attr->{$field}->{label};\n        $field_required       = $fields_attr->{$field}->{required};\n    }\n    else {\n        $field = xss_filter( scalar $q->param('field') );\n        $fallback_field_value =\n          xss_filter( scalar $q->param('fallback_field_value') );\n        $field_label = xss_filter( scalar $q->param('field_label') );\n        $field_required = $q->param('field_required') || 0;\n        if ( $field_required ne \"1\" && $field_required ne \"0\" ) {\n            die \"field_required needs to be either 1, or 0!\";\n            $field_required = 0;\n        }\n    }\n\n    if ( !$root_login && defined($process) ) {\n        die \"You need to log into the list with the root pass to do that!\";\n    }\n    if ( $process eq 'edit_field_order' ) {\n        my $dir = $q->param('direction') || 'down';\n        $pfm->change_field_order(\n            {\n                -field     => $field,\n                -direction => $dir,\n            }\n        );\n        $c->flush;\n\n        $self->header_type('redirect');\n        $self->header_props(\n            -url => $DADA::Config::S_PROGRAM_URL . '?flavor=profile_fields' );\n\n    }\n    if ( $process eq 'delete_field' ) {\n        ###\n        $pfm->remove_field( { -field => $field } );\n        $c->flush;\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor=profile_fields;deletion=1;working_field='\n              . $field\n              . ';field_changes=1' );\n\n    }\n    elsif ( $process eq 'add_field' ) {\n\n        ( $field_status, $field_error_details ) =\n          $pfm->validate_field_name( { -field => $field } );\n\n        if ( $field_status == 1 ) {\n            $pfm->add_field(\n                {\n                    -field          => $field,\n                    -fallback_value => $fallback_field_value,\n                    -label          => $field_label,\n                    -required       => $field_required,\n                }\n            );\n\n            $c->flush;\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=profile_fields;addition=1;working_field='\n                  . $field\n                  . ';field_changes=1' );\n\n        }\n        else {\n# Else, I guess for now, we'll show the template and have the errors print out there...\n            for (%$field_error_details) {\n                $flattened_field_errors{ 'field_error_' . $_ } =\n                  $field_error_details->{$_};\n            }\n\n        }\n    }\n    elsif ( $process eq 'edit_field' ) {\n\n        my $orig_field = xss_filter( scalar $q->param('orig_field') );\n\n        #old name\t\t\t# new name\n        if ( $orig_field eq $field ) {\n            ( $field_status, $field_error_details ) =\n              $pfm->validate_field_name(\n                { -field => $field, -skip => [qw(field_exists)] } );\n        }\n        else {\n            ( $field_status, $field_error_details ) =\n              $pfm->validate_field_name( { -field => $field } );\n        }\n        if ( $field_status == 1 ) {\n\n            $pfm->remove_field_attributes( { -field => $orig_field } );\n\n            if ( $orig_field eq $field ) {\n\n                # ...\n            }\n            else {\n                $pfm->edit_field_name(\n                    { -old_name => $orig_field, -new_name => $field } );\n                my $meta =\n                  $ls->param('tracker_update_profile_fields_ip_dada_meta');\n                if ( length($meta) > 4 ) {\n                    my $thawed_gip = $ls->_dd_thaw($meta);\n                    $thawed_gip->{$field} = $thawed_gip->{$orig_field};\n                    delete( $thawed_gip->{$orig_field} );\n                    $ls->save(\n                        {\n                            -settings => {\n                                tracker_update_profile_fields_ip_dada_meta =>\n                                  $ls->_dd_freeze($thawed_gip)\n                            }\n                        }\n                    );\n                }\n            }\n            $pfm->save_field_attributes(\n                {\n                    -field          => $field,\n                    -fallback_value => $fallback_field_value,\n                    -label          => $field_label,\n                    -required       => $field_required,\n                }\n            );\n            $c->flush;\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=profile_fields;edited=1;working_field='\n                  . $field\n                  . ';field_changes=1' );\n        }\n        else {\n# Else, I guess for now, we'll show the template and have the errors print out there...\n            $edit_field = 1;\n            $field      = xss_filter( scalar $q->param('orig_field') );\n\n            for (%$field_error_details) {\n                $flattened_field_errors{ 'field_error_' . $_ } =\n                  $field_error_details->{$_};\n            }\n        }\n    }\n\n    my $can_move_columns =\n      ( $DADA::Config::SQL_PARAMS{dbtype} eq 'mysql' ) ? 1 : 0;\n\n    my $named_subscriber_fields = [];\n\n    for (@$subscriber_fields) {\n        push(\n            @$named_subscriber_fields,\n            {\n                field            => $_,\n                fallback_value   => $fields_attr->{$_}->{fallback_value},\n                label            => $fields_attr->{$_}->{label},\n                required         => $fields_attr->{$_}->{required},\n                root_login       => $root_login,\n                can_move_columns => $can_move_columns,\n            }\n        );\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'profile_fields_screen.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $list,\n            },\n\n            -vars => {\n\n                screen => 'profile_fields',\n                title  => 'Profile Fields',\n\n                edit_field => $edit_field,\n                fields     => $named_subscriber_fields,\n\n                field_status         => $field_status,\n                field                => $field,\n                fallback_field_value => $fallback_field_value,\n                field_label          => $field_label,\n                field_required       => $field_required,\n\n                can_have_subscriber_fields => $dpf->can_have_subscriber_fields,\n\n                root_login => $root_login,\n\n                HIDDEN_SUBSCRIBER_FIELDS_PREFIX =>\n                  $DADA::Config::HIDDEN_SUBSCRIBER_FIELDS_PREFIX,\n\n                using_SQLite => $DADA::Config::SQL_PARAMS{dbtype} eq 'SQLite' ? 1 : 0,\n                field_changes =>\n                  xss_filter( scalar $q->param('field_changes') ),\n                working_field =>\n                  xss_filter( scalar $q->param('working_field') ),\n                deletion => xss_filter( scalar $q->param('deletion') ),\n                addition => xss_filter( scalar $q->param('addition') ),\n                edited   => xss_filter( scalar $q->param('edited') ),\n\n                can_move_columns => $can_move_columns,\n\n                %flattened_field_errors,\n            },\n        }\n    );\n    return $scrn;\n\n}\n\nsub subscribe {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\n\t# We're not going to accept GET requests:\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->subscribe_landing(); \n\t}\n\t\n\t\n    my %args = ( -html_output => 1, @_ );\n\n\tmy $skip_tests = [];\n\tif(exists($args{-skip_tests})){ \n\t\t$skip_tests = $args{-skip_tests};\n\t}\n\t\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->subscribe(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n\t\t\t-skip_tests  => $skip_tests, \n        }\n    );\n\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n}\n\nsub restful_subscribe {\n\n    my $self = shift;\n    my $q    = $self->query();\n    try {\n        require JSON;\n    }\n    catch {\n        warn 'Perl CPAN module: JSON is required!';\n        die '425';\n    };\n\n    my $json = JSON->new->allow_nonref;\n\n    my $using_jsonp = 0;\n\n    if ( $q->param('_method') eq 'GET' && $q->url_param('callback') ) {\n\n        # that's OK - it's a jsonp call.\n        $using_jsonp = 1;\n\n    }\n    elsif ($DADA::Config::S_PROGRAM_URL =~ m/\\?$/\n        && $q->param('_method') eq 'GET'\n        && $q->param('callback') )\n    {\n\n     # this is a messy workaround.\n     # If $S_PROGRAM_URL has a trailing, \"?\", it means something a little weird,\n     # as the PATH_INFO is read from the QUERY_STRING, then parsed.\n     # url_param()'s don't work like that, so we have to read it from param()\n        $using_jsonp = 1;\n\n    }\n    elsif ( $q->content_type =~ m/application\\/json/ ) {\n\n        # That's OK too - we support getting the params you send us in POST\n\n    }\n    elsif ( !$q->content_type || $q->content_type =~ m/text\\/html/ ) {\n\n        # RTFM!\n        my $api_doc_url =\n'https://dadamailproject.com/d/COOKBOOK-subscriptions.pod.html#restful_api';\n        return\n            '<p>API Documentation: <a href=\"'\n          . $api_doc_url . '\"/>'\n          . $api_doc_url\n          . '</a></p>';\n\n    }\n    else {\n\n        die '425';\n\n    }\n\n    my $new_q = undef;\n    if ( $using_jsonp == 0 ) {\n        my $post_data = $q->param('POSTDATA');\n        my $data      = undef;\n        try {\n            $data = $json->decode($post_data);\n        }\n        catch {\n            # What should really be done is to return a custom json doc\n            # saying there was a problem with the POSTDATA - essentially, it\n            # would be blank.\n            warn 'problems decoding POSTDATA: ' . $_;\n            warn 'POSTDATA looks like this: ' . $data;\n            die '400';\n        };\n\n        require CGI;\n        $new_q = CGI->new;\n        $new_q->charset($DADA::Config::HTML_CHARSET);\n\n        $new_q->delete_all;\n\n        $new_q->param( 'list',   $data->{list} );\n        $new_q->param( 'email',  $data->{email} );\n        $new_q->param( 'flavor', 'subscribe' );\n\n        require DADA::ProfileFieldsManager;\n        my $pfm = DADA::ProfileFieldsManager->new;\n\n        # Profile Fields\n        for ( @{ $pfm->fields } ) {\n            if ( exists( $data->{fields}->{$_} ) ) {\n                $new_q->param( $_, $data->{fields}->{$_} );\n            }\n        }\n    }\n    else {\n        $new_q = $q;\n    }\n\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n\n    my $callback = undef;\n    if ($using_jsonp) {\n\n        # Messy workaround again:\n        if ( $DADA::Config::S_PROGRAM_URL =~ m/\\?$/ ) {\n            $callback = xss_filter( strip( $q->param('callback') ) );\n        }\n        else {\n            $callback = xss_filter( strip( $q->url_param('callback') ) );\n        }\n    }\n\n    my $headers = {};\n    if ($using_jsonp) {\n        $headers = {\n            -type                           => 'application/javascript',\n            '-Access-Control-Allow-Origin'  => '*',\n            '-Access-Control-Allow-Methods' => 'POST',\n            '-Cache-Control'                => 'no-cache, must-revalidate',\n            -expires                        => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        };\n\n    }\n    else {\n        $headers = {\n            -type            => 'application/json',\n            '-Cache-Control' => 'no-cache, must-revalidate',\n            -expires         => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        };\n    }\n\n    my ( $throwaway_headers, $body ) = $das->subscribe(\n        {\n            -cgi_obj     => $new_q,\n            -return_json => 1,\n        }\n    );\n\n    #\twarn \"\\$callback\\n\" . $callback;\n    #\twarn \"\\$headers\\n\" . $headers;\n\n    if ($using_jsonp) {\n        $self->header_props(%$headers);\n        return $callback . '(' . $body . ');';\n    }\n    else {\n        $self->header_props(%$headers);\n        return $body;\n    }\n}\n\nsub unsubscribe {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->unsubscribe(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n}\n\nsub unsubscription_request {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->unsubscription_request(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n        }\n    );\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n\n}\n\nsub unsubscribe_email_lookup {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->unsubscribe_email_lookup(\n        {\n            -cgi_obj => $q,\n        }\n    );\n    $self->header_props(%$headers);\n    return $body;\n\n}\n\nsub outdated_subscription_urls {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    if ( check_if_list_exists( -List => $list ) == 0 ) {\n        undef($list);\n        return $self->default();\n    }\n\n    my $orig_flavor = $q->param('orig_flavor') || undef;\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen => 'outdated_subscription_urls_screen.tmpl',\n            -with   => 'list',\n            -list   => $list,\n            -expr   => 1,\n\n#\t\t-list_settings_vars_param => {-list => $list,},\n#\t\t-subscriber_vars_param    => {-list => $list, -email => $email, -type => 'list'},\n\n            -vars => {\n                show_profile_widget => 0,\n                orig_flavor         => $orig_flavor,\n\n                subscription_form => DADA::Template::Widgets::subscription_form(\n                    {\n                        -list       => $list,\n                        -email      => $email,\n                        -magic_form => 0,\n                    },\n                ),\n                unsubscription_form =>\n                  DADA::Template::Widgets::unsubscription_form(\n                    {\n                        -list  => $list,\n                        -email => $email,\n                    },\n                  ),\n            }\n        }\n    );\n    return $scrn;\n}\n\n\nsub token { \n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n\n\t# I'm fine with this check, as the whole reason for this is to \n\t# ONLY accept request via POST: \n\t#\n\t# There are some exceptions, where \"token\" is used as a flavor of the form - this \n\t# should handle those exceptions as well, so long as the form's action is, \"POST\":\n\t\n\tif($q->request_method() =~ m/POST/i){\n\t\t# is this ever called with args?\n\t\treturn $self->post_token(%args); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_token_get.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\ttoken => $q->param('token'), \n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \n\t}\n\t\n}\nsub post_token {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = ( -html_output => 1, @_ );\n    require DADA::App::Subscriptions;\n    my $das = DADA::App::Subscriptions->new;\n    my ( $headers, $body ) = $das->token(\n        {\n            -cgi_obj     => $q,\n            -html_output => $args{-html_output},\n        }\n    );\n\n    # use Data::Dumper;\n    # warn Dumper({headers => $headers, body => $body});\n\n    if ( exists( $headers->{-redirect_uri} ) ) {\n        $self->header_type('redirect');\n        $self->header_props( -url => $headers->{-redirect_uri} );\n    }\n    else {\n        if ( keys %$headers ) {\n            $self->header_props(%$headers);\n        }\n        return $body;\n    }\n}\n\nsub report_abuse {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $report_abuse_token = $q->param('report_abuse_token');\n    my $process = $q->param('process') || 0;\n\n    require DADA::App::Subscriptions::ConfirmationTokens;\n    my $ct = DADA::App::Subscriptions::ConfirmationTokens->new();\n\n    if ( $ct->exists($report_abuse_token) ) {\n        my $data = $ct->fetch($report_abuse_token);\n\n        if ( $data->{data}->{flavor} eq 'report_abuse' ) {\n\n            my $list = $data->{data}->{list};\n\n            if ( $process != 1 ) {\n\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen => 'report_abuse.tmpl',\n                        -with   => 'list',\n                        -vars   => {\n                            report_abuse_token => $report_abuse_token,\n                        },\n                        -list_settings_vars_param =>\n                          { -list => $list, -dot_it => 1 },\n                    }\n                );\n                return $scrn;\n            }\n            else {\n\n                my $abuse_report_details = $q->param('abuse_report_details');\n                $abuse_report_details =~ s/\\r\\n/\\n/g;\n\n                my $email = $data->{email};\n\n                #use Data::Dumper;\n                #warn Dumper($data);\n\n                # Email the Abuse Report\n                require DADA::App::Messages;\n                my $dap = DADA::App::Messages->new( { -list => $list } );\n                $dap->send_abuse_report(\n                    {\n                        -email                => $email,\n                        -abuse_report_details => $abuse_report_details,\n                    }\n                );\n\n                # (log the actual report?)\n                # ... #\n                #\n\n                # Log it for the Tracker\n                require DADA::Logging::Clickthrough;\n                my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n                $r->abuse_log(\n                    {\n                        -email => $email,\n                        -mid   => $data->{data}->{mid},\n\n                        # -details => unique_id to some sort of report table...\n                    }\n                );\n\n                $ct->remove_by_token($report_abuse_token);\n\n                # Tell 'em it worked!\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen => 'report_abuse_complete.tmpl',\n                        -with   => 'list',\n                        -vars   => {},\n                        -list_settings_vars_param =>\n                          { -list => $list, -dot_it => 1 },\n                    }\n                );\n                return $scrn;\n\n            }\n        }\n        else {\n            return user_error( { -error => 'token_problem' } );\n        }\n    }\n    else {\n        return user_error( { -error => 'token_problem' } );\n    }\n}\n\nsub resend_conf {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my $can_use_captcha = 0;\n\n    if ( $ls->param('limit_sub_confirm_use_captcha') == 1 ) {\n        $can_use_captcha = can_use_Google_reCAPTCHA();\n    }\n    if ( $can_use_captcha == 1 ) {\n        $self->resend_conf_captcha();\n    }\n    else {\n        $self->resend_conf_no_captcha();\n    }\n\n}\n\nsub resend_conf_captcha {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    my $admin_override = $q->param('admin_override') || 0;\n    my $admin_override_enabled = 0;\n    my ( $admin_list, $root_login, $checksout, $error_msg );\n    if ( $admin_override == 1 ) {\n        ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'view_list'\n          );\n        if ( !$checksout ) {\n            return $error_msg;\n        }\n        else {\n            $admin_override_enabled = 1;\n        }\n    }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $captcha_worked = 0;\n    my $captcha_auth   = 1;\n\n    my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\n    if ( $admin_override_enabled != 1 ) {\n        if ( !$crf ) {\n            $captcha_worked = 0;\n        }\n        else {\n\t\t\t\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n            if ( $captcha_status == 1 ) {\n                $captcha_auth   = 1;\n                $captcha_worked = 1;\n            }\n            else {\n                $captcha_worked = 0;\n                $captcha_auth   = 0;\n            }\n        }\n    }\n    if ( $captcha_worked == 1 || $admin_override_enabled == 1 ) {\n        if ( $q->param('rm') eq 's' ) {\n\n            # so, what's $sub_info for?!\n            my $sub_info = $lh->get_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n            for ( keys %{$sub_info} ) {\n                next if $_ eq 'email';\n                next if $_ eq 'email_name';\n                next if $_ eq 'email_domain';\n                $q->param( $_, $sub_info->{$_} );\n            }\n\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list'\n                }\n            );\n            $q->param( 'list',  $list );\n            $q->param( 'email', $email );\n            $q->delete(\n                'flavor',\n\t\t\t\t'rm',\n                'g-recaptcha-response',\n\t\t\t\t'token',\n            );\n            $q->param( 'flavor', 's' );\n\t\t\t\n\t\t\tmy $skip_tests = [\n\t\t\t\t'captcha_challenge_failed', \n\t\t\t\t'list_consent_check', \n\t\t\t];\n\t\t\t\n\t\t\t\n            $self->subscribe(-skip_tests => $skip_tests);\n\n        }\n        elsif ( $q->param('rm') eq 'unsubscription_request' ) {\n\n            # I like the idea better that we call the function directly...\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_confirm_list'\n                }\n            );\n            $q->param( 'list',   $list );\n            $q->param( 'email',  $email );\n            $q->param( 'flavor', 'unsubscription_request' );\n            $self->unsubscription_request();\n        }\n    }\n    else {\n        my $error = '';\n        if ( $q->param('rm') eq 's' ) {\n            $error = 'already_sent_sub_confirmation';\n        }\n        elsif ( $q->param('rm') eq 'unsubscription_request' ) {\n            $error = 'already_sent_unsub_confirmation';\n        }\n        else {\n            die 'unknown $rm!';\n        }\n\t\t\n\t\t\n        return user_error(\n            {\n                -error => $error,\n                -list  => $list,\n                -email => $email,\n                -vars  => { \n\t\t\t\t\tcan_use_captcha => 1, \n\t\t\t\t\tcaptcha_auth    => $captcha_auth,\n\t\t\t\t},\n            }\n        );\n    }\n\n}\n\nsub resend_conf_no_captcha {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    my $list_exists = check_if_list_exists( -List => $list, );\n\n    my $admin_override = $q->param('admin_override') || 0;\n    my $admin_override_enabled = 0;\n    my ( $admin_list, $root_login, $checksout, $error_msg );\n    if ( $admin_override == 1 ) {\n        ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'view_list'\n          );\n        if ( !$checksout ) {\n            return $error_msg;\n        }\n        else {\n            $admin_override_enabled = 1;\n        }\n    }\n\n    if ( $list_exists == 0 ) {\n        return $self->default();\n    }\n    if ( !$email ) {\n        $q->param( 'error_no_email', 1 );\n        return $self->list_page();\n    }\n    if (   $q->param('rm') ne 's'\n        && $q->param('rm') ne 'u' )\n    {\n        return $self->default();\n    }\n    if ( $q->request_method() !~ m/POST/i && $admin_override_enabled != 1 ) {\n        return $self->default();\n    }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my ( $sec, $min, $hour, $day, $month, $year ) =\n      (localtime)[ 0, 1, 2, 3, 4, 5 ];\n\n# This is just really broken... should be a CAPTCHA...\n# I'm assuming this happens if we FAILED this test below (1 = failure for check_email_pin)\n#\n\n    my $cep_results = DADA::App::Guts::check_email_pin(\n        -Email => $month . '.' . $day . '.' . $email,\n        -Pin   => xss_filter( scalar $q->param('auth_code') ),\n        -List  => $list,\n    );\n\n    if ( $cep_results == 0 && $admin_override_enabled != 1 ) {\n        my ( $e_day, $e_month, $e_stuff ) = split( '.', $email );\n\n        #  Ah, I see, it only is blocked for a... day?\n        if ( $e_day != $day || $e_month != $month ) {\n\n            # a stale blocking thingy.\n            if ( $q->param('rm') eq 's' ) {\n                my $rm_status = $lh->remove_subscriber(\n                    {\n                        -email => $email,\n                        -type  => 'sub_confirm_list'\n                    }\n                );\n            }\n            elsif ( $q->param('rm') eq 'u' ) {\n\n                my $rm_status = $lh->remove_subscriber(\n                    {\n                        -email => $email,\n                        -type  => 'unsub_confirm_list'\n                    }\n                );\n            }\n        }\n        return $self->list_page();\n    }\n    else {\n\n        if ( $q->param('rm') eq 's' ) {\n            my $sub_info = $lh->get_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list',\n                }\n            );\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'sub_confirm_list'\n                }\n            );\n            $q->param( 'list',   $list );\n            $q->param( 'email',  $email );\n            $q->param( 'flavor', 's' );\n          \t\n\t\t\tmy $skip_tests = [\n\t\t\t\t'list_consent_check', \n\t\t\t];\n            $self->subscribe(-skip_tests => $skip_tests);\n\t\t\t\n        }\n        elsif ( $q->param('rm') eq 'u' ) {\n\n            # I like the idea better that we call the function directly...\n            my $rm_status = $lh->remove_subscriber(\n                {\n                    -email => $email,\n                    -type  => 'unsub_confirm_list'\n                }\n            );\n            $q->param( 'list',   $list );\n            $q->param( 'email',  $email );\n            $q->param( 'flavor', 'unsubscription_request' );\n            $self->unsubscription_request();\n        }\n    }\n}\n\nsub show_error {\n\n\t\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $email = xss_filter( scalar $q->param('email') ) || undef;\n    my $error = xss_filter( scalar $q->param('error') ) || undef;\n    my $list  = xss_filter( scalar $q->param('list') )  || undef;\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $list_exists = check_if_list_exists( -List => $list, );\n    if ( $list_exists == 0 ) {\n\t\t\n        return $self->default();\n    }\n    if ( !$email ) {\n        $q->param( 'error_no_email', 1 );\n        return $self->list_page();\n    }\n\n    if ( \n\t$error ne 'already_sent_sub_confirmation'\n\t&& \n\t$error ne 'captcha_challenge_failed') {\n        return $self->default();\n    }\n\n    require DADA::App::Error;\n    my $error_msg = DADA::App::Error::cgi_user_error(\n        {\n            -list  => $list,\n            -error => $error,\n            -email => $email,\n        }\n    );\n    return $error_msg;\n\n}\n\nsub text_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'text_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $ls   = DADA::MailingList::Settings->new( { -list => $list } );\n    my $lh   = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $type = $q->param('type') || 'list';\n    my $query = xss_filter( scalar $q->param('query') ) || undef;\n    my $advanced_search =\n      xss_filter( scalar $q->param('advanced_search') ) || 0;\n    my $advanced_query =\n      xss_filter( scalar $q->param('advanced_query') ) || undef;\n    my $order_by = $q->param('order_by') || $ls->param('view_list_order_by');\n    my $order_dir = $q->param('order_dir')\n      || lc( $ls->param('view_list_order_by_direction') );\n\n    my $show_timestamp_column = $q->param('show_timestamp_column') || 0;\n    my $show_delivery_prefs_column =\n      $q->param('show_delivery_prefs_column') || 0;\n    my $show_profile_fields = $q->param('show_profile_fields') || 0;\n\n    my $partial_listing = {};\n    if ($advanced_query) {\n        if ( $advanced_search == 1 ) {\n            open my $fh, '<', \\$advanced_query || die $!;\n            require CGI;\n            my $new_q = CGI->new($fh);\n            $new_q->charset($DADA::Config::HTML_CHARSET);\n            $new_q           = decode_cgi_obj($new_q);\n            $partial_listing = partial_sending_query_to_params($new_q);\n        }\n    }\n\n    my $email;\n\n    my $headers = {\n        -attachment => $list . '-' . $type . '.csv',\n        -type       => 'text/csv',\n    };\n    my $body;\n    if ($advanced_query) {\n        $body = $lh->print_out_list(\n            {\n                -type                       => $type,\n                -order_by                   => $order_by,\n                -order_dir                  => $order_dir,\n                -partial_listing            => $partial_listing,\n                -show_timestamp_column      => $show_timestamp_column,\n                -show_delivery_prefs_column => $show_delivery_prefs_column,\n                -show_profile_fields        => $show_profile_fields,\n                -print_out                  => 0,\n            }\n        );\n    }\n    else {\n        $body = $lh->print_out_list(\n            {\n                -type                       => $type,\n                -query                      => $query,\n                -order_by                   => $order_by,\n                -order_dir                  => $order_dir,\n                -show_timestamp_column      => $show_timestamp_column,\n                -show_delivery_prefs_column => $show_delivery_prefs_column,\n                -show_profile_fields        => $show_profile_fields,\n                -print_out                  => 0,\n            }\n        );\n    }\n    $self->header_props(%$headers);\n    return $body;\n}\n\n\n\n\n\nsub new_list {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\t# GET request not allowed. \n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\t\n    require DADA::Security::Password;\n    my $root_password    = $q->param('root_password');\n    my $agree            = $q->param('agree');\n    my $process          = $q->param('process');\n    my $help             = $q->param('help');\n    my $list             = $q->param('list');\n    my $list_name        = $q->param('list_name')        || undef;\n    my $list_owner_email = $q->param('list_owner_email') || undef;\n    my $admin_email      = $q->param('admin_email')      || undef;\n    my $privacy_policy   = $q->param('privacy_policy')   || undef;\n    my $consent          = $q->param('consent')          || undef;\n    my $info             = $q->param('info')             || undef;\n    my $physical_address = $q->param('physical_address') || undef;\n    my $password         = $q->param('password')         || undef;\n    my $retype_password  = $q->param('retype_password')  || undef;\n\n    my $send_new_list_welcome_email =\n      $q->param('send_new_list_welcome_email') || 0;\n    my $send_new_list_welcome_email_with_list_pass =\n      $q->param('send_new_list_welcome_email_with_list_pass') || 0;\n\n    if ( !$process ) {\n\n        my $errors = shift;\n        my $flags  = shift;\n        my $pw_check;\n\n        require DADA::Security::SimpleAuthStringState;\n        my $sast       = DADA::Security::SimpleAuthStringState->new;\n        my $auth_state = $q->param('auth_state');\n\n        if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n            if ( $sast->check_state($auth_state) != 1 ) {\n                return user_error(\n                    { -list => undef, -error => 'incorrect_login_url' } );\n            }\n\n        }\n\n        if ( !$errors && can_use_Google_reCAPTCHA() == 1 ) {\n\n            my $crf =\n              xss_filter( scalar $q->param('g-recaptcha-response') ) || undef;\n            my $captcha_status = validate_recaptcha(\n                {\n                    -response    => $crf,\n                    -remote_addr => $ENV{'REMOTE_ADDR'},\n                }\n            );\n            if ( $captcha_status == 0 ) {\n                return user_error(\n                    {\n                        -list  => $list,\n                        -error => 'list_cp_login_recaptcha_failed',\n                    }\n                );\n            }\n        }\n\n        if ( !$DADA::Config::PROGRAM_ROOT_PASSWORD ) {\n            return user_error(\n                { -list => $list, -error => \"no_root_password\" } );\n        }\n        elsif ( $DADA::Config::ROOT_PASS_IS_ENCRYPTED == 1 ) {\n\n            #encrypted password check\n            $pw_check =\n              DADA::Security::Password::check_password(\n                $DADA::Config::PROGRAM_ROOT_PASSWORD,\n                $root_password );\n        }\n        else {\n            # unencrypted password check\n            if ( $DADA::Config::PROGRAM_ROOT_PASSWORD eq $root_password ) {\n                $pw_check = 1;\n            }\n        }\n\n        if ( $pw_check == 1 ) {\n\n            my @t_lists = available_lists();\n\n            $agree = 'yes' if $errors;\n\n            if ( ( !$t_lists[0] ) && ( $agree ne 'yes' ) && ( !$process ) ) {\n                $self->header_type('redirect');\n                $self->header_props(\n                    -url => $DADA::Config::S_PROGRAM_URL . '?agree=no' );\n            }\n\n            if ( strip($DADA::Config::LIST_QUOTA) eq '' ) {\n                $DADA::Config::LIST_QUOTA = undef;\n            }\n\n            # Special:\n            if ( $DADA::Config::LIST_QUOTA == 0 ) {\n                $DADA::Config::LIST_QUOTA = undef;\n            }\n            if ( defined($DADA::Config::LIST_QUOTA)\n                && ( ( $#t_lists + 1 ) >= $DADA::Config::LIST_QUOTA ) )\n            {\n                return user_error(\n                    { -list => $list, -error => \"over_list_quota\" } );\n            }\n\n            if ( !$t_lists[0] ) {\n                $help = 1;\n            }\n\n            my $ending   = undef;\n            my $err_word = undef;\n\n            if ($errors) {\n                $ending   = '';\n                $err_word = 'was';\n                $ending   = 's'    if $errors > 1;\n                $err_word = 'were' if $errors > 1;\n            }\n\n            my @available_lists = DADA::App::Guts::available_lists();\n            my $lists_exist     = $#available_lists + 1;\n\n            my $list_popup_menu = DADA::Template::Widgets::list_popup_menu(\n                -show_hidden         => 1,\n                -name                => 'clone_settings_from_this_list',\n                -empty_list_check    => 1,\n                -show_list_shortname => 1,\n            );\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'new_list_screen.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        errors                   => $errors,\n                        ending                   => $ending,\n                        err_word                 => $err_word,\n                        help                     => $help,\n                        root_password            => $root_password,\n                        flags_list_name          => $flags->{list_name},\n                        list_name                => $list_name,\n                        flags_list_exists        => $flags->{list_exists},\n                        flags_list               => $flags->{list},\n                        flags_shortname_too_long =>\n                          $flags->{shortname_too_long},\n                        flags_slashes_in_name  => $flags->{slashes_in_name},\n                        flags_weird_characters => $flags->{weird_characters},\n                        flags_quotes           => $flags->{quotes},\n                        list                   => $list,\n                        flags_password         => $flags->{password},\n                        password               => $password,\n\n                        flags_password_is_root_password =>\n                          $flags->{password_is_root_password},\n\n                        flags_retype_password => $flags->{retype_password},\n                        flags_password_ne_retype_password =>\n                          $flags->{password_ne_retype_password},\n                        retype_password                => $retype_password,\n                        flags_invalid_list_owner_email =>\n                          $flags->{invalid_list_owner_email},\n                        list_owner_email     => $list_owner_email,\n                        flags_list_info      => $flags->{list_info},\n                        info                 => $info,\n                        flags_privacy_policy => $flags->{privacy_policy},\n                        privacy_policy       => $privacy_policy,\n\n                        consent       => $consent,\n                        flags_consent => $flags->{consent},\n\n                        flags_physical_address => $flags->{physical_address},\n                        physical_address       => $physical_address,\n                        flags_list_name_bad_characters =>\n                          $flags->{list_name_bad_characters},\n\n                        lists_exist     => $lists_exist,\n                        list_popup_menu => $list_popup_menu,\n                        auth_state      => $sast->make_state,\n\n                    },\n                }\n            );\n\n            if ($errors) {\n\n# This fills in the advanced options form fields. Above also fills in other fields just\n# by setting the vars in via HTML::Template - so we have a mix of two techniques.\n# If there is another pass to this, it's probably best to consilidate on the below technique.\n\n                require CGI;\n                my $fif_q = CGI->new;\n                $fif_q->charset($DADA::Config::HTML_CHARSET);\n                $fif_q->delete_all;\n\n                $fif_q->param( 'clone_settings',\n                    scalar $q->param('clone_settings') );\n                $fif_q->param( 'clone_settings_from_this_list',\n                    scalar $q->param('clone_settings_from_this_list') );\n                $fif_q->param(\n                    'send_new_list_welcome_email',\n                    $send_new_list_welcome_email\n                );\n                $fif_q->param(\n                    'send_new_list_welcome_email_with_list_pass',\n                    $send_new_list_welcome_email_with_list_pass\n                );\n\n                require HTML::FillInForm::Lite;\n                my $h = HTML::FillInForm::Lite->new();\n                $scrn = $h->fill( \\$scrn, $fif_q );\n            }\n\n            return $scrn;\n\n        }\n        else {\n            require DADA::Template::Widgets;\n            return DADA::Template::Widgets::admin(\n                {\n                    -cgi_obj => $q,\n                    -vars    => {\n                        errors     => [ { error => 'invalid_root_password' } ],\n                        error_with => 'new_list',\n                    }\n                }\n            );\n\n        }\n    }\n    else {\n        chomp($list);\n        $list =~ s/^\\s+//;\n        $list =~ s/\\s+$//;\n\n        # $list =~ s/ /_/g; # What?\n\n        my $list_exists = check_if_list_exists( -List => $list );\n        my ( $list_errors, $flags ) = check_list_setup(\n            -fields => {\n                list             => $list,\n                list_name        => $list_name,\n                list_owner_email => $list_owner_email,\n                password         => $password,\n                retype_password  => $retype_password,\n                info             => $info,\n                privacy_policy   => $privacy_policy,\n                physical_address => $physical_address,\n                consent          => $consent,\n            }\n        );\n\n        if ( $list_errors >= 1 ) {\n            undef($process);\n            $q->delete('process');\n\n            $self->new_list( $list_errors, $flags );\n\n        }\n        elsif ( $list_exists >= 1 ) {\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => \"list_already_exists\"\n                }\n            );\n        }\n        else {\n\n            $list_owner_email = lc_email($list_owner_email);\n\n            my $new_info = {\n\n                #\tlist             =>   $list,\n                list_owner_email => $list_owner_email,\n                list_name        => $list_name,\n                password         => $password,\n                info             => $info,\n                physical_address => $physical_address,\n                privacy_policy   => $privacy_policy,\n                consent          => $consent,\n\n            };\n\n            require DADA::MailingList;\n            my $ls;\n            if ( $q->param('clone_settings') == 1 ) {\n                $ls = DADA::MailingList::Create(\n                    {\n                        -list     => $list,\n                        -settings => $new_info,\n                        -clone    => xss_filter(\n                            scalar $q->param('clone_settings_from_this_list')\n                        ),\n                    }\n                );\n            }\n            else {\n                $ls = DADA::MailingList::Create(\n                    {\n                        -list     => $list,\n                        -settings => $new_info,\n                    }\n                );\n            }\n\n            my $status;\n\n            if ( $DADA::Config::LOG{list_lives} ) {\n                require DADA::Logging::Usage;\n                my $log = new DADA::Logging::Usage;\n                $log->mj_log(\n                    $list,\n                    'List Created',\n                    \"remote_host:$ENV{REMOTE_HOST},\"\n                      . \"ip_address:$ENV{REMOTE_ADDR}\"\n                );\n            }\n\n            my $escaped_list = uriescape( $ls->param('list') );\n\n            my $auth_state;\n\n            if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n                require DADA::Security::SimpleAuthStringState;\n                my $sast = DADA::Security::SimpleAuthStringState->new;\n                $auth_state = $sast->make_state;\n            }\n\n            if ( $q->param('send_new_list_welcome_email') == 1 ) {\n                try {\n                    require DADA::App::Messages;\n                    my $dap = DADA::App::Messages->new(\n                        {\n                            -list => $ls->param('list'),\n                        }\n                    );\n\n                    # seems dumb to be passing this around, if we don't need to:\n                    my $send_new_list_created_notification_vars = {};\n\n                    if ( $send_new_list_welcome_email_with_list_pass == 1 ) {\n                        $send_new_list_created_notification_vars = {\n                            send_new_list_welcome_email_with_list_pass => 1,\n                            list_password => $password,\n                        };\n                    }\n                    else {\n                        $send_new_list_created_notification_vars = {\n                            send_new_list_welcome_email_with_list_pass => 0,\n                            list_password                              => undef,\n                        };\n                    }\n\n                    $dap->send_new_list_created_notification(\n                        {\n                            -vars => $send_new_list_created_notification_vars\n                        }\n                    );\n                }\n                catch {\n                    warn 'problems sending send_new_list_created_notification: '\n                      . $_;\n                };\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'new_list_created_screen.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n\n                        login_widget  => 'hidden_field',\n                        selected_list => $ls->param('list'),\n                        auth_state    => $auth_state,\n\n                        list_name        => $ls->param('list_name'),\n                        list             => $ls->param('list'),\n                        escaped_list     => $escaped_list,\n                        list_owner_email => $ls->param('list_owner_email'),\n                        info             => $ls->param('info'),\n                        privacy_policy   => $ls->param('privacy_policy'),\n                        physical_address => $ls->param('physical_address'),\n                    },\n                }\n            );\n            return $scrn;\n\n        }\n    }\n}\n\n\nsub list_archive {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    # are we dealing with a real list?\n    my $list_exists = check_if_list_exists( -List => $list, );\n\n    if ( $list_exists == 0 ) {\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL );\n\t\treturn;\n\n    }\n\n    my $id = $q->param('id') || undef;\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -from_session => 1 } );\n    my $allowed_to_view_archives = 1;\n    if ($prof) {\n        $allowed_to_view_archives =\n          $prof->allowed_to_view_archives( { -list => $list, } );\n    }\n    if ( $allowed_to_view_archives == 0 ) {\n        return user_error(\n            { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n    }\n\n    my $start = int( $q->param('start') ) || 0;\n\n    if ( $ls->param('show_archives') == 0 ) {\n        return user_error( { -list => $list, -error => \"no_show_archives\" } );\n    }\n\n    require DADA::MailingList::Archives;\n\n    my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n    my $entries = $archive->get_archive_entries();\n\n###### These are all little thingies.\n\n    my $archive_send_form = '';\n    $archive_send_form = DADA::Template::Widgets::archive_send_form(\n        $list,\n        $id,\n        xss_filter( scalar $q->param('send_archive_errors') ),\n        $ls->param('captcha_archive_send_form'),\n        xss_filter( scalar $q->param('captcha_fail') )\n    ) if $ls->param('archive_send_form') == 1 && defined($id);\n\n    my $nav_table = '';\n    $nav_table =\n      $archive->make_nav_table( -Id => $id, -List => $ls->param('list') )\n      if defined($id);\n\n    my $archive_subscribe_form = \"\";\n\n    if ( $ls->param('hide_list') ne \"1\" ) {\n\n        # DEV: This takes the cake for worst hack I have found... today.\n        my $info = '<!-- tmpl_var list_settings.info -->';\n        $info = DADA::Template::Widgets::screen(\n            {\n                -data                     => \\$info,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [qw(list_settings.info)],\n            }\n        );\n\n        unless ( $ls->param('archive_subscribe_form') eq \"0\" ) {\n\n            $archive_subscribe_form =\n              DADA::Template::Widgets::subscription_form(\n                {\n                    -list       => $ls->param('list'),\n                    -email      => $email,\n                }\n              );\n        }\n    }\n\n    my $archive_widgets = {\n        archive_send_form    => $archive_send_form,\n        nav_table            => $nav_table,\n        publish_archives_rss => $ls->param('publish_archives_rss') ? 1 : 0,\n        subscription_form    => $archive_subscribe_form,\n    };\n\n    #/##### These are all little thingies.\n\n    if ( !$id ) {\n\n        if (  !$c->profile_on\n            && $c->is_cached( 'archive/' . $list . '/' . $start . '.scrn' ) )\n        {\n            return $c->cached( 'archive/' . $list . '/' . $start . '.scrn' );\n\n        }\n\n        my $th_entries = [];\n\n        my ( $begin, $stop ) = $archive->create_index($start);\n        my $i;\n        my $stopped_at = $begin;\n        my $num        = $begin;\n\n        $num++;\n        my @archive_nums;\n        my @archive_links;\n\n        # iterate and save\n        for ( $i = $begin ; $i <= $stop ; $i++ ) {\n            my $link;\n\n            if ( defined( $entries->[$i] ) ) {\n\n                my ( $subject, $message, $format, $raw_msg ) =\n                  $archive->get_archive_info( $entries->[$i] );\n\n                # DEV: This is stupid, and I don't think it's a great idea.\n                # $subject = safely_decode($subject);\n                $subject = DADA::Template::Widgets::screen(\n                    {\n                        -data                     => \\$subject,\n                        -vars                     => $ls->get,\n                        -list_settings_vars       => $ls->get,\n                        -list_settings_vars_param => { -dot_it => 1 },\n                        -subscriber_vars_param =>\n                          { -use_fallback_vars => 1, -list => $list },\n                    },\n\n                );\n\n                # this is so atrocious.\n                my $date = date_this(\n                    -Packed_Date => $archive->_massaged_key( $entries->[$i] ),\n                    -Write_Month => $ls->param('archive_show_month'),\n                    -Write_Day   => $ls->param('archive_show_day'),\n                    -Write_Year  => $ls->param('archive_show_year'),\n                    -Write_H_And_M =>\n                      $ls->param('archive_show_hour_and_minute'),\n                    -Write_Second => $ls->param('archive_show_second'),\n                );\n                my $header_from      = undef;\n                my $orig_header_from = undef;\n\n                if ($raw_msg) {\n                    $header_from = $archive->get_header(\n                        -header => 'From',\n                        -key    => $entries->[$i]\n                    );\n                    $orig_header_from = $header_from;\n                }\n\n                my $can_use_gravatar_url = 1;\n                my $gravatar_img_url     = undef;\n                my $show_gravatar        = 0;\n\n                if ( $ls->param('enable_gravatars') ) {\n\n                    try {\n                        require Gravatar::URL\n                    }\n                    catch {\n                        $can_use_gravatar_url = 0;\n                    };\n\n                    if ( $can_use_gravatar_url == 1 ) {\n                        my $header_address = $archive->sender_address(\n                            {\n                                -id => $entries->[$i],\n                            }\n                        );\n                        $gravatar_img_url = gravatar_img_url(\n                            {\n                                -email => $header_address,\n                                -default_gravatar_url =>\n                                  $ls->param('default_gravatar_url'),\n                            }\n                        );\n\n                    }\n                    else {\n                        $can_use_gravatar_url = 0;\n                    }\n                    if (   $ls->param('enable_gravatars') == 1\n                        && $can_use_gravatar_url == 1\n                        && defined(gravatar_img_url) )\n                    {\n                        $show_gravatar = 1;\n                    }\n\n                }\n\n                my $entry = {\n                    id               => $entries->[$i],\n                    date             => $date,\n                    subject          => $subject,\n                    'format'         => $format,\n                    list             => $list,\n                    uri_escaped_list => uriescape($list),\n                    PROGRAM_URL      => $DADA::Config::PROGRAM_URL,\n                    message_blurb =>\n                      $archive->message_blurb( -key => $entries->[$i] ),\n                    show_gravatar        => $show_gravatar,\n                    can_use_gravatar_url => $can_use_gravatar_url,\n                    gravatar_img_url     => $gravatar_img_url,\n\n                };\n\n                $stopped_at++;\n                push( @archive_nums,  $num );\n                push( @archive_links, $link );\n                $num++;\n\n                push( @$th_entries, $entry );\n\n            }\n        }\n\n        my $ii;\n        for ( $ii = 0 ; $ii <= $#archive_links ; $ii++ ) {\n\n            my $bullet = $archive_nums[$ii];\n\n            #fix if we're doing reverse chronologic\n            $bullet = ( ( $#{$entries} + 1 ) - ( $archive_nums[$ii] ) + 1 )\n              if ( $ls->param('sort_archives_in_reverse') == 1 );\n\n            # yeah, whatever.\n            $th_entries->[$ii]->{bullet} = $bullet;\n\n        }\n\n        my $index_nav = $archive->create_index_nav($stopped_at);\n\n        require DADA::Profile;\n        my $prof = DADA::Profile->new( { -from_session => 1 } );\n        my $allowed_to_view_archives = 1;\n        if ($prof) {\n            $allowed_to_view_archives =\n              $prof->allowed_to_view_archives( { -list => $list, } );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'list_archive_index_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    list                     => $list,\n                    list_name                => $ls->param('list_name'),\n                    entries                  => $th_entries,\n                    index_nav                => $index_nav,\n                    flavor_archive           => 1,\n                    allowed_to_view_archives => $allowed_to_view_archives,\n                    publish_archives_rss => $ls->param('publish_archives_rss')\n                    ? 1\n                    : 0,\n\n                    %$archive_widgets,\n\n                },\n\n                -list_settings_vars       => $ls->get,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [\n                    qw(list_settings.discussion_pop_email list_settings.list_owner_email list_settings.info list_settings.privacy_policy )\n                ],\n\n            }\n        );\n        if ( !$c->profile_on ) {\n            $c->cache( 'archive/' . $list . '/' . $start . '.scrn', \\$scrn );\n        }\n        return $scrn;\n\n    }\n    else {    # There's an id...\n\n\t\n        $id = $archive->newest_entry if $id =~ /newest/i;\n        $id = $archive->oldest_entry if $id =~ /oldest/i;\n\t\t\n\t\tif($id eq 'PREVIEW_MESSAGE_ID'){ \t\t\t\n\t\t\t\n\t\t    my $scrn = DADA::Template::Widgets::wrap_screen(\n\t\t        {\n\t\t            -screen => 'archive_screen_preview_placeholder.tmpl',\n\t\t            -with   => 'list',\n\t\t            -vars   => {},\n\t\t            -list_settings_vars_param => {\n\t\t                -list   => $list,\n\t\t                -dot_it => 1,\n\t\t            },\n\t\t        }\n\t\t    );\n\t\t\treturn $scrn;\n\t\t}\n\n\n        if ( $q->param('extran') ) {\n\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::PROGRAM_URL\n                  . '/archive/'\n                  . $ls->param('list') . '/'\n                  . $id\n                  . '/' );\n        }\n\n        if ( $id !~ m/(\\d+)/g ) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::PROGRAM_URL\n                  . '/archive/'\n                  . $ls->param('list')\n                  . '/' );\n        }\n\n        $id = $archive->_massaged_key($id);\n\n        if (   $ls->param('archive_send_form') != 1\n            && $ls->param('captcha_archive_send_form') != 1 )\n        {\n\n            if (  !$c->profile_on\n                && $c->is_cached( 'archive/' . $list . '/' . $id . '.scrn' ) )\n            {\n                require DADA::Logging::Clickthrough;\n                my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n                $r->view_archive_log( { -mid => $id, } );\n                return $c->cached( 'archive/' . $list . '/' . $id . '.scrn' );\n            }\n        }\n\n        my $entry_exists = $archive->check_if_entry_exists($id);\n        if ( $entry_exists <= 0 ) {\n            return user_error(\n                { -list => $list, -error => \"no_archive_entry\" } );\n        }\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $archive->get_archive_info($id);\n\n        # DEV: This is stupid, and I don't think it's a great idea.\n        $subject = $archive->_parse_in_list_info( -data => $subject );\n\n        # That. Sucked.\n\n        my ( $massaged_message_for_display, $content_type ) =\n          $archive->massaged_msg_for_display(\n            { -key => $id, -body_only => 1 } );\n\n        my $show_iframe = $ls->param('html_archives_in_iframe') || 0;\n        if ( $content_type eq 'text/plain' ) {\n            $show_iframe = 0;\n        }\n\n        my $header_from      = undef;\n        my $orig_header_from = undef;\n\n        #my $header_date    = undef;\n        my $header_subject = undef;\n\n        my $in_reply_to_id;\n        my $in_reply_to_subject;\n\n        if ($raw_msg) {\n            $header_from =\n              $archive->get_header( -header => 'From', -key => $id );\n            $orig_header_from = $header_from;\n\n            # DEV: This logic should not be here...\n\n            # DEV: This is stupid, and I don't think it's a great idea.\n            $header_from =\n              $archive->_parse_in_list_info( -data => $header_from );\n\n\t\t\tif ( $ls->param('archive_protect_email') eq 'break' ) {\n                $header_from = encode_html_entities( break_encode($header_from),\n                    , \"\\200-\\377\" );\n            }\n            elsif ( $ls->param('archive_protect_email') eq 'spam_me_not' ) {\n                $header_from = spam_me_not_encode($header_from);\n            }\n            else {\n                $header_from = xss_filter( encode_html_entities($header_from),,\n                    \"\\200-\\377\" );\n            }\n\n            $header_subject =\n              $archive->get_header( -header => 'Subject', -key => $id );\n\n            $header_subject =~ s/\\r|\\n/ /g;\n            if ( !$header_subject ) {\n                $header_subject = $DADA::Config::EMAIL_HEADERS{Subject};\n            }\n\n            ( $in_reply_to_id, $in_reply_to_subject ) =\n              $archive->in_reply_to_info( -key => $id );\n\n            # DEV: This is stupid, and I don't think it's a great idea.\n            $header_subject =\n              $archive->_parse_in_list_info( -data => $header_subject );\n            $in_reply_to_subject =\n              $archive->_parse_in_list_info( -data => $in_reply_to_subject );\n\n            # That. Sucked.\n            $header_subject      = $header_subject;\n            $in_reply_to_subject = $in_reply_to_subject;\n\n        }\n\n        my $attachments =\n          ( $ls->param('display_attachments') == 1 )\n          ? $archive->attachment_list($id)\n          : [];\n\n        # this is so atrocious.\n        my $date = date_this(\n            -Packed_Date   => $id,\n            -Write_Month   => $ls->param('archive_show_month'),\n            -Write_Day     => $ls->param('archive_show_day'),\n            -Write_Year    => $ls->param('archive_show_year'),\n            -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n            -Write_Second  => $ls->param('archive_show_second'),\n        );\n\n        my $show_gravatar        = 0;\n        my $gravatar_img_url     = undef;\n        my $can_use_gravatar_url = 1;\n\n        if ( $ls->param('enable_gravatars') ) {\n            try {\n                require Gravatar::URL\n            }\n            catch {\n                $can_use_gravatar_url = 0;\n            };\n            if ( $can_use_gravatar_url == 1 ) {\n                my $header_address = $archive->sender_address(\n                    {\n                        -id => $id,\n                    }\n                );\n                $gravatar_img_url = gravatar_img_url(\n                    {\n                        -email => $header_address,\n                        -default_gravatar_url =>\n                          $ls->param('default_gravatar_url'),\n                    }\n                );\n            }\n            else {\n                $can_use_gravatar_url = 0;\n            }\n        }\n        if (   $ls->param('enable_gravatars') == 1\n            && $can_use_gravatar_url == 1\n            && defined(gravatar_img_url) )\n        {\n            $show_gravatar = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'list_archive_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    list      => $list,\n                    list_name => $ls->param('list_name'),\n                    id        => $id,\n\n                    # DEV. OK - riddle ME why there's two of these...\n                    header_subject => $header_subject,\n                    subject        => $subject,\n\n                    js_enc_subject      => js_enc($header_subject),\n                    uri_encoded_subject => uriescape($header_subject),\n                    uri_encoded_url     => uriescape(\n                            $DADA::Config::PROGRAM_URL\n                          . '/archive/'\n                          . $list . '/'\n                          . $id . '/'\n                    ),\n                    archived_msg_url => $DADA::Config::PROGRAM_NAME\n                      . '/archive/'\n                      . $list . '/'\n                      . $id . '/',\n                    massaged_msg_for_display => $massaged_message_for_display,\n                    send_archive_success =>\n                      scalar $q->param('send_archive_success')\n                    ? $q->param('send_archive_success')\n                    : undef,\n                    send_archive_errors =>\n                      scalar $q->param('send_archive_errors')\n                    ? $q->param('send_archive_errors')\n                    : undef,\n                    show_iframe     => $show_iframe,\n                    discussion_list => ( $ls->param('group_list') == 1 ) ? 1\n                    : 0,\n\n                    header_from         => $header_from,\n                    in_reply_to_id      => $in_reply_to_id,\n                    in_reply_to_subject => xss_filter($in_reply_to_subject),\n                    attachments         => $attachments,\n                    date                => $date,\n                    add_social_bookmarking_badges =>\n                      $ls->param('add_social_bookmarking_badges'),\n                    show_gravatar        => $show_gravatar,\n                    can_use_gravatar_url => $can_use_gravatar_url,\n                    gravatar_img_url     => $gravatar_img_url,\n                    %$archive_widgets,\n\n                },\n                -list_settings_vars       => $ls->get,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [\n                    qw(list_settings.discussion_pop_email list_settings.list_owner_email list_settings.info list_settings.privacy_policy )\n                ],\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n            }\n        );\n\n        require DADA::Logging::Clickthrough;\n        my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n        $r->view_archive_log( { -mid => $id, } );\n        if (  !$c->profile_on\n            && $ls->param('archive_send_form') != 1\n            && $ls->param('captcha_archive_send_form') != 1 )\n        {\n            $c->cache( 'archive/' . $list . '/' . $id . '.scrn', \\$scrn );\n\n        }\n        return $scrn;\n    }\n\n}\n\nsub archive_bare {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $list = $q->param('list');\n\n    if ( $q->param('admin') ) {\n        my ( $admin_list, $root_login, $checksout, $error_msg ) =\n          check_list_security(\n            -cgi_obj  => $q,\n            -Function => 'view_archive'\n          );\n        if ( !$checksout ) { return $error_msg; }\n        $list = $admin_list;\n    }\n\n    my $id = $q->param('id') || undef;\n\n    if (\n        $c->is_cached(\n                'archive_bare.'\n              . $list . '.'\n              . $id . '.'\n              . scalar( $q->param('admin') ) . '.scrn'\n        )\n      )\n    {\n        return $c->cached( 'archive_bare.'\n              . $list . '.'\n              . $id . '.'\n              . scalar( $q->param('admin') )\n              . '.scrn' );\n    }\n\n    require DADA::MailingList::Archives;\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n    my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n    if ( !$q->param('admin') ) {\n        if ( $ls->param('show_archives') == 0 ) {\n            return user_error(\n                { -list => $list, -error => \"no_show_archives\" } );\n        }\n        require DADA::Profile;\n        my $prof = DADA::Profile->new( { -from_session => 1 } );\n        my $allowed_to_view_archives = 1;\n        if ($prof) {\n            $allowed_to_view_archives =\n              $prof->allowed_to_view_archives( { -list => $list, } );\n        }\n\n        if ( $allowed_to_view_archives == 0 ) {\n            return user_error(\n                { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n        }\n    }\n    if ( $la->check_if_entry_exists($id) <= 0 ) {\n        return user_error( { -list => $list, -error => \"no_archive_entry\" } );\n    }\n\n    my $scrn = $la->massaged_msg_for_display( { -key => $id } );\n    $c->cache(\n        'archive_bare.'\n          . $list . '.'\n          . $id . '.'\n          . scalar( $q->param('admin') ) . '.scrn',\n        \\$scrn\n    );\n    return $scrn;\n\n}\n\nsub search_archive {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $list  = $q->param('list');\n    my $email = $q->param('email');\n\n    if ( check_if_list_exists( -List => $list ) <= 0 ) {\n        return user_error( { -list => $list, -error => \"no_list\" } );\n    }\n\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( $ls->param('show_archives') == 0 ) {\n        return user_error( { -list => $list, -error => \"no_show_archives\" } );\n    }\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -from_session => 1 } );\n    my $allowed_to_view_archives = 1;\n    if ($prof) {\n        $allowed_to_view_archives =\n          $prof->allowed_to_view_archives( { -list => $list, } );\n    }\n\n    if ( $allowed_to_view_archives == 0 ) {\n        return user_error(\n            { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n    }\n\n    my $keyword = $q->param('keyword');\n    $keyword = xss_filter($keyword);\n\n    if ( $keyword =~ m/^[A-Za-z]+$/ ) {    # just words, basically.\n        if (  !$c->profile_on\n            && $c->is_cached( $list . '.search_archive.' . $keyword . '.scrn' )\n          )\n        {\n            return $c->cached(\n                $list . '.search_archive.' . $keyword . '.scrn' );\n        }\n    }\n\n    require DADA::MailingList::Archives;\n\n    my $archive      = DADA::MailingList::Archives->new( { -list => $list } );\n    my $entries      = $archive->get_archive_entries();\n    my $ending       = \"\";\n    my $count        = 0;\n    my $ht_summaries = [];\n\n    my $search_results = $archive->search_entries($keyword);\n\n    if ( exists( $search_results->[0] ) && ( @$search_results[0] ne \"\" ) ) {\n\n        $count  = $#{$search_results} + 1;\n        $ending = 's'\n          if exists( $search_results->[1] );\n\n        my $summaries =\n          $archive->make_search_summary( $keyword, $search_results );\n\n        for (@$search_results) {\n\n            my ( $subject, $message, $format ) = $archive->get_archive_info($_);\n            my $date = date_this(\n                -Packed_Date   => $_,\n                -Write_Month   => $ls->param('archive_show_month'),\n                -Write_Day     => $ls->param('archive_show_day'),\n                -Write_Year    => $ls->param('archive_show_year'),\n                -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n                -Write_Second  => $ls->param('archive_show_second'),\n            );\n\n            push(\n                @$ht_summaries,\n                {\n                    summary => $summaries->{$_},\n                    subject =>\n                      $archive->_parse_in_list_info( -data => $subject ),\n                    date        => $date,\n                    id          => $_,\n                    PROGRAM_URL => $DADA::Config::PROGRAM_URL,\n                    list        => uriescape($list),\n                }\n            );\n\n        }\n    }\n\n    my $archive_subscribe_form = '';\n    if ( $ls->param('hide_list') ne \"1\" ) {\n\n        # DEV: This takes the cake for worst hack I have found... today.\n        my $info = '<!-- tmpl_var list_settings.info -->';\n        $info = DADA::Template::Widgets::screen(\n            {\n                -data                     => \\$info,\n                -list_settings_vars_param => { -list => $list, -dot_it => 1 },\n                -webify_and_santize_these => [qw(list_settings.info)],\n            }\n        );\n\n        unless ( $ls->param('archive_subscribe_form') == 0 ) {\n            $archive_subscribe_form =\n              DADA::Template::Widgets::subscription_form(\n                {\n                    -list       => $ls->param('list'),\n                    -email      => $email,\n                }\n              );\n        }\n\n    }\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen => 'search_archive_screen.tmpl',\n            -with   => 'list',\n            -vars   => {\n                list_name         => $ls->param('list_name'),\n                uriescape_list    => uriescape($list),\n                list              => $list,\n                count             => $count,\n                ending            => $ending,\n                keyword           => $keyword,\n                summaries         => $ht_summaries,\n                search_results    => $ht_summaries->[0] ? 1 : 0,\n                subscription_form => $archive_subscribe_form,\n            },\n            -list_settings_vars_param => {\n                -list   => $list,\n                -dot_it => 1,\n            },\n        }\n    );\n\n    if ( !$c->profile_on && $keyword =~ m/^[A-Za-z]+$/ )\n    {    # just words, basically.\n        $c->cache( $list . '.search_archive.' . $keyword . '.scrn', \\$scrn );\n    }\n    return $scrn;\n\n}\n\nsub send_archive {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $entry      = xss_filter( scalar $q->param('entry') );\n    my $from_email = xss_filter( scalar $q->param('from_email') );\n    my $to_email   = xss_filter( scalar $q->param('to_email') );\n    my $note       = xss_filter( scalar $q->param('note') );\n    my $list       = $q->param('list');\n\n\n\t# We're not going to accept GET requests:\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->default();\n\t}\n\n    my $errors = 0;\n\n    my $list_exists = check_if_list_exists( -List => $list );\n\n    if ( $list_exists <= 0 ) {\n        return user_error( { -list => $list, -error => \"no_list\" } );\n    }\n\n    if ( check_for_valid_email($to_email) == 1 ) {\n        $errors++;\n    }\n\n    if ( check_for_valid_email($from_email) == 1 ) {\n        $errors++;\n    }\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -from_session => 1 } );\n    my $allowed_to_view_archives = 1;\n    if ($prof) {\n        $allowed_to_view_archives =\n          $prof->allowed_to_view_archives( { -list => $list, } );\n    }\n\n    if ( $allowed_to_view_archives == 0 ) {\n        return user_error(\n            { -list => $list, -error => \"not_allowed_to_view_archives\" } );\n    }\n\n    # CAPTCHA STUFF\n\n    my $captcha_fail    = 0;\n    my $can_use_captcha = can_use_Google_reCAPTCHA();\n    if ( \n\t\t   $ls->param('captcha_archive_send_form') == 1 \n\t\t&& $can_use_captcha == 1 \n\t) {\n\n        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t{\n\t\t\t\t -response    => $crf, \n\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t}\n\t\t);\n\n        if ( $captcha_status != 1 ) {\n            $errors++;\n            $captcha_fail = 1;\n        }        \n    }\n\n    if ( $ls->param('archive_send_form') != 1 ) {\n        $errors++;\n    }\n\n    if ( $errors > 0 ) {\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL\n              . '?flavor=archive&list='\n              . $list . '&id='\n              . $entry\n              . '&send_archive_errors='\n              . $errors\n              . '&captcha_fail='\n              . $captcha_fail );\n\n    }\n    else {\n\n        require DADA::MailingList::Archives;\n\n        my $archive = DADA::MailingList::Archives->new( { -list => $list } );\n\n        if ( $entry =~ /newest/i ) {\n            $entry = $archive->newest_entry;\n        }\n        elsif ( $entry =~ /oldest/i ) {\n            $entry = $archive->oldest_entry;\n        }\n\n        my $archive_message_url =\n          $DADA::Config::PROGRAM_URL . '/archive/' . $list . '/' . $entry . '/';\n\n        my ( $subject, $message, $format, $raw_msg ) =\n          $archive->get_archive_info($entry);\n        chomp($subject);\n\n        # DEV: This is stupid, and I don't think it's a great idea.\n        $subject = $archive->_parse_in_list_info( -data => $subject );\n        ### /\n\t\t\n\t\trequire DADA::App::EmailThemes; \n\t\tmy $em = DADA::App::EmailThemes->new(\n\t\t\t{ \n\t\t\t\t-list      => $list,\n\t\t\t}\n\t\t);\n\t\tmy $etp = $em->fetch('send_archive_message');\n\t\t\n        require DADA::App::FormatMessages;\n        my $fm = DADA::App::FormatMessages->new( -List => $list );\n\t\t\n        require MIME::Entity;\n\n        # DEV: This should really be moved to DADA::App::Messages...\n        my $msg = MIME::Entity->build(\n            From => $fm->format_phrase_address(\n\t\t\t\t$etp->{vars}->{from_phrase}, \n\t\t\t\t$ls->param('list_owner_email'),\n\t\t\t), \n            To => $fm->format_phrase_address(\n\t\t\t\t$etp->{vars}->{to_phrase}, \n\t\t\t\t$to_email\n\t\t\t),\t\n            Subject => $etp->{vars}->{subject},\n            Type    => 'multipart/mixed',\n        );\n\n        my $pt = MIME::Entity->build(\n            Type     => 'text/plain',\n            Data     => $etp->{plaintext},\n            Encoding => $ls->param('plaintext_encoding')\n        );\n\n        my $html = MIME::Entity->build(\n            Type     => 'text/html',\n            Data     => $etp->{html},\n            Encoding => $ls->param('html_encoding'),\n        );\n\t\t\n        my $ma = MIME::Entity->build(\n\t\t\tType => 'multipart/alternative'\n\t\t);\n        $ma->add_part($pt);\n        $ma->add_part($html);\n\n        $msg->add_part($ma);\n\n        my $a_msg;\n\n        #... sort of weird.\n        if ($raw_msg) {\n\n            $a_msg = MIME::Entity->build(\n                Type        => 'message/rfc822',\n                Disposition => \"inline\",\n                Data => $archive->massage_msg_for_resending( -key => $entry ),\n            );\n\n        }\n        else {\n\n            $a_msg = MIME::Entity->build(\n                Type        => 'message/rfc822',\n                Disposition => \"inline\",\n                Type        => $format,\n                Data        => $message\n            );\n        }\n\n        $msg->add_part($a_msg);\n\n        require DADA::App::FormatMessages;\n        my $fm = DADA::App::FormatMessages->new( -List => $list );\n        $fm->use_email_templates(0);\n        $fm->use_header_info(1);\n\n        $msg = $fm->format_message(\n            {\n                -entity => $msg,\n            }\n        );\n\n        my ( $e_name, $e_domain ) = split( '@', $to_email, 2 );\n        my $entity = $fm->email_template(\n            {\n                -entity => $msg,\n                -list_settings_vars_param => { -list => $list, },\n                -vars                     => {\n                    from_email                => $from_email,\n                    to_email                  => $to_email,\n                    note                      => $note,\n                    archive_message_url       => $archive_message_url,\n                    archived_message_subject  => $subject,\n                    'subscriber.email_name'   => $e_name,\n                    'subscriber.email_domain' => $e_domain,\n                },\n            }\n        );\n\t\tundef($msg);\n        my $n_msg = safely_decode( $entity->as_string );\n        my ( $header_str, $body_str ) = split( \"\\n\\n\", $n_msg, 2 );\n\n        require DADA::Mail::Send;\n        my $mh = DADA::Mail::Send->new(\n            {\n                -list   => $list,\n                -ls_obj => $ls,\n            }\n        );\n\n        $mh->send( $mh->return_headers($header_str), Body => $body_str, );\n\n        require DADA::Logging::Clickthrough;\n        my $r = DADA::Logging::Clickthrough->new( { -list => $list } );\n        $r->forward_to_a_friend_log( { -mid => $entry, } );\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL\n              . '?flavor=archive&list='\n              . $list . '&id='\n              . $entry\n              . '&send_archive_success=1' );\n\n    }\n}\n\nsub archive_rss {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my %args = (\n        -type => 'rss',\n        @_\n    );\n    my $list = $q->param('list');\n\n    my $list_exists = check_if_list_exists( -List => $list );\n\n    if ( $list_exists == 0 ) {\n\n    }\n    else {\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        if ( $ls->param('show_archives') == 0 ) {\n\n        }\n        else {\n\n            require DADA::Profile;\n            my $prof = DADA::Profile->new( { -from_session => 1 } );\n            my $allowed_to_view_archives = 1;\n            if ($prof) {\n                $allowed_to_view_archives =\n                  $prof->allowed_to_view_archives( { -list => $list, } );\n            }\n\n            if ( $allowed_to_view_archives == 0 ) {\n                return '';\n            }\n\n            if ( $ls->param('publish_archives_rss') == 0 ) {\n\n            }\n            else {\n\n                if ( $args{-type} eq 'rss' ) {\n\n                    if ( $c->is_cached( 'archive_rss/' . $list ) ) {\n                        return $c->cached( 'archive_rss/' . $list . '.scrn' );\n                    }\n                    require DADA::MailingList::Archives;\n                    my $archive =\n                      DADA::MailingList::Archives->new( { -list => $list } );\n                    my $scrn = $archive->rss_index();\n                    $c->cache( 'archive_rss/' . $list . '.scrn', \\$scrn );\n                    my $headers = { -type => 'application/xml' };\n\n                    $self->header_props(%$headers);\n                    return $scrn;\n\n                }\n                elsif ( $args{-type} eq 'atom' ) {\n                    if ( $c->is_cached( 'archive_atom/' . $list ) ) {\n                        return $c->cached( 'archive_atom/' . $list . '.scrn' );\n                    }\n                    else {\n                        require DADA::MailingList::Archives;\n                        my $archive = DADA::MailingList::Archives->new(\n                            { -list => $list } );\n                        my $scrn = $archive->atom_index();\n                        $c->cache( 'archive_atom/' . $list . '.scrn', \\$scrn );\n                        my $headers = { -type => 'application/xml' };\n                        $self->header_props(%$headers);\n                        return $scrn;\n                    }\n                }\n                else {\n                    warn \"wrong type of feed asked for: \"\n                      . $args{-type} . ' - '\n                      . $!;\n                }\n            }\n        }\n    }\n}\n\nsub archive_atom {\n\n    my $self = shift;\n    my $q    = $self->query();\n    return $self->archive_rss( -type => 'atom' );\n}\n\n\n\n\n\n\nsub email_password { \n    my $self = shift;\n    my $q    = $self->query();\n\t\t\n\tif($q->request_method() =~ m/POST/i){\n\t\treturn $self->post_email_password(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_email_password.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\tlist         => $q->param('list'),\n\t\t\t\t\tpass_auth_id => $q->param('pass_auth_id'),\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n\n}\n\n\n\n\nsub post_email_password {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $list = $q->param('list');\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    require DADA::Security::Password;\n   # warn q{$q->param('pass_auth_id')} . $q->param('pass_auth_id');\n   # warn q{$ls->param('pass_auth_id')} . $ls->param('pass_auth_id');\n\n    if (   ( $ls->param('pass_auth_id') ne \"\" )\n        && ( defined( $ls->param('pass_auth_id') ) )\n        && ( $q->param('pass_auth_id') eq $ls->param('pass_auth_id') ) )\n    {\n\n        my $new_password = DADA::Security::Password::generate_password();\n\t\t\n        $ls->save(\n            {\n                -settings => {\n                    password     => $new_password,\n                    pass_auth_id => ''\n                }\n            }\n        );\n\n        require DADA::App::Messages;\n        my $dap = DADA::App::Messages->new( { -list => $list } );\n        $dap->send_out_message(\n            {\n                -message => 'list_password_reset_message',\n                -email   => $ls->param('list_owner_email'),\n\t\t\t\t-tmpl_params => {\n\t                -list_settings_vars_param => { -list => $list },\n\t                -vars    => {\n\t\t\t\t\t\tnew_password => $new_password,\n\t                },\n\t\t\t\t},\n            },\n        );\n\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->mj_log(\n            $list,\n            'List Password Reset',\n            \"remote_host:$ENV{REMOTE_HOST}, ip_address:\" \n\t\t\t. $ENV{REMOTE_ADDR}\n        ) if $DADA::Config::LOG{list_lives};\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n              . '?flavor='\n              . $DADA::Config::SIGN_IN_FLAVOR_NAME\n              . '&list='\n              . $list\n              . '&list_password_reset=1' );\n    }\n    else {\n\n\t\t# Gotta put v3 in here - probably take it from Validate.pm\n\n\n        if ( can_use_Google_reCAPTCHA() ) {\n            \t\t\t\n\t        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t\t{\n\t\t\t\t\t -response    => $crf, \n\t\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t\t}\n\t\t\t);\n\n            if ( $captcha_status == 0 ) {\n\t\t\t\t\n                require DADA::Template::Widgets;\n                return DADA::Template::Widgets::admin(\n                    {\n                        -cgi_obj => $q,\n                        -vars    => {\n                            selected_list   => $list,\n                            invalid_captcha => 1,\n                            errors => [ { error => 'invalid_password' } ],\n                        }\n                    }\n                );\n            }\n        }\n\n        my $random_string = DADA::Security::Password::generate_rand_string();\n\n        $ls->save(\n            {\n                -settings => {\n                    pass_auth_id => $random_string,\n                }\n            }\n        );\n\n        require DADA::App::Messages;\n        my $dap = DADA::App::Messages->new( { -list => $list } );\n        $dap->send_out_message(\n            {\n                -message => 'list_password_reset_confirmation_message',\n                -email   => $ls->param('list_owner_email'),\n\t\t\t\t-tmpl_params => {\n\t                -list_settings_vars_param => { -list => $list },\n\t                -vars    => {\n\t                    random_string => $random_string,\n\t                    REMOTE_HOST   => $ENV{REMOTE_HOST},\n\t                    REMOTE_ADDR   => $ENV{REMOTE_ADDR},\n\t                },\n\t\t\t\t},\n            },\n        );\n\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->mj_log(\n            $list,\n            'Sent Password Change Confirmation',\n            \"remote_host:$ENV{REMOTE_HOST}, ip_address:\" . $ENV{REMOTE_ADDR}\n        ) if $DADA::Config::LOG{list_lives};\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'list_password_confirmation_screen.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    REMOTE_HOST => $ENV{REMOTE_HOST},\n                    REMOTE_ADDR => $ENV{REMOTE_ADDR},\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n            },\n        );\n        return $scrn;\n    }\n}\n\nsub login {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $referer = $q->param('referer') || $DADA::Config::DEFAULT_ADMIN_SCREEN;\n    my $admin_password = $q->param('admin_password') || \"\";\n    my $admin_list     = $q->param('admin_list')     || \"\";\n    my $auth_state     = $q->param('auth_state')     || undef;\n\n    my $try_referer = $referer;\n\n    $try_referer =~ s/(^http\\:\\/\\/|^https\\:\\/\\/)//;\n    $try_referer =~ s/^www//;\n\n    my $reg_try_referer = quotemeta($try_referer);\n    if ( $DADA::Config::PROGRAM_URL =~ m/$reg_try_referer$/ ) {\n        $referer = $DADA::Config::DEFAULT_ADMIN_SCREEN;\n    }\n\n    my $list = $admin_list;\n\t\n\t# GET request not allowed. \n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\n    if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n        require DADA::Security::SimpleAuthStringState;\n        my $sast = DADA::Security::SimpleAuthStringState->new;\n        if ( $sast->check_state($auth_state) != 1 ) {\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => 'incorrect_login_url',\n                }\n            );\n        }\n    }\n    \n\t# Also, if we're to put this on the admin login form: \n    if (can_use_Google_reCAPTCHA() == 1 ) {\n\n        my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n\t\tmy $captcha_status = validate_recaptcha(\n\t\t\t{\n\t\t\t\t -response    => $crf, \n\t\t\t\t -remote_addr => $ENV{'REMOTE_ADDR'},\n\t\t\t}\n\t\t);\n\t\tif($captcha_status == 0){ \n            return user_error(\n                {\n                    -list  => $list,\n                    -error => 'list_cp_login_recaptcha_failed',\n                }\n            );\n\t\t}\n\t}\n\n\n\n    my $cookie;\n\n    if ( check_if_list_exists( -List => $list ) >= 1 ) {\n\n        require DADA::Security::Password;\n        require DADA::App::Session;\n        my $dada_session = DADA::App::Session->new();\n\n        if ( $dada_session->logged_into_diff_list( -cgi_obj => $q ) != 1 ) {\n\n            my $login_cookies = $dada_session->login_cookies(\n                -cgi_obj  => $q,\n                -list     => $list,\n                -password => $admin_password\n            );\n\n            # not cached atm\n            # require DADA::App::ScreenCache;\n            # my $c = DADA::App::ScreenCache->new;\n            # $c->remove( 'login_switch_widget.' . $list . '.scrn' );\n\n            if ( $DADA::Config::LOG{logins} ) {\n                require DADA::Logging::Usage;\n                my $log = new DADA::Logging::Usage;\n                my $rh  = $ENV{REMOTE_HOST} || '';\n                my $ra  = $ENV{REMOTE_ADDR} || '';\n\n                $log->mj_log( $admin_list, 'login',\n                    'remote_host:' . $rh . ', ip_address:' . $ra );\n            }\n\n           # my $cookies = [ $dumb_cookie, @$login_cookies ];\n            my $headers = {\n                -cookie  => $login_cookies,\n                -nph     => $DADA::Config::NPH,\n                -Refresh => '0; URL=' . $referer\n            };\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -with           => 'list',\n                    -screen         => 'logging_in_screen.tmpl',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        show_profile_widget => 0,\n                        referer             => $referer,\n                    },\n                }\n            );\n\n            $dada_session->remove_old_session_files();\n\n            $self->header_props(%$headers);\n            $scrn;\n        }\n        else {\n\n            return user_error(\n                {\n                    -list  => $list,\n                    -error => \"logged_into_different_list\",\n                }\n            );\n        }\n\n    }\n    else {\n        return user_error(\n            {\n                -list  => $list,\n                -error => \"no_list\",\n            }\n        );\n    }\n}\n\nsub logout {\n\n    my $self = shift;\n\n    my $q = $self->query();\n\n    my $headers = {};\n    my $body    = undef;\n\n\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\t\n    my %args = (\n        -redirect               => 1,\n        -redirect_url           => $DADA::Config::DEFAULT_LOGOUT_SCREEN,\n        -no_list_security_check => 0,\n        @_\n    );\n\n    my $admin_list;\n    my $root_login;\n\n    my $list_exists = check_if_list_exists( -List => $admin_list );\n\n    # I don't quite even understand why there's this check...\n    if ( $args{-no_list_security_check} == 0 ) {\n        if ( $list_exists == 1 ) {\n            my ( $admin_list, $root_login, $checksout, $error_msg ) =\n              check_list_security(\n                -cgi_obj  => $q,\n                -Function => 'logout'\n              );\n            if ( !$checksout ) { return $error_msg; }\n        }\n    }\n\n    # not cached atm\n    #require DADA::App::ScreenCache;\n    #my $c = DADA::App::ScreenCache->new;\n    #$c->remove( 'login_switch_widget.' . $admin_list . '.scrn' );\n\n    my $l_list = $admin_list;\n\n    my $location = $args{-redirect_url};\n\n    if ( $q->param('login_url') ) {\n        $location = $q->param('login_url');\n    }\n\n    if ( $DADA::Config::LOG{logins} != 0 ) {\n\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->mj_log( $l_list, 'logout',\n            \"remote_host:$ENV{REMOTE_HOST}, ip_address:$ENV{REMOTE_ADDR}\" );\n\n    }\n\n    require DADA::App::Session;\n    my $dada_session = DADA::App::Session->new( -List => $l_list );\n    my $logout_cookies = $dada_session->logout_cookie( -cgi_obj => $q );\n\n    if ( $args{-redirect} == 1 ) {\n\n        $headers = {\n            -cookie  => $logout_cookies,\n            -nph     => $DADA::Config::NPH,\n            -Refresh => '0; URL=' . $location,\n        };\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -with           => 'list',\n                -screen         => 'logging_out_screen.tmpl',\n                -wrapper_params => {\n                    -Use_Custom => 0,\n                },\n                -vars => {\n                    show_profile_widget => 0,\n                    location            => $location,\n                },\n            }\n        );\n\n        # Probably not setting up the header_props here, yey?\n\t\t$self->header_props({});\n        $self->header_props(%$headers);\n\t\t#return $scrn; \n        return ( $headers, $scrn );\n    }\n    else {\n        return $logout_cookies;    #DEV: not sure about this one...\n    }\n\n}\n\n#sub log_into_another_list {\n#\n#    my $self = shift;\n#    my $q    = $self->query();\n#\n#    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n#      check_list_security(\n#        -cgi_obj  => $q,\n#        -Function => 'log_into_another_list'\n#      );\n#    if ( !$checksout ) { return $error_msg; }\n#\n#    $self->logout( -redirect_url => $DADA::Config::PROGRAM_URL\n#          . '?flavor='\n#          . $DADA::Config::SIGN_IN_FLAVOR_NAME, );\n#\n#}\n\nsub change_login {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n\n\tif($q->request_method() !~ m/POST/i){\n\t\treturn $self->status_405(); \n\t}\n\t\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'change_login'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    die \"only for root logins!\"\n      if !$root_login;\n\n    require DADA::App::Session;\n    my $dada_session = DADA::App::Session->new();\n\n    my $change_to_list = $q->param('change_to_list');\n    my $location       = $q->param('location');\n    if ( $location !~ m/^http/ ) {\n        $location = 'http' . $location;\n    }\n\n    # DEV: Ooh. This is messy.\n    $location =~ s/(\\;|\\&)done\\=1$//;\n    $location =~ s/(\\;|\\&)delete_email_count\\=(.*?)$//;\n    $location =~ s/(\\;|\\&)email_count\\=(.*?)$//;\n\n    $location =~ s/f\\=add_email\\&fn\\=(.*?)(\\&)/f\\=add\\2/;\n\n    my $new_cookies = $dada_session->change_login(\n\t\t-cgi_obj => $q, \n\t\t-list    => $change_to_list\n\t);\n\n    # not cached atm\n    # require DADA::App::ScreenCache;\n    # my $c = DADA::App::ScreenCache->new;\n    # $c->remove( 'login_switch_widget.' . $change_to_list . '.scrn' );\n\n\t#$q->delete_all();\n\n\n\t\n    my $headers = {\n        -cookie  => $new_cookies,\n        -nph     => $DADA::Config::NPH,\n        -Refresh => '0; URL=' . $location\n    };\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -with           => 'list',\n            -screen         => 'logging_switch_screen.tmpl',\n            -wrapper_params => {\n                -Use_Custom => 0,\n            },\n            -vars => {\n                show_profile_widget => 0,\n                location            => $location,\n            },\n        }\n    );\n\t$self->header_props({});\n    $self->header_props(%$headers);\n    return $scrn;\n}\n\nsub remove_subscribers {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $type = $q->param('type');\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list           = $admin_list;\n    my $return_to      = $q->param('return_to') || '';\n    my $return_address = $q->param('return_address') || '';\n    my @address        = $q->multi_param('address');\n\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n    my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n        {\n            -addresses        => [@address],\n            -type             => $type,\n            -validation_check => 0,\n        }\n    );\n\n    my $flavor_to_return_to = 'view_list';\n    if ( $return_to eq 'membership' ) {    # or, others...\n        $flavor_to_return_to = $return_to;\n    }\n\n    my $qs =\n\n      'flavor='\n      . $flavor_to_return_to\n      . '&delete_email_count='\n      . $d_count\n      . '&type='\n      . $type\n      . '&black_list_add='\n      . $bl_count;\n\n    if ( $return_to eq 'membership' ) {\n        $qs .= '&email=' . uriescape($return_address);\n    }\n\n    $self->header_type('redirect');\n    $self->header_props( -url => $DADA::Config::S_PROGRAM_URL . '?' . $qs );\n}\n\nsub process_bouncing_addresses {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my @address = $q->multi_param('address');\n    my $type    = $q->param('type');\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'view_list'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    my $lh = DADA::MailingList::Subscribers->new( { -list => $list } );\n\n    my $return_to      = $q->param('return_to')      || 'view_list';\n    my $return_address = $q->param('return_address') || undef;\n\n    if ( $q->param('process') =~ m/remove/i ) {\n        my ( $d_count, $bl_count ) = $lh->admin_remove_subscribers(\n            {\n                -addresses => [@address],\n                -type      => 'bounced_list',\n            }\n        );\n        my $uri =\n            $DADA::Config::S_PROGRAM_URL\n          . '?flavor='\n          . $return_to\n          . '&bounced_list_removed_from_list='\n          . $d_count\n          . '&type='\n          . $type\n          . '&black_list_add='\n          . $bl_count\n          . '&email='\n          . uriescape($return_address);\n\n        $self->header_type('redirect');\n        $self->header_props( -url => $uri );\n\n    }\n    elsif ( $q->param('process') =~ m/move/i ) {\n\n        my $m_count = 0;\n\n        for my $address (@address) {\n            $lh->move_subscriber(\n                {\n                    -email => $address,\n                    -from  => 'bounced_list',\n                    -to    => 'list',\n                    -mode  => 'writeover',\n                }\n            );\n            $m_count++;\n        }\n\n# maybe if the bounce_list num_subscribers count is 0, we just go to the view_list screen.\n        my $uri =\n            $DADA::Config::S_PROGRAM_URL\n          . '?flavor='\n          . $return_to\n          . '&type='\n          . $type\n          . '&bounced_list_moved_to_list_count='\n          . $m_count\n          . '&email='\n          . uriescape($return_address);\n        $self->header_type('redirect');\n        $self->header_props( -url => $uri );\n\n    }\n    else {\n        croak \"I'm not sure what I'm supposed to do!\";\n    }\n}\n\nsub find_attachment_type {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $filename = shift;\n    my $a_type;\n\n    my $attach_name = $filename;\n    $attach_name =~ s!^.*(\\\\|\\/)!!;\n    $attach_name =~ s/\\s/%20/g;\n\n    my $file_ending = $attach_name;\n    $file_ending =~ s/.*\\.//;\n\n\ttry {\n\t    require MIME::Types;\n\t    require MIME::Type;\n\t    my ( $mimetype, $encoding ) = MIME::Types::by_suffix($filename);\n\t    $a_type = $mimetype\n\t\t\tif ( $mimetype && $mimetype =~ /^\\S+\\/\\S+$/ );    ### sanity check\n\t} catch { \n\t\t#...\n\t};\n\n\tif(!$a_type){\n        if ( exists( $DADA::Config::MIME_TYPES{ '.' . lc($file_ending) } ) ) {\n            $a_type = $DADA::Config::MIME_TYPES{ '.' . lc($file_ending) };\n        }\n        else {\n            $a_type = $DADA::Config::DEFAULT_MIME_TYPE;\n        }\n    }\n\t\n    if ( !$a_type ) {\n        warn\n\"attachment MIME Type never figured out, letting MIME::Lite handle this...\";\n        $a_type = 'AUTO';\n    }\n\n    return $a_type;\n}\n\nsub file_upload {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $upload_file = shift;\n    require CGI;\n    my $fu = CGI->new;\n    $fu->charset($DADA::Config::HTML_CHARSET);\n    my $file = $fu->param($upload_file);\n    if ( $file ne \"\" ) {\n        my $fileName = $file;\n        $fileName =~ s!^.*(\\\\|\\/)!!;\n\n        $fileName = uriescape($fileName);\n\n        my $outfile =\n          make_safer( $DADA::Config::TMP . '/' . time . '_' . $fileName );\n\n        open( OUTFILE, '>' . $outfile )\n          or warn( \"can't write to '\" . $outfile . \"' because: $!\" );\n        while ( my $bytesread = read( $file, my $buffer, 1024 ) ) {\n            print OUTFILE $buffer;\n        }\n        close(OUTFILE);\n        chmod( $DADA::Config::FILE_CHMOD, $outfile );\n        return $outfile;\n    }\n\n}\n\nsub pass_gen {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $pw = $q->param('pw');\n\n    if ( !$pw ) {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'pass_gen_screen.tmpl',\n                -with   => 'list',\n                -expr   => 1,\n                -vars   => {},\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        require DADA::Security::Password;\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'pass_gen_process_screen.tmpl',\n                -with   => 'list',\n                -expr   => 1,\n                -vars   => {\n                    encrypted_password =>\n                      DADA::Security::Password::encrypt_passwd($pw),\n                },\n            }\n        );\n        return $scrn;\n    }\n\n}\n\nsub setup_info {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $root_password = $q->param('root_password') || '';\n\n    my $from_control_panel = 0;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'setup_info',\n      );\n    my $list = undef;\n    if ( $checksout == 1 && $root_password eq '' ) {\n        $from_control_panel = 1;\n        $list               = $admin_list;\n    }\n\n    if ( $checksout == 1 || root_password_verification($root_password) == 1 ) {\n\n# If we have a .dada_config file, this is a contemporary installation, we'll say.\n        my $c_install = 0;\n\n        # Not sure why I should do this check at all, if the \"auto\" dealy\n        # could be set, anyways,\n        if (\n            (\n                   -e $DADA::Config::PROGRAM_CONFIG_FILE_DIR\n                && -d $DADA::Config::PROGRAM_CONFIG_FILE_DIR\n            )\n            || $DADA::Config::PROGRAM_CONFIG_FILE_DIR eq 'auto'\n          )\n        {\n            if ( -e $DADA::Config::CONFIG_FILE ) {\n                $c_install = 1;\n            }\n        }\n\n        my $config_file_contents = undef;\n        if ( -e $DADA::Config::CONFIG_FILE ) {\n            $config_file_contents =\n              DADA::Template::Widgets::_slurp($DADA::Config::CONFIG_FILE);\n        }\n        my $config_pm_file_contents =\n          DADA::Template::Widgets::_slurp('DADA/Config.pm');\n\n        my $files_var_exist = 0;\n        if ( -e $DADA::Config::FILES ) {\n            $files_var_exist = 1;\n        }\n\n        my $config_vals = [];\n\n        for (@DADA::Config::EXPORT_OK) {\n            my $orig_name = $_;\n            $_ =~ s/^(\\$|\\@|\\%)//;\n            my $sigil = $1;\n\n            require Data::Dumper;\n\n            my $var_val = undef;\n            if ( $sigil eq '$' ) {\n                $var_val = Data::Dumper::Dumper( ${ $DADA::Config::{$_} } );\n            }\n            elsif ( $sigil eq '@' ) {\n                $var_val = Data::Dumper::Dumper( \\@{ $DADA::Config::{$_} } );\n            }\n            elsif ( $sigil eq '%' ) {\n                $var_val = Data::Dumper::Dumper( \\%{ $DADA::Config::{$_} } );\n            }\n            else {\n                $var_val = '???';\n            }\n\n            #$var_val =~ s/^(.*?)\\'//m;\n            $var_val =~ s/^\\$VAR(.*?)\\= //;\n            $var_val =~ s/^\\'//;\n            $var_val =~ s/(\\';|\\'$)$//;\n            $var_val =~ s/\\;$//;\n\n            push( @$config_vals, { name => $orig_name, value => $var_val } );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'setup_info_screen.tmpl',\n                (\n                    $from_control_panel == 1\n                    ? (\n                        -with           => 'admin',\n                        -wrapper_params => {\n                            -Root_Login => $root_login,\n                            -List       => $list,\n                        },\n                      )\n                    : ( -with => 'list', )\n                ),\n                -vars => {\n                    FILES => $DADA::Config::FILES,\n                    PROGRAM_ROOT_PASSWORD =>\n                      $DADA::Config::PROGRAM_ROOT_PASSWORD,\n                    MAILPROG => $DADA::Config::MAILPROG,\n                    PROGRAM_CONFIG_FILE_DIR =>\n                      $DADA::Config::PROGRAM_CONFIG_FILE_DIR,\n                    PROGRAM_ERROR_LOG       => $DADA::Config::PROGRAM_ERROR_LOG,\n                    screen                  => 'setup_info',\n                    c_install               => $c_install,\n                    config_file_contents    => $config_file_contents,\n                    config_pm_file_contents => $config_pm_file_contents,\n                    files_var_exist         => $files_var_exist,\n                    config_vals             => $config_vals,\n\n                },\n            }\n        );\n        return $scrn;\n\n    }\n    else {\n\n        if ( $from_control_panel == 1 ) {\n\n            # just doin' this again, w/o the manual override:\n            my ( $admin_list, $root_login, $checksout, $error_msg ) =\n              check_list_security(\n                -cgi_obj  => $q,\n                -Function => 'setup_info',\n              );\n            if ( !$checksout ) { return $error_msg; }\n        }\n        else {\n\n            my $guess = $DADA::Config::PROGRAM_URL;\n            $guess = $q->script_name()\n              if $DADA::Config::PROGRAM_URL eq \"\"\n              || $DADA::Config::PROGRAM_URL eq\n              'https://www.changetoyoursite.com/cgi-bin/dada/mail.cgi'\n              ;    # default.\n\n            my $incorrect_root_password = $root_password ? 1 : 0;\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'setup_info_login_screen.tmpl',\n                    -with   => 'list',\n                    -vars   => {\n                        program_url_guess       => $guess,\n                        incorrect_root_password => $incorrect_root_password,\n                        PROGRAM_URL             => $DADA::Config::PROGRAM_URL,\n                        S_PROGRAM_URL           => $DADA::Config::S_PROGRAM_URL,\n                    },\n                }\n            );\n            return $scrn;\n        }\n\n    }\n\n}\n\nsub reset_cipher_keys {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $root_password   = $q->param('root_password');\n    my $root_pass_check = root_password_verification($root_password);\n\n    if ( $root_pass_check == 1 ) {\n        require DADA::Security::Password;\n        my @lists = available_lists();\n\n        require DADA::MailingList::Settings;\n\n        for (@lists) {\n            my $ls = DADA::MailingList::Settings->new( { -list => $_ } );\n            $ls->save(\n                {\n                    -settings => {\n                        cipher_key =>\n                          DADA::Security::Password::make_cipher_key()\n                    }\n                }\n            );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            -screen => 'reset_cipher_keys_process.tmpl',\n            -with   => 'list',\n        );\n        return $scrn;\n\n    }\n    else {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            -screen => 'reset_cipher_keys.tmpl',\n            -with   => 'list',\n        );\n        return $scrn;\n    }\n\n}\n\nsub restore_lists {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process');\n\n    if ( root_password_verification( $q->param('root_password') ) ) {\n\n        require DADA::MailingList::Settings;\n\n        require DADA::MailingList::Archives;\n\n        # No SQL veresion, so don't worry about handing over the dbi handle...\n\n        my @lists = available_lists();\n\n        if ( $process eq 'true' ) {\n\n            my $report = '';\n\n            my %restored;\n            for my $r_list (@lists) {\n                if (   $q->param( 'restore_' . $r_list . '_settings' )\n                    && $q->param( 'restore_' . $r_list . '_settings' ) == 1 )\n                {\n                    my $ls =\n                      DADA::MailingList::Settings->new( { -list => $r_list } );\n                    $ls->{ignore_open_db_error} = 1;\n                    $report .=\n                      $ls->restoreFromFile(\n                        $q->param( 'settings_' . $r_list . '_version' ) );\n                }\n            }\n            for my $r_list (@lists) {\n                if (   $q->param( 'restore_' . $r_list . '_archives' )\n                    && $q->param( 'restore_' . $r_list . '_archives' ) == 1 )\n                {\n                    my $ls =\n                      DADA::MailingList::Settings->new( { -list => $r_list } );\n                    $ls->{ignore_open_db_error} = 1;\n                    my $la = DADA::MailingList::Archives->new(\n                        { -list => $r_list, -ignore_open_db_error => 1 } );\n                    $report .=\n                      $la->restoreFromFile(\n                        $q->param( 'archives_' . $r_list . '_version' ) );\n                }\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'restore_lists_complete.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                }\n            );\n            return $scrn;\n\n        }\n        else {\n\n            my $backup_hist = {};\n            for my $l (@lists) {\n                my $ls = DADA::MailingList::Settings->new( { -list => $l } );\n                $ls->{ignore_open_db_error} = 1;\n                my $la =\n                  DADA::MailingList::Archives->new(\n                    { -list => $l, -ignore_open_db_error => 1 } )\n                  ;    #yeah, it's diff from MailingList::Settings - I'm stupid.\n\n                $backup_hist->{$l}->{settings} = $ls->backupDirs\n                  if $ls->uses_backupDirs;\n                $backup_hist->{$l}->{archives} = $la->backupDirs\n                  if $la->uses_backupDirs;\n\n            }\n\n            my $restore_list_options = '';\n\n            #    labels are for the popup menus, that's it    #\n            my $labels = {};\n\n            #use Data::Dumper;\n            for my $l ( sort keys %$backup_hist ) {\n\n                for my $bu ( @{ $backup_hist->{$l}->{settings} } ) {\n                    my ( $time_stamp, $appended ) = ( '', '' );\n                    if ( $bu->{dir} =~ /\\./ ) {\n                        ( $time_stamp, $appended ) =\n                          split( /\\./, $bu->{dir}, 2 );\n                    }\n                    else {\n                        $time_stamp = $bu->{dir};\n                    }\n\n                    $labels->{$l}->{settings}->{ $bu->{dir} } =\n                        scalar( localtime($time_stamp) ) . ' ('\n                      . $bu->{count}\n                      . ' entries)';\n\n                }\n\n                for my $bu ( @{ $backup_hist->{$l}->{archives} } ) {\n\n                    my ( $time_stamp, $appended ) = ( '', '' );\n                    if ( $bu->{dir} =~ /\\./ ) {\n                        ( $time_stamp, $appended ) =\n                          split( /\\./, $bu->{dir}, 2 );\n                    }\n                    else {\n                        $time_stamp = $bu->{dir};\n                    }\n\n                    $labels->{$l}->{archives}->{ $bu->{dir} } =\n                        scalar( localtime($time_stamp) ) . ' ('\n                      . $bu->{count}\n                      . ' entries)';\n\n                }\n                for my $bu ( @{ $backup_hist->{$l}->{schedules} } ) {\n\n                    my ( $time_stamp, $appended ) = ( '', '' );\n                    if ( $bu->{dir} =~ /\\./ ) {\n                        ( $time_stamp, $appended ) =\n                          split( /\\./, $bu->{dir}, 2 );\n                    }\n                    else {\n                        $time_stamp = $bu->{dir};\n                    }\n\n                    $labels->{$l}->{schedules}->{ $bu->{dir} } =\n                        scalar( localtime($time_stamp) ) . ' ('\n                      . $bu->{count}\n                      . ' entries)';\n\n                }\n            }\n\n            #\n\n            for my $f_list ( keys %$backup_hist ) {\n\n                $restore_list_options .=\n                  $q->start_table( { -cellpadding => 5 } );\n                $restore_list_options .= $q->h3($f_list);\n\n                $restore_list_options .= $q->Tr(\n                    $q->td(\n                        { -valign => 'top' },\n                        [\n                            ( $q->p( $q->strong('Restore?') ) ),\n                            ( $q->p( $q->strong('Backup Version*:') ) ),\n                        ]\n                    )\n                );\n\n                for my $t ( 'settings', 'archives', 'schedules' ) {\n\n                    #\t\trequire Data::Dumper;\n                    #\t\tdie Data::Dumper::Dumper(%labels);\n                    my $vals = [];\n                    for my $d ( @{ $backup_hist->{$f_list}->{$t} } ) {\n                        push( @$vals, $d->{dir} );\n                    }\n\n                    $restore_list_options .= $q->Tr(\n                        $q->td(\n                            [\n                                (\n                                    $q->p(\n                                        $q->checkbox(\n                                            -name => 'restore_'\n                                              . $f_list . '_'\n                                              . $t,\n                                            -id => 'restore_'\n                                              . $f_list . '_'\n                                              . $t,\n                                            -value => 1,\n                                            -label => ' ',\n                                        ),\n                                        '<label for=\"'\n                                          . 'restore_'\n                                          . $f_list . '_'\n                                          . $t . '\">'\n                                          . $t\n                                          . '</label>'\n                                    )\n                                ),\n\n                                ( scalar @{ $backup_hist->{$f_list}->{$t} } )\n                                ? (\n\n                                    (\n                                        '<p>'\n                                          . HTML::Menu::Select::popup_menu(\n                                            {\n                                                name => $t . '_'\n                                                  . $f_list\n                                                  . '_version',\n                                                values => $vals,\n                                                labels =>\n                                                  $labels->{$f_list}->{$t},\n                                            }\n                                          )\n                                          . '</p>'\n                                    ),\n\n                                  )\n                                : (\n\n                                    (\n                                        $q->p(\n                                            { -class => 'error' },\n                                            '-- No Backup Information Found --'\n                                        ),\n                                        $q->hidden(\n                                            -name => $t . '_'\n                                              . $f_list\n                                              . '_version',\n                                            -value => 'just_remove_blank'\n                                        )\n                                    ),\n                                ),\n                            ]\n                        )\n                    );\n                    $vals = [];\n\n                }\n                $restore_list_options .= '</table>';\n            }\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'restore_lists_options_screen.tmpl',\n                    -with           => 'list',\n                    -wrapper_params => {\n                        -Use_Custom => 0,\n                    },\n                    -vars => {\n                        restore_list_options => $restore_list_options,\n                        root_password =>\n                          xss_filter( scalar $q->param('root_password') ),\n                    }\n                }\n            );\n            return $scrn;\n\n        }\n\n    }\n    else {\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            { -screen => 'restore_lists_screen.tmpl', -with => 'list', } );\n        return $scrn;\n    }\n\n}\n\nsub subscription_form_html {\n\n    my $self                 = shift;\n    my $q                    = $self->query();\n    my $list                 = $q->param('list');\n    my $subscription_form_id = $q->param('subscription_form_id')\n      || 'jquery_subscription_form';\n\n    my $subscription_form = DADA::Template::Widgets::subscription_form(\n        {\n            -subscription_form_id => $subscription_form_id,\n            -show_fieldset        => 0,\n            -magic_form           => 0,\n            ( defined($list) ? ( -list => $list, ) : () )\n        }\n    );\n    if ( $q->param('_method') eq 'GET' && $q->param('callback') ) {\n\n        my $headers = {\n            -type                           => 'application/javascript',\n            '-Access-Control-Allow-Origin'  => '*',\n            '-Access-Control-Allow-Methods' => 'POST',\n            '-Cache-Control'                => 'no-cache, must-revalidate',\n            -expires                        => 'Mon, 26 Jul 1997 05:00:00 GMT',\n        };\n\n        my $callback = xss_filter( strip( $q->url_param('callback') ) );\n        require JSON;\n        my $json = JSON->new->allow_nonref;\n        my $r   = $json->encode( { subscription_form => $subscription_form } );\n\n        $self->header_props(%$headers);\n        return $callback . '(' . $r . ');';\n    }\n    else {\n        return $subscription_form;\n    }\n}\n\nsub subscriber_help {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $list = $q->param('list');\n\n    if ( !$list ) {\n        return $self->default();\n    }\n\n    if ( check_if_list_exists( -List => $list ) == 0 ) {\n        undef($list);\n        return $self->default();\n    }\n\n    require DADA::MailingList::Settings;\n\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen => 'subscriber_help_screen.tmpl',\n            -with   => 'list',\n            -vars   => {\n                list      => $list,\n                list_name => $ls->param('list_name'),\n                list_owner_email =>\n                  spam_me_not_encode( $ls->param('list_owner_email') ),\n            }\n        }\n    );\n    return $scrn;\n\n}\n\nsub show_img {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    $self->file_attachment( -inline_image_mode => 1 );\n}\n\nsub file_attachment {\n\n    my $self = shift;\n    my $q    = $self->query();\n    my $list = $q->param('list');\n\n    # Weird:\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email',\n      );\n\n    #if(!$checksout){ return $error_msg; }\n\n    my %args = (\n        -inline_image_mode => 0,\n        @_\n    );\n\n    my $id = $q->param('id') || undef;\n\n    if ( check_if_list_exists( -List => $list ) == 1 ) {\n\n        require DADA::MailingList::Settings;\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n        if ( $ls->param('show_archives') == 1 || $checksout == 1 ) {\n\n            if ( $ls->param('display_attachments') == 1 || $checksout == 1 ) {\n\n                require DADA::MailingList::Archives;\n\n                my $la = DADA::MailingList::Archives->new( { -list => $list } );\n\n                if ( $la->can_display_attachments ) {\n\n                    if ( $la->check_if_entry_exists( $q->param('id') ) ) {\n\n                        if ( $args{-inline_image_mode} == 1 ) {\n\n#  if (\n#      $c->is_cached(\n#          'view_inline_attachment.' . $list . '.' . $id . '.' . scalar($q->param('cid')) . '.cid'\n#      )\n#    )\n#  {\n#      return $c->cached(\n#          'view_inline_attachment.' . $list . '.' . $id . '.' . scalar($q->param('cid')) . '.cid' );\n#  }\n                            my ( $h, $scrn ) = $la->view_inline_attachment(\n                                -id  => scalar $q->param('id'),\n                                -cid => scalar $q->param('cid')\n                            );\n\n# Bettin' that it's binary (or at least, unencoded)\n# $c->cache( 'view_inline_attachment.' . $list . '.' . $id . '.' . scalar($q->param('cid')) . '.cid',\n#        \\$scrn );\n#    return $scrn;\n\n                            $self->header_props($h);\n                            return $scrn;\n\n                        }\n                        else {\n#if (\n#    $c->is_cached(\n#        'view_file_attachment.' . $list . '.' . $id . '.' . scalar($q->param('filename'))\n#    )\n#  )\n#{\n#    return $c->cached(\n#        'view_file_attachment.' . $list . '.' . $id . '.' . scalar($q->param('filename') ));\n#}\n#else {\n\n                            my ( $h, $scrn ) = $la->view_file_attachment(\n                                -id       => scalar $q->param('id'),\n                                -filename => scalar $q->param('filename')\n                            );\n\n#$c->cache( 'view_file_attachment.' . $list . '.' . $id . '.' . scalar($q->param('filename')),\n#    \\$scrn );\n\n# Binary. Well, actually, *probably* - how would you figure out the content-type of an attached file?\n                            $self->header_props($h);\n                            return $scrn;\n\n                            #}\n                        }\n\n                    }\n                    else {\n                        return user_error(\n                            { -list => $list, -error => \"no_archive_entry\" } );\n                    }\n\n                }\n                else {\n                    return user_error(\n                        { -list => $list, -error => \"no_display_attachments\" }\n                    );\n                }\n\n            }\n            else {\n                return user_error(\n                    { -list => $list, -error => \"no_display_attachments\" } );\n            }\n\n        }\n        else {\n            return user_error(\n                { -list => $list, -error => \"no_show_archives\" } );\n        }\n\n    }\n    else {\n        return user_error( { -list => $list, -error => 'no_list' } );\n    }\n\n}\n\n\n\n\nsub redirection { \n    my $self = shift;\n    my $q    = $self->query();\n\t\n\n    if ( check_if_list_exists( -List => $q->param('list') ) == 0 ) {\n\t\treturn $self->default();\n    }\n\trequire DADA::MailingList::Settings; \n\tmy $ls = DADA::MailingList::Settings->new({-list => $q->param('list')});\n\t\n\t \n\tif(\n\t\t   $q->request_method() =~ m/POST/i\n\t\t|| $ls->param('tracker_protect_tracked_links_from_prefetching') != 1\n\t){\n\t\treturn $self->post_redirection(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_redirection.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\t\n\t\t\t\t\tlist   => $q->param('list'),\n\t\t\t\t\tkey    => $q->param('key'),\n\t\t\t\t\temail  => $q->param('email'),\n\t\t\t\t\t\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n\n}\n\n\n\n\nsub post_redirection {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    #\tuse Data::Dumper;\n    #\tdie Dumper([$q->param('key'), $q->param('email')] );\n    require DADA::Logging::Clickthrough;\n    my $r =\n      DADA::Logging::Clickthrough->new( { -list => scalar $q->param('list') } );\n    if ( defined( $q->param('key') ) ) {\n\n        my ( $mid, $url, $atts ) = $r->fetch( $q->param('key') );\n\n        if ( defined($mid) && defined($url) ) {\n            $r->r_log(\n                {\n                    -mid   => $mid,\n                    -url   => $url,\n                    -atts  => $atts,\n                    -email => scalar $q->param('email'),\n                }\n            );\n        }\n        if ($url) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $url );\n        }\n        else {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::PROGRAM_URL );\n        }\n    }\n    else {\n        $self->header_type('redirect');\n        $self->header_props( -url => $DADA::Config::PROGRAM_URL );\n    }\n}\n\nsub m_o_c {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $list = xss_filter( scalar $q->param('list') );\n\n    if ( check_if_list_exists( -List => $list ) == 0 ) {\n        carp \"list: '$list' does not exist, aborted logging of open message\\n\"\n          . 'path_info(): '\n          . $q->path_info();\n\n    }\n    else {\n        require DADA::Logging::Clickthrough;\n        my $r = DADA::Logging::Clickthrough->new(\n            { -list => scalar $q->param('list') } );\n        if ( defined( $q->param('mid') ) ) {\n\n            $r->open_log(\n                {\n                    -mid   => scalar $q->param('mid'),\n                    -email => scalar $q->param('email'),\n                }\n            );\n        }\n    }\n    require MIME::Base64;\n    my $headers = {\n        -type            => 'image/png',\n        '-Cache-Control' => 'no-cache, max-age=0',\n\n        # '-Content-Length' => 0,\n    };\n\n    # a simple, 1px png image.\n    my $str = <<EOF\niVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAMAAAAoyzS7AAAABGdBTUEAANbY1E9YMgAAABl0RVh0\nU29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAGUExURf///wAAAFXC034AAAABdFJOUwBA\n5thmAAAADElEQVR42mJgAAgwAAACAAFPbVnhAAAAAElFTkSuQmCC\nEOF\n      ;\n    $self->header_props(%$headers);\n    return MIME::Base64::decode_base64($str);\n\n}\n\nsub css {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    # Backwards compat -\n    my $headers = { -type => 'text/css' };\n\n    if ( $q->param('css_file') eq 'dada_mail.css' ) {\n\n        my $body = DADA::Template::Widgets::_raw_screen(\n            {\n                -screen => $DADA::Config::SUPPORT_FILES->{dir}\n                  . '/static/css/dada_mail.css'\n            }\n        );\n\n        $self->header_props(%$headers);\n        return $body;\n    }\n    else {\n        $self->header_props(%$headers);\n    }\n}\n\nsub ver {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    return $DADA::Config::VER;\n}\n\nsub author {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    return \"Dada Mail is originally written by Justin Simoni\";\n\n}\n\nsub profile_login {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $whole_url = $q->url( -path_info => 1, -query => 0 );\n    if ( exists( $ENV{QUERY_STRING} ) ) {\n        if ( length( $ENV{QUERY_STRING} ) > 0 ) {\n            $whole_url .= '?' . $ENV{QUERY_STRING};\n        }\n    }\n\n    if ( $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n\n    }\n\t\n    require DADA::Profile;\n    ###\n    my $all_errors = [];\n    my $named_errs = {};\n    my $errors     = $q->param('errors');\n    for (@$errors) {\n        $named_errs->{ 'error_' . $_ } = 1;\n        push( @$all_errors, { error => $_ } );\n    }\n    ###\n\n    require DADA::Profile::Session;\n    my $prof_sess = DADA::Profile::Session->new;\n\n    if ( $q->param('process') != 1 ) {\n        if (   $prof_sess->is_logged_in( { -cgi_obj => $q } )\n            && $q->param('logged_out') != 1 )\n        {\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::PROGRAM_URL . '/profile/' );\n        }\n        else {\n\t\t\tmy $scrn              = '';\n            my $using_captcha     = 0;\n\n            if ( $DADA::Config::PROFILE_OPTIONS->{enable_captcha} == 1 ) {\n                $using_captcha = can_use_Google_reCAPTCHA();\n            }\n\n\t\t\tmy $auth_state;\n\t\t    if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n\t\t        require DADA::Security::SimpleAuthStringState;\n\t\t        my $sast = DADA::Security::SimpleAuthStringState->new;\n\t\t        $auth_state = $sast->make_state;\n\t\t    }\n\n            $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'profile_login.tmpl',\n                    -with   => 'list',\n                    -expr   => 1,\n                    -vars   => {\n                        errors => $all_errors,\n                        %$named_errs,\n\n                        email => xss_filter( scalar $q->param('email') )\n                          || '',\n                        login_email =>\n                          xss_filter( scalar $q->param('login_email') )\n                          || '',\n                        register_email =>\n                          xss_filter( scalar $q->param('register_email') )\n                          || '',\n                        reset_email =>\n                          xss_filter( scalar $q->param('reset_email') )\n                          || '',\n                        register_email_again => xss_filter(\n                            scalar $q->param('register_email_again')\n                          )\n                          || '',\n\n                        error_profile_login =>\n                          scalar $q->param('error_profile_login') || '',\n                        error_profile_register =>\n                          scalar $q->param('error_profile_register') || '',\n                        error_profile_activate =>\n                          scalar $q->param('error_profile_activate') || '',\n                        error_profile_reset_password =>\n                          scalar $q->param('error_profile_reset_password')\n                          || '',\n                        password_changed => scalar $q->param('password_changed')\n                          || '',\n                        logged_out => scalar $q->param('logged_out') || '',\n                        can_use_captcha => $using_captcha,\n                        welcome         => scalar $q->param('welcome') || '',\n                        removal         => scalar $q->param('removal') || '',\n                        WHOLE_URL       => $whole_url,\n\t\t\t\t\t\t\n\t\t                auth_state      => $auth_state,\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t# This should probably be deprecated, as I'm handling this in \n\t\t\t\t\t\t# DADA::Template::Widgets, now\n                        %{ DADA::Profile::feature_enabled() }\n                    },\n\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n        my ( $status, $errors ) = $prof_sess->validate_profile_login(\n            {\n                -email      => xss_filter( scalar $q->param('login_email') ),\n                -password   => xss_filter( scalar $q->param('login_password') ),\n\t\t\t\t-auth_state => xss_filter( scalar $q->param('auth_state') ),\n\n            },\n        );\n\n        if ( $status == 1 ) {\n            my $cookie = $prof_sess->login(\n                {\n                    -email           => xss_filter( scalar $q->param('login_email') ),\n                    -password        => xss_filter( scalar $q->param('login_password') ),\t\t\t\t\t\n                \t-skip_validation => 1, \n\t\t\t\t},\n            );\n\n            #DEV: encoding?\n            my $headers = {\n                -cookie  => [$cookie],\n                -nph     => $DADA::Config::NPH,\n                -Refresh => '0; URL='\n                  . $DADA::Config::PROGRAM_URL\n                  . '/profile/'\n            };\n            my $body = $q->start_html(\n                -title   => 'Logging in...',\n                -BGCOLOR => '#FFFFFF'\n            );\n            $body .= $q->p(\n                $q->a(\n                    { -href => $DADA::Config::PROGRAM_URL . '/profile/' },\n                    'Logging in...'\n                )\n            );\n            $body .= $q->end_html();\n\n            $self->header_props(%$headers);\n            return $body;\n        }\n        else {\n            my $p_errors = [];\n            for ( keys %$errors ) {\n                if ( $errors->{$_} == 1 ) {\n                    push( @$p_errors, $_ );\n                }\n            }\n            $q->param( 'errors',              $p_errors );\n            $q->param( 'process',             0 );\n            $q->param( 'error_profile_login', 1 );\n            return $self->profile_login();\n        }\n    }\n\n}\n\nsub profile_register {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1 ) {\n        return $self->default();\n    }\n\n    require DADA::Profile;\n    if ( !DADA::Profile::feature_enabled('register') == 1 ) {\n        return $self->default();\n    }\n\n    my $register_email =\n      strip( cased( xss_filter( scalar $q->param('register_email') ) ) );\n    my $register_email_again =\n      strip( cased( xss_filter( scalar $q->param('register_email_again') ) ) );\n    my $register_password =\n      strip( xss_filter( scalar $q->param('register_password') ) );\n\n    my $prof = DADA::Profile->new( { -email => $register_email } );\n\n    if ( $prof->exists()\n        && !$prof->is_activated() )\n    {\n        $prof->remove();\n    }\n\n    my $crf = xss_filter( scalar $q->param('g-recaptcha-response')) || undef;\n    my ( $status, $errors ) = $prof->is_valid_registration(\n        {\n            -email                     => $register_email,\n            -email_again               => $register_email_again,\n            -password                  => $register_password,\n            -recaptcha_response_field  => $crf,\n        }\n    );\n\n    if ( $status == 0 ) {\n        my $p_errors = [];\n        for ( keys %$errors ) {\n            if ( $errors->{$_} == 1 ) {\n                push( @$p_errors, $_ );\n            }\n        }\n        $q->param( 'errors',                 $p_errors );\n        $q->param( 'error_profile_register', 1 );\n        return $self->profile_login();\n\n    }\n    else {\n        $prof->setup_profile( { -password => $register_password, } );\n        my $scrn = '';\n\n        $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'profile_register.tmpl',\n                -with   => 'list',\n                -vars   => {\n\n                    'profile.email' => $register_email,\n                }\n            }\n        );\n        return $scrn;\n\n    }\n}\n\n\n\n\nsub profile_activate { \n    my $self = shift;\n    my $q    = $self->query();\n\t\n\tif($q->request_method() =~ m/POST/i){\n\t\treturn $self->post_redirection(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_profile_activate.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\temail => $q->param('email'),\n\t\t\t\t\tauth_code => $q->param('auth_code'),\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n}\n\n\n\n\nsub post_profile_activate {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\n    require DADA::Profile;\n    if ( !DADA::Profile::feature_enabled('register') == 1 ) {\n        return $self->default();\n    }\n\t\n\t\n\tmy $email     = strip( cased( xss_filter( scalar $q->param('email') ) ) );\n    my $auth_code = xss_filter( scalar $q->param('auth_code') );\n\n    my $prof = DADA::Profile->new( { -email => $email } );\n\n    if ( $email && $auth_code ) {\n        my ( $status, $errors ) = $prof->is_valid_activation(\n            {\n                -auth_code => xss_filter( scalar $q->param('auth_code') ) || '',\n            }\n        );\n        if ( $status == 1 ) {\n            $prof->activate;\n            my $profile = $prof->get;\n            $q->param( 'welcome', 1 );\n            return $self->profile_login();\n        }\n        else {\n            my $p_errors = [];\n            for ( keys %$errors ) {\n                if ( $errors->{$_} == 1 ) {\n                    push( @$p_errors, $_ );\n                }\n            }\n            $q->param( 'errors', $p_errors );\n            $q->param( 'error_invalid_auth_code',\n                $errors->{invalid_auth_code} );\n            $q->param( 'error_profile_activate', 1 );\n            return $self->profile_login();\n        }\n    }\n    else {\n        return 'no email or auth code!';\n    }\n}\n\nsub profile {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $whole_url = $q->url( -path_info => 1, -query => 0 );\n    if ( exists( $ENV{QUERY_STRING} ) ) {\n        if ( length( $ENV{QUERY_STRING} ) > 0 ) {\n            $whole_url .= '?' . $ENV{QUERY_STRING};\n        }\n    }\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\t\n\t\n\t\n\n    require DADA::Profile::Session;\n    my $prof_sess = DADA::Profile::Session->new;\n\n    if ($prof_sess->is_logged_in( { -cgi_obj => $q } ) ) {\n\t\t\n\t\tif(length($q->param('process')) > 0) { \n\t\t\n\t\t\tif($prof_sess->check_csrf($q) == 0){\n\t\t\t\t$prof_sess->logout;\n\t\t\t\t$q->param('flavor', 'profile_login');\n\t\t\t\treturn $self->profile_login();\n\t\t\t}\n\t\t}\n\t\t\n        my $prof_data = $prof_sess->get( { -cgi_obj => $q } );\n\n        require DADA::Profile::Fields;\n        require DADA::Profile;\n\n        my $prof = DADA::Profile->new( { -email => $prof_data->{email} } );\n        my $dpf = DADA::Profile::Fields->new( { -email => $prof_data->{email} } );\n        my $subscriber_fields =\n          $dpf->{manager}->fields( { -show_hidden_fields => 0, } );\n        my $field_attr   = $dpf->{manager}->get_all_field_attributes;\n        my $email_fields = $dpf->get;\n\n        if ( $q->param('process') eq 'edit_subscriber_fields' ) {\n\n            my $edited = {};\n            for (@$subscriber_fields) {\n                $edited->{$_} = xss_filter( scalar $q->param($_) );\n\n                # This is better than nothing, but it's very lazy -\n                # Make sure that the length is less than 10k.\n                if ( length( $edited->{$_} ) > 10240 ) {\n\n                    # Sigh.\n                    die $DADA::CONFIG::PROGRAM_NAME . ' '\n                      . $DADA::Config::VER\n                      . ' Error! Attempting to save Profile Field with too large of a value!';\n                }\n            }\n\n# DEV: This is somewhat of a hack - so that we don't writeover hidden fields, we re-add them, here\n# A little kludgey.\n\n            for my $field (\n                @{ $dpf->{manager}->fields( { -show_hidden_fields => 1 } ) } )\n            {\n                if ( $field =~\n                    m/^$DADA::Config::HIDDEN_SUBSCRIBER_FIELDS_PREFIX/ )\n                {\n                    $edited->{$field} = $email_fields->{$field},;\n                }\n            }\n            $dpf->insert( { -fields => $edited, } );\n\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::PROGRAM_URL . '?flavor=profile&edit=1' );\n        }\n        elsif ( $q->param('process') eq 'change_password' ) {\n\n            if ( !DADA::Profile::feature_enabled('change_password') == 1 ) {\n\n                # warn 'feature disabled.';\n                return $self->default();\n            }\n            else {\n                #                # warn 'feature enabled!';\n            }\n\n            my $new_password = xss_filter( scalar $q->param('password') );\n            my $again_new_password =\n              xss_filter( scalar $q->param('again_password') );\n\n# DEV: See?! Why are we doing this manually? Can we use is_valid_registration() perhaps?\n            if ( length($new_password) > 0\n                && $new_password eq $again_new_password )\n            {\n                $prof->update( { -password => $new_password, } );\n                $q->param( 'password_changed', 1 );\n                $q->delete('process');\n\n                require DADA::Profile::Session;\n                my $prof_sess = DADA::Profile::Session->new->logout;\n\n                # DEV: This is going to get repeated quite a bit..\n                require DADA::Profile::Htpasswd;\n                foreach my $p_list ( @{ $prof->subscribed_to } ) {\n                    my $htp =\n                      DADA::Profile::Htpasswd->new( { -list => $p_list } );\n                    for my $id ( @{ $htp->get_all_ids } ) {\n                        $htp->setup_directory( { -id => $id } );\n                    }\n                }\n                #\n                return $self->profile_login();\n\n            }\n            else {\n                $q->param( 'errors',                 1 );\n                $q->param( 'errors_change_password', 1 );\n                $q->delete('process');\n                return $self->profile();\n            }\n\n        }\n        elsif ( $q->param('process') eq 'update_email' ) {\n\n            if ( !DADA::Profile::feature_enabled('update_email_address') == 1 )\n            {\n\n                return $self->default();\n            }\n\n # So, send the confirmation email for update to the NEW email address?\n # What if the OLD email address is activated? Guess we'll have to go with the\n # NEW email address. The only problem is if someone gains access to the account\n # changes the address as their own, etc.\n # But, they'd still need access to the account...\n\n            # So,\n            # * Send confirmation out\n            # * Display report if there are any problems.\n            #\n            # Old AND New address subscribed to a list:\n            #\n            # At the moment, if a subscriber is already subscribed, we\n            # can give the option (only option) to remove the old address\n            # And keep the current address :\n            #\n            # New Address isn't allowed to subscribe\n            #\n            # Keep old address, profile for old address will be gone\n            # Option to unsubscribe old address\n            # Option to tell list owner to unsubscribe old address? (Perhaps)\n            #\n\n            # If we haven't confirmed....\n\n            # Check to make sure the email address is valid.\n\n            # Valid? OK! send the confirmaiton email\n\n            # Not Valid? Geez we better tell someone.\n            my $updated_email =\n              cased( xss_filter( scalar $q->param('updated_email') ) );\n\n            # Oh. What if there is already a profile for this address?\n\n            my ( $status, $errors ) = $prof->is_valid_update_profile_email(\n                { -updated_email => $updated_email, } );\n            if ( $status == 0 ) {\n\n                my $p_errors = [];\n                for ( keys %$errors ) {\n                    if ( $errors->{$_} == 1 ) {\n\n                        #push(@$p_errors, $_);\n                        $q->param( 'error_' . $_, 1 );\n                    }\n                }\n\n                #\t$q->param('errors',              $p_errors);\n                $q->param( 'errors',              1 );\n                $q->param( 'process',             0 );\n                $q->param( 'errors_update_email', 1 );\n                $q->param( 'updated_email',       $updated_email );\n                return $self->profile();\n            }\n            else {\n\n                $prof->confirm_update_profile_email(\n                    { -updated_email => $updated_email, } );\n\n                my $info = $prof->get( { -dotted => 1 } );\n                my $scrn = '';\n\n                $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -with   => 'list',\n                        -screen => 'profile_update_email_auth_send.tmpl',\n                        -vars   => { %$info, }\n                    }\n                );\n                return $scrn;\n            }\n\n            # Oh! We've confirmed?\n\n# We've got to make sure that we can switch the email address in each\n# various list - perhaps the new address is blacklisted? Ack. that would be stinky\n# Another problem: What if the new email address is already subscribed?\n# May need a, \"replace\" function.\n# Sigh...\n\n            # That's it.\n        }\n        elsif ( $q->param('process') eq 'delete_profile' ) {\n\n            if ( !DADA::Profile::feature_enabled('delete_profile') == 1 ) {\n                return $self->default();\n            }\n            else {\n                $prof_sess->logout;\n                $prof->remove;\n\n                undef $prof;\n                undef $prof_sess;\n\n                $q->param( 'flavor',  'profile_login' );\n                $q->param( 'removal', 1 );\n\n                return $self->profile_login();\n            }\n        }\n        elsif ( $q->param('process') eq 'profile_delivery_preferences' ) {\n            my $list = xss_filter( scalar $q->param('list') );\n            my $delivery_prefs =\n              xss_filter( scalar $q->param('delivery_prefs') );\n\n            require DADA::Profile::Settings;\n            my $dps = DADA::Profile::Settings->new({-list => $list});\n            my $r   = $dps->save(\n                {\n                    -email   => $prof_data->{email},\n                    -setting => 'delivery_prefs',\n                    -value   => $delivery_prefs,\n                }\n            );\n            $self->header_type('redirect');\n            $self->header_props(\n                -url => $DADA::Config::PROGRAM_URL . '?flavor=profile&edit=1' );\n\n        }\n        else {\n\n            my $fields = [];\n            for my $field (@$subscriber_fields) {\n                push(\n                    @$fields,\n                    {\n                        name     => $field,\n                        label    => $field_attr->{$field}->{label},\n                        value    => $email_fields->{$field},\n                        required => $field_attr->{$field}->{required},\n                    }\n                );\n            }\n\n            my $subscriptions =\n              $prof->subscribed_to( { -html_tmpl_params => 1 } ),\n              my $filled          = [];\n            my $has_subscriptions = 0;\n\n            my $protected_directories = [];\n\n            for my $i (@$subscriptions) {\n\n                if ( $i->{subscribed} == 1 ) {\n                    $has_subscriptions = 1;\n                }\n\n                require DADA::MailingList::Settings;\n                my $ls =\n                  DADA::MailingList::Settings->new( { -list => $i->{list} } );\n\n                # Ack, this is very awkward:\n\n                #  Ack, this is very awkward:\n\n                my $li = DADA::Template::Widgets::webify_and_santize(\n                    {\n                        -vars        => $ls->get( -dotted => 1 ),\n                        -to_sanitize => [\n                            qw(list_settings.list_owner_email list_settings.info list_settings.privacy_policy )\n                        ],\n                    }\n                );\n\n                require DADA::Profile::Htpasswd;\n                my $htp =\n                  DADA::Profile::Htpasswd->new( { -list => $i->{list} } );\n                my $l_p_d = $htp->get_all_entries;\n                if ( scalar(@$l_p_d) > 0 ) {\n                    @$protected_directories =\n                      ( @$protected_directories, @$l_p_d );\n                }\n\n                require DADA::App::Subscriptions::Unsub;\n                my $dasu = DADA::App::Subscriptions::Unsub->new(\n                    { -list => $i->{list} } );\n                my $unsub_link = $dasu->unsub_link(\n                    { -email => $prof_data->{email}, -mid => '00000000000000' } );\n\n                my $digest_timeframe =\n                  formatted_runtime( $ls->param('digest_schedule') );\n\n                require DADA::Profile::Settings;\n                my $dps = DADA::Profile::Settings->new(\t\n\t\t\t\t\t{\n\t\t\t\t\t\t-list => $i->{list}\n\t\t\t\t\t}\n\t\t\t\t);\n                my $s   = $dps->fetch(\n                    {\n                        -email => $prof_data->{email},\n                    }\n                );\n                my $delivery_prefs = $s->{delivery_prefs} || 'individual';\n                push(\n                    @$filled,\n                    {\n                        %{$i},\n                        %{$li},\n                        PROGRAM_URL           => $DADA::Config::PROGRAM_URL,\n                        list_unsubscribe_link => $unsub_link,\n                        digest_timeframe      => $digest_timeframe,\n                        delivery_prefs        => $delivery_prefs,\n                    }\n                );\n            }\n\n            my $scrn = '';\n\n            $scrn .= DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'profile_home.tmpl',\n                    -with   => 'list',\n                    -expr   => 1,\n                    -vars   => {\n                        errors => scalar $q->param('errors')\n                          || 0,\n                        'profile.email'   => $prof_data->{email},\n\t\t\t\t\t\tcsrf_token        => $prof_data->{token},\n                        subscriber_fields => $fields,\n                        subscriptions     => $filled,\n                        has_subscriptions => $has_subscriptions,\n                        welcome           => scalar $q->param('welcome')\n                          || '',\n                        edit => scalar $q->param('edit')\n                          || '',\n                        errors_change_password =>\n                          scalar $q->param('errors_change_password')\n                          || '',\n                        errors_update_email =>\n                          scalar $q->param('errors_update_email')\n                          || '',\n                        error_invalid_email =>\n                          scalar $q->param('error_invalid_email')\n                          || '',\n                        error_profile_exists =>\n                          scalar $q->param('error_profile_exists')\n                          || '',\n                        updated_email => scalar $q->param('updated_email')\n                          || '',\n\n                        gravators_enabled =>\n                          $DADA::Config::PROFILE_OPTIONS->{gravatar_options}\n                          ->{enable_gravators},\n                        gravatar_img_url =>\n                          gravatar_img_url( { -email => $prof_data->{email}, } ),\n                        protected_directories => $protected_directories,\n                        WHOLE_URL             => $whole_url,\n                        %{ DADA::Profile::feature_enabled() },\n\n                    }\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n        $q->param( 'error_profile_login', 1 );\n        $q->param( 'errors', ['not_logged_in'] );\n        return $self->profile_login();\n    }\n\n}\n\nsub profile_logout {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\n    require DADA::Profile::Session;\n    my $prof_sess = DADA::Profile::Session->new;\n\n    $prof_sess->logout;\n    my $redirect_to =\n      $DADA::Config::PROGRAM_URL . '?flavor=profile_login&logged_out=1';\n\n    #if ( $q->referer() && $q->referer() !~ m/\\/profile\\// ) {\n    #    $redirect_to = $q->referer();\n    #}\n    my $headers = {\n        -cookie  => [ $prof_sess->logout_cookie ],\n        -nph     => $DADA::Config::NPH,\n        -Refresh => '0; URL=' . $redirect_to,\n    };\n    my $body = $q->start_html(\n        -title   => 'Logging Out...',\n        -BGCOLOR => '#FFFFFF'\n    );\n    $body .= $q->p( $q->a( { -href => $redirect_to }, 'Logging Out...' ) );\n    $body .= $q->end_html();\n\n    $self->header_props(%$headers);\n    return $body;\n}\n\n\n\n\n\nsub profile_reset_password { \n    my $self = shift;\n    my $q    = $self->query();\n\t\n\tif($q->request_method() =~ m/POST/i){\n\t\treturn $self->post_profile_reset_password(); \n\t}\n\telse { \n\t    my $scrn = DADA::Template::Widgets::screen(\n\t        {\n\t            -screen => 'postify_profile_reset_password.tmpl',\n\t\t\t\t-vars => { \n\t\t\t\t\temail     => $q->param('email'),\n\t\t\t\t\tauth_code => $q->param('auth_code'),\n\t\t\t\t}\n\t        }\n\t    );\n\t\treturn $scrn; \t\n\t}\n}\n\n\n\n\nsub post_profile_reset_password {\n\n    my $self  = shift;\n    my $q     = $self->query();\n    my $email = $q->param('email');\n\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1) {\n        return $self->default();\n    }\n\n    require DADA::Profile;\n    if ( !DADA::Profile::feature_enabled('password_reset') == 1 ) {\n        return $self->default();\n    }\n\n    my $reset_email = cased( xss_filter( scalar $q->param('reset_email') ) );\n    my $auth_code = xss_filter( scalar $q->param('auth_code') ) || undef;\n\n    if ($auth_code) {\n        $reset_email = $email;\n    }\n    require DADA::Profile;\n    my $prof = DADA::Profile->new( { -email => $reset_email } );\n\n    if ($reset_email) {\n\n        my $password = xss_filter( scalar $q->param('password') ) || undef;\n\n        if ($auth_code) {\n            my ( $status, $errors ) =\n              $prof->is_valid_activation( { -auth_code => $auth_code, } );\n            if ( $status == 1 ) {\n                if ( !$password ) {\n\n                    my $scrn = DADA::Template::Widgets::wrap_screen(\n                        {\n                            -screen => 'profile_reset_password.tmpl',\n                            -with   => 'list',\n                            -vars   => {\n                                email     => $reset_email,\n                                auth_code => $auth_code,\n                            }\n                        }\n                    );\n                    return $scrn;\n                }\n                else {\n                    # Reset the Password\n                    $prof->update( { -password => $password, } );\n\n                    # Reactivate the Account\n                    $prof->activate();\n\n             # Log The person in.\n             # Probably pass the needed stuff to profile_login via CGI's param()\n                    $q->param( 'login_email',    $reset_email );\n                    $q->param( 'login_password', $password );\n                    $q->param( 'process',        1 );\n\n                    # and just called the subroutine itself. Hazzah!\n                    return $self->profile_login();\n\n                    # Go home, kiss the wife.\n                }\n            }\n            else {\n\n                my $p_errors = [];\n                for ( keys %$errors ) {\n                    if ( $errors->{$_} == 1 ) {\n                        push( @$p_errors, $_ );\n                        $q->param( 'error_' . $_, 1 );\n                    }\n                }\n                $q->param( 'error_profile_reset_password', 1 );\n                $q->param( 'errors',                       $p_errors );\n                return $self->profile_login();\n            }\n        }\n        else {\n\n            if ( $prof->exists() ) {\n\n                $prof->send_profile_reset_password_email();\n                $prof->activate;\n\n                my $scrn = DADA::Template::Widgets::wrap_screen(\n                    {\n                        -screen => 'profile_reset_password_confirm.tmpl',\n                        -with   => 'list',\n                        -vars   => {\n                            email           => $reset_email,\n                            'profile.email' => $reset_email,\n                        }\n                    }\n                );\n                return $scrn;\n            }\n            else {\n                $q->param( 'error_profile_reset_password', 1 );\n                $q->param( 'error_unknown_user',           1 );\n                $q->param( 'errors', ['unknown_user'] );\n                $q->param( 'email', $reset_email );\n                return $self->profile_login();\n            }\n        }\n    }\n    else {\n\n        $self->header_type('redirect');\n        $self->header_props(\n            -url => $DADA::Config::PROGRAM_URL . '/profile_login/' );\n    }\n}\n\nsub profile_update_email {\n\n    my $self = shift;\n    my $q    = $self->query();\n\n    my $auth_code = xss_filter( scalar $q->param('auth_code') );\n    my $email     = cased( xss_filter( scalar $q->param('email') ) );\n    my $confirmed = xss_filter( scalar $q->param('confirmed') );\n\n    require DADA::Profile;\n\n    if ( !DADA::Profile::feature_enabled('update_email_address') == 1 ) {\n        return $self->default();\n    }\n\n    my $prof = DADA::Profile->new( { -email => $email } );\n    my $info = $prof->get;\n\n    my ( $status, $errors ) = $prof->is_valid_update_profile_activation(\n        { -update_email_auth_code => $auth_code, } );\n\n    if ( $status == 1 ) {\n\n        my $profile_info = $prof->get( { -dotted => 1 } );\n        my $subs = $prof->profile_update_email_report;\n\n        #require Data::Dumper;\n        #die Data::Dumper::Dumper($subs);\n        if ( $confirmed == 1 ) {\n\n            # This should probably go in the update_email method...\n            require DADA::MailingList::Subscribers;\n            for my $in_list (@$subs) {\n                my $lh = DADA::MailingList::Subscribers->new(\n                    { -list => $in_list->{'list_settings.list'}, } );\n                $lh->remove_subscriber(\n                    {\n                        -email => cased( $profile_info->{'profile.email'} ),\n                        -type  => 'list'\n                    }\n                );\n                $lh->add_subscriber(\n                    {\n                        -email =>\n                          cased( $profile_info->{'profile.update_email'} ),\n                        -type => 'list'\n                    }\n                );\n\t\t\t\t$prof->update_email({-list => $in_list->{'list_settings.list'}});\n            }\n           \n\t\t   \n            #/ This should probably go in the update_email method...\n\t\t\t\n            $prof->send_update_email_notification(\n                { -prev_email => cased( $profile_info->{'profile.email'} ), } );\n\n            # Now, just log us in:\n            require DADA::Profile::Session;\n            my $prof_sess = DADA::Profile::Session->new;\n            if ( $prof_sess->is_logged_in ) {\n                $prof_sess->logout;\n            }\n            undef $prof_sess;\n\n            my $prof_sess = DADA::Profile::Session->new;\n            my $cookie    = $prof_sess->login(\n                {\n                    -email           => $profile_info->{'profile.update_email'},\n                    -no_pass         => 1,\n                \t-skip_validation => 1, \n\t\t\t\t\t\n                }\n            );\n\n            my $headers = {\n                -cookie  => [$cookie],\n                -nph     => $DADA::Config::NPH,\n                -Refresh => '0; URL='\n                  . $DADA::Config::PROGRAM_URL\n                  . '/profile/'\n            };\n            my $body = $q->start_html(\n                -title   => 'Logging in...',\n                -BGCOLOR => '#FFFFFF'\n            );\n            $body .= $q->p(\n                $q->a(\n                    { -href => $DADA::Config::PROGRAM_URL . '/profile/' },\n                    'Logging in...'\n                )\n            );\n            $body .= $q->end_html();\n\n            $self->header_props(%$headers);\n            return $body;\n        }\n        else {\n\n            # I should probably also just, log this person in...\n\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen => 'profile_update_email_confirm.tmpl',\n                    -with   => 'list',\n                    -vars   => {\n                        auth_code     => $auth_code,\n                        subscriptions => $subs,\n                        %$profile_info,\n                    },\n                }\n            );\n            return $scrn;\n        }\n    }\n    else {\n\n        # DEV: Currently there is no description of what the error is, just\n        # that, \"there is one\". Perhaps change that?\n        #\n\n        my $ht_errors = [];\n        for ( keys %$errors ) {\n            push( @$ht_errors, { name => $_, value => $errors->{$_} } );\n        }\n\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen => 'profile_update_email_error.tmpl',\n                -with   => 'list',\n                -vars   => {\n                    errors => $ht_errors,\n                },\n            }\n        );\n        return $scrn;\n\n    }\n}\n\nsub also_save_for_settings {\n    my $self = shift;\n    my $q    = $self->query();\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      DADA::App::Guts::check_list_security( -cgi_obj => $q, );\n    if ( $root_login != 1 ) {\n        return \"\";\n    }\n    else {\n        my $list = $admin_list;\n        my $form_id = $q->param('form_id') // undef;\n\n        my $ht_lists = [];\n        my @lists    = available_lists();\n        foreach (@lists) {\n            my $ls = DADA::MailingList::Settings->new( { -list => $_ } );\n            push(\n                @$ht_lists,\n                $ls->get(\n                    {\n                        #-dotted => 1\n                    }\n                )\n            );\n        }\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'also_save_for_settings.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    current_list => $list,\n                    lists        => $ht_lists,\n                    form_id      => $form_id,\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n}\n\nsub transform_to_pro {\n\n    my $self    = shift;\n    my $q       = $self->query();\n    my $process = $q->param('process') || undef;\n    my $done    = $q->param('done') || undef;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'transform_to_pro'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $list = $admin_list;\n    require DADA::MailingList::Settings;\n    my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n\n    if ( !$process ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'transform_to_pro.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n\n                -expr => 1,\n                -vars => {\n                    screen => 'transform_to_pro',\n                    title  => 'Transform into Pro Dada',\n                    list   => $list,\n                    done   => $done,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $process eq 'verify' ) {\n\n        my ( $cstatus, $cerrors, $receipt ) = $self->contact_mothership(\n            {\n                action            => 'verify',\n                pro_dada_username => $q->param('pro_dada_username'),\n                pro_dada_password => $q->param('pro_dada_password'),\n            }\n        );\n\n        my $ht_errors = {};\n        if ( keys %$cerrors ) {\n            $ht_errors->{ 'error_' . $_ } = 1;\n        }\n\n        my $scrn = DADA::Template::Widgets::screen(\n            {\n                -screen => 'transform_to_pro_verify.tmpl',\n                -expr   => 1,\n                -vars   => {\n                    list              => $list,\n                    status            => $cstatus,\n                    pro_dada_username => $q->param('pro_dada_username'),\n                    pro_dada_password => $q->param('pro_dada_password'),\n                    error_code        => Data::Dumper::Dumper(\n                        {\n                            status  => $cstatus,\n                            errors  => $cerrors,\n                            receipt => $receipt\n                        }\n                    ),\n                    %{$ht_errors},\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $process eq 'upgrade' ) {\n\n        my ( $cstatus, $cerrors, $receipt ) = $self->contact_mothership(\n            {\n                action            => 'transform',\n                pro_dada_username => $q->param('pro_dada_username'),\n                pro_dada_password => $q->param('pro_dada_password'),\n            }\n        );\n\n        if ( $cstatus == 0 ) {\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=transform_to_pro&process=failure' );\n            return;\n        }\n\n        my $config_file       = make_safer($DADA::Config::CONFIG_FILE);\n        my $pro_dada_username = $q->param('pro_dada_username');\n\n        my $config_chunk = qq{\n\t\t\t\n\t\t\t\n# Thank you for being a Pro Dada customer, $pro_dada_username!\n# RECEIPT: $receipt\n\\$PROGRAM_NAME                 = 'Pro Dada';\n\\$GIVE_PROPS_IN_EMAIL          = 0;\n\\$GIVE_PROPS_IN_HTML           = 0;\n\\$GIVE_PROPS_IN_ADMIN          = 0;\n\\$GIVE_PROPS_IN_SUBSCRIBE_FORM = 0;\n\\$PROGRAM_IMG_FILENAME         = 'pro_dada_mail_logo.png';\n\\$LIST_QUOTA                   = 0;\n\\$SUBSCRIPTION_QUOTA           = 0;\n\n};\n        my $status = 1;\n        my $error  = undef;\n        try {\n\n            # Let's be careful about this:\n            my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst )\n              = localtime(time);\n            my $timestamp =\n              sprintf( \"%4d-%02d-%02d\", $year + 1900, $mon + 1, $mday ) . '-'\n              . time;\n            my $config_file_backup =\n              make_safer( $config_file . '-backup-' . $timestamp );\n            require File::Copy;\n            my $r = File::Copy::copy( $config_file, $config_file_backup )\n              or warn\n\"Copy failed - From: $config_file, To: $config_file_backup, Error:$!\";\n\n            open my $config, '>>', $config_file or die $!;\n            print $config $config_chunk or die $!;\n            close $config or die;\n        }\n        catch {\n            $status = 0;\n            $error  = $_;\n            warn $_;\n        };\n        if ( $status == 1 ) {\n\n            $c->flush;\n            $self->header_type('redirect');\n            $self->header_props( -url => $DADA::Config::S_PROGRAM_URL\n                  . '?flavor=transform_to_pro&process=success' );\n        }\n        else {\n            my $scrn = DADA::Template::Widgets::wrap_screen(\n                {\n                    -screen         => 'transform_to_pro_failure.tmpl',\n                    -with           => 'admin',\n                    -wrapper_params => {\n                        -Root_Login => $root_login,\n                        -List       => $list,\n                    },\n                    -expr => 1,\n                    -vars => {\n                        list => $list,\n\n                        # receipt         => $receipt,\n\n                    },\n                    -list_settings_vars_param => {\n                        -list   => $list,\n                        -dot_it => 1,\n                    },\n\n                }\n            );\n            return $scrn;\n        }\n    }\n    elsif ( $process eq 'success' ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'transform_to_pro_success.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    list => $list,\n\n                    # receipt         => $receipt,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    elsif ( $process eq 'failure' ) {\n        my $scrn = DADA::Template::Widgets::wrap_screen(\n            {\n                -screen         => 'transform_to_pro_failure.tmpl',\n                -with           => 'admin',\n                -wrapper_params => {\n                    -Root_Login => $root_login,\n                    -List       => $list,\n                },\n                -expr => 1,\n                -vars => {\n                    list => $list,\n\n                },\n                -list_settings_vars_param => {\n                    -list   => $list,\n                    -dot_it => 1,\n                },\n\n            }\n        );\n        return $scrn;\n    }\n    else {\n        return \"unknown process - huh?\"\n\n    }\n\n}\n\n# Need to send back a recipt number\nsub contact_mothership {\n    my $self = shift;\n    my ($args) = @_;\n\n    my $status  = 0;\n    my $errors  = {};\n    my $receipt = 'UNDEFINED';\n\n    my $gargs = {};\n    for (\n        qw(\n        action\n        pro_dada_username\n        pro_dada_password\n        )\n      )\n    {\n        $gargs->{$_} = $args->{$_};\n    }\n    try {\n        require JSON;\n        require HTTP::Request;\n        require HTTP::Request::Common;\n        require LWP::UserAgent;\n\n        my $ua = LWP::UserAgent->new;\n\n        my $json = JSON->new->allow_nonref;\n\n        $gargs->{rm} = 'verify_pro_dada_user_status';\n\n        my $ver = $DADA::Config::VER;\n        $ver =~ s/ (.*?)$//;\n        $gargs->{program_version} = $ver;\n        $gargs->{program_url}     = $DADA::Config::PROGRAM_URL;\n\n        my $response = $ua->request(\n            HTTP::Request::Common::POST(\n                'https://dadamailproject.com/pro_dada/cpdus.cgi',\n                content => $gargs,\n            )\n        );\n\n        if ( $response->is_success ) {\n            my $r = $json->utf8->decode( $response->decoded_content );\n\n            # print Dumper($r);\n            if ( $r->{status} == 1 ) {\n\n                # print \"Success!\\n\";\n            }\n            else {\n                # print \"Problems!\\n\";\n            }\n            $status  = $r->{status};\n            $errors  = $r->{errors};\n            $receipt = $r->{receipt};\n        }\n        else {\n            die 'problem with Pro Dada account verification'\n              . $response->decoded_content;\n        }\n    }\n    catch {\n        #warn $_;\n        $status = 0;\n        $errors->{communication_problem} = 1;\n    };\n    return ( $status, $errors, $receipt );\n}\n\n\n\nsub plugins {\n    my $self   = shift;\n    my $q      = $self->query();\n    my $plugin = $q->param('plugin');\n    my ( $headers, $body );\n    if ( exists( $DADA::Config::PLUGINS_ENABLED->{$plugin} ) ) {\n        if ( $DADA::Config::PLUGINS_ENABLED->{$plugin} != 1 ) {\n            return 'Plugin disabled.';\n        }\n        eval {\n            require 'plugins/' . $plugin;\n            ( $headers, $body ) =\n              $DADA::Config::PLUGIN_RUNMODES->{$plugin}->{run}->($q);\n        };\n        if ( !$@ ) {\n            if ( exists( $headers->{-redirect_uri} ) ) {\n                $self->header_type('redirect');\n                $self->header_props( -url => $headers->{-redirect_uri} );\n            }\n            else {\n                if ( keys %$headers ) {\n                    $self->header_props(%$headers);\n                }\n                return $body;\n            }\n        }\n        else {\n            return ($@);\n        }\n    }\n    else {\n        return \"plugin not registered.\";\n    }\n\n}\n\nsub bridge_inject {\n\n    my $self = shift;\n    my $r;\n\n    $ENV{CGI_APP_RETURN_ONLY} = 1;\n\n    if ( $DADA::Config::PLUGINS_ENABLED->{bridge} != 1 ) {\n        return 'Plugin disabled.';\n    }\n    my $run_list = $self->param('run_list');\n\n    if ( !defined($run_list) ) {\n        $r .= 'No List Defined.';\n    }\n    require 'plugins/bridge';\n\n# One problem with this is that we don't know the encoding of the message.\n# If it's 8bit, and ISO-whatever, we're in trouble\n# We could read the full msg in, and change the encoding, THEN Tag the message in that encoding.\n# Sounds message.\n\n    require DADA::Security::Password;\n    my $filename =\n        $DADA::Config::TMP\n      . \"/tmp_file\"\n      . DADA::Security::Password::generate_rand_string() . \"-\"\n      . time . \".txt\";\n    open my $tmp_file, '>:encoding(' . $DADA::Config::HTML_CHARSET . ')',\n      $filename\n      or die $!;\n\n#   open my $tmp_file2, '>:encoding(' . $DADA::Config::HTML_CHARSET . ')', $filename . '2' or die $!;\n\n    my $msg;\n\n    # binmode(STDIN,  \":utf8\");\n    # binmode STDIN;\n    while ( my $line = <STDIN> ) {\n\n        #        $line = safely_decode($line);\n        #        $line = safely_encode($line);\n\n        print $tmp_file $line;\n\n        #        print $tmp_file2 $line;\n    }\n    close $tmp_file or die $!;\n\n    #   close $tmp_file2 or die $!;\n\n    chmod( $DADA::Config::FILE_CHMOD, $filename );\n\n    $r .= bridge::inject_msg(\n        {\n            -filename => $filename,\n            -list     => $run_list,\n        }\n    );\n\n}\n\nsub schedules {\n\n    # Just need to document this\n    # and figure out inject stuff.... sigh.\n\n    my $self = shift;\n\tmy ($args) = @_; \n\tif(!exists($args->{-at_teardown})){ \n\t\t$args->{-at_teardown} = 0; \n\t}\n\t\n    my $q    = $self->query;\n\n    my $t = time;\n    my $tz = strftime(\"%Z\", localtime()); \n\n\n    my $list         = $q->param('list')         || '_all';\n    my $schedule     = $q->param('schedule')     || '_all';\n    my $output_mode  = $q->param('output_mode')  || '_verbose';\n    my $for_colorbox = $q->param('for_colorbox') || 0;\n\n    my $r;\n    $r .= \"Started: \" . scalar localtime($t) . ' ' . $tz .\"\\n\";\n\t\n\t$r .= 'PID: ' . \"$$\\n\";\n\t\t\n\tmy $user = $ENV{ LOGNAME } || $ENV{ USER } || $ENV{ USERNAME } || getlogin || getpwuid( $< );\n\t\n\t\n\tif(defined($user)) {\n\t\t$r .= 'Running as uid:, ' . $user . \"\\n\";\n\t}\n\telse  {\n\t\t$r .= 'Running as unknown uid' . \"\\n\";\n\t}\n\t\n\tif($args->{-at_teardown} == 1){ \n\t\t$r .= \"Running after regular script execution.\\n\";\n\t}\n\telse { \n\t\t$r .= \"Running as dedicated schedule.\\n\";\t\t\n\t}\n\n    require DADA::App::ScheduledTasks;\n    my $dast = DADA::App::ScheduledTasks->new;\n\n    my $lock = $dast->lock_file();\n    if ( !defined($lock) ) {\n\t\t$r .= \"Scheduled Tasks may be running in a different process, stopping.\\n\";\n\t\twarn \"PID: $$ Scheduled Tasks may be running in a different process, stopping.\\n\";\n\t\t\n    }\n\telse {\n\t\t\n\t    if ( $schedule eq '_all' ) {\n\t        $r .= \"\\nMonitor:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->mass_mailing_monitor($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\n\t        $r .= \"Mass Mailing Schedules:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->scheduled_mass_mailings($list);\n\t        } catch {\n\t        \t$r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\n\t        $r .= \"Rate Limits:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->expire_rate_limit_checks($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\n\t        $r .= \"Cleaning Out MIME Cache:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->clean_out_mime_cache();\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\t\n\t        $r .= \"\\nRemoving old archive messages:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_archive_messages($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\t\n\t        $r .= \"\\nRemoving old tracker data:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_tracker_data($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t\t\t\n\n\t        $r .= \"\\nSending Analytics Email Notification:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->send_analytics_email_notification($list);\n\t        } catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\t\t  \n\n\t        for my $plugin ( keys %$DADA::Config::PLUGINS_ENABLED ) {\n\t            if ( exists( $DADA::Config::PLUGINS_ENABLED->{$plugin} ) ) {\n\t                next if ( $DADA::Config::PLUGINS_ENABLED->{$plugin} != 1 );\n\t                next\n\t                  if !\n\t                  exists(\n\t                    $DADA::Config::PLUGIN_RUNMODES->{$plugin}->{sched_run} );\n\t                $r .= \"Plugin: $plugin\\n\" . '-' x 72 . \"\\n\";\n\t                try {\n\t                    require 'plugins/' . $plugin;\n\t                    $r .= $DADA::Config::PLUGIN_RUNMODES->{$plugin}->{sched_run}\n\t                      ->($list);\n\t                }\n\t                catch {\n\t                    $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t                };\n\t            }\n\t        }\n\t    }\n\t    elsif ( $schedule eq 'mass_mailing_monitor' ) {\n\t        $r .= \"Monitor:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->mass_mailing_monitor($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'rate_limit_checks' ) {\n\t        $r .= \"Rate Limits:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->expire_rate_limit_checks($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'mime_cache' ) {\n\t        $r .= \"Cleaning Out MIME Cache:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->clean_out_mime_cache();\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'remove_old_archive_messages' ) {\n\t        $r .= \"Removing out old archive messages:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_archive_messages($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'remove_old_tracker_data' ) {\n\t        $r .= \"Removing out old tracker data:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->remove_old_tracker_data($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\n\t    elsif ( $schedule eq 'send_analytics_email_notification' ) {\n\t        $r .= \"Sending Analytics Email Notification:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->send_analytics_email_notification($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ( $schedule eq 'scheduled_mass_mailings' ) {\n\t        $r .= \"Mass Mailing Schedules:\\n\" . '-' x 72 . \"\\n\";\n\t        try {\n\t            $r .= $dast->scheduled_mass_mailings($list);\n\t        }\n\t        catch {\n\t            $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t        };\n\t    }\n\t    elsif ($schedule eq 'bridge'\n\t        || $schedule eq 'bounce_handler' )\n\t    {\n\t        if ( $DADA::Config::PLUGINS_ENABLED->{$schedule} != 1 ) {\n\n\t            #....\n\t        }\n\t        else {\n\n\t            $r .= \"Plugin: $schedule\\n\" . '-' x 72 . \"\\n\";\n\n\t            try {\n\t                require 'plugins/' . $schedule;\n\t                $r .= $DADA::Config::PLUGIN_RUNMODES->{$schedule}->{sched_run}\n\t                  ->($list);\n\t            }\n\t            catch {\n\t                $r .= \"* Error: \" . substr($_, 0, 100) . '...' . \"\\n\";\n\t            };\n\t        }\n\t    }\n\t    else {\n\t        $r .= 'No such schedule:\"' . $schedule . '\"';\n\t    }\n\t}\n\t\n\tif(defined($lock)){\n\t\t$dast->unlock_file($lock);\n\t}\n\t\n\tundef($dast);\n\t\n    my $end_t   = time;\n    my $total_t = $end_t - $t;\n    $r .= \"Finished: \" . scalar localtime($end_t) . ' ' . $tz . \"\\n\";\n    $r .= \"Total processing time: \" . formatted_runtime($total_t) . \"\\n\";\n\n    if ( $DADA::Config::SCHEDULED_JOBS_OPTIONS->{'log'} == 1 ) {\n        require DADA::Logging::Usage;\n        my $log = new DADA::Logging::Usage;\n        $log->cron_log($r);\n    }\n\n    my @lists = available_lists( -In_Order => 1 );\n    if ( scalar @lists >= 1 ) {\n        require DADA::MailingList::Settings;\n        my $ls = DADA::MailingList::Settings->new( { -list => $lists[0] } );\n        $ls->save(\n            {\n                -settings => {\n                    scheduled_jobs_last_ran => time,\n                }\n            }\n        );\n    }\n\n    if ( $output_mode ne '_silent' ) {\n        $self->header_props( { -type => 'text/plain' } );\n        if ( $for_colorbox == 1 ) {\n            return '<pre><small>' . $r . '</small></pre>';\n        }\n        else {\n            # $ENV{CGI_APP_RETURN_ONLY} = 1;\n            return $r;\n        }\n    }\n    else {\n        return '';\n    }\n}\n\nsub scheduled_jobs {\n\n    my $self = shift;\n    my $q    = $self->query;\n\n    my ( $admin_list, $root_login, $checksout, $error_msg ) =\n      check_list_security(\n        -cgi_obj  => $q,\n        -Function => 'send_email'\n      );\n    if ( !$checksout ) { return $error_msg; }\n\n    my $curl_location = `which curl`;\n\n    my $scrn = DADA::Template::Widgets::wrap_screen(\n        {\n            -screen         => 'scheduled_jobs.tmpl',\n            -with           => 'admin',\n            -wrapper_params => {\n                -Root_Login => $root_login,\n                -List       => $admin_list,\n            },\n            -expr => 1,\n            -vars => {\n                scheduled_jobs_flavor => $DADA::Config::SCHEDULED_JOBS_OPTIONS\n                  ->{scheduled_jobs_flavor},\n                curl_location => $curl_location,\n            },\n        }\n    );\n}\n\nsub DESTROY {\n\n    # warn 'DADA::App::DESTROY called.';\n}\n\nsub END { }\n\n1;\n\n__END__\n\n=pod\n\n=head1 COPYRIGHT\n\nCopyright (c) 1999 - 2020 Justin Simoni All rights reserved. \n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n=cut\n\n", "package DADA::Profile::Session;\n\nuse lib qw (../../ ../../../DADA/perllib);\nuse strict;\nuse Carp qw(carp croak);\nuse DADA::Config;\nuse DADA::App::Guts; \nuse CGI::Session;\nCGI::Session->name('dada_profile');\nuse Carp qw(carp croak); \n\nmy $t = $DADA::Config::DEBUG_TRACE->{DADA_Profile_Session};\n\nsub new {\n\n    my $class = shift;\n    my ($args) = @_;\n\n    my $self = {};\n    bless $self, $class;\n    $self->_init($args);\n    return $self;\n\n}\n\nsub _init {\n\n    my $self = shift;\n    my ($args) = @_;\n    $self->{list} = $args->{ -list };\n\tmy $dbh     = undef; \n\tmy $dbi_obj = undef; \n\t\t\n    require DADA::App::DBIHandle;\n       $dbi_obj = DADA::App::DBIHandle->new;\n       $dbh     = $dbi_obj->dbh_obj; \n\t\n    # http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session.pm\n\n\n        if ( $DADA::Config::SQL_PARAMS{dbtype} eq 'Pg' ) {\n\n# http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session/Driver/postgresql.pm\n            $self->{dsn}      = 'driver:PostgreSQL';\n            $self->{dsn_args} = {\n\n                Handle    => $dbh,\n                TableName => $DADA::Config::SQL_PARAMS{session_table},\n\n            };\n\n        }\n        elsif ( $DADA::Config::SQL_PARAMS{dbtype} eq 'mysql' ) {\n\n  # http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session/Driver/mysql.pm\n            $self->{dsn}      = 'driver:mysql';\n            $self->{dsn_args} = {\n\n                Handle    => $dbh,\n                TableName => $DADA::Config::SQL_PARAMS{session_table},\n\n            };\n\n        }\n        elsif ( $DADA::Config::SQL_PARAMS{dbtype} eq 'SQLite' ) {\n\n            # http://search.cpan.org/~bmoyles/CGI-Session-SQLite/SQLite.pm\n            $self->{dsn} =\n              'driver:SQLite:'\n              ;    # . ':' . $DADA::Config::FILES . '/' . $database;;\n            $self->{dsn_args} = {\n\n                Handle => $dbh,\n\t\t\t\tTableName => $DADA::Config::SQL_PARAMS{session_table},\n\n            };\n\n        }\n}\n\nsub _login_cookie {\n\n    my $self = shift;\n    my ($args) = @_;\n\n\trequire CGI; \n    my $q = new CGI; \n\n    my $cookie;\n\n    require CGI::Session;\n\n\tuse DADA::Security::Password; \n\n\tmy $token = DADA::Security::Password::generate_rand_string(undef, 41); \n\n    my $session = new CGI::Session( $self->{dsn}, $q, $self->{dsn_args} );\n\n       $session->param( 'email',      cased($args->{ -email }) );\n       $session->param( '_logged_in', 1 );\n       $session->param( 'token',      $token);\n\t\n\n\t    $session->expire( $DADA::Config::COOKIE_PARAMS{ -expires } );\n\t    $session->expire( '_logged_in', $DADA::Config::COOKIE_PARAMS{ -expires } );\n\t    $session->expire( 'token', $DADA::Config::COOKIE_PARAMS{ -expires } );\n\n    $cookie = $q->cookie( \n\t\t%{$DADA::Config::PROFILE_OPTIONS->{cookie_params}},\n\t\t-value => $session->id, \n\t\t($DADA::Config::PROGRAM_URL =~ m/^https/) ? (\n\t\t\t-secure  => 1,\n\t\t) : ()\n\t\t\n\t\t);\n    $session->flush();\n\n    return $cookie;\n}\n\nsub login {\n\n\n    my $self = shift;\n    my ($args) = @_;\n\n\trequire CGI; \n\tmy $q = new CGI; \n\n\tmy ($status, $errors);\n\t\n\tif($args->{-skip_validation} == 0){ \n\t    ( $status, $errors ) = $self->validate_profile_login($args);\n\t}\n\telse { \n\t\t$status = 1; \n\t\t$errors = {};\n\t}\n\t\n    if ( $status == 0 ) {\n        croak \"login failed.\";\n    }\n    else {\n        my $cookie = $self->_login_cookie($args);\n        return $cookie;\n    }\n}\n\nsub logout {\n\n    my $self = shift;\n    my ($args) = @_;\n\n\trequire CGI; \n\tmy $q = new CGI; \n\n    if ( $self->is_logged_in($args) ) {\n        my $s = new CGI::Session( $self->{dsn}, $q, $self->{dsn_args} );\n        $s->delete;\n        $s->flush;\n        return 1;\n    }\n    else {\n        carp 'profile was never logged in!';\n        return 0;\n    }\n}\n\nsub logout_cookie { \n\n\tmy $self = shift; \n\t\n\trequire CGI; \n\tmy $q = new CGI;\n\t\n\tmy $cookie = $q->cookie(\n\t\t\t\t-name    =>  $DADA::Config::PROFILE_OPTIONS->{cookie_params}->{-name},\n\t\t\t\t-value   =>  '',\n\t\t\t\t-path    =>  '/',\n\t);\n\treturn $cookie;\n}\n\n\nsub validate_profile_login {\n    my $self = shift;\n    my ($args) = @_;\n\t\n\t$args->{ -email } = cased($args->{ -email });\n\t\n    my $status = 1;\n    my $errors = {\n        unknown_user   => 0,\n        incorrect_pass => 0,\n    };\n\n\n    require DADA::Security::SimpleAuthStringState;\n    my $sast       = DADA::Security::SimpleAuthStringState->new;\n    my $auth_state = $args->{-auth_state};\n\n    if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n        if ( $sast->check_state($auth_state) != 1 ) {\n\t        $status = 0;\n\t        $errors->{invalid_form} = 1;\n        }\n\n    }\n\n\n    require DADA::Profile;\n    my $prof = DADA::Profile->new(\n\t\t{ \n\t\t\t-email => $args->{ -email } \n\t\t} \n\t);\n    \n    \n\tif ( $prof->exists == 1 ) {\n        # ...\n    }\n    else {\n        $status = 0;\n        $errors->{unknown_user} = 1;\n    }\n\t\n\tif($args->{-no_pass} == 1){ \n\t\t# ... \n\t}\n\telse { \n \t   if ( $prof->is_valid_password($args) ) {\n\n\t        # ...\n\t    }\n\t    else {\n\t        $status = 0;\n\t        $errors->{incorrect_pass} = 1;\n\t\n\t    }\n\t}\n\n    return ( $status, $errors );\n\n}\n\nsub check_csrf { \n\tmy $self = shift; \n\tmy $q    = shift; \n\t\n    my $s = CGI::Session->load( $self->{dsn}, $q, $self->{dsn_args} )\n      or croak 'failed to load session: ' . CGI::Session->errstr();\n\t\n      if ( $s->is_expired ) {\n          return 0;\n      }\n\n      if ( $s->is_empty ) {\n          return 0;\n      }\n\t\n\t  if($q->param('csrf_token') eq $s->param('token') ){ \n\t\t  return 1; \n\t  }\n\t  else { \n\t\t  return 0; \n\t  }\n\t\n\n}\nsub is_logged_in {\n\n    my $self = shift;\n    my ($args) = @_;\n    my $q;\n    if ( exists( $args->{ -cgi_obj } ) ) {\n        $q = $args->{ -cgi_obj };\n    }\n    else {\n        require CGI;\n        $q = new CGI;\n\n    }\n\t\n\t\n    my $s = CGI::Session->load( $self->{dsn}, $q, $self->{dsn_args} )\n      or croak 'failed to load session: ' . CGI::Session->errstr();\n\n    if ( $s->is_expired ) {\n        return 0;\n    }\n\n    if ( $s->is_empty ) {\n        return 0;\n    }\n\n    if ( $s->param('_logged_in') == 1 ) {\n\t\n\t\t# Something's wrong with this, but I don't know yet, yet: \n\t\t# \n\t\t#require DADA::Profile;\n\t    #my $prof = DADA::Profile->new( { -email => $self->get }  );\n\t\t#\n\t    #if ( $prof->exists == 1 ) {\n\t    #   return 1;\n\t    #}\n\t    #else {\n\t    #     return 0;\n\t    #}\n\t\treturn 1; \n    }\n    else {\n        return 0;\n    }\n\n}\n\nsub get {\n\n    my $self = shift;\n    my ($args) = @_;\n    my $q;\n    require CGI;\n    $q = new CGI;\n    require CGI::Session;\n\n    my $session = new CGI::Session( $self->{dsn}, $q, $self->{dsn_args} );\n    return {\n\t\temail => $session->param('email'), \n\t\ttoken => $session->param('token'),\n\t}; \n\n}\n\nsub reset_password {} # ??? \n\n1;\n\n\n=pod\n\n=head1 NAME \n\nDADA::Profile::Session\n\n=head1 SYNOPSIS\n\n=head1 DESCRIPTION\n\n=head1 Public Methods\n\n=head2 new\n\n\tmy $prof_sess = DADA::Profile::Session->new\n\nC<new> returns a DADA::Profile::Session object. \n\nC<new> does not take any parameters and returns a C<DADA::Profile::Session> object. \n\n=head2 login\n\n\tmy $cookie = $prof_sess->login(\n\t\t{ \n\t\t\t-email    => scalar $q->param('email'),\n\t\t\t-password => scalar $q->param('password'), \n\t\t},\n\t);\n\nC<login> saves the session information for the profile, as well as returns a cookie, so that the state can be fetched later. \n\nIt requires two arguments: \n\nC<-email> should hold the email address associated with the profile that you'd like to login. \n\nC<-password> should hold the correct password associated with the user. \n\nThis method will croak if the login information (user/password) is incorrect. Use C<validate_profile_login()> before trying to login. \n\n=head2 logout\n\n $prof_sess->logout;\n\nC<logout> removes the session state information. It'll return C<1> on success and C<0> on failure. Usually, a failure will happen \nif the profile is not actually logged in. \n\n=head2 validate_profile_login\n\n\tmy ($status, $errors) = $prof_sess->validate_profile_login(\n\t\t{ \n\t\t\t-email    => scalar $q->param('email'),\n\t\t\t-password => scalar $q->param('password'), \n\t\t\n\t\t},\n\t);\n\nC<validate_profile_login> is used to make sure the login information you give is valid. \n\nIt requires two parameters: \n\nC<-email> should be the email address associated with the profile. \n\nC<-password> should be the profile associated with the profile. \n\nIt'll return a two-element array. The first is the status and will be set to either, \nC<1> or C<0>, with C<1> meaning that no problems were encountered. If the status is set \nto, C<0>, then problems were encountered. Any problems will be described in the second element of the \narray. This should be a hashref of key/value pairs. The keys will describe the error and the value would \nbe set to, C<1> if the error was found. \n\nHere's the following keys that may be returned: \n\n=over\n\n=item * unknown_user\n\nThe email address passed in, C<-email> doesn't have a profile. \n\n=item * incorrect_pass\n\nThe password passed in, C<-password> isn't correct for the email address passed in, C<-email> \n\n=back\n\n=head2 is_logged_in\n\n my $logged_in = $prof_sess->is_logged_in; \n\nC<is_logged_in> returns C<1> if a profile is logged in, or C<0> if it is not. \n\nC<is_logged_in> does not need any arguments. \n\n=head2 get \n\n my $email = $prof_sess->get; \n\nC<get> returns the email address associated with the profile that is logged in. \n\nMost likely, if the profile is not logged in, C<undef> will be returned. \n\n=head1 AUTHOR\n\nJustin Simoni https://dadamailproject.com\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (c) 1999 - 2020 Justin Simoni All rights reserved. \n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, \nBoston, MA  02111-1307, USA.\n\n=cut \n\n\n", "package DADA::Template::Widgets;\nuse lib qw(\n\t../../../ \n\t../../../DADA/perllib\n); \n\nuse Encode; \nuse Try::Tiny; \nuse Carp qw(croak carp); \n\nuse DADA::Config qw(!:DEFAULT);  \n\nuse constant HAS_HTML_TEMPLATE_PRO => eval { require HTML::Template::Pro; 1; }; \n\nmy $TMP_TIME = undef; \nuse POSIX; \n\nBEGIN {\n   if($] > 5.008){\n      require Errno;\n      require Config;\n   }\n}\n\n\nuse DADA::App::Guts; \nmy $q; \n\nlame_init(); \n\nmy $wierd_abs_path = __FILE__; \n   $wierd_abs_path =~ s{^/}{}g;\n\nmy @guesses; \nmy $Templates; \n\nif(! $DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH ){ \n\n\teval { require File::Spec };\n\t\n\tif(!$@){\n\n\t   $Templates  =  File::Spec->rel2abs($wierd_abs_path);\n\t   $Templates  =~ s/DADA\\/Template\\/Widgets\\.pm$//g;\n\t   $Templates  =~ s/\\/$//; # cut off the first slash, if it's there; \n\t   $Templates .= '/templates';\n\t   \n\t    push(@guesses, $Templates); \n\t   \n\t}elsif($@){\n\n\t carp \"$DADA::Config::PROGRAM_NAME warning: File::Spec isn't working correctly: \". $@;\n\t carp 'You may want to setup the, \"$DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH \" Config variable!';\n\t \n\t} else{ \n\t\n\t\t$Templates = $DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH ;\n    \tpush(@guesses, $Templates);\n\t}\n\t\n}else{ \n\t\n\t$Templates = $DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH ;\n    push(@guesses, $Templates);\n\n}\n\t\t\nmy $second_guess_template  = $wierd_abs_path; \n   $second_guess_template  =~ s/DADA\\/Template\\/Widgets\\.pm$//g;\n   $second_guess_template  =~ s/\\/$//;\n   $second_guess_template .= '/templates';\n   $second_guess_template  = '/' . $second_guess_template;\n\n\tpush(@guesses, $second_guess_template);\n\n\n\tmy $getpwuid_call; \n\teval { $getpwuid_call = ( getpwuid $> )[7] };\n\tif(!$@){ \n\t\t# They're called guess, right? right...\n\t\tpush(@guesses, $getpwuid_call . '/cgi-bin/dada/templates');\n\t\tpush(@guesses, $getpwuid_call . '/public_html/cgi-bin/templates');\n\t\tpush(@guesses, $getpwuid_call . '/public_html/dada/templates');\n\t}\n\nrequire Exporter; \n\nuse vars (@ISA, @EXPORT); \n\n@ISA    = qw(Exporter);  \n@EXPORT = qw( \n \ntemplates_dir\npriority_popup_menu\nlist_popup_menu\nlist_popup_login_form\ndefault_screen\nsend_url_email_screen\nlogin_switch_widget\nscreen\nabsolute_path\nsubscription_form\nunsubscription_form\narchive_send_form\nprofile_widget\n_raw_screen\n);\n\nuse strict; \nuse vars qw( @EXPORT );\n\nmy %Global_Template_Variables = (\ncomment                     => 0, \n\nSUPPORT_FILES_URL           => $DADA::Config::SUPPORT_FILES->{url}, \nkcfinder_enabled            => $DADA::Config::FILE_BROWSER_OPTIONS->{kcfinder}->{enabled},\ncore5_filemanager_enabled   => $DADA::Config::FILE_BROWSER_OPTIONS->{core5_filemanager}->{enabled},\nrich_filemanager_enabled    => $DADA::Config::FILE_BROWSER_OPTIONS->{rich_filemanager}->{enabled},\n\t\t\nROOT_PASS_IS_ENCRYPTED       => $DADA::Config::ROOT_PASS_IS_ENCRYPTED, \nPROGRAM_NAME                 => $DADA::Config::PROGRAM_NAME, \nPROGRAM_URL                  => $DADA::Config::PROGRAM_URL,\nS_PROGRAM_URL                => $DADA::Config::S_PROGRAM_URL,\nS_PROGRAM_URL_base64_encoded => encode_html_entities($DADA::Config::S_PROGRAM_URL, '\\W'), \n\nSIGN_IN_FLAVOR_NAME    => $DADA::Config::SIGN_IN_FLAVOR_NAME, \nDISABLE_OUTSIDE_LOGINS => $DADA::Config::DISABLE_OUTSIDE_LOGINS, \n\nADMIN_FLAVOR_NAME      => $DADA::Config::ADMIN_FLAVOR_NAME, \nHELP_LINKS_URL         => $DADA::Config::HELP_LINKS_URL, \nMAILPROG               => $DADA::Config::MAILPROG,\nFILES                  => $DADA::Config::FILES, \nTEMPLATES              => $DADA::Config::TEMPLATES,\nVER                    => $DADA::Config::VER, \n\nDATA_CACHE             => $DADA::Config::DATA_CACHE, \n\n\n# CAPTCHA!\ncaptcha_params_recaptcha_type     => $DADA::Config::RECAPTCHA_PARAMS->{recaptcha_type},\ncaptcha_params_v2_public_key      => $DADA::Config::RECAPTCHA_PARAMS->{v2}->{public_key},\ncaptcha_params_v2_private_key     => $DADA::Config::RECAPTCHA_PARAMS->{v2}->{private_key},\ncaptcha_params_v3_public_key      => $DADA::Config::RECAPTCHA_PARAMS->{v3}->{public_key},\ncaptcha_params_v3_private_key     => $DADA::Config::RECAPTCHA_PARAMS->{v3}->{private_key},\n\ncan_use_Google_reCAPTCHA_v2       => scalar DADA::App::Guts::can_use_Google_reCAPTCHA_v2(), \ncan_use_Google_reCAPTCHA_v3       => scalar DADA::App::Guts::can_use_Google_reCAPTCHA_v3(), \n\n\nGIVE_PROPS_IN_HTML             => $DADA::Config::GIVE_PROPS_IN_HTML, \nGIVE_PROPS_IN_SUBSCRIBE_FORM   => $DADA::Config::GIVE_PROPS_IN_SUBSCRIBE_FORM, \nGIVE_PROPS_IN_ADMIN            => $DADA::Config::GIVE_PROPS_IN_ADMIN, \nGIVE_PROPS_IN_EMAIL            => $DADA::Config::GIVE_PROPS_IN_EMAIL, \n          \n\t\t  \nGLOBAL_UNSUBSCRIBE             => $DADA::Config::GLOBAL_UNSUBSCRIBE,                     \nGLOBAL_BLACK_LIST              => $DADA::Config::GLOBAL_BLACK_LIST,             \n\nDEFAULT_ADMIN_SCREEN           => $DADA::Config::DEFAULT_ADMIN_SCREEN, \nMAIL_SETTINGS                  => $DADA::Config::MAIL_SETTINGS, \nMASS_MAIL_SETTINGS             => $DADA::Config::MASS_MAIL_SETTINGS, \nVER                            => $DADA::Config::VER, \n                               \n                               \nENV_SCRIPT_URI                 => $ENV{SCRIPT_URI}, \nENV_SERVER_ADMIN               => $ENV{SERVER_ADMIN},\nHELP_LINKS_URL                 => $DADA::Config::HELP_LINKS_URL, \nHTML_CHARSET                   => $DADA::Config::HTML_CHARSET, \nPROFILE_ENABLED                => $DADA::Config::PROFILE_OPTIONS->{enabled}, \nENFORCE_CLOSED_LOOP_OPT_IN     => $DADA::Config::ENFORCE_CLOSED_LOOP_OPT_IN != 1 ? 0 : 1, \nSUBSCRIPTION_QUOTA             => $DADA::Config::SUBSCRIPTION_QUOTA, \nPROGRAM_IMG_FILENAME           => $DADA::Config::PROGRAM_IMG_FILENAME, \n\nGOOGLE_MAPS_API_PARAMS_api_key                => $DADA::Config::GOOGLE_MAPS_API_PARAMS->{api_key}, \nPII_OPTIONS_ip_address_logging_style          => $DADA::Config::PII_OPTIONS->{ip_address_logging_style}, \nPII_OPTIONS_allow_logging_emails_in_analytics => $DADA::Config::PII_OPTIONS->{allow_logging_emails_in_analytics}, \n\n\n\n\n\n# DEV: Cough! Kludge! Cough!\nLEFT_BRACKET                  => '[',\nRIGHT_BRACKET                 => ']',\nLT_CHAR                       => '<', \nGT_CHAR                       => '>',    \nTEST_UTF_VALUE                => \"\\x{a1}\\x{2122}\\x{a3}\\x{a2}\\x{221e}\\x{a7}\\x{b6}\\x{2022}\\x{aa}\\x{ba}\",        \n\n\n# Random hacks for MS Word, Outlook (sigh)\n#\n# [ 2030573 ] Dadamail 3.0 strips out [endif]\n# http://sourceforge.net/tracker/index.php?func=detail&aid=2030573&group_id=13002&atid=113002\n#\nendif                         => '[endif]',    \n#\n# /Random hacks for MS Word, Outlook (sigh)\n\n(\n    ($DADA::Config::CPAN_DEBUG_SETTINGS{HTML_TEMPLATE} == 1) ? \n        (debug => 1, ) :\n        ()\n), \n\n(\n\t\n\t($DADA::Config::SHOW_ADMIN_LINK eq \"1\") ?\n\t\t(SHOW_ADMIN_LINK  => 1,) : \n\t\t(SHOW_ADMIN_LINK  =>  0,),\n), \n\n                    \n(\n\t\n\t($DADA::Config::SHOW_HELP_LINKS eq \"1\") ?\n\t\t(SHOW_HELP_LINKS  => 1,) : \n\t\t(SHOW_HELP_LINKS  =>  0,),\n),\n\n\n); \n\nmy %WYSIWYG_Vars = WYSIWG_Vars(); \n%Global_Template_Variables = (%Global_Template_Variables, %WYSIWYG_Vars); \n\nsub WYSIWG_Vars { \n\tmy %Vars = (\n\t\tCKEDITOR_URL  => undef, \n\t\tTINY_MCE_URL  => undef, \n\t); \n\t# And test that I can get to the URL - our that at least it's a valid URL... \n\t\n\tif($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{enabled} == 1 \n\t\t&& defined($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url})\n\t\t&& isa_url($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url})\n\t\t){ \n\t\t$Vars{CKEDITOR_URL} = $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{ckeditor}->{url}; \n\t}\n\tif($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{enabled} == 1 \n\t\t&& defined($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url})\n\t\t&& isa_url($DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url})\n\t){ \n\t\t$Vars{TINY_MCE_URL} = $DADA::Config::WYSIWYG_EDITOR_OPTIONS->{tiny_mce}->{url}; \n\t}\n\t\n#\tuse Data::Dumper; \n#\tdie Dumper({%Vars}); \n\treturn %Vars;\n}\n\n\nsub make_wysiwyg_vars { \n\t\n\tmy $list = shift; \n\tmy %WYSIWG_Vars = WYSIWG_Vars(); \n\trequire DADA::MailingList::Settings; \n\tmy $ls = DADA::MailingList::Settings->new({-list => $list});\n\tmy %vars = ();\n\t\n\t \n\tif($ls->param('use_wysiwyg_editor') eq 'ckeditor' && defined($WYSIWG_Vars{CKEDITOR_URL})) { \n\t\t$vars{using_ckeditor} = 1; \n\t}\n\telsif($ls->param('use_wysiwyg_editor') eq 'tiny_mce' && defined($WYSIWG_Vars{TINY_MCE_URL})) { \n\t\t$vars{using_tiny_mce} = 1; \t\t\n\t}\n\telse { \n\t\t$vars{using_no_wysiwyg_editor} = 1; \n\t}\n\t\n#\tuse Data::Dumper; \n#\tdie Dumper({%vars}); \n\treturn %vars; \n\n}\nif($Global_Template_Variables{PROGRAM_URL} eq 'https://www.changetoyoursite.com/cgi-bin/dada/mail.cgi'){ \n\n\t$Global_Template_Variables{PROGRAM_URL} = $q->url; \n\t# Well, what if we're running as the installer?\n\tif($Global_Template_Variables{PROGRAM_URL} =~ m/installer\\/install\\.cgi$/){ \n\t\t$Global_Template_Variables{PROGRAM_URL} =~ s{installer\\/install\\.cgi}{mail.cgi};\n\t}\n}\nif($Global_Template_Variables{S_PROGRAM_URL} eq 'https://www.changetoyoursite.com/cgi-bin/dada/mail.cgi'){ \n\t$Global_Template_Variables{S_PROGRAM_URL} = $Global_Template_Variables{PROGRAM_URL}; \n}\nmy %Global_Template_Options = (\n\t\t# DEV: Dude, it's no wonder any templates are ever found.  \t\t\n\t\tpath              => [\n\t\t\t\t\t\t\t\t$DADA::Config::TEMPLATES, \n\t\t\t\t\t\t\t\t$DADA::Config::ALTERNATIVE_HTML_TEMPLATE_PATH, \n\t\t\t\t\t\t\t\t@guesses, \n\t\t\t\t\t\t\t\t'templates', \n\t\t\t\t\t\t\t\t'Templates/templates', \n\t\t\t\t\t\t\t\t'DADA/Templates/templates', \n\t\t\t\t\t\t\t\t'../DADA/Templates/templates',\n\t\t\t\t\t\t\t\t'../../DADA/Templates/templates',\n\t\t\t\t\t\t\t],\n\t\tdie_on_bad_params => 0,\t\n\t\tloop_context_vars => 1, \t\t\t\t\t\t\t\t\t\n);\n\nmy %_ht_tmpl_set_params = (); \n\t\t\t\t\t\t\t\t\t\t\t\n=pod\n\n=head1 Name\n\nDADA::Template::Widgets\n\n=head1 Description\n\nHolds commonly used HTML 'widgets'\n\n=head1 Subroutines\n\n=cut\n\n\n=pod\n\n=head2 list_popup_menu\n\nreturns a popup menu holding all the list names as labels and \nlist shortnames as values\n\n=cut\n\n\nsub priority_popup_menu { \n\n\tmy $li       = shift; \n\tmy $default = shift || undef;\n\t\n\t\n\tif(! defined($default)){ \n\t\t$default = $li->{priority};\n\t}\n\trequire HTML::Menu::Select; \n    my $priority_popup_menu = HTML::Menu::Select::popup_menu(\n\t\t\t\t\t\t\t  \t\t{ \n\t\t\t\t\t\t\t\t\t\tname     => 'X-Priority',\n\t\t\t\t\t\t\t\t\t\tid       => 'X-Priority',\n\t                                    values   =>[keys %DADA::Config::PRIORITIES],\n\t                                    labels   => \\%DADA::Config::PRIORITIES,\n\t                                    default  =>  $default, \n                              \t\t}\n\t\t\t\t\t\t\t  \t);\n\treturn $priority_popup_menu; \n\t\n}\n\n\n\n\nsub list_popup_menu { \n\n\t\n\trequire HTML::Menu::Select; \n\tmy $r = undef; \n\t\n\tmy %args = (\n\t\t-show_hidden         => 0,\n\t\t-name                => 'list',\n\t\t-empty_list_check    => 0, \n\t\t-as_checkboxes       => 0, \n\t\t-show_list_shortname => 0, \n\t\t-selected_list       => undef, \n\t\t-disable_invite_only => 0, \n\t    @_\n\t); \n\tmy $labels     = {}; \n\tmy $attributes = {};\n\t \n\trequire DADA::MailingList::Settings; \n\t\n\tmy @lists = available_lists(-Dont_Die => 1); \n\n\t \n\treturn undef if scalar @lists <= 0;\n\t\n\tmy $l_count = 0; \n\t\n\t# This needs its own method...\n\t\tforeach my $list( @lists ){\n\t\t\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\t\tnext if \n\t\t\t\t$args{-show_hidden} == 0 \n\t\t\t\t&& ($ls->param('hide_list') == 1 \n\t\t\t\t&& $ls->param('private_list') == 1); \n\t\t\t\t\n\t\t\tif($args{-show_list_shortname} == 1){ \n\t\t\t\t$labels->{$list} = $ls->param('list_name') . ' (' . $list . ')';\n\t\t\t}\n\t\t\telse { \n\t\t\t\t$labels->{$list} = $ls->param('list_name');\n\t\t\t}\n\n\t\t\tif($args{-disable_invite_only} == 1){\n\n\t\t\t\tif($ls->param('invite_only_list') == 1){ \n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t$labels->{$list} .= ' - by Invitation Only';\n\t\t\t\t\t$attributes->{$list}->{disabled} = \"disabled\";\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(\t$args{-selected_list} eq $list \n\t\t\t\t\t&& $ls->param('invite_only_list') != 1\n\t\t\t\t){ \n\t\t\t\t\t$attributes->{$list}->{selected} = \"selected\";\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { \n\t\t\t\tif(\t$args{-selected_list} eq $list \n\t\t\t\t){ \n\t\t\t\t\t$attributes->{$list}->{selected} = \"selected\";\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t$l_count++;\n\t\t}\n\t\tmy @opt_labels = sort { uc($labels->{$a}) cmp uc($labels->{$b}) } keys %$labels;\n\t#\t\t\t\t\t\t\t\t#\t\n\t\n\tif($l_count <= 0 && $args{-empty_list_check} == 1){ \n\t\n\t    return undef; \n\t}\n\t\n\tif($args{-as_checkboxes} == 1){ \n        $r =  $q->checkbox_group(\n                                   -name      => $args{-name}, \n\t\t\t\t\t\t\t\t   -id        => 'ddm_' . $args{-name}, \n                                  '-values'   => [@opt_labels],\n                                   -labels    => $labels,\n                                   -columns   => 2, \n\t\t\t\t\t\t\t\t   -default  => [$args{-selected_list}],\n                                 );\t\t\t\t \t\n\t\n\t}\n\telse { \n\t\t\n\t\tif(scalar @opt_labels == 0){ \n\t\t\treturn undef; \n\t\t}\n        $r = HTML::Menu::Select::popup_menu(\n\t\t\t {\n\t\t\t\tname       => $args{-name}, \n\t\t\t\tid         => 'ddm_' . $args{-name}, \n\t\t\t\tvalues     => [@opt_labels],\n\t\t\t\tlabels     => $labels,\n#\t\t\t\tdefault    => [],\n\t\t\t\tattributes => $attributes,\n\t\t\t}\n\t\t ); \n    }\n\t\n\t\n\treturn $r; \n\t\n}\n\n\n\n\nsub list_popup_login_form { \n\t\n\tmy %args = (\n\t\t-show_hidden => 0, \n\t\t-auth_state  => undef, \n\t\t@_,\n\t); \n\t\n\tmy $url             = $ENV{SCRIPT_URI} || $q->url(); \n\tmy $referer         = $ENV{HTTP_REFERER}; \n\tmy $query_string    = $ENV{QUERY_STRING}; \n\tmy $path_info       = $ENV{PATH_INFO}; \n\t\n\tmy $list_popup_menu = list_popup_menu(\n\t\t\t\t\t\t\t-name   \t         => 'admin_list', \n\t\t\t\t   \t\t    -show_hidden         => $args{-show_hidden},\n\t\t\t\t   \t\t    -empty_list_check    => 1, \n\t\t\t\t\t\t\t-show_list_shortname => 1, \n\t\t\t\t   \t\t   );\n\n\t\tif(show_login_list_textbox() == 1){ \n\t\t\treturn screen( \n\t\t\t\t{ \n\t\t\t\t\t-screen => 'text_box_login_form.tmpl', \n\t\t\t        -vars   => { \n\n\t\t\t            list_popup_menu => $list_popup_menu, \n\t                    auth_state      => $args{-auth_state},\n\t\t\t\t\t\treferer         => $referer, \n\t\t\t\t\t\turl             => $url, \n\t\t\t\t\t\tquery_string    => $query_string, \n\t\t\t\t\t\tpath_info       => $path_info, \n\t\t\t\t\t\tshow_other_link => _show_other_link(),  \n\t\t\t\t    }\n\t\t\t\t},\t\n\t\t\t);\n\t\t}\n\t\telse { \n\t\t\t\t\t\t  \t\t                 \n\t\t\treturn screen(\n\t\t\t    {\n\t\t\t        -screen => 'list_popup_login_form.tmpl',\t\t\n\t\t\t        -vars   => { \n\t\t            \n\t\t\t            list_popup_menu => $list_popup_menu, \n\t                    auth_state      => $args{-auth_state},\n\t\t\t\t\t\treferer         => $referer, \n\t\t\t\t\t\turl             => $url, \n\t\t\t\t\t\tquery_string    => $query_string, \n\t\t\t\t\t\tpath_info       => $path_info, \n\t\t\t\t\t\tshow_other_link => _show_other_link(),  \n\t\t\t\t    }\n\t\t\t\t}\n\t\t    ); \n\t}\n}\n\n\n\n\n\n\nsub default_screen {\n\t\n\tmy ($args) = @_; \t\n#        -show_hidden        => undef,\n#        -name               => undef,\n#        -email              => undef,\n#        -error_invalid_list => 0,\n\n    require DADA::MailingList::Settings;\n    require DADA::MailingList::Archives;\n\n    my $subscriber_fields;\n    my @list_information = ();\n    my $reusable_parser  = undef;\n\n    # Keeps count of how many visible lists are printed out;\n    my $l_count = 0;\n\n    my $labels = {};\n    foreach my $l ( available_lists() ) {\n\n        # This is a weird placement...\n        if ( !$subscriber_fields ) {\n            require DADA::MailingList::Subscribers;\n            my $lh = DADA::MailingList::Subscribers->new( { -list => $l } );\n            $subscriber_fields = $lh->subscriber_fields(\n\t\t\t\t{\n\t\t\t\t\t-show_hidden_fields => 0,\n\t\t\t\t}\n\t\t\t);\n        }\n\n        # /This is a weird placement...\n\n        my $ls = DADA::MailingList::Settings->new( { -list => $l } );\n        if($ls->param('hide_list') == 1 && $ls->param('private_list') == 1){ \n            next; \n        }\n        else {\n            $labels->{$l} = $ls->param('list_name');\n            $l_count++;\n        }\n    }\n    my @list_in_list_name_order =\n      sort { uc( $labels->{$a} ) cmp uc( $labels->{$b} ) } keys %$labels;\n\n    foreach my $list (@list_in_list_name_order) {\n        my $ls = DADA::MailingList::Settings->new( { -list => $list } );\n        my $all_list_info        = $ls->get;\n        my $all_list_info_dotted = $ls->get( -dotted => 1 );\n\n\t\tmy $ah = undef; \n\t\tif($ls->param('show_archives') == 1){   \n\n\t        $ah = DADA::MailingList::Archives->new(\n\t            {\n\t                -list => $list,\n\t                ( ($reusable_parser) ? ( -parser => $reusable_parser ) : () )\n\t            }\n\t        );\n\t\t}\n\t\t\n        unless($ls->param('hide_list') == 1 && $ls->param('private_list') == 1){ \n            $l_count++;\n\n            # This is strange...\n            $all_list_info_dotted->{'list_settings.info'} =\n              markdown_to_html({-str => $all_list_info_dotted->{'list_settings.info'} });\n            $all_list_info_dotted->{'list_settings.info'} =\n              _email_protect({-string => $all_list_info_dotted->{'list_settings.info'}} );\n\n  \t\t\tmy $ne; \n  \t\t\tmy $subject; \n  \t\t\tif($ls->param('show_archives') == 1){   \n              \t$ne      = $ah->newest_entry;\n              \t$subject = $ah->get_archive_subject($ne);\n                  $subject = $ah->_parse_in_list_info( -data => $subject );\n\n  \t\t\t   # this is so atrocious.\n  \t            $all_list_info_dotted->{latest_archive_date} = date_this(\n  \t           -Packed_Date   => $ne,\n  \t           -Write_Month   => $ls->param('archive_show_month'),\n  \t           -Write_Day     => $ls->param('archive_show_day'),\n  \t           -Write_Year    => $ls->param('archive_show_year'),\n  \t           -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n  \t           -Write_Second  => $ls->param('archive_show_second')\n  \t           );\n\t\t\t   \n  \t\t\t\t  $all_list_info_dotted->{latest_archive_id} = $ne;\n  \t            # These two things are sort of strange.\n  \t            $all_list_info_dotted->{latest_archive_blurb} =\n  \t              $ah->message_blurb();\n  \t            $all_list_info_dotted->{latest_archive_subject} = $subject;\n  \t\t\t}\n\t\t\n\t\t\n            push ( @list_information, $all_list_info_dotted );\n  \t\t\tif($ls->param('show_archives') == 1){   \n  \t\t\t\t$reusable_parser = $ah->{parser} if !$reusable_parser;\n  \t\t\t}\n        }\n    }\n\n    my $visible_lists = 1;\n    if ( $l_count == 0 ) {\n        $visible_lists = 0;\n    }\n\n    my $named_subscriber_fields = [];\n    foreach (@$subscriber_fields) {\n        push ( @$named_subscriber_fields, { name => $_ } );\n    }\n\n    my $list_popup_menu = list_popup_menu(\n        -email               => $args->{email},\n        -list                => $args->{list},\n\t\t-disable_invite_only => 1, \n    );\n\n\treturn wrap_screen(\n        {\n\t\t\t-with   => 'list', \n            -screen => 'default_screen.tmpl',\n            -vars   => {\n\t\t\t\tcan_use_JSON       => scalar DADA::App::Guts::can_use_JSON(), \n                list_popup_menu    => $list_popup_menu,\n                email              => $args->{ -email },\n                list_information   => \\@list_information,\n                visible_lists      => $visible_lists,\n                error_invalid_list => $args->{ -error_invalid_list },\n                fields             => $named_subscriber_fields,\n                #subscription_form  => scalar subscription_form(),\n            },\n        }\n    );\n}\n\nsub list_page { \n\n\tmy %args = (-list           => undef, \n\t\t\t    -email          => undef, \n\t\t\t\t-error_no_email => undef, \n\t\t\t\t-cgi_obj        => undef, \n\t\t\t\t@_);\n    \n\trequire DADA::MailingList::Settings; \n\t\n\tmy $ls = DADA::MailingList::Settings->new({-list => $args{-list}}); \n\n    my $html_archive_list = html_archive_list($args{-list}); \n\t\n\trequire DADA::Profile; \n\tmy $prof = DADA::Profile->new(\n\t\t{\n\t\t\t-from_session => 1, \n\t\t}\n\t); \n\tmy $allowed_to_view_archives = 1;\n\tif($prof) { \n\t\t$allowed_to_view_archives = $prof->allowed_to_view_archives(\n\t\t\t{\n\t\t\t\t-list         => $args{-list},\n\t\t\t}\n\t\t);\n\t}\n\t\n\t\n\t# So, how does, \"wrap_screen\" embed variables? \n\t# In other words, how do I show the list name in the title? That's important. \n\t\n    my $template = wrap_screen(\n        {\n        -with                     => 'list', \n        -screen                   => 'list_page_screen.tmpl',\n        -list_settings_vars       => $ls->get,\n        -list_settings_vars_param => {\n\t\t\t-dot_it => 1\n\t\t\t-list   => $args{-list}, # this is redundant, but important for email protection.\n\t\t },\n\n        -vars                     => \n        { \n\t\t\tcan_use_JSON              => scalar DADA::App::Guts::can_use_JSON(), \n            subscription_form         => subscription_form({-list => $args{-list}, -email => $args{-email}}), \n            error_no_email            => $args{-error_no_email}, \n            html_archive_list         => $html_archive_list, \n\t\t\tallowed_to_view_archives  => $allowed_to_view_archives,  \n        },\n        \n        -webify_and_santize_these => [qw(\n\t\t\tlist_settings.discussion_pop_email\n\t\t\tlist_settings.list_owner_email\n\t\t\tlist_settings.info list_settings.privacy_policy\n\t\t)], \n        \n        }\n    ); \n\n    return $template; \n\n}\n\n\n\n\nsub admin {\n\tmy ($args) = @_; \n\t\n\tif(! exists($args->{-vars}) ){ \n\t\t$args->{-vars} = {};\n\t}\n\t\n\tif(! exists($args->{-vars}->{login_widget}) ){ \n\t\t$args->{-vars}->{login_widget} = $DADA::Config::LOGIN_WIDGET;\n\t}\n\t\n\tif(\n\t\tcheck_if_list_exists( -List => $args->{-vars}->{selected_list}) >= 1\n\t\t&& _is_hidden($args->{-vars}->{selected_list})\n\t\n\t){ \n\t\t$args->{-vars}->{login_widget} = 'text_box'; \n\t}\n\t\n    my @available_lists = available_lists();\n\t\n    my $list_max_reached = 0;\n\t\n\tif(strip($DADA::Config::LIST_QUOTA) eq '') {\n\t\t$DADA::Config::LIST_QUOTA = undef;\n    } \n\t# Special: \n\tif($DADA::Config::LIST_QUOTA == 0){ \n\t\t$DADA::Config::LIST_QUOTA = undef;\n\t}\n    if (   defined($DADA::Config::LIST_QUOTA)\n        && ( \n\t\t\t( $#available_lists + 1 ) >= $DADA::Config::LIST_QUOTA \n\t\t) \n\t\t\n\t\t) {\n        $list_max_reached = 1;\n    }\n\n    my $list_popup_menu = list_popup_menu(\n        -name                => 'admin_list',\n        -show_hidden         => 0,\n        -empty_list_check    => 1,\n        -show_list_shortname => 1,\n\t\t-selected_list       => $args->{-vars}->{selected_list},\n    );\n\tif(!defined($list_popup_menu)) {\n\t\t$args->{-vars}->{login_widget} = 'text_box';\n\t}\n\n    my $auth_state;\n\t\n    if ( $DADA::Config::DISABLE_OUTSIDE_LOGINS == 1 ) {\n        require DADA::Security::SimpleAuthStringState;\n        my $sast = DADA::Security::SimpleAuthStringState->new;\n        $auth_state = $sast->make_state;\n    }\n\n\tmy $show_another_link = _show_other_link(); \n\t\n\tmy $logged_out = $args->{-cgi_obj}->param('logged_out') // 0; \n\t\n\tmy $show_2col_view = 0; \n\tmy $tmp_vars = $args->{-vars};\n\tif(\texists($tmp_vars->{errors})\t){ \n\t\tfor my $err(@{$tmp_vars->{errors}}){ \n\t\t\tif($err->{error} eq 'invalid_password'){ \n\t\t\t\t$show_2col_view = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n    return wrap_screen(\n        {\n            -screen         => 'admin_screen.tmpl',\n            -with           => 'list',\n            -wrapper_params => {\n                -Use_Custom => 0,\n            },\n            -vars => {\n\t\t\t\tlogged_out              => $logged_out, \n                list_popup_menu         => $list_popup_menu,\n                list_max_reached        => $list_max_reached,\n                auth_state              => $auth_state,\n                show_other_link         => $show_another_link,\n\t\t\t\t%{$args->{-vars}},\n            },\n        }\n    );\n}\n\n\nsub _is_hidden { \n    require DADA::MailingList::Settings; \n    my $list = shift; \n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n        return 1\n            if $ls->param('hide_list') == 1  && $ls->param('private_list') == 1; \t\t\n    return 0; \n}\nsub _show_other_link { \n\n    require DADA::MailingList::Settings; \n    \n    \n    # Basically, if there's at least one list that's hidden, we show the \n    # More... link. \n        \n    foreach my $list(available_lists(-Dont_Die => 1) ){\n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n        return 1\n            if $ls->param('hide_list') == 1  && $ls->param('private_list') == 1; \n\t}\n\t\t\t\n    return 0; \n    \n}\n\n\n\n\nsub show_login_list_textbox { \n\t\n\t# This means, if all the lists are hidden, we have to show the \n\t# text login box. Yup. \n\t#\n\t\n\trequire DADA::MailingList::Settings; \n    \n    foreach my $list(available_lists(-Dont_Die => 1) ){\n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n        return 0\n            if $ls->param('hide_list') == 1  && $ls->param('private_list') == 1; \n\t}\n\t\t\t\n    return 1;\n\t\n}\n\n\n\n\nsub html_archive_list { \n\n\t#  DEV: god, what a mess...\n\t#\n\tmy $list = shift; \n\tmy $t    = \"\";\n\t\n\trequire DADA::MailingList::Archives; \n\trequire DADA::MailingList::Settings;\n\n\t\n\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\n\treturn '' \n\t\tif $ls->param('show_archives') != 1;\n\t\n\trequire DADA::Profile; \n\tmy $prof = DADA::Profile->new(\n\t\t{\n\t\t\t-from_session => 1, \n\t\t}\n\t); \n\tmy $allowed_to_view_archives = 1;\n\tif($prof) { \n\t\t$allowed_to_view_archives = $prof->allowed_to_view_archives(\n\t\t\t{\n\t\t\t\t-list         => $list, \n\t\t\t}\n\t\t);\n\t}\n\tif($allowed_to_view_archives == 1){ \n\t\t\n\t\tmy $archive = DADA::MailingList::Archives->new({-list => $list}); \n\t\tmy $entries = $archive->get_archive_entries(); \n\t\n\t\n\t\tif(defined($entries->[0])) { \n\t\n\n\t        my ($begin, $stop) = $archive->create_index(0);\n\t        my $i;\n\t        my $stopped_at = $begin;\n\t        my $num = $begin;\n        \n\t        $num++; \n\t        my @archive_nums; \n\t        my @archive_links; \n\t        my $th_entries = []; \n    \n        \n        \n\t        # iterate and save\n\t        for($i = $begin; $i <=$stop; $i++){ \n\t            my $link; \n            \n\t            if(defined($entries->[$i])){\n                \n\t                my ($subject, $message, $format, $raw_msg) = $archive->get_archive_info($entries->[$i]); \n                \n                \n\t                 # THis is stupid: \n\t                 # DEV: This is stupid, and I don't think it's a great idea. \n\t                    $subject = DADA::Template::Widgets::screen(\n\t                        {\n\t                        -data                    => \\$subject, \n\t                        -vars                     => $ls->get, \n\t                        -list_settings_vars       => $ls->get, \n\t                        -list_settings_vars_param => {-dot_it => 1},                    \n\t\t\t\t\t\t\t-subscriber_vars_param    => {-use_fallback_vars => 1, -list => $ls->param('list')},\n\n\t                        }\n\t                    ); \n\t                    # That. Sucked.\n                \n                \n\t                # this is so atrocious.\n\t                my $date = date_this(\n\t                -Packed_Date   => $entries->[$i],\n\t                -Write_Month   => $ls->param('archive_show_month'),\n\t                -Write_Day     => $ls->param('archive_show_day'),\n\t                -Write_Year    => $ls->param('archive_show_year'),\n\t                -Write_H_And_M => $ls->param('archive_show_hour_and_minute'),\n\t                -Write_Second  => $ls->param('archive_show_second')\n\t                );\n\t\t\t\t\t\n\t\t\t\t\tmy $header_from      = undef;\n\t                my $orig_header_from = undef;\n\n\t                if ($raw_msg) {\n\t                    $header_from = $archive->get_header(\n\t                        -header => 'From',\n\t                        -key    => $entries->[$i]\n\t                    );\n\t                    $orig_header_from = $header_from;\n\t                }\n\t\n\t\t\t\t\tmy $can_use_gravatar_url = 0;\n\t                my $gravatar_img_url     = '';\n\n\t                if ( $ls->param('enable_gravatars') ) {\n\n\t                    eval { require Gravatar::URL };\n\t                    if ( !$@ ) {\n\t                        $can_use_gravatar_url = 1;\n\n\n                                my $header_address = $archive->sender_address(\n                                 {\n                                        -id => $entries->[$i],\n                                    }\n                            ); \n                            $gravatar_img_url = gravatar_img_url(\n                                {\n                                    -email                => $header_address,\n                                    -default_gravatar_url => $ls->param('default_gravatar_url'),\n                                }\n                            );\n\t                    }\n\t                    else {\n\t                        $can_use_gravatar_url = 0;\n\t                    }\n\t                }\n\t\t                \t\n   # die $archive->message_blurb(-key => $entries->[$i]); \n\t                my $entry = { \t\t\t\t\n\t                        id               => $entries->[$i], \n    \n\t                        date             => $date, \n\t                        subject          => $subject,\n\t                       'format'          => $format, \n\t                        list             => $list, \n\t                        uri_escaped_list => uriescape($list),\n\t                        PROGRAM_URL      => $DADA::Config::PROGRAM_URL, \n\t\t                    'list_settings.enable_gravatars' =>\n\t\t                      $ls->param('enable_gravatars'),\n\t\t                    can_use_gravatar_url => $can_use_gravatar_url,\n\t\t                    gravatar_img_url     => $gravatar_img_url,\n\t\n\t                        message_blurb    => $archive->message_blurb(-key => $entries->[$i]),\n\t                    }; \n                \n\t                $stopped_at++;\n\t                push(@archive_nums, $num); \n\t                push(@archive_links, $link); \n\t                $num++;\n    \n    \n\t                push(@$th_entries, $entry); \n                    \n\t            }\n\t        } \n    \n\t        my $ii; \n        \n\t        for($ii=0;$ii<=$#archive_links; $ii++){ \n    \n\t            my $bullet = $archive_nums[$ii];\n            \n\t            #fix if we're doing reverse chronologic \n\t            $bullet = (($#{$entries}+1) - ($archive_nums[$ii]) +1) \n\t                if($ls->param('sort_archives_in_reverse') == 1);\n    \n\t            # yeah, whatever. \n\t            $th_entries->[$ii]->{bullet} = $bullet; \n            \n\t        }\n    \t\n\n\n        $t .= screen({-screen => 'archive_list_widget.tmpl', \n                     -vars => {\n                                entries              => $th_entries,\n                                list                 => $list, \n                                list_name            => $ls->param('list_name'), \n                                publish_archives_rss => ($ls->param('publish_archives_rss')) ? 1: 0, \n                                index_nav            => $archive->create_index_nav($stopped_at), \n                               allowed_to_view_archives => 1, \n\t\t\t\t\t\t\t}\n                    });  \n \n\t\t\t}\n\t}\n\telse { \n\t\t$t = screen({-screen => 'archive_list_widget.tmpl', \n                     -vars => {\n                                entries              => [],\n                                list                 => $list, \n                                list_name            => $ls->param('list_name'), \n                                publish_archives_rss => 0,\n                                index_nav            => '', \n                                search_form          => '', \n\t\t\t\t\t\t\t\tallowed_to_view_archives => 0, \n                               }\n                    });  \n\n\t}\n\t\n\treturn $t; \n\n}\n\n\n\n\nsub login_switch_widget { \n\n\tmy $args = shift; \n\t\n\tcroak \"no list!\" if ! $args->{-list};\n\t\n\trequire DADA::MailingList::Settings; \n\n\tmy $location = $q->self_url || $DADA::Config::S_PROGRAM_URL . '?flavor=' . $args->{-f}; \n\t   $location =~ s/^http//; \n\t\n    require  DADA::App::ScreenCache; \n    my $c  = DADA::App::ScreenCache->new; \n    \n #   if($c->is_cached('login_switch_widget.' . $args->{-list} . '.scrn')){ \n #       my $lsw = $c->pass('login_switch_widget.' . $args->{-list} . '.scrn');\n #          $lsw =~ s/\\[LOCATION\\]/$location/g; \n #          return $lsw; \n #     }\n\n    my $scrn; \n    my $lists = []; \n    \n\tforeach my $list(available_lists(-In_Order => 1)){\n\t\t\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\t\tmy $logged_in = 0; \n\t\t\tif($list eq $args->{-list}){ \n\t\t\t   $logged_in = 1;  \n\t\t\t}\n\t\t\tpush(\n\t\t\t    @$lists, \n\t\t\t    {\n\t\t\t        'list_settings.list'      => $list, \n\t\t\t        'list_settings.list_name' => $ls->param('list_name'), \n\t\t\t        location                  => $location, \n\t\t\t        logged_in                 => $logged_in, \n\t\t\t\t\tS_PROGRAM_URL             => $DADA::Config::S_PROGRAM_URL, \n\t\t\t\t\tPROGRAM_URL               => $DADA::Config::PROGRAM_URL, \n\t\t\t\t\t\n\t\t\t    }\n\t\t\t); \n\t}\n\n\treturn DADA::Template::Widgets::screen(\n\t\t\t\t{\n\t\t\t\t    -screen => 'login_switch_widget.tmpl',\n\t\t\t\t    -vars   => { \n\t\t\t\t        lists => $lists, \n\t\t\t\t    },\n\t\t\t\t}\n\t\t\t); \n\t\n\t\n\t\n#\t$c->cache('login_switch_widget.' . $args->{-list} . '.scrn', \\$scrn);\t\n#\t$scrn =~ s/\\[LOCATION\\]/$location/g; \n # return $scrn; \n\n}\n\nsub login_switch_popup_menu_widget { \n\n\tmy $args = shift; \n\t\n\tcroak \"no list!\" if ! $args->{-list};\n\t\n\trequire DADA::MailingList::Settings; \n\n\tmy $location = $q->self_url || $DADA::Config::S_PROGRAM_URL . '?flavor=' . $args->{-f}; \n\n    require  DADA::App::ScreenCache; \n    my $c  = DADA::App::ScreenCache->new; \n    \n    #if($c->is_cached('login_switch_widget.' . $args->{-list} . '.scrn')){ \n    #    my $lsw = $c->pass('login_switch_widget.' . $args->{-list} . '.scrn');\n    #       $lsw =~ s/\\[LOCATION\\]/$location/g; \n    #       return $lsw; \n    #  }\n\n    my $scrn; \n    \n\n\tmy @lists = available_lists(-In_Order => 1); \n\tmy %label = (); \n\t\n\t# DEV TODO - This needs its own METHOD!!!\n\t\n\tforeach my $list( @lists ){\n\t\t\tmy $ls = DADA::MailingList::Settings->new({-list => $list}); \n\t\t\t$label{$list} = $ls->param('list_name') . ' (' . $list . ')'; \n\t\t\t\n\t}\n\t\n\t$label{$args->{-list}} = '----------'; \n\t\n\trequire HTML::Menu::Select;\n\tmy $login_switch_popup_menu = HTML::Menu::Select::popup_menu(\n\t\t{\n\t\t\tname    => 'change_to_list', \n\t\t\tid      => 'change_to_list', \n\t\t\tvalue   => [@lists], \n\t\t\tdefault => $args->{-list},\n\t\t\tlabels  => {%label}, \n\t\t}\n\t);\n\t\t\n\tmy $num_lists = scalar @lists; \n\treturn DADA::Template::Widgets::screen(\n\t\t{\n\t\t    -screen => 'login_switch_popup_menu_widget.tmpl',\n\t\t\t-vars   => { \n\t\t\t\tnum_lists               => $num_lists, \n\t\t\t\tlogin_switch_popup_menu => $login_switch_popup_menu, \n\t\t        location                => $location, \n\t\t    },\n\t\t}\n\t);\n}\n\n\n\n\nsub archive_send_form { \n\n\tmy ($list, $id, $errors, $captcha_archive_send_form, $captcha_fail) = @_; \n\n    my $CAPTCHA_string = '';\n    # ?!?!\n    $captcha_fail = defined $captcha_fail ? $captcha_fail : 0;\n\n    my $can_use_captcha = can_use_Google_reCAPTCHA_v2(); \t\n\t$can_use_captcha = 0 \n\t\tif length($DADA::Config::RECAPTCHA_PARAMS->{v2}->{public_key}) <= 0;\n\t$can_use_captcha = 0 \n\t\tif length($DADA::Config::RECAPTCHA_PARAMS->{v2}->{private_key}) <= 0;\n\t\n    if($captcha_archive_send_form == 1 && $can_use_captcha == 1){ \n            my $captcha_worked = 0; \n            my $captcha_auth   = 1; \n\n            require DADA::Security::AuthenCAPTCHA::Google_reCAPTCHA; \n            my $cap = DADA::Security::AuthenCAPTCHA::Google_reCAPTCHA->new; \n               $CAPTCHA_string = $cap->get_html();  \n    }\n\n\treturn DADA::Template::Widgets::screen(\n\t\t\t\t{\n\t\t\t\t    -screen => 'send_archive_form_widget.tmpl',\n\t\t\t\t    -vars   => { \n\t\t\t\t        send_archive_form_error => $errors, \n\t\t\t\t        list                    => $list, \n\t\t\t\t        id                      => $id, \n\t        \n\t\t\t\t        # CAPTCHA stuff\n\t\t\t\t\t    can_use_captcha => $can_use_captcha, \n\t\t\t\t        CAPTCHA_string  => $CAPTCHA_string,\n\t\t\t\t        captcha_fail    => $captcha_fail, \n\t\t\t\t    },\n\t\t\t\t}\n\t\t\t); \n}\n\n\n\nsub profile_widget {\n\n\tmy ($args) = @_; \n\tmy $prof_sess_obj = undef; \n\t\n\tif(defined($args->{-prof_sess_obj})){ \n\t\t$prof_sess_obj = $args->{-prof_sess_obj};\n\t}\n\t\n\t\n    my $scr              = '';\n    my $prof_data        = {};\n    my $is_logged_in     = 0;\n    my $profiles_enabled = $DADA::Config::PROFILE_OPTIONS->{enabled};\n    if (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1)\n    {\n        $profiles_enabled = 0;\n    }\n    else {\n\t\tif(defined($prof_sess_obj)){ \n\t\t\tif ( $prof_sess_obj->is_logged_in( { -cgi_obj => $q } ) ) {\n                $is_logged_in = 1;\n                $prof_data = $prof_sess_obj->get( { -cgi_obj => $q } );\n\t\t\t}\n\t\t}\n\t\telse {\n\t        require DADA::Profile;\n\t        my $dp = DADA::Profile->new( { -from_session => 1 } );\n\t        if ($dp) {\n\t            require DADA::Profile::Session;\n\t            require CGI;\n\t            my $prof_sess = DADA::Profile::Session->new;\n\t            if ( $prof_sess->is_logged_in( { -cgi_obj => $q } ) ) {\n\t                $is_logged_in = 1;\n\t\t\t\t\t$prof_data = $prof_sess->get( { -cgi_obj => $q } );\n\t            }\n\t        }\n\t\t}\n    }\n\n    return screen(\n        {\n            -screen => 'profile_widget.tmpl',\n            -vars   => {\n                profiles_enabled  => $profiles_enabled,\n                is_logged_in      => $is_logged_in,\n                'profile.email'   => $prof_data->{email},\n                gravators_enabled => $DADA::Config::PROFILE_OPTIONS->{gravatar_options}->{enable_gravators},\n                gravatar_img_url => gravatar_img_url(\n                    {\n                        -email                => $prof_data->{email},\n                        -size => 45,\n                    }\n                ),\n\n            }\n        }\n    );\n\n}\n\n\nsub amazon_ses_requirements_widget { \n\t\n\tmy $amazon_ses_required_modules = [ \n\t\t{module => 'Cwd',             installed => 1}, \n\t\t{module => 'Digest::SHA',     installed => 1}, \n\t\t{module => 'URI::Escape',     installed => 1}, \n\t\t{module => 'MIME::Base64',    installed => 1}, \t\n\t\t{module => 'Crypt::SSLeay',   installed => 1}, \t\n\t\t{module => 'XML::LibXML',     installed => 1},\n\t\t{module => 'LWP',             installed => 1}, \n\t\t{module => 'AWS::Signature4', installed => 1},\n#\t\t{module => 'Some::Unknown::Module',       installed => 1}, \n\t];\n\n\n\tmy $amazon_ses_has_needed_cpan_modules = 1; \n\ttry {\n\t\trequire Cwd;\n\t} catch { \n\t\t$amazon_ses_required_modules->[0]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire Digest::SHA;\n\t} catch { \n\t\t$amazon_ses_required_modules->[1]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire URI::Escape;\n\t} catch { \n\t\t$amazon_ses_required_modules->[2]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire MIME::Base64;\n\t} catch { \n\t\t$amazon_ses_required_modules->[3]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire Crypt::SSLeay;\n\t} catch { \n\t\t$amazon_ses_required_modules->[4]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\ttry {\n\t\trequire XML::LibXML;\n\t} catch { \n\t\t$amazon_ses_required_modules->[5]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0; \n\t};\n\teval {require LWP;};\n\tif($@){\n\t\t$amazon_ses_required_modules->[6]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0; \n\t}\n\t\n\ttry {\n\t\trequire AWS::Signature4;\n\t} catch { \n\t\t$amazon_ses_required_modules->[7]->{installed}           = 0;\n\t\t$amazon_ses_has_needed_cpan_modules = 0;\n\t};\n\t\n#\ttry {\n#\t\trequire Some::Unknown::Module;\n#\t} catch { \n#\t\t$amazon_ses_required_modules->[7]->{installed}           = 0;\n#\t\t$amazon_ses_has_needed_cpan_modules = 0; \n#\t};\n\t\n\t\n\t\n\treturn screen(\n\t\t{\n\t\t\t-screen => 'amazon_ses_requirements_widget.tmpl',\n\t\t\t-vars   => {\n\t\t\t\tamazon_ses_has_needed_cpan_modules  => $amazon_ses_has_needed_cpan_modules, \n\t\t\t\tamazon_ses_required_modules         => $amazon_ses_required_modules, \n\t\t\t}\n\t\t}\n\t);\n\t\n}\n\n\n\n\n\n\n\n=pod\n\n=head2 screen\n\nC<screen()> is a slight wrapper around the HTML::Template module. See: \n\nL<http://search.cpan.org/~samtregar/HTML-Template/Template.pm>\n\nC<screen> has somewhat of a similar API, but a bit simplier - for example, it also \nincludes support for HTML::Template::Expr: \n\nL<http://search.cpan.org/~samtregar/HTML-Template-Expr/Expr.pm>\n\nwith just a parameter change. The default is to use HTML::Template. \nNo other HTML::Template::* modules are used. \n\nI won't delve into great detail on how to make a HTML::Template or HTML::Template::Expr template, \nbut I would encourage you to look into the docs for the two above modules for the jist. Any valid \nHTML::Template and/or HTML::Template::Expr template can be used for C<screen>.\n\nFinally screen has some (always optional) hooks into Dada Mail's Settings and Subscribers backends, \nso you may tell C<screen> to use that information, instead of passing things in the C<-vars> paramter. \n\nAnyways: \n\n require DADA::Template::Widgets; \n print DADA::Template::Widgets::screen(\\\n    {\n    # ...\n    }\n ); \n\nC<screen> returns back a string with the final result of the template and basically what \nB<HTML::Template>'s C<output> will return. No post processing is done after that. \n\nGetting data to screen can be done in basically two ways: \n\nVia the C<-data> parameter: \n\n my $scalar = 'This is my information!'; \n print DADA::Template::Widgets::screen(\n    {\n        -data => \\$scalar,\n    }\n ); \n\nThe information in B<-data> needs to be a reference to a scalar value. In B<H::T>, it maps to the C<scalarref> parameter. \n\nVia the C<-screen> parameter: \n\n print DADA::Template::Widgets::screen(\n    {\n        -screen => 'somefile.tmpl',\n    }\n );\n\nwhich should be a filename to whatever template you'd like to use. \n\nIn B<H::T>, it maps to the C<filename> parameter. \n\n\nVariables to be used in the template can be passed using the, C<-vars> parameter, which maps to the, \nB<H::T> parameter, C<param>. C<-vars> should hold a reference to a hash: \n\n my $scalar = 'I wanted to say: <!-- tmpl_var var1 -->'; \n print DADA::Template::Widgets::screen(\n    {\n        -data => \\$scalar,\n        -vars   => {var1 => \"This!\"}, \n    }\n );\n\nThis will print:\n\n I wanted to say: This!\n\n\nAnd that's basically screen. Learn HTML::Template and memorize the mappings and you'll be right at home. \n\nA few things to mention: \n\nMany of the Dada Mail modules require you to pass a B<listshortname> some where - C<screen> doesn't,\nand this is by design - it attempts to be separate from any Dada Mail backend or information inside. \n\nThere are hooks in C<screen> to pass variables in the template from the settings and subscriber \nbackend, but they're limited and absolutely optional, but are handy for shortcuts and hey, what isn't \nprogramming but shortcuts?\n\nTo tell C<screen> to use a specific subscriber information, you have two different methods. \n\nThe first is to give the parameters to *which* subscriber to use, via the C<-subscriber_vars_param>: \n\n print DADA::Template::Widgets::screen(\n    {\n    -subscriber_vars_param => \n        {\n            -list  => 'listshortname', \n            -email => 'this@example.com', \n            -type  => 'list',\n        }\n    }\n );\n\nThis will basically have C<screen> call the B<DADA::MailingList::Subscribers::*> C<get_subscriber> \nmethod and pass the parameters set in this hashref. It's best to make sure the subscriber I<exists>, \nor you may run into trouble.\n\nThe subscriber information will be passed to B<HTML::Template> via its C<param> method. The name of \nthe parameters will be appended with, B<subscriber.>, so as not to clobber any other variables you're \npassing, so if you have a field named, \"first_name\", you can use a template var that looks like this: \n\n <!-- tmpl_var subscriber.first_name --> \n\nor: \n\n [subscriber.first_name]\n\nThe following won't work: \n\n <!-- tmpl_var first_name --> \n\n [first_name]\n\nB<Note:> that this dot notation isn't using B<HTML::Template::Plugin::Dot>, but is just a variable \nnaming convention, to give the subscriber information some sort of namespace.\n\n\nThe other magical thing that will happen, is that you'll get a new variable to be used in your template\ncalled, B<subscriber>, which is a array ref of hashrefs with name/value pairs for all your subscriber \nfields. So, this'll allow you to do something like this: \n\n <!-- tmpl_loop subscriber --> \n \n  <!-- tmpl_var name -->: <!-- tmpl_value -->\n \n <!--/tmpl_loop-->\n\nand this will loop over your Profile Fields. \n\nIf you'd like, you can also pass the Profile Fields information yourself - this may be useful if\nyou're in some sort of recursive subroutine, or if you already have the information on hand. You may\ndo so by passing the, C<-subscriber_vars> parameter, I<instead> of the C<-subscriber_vars_param>\nparameter, like so: \n\n use DADA::MailingList::Subscribers; \n my $lh = DADA::MailingList::Subscribers->new({-list => 'listshortname'}); \n \n my $subscriber = $lh->get_subscriber(\n                      {\n                         -email  => 'this@example.com', \n                         -type   => 'list', \n                         -dotted => 1, \n                       }\n                   ); \n \n use DADA::Template::Widgets; \n print DADA::Template::Widgets::screen(\n \n           { \n                -subscriber_vars => $subscriber,\n           }\n       ); \n\nThe, B<subscriber> variable will still be magically created for you. \n\nThe B<-subscriber_vars> parameter is also a way to override what gets printed for the, B<subscriber.> \nvariables, since nothing is done to check the validity of what you're passing. So, keep that in mind - \nall these are shortcuts and syntactic sugar. And we I<like> sugar. \n\n\n\nA similar thing can be used to retrieve the list settings of a particular list: \n\n print DADA::Template::Widgets::screen(\n    {\n    -list_settings_vars_param => \n        {\n            -list  => 'listshortname', \n        }\n    }\n );\n\nor:\n\n use DADA::MailingList::Settings; \n my $ls = DADA::MailingList::Settings->new({-list => 'mylist'}); \n \n my $list_settings = $ls->get(\n                         -dotted => 1, \n                     ); \n \n use DADA::Template::Widgets; \n print DADA::Template::Widgets::screen(\n \n           { \n                -list_settings_vars => $list_settings,\n           }\n       ); \n\nThis will even work, as well in a template: \n\n <!-- tmpl_loop list_settings --> \n \n    <!-- tmpl_var name -->: <!-- tmpl_var value -->\n \n <!-- /tmpl_loop -->\n\nAgain, much of this is syntactical sugar and magic, but a lot of it is to keep organized the various\nsources of your template data. Only at the very final time is all this information folded into itself. \n\nThe precendence for these various variables is: \n\n=over\n\n=item * -list_settings_vars\n\n=item * -subscriber _vars\n\n=item * -vars\n\n=back\n\nWhich means, if you (for whatever weird reason) want to override anything in either the \nB<-list_settings_vars> or B<-subscriber_vars>, you can in B<-vars>\n\n=cut\n\n\n\n\n\nsub screen {  \n\t\n    my ($args) = @_; \n\n    if (! exists($args->{-screen}) && ! exists($args->{-data})){ \n        croak \"no -screen! or -data!\";\n    }\n    \n    if(! exists($args->{-vars})){ \n        $args->{-vars} = {};\n    }\n    \n    # This is for mispelings: \n\tforeach('-list_settings_param', 'list_settings_param', 'list_settings_vars_params', '-list_settings_vars_params', 'list_settings_params', '-list_settings_params'){ \n\t\tif(exists($args->{$_})){ \n\t\t\tcroak \"Incorrect parameter passed to DADA::Template::Widgets:'$_'. Did you mean to pass, '-list_settings_vars_param'? $@\";\n\t\t}\n\t}\n\n\n\n    if(\n        exists($args->{-list_settings_vars})       || \n        exists($args->{-list_settings_vars_param})\n    ){ \n    \n        if( !exists($args->{-list_settings_vars_param}) ){ \n            # Well, nothing. \n            $args->{-list_settings_vars_param} = {}; \n        }\n        else { \n            \n            if(\n                !exists($args->{-list_settings_vars})      &&  # Don't write over something that's already there. \n                 exists($args->{-list_settings_vars_param})    # This is a rehash of the last if() statement, but it's here, for clarity...\n            ){             \n                require DADA::MailingList::Settings; \n                my $ls = DADA::MailingList::Settings->new(\n\t\t\t\t\t\t\t{\n                             \t-list => $args->{-list_settings_vars_param}->{-list},\n                         \t}\n\t\t\t\t\t\t); \n                $args->{-list_settings_vars} = $ls->get(-dotted => 1);                \n                \n                if( !exists($args->{-list_settings_vars_param}->{-i_know_what_im_doing}) ){                     \n                    # this is to get really naughty bits out: \n                    foreach(qw(\n                        password\n                        sasl_smtp_password\n                        pass_auth_id\n                        discussion_pop_password\n                        pop3_username\n                        sasl_smtp_username\n                        discussion_pop_username\n                        cipher_key\n                        \n                    )){ \n                        if(exists($args->{-list_settings_vars}->{'list_settings.' . $_})){ \n                            delete($args->{-list_settings_vars}->{'list_settings.' . $_}); \n                        }  \n                    }\n                }\n            }\n       }\n       \n       if(!exists($args->{-list_settings_vars_param}->{-dot_it})){\n            $args->{-list_settings_vars_param}->{-dot_it} = 0; \n       }\n\n\n       if($args->{-list_settings_vars_param}->{-dot_it} == 1){\n            \n            my $new = {}; \n            \n            while (my ($k, $v) = each(%{$args->{-list_settings_vars}})){\n                if($k =~ m/^list_settings\\./){ \n                    $new->{$k} = $v \n                }\n                else { \n                    $new->{'list_settings.' . $k} = $v; \n                }       \n            }\n            \n            $args->{-list_settings_vars} = $new;         \n       }\n\n\n\n      if(!exists($args->{-vars}->{list_settings})){\n        \n            $args->{-vars}->{list_settings} = [];\n            foreach(keys %{$args->{-list_settings_vars}}){ \n                my $nk = $_; \n                $nk =~ s/list_settings\\.//; \n                push( @{$args->{-vars}->{list_settings}}, {name => $nk, value => $args->{-list_settings_vars}->{$_}});   \n            }\n        }\n    }\n    else { \n        $args->{-list_settings_vars}       = {};\n        $args->{-list_settings_vars_param} = {};\n    }\n    \n    if(\n        exists($args->{-subscriber_vars})       || \n        exists($args->{-subscriber_vars_param})\n    ){ \n        \n        my ($subscriber_vars, $subscriber_loop_vars) = subscriber_vars($args); \n        $args->{-subscriber_vars}    = $subscriber_vars; \n        $args->{-vars}->{subscriber} = $subscriber_loop_vars;  \n        \n    } # exists($args->{-subscriber_vars}) || exists($args->{-subscriber_vars_param})\n    else { \n        $args->{-subscriber_vars}       = {};\n        $args->{-subscriber_vars_param} = {};\n    }\n    \n    \n\t###\n\n\tif($DADA::Config::PROFILE_OPTIONS->{enabled} == 1){ \n\t\tif(\n\t\t     exists($args->{-profile_vars})       || \n\t\t     exists($args->{-profile_vars_param})\n\t\t ){ \n \n\t\t     if( !exists($args->{-profile_vars_param}) ){ \n\t\t         # Well, nothing. \n\t\t         $args->{-profile_vars_param} = {}; \n\t\t     }\n\t\t     else { \n         \n\t\t         if(\n\t\t             !exists($args->{-profile_vars})      &&  # Don't write over something that's already there. \n\t\t              exists($args->{-profile_vars_param})    # This is a rehash of the last if() statement, but it's here, for clarity...\n\t\t         ){  \n\t\t\t\t\tif(exists($args->{-profile_vars_param}->{-email})){ \n\t\t\t\t         require DADA::Profile; \n\t\t\t\t\t\t my $prof = DADA::Profile->new(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t-email => $args->{-profile_vars_param}->{-email},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif($prof->exists){ \n\t\t\t             $args->{-profile_vars} = $prof->get(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t-dotted => 1,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t        \t}\n\t\t\t\t\t\telse { \n\t\t\t\t\t\t\t$args->{-profile_vars} = {};\n\t\t\t\t\t\t}\n\t\t\t         }\n\t\t\t\t}\n\t\t    }\n    \n\n\t\t   if(!exists($args->{-vars}->{profile})){\n     \n\t\t         $args->{-vars}->{profile} = [];\n\t\t         foreach(keys %{$args->{-profile_vars}}){ \n\t\t             my $nk = $_; \n\t\t             $nk =~ s/profile\\.//; \n\t\t             push( @{$args->{-vars}->{profile}}, {name => $nk, value => $args->{-profile_vars}->{$_}});   \n\t\t         }\n\t\t     }\n\t\t }\n\t\t else { \n\t\t     $args->{-profile_vars}       = {};\n\t\t     $args->{-profile_vars_param} = {};\n\t\t }\n\t}\n\telse { \n\t\t$args->{-profile_vars}       = {};\n\t    $args->{-profile_vars_param} = {};\n\t}\n\n\tif(exists($args->{-time})){ \n\t\t$TMP_TIME = $args->{-time};\n\t}\n\n\n    \n     my $template_vars = {}; \n        %$template_vars = (%{$args->{-list_settings_vars}}, %{$args->{-subscriber_vars}}, %{$args->{-profile_vars}}, %{$args->{-vars}}); \n\n\t\n\t\t\t\n\t\t\n    if(exists($args->{-webify_and_santize_these})){ \n\t\tif(exists($args->{-list_settings_vars_param}->{-list})) { \n\t\t\t$template_vars = webify_and_santize(\n\t            {\n\t                -to_sanitize => $args->{-webify_and_santize_these},\n\t                -vars        => $template_vars,\n\t\t\t\t\t-list        => $args->{-list_settings_vars_param}->{-list},\n\n\t            }\n\t        );\n\t\t}\n\t\telse { \n\t\t\t$template_vars = webify_and_santize(\n\t            {\n\t                -to_sanitize => $args->{-webify_and_santize_these},\n\t                -vars        => $template_vars,\n\n\t            }\n\t        );\t\t\t\n\t\t}\n\t\t\n\n    }\n\n\n\n\t\t\n\tif(exists($args->{-webify_these})){ \n\t\tforeach(@{$args->{-webify_these}}){ \n\t    \t$template_vars->{$_} = markdown_to_html(\n\t\t\t\t{\n\t\t\t\t\t-str    => $template_vars->{$_},\n\t\t\t\t\t-method => 'fast', \n\t\t\t\t}\n\t\t\t);\n\t    }\n\t}\n\n\n\t# Which templating engine to use? \n\t#\n\tmy $template; \t\n\tmy $filters = []; \n\n \tif(exists($args->{-screen})){\n\t\t\n\t\tpush(@$filters, \n\t\t\t\t{ \n\t\t\t\t\tsub    => \\&decode_str,\n\t\t\t\t\tformat => 'scalar' \n\t\t\t\t}\n\t\t); \n\t}\n\tpush(@$filters, \n\t    { \n\t\t\tsub => \\&hack_in_tmpl_set_support,\n\t\t\tformat => 'scalar' \n\t\t},\n\t);\n\tpush(@$filters, \n\t    { \n\t\t\tsub => \\&filter_time_piece,\n\t\t\tformat => 'scalar' \n\t\t},\n\t);\n\t \n\t# This is very strange - but filters break images (binary stuff) \n\tif(exists($args->{-img})){ \n\t\tif($args->{-img} == 1){ \n\t\t\t$filters = [];\n\t\t}\n\t}\n\t\n\trequire HTML::Template::MyExpr;\n\t\n\tif(exists($args->{-screen})){ \n\t\t$template = HTML::Template::MyExpr->new(\n\t\t\t%Global_Template_Options, \n\t\t\tfilename => $args->{-screen},\n\t\t\tfilter   => $filters, \n\t\t);\n\t}elsif(exists($args->{-data})){ \n\t\t\n\t\tif($args->{-decode_before} == 1){ \n\t\t\t${$args->{-data}} = safely_decode(${$args->{-data}}, 1); \n\t\t}\n\t\t$template = HTML::Template::MyExpr->new(\n\t\t\t%Global_Template_Options, \n\t\t\tscalarref => $args->{-data},\n\t\t\tfilter    => $filters, \n\t\t);\n\t}else{ \n\t\tcroak \"you MUST pass either a scarlarref in, '-data' or a filename in, '-screen'!\"; \n\t}\n\n\n\tmy %date_params = date_params(); \n\tmy %profile_settings_vars = profile_settings_vars();\n\tmy %final_params = (\n\t\t%Global_Template_Variables,\t\t\n\t\t%profile_settings_vars,\t\t\t\n\t\t%date_params,\n\t\t%$template_vars,\n\t\t%_ht_tmpl_set_params,\n\t);\n\tif(exists($args->{-list})){ \n\t\t$final_params{list} =  $args->{-list};  \n\t}\n\t\n   $template->param(%final_params); \n\t%_ht_tmpl_set_params = (); \n\tif(exists($args->{-return_params})){ \n\t\tif($args->{-return_params} == 1){ \t\t\n\t\t\treturn ($template->output(), {%final_params});\t\n\t\t}\n\t\telse { \t\t\t\t\t \n\t\t\treturn $template->output();\n\t\t}\n\t}\n\telse { \n\t\treturn $template->output();\n\t}\n}\n\n\n\nsub subscriber_vars {\n    \n    my ($args) = @_;\n     \n    if(!exists($args->{-subscriber_vars_param})){ \n        $args->{-subscriber_vars_param} = {}; \n    }\n    else { \n\n        if(\n            !exists($args->{-subscriber_vars})       &&  # Don't write over something that's already there. \n             exists($args->{-subscriber_vars_param})     # This is a rehash of the last if() statement, but it's here, for clarity...\n        ){       \n\n\n      \t\tif(\n    \t\t\texists($args->{-subscriber_vars_param}->{-email}) &&\n    \t\t\texists($args->{-subscriber_vars_param}->{-type})\n    \t\t){ \n\n        \t    require  DADA::MailingList::Subscribers;     \n\n                my $lh = DADA::MailingList::Subscribers->new(\n    \t\t\t\t\t\t{\n                            \t-list => $args->{-subscriber_vars_param}->{-list},\n                         \t}\n    \t\t\t\t\t); \n\n    \t\t\t# What happens if we pass an email address that's not valid? \n    \t\t\teval { \n                    $args->{-subscriber_vars} = $lh->get_subscriber(\n                                                    {\n                                                        -email  => $args->{-subscriber_vars_param}->{-email}, \n                                                        -type   => $args->{-subscriber_vars_param}->{-type},\n                                                        -dotted => 1, \n                                                    }\n                                                ); \n    \t\t\t};\n    \t\t\tif($@){ \n    \t\t\t\t$args->{-subscriber_vars} = {};\n    \t\t\t\tcarp $@; \n    \t\t\t}\n            }\n\n        } #if(!exists($args->{-subscriber_vars})){ \n\n    \t\tif(exists($args->{-subscriber_vars_param}->{-use_fallback_vars})){ \n    \t\t\tif($args->{-subscriber_vars_param}->{-use_fallback_vars} == 1){ \n\n    \t\t\t\trequire DADA::MailingList::Subscribers;\n    \t\t\t  \tmy $lh = DADA::MailingList::Subscribers->new(\n    \t\t\t\t\t\t\t{\n                                \t-list => $args->{-subscriber_vars_param}->{-list},\n                             \t}\n    \t\t\t\t\t\t);\n\n    \t\t\t\t\t\tmy $field_attrs = $lh->get_all_field_attributes; \n    \t\t\t\t\t\tmy $fallback_vars = {}; \n    \t\t\t\t\t\tforeach(keys %$field_attrs){ \n    \t\t\t\t\t\t\t$fallback_vars->{'subscriber.' . $_} = $field_attrs->{$_}->{fallback_value};\n    \t\t\t\t\t\t}\n    \t\t\t\t# This is sort of an odd placement for this, but I'm not sure \n    \t\t\t\t# Where I want this yet...  (perhaps $lh->get_fallback_values ?)\n\n    \t\t\t\t\tif(!exists($args->{-subscriber_vars}->{'subscriber.email'})){ \n    \t\t\t\t\t\t$fallback_vars->{'subscriber.email'} = 'example@example.com'; \n    \t\t\t\t\t}\n    \t\t\t\t\tmy ($name, $domain) = split('@', $fallback_vars->{'subscriber.email'}, 2); \n    \t\t\t\t\t$fallback_vars->{'subscriber.email_name'}   = $name; \n    \t\t\t\t\t$fallback_vars->{'subscriber.email_domain'} = $domain; \n    \t\t\t\t### /\n\n    \t\t\t\tforeach(keys %$fallback_vars){ \n    \t\t\t\t\tif(! exists($args->{-subscriber_vars}->{$_})){ \t\n    \t\t\t\t\t\t#warn \"I'm putting in a fallback field $_ that equals: \" . $fallback_vars->{$_}; \n    \t\t\t\t\t\t$args->{-subscriber_vars}->{$_} = $fallback_vars->{$_};\n    \t\t\t\t\t}\t\n    \t\t\t\t\telse  { \n    \t\t\t\t\t\t#warn \"no need for the fallback var! We're good with: \" . $args->{-subscriber_vars}->{$_}; \n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t}\t\n\n    \t\t}#if(exists($args->{-subscriber_vars_param}->{-use_fallback_vars}){\n\n\n    \tif(exists($args->{-subscriber_vars_param}->{-use_fallback_vars})){ \n    \t\tif($args->{-subscriber_vars_param}->{-use_fallback_vars} == 1){ \n    \t\t\t# DEV: This is a really really REALLY good place to put an optimization - \n    \t\t\t# No caching is currently done, either by this module, or another. \n    \t\t\t# That's no good! \n    \t\t\t# At the very least, we could put caching in \n    \t\t\t# DADA::ProfileFieldsManager and just keep that around... \n    \t\t\t# Ugh. \n    \t\t\t# \n    \t\t\t# Updated: At least in the mass mailing stuff, -use_fallback_vars param is not called, \n    \t\t\t# The fallback field stuff is done with a cached copy of DADA::ProfileFieldsManager\n    \t\t\t# That's a good thing.\n\n    \t\t\trequire DADA::MailingList::Subscribers;\n    \t\t  \tmy $lh = DADA::MailingList::Subscribers->new(\n    \t\t\t\t\t\t{\n                            \t-list => $args->{-subscriber_vars_param}->{-list},\n                         \t}\n    \t\t\t\t\t);\n\n    \t\t\t\t\tmy $fallback_vars = $lh->get_all_field_attributes; \n\n    \t\t\t# This is sort of an odd placement for this, but I'm not sure \n    \t\t\t# Where I want this yet...  (perhaps $lh->get_fallback_values ?)\n    \t\t\t\t$fallback_vars->{'subscriber.email'}        = 'example@example.com'; \n    \t\t\t    $fallback_vars->{'subscriber.email_name'}   = 'example'; \n    \t\t\t    $fallback_vars->{'subscriber.email_domain'} = 'example.com';    \n    \t\t\t### /\n\n    \t\t\tforeach(keys %$fallback_vars){ \n    \t\t\t\tif(! exists($args->{-subscriber_vars}->{$_})){ \n    \t\t\t\t\t$args->{-subscriber_vars}->{$_} = $fallback_vars->{$_};\n    \t\t\t\t}\t\n    \t\t\t}\n    \t\t}\t\n\n    \t}#if(exists($args->{-subscriber_vars_param}->{-use_fallback_vars}){\n\n    } #if(!exists($args->{-subscriber_vars_param})){ \n\n\n    if( !exists($args->{-vars}->{subscriber}) ){\n\n        $args->{-vars}->{subscriber} = [];\n\n        if(exists($args->{-subscriber_vars_param}->{-in_order})){ \n            foreach(sort %{$args->{-subscriber_vars}}){ \n                my $nk = $_; \n                $nk =~ s/subscriber\\.//; \n                push( @{$args->{-vars}->{subscriber}}, {name => $nk, value => $args->{-subscriber_vars}->{$_}});\n            }\n        }\n        else { \n            foreach(keys %{$args->{-subscriber_vars}}){ \n                my $nk = $_; \n                   $nk =~ s/subscriber\\.//; \n                push( @{$args->{-vars}->{subscriber}}, {name => $nk, value => $args->{-subscriber_vars}->{$_}});\n            }\n        } #if(exists($args->{-subscriber_vars_param}->{-in_order})){ \n    } #if( !exists($args->{-vars}->{subscriber}) ){\n\n    return ($args->{-subscriber_vars}, $args->{-vars}->{subscriber}); \n\n}\n\nsub date_params { \n\t\n\tmy $time = shift || $TMP_TIME || time;\n\t\n\tmy %params = ();\n\t \n\t\n\t# Anything more than this, and I should probably use \n\t# DateTime or something. \n\t# Don't want to for performance reasons\n\t# OR, use Time::Piece and probably remove some bugs I've created. \n\t#\n\t# 0 1 2 3 4 5 6 7 8\n\t# $mday = '17'; (Date)\n\t# $wday = '1' (Monday)\n\t# $yday =  289the day of the year (ie: in 365 days, this is the nth day\")\n    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =\n    \tlocaltime($time);\t\n\n    my $months = [\n\tqw(\n        January  \n        February \n        March    \n        April    \n        May      \n        June     \n        July     \n        August   \n        September\n        October  \n        November \n        December \n\t)\n    ];           \n\n\n    my $abbr_months = [\n\tqw(\n        Jan\n        Feb\n        Mar    \n        Apr    \n        May      \n        Jun     \n        Jul     \n        Aug   \n        Sep\n        Oct \n        Nov\n        Dec \n\t)\n    ];\n\n\t\n\tmy $days = [\n\tqw( \n\t\tSunday   \n\t\tMonday   \n\t\tTuesday  \n\t\tWednesday\n\t\tThursday \n\t\tFriday   \n\t\tSaturday    \n\t)\n\t];\n\n\tmy $abbr_days = [\n\tqw( \n\t\tSun\n\t\tMon   \n\t\tTue  \n\t\tWed\n\t\tThu \n\t\tFri   \n\t\tSat    \n\t)\n\t];\n\t\n\t\n\tmy $mail_day_values = {\n\t\t1  => '1st', \n\t\t2  => '2nd', \n\t\t3  => '3rd', \n\t\t4  => '4th', \n\t\t5  => '5th',\n\t\t6  => '6th', \n\t\t7  => '7th', \n\t\t8  => '8th', \n\t\t9  => '9th', \n\t\t10 => '10th', \n\t\t11 => '11th',\n\t\t12 => '12th', \n\t\t13 => '13th', \n\t\t14 => '14th', \n\t\t15 => '15th', \n\t\t16 => '16th', \n\t\t17 => '17th', \n\t\t18 => '18th', \n\t\t19 => '19th', \n\t\t20 => '20th', \n\t\t21 => '21st', \n\t\t22 => '22nd', \n\t\t23 => '23rd', \n\t\t24 => '24th', \n\t\t25 => '25th', \n\t\t26 => '26th', \n\t\t27 => '27th', \n\t\t28 => '28th', \n\t\t29 => '29th', \n\t\t30 => '30th', \n\t\t31 => '31st',\n\t};\n\t\n    $params{'date.time'}                 = $time;\n    $params{'date.localtime'}            = scalar( localtime($time) );\n    $params{'date'}                      = $params{'date.localtime'};\n    $params{'date.month'}                = $mon + 1;\n    $params{'date.named_month'}          = $months->[$mon];\n    $params{'date.padded_month'}         = sprintf( \"%02d\", $mon + 1 );\n    $params{'date.abbr_named_month'}     = $abbr_months->[$mon];\n    $params{'date.day'}                  = $mday;\n    $params{'date.day_of_the_week'}      = $days->[$wday];\n    $params{'date.padded_day'}           = sprintf( \"%02d\", $mday );\n    $params{'date.abbr_day_of_the_week'} = $abbr_days->[$wday];\n    $params{'date.nth_day'}              = $mail_day_values->{$mday};\n    $params{'date.year'}                 = $year += 1900;\n    $params{'date.abbr_year'}            = sprintf( \"%02d\", $year % 100 );\n\t$params{'date.24_time'}              = sprintf(\"%02d:%02d:%02d\", $hour, $min, $sec);\n\t$params{'date.timezone'}             = strftime(\"%Z\", localtime()); \n\t\n\treturn %params;\n\t\n}\n\n\nsub profile_settings_vars { \n\t\n\tmy %vars = (\n\t\t'profile_settings.enabled' => $DADA::Config::PROFILE_OPTIONS->{enabled},\n\t\t\n\t\t# backwards compat.: \n\t\tPROFILE_ENABLED            => $DADA::Config::PROFILE_OPTIONS->{enabled},\n\t\t# are we really going to use these?\n\t\t#'profile.email'                            => $DADA::Config::PROFILE_OPTIONS->{profile_email},\n\t\t#'profile.enable_captcha'                   => $DADA::Config::PROFILE_OPTIONS->{enable_captcha},\n\t\t\n\t\t\n\t); \n\tfor(qw(\n\t\t register                  \n\t\t password_reset            \n\t\t profile_fields            \n\t\t mailing_list_subscriptions\n\t\t protected_directories     \n\t\t update_email_address      \n\t\t change_password           \n\t\t delete_profile            \n\t)){ \n\t\tif(exists($DADA::Config::PROFILE_OPTIONS->{features}->{$_})){ \n\t\t\t$vars{'profile_settings.' . $_} = $DADA::Config::PROFILE_OPTIONS->{features}->{$_}; \n\t\t}\n\t}\n\t\n\treturn %vars;\n}\n\n\n=pod\n\n=head2 wrap_screen\n\n\tmy $scrn = wrap_screen(\n\t\t{ \n\t\t\t-with => 'list', # or, 'admin', \n\t\t\t-screen => 'some_screen.tmpl', # or, \"-data => \\$some_data, \n\t\t\t# ... other options\n\t\t}\n\t); \n\nC<wrap_screen> allows you to wrap either one of the two templates (currently) \nthat Dada Mail uses to wrap other template in: C<list_template.tmpl> and\nC<admin_template.tmpl>. \n\nIt takes the same options as, C<screen> and adds a few of its own: \n\nC<-with> is required and should be set to either, C<list>, or C<admin>, depending on \nwhether you want to wrap the template in either the list or admin template. \n\nC<-wrapper_params> can also be passed and the value of its parameters (confusingly)\nwill be different, depending on if you're using C<list> or, C<admin> for, C<-with>\n\nFor, C<list>:\n\n=over\n\n=item * any parameter you would usually send to DADA::Template::HTML::list_template()\n\nExample: \n\n\tmy $scrn = DADA::Template::Widgets::wrap_screen(\n\t\t{\n\t\t\t-screen => 'preview_template.tmpl',\n\t\t\t-with   => 'list', \n\t\t\t-wrapper_params => { \n\t\t\t\t-data => \\$template_info, # This is the actual template we'll be using! \n\t\t\t},\n\t\t}\n\t);\n\n=back\n\nFor, C<admin> \n\n=over\n\n=item * any parameter you would usually send to, DADA::Template::HTML::admin_template\n\n\tmy $scrn .= DADA::Template::Widgets::wrap_screen(\n\t\t{\n\t\t\t-screen => 'sending_monitor_index_screen.tmpl',\n            -with   => 'admin', \n\t\t\t-wrapper_params => { \n\t\t\t\t-Root_Login => 1,\n\t\t\t\t-List       => 'my_list',  \n\t\t\t},\n\t\t\t# ... \n\t\t}\n\t);\n\n=back\n\n=cut \n\n\nsub wrap_screen { \n\t\t\n\tmy ($args) = @_; \n\n\tif(!exists($args->{-with})){ \n\t\tcroak \"you must pass the, '-with' parameter\"; \n\t}\n\telse { \n\t\tif($args->{-with} !~ m/^(list|admin)$/){ \n\t\t\tcroak \"'-with' parameter must be either, 'list' or, 'admin'\";\n\t\t}\n\t}\n\tmy $with = $args->{-with}; \n\t# I'd rather not have this passed to, screen(); \n\tdelete $args->{-with}; \n\t\n\t# I need params from the first template passed. \n\t$args->{-return_params} = 1;\n\tmy ($tmpl, $params) = screen($args);\n\n\t# \"content\" is passed to the wrapper template\n\tmy $vars = { \n\t\tcontent => $tmpl, \n\t};\n\tfor(qw(title show_profile_widget load_wysiwyg_editor load_google_viz load_colorbox load_captcha_js load_jquery_validate load_datetimepicker SUPPORT_FILES_URL)){ \n\t\tif(exists($params->{$_})){ \n\t\t\t# variables within variables... \n\t\t\t$vars->{$_} = $params->{$_}; \n\t\t\tif($vars->{$_} =~ m/\\<\\!\\-- tmpl_/){\n\t\t\t\t$vars->{$_} = screen({-data => \\$vars->{$_}, -vars => $params}); \n\t\t\t}\n\t\t}\n\t}\t \n\t\n\tif($with eq 'list'){ \n\t\n\t\t# list_template is the wrapper template - it calls, screen()\n\t\t# This will aggravate you, as I'm aggravated by it - there's 3 ways to send the listshortname to screen()\n\t\t# And list_template() here has one way, so we have to figure out where, \"list\" is, and use it. \n\t\t# Here we go: \n\t\tmy $list_param = undef; \n\t\tif(exists($args->{-list})){ \n\t\t\t$list_param =  $args->{-list}; \n\t\t}\n\t\telsif(exists($args->{-list_settings_vars})){\n\t\t\tif(exists($args->{-list_settings_vars}->{list})){ \n\t\t\t\t$list_param =  $args->{-list_settings_vars}->{list}; \n\t\t\t}\n\t\t\telsif(exists($args->{-list_settings_vars}->{'list_settings.list'})){ \n\t\t\t\t$list_param =  $args->{-list_settings_vars}->{'list_settings.list'}; \n\t\t\t}\t\n\t\t}\n\t\telsif(exists($args->{-list_settings_vars_param}->{-list})){\n\t\t\t$list_param = $args->{-list_settings_vars_param}->{-list}; \n\t\t}\n\t\t\n\t\trequire DADA::Template::HTML; \t\n\t\tmy $template = DADA::Template::HTML::list_template(\n\t\t\t%{$args->{-wrapper_params}}, # This is currently, \"blank\" - where is put in here - header_params? \n\t\t\t-vars => $vars,\t\t\t\t \n\t\t\t-Part => 'full', \n\t\t\t-List => $list_param, \n\t\t\t); \t\t\t\n\t\treturn $template; \n\t}\n\telsif($with eq 'admin'){ \n\t\tmy %wysiwyg_vars = ();\n\t\tif(exists($args->{-wrapper_params}->{-List})){ \n\t\t\t%wysiwyg_vars = DADA::Template::Widgets::make_wysiwyg_vars($args->{-wrapper_params}->{-List});  \n\t\t\t$vars = {(%$vars, %wysiwyg_vars)};\n\t\t}\n\t\trequire DADA::Template::HTML; \t\n\t\tmy $template = DADA::Template::HTML::admin_template(\n\t\t\t%{$args->{-wrapper_params}}, \n\t\t\t-vars => $vars,\t\t\t\t \t\t\t\t\t\t \n\t\t\t-Part => 'full', \n\t\t\t); \n\t\treturn $template;\n\t}\n\telse { \n\t\t# I think it may be impossible to get here. \n\t\tdie \"only 'list' and 'admin' wrapping is currently supported.\"; \n\t}\n}\n\nsub validate_screen { \n\tmy ($args) = @_; \n\t\n\t# use Data::Dumper; \n\t# carp '$args' . Dumper($args); \n\t\n\tmy $r      = 1; \n\tmy $errors = undef; \n\tmy $scrn   = undef; \n\ttry { \n\t\t$scrn = screen({%$args}); \n\t} catch {\n\t\t# warn 'validate_screen FAILED!';\n\t\t# warn $_; \n\t\t$r      = 0; \n\t\t$errors = $_; \n\t};\n\t# warn 'validate_screen PASSED!';\n\treturn ($r, $errors); \n}\n\nsub decode_str { \n\tmy $ref = shift;\n \t   ${$ref} = safely_decode(${$ref}); \n}\n\nsub not_defined { \n    my $ref = shift;\n#    use Data::Dumper; \n#    warn Dumper($ref); \n    \n    if(ref($ref) eq 'ARRAY'){\n        return 1 if defined($ref->[0]); \n    }\n    else { \n        return 1 if ! defined($ref); \n    }\n    return 0;\n}\nsub hack_in_tmpl_set_support {\n    my $text_ref = shift;\n\n    my $match = qr/\\<\\!\\-\\- tmpl_set name\\=\\\"(.*?)\\\" value\\=\\\"(.*?)\\\" \\-\\-\\>/;\n\t\t\t\t\t#\t<!-- set name=\"one\" value=\"two\" -->\n    my @taglist = $$text_ref =~ m/$match/gi;\n    while (@taglist) {\n        my ( $t, $v ) = ( shift @taglist, shift @taglist );\t\t\n\t\t$_ht_tmpl_set_params{$t} = $v;\n    }\n\n    $$text_ref =~ s/$match//gi;\n}\n\nsub filter_time_piece {\n\t\n    my $text_ref = shift;\n\tmy $time     = $TMP_TIME || time; \n\t\n    my $match = qr/\\<\\!\\-\\- tmpl_strftime (.*?) \\-\\-\\>/;\n    \n\tmy @taglist = (); \n\t@taglist = $$text_ref =~ m/$match/gi;\n    \n\tmy $can_use_time_piece = 1;\n\tmy $can_use_posix      = 1; ; \n\tmy $t                  = undef; \n\tif(exists($taglist[0])){  \n\t\t\n\t\ttry { \n\t\t\trequire Time::Piece; \n\t\t\t#$t = Time::Piece->new;\n\t\t     $t = Time::Piece::localtime($time);\n\t\t} catch {\n\t\t\t$can_use_time_piece = 0; \n\t\t\tcarp \"Time::Piece doesn't work!? $_\"; \n\t\t};\n\t\t\n\t\tif($can_use_time_piece == 0){ \n\t\t\t# I mean, who knows. \n\t\t\ttry { \n\t\t\t\trequire POSIX; \n\t\t\t\tPOSIX::->import( 'strftime' );\n\t\t\t} catch {\n\t\t\t\t$can_use_posix = 0; \n\t\t\t};\n\t\t}\n\t\tif($can_use_time_piece == 0 && $can_use_posix == 0){ \n\t\t\tcroak '<!-- tmpl_var tmpl_strftime [...] --> tags unsupported! Install Time::Piece!'; \n\t\t}\n\t\t\n\t\twhile (@taglist) {\n\t\t\t # I have no understanding of this, rather than, my $format(@taglist) { } \n\t\t\tmy $format = shift @taglist;\n\t\t\t\n\t\t\tmy $formatted_time = undef; \n\t\t\t\n\t\t\tif($can_use_time_piece) { \n\t\t\t\t$formatted_time = $t->strftime($format);\n\t\t\t}\n\t\t\telse { \n\t\t\t\tmy ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($time);\n\t\t\t\t$formatted_time = POSIX::strftime($format, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst );\n\t\t\t}\n\t\t\tmy $formatted_match = quotemeta(\"<!-- tmpl_strftime $format -->\");\n\t\t\t$$text_ref =~ s/$formatted_match/$formatted_time/gi;\n\t    }\n\n\t}\n   \n}\n\n\nsub webify_and_santize { \n\n    my ($args) = @_; \n    \n    if(!exists($args->{-vars})){ \n        die \"need to pass, -vars\"; \n    }\n    \n    if(!exists($args->{-to_sanitize})){ \n        die \"need to pass, -to_sanitize\"; \n    }\n    \n\tif(! exists($args->{-list})){ \n\t\t$args->{-list} = undef; \n\t}\n    foreach(@{$args->{-to_sanitize}}){ \n    \n        \n\t\t\n\t\t# Markdown seems to wrap all strings in <p> tags\n\t\tif(\n\t\t\t   $_ eq 'list_settings.discussion_pop_email'\n\t\t\t|| $_ eq 'discussion_pop_email'\n\t\t\t|| $_ eq 'list_settings.list_owner_email'\t\t\t\n\t\t\t|| $_ eq 'list_settings.list_owner_email'\t\t\t\n\t\t\t|| $_ eq 'list_owner_email'\t\t\t\n\t\t\t|| $_ eq 'list_settings.admin_email'\t\t\t\n\t\t\t|| $_ eq 'admin_email'\t\t\t\n\t\t){\n\t\t\tplaintext_to_html({-str => $args->{-vars}->{$_}});\n\t\t}\n\t\telse { \n\t        $args->{-vars}->{$_} = markdown_to_html({-str =>$args->{-vars}->{$_}});\n\t\t}\n\t\t\n        $args->{-vars}->{$_} = _email_protect(\n\t\t\t{\n\t\t\t\t-string => $args->{-vars}->{$_},\n\t\t\t\t-list   => $args->{-list}, #?\n\t\t\t}\n\t\t);\n\t\t\n          \n        \n    }\n    \n    return $args->{-vars};\n    \n}\n\n\n\n\nsub _email_protect { \n    \n\tmy ($args) = @_; \n    my $str  = $args->{-string};\n \tmy $list = undef; \n\tmy $ls   = undef; \n    if(exists($args->{-list}) && $args->{-list} ne undef){ \n\t\t$list = $args->{-list};\n\t\trequire DADA::MailingList::Settings; \n\t\t$ls = DADA::MailingList::Settings->new({-list => $list});\n\t}\n    \n\n    # strange module - API based on File::Find I guess.\n\trequire Email::Find;\n \tmy $found_addresses = []; \n   \n\tmy $finder = Email::Find->new(sub {\n\t\t\t\t\t\t\t\t\tmy($email, $orig_email) = @_;\n\t\t\t\t\t\t\t\t\tpush(@$found_addresses, $orig_email); \n\t\t\t\t\t\t\t\t\treturn $orig_email; \n\t\t\t\t\t\t\t\t});\n\t$finder->find(\\$str); \n\t\n\tforeach my $fa (@$found_addresses){ \t\n\t\tif($list){ \t\t\t\n\t\t\tif($ls->param('archive_protect_email') eq 'spam_me_not'){ \t\t\n\t            my $pe = spam_me_not_encode($fa);\n\t            my $le = quotemeta($fa); \n\t            $str =~ s/$le/$pe/g;   \n\t        }\n\t\t}\n\t\telse { \n\t\t\t my $pe = spam_me_not_encode($fa);\n\t         my $le = quotemeta($fa); \n\t         $str =~ s/$le/$pe/g;\n\t\t}\n\t}\n\n    return $str; \n }\n\n\n\n\nsub subscription_form { \n\n   \n    my ($args) = @_; \n\t\n    my $list = undef; \n\tif(exists($args->{-list})){ \n\t\t$list = $args->{-list};\n\t}\n    \n    if(! exists($args->{-form_type})){ \n\t\t$args->{-form_type} = 'full';\n\t}\n\n    if(! exists($args->{-script_url})){ \n        $args->{-script_url} = $DADA::Config::PROGRAM_URL; \n    }\n    \n        \n    if(! exists($args->{-multiple_lists})){ \n        $args->{-multiple_lists} = 0; \n    }\n\n\tif(! exists($args->{-show_fields})){ \n\t\t$args->{-show_fields} = 1; \n\t}\n\t\n\tif(! exists($args->{-magic_form})){\n    \t$args->{-magic_form} = 1; \n\t}\n\n\tif(! exists($args->{-show_fieldset})) { \n\t\t$args->{-show_fieldset} = 1;\n\t}\n\t\n\tif(! exists($args->{-subscription_form_id})) { \n\t\t$args->{-subscription_form_id} = undef;\n\t}\n\t\n\tif(! exists($args->{-add_recaptcha_js})) { \n\t\t$args->{-add_recaptcha_js} = 0;\n\t}\n\t\n\tif(! exists($args->{-form_target})) { \n\t\t$args->{-form_target} = '_self';\n\t}\t\n\n    my @available_lists = available_lists(-Dont_Die => 1); \n    if(! $available_lists[0]){ \n        return ''; \n    }\n    \n    \n    require DADA::ProfileFieldsManager; \n    my $pfm               = DADA::ProfileFieldsManager->new; \n\tmy $subscriber_fields = $pfm->fields(\n\t\t{\n\t\t\t-show_hidden_fields => 0,\n\t\t}\n\t);\n\t\t\n\tmy $field_attrs       = $pfm->get_all_field_attributes;\n\t\n\tmy $named_subscriber_fields = [];\n\n\tforeach(@$subscriber_fields){ \n\t    push(\n\t\t\t@$named_subscriber_fields, \n\t\t\t\t{\n\t\t\t\t\tname        => $_, \n\t\t\t\t\tpretty_name => $field_attrs->{$_}->{label},\n\t\t\t\t\tlabel       => $field_attrs->{$_}->{label},\n\t\t\t\t\trequired    => $field_attrs->{$_}->{required},\n\t\t\t\t}\n\t\t\t)\n\t}\n\t\n\tif(! exists ($args->{-ignore_cgi}) && $args->{-ignore_cgi} != 1){ \n           foreach(qw(email list )){ \n            if(! exists ( $args->{'-' . $_} ) && defined($q->param($_))){ \n                $args->{'-' . $_} = xss_filter($q->param($_));\n            }\n        }\n        \n        my $i = 0; \n        foreach my $sf(@$subscriber_fields){ \n            if(defined($q->param($sf))){ \n                $named_subscriber_fields->[$i]->{given_value} = xss_filter($q->param($sf));\n            }\n            $i++;\n        }\n        undef($i);\n\n\t\t$args->{-profile_logged_in} = 0; \n\n\t\tif (   $DADA::Config::PROFILE_OPTIONS->{enabled} != 1)\n\t    {\n\t\t\t# ... \n\t\t}\t\t\n    }\n\n    if(\n\t\t$list && \n\t\tcheck_if_list_exists( -List=> $list, -Dont_Die  => 1) > 0\n\t){ \n\t\n\t\trequire DADA::MailingList::Settings; \n        my $ls = DADA::MailingList::Settings->new({-list => $list}); \n  \n\t\t# This is so that we don't show the entire form, if we don't have to:\n\t\tif(\n\t\t\t(\n\t\t\t\t$ls->param('invite_only_list') == 1\n\t\t\t&&  $ls->param('closed_list') == 1\n\t\t\t) \n\t\t){ \n\t\t\tif($ls->param('invites_show_profile_fields_in_subscription_form') == 1){ \n\t\t\t\t$args->{-show_fields} = 1;\n\t\t\t}\n\t\t\telse { \n\t\t\t\t$args->{-show_fields} = 0;\n\t\t\t} \n\t\t}\n\t\t\n\t\tmy $tmpl_name = 'subscription_form_widget.tmpl'; \n\t\tif($args->{-form_type} eq 'minimal'){ \n \t\t\t$tmpl_name = 'minimal_subscription_form.tmpl'; \n\t\t}\n\t\telsif($args->{-form_type} eq 'form_fields_example'){ \n \t\t\t$tmpl_name = 'subscription_form_fields_example.tmpl'; \n\t\t}\n\t\t\n\t\trequire DADA::MailingList::Consents; \n\t\tmy $con           = DADA::MailingList::Consents->new; \n\t\tmy $list_consents = $con->give_me_all_consents($ls); \n\t\t\t\t\n        return screen({\n            -screen => $tmpl_name, \n            -vars   => {\n\t\t\t\t\t\t\tform_target              => $args->{-form_target},  \n\t\t\t\t\t\t\tcan_use_JSON             => scalar DADA::App::Guts::can_use_JSON(), \n                            single_list              => 1, \n                            subscriber_fields        => $named_subscriber_fields,\n                            list                     => $list, \n                            email                    => $args->{-email},\n                            script_url               => $args->{-script_url}, \n\t\t\t\t\t\t\tshow_fields              => $args->{-show_fields}, \n\t\t\t\t\t\t\tprofile_logged_in        => $args->{-profile_logged_in}, \n\t\t\t\t\t\t\tsubscription_form_id     => $args->{-subscription_form_id}, \n\t\t\t\t\t\t\tshow_fieldset            => $args->{-show_fieldset}, \n\t\t\t\t\t\t\tadd_recaptcha_js         => $args->{-add_recaptcha_js}, \n\t\t\t\t\t\t\tlist_consents            => $list_consents, \t\t\t\t\t\n\t\t\t\t\t\t\t\n                        },\n\t\t\t\t\t\t-list_settings_vars_param => {\n\t\t\t\t\t\t\t-list    => $list,\n\t\t\t\t\t\t\t-dot_it => 1,\n\t\t\t\t\t\t},\n                    });  \n  \n    }\n    else { \n\t\t\n\t\tmy $enable_captcha_on_initial_subscribe_form = 0; \n\t\t\n\t\t# Eek, this is a hack, kinda: \n\t\tif($args->{-multiple_lists} == 1){ \n\t\t\trequire DADA::MailingList::Settings; \n\t\t\tmy @lists = available_lists(-Dont_Die => 1); \n\t\t\tforeach my $mlist(@lists){ \n\t\t\t\tmy $mls = DADA::MailingList::Settings->new({-list => $mlist}); \n\t\t\t\tif($mls->param('enable_captcha_on_initial_subscribe_form') == 1){\n\t\t\t\t\t $enable_captcha_on_initial_subscribe_form = 1; \n\t\t\t\t}\n\t\t\t\tlast; \n\t\t\t}\n\t\t}\n\t\t\n\t\treturn screen({\n            -screen => 'subscription_form_widget.tmpl', \n            -vars   => {\n\t\t\t\tform_target              => $args->{-form_target},  \n\t            single_list              => 0, \n\t            subscriber_fields        => $named_subscriber_fields,\n\t            list                     => $list, \n\t            email                    => $args->{-email},\n\t            list_popup_menu          => list_popup_menu(-disable_invite_only => 1),\n\t            list_checkbox_menu       => list_popup_menu(-as_checkboxes => 1), \n\t            multiple_lists           => $args->{-multiple_lists}, \n\t            script_url               => $args->{-script_url}, \n\t\t\t\tshow_fields              => $args->{-show_fields}, \n\t\t\t\tprofile_logged_in        => $args->{-profile_logged_in}, \n\t\t\t\tsubscription_form_id     => $args->{-subscription_form_id}, \n\t\t\t\tshow_fieldset            => $args->{-show_fieldset}, \n\t\t\t\tadd_recaptcha_js         => $args->{-add_recaptcha_js}, \n\t\t\t\t'list_settings.enable_captcha_on_initial_subscribe_form' \n\t\t\t\t\t=> $enable_captcha_on_initial_subscribe_form, \n\t\t\t}\n    \t});      \n    }\n\n}\n\n\n\nsub unsubscription_form { \n\t\n\t\n    my ($args) = @_; \n    \n\tif(! exists($args->{-list})) { \n\t\tcroak \"you MUST pass a, '-list'\"; \n\t}\n\tmy $list_exists = check_if_list_exists( -List=> $args->{-list}, -Dont_Die  => 1) || 0;\n\t\n\tif($list_exists == 0){ \n\t\tcroak \"list,  '\" .  $args->{-list} . \"' does not exist.\"; \n\n\t}\n\telse { \n\t\n\t\treturn screen({\n\t        -screen => 'unsubscription_form_widget.tmpl', \n\t        -vars   => {\n                       \n\t                        list                     => $args->{-list}, \n\t                        email                    => $args->{-email},\n\t                    },\n\t\t\t\t\t\t-list_settings_vars_param => {\n\t\t\t\t\t\t\t-list    => $args->{-list},\n\t\t\t\t\t\t\t-dot_it => 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t\n\t                }\n\t\t);  \n\t}\n}\n\n\n\n\nsub file_path { \n\n    my $fn   = shift; \n    if(!$fn){ \n        croak \"You did not pass a filename as the sole argument!!!\"; \n    }\n    my $path = undef; \n    \n    foreach my $path(@{$Global_Template_Options{path}}){ \n        if(-e $path . '/' . $fn){ \n            return $path . '/' . $fn;\n        }\n    }\n}\n\n\n\nsub _raw_screen { \n\t\n\tmy ($args) = @_; \n\t\n\tmy $screen = $args->{-screen}; \n\t\n\t\n\tmy $path = file_path($screen);\n\t\n\tif($path){ \n\t\tif($args->{-encoding} == 0) {  \n\t\t\treturn _slurp_raw($path);\n\t\t}\n\t\telse { \n\t\t\treturn _slurp($path);\n\t\t\t\n\t\t}\n\t}\n\telse { \n\t\tcarp \"cannot find, $screen to open!\"; \n\t\treturn undef; \n\t}\n}\n\n\n\nsub _slurp { \n\t\n\t\tmy ($file) = @_;\n\n        local($/) = wantarray ? $/ : undef;\n        local(*F);\n        my $r;\n        my (@r);\n\n\t\t$file = make_safer($file); \n        open(F, '<:encoding(' . $DADA::Config::HTML_CHARSET .')', $file) || die \"open $file: $!\";\n        @r = <F>;\n        close(F) || die \"close $file: $!\";\n\n        return $r[0] unless wantarray;\n        return @r;\n\n}\n\nsub _slurp_raw { \n\tmy ($file) = @_;\n\n    local($/) = wantarray ? $/ : undef;\n    local(*F);\n    my $r;\n    my (@r);\n\n\t$file = make_safer($file); \n    open(F, '<', $file) || die \"open $file: $!\";\n    @r = <F>;\n    close(F) || die \"close $file: $!\";\n\n    return $r[0] unless wantarray;\n    return @r;\n}\n\n\n\n# This is a bad idea - better to just OO this module... \nsub lame_init(){ \n    if(!defined($q)){ \n        require CGI;\n        $q = CGI->new();\n    }\n}\n\n\n1;\n\n\n\n\n=pod\n\n=head1 COPYRIGHT\n\nCopyright (c) 1999 - 2020 Justin Simoni \nhttps://justinsimoni.com \nAll rights reserved. \n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n=cut\n", "<!-- begin profile_home.tmpl --> \n\n<!-- tmpl_set name=\"title\" value=\"Profile\" --> \n\n<div id=\"profile_home\"></div>\n\n\n\n\n<script type=\"text/javascript\">\n\tfunction confirm_profile_removal(form_name) {\n        \n    \n\t    var confirm_msg =  \"Are you sure you want to \";\n\t        confirm_msg += \" remove this profile?\";\n\t        confirm_msg += \" This profile removal cannot be undone.\";\n\t    if(!confirm(confirm_msg)){\n\t        alert('Profile not removed.');\n\t        return false;\n\t    }    \n\t}\n</script> \n\n\n\n\n<!-- tmpl_if welcome --> \n    <div class=\"alert-box info radius\">\n\t     Welcome to your Profile. From here, you may subscribe/unsubscribe \n\t     to the available mailing lists, as well as update your subscription \n\t    information.\n\t</div> \n<!-- /tmpl_if --> \n<!-- tmpl_if edit --> \n    <div class=\"alert-box info radius\">\n       Changes have been saved.\n    </div>\n<!-- /tmpl_if --> \n\n\n<!-- tmpl_if errors --> \n    <div class=\"alert-box warning radius\">\n    <p> \n        <strong>There was an error with your last request:</strong>\n    </p> \n\n    <!-- tmpl_if errors_change_password --> \n        <p>Your Password:</p>\n        <ul> \n            <li>\n                Make sure that you re-typed your password correctly. \n        </li> \n        </ul> \n\n    <!-- /tmpl_if -->\n\n    <!-- tmpl_if errors_update_email --> \n        <p>\n            Update Your Profile Email: \n        </p>\n        <ul> \n        <!-- tmpl_if error_invalid_email --> \n            <li>\n                The email address you submitted was not valid.\n            </li> \n        <!-- /tmpl_if --> \n    \n        <!-- tmpl_if error_profile_exists --> \n            <li>\n                     A Profile already exists for the email address, <!-- tmpl_var updated_email -->.\n            </li> \n        <!-- /tmpl_if --> \n        </ul> \n    <!-- /tmpl_if --> \n</div>\n\n<!-- /tmpl_if --> \n\n\n\n\n\n\n<div class=\"row\">\n\t<div class=\"small-12 columns\">\n\t\t<ul class=\"tabs show-for-medium-up\" data-tab=\"\">\n\t\t\t\n\t\t\t<!-- tmpl_if expr=\"profile_feature_mailing_list_subscriptions == 1\" -->\n\t\t\t\t<li class=\"tab-title active\">\n\t\t\t\t\t<a href=\"#mailing_list_subscriptions\">\n\t\t\t\t\t\tSubscriptions\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if --> \n\t\t\t\n\t\t\t<!-- tmpl_if expr=\"profile_feature_profile_fields == 1\" -->\n\t\t\t\t<!-- tmpl_if subscriber_fields -->\n\t\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t\t<a href=\"#profile_fields\">\n\t\t\t\t\t\t\tProfile Fields\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</li>\n\t\t\t\t<!-- /tmpl_if --> \n\t\t\t<!-- /tmpl_if --> \n\t\t\t\n\t\t\t<!-- tmpl_if protected_directories --> \n\t\t\t\t<!-- tmpl_if expr=\"profile_feature_protected_directories == 1\" -->\n\t\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t\t<a href=\"#protected_directories\">\n\t\t\t\t\t\t\tProtected Directories\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</li>\n\t\t\t\t<!-- /tmpl_if --> \n\t\t\t<!-- /tmpl_if --> \n\n\t\t    <!-- tmpl_if expr=\"profile_feature_update_email_address == 1\" -->\t\t\t\n\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t<a href=\"#update_email_address\">\n\t\t\t\t\t\tUpdate Address\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if --> \n\n\n\t\t\t<!-- tmpl_if expr=\"profile_feature_change_password == 1\" -->\n\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t<a href=\"#change_password\">\n\t\t\t\t\t\tPassword\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if --> \n\n\n\t\t    <!-- tmpl_if expr=\"profile_feature_delete_profile == 1\" -->\t\t\t\n\t\t\t\t<li class=\"tab-title\">\n\t\t\t\t\t<a href=\"#delete_profile\">\n\t\t\t\t\t\tDelete\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t    <!-- /tmpl_if -->\n\t\t</ul>\n\t\t\n\t\t<dl class=\"accordion\" data-accordion=\"\">\n\t\t\t<dd class=\"accordion-navigation\">\n\n\t\t\t \t<!-- tmpl_if expr=\"profile_feature_mailing_list_subscriptions == 1\" -->\n\t\t\t\t\n\t\t\t\t\t<a href=\"#mailing_list_subscriptions\" class=\"show-for-small-only\">\n\t\t\t\t\t\tSubscriptions\n\t\t\t\t\t</a>\n\t\t\t\t\t\n\t\t\t\t\t<div id=\"mailing_list_subscriptions\" class=\"content active\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t                \n\t\t\t\t\t\t\t<!-- tmpl_if has_subscriptions --> \n\t\t\t                    <!-- ... -->\n\t\t\t                <!-- tmpl_else --> \n\t\t\t                    <div class=\"alert-box info radius\">\n\t\t\t                        You are not currently subscribed to any mailing list.\n\t\t\t\t\t\t\t\t</div>\n\t\t\t                <!-- /tmpl_if --> \n\n\t\t\t                <!-- tmpl_loop subscriptions --> \n\t\t\t                    <!-- tmpl_if subscribed --> \n\t\t\t                        <h2>\n\t\t\t                            <a href=\"<!-- tmpl_var PROGRAM_URL -->/list/<!-- tmpl_var list_settings.list -->\">\n\t\t\t                                <!-- tmpl_var list_settings.list_name --> \n\t\t\t                            </a>\n\t\t\t                        </h2>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<div class=\"alert-box info radius\">\n\t\t\t\t\t\t\t\t\t\t\t<ul> \n\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if list_settings.private_list --> \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list is a private mailing list. There may be additional steps in order to join, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tand the List Owner controls who may leave the mailing list. \n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_else --> \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t    \t\t\tThis mailing list is a public mailing list - anyone may join or leave, at any time.\n\t\t\t\t\t\t\t\t\t\t    \t</li>\t\t\n\t\t\t\t\t\t\t\t\t\t    <!-- /tmpl_if -->\n\n\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if list_settings.enable_subscription_approval_step --> \n\t\t\t\t\t\t\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list requires approval from the List Owner, before subscriptions are finalized.\n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t\t\t<!-- /tmpl_if --> \n\n\t\t\t\t\t\t\t\t\t\t    <!-- tmpl_if list_settings.group_list --> \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list is a group discussion list\n     \n\t\t\t\t\t\t\t\t\t\t            <!-- tmpl_if list_settings.enable_moderation --> \n\t\t\t\t\t\t\t\t\t\t                (moderated)\n\t\t\t\t\t\t\t\t\t\t            <!-- tmpl_else -->\n\t\t\t\t\t\t\t\t\t\t                (unmoderated)\n\t\t\t\t\t\t\t\t\t\t            <!-- /tmpl_if --> \n\t\t\t\t\t\t\t\t\t\t        </li>\n\t\t\t\t\t\t\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- this is strange, as the bare link will be wrapped with a HTML link --> \n\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Start a new thread, email: <!-- tmpl_var list_settings.discussion_pop_email --></p>\n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\n\t\t\t\t\t\t\t\t\t\t    <!-- tmpl_else --> \n    \n\t\t\t\t\t\t\t\t\t\t        <li>\n\t\t\t\t\t\t\t\t\t\t         <p>\n\t\t\t\t\t\t\t\t\t\t\t\t\tThis mailing list is announce-only.\n\t\t\t\t\t\t\t\t\t\t         </p>\n\t\t\t\t\t\t\t\t\t\t\t\t</li>\n\n\n\t\t\t\t\t\t\t\t\t\t     <!-- /tmpl_if --> \n\t\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n                                                        \n\t\t\t                        <div class=\"panel\"> \n\t\t\t                            <p>\n\t\t\t                                <!-- tmpl_var list_settings.info -->\n\t\t\t                            </p>\n\t\t\t\t\t\t\t\t\t</div> \n\t\t\t                      \n\n\t\t\t                        <ul>\n\t\t\t\t                        <li>\n\t\t\t\t                            <p>\n\t\t\t\t                                <a href=\"<!-- tmpl_var PROGRAM_URL -->/archive/<!-- tmpl_var list_settings.list -->\">\n\t\t\t\t                                    View Archives\n\t\t\t\t                                </a>\n\t\t\t\t                            </p>\n\t\t\t\t                        </li>\n\t\t\t\t                        </ul>\n\t\t\t\t                            <p>\n\t\t\t\t                                <a href=\"<!-- tmpl_var list_unsubscribe_link -->\" class=\"button\">\n\t\t\t\t                                    <!-- tmpl_if list_settings.private_list -->\n\t\t\t\t                                          Request to be removed from <!-- tmpl_var list_settings.list_name -->                  \n\t\t\t\t                                    <!-- tmpl_else --> \n\t\t\t\t                                        Unsubscribe from <!-- tmpl_var list_settings.list_name -->\n\t\t\t\t                                    <!-- /tmpl_if -->\n\t\t\t\t                                </a>\n\t\t\t\t                            </p>\n\t\t\t\t                  \n\t\t\t\t                    \n    \n    \n<!-- tmpl_if list_settings.digest_enable -->\n    <fieldset>\n        <legend>Delivery Preferences:</legend>\n        <form action=\"<!-- tmpl_var S_PROGRAM_URL -->\" method=\"post\"> \n\n            <input type=\"hidden\" name=\"flavor\"     value=\"profile\" > \n            <input type=\"hidden\" name=\"process\"    value=\"profile_delivery_preferences\" > \n            <input type=\"hidden\" name=\"list\"       value=\"<!-- tmpl_var list_settings.list -->\" > \n\t\t\t<input type=\"hidden\" name=\"csrf_token\" value=\"<!-- tmpl_var csrf_token -->\">\n\t\t\t\n\t\t\t<div class=\"row\">\n\t\t\t\t<div class=\"small-10 medium-5 large-4 columns\">\t \n\t\t\t\t\t\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t                    <label for=\"delivery_prefs_individual\">\n\t\t\t                    <input \n\t\t\t\t\t\t\t\t\ttype=\"radio\" \n\t\t\t\t\t\t\t\t\tname=\"delivery_prefs\" \n\t\t\t\t\t\t\t\t\tvalue=\"individual\" \n\t\t\t\t\t\t\t\t\tid=\"delivery_prefs_individual\" \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if expr=\"delivery_prefs eq 'individual'\" -->checked=\"checked\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t\t>\n\t\t                            Receive Individual Messages\n\t                        </label>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t                    <label for=\"delivery_prefs_digest\">\t\t\t\t\t\n\t\t\t                    <input \n\t\t\t\t\t\t\t\t\ttype=\"radio\" \n\t\t\t\t\t\t\t\t\tname=\"delivery_prefs\" \n\t\t\t\t\t\t\t\t\tvalue=\"digest\" \n\t\t\t\t\t\t\t\t\tid=\"delivery_prefs_digest\" \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if expr=\"delivery_prefs eq 'digest'\" -->checked=\"checked\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t>\n\t\t                        Receive Messages in a Digest (<!-- tmpl_var digest_timeframe -->)\n\t\t                    </label> \n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t                    <label for=\"delivery_prefs_hold\">\n\t\t                    \t<input \n\t\t\t\t\t\t\t\t\ttype=\"radio\" \n\t\t\t\t\t\t\t\t\tname=\"delivery_prefs\" \n\t\t\t\t\t\t\t\t\tvalue=\"hold\" \n\t\t\t\t\t\t\t\t\tid=\"delivery_prefs_hold\" \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if expr=\"delivery_prefs eq 'hold'\" -->checked=\"checked\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t>\n\t\t                            Hold Mailings (vacation, etc)     \n\t\t                    </label> \n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t<input type=\"submit\" value=\"Save Delivery Preferences\" class=\"success button expand\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div> \n\t\t\t\t</div>\n\t\t\t</div> \n        </form>\n    </fieldset>\n<!-- /tmpl_if --> \n    \n    \n\t\t\t\t                    <!-- tmpl_if comment --> \n\t\t\t\t                        <!-- tmpl_if list_owner --> \n\t\t\t\t                            <div class=\"alert-box info radius\"> \n\t\t\t\t                                You are the List Owner. \n\t\t\t\t                                <a href=\"<!-- tmpl_var S_PROGRAM_URL -->/sign_in/<!-- tmpl_var list_settings.list -->/\"> \n\t\t\t\t                                    Login...\n\t\t\t\t                                </a>  \n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t                        <!-- /tmpl_if -->\n\t\t\t\t                     <!-- /tmpl_if -->\n\t\t\t\t                <!-- /tmpl_if --> \n\t\t\t\t            <!-- /tmpl_loop -->\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\n\t\t\t\t<!-- /tmpl_if --><!-- profile_feature_mailing_list_subscriptions -->\n\t\t\t    \n\t\t\t\t\n\t\t\t\t<!-- tmpl_if expr=\"profile_feature_profile_fields == 1\" -->\n\t\t\t        <!-- tmpl_if subscriber_fields -->\n\t\t\t\t\n\t\t\t\t\t\t<a href=\"#profile_fields\" class=\"show-for-small-only\">\n\t\t\t\t\t\t\tProfile Fields\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<div id=\"profile_fields\" class=\"content\">\n\t\t\t\t\t\t\t<div class=\"content-box section-box\">\n\n\t\t\t\t                <form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" id=\"membership_profile_fields\"> \n\t\t\t\t                    <input type=\"hidden\" name=\"flavor\"   value=\"profile\" > \n\t\t\t\t                    <input type=\"hidden\" name=\"process\"  value=\"edit_subscriber_fields\" > \n\t\t\t\t\t\t\t\t\t<input type=\"hidden\" name=\"csrf_token\" value=\"<!-- tmpl_var csrf_token -->\">\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t                    <!-- tmpl_loop subscriber_fields --> \n\n\t\t\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"large-3 medium-3 columns\">\n\t\t\t\t\t\t\t\t\t\t\t\t<label \n\t\t\t\t\t\t\t\t\t\t\t\t\tfor=\"<!-- tmpl_var name escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"medium-text-right\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t                        <!-- tmpl_if label --> \n\t\t\t\t\t\t\t                            <!-- tmpl_var label escape=HTML -->: \n\t\t\t\t\t\t\t                        <!-- tmpl_else --> \n\t\t\t\t\t\t\t                            <!-- tmpl_var name escape=HTML -->: \n\t\t\t\t\t\t\t                        <!-- /tmpl_if -->\n\t\t\t\t\t\t                        </label>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"large-9 medium-9 columns\">\n\t\t\t\t\t\t                        <input \n\t\t\t\t\t\t\t\t\t\t\t\t\ttype=\"text\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tname=\"<!-- tmpl_var name escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tid=\"<!-- tmpl_var name escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var value escape=HTML -->\" \n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if required -->required<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- tmpl_if required -->placeholder=\"(required)\"<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t                    <!-- /tmpl_loop -->\n\t\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t\t<input type=\"submit\" value=\"Update Information\" class=\"success button expand\"> \n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t                </form>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t        <!-- /tmpl_if -->\n\t\t\t    <!-- /tmpl_if--><!-- profile_feature_profile_fields -->\n\t\t\t\t\n\t\t\t    <!-- tmpl_if protected_directories --> \n\t\t\t        <!-- tmpl_if expr=\"profile_feature_protected_directories == 1\" -->    \t\t\t\t\n\t\t\t\t\t\t<a href=\"#protected_directories\" class=\"show-for-small-only\">\n\t\t\t\t\t\t\tProtected Directories\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<div id=\"protected_directories\" class=\"content\">\n\t\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t                    <p>Access these directories with your Profile Username/Password.\n\t\t\t                    <ul>        \n\t\t\t                        <!-- tmpl_loop protected_directories --> \n\t\t\t                            <p>\n\t\t\t                                <li>\n\t\t\t                                    <strong>\n\t\t\t                                        <a href=\"<!-- tmpl_var url -->\" target=\"_blank\"><!-- tmpl_var name --></a>\n\t\t\t                                    </strong> \n\t\t\t                                </li>\n\t\t\t                            </p>\n\t\t\t                        <!-- /tmpl_loop --> \n\t\t\t                    </ul>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t        <!-- /tmpl_if --> \n\t\t\t    <!-- /tmpl_if -->\n\t\t\t\t\n\t\t\t    <!-- tmpl_if expr=\"profile_feature_update_email_address == 1\" -->\n\t\t\t\t\n\t\t\t\t\t<a href=\"#update_email_address\" class=\"show-for-small-only\">\n\t\t\t\t\t\tUpdate Address\n\t\t\t\t\t</a>\n\t\t\t\t\t<div id=\"update_email_address\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t\t\t\t\t\n\t\t\t\t            <div class=\"alert-box warning radius\">\n\t\t\t\t                The Profile Email Address and Subscriptions using your current email address (<!-- tmpl_var profile.email -->) \n\t\t\t\t                will be replaced with this new email address, where it's allowed: \n\t\t\t\t\t\t\t</div>\n\t\t\t\t            <form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\"> \n\t\t\t\t                <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n\t\t\t\t                <input type=\"hidden\" name=\"process\"  value=\"update_email\" >\n\t\t\t\t\t\t\t\t<input type=\"hidden\" name=\"csrf_token\" value=\"<!-- tmpl_var csrf_token -->\">\n\t\t\t\t\t\t\t\t\n\t\t\t                    <!-- tmpl_if errors_update_email --> \n\t\t\t                        <!-- tmpl_if error_invalid_email --> \n\t\t\t                            <p class=\"error\"> \n\t\t\t                                * The email address you submitted is not valid.\n\t\t\t                            </p> \n\t\t\t                        <!-- /tmpl_if --> \n\n\t\t\t                        <!-- tmpl_if error_profile_exists --> \n\t\t\t                            <p class=\"error\"> \n\t\t\t                                * A Profile already exists for the email address, <!-- tmpl_var updated_email -->.\n\t\t\t                            </p> \n\t\t\t                        <!-- /tmpl_if --> \n\t\t\t                    <!-- tmpl_else --> \n\t\t\t                    <!-- /tmpl_if -->\n\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<label for=\"updated_email\" class=\"label_profile_fields\">\n\t\t\t\t\t\t\t\t\t\t\tYour New Profile Email Address: \n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input type=\"text\" name=\"updated_email\" id=\"updated_email\" value=\"\" >\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<input type=\"submit\"  class=\"success button\" value=\"Confirm and Update Your New Profile Email Address\" > \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\t\n\t\t\t\t\t\t\t</form>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t<!-- /tmpl_if --><!-- profile_feature_update_email_address -->\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t    <!-- tmpl_if expr=\"profile_feature_change_password == 1\" -->\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t<a href=\"#change_password\" class=\"show-for-small-only\">\n\t\t\t\t\t\tPassword\n\t\t\t\t\t</a>\n\t\t\t\t\t\n\t\t\t\t\t<div id=\"change_password\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t<form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\"> \n\t\t\t\t                <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n\t\t\t\t                <input type=\"hidden\" name=\"process\"  value=\"change_password\" >\n\t\t\t\t\t\t\t\t<input type=\"hidden\" name=\"csrf_token\" value=\"<!-- tmpl_var csrf_token -->\">\n\n\t\t\t\t                <!-- tmpl_if errors_change_password --> \n\t\t\t\t                        <p class=\"error\">\n\t\t\t\t                            Make sure that you re-typed your password correctly. \n\t\t\t\t                        </p>\n\t\t\t\t                <!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"password\" class=\"label_profile_fields\">\n\t\t\t\t\t                 \t   New Password \n\t\t\t\t\t                    </label>\n\t\t\t\t\t\t\t\t\t\t<input type=\"password\" name=\"password\" id=\"password\" value=\"\"  >\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"again_password\" class=\"label_profile_fields\">\n\t\t\t\t\t                    New Password Again: \n\t\t\t\t\t                    </label>\n\t\t\t\t\t                    <input type=\"password\" name=\"again_password\" id=\"again_password\" value=\"\"  >\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\t\n\t\t\t\t                \t\t<input type=\"submit\"   class=\"success button\"  value=\"Change Password\" > \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t            </form>\t\t\t\t\t\t\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t    <!-- /tmpl_if --><!-- profile_feature_change_password -->\n\t\t\t\t\n\t\t\t\t\n\t\t\t    <!-- tmpl_if expr=\"profile_feature_delete_profile == 1\" -->\t\t\t\n\t\t\t\t\t<a href=\"#delete_profile\" class=\"show-for-small-only\">\n\t\t\t\t\t\tDelete\n\t\t\t\t\t</a>\n\t\t\t\t\t<div id=\"delete_profile\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\t\t\t\t            <form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\"> \n\t\t\t\t                <input type=\"hidden\" name=\"flavor\"        value=\"profile\" > \n\t\t\t\t                <input type=\"hidden\" name=\"process\"  value=\"delete_profile\" >\n\t\t\t\t\t\t\t\t<input type=\"hidden\" name=\"csrf_token\" value=\"<!-- tmpl_var csrf_token -->\">\n        \n\t\t\t\t\t\t\t\t<div class=\"alert-box info radius\">\n\t\t\t\t\t\t\t        Deleting your profile will remove all your profile information, but \n\t\t\t\t                    all your subscriptions to subscribed mailing lists will remain.\n\t\t\t\t\t\t\t\t</div> \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t                <input type=\"submit\" value=\"Delete Your Profile\" class=\"alert button\" onclick=\"return confirm_profile_removal(this.form);\" > \n        \n\t\t\t\t\t\t\t</form>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t    <!-- /tmpl_if -->\n\t\t\t\t\n\t\t\t</dd>\n\t\t</dl>\n\t</div>\n</div>\n\n\n\n\n\n<!-- end profile_home.tmpl --> ", "<!-- being profile_login.tmpl --> \n\n<!-- tmpl_set name=\"title\" value=\"Profile Login\" --> \n<!-- tmpl_set name=\"show_profile_widget\" value=\"0\" --> \n<!-- tmpl_set name=\"load_captcha_js\" value=\"1\" --> \n\n<div id=\"profile_login_registration\"></div>\n\n<!-- tmpl_if removal --> \n\t<div class=\"alert-box info radius\">\n\t\tYour Profile has been removed.\n\t</div> \n<!-- /tmpl_if --> \n\n<!-- tmpl_if welcome --> \n\t<div class=\"alert-box info radius\">\n\t\tYou have been successfully registered! Please log in with your Profile email address and password:\n\t</div> \n<!-- /tmpl_if --> \n\n<!-- tmpl_if logged_out --> \n\t<div class=\"alert-box info radius\">\n\t\tYou have logged out. \n\t</div> \n<!-- /tmpl_if --> \n\n<!-- tmpl_if password_changed --> \n\t<div class=\"alert-box info radius\">\n\t\tYou've successfully changed your Profile password ! Please log in again:\n\t</div> \n<!-- /tmpl_if --> \n\n\n\n\t\t\t\t<!-- tmpl_if comment --> \n\t\t\t\t\t<!-- tmpl_if errors --> \n\t\t\t\t\t\t<h3>YOU HAVE ERRORS!!!</h3> \n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t<!-- tmpl_loop errors --> \n\t\t\t\t\t\t\t<li><p><!-- tmpl_var error --></p></li>\n\t\t\t\t\t\t<!-- /tmpl_loop --> \n\t\t\t\t\t\t</ul>\n\t\t\t\t\t<!-- /tmpl_if --> \n\n\t\t\t\t\t<h3>error_profile_login: <!-- tmpl_var error_profile_login --> </h3> \n\t\t\t\t\t<h3>error_profile_register: <!-- tmpl_var error_profile_register --></h3>\n\t\t\t\t\t<hr > \n\t\t\t\t\t<hr > \n\t\t\t\t\t<hr > \n\t\t\t\t<!-- /tmpl_if --> \n\n\n\n\n<!-- tmpl_if errors --> \n\t<div class=\"alert-box warning radius\">\n\n\t<p>\n\t\t<strong>\n\t\t\tProblems with your Request:\n\t\t</strong>\n\t</p>\n\t\n\t<ul> \n\t<!-- tmpl_if error_profile_login --> \n\t\t<li>\n\t\t\tPlease log into your Profile.\n\t\t</li>\n\t<!-- /tmpl_if --> \n\t<!-- tmpl_if error_profile_activate --> \n\t\t<!-- tmpl_if error_invalid_auth_code -->                 \n\t\t\t<li>\n\t\t\t\tYour Registration Authorization Code does not seem to be valid. Make sure to copy/paste the entire registration link. \n\t\t\t</li>\n\t\t<!-- /tmpl_if -->  \n\t<!-- /tmpl_if -->\n\n\t<!-- tmpl_if error_profile_register --> \n\t\t<!-- tmpl_if error_invalid_email -->\n\t\t\t<li>\n\t\t\t\tThe email address you've entered is not valid.\n\t\t\t</li>        \n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_password_blank --> \n\t\t\t<li>\n\t\t\t\tYou forgot to enter a password.\n\t\t\t</li>\n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_email_no_match --> \t\n\t\t\t<li>\n\t\t\t\tThe email addresses you've entered do not match.\n\t\t\t</li>        \n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_captcha_failed --> \n\t\t\t<li>\n\t\t\t\tSorry, reCAPTCHA failed. \n\t\t\t</li>\n\t\t<!-- /tmpl_if --> \n\n\t\t<!-- tmpl_if error_profile_exists -->\n\t\t\t<li>\n\t\t\t\tA Profile for this address already exists. Please log in, or reset your Profile Password.\n\t\t\t</li>        \n\t\t<!-- /tmpl_if --> \n\t<!-- /tmpl_if --> \n\n\t<!-- tmpl_if error_profile_login --> \n\t\t<!-- tmpl_if errors_not_logged_in -->     \n\t\t<li>\n\t\t\tYou'll have to log in, before you may access your Profile.\n\t\t</li>\n\t\t<!-- /tmpl_if -->             \n\t\t<!-- tmpl_if error_unknown_user --> \n\t\t\t<!-- tmpl_if profile_settings.register -->\n\t\t\t\t<li>\n\t\t\t\t\tProfile User Unknown - have you registered?\n\t\t\t\t</li>\n\t\t\t<!-- tmpl_else -->\n\t\t\t\t<li>\n\t\t\t\t\tProfile User Unknown - self-registration is also disabled.\n\t\t\t\t</li>\n\t\t\t<!-- /tmpl_if -->\n\t\t<!-- /tmpl_if --> \n\t\t<!-- tmpl_if error_incorrect_pass --> \n\t\t\t<li>\n\t\t\t\tIncorrect Password.\n\t\t\t</li>\n\t\t<!-- /tmpl_if --> \n\t\t</ul> \n\t<!-- /tmpl_if --> \n\n\t<!-- tmpl_if error_profile_reset_password --> \n\t\t<!-- tmpl_if error_invalid_auth_code --> \n\t\t\t<li>\n\t\t\t\tAuthorization Code is not valid. Make sure to copy/paste the entire password reset link. \n\t\t\t</li> \n\t\t<!-- /tmpl_if --> \n\n\t\t<!-- tmpl_if error_unknown_user --> \n\t\t\t<li>\n\t\t\t\tProfile User Unknown - have you registered?\n\t\t\t</li> \n\t\t<!-- /tmpl_if -->\n\t<!-- /tmpl_if -->\n\t\t</ul>\n\t</div> \n<!-- /tmpl_if --> \n\n\n\n\n<div class=\"alert-box info radius\"> \n\t<p>\n\t\t<!-- tmpl_var PROGRAM_NAME --> Profiles allow you to view and work with all \n\t\tyour <!-- tmpl_var PROGRAM_NAME --> subscriptions.\n\t</p>\n\t<p>\n\t\tHaving a profile and being logged in also allows you to view subscriber-only archives.\n\t</p>\n</div> \n\n\n\n<div class=\"row\">\n  <div class=\"small-12 columns\">\n    <ul class=\"tabs show-for-medium-up\" data-tab>\n      <li class=\"tab-title active\"><a href=\"#profile_login\">Login</a></li>\n\t\t \n\t\t  <!-- tmpl_if profile_settings.password_reset -->\n\t\t \t <li class=\"tab-title\"><a href=\"#profile_password_reset\">Reset Password</a></li>\n\t\t  <!-- /tmpl_if -->\n\t   \n\t\t  <!-- tmpl_if profile_settings.register -->\n\t      \t\t<li class=\"tab-title\"><a href=\"#profile_register\">Register</a></li>\n\t\t  <!-- /tmpl_if -->\t\n\t\n\t</ul>\n\n\t<dl class=\"accordion\" data-accordion>\n\t\n\t\t<dd class=\"accordion-navigation\">\n\t\t\t<a href=\"#profile_login\" class=\"show-for-small-only\">Login</a>\n\t\t\t<div id=\"profile_login\" class=\"content active\">\n\t\t\t\t<div class=\"content-box section-box\">\n\n\n\n\t\t\t\t\t<form \n\t\t\t\t\t\taction=\"<!-- tmpl_var PROGRAM_URL -->\" \n\t\t\t\t\t\tmethod=\"post\" \n\t\t\t\t\t\taccept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" \n\t\t\t\t\t\tid=\"profile_login\"\n\t\t\t\t\t> \n\t\t\t\t\t\t<input type=\"hidden\" name=\"flavor\" value=\"profile_login\" > \n\t\t\t\t\t\t<input type=\"hidden\" name=\"process\" value=\"1\" > \n\t\t\t\t\t\t\n\t\t\t\t\t\t<!-- tmpl_if DISABLE_OUTSIDE_LOGINS --> \n\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\ttype=\"hidden\" \n\t\t\t\t\t\t\t\tname=\"auth_state\" \n\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var auth_state -->\"\n\t\t\t\t\t\t\t> \n\t\t\t\t\t\t<!--/tmpl_if--> \n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t<label for=\"login_email\">\n\t\t\t\t\t\t\t\t\tEmail Address\n\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\ttype=\"email\" \n\t\t\t\t\t\t\t\t\tname=\"login_email\" \n\t\t\t\t\t\t\t\t\tid=\"login_email\" \n\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var login_email escape=\"HTML\" -->\"\n\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t<label for=\"login_password\">\n\t\t\t\t\t\t\t\t\tPassword\n\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\ttype=\"password\" \n\t\t\t\t\t\t\t\t\tname=\"login_password\" \n\t\t\t\t\t\t\t\t\tid=\"login_password\" \n\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t<input type=\"submit\" class=\"button expand\" value=\"Log Into Your Profile\" > \n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</form>\n    \t\t\t</div>\n\t\t\t</div>\n\t\t\n\t\t <!-- tmpl_if profile_settings.password_reset -->\n\t\t\n\t\t\t\t<a href=\"#profile_password_reset\" class=\"show-for-small-only\">Reset Password</a>\n\t\t\t\t<div id=\"profile_password_reset\" class=\"content\">\n\t\t\t\t\t<div class=\"content-box section-box\">\n\n\n\n\n\n\t\t\t\t\t\t<form \n\t\t\t\t\t\t\taction=\"<!-- tmpl_var PROGRAM_URL -->\" \n\t\t\t\t\t\t\tmethod=\"post\" \n\t\t\t\t\t\t\taccept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" \n\t\t\t\t\t\t\tid=\"profile_reset_password\"\n\t\t\t\t\t\t> \n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"flavor\" value='profile_reset_password' > \n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t<label for=\"reset_email\">\n\t\t\t\t\t\t\t\t\t\tEmail Address\n\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\ttype=\"text\" \n\t\t\t\t\t\t\t\t\t\tid=\"reset_email\" \n\t\t\t\t\t\t\t\t\t\tname=\"reset_email\" \n\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var reset_email escape=HTML -->\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t<input type=\"submit\" class=\"button expand\" value=\"Reset Your Profile Password\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div> \n\t\t\t\t\t\t</form>\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t    \t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t\n\t\t\t<!-- /tmpl_if -->\n\t\t\t\n\t\t\t <!-- tmpl_if profile_settings.register -->\n\t\t\t\n\t\t\t\t\t<a href=\"#profile_register\" class=\"show-for-small-only\">Register</a>\n\t\t\t\t\t<div id=\"profile_register\" class=\"content\">\n\t\t\t\t\t\t<div class=\"content-box section-box\">\n\n\n\t\t\t\t\t\t\t<div class=\"alert-box info radius\">\n\t\t\t\t\t\t\t\tRegister a Profile to easily manage all your <!-- PROGRAM_NAME --> Subscriptions.\n\t\t\t\t\t\t\t</div> \n\n\t\t\t\t\t\t\t<form action=\"<!-- tmpl_var PROGRAM_URL -->\" method=\"post\" accept-charset=\"<!-- tmpl_var HTML_CHARSET -->\" id=\"profile_register\"> \n\t\t\t\t\t\t\t\t<input type=\"hidden\" name=\"flavor\" value=\"profile_register\" > \n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"register_email\">\n\t\t\t\t\t\t\t\t\t\t\tEmail Address\n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"email\" \n\t\t\t\t\t\t\t\t\t\t\tname=\"register_email\" \n\t\t\t\t\t\t\t\t\t\t\tid=\"register_email\" \n\t\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var register_email escape=HTML -->\"\n\t\t\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"register_email_again\" >\n\t\t\t\t\t\t\t\t\t\t\tEmail Address (again)\n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"email\" \n\t\t\t\t\t\t\t\t\t\t\tname=\"register_email_again\" \n\t\t\t\t\t\t\t\t\t\t\tid=\"register_email_again\" \n\t\t\t\t\t\t\t\t\t\t\tvalue=\"<!-- tmpl_var register_email_again -->\"\n\t\t\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<label for=\"register_password\" >\n\t\t\t\t\t\t\t\t\t\t\tPassword\n\t\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"password\" \n\t\t\t\t\t\t\t\t\t\t\tname=\"register_password\" \n\t\t\t\t\t\t\t\t\t\t\tid=\"register_password\" \n\t\t\t\t\t\t\t\t\t\t > \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<!-- tmpl_if can_use_captcha --> \n\t\t\t\t\t\t\t\t\t<!-- tmpl_if can_use_Google_reCAPTCHA_v2 --> \n\t\t\t\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t\t\t\t<div \n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"g-recaptcha\" \n\t\t\t\t\t\t\t\t\t\t\t\tid=\"profile_login_gr\"\n\t\t\t\t\t\t\t\t\t\t\t></div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<!-- /tmpl_if --> \n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<!-- tmpl_if can_use_Google_reCAPTCHA_v3 -->\t\t\t\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"hidden\"\n\t\t\t\t\t\t\t\t\t\t\tid=\"g-recaptcha-response_profile_login\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"g-recaptcha-response\"\n\t\t\t\t\t\t\t\t\t\t\tname=\"g-recaptcha-response\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<!-- /tmpl_if -->\n\t\t\t\t\t\t\t\t<!-- /tmpl_if --> \n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"small-12 columns\">\n\t\t\t\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\t\t\t\ttype=\"submit\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"button expand\"\n\t\t\t\t\t\t\t\t\t\t\tvalue=\"Register a New Profile\"\n\t\t\t\t\t\t\t\t\t\t> \n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</form> \n\n\t\t        </div>\n\t\t\t\t\t</div>\n\t\t\t\n\t\t\t<!-- /tmpl_if -->\n\n\t\t</dd>\n\t</dl>\n\n\n\n\n\n\t</div>\n</div>\n<!-- end profile_login.tmpl --> "], "filenames": ["dada/DADA/App.pm", "dada/DADA/Profile/Session.pm", "dada/DADA/Template/Widgets.pm", "dada/templates/profile_home.tmpl", "dada/templates/profile_login.tmpl"], "buggy_code_start_loc": [15089, 92, 1253, 257, 195], "buggy_code_end_loc": [16019, 276, 1293, 515, 195], "fixing_code_start_loc": [15089, 93, 1253, 257, 196], "fixing_code_end_loc": [16042, 331, 1293, 523, 205], "type": "CWE-352", "message": "Dada Mail is a web-based e-mail list management system. In affected versions a bad actor could give someone a carefully crafted web page via email, SMS, etc, that - when visited, allows them control of the list control panel as if the bad actor was logged in themselves. This includes changing any mailing list password, as well as the Dada Mail Root Password - which could effectively shut out actual list owners of the mailing list and allow the bad actor complete and unfettered control of your mailing list. This vulnerability also affects profile logins. For this vulnerability to work, the target of the bad actor would need to be logged into the list control panel themselves. This CSRF vulnerability in Dada Mail affects all versions of Dada Mail v11.15.1 and below. Although we know of no known CSRF exploits that have happened in the wild, this vulnerability has been confirmed by our testing, and by a third party. Users are advised to update to version 11.16.0.", "other": {"cve": {"id": "CVE-2021-41083", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-20T22:15:07.617", "lastModified": "2021-10-01T17:19:13.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dada Mail is a web-based e-mail list management system. In affected versions a bad actor could give someone a carefully crafted web page via email, SMS, etc, that - when visited, allows them control of the list control panel as if the bad actor was logged in themselves. This includes changing any mailing list password, as well as the Dada Mail Root Password - which could effectively shut out actual list owners of the mailing list and allow the bad actor complete and unfettered control of your mailing list. This vulnerability also affects profile logins. For this vulnerability to work, the target of the bad actor would need to be logged into the list control panel themselves. This CSRF vulnerability in Dada Mail affects all versions of Dada Mail v11.15.1 and below. Although we know of no known CSRF exploits that have happened in the wild, this vulnerability has been confirmed by our testing, and by a third party. Users are advised to update to version 11.16.0."}, {"lang": "es", "value": "Dada Mail es un sistema de administraci\u00f3n de listas de correo electr\u00f3nico basado en la web. En las versiones afectadas, un actor malicioso podr\u00eda dar a alguien una p\u00e1gina web cuidadosamente dise\u00f1ada por medio de correo electr\u00f3nico, SMS, etc., que, cuando es visitada, permite controlar el panel de control de la lista como si el actor malicioso estuviera conectado. Esto incluye el cambio de cualquier contrase\u00f1a de la lista de correo, as\u00ed como de la Contrase\u00f1a Root de Dada Mail, lo que podr\u00eda excluir a los verdaderos propietarios de la lista de correo y permitir al actor malicioso el control completo y sin restricciones de su lista de correo. Esta vulnerabilidad tambi\u00e9n afecta a los inicios de sesi\u00f3n del perfil. Para que esta vulnerabilidad funcione, el objetivo del actor malicioso tendr\u00eda que haber iniciado sesi\u00f3n en el panel de control de la lista por s\u00ed mismo. Esta vulnerabilidad de tipo CSRF en Dada Mail afecta a todas las versiones de Dada Mail v11.15.1 y por debajo. Aunque no sabemos de ninguna explotaci\u00f3n conocida de tipo CSRF que haya ocurrido en el wild, esta vulnerabilidad ha sido confirmada por nuestras pruebas, y por un tercero. Se recomienda a los usuarios que actualicen a la versi\u00f3n 11.16.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dadamailproject:dada_mail:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.16.0", "matchCriteriaId": "3C1B22EF-3AE3-4DB6-9E85-93AA7D3D33B6"}]}]}], "references": [{"url": "https://github.com/justingit/dada-mail/commit/d4d3d86d08c816b4da75a5ef45abc12188772459", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/justingit/dada-mail/security/advisories/GHSA-344m-p829-2r38", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/justingit/dada-mail/commit/d4d3d86d08c816b4da75a5ef45abc12188772459"}}