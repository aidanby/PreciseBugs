{"buggy_code": ["(ns metabase.api.session\n  \"/api/session endpoints\"\n  (:require [clojure.tools.logging :as log]\n            [compojure.core :refer [DELETE GET POST]]\n            [java-time :as t]\n            [metabase.analytics.snowplow :as snowplow]\n            [metabase.api.common :as api]\n            [metabase.config :as config]\n            [metabase.email.messages :as messages]\n            [metabase.events :as events]\n            [metabase.integrations.google :as google]\n            [metabase.integrations.ldap :as ldap]\n            [metabase.models.login-history :refer [LoginHistory]]\n            [metabase.models.session :refer [Session]]\n            [metabase.models.setting :as setting]\n            [metabase.models.user :as user :refer [User]]\n            [metabase.public-settings :as public-settings]\n            [metabase.server.middleware.session :as mw.session]\n            [metabase.server.request.util :as request.u]\n            [metabase.util :as u]\n            [metabase.util.i18n :refer [deferred-tru trs tru]]\n            [metabase.util.password :as u.password]\n            [metabase.util.schema :as su]\n            [schema.core :as s]\n            [throttle.core :as throttle]\n            [toucan.db :as db]\n            [toucan.models :as models])\n  (:import com.unboundid.util.LDAPSDKException\n           java.util.UUID))\n\n(s/defn ^:private record-login-history!\n  [session-id :- UUID user-id :- su/IntGreaterThanZero device-info :- request.u/DeviceInfo]\n  (db/insert! LoginHistory (merge {:user_id    user-id\n                                   :session_id (str session-id)}\n                                  device-info)))\n\n(defmulti create-session!\n  \"Generate a new Session for a User. `session-type` is the currently either `:password` (for email + password login) or\n  `:sso` (for other login types). Returns the newly generated Session.\"\n  {:arglists '(^java.util.UUID [session-type user device-info])}\n  (fn [session-type & _]\n    session-type))\n\n(def ^:private CreateSessionUserInfo\n  {:id         su/IntGreaterThanZero\n   :last_login s/Any\n   s/Keyword   s/Any})\n\n(s/defmethod create-session! :sso :- {:id UUID, :type (s/enum :normal :full-app-embed) s/Keyword s/Any}\n  [_ user :- CreateSessionUserInfo device-info :- request.u/DeviceInfo]\n  (let [session-uuid (UUID/randomUUID)\n        session      (or\n                      (db/insert! Session\n                        :id      (str session-uuid)\n                        :user_id (u/the-id user))\n                      ;; HACK !!! For some reason `db/insert` doesn't seem to be working correctly for Session.\n                      (models/post-insert (Session (str session-uuid))))]\n    (assert (map? session))\n    (events/publish-event! :user-login\n      {:user_id (u/the-id user), :session_id (str session-uuid), :first_login (nil? (:last_login user))})\n    (record-login-history! session-uuid (u/the-id user) device-info)\n    (when-not (:last_login user)\n      (snowplow/track-event! ::snowplow/new-user-created (u/the-id user)))\n    (assoc session :id session-uuid)))\n\n(s/defmethod create-session! :password :- {:id UUID, :type (s/enum :normal :full-app-embed), s/Keyword s/Any}\n  [session-type user :- CreateSessionUserInfo device-info :- request.u/DeviceInfo]\n  ;; this is actually the same as `create-session!` for `:sso` but we check whether password login is enabled.\n  (when-not (public-settings/enable-password-login)\n    (throw (ex-info (str (tru \"Password login is disabled for this instance.\")) {:status-code 400})))\n  ((get-method create-session! :sso) session-type user device-info))\n\n\n;;; ## API Endpoints\n\n(def ^:private login-throttlers\n  {:username   (throttle/make-throttler :username)\n   ;; IP Address doesn't have an actual UI field so just show error by username\n   :ip-address (throttle/make-throttler :username, :attempts-threshold 50)})\n\n(def ^:private password-fail-message (deferred-tru \"Password did not match stored password.\"))\n(def ^:private password-fail-snippet (deferred-tru \"did not match stored password\"))\n\n(def ^:private disabled-account-message (deferred-tru \"Your account is disabled. Please contact your administrator.\"))\n(def ^:private disabled-account-snippet (deferred-tru \"Your account is disabled.\"))\n\n;; Fake salt & hash used to run bcrypt hash if user doesn't exist, to avoid timing attacks (Metaboat #134)\n(def ^:private fake-salt \"ee169694-5eb6-4010-a145-3557252d7807\")\n(def ^:private fake-hashed-password \"$2a$10$owKjTym0ZGEEZOpxM0UyjekSvt66y1VvmOJddkAaMB37e0VAIVOX2\")\n\n(s/defn ^:private ldap-login :- (s/maybe {:id UUID, s/Keyword s/Any})\n  \"If LDAP is enabled and a matching user exists return a new Session for them, or `nil` if they couldn't be\n  authenticated.\"\n  [username password device-info :- request.u/DeviceInfo]\n  (when (ldap/ldap-configured?)\n    (try\n      (when-let [user-info (ldap/find-user username)]\n        (when-not (ldap/verify-password user-info password)\n          ;; Since LDAP knows about the user, fail here to prevent the local strategy to be tried with a possibly\n          ;; outdated password\n          (throw (ex-info (str password-fail-message)\n                          {:status-code 401\n                           :errors      {:password password-fail-snippet}})))\n        ;; password is ok, return new session if user is not deactivated\n        (let [user (ldap/fetch-or-create-user! user-info)]\n          (if (:is_active user)\n            (create-session! :sso user device-info)\n            (throw (ex-info (str disabled-account-message)\n                            {:status-code 401\n                             :errors      {:_error disabled-account-snippet}})))))\n      (catch LDAPSDKException e\n        (log/error e (trs \"Problem connecting to LDAP server, will fall back to local authentication\"))))))\n\n(s/defn ^:private email-login :- (s/maybe {:id UUID, s/Keyword s/Any})\n  \"Find a matching `User` if one exists and return a new Session for them, or `nil` if they couldn't be authenticated.\"\n  [username password device-info :- request.u/DeviceInfo]\n  (if-let [user (db/select-one [User :id :password_salt :password :last_login :is_active], :%lower.email (u/lower-case-en username))]\n    (when (u.password/verify-password password (:password_salt user) (:password user))\n      (if (:is_active user)\n        (create-session! :password user device-info)\n        (throw (ex-info (str disabled-account-message)\n                        {:status-code 401\n                         :errors      {:_error disabled-account-snippet}}))))\n    (do\n      ;; User doesn't exist; run bcrypt hash anyway to avoid leaking account existence in request timing\n      (u.password/verify-password password fake-salt fake-hashed-password)\n      nil)))\n\n(def ^:private throttling-disabled? (config/config-bool :mb-disable-session-throttle))\n\n(defn- throttle-check\n  \"Pass through to `throttle/check` but will not check if `throttling-disabled?` is true\"\n  [throttler throttle-key]\n  (when-not throttling-disabled?\n    (throttle/check throttler throttle-key)))\n\n(s/defn ^:private login :- {:id UUID, :type (s/enum :normal :full-app-embed), s/Keyword s/Any}\n  \"Attempt to login with different avaialable methods with `username` and `password`, returning new Session ID or\n  throwing an Exception if login could not be completed.\"\n  [username :- su/NonBlankString password :- su/NonBlankString device-info :- request.u/DeviceInfo]\n  ;; Primitive \"strategy implementation\", should be reworked for modular providers in #3210\n  (or (ldap-login username password device-info)  ; First try LDAP if it's enabled\n      (email-login username password device-info) ; Then try local authentication\n      ;; If nothing succeeded complain about it\n      ;; Don't leak whether the account doesn't exist or the password was incorrect\n      (throw\n       (ex-info (str password-fail-message)\n                {:status-code 401\n                 :errors      {:password password-fail-snippet}}))))\n\n(defn- do-http-401-on-error [f]\n  (try\n    (f)\n    (catch clojure.lang.ExceptionInfo e\n      (throw (ex-info (ex-message e)\n                      (assoc (ex-data e) :status-code 401))))))\n\n(defmacro http-401-on-error\n  \"Add `{:status-code 401}` to exception data thrown by `body`.\"\n  [& body]\n  `(do-http-401-on-error (fn [] ~@body)))\n\n(api/defendpoint POST \"/\"\n  \"Login.\"\n  [:as {{:keys [username password]} :body, :as request}]\n  {username su/NonBlankString\n   password su/NonBlankString}\n  (let [ip-address   (request.u/ip-address request)\n        request-time (t/zoned-date-time (t/zone-id \"GMT\"))\n        do-login     (fn []\n                       (let [{session-uuid :id, :as session} (login username password (request.u/device-info request))\n                             response                        {:id (str session-uuid)}]\n                         (mw.session/set-session-cookies request response session request-time)))]\n    (if throttling-disabled?\n      (do-login)\n      (http-401-on-error\n       (throttle/with-throttling [(login-throttlers :ip-address) ip-address\n                                  (login-throttlers :username)   username]\n           (do-login))))))\n\n(api/defendpoint DELETE \"/\"\n  \"Logout.\"\n  [:as {:keys [metabase-session-id]}]\n  (api/check-exists? Session metabase-session-id)\n  (db/delete! Session :id metabase-session-id)\n  (mw.session/clear-session-cookie api/generic-204-no-content))\n\n;; Reset tokens: We need some way to match a plaintext token with the a user since the token stored in the DB is\n;; hashed. So we'll make the plaintext token in the format USER-ID_RANDOM-UUID, e.g.\n;; \"100_8a266560-e3a8-4dc1-9cd1-b4471dcd56d7\", before hashing it. \"Leaking\" the ID this way is ok because the\n;; plaintext token is only sent in the password reset email to the user in question.\n;;\n;; There's also no need to salt the token because it's already random <3\n\n(def ^:private forgot-password-throttlers\n  {:email      (throttle/make-throttler :email)\n   :ip-address (throttle/make-throttler :email, :attempts-threshold 50)})\n\n(defn- forgot-password-impl\n  [email]\n  (future\n    (when-let [{user-id :id, google-auth? :google_auth, is-active? :is_active}\n               (db/select-one [User :id :google_auth :is_active] :%lower.email (u/lower-case-en email))]\n      (let [reset-token        (user/set-password-reset-token! user-id)\n            password-reset-url (str (public-settings/site-url) \"/auth/reset_password/\" reset-token)]\n        (log/info password-reset-url)\n        (messages/send-password-reset-email! email google-auth? password-reset-url is-active?)))))\n\n(api/defendpoint POST \"/forgot_password\"\n  \"Send a reset email when user has forgotten their password.\"\n  [:as {{:keys [email]} :body, :as request}]\n  {email su/Email}\n  ;; Don't leak whether the account doesn't exist, just pretend everything is ok\n  (let [request-source (request.u/ip-address request)]\n    (throttle-check (forgot-password-throttlers :ip-address) request-source))\n  (throttle-check (forgot-password-throttlers :email) email)\n  (forgot-password-impl email)\n  api/generic-204-no-content)\n\n(def ^:private ^:const reset-token-ttl-ms\n  \"Number of milliseconds a password reset is considered valid.\"\n  (* 48 60 60 1000)) ; token considered valid for 48 hours\n\n(defn- valid-reset-token->user\n  \"Check if a password reset token is valid. If so, return the `User` ID it corresponds to.\"\n  [^String token]\n  (when-let [[_ user-id] (re-matches #\"(^\\d+)_.+$\" token)]\n    (let [user-id (Integer/parseInt user-id)]\n      (when-let [{:keys [reset_token reset_triggered], :as user} (db/select-one [User :id :last_login :reset_triggered\n                                                                                 :reset_token]\n                                                                   :id user-id, :is_active true)]\n        ;; Make sure the plaintext token matches up with the hashed one for this user\n        (when (u/ignore-exceptions\n                (u.password/bcrypt-verify token reset_token))\n          ;; check that the reset was triggered within the last 48 HOURS, after that the token is considered expired\n          (let [token-age (- (System/currentTimeMillis) reset_triggered)]\n            (when (< token-age reset-token-ttl-ms)\n              user)))))))\n\n(api/defendpoint POST \"/reset_password\"\n  \"Reset password with a reset token.\"\n  [:as {{:keys [token password]} :body, :as request}]\n  {token    su/NonBlankString\n   password su/ValidPassword}\n  (or (when-let [{user-id :id, :as user} (valid-reset-token->user token)]\n        (user/set-password! user-id password)\n        ;; if this is the first time the user has logged in it means that they're just accepted their Metabase invite.\n        ;; Send all the active admins an email :D\n        (when-not (:last_login user)\n          (messages/send-user-joined-admin-notification-email! (User user-id)))\n        ;; after a successful password update go ahead and offer the client a new session that they can use\n        (let [{session-uuid :id, :as session} (create-session! :password user (request.u/device-info request))\n              response                        {:success    true\n                                               :session_id (str session-uuid)}]\n          (mw.session/set-session-cookies request response session (t/zoned-date-time (t/zone-id \"GMT\")))))\n      (api/throw-invalid-param-exception :password (tru \"Invalid reset token\"))))\n\n(api/defendpoint GET \"/password_reset_token_valid\"\n  \"Check is a password reset token is valid and isn't expired.\"\n  [token]\n  {token s/Str}\n  {:valid (boolean (valid-reset-token->user token))})\n\n(api/defendpoint GET \"/properties\"\n  \"Get all global properties and their values. These are the specific `Settings` which are meant to be public.\"\n  []\n  (merge\n   (setting/user-readable-values-map :public)\n   (when @api/*current-user*\n     (setting/user-readable-values-map :authenticated))\n   (when api/*is-superuser?*\n     (setting/user-readable-values-map :admin))))\n\n(api/defendpoint POST \"/google_auth\"\n  \"Login with Google Auth.\"\n  [:as {{:keys [token]} :body, :as request}]\n  {token su/NonBlankString}\n  (when-not (google/google-auth-client-id)\n    (throw (ex-info \"Google Auth is disabled.\" {:status-code 400})))\n  ;; Verify the token is valid with Google\n  (if throttling-disabled?\n    (google/do-google-auth request)\n    (http-401-on-error\n     (throttle/with-throttling [(login-throttlers :ip-address) (request.u/ip-address request)]\n       (let [user (google/do-google-auth request)\n             {session-uuid :id, :as session} (create-session! :sso user (request.u/device-info request))\n             response {:id (str session-uuid)}\n             user (db/select-one [User :id :is_active], :email (:email user))]\n         (if (and user (:is_active user))\n           (mw.session/set-session-cookies request\n                                           response\n                                           session\n                                           (t/zoned-date-time (t/zone-id \"GMT\")))\n           (throw (ex-info (str disabled-account-message)\n                           {:status-code 401\n                            :errors      {:account disabled-account-snippet}}))))))))\n\n(defn- +log-all-request-failures [handler]\n  (fn [request respond raise]\n    (try\n      (handler request respond raise)\n      (catch Throwable e\n        (log/error e (trs \"Authentication endpoint error\"))\n        (throw e)))))\n\n(api/define-routes +log-all-request-failures)\n", "(ns metabase.email.messages\n  \"Convenience functions for sending templated email messages.  Each function here should represent a single email.\n   NOTE: we want to keep this about email formatting, so don't put heavy logic here RE: building data for emails.\"\n  (:require [clojure.core.cache :as cache]\n            [clojure.java.io :as io]\n            [clojure.tools.logging :as log]\n            [hiccup.core :refer [html]]\n            [java-time :as t]\n            [medley.core :as m]\n            [metabase.config :as config]\n            [metabase.driver :as driver]\n            [metabase.driver.util :as driver.u]\n            [metabase.email :as email]\n            [metabase.models.collection :as collection]\n            [metabase.models.permissions :as perms]\n            [metabase.models.user :refer [User]]\n            [metabase.public-settings :as public-settings]\n            [metabase.public-settings.premium-features :as premium-features]\n            [metabase.pulse.markdown :as markdown]\n            [metabase.pulse.parameters :as params]\n            [metabase.pulse.render :as render]\n            [metabase.pulse.render.body :as body]\n            [metabase.pulse.render.image-bundle :as image-bundle]\n            [metabase.pulse.render.js-svg :as js-svg]\n            [metabase.pulse.render.style :as style]\n            [metabase.query-processor.store :as qp.store]\n            [metabase.query-processor.streaming :as qp.streaming]\n            [metabase.query-processor.streaming.interface :as qp.si]\n            [metabase.query-processor.streaming.xlsx :as qp.xlsx]\n            [metabase.query-processor.timezone :as qp.timezone]\n            [metabase.util :as u]\n            [metabase.util.date-2 :as u.date]\n            [metabase.util.i18n :as i18n :refer [deferred-trs trs tru]]\n            [metabase.util.urls :as urls]\n            [stencil.core :as stencil]\n            [stencil.loader :as stencil-loader]\n            [toucan.db :as db])\n  (:import [java.io File IOException OutputStream]\n           java.time.format.DateTimeFormatter\n           java.time.LocalTime))\n\n(defn- app-name-trs\n  \"Return the user configured application name, or Metabase translated\n  via tru if a name isn't configured.\"\n  []\n  (or (public-settings/application-name)\n      (trs \"Metabase\")))\n\n;; Dev only -- disable template caching\n(when config/is-dev?\n  (alter-meta! #'stencil.core/render-file assoc :style/indent 1)\n  (stencil-loader/set-cache (cache/ttl-cache-factory {} :ttl 0)))\n\n(defn- logo-url []\n  (let [url (public-settings/application-logo-url)]\n    (cond\n      (= url \"app/assets/img/logo.svg\") \"http://static.metabase.com/email_logo.png\"\n\n      :else nil\n      ;; NOTE: disabling whitelabeled URLs for now since some email clients don't render them correctly\n      ;; We need to extract them and embed as attachments like we do in metabase.pulse.render.image-bundle\n      ;; (data-uri-svg? url)               (themed-image-url url color)\n      ;; :else                             url\n      )))\n\n(defn- icon-bundle\n  [icon-name]\n  (let [color     (style/primary-color)\n        png-bytes (js-svg/icon icon-name color)]\n    (-> (image-bundle/make-image-bundle :attachment png-bytes)\n        (image-bundle/image-bundle->attachment))))\n\n(defn- button-style [color]\n  (str \"display: inline-block; \"\n       \"box-sizing: border-box; \"\n       \"padding: 0.5rem 1.375rem; \"\n       \"font-size: 1.063rem; \"\n       \"font-weight: bold; \"\n       \"text-decoration: none; \"\n       \"cursor: pointer; \"\n       \"color: #fff; \"\n       \"border: 1px solid \" color \"; \"\n       \"background-color: \" color \"; \"\n       \"border-radius: 4px;\"))\n\n;;; Various Context Helper Fns. Used to build Stencil template context\n\n(defn- common-context\n  \"Context that is used across multiple email templates, and that is the same for all emails\"\n  []\n  {:applicationName           (public-settings/application-name)\n   :applicationColor          (style/primary-color)\n   :applicationLogoUrl        (logo-url)\n   :buttonStyle               (button-style (style/primary-color))\n   :colorTextLight            style/color-text-light\n   :colorTextMedium           style/color-text-medium\n   :colorTextDark             style/color-text-dark\n   :notificationManagementUrl (urls/notification-management-url)\n   :siteUrl                   (public-settings/site-url)})\n\n(def ^:private notification-context\n  {:emailType  \"notification\"\n   :logoHeader true})\n\n(defn- abandonment-context []\n  {:heading      (trs \"We\u2019d love your feedback.\")\n   :callToAction (str (deferred-trs \"It looks like Metabase wasn\u2019t quite a match for you.\")\n                      \" \"\n                      (deferred-trs \"Would you mind taking a fast 5 question survey to help the Metabase team understand why and make things better in the future?\"))\n   :link         \"https://metabase.com/feedback/inactive\"})\n\n(defn- follow-up-context []\n  {:heading      (trs \"We hope you''ve been enjoying Metabase.\")\n   :callToAction (trs \"Would you mind taking a fast 6 question survey to tell us how it\u2019s going?\")\n   :link         \"https://metabase.com/feedback/active\"})\n\n\n;;; ### Public Interface\n\n\n(defn send-new-user-email!\n  \"Send an email to `invitied` letting them know `invitor` has invited them to join Metabase.\"\n  [invited invitor join-url sent-from-setup?]\n  (let [company      (or (public-settings/site-name) \"Unknown\")\n        message-body (stencil/render-file \"metabase/email/new_user_invite\"\n                                          (merge (common-context)\n                                                 {:emailType     \"new_user_invite\"\n                                                  :invitedName   (or (:first_name invited) (:email invited))\n                                                  :invitorName   (or (:first_name invitor) (:email invitor))\n                                                  :invitorEmail  (:email invitor)\n                                                  :company       company\n                                                  :joinUrl       join-url\n                                                  :today         (t/format \"MMM'&nbsp;'dd,'&nbsp;'yyyy\" (t/zoned-date-time))\n                                                  :logoHeader    true\n                                                  :sentFromSetup sent-from-setup?}))]\n    (email/send-message!\n     :subject      (str (trs \"You''re invited to join {0}''s {1}\" company (app-name-trs)))\n     :recipients   [(:email invited)]\n     :message-type :html\n     :message      message-body)))\n\n(defn- all-admin-recipients\n  \"Return a sequence of email addresses for all Admin users.\n\n  The first recipient will be the site admin (or oldest admin if unset), which is the address that should be used in\n  `mailto` links (e.g., for the new user to email with any questions).\"\n  []\n  (concat (when-let [admin-email (public-settings/admin-email)]\n            [admin-email])\n          (db/select-field :email 'User, :is_superuser true, :is_active true, {:order-by [[:id :asc]]})))\n\n(defn send-user-joined-admin-notification-email!\n  \"Send an email to the `invitor` (the Admin who invited `new-user`) letting them know `new-user` has joined.\"\n  [new-user & {:keys [google-auth?]}]\n  {:pre [(map? new-user)]}\n  (let [recipients (all-admin-recipients)]\n    (email/send-message!\n     :subject      (str (if google-auth?\n                          (trs \"{0} created a {1} account\" (:common_name new-user) (app-name-trs))\n                          (trs \"{0} accepted their {1} invite\" (:common_name new-user) (app-name-trs))))\n     :recipients   recipients\n     :message-type :html\n     :message      (stencil/render-file \"metabase/email/user_joined_notification\"\n                                        (merge (common-context)\n                                               {:logoHeader        true\n                                                :joinedUserName    (or (:first_name new-user) (:email new-user))\n                                                :joinedViaSSO      google-auth?\n                                                :joinedUserEmail   (:email new-user)\n                                                :joinedDate        (t/format \"EEEE, MMMM d\" (t/zoned-date-time)) ; e.g. \"Wednesday, July 13\". TODO - is this what we want?\n                                                :adminEmail        (first recipients)\n                                                :joinedUserEditUrl (str (public-settings/site-url) \"/admin/people\")})))))\n\n(defn send-password-reset-email!\n  \"Format and send an email informing the user how to reset their password.\"\n  [email google-auth? password-reset-url is-active?]\n  {:pre [(m/boolean? google-auth?)\n         (u/email? email)\n         (string? password-reset-url)]}\n  (let [message-body (stencil/render-file\n                      \"metabase/email/password_reset\"\n                      (merge (common-context)\n                             {:emailType        \"password_reset\"\n                              :sso              google-auth?\n                              :passwordResetUrl password-reset-url\n                              :logoHeader       true\n                              :isActive         is-active?\n                              :adminEmail       (public-settings/admin-email)\n                              :adminEmailSet    (boolean (public-settings/admin-email))}))]\n    (email/send-message!\n     :subject      (trs \"[{0}] Password Reset Request\" (app-name-trs))\n     :recipients   [email]\n     :message-type :html\n     :message      message-body)))\n\n(defn send-login-from-new-device-email!\n  \"Format and send an email informing the user that this is the first time we've seen a login from this device. Expects\n  login history infomation as returned by `metabase.models.login-history/human-friendly-infos`.\"\n  [{user-id :user_id, :keys [timestamp], :as login-history}]\n  (let [user-info    (db/select-one ['User [:first_name :first-name] :email :locale] :id user-id)\n        user-locale  (or (:locale user-info) (i18n/site-locale))\n        timestamp    (u.date/format-human-readable timestamp user-locale)\n        context      (merge (common-context)\n                            {:first-name (:first-name user-info)\n                             :device     (:device_description login-history)\n                             :location   (:location login-history)\n                             :timestamp  timestamp})\n        message-body (stencil/render-file \"metabase/email/login_from_new_device\"\n                                          context)]\n    (email/send-message!\n     :subject      (trs \"We''ve Noticed a New {0} Login, {1}\" (app-name-trs) (:first-name user-info))\n     :recipients   [(:email user-info)]\n     :message-type :html\n     :message      message-body)))\n\n;; TODO - I didn't write these function and I don't know what it's for / what it's supposed to be doing. If this is\n;; determined add appropriate documentation\n\n(defn- model-name->url-fn [model]\n  (case model\n    \"Card\"      urls/card-url\n    \"Dashboard\" urls/dashboard-url\n    \"Pulse\"     urls/pulse-url\n    \"Segment\"   urls/segment-url))\n\n(defn- add-url-to-dependency [{:keys [id model], :as obj}]\n  (assoc obj :url ((model-name->url-fn model) id)))\n\n(defn- build-dependencies\n  \"Build a sequence of dependencies from a `model-name->dependencies` map, and add various information such as obj URLs.\"\n  [model-name->dependencies]\n  (for [model-name (sort (keys model-name->dependencies))\n        :let       [user-facing-name (if (= model-name \"Card\")\n                                       \"Saved Question\"\n                                       model-name)]\n        deps       (get model-name->dependencies model-name)]\n    {:model   user-facing-name\n     :objects (for [dep deps]\n                (add-url-to-dependency dep))}))\n\n(defn send-notification-email!\n  \"Format and send an email informing the user about changes to objects in the system.\"\n  [email context]\n  {:pre [(u/email? email) (map? context)]}\n  (let [context      (merge (update context :dependencies build-dependencies)\n                            notification-context)\n        message-body (stencil/render-file \"metabase/email/notification\"\n                                          (merge (common-context) context))]\n    (email/send-message!\n     :subject      (trs \"[{0}] Notification\" (app-name-trs))\n     :recipients   [email]\n     :message-type :html\n     :message      message-body)))\n\n(defn- admin-or-ee-monitoring-details-emails\n  \"Find emails for users that have an interest in monitoring the database.\n   If oss that means admin users.\n   If ee that also means users with monitoring and details permissions.\"\n  [database-id]\n  (let [monitoring (perms/application-perms-path :monitoring)\n        db-details (perms/feature-perms-path :details :yes database-id)\n        user-ids (when (premium-features/enable-advanced-permissions?)\n                   (->> {:select   [:pgm.user_id]\n                         :from     [[:permissions_group_membership :pgm]]\n                         :join     [[:permissions_group :pg] [:= :pgm.group_id :pg.id]]\n                         :where    [:and\n                                    [:exists {:select [1]\n                                              :from [[:permissions :p]]\n                                              :where [:and\n                                                      [:= :p.group_id :pg.id]\n                                                      [:= :p.object monitoring]]}]\n                                    [:exists {:select [1]\n                                              :from [[:permissions :p]]\n                                              :where [:and\n                                                      [:= :p.group_id :pg.id]\n                                                      [:= :p.object db-details]]}]]\n                         :group-by [:pgm.user_id]}\n                        db/query\n                        (mapv :user_id)))]\n    (into\n      []\n      (distinct)\n      (concat\n        (all-admin-recipients)\n        (when (seq user-ids)\n          (db/select-field :email User {:where [:and\n                                                [:= :is_active true]\n                                                [:in :id user-ids]]}))))))\n\n(defn send-persistent-model-error-email!\n  \"Format and send an email informing the user about errors in the persistent model refresh task.\"\n  [database-id persisted-infos trigger]\n  {:pre [(seq persisted-infos)]}\n  (let [database (:database (first persisted-infos))\n        emails (admin-or-ee-monitoring-details-emails database-id)\n        timezone (some-> database qp.timezone/results-timezone-id t/zone-id)\n        context {:database-name (:name database)\n                 :errors\n                 (for [[idx persisted-info] (m/indexed persisted-infos)\n                       :let [card (:card persisted-info)\n                             collection (or (:collection card)\n                                            (collection/root-collection-with-ui-details nil))]]\n                   {:is-not-first (not= 0 idx)\n                    :error (:error persisted-info)\n                    :card-id (:id card)\n                    :card-name (:name card)\n                    :collection-name (:name collection)\n                    ;; February 1, 2022, 3:10 PM\n                    :last-run-at (t/format \"MMMM d, yyyy, h:mm a z\" (t/zoned-date-time (:refresh_begin persisted-info) timezone))\n                    :last-run-trigger trigger\n                    :card-url (urls/card-url (:id card))\n                    :collection-url (urls/collection-url (:id collection))\n                    :caching-log-details-url (urls/tools-caching-details-url (:id persisted-info))})}\n        message-body (stencil/render-file \"metabase/email/persisted-model-error\"\n                                          (merge (common-context) context))]\n    (when (seq emails)\n      (email/send-message!\n        :subject      (trs \"[{0}] Model cache refresh failed for {1}\" (app-name-trs) (:name database))\n        :recipients   (vec emails)\n        :message-type :html\n        :message      message-body))))\n\n(defn send-follow-up-email!\n  \"Format and send an email to the system admin following up on the installation.\"\n  [email msg-type]\n  {:pre [(u/email? email) (contains? #{\"abandon\" \"follow-up\"} msg-type)]}\n  (let [subject      (str (if (= \"abandon\" msg-type)\n                            (trs \"[{0}] Help make [{1}] better.\" (app-name-trs) (app-name-trs))\n                            (trs \"[{0}] Tell us how things are going.\" (app-name-trs))))\n        context      (merge notification-context\n                            (if (= \"abandon\" msg-type)\n                              (abandonment-context)\n                              (follow-up-context)))\n        message-body (stencil/render-file \"metabase/email/follow_up_email\"\n                                          (merge (common-context) context))]\n    (email/send-message!\n     :subject      subject\n     :recipients   [email]\n     :message-type :html\n     :message      message-body)))\n\n(defn- make-message-attachment [[content-id url]]\n  {:type         :inline\n   :content-id   content-id\n   :content-type \"image/png\"\n   :content      url})\n\n(defn- pulse-link-context\n  [{:keys [cards dashboard_id]}]\n  (when-let [dashboard-id (or dashboard_id\n                              (some :dashboard_id cards))]\n    {:pulseLink (urls/dashboard-url dashboard-id)}))\n\n(defn- pulse-context [pulse dashboard]\n  (merge (common-context)\n         {:emailType                 \"pulse\"\n          :title                     (:name pulse)\n          :titleUrl                  (params/dashboard-url (:id dashboard) (params/parameters pulse dashboard))\n          :dashboardDescription      (:description dashboard)\n          :creator                   (-> pulse :creator :common_name)\n          :sectionStyle              (style/style (style/section-style))}\n         (pulse-link-context pulse)))\n\n(defn- create-temp-file\n  \"Separate from `create-temp-file-or-throw` primarily so that we can simulate exceptions in tests\"\n  [suffix]\n  (doto (File/createTempFile \"metabase_attachment\" suffix)\n    .deleteOnExit))\n\n(defn- create-temp-file-or-throw\n  \"Tries to create a temp file, will give the users a better error message if we are unable to create the temp file\"\n  [suffix]\n  (try\n    (create-temp-file suffix)\n    (catch IOException e\n      (let [ex-msg (tru \"Unable to create temp file in `{0}` for email attachments \"\n                        (System/getProperty \"java.io.tmpdir\"))]\n        (throw (IOException. ex-msg e))))))\n\n(defn- create-result-attachment-map [export-type card-name ^File attachment-file]\n  (let [{:keys [content-type]} (qp.si/stream-options export-type)]\n    {:type         :attachment\n     :content-type content-type\n     :file-name    (format \"%s.%s\" card-name (name export-type))\n     :content      (-> attachment-file .toURI .toURL)\n     :description  (format \"More results for '%s'\" card-name)}))\n\n(defn- include-csv-attachment?\n  \"Should this `card` and `results` include a CSV attachment?\"\n  [{include-csv? :include_csv, include-xls? :include_xls, card-name :name, :as card} {:keys [cols rows], :as result-data}]\n  (letfn [(yes [reason & args]\n            (log/tracef \"Including CSV attachement for Card %s because %s\" (pr-str card-name) (apply format reason args))\n            true)\n          (no [reason & args]\n            (log/tracef \"NOT including CSV attachement for Card %s because %s\" (pr-str card-name) (apply format reason args))\n            false)]\n    (cond\n      include-csv?\n      (yes \"it has `:include_csv`\")\n\n      include-xls?\n      (no \"it has `:include_xls`\")\n\n      (some (complement body/show-in-table?) cols)\n      (yes \"some columns are not included in rendered results\")\n\n      (not= :table (render/detect-pulse-chart-type card nil result-data))\n      (no \"we've determined it should not be rendered as a table\")\n\n      (= (count (take body/rows-limit rows)) body/rows-limit)\n      (yes \"the results have >= %d rows\" body/rows-limit)\n\n      :else\n      (no \"less than %d rows in results\" body/rows-limit))))\n\n(defn- stream-api-results-to-export-format\n  \"For legacy compatability. Takes QP results in the normal `:api` response format and streams them to a different\n  format.\n\n  TODO -- this function is provided mainly because rewriting all of the Pulse/Alert code to stream results directly\n  was a lot of work. I intend to rework that code so we can stream directly to the correct export format(s) at some\n  point in the future; for now, this function is a stopgap.\n\n  Results are streamed synchronosuly. Caller is responsible for closing `os` when this call is complete.\"\n  [export-format ^OutputStream os {{:keys [rows]} :data, database-id :database_id, :as results}]\n  ;; make sure Database/driver info is available for the streaming results writers -- they might need this in order to\n  ;; get timezone information when writing results\n  (driver/with-driver (driver.u/database->driver database-id)\n    (qp.store/with-store\n      (qp.store/fetch-and-store-database! database-id)\n      (binding [qp.xlsx/*parse-temporal-string-values* true]\n        (let [w                           (qp.si/streaming-results-writer export-format os)\n              cols                        (-> results :data :cols)\n              viz-settings                (-> results :data :viz-settings)\n              [ordered-cols output-order] (qp.streaming/order-cols cols viz-settings)\n              viz-settings'               (assoc viz-settings :output-order output-order)]\n          (qp.si/begin! w\n                        (assoc-in results [:data :ordered-cols] ordered-cols)\n                        viz-settings')\n          (dorun\n           (map-indexed\n            (fn [i row]\n              (qp.si/write-row! w row i ordered-cols viz-settings'))\n            rows))\n          (qp.si/finish! w results))))))\n\n(defn- result-attachment\n  [{{card-name :name, :as card} :card, {{:keys [rows], :as result-data} :data, :as result} :result}]\n  (when (seq rows)\n    [(when-let [temp-file (and (include-csv-attachment? card result-data)\n                               (create-temp-file-or-throw \"csv\"))]\n       (with-open [os (io/output-stream temp-file)]\n         (stream-api-results-to-export-format :csv os result))\n       (create-result-attachment-map \"csv\" card-name temp-file))\n     (when-let [temp-file (and (:include_xls card)\n                               (create-temp-file-or-throw \"xlsx\"))]\n       (with-open [os (io/output-stream temp-file)]\n         (stream-api-results-to-export-format :xlsx os result))\n       (create-result-attachment-map \"xlsx\" card-name temp-file))]))\n\n(defn- result-attachments [results]\n  (filter some? (mapcat result-attachment results)))\n\n(defn- render-result-card\n  [timezone result]\n  (if (:card result)\n    (render/render-pulse-section timezone result)\n    {:content (markdown/process-markdown (:text result) :html)}))\n\n(defn- render-filters\n  [notification dashboard]\n  (let [filters (params/parameters notification dashboard)\n        cells   (map\n                 (fn [filter]\n                   [:td {:class \"filter-cell\"\n                         :style (style/style {:width \"50%\"\n                                              :padding \"0px\"\n                                              :vertical-align \"baseline\"})}\n                    [:table {:cellpadding \"0\"\n                             :cellspacing \"0\"\n                             :width \"100%\"\n                             :height \"100%\"}\n                     [:tr\n                      [:td\n                       {:style (style/style {:color style/color-text-medium\n                                             :min-width \"100px\"\n                                             :width \"50%\"\n                                             :padding \"4px 4px 4px 0\"\n                                             :vertical-align \"baseline\"})}\n                       (:name filter)]\n                      [:td\n                       {:style (style/style {:color style/color-text-dark\n                                             :min-width \"100px\"\n                                             :width \"50%\"\n                                             :padding \"4px 16px 4px 8px\"\n                                             :vertical-align \"baseline\"})}\n                       (params/value-string filter)]]]])\n                 filters)\n        rows    (partition 2 2 nil cells)]\n    (html\n      [:table {:style (style/style {:table-layout :fixed\n                                    :border-collapse :collapse\n                                    :cellpadding \"0\"\n                                    :cellspacing \"0\"\n                                    :width \"100%\"\n                                    :font-size  \"12px\"\n                                    :font-weight 700\n                                    :margin-top \"8px\"})}\n      (for [row rows]\n        [:tr {} row])])))\n\n(defn- render-message-body\n  [notification message-type message-context timezone dashboard results]\n  (let [rendered-cards  (binding [render/*include-title* true]\n                          (mapv #(render-result-card timezone %) results))\n        icon-name       (case message-type\n                          :alert :bell\n                          :pulse :dashboard)\n        icon-attachment (first (map make-message-attachment (icon-bundle icon-name)))\n        filters         (when dashboard\n                          (render-filters notification dashboard))\n        message-body    (assoc message-context :pulse (html (vec (cons :div (map :content rendered-cards))))\n                               :filters filters\n                               :iconCid (:content-id icon-attachment))\n        attachments     (apply merge (map :attachments rendered-cards))]\n    (vec (concat [{:type \"text/html; charset=utf-8\" :content (stencil/render-file \"metabase/email/pulse\" message-body)}]\n                 (map make-message-attachment attachments)\n                 [icon-attachment]\n                 (result-attachments results)))))\n\n(defn- assoc-attachment-booleans [pulse results]\n  (for [{{result-card-id :id} :card :as result} results\n        :let [pulse-card (m/find-first #(= (:id %) result-card-id) (:cards pulse))]]\n    (if result-card-id\n      (update result :card merge (select-keys pulse-card [:include_csv :include_xls]))\n      result)))\n\n(defn render-pulse-email\n  \"Take a pulse object and list of results, returns an array of attachment objects for an email\"\n  [timezone pulse dashboard results]\n  (render-message-body pulse\n                       :pulse\n                       (pulse-context pulse dashboard)\n                       timezone\n                       dashboard\n                       (assoc-attachment-booleans pulse results)))\n\n(defn pulse->alert-condition-kwd\n  \"Given an `alert` return a keyword representing what kind of goal needs to be met.\"\n  [{:keys [alert_above_goal alert_condition] :as _alert}]\n  (if (= \"goal\" alert_condition)\n    (if (true? alert_above_goal)\n      :meets\n      :below)\n    :rows))\n\n(defn- first-card\n  \"Alerts only have a single card, so the alerts API accepts a `:card` key, while pulses have `:cards`. Depending on\n  whether the data comes from the alert API or pulse tasks, the card could be under `:card` or `:cards`\"\n  [alert]\n  (or (:card alert)\n      (first (:cards alert))))\n\n(defn- common-alert-context\n  \"Template context that is applicable to all alert templates, including alert management templates\n  (e.g. the subscribed/unsubscribed emails)\"\n  ([alert]\n   (common-alert-context alert nil))\n  ([alert alert-condition-map]\n   (let [{card-id :id, card-name :name} (first-card alert)]\n     (merge (common-context)\n            {:emailType                 \"alert\"\n             :questionName              card-name\n             :questionURL               (urls/card-url card-id)\n             :sectionStyle              (style/section-style)}\n            (when alert-condition-map\n              {:alertCondition (get alert-condition-map (pulse->alert-condition-kwd alert))})))))\n\n(defn- schedule-hour-text\n  [{hour :schedule_hour}]\n  (.format (LocalTime/of hour 0)\n           (DateTimeFormatter/ofPattern \"h a\")))\n\n(defn- schedule-day-text\n  [{day :schedule_day}]\n  (get {\"sun\" \"Sunday\"\n        \"mon\" \"Monday\"\n        \"tue\" \"Tuesday\"\n        \"wed\" \"Wednesday\"\n        \"thu\" \"Thursday\"\n        \"fri\" \"Friday\"\n        \"sat\" \"Saturday\"}\n       day))\n\n(defn- schedule-timezone\n  []\n  (or (driver/report-timezone) \"UTC\"))\n\n(defn- alert-schedule-text\n  \"Returns a string that describes the run schedule of an alert (i.e. how often results are checked),\n  for inclusion in the email template. Not translated, since emails in general are not currently translated.\"\n  [channel]\n  (case (:schedule_type channel)\n    :hourly\n    \"Run hourly\"\n\n    :daily\n    (format \"Run daily at %s %s\"\n            (schedule-hour-text channel)\n            (schedule-timezone))\n\n    :weekly\n    (format \"Run weekly on %s at %s %s\"\n            (schedule-day-text channel)\n            (schedule-hour-text channel)\n            (schedule-timezone))))\n\n(defn- alert-context\n  \"Context that is applicable only to the actual alert template (not alert management templates)\"\n  [alert channel]\n  (let [{card-id :id, card-name :name} (first-card alert)]\n    {:title         card-name\n     :titleUrl      (urls/card-url card-id)\n     :alertSchedule (alert-schedule-text channel)\n     :creator       (-> alert :creator :common_name)}))\n\n(defn- alert-results-condition-text [goal-value]\n  {:meets (format \"This question has reached its goal of %s.\" goal-value)\n   :below (format \"This question has gone below its goal of %s.\" goal-value)})\n\n(defn render-alert-email\n  \"Take a pulse object and list of results, returns an array of attachment objects for an email\"\n  [timezone {:keys [alert_first_only] :as alert} channel results goal-value]\n  (let [message-ctx  (merge\n                      (common-alert-context alert (alert-results-condition-text goal-value))\n                      (alert-context alert channel))]\n    (render-message-body alert\n                         :alert\n                         (assoc message-ctx :firstRunOnly? alert_first_only)\n                         timezone\n                         nil\n                         (assoc-attachment-booleans alert results))))\n\n(def ^:private alert-condition-text\n  {:meets \"when this question meets its goal\"\n   :below \"when this question goes below its goal\"\n   :rows  \"whenever this question has any results\"})\n\n(defn- send-email!\n  \"Sends an email on a background thread, returning a future.\"\n  [user subject template-path template-context]\n  (future\n    (try\n      (email/send-message-or-throw!\n       {:recipients   [(:email user)]\n        :message-type :html\n        :subject      subject\n        :message      (stencil/render-file template-path template-context)})\n      (catch Exception e\n        (log/errorf e \"Failed to send message to '%s' with subject '%s'\" (:email user) subject)))))\n\n(defn- template-path [template-name]\n  (str \"metabase/email/\" template-name \".mustache\"))\n\n;; Paths to the templates for all of the alerts emails\n(def ^:private new-alert-template          (template-path \"alert_new_confirmation\"))\n(def ^:private you-unsubscribed-template   (template-path \"alert_unsubscribed\"))\n(def ^:private admin-unsubscribed-template (template-path \"alert_admin_unsubscribed_you\"))\n(def ^:private added-template              (template-path \"alert_you_were_added\"))\n(def ^:private stopped-template            (template-path \"alert_stopped_working\"))\n\n(defn send-new-alert-email!\n  \"Send out the initial 'new alert' email to the `creator` of the alert\"\n  [{:keys [creator] :as alert}]\n  (send-email! creator \"You set up an alert\" new-alert-template\n               (common-alert-context alert alert-condition-text)))\n\n(defn send-you-unsubscribed-alert-email!\n  \"Send an email to `who-unsubscribed` letting them know they've unsubscribed themselves from `alert`\"\n  [alert who-unsubscribed]\n  (send-email! who-unsubscribed \"You unsubscribed from an alert\" you-unsubscribed-template\n               (common-alert-context alert)))\n\n(defn send-admin-unsubscribed-alert-email!\n  \"Send an email to `user-added` letting them know `admin` has unsubscribed them from `alert`\"\n  [alert user-added {:keys [first_name last_name] :as _admin}]\n  (let [admin-name (format \"%s %s\" first_name last_name)]\n    (send-email! user-added \"You\u2019ve been unsubscribed from an alert\" admin-unsubscribed-template\n                 (assoc (common-alert-context alert) :adminName admin-name))))\n\n(defn send-you-were-added-alert-email!\n  \"Send an email to `user-added` letting them know `admin-adder` has added them to `alert`\"\n  [alert user-added {:keys [first_name last_name] :as _admin-adder}]\n  (let [subject (format \"%s %s added you to an alert\" first_name last_name)]\n    (send-email! user-added subject added-template (common-alert-context alert alert-condition-text))))\n\n(def ^:private not-working-subject \"One of your alerts has stopped working\")\n\n(defn send-alert-stopped-because-archived-email!\n  \"Email to notify users when a card associated to their alert has been archived\"\n  [alert user {:keys [first_name last_name] :as _archiver}]\n  (let [deletion-text (format \"the question was archived by %s %s\" first_name last_name)]\n    (send-email! user not-working-subject stopped-template (assoc (common-alert-context alert) :deletionCause deletion-text))))\n\n(defn send-alert-stopped-because-changed-email!\n  \"Email to notify users when a card associated to their alert changed in a way that invalidates their alert\"\n  [alert user {:keys [first_name last_name] :as _archiver}]\n  (let [edited-text (format \"the question was edited by %s %s\" first_name last_name)]\n    (send-email! user not-working-subject stopped-template (assoc (common-alert-context alert) :deletionCause edited-text))))\n\n(defn send-slack-token-error-emails!\n  \"Email all admins when a Slack API call fails due to a revoked token or other auth error\"\n  []\n  (email/send-message!\n   :subject (trs \"Your Slack connection stopped working\")\n   :recipients (all-admin-recipients)\n   :message-type :html\n   :message (stencil/render-file \"metabase/email/slack_token_error.mustache\"\n                                 (merge (common-context)\n                                        {:logoHeader  true\n                                         :settingsUrl (str (public-settings/site-url) \"/admin/settings/slack\")}))))\n", "{{> metabase/email/_header }}\n  <div>\n    {{#sso}}\n      <p>You're using Google to log in to {{applicationName}}, so you don't have a password. You can log in to {{applicationName}} by clicking \"Sign in with Google\"</p>\n      <a href=\"{{siteUrl}}\">Go to {{applicationName}}</a>\n    {{/sso}}\n    {{^sso}}\n      {{#isActive}}\n        <div style=\"text-align: center\">\n          <p>Click the button below to reset the password for your {{applicationName}} account at {{siteUrl}}.</p>\n          <a style=\"display: inline-block; box-sizing: border-box; font-size: 18px; padding: 8px 22px; cursor: pointer; text-decoration: none; border-radius: 4px; background-color: #4990E2; border-color: #4990E2; color: #fff;\" href=\"{{passwordResetUrl}}\">Reset password</a>\n          <p style=\"padding-top: 2em; font-size: small;\">Didn't request this password reset? It's safe to ignore it.</p>\n        </div>\n      {{/isActive}}\n      {{^isActive}}\n        <p>Someone requested a password reset for your {{applicationName}} account at {{siteUrl}}, but your account\n        has been deactivated. Contact an administrator for further assistance.</p>\n        {{#adminEmailSet}}\n          <a href=\"mailto:{{adminEmail}}\">Contact your administrator</a>\n        {{/adminEmailSet}}\n      {{/isActive}}\n    {{/sso}}\n  </div>\n{{> metabase/email/_footer }}\n", "(ns metabase.email.messages-test\n  (:require [clojure.string :as str]\n            [clojure.test :refer :all]\n            [metabase.email-test :as et]\n            [metabase.email.messages :as messages]\n            [metabase.test.util :as tu])\n  (:import java.io.IOException))\n\n(deftest new-user-email\n  (is (= [{:from    \"notifications@metabase.com\",\n           :to      [\"test@test.com\"],\n           :subject \"You're invited to join Metabase Test's Metabase\",\n           :body    [{:type \"text/html; charset=utf-8\"}]}]\n         (tu/with-temporary-setting-values [site-name \"Metabase Test\"]\n           (et/with-fake-inbox\n             (messages/send-new-user-email! {:first_name \"test\" :email \"test@test.com\"}\n                                            {:first_name \"invitor\" :email \"invited_by@test.com\"}\n                                            \"http://localhost/some/url\"\n                                            false)\n             (-> (@et/inbox \"test@test.com\")\n                 (update-in [0 :body 0] dissoc :content)))))))\n\n(deftest password-reset-email\n  (testing \"password reset email can be sent successfully\"\n    (et/with-fake-inbox\n      (messages/send-password-reset-email! \"test@test.com\" false \"http://localhost/some/url\" true)\n      (is (= [{:from    \"notifications@metabase.com\",\n               :to      [\"test@test.com\"],\n               :subject \"[Metabase] Password Reset Request\",\n               :body    [{:type \"text/html; charset=utf-8\"}]}]\n             (-> (@et/inbox \"test@test.com\")\n                 (update-in [0 :body 0] dissoc :content))))))\n  ;; Email contents contain randomized elements, so we only check for the inclusion of a single word to verify\n  ;; that the contents changed in the tests below.\n  (testing \"password reset email tells user if they should log in with Google Sign-In\"\n    (et/with-fake-inbox\n      (messages/send-password-reset-email! \"test@test.com\" true  \"http://localhost/some/url\" true)\n      (is (-> (@et/inbox \"test@test.com\")\n              (get-in [0 :body 0 :content])\n              (str/includes? \"Google\")))))\n  (testing \"password reset email tells user if their account is inactive\"\n    (et/with-fake-inbox\n      (messages/send-password-reset-email! \"test@test.com\" false \"http://localhost/some/url\" false)\n      (is (-> (@et/inbox \"test@test.com\")\n              (get-in [0 :body 0 :content])\n              (str/includes? \"deactivated\"))))))\n\n(defmacro ^:private with-create-temp-failure [& body]\n  `(with-redefs [messages/create-temp-file (fn [~'_]\n                                             (throw (IOException. \"Failed to write file\")))]\n     ~@body))\n\n;; Test that IOException bubbles up\n(deftest throws-exception\n  (is (thrown-with-msg?\n        IOException\n        (re-pattern (format \"Unable to create temp file in `%s`\" (System/getProperty \"java.io.tmpdir\")))\n        (with-create-temp-failure\n          (#'messages/create-temp-file-or-throw \"txt\")))))\n\n(deftest alert-schedule-text-test\n  (testing \"Alert schedules can be described as English strings, with the timezone included\"\n    (tu/with-temporary-setting-values [report-timezone \"America/Pacific\"]\n      (is (= \"Run hourly\"\n             (@#'messages/alert-schedule-text {:schedule_type :hourly})))\n      (is (= \"Run daily at 12 AM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 0})))\n      (is (= \"Run daily at 5 AM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 5})))\n      (is (= \"Run daily at 6 PM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 18})))\n      (is (= \"Run weekly on Monday at 8 AM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :weekly\n                                               :schedule_day  \"mon\"\n                                               :schedule_hour 8})))))\n  (testing \"If report-timezone is not set, falls back to UTC\"\n    (tu/with-temporary-setting-values [report-timezone nil]\n      (is (= \"Run daily at 12 AM UTC\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 0}))))))\n\n(deftest render-pulse-email-test\n  (testing \"Email with few rows and columns can be rendered when tracing (#21166)\"\n    (tu/with-log-level [metabase.email :trace]\n      (let [result {:card   {:name \"card-name\"\n                             :visualization_settings\n                             {:table.column_formatting []}}\n                    :result {:data {:cols [{:name \"x\"} {:name \"y\"}]\n                                    :rows [[0 0]\n                                           [1 1]]}}}\n            emails (messages/render-pulse-email \"America/Pacific\" {} {} [result])]\n        (is (vector? emails))\n        (is (map? (first emails)))))))\n", "(ns metabase.email-test\n  \"Various helper functions for testing email functionality.\"\n  (:require [clojure.java.io :as io]\n            [clojure.test :refer :all]\n            [medley.core :as m]\n            [metabase.email :as email]\n            [metabase.test.data.users :as test.users]\n            [metabase.test.util :as tu]\n            [metabase.util :refer [prog1]]\n            [postal.message :as message])\n  (:import java.io.File\n           javax.activation.MimeType))\n\n;; TODO - this should be made dynamic so it's (at least theoretically) possible to use this in parallel\n(def inbox\n  \"Map of email addresses -> sequence of messages they've received.\"\n  (atom {}))\n\n(defn reset-inbox!\n  \"Clear all messages from `inbox`.\"\n  []\n  (reset! inbox {}))\n\n(defn fake-inbox-email-fn\n  \"A function that can be used in place of `send-email!`.\n   Put all messages into `inbox` instead of actually sending them.\"\n  [_ email]\n  (doseq [recipient (:to email)]\n    (swap! inbox assoc recipient (-> (get @inbox recipient [])\n                                     (conj email)))))\n\n(defn do-with-expected-messages\n  \"Invokes `thunk`, blocking until `n` messages are found in the inbox.\"\n  [n thunk]\n  {:pre [(number? n)]}\n  (let [p (promise)]\n    ;; Watches get invoked on the callers thread. In our case, this will be the future (or background thread) that is\n    ;; sending the message. It will block that thread, counting the number of messages. If it has reached it's goal,\n    ;; it will deliver the promise\n    (add-watch inbox ::inbox-watcher\n               (fn [_ _ _ new-value]\n                 (let [num-msgs (count (apply concat (vals new-value)))]\n                   (when (<= n num-msgs)\n                     (deliver p num-msgs)))))\n    (try\n      (let [result        (thunk)\n            ;; This will block the calling thread (i.e. the test) waiting for the promise to be delivered. There is a\n            ;; very high timeout (30 seconds) that we should never reach, but without it, if we do hit that scenario, it\n            ;; should at least not hang forever in CI\n            promise-value (deref p 30000 ::timeout)]\n        (if (= promise-value ::timeout)\n          (throw (Exception. \"Timed out while waiting for messages in the inbox\"))\n          result))\n      (finally\n        (remove-watch inbox ::inbox-watcher)))))\n\n(defmacro with-expected-messages\n  \"Invokes `body`, waiting until `n` messages are found in the inbox before returning. This is useful if the code you\n  are testing sends emails via a future or background thread. Using this will block the test, waiting for the messages\n  to arrive before continuing.\"\n  [n & body]\n  `(do-with-expected-messages ~n (fn [] ~@body)))\n\n(defn do-with-fake-inbox\n  \"Impl for `with-fake-inbox` macro; prefer using that rather than calling this directly.\"\n  [f]\n  (with-redefs [email/send-email! fake-inbox-email-fn]\n    (reset-inbox!)\n    (tu/with-temporary-setting-values [email-smtp-host \"fake_smtp_host\"\n                                       email-smtp-port 587]\n      (f))))\n\n(defmacro with-fake-inbox\n  \"Clear `inbox`, bind `send-email!` to `fake-inbox-email-fn`, set temporary settings for `email-smtp-username`\n   and `email-smtp-password` (which will cause `metabase.email/email-configured?` to return `true`, and execute `body`.\n\n   Fetch the emails send by dereffing `inbox`.\n\n     (with-fake-inbox\n       (send-some-emails!)\n       @inbox)\"\n  [& body]\n  {:style/indent 0}\n  `(do-with-fake-inbox (fn [] ~@body)))\n\n(defn- create-email-body->regex-fn\n  \"Returns a function expecting the email body structure. It will apply the regexes in `regex-seq` over the body and\n  return map of the stringified regex as the key and a boolean as the value. True if it returns results via `re-find`\n  false otherwise.\"\n  [regex-seq]\n  (fn [message-body]\n    (let [{:keys [content]} message-body]\n      (zipmap (map str regex-seq)\n              (map #(boolean (re-find % content)) regex-seq)))))\n\n(defn- regex-email-bodies*\n  [regexes emails]\n  (let [email-body->regex-boolean (create-email-body->regex-fn regexes)]\n    (->> emails\n         (m/map-vals (fn [emails-for-recipient]\n                       (for [{:keys [body] :as email} emails-for-recipient\n                             :let [matches (-> body first email-body->regex-boolean)]\n                             :when (some true? (vals matches))]\n                         (-> email\n                             (update :to set)\n                             (assoc :body matches)))))\n         (m/filter-vals seq))))\n\n(defn regex-email-bodies\n  \"Return messages in the fake inbox whose body matches the regex(es). The body will be replaced by a map with the\n  stringified regex as it's key and a boolean indicated that the regex returned results.\"\n  [& regexes]\n  (regex-email-bodies* regexes @inbox))\n\n(defn received-email-subject?\n  \"Indicate whether a user received an email whose subject matches the `regex`. First argument should be a keyword\n  like :rasta, or an email address string.\"\n  [user-or-email regex]\n  (let [address (if (string? user-or-email) user-or-email (:username (test.users/user->credentials user-or-email)))\n        emails  (get @inbox address)]\n    (boolean (some #(re-find regex %) (map :subject emails)))))\n\n(defn received-email-body?\n  \"Indicate whether a user received an email whose body matches the `regex`. First argument should be a keyword\n  like :rasta, or an email address string.\"\n  [user-or-email regex]\n  (let [address (if (string? user-or-email) user-or-email (:username (test.users/user->credentials user-or-email)))\n        emails  (get @inbox address)]\n    (boolean (some #(re-find regex %) (map (comp :content first :body) emails)))))\n\n(deftest regex-email-bodies-test\n  (letfn [(email [body] {:to #{\"mail\"}\n                         :body [{:content body}]})\n          (clean [emails] (m/map-vals #(map :body %) emails))]\n    (testing \"marks emails with regex match\"\n      (let [emails {\"bob@metabase.com\" [(email \"foo bar baz\")\n                                        (email \"other keyword\")]\n                    \"sue@metabase.com\" [(email \"foo bar baz\")]}]\n        (is (= {\"bob@metabase.com\" [{\"foo\" true \"keyword\" false} {\"foo\" false \"keyword\" true}]\n                \"sue@metabase.com\" [{\"foo\" true \"keyword\" false}]}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"] emails))))))\n    (testing \"Returns only emails with at least one match\"\n      ;; drops the email that isn't matched by any regex\n      (testing \"Drops the email that doesn't match\"\n        (is (= {\"bob@metabase.com\" [{\"foo\" true \"keyword\" false}]}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"]\n                                           {\"bob@metabase.com\" [(email \"foo\")\n                                                                (email \"no-match\")]})))))\n      (testing \"Drops the entry for the other person with no matching emails\"\n        (is (= {\"bob@metabase.com\" [{\"foo\" true \"keyword\" false}]}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"]\n                                           {\"bob@metabase.com\" [(email \"foo\")\n                                                                (email \"no-match\")]\n                                            \"sue@metabase.com\" [(email \"no-match\")]}))))\n        (is (= {}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"]\n                                           {\"bob@metabase.com\" [(email \"no-match\")\n                                                                (email \"no-match\")]\n                                            \"sue@metabase.com\" [(email \"no-match\")]}))))))))\n\n(defn- mime-type [mime-type-str]\n  (-> mime-type-str\n      MimeType.\n      .getBaseType))\n\n(defn- summarize-attachment [email-attachment]\n  (-> email-attachment\n      (update :content-type mime-type)\n      (update :content class)\n      (update :content-id boolean)))\n\n(defn summarize-multipart-email\n  \"For text/html portions of an email, this is similar to `regex-email-bodies`, but for images in the attachments will\n  summarize the contents for comparison in expects\"\n  [& regexes]\n  (let [email-body->regex-boolean (create-email-body->regex-fn regexes)]\n    (m/map-vals (fn [emails-for-recipient]\n                  (for [email emails-for-recipient]\n                    (-> email\n                        (update :to set)\n                        (update :body (fn [email-body-seq]\n                                        (doall\n                                         (for [{email-type :type :as email-part} email-body-seq]\n                                           (if (string? email-type)\n                                             (email-body->regex-boolean email-part)\n                                             (summarize-attachment email-part)))))))))\n                @inbox)))\n\n(defn email-to\n  \"Creates a default email map for `user-kwd` via `test.users/fetch-user`, as would be returned by `with-fake-inbox`\"\n  [user-kwd & [email-map]]\n  (let [{:keys [email]} (test.users/fetch-user user-kwd)]\n    {email [(merge {:from (email/email-from-address)\n                    :to #{email}}\n                   email-map)]}))\n\n(defn temp-csv\n  [file-basename content]\n  (prog1 (File/createTempFile file-basename \".csv\")\n    (with-open [file (io/writer <>)]\n      (.write ^java.io.Writer file ^String content))))\n\n(defn mock-send-email!\n  \"To stub out email sending, instead returning the would-be email contents as a string\"\n  [_smtp-credentials email-details]\n  (-> email-details\n      message/make-jmessage\n      message/message->str))\n\n(deftest send-message!-test\n  (tu/with-temporary-setting-values [email-from-address \"lucky@metabase.com\"\n                                     email-from-name    \"Lucky\"\n                                     email-smtp-host    \"smtp.metabase.com\"\n                                     email-smtp-username \"lucky\"\n                                     email-smtp-password \"d1nner3scapee!\"\n                                     email-smtp-port     1025\n                                     email-reply-to      [\"reply-to-me@metabase.com\" \"reply-to-me-too@metabase.com\"]\n                                     email-smtp-security :none]\n    (testing \"basic sending\"\n      (is (=\n           [{:from     (str (email/email-from-name) \" <\" (email/email-from-address) \">\")\n             :to       [\"test@test.com\"]\n             :subject  \"101 Reasons to use Metabase\"\n             :reply-to (email/email-reply-to)\n             :body     [{:type    \"text/html; charset=utf-8\"\n                         :content \"101. Metabase will make you a better person\"}]}]\n           (with-fake-inbox\n             (email/send-message!\n              :subject      \"101 Reasons to use Metabase\"\n              :recipients   [\"test@test.com\"]\n              :message-type :html\n              :message      \"101. Metabase will make you a better person\")\n             (@inbox \"test@test.com\")))))\n    (testing \"basic sending without email-from-name\"\n      (tu/with-temporary-setting-values [email-from-name nil]\n        (is (=\n             [{:from     (email/email-from-address)\n               :to       [\"test@test.com\"]\n               :subject  \"101 Reasons to use Metabase\"\n               :reply-to (email/email-reply-to)\n               :body     [{:type    \"text/html; charset=utf-8\"\n                           :content \"101. Metabase will make you a better person\"}]}]\n             (with-fake-inbox\n               (email/send-message!\n                :subject      \"101 Reasons to use Metabase\"\n                :recipients   [\"test@test.com\"]\n                :message-type :html\n                :message      \"101. Metabase will make you a better person\")\n               (@inbox \"test@test.com\"))))))\n    (testing \"with an attachment\"\n      (let [recipient    \"csv_user@example.com\"\n            csv-contents \"hugs_with_metabase,hugs_without_metabase\\n1,0\"\n            csv-file     (temp-csv \"metabase-reasons\" csv-contents)\n            params       {:subject      \"101 Reasons to use Metabase\"\n                          :recipients   [recipient]\n                          :message-type :attachments\n                          :message      [{:type    \"text/html; charset=utf-8\"\n                                          :content \"100. Metabase will hug you when you're sad\"}\n                                         {:type         :attachment\n                                          :content-type \"text/csv\"\n                                          :file-name    \"metabase-reasons.csv\"\n                                          :content      csv-file\n                                          :description  \"very scientific data\"}]}]\n        (testing \"it sends successfully\"\n          (is (=\n               [{:from     (str (email/email-from-name) \" <\" (email/email-from-address) \">\")\n                 :to       [recipient]\n                 :subject  \"101 Reasons to use Metabase\"\n                 :reply-to (email/email-reply-to)\n                 :body     [{:type    \"text/html; charset=utf-8\"\n                             :content \"100. Metabase will hug you when you're sad\"}\n                            {:type         :attachment\n                             :content-type \"text/csv\"\n                             :file-name    \"metabase-reasons.csv\"\n                             :content      csv-file\n                             :description  \"very scientific data\"}]}]\n               (with-fake-inbox\n                 (m/mapply email/send-message! params)\n                 (@inbox recipient)))))\n        (testing \"it does not wrap long, non-ASCII filenames\"\n          (with-redefs [email/send-email! mock-send-email!]\n            (let [basename                     \"this-is-quite-long-and-has-non-\u00c2\u017f\u00e7\u00ef\u0131-characters\"\n                  csv-file                     (temp-csv basename csv-contents)\n                  params-with-problematic-file (-> params\n                                                   (assoc-in [:message 1 :file-name] (str basename \".csv\"))\n                                                   (assoc-in [:message 1 :content] csv-file))]\n              ;; Bad string (ignore the linebreak):\n              ;; Content-Disposition: attachment; filename=\"=?UTF-8?Q?this-is-quite-long-and-ha?= =?UTF-8?Q?s-non-\n              ;; =C3=82\\\"; filename*1=\\\"=C5=BF=C3=A7=C3=AF=C4=B1-characters.csv?=\"\n              ;;           ^-- this is the problem\n              ;; Acceptable string (again, ignore the linebreak):\n              ;; Content-Disposition: attachment; filename= \"=?UTF-8?Q?this-is-quite-long-and-ha?=\n              ;; =?UTF-8?Q?s-non-=C3=82=C5=BF=C3=A7=C3=AF=C4=B1-characters.csv?=\"\n\n              (is (re-find\n                   #\"(?s)Content-Disposition: attachment.+filename=.+this-is-quite-[\\-\\s?=0-9a-zA-Z]+-characters.csv\"\n                   (m/mapply email/send-message! params-with-problematic-file))))))))))\n"], "fixing_code": ["(ns metabase.api.session\n  \"/api/session endpoints\"\n  (:require [clojure.tools.logging :as log]\n            [compojure.core :refer [DELETE GET POST]]\n            [java-time :as t]\n            [metabase.analytics.snowplow :as snowplow]\n            [metabase.api.common :as api]\n            [metabase.config :as config]\n            [metabase.email.messages :as messages]\n            [metabase.events :as events]\n            [metabase.integrations.google :as google]\n            [metabase.integrations.ldap :as ldap]\n            [metabase.models.login-history :refer [LoginHistory]]\n            [metabase.models.session :refer [Session]]\n            [metabase.models.setting :as setting]\n            [metabase.models.user :as user :refer [User]]\n            [metabase.public-settings :as public-settings]\n            [metabase.server.middleware.session :as mw.session]\n            [metabase.server.request.util :as request.u]\n            [metabase.util :as u]\n            [metabase.util.i18n :refer [deferred-tru trs tru]]\n            [metabase.util.password :as u.password]\n            [metabase.util.schema :as su]\n            [schema.core :as s]\n            [throttle.core :as throttle]\n            [toucan.db :as db]\n            [toucan.models :as models])\n  (:import com.unboundid.util.LDAPSDKException\n           java.util.UUID))\n\n(s/defn ^:private record-login-history!\n  [session-id :- UUID user-id :- su/IntGreaterThanZero device-info :- request.u/DeviceInfo]\n  (db/insert! LoginHistory (merge {:user_id    user-id\n                                   :session_id (str session-id)}\n                                  device-info)))\n\n(defmulti create-session!\n  \"Generate a new Session for a User. `session-type` is the currently either `:password` (for email + password login) or\n  `:sso` (for other login types). Returns the newly generated Session.\"\n  {:arglists '(^java.util.UUID [session-type user device-info])}\n  (fn [session-type & _]\n    session-type))\n\n(def ^:private CreateSessionUserInfo\n  {:id         su/IntGreaterThanZero\n   :last_login s/Any\n   s/Keyword   s/Any})\n\n(s/defmethod create-session! :sso :- {:id UUID, :type (s/enum :normal :full-app-embed) s/Keyword s/Any}\n  [_ user :- CreateSessionUserInfo device-info :- request.u/DeviceInfo]\n  (let [session-uuid (UUID/randomUUID)\n        session      (or\n                      (db/insert! Session\n                        :id      (str session-uuid)\n                        :user_id (u/the-id user))\n                      ;; HACK !!! For some reason `db/insert` doesn't seem to be working correctly for Session.\n                      (models/post-insert (Session (str session-uuid))))]\n    (assert (map? session))\n    (events/publish-event! :user-login\n      {:user_id (u/the-id user), :session_id (str session-uuid), :first_login (nil? (:last_login user))})\n    (record-login-history! session-uuid (u/the-id user) device-info)\n    (when-not (:last_login user)\n      (snowplow/track-event! ::snowplow/new-user-created (u/the-id user)))\n    (assoc session :id session-uuid)))\n\n(s/defmethod create-session! :password :- {:id UUID, :type (s/enum :normal :full-app-embed), s/Keyword s/Any}\n  [session-type user :- CreateSessionUserInfo device-info :- request.u/DeviceInfo]\n  ;; this is actually the same as `create-session!` for `:sso` but we check whether password login is enabled.\n  (when-not (public-settings/enable-password-login)\n    (throw (ex-info (str (tru \"Password login is disabled for this instance.\")) {:status-code 400})))\n  ((get-method create-session! :sso) session-type user device-info))\n\n\n;;; ## API Endpoints\n\n(def ^:private login-throttlers\n  {:username   (throttle/make-throttler :username)\n   ;; IP Address doesn't have an actual UI field so just show error by username\n   :ip-address (throttle/make-throttler :username, :attempts-threshold 50)})\n\n(def ^:private password-fail-message (deferred-tru \"Password did not match stored password.\"))\n(def ^:private password-fail-snippet (deferred-tru \"did not match stored password\"))\n\n(def ^:private disabled-account-message (deferred-tru \"Your account is disabled. Please contact your administrator.\"))\n(def ^:private disabled-account-snippet (deferred-tru \"Your account is disabled.\"))\n\n;; Fake salt & hash used to run bcrypt hash if user doesn't exist, to avoid timing attacks (Metaboat #134)\n(def ^:private fake-salt \"ee169694-5eb6-4010-a145-3557252d7807\")\n(def ^:private fake-hashed-password \"$2a$10$owKjTym0ZGEEZOpxM0UyjekSvt66y1VvmOJddkAaMB37e0VAIVOX2\")\n\n(s/defn ^:private ldap-login :- (s/maybe {:id UUID, s/Keyword s/Any})\n  \"If LDAP is enabled and a matching user exists return a new Session for them, or `nil` if they couldn't be\n  authenticated.\"\n  [username password device-info :- request.u/DeviceInfo]\n  (when (ldap/ldap-configured?)\n    (try\n      (when-let [user-info (ldap/find-user username)]\n        (when-not (ldap/verify-password user-info password)\n          ;; Since LDAP knows about the user, fail here to prevent the local strategy to be tried with a possibly\n          ;; outdated password\n          (throw (ex-info (str password-fail-message)\n                          {:status-code 401\n                           :errors      {:password password-fail-snippet}})))\n        ;; password is ok, return new session if user is not deactivated\n        (let [user (ldap/fetch-or-create-user! user-info)]\n          (if (:is_active user)\n            (create-session! :sso user device-info)\n            (throw (ex-info (str disabled-account-message)\n                            {:status-code 401\n                             :errors      {:_error disabled-account-snippet}})))))\n      (catch LDAPSDKException e\n        (log/error e (trs \"Problem connecting to LDAP server, will fall back to local authentication\"))))))\n\n(s/defn ^:private email-login :- (s/maybe {:id UUID, s/Keyword s/Any})\n  \"Find a matching `User` if one exists and return a new Session for them, or `nil` if they couldn't be authenticated.\"\n  [username password device-info :- request.u/DeviceInfo]\n  (if-let [user (db/select-one [User :id :password_salt :password :last_login :is_active], :%lower.email (u/lower-case-en username))]\n    (when (u.password/verify-password password (:password_salt user) (:password user))\n      (if (:is_active user)\n        (create-session! :password user device-info)\n        (throw (ex-info (str disabled-account-message)\n                        {:status-code 401\n                         :errors      {:_error disabled-account-snippet}}))))\n    (do\n      ;; User doesn't exist; run bcrypt hash anyway to avoid leaking account existence in request timing\n      (u.password/verify-password password fake-salt fake-hashed-password)\n      nil)))\n\n(def ^:private throttling-disabled? (config/config-bool :mb-disable-session-throttle))\n\n(defn- throttle-check\n  \"Pass through to `throttle/check` but will not check if `throttling-disabled?` is true\"\n  [throttler throttle-key]\n  (when-not throttling-disabled?\n    (throttle/check throttler throttle-key)))\n\n(s/defn ^:private login :- {:id UUID, :type (s/enum :normal :full-app-embed), s/Keyword s/Any}\n  \"Attempt to login with different avaialable methods with `username` and `password`, returning new Session ID or\n  throwing an Exception if login could not be completed.\"\n  [username :- su/NonBlankString password :- su/NonBlankString device-info :- request.u/DeviceInfo]\n  ;; Primitive \"strategy implementation\", should be reworked for modular providers in #3210\n  (or (ldap-login username password device-info)  ; First try LDAP if it's enabled\n      (email-login username password device-info) ; Then try local authentication\n      ;; If nothing succeeded complain about it\n      ;; Don't leak whether the account doesn't exist or the password was incorrect\n      (throw\n       (ex-info (str password-fail-message)\n                {:status-code 401\n                 :errors      {:password password-fail-snippet}}))))\n\n(defn- do-http-401-on-error [f]\n  (try\n    (f)\n    (catch clojure.lang.ExceptionInfo e\n      (throw (ex-info (ex-message e)\n                      (assoc (ex-data e) :status-code 401))))))\n\n(defmacro http-401-on-error\n  \"Add `{:status-code 401}` to exception data thrown by `body`.\"\n  [& body]\n  `(do-http-401-on-error (fn [] ~@body)))\n\n(api/defendpoint POST \"/\"\n  \"Login.\"\n  [:as {{:keys [username password]} :body, :as request}]\n  {username su/NonBlankString\n   password su/NonBlankString}\n  (let [ip-address   (request.u/ip-address request)\n        request-time (t/zoned-date-time (t/zone-id \"GMT\"))\n        do-login     (fn []\n                       (let [{session-uuid :id, :as session} (login username password (request.u/device-info request))\n                             response                        {:id (str session-uuid)}]\n                         (mw.session/set-session-cookies request response session request-time)))]\n    (if throttling-disabled?\n      (do-login)\n      (http-401-on-error\n       (throttle/with-throttling [(login-throttlers :ip-address) ip-address\n                                  (login-throttlers :username)   username]\n           (do-login))))))\n\n(api/defendpoint DELETE \"/\"\n  \"Logout.\"\n  [:as {:keys [metabase-session-id]}]\n  (api/check-exists? Session metabase-session-id)\n  (db/delete! Session :id metabase-session-id)\n  (mw.session/clear-session-cookie api/generic-204-no-content))\n\n;; Reset tokens: We need some way to match a plaintext token with the a user since the token stored in the DB is\n;; hashed. So we'll make the plaintext token in the format USER-ID_RANDOM-UUID, e.g.\n;; \"100_8a266560-e3a8-4dc1-9cd1-b4471dcd56d7\", before hashing it. \"Leaking\" the ID this way is ok because the\n;; plaintext token is only sent in the password reset email to the user in question.\n;;\n;; There's also no need to salt the token because it's already random <3\n\n(def ^:private forgot-password-throttlers\n  {:email      (throttle/make-throttler :email)\n   :ip-address (throttle/make-throttler :email, :attempts-threshold 50)})\n\n(defn- forgot-password-impl\n  [email]\n  (future\n    (when-let [{user-id      :id\n                google-auth? :google_auth\n                ldap-auth?   :ldap_auth\n                sso-source   :sso_source\n                is-active?   :is_active}\n               (db/select-one [User :id :google_auth :ldap_auth :sso_source :is_active]\n                              :%lower.email\n                              (u/lower-case-en email))]\n      (if (or google-auth? ldap-auth? sso-source)\n        ;; If user uses any SSO method to log in, no need to generate a reset token\n        (messages/send-password-reset-email! email google-auth? (boolean (or ldap-auth? sso-source)) nil is-active?)\n        (let [reset-token        (user/set-password-reset-token! user-id)\n              password-reset-url (str (public-settings/site-url) \"/auth/reset_password/\" reset-token)]\n          (log/info password-reset-url)\n          (messages/send-password-reset-email! email false false password-reset-url is-active?))))))\n\n(api/defendpoint POST \"/forgot_password\"\n  \"Send a reset email when user has forgotten their password.\"\n  [:as {{:keys [email]} :body, :as request}]\n  {email su/Email}\n  ;; Don't leak whether the account doesn't exist, just pretend everything is ok\n  (let [request-source (request.u/ip-address request)]\n    (throttle-check (forgot-password-throttlers :ip-address) request-source))\n  (throttle-check (forgot-password-throttlers :email) email)\n  (forgot-password-impl email)\n  api/generic-204-no-content)\n\n(def ^:private ^:const reset-token-ttl-ms\n  \"Number of milliseconds a password reset is considered valid.\"\n  (* 48 60 60 1000)) ; token considered valid for 48 hours\n\n(defn- valid-reset-token->user\n  \"Check if a password reset token is valid. If so, return the `User` ID it corresponds to.\"\n  [^String token]\n  (when-let [[_ user-id] (re-matches #\"(^\\d+)_.+$\" token)]\n    (let [user-id (Integer/parseInt user-id)]\n      (when-let [{:keys [reset_token reset_triggered], :as user} (db/select-one [User :id :last_login :reset_triggered\n                                                                                 :reset_token]\n                                                                   :id user-id, :is_active true)]\n        ;; Make sure the plaintext token matches up with the hashed one for this user\n        (when (u/ignore-exceptions\n                (u.password/bcrypt-verify token reset_token))\n          ;; check that the reset was triggered within the last 48 HOURS, after that the token is considered expired\n          (let [token-age (- (System/currentTimeMillis) reset_triggered)]\n            (when (< token-age reset-token-ttl-ms)\n              user)))))))\n\n(api/defendpoint POST \"/reset_password\"\n  \"Reset password with a reset token.\"\n  [:as {{:keys [token password]} :body, :as request}]\n  {token    su/NonBlankString\n   password su/ValidPassword}\n  (or (when-let [{user-id :id, :as user} (valid-reset-token->user token)]\n        (user/set-password! user-id password)\n        ;; if this is the first time the user has logged in it means that they're just accepted their Metabase invite.\n        ;; Send all the active admins an email :D\n        (when-not (:last_login user)\n          (messages/send-user-joined-admin-notification-email! (User user-id)))\n        ;; after a successful password update go ahead and offer the client a new session that they can use\n        (let [{session-uuid :id, :as session} (create-session! :password user (request.u/device-info request))\n              response                        {:success    true\n                                               :session_id (str session-uuid)}]\n          (mw.session/set-session-cookies request response session (t/zoned-date-time (t/zone-id \"GMT\")))))\n      (api/throw-invalid-param-exception :password (tru \"Invalid reset token\"))))\n\n(api/defendpoint GET \"/password_reset_token_valid\"\n  \"Check is a password reset token is valid and isn't expired.\"\n  [token]\n  {token s/Str}\n  {:valid (boolean (valid-reset-token->user token))})\n\n(api/defendpoint GET \"/properties\"\n  \"Get all global properties and their values. These are the specific `Settings` which are meant to be public.\"\n  []\n  (merge\n   (setting/user-readable-values-map :public)\n   (when @api/*current-user*\n     (setting/user-readable-values-map :authenticated))\n   (when api/*is-superuser?*\n     (setting/user-readable-values-map :admin))))\n\n(api/defendpoint POST \"/google_auth\"\n  \"Login with Google Auth.\"\n  [:as {{:keys [token]} :body, :as request}]\n  {token su/NonBlankString}\n  (when-not (google/google-auth-client-id)\n    (throw (ex-info \"Google Auth is disabled.\" {:status-code 400})))\n  ;; Verify the token is valid with Google\n  (if throttling-disabled?\n    (google/do-google-auth request)\n    (http-401-on-error\n     (throttle/with-throttling [(login-throttlers :ip-address) (request.u/ip-address request)]\n       (let [user (google/do-google-auth request)\n             {session-uuid :id, :as session} (create-session! :sso user (request.u/device-info request))\n             response {:id (str session-uuid)}\n             user (db/select-one [User :id :is_active], :email (:email user))]\n         (if (and user (:is_active user))\n           (mw.session/set-session-cookies request\n                                           response\n                                           session\n                                           (t/zoned-date-time (t/zone-id \"GMT\")))\n           (throw (ex-info (str disabled-account-message)\n                           {:status-code 401\n                            :errors      {:account disabled-account-snippet}}))))))))\n\n(defn- +log-all-request-failures [handler]\n  (fn [request respond raise]\n    (try\n      (handler request respond raise)\n      (catch Throwable e\n        (log/error e (trs \"Authentication endpoint error\"))\n        (throw e)))))\n\n(api/define-routes +log-all-request-failures)\n", "(ns metabase.email.messages\n  \"Convenience functions for sending templated email messages.  Each function here should represent a single email.\n   NOTE: we want to keep this about email formatting, so don't put heavy logic here RE: building data for emails.\"\n  (:require [clojure.core.cache :as cache]\n            [clojure.java.io :as io]\n            [clojure.tools.logging :as log]\n            [hiccup.core :refer [html]]\n            [java-time :as t]\n            [medley.core :as m]\n            [metabase.config :as config]\n            [metabase.driver :as driver]\n            [metabase.driver.util :as driver.u]\n            [metabase.email :as email]\n            [metabase.models.collection :as collection]\n            [metabase.models.permissions :as perms]\n            [metabase.models.user :refer [User]]\n            [metabase.public-settings :as public-settings]\n            [metabase.public-settings.premium-features :as premium-features]\n            [metabase.pulse.markdown :as markdown]\n            [metabase.pulse.parameters :as params]\n            [metabase.pulse.render :as render]\n            [metabase.pulse.render.body :as body]\n            [metabase.pulse.render.image-bundle :as image-bundle]\n            [metabase.pulse.render.js-svg :as js-svg]\n            [metabase.pulse.render.style :as style]\n            [metabase.query-processor.store :as qp.store]\n            [metabase.query-processor.streaming :as qp.streaming]\n            [metabase.query-processor.streaming.interface :as qp.si]\n            [metabase.query-processor.streaming.xlsx :as qp.xlsx]\n            [metabase.query-processor.timezone :as qp.timezone]\n            [metabase.util :as u]\n            [metabase.util.date-2 :as u.date]\n            [metabase.util.i18n :as i18n :refer [deferred-trs trs tru]]\n            [metabase.util.urls :as urls]\n            [stencil.core :as stencil]\n            [stencil.loader :as stencil-loader]\n            [toucan.db :as db])\n  (:import [java.io File IOException OutputStream]\n           java.time.format.DateTimeFormatter\n           java.time.LocalTime))\n\n(defn- app-name-trs\n  \"Return the user configured application name, or Metabase translated\n  via tru if a name isn't configured.\"\n  []\n  (or (public-settings/application-name)\n      (trs \"Metabase\")))\n\n;; Dev only -- disable template caching\n(when config/is-dev?\n  (alter-meta! #'stencil.core/render-file assoc :style/indent 1)\n  (stencil-loader/set-cache (cache/ttl-cache-factory {} :ttl 0)))\n\n(defn- logo-url []\n  (let [url (public-settings/application-logo-url)]\n    (cond\n      (= url \"app/assets/img/logo.svg\") \"http://static.metabase.com/email_logo.png\"\n\n      :else nil)))\n      ;; NOTE: disabling whitelabeled URLs for now since some email clients don't render them correctly\n      ;; We need to extract them and embed as attachments like we do in metabase.pulse.render.image-bundle\n      ;; (data-uri-svg? url)               (themed-image-url url color)\n      ;; :else                             url\n\n(defn- icon-bundle\n  [icon-name]\n  (let [color     (style/primary-color)\n        png-bytes (js-svg/icon icon-name color)]\n    (-> (image-bundle/make-image-bundle :attachment png-bytes)\n        (image-bundle/image-bundle->attachment))))\n\n(defn- button-style [color]\n  (str \"display: inline-block; \"\n       \"box-sizing: border-box; \"\n       \"padding: 0.5rem 1.375rem; \"\n       \"font-size: 1.063rem; \"\n       \"font-weight: bold; \"\n       \"text-decoration: none; \"\n       \"cursor: pointer; \"\n       \"color: #fff; \"\n       \"border: 1px solid \" color \"; \"\n       \"background-color: \" color \"; \"\n       \"border-radius: 4px;\"))\n\n;;; Various Context Helper Fns. Used to build Stencil template context\n\n(defn- common-context\n  \"Context that is used across multiple email templates, and that is the same for all emails\"\n  []\n  {:applicationName           (public-settings/application-name)\n   :applicationColor          (style/primary-color)\n   :applicationLogoUrl        (logo-url)\n   :buttonStyle               (button-style (style/primary-color))\n   :colorTextLight            style/color-text-light\n   :colorTextMedium           style/color-text-medium\n   :colorTextDark             style/color-text-dark\n   :notificationManagementUrl (urls/notification-management-url)\n   :siteUrl                   (public-settings/site-url)})\n\n(def ^:private notification-context\n  {:emailType  \"notification\"\n   :logoHeader true})\n\n(defn- abandonment-context []\n  {:heading      (trs \"We\u2019d love your feedback.\")\n   :callToAction (str (deferred-trs \"It looks like Metabase wasn\u2019t quite a match for you.\")\n                      \" \"\n                      (deferred-trs \"Would you mind taking a fast 5 question survey to help the Metabase team understand why and make things better in the future?\"))\n   :link         \"https://metabase.com/feedback/inactive\"})\n\n(defn- follow-up-context []\n  {:heading      (trs \"We hope you''ve been enjoying Metabase.\")\n   :callToAction (trs \"Would you mind taking a fast 6 question survey to tell us how it\u2019s going?\")\n   :link         \"https://metabase.com/feedback/active\"})\n\n\n;;; ### Public Interface\n\n\n(defn send-new-user-email!\n  \"Send an email to `invitied` letting them know `invitor` has invited them to join Metabase.\"\n  [invited invitor join-url sent-from-setup?]\n  (let [company      (or (public-settings/site-name) \"Unknown\")\n        message-body (stencil/render-file \"metabase/email/new_user_invite\"\n                                          (merge (common-context)\n                                                 {:emailType     \"new_user_invite\"\n                                                  :invitedName   (or (:first_name invited) (:email invited))\n                                                  :invitorName   (or (:first_name invitor) (:email invitor))\n                                                  :invitorEmail  (:email invitor)\n                                                  :company       company\n                                                  :joinUrl       join-url\n                                                  :today         (t/format \"MMM'&nbsp;'dd,'&nbsp;'yyyy\" (t/zoned-date-time))\n                                                  :logoHeader    true\n                                                  :sentFromSetup sent-from-setup?}))]\n    (email/send-message!\n     :subject      (str (trs \"You''re invited to join {0}''s {1}\" company (app-name-trs)))\n     :recipients   [(:email invited)]\n     :message-type :html\n     :message      message-body)))\n\n(defn- all-admin-recipients\n  \"Return a sequence of email addresses for all Admin users.\n\n  The first recipient will be the site admin (or oldest admin if unset), which is the address that should be used in\n  `mailto` links (e.g., for the new user to email with any questions).\"\n  []\n  (concat (when-let [admin-email (public-settings/admin-email)]\n            [admin-email])\n          (db/select-field :email 'User, :is_superuser true, :is_active true, {:order-by [[:id :asc]]})))\n\n(defn send-user-joined-admin-notification-email!\n  \"Send an email to the `invitor` (the Admin who invited `new-user`) letting them know `new-user` has joined.\"\n  [new-user & {:keys [google-auth?]}]\n  {:pre [(map? new-user)]}\n  (let [recipients (all-admin-recipients)]\n    (email/send-message!\n     :subject      (str (if google-auth?\n                          (trs \"{0} created a {1} account\" (:common_name new-user) (app-name-trs))\n                          (trs \"{0} accepted their {1} invite\" (:common_name new-user) (app-name-trs))))\n     :recipients   recipients\n     :message-type :html\n     :message      (stencil/render-file \"metabase/email/user_joined_notification\"\n                                        (merge (common-context)\n                                               {:logoHeader        true\n                                                :joinedUserName    (or (:first_name new-user) (:email new-user))\n                                                :joinedViaSSO      google-auth?\n                                                :joinedUserEmail   (:email new-user)\n                                                :joinedDate        (t/format \"EEEE, MMMM d\" (t/zoned-date-time)) ; e.g. \"Wednesday, July 13\". TODO - is this what we want?\n                                                :adminEmail        (first recipients)\n                                                :joinedUserEditUrl (str (public-settings/site-url) \"/admin/people\")})))))\n\n(defn send-password-reset-email!\n  \"Format and send an email informing the user how to reset their password.\"\n  [email google-auth? non-google-sso? password-reset-url is-active?]\n  {:pre [(m/boolean? google-auth?)\n         (m/boolean? non-google-sso?)\n         (u/email? email)\n         ((some-fn string? nil?) password-reset-url)]}\n  (let [message-body (stencil/render-file\n                      \"metabase/email/password_reset\"\n                      (merge (common-context)\n                             {:emailType        \"password_reset\"\n                              :google           google-auth?\n                              :nonGoogleSSO     non-google-sso?\n                              :passwordResetUrl password-reset-url\n                              :logoHeader       true\n                              :isActive         is-active?\n                              :adminEmail       (public-settings/admin-email)\n                              :adminEmailSet    (boolean (public-settings/admin-email))}))]\n    (email/send-message!\n     :subject      (trs \"[{0}] Password Reset Request\" (app-name-trs))\n     :recipients   [email]\n     :message-type :html\n     :message      message-body)))\n\n(defn send-login-from-new-device-email!\n  \"Format and send an email informing the user that this is the first time we've seen a login from this device. Expects\n  login history infomation as returned by `metabase.models.login-history/human-friendly-infos`.\"\n  [{user-id :user_id, :keys [timestamp], :as login-history}]\n  (let [user-info    (db/select-one ['User [:first_name :first-name] :email :locale] :id user-id)\n        user-locale  (or (:locale user-info) (i18n/site-locale))\n        timestamp    (u.date/format-human-readable timestamp user-locale)\n        context      (merge (common-context)\n                            {:first-name (:first-name user-info)\n                             :device     (:device_description login-history)\n                             :location   (:location login-history)\n                             :timestamp  timestamp})\n        message-body (stencil/render-file \"metabase/email/login_from_new_device\"\n                                          context)]\n    (email/send-message!\n     :subject      (trs \"We''ve Noticed a New {0} Login, {1}\" (app-name-trs) (:first-name user-info))\n     :recipients   [(:email user-info)]\n     :message-type :html\n     :message      message-body)))\n\n;; TODO - I didn't write these function and I don't know what it's for / what it's supposed to be doing. If this is\n;; determined add appropriate documentation\n\n(defn- model-name->url-fn [model]\n  (case model\n    \"Card\"      urls/card-url\n    \"Dashboard\" urls/dashboard-url\n    \"Pulse\"     urls/pulse-url\n    \"Segment\"   urls/segment-url))\n\n(defn- add-url-to-dependency [{:keys [id model], :as obj}]\n  (assoc obj :url ((model-name->url-fn model) id)))\n\n(defn- build-dependencies\n  \"Build a sequence of dependencies from a `model-name->dependencies` map, and add various information such as obj URLs.\"\n  [model-name->dependencies]\n  (for [model-name (sort (keys model-name->dependencies))\n        :let       [user-facing-name (if (= model-name \"Card\")\n                                       \"Saved Question\"\n                                       model-name)]\n        deps       (get model-name->dependencies model-name)]\n    {:model   user-facing-name\n     :objects (for [dep deps]\n                (add-url-to-dependency dep))}))\n\n(defn send-notification-email!\n  \"Format and send an email informing the user about changes to objects in the system.\"\n  [email context]\n  {:pre [(u/email? email) (map? context)]}\n  (let [context      (merge (update context :dependencies build-dependencies)\n                            notification-context)\n        message-body (stencil/render-file \"metabase/email/notification\"\n                                          (merge (common-context) context))]\n    (email/send-message!\n     :subject      (trs \"[{0}] Notification\" (app-name-trs))\n     :recipients   [email]\n     :message-type :html\n     :message      message-body)))\n\n(defn- admin-or-ee-monitoring-details-emails\n  \"Find emails for users that have an interest in monitoring the database.\n   If oss that means admin users.\n   If ee that also means users with monitoring and details permissions.\"\n  [database-id]\n  (let [monitoring (perms/application-perms-path :monitoring)\n        db-details (perms/feature-perms-path :details :yes database-id)\n        user-ids (when (premium-features/enable-advanced-permissions?)\n                   (->> {:select   [:pgm.user_id]\n                         :from     [[:permissions_group_membership :pgm]]\n                         :join     [[:permissions_group :pg] [:= :pgm.group_id :pg.id]]\n                         :where    [:and\n                                    [:exists {:select [1]\n                                              :from [[:permissions :p]]\n                                              :where [:and\n                                                      [:= :p.group_id :pg.id]\n                                                      [:= :p.object monitoring]]}]\n                                    [:exists {:select [1]\n                                              :from [[:permissions :p]]\n                                              :where [:and\n                                                      [:= :p.group_id :pg.id]\n                                                      [:= :p.object db-details]]}]]\n                         :group-by [:pgm.user_id]}\n                        db/query\n                        (mapv :user_id)))]\n    (into\n      []\n      (distinct)\n      (concat\n        (all-admin-recipients)\n        (when (seq user-ids)\n          (db/select-field :email User {:where [:and\n                                                [:= :is_active true]\n                                                [:in :id user-ids]]}))))))\n\n(defn send-persistent-model-error-email!\n  \"Format and send an email informing the user about errors in the persistent model refresh task.\"\n  [database-id persisted-infos trigger]\n  {:pre [(seq persisted-infos)]}\n  (let [database (:database (first persisted-infos))\n        emails (admin-or-ee-monitoring-details-emails database-id)\n        timezone (some-> database qp.timezone/results-timezone-id t/zone-id)\n        context {:database-name (:name database)\n                 :errors\n                 (for [[idx persisted-info] (m/indexed persisted-infos)\n                       :let [card (:card persisted-info)\n                             collection (or (:collection card)\n                                            (collection/root-collection-with-ui-details nil))]]\n                   {:is-not-first (not= 0 idx)\n                    :error (:error persisted-info)\n                    :card-id (:id card)\n                    :card-name (:name card)\n                    :collection-name (:name collection)\n                    ;; February 1, 2022, 3:10 PM\n                    :last-run-at (t/format \"MMMM d, yyyy, h:mm a z\" (t/zoned-date-time (:refresh_begin persisted-info) timezone))\n                    :last-run-trigger trigger\n                    :card-url (urls/card-url (:id card))\n                    :collection-url (urls/collection-url (:id collection))\n                    :caching-log-details-url (urls/tools-caching-details-url (:id persisted-info))})}\n        message-body (stencil/render-file \"metabase/email/persisted-model-error\"\n                                          (merge (common-context) context))]\n    (when (seq emails)\n      (email/send-message!\n        :subject      (trs \"[{0}] Model cache refresh failed for {1}\" (app-name-trs) (:name database))\n        :recipients   (vec emails)\n        :message-type :html\n        :message      message-body))))\n\n(defn send-follow-up-email!\n  \"Format and send an email to the system admin following up on the installation.\"\n  [email msg-type]\n  {:pre [(u/email? email) (contains? #{\"abandon\" \"follow-up\"} msg-type)]}\n  (let [subject      (str (if (= \"abandon\" msg-type)\n                            (trs \"[{0}] Help make [{1}] better.\" (app-name-trs) (app-name-trs))\n                            (trs \"[{0}] Tell us how things are going.\" (app-name-trs))))\n        context      (merge notification-context\n                            (if (= \"abandon\" msg-type)\n                              (abandonment-context)\n                              (follow-up-context)))\n        message-body (stencil/render-file \"metabase/email/follow_up_email\"\n                                          (merge (common-context) context))]\n    (email/send-message!\n     :subject      subject\n     :recipients   [email]\n     :message-type :html\n     :message      message-body)))\n\n(defn- make-message-attachment [[content-id url]]\n  {:type         :inline\n   :content-id   content-id\n   :content-type \"image/png\"\n   :content      url})\n\n(defn- pulse-link-context\n  [{:keys [cards dashboard_id]}]\n  (when-let [dashboard-id (or dashboard_id\n                              (some :dashboard_id cards))]\n    {:pulseLink (urls/dashboard-url dashboard-id)}))\n\n(defn- pulse-context [pulse dashboard]\n  (merge (common-context)\n         {:emailType                 \"pulse\"\n          :title                     (:name pulse)\n          :titleUrl                  (params/dashboard-url (:id dashboard) (params/parameters pulse dashboard))\n          :dashboardDescription      (:description dashboard)\n          :creator                   (-> pulse :creator :common_name)\n          :sectionStyle              (style/style (style/section-style))}\n         (pulse-link-context pulse)))\n\n(defn- create-temp-file\n  \"Separate from `create-temp-file-or-throw` primarily so that we can simulate exceptions in tests\"\n  [suffix]\n  (doto (File/createTempFile \"metabase_attachment\" suffix)\n    .deleteOnExit))\n\n(defn- create-temp-file-or-throw\n  \"Tries to create a temp file, will give the users a better error message if we are unable to create the temp file\"\n  [suffix]\n  (try\n    (create-temp-file suffix)\n    (catch IOException e\n      (let [ex-msg (tru \"Unable to create temp file in `{0}` for email attachments \"\n                        (System/getProperty \"java.io.tmpdir\"))]\n        (throw (IOException. ex-msg e))))))\n\n(defn- create-result-attachment-map [export-type card-name ^File attachment-file]\n  (let [{:keys [content-type]} (qp.si/stream-options export-type)]\n    {:type         :attachment\n     :content-type content-type\n     :file-name    (format \"%s.%s\" card-name (name export-type))\n     :content      (-> attachment-file .toURI .toURL)\n     :description  (format \"More results for '%s'\" card-name)}))\n\n(defn- include-csv-attachment?\n  \"Should this `card` and `results` include a CSV attachment?\"\n  [{include-csv? :include_csv, include-xls? :include_xls, card-name :name, :as card} {:keys [cols rows], :as result-data}]\n  (letfn [(yes [reason & args]\n            (log/tracef \"Including CSV attachement for Card %s because %s\" (pr-str card-name) (apply format reason args))\n            true)\n          (no [reason & args]\n            (log/tracef \"NOT including CSV attachement for Card %s because %s\" (pr-str card-name) (apply format reason args))\n            false)]\n    (cond\n      include-csv?\n      (yes \"it has `:include_csv`\")\n\n      include-xls?\n      (no \"it has `:include_xls`\")\n\n      (some (complement body/show-in-table?) cols)\n      (yes \"some columns are not included in rendered results\")\n\n      (not= :table (render/detect-pulse-chart-type card nil result-data))\n      (no \"we've determined it should not be rendered as a table\")\n\n      (= (count (take body/rows-limit rows)) body/rows-limit)\n      (yes \"the results have >= %d rows\" body/rows-limit)\n\n      :else\n      (no \"less than %d rows in results\" body/rows-limit))))\n\n(defn- stream-api-results-to-export-format\n  \"For legacy compatability. Takes QP results in the normal `:api` response format and streams them to a different\n  format.\n\n  TODO -- this function is provided mainly because rewriting all of the Pulse/Alert code to stream results directly\n  was a lot of work. I intend to rework that code so we can stream directly to the correct export format(s) at some\n  point in the future; for now, this function is a stopgap.\n\n  Results are streamed synchronosuly. Caller is responsible for closing `os` when this call is complete.\"\n  [export-format ^OutputStream os {{:keys [rows]} :data, database-id :database_id, :as results}]\n  ;; make sure Database/driver info is available for the streaming results writers -- they might need this in order to\n  ;; get timezone information when writing results\n  (driver/with-driver (driver.u/database->driver database-id)\n    (qp.store/with-store\n      (qp.store/fetch-and-store-database! database-id)\n      (binding [qp.xlsx/*parse-temporal-string-values* true]\n        (let [w                           (qp.si/streaming-results-writer export-format os)\n              cols                        (-> results :data :cols)\n              viz-settings                (-> results :data :viz-settings)\n              [ordered-cols output-order] (qp.streaming/order-cols cols viz-settings)\n              viz-settings'               (assoc viz-settings :output-order output-order)]\n          (qp.si/begin! w\n                        (assoc-in results [:data :ordered-cols] ordered-cols)\n                        viz-settings')\n          (dorun\n           (map-indexed\n            (fn [i row]\n              (qp.si/write-row! w row i ordered-cols viz-settings'))\n            rows))\n          (qp.si/finish! w results))))))\n\n(defn- result-attachment\n  [{{card-name :name, :as card} :card, {{:keys [rows], :as result-data} :data, :as result} :result}]\n  (when (seq rows)\n    [(when-let [temp-file (and (include-csv-attachment? card result-data)\n                               (create-temp-file-or-throw \"csv\"))]\n       (with-open [os (io/output-stream temp-file)]\n         (stream-api-results-to-export-format :csv os result))\n       (create-result-attachment-map \"csv\" card-name temp-file))\n     (when-let [temp-file (and (:include_xls card)\n                               (create-temp-file-or-throw \"xlsx\"))]\n       (with-open [os (io/output-stream temp-file)]\n         (stream-api-results-to-export-format :xlsx os result))\n       (create-result-attachment-map \"xlsx\" card-name temp-file))]))\n\n(defn- result-attachments [results]\n  (filter some? (mapcat result-attachment results)))\n\n(defn- render-result-card\n  [timezone result]\n  (if (:card result)\n    (render/render-pulse-section timezone result)\n    {:content (markdown/process-markdown (:text result) :html)}))\n\n(defn- render-filters\n  [notification dashboard]\n  (let [filters (params/parameters notification dashboard)\n        cells   (map\n                 (fn [filter]\n                   [:td {:class \"filter-cell\"\n                         :style (style/style {:width \"50%\"\n                                              :padding \"0px\"\n                                              :vertical-align \"baseline\"})}\n                    [:table {:cellpadding \"0\"\n                             :cellspacing \"0\"\n                             :width \"100%\"\n                             :height \"100%\"}\n                     [:tr\n                      [:td\n                       {:style (style/style {:color style/color-text-medium\n                                             :min-width \"100px\"\n                                             :width \"50%\"\n                                             :padding \"4px 4px 4px 0\"\n                                             :vertical-align \"baseline\"})}\n                       (:name filter)]\n                      [:td\n                       {:style (style/style {:color style/color-text-dark\n                                             :min-width \"100px\"\n                                             :width \"50%\"\n                                             :padding \"4px 16px 4px 8px\"\n                                             :vertical-align \"baseline\"})}\n                       (params/value-string filter)]]]])\n                 filters)\n        rows    (partition 2 2 nil cells)]\n    (html\n     [:table {:style (style/style {:table-layout :fixed\n                                   :border-collapse :collapse\n                                   :cellpadding \"0\"\n                                   :cellspacing \"0\"\n                                   :width \"100%\"\n                                   :font-size  \"12px\"\n                                   :font-weight 700\n                                   :margin-top \"8px\"})}\n      (for [row rows]\n        [:tr {} row])])))\n\n(defn- render-message-body\n  [notification message-type message-context timezone dashboard results]\n  (let [rendered-cards  (binding [render/*include-title* true]\n                          (mapv #(render-result-card timezone %) results))\n        icon-name       (case message-type\n                          :alert :bell\n                          :pulse :dashboard)\n        icon-attachment (first (map make-message-attachment (icon-bundle icon-name)))\n        filters         (when dashboard\n                          (render-filters notification dashboard))\n        message-body    (assoc message-context :pulse (html (vec (cons :div (map :content rendered-cards))))\n                               :filters filters\n                               :iconCid (:content-id icon-attachment))\n        attachments     (apply merge (map :attachments rendered-cards))]\n    (vec (concat [{:type \"text/html; charset=utf-8\" :content (stencil/render-file \"metabase/email/pulse\" message-body)}]\n                 (map make-message-attachment attachments)\n                 [icon-attachment]\n                 (result-attachments results)))))\n\n(defn- assoc-attachment-booleans [pulse results]\n  (for [{{result-card-id :id} :card :as result} results\n        :let [pulse-card (m/find-first #(= (:id %) result-card-id) (:cards pulse))]]\n    (if result-card-id\n      (update result :card merge (select-keys pulse-card [:include_csv :include_xls]))\n      result)))\n\n(defn render-pulse-email\n  \"Take a pulse object and list of results, returns an array of attachment objects for an email\"\n  [timezone pulse dashboard results]\n  (render-message-body pulse\n                       :pulse\n                       (pulse-context pulse dashboard)\n                       timezone\n                       dashboard\n                       (assoc-attachment-booleans pulse results)))\n\n(defn pulse->alert-condition-kwd\n  \"Given an `alert` return a keyword representing what kind of goal needs to be met.\"\n  [{:keys [alert_above_goal alert_condition] :as _alert}]\n  (if (= \"goal\" alert_condition)\n    (if (true? alert_above_goal)\n      :meets\n      :below)\n    :rows))\n\n(defn- first-card\n  \"Alerts only have a single card, so the alerts API accepts a `:card` key, while pulses have `:cards`. Depending on\n  whether the data comes from the alert API or pulse tasks, the card could be under `:card` or `:cards`\"\n  [alert]\n  (or (:card alert)\n      (first (:cards alert))))\n\n(defn- common-alert-context\n  \"Template context that is applicable to all alert templates, including alert management templates\n  (e.g. the subscribed/unsubscribed emails)\"\n  ([alert]\n   (common-alert-context alert nil))\n  ([alert alert-condition-map]\n   (let [{card-id :id, card-name :name} (first-card alert)]\n     (merge (common-context)\n            {:emailType                 \"alert\"\n             :questionName              card-name\n             :questionURL               (urls/card-url card-id)\n             :sectionStyle              (style/section-style)}\n            (when alert-condition-map\n              {:alertCondition (get alert-condition-map (pulse->alert-condition-kwd alert))})))))\n\n(defn- schedule-hour-text\n  [{hour :schedule_hour}]\n  (.format (LocalTime/of hour 0)\n           (DateTimeFormatter/ofPattern \"h a\")))\n\n(defn- schedule-day-text\n  [{day :schedule_day}]\n  (get {\"sun\" \"Sunday\"\n        \"mon\" \"Monday\"\n        \"tue\" \"Tuesday\"\n        \"wed\" \"Wednesday\"\n        \"thu\" \"Thursday\"\n        \"fri\" \"Friday\"\n        \"sat\" \"Saturday\"}\n       day))\n\n(defn- schedule-timezone\n  []\n  (or (driver/report-timezone) \"UTC\"))\n\n(defn- alert-schedule-text\n  \"Returns a string that describes the run schedule of an alert (i.e. how often results are checked),\n  for inclusion in the email template. Not translated, since emails in general are not currently translated.\"\n  [channel]\n  (case (:schedule_type channel)\n    :hourly\n    \"Run hourly\"\n\n    :daily\n    (format \"Run daily at %s %s\"\n            (schedule-hour-text channel)\n            (schedule-timezone))\n\n    :weekly\n    (format \"Run weekly on %s at %s %s\"\n            (schedule-day-text channel)\n            (schedule-hour-text channel)\n            (schedule-timezone))))\n\n(defn- alert-context\n  \"Context that is applicable only to the actual alert template (not alert management templates)\"\n  [alert channel]\n  (let [{card-id :id, card-name :name} (first-card alert)]\n    {:title         card-name\n     :titleUrl      (urls/card-url card-id)\n     :alertSchedule (alert-schedule-text channel)\n     :creator       (-> alert :creator :common_name)}))\n\n(defn- alert-results-condition-text [goal-value]\n  {:meets (format \"This question has reached its goal of %s.\" goal-value)\n   :below (format \"This question has gone below its goal of %s.\" goal-value)})\n\n(defn render-alert-email\n  \"Take a pulse object and list of results, returns an array of attachment objects for an email\"\n  [timezone {:keys [alert_first_only] :as alert} channel results goal-value]\n  (let [message-ctx  (merge\n                      (common-alert-context alert (alert-results-condition-text goal-value))\n                      (alert-context alert channel))]\n    (render-message-body alert\n                         :alert\n                         (assoc message-ctx :firstRunOnly? alert_first_only)\n                         timezone\n                         nil\n                         (assoc-attachment-booleans alert results))))\n\n(def ^:private alert-condition-text\n  {:meets \"when this question meets its goal\"\n   :below \"when this question goes below its goal\"\n   :rows  \"whenever this question has any results\"})\n\n(defn- send-email!\n  \"Sends an email on a background thread, returning a future.\"\n  [user subject template-path template-context]\n  (future\n    (try\n      (email/send-message-or-throw!\n       {:recipients   [(:email user)]\n        :message-type :html\n        :subject      subject\n        :message      (stencil/render-file template-path template-context)})\n      (catch Exception e\n        (log/errorf e \"Failed to send message to '%s' with subject '%s'\" (:email user) subject)))))\n\n(defn- template-path [template-name]\n  (str \"metabase/email/\" template-name \".mustache\"))\n\n;; Paths to the templates for all of the alerts emails\n(def ^:private new-alert-template          (template-path \"alert_new_confirmation\"))\n(def ^:private you-unsubscribed-template   (template-path \"alert_unsubscribed\"))\n(def ^:private admin-unsubscribed-template (template-path \"alert_admin_unsubscribed_you\"))\n(def ^:private added-template              (template-path \"alert_you_were_added\"))\n(def ^:private stopped-template            (template-path \"alert_stopped_working\"))\n\n(defn send-new-alert-email!\n  \"Send out the initial 'new alert' email to the `creator` of the alert\"\n  [{:keys [creator] :as alert}]\n  (send-email! creator \"You set up an alert\" new-alert-template\n               (common-alert-context alert alert-condition-text)))\n\n(defn send-you-unsubscribed-alert-email!\n  \"Send an email to `who-unsubscribed` letting them know they've unsubscribed themselves from `alert`\"\n  [alert who-unsubscribed]\n  (send-email! who-unsubscribed \"You unsubscribed from an alert\" you-unsubscribed-template\n               (common-alert-context alert)))\n\n(defn send-admin-unsubscribed-alert-email!\n  \"Send an email to `user-added` letting them know `admin` has unsubscribed them from `alert`\"\n  [alert user-added {:keys [first_name last_name] :as _admin}]\n  (let [admin-name (format \"%s %s\" first_name last_name)]\n    (send-email! user-added \"You\u2019ve been unsubscribed from an alert\" admin-unsubscribed-template\n                 (assoc (common-alert-context alert) :adminName admin-name))))\n\n(defn send-you-were-added-alert-email!\n  \"Send an email to `user-added` letting them know `admin-adder` has added them to `alert`\"\n  [alert user-added {:keys [first_name last_name] :as _admin-adder}]\n  (let [subject (format \"%s %s added you to an alert\" first_name last_name)]\n    (send-email! user-added subject added-template (common-alert-context alert alert-condition-text))))\n\n(def ^:private not-working-subject \"One of your alerts has stopped working\")\n\n(defn send-alert-stopped-because-archived-email!\n  \"Email to notify users when a card associated to their alert has been archived\"\n  [alert user {:keys [first_name last_name] :as _archiver}]\n  (let [deletion-text (format \"the question was archived by %s %s\" first_name last_name)]\n    (send-email! user not-working-subject stopped-template (assoc (common-alert-context alert) :deletionCause deletion-text))))\n\n(defn send-alert-stopped-because-changed-email!\n  \"Email to notify users when a card associated to their alert changed in a way that invalidates their alert\"\n  [alert user {:keys [first_name last_name] :as _archiver}]\n  (let [edited-text (format \"the question was edited by %s %s\" first_name last_name)]\n    (send-email! user not-working-subject stopped-template (assoc (common-alert-context alert) :deletionCause edited-text))))\n\n(defn send-slack-token-error-emails!\n  \"Email all admins when a Slack API call fails due to a revoked token or other auth error\"\n  []\n  (email/send-message!\n   :subject (trs \"Your Slack connection stopped working\")\n   :recipients (all-admin-recipients)\n   :message-type :html\n   :message (stencil/render-file \"metabase/email/slack_token_error.mustache\"\n                                 (merge (common-context)\n                                        {:logoHeader  true\n                                         :settingsUrl (str (public-settings/site-url) \"/admin/settings/slack\")}))))\n", "{{> metabase/email/_header }}\n  <div>\n    {{#google}}\n      <p>You're using Google to log in to {{applicationName}}, so you don't have a password. You can log in to {{applicationName}} by clicking \"Sign in with Google\"</p>\n      <a href=\"{{siteUrl}}\">Go to {{applicationName}}</a>\n    {{/google}}\n    {{^google}}\n      {{#nonGoogleSSO}}\n        <p>We can't reset your password becase you're using single sign-on to log in to {{applicationName}}. Use the\n        \"Sign in with SSO\" button on the log in page. To change your password, you'll need to contact an administrator.</p>\n        <a href=\"{{siteUrl}}\">Go to {{applicationName}}</a>\n      {{/nonGoogleSSO}}\n      {{^nonGoogleSSO}}\n        {{#isActive}}\n          <div style=\"text-align: center\">\n            <p>Click the button below to reset the password for your {{applicationName}} account at {{siteUrl}}.</p>\n            <a style=\"display: inline-block; box-sizing: border-box; font-size: 18px; padding: 8px 22px; cursor: pointer; text-decoration: none; border-radius: 4px; background-color: #4990E2; border-color: #4990E2; color: #fff;\" href=\"{{passwordResetUrl}}\">Reset password</a>\n            <p style=\"padding-top: 2em; font-size: small;\">Didn't request this password reset? It's safe to ignore it.</p>\n          </div>\n        {{/isActive}}\n        {{^isActive}}\n          <p>Someone requested a password reset for your {{applicationName}} account at {{siteUrl}}, but your account\n          has been deactivated. Contact an administrator for further assistance.</p>\n          {{#adminEmailSet}}\n            <a href=\"mailto:{{adminEmail}}\">Contact your administrator</a>\n          {{/adminEmailSet}}\n        {{/isActive}}\n      {{/nonGoogleSSO}}\n    {{/google}}\n  </div>\n{{> metabase/email/_footer }}\n", "(ns metabase.email.messages-test\n  (:require [clojure.string :as str]\n            [clojure.test :refer :all]\n            [metabase.email-test :as et]\n            [metabase.email.messages :as messages]\n            [metabase.test.util :as tu])\n  (:import java.io.IOException))\n\n(deftest new-user-email\n  (is (= [{:from    \"notifications@metabase.com\",\n           :to      [\"test@test.com\"],\n           :subject \"You're invited to join Metabase Test's Metabase\",\n           :body    [{:type \"text/html; charset=utf-8\"}]}]\n         (tu/with-temporary-setting-values [site-name \"Metabase Test\"]\n           (et/with-fake-inbox\n             (messages/send-new-user-email! {:first_name \"test\" :email \"test@test.com\"}\n                                            {:first_name \"invitor\" :email \"invited_by@test.com\"}\n                                            \"http://localhost/some/url\"\n                                            false)\n             (-> (@et/inbox \"test@test.com\")\n                 (update-in [0 :body 0] dissoc :content)))))))\n\n(deftest password-reset-email\n  (testing \"password reset email can be sent successfully\"\n    (et/with-fake-inbox\n      (messages/send-password-reset-email! \"test@test.com\" false false \"http://localhost/some/url\" true)\n      (is (= [{:from    \"notifications@metabase.com\",\n               :to      [\"test@test.com\"],\n               :subject \"[Metabase] Password Reset Request\",\n               :body    [{:type \"text/html; charset=utf-8\"}]}]\n             (-> (@et/inbox \"test@test.com\")\n                 (update-in [0 :body 0] dissoc :content))))))\n  ;; Email contents contain randomized elements, so we only check for the inclusion of a single word to verify\n  ;; that the contents changed in the tests below.\n  (testing \"password reset email tells user if they should log in with Google Sign-In\"\n    (et/with-fake-inbox\n      (messages/send-password-reset-email! \"test@test.com\" true false \"http://localhost/some/url\" true)\n      (is (-> (@et/inbox \"test@test.com\")\n              (get-in [0 :body 0 :content])\n              (str/includes? \"Google\")))))\n  (testing \"password reset email tells user if they should log in with (non-Google) SSO\"\n    (et/with-fake-inbox\n      (messages/send-password-reset-email! \"test@test.com\" false true nil true)\n      (is (-> (@et/inbox \"test@test.com\")\n              (get-in [0 :body 0 :content])\n              (str/includes? \"SSO\")))))\n  (testing \"password reset email tells user if their account is inactive\"\n    (et/with-fake-inbox\n      (messages/send-password-reset-email! \"test@test.com\" false false \"http://localhost/some/url\" false)\n      (is (-> (@et/inbox \"test@test.com\")\n              (get-in [0 :body 0 :content])\n              (str/includes? \"deactivated\"))))))\n\n(defmacro ^:private with-create-temp-failure [& body]\n  `(with-redefs [messages/create-temp-file (fn [~'_]\n                                             (throw (IOException. \"Failed to write file\")))]\n     ~@body))\n\n;; Test that IOException bubbles up\n(deftest throws-exception\n  (is (thrown-with-msg?\n        IOException\n        (re-pattern (format \"Unable to create temp file in `%s`\" (System/getProperty \"java.io.tmpdir\")))\n        (with-create-temp-failure\n          (#'messages/create-temp-file-or-throw \"txt\")))))\n\n(deftest alert-schedule-text-test\n  (testing \"Alert schedules can be described as English strings, with the timezone included\"\n    (tu/with-temporary-setting-values [report-timezone \"America/Pacific\"]\n      (is (= \"Run hourly\"\n             (@#'messages/alert-schedule-text {:schedule_type :hourly})))\n      (is (= \"Run daily at 12 AM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 0})))\n      (is (= \"Run daily at 5 AM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 5})))\n      (is (= \"Run daily at 6 PM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 18})))\n      (is (= \"Run weekly on Monday at 8 AM America/Pacific\"\n             (@#'messages/alert-schedule-text {:schedule_type :weekly\n                                               :schedule_day  \"mon\"\n                                               :schedule_hour 8})))))\n  (testing \"If report-timezone is not set, falls back to UTC\"\n    (tu/with-temporary-setting-values [report-timezone nil]\n      (is (= \"Run daily at 12 AM UTC\"\n             (@#'messages/alert-schedule-text {:schedule_type :daily\n                                               :schedule_hour 0}))))))\n\n(deftest render-pulse-email-test\n  (testing \"Email with few rows and columns can be rendered when tracing (#21166)\"\n    (tu/with-log-level [metabase.email :trace]\n      (let [result {:card   {:name \"card-name\"\n                             :visualization_settings\n                             {:table.column_formatting []}}\n                    :result {:data {:cols [{:name \"x\"} {:name \"y\"}]\n                                    :rows [[0 0]\n                                           [1 1]]}}}\n            emails (messages/render-pulse-email \"America/Pacific\" {} {} [result])]\n        (is (vector? emails))\n        (is (map? (first emails)))))))\n", "(ns metabase.email-test\n  \"Various helper functions for testing email functionality.\"\n  (:require [clojure.java.io :as io]\n            [clojure.test :refer :all]\n            [medley.core :as m]\n            [metabase.email :as email]\n            [metabase.test.data.users :as test.users]\n            [metabase.test.util :as tu]\n            [metabase.util :refer [prog1]]\n            [postal.message :as message])\n  (:import java.io.File\n           javax.activation.MimeType))\n\n;; TODO - this should be made dynamic so it's (at least theoretically) possible to use this in parallel\n(def inbox\n  \"Map of email addresses -> sequence of messages they've received.\"\n  (atom {}))\n\n(defn reset-inbox!\n  \"Clear all messages from `inbox`.\"\n  []\n  (reset! inbox {}))\n\n(defn fake-inbox-email-fn\n  \"A function that can be used in place of `send-email!`.\n   Put all messages into `inbox` instead of actually sending them.\"\n  [_ email]\n  (doseq [recipient (:to email)]\n    (swap! inbox assoc recipient (-> (get @inbox recipient [])\n                                     (conj email)))))\n\n(defn do-with-expected-messages\n  \"Invokes `thunk`, blocking until `n` messages are found in the inbox.\"\n  [n thunk]\n  {:pre [(number? n)]}\n  (let [p (promise)]\n    ;; Watches get invoked on the callers thread. In our case, this will be the future (or background thread) that is\n    ;; sending the message. It will block that thread, counting the number of messages. If it has reached it's goal,\n    ;; it will deliver the promise\n    (add-watch inbox ::inbox-watcher\n               (fn [_ _ _ new-value]\n                 (let [num-msgs (count (apply concat (vals new-value)))]\n                   (when (<= n num-msgs)\n                     (deliver p num-msgs)))))\n    (try\n      (let [result        (thunk)\n            ;; This will block the calling thread (i.e. the test) waiting for the promise to be delivered. There is a\n            ;; very high timeout (30 seconds) that we should never reach, but without it, if we do hit that scenario, it\n            ;; should at least not hang forever in CI\n            promise-value (deref p 30000 ::timeout)]\n        (if (= promise-value ::timeout)\n          (throw (Exception. \"Timed out while waiting for messages in the inbox\"))\n          result))\n      (finally\n        (remove-watch inbox ::inbox-watcher)))))\n\n(defmacro with-expected-messages\n  \"Invokes `body`, waiting until `n` messages are found in the inbox before returning. This is useful if the code you\n  are testing sends emails via a future or background thread. Using this will block the test, waiting for the messages\n  to arrive before continuing.\"\n  [n & body]\n  `(do-with-expected-messages ~n (fn [] ~@body)))\n\n(defn do-with-fake-inbox\n  \"Impl for `with-fake-inbox` macro; prefer using that rather than calling this directly.\"\n  [f]\n  (with-redefs [email/send-email! fake-inbox-email-fn]\n    (reset-inbox!)\n    (tu/with-temporary-setting-values [email-smtp-host    \"fake_smtp_host\"\n                                       email-smtp-port    587]\n      (f))))\n\n(defmacro with-fake-inbox\n  \"Clear `inbox`, bind `send-email!` to `fake-inbox-email-fn`, set temporary settings for `email-smtp-username`\n   and `email-smtp-password` (which will cause `metabase.email/email-configured?` to return `true`, and execute `body`.\n\n   Fetch the emails send by dereffing `inbox`.\n\n     (with-fake-inbox\n       (send-some-emails!)\n       @inbox)\"\n  [& body]\n  {:style/indent 0}\n  `(do-with-fake-inbox (fn [] ~@body)))\n\n(defn- create-email-body->regex-fn\n  \"Returns a function expecting the email body structure. It will apply the regexes in `regex-seq` over the body and\n  return map of the stringified regex as the key and a boolean as the value. True if it returns results via `re-find`\n  false otherwise.\"\n  [regex-seq]\n  (fn [message-body]\n    (let [{:keys [content]} message-body]\n      (zipmap (map str regex-seq)\n              (map #(boolean (re-find % content)) regex-seq)))))\n\n(defn- regex-email-bodies*\n  [regexes emails]\n  (let [email-body->regex-boolean (create-email-body->regex-fn regexes)]\n    (->> emails\n         (m/map-vals (fn [emails-for-recipient]\n                       (for [{:keys [body] :as email} emails-for-recipient\n                             :let [matches (-> body first email-body->regex-boolean)]\n                             :when (some true? (vals matches))]\n                         (-> email\n                             (update :to set)\n                             (assoc :body matches)))))\n         (m/filter-vals seq))))\n\n(defn regex-email-bodies\n  \"Return messages in the fake inbox whose body matches the regex(es). The body will be replaced by a map with the\n  stringified regex as it's key and a boolean indicated that the regex returned results.\"\n  [& regexes]\n  (regex-email-bodies* regexes @inbox))\n\n(defn received-email-subject?\n  \"Indicate whether a user received an email whose subject matches the `regex`. First argument should be a keyword\n  like :rasta, or an email address string.\"\n  [user-or-email regex]\n  (let [address (if (string? user-or-email) user-or-email (:username (test.users/user->credentials user-or-email)))\n        emails  (get @inbox address)]\n    (boolean (some #(re-find regex %) (map :subject emails)))))\n\n(defn received-email-body?\n  \"Indicate whether a user received an email whose body matches the `regex`. First argument should be a keyword\n  like :rasta, or an email address string.\"\n  [user-or-email regex]\n  (let [address (if (string? user-or-email) user-or-email (:username (test.users/user->credentials user-or-email)))\n        emails  (get @inbox address)]\n    (boolean (some #(re-find regex %) (map (comp :content first :body) emails)))))\n\n(deftest regex-email-bodies-test\n  (letfn [(email [body] {:to #{\"mail\"}\n                         :body [{:content body}]})\n          (clean [emails] (m/map-vals #(map :body %) emails))]\n    (testing \"marks emails with regex match\"\n      (let [emails {\"bob@metabase.com\" [(email \"foo bar baz\")\n                                        (email \"other keyword\")]\n                    \"sue@metabase.com\" [(email \"foo bar baz\")]}]\n        (is (= {\"bob@metabase.com\" [{\"foo\" true \"keyword\" false} {\"foo\" false \"keyword\" true}]\n                \"sue@metabase.com\" [{\"foo\" true \"keyword\" false}]}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"] emails))))))\n    (testing \"Returns only emails with at least one match\"\n      ;; drops the email that isn't matched by any regex\n      (testing \"Drops the email that doesn't match\"\n        (is (= {\"bob@metabase.com\" [{\"foo\" true \"keyword\" false}]}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"]\n                                           {\"bob@metabase.com\" [(email \"foo\")\n                                                                (email \"no-match\")]})))))\n      (testing \"Drops the entry for the other person with no matching emails\"\n        (is (= {\"bob@metabase.com\" [{\"foo\" true \"keyword\" false}]}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"]\n                                           {\"bob@metabase.com\" [(email \"foo\")\n                                                                (email \"no-match\")]\n                                            \"sue@metabase.com\" [(email \"no-match\")]}))))\n        (is (= {}\n               (clean (regex-email-bodies* [#\"foo\" #\"keyword\"]\n                                           {\"bob@metabase.com\" [(email \"no-match\")\n                                                                (email \"no-match\")]\n                                            \"sue@metabase.com\" [(email \"no-match\")]}))))))))\n\n(defn- mime-type [mime-type-str]\n  (-> mime-type-str\n      MimeType.\n      .getBaseType))\n\n(defn- summarize-attachment [email-attachment]\n  (-> email-attachment\n      (update :content-type mime-type)\n      (update :content class)\n      (update :content-id boolean)))\n\n(defn summarize-multipart-email\n  \"For text/html portions of an email, this is similar to `regex-email-bodies`, but for images in the attachments will\n  summarize the contents for comparison in expects\"\n  [& regexes]\n  (let [email-body->regex-boolean (create-email-body->regex-fn regexes)]\n    (m/map-vals (fn [emails-for-recipient]\n                  (for [email emails-for-recipient]\n                    (-> email\n                        (update :to set)\n                        (update :body (fn [email-body-seq]\n                                        (doall\n                                         (for [{email-type :type :as email-part} email-body-seq]\n                                           (if (string? email-type)\n                                             (email-body->regex-boolean email-part)\n                                             (summarize-attachment email-part)))))))))\n                @inbox)))\n\n(defn email-to\n  \"Creates a default email map for `user-kwd` via `test.users/fetch-user`, as would be returned by `with-fake-inbox`\"\n  [user-kwd & [email-map]]\n  (let [{:keys [email]} (test.users/fetch-user user-kwd)]\n    {email [(merge {:from (email/email-from-address)\n                    :to #{email}}\n                   email-map)]}))\n\n(defn temp-csv\n  [file-basename content]\n  (prog1 (File/createTempFile file-basename \".csv\")\n    (with-open [file (io/writer <>)]\n      (.write ^java.io.Writer file ^String content))))\n\n(defn mock-send-email!\n  \"To stub out email sending, instead returning the would-be email contents as a string\"\n  [_smtp-credentials email-details]\n  (-> email-details\n      message/make-jmessage\n      message/message->str))\n\n(deftest send-message!-test\n  (tu/with-temporary-setting-values [email-from-address \"lucky@metabase.com\"\n                                     email-from-name    \"Lucky\"\n                                     email-smtp-host    \"smtp.metabase.com\"\n                                     email-smtp-username \"lucky\"\n                                     email-smtp-password \"d1nner3scapee!\"\n                                     email-smtp-port     1025\n                                     email-reply-to      [\"reply-to-me@metabase.com\" \"reply-to-me-too@metabase.com\"]\n                                     email-smtp-security :none]\n    (testing \"basic sending\"\n      (is (=\n           [{:from     (str (email/email-from-name) \" <\" (email/email-from-address) \">\")\n             :to       [\"test@test.com\"]\n             :subject  \"101 Reasons to use Metabase\"\n             :reply-to (email/email-reply-to)\n             :body     [{:type    \"text/html; charset=utf-8\"\n                         :content \"101. Metabase will make you a better person\"}]}]\n           (with-fake-inbox\n             (email/send-message!\n              :subject      \"101 Reasons to use Metabase\"\n              :recipients   [\"test@test.com\"]\n              :message-type :html\n              :message      \"101. Metabase will make you a better person\")\n             (@inbox \"test@test.com\")))))\n    (testing \"basic sending without email-from-name\"\n      (tu/with-temporary-setting-values [email-from-name nil]\n        (is (=\n             [{:from     (email/email-from-address)\n               :to       [\"test@test.com\"]\n               :subject  \"101 Reasons to use Metabase\"\n               :reply-to (email/email-reply-to)\n               :body     [{:type    \"text/html; charset=utf-8\"\n                           :content \"101. Metabase will make you a better person\"}]}]\n             (with-fake-inbox\n               (email/send-message!\n                :subject      \"101 Reasons to use Metabase\"\n                :recipients   [\"test@test.com\"]\n                :message-type :html\n                :message      \"101. Metabase will make you a better person\")\n               (@inbox \"test@test.com\"))))))\n    (testing \"with an attachment\"\n      (let [recipient    \"csv_user@example.com\"\n            csv-contents \"hugs_with_metabase,hugs_without_metabase\\n1,0\"\n            csv-file     (temp-csv \"metabase-reasons\" csv-contents)\n            params       {:subject      \"101 Reasons to use Metabase\"\n                          :recipients   [recipient]\n                          :message-type :attachments\n                          :message      [{:type    \"text/html; charset=utf-8\"\n                                          :content \"100. Metabase will hug you when you're sad\"}\n                                         {:type         :attachment\n                                          :content-type \"text/csv\"\n                                          :file-name    \"metabase-reasons.csv\"\n                                          :content      csv-file\n                                          :description  \"very scientific data\"}]}]\n        (testing \"it sends successfully\"\n          (is (=\n               [{:from     (str (email/email-from-name) \" <\" (email/email-from-address) \">\")\n                 :to       [recipient]\n                 :subject  \"101 Reasons to use Metabase\"\n                 :reply-to (email/email-reply-to)\n                 :body     [{:type    \"text/html; charset=utf-8\"\n                             :content \"100. Metabase will hug you when you're sad\"}\n                            {:type         :attachment\n                             :content-type \"text/csv\"\n                             :file-name    \"metabase-reasons.csv\"\n                             :content      csv-file\n                             :description  \"very scientific data\"}]}]\n               (with-fake-inbox\n                 (m/mapply email/send-message! params)\n                 (@inbox recipient)))))\n        (testing \"it does not wrap long, non-ASCII filenames\"\n          (with-redefs [email/send-email! mock-send-email!]\n            (let [basename                     \"this-is-quite-long-and-has-non-\u00c2\u017f\u00e7\u00ef\u0131-characters\"\n                  csv-file                     (temp-csv basename csv-contents)\n                  params-with-problematic-file (-> params\n                                                   (assoc-in [:message 1 :file-name] (str basename \".csv\"))\n                                                   (assoc-in [:message 1 :content] csv-file))]\n              ;; Bad string (ignore the linebreak):\n              ;; Content-Disposition: attachment; filename=\"=?UTF-8?Q?this-is-quite-long-and-ha?= =?UTF-8?Q?s-non-\n              ;; =C3=82\\\"; filename*1=\\\"=C5=BF=C3=A7=C3=AF=C4=B1-characters.csv?=\"\n              ;;           ^-- this is the problem\n              ;; Acceptable string (again, ignore the linebreak):\n              ;; Content-Disposition: attachment; filename= \"=?UTF-8?Q?this-is-quite-long-and-ha?=\n              ;; =?UTF-8?Q?s-non-=C3=82=C5=BF=C3=A7=C3=AF=C4=B1-characters.csv?=\"\n\n              (is (re-find\n                   #\"(?s)Content-Disposition: attachment.+filename=.+this-is-quite-[\\-\\s?=0-9a-zA-Z]+-characters.csv\"\n                   (m/mapply email/send-message! params-with-problematic-file))))))))))\n"], "filenames": ["src/metabase/api/session.clj", "src/metabase/email/messages.clj", "src/metabase/email/password_reset.mustache", "test/metabase/email/messages_test.clj", "test/metabase/email_test.clj"], "buggy_code_start_loc": [202, 59, 3, 26, 69], "buggy_code_end_loc": [208, 508, 23, 44, 71], "fixing_code_start_loc": [202, 59, 3, 26, 69], "fixing_code_end_loc": [217, 509, 30, 50, 71], "type": "CWE-287", "message": "Metabase is data visualization software. Prior to versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9 single sign on (SSO) users were able to do password resets on Metabase, which could allow a user access without going through the SSO IdP. This issue is patched in versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9. Metabase now blocks password reset for all users who use SSO for their Metabase login.", "other": {"cve": {"id": "CVE-2022-39360", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-26T19:15:13.657", "lastModified": "2022-10-28T16:29:32.107", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Metabase is data visualization software. Prior to versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9 single sign on (SSO) users were able to do password resets on Metabase, which could allow a user access without going through the SSO IdP. This issue is patched in versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9. Metabase now blocks password reset for all users who use SSO for their Metabase login."}, {"lang": "es", "value": "Metabase es un software de visualizaci\u00f3n de datos. En versiones anteriores a 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9 y 1.41.9, los usuarios de inicio de sesi\u00f3n \u00fanico (SSO) pod\u00edan restablecer sus contrase\u00f1as en Metabase, lo que pod\u00eda permitir el acceso de un usuario sin pasar por el IdP de SSO. Este problema ha sido corregido en las versiones 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9 y 1.41.9. Metabase ahora bloquea el restablecimiento de la contrase\u00f1a para todos los usuarios que usan SSO para su inicio de sesi\u00f3n en Metabase"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-304"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.41.0", "versionEndExcluding": "0.41.9", "matchCriteriaId": "BCD50540-E323-41CE-9D9C-EDA8CB718E42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.42.0", "versionEndExcluding": "0.42.6", "matchCriteriaId": "EF01C7BF-CB4C-4990-9082-587CFD555225"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.43.0", "versionEndExcluding": "0.43.7", "matchCriteriaId": "8858058E-C597-4752-8625-9B279DC65A48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.44.0", "versionEndExcluding": "0.44.5", "matchCriteriaId": "6A94F7EA-BC18-4013-9A93-7962226FDD98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.41.0", "versionEndExcluding": "1.41.9", "matchCriteriaId": "804B84E1-5D1A-4251-9829-65F5FD927D99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.42.0", "versionEndExcluding": "1.42.6", "matchCriteriaId": "73310924-8CD4-4696-89B9-EED3390375A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.43.0", "versionEndExcluding": "1.43.7", "matchCriteriaId": "A86AA0C8-2C4F-4DDD-8371-6B43611E2479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.44.0", "versionEndExcluding": "1.44.5", "matchCriteriaId": "EF7A60F6-5062-4094-91A5-71445F9B7BC1"}]}]}], "references": [{"url": "https://github.com/metabase/metabase/commit/edadf7303c3b068609f57ca073e67885d5c98730", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/metabase/metabase/security/advisories/GHSA-gw4g-ww2m-v7vc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/metabase/metabase/commit/edadf7303c3b068609f57ca073e67885d5c98730"}}