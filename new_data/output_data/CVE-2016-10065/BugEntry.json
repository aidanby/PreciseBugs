{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                    M   M  EEEEE  M   M   OOO   RRRR   Y   Y                 %\n%                    MM MM  E      MM MM  O   O  R   R   Y Y                  %\n%                    M M M  EEE    M M M  O   O  RRRR     Y                   %\n%                    M   M  E      M   M  O   O  R R      Y                   %\n%                    M   M  EEEEE  M   M   OOO   R  R     Y                   %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Memory Allocation Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1998                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Segregate our memory requirements from any program that calls our API.  This\n%  should help reduce the risk of others changing our program state or causing\n%  memory corruption.\n%\n%  Our custom memory allocation manager implements a best-fit allocation policy\n%  using segregated free lists.  It uses a linear distribution of size classes\n%  for lower sizes and a power of two distribution of size classes at higher\n%  sizes.  It is based on the paper, \"Fast Memory Allocation using Lazy Fits.\"\n%  written by Yoo C. Chung.\n%\n%  By default, ANSI memory methods are called (e.g. malloc).  Use the\n%  custom memory allocator by defining MAGICKCORE_ZERO_CONFIGURATION_SUPPORT\n%  to allocate memory with private anonymous mapping rather than from the\n%  heap.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define BlockFooter(block,size) \\\n  ((size_t *) ((char *) (block)+(size)-2*sizeof(size_t)))\n#define BlockHeader(block)  ((size_t *) (block)-1)\n#define BlockSize  4096\n#define BlockThreshold  1024\n#define MaxBlockExponent  16\n#define MaxBlocks ((BlockThreshold/(4*sizeof(size_t)))+MaxBlockExponent+1)\n#define MaxSegments  1024\n#define MemoryGuard  ((0xdeadbeef << 31)+0xdeafdeed)\n#define NextBlock(block)  ((char *) (block)+SizeOfBlock(block))\n#define NextBlockInList(block)  (*(void **) (block))\n#define PreviousBlock(block)  ((char *) (block)-(*((size_t *) (block)-2)))\n#define PreviousBlockBit  0x01\n#define PreviousBlockInList(block)  (*((void **) (block)+1))\n#define SegmentSize  (2*1024*1024)\n#define SizeMask  (~0x01)\n#define SizeOfBlock(block)  (*BlockHeader(block) & SizeMask)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  UndefinedVirtualMemory,\n  AlignedVirtualMemory,\n  MapVirtualMemory,\n  UnalignedVirtualMemory\n} VirtualMemoryType;\n\ntypedef struct _DataSegmentInfo\n{\n  void\n    *allocation,\n    *bound;\n\n  MagickBooleanType\n    mapped;\n\n  size_t\n    length;\n\n  struct _DataSegmentInfo\n    *previous,\n    *next;\n} DataSegmentInfo;\n\ntypedef struct _MagickMemoryMethods\n{\n  AcquireMemoryHandler\n    acquire_memory_handler;\n\n  ResizeMemoryHandler\n    resize_memory_handler;\n\n  DestroyMemoryHandler\n    destroy_memory_handler;\n} MagickMemoryMethods;\n\nstruct _MemoryInfo\n{\n  char\n    filename[MagickPathExtent];\n\n  VirtualMemoryType\n    type;\n\n  size_t\n    length;\n\n  void\n    *blob;\n\n  size_t\n    signature;\n};\n\ntypedef struct _MemoryPool\n{\n  size_t\n    allocation;\n\n  void\n    *blocks[MaxBlocks+1];\n\n  size_t\n    number_segments;\n\n  DataSegmentInfo\n    *segments[MaxSegments],\n    segment_pool[MaxSegments];\n} MemoryPool;\n\f\n/*\n  Global declarations.\n*/\n#if defined _MSC_VER\nstatic void* MSCMalloc(size_t size)\n{\n  return malloc(size);\n}\nstatic void* MSCRealloc(void* ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\nstatic void MSCFree(void* ptr)\n{\n  free(ptr);\n}\n#endif\n\nstatic MagickMemoryMethods\n  memory_methods =\n  {\n#if defined _MSC_VER\n    (AcquireMemoryHandler) MSCMalloc,\n    (ResizeMemoryHandler) MSCRealloc,\n    (DestroyMemoryHandler) MSCFree\n#else\n    (AcquireMemoryHandler) malloc,\n    (ResizeMemoryHandler) realloc,\n    (DestroyMemoryHandler) free\n#endif\n  };\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic MemoryPool\n  memory_pool;\n\nstatic SemaphoreInfo\n  *memory_semaphore = (SemaphoreInfo *) NULL;\n\nstatic volatile DataSegmentInfo\n  *free_segments = (DataSegmentInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  ExpandHeap(size_t);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e A l i g n e d M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireAlignedMemory() returns a pointer to a block of memory at least size\n%  bytes whose address is a multiple of 16*sizeof(void *).\n%\n%  The format of the AcquireAlignedMemory method is:\n%\n%      void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nstatic MagickBooleanType CheckMemoryOverflow(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\nMagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n{\n#define AlignedExtent(size,alignment) \\\n  (((size)+((alignment)-1)) & ~((alignment)-1))\n\n  size_t\n    alignment,\n    extent,\n    size;\n\n  void\n    *memory;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  memory=NULL;\n  alignment=CACHE_LINE_SIZE;\n  size=count*quantum;\n  extent=AlignedExtent(size,alignment);\n  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  if (posix_memalign(&memory,alignment,extent) != 0)\n    memory=NULL;\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  memory=_aligned_malloc(extent,alignment);\n#else\n  {\n    void\n      *p;\n\n    extent=(size+alignment-1)+sizeof(void *);\n    if (extent > size)\n      {\n        p=malloc(extent);\n        if (p != NULL)\n          {\n            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);\n            *((void **) memory-1)=p;\n          }\n      }\n  }\n#endif\n  return(memory);\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e B l o c k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireBlock() returns a pointer to a block of memory at least size bytes\n%  suitably aligned for any use.\n%\n%  The format of the AcquireBlock method is:\n%\n%      void *AcquireBlock(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\n\nstatic inline size_t AllocationPolicy(size_t size)\n{\n  register size_t\n    blocksize;\n\n  /*\n    The linear distribution.\n  */\n  assert(size != 0);\n  assert(size % (4*sizeof(size_t)) == 0);\n  if (size <= BlockThreshold)\n    return(size/(4*sizeof(size_t)));\n  /*\n    Check for the largest block size.\n  */\n  if (size > (size_t) (BlockThreshold*(1L << (MaxBlockExponent-1L))))\n    return(MaxBlocks-1L);\n  /*\n    Otherwise use a power of two distribution.\n  */\n  blocksize=BlockThreshold/(4*sizeof(size_t));\n  for ( ; size > BlockThreshold; size/=2)\n    blocksize++;\n  assert(blocksize > (BlockThreshold/(4*sizeof(size_t))));\n  assert(blocksize < (MaxBlocks-1L));\n  return(blocksize);\n}\n\nstatic inline void InsertFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  size_t\n    size;\n\n  size=SizeOfBlock(block);\n  previous=(void *) NULL;\n  next=memory_pool.blocks[i];\n  while ((next != (void *) NULL) && (SizeOfBlock(next) < size))\n  {\n    previous=next;\n    next=NextBlockInList(next);\n  }\n  PreviousBlockInList(block)=previous;\n  NextBlockInList(block)=next;\n  if (previous != (void *) NULL)\n    NextBlockInList(previous)=block;\n  else\n    memory_pool.blocks[i]=block;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=block;\n}\n\nstatic inline void RemoveFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  next=NextBlockInList(block);\n  previous=PreviousBlockInList(block);\n  if (previous == (void *) NULL)\n    memory_pool.blocks[i]=next;\n  else\n    NextBlockInList(previous)=next;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=previous;\n}\n\nstatic void *AcquireBlock(size_t size)\n{\n  register size_t\n    i;\n\n  register void\n    *block;\n\n  /*\n    Find free block.\n  */\n  size=(size_t) (size+sizeof(size_t)+6*sizeof(size_t)-1) & -(4U*sizeof(size_t));\n  i=AllocationPolicy(size);\n  block=memory_pool.blocks[i];\n  while ((block != (void *) NULL) && (SizeOfBlock(block) < size))\n    block=NextBlockInList(block);\n  if (block == (void *) NULL)\n    {\n      i++;\n      while (memory_pool.blocks[i] == (void *) NULL)\n        i++;\n      block=memory_pool.blocks[i];\n      if (i >= MaxBlocks)\n        return((void *) NULL);\n    }\n  assert((*BlockHeader(NextBlock(block)) & PreviousBlockBit) == 0);\n  assert(SizeOfBlock(block) >= size);\n  RemoveFreeBlock(block,AllocationPolicy(SizeOfBlock(block)));\n  if (SizeOfBlock(block) > size)\n    {\n      size_t\n        blocksize;\n\n      void\n        *next;\n\n      /*\n        Split block.\n      */\n      next=(char *) block+size;\n      blocksize=SizeOfBlock(block)-size;\n      *BlockHeader(next)=blocksize;\n      *BlockFooter(next,blocksize)=blocksize;\n      InsertFreeBlock(next,AllocationPolicy(blocksize));\n      *BlockHeader(block)=size | (*BlockHeader(block) & ~SizeMask);\n    }\n  assert(size == SizeOfBlock(block));\n  *BlockHeader(NextBlock(block))|=PreviousBlockBit;\n  memory_pool.allocation+=size;\n  return(block);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireMagickMemory() returns a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireMagickMemory method is:\n%\n%      void *AcquireMagickMemory(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *AcquireMagickMemory(const size_t size)\n{\n  register void\n    *memory;\n\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory=memory_methods.acquire_memory_handler(size == 0 ? 1UL : size);\n#else\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  if (free_segments == (DataSegmentInfo *) NULL)\n    {\n      LockSemaphoreInfo(memory_semaphore);\n      if (free_segments == (DataSegmentInfo *) NULL)\n        {\n          register ssize_t\n            i;\n\n          assert(2*sizeof(size_t) > (size_t) (~SizeMask));\n          (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n          memory_pool.allocation=SegmentSize;\n          memory_pool.blocks[MaxBlocks]=(void *) (-1);\n          for (i=0; i < MaxSegments; i++)\n          {\n            if (i != 0)\n              memory_pool.segment_pool[i].previous=\n                (&memory_pool.segment_pool[i-1]);\n            if (i != (MaxSegments-1))\n              memory_pool.segment_pool[i].next=(&memory_pool.segment_pool[i+1]);\n          }\n          free_segments=(&memory_pool.segment_pool[0]);\n        }\n      UnlockSemaphoreInfo(memory_semaphore);\n    }\n  LockSemaphoreInfo(memory_semaphore);\n  memory=AcquireBlock(size == 0 ? 1UL : size);\n  if (memory == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) != MagickFalse)\n        memory=AcquireBlock(size == 0 ? 1UL : size);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return(memory);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t u m M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumMemory() returns a pointer to a block of memory at least\n%  count * quantum bytes suitably aligned for any use.\n%\n%  The format of the AcquireQuantumMemory method is:\n%\n%      void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e V i r t u a l M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireVirtualMemory() allocates a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireVirtualMemory method is:\n%\n%      MemoryInfo *AcquireVirtualMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickCoreSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      /*\n        Heap memory failed, try anonymous memory mapping.\n      */\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n\n          /*\n            Anonymous memory mapping failed, try file-backed memory mapping.\n            If the MapResource request failed, there is no point in trying\n            file-backed memory mapping.\n          */\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              if ((lseek(file,extent-1,SEEK_SET) == (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              /*\n                File-backed memory mapping failed, delete the temporary file.\n              */\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename = '\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y M a g i c k M e m o r y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyMagickMemory() copies size bytes from memory area source to the\n%  destination.  Copying between objects that overlap will take place\n%  correctly.  It returns destination.\n%\n%  The format of the CopyMagickMemory method is:\n%\n%      void *CopyMagickMemory(void *destination,const void *source,\n%        const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o destination: the destination.\n%\n%    o source: the source.\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *CopyMagickMemory(void *destination,const void *source,\n  const size_t size)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  assert(destination != (void *) NULL);\n  assert(source != (const void *) NULL);\n  p=(const unsigned char *) source;\n  q=(unsigned char *) destination;\n  if (((q+size) < p) || (q > (p+size)))\n    switch (size)\n    {\n      default: return(memcpy(destination,source,size));\n      case 8: *q++=(*p++);\n      case 7: *q++=(*p++);\n      case 6: *q++=(*p++);\n      case 5: *q++=(*p++);\n      case 4: *q++=(*p++);\n      case 3: *q++=(*p++);\n      case 2: *q++=(*p++);\n      case 1: *q++=(*p++);\n      case 0: return(destination);\n    }\n  return(memmove(destination,source,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyMagickMemory() deallocates memory associated with the memory manager.\n%\n%  The format of the DestroyMagickMemory method is:\n%\n%      DestroyMagickMemory(void)\n%\n*/\nMagickExport void DestroyMagickMemory(void)\n{\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  register ssize_t\n    i;\n\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  LockSemaphoreInfo(memory_semaphore);\n  for (i=0; i < (ssize_t) memory_pool.number_segments; i++)\n    if (memory_pool.segments[i]->mapped == MagickFalse)\n      memory_methods.destroy_memory_handler(\n        memory_pool.segments[i]->allocation);\n    else\n      (void) UnmapBlob(memory_pool.segments[i]->allocation,\n        memory_pool.segments[i]->length);\n  free_segments=(DataSegmentInfo *) NULL;\n  (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n  UnlockSemaphoreInfo(memory_semaphore);\n  RelinquishSemaphoreInfo(&memory_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   E x p a n d H e a p                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExpandHeap() get more memory from the system.  It returns MagickTrue on\n%  success otherwise MagickFalse.\n%\n%  The format of the ExpandHeap method is:\n%\n%      MagickBooleanType ExpandHeap(size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes we require.\n%\n*/\nstatic MagickBooleanType ExpandHeap(size_t size)\n{\n  DataSegmentInfo\n    *segment_info;\n\n  MagickBooleanType\n    mapped;\n\n  register ssize_t\n    i;\n\n  register void\n    *block;\n\n  size_t\n    blocksize;\n\n  void\n    *segment;\n\n  blocksize=((size+12*sizeof(size_t))+SegmentSize-1) & -SegmentSize;\n  assert(memory_pool.number_segments < MaxSegments);\n  segment=MapBlob(-1,IOMode,0,blocksize);\n  mapped=segment != (void *) NULL ? MagickTrue : MagickFalse;\n  if (segment == (void *) NULL)\n    segment=(void *) memory_methods.acquire_memory_handler(blocksize);\n  if (segment == (void *) NULL)\n    return(MagickFalse);\n  segment_info=(DataSegmentInfo *) free_segments;\n  free_segments=segment_info->next;\n  segment_info->mapped=mapped;\n  segment_info->length=blocksize;\n  segment_info->allocation=segment;\n  segment_info->bound=(char *) segment+blocksize;\n  i=(ssize_t) memory_pool.number_segments-1;\n  for ( ; (i >= 0) && (memory_pool.segments[i]->allocation > segment); i--)\n    memory_pool.segments[i+1]=memory_pool.segments[i];\n  memory_pool.segments[i+1]=segment_info;\n  memory_pool.number_segments++;\n  size=blocksize-12*sizeof(size_t);\n  block=(char *) segment_info->allocation+4*sizeof(size_t);\n  *BlockHeader(block)=size | PreviousBlockBit;\n  *BlockFooter(block,size)=size;\n  InsertFreeBlock(block,AllocationPolicy(size));\n  block=NextBlock(block);\n  assert(block < segment_info->bound);\n  *BlockHeader(block)=2*sizeof(size_t);\n  *BlockHeader(NextBlock(block))=PreviousBlockBit;\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickMemoryMethods() gets the methods to acquire, resize, and destroy\n%  memory.\n%\n%  The format of the GetMagickMemoryMethods() method is:\n%\n%      void GetMagickMemoryMethods(AcquireMemoryHandler *acquire_memory_handler,\n%        ResizeMemoryHandler *resize_memory_handler,\n%        DestroyMemoryHandler *destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void GetMagickMemoryMethods(\n  AcquireMemoryHandler *acquire_memory_handler,\n  ResizeMemoryHandler *resize_memory_handler,\n  DestroyMemoryHandler *destroy_memory_handler)\n{\n  assert(acquire_memory_handler != (AcquireMemoryHandler *) NULL);\n  assert(resize_memory_handler != (ResizeMemoryHandler *) NULL);\n  assert(destroy_memory_handler != (DestroyMemoryHandler *) NULL);\n  *acquire_memory_handler=memory_methods.acquire_memory_handler;\n  *resize_memory_handler=memory_methods.resize_memory_handler;\n  *destroy_memory_handler=memory_methods.destroy_memory_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l M e m o r y B l o b                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMemoryBlob() returns the virtual memory blob associated with the\n%  specified MemoryInfo structure.\n%\n%  The format of the GetVirtualMemoryBlob method is:\n%\n%      void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: The MemoryInfo structure.\n*/\nMagickExport void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n{\n  assert(memory_info != (const MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickCoreSignature);\n  return(memory_info->blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h A l i g n e d M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishAlignedMemory() frees memory acquired with AcquireAlignedMemory()\n%  or reuse.\n%\n%  The format of the RelinquishAlignedMemory method is:\n%\n%      void *RelinquishAlignedMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishAlignedMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  free(memory);\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  _aligned_free(memory);\n#else\n  free(*((void **) memory-1));\n#endif\n  return(NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h M a g i c k M e m o r y                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishMagickMemory() frees memory acquired with AcquireMagickMemory()\n%  or AcquireQuantumMemory() for reuse.\n%\n%  The format of the RelinquishMagickMemory method is:\n%\n%      void *RelinquishMagickMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishMagickMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory_methods.destroy_memory_handler(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  assert((SizeOfBlock(memory) % (4*sizeof(size_t))) == 0);\n  assert((*BlockHeader(NextBlock(memory)) & PreviousBlockBit) != 0);\n  if ((*BlockHeader(memory) & PreviousBlockBit) == 0)\n    {\n      void\n        *previous;\n\n      /*\n        Coalesce with previous adjacent block.\n      */\n      previous=PreviousBlock(memory);\n      RemoveFreeBlock(previous,AllocationPolicy(SizeOfBlock(previous)));\n      *BlockHeader(previous)=(SizeOfBlock(previous)+SizeOfBlock(memory)) |\n        (*BlockHeader(previous) & ~SizeMask);\n      memory=previous;\n    }\n  if ((*BlockHeader(NextBlock(NextBlock(memory))) & PreviousBlockBit) == 0)\n    {\n      void\n        *next;\n\n      /*\n        Coalesce with next adjacent block.\n      */\n      next=NextBlock(memory);\n      RemoveFreeBlock(next,AllocationPolicy(SizeOfBlock(next)));\n      *BlockHeader(memory)=(SizeOfBlock(memory)+SizeOfBlock(next)) |\n        (*BlockHeader(memory) & ~SizeMask);\n    }\n  *BlockFooter(memory,SizeOfBlock(memory))=SizeOfBlock(memory);\n  *BlockHeader(NextBlock(memory))&=(~PreviousBlockBit);\n  InsertFreeBlock(memory,AllocationPolicy(SizeOfBlock(memory)));\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return((void *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h V i r t u a l M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishVirtualMemory() frees memory acquired with AcquireVirtualMemory().\n%\n%  The format of the RelinquishVirtualMemory method is:\n%\n%      MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n{\n  assert(memory_info != (MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickCoreSignature);\n  if (memory_info->blob != (void *) NULL)\n    switch (memory_info->type)\n    {\n      case AlignedVirtualMemory:\n      {\n        memory_info->blob=RelinquishAlignedMemory(memory_info->blob);\n        RelinquishMagickResource(MemoryResource,memory_info->length);\n        break;\n      }\n      case MapVirtualMemory:\n      {\n        (void) UnmapBlob(memory_info->blob,memory_info->length);\n        memory_info->blob=NULL;\n        RelinquishMagickResource(MapResource,memory_info->length);\n        if (*memory_info->filename != '\\0')\n          {\n            (void) RelinquishUniqueFileResource(memory_info->filename);\n            RelinquishMagickResource(DiskResource,memory_info->length);\n          }\n        break;\n      }\n      case UnalignedVirtualMemory:\n      default:\n      {\n        memory_info->blob=RelinquishMagickMemory(memory_info->blob);\n        break;\n      }\n    }\n  memory_info->signature=(~MagickCoreSignature);\n  memory_info=(MemoryInfo *) RelinquishAlignedMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t M a g i c k M e m o r y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetMagickMemory() fills the first size bytes of the memory area pointed to\n%  by memory with the constant byte c.\n%\n%  The format of the ResetMagickMemory method is:\n%\n%      void *ResetMagickMemory(void *memory,int byte,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: a pointer to a memory allocation.\n%\n%    o byte: set the memory to this value.\n%\n%    o size: size of the memory to reset.\n%\n*/\nMagickExport void *ResetMagickMemory(void *memory,int byte,const size_t size)\n{\n  assert(memory != (void *) NULL);\n  return(memset(memory,byte,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e M a g i c k M e m o r y                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeMagickMemory() changes the size of the memory and returns a pointer to\n%  the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeMagickMemory method is:\n%\n%      void *ResizeMagickMemory(void *memory,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o size: the new size of the allocated memory.\n%\n*/\n\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic inline void *ResizeBlock(void *block,size_t size)\n{\n  register void\n    *memory;\n\n  if (block == (void *) NULL)\n    return(AcquireBlock(size));\n  memory=AcquireBlock(size);\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n  if (size <= (SizeOfBlock(block)-sizeof(size_t)))\n    (void) memcpy(memory,block,size);\n  else\n    (void) memcpy(memory,block,SizeOfBlock(block)-sizeof(size_t));\n  memory_pool.allocation+=size;\n  return(memory);\n}\n#endif\n\nMagickExport void *ResizeMagickMemory(void *memory,const size_t size)\n{\n  register void\n    *block;\n\n  if (memory == (void *) NULL)\n    return(AcquireMagickMemory(size));\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  block=memory_methods.resize_memory_handler(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    memory=RelinquishMagickMemory(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  block=ResizeBlock(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) == MagickFalse)\n        {\n          UnlockSemaphoreInfo(memory_semaphore);\n          memory=RelinquishMagickMemory(memory);\n          ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n        }\n      block=ResizeBlock(memory,size == 0 ? 1UL : size);\n      assert(block != (void *) NULL);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n  memory=RelinquishMagickMemory(memory);\n#endif\n  return(block);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e Q u a n t u m M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeQuantumMemory() changes the size of the memory and returns a pointer\n%  to the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeQuantumMemory method is:\n%\n%      void *ResizeQuantumMemory(void *memory,const size_t count,\n%        const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetMagickMemoryMethods() sets the methods to acquire, resize, and destroy\n%  memory. Your custom memory methods must be set prior to the\n%  MagickCoreGenesis() method.\n%\n%  The format of the SetMagickMemoryMethods() method is:\n%\n%      SetMagickMemoryMethods(AcquireMemoryHandler acquire_memory_handler,\n%        ResizeMemoryHandler resize_memory_handler,\n%        DestroyMemoryHandler destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void SetMagickMemoryMethods(\n  AcquireMemoryHandler acquire_memory_handler,\n  ResizeMemoryHandler resize_memory_handler,\n  DestroyMemoryHandler destroy_memory_handler)\n{\n  /*\n    Set memory methods.\n  */\n  if (acquire_memory_handler != (AcquireMemoryHandler) NULL)\n    memory_methods.acquire_memory_handler=acquire_memory_handler;\n  if (resize_memory_handler != (ResizeMemoryHandler) NULL)\n    memory_methods.resize_memory_handler=resize_memory_handler;\n  if (destroy_memory_handler != (DestroyMemoryHandler) NULL)\n    memory_methods.destroy_memory_handler=destroy_memory_handler;\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%                   IIIII  M   M  PPPP    OOO   RRRR   TTTTT                  %\n%                     I    MM MM  P   P  O   O  R   R    T                    %\n%                     I    M M M  PPPP   O   O  RRRR     T                    %\n%                     I    M   M  P      O   O  R R      T                    %\n%                   IIIII  M   M  P       OOO   R  R     T                    %\n%                                                                             %\n%                 MagickCore Methods to Import Quantum Pixels                 %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m p o r t Q u a n t u m P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImportQuantumPixels() transfers one or more pixel components from a user\n%  supplied buffer into the image pixel cache of an image.  The pixels are\n%  expected in network byte order.  It returns MagickTrue if the pixels are\n%  successfully transferred, otherwise MagickFalse.\n%\n%  The format of the ImportQuantumPixels method is:\n%\n%      size_t ImportQuantumPixels(const Image *image,CacheView *image_view,\n%        QuantumInfo *quantum_info,const QuantumType quantum_type,\n%        const unsigned char *magick_restrict pixels,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o image_view: the image cache view.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n%    o pixels:  The pixel components are transferred from this buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PushColormapIndex(const Image *image,const size_t index,\n  MagickBooleanType *range_exception)\n{\n  if (index < image->colors)\n    return((Quantum) index);\n  *range_exception=MagickTrue;\n  return((Quantum) 0);\n}\n\nstatic inline const unsigned char *PushDoublePixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,double *pixel)\n{\n  double\n    *p;\n\n  unsigned char\n    quantum[8];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      quantum[4]=(*pixels++);\n      quantum[5]=(*pixels++);\n      quantum[6]=(*pixels++);\n      quantum[7]=(*pixels++);\n      p=(double *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[7]=(*pixels++);\n  quantum[6]=(*pixels++);\n  quantum[5]=(*pixels++);\n  quantum[4]=(*pixels++);\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(double *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushFloatPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,float *pixel)\n{\n  float\n    *p;\n\n  unsigned char\n    quantum[4];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      p=(float *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(float *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=(QuantumAny) 0;\n  for (i=(ssize_t) quantum_info->depth; i > 0L; )\n  {\n    if (quantum_info->state.bits == 0UL)\n      {\n        quantum_info->state.pixel=(*pixels++);\n        quantum_info->state.bits=8UL;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n    *quantum=(unsigned int) ((*quantum << quantum_bits) |\n      ((quantum_info->state.pixel >> quantum_info->state.bits) &~ ((~0UL) <<\n      quantum_bits)));\n  }\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumLongPixel(\n  QuantumInfo *quantum_info,const unsigned char *magick_restrict pixels,\n  unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=0UL;\n  for (i=(ssize_t) quantum_info->depth; i > 0; )\n  {\n    if (quantum_info->state.bits == 0)\n      {\n        pixels=PushLongPixel(quantum_info->endian,pixels,\n          &quantum_info->state.pixel);\n        quantum_info->state.bits=32U;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    *quantum|=(((quantum_info->state.pixel >> (32U-quantum_info->state.bits)) &\n      quantum_info->state.mask[quantum_bits]) << (quantum_info->depth-i));\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n  }\n  return(pixels);\n}\n\nstatic void ImportAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGROQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlackQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlueQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 10:\n    {\n      Quantum\n        cbcr[4];\n\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x+=4)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              cbcr[i]=(Quantum) (quantum);\n              n++;\n            }\n            p+=quantum_info->pad;\n            SetPixelRed(image,cbcr[1],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n            SetPixelRed(image,cbcr[3],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      bit=0;\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel != 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGreenQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ?\n              0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ?\n              0x00 : 0x01);\n          SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),\n            q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n            GetPixelIndex(image,q),q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        if (quantum_info->min_is_white == MagickFalse)\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n        else\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) ((*p++ >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportIndexAlphaQuantum(const Image *image,\n  QuantumInfo *quantum_info,const MagickSizeType number_pixels,\n  const unsigned char *magick_restrict p,Quantum *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          q+=GetPixelChannels(image);\n        }\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,\n              ClampToQuantum(pixel),&range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportOpacityQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRedQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nMagickExport size_t ImportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,const unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  register const unsigned char\n    *magick_restrict p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (const unsigned char *) NULL)\n    pixels=(const unsigned char *) GetQuantumPixels(quantum_info);\n  x=0;\n  p=pixels;\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      q=GetAuthenticPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_view);\n      q=GetCacheViewAuthenticPixelQueue(image_view);\n    }\n  ResetQuantumState(quantum_info);\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  switch (quantum_type)\n  {\n    case AlphaQuantum:\n    {\n      ImportAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRQuantum:\n    {\n      ImportBGRQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRAQuantum:\n    {\n      ImportBGRAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGROQuantum:\n    {\n      ImportBGROQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlackQuantum:\n    {\n      ImportBlackQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlueQuantum:\n    case YellowQuantum:\n    {\n      ImportBlueQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKQuantum:\n    {\n      ImportCMYKQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKAQuantum:\n    {\n      ImportCMYKAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKOQuantum:\n    {\n      ImportCMYKOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CbYCrYQuantum:\n    {\n      ImportCbYCrYQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayQuantum:\n    {\n      ImportGrayQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayAlphaQuantum:\n    {\n      ImportGrayAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GreenQuantum:\n    case MagentaQuantum:\n    {\n      ImportGreenQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexQuantum:\n    {\n      ImportIndexQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexAlphaQuantum:\n    {\n      ImportIndexAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case OpacityQuantum:\n    {\n      ImportOpacityQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RedQuantum:\n    case CyanQuantum:\n    {\n      ImportRedQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBQuantum:\n    case CbYCrQuantum:\n    {\n      ImportRGBQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBAQuantum:\n    case CbYCrAQuantum:\n    {\n      ImportRGBAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBOQuantum:\n    {\n      ImportRGBOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    default:\n      break;\n  }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      register Quantum\n        *magick_restrict q;\n\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  if (quantum_info->alpha_type == DisassociatedQuantumAlpha)\n    {\n      double\n        gamma,\n        Sa;\n\n      register Quantum\n        *magick_restrict q;\n\n      /*\n        Disassociate alpha.\n      */\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        register ssize_t\n          i;\n\n        if (GetPixelReadMask(image,q) == 0)\n          {\n            q+=GetPixelChannels(image);\n            continue;\n          }\n        Sa=QuantumScale*GetPixelAlpha(image,q);\n        gamma=PerceptibleReciprocal(Sa);\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          if ((channel == AlphaPixelChannel) ||\n              ((traits & UpdatePixelTrait) == 0))\n            continue;\n          q[i]=ClampToQuantum(gamma*q[i]);\n        }\n        q+=GetPixelChannels(image);\n      }\n    }\n  return(extent);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        V   V  IIIII  FFFFF  FFFFF                           %\n%                        V   V    I    F      F                               %\n%                        V   V    I    FFF    FFF                             %\n%                         V V     I    F      F                               %\n%                          V    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write Khoros Visualization Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteVIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s V I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsVIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is VIFF.\n%\n%  The format of the IsVIFF method is:\n%\n%      MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\253\\001\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d V I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadVIFFImage() reads a Khoros Visualization image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadVIFFImage method is:\n%\n%      Image *ReadVIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadVIFFImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : \n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n    else\n      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n                  \n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r V I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterVIFFImage() adds properties for the VIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterVIFFImage method is:\n%\n%      size_t RegisterVIFFImage(void)\n%\n*/\nModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"VIFF\",\"VIFF\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"VIFF\",\"XV\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r V I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterVIFFImage() removes format registrations made by the\n%  VIFF module from the list of supported formats.\n%\n%  The format of the UnregisterVIFFImage method is:\n%\n%      UnregisterVIFFImage(void)\n%\n*/\nModuleExport void UnregisterVIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"VIFF\");\n  (void) UnregisterMagickInfo(\"XV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e V I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteVIFFImage() writes an image to a file in the VIFF image format.\n%\n%  The format of the WriteVIFFImage method is:\n%\n%      MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_NONE  0\n#define VFF_DEP_IEEEORDER  0x2\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n\n  typedef struct _ViffInfo\n  {\n    char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3],\n      comment[512];\n\n    size_t\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    unsigned int\n      x_bits_per_pixel,\n      y_bits_per_pixel,\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels,\n    packets;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) ResetMagickMemory(&viff_info,0,sizeof(ViffInfo));\n  scene=0;\n  do\n  {\n    /*\n      Initialize VIFF image structure.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\nDisableMSCWarning(4310)\n    viff_info.identifier=(char) 0xab;\nRestoreMSCWarning\n    viff_info.file_type=1;\n    viff_info.release=1;\n    viff_info.version=3;\n    viff_info.machine_dependency=VFF_DEP_IEEEORDER;  /* IEEE byte ordering */\n    *viff_info.comment='\\0';\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(viff_info.comment,value,MagickMin(strlen(value),\n        511)+1);\n    viff_info.rows=image->columns;\n    viff_info.columns=image->rows;\n    viff_info.subrows=0;\n    viff_info.x_offset=(~0);\n    viff_info.y_offset=(~0);\n    viff_info.x_bits_per_pixel=0;\n    viff_info.y_bits_per_pixel=0;\n    viff_info.location_type=VFF_LOC_IMPLICIT;\n    viff_info.location_dimension=0;\n    viff_info.number_of_images=1;\n    viff_info.data_encode_scheme=VFF_DES_RAW;\n    viff_info.map_scheme=VFF_MS_NONE;\n    viff_info.map_storage_type=VFF_MAPTYP_NONE;\n    viff_info.map_rows=0;\n    viff_info.map_columns=0;\n    viff_info.map_subrows=0;\n    viff_info.map_enable=1;  /* no colormap */\n    viff_info.maps_per_cycle=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color VIFF raster.\n        */\n        viff_info.number_data_bands=image->alpha_trait ? 4U : 3U;\n        viff_info.color_space_model=VFF_CM_genericRGB;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=viff_info.number_data_bands*number_pixels;\n      }\n    else\n      {\n        viff_info.number_data_bands=1;\n        viff_info.color_space_model=VFF_CM_NONE;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=number_pixels;\n        if (SetImageGray(image,exception) == MagickFalse)\n          {\n            /*\n              Colormapped VIFF raster.\n            */\n            viff_info.map_scheme=VFF_MS_ONEPERBAND;\n            viff_info.map_storage_type=VFF_MAPTYP_1_BYTE;\n            viff_info.map_rows=3;\n            viff_info.map_columns=(unsigned int) image->colors;\n          }\n        else\n          if (image->colors <= 2)\n            {\n              /*\n                Monochrome VIFF raster.\n              */\n              viff_info.data_storage_type=VFF_TYP_BIT;\n              packets=((image->columns+7) >> 3)*image->rows;\n            }\n      }\n    /*\n      Write VIFF image header (pad to 1024 bytes).\n    */\n    (void) WriteBlob(image,sizeof(viff_info.identifier),(unsigned char *)\n      &viff_info.identifier);\n    (void) WriteBlob(image,sizeof(viff_info.file_type),(unsigned char *)\n      &viff_info.file_type);\n    (void) WriteBlob(image,sizeof(viff_info.release),(unsigned char *)\n      &viff_info.release);\n    (void) WriteBlob(image,sizeof(viff_info.version),(unsigned char *)\n      &viff_info.version);\n    (void) WriteBlob(image,sizeof(viff_info.machine_dependency),\n      (unsigned char *) &viff_info.machine_dependency);\n    (void) WriteBlob(image,sizeof(viff_info.reserve),(unsigned char *)\n      viff_info.reserve);\n    (void) WriteBlob(image,512,(unsigned char *) viff_info.comment);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_offset);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_offset);\n    viff_info.x_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_bits_per_pixel);\n    viff_info.y_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_bits_per_pixel);\n    (void) WriteBlobMSBLong(image,viff_info.location_type);\n    (void) WriteBlobMSBLong(image,viff_info.location_dimension);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_of_images);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_data_bands);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_encode_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_enable);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.maps_per_cycle);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.color_space_model);\n    for (i=0; i < 420; i++)\n      (void) WriteBlobByte(image,'\\0');\n    /*\n      Convert MIFF to VIFF raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) packets,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert DirectClass packet to VIFF RGB pixel.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q=ScaleQuantumToChar(GetPixelRed(image,p));\n            *(q+number_pixels)=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *(q+number_pixels*2)=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *(q+number_pixels*3)=ScaleQuantumToChar((Quantum)\n                (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n            q++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (SetImageGray(image,exception) == MagickFalse)\n        {\n          unsigned char\n            *viff_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n            3*sizeof(*viff_colormap));\n          if (viff_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=viff_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n          (void) WriteBlob(image,3*image->colors,viff_colormap);\n          viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n          /*\n            Convert PseudoClass packet to VIFF colormapped pixels.\n          */\n          q=pixels;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        if (image->colors <= 2)\n          {\n            ssize_t\n              x,\n              y;\n\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a VIFF monochrome image.\n            */\n            (void) SetImageType(image,BilevelType,exception);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte>>=1;\n                if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                  byte|=0x80;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte >> (8-bit);\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          {\n            /*\n              Convert PseudoClass packet to VIFF grayscale pixel.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=(unsigned char) ClampToQuantum(GetPixelLuma(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n    (void) WriteBlob(image,(size_t) packets,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                    M   M  EEEEE  M   M   OOO   RRRR   Y   Y                 %\n%                    MM MM  E      MM MM  O   O  R   R   Y Y                  %\n%                    M M M  EEE    M M M  O   O  RRRR     Y                   %\n%                    M   M  E      M   M  O   O  R R      Y                   %\n%                    M   M  EEEEE  M   M   OOO   R  R     Y                   %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Memory Allocation Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1998                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Segregate our memory requirements from any program that calls our API.  This\n%  should help reduce the risk of others changing our program state or causing\n%  memory corruption.\n%\n%  Our custom memory allocation manager implements a best-fit allocation policy\n%  using segregated free lists.  It uses a linear distribution of size classes\n%  for lower sizes and a power of two distribution of size classes at higher\n%  sizes.  It is based on the paper, \"Fast Memory Allocation using Lazy Fits.\"\n%  written by Yoo C. Chung.\n%\n%  By default, ANSI memory methods are called (e.g. malloc).  Use the\n%  custom memory allocator by defining MAGICKCORE_ZERO_CONFIGURATION_SUPPORT\n%  to allocate memory with private anonymous mapping rather than from the\n%  heap.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define BlockFooter(block,size) \\\n  ((size_t *) ((char *) (block)+(size)-2*sizeof(size_t)))\n#define BlockHeader(block)  ((size_t *) (block)-1)\n#define BlockSize  4096\n#define BlockThreshold  1024\n#define MaxBlockExponent  16\n#define MaxBlocks ((BlockThreshold/(4*sizeof(size_t)))+MaxBlockExponent+1)\n#define MaxSegments  1024\n#define MemoryGuard  ((0xdeadbeef << 31)+0xdeafdeed)\n#define NextBlock(block)  ((char *) (block)+SizeOfBlock(block))\n#define NextBlockInList(block)  (*(void **) (block))\n#define PreviousBlock(block)  ((char *) (block)-(*((size_t *) (block)-2)))\n#define PreviousBlockBit  0x01\n#define PreviousBlockInList(block)  (*((void **) (block)+1))\n#define SegmentSize  (2*1024*1024)\n#define SizeMask  (~0x01)\n#define SizeOfBlock(block)  (*BlockHeader(block) & SizeMask)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  UndefinedVirtualMemory,\n  AlignedVirtualMemory,\n  MapVirtualMemory,\n  UnalignedVirtualMemory\n} VirtualMemoryType;\n\ntypedef struct _DataSegmentInfo\n{\n  void\n    *allocation,\n    *bound;\n\n  MagickBooleanType\n    mapped;\n\n  size_t\n    length;\n\n  struct _DataSegmentInfo\n    *previous,\n    *next;\n} DataSegmentInfo;\n\ntypedef struct _MagickMemoryMethods\n{\n  AcquireMemoryHandler\n    acquire_memory_handler;\n\n  ResizeMemoryHandler\n    resize_memory_handler;\n\n  DestroyMemoryHandler\n    destroy_memory_handler;\n} MagickMemoryMethods;\n\nstruct _MemoryInfo\n{\n  char\n    filename[MagickPathExtent];\n\n  VirtualMemoryType\n    type;\n\n  size_t\n    length;\n\n  void\n    *blob;\n\n  size_t\n    signature;\n};\n\ntypedef struct _MemoryPool\n{\n  size_t\n    allocation;\n\n  void\n    *blocks[MaxBlocks+1];\n\n  size_t\n    number_segments;\n\n  DataSegmentInfo\n    *segments[MaxSegments],\n    segment_pool[MaxSegments];\n} MemoryPool;\n\f\n/*\n  Global declarations.\n*/\n#if defined _MSC_VER\nstatic void* MSCMalloc(size_t size)\n{\n  return malloc(size);\n}\nstatic void* MSCRealloc(void* ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\nstatic void MSCFree(void* ptr)\n{\n  free(ptr);\n}\n#endif\n\nstatic MagickMemoryMethods\n  memory_methods =\n  {\n#if defined _MSC_VER\n    (AcquireMemoryHandler) MSCMalloc,\n    (ResizeMemoryHandler) MSCRealloc,\n    (DestroyMemoryHandler) MSCFree\n#else\n    (AcquireMemoryHandler) malloc,\n    (ResizeMemoryHandler) realloc,\n    (DestroyMemoryHandler) free\n#endif\n  };\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic MemoryPool\n  memory_pool;\n\nstatic SemaphoreInfo\n  *memory_semaphore = (SemaphoreInfo *) NULL;\n\nstatic volatile DataSegmentInfo\n  *free_segments = (DataSegmentInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  ExpandHeap(size_t);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e A l i g n e d M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireAlignedMemory() returns a pointer to a block of memory at least size\n%  bytes whose address is a multiple of 16*sizeof(void *).\n%\n%  The format of the AcquireAlignedMemory method is:\n%\n%      void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\n\nstatic MagickBooleanType CheckMemoryOverflow(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\nMagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n{\n#define AlignedExtent(size,alignment) \\\n  (((size)+((alignment)-1)) & ~((alignment)-1))\n\n  size_t\n    alignment,\n    extent,\n    size;\n\n  void\n    *memory;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  memory=NULL;\n  alignment=CACHE_LINE_SIZE;\n  size=count*quantum;\n  extent=AlignedExtent(size,alignment);\n  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  if (posix_memalign(&memory,alignment,extent) != 0)\n    memory=NULL;\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  memory=_aligned_malloc(extent,alignment);\n#else\n  {\n    void\n      *p;\n\n    extent=(size+alignment-1)+sizeof(void *);\n    if (extent > size)\n      {\n        p=malloc(extent);\n        if (p != NULL)\n          {\n            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);\n            *((void **) memory-1)=p;\n          }\n      }\n  }\n#endif\n  return(memory);\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e B l o c k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireBlock() returns a pointer to a block of memory at least size bytes\n%  suitably aligned for any use.\n%\n%  The format of the AcquireBlock method is:\n%\n%      void *AcquireBlock(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\n\nstatic inline size_t AllocationPolicy(size_t size)\n{\n  register size_t\n    blocksize;\n\n  /*\n    The linear distribution.\n  */\n  assert(size != 0);\n  assert(size % (4*sizeof(size_t)) == 0);\n  if (size <= BlockThreshold)\n    return(size/(4*sizeof(size_t)));\n  /*\n    Check for the largest block size.\n  */\n  if (size > (size_t) (BlockThreshold*(1L << (MaxBlockExponent-1L))))\n    return(MaxBlocks-1L);\n  /*\n    Otherwise use a power of two distribution.\n  */\n  blocksize=BlockThreshold/(4*sizeof(size_t));\n  for ( ; size > BlockThreshold; size/=2)\n    blocksize++;\n  assert(blocksize > (BlockThreshold/(4*sizeof(size_t))));\n  assert(blocksize < (MaxBlocks-1L));\n  return(blocksize);\n}\n\nstatic inline void InsertFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  size_t\n    size;\n\n  size=SizeOfBlock(block);\n  previous=(void *) NULL;\n  next=memory_pool.blocks[i];\n  while ((next != (void *) NULL) && (SizeOfBlock(next) < size))\n  {\n    previous=next;\n    next=NextBlockInList(next);\n  }\n  PreviousBlockInList(block)=previous;\n  NextBlockInList(block)=next;\n  if (previous != (void *) NULL)\n    NextBlockInList(previous)=block;\n  else\n    memory_pool.blocks[i]=block;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=block;\n}\n\nstatic inline void RemoveFreeBlock(void *block,const size_t i)\n{\n  register void\n    *next,\n    *previous;\n\n  next=NextBlockInList(block);\n  previous=PreviousBlockInList(block);\n  if (previous == (void *) NULL)\n    memory_pool.blocks[i]=next;\n  else\n    NextBlockInList(previous)=next;\n  if (next != (void *) NULL)\n    PreviousBlockInList(next)=previous;\n}\n\nstatic void *AcquireBlock(size_t size)\n{\n  register size_t\n    i;\n\n  register void\n    *block;\n\n  /*\n    Find free block.\n  */\n  size=(size_t) (size+sizeof(size_t)+6*sizeof(size_t)-1) & -(4U*sizeof(size_t));\n  i=AllocationPolicy(size);\n  block=memory_pool.blocks[i];\n  while ((block != (void *) NULL) && (SizeOfBlock(block) < size))\n    block=NextBlockInList(block);\n  if (block == (void *) NULL)\n    {\n      i++;\n      while (memory_pool.blocks[i] == (void *) NULL)\n        i++;\n      block=memory_pool.blocks[i];\n      if (i >= MaxBlocks)\n        return((void *) NULL);\n    }\n  assert((*BlockHeader(NextBlock(block)) & PreviousBlockBit) == 0);\n  assert(SizeOfBlock(block) >= size);\n  RemoveFreeBlock(block,AllocationPolicy(SizeOfBlock(block)));\n  if (SizeOfBlock(block) > size)\n    {\n      size_t\n        blocksize;\n\n      void\n        *next;\n\n      /*\n        Split block.\n      */\n      next=(char *) block+size;\n      blocksize=SizeOfBlock(block)-size;\n      *BlockHeader(next)=blocksize;\n      *BlockFooter(next,blocksize)=blocksize;\n      InsertFreeBlock(next,AllocationPolicy(blocksize));\n      *BlockHeader(block)=size | (*BlockHeader(block) & ~SizeMask);\n    }\n  assert(size == SizeOfBlock(block));\n  *BlockHeader(NextBlock(block))|=PreviousBlockBit;\n  memory_pool.allocation+=size;\n  return(block);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireMagickMemory() returns a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireMagickMemory method is:\n%\n%      void *AcquireMagickMemory(const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *AcquireMagickMemory(const size_t size)\n{\n  register void\n    *memory;\n\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory=memory_methods.acquire_memory_handler(size == 0 ? 1UL : size);\n#else\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  if (free_segments == (DataSegmentInfo *) NULL)\n    {\n      LockSemaphoreInfo(memory_semaphore);\n      if (free_segments == (DataSegmentInfo *) NULL)\n        {\n          register ssize_t\n            i;\n\n          assert(2*sizeof(size_t) > (size_t) (~SizeMask));\n          (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n          memory_pool.allocation=SegmentSize;\n          memory_pool.blocks[MaxBlocks]=(void *) (-1);\n          for (i=0; i < MaxSegments; i++)\n          {\n            if (i != 0)\n              memory_pool.segment_pool[i].previous=\n                (&memory_pool.segment_pool[i-1]);\n            if (i != (MaxSegments-1))\n              memory_pool.segment_pool[i].next=(&memory_pool.segment_pool[i+1]);\n          }\n          free_segments=(&memory_pool.segment_pool[0]);\n        }\n      UnlockSemaphoreInfo(memory_semaphore);\n    }\n  LockSemaphoreInfo(memory_semaphore);\n  memory=AcquireBlock(size == 0 ? 1UL : size);\n  if (memory == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) != MagickFalse)\n        memory=AcquireBlock(size == 0 ? 1UL : size);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return(memory);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t u m M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumMemory() returns a pointer to a block of memory at least\n%  count * quantum bytes suitably aligned for any use.\n%\n%  The format of the AcquireQuantumMemory method is:\n%\n%      void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e V i r t u a l M e m o r y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireVirtualMemory() allocates a pointer to a block of memory at least size\n%  bytes suitably aligned for any use.\n%\n%  The format of the AcquireVirtualMemory method is:\n%\n%      MemoryInfo *AcquireVirtualMemory(const size_t count,const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickCoreSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      /*\n        Heap memory failed, try anonymous memory mapping.\n      */\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n\n          /*\n            Anonymous memory mapping failed, try file-backed memory mapping.\n            If the MapResource request failed, there is no point in trying\n            file-backed memory mapping.\n          */\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              if ((lseek(file,extent-1,SEEK_SET) == (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              /*\n                File-backed memory mapping failed, delete the temporary file.\n              */\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename = '\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y M a g i c k M e m o r y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyMagickMemory() copies size bytes from memory area source to the\n%  destination.  Copying between objects that overlap will take place\n%  correctly.  It returns destination.\n%\n%  The format of the CopyMagickMemory method is:\n%\n%      void *CopyMagickMemory(void *destination,const void *source,\n%        const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o destination: the destination.\n%\n%    o source: the source.\n%\n%    o size: the size of the memory in bytes to allocate.\n%\n*/\nMagickExport void *CopyMagickMemory(void *destination,const void *source,\n  const size_t size)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  assert(destination != (void *) NULL);\n  assert(source != (const void *) NULL);\n  p=(const unsigned char *) source;\n  q=(unsigned char *) destination;\n  if (((q+size) < p) || (q > (p+size)))\n    switch (size)\n    {\n      default: return(memcpy(destination,source,size));\n      case 8: *q++=(*p++);\n      case 7: *q++=(*p++);\n      case 6: *q++=(*p++);\n      case 5: *q++=(*p++);\n      case 4: *q++=(*p++);\n      case 3: *q++=(*p++);\n      case 2: *q++=(*p++);\n      case 1: *q++=(*p++);\n      case 0: return(destination);\n    }\n  return(memmove(destination,source,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y M a g i c k M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyMagickMemory() deallocates memory associated with the memory manager.\n%\n%  The format of the DestroyMagickMemory method is:\n%\n%      DestroyMagickMemory(void)\n%\n*/\nMagickExport void DestroyMagickMemory(void)\n{\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  register ssize_t\n    i;\n\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  LockSemaphoreInfo(memory_semaphore);\n  for (i=0; i < (ssize_t) memory_pool.number_segments; i++)\n    if (memory_pool.segments[i]->mapped == MagickFalse)\n      memory_methods.destroy_memory_handler(\n        memory_pool.segments[i]->allocation);\n    else\n      (void) UnmapBlob(memory_pool.segments[i]->allocation,\n        memory_pool.segments[i]->length);\n  free_segments=(DataSegmentInfo *) NULL;\n  (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n  UnlockSemaphoreInfo(memory_semaphore);\n  RelinquishSemaphoreInfo(&memory_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   E x p a n d H e a p                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExpandHeap() get more memory from the system.  It returns MagickTrue on\n%  success otherwise MagickFalse.\n%\n%  The format of the ExpandHeap method is:\n%\n%      MagickBooleanType ExpandHeap(size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o size: the size of the memory in bytes we require.\n%\n*/\nstatic MagickBooleanType ExpandHeap(size_t size)\n{\n  DataSegmentInfo\n    *segment_info;\n\n  MagickBooleanType\n    mapped;\n\n  register ssize_t\n    i;\n\n  register void\n    *block;\n\n  size_t\n    blocksize;\n\n  void\n    *segment;\n\n  blocksize=((size+12*sizeof(size_t))+SegmentSize-1) & -SegmentSize;\n  assert(memory_pool.number_segments < MaxSegments);\n  segment=MapBlob(-1,IOMode,0,blocksize);\n  mapped=segment != (void *) NULL ? MagickTrue : MagickFalse;\n  if (segment == (void *) NULL)\n    segment=(void *) memory_methods.acquire_memory_handler(blocksize);\n  if (segment == (void *) NULL)\n    return(MagickFalse);\n  segment_info=(DataSegmentInfo *) free_segments;\n  free_segments=segment_info->next;\n  segment_info->mapped=mapped;\n  segment_info->length=blocksize;\n  segment_info->allocation=segment;\n  segment_info->bound=(char *) segment+blocksize;\n  i=(ssize_t) memory_pool.number_segments-1;\n  for ( ; (i >= 0) && (memory_pool.segments[i]->allocation > segment); i--)\n    memory_pool.segments[i+1]=memory_pool.segments[i];\n  memory_pool.segments[i+1]=segment_info;\n  memory_pool.number_segments++;\n  size=blocksize-12*sizeof(size_t);\n  block=(char *) segment_info->allocation+4*sizeof(size_t);\n  *BlockHeader(block)=size | PreviousBlockBit;\n  *BlockFooter(block,size)=size;\n  InsertFreeBlock(block,AllocationPolicy(size));\n  block=NextBlock(block);\n  assert(block < segment_info->bound);\n  *BlockHeader(block)=2*sizeof(size_t);\n  *BlockHeader(NextBlock(block))=PreviousBlockBit;\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickMemoryMethods() gets the methods to acquire, resize, and destroy\n%  memory.\n%\n%  The format of the GetMagickMemoryMethods() method is:\n%\n%      void GetMagickMemoryMethods(AcquireMemoryHandler *acquire_memory_handler,\n%        ResizeMemoryHandler *resize_memory_handler,\n%        DestroyMemoryHandler *destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void GetMagickMemoryMethods(\n  AcquireMemoryHandler *acquire_memory_handler,\n  ResizeMemoryHandler *resize_memory_handler,\n  DestroyMemoryHandler *destroy_memory_handler)\n{\n  assert(acquire_memory_handler != (AcquireMemoryHandler *) NULL);\n  assert(resize_memory_handler != (ResizeMemoryHandler *) NULL);\n  assert(destroy_memory_handler != (DestroyMemoryHandler *) NULL);\n  *acquire_memory_handler=memory_methods.acquire_memory_handler;\n  *resize_memory_handler=memory_methods.resize_memory_handler;\n  *destroy_memory_handler=memory_methods.destroy_memory_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l M e m o r y B l o b                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMemoryBlob() returns the virtual memory blob associated with the\n%  specified MemoryInfo structure.\n%\n%  The format of the GetVirtualMemoryBlob method is:\n%\n%      void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: The MemoryInfo structure.\n*/\nMagickExport void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)\n{\n  assert(memory_info != (const MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickCoreSignature);\n  return(memory_info->blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h A l i g n e d M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishAlignedMemory() frees memory acquired with AcquireAlignedMemory()\n%  or reuse.\n%\n%  The format of the RelinquishAlignedMemory method is:\n%\n%      void *RelinquishAlignedMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishAlignedMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  free(memory);\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  _aligned_free(memory);\n#else\n  free(*((void **) memory-1));\n#endif\n  return(NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h M a g i c k M e m o r y                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishMagickMemory() frees memory acquired with AcquireMagickMemory()\n%  or AcquireQuantumMemory() for reuse.\n%\n%  The format of the RelinquishMagickMemory method is:\n%\n%      void *RelinquishMagickMemory(void *memory)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport void *RelinquishMagickMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  memory_methods.destroy_memory_handler(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  assert((SizeOfBlock(memory) % (4*sizeof(size_t))) == 0);\n  assert((*BlockHeader(NextBlock(memory)) & PreviousBlockBit) != 0);\n  if ((*BlockHeader(memory) & PreviousBlockBit) == 0)\n    {\n      void\n        *previous;\n\n      /*\n        Coalesce with previous adjacent block.\n      */\n      previous=PreviousBlock(memory);\n      RemoveFreeBlock(previous,AllocationPolicy(SizeOfBlock(previous)));\n      *BlockHeader(previous)=(SizeOfBlock(previous)+SizeOfBlock(memory)) |\n        (*BlockHeader(previous) & ~SizeMask);\n      memory=previous;\n    }\n  if ((*BlockHeader(NextBlock(NextBlock(memory))) & PreviousBlockBit) == 0)\n    {\n      void\n        *next;\n\n      /*\n        Coalesce with next adjacent block.\n      */\n      next=NextBlock(memory);\n      RemoveFreeBlock(next,AllocationPolicy(SizeOfBlock(next)));\n      *BlockHeader(memory)=(SizeOfBlock(memory)+SizeOfBlock(next)) |\n        (*BlockHeader(memory) & ~SizeMask);\n    }\n  *BlockFooter(memory,SizeOfBlock(memory))=SizeOfBlock(memory);\n  *BlockHeader(NextBlock(memory))&=(~PreviousBlockBit);\n  InsertFreeBlock(memory,AllocationPolicy(SizeOfBlock(memory)));\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return((void *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e l i n q u i s h V i r t u a l M e m o r y                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RelinquishVirtualMemory() frees memory acquired with AcquireVirtualMemory().\n%\n%  The format of the RelinquishVirtualMemory method is:\n%\n%      MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n%\n%  A description of each parameter follows:\n%\n%    o memory_info: A pointer to a block of memory to free for reuse.\n%\n*/\nMagickExport MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)\n{\n  assert(memory_info != (MemoryInfo *) NULL);\n  assert(memory_info->signature == MagickCoreSignature);\n  if (memory_info->blob != (void *) NULL)\n    switch (memory_info->type)\n    {\n      case AlignedVirtualMemory:\n      {\n        memory_info->blob=RelinquishAlignedMemory(memory_info->blob);\n        RelinquishMagickResource(MemoryResource,memory_info->length);\n        break;\n      }\n      case MapVirtualMemory:\n      {\n        (void) UnmapBlob(memory_info->blob,memory_info->length);\n        memory_info->blob=NULL;\n        RelinquishMagickResource(MapResource,memory_info->length);\n        if (*memory_info->filename != '\\0')\n          {\n            (void) RelinquishUniqueFileResource(memory_info->filename);\n            RelinquishMagickResource(DiskResource,memory_info->length);\n          }\n        break;\n      }\n      case UnalignedVirtualMemory:\n      default:\n      {\n        memory_info->blob=RelinquishMagickMemory(memory_info->blob);\n        break;\n      }\n    }\n  memory_info->signature=(~MagickCoreSignature);\n  memory_info=(MemoryInfo *) RelinquishAlignedMemory(memory_info);\n  return(memory_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t M a g i c k M e m o r y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetMagickMemory() fills the first size bytes of the memory area pointed to\n%  by memory with the constant byte c.\n%\n%  The format of the ResetMagickMemory method is:\n%\n%      void *ResetMagickMemory(void *memory,int byte,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: a pointer to a memory allocation.\n%\n%    o byte: set the memory to this value.\n%\n%    o size: size of the memory to reset.\n%\n*/\nMagickExport void *ResetMagickMemory(void *memory,int byte,const size_t size)\n{\n  assert(memory != (void *) NULL);\n  return(memset(memory,byte,size));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e M a g i c k M e m o r y                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeMagickMemory() changes the size of the memory and returns a pointer to\n%  the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeMagickMemory method is:\n%\n%      void *ResizeMagickMemory(void *memory,const size_t size)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o size: the new size of the allocated memory.\n%\n*/\n\n#if defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\nstatic inline void *ResizeBlock(void *block,size_t size)\n{\n  register void\n    *memory;\n\n  if (block == (void *) NULL)\n    return(AcquireBlock(size));\n  memory=AcquireBlock(size);\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n  if (size <= (SizeOfBlock(block)-sizeof(size_t)))\n    (void) memcpy(memory,block,size);\n  else\n    (void) memcpy(memory,block,SizeOfBlock(block)-sizeof(size_t));\n  memory_pool.allocation+=size;\n  return(memory);\n}\n#endif\n\nMagickExport void *ResizeMagickMemory(void *memory,const size_t size)\n{\n  register void\n    *block;\n\n  if (memory == (void *) NULL)\n    return(AcquireMagickMemory(size));\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  block=memory_methods.resize_memory_handler(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    memory=RelinquishMagickMemory(memory);\n#else\n  LockSemaphoreInfo(memory_semaphore);\n  block=ResizeBlock(memory,size == 0 ? 1UL : size);\n  if (block == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) == MagickFalse)\n        {\n          UnlockSemaphoreInfo(memory_semaphore);\n          memory=RelinquishMagickMemory(memory);\n          ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n        }\n      block=ResizeBlock(memory,size == 0 ? 1UL : size);\n      assert(block != (void *) NULL);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n  memory=RelinquishMagickMemory(memory);\n#endif\n  return(block);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s i z e Q u a n t u m M e m o r y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResizeQuantumMemory() changes the size of the memory and returns a pointer\n%  to the (possibly moved) block.  The contents will be unchanged up to the\n%  lesser of the new and old sizes.\n%\n%  The format of the ResizeQuantumMemory method is:\n%\n%      void *ResizeQuantumMemory(void *memory,const size_t count,\n%        const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o memory: A pointer to a memory allocation.\n%\n%    o count: the number of quantum elements to allocate.\n%\n%    o quantum: the number of bytes in each quantum.\n%\n*/\nMagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t M a g i c k M e m o r y M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetMagickMemoryMethods() sets the methods to acquire, resize, and destroy\n%  memory. Your custom memory methods must be set prior to the\n%  MagickCoreGenesis() method.\n%\n%  The format of the SetMagickMemoryMethods() method is:\n%\n%      SetMagickMemoryMethods(AcquireMemoryHandler acquire_memory_handler,\n%        ResizeMemoryHandler resize_memory_handler,\n%        DestroyMemoryHandler destroy_memory_handler)\n%\n%  A description of each parameter follows:\n%\n%    o acquire_memory_handler: method to acquire memory (e.g. malloc).\n%\n%    o resize_memory_handler: method to resize memory (e.g. realloc).\n%\n%    o destroy_memory_handler: method to destroy memory (e.g. free).\n%\n*/\nMagickExport void SetMagickMemoryMethods(\n  AcquireMemoryHandler acquire_memory_handler,\n  ResizeMemoryHandler resize_memory_handler,\n  DestroyMemoryHandler destroy_memory_handler)\n{\n  /*\n    Set memory methods.\n  */\n  if (acquire_memory_handler != (AcquireMemoryHandler) NULL)\n    memory_methods.acquire_memory_handler=acquire_memory_handler;\n  if (resize_memory_handler != (ResizeMemoryHandler) NULL)\n    memory_methods.resize_memory_handler=resize_memory_handler;\n  if (destroy_memory_handler != (DestroyMemoryHandler) NULL)\n    memory_methods.destroy_memory_handler=destroy_memory_handler;\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%                   IIIII  M   M  PPPP    OOO   RRRR   TTTTT                  %\n%                     I    MM MM  P   P  O   O  R   R    T                    %\n%                     I    M M M  PPPP   O   O  RRRR     T                    %\n%                     I    M   M  P      O   O  R R      T                    %\n%                   IIIII  M   M  P       OOO   R  R     T                    %\n%                                                                             %\n%                 MagickCore Methods to Import Quantum Pixels                 %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m p o r t Q u a n t u m P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImportQuantumPixels() transfers one or more pixel components from a user\n%  supplied buffer into the image pixel cache of an image.  The pixels are\n%  expected in network byte order.  It returns MagickTrue if the pixels are\n%  successfully transferred, otherwise MagickFalse.\n%\n%  The format of the ImportQuantumPixels method is:\n%\n%      size_t ImportQuantumPixels(const Image *image,CacheView *image_view,\n%        QuantumInfo *quantum_info,const QuantumType quantum_type,\n%        const unsigned char *magick_restrict pixels,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o image_view: the image cache view.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n%    o pixels:  The pixel components are transferred from this buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PushColormapIndex(const Image *image,const size_t index,\n  MagickBooleanType *range_exception)\n{\n  if (index < image->colors)\n    return((Quantum) index);\n  *range_exception=MagickTrue;\n  return((Quantum) 0);\n}\n\nstatic inline const unsigned char *PushDoublePixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,double *pixel)\n{\n  double\n    *p;\n\n  unsigned char\n    quantum[8];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      quantum[4]=(*pixels++);\n      quantum[5]=(*pixels++);\n      quantum[6]=(*pixels++);\n      quantum[7]=(*pixels++);\n      p=(double *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[7]=(*pixels++);\n  quantum[6]=(*pixels++);\n  quantum[5]=(*pixels++);\n  quantum[4]=(*pixels++);\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(double *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushFloatPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,float *pixel)\n{\n  float\n    *p;\n\n  unsigned char\n    quantum[4];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      p=(float *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(float *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=(QuantumAny) 0;\n  for (i=(ssize_t) quantum_info->depth; i > 0L; )\n  {\n    if (quantum_info->state.bits == 0UL)\n      {\n        quantum_info->state.pixel=(*pixels++);\n        quantum_info->state.bits=8UL;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n    *quantum=(unsigned int) ((*quantum << quantum_bits) |\n      ((quantum_info->state.pixel >> quantum_info->state.bits) &~ ((~0UL) <<\n      quantum_bits)));\n  }\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumLongPixel(\n  QuantumInfo *quantum_info,const unsigned char *magick_restrict pixels,\n  unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=0UL;\n  for (i=(ssize_t) quantum_info->depth; i > 0; )\n  {\n    if (quantum_info->state.bits == 0)\n      {\n        pixels=PushLongPixel(quantum_info->endian,pixels,\n          &quantum_info->state.pixel);\n        quantum_info->state.bits=32U;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    *quantum|=(((quantum_info->state.pixel >> (32U-quantum_info->state.bits)) &\n      quantum_info->state.mask[quantum_bits]) << (quantum_info->depth-i));\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n  }\n  return(pixels);\n}\n\nstatic void ImportAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGROQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlackQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlueQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 10:\n    {\n      Quantum\n        cbcr[4];\n\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x+=4)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              cbcr[i]=(Quantum) (quantum);\n              n++;\n            }\n            p+=quantum_info->pad;\n            SetPixelRed(image,cbcr[1],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n            SetPixelRed(image,cbcr[3],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  pixel=0;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      bit=0;\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel != 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGreenQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ?\n              0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ?\n              0x00 : 0x01);\n          SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),\n            q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n            GetPixelIndex(image,q),q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        if (quantum_info->min_is_white == MagickFalse)\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n        else\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) ((*p++ >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportIndexAlphaQuantum(const Image *image,\n  QuantumInfo *quantum_info,const MagickSizeType number_pixels,\n  const unsigned char *magick_restrict p,Quantum *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          q+=GetPixelChannels(image);\n        }\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,\n              ClampToQuantum(pixel),&range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportOpacityQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRedQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nMagickExport size_t ImportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,const unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  register const unsigned char\n    *magick_restrict p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (const unsigned char *) NULL)\n    pixels=(const unsigned char *) GetQuantumPixels(quantum_info);\n  x=0;\n  p=pixels;\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      q=GetAuthenticPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_view);\n      q=GetCacheViewAuthenticPixelQueue(image_view);\n    }\n  ResetQuantumState(quantum_info);\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  switch (quantum_type)\n  {\n    case AlphaQuantum:\n    {\n      ImportAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRQuantum:\n    {\n      ImportBGRQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRAQuantum:\n    {\n      ImportBGRAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGROQuantum:\n    {\n      ImportBGROQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlackQuantum:\n    {\n      ImportBlackQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlueQuantum:\n    case YellowQuantum:\n    {\n      ImportBlueQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKQuantum:\n    {\n      ImportCMYKQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKAQuantum:\n    {\n      ImportCMYKAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKOQuantum:\n    {\n      ImportCMYKOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CbYCrYQuantum:\n    {\n      ImportCbYCrYQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayQuantum:\n    {\n      ImportGrayQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayAlphaQuantum:\n    {\n      ImportGrayAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GreenQuantum:\n    case MagentaQuantum:\n    {\n      ImportGreenQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexQuantum:\n    {\n      ImportIndexQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexAlphaQuantum:\n    {\n      ImportIndexAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case OpacityQuantum:\n    {\n      ImportOpacityQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RedQuantum:\n    case CyanQuantum:\n    {\n      ImportRedQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBQuantum:\n    case CbYCrQuantum:\n    {\n      ImportRGBQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBAQuantum:\n    case CbYCrAQuantum:\n    {\n      ImportRGBAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBOQuantum:\n    {\n      ImportRGBOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    default:\n      break;\n  }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      register Quantum\n        *magick_restrict q;\n\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  if (quantum_info->alpha_type == DisassociatedQuantumAlpha)\n    {\n      double\n        gamma,\n        Sa;\n\n      register Quantum\n        *magick_restrict q;\n\n      /*\n        Disassociate alpha.\n      */\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        register ssize_t\n          i;\n\n        if (GetPixelReadMask(image,q) == 0)\n          {\n            q+=GetPixelChannels(image);\n            continue;\n          }\n        Sa=QuantumScale*GetPixelAlpha(image,q);\n        gamma=PerceptibleReciprocal(Sa);\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          if ((channel == AlphaPixelChannel) ||\n              ((traits & UpdatePixelTrait) == 0))\n            continue;\n          q[i]=ClampToQuantum(gamma*q[i]);\n        }\n        q+=GetPixelChannels(image);\n      }\n    }\n  return(extent);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        V   V  IIIII  FFFFF  FFFFF                           %\n%                        V   V    I    F      F                               %\n%                        V   V    I    FFF    FFF                             %\n%                         V V     I    F      F                               %\n%                          V    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write Khoros Visualization Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteVIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s V I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsVIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is VIFF.\n%\n%  The format of the IsVIFF method is:\n%\n%      MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\253\\001\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d V I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadVIFFImage() reads a Khoros Visualization image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadVIFFImage method is:\n%\n%      Image *ReadVIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadVIFFImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType CheckMemoryOverflow(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\nstatic Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r V I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterVIFFImage() adds properties for the VIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterVIFFImage method is:\n%\n%      size_t RegisterVIFFImage(void)\n%\n*/\nModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"VIFF\",\"VIFF\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"VIFF\",\"XV\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r V I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterVIFFImage() removes format registrations made by the\n%  VIFF module from the list of supported formats.\n%\n%  The format of the UnregisterVIFFImage method is:\n%\n%      UnregisterVIFFImage(void)\n%\n*/\nModuleExport void UnregisterVIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"VIFF\");\n  (void) UnregisterMagickInfo(\"XV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e V I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteVIFFImage() writes an image to a file in the VIFF image format.\n%\n%  The format of the WriteVIFFImage method is:\n%\n%      MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_NONE  0\n#define VFF_DEP_IEEEORDER  0x2\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n\n  typedef struct _ViffInfo\n  {\n    char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3],\n      comment[512];\n\n    size_t\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    unsigned int\n      x_bits_per_pixel,\n      y_bits_per_pixel,\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels,\n    packets;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) ResetMagickMemory(&viff_info,0,sizeof(ViffInfo));\n  scene=0;\n  do\n  {\n    /*\n      Initialize VIFF image structure.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\nDisableMSCWarning(4310)\n    viff_info.identifier=(char) 0xab;\nRestoreMSCWarning\n    viff_info.file_type=1;\n    viff_info.release=1;\n    viff_info.version=3;\n    viff_info.machine_dependency=VFF_DEP_IEEEORDER;  /* IEEE byte ordering */\n    *viff_info.comment='\\0';\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(viff_info.comment,value,MagickMin(strlen(value),\n        511)+1);\n    viff_info.rows=image->columns;\n    viff_info.columns=image->rows;\n    viff_info.subrows=0;\n    viff_info.x_offset=(~0);\n    viff_info.y_offset=(~0);\n    viff_info.x_bits_per_pixel=0;\n    viff_info.y_bits_per_pixel=0;\n    viff_info.location_type=VFF_LOC_IMPLICIT;\n    viff_info.location_dimension=0;\n    viff_info.number_of_images=1;\n    viff_info.data_encode_scheme=VFF_DES_RAW;\n    viff_info.map_scheme=VFF_MS_NONE;\n    viff_info.map_storage_type=VFF_MAPTYP_NONE;\n    viff_info.map_rows=0;\n    viff_info.map_columns=0;\n    viff_info.map_subrows=0;\n    viff_info.map_enable=1;  /* no colormap */\n    viff_info.maps_per_cycle=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color VIFF raster.\n        */\n        viff_info.number_data_bands=image->alpha_trait ? 4U : 3U;\n        viff_info.color_space_model=VFF_CM_genericRGB;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=viff_info.number_data_bands*number_pixels;\n      }\n    else\n      {\n        viff_info.number_data_bands=1;\n        viff_info.color_space_model=VFF_CM_NONE;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=number_pixels;\n        if (SetImageGray(image,exception) == MagickFalse)\n          {\n            /*\n              Colormapped VIFF raster.\n            */\n            viff_info.map_scheme=VFF_MS_ONEPERBAND;\n            viff_info.map_storage_type=VFF_MAPTYP_1_BYTE;\n            viff_info.map_rows=3;\n            viff_info.map_columns=(unsigned int) image->colors;\n          }\n        else\n          if (image->colors <= 2)\n            {\n              /*\n                Monochrome VIFF raster.\n              */\n              viff_info.data_storage_type=VFF_TYP_BIT;\n              packets=((image->columns+7) >> 3)*image->rows;\n            }\n      }\n    /*\n      Write VIFF image header (pad to 1024 bytes).\n    */\n    (void) WriteBlob(image,sizeof(viff_info.identifier),(unsigned char *)\n      &viff_info.identifier);\n    (void) WriteBlob(image,sizeof(viff_info.file_type),(unsigned char *)\n      &viff_info.file_type);\n    (void) WriteBlob(image,sizeof(viff_info.release),(unsigned char *)\n      &viff_info.release);\n    (void) WriteBlob(image,sizeof(viff_info.version),(unsigned char *)\n      &viff_info.version);\n    (void) WriteBlob(image,sizeof(viff_info.machine_dependency),\n      (unsigned char *) &viff_info.machine_dependency);\n    (void) WriteBlob(image,sizeof(viff_info.reserve),(unsigned char *)\n      viff_info.reserve);\n    (void) WriteBlob(image,512,(unsigned char *) viff_info.comment);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_offset);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_offset);\n    viff_info.x_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_bits_per_pixel);\n    viff_info.y_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_bits_per_pixel);\n    (void) WriteBlobMSBLong(image,viff_info.location_type);\n    (void) WriteBlobMSBLong(image,viff_info.location_dimension);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_of_images);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_data_bands);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_encode_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_enable);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.maps_per_cycle);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.color_space_model);\n    for (i=0; i < 420; i++)\n      (void) WriteBlobByte(image,'\\0');\n    /*\n      Convert MIFF to VIFF raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) packets,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert DirectClass packet to VIFF RGB pixel.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q=ScaleQuantumToChar(GetPixelRed(image,p));\n            *(q+number_pixels)=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *(q+number_pixels*2)=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *(q+number_pixels*3)=ScaleQuantumToChar((Quantum)\n                (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n            q++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (SetImageGray(image,exception) == MagickFalse)\n        {\n          unsigned char\n            *viff_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n            3*sizeof(*viff_colormap));\n          if (viff_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=viff_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n          (void) WriteBlob(image,3*image->colors,viff_colormap);\n          viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n          /*\n            Convert PseudoClass packet to VIFF colormapped pixels.\n          */\n          q=pixels;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        if (image->colors <= 2)\n          {\n            ssize_t\n              x,\n              y;\n\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a VIFF monochrome image.\n            */\n            (void) SetImageType(image,BilevelType,exception);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte>>=1;\n                if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                  byte|=0x80;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte >> (8-bit);\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          {\n            /*\n              Convert PseudoClass packet to VIFF grayscale pixel.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=(unsigned char) ClampToQuantum(GetPixelLuma(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n    (void) WriteBlob(image,(size_t) packets,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["MagickCore/memory.c", "MagickCore/quantum-import.c", "coders/viff.c"], "buggy_code_start_loc": [241, 2028, 143], "buggy_code_end_loc": [241, 2028, 703], "fixing_code_start_loc": [242, 2029, 144], "fixing_code_end_loc": [243, 2030, 727], "type": "CWE-284", "message": "The ReadVIFFImage function in coders/viff.c in ImageMagick before 7.0.1-0 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.", "other": {"cve": {"id": "CVE-2016-10065", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-03T17:59:00.253", "lastModified": "2019-04-12T18:58:43.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ReadVIFFImage function in coders/viff.c in ImageMagick before 7.0.1-0 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n ReadVIFFImage en coders/viff.c en ImageMagick en versiones anteriores a 7.0.1-0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) o tener otro impacto no especificado a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.7-10", "matchCriteriaId": "7343EDC4-13AF-4BC0-BA96-AB1704D3DA42"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00028.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/26/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95213", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1410482", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/134463b926fa965571aa4febd61b810be5e7da05", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/129", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/134463b926fa965571aa4febd61b810be5e7da05"}}