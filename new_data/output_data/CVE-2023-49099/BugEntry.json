{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"mini_mime\"\n\nclass UploadsController < ApplicationController\n  include ExternalUploadHelpers\n\n  requires_login except: %i[show show_short _show_secure_deprecated show_secure]\n\n  skip_before_action :preload_json,\n                     :check_xhr,\n                     :redirect_to_login_if_required,\n                     only: %i[show show_short _show_secure_deprecated show_secure]\n  protect_from_forgery except: :show\n\n  before_action :is_asset_path,\n                :apply_cdn_headers,\n                only: %i[show show_short _show_secure_deprecated show_secure]\n  before_action :external_store_check, only: %i[_show_secure_deprecated show_secure]\n\n  SECURE_REDIRECT_GRACE_SECONDS = 5\n\n  def create\n    # capture current user for block later on\n    me = current_user\n\n    params.permit(:type, :upload_type)\n    raise Discourse::InvalidParameters if params[:type].blank? && params[:upload_type].blank?\n    # 50 characters ought to be enough for the upload type\n    type =\n      (params[:upload_type].presence || params[:type].presence).parameterize(separator: \"_\")[0..50]\n\n    if type == \"avatar\" &&\n         (\n           SiteSetting.discourse_connect_overrides_avatar ||\n             !me.in_any_groups?(SiteSetting.uploaded_avatars_allowed_groups_map)\n         )\n      return render json: failed_json, status: 422\n    end\n\n    url = params[:url]\n    file = params[:file] || params[:files]&.first\n    pasted = params[:pasted] == \"true\"\n    for_private_message = params[:for_private_message] == \"true\"\n    for_site_setting = params[:for_site_setting] == \"true\"\n    is_api = is_api?\n    retain_hours = params[:retain_hours].to_i\n\n    # note, atm hijack is processed in its own context and has not access to controller\n    # longer term we may change this\n    hijack do\n      begin\n        info =\n          UploadsController.create_upload(\n            current_user: me,\n            file: file,\n            url: url,\n            type: type,\n            for_private_message: for_private_message,\n            for_site_setting: for_site_setting,\n            pasted: pasted,\n            is_api: is_api,\n            retain_hours: retain_hours,\n          )\n      rescue => e\n        render json: failed_json.merge(message: e.message&.split(\"\\n\")&.first), status: 422\n      else\n        render json: UploadsController.serialize_upload(info), status: Upload === info ? 200 : 422\n      end\n    end\n  end\n\n  def lookup_urls\n    params.permit(short_urls: [])\n    uploads = []\n\n    if (params[:short_urls] && params[:short_urls].length > 0)\n      PrettyText::Helpers\n        .lookup_upload_urls(params[:short_urls])\n        .each do |short_url, paths|\n          uploads << { short_url: short_url, url: paths[:url], short_path: paths[:short_path] }\n        end\n    end\n\n    render json: uploads.to_json\n  end\n\n  def show\n    # do not serve uploads requested via XHR to prevent XSS\n    return xhr_not_allowed if request.xhr?\n\n    return render_404 if !RailsMultisite::ConnectionManagement.has_db?(params[:site])\n\n    RailsMultisite::ConnectionManagement.with_connection(params[:site]) do |db|\n      return render_404 if SiteSetting.prevent_anons_from_downloading_files && current_user.nil?\n\n      if upload =\n           Upload.find_by(sha1: params[:sha]) ||\n             Upload.find_by(id: params[:id], url: request.env[\"PATH_INFO\"])\n        unless Discourse.store.internal?\n          local_store = FileStore::LocalStore.new\n          return render_404 unless local_store.has_been_uploaded?(upload.url)\n        end\n\n        send_file_local_upload(upload)\n      else\n        render_404\n      end\n    end\n  end\n\n  def show_short\n    # do not serve uploads requested via XHR to prevent XSS\n    return xhr_not_allowed if request.xhr?\n\n    return render_404 if SiteSetting.prevent_anons_from_downloading_files && current_user.nil?\n\n    sha1 = Upload.sha1_from_base62_encoded(params[:base62])\n\n    if upload = Upload.find_by(sha1: sha1)\n      return handle_secure_upload_request(upload) if upload.secure? && SiteSetting.secure_uploads?\n\n      if Discourse.store.internal?\n        send_file_local_upload(upload)\n      else\n        redirect_to Discourse.store.url_for(upload, force_download: force_download?),\n                    allow_other_host: true\n      end\n    else\n      render_404\n    end\n  end\n\n  # Kept to avoid rebaking old posts with /show-secure-uploads/ in their\n  # contents, this will ensure the uploads in these posts continue to\n  # work in future.\n  def _show_secure_deprecated\n    show_secure\n  end\n\n  def show_secure\n    # do not serve uploads requested via XHR to prevent XSS\n    return xhr_not_allowed if request.xhr?\n\n    path_with_ext = \"#{params[:path]}.#{params[:extension]}\"\n\n    sha1 = File.basename(path_with_ext, File.extname(path_with_ext))\n    # this takes care of optimized image requests\n    sha1 = sha1.partition(\"_\").first if sha1.include?(\"_\")\n\n    upload = Upload.find_by(sha1: sha1)\n    return render_404 if upload.blank?\n\n    return render_404 if SiteSetting.prevent_anons_from_downloading_files && current_user.nil?\n    return handle_secure_upload_request(upload, path_with_ext) if SiteSetting.secure_uploads?\n\n    # we don't want to 404 here if secure uploads gets disabled\n    # because all posts with secure uploads will show broken media\n    # until rebaked, which could take some time\n    #\n    # if the upload is still secure, that means the ACL is probably still\n    # private, so we don't want to go to the CDN url just yet otherwise we\n    # will get a 403. if the upload is not secure we assume the ACL is public\n    signed_secure_url = Discourse.store.signed_url_for_path(path_with_ext)\n    redirect_to upload.secure? ? signed_secure_url : Discourse.store.cdn_url(upload.url),\n                allow_other_host: true\n  end\n\n  def handle_secure_upload_request(upload, path_with_ext = nil)\n    if upload.access_control_post_id.present?\n      raise Discourse::InvalidAccess if !guardian.can_see?(upload.access_control_post)\n    else\n      return render_404 if current_user.nil?\n    end\n\n    # defaults to public: false, so only cached by the client browser\n    cache_seconds =\n      SiteSetting.s3_presigned_get_url_expires_after_seconds - SECURE_REDIRECT_GRACE_SECONDS\n    expires_in cache_seconds.seconds\n\n    # url_for figures out the full URL, handling multisite DBs,\n    # and will return a presigned URL for the upload\n    if path_with_ext.blank?\n      return(\n        redirect_to Discourse.store.url_for(upload, force_download: force_download?),\n                    allow_other_host: true\n      )\n    end\n\n    redirect_to Discourse.store.signed_url_for_path(\n                  path_with_ext,\n                  expires_in: SiteSetting.s3_presigned_get_url_expires_after_seconds,\n                  force_download: force_download?,\n                ),\n                allow_other_host: true\n  end\n\n  def metadata\n    params.require(:url)\n    upload = Upload.get_from_url(params[:url])\n    raise Discourse::NotFound unless upload\n\n    render json: {\n             original_filename: upload.original_filename,\n             width: upload.width,\n             height: upload.height,\n             human_filesize: upload.human_filesize,\n           }\n  end\n\n  protected\n\n  def validate_before_create_multipart(file_name:, file_size:, upload_type:)\n    validate_file_size(file_name: file_name, file_size: file_size)\n  end\n\n  def validate_before_create_direct_upload(file_name:, file_size:, upload_type:)\n    validate_file_size(file_name: file_name, file_size: file_size)\n  end\n\n  def validate_file_size(file_name:, file_size:)\n    raise ExternalUploadValidationError.new(I18n.t(\"upload.size_zero_failure\")) if file_size.zero?\n\n    if attachment_too_big?(file_name, file_size)\n      raise ExternalUploadValidationError.new(\n              I18n.t(\n                \"upload.attachments.too_large_humanized\",\n                max_size:\n                  ActiveSupport::NumberHelper.number_to_human_size(\n                    SiteSetting.max_attachment_size_kb.kilobytes,\n                  ),\n              ),\n            )\n    end\n\n    if image_too_big?(file_name, file_size)\n      raise ExternalUploadValidationError.new(\n              I18n.t(\n                \"upload.images.too_large_humanized\",\n                max_size:\n                  ActiveSupport::NumberHelper.number_to_human_size(\n                    SiteSetting.max_image_size_kb.kilobytes,\n                  ),\n              ),\n            )\n    end\n  end\n\n  def force_download?\n    params[:dl] == \"1\"\n  end\n\n  def xhr_not_allowed\n    raise Discourse::InvalidParameters.new(\"XHR not allowed\")\n  end\n\n  def self.serialize_upload(data)\n    # as_json.as_json is not a typo... as_json in AM serializer returns keys as symbols, we need them\n    # as strings here\n    serialized = UploadSerializer.new(data, root: nil).as_json.as_json if Upload === data\n    serialized ||= (data || {}).as_json\n  end\n\n  def self.create_upload(\n    current_user:,\n    file:,\n    url:,\n    type:,\n    for_private_message:,\n    for_site_setting:,\n    pasted:,\n    is_api:,\n    retain_hours:\n  )\n    if file.nil?\n      if url.present? && is_api\n        maximum_upload_size = [\n          SiteSetting.max_image_size_kb,\n          SiteSetting.max_attachment_size_kb,\n        ].max.kilobytes\n        tempfile =\n          begin\n            FileHelper.download(\n              url,\n              follow_redirect: true,\n              max_file_size: maximum_upload_size,\n              tmp_file_name: \"discourse-upload-#{type}\",\n            )\n          rescue StandardError\n            nil\n          end\n        filename = File.basename(URI.parse(url).path)\n      end\n    else\n      tempfile = file.tempfile\n      filename = file.original_filename\n    end\n\n    return { errors: [I18n.t(\"upload.file_missing\")] } if tempfile.nil?\n\n    opts = {\n      type: type,\n      for_private_message: for_private_message,\n      for_site_setting: for_site_setting,\n      pasted: pasted,\n    }\n\n    upload = UploadCreator.new(tempfile, filename, opts).create_for(current_user.id)\n\n    if upload.errors.empty? && current_user.admin?\n      upload.update_columns(retain_hours: retain_hours) if retain_hours > 0\n    end\n\n    upload.errors.empty? ? upload : { errors: upload.errors.to_hash.values.flatten }\n  ensure\n    tempfile&.close!\n  end\n\n  private\n\n  # We can preemptively check size for attachments, but not for (most) images\n  # as they may be further reduced in size by UploadCreator (at this point\n  # they may have already been reduced in size by preprocessors)\n  def attachment_too_big?(file_name, file_size)\n    !FileHelper.is_supported_image?(file_name) &&\n      file_size >= SiteSetting.max_attachment_size_kb.kilobytes\n  end\n\n  # Gifs are not resized on the client and not reduced in size by UploadCreator\n  def image_too_big?(file_name, file_size)\n    FileHelper.is_supported_image?(file_name) && File.extname(file_name) == \".gif\" &&\n      file_size >= SiteSetting.max_image_size_kb.kilobytes\n  end\n\n  def send_file_local_upload(upload)\n    opts = {\n      filename: upload.original_filename,\n      content_type: MiniMime.lookup_by_filename(upload.original_filename)&.content_type,\n    }\n\n    if !FileHelper.is_inline_image?(upload.original_filename)\n      opts[:disposition] = \"attachment\"\n    elsif params[:inline]\n      opts[:disposition] = \"inline\"\n    end\n\n    file_path = Discourse.store.path_for(upload)\n    return render_404 unless file_path\n\n    send_file(file_path, opts)\n  end\n\n  def create_direct_multipart_upload\n    begin\n      yield\n    rescue Aws::S3::Errors::ServiceError => err\n      message =\n        debug_upload_error(\n          err,\n          I18n.t(\"upload.create_multipart_failure\", additional_detail: err.message),\n        )\n      raise ExternalUploadHelpers::ExternalUploadValidationError.new(message)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe UploadsController do\n  fab!(:user) { Fabricate(:user, refresh_auto_groups: true) }\n\n  describe \"#create\" do\n    it \"requires you to be logged in\" do\n      post \"/uploads.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      let(:logo_file) { file_from_fixtures(\"logo.png\") }\n      let(:logo_filename) { File.basename(logo_file) }\n\n      let(:logo) { Rack::Test::UploadedFile.new(logo_file) }\n      let(:fake_jpg) { Rack::Test::UploadedFile.new(file_from_fixtures(\"fake.jpg\")) }\n      let(:text_file) { Rack::Test::UploadedFile.new(File.new(\"#{Rails.root}/LICENSE.txt\")) }\n\n      it \"expects a type or upload_type\" do\n        post \"/uploads.json\", params: { file: logo }\n        expect(response.status).to eq(400)\n        post \"/uploads.json\",\n             params: {\n               file: Rack::Test::UploadedFile.new(logo_file),\n               type: \"avatar\",\n             }\n        expect(response.status).to eq 200\n        post \"/uploads.json\",\n             params: {\n               file: Rack::Test::UploadedFile.new(logo_file),\n               upload_type: \"avatar\",\n             }\n        expect(response.status).to eq 200\n      end\n\n      it \"is successful with an image\" do\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq 200\n        expect(response.parsed_body[\"id\"]).to be_present\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(1)\n      end\n\n      it 'returns \"raw\" url for site settings' do\n        set_cdn_url \"https://awesome.com\"\n\n        upload = UploadCreator.new(logo_file, \"logo.png\").create_for(-1)\n        logo = Rack::Test::UploadedFile.new(file_from_fixtures(\"logo.png\"))\n\n        post \"/uploads.json\", params: { file: logo, type: \"site_setting\", for_site_setting: \"true\" }\n        expect(response.status).to eq 200\n        expect(response.parsed_body[\"url\"]).to eq(upload.url)\n      end\n\n      it \"returns cdn url\" do\n        set_cdn_url \"https://awesome.com\"\n        post \"/uploads.json\", params: { file: logo, type: \"composer\" }\n        expect(response.status).to eq 200\n        expect(response.parsed_body[\"url\"]).to start_with(\"https://awesome.com/uploads/default/\")\n      end\n\n      it \"is successful with an attachment\" do\n        SiteSetting.authorized_extensions = \"*\"\n\n        post \"/uploads.json\", params: { file: text_file, type: \"composer\" }\n        expect(response.status).to eq 200\n\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        id = response.parsed_body[\"id\"]\n        expect(id).to be\n      end\n\n      it \"is successful with api\" do\n        SiteSetting.authorized_extensions = \"*\"\n        api_key = Fabricate(:api_key, user: user).key\n\n        url = \"http://example.com/image.png\"\n        png = File.read(Rails.root + \"spec/fixtures/images/logo.png\")\n\n        stub_request(:get, url).to_return(status: 200, body: png)\n\n        post \"/uploads.json\",\n             params: {\n               url: url,\n               type: \"avatar\",\n             },\n             headers: {\n               HTTP_API_KEY: api_key,\n               HTTP_API_USERNAME: user.username.downcase,\n             }\n\n        json = response.parsed_body\n\n        expect(response.status).to eq(200)\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(1)\n        expect(json[\"id\"]).to be_present\n        expect(json[\"short_url\"]).to eq(\"upload://qUm0DGR49PAZshIi7HxMd3cAlzn.png\")\n      end\n\n      it \"correctly sets retain_hours for admins\" do\n        sign_in(Fabricate(:admin))\n\n        post \"/uploads.json\", params: { file: logo, retain_hours: 100, type: \"profile_background\" }\n\n        id = response.parsed_body[\"id\"]\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        expect(Upload.find(id).retain_hours).to eq(100)\n      end\n\n      it \"requires a file\" do\n        post \"/uploads.json\", params: { type: \"composer\" }\n\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        message = response.parsed_body\n        expect(response.status).to eq 422\n        expect(message[\"errors\"]).to contain_exactly(I18n.t(\"upload.file_missing\"))\n      end\n\n      it \"properly returns errors\" do\n        SiteSetting.authorized_extensions = \"*\"\n        SiteSetting.max_attachment_size_kb = 1\n\n        post \"/uploads.json\", params: { file: text_file, type: \"avatar\" }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        errors = response.parsed_body[\"errors\"]\n        expect(errors.first).to eq(\n          I18n.t(\"upload.attachments.too_large_humanized\", max_size: \"1 KB\"),\n        )\n      end\n\n      it \"ensures user belongs to uploaded_avatars_allowed_groups when uploading an avatar\" do\n        SiteSetting.uploaded_avatars_allowed_groups = \"13\"\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq(422)\n\n        user.update!(trust_level: 3)\n        Group.refresh_automatic_groups!\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq(200)\n      end\n\n      it \"ensures discourse_connect_overrides_avatar is not enabled when uploading an avatar\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq(422)\n      end\n\n      it \"allows staff to upload any file in PM\" do\n        SiteSetting.authorized_extensions = \"jpg\"\n        SiteSetting.allow_staff_to_upload_any_file_in_pm = true\n        user.update_columns(moderator: true)\n\n        post \"/uploads.json\",\n             params: {\n               file: text_file,\n               type: \"composer\",\n               for_private_message: \"true\",\n             }\n\n        expect(response.status).to eq(200)\n        id = response.parsed_body[\"id\"]\n        expect(Upload.last.id).to eq(id)\n      end\n\n      it \"allows staff to upload supported images for site settings\" do\n        SiteSetting.authorized_extensions = \"\"\n        user.update!(admin: true)\n\n        post \"/uploads.json\", params: { file: logo, type: \"site_setting\", for_site_setting: \"true\" }\n\n        expect(response.status).to eq(200)\n        id = response.parsed_body[\"id\"]\n\n        upload = Upload.last\n\n        expect(upload.id).to eq(id)\n        expect(upload.original_filename).to eq(logo_filename)\n      end\n\n      it \"respects `authorized_extensions_for_staff` setting when staff upload file\" do\n        SiteSetting.authorized_extensions = \"\"\n        SiteSetting.authorized_extensions_for_staff = \"*\"\n        user.update_columns(moderator: true)\n\n        post \"/uploads.json\", params: { file: text_file, type: \"composer\" }\n\n        expect(response.status).to eq(200)\n        data = response.parsed_body\n        expect(data[\"id\"]).to be_present\n      end\n\n      it \"ignores `authorized_extensions_for_staff` setting when non-staff upload file\" do\n        SiteSetting.authorized_extensions = \"\"\n        SiteSetting.authorized_extensions_for_staff = \"*\"\n\n        post \"/uploads.json\", params: { file: text_file, type: \"composer\" }\n\n        data = response.parsed_body\n        expect(data[\"errors\"].first).to eq(I18n.t(\"upload.unauthorized\", authorized_extensions: \"\"))\n      end\n\n      it \"returns an error when it could not determine the dimensions of an image\" do\n        post \"/uploads.json\", params: { file: fake_jpg, type: \"composer\" }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        message = response.parsed_body[\"errors\"]\n        expect(message).to contain_exactly(I18n.t(\"upload.images.size_not_found\"))\n      end\n    end\n  end\n\n  def upload_file(file, folder = \"images\")\n    fake_logo = Rack::Test::UploadedFile.new(file_from_fixtures(file, folder))\n    SiteSetting.authorized_extensions = \"*\"\n    sign_in(user)\n\n    post \"/uploads.json\", params: { file: fake_logo, type: \"composer\" }\n\n    expect(response.status).to eq(200)\n\n    url = response.parsed_body[\"url\"]\n    upload = Upload.get_from_url(url)\n    upload\n  end\n\n  describe \"#show\" do\n    let(:site) { \"default\" }\n    let(:sha) { Digest::SHA1.hexdigest(\"discourse\") }\n\n    context \"when using external storage\" do\n      fab!(:upload) { upload_file(\"small.pdf\", \"pdf\") }\n\n      before { setup_s3 }\n\n      it \"returns 404 \" do\n        upload = Fabricate(:upload_s3)\n        get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n\n        expect(response.response_code).to eq(404)\n      end\n\n      it \"returns upload if url not migrated\" do\n        get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n\n        expect(response.status).to eq(200)\n      end\n    end\n\n    it \"returns 404 when the upload doesn't exist\" do\n      get \"/uploads/#{site}/#{sha}.pdf\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns 404 when the path is nil\" do\n      upload = upload_file(\"logo.png\")\n      upload.update_column(:url, \"invalid-url\")\n\n      get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"uses send_file\" do\n      upload = upload_file(\"logo.png\")\n      get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n      expect(response.status).to eq(200)\n\n      expect(response.headers[\"Content-Disposition\"]).to eq(\n        %Q|attachment; filename=\"#{upload.original_filename}\"; filename*=UTF-8''#{upload.original_filename}|,\n      )\n    end\n\n    it \"returns 200 when js file\" do\n      ActionDispatch::FileHandler.any_instance.stubs(:match?).returns(false)\n      upload = upload_file(\"test.js\", \"themes\")\n      get upload.url\n      expect(response.status).to eq(200)\n    end\n\n    it \"handles image without extension\" do\n      SiteSetting.authorized_extensions = \"*\"\n      upload = upload_file(\"image_no_extension\")\n\n      get \"/uploads/#{site}/#{upload.sha1}.json\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Content-Disposition\"]).to eq(\n        %Q|attachment; filename=\"#{upload.original_filename}\"; filename*=UTF-8''#{upload.original_filename}|,\n      )\n    end\n\n    it \"handles file without extension\" do\n      SiteSetting.authorized_extensions = \"*\"\n      upload = upload_file(\"not_an_image\")\n\n      get \"/uploads/#{site}/#{upload.sha1}.json\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Content-Disposition\"]).to eq(\n        %Q|attachment; filename=\"#{upload.original_filename}\"; filename*=UTF-8''#{upload.original_filename}|,\n      )\n    end\n\n    context \"when user is anonymous\" do\n      it \"returns 404\" do\n        upload = upload_file(\"small.pdf\", \"pdf\")\n        delete \"/session/#{user.username}.json\"\n\n        SiteSetting.prevent_anons_from_downloading_files = true\n        get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#show_short\" do\n    it \"inlines only supported image files\" do\n      upload = upload_file(\"smallest.png\")\n      get upload.short_path, params: { inline: true }\n      expect(response.header[\"Content-Type\"]).to eq(\"image/png\")\n      expect(response.header[\"Content-Disposition\"]).to include(\"inline;\")\n\n      upload.update!(original_filename: \"test.xml\")\n      get upload.short_path, params: { inline: true }\n      expect(response.header[\"Content-Type\"]).to eq(\"application/xml\")\n      expect(response.header[\"Content-Disposition\"]).to include(\"attachment;\")\n    end\n\n    describe \"local store\" do\n      fab!(:image_upload) { upload_file(\"smallest.png\") }\n\n      it \"returns the right response\" do\n        get image_upload.short_path\n\n        expect(response.status).to eq(200)\n\n        expect(response.headers[\"Content-Disposition\"]).to include(\n          \"attachment; filename=\\\"#{image_upload.original_filename}\\\"\",\n        )\n      end\n\n      it \"returns the right response when `inline` param is given\" do\n        get \"#{image_upload.short_path}?inline=1\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.headers[\"Content-Disposition\"]).to include(\n          \"inline; filename=\\\"#{image_upload.original_filename}\\\"\",\n        )\n      end\n\n      it \"returns the right response when base62 param is invalid \" do\n        get \"/uploads/short-url/12345.png\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns uploads with underscore in extension correctly\" do\n        fake_upload = upload_file(\"fake.not_image\")\n        get fake_upload.short_path\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns uploads with a dash and uppercase in extension correctly\" do\n        fake_upload = upload_file(\"fake.long-FileExtension\")\n        get fake_upload.short_path\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns the right response when anon tries to download a file \" \\\n           \"when prevent_anons_from_downloading_files is true\" do\n        delete \"/session/#{user.username}.json\"\n        SiteSetting.prevent_anons_from_downloading_files = true\n\n        get image_upload.short_path\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"s3 store\" do\n      let(:upload) { Fabricate(:upload_s3) }\n\n      before { setup_s3 }\n\n      it \"should redirect to the s3 URL\" do\n        get upload.short_path\n\n        expect(response).to redirect_to(upload.url)\n      end\n\n      context \"when upload is secure and secure uploads enabled\" do\n        before do\n          SiteSetting.secure_uploads = true\n          upload.update(secure: true)\n        end\n\n        it \"redirects to the signed_url_for_path\" do\n          sign_in(user)\n          freeze_time\n          get upload.short_path\n\n          expect(response).to redirect_to(\n            Discourse.store.signed_url_for_path(Discourse.store.get_path_for_upload(upload)),\n          )\n          expect(response.header[\"Location\"]).not_to include(\n            \"response-content-disposition=attachment\",\n          )\n        end\n\n        it \"respects the force download (dl) param\" do\n          sign_in(user)\n          freeze_time\n          get upload.short_path, params: { dl: \"1\" }\n          expect(response.header[\"Location\"]).to include(\"response-content-disposition=attachment\")\n        end\n\n        it \"has the correct caching header\" do\n          sign_in(user)\n          get upload.short_path\n\n          expected_max_age =\n            SiteSetting.s3_presigned_get_url_expires_after_seconds -\n              UploadsController::SECURE_REDIRECT_GRACE_SECONDS\n          expect(expected_max_age).to be > 0 # Sanity check that the constants haven't been set to broken values\n\n          expect(response.headers[\"Cache-Control\"]).to eq(\"max-age=#{expected_max_age}, private\")\n        end\n\n        it \"raises invalid access if the user cannot access the upload access control post\" do\n          sign_in(user)\n          post = Fabricate(:post)\n          post.topic.change_category_to_id(\n            Fabricate(:private_category, group: Fabricate(:group)).id,\n          )\n          upload.update(access_control_post: post)\n\n          get upload.short_path\n          expect(response.code).to eq(\"403\")\n        end\n      end\n    end\n  end\n\n  describe \"#show_secure\" do\n    describe \"local store\" do\n      fab!(:image_upload) { upload_file(\"smallest.png\") }\n\n      it \"does not return secure uploads when using local store\" do\n        secure_url = image_upload.url.sub(\"/uploads\", \"/secure-uploads\")\n        get secure_url\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"s3 store\" do\n      let(:upload) { Fabricate(:upload_s3) }\n      let(:secure_url) { upload.url.sub(SiteSetting.Upload.absolute_base_url, \"/secure-uploads\") }\n\n      before do\n        setup_s3\n        SiteSetting.authorized_extensions = \"*\"\n        SiteSetting.secure_uploads = true\n      end\n\n      it \"should return 404 for anonymous requests requests\" do\n        get secure_url\n        expect(response.status).to eq(404)\n      end\n\n      it \"should return signed url for legitimate request\" do\n        sign_in(user)\n        get secure_url\n\n        expect(response.status).to eq(302)\n        expect(response.redirect_url).to match(\"Amz-Expires\")\n      end\n\n      it \"should return secure uploads URL when looking up urls\" do\n        upload.update_column(:secure, true)\n        sign_in(user)\n\n        post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[0][\"url\"]).to match(\"secure-uploads\")\n      end\n\n      context \"when the upload cannot be found from the URL\" do\n        it \"returns a 404\" do\n          sign_in(user)\n          upload.update(sha1: \"test\")\n\n          get secure_url\n          expect(response.status).to eq(404)\n        end\n      end\n\n      context \"when the access_control_post_id has been set for the upload\" do\n        let(:post) { Fabricate(:post) }\n        let!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n        before { upload.update(access_control_post_id: post.id) }\n\n        context \"when the user is anon\" do\n          it \"should return signed url for public posts\" do\n            get secure_url\n            expect(response.status).to eq(302)\n            expect(response.redirect_url).to match(\"Amz-Expires\")\n          end\n\n          it \"should return 403 for deleted posts\" do\n            post.trash!\n            get secure_url\n            expect(response.status).to eq(403)\n          end\n\n          context \"when the user does not have access to the post via guardian\" do\n            before { post.topic.change_category_to_id(private_category.id) }\n\n            it \"returns a 403\" do\n              get secure_url\n              expect(response.status).to eq(403)\n            end\n          end\n        end\n\n        context \"when the user is logged in\" do\n          before { sign_in(user) }\n\n          context \"when the user has access to the post via guardian\" do\n            it \"should return signed url for legitimate request\" do\n              get secure_url\n              expect(response.status).to eq(302)\n              expect(response.redirect_url).to match(\"Amz-Expires\")\n            end\n          end\n\n          context \"when the user does not have access to the post via guardian\" do\n            before { post.topic.change_category_to_id(private_category.id) }\n\n            it \"returns a 403\" do\n              get secure_url\n              expect(response.status).to eq(403)\n            end\n          end\n        end\n      end\n\n      context \"when the upload is an attachment file\" do\n        before { upload.update(original_filename: \"test.pdf\") }\n        it \"redirects to the signed_url_for_path\" do\n          sign_in(user)\n          get secure_url\n          expect(response.status).to eq(302)\n          expect(response.redirect_url).to match(\"Amz-Expires\")\n        end\n\n        context \"when the user does not have access to the access control post via guardian\" do\n          let(:post) { Fabricate(:post) }\n          let!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n          before do\n            post.topic.change_category_to_id(private_category.id)\n            upload.update(access_control_post_id: post.id)\n          end\n\n          it \"returns a 403\" do\n            sign_in(user)\n            get secure_url\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context \"when the prevent_anons_from_downloading_files setting is enabled and the user is anon\" do\n          before { SiteSetting.prevent_anons_from_downloading_files = true }\n\n          it \"returns a 404\" do\n            delete \"/session/#{user.username}.json\"\n            get secure_url\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      context \"when secure uploads is disabled\" do\n        before { SiteSetting.secure_uploads = false }\n\n        context \"if the upload is secure false, meaning the ACL is probably public\" do\n          before { upload.update(secure: false) }\n\n          it \"should redirect to the regular show route\" do\n            secure_url = upload.url.sub(SiteSetting.Upload.absolute_base_url, \"/secure-uploads\")\n            sign_in(user)\n            get secure_url\n\n            expect(response.status).to eq(302)\n            expect(response.redirect_url).to eq(Discourse.store.cdn_url(upload.url))\n          end\n        end\n\n        context \"if the upload is secure true, meaning the ACL is probably private\" do\n          before { upload.update(secure: true) }\n\n          it \"should redirect to the presigned URL still otherwise we will get a 403\" do\n            secure_url = upload.url.sub(SiteSetting.Upload.absolute_base_url, \"/secure-uploads\")\n            sign_in(user)\n            get secure_url\n\n            expect(response.status).to eq(302)\n            expect(response.redirect_url).to match(\"Amz-Expires\")\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#lookup_urls\" do\n    it \"can look up long urls\" do\n      sign_in(user)\n      upload = Fabricate(:upload)\n\n      post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n      expect(response.status).to eq(200)\n\n      result = response.parsed_body\n      expect(result[0][\"url\"]).to eq(upload.url)\n      expect(result[0][\"short_path\"]).to eq(upload.short_path)\n    end\n\n    describe \"secure uploads\" do\n      let(:upload) { Fabricate(:upload_s3, secure: true) }\n\n      before do\n        setup_s3\n        SiteSetting.authorized_extensions = \"pdf|png\"\n        SiteSetting.secure_uploads = true\n      end\n\n      it \"returns secure url for a secure uploads upload\" do\n        sign_in(user)\n\n        post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[0][\"url\"]).to match(\"/secure-uploads\")\n        expect(result[0][\"short_path\"]).to eq(upload.short_path)\n      end\n\n      it \"returns secure urls for non-media uploads\" do\n        upload.update!(original_filename: \"not-an-image.pdf\", extension: \"pdf\")\n        sign_in(user)\n\n        post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[0][\"url\"]).to match(\"/secure-uploads\")\n        expect(result[0][\"short_path\"]).to eq(upload.short_path)\n      end\n    end\n  end\n\n  describe \"#metadata\" do\n    fab!(:upload)\n\n    describe \"when url is missing\" do\n      it \"should return the right response\" do\n        post \"/uploads/lookup-metadata.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    describe \"when not signed in\" do\n      it \"should return the right response\" do\n        post \"/uploads/lookup-metadata.json\", params: { url: upload.url }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    describe \"when signed in\" do\n      before { sign_in(user) }\n\n      describe \"when url is invalid\" do\n        it \"should return the right response\" do\n          post \"/uploads/lookup-metadata.json\", params: { url: \"abc\" }\n\n          expect(response.status).to eq(404)\n        end\n      end\n\n      it \"should return the right response\" do\n        post \"/uploads/lookup-metadata.json\", params: { url: upload.url }\n\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n\n        expect(result[\"original_filename\"]).to eq(upload.original_filename)\n        expect(result[\"width\"]).to eq(upload.width)\n        expect(result[\"height\"]).to eq(upload.height)\n        expect(result[\"human_filesize\"]).to eq(upload.human_filesize)\n      end\n    end\n  end\n\n  describe \"#generate_presigned_put\" do\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/generate-presigned-put.json\", params: { file_name: \"test.png\" }\n        expect(response.status).to eq(400)\n        post \"/uploads/generate-presigned-put.json\", params: { type: \"card_background\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"generates a presigned URL and creates an external upload stub\" do\n        post \"/uploads/generate-presigned-put.json\",\n             params: {\n               file_name: \"test.png\",\n               type: \"card_background\",\n               file_size: 1024,\n             }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n\n        external_upload_stub =\n          ExternalUploadStub.where(\n            unique_identifier: result[\"unique_identifier\"],\n            original_filename: \"test.png\",\n            created_by: user,\n            upload_type: \"card_background\",\n            filesize: 1024,\n          )\n        expect(external_upload_stub.exists?).to eq(true)\n        expect(result[\"key\"]).to include(FileStore::S3Store::TEMPORARY_UPLOAD_PREFIX)\n        expect(result[\"url\"]).to include(FileStore::S3Store::TEMPORARY_UPLOAD_PREFIX)\n        expect(result[\"url\"]).to include(\"Amz-Expires\")\n      end\n\n      it \"includes accepted metadata in the response when provided\" do\n        post \"/uploads/generate-presigned-put.json\",\n             **{\n               params: {\n                 file_name: \"test.png\",\n                 file_size: 1024,\n                 type: \"card_background\",\n                 metadata: {\n                   \"sha1-checksum\" => \"testing\",\n                   \"blah\" => \"wontbeincluded\",\n                 },\n               },\n             }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[\"url\"]).not_to include(\"&x-amz-meta-sha1-checksum=testing\")\n        expect(result[\"url\"]).not_to include(\"&x-amz-meta-blah=wontbeincluded\")\n        expect(result[\"signed_headers\"]).to eq(\n          \"x-amz-acl\" => \"private\",\n          \"x-amz-meta-sha1-checksum\" => \"testing\",\n        )\n      end\n\n      context \"when enable_s3_transfer_acceleration is true\" do\n        before { SiteSetting.enable_s3_transfer_acceleration = true }\n\n        it \"uses the s3-accelerate endpoint for presigned URLs\" do\n          post \"/uploads/generate-presigned-put.json\",\n               **{\n                 params: {\n                   file_name: \"test.png\",\n                   file_size: 1024,\n                   type: \"card_background\",\n                   metadata: {\n                     \"sha1-checksum\" => \"testing\",\n                     \"blah\" => \"wontbeincluded\",\n                   },\n                 },\n               }\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n          expect(result[\"url\"]).to include(\"s3-accelerate\")\n        end\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_presigned_put_per_minute = 1\n\n          post \"/uploads/generate-presigned-put.json\",\n               params: {\n                 file_name: \"test.png\",\n                 type: \"card_background\",\n                 file_size: 1024,\n               }\n          post \"/uploads/generate-presigned-put.json\",\n               params: {\n                 file_name: \"test.png\",\n                 type: \"card_background\",\n                 file_size: 1024,\n               }\n\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/generate-presigned-put.json\",\n             params: {\n               file_name: \"test.png\",\n               type: \"card_background\",\n               file_size: 1024,\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#create_multipart\" do\n    context \"when the store is external\" do\n      let(:mock_multipart_upload_id) do\n        \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n      end\n      let(:test_bucket_prefix) { \"test_#{ENV[\"TEST_ENV_NUMBER\"].presence || \"0\"}\" }\n\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/create-multipart.json\", params: { file_name: \"test.png\" }\n        expect(response.status).to eq(400)\n        post \"/uploads/create-multipart.json\", params: { upload_type: \"composer\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"returns 422 when the create request errors\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:create_multipart)\n          .raises(Aws::S3::Errors::ServiceError.new({}, \"test\"))\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.png\", file_size: 1024, upload_type: \"composer\" } }\n        expect(response.status).to eq(422)\n      end\n\n      it \"returns 422 when the file is an attachment and it's too big\" do\n        SiteSetting.max_attachment_size_kb = 1024\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.zip\", file_size: 9_999_999, upload_type: \"composer\" } }\n        expect(response.status).to eq(422)\n        expect(response.body).to include(\n          I18n.t(\"upload.attachments.too_large_humanized\", max_size: \"1 MB\"),\n        )\n      end\n\n      it \"returns 422 when the file is an gif and it's too big, since gifs cannot be resized on client\" do\n        SiteSetting.max_image_size_kb = 1024\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.gif\", file_size: 9_999_999, upload_type: \"composer\" } }\n        expect(response.status).to eq(422)\n        expect(response.body).to include(\n          I18n.t(\"upload.images.too_large_humanized\", max_size: \"1 MB\"),\n        )\n      end\n\n      it \"returns a sensible error if the file size is 0 bytes\" do\n        SiteSetting.authorized_extensions = \"*\"\n        stub_create_multipart_request\n\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.zip\", file_size: 0, upload_type: \"composer\" } }\n\n        expect(response.status).to eq(422)\n        expect(response.body).to include(I18n.t(\"upload.size_zero_failure\"))\n      end\n\n      def stub_create_multipart_request\n        FileStore::S3Store\n          .any_instance\n          .stubs(:temporary_upload_path)\n          .returns(\n            \"uploads/default/#{test_bucket_prefix}/temp/28fccf8259bbe75b873a2bd2564b778c/test.png\",\n          )\n        create_multipart_result = <<~XML\n        <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\n        <InitiateMultipartUploadResult>\n           <Bucket>s3-upload-bucket</Bucket>\n           <Key>uploads/default/#{test_bucket_prefix}/temp/28fccf8259bbe75b873a2bd2564b778c/test.png</Key>\n           <UploadId>#{mock_multipart_upload_id}</UploadId>\n        </InitiateMultipartUploadResult>\n        XML\n        stub_request(\n          :post,\n          \"https://s3-upload-bucket.s3.us-west-1.amazonaws.com/uploads/default/#{test_bucket_prefix}/temp/28fccf8259bbe75b873a2bd2564b778c/test.png?uploads\",\n        ).to_return({ status: 200, body: create_multipart_result })\n      end\n\n      it \"creates a multipart upload and creates an external upload stub that is marked as multipart\" do\n        stub_create_multipart_request\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.png\", file_size: 1024, upload_type: \"composer\" } }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n\n        external_upload_stub =\n          ExternalUploadStub.where(\n            unique_identifier: result[\"unique_identifier\"],\n            original_filename: \"test.png\",\n            created_by: user,\n            upload_type: \"composer\",\n            key: result[\"key\"],\n            external_upload_identifier: mock_multipart_upload_id,\n            multipart: true,\n            filesize: 1024,\n          )\n        expect(external_upload_stub.exists?).to eq(true)\n        expect(result[\"key\"]).to include(FileStore::S3Store::TEMPORARY_UPLOAD_PREFIX)\n        expect(result[\"external_upload_identifier\"]).to eq(mock_multipart_upload_id)\n        expect(result[\"key\"]).to eq(external_upload_stub.last.key)\n      end\n\n      it \"includes accepted metadata when calling the store to create_multipart, but only allowed keys\" do\n        stub_create_multipart_request\n        FileStore::S3Store\n          .any_instance\n          .expects(:create_multipart)\n          .with(\"test.png\", \"image/png\", metadata: { \"sha1-checksum\" => \"testing\" })\n          .returns({ key: \"test\" })\n\n        post \"/uploads/create-multipart.json\",\n             **{\n               params: {\n                 file_name: \"test.png\",\n                 file_size: 1024,\n                 upload_type: \"composer\",\n                 metadata: {\n                   \"sha1-checksum\" => \"testing\",\n                   \"blah\" => \"wontbeincluded\",\n                 },\n               },\n             }\n\n        expect(response.status).to eq(200)\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_create_multipart_per_minute = 1\n\n          stub_create_multipart_request\n          post \"/uploads/create-multipart.json\",\n               params: {\n                 file_name: \"test.png\",\n                 upload_type: \"composer\",\n                 file_size: 1024,\n               }\n          expect(response.status).to eq(200)\n\n          post \"/uploads/create-multipart.json\",\n               params: {\n                 file_name: \"test.png\",\n                 upload_type: \"composer\",\n                 file_size: 1024,\n               }\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/create-multipart.json\",\n             params: {\n               file_name: \"test.png\",\n               upload_type: \"composer\",\n               file_size: 1024,\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#batch_presign_multipart_parts\" do\n    fab!(:mock_multipart_upload_id) do\n      \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n    end\n    fab!(:external_upload_stub) do\n      Fabricate(\n        :image_external_upload_stub,\n        created_by: user,\n        multipart: true,\n        external_upload_identifier: mock_multipart_upload_id,\n      )\n    end\n\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      def stub_list_multipart_request\n        list_multipart_result = <<~XML\n        <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\n        <ListPartsResult>\n           <Bucket>s3-upload-bucket</Bucket>\n           <Key>#{external_upload_stub.key}</Key>\n           <UploadId>#{mock_multipart_upload_id}</UploadId>\n           <PartNumberMarker>0</PartNumberMarker>\n           <NextPartNumberMarker>0</NextPartNumberMarker>\n           <MaxParts>1</MaxParts>\n           <IsTruncated>false</IsTruncated>\n           <Part>\n              <ETag>test</ETag>\n              <LastModified>#{Time.zone.now}</LastModified>\n              <PartNumber>1</PartNumber>\n              <Size>#{5.megabytes}</Size>\n           </Part>\n           <Initiator>\n              <DisplayName>test-upload-user</DisplayName>\n              <ID>arn:aws:iam::123:user/test-upload-user</ID>\n           </Initiator>\n           <Owner>\n              <DisplayName></DisplayName>\n              <ID>12345</ID>\n           </Owner>\n           <StorageClass>STANDARD</StorageClass>\n        </ListPartsResult>\n        XML\n        stub_request(\n          :get,\n          \"https://s3-upload-bucket.#{SiteSetting.enable_s3_transfer_acceleration ? \"s3-accelerate\" : \"s3.us-west-1\"}.amazonaws.com/#{external_upload_stub.key}?max-parts=1&uploadId=#{mock_multipart_upload_id}\",\n        ).to_return({ status: 200, body: list_multipart_result })\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/batch-presign-multipart-parts.json\", params: {}\n        expect(response.status).to eq(400)\n      end\n\n      it \"errors if the part_numbers do not contain numbers between 1 and 10000\" do\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [-1, 0, 1, 2, 3, 4],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [3, 4, \"blah\"],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n      end\n\n      it \"returns 404 when the upload stub does not exist\" do\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: \"unknown\",\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the multipart upload does not exist\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:list_multipart_parts)\n          .raises(Aws::S3::Errors::NoSuchUpload.new(\"test\", \"test\"))\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns an object with the presigned URLs with the part numbers as keys\" do\n        stub_list_multipart_request\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [2, 3, 4],\n             }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"presigned_urls\"].keys).to eq(%w[2 3 4])\n        expect(result[\"presigned_urls\"][\"2\"]).to include(\n          \"?partNumber=2&uploadId=#{mock_multipart_upload_id}\",\n        )\n        expect(result[\"presigned_urls\"][\"3\"]).to include(\n          \"?partNumber=3&uploadId=#{mock_multipart_upload_id}\",\n        )\n        expect(result[\"presigned_urls\"][\"4\"]).to include(\n          \"?partNumber=4&uploadId=#{mock_multipart_upload_id}\",\n        )\n      end\n\n      context \"when enable_s3_transfer_acceleration is true\" do\n        before { SiteSetting.enable_s3_transfer_acceleration = true }\n\n        it \"uses the s3-accelerate endpoint for presigned URLs\" do\n          stub_list_multipart_request\n          post \"/uploads/batch-presign-multipart-parts.json\",\n               params: {\n                 unique_identifier: external_upload_stub.unique_identifier,\n                 part_numbers: [2, 3, 4],\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"presigned_urls\"].keys).to eq(%w[2 3 4])\n          expect(result[\"presigned_urls\"][\"2\"]).to include(\"s3-accelerate\")\n        end\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_batch_presign_multipart_per_minute = 1\n\n          stub_list_multipart_request\n          post \"/uploads/batch-presign-multipart-parts.json\",\n               params: {\n                 unique_identifier: external_upload_stub.unique_identifier,\n                 part_numbers: [1, 2, 3],\n               }\n\n          expect(response.status).to eq(200)\n\n          post \"/uploads/batch-presign-multipart-parts.json\",\n               params: {\n                 unique_identifier: external_upload_stub.unique_identifier,\n                 part_numbers: [1, 2, 3],\n               }\n\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#complete_multipart\" do\n    let(:upload_base_url) do\n      \"https://#{SiteSetting.s3_upload_bucket}.#{SiteSetting.enable_s3_transfer_acceleration ? \"s3-accelerate\" : \"s3.#{SiteSetting.s3_region}\"}.amazonaws.com\"\n    end\n    let(:mock_multipart_upload_id) do\n      \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n    end\n    let!(:external_upload_stub) do\n      Fabricate(\n        :image_external_upload_stub,\n        created_by: user,\n        multipart: true,\n        external_upload_identifier: mock_multipart_upload_id,\n      )\n    end\n\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      def stub_list_multipart_request\n        list_multipart_result = <<~XML\n        <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\n        <ListPartsResult>\n           <Bucket>s3-upload-bucket</Bucket>\n           <Key>#{external_upload_stub.key}</Key>\n           <UploadId>#{mock_multipart_upload_id}</UploadId>\n           <PartNumberMarker>0</PartNumberMarker>\n           <NextPartNumberMarker>0</NextPartNumberMarker>\n           <MaxParts>1</MaxParts>\n           <IsTruncated>false</IsTruncated>\n           <Part>\n              <ETag>test</ETag>\n              <LastModified>#{Time.zone.now}</LastModified>\n              <PartNumber>1</PartNumber>\n              <Size>#{5.megabytes}</Size>\n           </Part>\n           <Initiator>\n              <DisplayName>test-upload-user</DisplayName>\n              <ID>arn:aws:iam::123:user/test-upload-user</ID>\n           </Initiator>\n           <Owner>\n              <DisplayName></DisplayName>\n              <ID>12345</ID>\n           </Owner>\n           <StorageClass>STANDARD</StorageClass>\n        </ListPartsResult>\n        XML\n        stub_request(\n          :get,\n          \"#{upload_base_url}/#{external_upload_stub.key}?max-parts=1&uploadId=#{mock_multipart_upload_id}\",\n        ).to_return({ status: 200, body: list_multipart_result })\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/complete-multipart.json\", params: {}\n        expect(response.status).to eq(400)\n      end\n\n      it \"errors if the part_numbers do not contain numbers between 1 and 10000\" do\n        stub_list_multipart_request\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: -1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 20_001, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: \"blah\", etag: \"test1\" }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n      end\n\n      it \"errors if any of the parts objects have missing values\" do\n        stub_list_multipart_request\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1 }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\"All parts must have an etag\")\n      end\n\n      it \"returns 404 when the upload stub does not exist\" do\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: \"unknown\",\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 422 when the complete request errors\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:complete_multipart)\n          .raises(Aws::S3::Errors::ServiceError.new({}, \"test\"))\n        stub_list_multipart_request\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(422)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the multipart upload does not exist\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:list_multipart_parts)\n          .raises(Aws::S3::Errors::NoSuchUpload.new(\"test\", \"test\"))\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"completes the multipart upload, creates the Upload record, and returns a serialized Upload record\" do\n        temp_location = \"#{upload_base_url}/#{external_upload_stub.key}\"\n        stub_list_multipart_request\n        stub_request(\n          :post,\n          \"#{temp_location}?uploadId=#{external_upload_stub.external_upload_identifier}\",\n        ).with(\n          body:\n            \"<CompleteMultipartUpload xmlns=\\\"http://s3.amazonaws.com/doc/2006-03-01/\\\"><Part><ETag>test1</ETag><PartNumber>1</PartNumber></Part><Part><ETag>test2</ETag><PartNumber>2</PartNumber></Part></CompleteMultipartUpload>\",\n        ).to_return(status: 200, body: <<~XML)\n          <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n          <CompleteMultipartUploadResult>\n             <Location>#{temp_location}</Location>\n             <Bucket>s3-upload-bucket</Bucket>\n             <Key>#{external_upload_stub.key}</Key>\n             <ETag>testfinal</ETag>\n          </CompleteMultipartUploadResult>\n        XML\n\n        # all the functionality for ExternalUploadManager is already tested along\n        # with stubs to S3 in its own test, we can just stub the response here\n        upload = Fabricate(:upload)\n        ExternalUploadManager.any_instance.stubs(:transform!).returns(upload)\n\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n             }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[:upload]).to eq(JSON.parse(UploadSerializer.new(upload).to_json)[:upload])\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_complete_multipart_per_minute = 1\n\n          post \"/uploads/complete-multipart.json\",\n               params: {\n                 unique_identifier: \"blah\",\n                 parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n               }\n          post \"/uploads/complete-multipart.json\",\n               params: {\n                 unique_identifier: \"blah\",\n                 parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n               }\n\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.external_upload_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#abort_multipart\" do\n    let(:upload_base_url) do\n      \"https://#{SiteSetting.s3_upload_bucket}.#{SiteSetting.enable_s3_transfer_acceleration ? \"s3-accelerate\" : \"s3.#{SiteSetting.s3_region}\"}.amazonaws.com\"\n    end\n    let(:mock_multipart_upload_id) do\n      \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n    end\n    let!(:external_upload_stub) do\n      Fabricate(\n        :image_external_upload_stub,\n        created_by: user,\n        multipart: true,\n        external_upload_identifier: mock_multipart_upload_id,\n      )\n    end\n\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      def stub_abort_request\n        temp_location = \"#{upload_base_url}/#{external_upload_stub.key}\"\n        stub_request(\n          :delete,\n          \"#{temp_location}?uploadId=#{external_upload_stub.external_upload_identifier}\",\n        ).to_return(status: 200, body: \"\")\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/abort-multipart.json\", params: {}\n        expect(response.status).to eq(400)\n      end\n\n      it \"returns 200 when the stub does not exist, assumes it has already been deleted\" do\n        FileStore::S3Store.any_instance.expects(:abort_multipart).never\n        post \"/uploads/abort-multipart.json\", params: { external_upload_identifier: \"unknown\" }\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/abort-multipart.json\",\n             params: {\n               external_upload_identifier: external_upload_stub.external_upload_identifier,\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"aborts the multipart upload and deletes the stub\" do\n        stub_abort_request\n\n        post \"/uploads/abort-multipart.json\",\n             params: {\n               external_upload_identifier: external_upload_stub.external_upload_identifier,\n             }\n\n        expect(response.status).to eq(200)\n        expect(ExternalUploadStub.exists?(id: external_upload_stub.id)).to eq(false)\n      end\n\n      it \"returns 422 when the abort request errors\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:abort_multipart)\n          .raises(Aws::S3::Errors::ServiceError.new({}, \"test\"))\n        post \"/uploads/abort-multipart.json\",\n             params: {\n               external_upload_identifier: external_upload_stub.external_upload_identifier,\n             }\n        expect(response.status).to eq(422)\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.external_upload_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#complete_external_upload\" do\n    before { sign_in(user) }\n\n    context \"when the store is external\" do\n      fab!(:external_upload_stub) { Fabricate(:image_external_upload_stub, created_by: user) }\n      let(:upload) { Fabricate(:upload) }\n\n      before do\n        SiteSetting.enable_direct_s3_uploads = true\n        SiteSetting.enable_upload_debug_mode = true\n        setup_s3\n      end\n\n      it \"returns 404 when the upload stub does not exist\" do\n        post \"/uploads/complete-external-upload.json\", params: { unique_identifier: \"unknown\" }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"handles ChecksumMismatchError\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::ChecksumMismatchError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(\n          I18n.t(\"upload.checksum_mismatch_failure\"),\n        )\n      end\n\n      it \"handles SizeMismatchError\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::SizeMismatchError.new(\"expected: 10, actual: 1000\"))\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(\n          I18n.t(\"upload.size_mismatch_failure\", additional_detail: \"expected: 10, actual: 1000\"),\n        )\n      end\n\n      it \"handles CannotPromoteError\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::CannotPromoteError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.cannot_promote_failure\"))\n      end\n\n      it \"handles DownloadFailedError and Aws::S3::Errors::NotFound\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::DownloadFailedError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.download_failure\"))\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(Aws::S3::Errors::NotFound.new(\"error\", \"not found\"))\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.download_failure\"))\n      end\n\n      it \"handles a generic upload failure\" do\n        ExternalUploadManager.any_instance.stubs(:transform!).raises(StandardError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.failed\"))\n      end\n\n      it \"handles validation errors on the upload\" do\n        upload.errors.add(:base, \"test error\")\n        ExternalUploadManager.any_instance.stubs(:transform!).returns(upload)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to eq([\"test error\"])\n      end\n\n      it \"deletes the stub and returns the serialized upload when complete\" do\n        ExternalUploadManager.any_instance.stubs(:transform!).returns(upload)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(ExternalUploadStub.exists?(id: external_upload_stub.id)).to eq(false)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body).to eq(UploadsController.serialize_upload(upload))\n      end\n    end\n\n    context \"when the store is not external\" do\n      it \"returns 404\" do\n        post \"/uploads/generate-presigned-put.json\",\n             params: {\n               file_name: \"test.png\",\n               type: \"card_background\",\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"mini_mime\"\n\nclass UploadsController < ApplicationController\n  include ExternalUploadHelpers\n\n  requires_login except: %i[show show_short _show_secure_deprecated show_secure]\n\n  skip_before_action :preload_json,\n                     :check_xhr,\n                     :redirect_to_login_if_required,\n                     only: %i[show show_short _show_secure_deprecated show_secure]\n  protect_from_forgery except: :show\n\n  before_action :is_asset_path,\n                :apply_cdn_headers,\n                only: %i[show show_short _show_secure_deprecated show_secure]\n  before_action :external_store_check, only: %i[_show_secure_deprecated show_secure]\n\n  SECURE_REDIRECT_GRACE_SECONDS = 5\n\n  def create\n    # capture current user for block later on\n    me = current_user\n\n    params.permit(:type, :upload_type)\n    raise Discourse::InvalidParameters if params[:type].blank? && params[:upload_type].blank?\n    # 50 characters ought to be enough for the upload type\n    type =\n      (params[:upload_type].presence || params[:type].presence).parameterize(separator: \"_\")[0..50]\n\n    if type == \"avatar\" &&\n         (\n           SiteSetting.discourse_connect_overrides_avatar ||\n             !me.in_any_groups?(SiteSetting.uploaded_avatars_allowed_groups_map)\n         )\n      return render json: failed_json, status: 422\n    end\n\n    url = params[:url]\n    file = params[:file] || params[:files]&.first\n    pasted = params[:pasted] == \"true\"\n    for_private_message = params[:for_private_message] == \"true\"\n    for_site_setting = params[:for_site_setting] == \"true\"\n    is_api = is_api?\n    retain_hours = params[:retain_hours].to_i\n\n    # note, atm hijack is processed in its own context and has not access to controller\n    # longer term we may change this\n    hijack do\n      begin\n        info =\n          UploadsController.create_upload(\n            current_user: me,\n            file: file,\n            url: url,\n            type: type,\n            for_private_message: for_private_message,\n            for_site_setting: for_site_setting,\n            pasted: pasted,\n            is_api: is_api,\n            retain_hours: retain_hours,\n          )\n      rescue => e\n        render json: failed_json.merge(message: e.message&.split(\"\\n\")&.first), status: 422\n      else\n        render json: UploadsController.serialize_upload(info), status: Upload === info ? 200 : 422\n      end\n    end\n  end\n\n  def lookup_urls\n    params.permit(short_urls: [])\n    uploads = []\n\n    if (params[:short_urls] && params[:short_urls].length > 0)\n      PrettyText::Helpers\n        .lookup_upload_urls(params[:short_urls])\n        .each do |short_url, paths|\n          uploads << { short_url: short_url, url: paths[:url], short_path: paths[:short_path] }\n        end\n    end\n\n    render json: uploads.to_json\n  end\n\n  def show\n    # do not serve uploads requested via XHR to prevent XSS\n    return xhr_not_allowed if request.xhr?\n\n    return render_404 if !RailsMultisite::ConnectionManagement.has_db?(params[:site])\n\n    RailsMultisite::ConnectionManagement.with_connection(params[:site]) do |db|\n      return render_404 if SiteSetting.prevent_anons_from_downloading_files && current_user.nil?\n\n      if upload =\n           Upload.find_by(sha1: params[:sha]) ||\n             Upload.find_by(id: params[:id], url: request.env[\"PATH_INFO\"])\n        unless Discourse.store.internal?\n          local_store = FileStore::LocalStore.new\n          return render_404 unless local_store.has_been_uploaded?(upload.url)\n        end\n\n        send_file_local_upload(upload)\n      else\n        render_404\n      end\n    end\n  end\n\n  def show_short\n    # do not serve uploads requested via XHR to prevent XSS\n    return xhr_not_allowed if request.xhr?\n\n    return render_404 if SiteSetting.prevent_anons_from_downloading_files && current_user.nil?\n\n    sha1 = Upload.sha1_from_base62_encoded(params[:base62])\n\n    if upload = Upload.find_by(sha1: sha1)\n      return handle_secure_upload_request(upload) if upload.secure? && SiteSetting.secure_uploads?\n\n      if Discourse.store.internal?\n        send_file_local_upload(upload)\n      else\n        redirect_to Discourse.store.url_for(upload, force_download: force_download?),\n                    allow_other_host: true\n      end\n    else\n      render_404\n    end\n  end\n\n  # Kept to avoid rebaking old posts with /show-secure-uploads/ in their\n  # contents, this will ensure the uploads in these posts continue to\n  # work in future.\n  def _show_secure_deprecated\n    show_secure\n  end\n\n  def show_secure\n    # do not serve uploads requested via XHR to prevent XSS\n    return xhr_not_allowed if request.xhr?\n\n    path_with_ext = \"#{params[:path]}.#{params[:extension]}\"\n\n    sha1 = File.basename(path_with_ext, File.extname(path_with_ext))\n    # this takes care of optimized image requests\n    sha1 = sha1.partition(\"_\").first if sha1.include?(\"_\")\n\n    upload = Upload.find_by(sha1: sha1)\n    return render_404 if upload.blank?\n\n    return render_404 if SiteSetting.prevent_anons_from_downloading_files && current_user.nil?\n    return handle_secure_upload_request(upload, path_with_ext) if SiteSetting.secure_uploads?\n\n    # we don't want to 404 here if secure uploads gets disabled\n    # because all posts with secure uploads will show broken media\n    # until rebaked, which could take some time\n    #\n    # if the upload is still secure, that means the ACL is probably still\n    # private, so we don't want to go to the CDN url just yet otherwise we\n    # will get a 403. if the upload is not secure we assume the ACL is public\n    signed_secure_url = Discourse.store.signed_url_for_path(path_with_ext)\n    redirect_to upload.secure? ? signed_secure_url : Discourse.store.cdn_url(upload.url),\n                allow_other_host: true\n  end\n\n  def handle_secure_upload_request(upload, path_with_ext = nil)\n    if upload.access_control_post_id.present?\n      raise Discourse::InvalidAccess if current_user.nil? && SiteSetting.login_required\n      raise Discourse::InvalidAccess if !guardian.can_see?(upload.access_control_post)\n    else\n      return render_404 if current_user.nil?\n    end\n\n    # defaults to public: false, so only cached by the client browser\n    cache_seconds =\n      SiteSetting.s3_presigned_get_url_expires_after_seconds - SECURE_REDIRECT_GRACE_SECONDS\n    expires_in cache_seconds.seconds\n\n    # url_for figures out the full URL, handling multisite DBs,\n    # and will return a presigned URL for the upload\n    if path_with_ext.blank?\n      return(\n        redirect_to Discourse.store.url_for(upload, force_download: force_download?),\n                    allow_other_host: true\n      )\n    end\n\n    redirect_to Discourse.store.signed_url_for_path(\n                  path_with_ext,\n                  expires_in: SiteSetting.s3_presigned_get_url_expires_after_seconds,\n                  force_download: force_download?,\n                ),\n                allow_other_host: true\n  end\n\n  def metadata\n    params.require(:url)\n    upload = Upload.get_from_url(params[:url])\n    raise Discourse::NotFound unless upload\n\n    render json: {\n             original_filename: upload.original_filename,\n             width: upload.width,\n             height: upload.height,\n             human_filesize: upload.human_filesize,\n           }\n  end\n\n  protected\n\n  def validate_before_create_multipart(file_name:, file_size:, upload_type:)\n    validate_file_size(file_name: file_name, file_size: file_size)\n  end\n\n  def validate_before_create_direct_upload(file_name:, file_size:, upload_type:)\n    validate_file_size(file_name: file_name, file_size: file_size)\n  end\n\n  def validate_file_size(file_name:, file_size:)\n    raise ExternalUploadValidationError.new(I18n.t(\"upload.size_zero_failure\")) if file_size.zero?\n\n    if attachment_too_big?(file_name, file_size)\n      raise ExternalUploadValidationError.new(\n              I18n.t(\n                \"upload.attachments.too_large_humanized\",\n                max_size:\n                  ActiveSupport::NumberHelper.number_to_human_size(\n                    SiteSetting.max_attachment_size_kb.kilobytes,\n                  ),\n              ),\n            )\n    end\n\n    if image_too_big?(file_name, file_size)\n      raise ExternalUploadValidationError.new(\n              I18n.t(\n                \"upload.images.too_large_humanized\",\n                max_size:\n                  ActiveSupport::NumberHelper.number_to_human_size(\n                    SiteSetting.max_image_size_kb.kilobytes,\n                  ),\n              ),\n            )\n    end\n  end\n\n  def force_download?\n    params[:dl] == \"1\"\n  end\n\n  def xhr_not_allowed\n    raise Discourse::InvalidParameters.new(\"XHR not allowed\")\n  end\n\n  def self.serialize_upload(data)\n    # as_json.as_json is not a typo... as_json in AM serializer returns keys as symbols, we need them\n    # as strings here\n    serialized = UploadSerializer.new(data, root: nil).as_json.as_json if Upload === data\n    serialized ||= (data || {}).as_json\n  end\n\n  def self.create_upload(\n    current_user:,\n    file:,\n    url:,\n    type:,\n    for_private_message:,\n    for_site_setting:,\n    pasted:,\n    is_api:,\n    retain_hours:\n  )\n    if file.nil?\n      if url.present? && is_api\n        maximum_upload_size = [\n          SiteSetting.max_image_size_kb,\n          SiteSetting.max_attachment_size_kb,\n        ].max.kilobytes\n        tempfile =\n          begin\n            FileHelper.download(\n              url,\n              follow_redirect: true,\n              max_file_size: maximum_upload_size,\n              tmp_file_name: \"discourse-upload-#{type}\",\n            )\n          rescue StandardError\n            nil\n          end\n        filename = File.basename(URI.parse(url).path)\n      end\n    else\n      tempfile = file.tempfile\n      filename = file.original_filename\n    end\n\n    return { errors: [I18n.t(\"upload.file_missing\")] } if tempfile.nil?\n\n    opts = {\n      type: type,\n      for_private_message: for_private_message,\n      for_site_setting: for_site_setting,\n      pasted: pasted,\n    }\n\n    upload = UploadCreator.new(tempfile, filename, opts).create_for(current_user.id)\n\n    if upload.errors.empty? && current_user.admin?\n      upload.update_columns(retain_hours: retain_hours) if retain_hours > 0\n    end\n\n    upload.errors.empty? ? upload : { errors: upload.errors.to_hash.values.flatten }\n  ensure\n    tempfile&.close!\n  end\n\n  private\n\n  # We can preemptively check size for attachments, but not for (most) images\n  # as they may be further reduced in size by UploadCreator (at this point\n  # they may have already been reduced in size by preprocessors)\n  def attachment_too_big?(file_name, file_size)\n    !FileHelper.is_supported_image?(file_name) &&\n      file_size >= SiteSetting.max_attachment_size_kb.kilobytes\n  end\n\n  # Gifs are not resized on the client and not reduced in size by UploadCreator\n  def image_too_big?(file_name, file_size)\n    FileHelper.is_supported_image?(file_name) && File.extname(file_name) == \".gif\" &&\n      file_size >= SiteSetting.max_image_size_kb.kilobytes\n  end\n\n  def send_file_local_upload(upload)\n    opts = {\n      filename: upload.original_filename,\n      content_type: MiniMime.lookup_by_filename(upload.original_filename)&.content_type,\n    }\n\n    if !FileHelper.is_inline_image?(upload.original_filename)\n      opts[:disposition] = \"attachment\"\n    elsif params[:inline]\n      opts[:disposition] = \"inline\"\n    end\n\n    file_path = Discourse.store.path_for(upload)\n    return render_404 unless file_path\n\n    send_file(file_path, opts)\n  end\n\n  def create_direct_multipart_upload\n    begin\n      yield\n    rescue Aws::S3::Errors::ServiceError => err\n      message =\n        debug_upload_error(\n          err,\n          I18n.t(\"upload.create_multipart_failure\", additional_detail: err.message),\n        )\n      raise ExternalUploadHelpers::ExternalUploadValidationError.new(message)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe UploadsController do\n  fab!(:user) { Fabricate(:user, refresh_auto_groups: true) }\n\n  describe \"#create\" do\n    it \"requires you to be logged in\" do\n      post \"/uploads.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      let(:logo_file) { file_from_fixtures(\"logo.png\") }\n      let(:logo_filename) { File.basename(logo_file) }\n\n      let(:logo) { Rack::Test::UploadedFile.new(logo_file) }\n      let(:fake_jpg) { Rack::Test::UploadedFile.new(file_from_fixtures(\"fake.jpg\")) }\n      let(:text_file) { Rack::Test::UploadedFile.new(File.new(\"#{Rails.root}/LICENSE.txt\")) }\n\n      it \"expects a type or upload_type\" do\n        post \"/uploads.json\", params: { file: logo }\n        expect(response.status).to eq(400)\n        post \"/uploads.json\",\n             params: {\n               file: Rack::Test::UploadedFile.new(logo_file),\n               type: \"avatar\",\n             }\n        expect(response.status).to eq 200\n        post \"/uploads.json\",\n             params: {\n               file: Rack::Test::UploadedFile.new(logo_file),\n               upload_type: \"avatar\",\n             }\n        expect(response.status).to eq 200\n      end\n\n      it \"is successful with an image\" do\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq 200\n        expect(response.parsed_body[\"id\"]).to be_present\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(1)\n      end\n\n      it 'returns \"raw\" url for site settings' do\n        set_cdn_url \"https://awesome.com\"\n\n        upload = UploadCreator.new(logo_file, \"logo.png\").create_for(-1)\n        logo = Rack::Test::UploadedFile.new(file_from_fixtures(\"logo.png\"))\n\n        post \"/uploads.json\", params: { file: logo, type: \"site_setting\", for_site_setting: \"true\" }\n        expect(response.status).to eq 200\n        expect(response.parsed_body[\"url\"]).to eq(upload.url)\n      end\n\n      it \"returns cdn url\" do\n        set_cdn_url \"https://awesome.com\"\n        post \"/uploads.json\", params: { file: logo, type: \"composer\" }\n        expect(response.status).to eq 200\n        expect(response.parsed_body[\"url\"]).to start_with(\"https://awesome.com/uploads/default/\")\n      end\n\n      it \"is successful with an attachment\" do\n        SiteSetting.authorized_extensions = \"*\"\n\n        post \"/uploads.json\", params: { file: text_file, type: \"composer\" }\n        expect(response.status).to eq 200\n\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        id = response.parsed_body[\"id\"]\n        expect(id).to be\n      end\n\n      it \"is successful with api\" do\n        SiteSetting.authorized_extensions = \"*\"\n        api_key = Fabricate(:api_key, user: user).key\n\n        url = \"http://example.com/image.png\"\n        png = File.read(Rails.root + \"spec/fixtures/images/logo.png\")\n\n        stub_request(:get, url).to_return(status: 200, body: png)\n\n        post \"/uploads.json\",\n             params: {\n               url: url,\n               type: \"avatar\",\n             },\n             headers: {\n               HTTP_API_KEY: api_key,\n               HTTP_API_USERNAME: user.username.downcase,\n             }\n\n        json = response.parsed_body\n\n        expect(response.status).to eq(200)\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(1)\n        expect(json[\"id\"]).to be_present\n        expect(json[\"short_url\"]).to eq(\"upload://qUm0DGR49PAZshIi7HxMd3cAlzn.png\")\n      end\n\n      it \"correctly sets retain_hours for admins\" do\n        sign_in(Fabricate(:admin))\n\n        post \"/uploads.json\", params: { file: logo, retain_hours: 100, type: \"profile_background\" }\n\n        id = response.parsed_body[\"id\"]\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        expect(Upload.find(id).retain_hours).to eq(100)\n      end\n\n      it \"requires a file\" do\n        post \"/uploads.json\", params: { type: \"composer\" }\n\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        message = response.parsed_body\n        expect(response.status).to eq 422\n        expect(message[\"errors\"]).to contain_exactly(I18n.t(\"upload.file_missing\"))\n      end\n\n      it \"properly returns errors\" do\n        SiteSetting.authorized_extensions = \"*\"\n        SiteSetting.max_attachment_size_kb = 1\n\n        post \"/uploads.json\", params: { file: text_file, type: \"avatar\" }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        errors = response.parsed_body[\"errors\"]\n        expect(errors.first).to eq(\n          I18n.t(\"upload.attachments.too_large_humanized\", max_size: \"1 KB\"),\n        )\n      end\n\n      it \"ensures user belongs to uploaded_avatars_allowed_groups when uploading an avatar\" do\n        SiteSetting.uploaded_avatars_allowed_groups = \"13\"\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq(422)\n\n        user.update!(trust_level: 3)\n        Group.refresh_automatic_groups!\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq(200)\n      end\n\n      it \"ensures discourse_connect_overrides_avatar is not enabled when uploading an avatar\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        post \"/uploads.json\", params: { file: logo, type: \"avatar\" }\n        expect(response.status).to eq(422)\n      end\n\n      it \"allows staff to upload any file in PM\" do\n        SiteSetting.authorized_extensions = \"jpg\"\n        SiteSetting.allow_staff_to_upload_any_file_in_pm = true\n        user.update_columns(moderator: true)\n\n        post \"/uploads.json\",\n             params: {\n               file: text_file,\n               type: \"composer\",\n               for_private_message: \"true\",\n             }\n\n        expect(response.status).to eq(200)\n        id = response.parsed_body[\"id\"]\n        expect(Upload.last.id).to eq(id)\n      end\n\n      it \"allows staff to upload supported images for site settings\" do\n        SiteSetting.authorized_extensions = \"\"\n        user.update!(admin: true)\n\n        post \"/uploads.json\", params: { file: logo, type: \"site_setting\", for_site_setting: \"true\" }\n\n        expect(response.status).to eq(200)\n        id = response.parsed_body[\"id\"]\n\n        upload = Upload.last\n\n        expect(upload.id).to eq(id)\n        expect(upload.original_filename).to eq(logo_filename)\n      end\n\n      it \"respects `authorized_extensions_for_staff` setting when staff upload file\" do\n        SiteSetting.authorized_extensions = \"\"\n        SiteSetting.authorized_extensions_for_staff = \"*\"\n        user.update_columns(moderator: true)\n\n        post \"/uploads.json\", params: { file: text_file, type: \"composer\" }\n\n        expect(response.status).to eq(200)\n        data = response.parsed_body\n        expect(data[\"id\"]).to be_present\n      end\n\n      it \"ignores `authorized_extensions_for_staff` setting when non-staff upload file\" do\n        SiteSetting.authorized_extensions = \"\"\n        SiteSetting.authorized_extensions_for_staff = \"*\"\n\n        post \"/uploads.json\", params: { file: text_file, type: \"composer\" }\n\n        data = response.parsed_body\n        expect(data[\"errors\"].first).to eq(I18n.t(\"upload.unauthorized\", authorized_extensions: \"\"))\n      end\n\n      it \"returns an error when it could not determine the dimensions of an image\" do\n        post \"/uploads.json\", params: { file: fake_jpg, type: \"composer\" }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::CreateAvatarThumbnails.jobs.size).to eq(0)\n        message = response.parsed_body[\"errors\"]\n        expect(message).to contain_exactly(I18n.t(\"upload.images.size_not_found\"))\n      end\n    end\n  end\n\n  def upload_file(file, folder = \"images\")\n    fake_logo = Rack::Test::UploadedFile.new(file_from_fixtures(file, folder))\n    SiteSetting.authorized_extensions = \"*\"\n    sign_in(user)\n\n    post \"/uploads.json\", params: { file: fake_logo, type: \"composer\" }\n\n    expect(response.status).to eq(200)\n\n    url = response.parsed_body[\"url\"]\n    upload = Upload.get_from_url(url)\n    upload\n  end\n\n  describe \"#show\" do\n    let(:site) { \"default\" }\n    let(:sha) { Digest::SHA1.hexdigest(\"discourse\") }\n\n    context \"when using external storage\" do\n      fab!(:upload) { upload_file(\"small.pdf\", \"pdf\") }\n\n      before { setup_s3 }\n\n      it \"returns 404 \" do\n        upload = Fabricate(:upload_s3)\n        get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n\n        expect(response.response_code).to eq(404)\n      end\n\n      it \"returns upload if url not migrated\" do\n        get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n\n        expect(response.status).to eq(200)\n      end\n    end\n\n    it \"returns 404 when the upload doesn't exist\" do\n      get \"/uploads/#{site}/#{sha}.pdf\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns 404 when the path is nil\" do\n      upload = upload_file(\"logo.png\")\n      upload.update_column(:url, \"invalid-url\")\n\n      get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"uses send_file\" do\n      upload = upload_file(\"logo.png\")\n      get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n      expect(response.status).to eq(200)\n\n      expect(response.headers[\"Content-Disposition\"]).to eq(\n        %Q|attachment; filename=\"#{upload.original_filename}\"; filename*=UTF-8''#{upload.original_filename}|,\n      )\n    end\n\n    it \"returns 200 when js file\" do\n      ActionDispatch::FileHandler.any_instance.stubs(:match?).returns(false)\n      upload = upload_file(\"test.js\", \"themes\")\n      get upload.url\n      expect(response.status).to eq(200)\n    end\n\n    it \"handles image without extension\" do\n      SiteSetting.authorized_extensions = \"*\"\n      upload = upload_file(\"image_no_extension\")\n\n      get \"/uploads/#{site}/#{upload.sha1}.json\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Content-Disposition\"]).to eq(\n        %Q|attachment; filename=\"#{upload.original_filename}\"; filename*=UTF-8''#{upload.original_filename}|,\n      )\n    end\n\n    it \"handles file without extension\" do\n      SiteSetting.authorized_extensions = \"*\"\n      upload = upload_file(\"not_an_image\")\n\n      get \"/uploads/#{site}/#{upload.sha1}.json\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Content-Disposition\"]).to eq(\n        %Q|attachment; filename=\"#{upload.original_filename}\"; filename*=UTF-8''#{upload.original_filename}|,\n      )\n    end\n\n    context \"when user is anonymous\" do\n      it \"returns 404\" do\n        upload = upload_file(\"small.pdf\", \"pdf\")\n        delete \"/session/#{user.username}.json\"\n\n        SiteSetting.prevent_anons_from_downloading_files = true\n        get \"/uploads/#{site}/#{upload.sha1}.#{upload.extension}\"\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#show_short\" do\n    it \"inlines only supported image files\" do\n      upload = upload_file(\"smallest.png\")\n      get upload.short_path, params: { inline: true }\n      expect(response.header[\"Content-Type\"]).to eq(\"image/png\")\n      expect(response.header[\"Content-Disposition\"]).to include(\"inline;\")\n\n      upload.update!(original_filename: \"test.xml\")\n      get upload.short_path, params: { inline: true }\n      expect(response.header[\"Content-Type\"]).to eq(\"application/xml\")\n      expect(response.header[\"Content-Disposition\"]).to include(\"attachment;\")\n    end\n\n    describe \"local store\" do\n      fab!(:image_upload) { upload_file(\"smallest.png\") }\n\n      it \"returns the right response\" do\n        get image_upload.short_path\n\n        expect(response.status).to eq(200)\n\n        expect(response.headers[\"Content-Disposition\"]).to include(\n          \"attachment; filename=\\\"#{image_upload.original_filename}\\\"\",\n        )\n      end\n\n      it \"returns the right response when `inline` param is given\" do\n        get \"#{image_upload.short_path}?inline=1\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.headers[\"Content-Disposition\"]).to include(\n          \"inline; filename=\\\"#{image_upload.original_filename}\\\"\",\n        )\n      end\n\n      it \"returns the right response when base62 param is invalid \" do\n        get \"/uploads/short-url/12345.png\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns uploads with underscore in extension correctly\" do\n        fake_upload = upload_file(\"fake.not_image\")\n        get fake_upload.short_path\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns uploads with a dash and uppercase in extension correctly\" do\n        fake_upload = upload_file(\"fake.long-FileExtension\")\n        get fake_upload.short_path\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns the right response when anon tries to download a file \" \\\n           \"when prevent_anons_from_downloading_files is true\" do\n        delete \"/session/#{user.username}.json\"\n        SiteSetting.prevent_anons_from_downloading_files = true\n\n        get image_upload.short_path\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"s3 store\" do\n      let(:upload) { Fabricate(:upload_s3) }\n\n      before { setup_s3 }\n\n      it \"should redirect to the s3 URL\" do\n        get upload.short_path\n\n        expect(response).to redirect_to(upload.url)\n      end\n\n      context \"when upload is secure and secure uploads enabled\" do\n        before do\n          SiteSetting.secure_uploads = true\n          upload.update(secure: true)\n        end\n\n        it \"redirects to the signed_url_for_path\" do\n          sign_in(user)\n          freeze_time\n          get upload.short_path\n\n          expect(response).to redirect_to(\n            Discourse.store.signed_url_for_path(Discourse.store.get_path_for_upload(upload)),\n          )\n          expect(response.header[\"Location\"]).not_to include(\n            \"response-content-disposition=attachment\",\n          )\n        end\n\n        it \"respects the force download (dl) param\" do\n          sign_in(user)\n          freeze_time\n          get upload.short_path, params: { dl: \"1\" }\n          expect(response.header[\"Location\"]).to include(\"response-content-disposition=attachment\")\n        end\n\n        it \"has the correct caching header\" do\n          sign_in(user)\n          get upload.short_path\n\n          expected_max_age =\n            SiteSetting.s3_presigned_get_url_expires_after_seconds -\n              UploadsController::SECURE_REDIRECT_GRACE_SECONDS\n          expect(expected_max_age).to be > 0 # Sanity check that the constants haven't been set to broken values\n\n          expect(response.headers[\"Cache-Control\"]).to eq(\"max-age=#{expected_max_age}, private\")\n        end\n\n        it \"raises invalid access if the user cannot access the upload access control post\" do\n          sign_in(user)\n          post = Fabricate(:post)\n          post.topic.change_category_to_id(\n            Fabricate(:private_category, group: Fabricate(:group)).id,\n          )\n          upload.update(access_control_post: post)\n\n          get upload.short_path\n          expect(response.code).to eq(\"403\")\n        end\n      end\n    end\n  end\n\n  describe \"#show_secure\" do\n    describe \"local store\" do\n      fab!(:image_upload) { upload_file(\"smallest.png\") }\n\n      it \"does not return secure uploads when using local store\" do\n        secure_url = image_upload.url.sub(\"/uploads\", \"/secure-uploads\")\n        get secure_url\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"s3 store\" do\n      let(:upload) { Fabricate(:upload_s3) }\n      let(:secure_url) { upload.url.sub(SiteSetting.Upload.absolute_base_url, \"/secure-uploads\") }\n\n      before do\n        setup_s3\n        SiteSetting.authorized_extensions = \"*\"\n        SiteSetting.secure_uploads = true\n      end\n\n      it \"should return 404 for anonymous requests requests\" do\n        get secure_url\n        expect(response.status).to eq(404)\n      end\n\n      it \"should return signed url for legitimate request\" do\n        sign_in(user)\n        get secure_url\n\n        expect(response.status).to eq(302)\n        expect(response.redirect_url).to match(\"Amz-Expires\")\n      end\n\n      it \"should return secure uploads URL when looking up urls\" do\n        upload.update_column(:secure, true)\n        sign_in(user)\n\n        post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[0][\"url\"]).to match(\"secure-uploads\")\n      end\n\n      context \"when the upload cannot be found from the URL\" do\n        it \"returns a 404\" do\n          sign_in(user)\n          upload.update(sha1: \"test\")\n\n          get secure_url\n          expect(response.status).to eq(404)\n        end\n      end\n\n      context \"when the access_control_post_id has been set for the upload\" do\n        let(:post) { Fabricate(:post) }\n        let!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n        before { upload.update(access_control_post_id: post.id) }\n\n        context \"when the user is anon\" do\n          it \"should return signed url for public posts\" do\n            get secure_url\n            expect(response.status).to eq(302)\n            expect(response.redirect_url).to match(\"Amz-Expires\")\n          end\n\n          it \"should return 403 for deleted posts\" do\n            post.trash!\n            get secure_url\n            expect(response.status).to eq(403)\n          end\n\n          context \"when the user does not have access to the post via guardian\" do\n            before { post.topic.change_category_to_id(private_category.id) }\n\n            it \"returns a 403\" do\n              get secure_url\n              expect(response.status).to eq(403)\n            end\n          end\n        end\n\n        context \"when the user is logged in\" do\n          before { sign_in(user) }\n\n          context \"when the user has access to the post via guardian\" do\n            it \"should return signed url for legitimate request\" do\n              get secure_url\n              expect(response.status).to eq(302)\n              expect(response.redirect_url).to match(\"Amz-Expires\")\n            end\n          end\n\n          context \"when the user does not have access to the post via guardian\" do\n            before { post.topic.change_category_to_id(private_category.id) }\n\n            it \"returns a 403\" do\n              get secure_url\n              expect(response.status).to eq(403)\n            end\n          end\n        end\n      end\n\n      context \"when the upload is an attachment file\" do\n        before { upload.update(original_filename: \"test.pdf\") }\n        it \"redirects to the signed_url_for_path\" do\n          sign_in(user)\n          get secure_url\n          expect(response.status).to eq(302)\n          expect(response.redirect_url).to match(\"Amz-Expires\")\n        end\n\n        context \"when the user does not have access to the access control post via guardian\" do\n          let(:post) { Fabricate(:post) }\n          let!(:private_category) { Fabricate(:private_category, group: Fabricate(:group)) }\n\n          before do\n            post.topic.change_category_to_id(private_category.id)\n            upload.update(access_control_post_id: post.id)\n          end\n\n          it \"returns a 403\" do\n            sign_in(user)\n            get secure_url\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context \"when login is required and user is not signed in\" do\n          let(:post) { Fabricate(:post) }\n\n          before do\n            SiteSetting.login_required = true\n            upload.update(access_control_post_id: post.id)\n          end\n\n          it \"returns a 403\" do\n            get secure_url\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context \"when the prevent_anons_from_downloading_files setting is enabled and the user is anon\" do\n          before { SiteSetting.prevent_anons_from_downloading_files = true }\n\n          it \"returns a 404\" do\n            delete \"/session/#{user.username}.json\"\n            get secure_url\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      context \"when secure uploads is disabled\" do\n        before { SiteSetting.secure_uploads = false }\n\n        context \"if the upload is secure false, meaning the ACL is probably public\" do\n          before { upload.update(secure: false) }\n\n          it \"should redirect to the regular show route\" do\n            secure_url = upload.url.sub(SiteSetting.Upload.absolute_base_url, \"/secure-uploads\")\n            sign_in(user)\n            get secure_url\n\n            expect(response.status).to eq(302)\n            expect(response.redirect_url).to eq(Discourse.store.cdn_url(upload.url))\n          end\n        end\n\n        context \"if the upload is secure true, meaning the ACL is probably private\" do\n          before { upload.update(secure: true) }\n\n          it \"should redirect to the presigned URL still otherwise we will get a 403\" do\n            secure_url = upload.url.sub(SiteSetting.Upload.absolute_base_url, \"/secure-uploads\")\n            sign_in(user)\n            get secure_url\n\n            expect(response.status).to eq(302)\n            expect(response.redirect_url).to match(\"Amz-Expires\")\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#lookup_urls\" do\n    it \"can look up long urls\" do\n      sign_in(user)\n      upload = Fabricate(:upload)\n\n      post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n      expect(response.status).to eq(200)\n\n      result = response.parsed_body\n      expect(result[0][\"url\"]).to eq(upload.url)\n      expect(result[0][\"short_path\"]).to eq(upload.short_path)\n    end\n\n    describe \"secure uploads\" do\n      let(:upload) { Fabricate(:upload_s3, secure: true) }\n\n      before do\n        setup_s3\n        SiteSetting.authorized_extensions = \"pdf|png\"\n        SiteSetting.secure_uploads = true\n      end\n\n      it \"returns secure url for a secure uploads upload\" do\n        sign_in(user)\n\n        post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[0][\"url\"]).to match(\"/secure-uploads\")\n        expect(result[0][\"short_path\"]).to eq(upload.short_path)\n      end\n\n      it \"returns secure urls for non-media uploads\" do\n        upload.update!(original_filename: \"not-an-image.pdf\", extension: \"pdf\")\n        sign_in(user)\n\n        post \"/uploads/lookup-urls.json\", params: { short_urls: [upload.short_url] }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[0][\"url\"]).to match(\"/secure-uploads\")\n        expect(result[0][\"short_path\"]).to eq(upload.short_path)\n      end\n    end\n  end\n\n  describe \"#metadata\" do\n    fab!(:upload)\n\n    describe \"when url is missing\" do\n      it \"should return the right response\" do\n        post \"/uploads/lookup-metadata.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    describe \"when not signed in\" do\n      it \"should return the right response\" do\n        post \"/uploads/lookup-metadata.json\", params: { url: upload.url }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    describe \"when signed in\" do\n      before { sign_in(user) }\n\n      describe \"when url is invalid\" do\n        it \"should return the right response\" do\n          post \"/uploads/lookup-metadata.json\", params: { url: \"abc\" }\n\n          expect(response.status).to eq(404)\n        end\n      end\n\n      it \"should return the right response\" do\n        post \"/uploads/lookup-metadata.json\", params: { url: upload.url }\n\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n\n        expect(result[\"original_filename\"]).to eq(upload.original_filename)\n        expect(result[\"width\"]).to eq(upload.width)\n        expect(result[\"height\"]).to eq(upload.height)\n        expect(result[\"human_filesize\"]).to eq(upload.human_filesize)\n      end\n    end\n  end\n\n  describe \"#generate_presigned_put\" do\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/generate-presigned-put.json\", params: { file_name: \"test.png\" }\n        expect(response.status).to eq(400)\n        post \"/uploads/generate-presigned-put.json\", params: { type: \"card_background\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"generates a presigned URL and creates an external upload stub\" do\n        post \"/uploads/generate-presigned-put.json\",\n             params: {\n               file_name: \"test.png\",\n               type: \"card_background\",\n               file_size: 1024,\n             }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n\n        external_upload_stub =\n          ExternalUploadStub.where(\n            unique_identifier: result[\"unique_identifier\"],\n            original_filename: \"test.png\",\n            created_by: user,\n            upload_type: \"card_background\",\n            filesize: 1024,\n          )\n        expect(external_upload_stub.exists?).to eq(true)\n        expect(result[\"key\"]).to include(FileStore::S3Store::TEMPORARY_UPLOAD_PREFIX)\n        expect(result[\"url\"]).to include(FileStore::S3Store::TEMPORARY_UPLOAD_PREFIX)\n        expect(result[\"url\"]).to include(\"Amz-Expires\")\n      end\n\n      it \"includes accepted metadata in the response when provided\" do\n        post \"/uploads/generate-presigned-put.json\",\n             **{\n               params: {\n                 file_name: \"test.png\",\n                 file_size: 1024,\n                 type: \"card_background\",\n                 metadata: {\n                   \"sha1-checksum\" => \"testing\",\n                   \"blah\" => \"wontbeincluded\",\n                 },\n               },\n             }\n        expect(response.status).to eq(200)\n\n        result = response.parsed_body\n        expect(result[\"url\"]).not_to include(\"&x-amz-meta-sha1-checksum=testing\")\n        expect(result[\"url\"]).not_to include(\"&x-amz-meta-blah=wontbeincluded\")\n        expect(result[\"signed_headers\"]).to eq(\n          \"x-amz-acl\" => \"private\",\n          \"x-amz-meta-sha1-checksum\" => \"testing\",\n        )\n      end\n\n      context \"when enable_s3_transfer_acceleration is true\" do\n        before { SiteSetting.enable_s3_transfer_acceleration = true }\n\n        it \"uses the s3-accelerate endpoint for presigned URLs\" do\n          post \"/uploads/generate-presigned-put.json\",\n               **{\n                 params: {\n                   file_name: \"test.png\",\n                   file_size: 1024,\n                   type: \"card_background\",\n                   metadata: {\n                     \"sha1-checksum\" => \"testing\",\n                     \"blah\" => \"wontbeincluded\",\n                   },\n                 },\n               }\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n          expect(result[\"url\"]).to include(\"s3-accelerate\")\n        end\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_presigned_put_per_minute = 1\n\n          post \"/uploads/generate-presigned-put.json\",\n               params: {\n                 file_name: \"test.png\",\n                 type: \"card_background\",\n                 file_size: 1024,\n               }\n          post \"/uploads/generate-presigned-put.json\",\n               params: {\n                 file_name: \"test.png\",\n                 type: \"card_background\",\n                 file_size: 1024,\n               }\n\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/generate-presigned-put.json\",\n             params: {\n               file_name: \"test.png\",\n               type: \"card_background\",\n               file_size: 1024,\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#create_multipart\" do\n    context \"when the store is external\" do\n      let(:mock_multipart_upload_id) do\n        \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n      end\n      let(:test_bucket_prefix) { \"test_#{ENV[\"TEST_ENV_NUMBER\"].presence || \"0\"}\" }\n\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/create-multipart.json\", params: { file_name: \"test.png\" }\n        expect(response.status).to eq(400)\n        post \"/uploads/create-multipart.json\", params: { upload_type: \"composer\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"returns 422 when the create request errors\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:create_multipart)\n          .raises(Aws::S3::Errors::ServiceError.new({}, \"test\"))\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.png\", file_size: 1024, upload_type: \"composer\" } }\n        expect(response.status).to eq(422)\n      end\n\n      it \"returns 422 when the file is an attachment and it's too big\" do\n        SiteSetting.max_attachment_size_kb = 1024\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.zip\", file_size: 9_999_999, upload_type: \"composer\" } }\n        expect(response.status).to eq(422)\n        expect(response.body).to include(\n          I18n.t(\"upload.attachments.too_large_humanized\", max_size: \"1 MB\"),\n        )\n      end\n\n      it \"returns 422 when the file is an gif and it's too big, since gifs cannot be resized on client\" do\n        SiteSetting.max_image_size_kb = 1024\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.gif\", file_size: 9_999_999, upload_type: \"composer\" } }\n        expect(response.status).to eq(422)\n        expect(response.body).to include(\n          I18n.t(\"upload.images.too_large_humanized\", max_size: \"1 MB\"),\n        )\n      end\n\n      it \"returns a sensible error if the file size is 0 bytes\" do\n        SiteSetting.authorized_extensions = \"*\"\n        stub_create_multipart_request\n\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.zip\", file_size: 0, upload_type: \"composer\" } }\n\n        expect(response.status).to eq(422)\n        expect(response.body).to include(I18n.t(\"upload.size_zero_failure\"))\n      end\n\n      def stub_create_multipart_request\n        FileStore::S3Store\n          .any_instance\n          .stubs(:temporary_upload_path)\n          .returns(\n            \"uploads/default/#{test_bucket_prefix}/temp/28fccf8259bbe75b873a2bd2564b778c/test.png\",\n          )\n        create_multipart_result = <<~XML\n        <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\n        <InitiateMultipartUploadResult>\n           <Bucket>s3-upload-bucket</Bucket>\n           <Key>uploads/default/#{test_bucket_prefix}/temp/28fccf8259bbe75b873a2bd2564b778c/test.png</Key>\n           <UploadId>#{mock_multipart_upload_id}</UploadId>\n        </InitiateMultipartUploadResult>\n        XML\n        stub_request(\n          :post,\n          \"https://s3-upload-bucket.s3.us-west-1.amazonaws.com/uploads/default/#{test_bucket_prefix}/temp/28fccf8259bbe75b873a2bd2564b778c/test.png?uploads\",\n        ).to_return({ status: 200, body: create_multipart_result })\n      end\n\n      it \"creates a multipart upload and creates an external upload stub that is marked as multipart\" do\n        stub_create_multipart_request\n        post \"/uploads/create-multipart.json\",\n             **{ params: { file_name: \"test.png\", file_size: 1024, upload_type: \"composer\" } }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n\n        external_upload_stub =\n          ExternalUploadStub.where(\n            unique_identifier: result[\"unique_identifier\"],\n            original_filename: \"test.png\",\n            created_by: user,\n            upload_type: \"composer\",\n            key: result[\"key\"],\n            external_upload_identifier: mock_multipart_upload_id,\n            multipart: true,\n            filesize: 1024,\n          )\n        expect(external_upload_stub.exists?).to eq(true)\n        expect(result[\"key\"]).to include(FileStore::S3Store::TEMPORARY_UPLOAD_PREFIX)\n        expect(result[\"external_upload_identifier\"]).to eq(mock_multipart_upload_id)\n        expect(result[\"key\"]).to eq(external_upload_stub.last.key)\n      end\n\n      it \"includes accepted metadata when calling the store to create_multipart, but only allowed keys\" do\n        stub_create_multipart_request\n        FileStore::S3Store\n          .any_instance\n          .expects(:create_multipart)\n          .with(\"test.png\", \"image/png\", metadata: { \"sha1-checksum\" => \"testing\" })\n          .returns({ key: \"test\" })\n\n        post \"/uploads/create-multipart.json\",\n             **{\n               params: {\n                 file_name: \"test.png\",\n                 file_size: 1024,\n                 upload_type: \"composer\",\n                 metadata: {\n                   \"sha1-checksum\" => \"testing\",\n                   \"blah\" => \"wontbeincluded\",\n                 },\n               },\n             }\n\n        expect(response.status).to eq(200)\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_create_multipart_per_minute = 1\n\n          stub_create_multipart_request\n          post \"/uploads/create-multipart.json\",\n               params: {\n                 file_name: \"test.png\",\n                 upload_type: \"composer\",\n                 file_size: 1024,\n               }\n          expect(response.status).to eq(200)\n\n          post \"/uploads/create-multipart.json\",\n               params: {\n                 file_name: \"test.png\",\n                 upload_type: \"composer\",\n                 file_size: 1024,\n               }\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/create-multipart.json\",\n             params: {\n               file_name: \"test.png\",\n               upload_type: \"composer\",\n               file_size: 1024,\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#batch_presign_multipart_parts\" do\n    fab!(:mock_multipart_upload_id) do\n      \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n    end\n    fab!(:external_upload_stub) do\n      Fabricate(\n        :image_external_upload_stub,\n        created_by: user,\n        multipart: true,\n        external_upload_identifier: mock_multipart_upload_id,\n      )\n    end\n\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      def stub_list_multipart_request\n        list_multipart_result = <<~XML\n        <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\n        <ListPartsResult>\n           <Bucket>s3-upload-bucket</Bucket>\n           <Key>#{external_upload_stub.key}</Key>\n           <UploadId>#{mock_multipart_upload_id}</UploadId>\n           <PartNumberMarker>0</PartNumberMarker>\n           <NextPartNumberMarker>0</NextPartNumberMarker>\n           <MaxParts>1</MaxParts>\n           <IsTruncated>false</IsTruncated>\n           <Part>\n              <ETag>test</ETag>\n              <LastModified>#{Time.zone.now}</LastModified>\n              <PartNumber>1</PartNumber>\n              <Size>#{5.megabytes}</Size>\n           </Part>\n           <Initiator>\n              <DisplayName>test-upload-user</DisplayName>\n              <ID>arn:aws:iam::123:user/test-upload-user</ID>\n           </Initiator>\n           <Owner>\n              <DisplayName></DisplayName>\n              <ID>12345</ID>\n           </Owner>\n           <StorageClass>STANDARD</StorageClass>\n        </ListPartsResult>\n        XML\n        stub_request(\n          :get,\n          \"https://s3-upload-bucket.#{SiteSetting.enable_s3_transfer_acceleration ? \"s3-accelerate\" : \"s3.us-west-1\"}.amazonaws.com/#{external_upload_stub.key}?max-parts=1&uploadId=#{mock_multipart_upload_id}\",\n        ).to_return({ status: 200, body: list_multipart_result })\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/batch-presign-multipart-parts.json\", params: {}\n        expect(response.status).to eq(400)\n      end\n\n      it \"errors if the part_numbers do not contain numbers between 1 and 10000\" do\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [-1, 0, 1, 2, 3, 4],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [3, 4, \"blah\"],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n      end\n\n      it \"returns 404 when the upload stub does not exist\" do\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: \"unknown\",\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the multipart upload does not exist\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:list_multipart_parts)\n          .raises(Aws::S3::Errors::NoSuchUpload.new(\"test\", \"test\"))\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns an object with the presigned URLs with the part numbers as keys\" do\n        stub_list_multipart_request\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [2, 3, 4],\n             }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"presigned_urls\"].keys).to eq(%w[2 3 4])\n        expect(result[\"presigned_urls\"][\"2\"]).to include(\n          \"?partNumber=2&uploadId=#{mock_multipart_upload_id}\",\n        )\n        expect(result[\"presigned_urls\"][\"3\"]).to include(\n          \"?partNumber=3&uploadId=#{mock_multipart_upload_id}\",\n        )\n        expect(result[\"presigned_urls\"][\"4\"]).to include(\n          \"?partNumber=4&uploadId=#{mock_multipart_upload_id}\",\n        )\n      end\n\n      context \"when enable_s3_transfer_acceleration is true\" do\n        before { SiteSetting.enable_s3_transfer_acceleration = true }\n\n        it \"uses the s3-accelerate endpoint for presigned URLs\" do\n          stub_list_multipart_request\n          post \"/uploads/batch-presign-multipart-parts.json\",\n               params: {\n                 unique_identifier: external_upload_stub.unique_identifier,\n                 part_numbers: [2, 3, 4],\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"presigned_urls\"].keys).to eq(%w[2 3 4])\n          expect(result[\"presigned_urls\"][\"2\"]).to include(\"s3-accelerate\")\n        end\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_batch_presign_multipart_per_minute = 1\n\n          stub_list_multipart_request\n          post \"/uploads/batch-presign-multipart-parts.json\",\n               params: {\n                 unique_identifier: external_upload_stub.unique_identifier,\n                 part_numbers: [1, 2, 3],\n               }\n\n          expect(response.status).to eq(200)\n\n          post \"/uploads/batch-presign-multipart-parts.json\",\n               params: {\n                 unique_identifier: external_upload_stub.unique_identifier,\n                 part_numbers: [1, 2, 3],\n               }\n\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/batch-presign-multipart-parts.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               part_numbers: [1, 2, 3],\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#complete_multipart\" do\n    let(:upload_base_url) do\n      \"https://#{SiteSetting.s3_upload_bucket}.#{SiteSetting.enable_s3_transfer_acceleration ? \"s3-accelerate\" : \"s3.#{SiteSetting.s3_region}\"}.amazonaws.com\"\n    end\n    let(:mock_multipart_upload_id) do\n      \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n    end\n    let!(:external_upload_stub) do\n      Fabricate(\n        :image_external_upload_stub,\n        created_by: user,\n        multipart: true,\n        external_upload_identifier: mock_multipart_upload_id,\n      )\n    end\n\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      def stub_list_multipart_request\n        list_multipart_result = <<~XML\n        <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\n        <ListPartsResult>\n           <Bucket>s3-upload-bucket</Bucket>\n           <Key>#{external_upload_stub.key}</Key>\n           <UploadId>#{mock_multipart_upload_id}</UploadId>\n           <PartNumberMarker>0</PartNumberMarker>\n           <NextPartNumberMarker>0</NextPartNumberMarker>\n           <MaxParts>1</MaxParts>\n           <IsTruncated>false</IsTruncated>\n           <Part>\n              <ETag>test</ETag>\n              <LastModified>#{Time.zone.now}</LastModified>\n              <PartNumber>1</PartNumber>\n              <Size>#{5.megabytes}</Size>\n           </Part>\n           <Initiator>\n              <DisplayName>test-upload-user</DisplayName>\n              <ID>arn:aws:iam::123:user/test-upload-user</ID>\n           </Initiator>\n           <Owner>\n              <DisplayName></DisplayName>\n              <ID>12345</ID>\n           </Owner>\n           <StorageClass>STANDARD</StorageClass>\n        </ListPartsResult>\n        XML\n        stub_request(\n          :get,\n          \"#{upload_base_url}/#{external_upload_stub.key}?max-parts=1&uploadId=#{mock_multipart_upload_id}\",\n        ).to_return({ status: 200, body: list_multipart_result })\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/complete-multipart.json\", params: {}\n        expect(response.status).to eq(400)\n      end\n\n      it \"errors if the part_numbers do not contain numbers between 1 and 10000\" do\n        stub_list_multipart_request\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: -1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 20_001, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: \"blah\", etag: \"test1\" }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\n          \"You supplied invalid parameters to the request: Each part number should be between 1 and 10000\",\n        )\n      end\n\n      it \"errors if any of the parts objects have missing values\" do\n        stub_list_multipart_request\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1 }],\n             }\n        expect(response.status).to eq(400)\n        expect(response.body).to include(\"All parts must have an etag\")\n      end\n\n      it \"returns 404 when the upload stub does not exist\" do\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: \"unknown\",\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 422 when the complete request errors\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:complete_multipart)\n          .raises(Aws::S3::Errors::ServiceError.new({}, \"test\"))\n        stub_list_multipart_request\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(422)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the multipart upload does not exist\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:list_multipart_parts)\n          .raises(Aws::S3::Errors::NoSuchUpload.new(\"test\", \"test\"))\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"completes the multipart upload, creates the Upload record, and returns a serialized Upload record\" do\n        temp_location = \"#{upload_base_url}/#{external_upload_stub.key}\"\n        stub_list_multipart_request\n        stub_request(\n          :post,\n          \"#{temp_location}?uploadId=#{external_upload_stub.external_upload_identifier}\",\n        ).with(\n          body:\n            \"<CompleteMultipartUpload xmlns=\\\"http://s3.amazonaws.com/doc/2006-03-01/\\\"><Part><ETag>test1</ETag><PartNumber>1</PartNumber></Part><Part><ETag>test2</ETag><PartNumber>2</PartNumber></Part></CompleteMultipartUpload>\",\n        ).to_return(status: 200, body: <<~XML)\n          <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n          <CompleteMultipartUploadResult>\n             <Location>#{temp_location}</Location>\n             <Bucket>s3-upload-bucket</Bucket>\n             <Key>#{external_upload_stub.key}</Key>\n             <ETag>testfinal</ETag>\n          </CompleteMultipartUploadResult>\n        XML\n\n        # all the functionality for ExternalUploadManager is already tested along\n        # with stubs to S3 in its own test, we can just stub the response here\n        upload = Fabricate(:upload)\n        ExternalUploadManager.any_instance.stubs(:transform!).returns(upload)\n\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n             }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[:upload]).to eq(JSON.parse(UploadSerializer.new(upload).to_json)[:upload])\n      end\n\n      describe \"rate limiting\" do\n        before { RateLimiter.enable }\n\n        use_redis_snapshotting\n\n        it \"rate limits\" do\n          SiteSetting.max_complete_multipart_per_minute = 1\n\n          post \"/uploads/complete-multipart.json\",\n               params: {\n                 unique_identifier: \"blah\",\n                 parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n               }\n          post \"/uploads/complete-multipart.json\",\n               params: {\n                 unique_identifier: \"blah\",\n                 parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n               }\n\n          expect(response.status).to eq(429)\n        end\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.external_upload_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#abort_multipart\" do\n    let(:upload_base_url) do\n      \"https://#{SiteSetting.s3_upload_bucket}.#{SiteSetting.enable_s3_transfer_acceleration ? \"s3-accelerate\" : \"s3.#{SiteSetting.s3_region}\"}.amazonaws.com\"\n    end\n    let(:mock_multipart_upload_id) do\n      \"ibZBv_75gd9r8lH_gqXatLdxMVpAlj6CFTR.OwyF3953YdwbcQnMA2BLGn8Lx12fQNICtMw5KyteFeHw.Sjng--\"\n    end\n    let!(:external_upload_stub) do\n      Fabricate(\n        :image_external_upload_stub,\n        created_by: user,\n        multipart: true,\n        external_upload_identifier: mock_multipart_upload_id,\n      )\n    end\n\n    context \"when the store is external\" do\n      before do\n        sign_in(user)\n        SiteSetting.enable_direct_s3_uploads = true\n        setup_s3\n      end\n\n      def stub_abort_request\n        temp_location = \"#{upload_base_url}/#{external_upload_stub.key}\"\n        stub_request(\n          :delete,\n          \"#{temp_location}?uploadId=#{external_upload_stub.external_upload_identifier}\",\n        ).to_return(status: 200, body: \"\")\n      end\n\n      it \"errors if the correct params are not provided\" do\n        post \"/uploads/abort-multipart.json\", params: {}\n        expect(response.status).to eq(400)\n      end\n\n      it \"returns 200 when the stub does not exist, assumes it has already been deleted\" do\n        FileStore::S3Store.any_instance.expects(:abort_multipart).never\n        post \"/uploads/abort-multipart.json\", params: { external_upload_identifier: \"unknown\" }\n        expect(response.status).to eq(200)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/abort-multipart.json\",\n             params: {\n               external_upload_identifier: external_upload_stub.external_upload_identifier,\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"aborts the multipart upload and deletes the stub\" do\n        stub_abort_request\n\n        post \"/uploads/abort-multipart.json\",\n             params: {\n               external_upload_identifier: external_upload_stub.external_upload_identifier,\n             }\n\n        expect(response.status).to eq(200)\n        expect(ExternalUploadStub.exists?(id: external_upload_stub.id)).to eq(false)\n      end\n\n      it \"returns 422 when the abort request errors\" do\n        FileStore::S3Store\n          .any_instance\n          .stubs(:abort_multipart)\n          .raises(Aws::S3::Errors::ServiceError.new({}, \"test\"))\n        post \"/uploads/abort-multipart.json\",\n             params: {\n               external_upload_identifier: external_upload_stub.external_upload_identifier,\n             }\n        expect(response.status).to eq(422)\n      end\n    end\n\n    context \"when the store is not external\" do\n      before { sign_in(user) }\n\n      it \"returns 404\" do\n        post \"/uploads/complete-multipart.json\",\n             params: {\n               unique_identifier: external_upload_stub.external_upload_identifier,\n               parts: [{ part_number: 1, etag: \"test1\" }, { part_number: 2, etag: \"test2\" }],\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#complete_external_upload\" do\n    before { sign_in(user) }\n\n    context \"when the store is external\" do\n      fab!(:external_upload_stub) { Fabricate(:image_external_upload_stub, created_by: user) }\n      let(:upload) { Fabricate(:upload) }\n\n      before do\n        SiteSetting.enable_direct_s3_uploads = true\n        SiteSetting.enable_upload_debug_mode = true\n        setup_s3\n      end\n\n      it \"returns 404 when the upload stub does not exist\" do\n        post \"/uploads/complete-external-upload.json\", params: { unique_identifier: \"unknown\" }\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns 404 when the upload stub does not belong to the user\" do\n        external_upload_stub.update!(created_by: Fabricate(:user))\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(404)\n      end\n\n      it \"handles ChecksumMismatchError\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::ChecksumMismatchError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(\n          I18n.t(\"upload.checksum_mismatch_failure\"),\n        )\n      end\n\n      it \"handles SizeMismatchError\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::SizeMismatchError.new(\"expected: 10, actual: 1000\"))\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(\n          I18n.t(\"upload.size_mismatch_failure\", additional_detail: \"expected: 10, actual: 1000\"),\n        )\n      end\n\n      it \"handles CannotPromoteError\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::CannotPromoteError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.cannot_promote_failure\"))\n      end\n\n      it \"handles DownloadFailedError and Aws::S3::Errors::NotFound\" do\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(ExternalUploadManager::DownloadFailedError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.download_failure\"))\n        ExternalUploadManager\n          .any_instance\n          .stubs(:transform!)\n          .raises(Aws::S3::Errors::NotFound.new(\"error\", \"not found\"))\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.download_failure\"))\n      end\n\n      it \"handles a generic upload failure\" do\n        ExternalUploadManager.any_instance.stubs(:transform!).raises(StandardError)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"].first).to eq(I18n.t(\"upload.failed\"))\n      end\n\n      it \"handles validation errors on the upload\" do\n        upload.errors.add(:base, \"test error\")\n        ExternalUploadManager.any_instance.stubs(:transform!).returns(upload)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to eq([\"test error\"])\n      end\n\n      it \"deletes the stub and returns the serialized upload when complete\" do\n        ExternalUploadManager.any_instance.stubs(:transform!).returns(upload)\n        post \"/uploads/complete-external-upload.json\",\n             params: {\n               unique_identifier: external_upload_stub.unique_identifier,\n             }\n        expect(ExternalUploadStub.exists?(id: external_upload_stub.id)).to eq(false)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body).to eq(UploadsController.serialize_upload(upload))\n      end\n    end\n\n    context \"when the store is not external\" do\n      it \"returns 404\" do\n        post \"/uploads/generate-presigned-put.json\",\n             params: {\n               file_name: \"test.png\",\n               type: \"card_background\",\n             }\n        expect(response.status).to eq(404)\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/uploads_controller.rb", "spec/requests/uploads_controller_spec.rb"], "buggy_code_start_loc": [170, 575], "buggy_code_end_loc": [170, 575], "fixing_code_start_loc": [171, 576], "fixing_code_end_loc": [172, 590], "type": "CWE-284", "message": "Discourse is a platform for community discussion. Under very specific circumstances, secure upload URLs associated with posts can be accessed by guest users even when login is required. This vulnerability has been patched in 3.2.0.beta4 and 3.1.4.", "other": {"cve": {"id": "CVE-2023-49099", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-12T21:15:09.747", "lastModified": "2024-01-25T15:32:52.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is a platform for community discussion. Under very specific circumstances, secure upload URLs associated with posts can be accessed by guest users even when login is required. This vulnerability has been patched in 3.2.0.beta4 and 3.1.4."}, {"lang": "es", "value": "Discourse es una plataforma para la discusi\u00f3n comunitaria. En circunstancias muy espec\u00edficas, los usuarios invitados pueden acceder a las URL de carga segura asociadas con las publicaciones incluso cuando se requiere iniciar sesi\u00f3n. Esta vulnerabilidad ha sido parcheada en 3.2.0.beta4 y 3.1.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.1.4", "matchCriteriaId": "A51406A4-A2FE-4BFE-8EA0-58359582D6A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "1BFF647B-6CEF-43BF-BF5E-C82B557F78E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "10D931DE-F8F5-4A34-A30A-FDD4420ABD1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "C62C36D4-6CE7-4A57-BBF7-8066CFAE342A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/1b288236387fc0a823e4f15f1aea8dde81b49d53", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-j67x-x6mq-pwv4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/1b288236387fc0a823e4f15f1aea8dde81b49d53"}}