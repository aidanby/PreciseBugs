{"buggy_code": ["// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage tls\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdh\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype clientHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tserverHello  *serverHelloMsg\n\thello        *clientHelloMsg\n\tsuite        *cipherSuite\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tsession      *SessionState // the session being resumed\n\tticket       []byte        // a fresh ticket received during this handshake\n}\n\nvar testingOnlyForceClientHelloSignatureAlgorithms []SignatureScheme\n\nfunc (c *Conn) makeClientHello() (*clientHelloMsg, *ecdh.PrivateKey, error) {\n\tconfig := c.config\n\tif len(config.ServerName) == 0 && !config.InsecureSkipVerify {\n\t\treturn nil, nil, errors.New(\"tls: either ServerName or InsecureSkipVerify must be specified in the tls.Config\")\n\t}\n\n\tnextProtosLength := 0\n\tfor _, proto := range config.NextProtos {\n\t\tif l := len(proto); l == 0 || l > 255 {\n\t\t\treturn nil, nil, errors.New(\"tls: invalid NextProtos value\")\n\t\t} else {\n\t\t\tnextProtosLength += 1 + l\n\t\t}\n\t}\n\tif nextProtosLength > 0xffff {\n\t\treturn nil, nil, errors.New(\"tls: NextProtos values too large\")\n\t}\n\n\tsupportedVersions := config.supportedVersions(roleClient)\n\tif len(supportedVersions) == 0 {\n\t\treturn nil, nil, errors.New(\"tls: no supported versions satisfy MinVersion and MaxVersion\")\n\t}\n\n\tclientHelloVersion := config.maxSupportedVersion(roleClient)\n\t// The version at the beginning of the ClientHello was capped at TLS 1.2\n\t// for compatibility reasons. The supported_versions extension is used\n\t// to negotiate versions now. See RFC 8446, Section 4.2.1.\n\tif clientHelloVersion > VersionTLS12 {\n\t\tclientHelloVersion = VersionTLS12\n\t}\n\n\thello := &clientHelloMsg{\n\t\tvers:                         clientHelloVersion,\n\t\tcompressionMethods:           []uint8{compressionNone},\n\t\trandom:                       make([]byte, 32),\n\t\textendedMasterSecret:         true,\n\t\tocspStapling:                 true,\n\t\tscts:                         true,\n\t\tserverName:                   hostnameInSNI(config.ServerName),\n\t\tsupportedCurves:              config.curvePreferences(),\n\t\tsupportedPoints:              []uint8{pointFormatUncompressed},\n\t\tsecureRenegotiationSupported: true,\n\t\talpnProtocols:                config.NextProtos,\n\t\tsupportedVersions:            supportedVersions,\n\t}\n\n\tif c.handshakes > 0 {\n\t\thello.secureRenegotiation = c.clientFinished[:]\n\t}\n\n\tpreferenceOrder := cipherSuitesPreferenceOrder\n\tif !hasAESGCMHardwareSupport {\n\t\tpreferenceOrder = cipherSuitesPreferenceOrderNoAES\n\t}\n\tconfigCipherSuites := config.cipherSuites()\n\thello.cipherSuites = make([]uint16, 0, len(configCipherSuites))\n\n\tfor _, suiteId := range preferenceOrder {\n\t\tsuite := mutualCipherSuite(configCipherSuites, suiteId)\n\t\tif suite == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Don't advertise TLS 1.2-only cipher suites unless\n\t\t// we're attempting TLS 1.2.\n\t\tif hello.vers < VersionTLS12 && suite.flags&suiteTLS12 != 0 {\n\t\t\tcontinue\n\t\t}\n\t\thello.cipherSuites = append(hello.cipherSuites, suiteId)\n\t}\n\n\t_, err := io.ReadFull(config.rand(), hello.random)\n\tif err != nil {\n\t\treturn nil, nil, errors.New(\"tls: short read from Rand: \" + err.Error())\n\t}\n\n\t// A random session ID is used to detect when the server accepted a ticket\n\t// and is resuming a session (see RFC 5077). In TLS 1.3, it's always set as\n\t// a compatibility measure (see RFC 8446, Section 4.1.2).\n\t//\n\t// The session ID is not set for QUIC connections (see RFC 9001, Section 8.4).\n\tif c.quic == nil {\n\t\thello.sessionId = make([]byte, 32)\n\t\tif _, err := io.ReadFull(config.rand(), hello.sessionId); err != nil {\n\t\t\treturn nil, nil, errors.New(\"tls: short read from Rand: \" + err.Error())\n\t\t}\n\t}\n\n\tif hello.vers >= VersionTLS12 {\n\t\thello.supportedSignatureAlgorithms = supportedSignatureAlgorithms()\n\t}\n\tif testingOnlyForceClientHelloSignatureAlgorithms != nil {\n\t\thello.supportedSignatureAlgorithms = testingOnlyForceClientHelloSignatureAlgorithms\n\t}\n\n\tvar key *ecdh.PrivateKey\n\tif hello.supportedVersions[0] == VersionTLS13 {\n\t\t// Reset the list of ciphers when the client only supports TLS 1.3.\n\t\tif len(hello.supportedVersions) == 1 {\n\t\t\thello.cipherSuites = nil\n\t\t}\n\t\tif hasAESGCMHardwareSupport {\n\t\t\thello.cipherSuites = append(hello.cipherSuites, defaultCipherSuitesTLS13...)\n\t\t} else {\n\t\t\thello.cipherSuites = append(hello.cipherSuites, defaultCipherSuitesTLS13NoAES...)\n\t\t}\n\n\t\tcurveID := config.curvePreferences()[0]\n\t\tif _, ok := curveForCurveID(curveID); !ok {\n\t\t\treturn nil, nil, errors.New(\"tls: CurvePreferences includes unsupported curve\")\n\t\t}\n\t\tkey, err = generateECDHEKey(config.rand(), curveID)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\thello.keyShares = []keyShare{{group: curveID, data: key.PublicKey().Bytes()}}\n\t}\n\n\tif c.quic != nil {\n\t\tp, err := c.quicGetTransportParameters()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif p == nil {\n\t\t\tp = []byte{}\n\t\t}\n\t\thello.quicTransportParameters = p\n\t}\n\n\treturn hello, key, nil\n}\n\nfunc (c *Conn) clientHandshake(ctx context.Context) (err error) {\n\tif c.config == nil {\n\t\tc.config = defaultConfig()\n\t}\n\n\t// This may be a renegotiation handshake, in which case some fields\n\t// need to be reset.\n\tc.didResume = false\n\n\thello, ecdheKey, err := c.makeClientHello()\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.serverName = hello.serverName\n\n\tsession, earlySecret, binderKey, err := c.loadSession(hello)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif session != nil {\n\t\tdefer func() {\n\t\t\t// If we got a handshake failure when resuming a session, throw away\n\t\t\t// the session ticket. See RFC 5077, Section 3.2.\n\t\t\t//\n\t\t\t// RFC 8446 makes no mention of dropping tickets on failure, but it\n\t\t\t// does require servers to abort on invalid binders, so we need to\n\t\t\t// delete tickets to recover from a corrupted PSK.\n\t\t\tif err != nil {\n\t\t\t\tif cacheKey := c.clientSessionCacheKey(); cacheKey != \"\" {\n\t\t\t\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tif _, err := c.writeHandshakeRecord(hello, nil); err != nil {\n\t\treturn err\n\t}\n\n\tif hello.earlyData {\n\t\tsuite := cipherSuiteTLS13ByID(session.cipherSuite)\n\t\ttranscript := suite.hash.New()\n\t\tif err := transcriptMsg(hello, transcript); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tearlyTrafficSecret := suite.deriveSecret(earlySecret, clientEarlyTrafficLabel, transcript)\n\t\tc.quicSetWriteSecret(QUICEncryptionLevelEarly, suite.id, earlyTrafficSecret)\n\t}\n\n\t// serverHelloMsg is not included in the transcript\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserverHello, ok := msg.(*serverHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(serverHello, msg)\n\t}\n\n\tif err := c.pickTLSVersion(serverHello); err != nil {\n\t\treturn err\n\t}\n\n\t// If we are negotiating a protocol version that's lower than what we\n\t// support, check for the server downgrade canaries.\n\t// See RFC 8446, Section 4.1.3.\n\tmaxVers := c.config.maxSupportedVersion(roleClient)\n\ttls12Downgrade := string(serverHello.random[24:]) == downgradeCanaryTLS12\n\ttls11Downgrade := string(serverHello.random[24:]) == downgradeCanaryTLS11\n\tif maxVers == VersionTLS13 && c.vers <= VersionTLS12 && (tls12Downgrade || tls11Downgrade) ||\n\t\tmaxVers == VersionTLS12 && c.vers <= VersionTLS11 && tls11Downgrade {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: downgrade attempt detected, possibly due to a MitM attack or a broken middlebox\")\n\t}\n\n\tif c.vers == VersionTLS13 {\n\t\ths := &clientHandshakeStateTLS13{\n\t\t\tc:           c,\n\t\t\tctx:         ctx,\n\t\t\tserverHello: serverHello,\n\t\t\thello:       hello,\n\t\t\tecdheKey:    ecdheKey,\n\t\t\tsession:     session,\n\t\t\tearlySecret: earlySecret,\n\t\t\tbinderKey:   binderKey,\n\t\t}\n\n\t\t// In TLS 1.3, session tickets are delivered after the handshake.\n\t\treturn hs.handshake()\n\t}\n\n\ths := &clientHandshakeState{\n\t\tc:           c,\n\t\tctx:         ctx,\n\t\tserverHello: serverHello,\n\t\thello:       hello,\n\t\tsession:     session,\n\t}\n\n\tif err := hs.handshake(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *Conn) loadSession(hello *clientHelloMsg) (\n\tsession *SessionState, earlySecret, binderKey []byte, err error) {\n\tif c.config.SessionTicketsDisabled || c.config.ClientSessionCache == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\thello.ticketSupported = true\n\n\tif hello.supportedVersions[0] == VersionTLS13 {\n\t\t// Require DHE on resumption as it guarantees forward secrecy against\n\t\t// compromise of the session ticket key. See RFC 8446, Section 4.2.9.\n\t\thello.pskModes = []uint8{pskModeDHE}\n\t}\n\n\t// Session resumption is not allowed if renegotiating because\n\t// renegotiation is primarily used to allow a client to send a client\n\t// certificate, which would be skipped if session resumption occurred.\n\tif c.handshakes != 0 {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// Try to resume a previously negotiated TLS session, if available.\n\tcacheKey := c.clientSessionCacheKey()\n\tif cacheKey == \"\" {\n\t\treturn nil, nil, nil, nil\n\t}\n\tcs, ok := c.config.ClientSessionCache.Get(cacheKey)\n\tif !ok || cs == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\tsession = cs.session\n\n\t// Check that version used for the previous session is still valid.\n\tversOk := false\n\tfor _, v := range hello.supportedVersions {\n\t\tif v == session.version {\n\t\t\tversOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !versOk {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// Check that the cached server certificate is not expired, and that it's\n\t// valid for the ServerName. This should be ensured by the cache key, but\n\t// protect the application from a faulty ClientSessionCache implementation.\n\tif c.config.time().After(session.peerCertificates[0].NotAfter) {\n\t\t// Expired certificate, delete the entry.\n\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\treturn nil, nil, nil, nil\n\t}\n\tif !c.config.InsecureSkipVerify {\n\t\tif len(session.verifiedChains) == 0 {\n\t\t\t// The original connection had InsecureSkipVerify, while this doesn't.\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\t\tif err := session.peerCertificates[0].VerifyHostname(c.config.ServerName); err != nil {\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\t}\n\n\tif session.version != VersionTLS13 {\n\t\t// In TLS 1.2 the cipher suite must match the resumed session. Ensure we\n\t\t// are still offering it.\n\t\tif mutualCipherSuite(hello.cipherSuites, session.cipherSuite) == nil {\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\n\t\thello.sessionTicket = cs.ticket\n\t\treturn\n\t}\n\n\t// Check that the session ticket is not expired.\n\tif c.config.time().After(time.Unix(int64(session.useBy), 0)) {\n\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// In TLS 1.3 the KDF hash must match the resumed session. Ensure we\n\t// offer at least one cipher suite with that hash.\n\tcipherSuite := cipherSuiteTLS13ByID(session.cipherSuite)\n\tif cipherSuite == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\tcipherSuiteOk := false\n\tfor _, offeredID := range hello.cipherSuites {\n\t\tofferedSuite := cipherSuiteTLS13ByID(offeredID)\n\t\tif offeredSuite != nil && offeredSuite.hash == cipherSuite.hash {\n\t\t\tcipherSuiteOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !cipherSuiteOk {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\tif c.quic != nil && session.EarlyData {\n\t\t// For 0-RTT, the cipher suite has to match exactly, and we need to be\n\t\t// offering the same ALPN.\n\t\tif mutualCipherSuiteTLS13(hello.cipherSuites, session.cipherSuite) != nil {\n\t\t\tfor _, alpn := range hello.alpnProtocols {\n\t\t\t\tif alpn == session.alpnProtocol {\n\t\t\t\t\thello.earlyData = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the pre_shared_key extension. See RFC 8446, Section 4.2.11.1.\n\tticketAge := c.config.time().Sub(time.Unix(int64(session.createdAt), 0))\n\tidentity := pskIdentity{\n\t\tlabel:               cs.ticket,\n\t\tobfuscatedTicketAge: uint32(ticketAge/time.Millisecond) + session.ageAdd,\n\t}\n\thello.pskIdentities = []pskIdentity{identity}\n\thello.pskBinders = [][]byte{make([]byte, cipherSuite.hash.Size())}\n\n\t// Compute the PSK binders. See RFC 8446, Section 4.2.11.2.\n\tearlySecret = cipherSuite.extract(session.secret, nil)\n\tbinderKey = cipherSuite.deriveSecret(earlySecret, resumptionBinderLabel, nil)\n\ttranscript := cipherSuite.hash.New()\n\thelloBytes, err := hello.marshalWithoutBinders()\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\ttranscript.Write(helloBytes)\n\tpskBinders := [][]byte{cipherSuite.finishedHash(binderKey, transcript)}\n\tif err := hello.updateBinders(pskBinders); err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\treturn\n}\n\nfunc (c *Conn) pickTLSVersion(serverHello *serverHelloMsg) error {\n\tpeerVersion := serverHello.vers\n\tif serverHello.supportedVersion != 0 {\n\t\tpeerVersion = serverHello.supportedVersion\n\t}\n\n\tvers, ok := c.config.mutualVersion(roleClient, []uint16{peerVersion})\n\tif !ok {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn fmt.Errorf(\"tls: server selected unsupported protocol version %x\", peerVersion)\n\t}\n\n\tc.vers = vers\n\tc.haveVers = true\n\tc.in.version = vers\n\tc.out.version = vers\n\n\treturn nil\n}\n\n// Does the handshake, either a full one or resumes old session. Requires hs.c,\n// hs.hello, hs.serverHello, and, optionally, hs.session to be set.\nfunc (hs *clientHandshakeState) handshake() error {\n\tc := hs.c\n\n\tisResume, err := hs.processServerHello()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ths.finishedHash = newFinishedHash(c.vers, hs.suite)\n\n\t// No signatures of the handshake are needed in a resumption.\n\t// Otherwise, in a full handshake, if we don't have any certificates\n\t// configured then we will never send a CertificateVerify message and\n\t// thus no signatures are needed in that case either.\n\tif isResume || (len(c.config.Certificates) == 0 && c.config.GetClientCertificate == nil) {\n\t\ths.finishedHash.discardHandshakeBuffer()\n\t}\n\n\tif err := transcriptMsg(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif err := transcriptMsg(hs.serverHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tc.buffering = true\n\tc.didResume = isResume\n\tif isResume {\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = false\n\t\t// Make sure the connection is still being verified whether or not this\n\t\t// is a resumption. Resumptions currently don't reverify certificates so\n\t\t// they don't call verifyServerCertificate. See Issue 31641.\n\t\tif c.config.VerifyConnection != nil {\n\t\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := hs.doFullHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = true\n\t\tif err := hs.readSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := hs.saveSessionTicket(); err != nil {\n\t\treturn err\n\t}\n\n\tc.ekm = ekmFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random)\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) pickCipherSuite() error {\n\tif hs.suite = mutualCipherSuite(hs.hello.cipherSuites, hs.serverHello.cipherSuite); hs.suite == nil {\n\t\ths.c.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: server chose an unconfigured cipher suite\")\n\t}\n\n\ths.c.cipherSuite = hs.suite.id\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) doFullHandshake() error {\n\tc := hs.c\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcertMsg, ok := msg.(*certificateMsg)\n\tif !ok || len(certMsg.certificates) == 0 {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(certMsg, msg)\n\t}\n\n\tmsg, err = c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcs, ok := msg.(*certificateStatusMsg)\n\tif ok {\n\t\t// RFC4366 on Certificate Status Request:\n\t\t// The server MAY return a \"certificate_status\" message.\n\n\t\tif !hs.serverHello.ocspStapling {\n\t\t\t// If a server returns a \"CertificateStatus\" message, then the\n\t\t\t// server MUST have included an extension of type \"status_request\"\n\t\t\t// with empty \"extension_data\" in the extended server hello.\n\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn errors.New(\"tls: received unexpected CertificateStatus message\")\n\t\t}\n\n\t\tc.ocspResponse = cs.response\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.handshakes == 0 {\n\t\t// If this is the first handshake on a connection, process and\n\t\t// (optionally) verify the server's certificates.\n\t\tif err := c.verifyServerCertificate(certMsg.certificates); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// This is a renegotiation handshake. We require that the\n\t\t// server's identity (i.e. leaf certificate) is unchanged and\n\t\t// thus any previous trust decision is still valid.\n\t\t//\n\t\t// See https://mitls.org/pages/attacks/3SHAKE for the\n\t\t// motivation behind this requirement.\n\t\tif !bytes.Equal(c.peerCertificates[0].Raw, certMsg.certificates[0]) {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: server's identity changed during renegotiation\")\n\t\t}\n\t}\n\n\tkeyAgreement := hs.suite.ka(c.vers)\n\n\tskx, ok := msg.(*serverKeyExchangeMsg)\n\tif ok {\n\t\terr = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, c.peerCertificates[0], skx)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn err\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar chainToSend *Certificate\n\tvar certRequested bool\n\tcertReq, ok := msg.(*certificateRequestMsg)\n\tif ok {\n\t\tcertRequested = true\n\n\t\tcri := certificateRequestInfoFromMsg(hs.ctx, c.vers, certReq)\n\t\tif chainToSend, err = c.getClientCertificate(cri); err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tshd, ok := msg.(*serverHelloDoneMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(shd, msg)\n\t}\n\n\t// If the server requested a certificate then we have to send a\n\t// Certificate message, even if it's empty because we don't have a\n\t// certificate to send.\n\tif certRequested {\n\t\tcertMsg = new(certificateMsg)\n\t\tcertMsg.certificates = chainToSend.Certificate\n\t\tif _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tpreMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, c.peerCertificates[0])\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\tif ckx != nil {\n\t\tif _, err := hs.c.writeHandshakeRecord(ckx, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hs.serverHello.extendedMasterSecret {\n\t\tc.extMasterSecret = true\n\t\ths.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.finishedHash.Sum())\n\t} else {\n\t\ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.hello.random, hs.serverHello.random)\n\t}\n\tif err := c.config.writeKeyLog(keyLogLabelTLS12, hs.hello.random, hs.masterSecret); err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn errors.New(\"tls: failed to write to key log: \" + err.Error())\n\t}\n\n\tif chainToSend != nil && len(chainToSend.Certificate) > 0 {\n\t\tcertVerify := &certificateVerifyMsg{}\n\n\t\tkey, ok := chainToSend.PrivateKey.(crypto.Signer)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: client certificate private key of type %T does not implement crypto.Signer\", chainToSend.PrivateKey)\n\t\t}\n\n\t\tvar sigType uint8\n\t\tvar sigHash crypto.Hash\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tsignatureAlgorithm, err := selectSignatureScheme(c.vers, chainToSend, certReq.supportedSignatureAlgorithms)\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(signatureAlgorithm)\n\t\t\tif err != nil {\n\t\t\t\treturn c.sendAlert(alertInternalError)\n\t\t\t}\n\t\t\tcertVerify.hasSignatureAlgorithm = true\n\t\t\tcertVerify.signatureAlgorithm = signatureAlgorithm\n\t\t} else {\n\t\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(key.Public())\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tsigned := hs.finishedHash.hashForClientCertificate(sigType, sigHash)\n\t\tsignOpts := crypto.SignerOpts(sigHash)\n\t\tif sigType == signatureRSAPSS {\n\t\t\tsignOpts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: sigHash}\n\t\t}\n\t\tcertVerify.signature, err = key.Sign(c.config.rand(), signed, signOpts)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := hs.c.writeHandshakeRecord(certVerify, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.finishedHash.discardHandshakeBuffer()\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) establishKeys() error {\n\tc := hs.c\n\n\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n\t\tkeysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n\tvar clientCipher, serverCipher any\n\tvar clientHash, serverHash hash.Hash\n\tif hs.suite.cipher != nil {\n\t\tclientCipher = hs.suite.cipher(clientKey, clientIV, false /* not for reading */)\n\t\tclientHash = hs.suite.mac(clientMAC)\n\t\tserverCipher = hs.suite.cipher(serverKey, serverIV, true /* for reading */)\n\t\tserverHash = hs.suite.mac(serverMAC)\n\t} else {\n\t\tclientCipher = hs.suite.aead(clientKey, clientIV)\n\t\tserverCipher = hs.suite.aead(serverKey, serverIV)\n\t}\n\n\tc.in.prepareCipherSpec(c.vers, serverCipher, serverHash)\n\tc.out.prepareCipherSpec(c.vers, clientCipher, clientHash)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) serverResumedSession() bool {\n\t// If the server responded with the same sessionId then it means the\n\t// sessionTicket is being used to resume a TLS session.\n\treturn hs.session != nil && hs.hello.sessionId != nil &&\n\t\tbytes.Equal(hs.serverHello.sessionId, hs.hello.sessionId)\n}\n\nfunc (hs *clientHandshakeState) processServerHello() (bool, error) {\n\tc := hs.c\n\n\tif err := hs.pickCipherSuite(); err != nil {\n\t\treturn false, err\n\t}\n\n\tif hs.serverHello.compressionMethod != compressionNone {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn false, errors.New(\"tls: server selected unsupported compression format\")\n\t}\n\n\tif c.handshakes == 0 && hs.serverHello.secureRenegotiationSupported {\n\t\tc.secureRenegotiation = true\n\t\tif len(hs.serverHello.secureRenegotiation) != 0 {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn false, errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n\t\t}\n\t}\n\n\tif c.handshakes > 0 && c.secureRenegotiation {\n\t\tvar expectedSecureRenegotiation [24]byte\n\t\tcopy(expectedSecureRenegotiation[:], c.clientFinished[:])\n\t\tcopy(expectedSecureRenegotiation[12:], c.serverFinished[:])\n\t\tif !bytes.Equal(hs.serverHello.secureRenegotiation, expectedSecureRenegotiation[:]) {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn false, errors.New(\"tls: incorrect renegotiation extension contents\")\n\t\t}\n\t}\n\n\tif err := checkALPN(hs.hello.alpnProtocols, hs.serverHello.alpnProtocol, false); err != nil {\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn false, err\n\t}\n\tc.clientProtocol = hs.serverHello.alpnProtocol\n\n\tc.scts = hs.serverHello.scts\n\n\tif !hs.serverResumedSession() {\n\t\treturn false, nil\n\t}\n\n\tif hs.session.version != c.vers {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different version\")\n\t}\n\n\tif hs.session.cipherSuite != hs.suite.id {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different cipher suite\")\n\t}\n\n\t// RFC 7627, Section 5.3\n\tif hs.session.extMasterSecret != hs.serverHello.extendedMasterSecret {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different EMS extension\")\n\t}\n\n\t// Restore master secret and certificates from previous state\n\ths.masterSecret = hs.session.secret\n\tc.extMasterSecret = hs.session.extMasterSecret\n\tc.peerCertificates = hs.session.peerCertificates\n\tc.activeCertHandles = hs.c.activeCertHandles\n\tc.verifiedChains = hs.session.verifiedChains\n\tc.ocspResponse = hs.session.ocspResponse\n\t// Let the ServerHello SCTs override the session SCTs from the original\n\t// connection, if any are provided\n\tif len(c.scts) == 0 && len(hs.session.scts) != 0 {\n\t\tc.scts = hs.session.scts\n\t}\n\n\treturn true, nil\n}\n\n// checkALPN ensure that the server's choice of ALPN protocol is compatible with\n// the protocols that we advertised in the Client Hello.\nfunc checkALPN(clientProtos []string, serverProto string, quic bool) error {\n\tif serverProto == \"\" {\n\t\tif quic && len(clientProtos) > 0 {\n\t\t\t// RFC 9001, Section 8.1\n\t\t\treturn errors.New(\"tls: server did not select an ALPN protocol\")\n\t\t}\n\t\treturn nil\n\t}\n\tif len(clientProtos) == 0 {\n\t\treturn errors.New(\"tls: server advertised unrequested ALPN extension\")\n\t}\n\tfor _, proto := range clientProtos {\n\t\tif proto == serverProto {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"tls: server selected unadvertised ALPN protocol\")\n}\n\nfunc (hs *clientHandshakeState) readFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.readChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\n\t// finishedMsg is included in the transcript, but not until after we\n\t// check the client version, since the state before this message was\n\t// sent is used during verification.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tserverFinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(serverFinished, msg)\n\t}\n\n\tverify := hs.finishedHash.serverSum(hs.masterSecret)\n\tif len(verify) != len(serverFinished.verifyData) ||\n\t\tsubtle.ConstantTimeCompare(verify, serverFinished.verifyData) != 1 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: server's Finished message was incorrect\")\n\t}\n\n\tif err := transcriptMsg(serverFinished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, verify)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) readSessionTicket() error {\n\tif !hs.serverHello.ticketSupported {\n\t\treturn nil\n\t}\n\tc := hs.c\n\n\tif !hs.hello.ticketSupported {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server sent unrequested session ticket\")\n\t}\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsessionTicketMsg, ok := msg.(*newSessionTicketMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(sessionTicketMsg, msg)\n\t}\n\n\ths.ticket = sessionTicketMsg.ticket\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) saveSessionTicket() error {\n\tif hs.ticket == nil {\n\t\treturn nil\n\t}\n\tc := hs.c\n\n\tcacheKey := c.clientSessionCacheKey()\n\tif cacheKey == \"\" {\n\t\treturn nil\n\t}\n\n\tsession, err := c.sessionState()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsession.secret = hs.masterSecret\n\n\tcs := &ClientSessionState{ticket: hs.ticket, session: session}\n\tc.config.ClientSessionCache.Put(cacheKey, cs)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) sendFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.writeChangeCipherRecord(); err != nil {\n\t\treturn err\n\t}\n\n\tfinished := new(finishedMsg)\n\tfinished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)\n\tif _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tcopy(out, finished.verifyData)\n\treturn nil\n}\n\n// verifyServerCertificate parses and verifies the provided chain, setting\n// c.verifiedChains and c.peerCertificates or sending the appropriate alert.\nfunc (c *Conn) verifyServerCertificate(certificates [][]byte) error {\n\tactiveHandles := make([]*activeCert, len(certificates))\n\tcerts := make([]*x509.Certificate, len(certificates))\n\tfor i, asn1Data := range certificates {\n\t\tcert, err := globalCertCache.newCert(asn1Data)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: failed to parse certificate from server: \" + err.Error())\n\t\t}\n\t\tactiveHandles[i] = cert\n\t\tcerts[i] = cert.cert\n\t}\n\n\tif !c.config.InsecureSkipVerify {\n\t\topts := x509.VerifyOptions{\n\t\t\tRoots:         c.config.RootCAs,\n\t\t\tCurrentTime:   c.config.time(),\n\t\t\tDNSName:       c.config.ServerName,\n\t\t\tIntermediates: x509.NewCertPool(),\n\t\t}\n\n\t\tfor _, cert := range certs[1:] {\n\t\t\topts.Intermediates.AddCert(cert)\n\t\t}\n\t\tvar err error\n\t\tc.verifiedChains, err = certs[0].Verify(opts)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn &CertificateVerificationError{UnverifiedCertificates: certs, Err: err}\n\t\t}\n\t}\n\n\tswitch certs[0].PublicKey.(type) {\n\tcase *rsa.PublicKey, *ecdsa.PublicKey, ed25519.PublicKey:\n\t\tbreak\n\tdefault:\n\t\tc.sendAlert(alertUnsupportedCertificate)\n\t\treturn fmt.Errorf(\"tls: server's certificate contains an unsupported type of public key: %T\", certs[0].PublicKey)\n\t}\n\n\tc.activeCertHandles = activeHandles\n\tc.peerCertificates = certs\n\n\tif c.config.VerifyPeerCertificate != nil {\n\t\tif err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// certificateRequestInfoFromMsg generates a CertificateRequestInfo from a TLS\n// <= 1.2 CertificateRequest, making an effort to fill in missing information.\nfunc certificateRequestInfoFromMsg(ctx context.Context, vers uint16, certReq *certificateRequestMsg) *CertificateRequestInfo {\n\tcri := &CertificateRequestInfo{\n\t\tAcceptableCAs: certReq.certificateAuthorities,\n\t\tVersion:       vers,\n\t\tctx:           ctx,\n\t}\n\n\tvar rsaAvail, ecAvail bool\n\tfor _, certType := range certReq.certificateTypes {\n\t\tswitch certType {\n\t\tcase certTypeRSASign:\n\t\t\trsaAvail = true\n\t\tcase certTypeECDSASign:\n\t\t\tecAvail = true\n\t\t}\n\t}\n\n\tif !certReq.hasSignatureAlgorithm {\n\t\t// Prior to TLS 1.2, signature schemes did not exist. In this case we\n\t\t// make up a list based on the acceptable certificate types, to help\n\t\t// GetClientCertificate and SupportsCertificate select the right certificate.\n\t\t// The hash part of the SignatureScheme is a lie here, because\n\t\t// TLS 1.0 and 1.1 always use MD5+SHA1 for RSA and SHA1 for ECDSA.\n\t\tswitch {\n\t\tcase rsaAvail && ecAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512,\n\t\t\t\tPKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512, PKCS1WithSHA1,\n\t\t\t}\n\t\tcase rsaAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tPKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512, PKCS1WithSHA1,\n\t\t\t}\n\t\tcase ecAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512,\n\t\t\t}\n\t\t}\n\t\treturn cri\n\t}\n\n\t// Filter the signature schemes based on the certificate types.\n\t// See RFC 5246, Section 7.4.4 (where it calls this \"somewhat complicated\").\n\tcri.SignatureSchemes = make([]SignatureScheme, 0, len(certReq.supportedSignatureAlgorithms))\n\tfor _, sigScheme := range certReq.supportedSignatureAlgorithms {\n\t\tsigType, _, err := typeAndHashFromSignatureScheme(sigScheme)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tswitch sigType {\n\t\tcase signatureECDSA, signatureEd25519:\n\t\t\tif ecAvail {\n\t\t\t\tcri.SignatureSchemes = append(cri.SignatureSchemes, sigScheme)\n\t\t\t}\n\t\tcase signatureRSAPSS, signaturePKCS1v15:\n\t\t\tif rsaAvail {\n\t\t\t\tcri.SignatureSchemes = append(cri.SignatureSchemes, sigScheme)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cri\n}\n\nfunc (c *Conn) getClientCertificate(cri *CertificateRequestInfo) (*Certificate, error) {\n\tif c.config.GetClientCertificate != nil {\n\t\treturn c.config.GetClientCertificate(cri)\n\t}\n\n\tfor _, chain := range c.config.Certificates {\n\t\tif err := cri.SupportsCertificate(&chain); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\treturn &chain, nil\n\t}\n\n\t// No acceptable certificate found. Don't send a certificate.\n\treturn new(Certificate), nil\n}\n\n// clientSessionCacheKey returns a key used to cache sessionTickets that could\n// be used to resume previously negotiated TLS sessions with a server.\nfunc (c *Conn) clientSessionCacheKey() string {\n\tif len(c.config.ServerName) > 0 {\n\t\treturn c.config.ServerName\n\t}\n\tif c.conn != nil {\n\t\treturn c.conn.RemoteAddr().String()\n\t}\n\treturn \"\"\n}\n\n// hostnameInSNI converts name into an appropriate hostname for SNI.\n// Literal IP addresses and absolute FQDNs are not permitted as SNI values.\n// See RFC 6066, Section 3.\nfunc hostnameInSNI(name string) string {\n\thost := name\n\tif len(host) > 0 && host[0] == '[' && host[len(host)-1] == ']' {\n\t\thost = host[1 : len(host)-1]\n\t}\n\tif i := strings.LastIndex(host, \"%\"); i > 0 {\n\t\thost = host[:i]\n\t}\n\tif net.ParseIP(host) != nil {\n\t\treturn \"\"\n\t}\n\tfor len(name) > 0 && name[len(name)-1] == '.' {\n\t\tname = name[:len(name)-1]\n\t}\n\treturn name\n}\n", "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage tls\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\n// Note: see comment in handshake_test.go for details of how the reference\n// tests work.\n\n// opensslInputEvent enumerates possible inputs that can be sent to an `openssl\n// s_client` process.\ntype opensslInputEvent int\n\nconst (\n\t// opensslRenegotiate causes OpenSSL to request a renegotiation of the\n\t// connection.\n\topensslRenegotiate opensslInputEvent = iota\n\n\t// opensslSendBanner causes OpenSSL to send the contents of\n\t// opensslSentinel on the connection.\n\topensslSendSentinel\n\n\t// opensslKeyUpdate causes OpenSSL to send a key update message to the\n\t// client and request one back.\n\topensslKeyUpdate\n)\n\nconst opensslSentinel = \"SENTINEL\\n\"\n\ntype opensslInput chan opensslInputEvent\n\nfunc (i opensslInput) Read(buf []byte) (n int, err error) {\n\tfor event := range i {\n\t\tswitch event {\n\t\tcase opensslRenegotiate:\n\t\t\treturn copy(buf, []byte(\"R\\n\")), nil\n\t\tcase opensslKeyUpdate:\n\t\t\treturn copy(buf, []byte(\"K\\n\")), nil\n\t\tcase opensslSendSentinel:\n\t\t\treturn copy(buf, []byte(opensslSentinel)), nil\n\t\tdefault:\n\t\t\tpanic(\"unknown event\")\n\t\t}\n\t}\n\n\treturn 0, io.EOF\n}\n\n// opensslOutputSink is an io.Writer that receives the stdout and stderr from an\n// `openssl` process and sends a value to handshakeComplete or readKeyUpdate\n// when certain messages are seen.\ntype opensslOutputSink struct {\n\thandshakeComplete chan struct{}\n\treadKeyUpdate     chan struct{}\n\tall               []byte\n\tline              []byte\n}\n\nfunc newOpensslOutputSink() *opensslOutputSink {\n\treturn &opensslOutputSink{make(chan struct{}), make(chan struct{}), nil, nil}\n}\n\n// opensslEndOfHandshake is a message that the \u201copenssl s_server\u201d tool will\n// print when a handshake completes if run with \u201c-state\u201d.\nconst opensslEndOfHandshake = \"SSL_accept:SSLv3/TLS write finished\"\n\n// opensslReadKeyUpdate is a message that the \u201copenssl s_server\u201d tool will\n// print when a KeyUpdate message is received if run with \u201c-state\u201d.\nconst opensslReadKeyUpdate = \"SSL_accept:TLSv1.3 read client key update\"\n\nfunc (o *opensslOutputSink) Write(data []byte) (n int, err error) {\n\to.line = append(o.line, data...)\n\to.all = append(o.all, data...)\n\n\tfor {\n\t\tline, next, ok := bytes.Cut(o.line, []byte(\"\\n\"))\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\n\t\tif bytes.Equal([]byte(opensslEndOfHandshake), line) {\n\t\t\to.handshakeComplete <- struct{}{}\n\t\t}\n\t\tif bytes.Equal([]byte(opensslReadKeyUpdate), line) {\n\t\t\to.readKeyUpdate <- struct{}{}\n\t\t}\n\t\to.line = next\n\t}\n\n\treturn len(data), nil\n}\n\nfunc (o *opensslOutputSink) String() string {\n\treturn string(o.all)\n}\n\n// clientTest represents a test of the TLS client handshake against a reference\n// implementation.\ntype clientTest struct {\n\t// name is a freeform string identifying the test and the file in which\n\t// the expected results will be stored.\n\tname string\n\t// args, if not empty, contains a series of arguments for the\n\t// command to run for the reference server.\n\targs []string\n\t// config, if not nil, contains a custom Config to use for this test.\n\tconfig *Config\n\t// cert, if not empty, contains a DER-encoded certificate for the\n\t// reference server.\n\tcert []byte\n\t// key, if not nil, contains either a *rsa.PrivateKey, ed25519.PrivateKey or\n\t// *ecdsa.PrivateKey which is the private key for the reference server.\n\tkey any\n\t// extensions, if not nil, contains a list of extension data to be returned\n\t// from the ServerHello. The data should be in standard TLS format with\n\t// a 2-byte uint16 type, 2-byte data length, followed by the extension data.\n\textensions [][]byte\n\t// validate, if not nil, is a function that will be called with the\n\t// ConnectionState of the resulting connection. It returns a non-nil\n\t// error if the ConnectionState is unacceptable.\n\tvalidate func(ConnectionState) error\n\t// numRenegotiations is the number of times that the connection will be\n\t// renegotiated.\n\tnumRenegotiations int\n\t// renegotiationExpectedToFail, if not zero, is the number of the\n\t// renegotiation attempt that is expected to fail.\n\trenegotiationExpectedToFail int\n\t// checkRenegotiationError, if not nil, is called with any error\n\t// arising from renegotiation. It can map expected errors to nil to\n\t// ignore them.\n\tcheckRenegotiationError func(renegotiationNum int, err error) error\n\t// sendKeyUpdate will cause the server to send a KeyUpdate message.\n\tsendKeyUpdate bool\n}\n\nvar serverCommand = []string{\"openssl\", \"s_server\", \"-no_ticket\", \"-num_tickets\", \"0\"}\n\n// connFromCommand starts the reference server process, connects to it and\n// returns a recordingConn for the connection. The stdin return value is an\n// opensslInput for the stdin of the child process. It must be closed before\n// Waiting for child.\nfunc (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, stdin opensslInput, stdout *opensslOutputSink, err error) {\n\tcert := testRSACertificate\n\tif len(test.cert) > 0 {\n\t\tcert = test.cert\n\t}\n\tcertPath := tempFile(string(cert))\n\tdefer os.Remove(certPath)\n\n\tvar key any = testRSAPrivateKey\n\tif test.key != nil {\n\t\tkey = test.key\n\t}\n\tderBytes, err := x509.MarshalPKCS8PrivateKey(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar pemOut bytes.Buffer\n\tpem.Encode(&pemOut, &pem.Block{Type: \"PRIVATE KEY\", Bytes: derBytes})\n\n\tkeyPath := tempFile(pemOut.String())\n\tdefer os.Remove(keyPath)\n\n\tvar command []string\n\tcommand = append(command, serverCommand...)\n\tcommand = append(command, test.args...)\n\tcommand = append(command, \"-cert\", certPath, \"-certform\", \"DER\", \"-key\", keyPath)\n\t// serverPort contains the port that OpenSSL will listen on. OpenSSL\n\t// can't take \"0\" as an argument here so we have to pick a number and\n\t// hope that it's not in use on the machine. Since this only occurs\n\t// when -update is given and thus when there's a human watching the\n\t// test, this isn't too bad.\n\tconst serverPort = 24323\n\tcommand = append(command, \"-accept\", strconv.Itoa(serverPort))\n\n\tif len(test.extensions) > 0 {\n\t\tvar serverInfo bytes.Buffer\n\t\tfor _, ext := range test.extensions {\n\t\t\tpem.Encode(&serverInfo, &pem.Block{\n\t\t\t\tType:  fmt.Sprintf(\"SERVERINFO FOR EXTENSION %d\", binary.BigEndian.Uint16(ext)),\n\t\t\t\tBytes: ext,\n\t\t\t})\n\t\t}\n\t\tserverInfoPath := tempFile(serverInfo.String())\n\t\tdefer os.Remove(serverInfoPath)\n\t\tcommand = append(command, \"-serverinfo\", serverInfoPath)\n\t}\n\n\tif test.numRenegotiations > 0 || test.sendKeyUpdate {\n\t\tfound := false\n\t\tfor _, flag := range command[1:] {\n\t\t\tif flag == \"-state\" {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\tpanic(\"-state flag missing to OpenSSL, you need this if testing renegotiation or KeyUpdate\")\n\t\t}\n\t}\n\n\tcmd := exec.Command(command[0], command[1:]...)\n\tstdin = opensslInput(make(chan opensslInputEvent))\n\tcmd.Stdin = stdin\n\tout := newOpensslOutputSink()\n\tcmd.Stdout = out\n\tcmd.Stderr = out\n\tif err := cmd.Start(); err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\t// OpenSSL does print an \"ACCEPT\" banner, but it does so *before*\n\t// opening the listening socket, so we can't use that to wait until it\n\t// has started listening. Thus we are forced to poll until we get a\n\t// connection.\n\tvar tcpConn net.Conn\n\tfor i := uint(0); i < 5; i++ {\n\t\ttcpConn, err = net.DialTCP(\"tcp\", nil, &net.TCPAddr{\n\t\t\tIP:   net.IPv4(127, 0, 0, 1),\n\t\t\tPort: serverPort,\n\t\t})\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep((1 << i) * 5 * time.Millisecond)\n\t}\n\tif err != nil {\n\t\tclose(stdin)\n\t\tcmd.Process.Kill()\n\t\terr = fmt.Errorf(\"error connecting to the OpenSSL server: %v (%v)\\n\\n%s\", err, cmd.Wait(), out)\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\trecord := &recordingConn{\n\t\tConn: tcpConn,\n\t}\n\n\treturn record, cmd, stdin, out, nil\n}\n\nfunc (test *clientTest) dataPath() string {\n\treturn filepath.Join(\"testdata\", \"Client-\"+test.name)\n}\n\nfunc (test *clientTest) loadData() (flows [][]byte, err error) {\n\tin, err := os.Open(test.dataPath())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer in.Close()\n\treturn parseTestData(in)\n}\n\nfunc (test *clientTest) run(t *testing.T, write bool) {\n\tvar clientConn, serverConn net.Conn\n\tvar recordingConn *recordingConn\n\tvar childProcess *exec.Cmd\n\tvar stdin opensslInput\n\tvar stdout *opensslOutputSink\n\n\tif write {\n\t\tvar err error\n\t\trecordingConn, childProcess, stdin, stdout, err = test.connFromCommand()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to start subcommand: %s\", err)\n\t\t}\n\t\tclientConn = recordingConn\n\t\tdefer func() {\n\t\t\tif t.Failed() {\n\t\t\t\tt.Logf(\"OpenSSL output:\\n\\n%s\", stdout.all)\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tclientConn, serverConn = localPipe(t)\n\t}\n\n\tdoneChan := make(chan bool)\n\tdefer func() {\n\t\tclientConn.Close()\n\t\t<-doneChan\n\t}()\n\tgo func() {\n\t\tdefer close(doneChan)\n\n\t\tconfig := test.config\n\t\tif config == nil {\n\t\t\tconfig = testConfig\n\t\t}\n\t\tclient := Client(clientConn, config)\n\t\tdefer client.Close()\n\n\t\tif _, err := client.Write([]byte(\"hello\\n\")); err != nil {\n\t\t\tt.Errorf(\"Client.Write failed: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 1; i <= test.numRenegotiations; i++ {\n\t\t\t// The initial handshake will generate a\n\t\t\t// handshakeComplete signal which needs to be quashed.\n\t\t\tif i == 1 && write {\n\t\t\t\t<-stdout.handshakeComplete\n\t\t\t}\n\n\t\t\t// OpenSSL will try to interleave application data and\n\t\t\t// a renegotiation if we send both concurrently.\n\t\t\t// Therefore: ask OpensSSL to start a renegotiation, run\n\t\t\t// a goroutine to call client.Read and thus process the\n\t\t\t// renegotiation request, watch for OpenSSL's stdout to\n\t\t\t// indicate that the handshake is complete and,\n\t\t\t// finally, have OpenSSL write something to cause\n\t\t\t// client.Read to complete.\n\t\t\tif write {\n\t\t\t\tstdin <- opensslRenegotiate\n\t\t\t}\n\n\t\t\tsignalChan := make(chan struct{})\n\n\t\t\tgo func() {\n\t\t\t\tdefer close(signalChan)\n\n\t\t\t\tbuf := make([]byte, 256)\n\t\t\t\tn, err := client.Read(buf)\n\n\t\t\t\tif test.checkRenegotiationError != nil {\n\t\t\t\t\tnewErr := test.checkRenegotiationError(i, err)\n\t\t\t\t\tif err != nil && newErr == nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\terr = newErr\n\t\t\t\t}\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Client.Read failed after renegotiation #%d: %s\", i, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tbuf = buf[:n]\n\t\t\t\tif !bytes.Equal([]byte(opensslSentinel), buf) {\n\t\t\t\t\tt.Errorf(\"Client.Read returned %q, but wanted %q\", string(buf), opensslSentinel)\n\t\t\t\t}\n\n\t\t\t\tif expected := i + 1; client.handshakes != expected {\n\t\t\t\t\tt.Errorf(\"client should have recorded %d handshakes, but believes that %d have occurred\", expected, client.handshakes)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif write && test.renegotiationExpectedToFail != i {\n\t\t\t\t<-stdout.handshakeComplete\n\t\t\t\tstdin <- opensslSendSentinel\n\t\t\t}\n\t\t\t<-signalChan\n\t\t}\n\n\t\tif test.sendKeyUpdate {\n\t\t\tif write {\n\t\t\t\t<-stdout.handshakeComplete\n\t\t\t\tstdin <- opensslKeyUpdate\n\t\t\t}\n\n\t\t\tdoneRead := make(chan struct{})\n\n\t\t\tgo func() {\n\t\t\t\tdefer close(doneRead)\n\n\t\t\t\tbuf := make([]byte, 256)\n\t\t\t\tn, err := client.Read(buf)\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Client.Read failed after KeyUpdate: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tbuf = buf[:n]\n\t\t\t\tif !bytes.Equal([]byte(opensslSentinel), buf) {\n\t\t\t\t\tt.Errorf(\"Client.Read returned %q, but wanted %q\", string(buf), opensslSentinel)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif write {\n\t\t\t\t// There's no real reason to wait for the client KeyUpdate to\n\t\t\t\t// send data with the new server keys, except that s_server\n\t\t\t\t// drops writes if they are sent at the wrong time.\n\t\t\t\t<-stdout.readKeyUpdate\n\t\t\t\tstdin <- opensslSendSentinel\n\t\t\t}\n\t\t\t<-doneRead\n\n\t\t\tif _, err := client.Write([]byte(\"hello again\\n\")); err != nil {\n\t\t\t\tt.Errorf(\"Client.Write failed: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif test.validate != nil {\n\t\t\tif err := test.validate(client.ConnectionState()); err != nil {\n\t\t\t\tt.Errorf(\"validate callback returned error: %s\", err)\n\t\t\t}\n\t\t}\n\n\t\t// If the server sent us an alert after our last flight, give it a\n\t\t// chance to arrive.\n\t\tif write && test.renegotiationExpectedToFail == 0 {\n\t\t\tif err := peekError(client); err != nil {\n\t\t\t\tt.Errorf(\"final Read returned an error: %s\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif !write {\n\t\tflows, err := test.loadData()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: failed to load data from %s: %v\", test.name, test.dataPath(), err)\n\t\t}\n\t\tfor i, b := range flows {\n\t\t\tif i%2 == 1 {\n\t\t\t\tif *fast {\n\t\t\t\t\tserverConn.SetWriteDeadline(time.Now().Add(1 * time.Second))\n\t\t\t\t} else {\n\t\t\t\t\tserverConn.SetWriteDeadline(time.Now().Add(1 * time.Minute))\n\t\t\t\t}\n\t\t\t\tserverConn.Write(b)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbb := make([]byte, len(b))\n\t\t\tif *fast {\n\t\t\t\tserverConn.SetReadDeadline(time.Now().Add(1 * time.Second))\n\t\t\t} else {\n\t\t\t\tserverConn.SetReadDeadline(time.Now().Add(1 * time.Minute))\n\t\t\t}\n\t\t\t_, err := io.ReadFull(serverConn, bb)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s, flow %d: %s\", test.name, i+1, err)\n\t\t\t}\n\t\t\tif !bytes.Equal(b, bb) {\n\t\t\t\tt.Fatalf(\"%s, flow %d: mismatch on read: got:%x want:%x\", test.name, i+1, bb, b)\n\t\t\t}\n\t\t}\n\t}\n\n\t<-doneChan\n\tif !write {\n\t\tserverConn.Close()\n\t}\n\n\tif write {\n\t\tpath := test.dataPath()\n\t\tout, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create output file: %s\", err)\n\t\t}\n\t\tdefer out.Close()\n\t\trecordingConn.Close()\n\t\tclose(stdin)\n\t\tchildProcess.Process.Kill()\n\t\tchildProcess.Wait()\n\t\tif len(recordingConn.flows) < 3 {\n\t\t\tt.Fatalf(\"Client connection didn't work\")\n\t\t}\n\t\trecordingConn.WriteTo(out)\n\t\tt.Logf(\"Wrote %s\\n\", path)\n\t}\n}\n\n// peekError does a read with a short timeout to check if the next read would\n// cause an error, for example if there is an alert waiting on the wire.\nfunc peekError(conn net.Conn) error {\n\tconn.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n\tif n, err := conn.Read(make([]byte, 1)); n != 0 {\n\t\treturn errors.New(\"unexpectedly read data\")\n\t} else if err != nil {\n\t\tif netErr, ok := err.(net.Error); !ok || !netErr.Timeout() {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc runClientTestForVersion(t *testing.T, template *clientTest, version, option string) {\n\t// Make a deep copy of the template before going parallel.\n\ttest := *template\n\tif template.config != nil {\n\t\ttest.config = template.config.Clone()\n\t}\n\ttest.name = version + \"-\" + test.name\n\ttest.args = append([]string{option}, test.args...)\n\n\trunTestAndUpdateIfNeeded(t, version, test.run, false)\n}\n\nfunc runClientTestTLS10(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv10\", \"-tls1\")\n}\n\nfunc runClientTestTLS11(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv11\", \"-tls1_1\")\n}\n\nfunc runClientTestTLS12(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv12\", \"-tls1_2\")\n}\n\nfunc runClientTestTLS13(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv13\", \"-tls1_3\")\n}\n\nfunc TestHandshakeClientRSARC4(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"RSA-RC4\",\n\t\targs: []string{\"-cipher\", \"RC4-SHA\"},\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS11(t, test)\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientRSAAES128GCM(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES128-GCM-SHA256\",\n\t\targs: []string{\"-cipher\", \"AES128-GCM-SHA256\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientRSAAES256GCM(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES256-GCM-SHA384\",\n\t\targs: []string{\"-cipher\", \"AES256-GCM-SHA384\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHERSAAES(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-RSA-AES\",\n\t\targs: []string{\"-cipher\", \"ECDHE-RSA-AES128-SHA\"},\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS11(t, test)\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAAES(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS11(t, test)\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAAESGCM(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES-GCM\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES128-GCM-SHA256\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientAES256GCMSHA384(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES256-GCM-SHA384\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientAES128CBCSHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES128-SHA256\",\n\t\targs: []string{\"-cipher\", \"AES128-SHA256\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHERSAAES128CBCSHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-RSA-AES128-SHA256\",\n\t\targs: []string{\"-cipher\", \"ECDHE-RSA-AES128-SHA256\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAAES128CBCSHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES128-SHA256\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA256\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientX25519(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CurvePreferences = []CurveID{X25519}\n\n\ttest := &clientTest{\n\t\tname:   \"X25519-ECDHE\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\", \"-curves\", \"X25519\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientP256(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CurvePreferences = []CurveID{CurveP256}\n\n\ttest := &clientTest{\n\t\tname:   \"P256-ECDHE\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\", \"-curves\", \"P-256\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientHelloRetryRequest(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CurvePreferences = []CurveID{X25519, CurveP256}\n\n\ttest := &clientTest{\n\t\tname:   \"HelloRetryRequest\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\", \"-curves\", \"P-256\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientECDHERSAChaCha20(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305}\n\n\ttest := &clientTest{\n\t\tname:   \"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-CHACHA20-POLY1305\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAChaCha20(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CipherSuites = []uint16{TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305}\n\n\ttest := &clientTest{\n\t\tname:   \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-ECDSA-CHACHA20-POLY1305\"},\n\t\tconfig: config,\n\t\tcert:   testECDSACertificate,\n\t\tkey:    testECDSAPrivateKey,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientAES128SHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES128-SHA256\",\n\t\targs: []string{\"-ciphersuites\", \"TLS_AES_128_GCM_SHA256\"},\n\t}\n\trunClientTestTLS13(t, test)\n}\nfunc TestHandshakeClientAES256SHA384(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES256-SHA384\",\n\t\targs: []string{\"-ciphersuites\", \"TLS_AES_256_GCM_SHA384\"},\n\t}\n\trunClientTestTLS13(t, test)\n}\nfunc TestHandshakeClientCHACHA20SHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"CHACHA20-SHA256\",\n\t\targs: []string{\"-ciphersuites\", \"TLS_CHACHA20_POLY1305_SHA256\"},\n\t}\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientECDSATLS13(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDSA\",\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientEd25519(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"Ed25519\",\n\t\tcert: testEd25519Certificate,\n\t\tkey:  testEd25519PrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientEd25519CertificatePEM), []byte(clientEd25519KeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-Ed25519\",\n\t\targs:   []string{\"-Verify\", \"1\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientCertRSA(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientCertificatePEM), []byte(clientKeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest := &clientTest{\n\t\tname:   \"ClientCert-RSA-RSA\",\n\t\targs:   []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-RSA-ECDSA\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t\tcert:   testECDSACertificate,\n\t\tkey:    testECDSAPrivateKey,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-RSA-AES256-GCM-SHA384\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES256-GCM-SHA384\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t\tcert:   testRSACertificate,\n\t\tkey:    testRSAPrivateKey,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientCertECDSA(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientECDSACertificatePEM), []byte(clientECDSAKeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest := &clientTest{\n\t\tname:   \"ClientCert-ECDSA-RSA\",\n\t\targs:   []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-ECDSA-ECDSA\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t\tcert:   testECDSACertificate,\n\t\tkey:    testECDSAPrivateKey,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n}\n\n// TestHandshakeClientCertRSAPSS tests rsa_pss_rsae_sha256 signatures from both\n// client and server certificates. It also serves from both sides a certificate\n// signed itself with RSA-PSS, mostly to check that crypto/x509 chain validation\n// works.\nfunc TestHandshakeClientCertRSAPSS(t *testing.T) {\n\tcert, err := x509.ParseCertificate(testRSAPSSCertificate)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trootCAs := x509.NewCertPool()\n\trootCAs.AddCert(cert)\n\n\tconfig := testConfig.Clone()\n\t// Use GetClientCertificate to bypass the client certificate selection logic.\n\tconfig.GetClientCertificate = func(*CertificateRequestInfo) (*Certificate, error) {\n\t\treturn &Certificate{\n\t\t\tCertificate: [][]byte{testRSAPSSCertificate},\n\t\t\tPrivateKey:  testRSAPrivateKey,\n\t\t}, nil\n\t}\n\tconfig.RootCAs = rootCAs\n\n\ttest := &clientTest{\n\t\tname: \"ClientCert-RSA-RSAPSS\",\n\t\targs: []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\", \"-client_sigalgs\",\n\t\t\t\"rsa_pss_rsae_sha256\", \"-sigalgs\", \"rsa_pss_rsae_sha256\"},\n\t\tconfig: config,\n\t\tcert:   testRSAPSSCertificate,\n\t\tkey:    testRSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientCertRSAPKCS1v15(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientCertificatePEM), []byte(clientKeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest := &clientTest{\n\t\tname: \"ClientCert-RSA-RSAPKCS1v15\",\n\t\targs: []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\", \"-client_sigalgs\",\n\t\t\t\"rsa_pkcs1_sha256\", \"-sigalgs\", \"rsa_pkcs1_sha256\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestClientKeyUpdate(t *testing.T) {\n\ttest := &clientTest{\n\t\tname:          \"KeyUpdate\",\n\t\targs:          []string{\"-state\"},\n\t\tsendKeyUpdate: true,\n\t}\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestResumption(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testResumption(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testResumption(t, VersionTLS13) })\n}\n\nfunc testResumption(t *testing.T, version uint16) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping in -short mode\")\n\t}\n\tserverConfig := &Config{\n\t\tMaxVersion:   version,\n\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n\t\tCertificates: testConfig.Certificates,\n\t}\n\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\trootCAs := x509.NewCertPool()\n\trootCAs.AddCert(issuer)\n\n\tclientConfig := &Config{\n\t\tMaxVersion:         version,\n\t\tCipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n\t\tClientSessionCache: NewLRUClientSessionCache(32),\n\t\tRootCAs:            rootCAs,\n\t\tServerName:         \"example.golang\",\n\t}\n\n\ttestResumeState := func(test string, didResume bool) {\n\t\tt.Helper()\n\t\t_, hs, err := testHandshake(t, clientConfig, serverConfig)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: handshake failed: %s\", test, err)\n\t\t}\n\t\tif hs.DidResume != didResume {\n\t\t\tt.Fatalf(\"%s resumed: %v, expected: %v\", test, hs.DidResume, didResume)\n\t\t}\n\t\tif didResume && (hs.PeerCertificates == nil || hs.VerifiedChains == nil) {\n\t\t\tt.Fatalf(\"expected non-nil certificates after resumption. Got peerCertificates: %#v, verifiedCertificates: %#v\", hs.PeerCertificates, hs.VerifiedChains)\n\t\t}\n\t\tif got, want := hs.ServerName, clientConfig.ServerName; got != want {\n\t\t\tt.Errorf(\"%s: server name %s, want %s\", test, got, want)\n\t\t}\n\t}\n\n\tgetTicket := func() []byte {\n\t\treturn clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).state.ticket\n\t}\n\tdeleteTicket := func() {\n\t\tticketKey := clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).sessionKey\n\t\tclientConfig.ClientSessionCache.Put(ticketKey, nil)\n\t}\n\tcorruptTicket := func() {\n\t\tclientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).state.session.secret[0] ^= 0xff\n\t}\n\trandomKey := func() [32]byte {\n\t\tvar k [32]byte\n\t\tif _, err := io.ReadFull(serverConfig.rand(), k[:]); err != nil {\n\t\t\tt.Fatalf(\"Failed to read new SessionTicketKey: %s\", err)\n\t\t}\n\t\treturn k\n\t}\n\n\ttestResumeState(\"Handshake\", false)\n\tticket := getTicket()\n\ttestResumeState(\"Resume\", true)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"ticket didn't change after resumption\")\n\t}\n\n\t// An old session ticket is replaced with a ticket encrypted with a fresh key.\n\tticket = getTicket()\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*time.Hour + time.Minute) }\n\ttestResumeState(\"ResumeWithOldTicket\", true)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"old first ticket matches the fresh one\")\n\t}\n\n\t// Once the session master secret is expired, a full handshake should occur.\n\tticket = getTicket()\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*8*time.Hour + time.Minute) }\n\ttestResumeState(\"ResumeWithExpiredTicket\", false)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"expired first ticket matches the fresh one\")\n\t}\n\n\tserverConfig.Time = func() time.Time { return time.Now() } // reset the time back\n\tkey1 := randomKey()\n\tserverConfig.SetSessionTicketKeys([][32]byte{key1})\n\n\ttestResumeState(\"InvalidSessionTicketKey\", false)\n\ttestResumeState(\"ResumeAfterInvalidSessionTicketKey\", true)\n\n\tkey2 := randomKey()\n\tserverConfig.SetSessionTicketKeys([][32]byte{key2, key1})\n\tticket = getTicket()\n\ttestResumeState(\"KeyChange\", true)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"new ticket wasn't included while resuming\")\n\t}\n\ttestResumeState(\"KeyChangeFinish\", true)\n\n\t// Age the session ticket a bit, but not yet expired.\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*time.Hour + time.Minute) }\n\ttestResumeState(\"OldSessionTicket\", true)\n\tticket = getTicket()\n\t// Expire the session ticket, which would force a full handshake.\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*8*time.Hour + time.Minute) }\n\ttestResumeState(\"ExpiredSessionTicket\", false)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"new ticket wasn't provided after old ticket expired\")\n\t}\n\n\t// Age the session ticket a bit at a time, but don't expire it.\n\td := 0 * time.Hour\n\tserverConfig.Time = func() time.Time { return time.Now().Add(d) }\n\tdeleteTicket()\n\ttestResumeState(\"GetFreshSessionTicket\", false)\n\tfor i := 0; i < 13; i++ {\n\t\td += 12 * time.Hour\n\t\ttestResumeState(\"OldSessionTicket\", true)\n\t}\n\t// Expire it (now a little more than 7 days) and make sure a full\n\t// handshake occurs for TLS 1.2. Resumption should still occur for\n\t// TLS 1.3 since the client should be using a fresh ticket sent over\n\t// by the server.\n\td += 12 * time.Hour\n\tif version == VersionTLS13 {\n\t\ttestResumeState(\"ExpiredSessionTicket\", true)\n\t} else {\n\t\ttestResumeState(\"ExpiredSessionTicket\", false)\n\t}\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"new ticket wasn't provided after old ticket expired\")\n\t}\n\n\t// Reset serverConfig to ensure that calling SetSessionTicketKeys\n\t// before the serverConfig is used works.\n\tserverConfig = &Config{\n\t\tMaxVersion:   version,\n\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n\t\tCertificates: testConfig.Certificates,\n\t}\n\tserverConfig.SetSessionTicketKeys([][32]byte{key2})\n\n\ttestResumeState(\"FreshConfig\", true)\n\n\t// In TLS 1.3, cross-cipher suite resumption is allowed as long as the KDF\n\t// hash matches. Also, Config.CipherSuites does not apply to TLS 1.3.\n\tif version != VersionTLS13 {\n\t\tclientConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}\n\t\ttestResumeState(\"DifferentCipherSuite\", false)\n\t\ttestResumeState(\"DifferentCipherSuiteRecovers\", true)\n\t}\n\n\tdeleteTicket()\n\ttestResumeState(\"WithoutSessionTicket\", false)\n\n\t// In TLS 1.3, HelloRetryRequest is sent after incorrect key share.\n\t// See https://www.rfc-editor.org/rfc/rfc8446#page-14.\n\tif version == VersionTLS13 {\n\t\tdeleteTicket()\n\t\tserverConfig = &Config{\n\t\t\t// Use a different curve than the client to force a HelloRetryRequest.\n\t\t\tCurvePreferences: []CurveID{CurveP521, CurveP384, CurveP256},\n\t\t\tMaxVersion:       version,\n\t\t\tCertificates:     testConfig.Certificates,\n\t\t}\n\t\ttestResumeState(\"InitialHandshake\", false)\n\t\ttestResumeState(\"WithHelloRetryRequest\", true)\n\n\t\t// Reset serverConfig back.\n\t\tserverConfig = &Config{\n\t\t\tMaxVersion:   version,\n\t\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n\t\t\tCertificates: testConfig.Certificates,\n\t\t}\n\t}\n\n\t// Session resumption should work when using client certificates\n\tdeleteTicket()\n\tserverConfig.ClientCAs = rootCAs\n\tserverConfig.ClientAuth = RequireAndVerifyClientCert\n\tclientConfig.Certificates = serverConfig.Certificates\n\ttestResumeState(\"InitialHandshake\", false)\n\ttestResumeState(\"WithClientCertificates\", true)\n\tserverConfig.ClientAuth = NoClientCert\n\n\t// Tickets should be removed from the session cache on TLS handshake\n\t// failure, and the client should recover from a corrupted PSK\n\ttestResumeState(\"FetchTicketToCorrupt\", false)\n\tcorruptTicket()\n\t_, _, err = testHandshake(t, clientConfig, serverConfig)\n\tif err == nil {\n\t\tt.Fatalf(\"handshake did not fail with a corrupted client secret\")\n\t}\n\ttestResumeState(\"AfterHandshakeFailure\", false)\n\n\tclientConfig.ClientSessionCache = nil\n\ttestResumeState(\"WithoutSessionCache\", false)\n\n\tclientConfig.ClientSessionCache = &serializingClientCache{t: t}\n\ttestResumeState(\"BeforeSerializingCache\", false)\n\ttestResumeState(\"WithSerializingCache\", true)\n}\n\ntype serializingClientCache struct {\n\tt *testing.T\n\n\tticket, state []byte\n}\n\nfunc (c *serializingClientCache) Get(sessionKey string) (session *ClientSessionState, ok bool) {\n\tif c.ticket == nil {\n\t\treturn nil, false\n\t}\n\tstate, err := ParseSessionState(c.state)\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn nil, false\n\t}\n\tcs, err := NewResumptionState(c.ticket, state)\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn nil, false\n\t}\n\treturn cs, true\n}\n\nfunc (c *serializingClientCache) Put(sessionKey string, cs *ClientSessionState) {\n\tticket, state, err := cs.ResumptionState()\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn\n\t}\n\tstateBytes, err := state.Bytes()\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn\n\t}\n\tc.ticket, c.state = ticket, stateBytes\n}\n\nfunc TestLRUClientSessionCache(t *testing.T) {\n\t// Initialize cache of capacity 4.\n\tcache := NewLRUClientSessionCache(4)\n\tcs := make([]ClientSessionState, 6)\n\tkeys := []string{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\"}\n\n\t// Add 4 entries to the cache and look them up.\n\tfor i := 0; i < 4; i++ {\n\t\tcache.Put(keys[i], &cs[i])\n\t}\n\tfor i := 0; i < 4; i++ {\n\t\tif s, ok := cache.Get(keys[i]); !ok || s != &cs[i] {\n\t\t\tt.Fatalf(\"session cache failed lookup for added key: %s\", keys[i])\n\t\t}\n\t}\n\n\t// Add 2 more entries to the cache. First 2 should be evicted.\n\tfor i := 4; i < 6; i++ {\n\t\tcache.Put(keys[i], &cs[i])\n\t}\n\tfor i := 0; i < 2; i++ {\n\t\tif s, ok := cache.Get(keys[i]); ok || s != nil {\n\t\t\tt.Fatalf(\"session cache should have evicted key: %s\", keys[i])\n\t\t}\n\t}\n\n\t// Touch entry 2. LRU should evict 3 next.\n\tcache.Get(keys[2])\n\tcache.Put(keys[0], &cs[0])\n\tif s, ok := cache.Get(keys[3]); ok || s != nil {\n\t\tt.Fatalf(\"session cache should have evicted key 3\")\n\t}\n\n\t// Update entry 0 in place.\n\tcache.Put(keys[0], &cs[3])\n\tif s, ok := cache.Get(keys[0]); !ok || s != &cs[3] {\n\t\tt.Fatalf(\"session cache failed update for key 0\")\n\t}\n\n\t// Calling Put with a nil entry deletes the key.\n\tcache.Put(keys[0], nil)\n\tif _, ok := cache.Get(keys[0]); ok {\n\t\tt.Fatalf(\"session cache failed to delete key 0\")\n\t}\n\n\t// Delete entry 2. LRU should keep 4 and 5\n\tcache.Put(keys[2], nil)\n\tif _, ok := cache.Get(keys[2]); ok {\n\t\tt.Fatalf(\"session cache failed to delete key 4\")\n\t}\n\tfor i := 4; i < 6; i++ {\n\t\tif s, ok := cache.Get(keys[i]); !ok || s != &cs[i] {\n\t\t\tt.Fatalf(\"session cache should not have deleted key: %s\", keys[i])\n\t\t}\n\t}\n}\n\nfunc TestKeyLogTLS12(t *testing.T) {\n\tvar serverBuf, clientBuf bytes.Buffer\n\n\tclientConfig := testConfig.Clone()\n\tclientConfig.KeyLogWriter = &clientBuf\n\tclientConfig.MaxVersion = VersionTLS12\n\n\tserverConfig := testConfig.Clone()\n\tserverConfig.KeyLogWriter = &serverBuf\n\tserverConfig.MaxVersion = VersionTLS12\n\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\tdefer close(done)\n\n\t\tif err := Server(s, serverConfig).Handshake(); err != nil {\n\t\t\tt.Errorf(\"server: %s\", err)\n\t\t\treturn\n\t\t}\n\t\ts.Close()\n\t}()\n\n\tif err := Client(c, clientConfig).Handshake(); err != nil {\n\t\tt.Fatalf(\"client: %s\", err)\n\t}\n\n\tc.Close()\n\t<-done\n\n\tcheckKeylogLine := func(side, loggedLine string) {\n\t\tif len(loggedLine) == 0 {\n\t\t\tt.Fatalf(\"%s: no keylog line was produced\", side)\n\t\t}\n\t\tconst expectedLen = 13 /* \"CLIENT_RANDOM\" */ +\n\t\t\t1 /* space */ +\n\t\t\t32*2 /* hex client nonce */ +\n\t\t\t1 /* space */ +\n\t\t\t48*2 /* hex master secret */ +\n\t\t\t1 /* new line */\n\t\tif len(loggedLine) != expectedLen {\n\t\t\tt.Fatalf(\"%s: keylog line has incorrect length (want %d, got %d): %q\", side, expectedLen, len(loggedLine), loggedLine)\n\t\t}\n\t\tif !strings.HasPrefix(loggedLine, \"CLIENT_RANDOM \"+strings.Repeat(\"0\", 64)+\" \") {\n\t\t\tt.Fatalf(\"%s: keylog line has incorrect structure or nonce: %q\", side, loggedLine)\n\t\t}\n\t}\n\n\tcheckKeylogLine(\"client\", clientBuf.String())\n\tcheckKeylogLine(\"server\", serverBuf.String())\n}\n\nfunc TestKeyLogTLS13(t *testing.T) {\n\tvar serverBuf, clientBuf bytes.Buffer\n\n\tclientConfig := testConfig.Clone()\n\tclientConfig.KeyLogWriter = &clientBuf\n\n\tserverConfig := testConfig.Clone()\n\tserverConfig.KeyLogWriter = &serverBuf\n\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\tdefer close(done)\n\n\t\tif err := Server(s, serverConfig).Handshake(); err != nil {\n\t\t\tt.Errorf(\"server: %s\", err)\n\t\t\treturn\n\t\t}\n\t\ts.Close()\n\t}()\n\n\tif err := Client(c, clientConfig).Handshake(); err != nil {\n\t\tt.Fatalf(\"client: %s\", err)\n\t}\n\n\tc.Close()\n\t<-done\n\n\tcheckKeylogLines := func(side, loggedLines string) {\n\t\tloggedLines = strings.TrimSpace(loggedLines)\n\t\tlines := strings.Split(loggedLines, \"\\n\")\n\t\tif len(lines) != 4 {\n\t\t\tt.Errorf(\"Expected the %s to log 4 lines, got %d\", side, len(lines))\n\t\t}\n\t}\n\n\tcheckKeylogLines(\"client\", clientBuf.String())\n\tcheckKeylogLines(\"server\", serverBuf.String())\n}\n\nfunc TestHandshakeClientALPNMatch(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.NextProtos = []string{\"proto2\", \"proto1\"}\n\n\ttest := &clientTest{\n\t\tname: \"ALPN\",\n\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n\t\t// version that supports the -alpn flag.\n\t\targs:   []string{\"-alpn\", \"proto1,proto2\"},\n\t\tconfig: config,\n\t\tvalidate: func(state ConnectionState) error {\n\t\t\t// The server's preferences should override the client.\n\t\t\tif state.NegotiatedProtocol != \"proto1\" {\n\t\t\t\treturn fmt.Errorf(\"Got protocol %q, wanted proto1\", state.NegotiatedProtocol)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestServerSelectingUnconfiguredApplicationProtocol(t *testing.T) {\n\t// This checks that the server can't select an application protocol that the\n\t// client didn't offer.\n\n\tc, s := localPipe(t)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\tclient := Client(c, &Config{\n\t\t\tServerName:   \"foo\",\n\t\t\tCipherSuites: []uint16{TLS_RSA_WITH_AES_128_GCM_SHA256},\n\t\t\tNextProtos:   []string{\"http\", \"something-else\"},\n\t\t})\n\t\terrChan <- client.Handshake()\n\t}()\n\n\tvar header [5]byte\n\tif _, err := io.ReadFull(s, header[:]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\trecordLen := int(header[3])<<8 | int(header[4])\n\n\trecord := make([]byte, recordLen)\n\tif _, err := io.ReadFull(s, record); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tserverHello := &serverHelloMsg{\n\t\tvers:         VersionTLS12,\n\t\trandom:       make([]byte, 32),\n\t\tcipherSuite:  TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t\talpnProtocol: \"how-about-this\",\n\t}\n\tserverHelloBytes := mustMarshal(t, serverHello)\n\n\ts.Write([]byte{\n\t\tbyte(recordTypeHandshake),\n\t\tbyte(VersionTLS12 >> 8),\n\t\tbyte(VersionTLS12 & 0xff),\n\t\tbyte(len(serverHelloBytes) >> 8),\n\t\tbyte(len(serverHelloBytes)),\n\t})\n\ts.Write(serverHelloBytes)\n\ts.Close()\n\n\tif err := <-errChan; !strings.Contains(err.Error(), \"server selected unadvertised ALPN protocol\") {\n\t\tt.Fatalf(\"Expected error about unconfigured cipher suite but got %q\", err)\n\t}\n}\n\n// sctsBase64 contains data from `openssl s_client -serverinfo 18 -connect ritter.vg:443`\nconst sctsBase64 = \"ABIBaQFnAHUApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFHl5nuFgAABAMARjBEAiAcS4JdlW5nW9sElUv2zvQyPoZ6ejKrGGB03gjaBZFMLwIgc1Qbbn+hsH0RvObzhS+XZhr3iuQQJY8S9G85D9KeGPAAdgBo9pj4H2SCvjqM7rkoHUz8cVFdZ5PURNEKZ6y7T0/7xAAAAUeX4bVwAAAEAwBHMEUCIDIhFDgG2HIuADBkGuLobU5a4dlCHoJLliWJ1SYT05z6AiEAjxIoZFFPRNWMGGIjskOTMwXzQ1Wh2e7NxXE1kd1J0QsAdgDuS723dc5guuFCaR+r4Z5mow9+X7By2IMAxHuJeqj9ywAAAUhcZIqHAAAEAwBHMEUCICmJ1rBT09LpkbzxtUC+Hi7nXLR0J+2PmwLp+sJMuqK+AiEAr0NkUnEVKVhAkccIFpYDqHOlZaBsuEhWWrYpg2RtKp0=\"\n\nfunc TestHandshakClientSCTs(t *testing.T) {\n\tconfig := testConfig.Clone()\n\n\tscts, err := base64.StdEncoding.DecodeString(sctsBase64)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Note that this needs OpenSSL 1.0.2 because that is the first\n\t// version that supports the -serverinfo flag.\n\ttest := &clientTest{\n\t\tname:       \"SCT\",\n\t\tconfig:     config,\n\t\textensions: [][]byte{scts},\n\t\tvalidate: func(state ConnectionState) error {\n\t\t\texpectedSCTs := [][]byte{\n\t\t\t\tscts[8:125],\n\t\t\t\tscts[127:245],\n\t\t\t\tscts[247:],\n\t\t\t}\n\t\t\tif n := len(state.SignedCertificateTimestamps); n != len(expectedSCTs) {\n\t\t\t\treturn fmt.Errorf(\"Got %d scts, wanted %d\", n, len(expectedSCTs))\n\t\t\t}\n\t\t\tfor i, expected := range expectedSCTs {\n\t\t\t\tif sct := state.SignedCertificateTimestamps[i]; !bytes.Equal(sct, expected) {\n\t\t\t\t\treturn fmt.Errorf(\"SCT #%d contained %x, expected %x\", i, sct, expected)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS12(t, test)\n\n\t// TLS 1.3 moved SCTs to the Certificate extensions and -serverinfo only\n\t// supports ServerHello extensions.\n}\n\nfunc TestRenegotiationRejected(t *testing.T) {\n\tconfig := testConfig.Clone()\n\ttest := &clientTest{\n\t\tname:                        \"RenegotiationRejected\",\n\t\targs:                        []string{\"-state\"},\n\t\tconfig:                      config,\n\t\tnumRenegotiations:           1,\n\t\trenegotiationExpectedToFail: 1,\n\t\tcheckRenegotiationError: func(renegotiationNum int, err error) error {\n\t\t\tif err == nil {\n\t\t\t\treturn errors.New(\"expected error from renegotiation but got nil\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), \"no renegotiation\") {\n\t\t\t\treturn fmt.Errorf(\"expected renegotiation to be rejected but got %q\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestRenegotiateOnce(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.Renegotiation = RenegotiateOnceAsClient\n\n\ttest := &clientTest{\n\t\tname:              \"RenegotiateOnce\",\n\t\targs:              []string{\"-state\"},\n\t\tconfig:            config,\n\t\tnumRenegotiations: 1,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestRenegotiateTwice(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.Renegotiation = RenegotiateFreelyAsClient\n\n\ttest := &clientTest{\n\t\tname:              \"RenegotiateTwice\",\n\t\targs:              []string{\"-state\"},\n\t\tconfig:            config,\n\t\tnumRenegotiations: 2,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestRenegotiateTwiceRejected(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.Renegotiation = RenegotiateOnceAsClient\n\n\ttest := &clientTest{\n\t\tname:                        \"RenegotiateTwiceRejected\",\n\t\targs:                        []string{\"-state\"},\n\t\tconfig:                      config,\n\t\tnumRenegotiations:           2,\n\t\trenegotiationExpectedToFail: 2,\n\t\tcheckRenegotiationError: func(renegotiationNum int, err error) error {\n\t\t\tif renegotiationNum == 1 {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\treturn errors.New(\"expected error from renegotiation but got nil\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), \"no renegotiation\") {\n\t\t\t\treturn fmt.Errorf(\"expected renegotiation to be rejected but got %q\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientExportKeyingMaterial(t *testing.T) {\n\ttest := &clientTest{\n\t\tname:   \"ExportKeyingMaterial\",\n\t\tconfig: testConfig.Clone(),\n\t\tvalidate: func(state ConnectionState) error {\n\t\t\tif km, err := state.ExportKeyingMaterial(\"test\", nil, 42); err != nil {\n\t\t\t\treturn fmt.Errorf(\"ExportKeyingMaterial failed: %v\", err)\n\t\t\t} else if len(km) != 42 {\n\t\t\t\treturn fmt.Errorf(\"Got %d bytes from ExportKeyingMaterial, wanted %d\", len(km), 42)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nvar hostnameInSNITests = []struct {\n\tin, out string\n}{\n\t// Opaque string\n\t{\"\", \"\"},\n\t{\"localhost\", \"localhost\"},\n\t{\"foo, bar, baz and qux\", \"foo, bar, baz and qux\"},\n\n\t// DNS hostname\n\t{\"golang.org\", \"golang.org\"},\n\t{\"golang.org.\", \"golang.org\"},\n\n\t// Literal IPv4 address\n\t{\"1.2.3.4\", \"\"},\n\n\t// Literal IPv6 address\n\t{\"::1\", \"\"},\n\t{\"::1%lo0\", \"\"}, // with zone identifier\n\t{\"[::1]\", \"\"},   // as per RFC 5952 we allow the [] style as IPv6 literal\n\t{\"[::1%lo0]\", \"\"},\n}\n\nfunc TestHostnameInSNI(t *testing.T) {\n\tfor _, tt := range hostnameInSNITests {\n\t\tc, s := localPipe(t)\n\n\t\tgo func(host string) {\n\t\t\tClient(c, &Config{ServerName: host, InsecureSkipVerify: true}).Handshake()\n\t\t}(tt.in)\n\n\t\tvar header [5]byte\n\t\tif _, err := io.ReadFull(s, header[:]); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\trecordLen := int(header[3])<<8 | int(header[4])\n\n\t\trecord := make([]byte, recordLen)\n\t\tif _, err := io.ReadFull(s, record[:]); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tc.Close()\n\t\ts.Close()\n\n\t\tvar m clientHelloMsg\n\t\tif !m.unmarshal(record) {\n\t\t\tt.Errorf(\"unmarshaling ClientHello for %q failed\", tt.in)\n\t\t\tcontinue\n\t\t}\n\t\tif tt.in != tt.out && m.serverName == tt.in {\n\t\t\tt.Errorf(\"prohibited %q found in ClientHello: %x\", tt.in, record)\n\t\t}\n\t\tif m.serverName != tt.out {\n\t\t\tt.Errorf(\"expected %q not found in ClientHello: %x\", tt.out, record)\n\t\t}\n\t}\n}\n\nfunc TestServerSelectingUnconfiguredCipherSuite(t *testing.T) {\n\t// This checks that the server can't select a cipher suite that the\n\t// client didn't offer. See #13174.\n\n\tc, s := localPipe(t)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\tclient := Client(c, &Config{\n\t\t\tServerName:   \"foo\",\n\t\t\tCipherSuites: []uint16{TLS_RSA_WITH_AES_128_GCM_SHA256},\n\t\t})\n\t\terrChan <- client.Handshake()\n\t}()\n\n\tvar header [5]byte\n\tif _, err := io.ReadFull(s, header[:]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\trecordLen := int(header[3])<<8 | int(header[4])\n\n\trecord := make([]byte, recordLen)\n\tif _, err := io.ReadFull(s, record); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create a ServerHello that selects a different cipher suite than the\n\t// sole one that the client offered.\n\tserverHello := &serverHelloMsg{\n\t\tvers:        VersionTLS12,\n\t\trandom:      make([]byte, 32),\n\t\tcipherSuite: TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t}\n\tserverHelloBytes := mustMarshal(t, serverHello)\n\n\ts.Write([]byte{\n\t\tbyte(recordTypeHandshake),\n\t\tbyte(VersionTLS12 >> 8),\n\t\tbyte(VersionTLS12 & 0xff),\n\t\tbyte(len(serverHelloBytes) >> 8),\n\t\tbyte(len(serverHelloBytes)),\n\t})\n\ts.Write(serverHelloBytes)\n\ts.Close()\n\n\tif err := <-errChan; !strings.Contains(err.Error(), \"unconfigured cipher\") {\n\t\tt.Fatalf(\"Expected error about unconfigured cipher suite but got %q\", err)\n\t}\n}\n\nfunc TestVerifyConnection(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testVerifyConnection(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testVerifyConnection(t, VersionTLS13) })\n}\n\nfunc testVerifyConnection(t *testing.T, version uint16) {\n\tcheckFields := func(c ConnectionState, called *int, errorType string) error {\n\t\tif c.Version != version {\n\t\t\treturn fmt.Errorf(\"%s: got Version %v, want %v\", errorType, c.Version, version)\n\t\t}\n\t\tif c.HandshakeComplete {\n\t\t\treturn fmt.Errorf(\"%s: got HandshakeComplete, want false\", errorType)\n\t\t}\n\t\tif c.ServerName != \"example.golang\" {\n\t\t\treturn fmt.Errorf(\"%s: got ServerName %s, want %s\", errorType, c.ServerName, \"example.golang\")\n\t\t}\n\t\tif c.NegotiatedProtocol != \"protocol1\" {\n\t\t\treturn fmt.Errorf(\"%s: got NegotiatedProtocol %s, want %s\", errorType, c.NegotiatedProtocol, \"protocol1\")\n\t\t}\n\t\tif c.CipherSuite == 0 {\n\t\t\treturn fmt.Errorf(\"%s: got CipherSuite 0, want non-zero\", errorType)\n\t\t}\n\t\twantDidResume := false\n\t\tif *called == 2 { // if this is the second time, then it should be a resumption\n\t\t\twantDidResume = true\n\t\t}\n\t\tif c.DidResume != wantDidResume {\n\t\t\treturn fmt.Errorf(\"%s: got DidResume %t, want %t\", errorType, c.DidResume, wantDidResume)\n\t\t}\n\t\treturn nil\n\t}\n\n\ttests := []struct {\n\t\tname            string\n\t\tconfigureServer func(*Config, *int)\n\t\tconfigureClient func(*Config, *int)\n\t}{\n\t\t{\n\t\t\tname: \"RequireAndVerifyClientCert\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = RequireAndVerifyClientCert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.VerifiedChains) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.VerifiedChains) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif c.DidResume {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t// The SCTs and OCSP Response are dropped on resumption.\n\t\t\t\t\t\t// See http://golang.org/issue/39075.\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.OCSPResponse) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.SignedCertificateTimestamps) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(SignedCertificateTimestamps) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"InsecureSkipVerify\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = RequireAnyClientCert\n\t\t\t\tconfig.InsecureSkipVerify = true\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif c.VerifiedChains != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got Verified Chains %v, want nil\", c.VerifiedChains)\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.InsecureSkipVerify = true\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif c.VerifiedChains != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got Verified Chains %v, want nil\", c.VerifiedChains)\n\t\t\t\t\t}\n\t\t\t\t\tif c.DidResume {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t// The SCTs and OCSP Response are dropped on resumption.\n\t\t\t\t\t\t// See http://golang.org/issue/39075.\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.OCSPResponse) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.SignedCertificateTimestamps) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(SignedCertificateTimestamps) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NoClientCert\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = NoClientCert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"RequestClientCert\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = RequestClientCert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.Certificates = nil // clear the client cert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.VerifiedChains) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif c.DidResume {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t// The SCTs and OCSP Response are dropped on resumption.\n\t\t\t\t\t\t// See http://golang.org/issue/39075.\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.OCSPResponse) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.SignedCertificateTimestamps) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(SignedCertificateTimestamps) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\trootCAs := x509.NewCertPool()\n\t\trootCAs.AddCert(issuer)\n\n\t\tvar serverCalled, clientCalled int\n\n\t\tserverConfig := &Config{\n\t\t\tMaxVersion:   version,\n\t\t\tCertificates: []Certificate{testConfig.Certificates[0]},\n\t\t\tClientCAs:    rootCAs,\n\t\t\tNextProtos:   []string{\"protocol1\"},\n\t\t}\n\t\tserverConfig.Certificates[0].SignedCertificateTimestamps = [][]byte{[]byte(\"dummy sct 1\"), []byte(\"dummy sct 2\")}\n\t\tserverConfig.Certificates[0].OCSPStaple = []byte(\"dummy ocsp\")\n\t\ttest.configureServer(serverConfig, &serverCalled)\n\n\t\tclientConfig := &Config{\n\t\t\tMaxVersion:         version,\n\t\t\tClientSessionCache: NewLRUClientSessionCache(32),\n\t\t\tRootCAs:            rootCAs,\n\t\t\tServerName:         \"example.golang\",\n\t\t\tCertificates:       []Certificate{testConfig.Certificates[0]},\n\t\t\tNextProtos:         []string{\"protocol1\"},\n\t\t}\n\t\ttest.configureClient(clientConfig, &clientCalled)\n\n\t\ttestHandshakeState := func(name string, didResume bool) {\n\t\t\t_, hs, err := testHandshake(t, clientConfig, serverConfig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s: handshake failed: %s\", name, err)\n\t\t\t}\n\t\t\tif hs.DidResume != didResume {\n\t\t\t\tt.Errorf(\"%s: resumed: %v, expected: %v\", name, hs.DidResume, didResume)\n\t\t\t}\n\t\t\twantCalled := 1\n\t\t\tif didResume {\n\t\t\t\twantCalled = 2 // resumption would mean this is the second time it was called in this test\n\t\t\t}\n\t\t\tif clientCalled != wantCalled {\n\t\t\t\tt.Errorf(\"%s: expected client VerifyConnection called %d times, did %d times\", name, wantCalled, clientCalled)\n\t\t\t}\n\t\t\tif serverCalled != wantCalled {\n\t\t\t\tt.Errorf(\"%s: expected server VerifyConnection called %d times, did %d times\", name, wantCalled, serverCalled)\n\t\t\t}\n\t\t}\n\t\ttestHandshakeState(fmt.Sprintf(\"%s-FullHandshake\", test.name), false)\n\t\ttestHandshakeState(fmt.Sprintf(\"%s-Resumption\", test.name), true)\n\t}\n}\n\nfunc TestVerifyPeerCertificate(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testVerifyPeerCertificate(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testVerifyPeerCertificate(t, VersionTLS13) })\n}\n\nfunc testVerifyPeerCertificate(t *testing.T, version uint16) {\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\trootCAs := x509.NewCertPool()\n\trootCAs.AddCert(issuer)\n\n\tnow := func() time.Time { return time.Unix(1476984729, 0) }\n\n\tsentinelErr := errors.New(\"TestVerifyPeerCertificate\")\n\n\tverifyPeerCertificateCallback := func(called *bool, rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\tif l := len(rawCerts); l != 1 {\n\t\t\treturn fmt.Errorf(\"got len(rawCerts) = %d, wanted 1\", l)\n\t\t}\n\t\tif len(validatedChains) == 0 {\n\t\t\treturn errors.New(\"got len(validatedChains) = 0, wanted non-zero\")\n\t\t}\n\t\t*called = true\n\t\treturn nil\n\t}\n\tverifyConnectionCallback := func(called *bool, isClient bool, c ConnectionState) error {\n\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\treturn fmt.Errorf(\"got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t}\n\t\tif len(c.VerifiedChains) == 0 {\n\t\t\treturn fmt.Errorf(\"got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t}\n\t\tif isClient && len(c.OCSPResponse) == 0 {\n\t\t\treturn fmt.Errorf(\"got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t}\n\t\t*called = true\n\t\treturn nil\n\t}\n\n\ttests := []struct {\n\t\tconfigureServer func(*Config, *bool)\n\t\tconfigureClient func(*Config, *bool)\n\t\tvalidate        func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error)\n\t}{\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif serverErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t\tif !serverCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: server did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.VerifyPeerCertificate = nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif serverErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got server error %v, wanted sentinelErr\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got client error %v, wanted sentinelErr\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = true\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\tif l := len(rawCerts); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"got len(rawCerts) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\t// With InsecureSkipVerify set, this\n\t\t\t\t\t// callback should still be called but\n\t\t\t\t\t// validatedChains must be empty.\n\t\t\t\t\tif l := len(validatedChains); l != 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"got len(validatedChains) = %d, wanted zero\", l)\n\t\t\t\t\t}\n\t\t\t\t\t*called = true\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif serverErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn verifyConnectionCallback(called, false, c)\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn verifyConnectionCallback(called, true, c)\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif serverErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t\tif !serverCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: server did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif serverErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got server error %v, wanted sentinelErr\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got client error %v, wanted sentinelErr\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = nil\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif serverErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got server error %v, wanted sentinelErr\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !serverCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: server did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = nil\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got client error %v, wanted sentinelErr\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tc, s := localPipe(t)\n\t\tdone := make(chan error)\n\n\t\tvar clientCalled, serverCalled bool\n\n\t\tgo func() {\n\t\t\tconfig := testConfig.Clone()\n\t\t\tconfig.ServerName = \"example.golang\"\n\t\t\tconfig.ClientAuth = RequireAndVerifyClientCert\n\t\t\tconfig.ClientCAs = rootCAs\n\t\t\tconfig.Time = now\n\t\t\tconfig.MaxVersion = version\n\t\t\tconfig.Certificates = make([]Certificate, 1)\n\t\t\tconfig.Certificates[0].Certificate = [][]byte{testRSACertificate}\n\t\t\tconfig.Certificates[0].PrivateKey = testRSAPrivateKey\n\t\t\tconfig.Certificates[0].SignedCertificateTimestamps = [][]byte{[]byte(\"dummy sct 1\"), []byte(\"dummy sct 2\")}\n\t\t\tconfig.Certificates[0].OCSPStaple = []byte(\"dummy ocsp\")\n\t\t\ttest.configureServer(config, &serverCalled)\n\n\t\t\terr = Server(s, config).Handshake()\n\t\t\ts.Close()\n\t\t\tdone <- err\n\t\t}()\n\n\t\tconfig := testConfig.Clone()\n\t\tconfig.ServerName = \"example.golang\"\n\t\tconfig.RootCAs = rootCAs\n\t\tconfig.Time = now\n\t\tconfig.MaxVersion = version\n\t\ttest.configureClient(config, &clientCalled)\n\t\tclientErr := Client(c, config).Handshake()\n\t\tc.Close()\n\t\tserverErr := <-done\n\n\t\ttest.validate(t, i, clientCalled, serverCalled, clientErr, serverErr)\n\t}\n}\n\n// brokenConn wraps a net.Conn and causes all Writes after a certain number to\n// fail with brokenConnErr.\ntype brokenConn struct {\n\tnet.Conn\n\n\t// breakAfter is the number of successful writes that will be allowed\n\t// before all subsequent writes fail.\n\tbreakAfter int\n\n\t// numWrites is the number of writes that have been done.\n\tnumWrites int\n}\n\n// brokenConnErr is the error that brokenConn returns once exhausted.\nvar brokenConnErr = errors.New(\"too many writes to brokenConn\")\n\nfunc (b *brokenConn) Write(data []byte) (int, error) {\n\tif b.numWrites >= b.breakAfter {\n\t\treturn 0, brokenConnErr\n\t}\n\n\tb.numWrites++\n\treturn b.Conn.Write(data)\n}\n\nfunc TestFailedWrite(t *testing.T) {\n\t// Test that a write error during the handshake is returned.\n\tfor _, breakAfter := range []int{0, 1} {\n\t\tc, s := localPipe(t)\n\t\tdone := make(chan bool)\n\n\t\tgo func() {\n\t\t\tServer(s, testConfig).Handshake()\n\t\t\ts.Close()\n\t\t\tdone <- true\n\t\t}()\n\n\t\tbrokenC := &brokenConn{Conn: c, breakAfter: breakAfter}\n\t\terr := Client(brokenC, testConfig).Handshake()\n\t\tif err != brokenConnErr {\n\t\t\tt.Errorf(\"#%d: expected error from brokenConn but got %q\", breakAfter, err)\n\t\t}\n\t\tbrokenC.Close()\n\n\t\t<-done\n\t}\n}\n\n// writeCountingConn wraps a net.Conn and counts the number of Write calls.\ntype writeCountingConn struct {\n\tnet.Conn\n\n\t// numWrites is the number of writes that have been done.\n\tnumWrites int\n}\n\nfunc (wcc *writeCountingConn) Write(data []byte) (int, error) {\n\twcc.numWrites++\n\treturn wcc.Conn.Write(data)\n}\n\nfunc TestBuffering(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testBuffering(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testBuffering(t, VersionTLS13) })\n}\n\nfunc testBuffering(t *testing.T, version uint16) {\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tclientWCC := &writeCountingConn{Conn: c}\n\tserverWCC := &writeCountingConn{Conn: s}\n\n\tgo func() {\n\t\tconfig := testConfig.Clone()\n\t\tconfig.MaxVersion = version\n\t\tServer(serverWCC, config).Handshake()\n\t\tserverWCC.Close()\n\t\tdone <- true\n\t}()\n\n\terr := Client(clientWCC, testConfig).Handshake()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclientWCC.Close()\n\t<-done\n\n\tvar expectedClient, expectedServer int\n\tif version == VersionTLS13 {\n\t\texpectedClient = 2\n\t\texpectedServer = 1\n\t} else {\n\t\texpectedClient = 2\n\t\texpectedServer = 2\n\t}\n\n\tif n := clientWCC.numWrites; n != expectedClient {\n\t\tt.Errorf(\"expected client handshake to complete with %d writes, but saw %d\", expectedClient, n)\n\t}\n\n\tif n := serverWCC.numWrites; n != expectedServer {\n\t\tt.Errorf(\"expected server handshake to complete with %d writes, but saw %d\", expectedServer, n)\n\t}\n}\n\nfunc TestAlertFlushing(t *testing.T) {\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tclientWCC := &writeCountingConn{Conn: c}\n\tserverWCC := &writeCountingConn{Conn: s}\n\n\tserverConfig := testConfig.Clone()\n\n\t// Cause a signature-time error\n\tbrokenKey := rsa.PrivateKey{PublicKey: testRSAPrivateKey.PublicKey}\n\tbrokenKey.D = big.NewInt(42)\n\tserverConfig.Certificates = []Certificate{{\n\t\tCertificate: [][]byte{testRSACertificate},\n\t\tPrivateKey:  &brokenKey,\n\t}}\n\n\tgo func() {\n\t\tServer(serverWCC, serverConfig).Handshake()\n\t\tserverWCC.Close()\n\t\tdone <- true\n\t}()\n\n\terr := Client(clientWCC, testConfig).Handshake()\n\tif err == nil {\n\t\tt.Fatal(\"client unexpectedly returned no error\")\n\t}\n\n\tconst expectedError = \"remote error: tls: internal error\"\n\tif e := err.Error(); !strings.Contains(e, expectedError) {\n\t\tt.Fatalf(\"expected to find %q in error but error was %q\", expectedError, e)\n\t}\n\tclientWCC.Close()\n\t<-done\n\n\tif n := serverWCC.numWrites; n != 1 {\n\t\tt.Errorf(\"expected server handshake to complete with one write, but saw %d\", n)\n\t}\n}\n\nfunc TestHandshakeRace(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping in -short mode\")\n\t}\n\tt.Parallel()\n\t// This test races a Read and Write to try and complete a handshake in\n\t// order to provide some evidence that there are no races or deadlocks\n\t// in the handshake locking.\n\tfor i := 0; i < 32; i++ {\n\t\tc, s := localPipe(t)\n\n\t\tgo func() {\n\t\t\tserver := Server(s, testConfig)\n\t\t\tif err := server.Handshake(); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tvar request [1]byte\n\t\t\tif n, err := server.Read(request[:]); err != nil || n != 1 {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tserver.Write(request[:])\n\t\t\tserver.Close()\n\t\t}()\n\n\t\tstartWrite := make(chan struct{})\n\t\tstartRead := make(chan struct{})\n\t\treadDone := make(chan struct{}, 1)\n\n\t\tclient := Client(c, testConfig)\n\t\tgo func() {\n\t\t\t<-startWrite\n\t\t\tvar request [1]byte\n\t\t\tclient.Write(request[:])\n\t\t}()\n\n\t\tgo func() {\n\t\t\t<-startRead\n\t\t\tvar reply [1]byte\n\t\t\tif _, err := io.ReadFull(client, reply[:]); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treadDone <- struct{}{}\n\t\t}()\n\n\t\tif i&1 == 1 {\n\t\t\tstartWrite <- struct{}{}\n\t\t\tstartRead <- struct{}{}\n\t\t} else {\n\t\t\tstartRead <- struct{}{}\n\t\t\tstartWrite <- struct{}{}\n\t\t}\n\t\t<-readDone\n\t}\n}\n\nvar getClientCertificateTests = []struct {\n\tsetup               func(*Config, *Config)\n\texpectedClientError string\n\tverify              func(*testing.T, int, *ConnectionState)\n}{\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\t// Returning a Certificate with no certificate data\n\t\t\t// should result in an empty message being sent to the\n\t\t\t// server.\n\t\t\tserverConfig.ClientCAs = nil\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\tif len(cri.SignatureSchemes) == 0 {\n\t\t\t\t\tpanic(\"empty SignatureSchemes\")\n\t\t\t\t}\n\t\t\t\tif len(cri.AcceptableCAs) != 0 {\n\t\t\t\t\tpanic(\"AcceptableCAs should have been empty\")\n\t\t\t\t}\n\t\t\t\treturn new(Certificate), nil\n\t\t\t}\n\t\t},\n\t\t\"\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t\tif l := len(cs.PeerCertificates); l != 0 {\n\t\t\t\tt.Errorf(\"#%d: expected no certificates but got %d\", testNum, l)\n\t\t\t}\n\t\t},\n\t},\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\t// With TLS 1.1, the SignatureSchemes should be\n\t\t\t// synthesised from the supported certificate types.\n\t\t\tclientConfig.MaxVersion = VersionTLS11\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\tif len(cri.SignatureSchemes) == 0 {\n\t\t\t\t\tpanic(\"empty SignatureSchemes\")\n\t\t\t\t}\n\t\t\t\treturn new(Certificate), nil\n\t\t\t}\n\t\t},\n\t\t\"\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t\tif l := len(cs.PeerCertificates); l != 0 {\n\t\t\t\tt.Errorf(\"#%d: expected no certificates but got %d\", testNum, l)\n\t\t\t}\n\t\t},\n\t},\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\t// Returning an error should abort the handshake with\n\t\t\t// that error.\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\treturn nil, errors.New(\"GetClientCertificate\")\n\t\t\t}\n\t\t},\n\t\t\"GetClientCertificate\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t},\n\t},\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\tif len(cri.AcceptableCAs) == 0 {\n\t\t\t\t\tpanic(\"empty AcceptableCAs\")\n\t\t\t\t}\n\t\t\t\tcert := &Certificate{\n\t\t\t\t\tCertificate: [][]byte{testRSACertificate},\n\t\t\t\t\tPrivateKey:  testRSAPrivateKey,\n\t\t\t\t}\n\t\t\t\treturn cert, nil\n\t\t\t}\n\t\t},\n\t\t\"\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t\tif len(cs.VerifiedChains) == 0 {\n\t\t\t\tt.Errorf(\"#%d: expected some verified chains, but found none\", testNum)\n\t\t\t}\n\t\t},\n\t},\n}\n\nfunc TestGetClientCertificate(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testGetClientCertificate(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testGetClientCertificate(t, VersionTLS13) })\n}\n\nfunc testGetClientCertificate(t *testing.T, version uint16) {\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i, test := range getClientCertificateTests {\n\t\tserverConfig := testConfig.Clone()\n\t\tserverConfig.ClientAuth = VerifyClientCertIfGiven\n\t\tserverConfig.RootCAs = x509.NewCertPool()\n\t\tserverConfig.RootCAs.AddCert(issuer)\n\t\tserverConfig.ClientCAs = serverConfig.RootCAs\n\t\tserverConfig.Time = func() time.Time { return time.Unix(1476984729, 0) }\n\t\tserverConfig.MaxVersion = version\n\n\t\tclientConfig := testConfig.Clone()\n\t\tclientConfig.MaxVersion = version\n\n\t\ttest.setup(clientConfig, serverConfig)\n\n\t\ttype serverResult struct {\n\t\t\tcs  ConnectionState\n\t\t\terr error\n\t\t}\n\n\t\tc, s := localPipe(t)\n\t\tdone := make(chan serverResult)\n\n\t\tgo func() {\n\t\t\tdefer s.Close()\n\t\t\tserver := Server(s, serverConfig)\n\t\t\terr := server.Handshake()\n\n\t\t\tvar cs ConnectionState\n\t\t\tif err == nil {\n\t\t\t\tcs = server.ConnectionState()\n\t\t\t}\n\t\t\tdone <- serverResult{cs, err}\n\t\t}()\n\n\t\tclientErr := Client(c, clientConfig).Handshake()\n\t\tc.Close()\n\n\t\tresult := <-done\n\n\t\tif clientErr != nil {\n\t\t\tif len(test.expectedClientError) == 0 {\n\t\t\t\tt.Errorf(\"#%d: client error: %v\", i, clientErr)\n\t\t\t} else if got := clientErr.Error(); got != test.expectedClientError {\n\t\t\t\tt.Errorf(\"#%d: expected client error %q, but got %q\", i, test.expectedClientError, got)\n\t\t\t} else {\n\t\t\t\ttest.verify(t, i, &result.cs)\n\t\t\t}\n\t\t} else if len(test.expectedClientError) > 0 {\n\t\t\tt.Errorf(\"#%d: expected client error %q, but got no error\", i, test.expectedClientError)\n\t\t} else if err := result.err; err != nil {\n\t\t\tt.Errorf(\"#%d: server error: %v\", i, err)\n\t\t} else {\n\t\t\ttest.verify(t, i, &result.cs)\n\t\t}\n\t}\n}\n\nfunc TestRSAPSSKeyError(t *testing.T) {\n\t// crypto/tls does not support the rsa_pss_pss_* SignatureSchemes. If support for\n\t// public keys with OID RSASSA-PSS is added to crypto/x509, they will be misused with\n\t// the rsa_pss_rsae_* SignatureSchemes. Assert that RSASSA-PSS certificates don't\n\t// parse, or that they don't carry *rsa.PublicKey keys.\n\tb, _ := pem.Decode([]byte(`\n-----BEGIN CERTIFICATE-----\nMIIDZTCCAhygAwIBAgIUCF2x0FyTgZG0CC9QTDjGWkB5vgEwPgYJKoZIhvcNAQEK\nMDGgDTALBglghkgBZQMEAgGhGjAYBgkqhkiG9w0BAQgwCwYJYIZIAWUDBAIBogQC\nAgDeMBIxEDAOBgNVBAMMB1JTQS1QU1MwHhcNMTgwNjI3MjI0NDM2WhcNMTgwNzI3\nMjI0NDM2WjASMRAwDgYDVQQDDAdSU0EtUFNTMIIBIDALBgkqhkiG9w0BAQoDggEP\nADCCAQoCggEBANxDm0f76JdI06YzsjB3AmmjIYkwUEGxePlafmIASFjDZl/elD0Z\n/a7xLX468b0qGxLS5al7XCcEprSdsDR6DF5L520+pCbpfLyPOjuOvGmk9KzVX4x5\nb05YXYuXdsQ0Kjxcx2i3jjCday6scIhMJVgBZxTEyMj1thPQM14SHzKCd/m6HmCL\nQmswpH2yMAAcBRWzRpp/vdH5DeOJEB3aelq7094no731mrLUCHRiZ1htq8BDB3ou\nczwqgwspbqZ4dnMXl2MvfySQ5wJUxQwILbiuAKO2lVVPUbFXHE9pgtznNoPvKwQT\nJNcX8ee8WIZc2SEGzofjk3NpjR+2ADB2u3sCAwEAAaNTMFEwHQYDVR0OBBYEFNEz\nAdyJ2f+fU+vSCS6QzohnOnprMB8GA1UdIwQYMBaAFNEzAdyJ2f+fU+vSCS6Qzohn\nOnprMA8GA1UdEwEB/wQFMAMBAf8wPgYJKoZIhvcNAQEKMDGgDTALBglghkgBZQME\nAgGhGjAYBgkqhkiG9w0BAQgwCwYJYIZIAWUDBAIBogQCAgDeA4IBAQCjEdrR5aab\nsZmCwrMeKidXgfkmWvfuLDE+TCbaqDZp7BMWcMQXT9O0UoUT5kqgKj2ARm2pEW0Z\nH3Z1vj3bbds72qcDIJXp+l0fekyLGeCrX/CbgnMZXEP7+/+P416p34ChR1Wz4dU1\nKD3gdsUuTKKeMUog3plxlxQDhRQmiL25ygH1LmjLd6dtIt0GVRGr8lj3euVeprqZ\nbZ3Uq5eLfsn8oPgfC57gpO6yiN+UURRTlK3bgYvLh4VWB3XXk9UaQZ7Mq1tpXjoD\nHYFybkWzibkZp4WRo+Fa28rirH+/wHt0vfeN7UCceURZEx4JaxIIfe4ku7uDRhJi\nRwBA9Xk1KBNF\n-----END CERTIFICATE-----`))\n\tif b == nil {\n\t\tt.Fatal(\"Failed to decode certificate\")\n\t}\n\tcert, err := x509.ParseCertificate(b.Bytes)\n\tif err != nil {\n\t\treturn\n\t}\n\tif _, ok := cert.PublicKey.(*rsa.PublicKey); ok {\n\t\tt.Error(\"A RSASSA-PSS certificate was parsed like a PKCS#1 v1.5 one, and it will be mistakenly used with rsa_pss_rsae_* signature algorithms\")\n\t}\n}\n\nfunc TestCloseClientConnectionOnIdleServer(t *testing.T) {\n\tclientConn, serverConn := localPipe(t)\n\tclient := Client(clientConn, testConfig.Clone())\n\tgo func() {\n\t\tvar b [1]byte\n\t\tserverConn.Read(b[:])\n\t\tclient.Close()\n\t}()\n\tclient.SetWriteDeadline(time.Now().Add(time.Minute))\n\terr := client.Handshake()\n\tif err != nil {\n\t\tif err, ok := err.(net.Error); ok && err.Timeout() {\n\t\t\tt.Errorf(\"Expected a closed network connection error but got '%s'\", err.Error())\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Error expected, but no error returned\")\n\t}\n}\n\nfunc testDowngradeCanary(t *testing.T, clientVersion, serverVersion uint16) error {\n\tdefer func() { testingOnlyForceDowngradeCanary = false }()\n\ttestingOnlyForceDowngradeCanary = true\n\n\tclientConfig := testConfig.Clone()\n\tclientConfig.MaxVersion = clientVersion\n\tserverConfig := testConfig.Clone()\n\tserverConfig.MaxVersion = serverVersion\n\t_, _, err := testHandshake(t, clientConfig, serverConfig)\n\treturn err\n}\n\nfunc TestDowngradeCanary(t *testing.T) {\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS12); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.3 to TLS 1.2 was not detected\")\n\t}\n\tif testing.Short() {\n\t\tt.Skip(\"skipping the rest of the checks in short mode\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS11); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.3 to TLS 1.1 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS10); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.3 to TLS 1.0 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS12, VersionTLS11); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.2 to TLS 1.1 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS12, VersionTLS10); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.2 to TLS 1.0 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS13); err != nil {\n\t\tt.Errorf(\"server unexpectedly sent downgrade canary for TLS 1.3\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS12, VersionTLS12); err != nil {\n\t\tt.Errorf(\"client didn't ignore expected TLS 1.2 canary\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS11, VersionTLS11); err != nil {\n\t\tt.Errorf(\"client unexpectedly reacted to a canary in TLS 1.1\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS10, VersionTLS10); err != nil {\n\t\tt.Errorf(\"client unexpectedly reacted to a canary in TLS 1.0\")\n\t}\n}\n\nfunc TestResumptionKeepsOCSPAndSCT(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testResumptionKeepsOCSPAndSCT(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testResumptionKeepsOCSPAndSCT(t, VersionTLS13) })\n}\n\nfunc testResumptionKeepsOCSPAndSCT(t *testing.T, ver uint16) {\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse test issuer\")\n\t}\n\troots := x509.NewCertPool()\n\troots.AddCert(issuer)\n\tclientConfig := &Config{\n\t\tMaxVersion:         ver,\n\t\tClientSessionCache: NewLRUClientSessionCache(32),\n\t\tServerName:         \"example.golang\",\n\t\tRootCAs:            roots,\n\t}\n\tserverConfig := testConfig.Clone()\n\tserverConfig.MaxVersion = ver\n\tserverConfig.Certificates[0].OCSPStaple = []byte{1, 2, 3}\n\tserverConfig.Certificates[0].SignedCertificateTimestamps = [][]byte{{4, 5, 6}}\n\n\t_, ccs, err := testHandshake(t, clientConfig, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n\t// after a new session we expect to see OCSPResponse and\n\t// SignedCertificateTimestamps populated as usual\n\tif !bytes.Equal(ccs.OCSPResponse, serverConfig.Certificates[0].OCSPStaple) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected OCSPResponse: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].OCSPStaple, ccs.OCSPResponse)\n\t}\n\tif !reflect.DeepEqual(ccs.SignedCertificateTimestamps, serverConfig.Certificates[0].SignedCertificateTimestamps) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected SignedCertificateTimestamps: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].SignedCertificateTimestamps, ccs.SignedCertificateTimestamps)\n\t}\n\n\t// if the server doesn't send any SCTs, repopulate the old SCTs\n\toldSCTs := serverConfig.Certificates[0].SignedCertificateTimestamps\n\tserverConfig.Certificates[0].SignedCertificateTimestamps = nil\n\t_, ccs, err = testHandshake(t, clientConfig, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n\tif !ccs.DidResume {\n\t\tt.Fatalf(\"expected session to be resumed\")\n\t}\n\t// after a resumed session we also expect to see OCSPResponse\n\t// and SignedCertificateTimestamps populated\n\tif !bytes.Equal(ccs.OCSPResponse, serverConfig.Certificates[0].OCSPStaple) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected OCSPResponse after resumption: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].OCSPStaple, ccs.OCSPResponse)\n\t}\n\tif !reflect.DeepEqual(ccs.SignedCertificateTimestamps, oldSCTs) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected SignedCertificateTimestamps after resumption: wanted %v, got %v\",\n\t\t\toldSCTs, ccs.SignedCertificateTimestamps)\n\t}\n\n\t//  Only test overriding the SCTs for TLS 1.2, since in 1.3\n\t// the server won't send the message containing them\n\tif ver == VersionTLS13 {\n\t\treturn\n\t}\n\n\t// if the server changes the SCTs it sends, they should override the saved SCTs\n\tserverConfig.Certificates[0].SignedCertificateTimestamps = [][]byte{{7, 8, 9}}\n\t_, ccs, err = testHandshake(t, clientConfig, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n\tif !ccs.DidResume {\n\t\tt.Fatalf(\"expected session to be resumed\")\n\t}\n\tif !reflect.DeepEqual(ccs.SignedCertificateTimestamps, serverConfig.Certificates[0].SignedCertificateTimestamps) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected SignedCertificateTimestamps after resumption: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].SignedCertificateTimestamps, ccs.SignedCertificateTimestamps)\n\t}\n}\n\n// TestClientHandshakeContextCancellation tests that canceling\n// the context given to the client side conn.HandshakeContext\n// interrupts the in-progress handshake.\nfunc TestClientHandshakeContextCancellation(t *testing.T) {\n\tc, s := localPipe(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tunblockServer := make(chan struct{})\n\tdefer close(unblockServer)\n\tgo func() {\n\t\tcancel()\n\t\t<-unblockServer\n\t\t_ = s.Close()\n\t}()\n\tcli := Client(c, testConfig)\n\t// Initiates client side handshake, which will block until the client hello is read\n\t// by the server, unless the cancellation works.\n\terr := cli.HandshakeContext(ctx)\n\tif err == nil {\n\t\tt.Fatal(\"Client handshake did not error when the context was canceled\")\n\t}\n\tif err != context.Canceled {\n\t\tt.Errorf(\"Unexpected client handshake error: %v\", err)\n\t}\n\tif runtime.GOARCH == \"wasm\" {\n\t\tt.Skip(\"conn.Close does not error as expected when called multiple times on WASM\")\n\t}\n\terr = cli.Close()\n\tif err == nil {\n\t\tt.Error(\"Client connection was not closed when the context was canceled\")\n\t}\n}\n\n// TestTLS13OnlyClientHelloCipherSuite tests that when a client states that\n// it only supports TLS 1.3, it correctly advertises only TLS 1.3 ciphers.\nfunc TestTLS13OnlyClientHelloCipherSuite(t *testing.T) {\n\ttls13Tests := []struct {\n\t\tname    string\n\t\tciphers []uint16\n\t}{\n\t\t{\n\t\t\tname:    \"nil\",\n\t\t\tciphers: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty\",\n\t\t\tciphers: []uint16{},\n\t\t},\n\t\t{\n\t\t\tname:    \"some TLS 1.2 cipher\",\n\t\t\tciphers: []uint16{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256},\n\t\t},\n\t\t{\n\t\t\tname:    \"some TLS 1.3 cipher\",\n\t\t\tciphers: []uint16{TLS_AES_128_GCM_SHA256},\n\t\t},\n\t\t{\n\t\t\tname:    \"some TLS 1.2 and 1.3 ciphers\",\n\t\t\tciphers: []uint16{TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_AES_256_GCM_SHA384},\n\t\t},\n\t}\n\tfor _, tt := range tls13Tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ttestTLS13OnlyClientHelloCipherSuite(t, tt.ciphers)\n\t\t})\n\t}\n}\n\nfunc testTLS13OnlyClientHelloCipherSuite(t *testing.T, ciphers []uint16) {\n\tserverConfig := &Config{\n\t\tCertificates: testConfig.Certificates,\n\t\tGetConfigForClient: func(chi *ClientHelloInfo) (*Config, error) {\n\t\t\tif len(chi.CipherSuites) != len(defaultCipherSuitesTLS13NoAES) {\n\t\t\t\tt.Errorf(\"only TLS 1.3 suites should be advertised, got=%x\", chi.CipherSuites)\n\t\t\t} else {\n\t\t\t\tfor i := range defaultCipherSuitesTLS13NoAES {\n\t\t\t\t\tif want, got := defaultCipherSuitesTLS13NoAES[i], chi.CipherSuites[i]; want != got {\n\t\t\t\t\t\tt.Errorf(\"cipher at index %d does not match, want=%x, got=%x\", i, want, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t},\n\t}\n\tclientConfig := &Config{\n\t\tMinVersion:         VersionTLS13, // client only supports TLS 1.3\n\t\tCipherSuites:       ciphers,\n\t\tInsecureSkipVerify: true,\n\t}\n\tif _, _, err := testHandshake(t, clientConfig, serverConfig); err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n}\n", "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage tls\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"time\"\n)\n\n// serverHandshakeState contains details of a server handshake in progress.\n// It's discarded once the handshake has completed.\ntype serverHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tclientHello  *clientHelloMsg\n\thello        *serverHelloMsg\n\tsuite        *cipherSuite\n\tecdheOk      bool\n\tecSignOk     bool\n\trsaDecryptOk bool\n\trsaSignOk    bool\n\tsessionState *SessionState\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tcert         *Certificate\n}\n\n// serverHandshake performs a TLS handshake as a server.\nfunc (c *Conn) serverHandshake(ctx context.Context) error {\n\tclientHello, err := c.readClientHello(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.vers == VersionTLS13 {\n\t\ths := serverHandshakeStateTLS13{\n\t\t\tc:           c,\n\t\t\tctx:         ctx,\n\t\t\tclientHello: clientHello,\n\t\t}\n\t\treturn hs.handshake()\n\t}\n\n\ths := serverHandshakeState{\n\t\tc:           c,\n\t\tctx:         ctx,\n\t\tclientHello: clientHello,\n\t}\n\treturn hs.handshake()\n}\n\nfunc (hs *serverHandshakeState) handshake() error {\n\tc := hs.c\n\n\tif err := hs.processClientHello(); err != nil {\n\t\treturn err\n\t}\n\n\t// For an overview of TLS handshaking, see RFC 5246, Section 7.3.\n\tc.buffering = true\n\tif err := hs.checkForResumption(); err != nil {\n\t\treturn err\n\t}\n\tif hs.sessionState != nil {\n\t\t// The client has included a session ticket and so we do an abbreviated handshake.\n\t\tif err := hs.doResumeHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = false\n\t\tif err := hs.readFinished(nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// The client didn't include a session ticket, or it wasn't\n\t\t// valid so we do a full handshake.\n\t\tif err := hs.pickCipherSuite(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.doFullHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = true\n\t\tc.buffering = true\n\t\tif err := hs.sendSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tc.ekm = ekmFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random)\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\n// readClientHello reads a ClientHello message and selects the protocol version.\nfunc (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error) {\n\t// clientHelloMsg is included in the transcript, but we haven't initialized\n\t// it yet. The respective handshake functions will record it themselves.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclientHello, ok := msg.(*clientHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn nil, unexpectedMessageError(clientHello, msg)\n\t}\n\n\tvar configForClient *Config\n\toriginalConfig := c.config\n\tif c.config.GetConfigForClient != nil {\n\t\tchi := clientHelloInfo(ctx, c, clientHello)\n\t\tif configForClient, err = c.config.GetConfigForClient(chi); err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn nil, err\n\t\t} else if configForClient != nil {\n\t\t\tc.config = configForClient\n\t\t}\n\t}\n\tc.ticketKeys = originalConfig.ticketKeys(configForClient)\n\n\tclientVersions := clientHello.supportedVersions\n\tif len(clientHello.supportedVersions) == 0 {\n\t\tclientVersions = supportedVersionsFromMax(clientHello.vers)\n\t}\n\tc.vers, ok = c.config.mutualVersion(roleServer, clientVersions)\n\tif !ok {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn nil, fmt.Errorf(\"tls: client offered only unsupported versions: %x\", clientVersions)\n\t}\n\tc.haveVers = true\n\tc.in.version = c.vers\n\tc.out.version = c.vers\n\n\treturn clientHello, nil\n}\n\nfunc (hs *serverHandshakeState) processClientHello() error {\n\tc := hs.c\n\n\ths.hello = new(serverHelloMsg)\n\ths.hello.vers = c.vers\n\n\tfoundCompression := false\n\t// We only support null compression, so check that the client offered it.\n\tfor _, compression := range hs.clientHello.compressionMethods {\n\t\tif compression == compressionNone {\n\t\t\tfoundCompression = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !foundCompression {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: client does not support uncompressed connections\")\n\t}\n\n\ths.hello.random = make([]byte, 32)\n\tserverRandom := hs.hello.random\n\t// Downgrade protection canaries. See RFC 8446, Section 4.1.3.\n\tmaxVers := c.config.maxSupportedVersion(roleServer)\n\tif maxVers >= VersionTLS12 && c.vers < maxVers || testingOnlyForceDowngradeCanary {\n\t\tif c.vers == VersionTLS12 {\n\t\t\tcopy(serverRandom[24:], downgradeCanaryTLS12)\n\t\t} else {\n\t\t\tcopy(serverRandom[24:], downgradeCanaryTLS11)\n\t\t}\n\t\tserverRandom = serverRandom[:24]\n\t}\n\t_, err := io.ReadFull(c.config.rand(), serverRandom)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\tif len(hs.clientHello.secureRenegotiation) != 0 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n\t}\n\n\ths.hello.extendedMasterSecret = hs.clientHello.extendedMasterSecret\n\ths.hello.secureRenegotiationSupported = hs.clientHello.secureRenegotiationSupported\n\ths.hello.compressionMethod = compressionNone\n\tif len(hs.clientHello.serverName) > 0 {\n\t\tc.serverName = hs.clientHello.serverName\n\t}\n\n\tselectedProto, err := negotiateALPN(c.config.NextProtos, hs.clientHello.alpnProtocols, false)\n\tif err != nil {\n\t\tc.sendAlert(alertNoApplicationProtocol)\n\t\treturn err\n\t}\n\ths.hello.alpnProtocol = selectedProto\n\tc.clientProtocol = selectedProto\n\n\ths.cert, err = c.config.getCertificate(clientHelloInfo(hs.ctx, c, hs.clientHello))\n\tif err != nil {\n\t\tif err == errNoCertificates {\n\t\t\tc.sendAlert(alertUnrecognizedName)\n\t\t} else {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t}\n\t\treturn err\n\t}\n\tif hs.clientHello.scts {\n\t\ths.hello.scts = hs.cert.SignedCertificateTimestamps\n\t}\n\n\ths.ecdheOk = supportsECDHE(c.config, hs.clientHello.supportedCurves, hs.clientHello.supportedPoints)\n\n\tif hs.ecdheOk && len(hs.clientHello.supportedPoints) > 0 {\n\t\t// Although omitting the ec_point_formats extension is permitted, some\n\t\t// old OpenSSL version will refuse to handshake if not present.\n\t\t//\n\t\t// Per RFC 4492, section 5.1.2, implementations MUST support the\n\t\t// uncompressed point format. See golang.org/issue/31943.\n\t\ths.hello.supportedPoints = []uint8{pointFormatUncompressed}\n\t}\n\n\tif priv, ok := hs.cert.PrivateKey.(crypto.Signer); ok {\n\t\tswitch priv.Public().(type) {\n\t\tcase *ecdsa.PublicKey:\n\t\t\ths.ecSignOk = true\n\t\tcase ed25519.PublicKey:\n\t\t\ths.ecSignOk = true\n\t\tcase *rsa.PublicKey:\n\t\t\ths.rsaSignOk = true\n\t\tdefault:\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: unsupported signing key type (%T)\", priv.Public())\n\t\t}\n\t}\n\tif priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok {\n\t\tswitch priv.Public().(type) {\n\t\tcase *rsa.PublicKey:\n\t\t\ths.rsaDecryptOk = true\n\t\tdefault:\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: unsupported decryption key type (%T)\", priv.Public())\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// negotiateALPN picks a shared ALPN protocol that both sides support in server\n// preference order. If ALPN is not configured or the peer doesn't support it,\n// it returns \"\" and no error.\nfunc negotiateALPN(serverProtos, clientProtos []string, quic bool) (string, error) {\n\tif len(serverProtos) == 0 || len(clientProtos) == 0 {\n\t\tif quic && len(serverProtos) != 0 {\n\t\t\t// RFC 9001, Section 8.1\n\t\t\treturn \"\", fmt.Errorf(\"tls: client did not request an application protocol\")\n\t\t}\n\t\treturn \"\", nil\n\t}\n\tvar http11fallback bool\n\tfor _, s := range serverProtos {\n\t\tfor _, c := range clientProtos {\n\t\t\tif s == c {\n\t\t\t\treturn s, nil\n\t\t\t}\n\t\t\tif s == \"h2\" && c == \"http/1.1\" {\n\t\t\t\thttp11fallback = true\n\t\t\t}\n\t\t}\n\t}\n\t// As a special case, let http/1.1 clients connect to h2 servers as if they\n\t// didn't support ALPN. We used not to enforce protocol overlap, so over\n\t// time a number of HTTP servers were configured with only \"h2\", but\n\t// expected to accept connections from \"http/1.1\" clients. See Issue 46310.\n\tif http11fallback {\n\t\treturn \"\", nil\n\t}\n\treturn \"\", fmt.Errorf(\"tls: client requested unsupported application protocols (%s)\", clientProtos)\n}\n\n// supportsECDHE returns whether ECDHE key exchanges can be used with this\n// pre-TLS 1.3 client.\nfunc supportsECDHE(c *Config, supportedCurves []CurveID, supportedPoints []uint8) bool {\n\tsupportsCurve := false\n\tfor _, curve := range supportedCurves {\n\t\tif c.supportsCurve(curve) {\n\t\t\tsupportsCurve = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tsupportsPointFormat := false\n\tfor _, pointFormat := range supportedPoints {\n\t\tif pointFormat == pointFormatUncompressed {\n\t\t\tsupportsPointFormat = true\n\t\t\tbreak\n\t\t}\n\t}\n\t// Per RFC 8422, Section 5.1.2, if the Supported Point Formats extension is\n\t// missing, uncompressed points are supported. If supportedPoints is empty,\n\t// the extension must be missing, as an empty extension body is rejected by\n\t// the parser. See https://go.dev/issue/49126.\n\tif len(supportedPoints) == 0 {\n\t\tsupportsPointFormat = true\n\t}\n\n\treturn supportsCurve && supportsPointFormat\n}\n\nfunc (hs *serverHandshakeState) pickCipherSuite() error {\n\tc := hs.c\n\n\tpreferenceOrder := cipherSuitesPreferenceOrder\n\tif !hasAESGCMHardwareSupport || !aesgcmPreferred(hs.clientHello.cipherSuites) {\n\t\tpreferenceOrder = cipherSuitesPreferenceOrderNoAES\n\t}\n\n\tconfigCipherSuites := c.config.cipherSuites()\n\tpreferenceList := make([]uint16, 0, len(configCipherSuites))\n\tfor _, suiteID := range preferenceOrder {\n\t\tfor _, id := range configCipherSuites {\n\t\t\tif id == suiteID {\n\t\t\t\tpreferenceList = append(preferenceList, id)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\ths.suite = selectCipherSuite(preferenceList, hs.clientHello.cipherSuites, hs.cipherSuiteOk)\n\tif hs.suite == nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: no cipher suite supported by both client and server\")\n\t}\n\tc.cipherSuite = hs.suite.id\n\n\tfor _, id := range hs.clientHello.cipherSuites {\n\t\tif id == TLS_FALLBACK_SCSV {\n\t\t\t// The client is doing a fallback connection. See RFC 7507.\n\t\t\tif hs.clientHello.vers < c.config.maxSupportedVersion(roleServer) {\n\t\t\t\tc.sendAlert(alertInappropriateFallback)\n\t\t\t\treturn errors.New(\"tls: client using inappropriate protocol fallback\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) cipherSuiteOk(c *cipherSuite) bool {\n\tif c.flags&suiteECDHE != 0 {\n\t\tif !hs.ecdheOk {\n\t\t\treturn false\n\t\t}\n\t\tif c.flags&suiteECSign != 0 {\n\t\t\tif !hs.ecSignOk {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if !hs.rsaSignOk {\n\t\t\treturn false\n\t\t}\n\t} else if !hs.rsaDecryptOk {\n\t\treturn false\n\t}\n\tif hs.c.vers < VersionTLS12 && c.flags&suiteTLS12 != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// checkForResumption reports whether we should perform resumption on this connection.\nfunc (hs *serverHandshakeState) checkForResumption() error {\n\tc := hs.c\n\n\tif c.config.SessionTicketsDisabled {\n\t\treturn nil\n\t}\n\n\tvar sessionState *SessionState\n\tif c.config.UnwrapSession != nil {\n\t\tss, err := c.config.UnwrapSession(hs.clientHello.sessionTicket, c.connectionStateLocked())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif ss == nil {\n\t\t\treturn nil\n\t\t}\n\t\tsessionState = ss\n\t} else {\n\t\tplaintext := c.config.decryptTicket(hs.clientHello.sessionTicket, c.ticketKeys)\n\t\tif plaintext == nil {\n\t\t\treturn nil\n\t\t}\n\t\tss, err := ParseSessionState(plaintext)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tsessionState = ss\n\t}\n\n\t// TLS 1.2 tickets don't natively have a lifetime, but we want to avoid\n\t// re-wrapping the same master secret in different tickets over and over for\n\t// too long, weakening forward secrecy.\n\tcreatedAt := time.Unix(int64(sessionState.createdAt), 0)\n\tif c.config.time().Sub(createdAt) > maxSessionTicketLifetime {\n\t\treturn nil\n\t}\n\n\t// Never resume a session for a different TLS version.\n\tif c.vers != sessionState.version {\n\t\treturn nil\n\t}\n\n\tcipherSuiteOk := false\n\t// Check that the client is still offering the ciphersuite in the session.\n\tfor _, id := range hs.clientHello.cipherSuites {\n\t\tif id == sessionState.cipherSuite {\n\t\t\tcipherSuiteOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !cipherSuiteOk {\n\t\treturn nil\n\t}\n\n\t// Check that we also support the ciphersuite from the session.\n\tsuite := selectCipherSuite([]uint16{sessionState.cipherSuite},\n\t\tc.config.cipherSuites(), hs.cipherSuiteOk)\n\tif suite == nil {\n\t\treturn nil\n\t}\n\n\tsessionHasClientCerts := len(sessionState.peerCertificates) != 0\n\tneedClientCerts := requiresClientCert(c.config.ClientAuth)\n\tif needClientCerts && !sessionHasClientCerts {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.ClientAuth == NoClientCert {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.time().After(sessionState.peerCertificates[0].NotAfter) {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.ClientAuth >= VerifyClientCertIfGiven &&\n\t\tlen(sessionState.verifiedChains) == 0 {\n\t\treturn nil\n\t}\n\n\t// RFC 7627, Section 5.3\n\tif !sessionState.extMasterSecret && hs.clientHello.extendedMasterSecret {\n\t\treturn nil\n\t}\n\tif sessionState.extMasterSecret && !hs.clientHello.extendedMasterSecret {\n\t\t// Aborting is somewhat harsh, but it's a MUST and it would indicate a\n\t\t// weird downgrade in client capabilities.\n\t\treturn errors.New(\"tls: session supported extended_master_secret but client does not\")\n\t}\n\n\tc.peerCertificates = sessionState.peerCertificates\n\tc.ocspResponse = sessionState.ocspResponse\n\tc.scts = sessionState.scts\n\tc.verifiedChains = sessionState.verifiedChains\n\tc.extMasterSecret = sessionState.extMasterSecret\n\ths.sessionState = sessionState\n\ths.suite = suite\n\tc.didResume = true\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) doResumeHandshake() error {\n\tc := hs.c\n\n\ths.hello.cipherSuite = hs.suite.id\n\tc.cipherSuite = hs.suite.id\n\t// We echo the client's session ID in the ServerHello to let it know\n\t// that we're doing a resumption.\n\ths.hello.sessionId = hs.clientHello.sessionId\n\t// We always send a new session ticket, even if it wraps the same master\n\t// secret and it's potentially encrypted with the same key, to help the\n\t// client avoid cross-connection tracking from a network observer.\n\ths.hello.ticketSupported = true\n\ths.finishedHash = newFinishedHash(c.vers, hs.suite)\n\ths.finishedHash.discardHandshakeBuffer()\n\tif err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.masterSecret = hs.sessionState.secret\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) doFullHandshake() error {\n\tc := hs.c\n\n\tif hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 {\n\t\ths.hello.ocspStapling = true\n\t}\n\n\ths.hello.ticketSupported = hs.clientHello.ticketSupported && !c.config.SessionTicketsDisabled\n\ths.hello.cipherSuite = hs.suite.id\n\n\ths.finishedHash = newFinishedHash(hs.c.vers, hs.suite)\n\tif c.config.ClientAuth == NoClientCert {\n\t\t// No need to keep a full record of the handshake if client\n\t\t// certificates won't be used.\n\t\ths.finishedHash.discardHandshakeBuffer()\n\t}\n\tif err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcertMsg := new(certificateMsg)\n\tcertMsg.certificates = hs.cert.Certificate\n\tif _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif hs.hello.ocspStapling {\n\t\tcertStatus := new(certificateStatusMsg)\n\t\tcertStatus.response = hs.cert.OCSPStaple\n\t\tif _, err := hs.c.writeHandshakeRecord(certStatus, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tkeyAgreement := hs.suite.ka(c.vers)\n\tskx, err := keyAgreement.generateServerKeyExchange(c.config, hs.cert, hs.clientHello, hs.hello)\n\tif err != nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\tif skx != nil {\n\t\tif _, err := hs.c.writeHandshakeRecord(skx, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar certReq *certificateRequestMsg\n\tif c.config.ClientAuth >= RequestClientCert {\n\t\t// Request a client certificate\n\t\tcertReq = new(certificateRequestMsg)\n\t\tcertReq.certificateTypes = []byte{\n\t\t\tbyte(certTypeRSASign),\n\t\t\tbyte(certTypeECDSASign),\n\t\t}\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tcertReq.hasSignatureAlgorithm = true\n\t\t\tcertReq.supportedSignatureAlgorithms = supportedSignatureAlgorithms()\n\t\t}\n\n\t\t// An empty list of certificateAuthorities signals to\n\t\t// the client that it may send any certificate in response\n\t\t// to our request. When we know the CAs we trust, then\n\t\t// we can send them down, so that the client can choose\n\t\t// an appropriate certificate to give to us.\n\t\tif c.config.ClientCAs != nil {\n\t\t\tcertReq.certificateAuthorities = c.config.ClientCAs.Subjects()\n\t\t}\n\t\tif _, err := hs.c.writeHandshakeRecord(certReq, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\thelloDone := new(serverHelloDoneMsg)\n\tif _, err := hs.c.writeHandshakeRecord(helloDone, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := c.flush(); err != nil {\n\t\treturn err\n\t}\n\n\tvar pub crypto.PublicKey // public key for client auth, if any\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If we requested a client certificate, then the client must send a\n\t// certificate message, even if it's empty.\n\tif c.config.ClientAuth >= RequestClientCert {\n\t\tcertMsg, ok := msg.(*certificateMsg)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn unexpectedMessageError(certMsg, msg)\n\t\t}\n\n\t\tif err := c.processCertsFromClient(Certificate{\n\t\t\tCertificate: certMsg.certificates,\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(certMsg.certificates) != 0 {\n\t\t\tpub = c.peerCertificates[0].PublicKey\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Get client key exchange\n\tckx, ok := msg.(*clientKeyExchangeMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(ckx, msg)\n\t}\n\n\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(c.config, hs.cert, ckx, c.vers)\n\tif err != nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\tif hs.hello.extendedMasterSecret {\n\t\tc.extMasterSecret = true\n\t\ths.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.finishedHash.Sum())\n\t} else {\n\t\ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.clientHello.random, hs.hello.random)\n\t}\n\tif err := c.config.writeKeyLog(keyLogLabelTLS12, hs.clientHello.random, hs.masterSecret); err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\t// If we received a client cert in response to our certificate request message,\n\t// the client will send us a certificateVerifyMsg immediately after the\n\t// clientKeyExchangeMsg. This message is a digest of all preceding\n\t// handshake-layer messages that is signed using the private key corresponding\n\t// to the client's certificate. This allows us to verify that the client is in\n\t// possession of the private key of the certificate.\n\tif len(c.peerCertificates) > 0 {\n\t\t// certificateVerifyMsg is included in the transcript, but not until\n\t\t// after we verify the handshake signature, since the state before\n\t\t// this message was sent is used.\n\t\tmsg, err = c.readHandshake(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcertVerify, ok := msg.(*certificateVerifyMsg)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn unexpectedMessageError(certVerify, msg)\n\t\t}\n\n\t\tvar sigType uint8\n\t\tvar sigHash crypto.Hash\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tif !isSupportedSignatureAlgorithm(certVerify.signatureAlgorithm, certReq.supportedSignatureAlgorithms) {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn errors.New(\"tls: client certificate used with invalid signature algorithm\")\n\t\t\t}\n\t\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(certVerify.signatureAlgorithm)\n\t\t\tif err != nil {\n\t\t\t\treturn c.sendAlert(alertInternalError)\n\t\t\t}\n\t\t} else {\n\t\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(pub)\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tsigned := hs.finishedHash.hashForClientCertificate(sigType, sigHash)\n\t\tif err := verifyHandshakeSignature(sigType, pub, sigHash, signed, certVerify.signature); err != nil {\n\t\t\tc.sendAlert(alertDecryptError)\n\t\t\treturn errors.New(\"tls: invalid signature by the client certificate: \" + err.Error())\n\t\t}\n\n\t\tif err := transcriptMsg(certVerify, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.finishedHash.discardHandshakeBuffer()\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) establishKeys() error {\n\tc := hs.c\n\n\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n\t\tkeysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n\n\tvar clientCipher, serverCipher any\n\tvar clientHash, serverHash hash.Hash\n\n\tif hs.suite.aead == nil {\n\t\tclientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)\n\t\tclientHash = hs.suite.mac(clientMAC)\n\t\tserverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)\n\t\tserverHash = hs.suite.mac(serverMAC)\n\t} else {\n\t\tclientCipher = hs.suite.aead(clientKey, clientIV)\n\t\tserverCipher = hs.suite.aead(serverKey, serverIV)\n\t}\n\n\tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n\tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) readFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.readChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\n\t// finishedMsg is included in the transcript, but not until after we\n\t// check the client version, since the state before this message was\n\t// sent is used during verification.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tclientFinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(clientFinished, msg)\n\t}\n\n\tverify := hs.finishedHash.clientSum(hs.masterSecret)\n\tif len(verify) != len(clientFinished.verifyData) ||\n\t\tsubtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: client's Finished message is incorrect\")\n\t}\n\n\tif err := transcriptMsg(clientFinished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, verify)\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) sendSessionTicket() error {\n\tif !hs.hello.ticketSupported {\n\t\treturn nil\n\t}\n\n\tc := hs.c\n\tm := new(newSessionTicketMsg)\n\n\tstate, err := c.sessionState()\n\tif err != nil {\n\t\treturn err\n\t}\n\tstate.secret = hs.masterSecret\n\tif hs.sessionState != nil {\n\t\t// If this is re-wrapping an old key, then keep\n\t\t// the original time it was created.\n\t\tstate.createdAt = hs.sessionState.createdAt\n\t}\n\tif c.config.WrapSession != nil {\n\t\tm.ticket, err = c.config.WrapSession(c.connectionStateLocked(), state)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tstateBytes, err := state.Bytes()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.ticket, err = c.config.encryptTicket(stateBytes, c.ticketKeys)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(m, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) sendFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.writeChangeCipherRecord(); err != nil {\n\t\treturn err\n\t}\n\n\tfinished := new(finishedMsg)\n\tfinished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)\n\tif _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, finished.verifyData)\n\n\treturn nil\n}\n\n// processCertsFromClient takes a chain of client certificates either from a\n// Certificates message and verifies them.\nfunc (c *Conn) processCertsFromClient(certificate Certificate) error {\n\tcertificates := certificate.Certificate\n\tcerts := make([]*x509.Certificate, len(certificates))\n\tvar err error\n\tfor i, asn1Data := range certificates {\n\t\tif certs[i], err = x509.ParseCertificate(asn1Data); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: failed to parse client certificate: \" + err.Error())\n\t\t}\n\t}\n\n\tif len(certs) == 0 && requiresClientCert(c.config.ClientAuth) {\n\t\tif c.vers == VersionTLS13 {\n\t\t\tc.sendAlert(alertCertificateRequired)\n\t\t} else {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t}\n\t\treturn errors.New(\"tls: client didn't provide a certificate\")\n\t}\n\n\tif c.config.ClientAuth >= VerifyClientCertIfGiven && len(certs) > 0 {\n\t\topts := x509.VerifyOptions{\n\t\t\tRoots:         c.config.ClientCAs,\n\t\t\tCurrentTime:   c.config.time(),\n\t\t\tIntermediates: x509.NewCertPool(),\n\t\t\tKeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},\n\t\t}\n\n\t\tfor _, cert := range certs[1:] {\n\t\t\topts.Intermediates.AddCert(cert)\n\t\t}\n\n\t\tchains, err := certs[0].Verify(opts)\n\t\tif err != nil {\n\t\t\tvar errCertificateInvalid x509.CertificateInvalidError\n\t\t\tif errors.As(err, &x509.UnknownAuthorityError{}) {\n\t\t\t\tc.sendAlert(alertUnknownCA)\n\t\t\t} else if errors.As(err, &errCertificateInvalid) && errCertificateInvalid.Reason == x509.Expired {\n\t\t\t\tc.sendAlert(alertCertificateExpired)\n\t\t\t} else {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t}\n\t\t\treturn &CertificateVerificationError{UnverifiedCertificates: certs, Err: err}\n\t\t}\n\n\t\tc.verifiedChains = chains\n\t}\n\n\tc.peerCertificates = certs\n\tc.ocspResponse = certificate.OCSPStaple\n\tc.scts = certificate.SignedCertificateTimestamps\n\n\tif len(certs) > 0 {\n\t\tswitch certs[0].PublicKey.(type) {\n\t\tcase *ecdsa.PublicKey, *rsa.PublicKey, ed25519.PublicKey:\n\t\tdefault:\n\t\t\tc.sendAlert(alertUnsupportedCertificate)\n\t\t\treturn fmt.Errorf(\"tls: client certificate contains an unsupported public key of type %T\", certs[0].PublicKey)\n\t\t}\n\t}\n\n\tif c.config.VerifyPeerCertificate != nil {\n\t\tif err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc clientHelloInfo(ctx context.Context, c *Conn, clientHello *clientHelloMsg) *ClientHelloInfo {\n\tsupportedVersions := clientHello.supportedVersions\n\tif len(clientHello.supportedVersions) == 0 {\n\t\tsupportedVersions = supportedVersionsFromMax(clientHello.vers)\n\t}\n\n\treturn &ClientHelloInfo{\n\t\tCipherSuites:      clientHello.cipherSuites,\n\t\tServerName:        clientHello.serverName,\n\t\tSupportedCurves:   clientHello.supportedCurves,\n\t\tSupportedPoints:   clientHello.supportedPoints,\n\t\tSignatureSchemes:  clientHello.supportedSignatureAlgorithms,\n\t\tSupportedProtos:   clientHello.alpnProtocols,\n\t\tSupportedVersions: supportedVersions,\n\t\tConn:              c.conn,\n\t\tconfig:            c.config,\n\t\tctx:               ctx,\n\t}\n}\n"], "fixing_code": ["// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage tls\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdh\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype clientHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tserverHello  *serverHelloMsg\n\thello        *clientHelloMsg\n\tsuite        *cipherSuite\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tsession      *SessionState // the session being resumed\n\tticket       []byte        // a fresh ticket received during this handshake\n}\n\nvar testingOnlyForceClientHelloSignatureAlgorithms []SignatureScheme\n\nfunc (c *Conn) makeClientHello() (*clientHelloMsg, *ecdh.PrivateKey, error) {\n\tconfig := c.config\n\tif len(config.ServerName) == 0 && !config.InsecureSkipVerify {\n\t\treturn nil, nil, errors.New(\"tls: either ServerName or InsecureSkipVerify must be specified in the tls.Config\")\n\t}\n\n\tnextProtosLength := 0\n\tfor _, proto := range config.NextProtos {\n\t\tif l := len(proto); l == 0 || l > 255 {\n\t\t\treturn nil, nil, errors.New(\"tls: invalid NextProtos value\")\n\t\t} else {\n\t\t\tnextProtosLength += 1 + l\n\t\t}\n\t}\n\tif nextProtosLength > 0xffff {\n\t\treturn nil, nil, errors.New(\"tls: NextProtos values too large\")\n\t}\n\n\tsupportedVersions := config.supportedVersions(roleClient)\n\tif len(supportedVersions) == 0 {\n\t\treturn nil, nil, errors.New(\"tls: no supported versions satisfy MinVersion and MaxVersion\")\n\t}\n\n\tclientHelloVersion := config.maxSupportedVersion(roleClient)\n\t// The version at the beginning of the ClientHello was capped at TLS 1.2\n\t// for compatibility reasons. The supported_versions extension is used\n\t// to negotiate versions now. See RFC 8446, Section 4.2.1.\n\tif clientHelloVersion > VersionTLS12 {\n\t\tclientHelloVersion = VersionTLS12\n\t}\n\n\thello := &clientHelloMsg{\n\t\tvers:                         clientHelloVersion,\n\t\tcompressionMethods:           []uint8{compressionNone},\n\t\trandom:                       make([]byte, 32),\n\t\textendedMasterSecret:         true,\n\t\tocspStapling:                 true,\n\t\tscts:                         true,\n\t\tserverName:                   hostnameInSNI(config.ServerName),\n\t\tsupportedCurves:              config.curvePreferences(),\n\t\tsupportedPoints:              []uint8{pointFormatUncompressed},\n\t\tsecureRenegotiationSupported: true,\n\t\talpnProtocols:                config.NextProtos,\n\t\tsupportedVersions:            supportedVersions,\n\t}\n\n\tif c.handshakes > 0 {\n\t\thello.secureRenegotiation = c.clientFinished[:]\n\t}\n\n\tpreferenceOrder := cipherSuitesPreferenceOrder\n\tif !hasAESGCMHardwareSupport {\n\t\tpreferenceOrder = cipherSuitesPreferenceOrderNoAES\n\t}\n\tconfigCipherSuites := config.cipherSuites()\n\thello.cipherSuites = make([]uint16, 0, len(configCipherSuites))\n\n\tfor _, suiteId := range preferenceOrder {\n\t\tsuite := mutualCipherSuite(configCipherSuites, suiteId)\n\t\tif suite == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Don't advertise TLS 1.2-only cipher suites unless\n\t\t// we're attempting TLS 1.2.\n\t\tif hello.vers < VersionTLS12 && suite.flags&suiteTLS12 != 0 {\n\t\t\tcontinue\n\t\t}\n\t\thello.cipherSuites = append(hello.cipherSuites, suiteId)\n\t}\n\n\t_, err := io.ReadFull(config.rand(), hello.random)\n\tif err != nil {\n\t\treturn nil, nil, errors.New(\"tls: short read from Rand: \" + err.Error())\n\t}\n\n\t// A random session ID is used to detect when the server accepted a ticket\n\t// and is resuming a session (see RFC 5077). In TLS 1.3, it's always set as\n\t// a compatibility measure (see RFC 8446, Section 4.1.2).\n\t//\n\t// The session ID is not set for QUIC connections (see RFC 9001, Section 8.4).\n\tif c.quic == nil {\n\t\thello.sessionId = make([]byte, 32)\n\t\tif _, err := io.ReadFull(config.rand(), hello.sessionId); err != nil {\n\t\t\treturn nil, nil, errors.New(\"tls: short read from Rand: \" + err.Error())\n\t\t}\n\t}\n\n\tif hello.vers >= VersionTLS12 {\n\t\thello.supportedSignatureAlgorithms = supportedSignatureAlgorithms()\n\t}\n\tif testingOnlyForceClientHelloSignatureAlgorithms != nil {\n\t\thello.supportedSignatureAlgorithms = testingOnlyForceClientHelloSignatureAlgorithms\n\t}\n\n\tvar key *ecdh.PrivateKey\n\tif hello.supportedVersions[0] == VersionTLS13 {\n\t\t// Reset the list of ciphers when the client only supports TLS 1.3.\n\t\tif len(hello.supportedVersions) == 1 {\n\t\t\thello.cipherSuites = nil\n\t\t}\n\t\tif hasAESGCMHardwareSupport {\n\t\t\thello.cipherSuites = append(hello.cipherSuites, defaultCipherSuitesTLS13...)\n\t\t} else {\n\t\t\thello.cipherSuites = append(hello.cipherSuites, defaultCipherSuitesTLS13NoAES...)\n\t\t}\n\n\t\tcurveID := config.curvePreferences()[0]\n\t\tif _, ok := curveForCurveID(curveID); !ok {\n\t\t\treturn nil, nil, errors.New(\"tls: CurvePreferences includes unsupported curve\")\n\t\t}\n\t\tkey, err = generateECDHEKey(config.rand(), curveID)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\thello.keyShares = []keyShare{{group: curveID, data: key.PublicKey().Bytes()}}\n\t}\n\n\tif c.quic != nil {\n\t\tp, err := c.quicGetTransportParameters()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif p == nil {\n\t\t\tp = []byte{}\n\t\t}\n\t\thello.quicTransportParameters = p\n\t}\n\n\treturn hello, key, nil\n}\n\nfunc (c *Conn) clientHandshake(ctx context.Context) (err error) {\n\tif c.config == nil {\n\t\tc.config = defaultConfig()\n\t}\n\n\t// This may be a renegotiation handshake, in which case some fields\n\t// need to be reset.\n\tc.didResume = false\n\n\thello, ecdheKey, err := c.makeClientHello()\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.serverName = hello.serverName\n\n\tsession, earlySecret, binderKey, err := c.loadSession(hello)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif session != nil {\n\t\tdefer func() {\n\t\t\t// If we got a handshake failure when resuming a session, throw away\n\t\t\t// the session ticket. See RFC 5077, Section 3.2.\n\t\t\t//\n\t\t\t// RFC 8446 makes no mention of dropping tickets on failure, but it\n\t\t\t// does require servers to abort on invalid binders, so we need to\n\t\t\t// delete tickets to recover from a corrupted PSK.\n\t\t\tif err != nil {\n\t\t\t\tif cacheKey := c.clientSessionCacheKey(); cacheKey != \"\" {\n\t\t\t\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tif _, err := c.writeHandshakeRecord(hello, nil); err != nil {\n\t\treturn err\n\t}\n\n\tif hello.earlyData {\n\t\tsuite := cipherSuiteTLS13ByID(session.cipherSuite)\n\t\ttranscript := suite.hash.New()\n\t\tif err := transcriptMsg(hello, transcript); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tearlyTrafficSecret := suite.deriveSecret(earlySecret, clientEarlyTrafficLabel, transcript)\n\t\tc.quicSetWriteSecret(QUICEncryptionLevelEarly, suite.id, earlyTrafficSecret)\n\t}\n\n\t// serverHelloMsg is not included in the transcript\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserverHello, ok := msg.(*serverHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(serverHello, msg)\n\t}\n\n\tif err := c.pickTLSVersion(serverHello); err != nil {\n\t\treturn err\n\t}\n\n\t// If we are negotiating a protocol version that's lower than what we\n\t// support, check for the server downgrade canaries.\n\t// See RFC 8446, Section 4.1.3.\n\tmaxVers := c.config.maxSupportedVersion(roleClient)\n\ttls12Downgrade := string(serverHello.random[24:]) == downgradeCanaryTLS12\n\ttls11Downgrade := string(serverHello.random[24:]) == downgradeCanaryTLS11\n\tif maxVers == VersionTLS13 && c.vers <= VersionTLS12 && (tls12Downgrade || tls11Downgrade) ||\n\t\tmaxVers == VersionTLS12 && c.vers <= VersionTLS11 && tls11Downgrade {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: downgrade attempt detected, possibly due to a MitM attack or a broken middlebox\")\n\t}\n\n\tif c.vers == VersionTLS13 {\n\t\ths := &clientHandshakeStateTLS13{\n\t\t\tc:           c,\n\t\t\tctx:         ctx,\n\t\t\tserverHello: serverHello,\n\t\t\thello:       hello,\n\t\t\tecdheKey:    ecdheKey,\n\t\t\tsession:     session,\n\t\t\tearlySecret: earlySecret,\n\t\t\tbinderKey:   binderKey,\n\t\t}\n\n\t\t// In TLS 1.3, session tickets are delivered after the handshake.\n\t\treturn hs.handshake()\n\t}\n\n\ths := &clientHandshakeState{\n\t\tc:           c,\n\t\tctx:         ctx,\n\t\tserverHello: serverHello,\n\t\thello:       hello,\n\t\tsession:     session,\n\t}\n\n\tif err := hs.handshake(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *Conn) loadSession(hello *clientHelloMsg) (\n\tsession *SessionState, earlySecret, binderKey []byte, err error) {\n\tif c.config.SessionTicketsDisabled || c.config.ClientSessionCache == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\thello.ticketSupported = true\n\n\tif hello.supportedVersions[0] == VersionTLS13 {\n\t\t// Require DHE on resumption as it guarantees forward secrecy against\n\t\t// compromise of the session ticket key. See RFC 8446, Section 4.2.9.\n\t\thello.pskModes = []uint8{pskModeDHE}\n\t}\n\n\t// Session resumption is not allowed if renegotiating because\n\t// renegotiation is primarily used to allow a client to send a client\n\t// certificate, which would be skipped if session resumption occurred.\n\tif c.handshakes != 0 {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// Try to resume a previously negotiated TLS session, if available.\n\tcacheKey := c.clientSessionCacheKey()\n\tif cacheKey == \"\" {\n\t\treturn nil, nil, nil, nil\n\t}\n\tcs, ok := c.config.ClientSessionCache.Get(cacheKey)\n\tif !ok || cs == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\tsession = cs.session\n\n\t// Check that version used for the previous session is still valid.\n\tversOk := false\n\tfor _, v := range hello.supportedVersions {\n\t\tif v == session.version {\n\t\t\tversOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !versOk {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// Check that the cached server certificate is not expired, and that it's\n\t// valid for the ServerName. This should be ensured by the cache key, but\n\t// protect the application from a faulty ClientSessionCache implementation.\n\tif c.config.time().After(session.peerCertificates[0].NotAfter) {\n\t\t// Expired certificate, delete the entry.\n\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\treturn nil, nil, nil, nil\n\t}\n\tif !c.config.InsecureSkipVerify {\n\t\tif len(session.verifiedChains) == 0 {\n\t\t\t// The original connection had InsecureSkipVerify, while this doesn't.\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\t\tif err := session.peerCertificates[0].VerifyHostname(c.config.ServerName); err != nil {\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\t}\n\n\tif session.version != VersionTLS13 {\n\t\t// In TLS 1.2 the cipher suite must match the resumed session. Ensure we\n\t\t// are still offering it.\n\t\tif mutualCipherSuite(hello.cipherSuites, session.cipherSuite) == nil {\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\n\t\thello.sessionTicket = cs.ticket\n\t\treturn\n\t}\n\n\t// Check that the session ticket is not expired.\n\tif c.config.time().After(time.Unix(int64(session.useBy), 0)) {\n\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// In TLS 1.3 the KDF hash must match the resumed session. Ensure we\n\t// offer at least one cipher suite with that hash.\n\tcipherSuite := cipherSuiteTLS13ByID(session.cipherSuite)\n\tif cipherSuite == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\tcipherSuiteOk := false\n\tfor _, offeredID := range hello.cipherSuites {\n\t\tofferedSuite := cipherSuiteTLS13ByID(offeredID)\n\t\tif offeredSuite != nil && offeredSuite.hash == cipherSuite.hash {\n\t\t\tcipherSuiteOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !cipherSuiteOk {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\tif c.quic != nil && session.EarlyData {\n\t\t// For 0-RTT, the cipher suite has to match exactly, and we need to be\n\t\t// offering the same ALPN.\n\t\tif mutualCipherSuiteTLS13(hello.cipherSuites, session.cipherSuite) != nil {\n\t\t\tfor _, alpn := range hello.alpnProtocols {\n\t\t\t\tif alpn == session.alpnProtocol {\n\t\t\t\t\thello.earlyData = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the pre_shared_key extension. See RFC 8446, Section 4.2.11.1.\n\tticketAge := c.config.time().Sub(time.Unix(int64(session.createdAt), 0))\n\tidentity := pskIdentity{\n\t\tlabel:               cs.ticket,\n\t\tobfuscatedTicketAge: uint32(ticketAge/time.Millisecond) + session.ageAdd,\n\t}\n\thello.pskIdentities = []pskIdentity{identity}\n\thello.pskBinders = [][]byte{make([]byte, cipherSuite.hash.Size())}\n\n\t// Compute the PSK binders. See RFC 8446, Section 4.2.11.2.\n\tearlySecret = cipherSuite.extract(session.secret, nil)\n\tbinderKey = cipherSuite.deriveSecret(earlySecret, resumptionBinderLabel, nil)\n\ttranscript := cipherSuite.hash.New()\n\thelloBytes, err := hello.marshalWithoutBinders()\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\ttranscript.Write(helloBytes)\n\tpskBinders := [][]byte{cipherSuite.finishedHash(binderKey, transcript)}\n\tif err := hello.updateBinders(pskBinders); err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\treturn\n}\n\nfunc (c *Conn) pickTLSVersion(serverHello *serverHelloMsg) error {\n\tpeerVersion := serverHello.vers\n\tif serverHello.supportedVersion != 0 {\n\t\tpeerVersion = serverHello.supportedVersion\n\t}\n\n\tvers, ok := c.config.mutualVersion(roleClient, []uint16{peerVersion})\n\tif !ok {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn fmt.Errorf(\"tls: server selected unsupported protocol version %x\", peerVersion)\n\t}\n\n\tc.vers = vers\n\tc.haveVers = true\n\tc.in.version = vers\n\tc.out.version = vers\n\n\treturn nil\n}\n\n// Does the handshake, either a full one or resumes old session. Requires hs.c,\n// hs.hello, hs.serverHello, and, optionally, hs.session to be set.\nfunc (hs *clientHandshakeState) handshake() error {\n\tc := hs.c\n\n\tisResume, err := hs.processServerHello()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ths.finishedHash = newFinishedHash(c.vers, hs.suite)\n\n\t// No signatures of the handshake are needed in a resumption.\n\t// Otherwise, in a full handshake, if we don't have any certificates\n\t// configured then we will never send a CertificateVerify message and\n\t// thus no signatures are needed in that case either.\n\tif isResume || (len(c.config.Certificates) == 0 && c.config.GetClientCertificate == nil) {\n\t\ths.finishedHash.discardHandshakeBuffer()\n\t}\n\n\tif err := transcriptMsg(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif err := transcriptMsg(hs.serverHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tc.buffering = true\n\tc.didResume = isResume\n\tif isResume {\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = false\n\t\t// Make sure the connection is still being verified whether or not this\n\t\t// is a resumption. Resumptions currently don't reverify certificates so\n\t\t// they don't call verifyServerCertificate. See Issue 31641.\n\t\tif c.config.VerifyConnection != nil {\n\t\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := hs.doFullHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = true\n\t\tif err := hs.readSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := hs.saveSessionTicket(); err != nil {\n\t\treturn err\n\t}\n\n\tc.ekm = ekmFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random)\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) pickCipherSuite() error {\n\tif hs.suite = mutualCipherSuite(hs.hello.cipherSuites, hs.serverHello.cipherSuite); hs.suite == nil {\n\t\ths.c.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: server chose an unconfigured cipher suite\")\n\t}\n\n\ths.c.cipherSuite = hs.suite.id\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) doFullHandshake() error {\n\tc := hs.c\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcertMsg, ok := msg.(*certificateMsg)\n\tif !ok || len(certMsg.certificates) == 0 {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(certMsg, msg)\n\t}\n\n\tmsg, err = c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcs, ok := msg.(*certificateStatusMsg)\n\tif ok {\n\t\t// RFC4366 on Certificate Status Request:\n\t\t// The server MAY return a \"certificate_status\" message.\n\n\t\tif !hs.serverHello.ocspStapling {\n\t\t\t// If a server returns a \"CertificateStatus\" message, then the\n\t\t\t// server MUST have included an extension of type \"status_request\"\n\t\t\t// with empty \"extension_data\" in the extended server hello.\n\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn errors.New(\"tls: received unexpected CertificateStatus message\")\n\t\t}\n\n\t\tc.ocspResponse = cs.response\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.handshakes == 0 {\n\t\t// If this is the first handshake on a connection, process and\n\t\t// (optionally) verify the server's certificates.\n\t\tif err := c.verifyServerCertificate(certMsg.certificates); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// This is a renegotiation handshake. We require that the\n\t\t// server's identity (i.e. leaf certificate) is unchanged and\n\t\t// thus any previous trust decision is still valid.\n\t\t//\n\t\t// See https://mitls.org/pages/attacks/3SHAKE for the\n\t\t// motivation behind this requirement.\n\t\tif !bytes.Equal(c.peerCertificates[0].Raw, certMsg.certificates[0]) {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: server's identity changed during renegotiation\")\n\t\t}\n\t}\n\n\tkeyAgreement := hs.suite.ka(c.vers)\n\n\tskx, ok := msg.(*serverKeyExchangeMsg)\n\tif ok {\n\t\terr = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, c.peerCertificates[0], skx)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn err\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar chainToSend *Certificate\n\tvar certRequested bool\n\tcertReq, ok := msg.(*certificateRequestMsg)\n\tif ok {\n\t\tcertRequested = true\n\n\t\tcri := certificateRequestInfoFromMsg(hs.ctx, c.vers, certReq)\n\t\tif chainToSend, err = c.getClientCertificate(cri); err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tshd, ok := msg.(*serverHelloDoneMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(shd, msg)\n\t}\n\n\t// If the server requested a certificate then we have to send a\n\t// Certificate message, even if it's empty because we don't have a\n\t// certificate to send.\n\tif certRequested {\n\t\tcertMsg = new(certificateMsg)\n\t\tcertMsg.certificates = chainToSend.Certificate\n\t\tif _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tpreMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, c.peerCertificates[0])\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\tif ckx != nil {\n\t\tif _, err := hs.c.writeHandshakeRecord(ckx, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hs.serverHello.extendedMasterSecret {\n\t\tc.extMasterSecret = true\n\t\ths.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.finishedHash.Sum())\n\t} else {\n\t\ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.hello.random, hs.serverHello.random)\n\t}\n\tif err := c.config.writeKeyLog(keyLogLabelTLS12, hs.hello.random, hs.masterSecret); err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn errors.New(\"tls: failed to write to key log: \" + err.Error())\n\t}\n\n\tif chainToSend != nil && len(chainToSend.Certificate) > 0 {\n\t\tcertVerify := &certificateVerifyMsg{}\n\n\t\tkey, ok := chainToSend.PrivateKey.(crypto.Signer)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: client certificate private key of type %T does not implement crypto.Signer\", chainToSend.PrivateKey)\n\t\t}\n\n\t\tvar sigType uint8\n\t\tvar sigHash crypto.Hash\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tsignatureAlgorithm, err := selectSignatureScheme(c.vers, chainToSend, certReq.supportedSignatureAlgorithms)\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(signatureAlgorithm)\n\t\t\tif err != nil {\n\t\t\t\treturn c.sendAlert(alertInternalError)\n\t\t\t}\n\t\t\tcertVerify.hasSignatureAlgorithm = true\n\t\t\tcertVerify.signatureAlgorithm = signatureAlgorithm\n\t\t} else {\n\t\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(key.Public())\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tsigned := hs.finishedHash.hashForClientCertificate(sigType, sigHash)\n\t\tsignOpts := crypto.SignerOpts(sigHash)\n\t\tif sigType == signatureRSAPSS {\n\t\t\tsignOpts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: sigHash}\n\t\t}\n\t\tcertVerify.signature, err = key.Sign(c.config.rand(), signed, signOpts)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := hs.c.writeHandshakeRecord(certVerify, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.finishedHash.discardHandshakeBuffer()\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) establishKeys() error {\n\tc := hs.c\n\n\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n\t\tkeysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n\tvar clientCipher, serverCipher any\n\tvar clientHash, serverHash hash.Hash\n\tif hs.suite.cipher != nil {\n\t\tclientCipher = hs.suite.cipher(clientKey, clientIV, false /* not for reading */)\n\t\tclientHash = hs.suite.mac(clientMAC)\n\t\tserverCipher = hs.suite.cipher(serverKey, serverIV, true /* for reading */)\n\t\tserverHash = hs.suite.mac(serverMAC)\n\t} else {\n\t\tclientCipher = hs.suite.aead(clientKey, clientIV)\n\t\tserverCipher = hs.suite.aead(serverKey, serverIV)\n\t}\n\n\tc.in.prepareCipherSpec(c.vers, serverCipher, serverHash)\n\tc.out.prepareCipherSpec(c.vers, clientCipher, clientHash)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) serverResumedSession() bool {\n\t// If the server responded with the same sessionId then it means the\n\t// sessionTicket is being used to resume a TLS session.\n\treturn hs.session != nil && hs.hello.sessionId != nil &&\n\t\tbytes.Equal(hs.serverHello.sessionId, hs.hello.sessionId)\n}\n\nfunc (hs *clientHandshakeState) processServerHello() (bool, error) {\n\tc := hs.c\n\n\tif err := hs.pickCipherSuite(); err != nil {\n\t\treturn false, err\n\t}\n\n\tif hs.serverHello.compressionMethod != compressionNone {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn false, errors.New(\"tls: server selected unsupported compression format\")\n\t}\n\n\tif c.handshakes == 0 && hs.serverHello.secureRenegotiationSupported {\n\t\tc.secureRenegotiation = true\n\t\tif len(hs.serverHello.secureRenegotiation) != 0 {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn false, errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n\t\t}\n\t}\n\n\tif c.handshakes > 0 && c.secureRenegotiation {\n\t\tvar expectedSecureRenegotiation [24]byte\n\t\tcopy(expectedSecureRenegotiation[:], c.clientFinished[:])\n\t\tcopy(expectedSecureRenegotiation[12:], c.serverFinished[:])\n\t\tif !bytes.Equal(hs.serverHello.secureRenegotiation, expectedSecureRenegotiation[:]) {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn false, errors.New(\"tls: incorrect renegotiation extension contents\")\n\t\t}\n\t}\n\n\tif err := checkALPN(hs.hello.alpnProtocols, hs.serverHello.alpnProtocol, false); err != nil {\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn false, err\n\t}\n\tc.clientProtocol = hs.serverHello.alpnProtocol\n\n\tc.scts = hs.serverHello.scts\n\n\tif !hs.serverResumedSession() {\n\t\treturn false, nil\n\t}\n\n\tif hs.session.version != c.vers {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different version\")\n\t}\n\n\tif hs.session.cipherSuite != hs.suite.id {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different cipher suite\")\n\t}\n\n\t// RFC 7627, Section 5.3\n\tif hs.session.extMasterSecret != hs.serverHello.extendedMasterSecret {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different EMS extension\")\n\t}\n\n\t// Restore master secret and certificates from previous state\n\ths.masterSecret = hs.session.secret\n\tc.extMasterSecret = hs.session.extMasterSecret\n\tc.peerCertificates = hs.session.peerCertificates\n\tc.activeCertHandles = hs.c.activeCertHandles\n\tc.verifiedChains = hs.session.verifiedChains\n\tc.ocspResponse = hs.session.ocspResponse\n\t// Let the ServerHello SCTs override the session SCTs from the original\n\t// connection, if any are provided\n\tif len(c.scts) == 0 && len(hs.session.scts) != 0 {\n\t\tc.scts = hs.session.scts\n\t}\n\n\treturn true, nil\n}\n\n// checkALPN ensure that the server's choice of ALPN protocol is compatible with\n// the protocols that we advertised in the Client Hello.\nfunc checkALPN(clientProtos []string, serverProto string, quic bool) error {\n\tif serverProto == \"\" {\n\t\tif quic && len(clientProtos) > 0 {\n\t\t\t// RFC 9001, Section 8.1\n\t\t\treturn errors.New(\"tls: server did not select an ALPN protocol\")\n\t\t}\n\t\treturn nil\n\t}\n\tif len(clientProtos) == 0 {\n\t\treturn errors.New(\"tls: server advertised unrequested ALPN extension\")\n\t}\n\tfor _, proto := range clientProtos {\n\t\tif proto == serverProto {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"tls: server selected unadvertised ALPN protocol\")\n}\n\nfunc (hs *clientHandshakeState) readFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.readChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\n\t// finishedMsg is included in the transcript, but not until after we\n\t// check the client version, since the state before this message was\n\t// sent is used during verification.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tserverFinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(serverFinished, msg)\n\t}\n\n\tverify := hs.finishedHash.serverSum(hs.masterSecret)\n\tif len(verify) != len(serverFinished.verifyData) ||\n\t\tsubtle.ConstantTimeCompare(verify, serverFinished.verifyData) != 1 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: server's Finished message was incorrect\")\n\t}\n\n\tif err := transcriptMsg(serverFinished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, verify)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) readSessionTicket() error {\n\tif !hs.serverHello.ticketSupported {\n\t\treturn nil\n\t}\n\tc := hs.c\n\n\tif !hs.hello.ticketSupported {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server sent unrequested session ticket\")\n\t}\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsessionTicketMsg, ok := msg.(*newSessionTicketMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(sessionTicketMsg, msg)\n\t}\n\n\ths.ticket = sessionTicketMsg.ticket\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) saveSessionTicket() error {\n\tif hs.ticket == nil {\n\t\treturn nil\n\t}\n\tc := hs.c\n\n\tcacheKey := c.clientSessionCacheKey()\n\tif cacheKey == \"\" {\n\t\treturn nil\n\t}\n\n\tsession, err := c.sessionState()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsession.secret = hs.masterSecret\n\n\tcs := &ClientSessionState{ticket: hs.ticket, session: session}\n\tc.config.ClientSessionCache.Put(cacheKey, cs)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) sendFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.writeChangeCipherRecord(); err != nil {\n\t\treturn err\n\t}\n\n\tfinished := new(finishedMsg)\n\tfinished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)\n\tif _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tcopy(out, finished.verifyData)\n\treturn nil\n}\n\n// maxRSAKeySize is the maximum RSA key size in bits that we are willing\n// to verify the signatures of during a TLS handshake.\nconst maxRSAKeySize = 8192\n\n// verifyServerCertificate parses and verifies the provided chain, setting\n// c.verifiedChains and c.peerCertificates or sending the appropriate alert.\nfunc (c *Conn) verifyServerCertificate(certificates [][]byte) error {\n\tactiveHandles := make([]*activeCert, len(certificates))\n\tcerts := make([]*x509.Certificate, len(certificates))\n\tfor i, asn1Data := range certificates {\n\t\tcert, err := globalCertCache.newCert(asn1Data)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: failed to parse certificate from server: \" + err.Error())\n\t\t}\n\t\tif cert.cert.PublicKeyAlgorithm == x509.RSA && cert.cert.PublicKey.(*rsa.PublicKey).N.BitLen() > maxRSAKeySize {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn fmt.Errorf(\"tls: server sent certificate containing RSA key larger than %d bits\", maxRSAKeySize)\n\t\t}\n\t\tactiveHandles[i] = cert\n\t\tcerts[i] = cert.cert\n\t}\n\n\tif !c.config.InsecureSkipVerify {\n\t\topts := x509.VerifyOptions{\n\t\t\tRoots:         c.config.RootCAs,\n\t\t\tCurrentTime:   c.config.time(),\n\t\t\tDNSName:       c.config.ServerName,\n\t\t\tIntermediates: x509.NewCertPool(),\n\t\t}\n\n\t\tfor _, cert := range certs[1:] {\n\t\t\topts.Intermediates.AddCert(cert)\n\t\t}\n\t\tvar err error\n\t\tc.verifiedChains, err = certs[0].Verify(opts)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn &CertificateVerificationError{UnverifiedCertificates: certs, Err: err}\n\t\t}\n\t}\n\n\tswitch certs[0].PublicKey.(type) {\n\tcase *rsa.PublicKey, *ecdsa.PublicKey, ed25519.PublicKey:\n\t\tbreak\n\tdefault:\n\t\tc.sendAlert(alertUnsupportedCertificate)\n\t\treturn fmt.Errorf(\"tls: server's certificate contains an unsupported type of public key: %T\", certs[0].PublicKey)\n\t}\n\n\tc.activeCertHandles = activeHandles\n\tc.peerCertificates = certs\n\n\tif c.config.VerifyPeerCertificate != nil {\n\t\tif err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// certificateRequestInfoFromMsg generates a CertificateRequestInfo from a TLS\n// <= 1.2 CertificateRequest, making an effort to fill in missing information.\nfunc certificateRequestInfoFromMsg(ctx context.Context, vers uint16, certReq *certificateRequestMsg) *CertificateRequestInfo {\n\tcri := &CertificateRequestInfo{\n\t\tAcceptableCAs: certReq.certificateAuthorities,\n\t\tVersion:       vers,\n\t\tctx:           ctx,\n\t}\n\n\tvar rsaAvail, ecAvail bool\n\tfor _, certType := range certReq.certificateTypes {\n\t\tswitch certType {\n\t\tcase certTypeRSASign:\n\t\t\trsaAvail = true\n\t\tcase certTypeECDSASign:\n\t\t\tecAvail = true\n\t\t}\n\t}\n\n\tif !certReq.hasSignatureAlgorithm {\n\t\t// Prior to TLS 1.2, signature schemes did not exist. In this case we\n\t\t// make up a list based on the acceptable certificate types, to help\n\t\t// GetClientCertificate and SupportsCertificate select the right certificate.\n\t\t// The hash part of the SignatureScheme is a lie here, because\n\t\t// TLS 1.0 and 1.1 always use MD5+SHA1 for RSA and SHA1 for ECDSA.\n\t\tswitch {\n\t\tcase rsaAvail && ecAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512,\n\t\t\t\tPKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512, PKCS1WithSHA1,\n\t\t\t}\n\t\tcase rsaAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tPKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512, PKCS1WithSHA1,\n\t\t\t}\n\t\tcase ecAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512,\n\t\t\t}\n\t\t}\n\t\treturn cri\n\t}\n\n\t// Filter the signature schemes based on the certificate types.\n\t// See RFC 5246, Section 7.4.4 (where it calls this \"somewhat complicated\").\n\tcri.SignatureSchemes = make([]SignatureScheme, 0, len(certReq.supportedSignatureAlgorithms))\n\tfor _, sigScheme := range certReq.supportedSignatureAlgorithms {\n\t\tsigType, _, err := typeAndHashFromSignatureScheme(sigScheme)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tswitch sigType {\n\t\tcase signatureECDSA, signatureEd25519:\n\t\t\tif ecAvail {\n\t\t\t\tcri.SignatureSchemes = append(cri.SignatureSchemes, sigScheme)\n\t\t\t}\n\t\tcase signatureRSAPSS, signaturePKCS1v15:\n\t\t\tif rsaAvail {\n\t\t\t\tcri.SignatureSchemes = append(cri.SignatureSchemes, sigScheme)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cri\n}\n\nfunc (c *Conn) getClientCertificate(cri *CertificateRequestInfo) (*Certificate, error) {\n\tif c.config.GetClientCertificate != nil {\n\t\treturn c.config.GetClientCertificate(cri)\n\t}\n\n\tfor _, chain := range c.config.Certificates {\n\t\tif err := cri.SupportsCertificate(&chain); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\treturn &chain, nil\n\t}\n\n\t// No acceptable certificate found. Don't send a certificate.\n\treturn new(Certificate), nil\n}\n\n// clientSessionCacheKey returns a key used to cache sessionTickets that could\n// be used to resume previously negotiated TLS sessions with a server.\nfunc (c *Conn) clientSessionCacheKey() string {\n\tif len(c.config.ServerName) > 0 {\n\t\treturn c.config.ServerName\n\t}\n\tif c.conn != nil {\n\t\treturn c.conn.RemoteAddr().String()\n\t}\n\treturn \"\"\n}\n\n// hostnameInSNI converts name into an appropriate hostname for SNI.\n// Literal IP addresses and absolute FQDNs are not permitted as SNI values.\n// See RFC 6066, Section 3.\nfunc hostnameInSNI(name string) string {\n\thost := name\n\tif len(host) > 0 && host[0] == '[' && host[len(host)-1] == ']' {\n\t\thost = host[1 : len(host)-1]\n\t}\n\tif i := strings.LastIndex(host, \"%\"); i > 0 {\n\t\thost = host[:i]\n\t}\n\tif net.ParseIP(host) != nil {\n\t\treturn \"\"\n\t}\n\tfor len(name) > 0 && name[len(name)-1] == '.' {\n\t\tname = name[:len(name)-1]\n\t}\n\treturn name\n}\n", "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage tls\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\n// Note: see comment in handshake_test.go for details of how the reference\n// tests work.\n\n// opensslInputEvent enumerates possible inputs that can be sent to an `openssl\n// s_client` process.\ntype opensslInputEvent int\n\nconst (\n\t// opensslRenegotiate causes OpenSSL to request a renegotiation of the\n\t// connection.\n\topensslRenegotiate opensslInputEvent = iota\n\n\t// opensslSendBanner causes OpenSSL to send the contents of\n\t// opensslSentinel on the connection.\n\topensslSendSentinel\n\n\t// opensslKeyUpdate causes OpenSSL to send a key update message to the\n\t// client and request one back.\n\topensslKeyUpdate\n)\n\nconst opensslSentinel = \"SENTINEL\\n\"\n\ntype opensslInput chan opensslInputEvent\n\nfunc (i opensslInput) Read(buf []byte) (n int, err error) {\n\tfor event := range i {\n\t\tswitch event {\n\t\tcase opensslRenegotiate:\n\t\t\treturn copy(buf, []byte(\"R\\n\")), nil\n\t\tcase opensslKeyUpdate:\n\t\t\treturn copy(buf, []byte(\"K\\n\")), nil\n\t\tcase opensslSendSentinel:\n\t\t\treturn copy(buf, []byte(opensslSentinel)), nil\n\t\tdefault:\n\t\t\tpanic(\"unknown event\")\n\t\t}\n\t}\n\n\treturn 0, io.EOF\n}\n\n// opensslOutputSink is an io.Writer that receives the stdout and stderr from an\n// `openssl` process and sends a value to handshakeComplete or readKeyUpdate\n// when certain messages are seen.\ntype opensslOutputSink struct {\n\thandshakeComplete chan struct{}\n\treadKeyUpdate     chan struct{}\n\tall               []byte\n\tline              []byte\n}\n\nfunc newOpensslOutputSink() *opensslOutputSink {\n\treturn &opensslOutputSink{make(chan struct{}), make(chan struct{}), nil, nil}\n}\n\n// opensslEndOfHandshake is a message that the \u201copenssl s_server\u201d tool will\n// print when a handshake completes if run with \u201c-state\u201d.\nconst opensslEndOfHandshake = \"SSL_accept:SSLv3/TLS write finished\"\n\n// opensslReadKeyUpdate is a message that the \u201copenssl s_server\u201d tool will\n// print when a KeyUpdate message is received if run with \u201c-state\u201d.\nconst opensslReadKeyUpdate = \"SSL_accept:TLSv1.3 read client key update\"\n\nfunc (o *opensslOutputSink) Write(data []byte) (n int, err error) {\n\to.line = append(o.line, data...)\n\to.all = append(o.all, data...)\n\n\tfor {\n\t\tline, next, ok := bytes.Cut(o.line, []byte(\"\\n\"))\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\n\t\tif bytes.Equal([]byte(opensslEndOfHandshake), line) {\n\t\t\to.handshakeComplete <- struct{}{}\n\t\t}\n\t\tif bytes.Equal([]byte(opensslReadKeyUpdate), line) {\n\t\t\to.readKeyUpdate <- struct{}{}\n\t\t}\n\t\to.line = next\n\t}\n\n\treturn len(data), nil\n}\n\nfunc (o *opensslOutputSink) String() string {\n\treturn string(o.all)\n}\n\n// clientTest represents a test of the TLS client handshake against a reference\n// implementation.\ntype clientTest struct {\n\t// name is a freeform string identifying the test and the file in which\n\t// the expected results will be stored.\n\tname string\n\t// args, if not empty, contains a series of arguments for the\n\t// command to run for the reference server.\n\targs []string\n\t// config, if not nil, contains a custom Config to use for this test.\n\tconfig *Config\n\t// cert, if not empty, contains a DER-encoded certificate for the\n\t// reference server.\n\tcert []byte\n\t// key, if not nil, contains either a *rsa.PrivateKey, ed25519.PrivateKey or\n\t// *ecdsa.PrivateKey which is the private key for the reference server.\n\tkey any\n\t// extensions, if not nil, contains a list of extension data to be returned\n\t// from the ServerHello. The data should be in standard TLS format with\n\t// a 2-byte uint16 type, 2-byte data length, followed by the extension data.\n\textensions [][]byte\n\t// validate, if not nil, is a function that will be called with the\n\t// ConnectionState of the resulting connection. It returns a non-nil\n\t// error if the ConnectionState is unacceptable.\n\tvalidate func(ConnectionState) error\n\t// numRenegotiations is the number of times that the connection will be\n\t// renegotiated.\n\tnumRenegotiations int\n\t// renegotiationExpectedToFail, if not zero, is the number of the\n\t// renegotiation attempt that is expected to fail.\n\trenegotiationExpectedToFail int\n\t// checkRenegotiationError, if not nil, is called with any error\n\t// arising from renegotiation. It can map expected errors to nil to\n\t// ignore them.\n\tcheckRenegotiationError func(renegotiationNum int, err error) error\n\t// sendKeyUpdate will cause the server to send a KeyUpdate message.\n\tsendKeyUpdate bool\n}\n\nvar serverCommand = []string{\"openssl\", \"s_server\", \"-no_ticket\", \"-num_tickets\", \"0\"}\n\n// connFromCommand starts the reference server process, connects to it and\n// returns a recordingConn for the connection. The stdin return value is an\n// opensslInput for the stdin of the child process. It must be closed before\n// Waiting for child.\nfunc (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, stdin opensslInput, stdout *opensslOutputSink, err error) {\n\tcert := testRSACertificate\n\tif len(test.cert) > 0 {\n\t\tcert = test.cert\n\t}\n\tcertPath := tempFile(string(cert))\n\tdefer os.Remove(certPath)\n\n\tvar key any = testRSAPrivateKey\n\tif test.key != nil {\n\t\tkey = test.key\n\t}\n\tderBytes, err := x509.MarshalPKCS8PrivateKey(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar pemOut bytes.Buffer\n\tpem.Encode(&pemOut, &pem.Block{Type: \"PRIVATE KEY\", Bytes: derBytes})\n\n\tkeyPath := tempFile(pemOut.String())\n\tdefer os.Remove(keyPath)\n\n\tvar command []string\n\tcommand = append(command, serverCommand...)\n\tcommand = append(command, test.args...)\n\tcommand = append(command, \"-cert\", certPath, \"-certform\", \"DER\", \"-key\", keyPath)\n\t// serverPort contains the port that OpenSSL will listen on. OpenSSL\n\t// can't take \"0\" as an argument here so we have to pick a number and\n\t// hope that it's not in use on the machine. Since this only occurs\n\t// when -update is given and thus when there's a human watching the\n\t// test, this isn't too bad.\n\tconst serverPort = 24323\n\tcommand = append(command, \"-accept\", strconv.Itoa(serverPort))\n\n\tif len(test.extensions) > 0 {\n\t\tvar serverInfo bytes.Buffer\n\t\tfor _, ext := range test.extensions {\n\t\t\tpem.Encode(&serverInfo, &pem.Block{\n\t\t\t\tType:  fmt.Sprintf(\"SERVERINFO FOR EXTENSION %d\", binary.BigEndian.Uint16(ext)),\n\t\t\t\tBytes: ext,\n\t\t\t})\n\t\t}\n\t\tserverInfoPath := tempFile(serverInfo.String())\n\t\tdefer os.Remove(serverInfoPath)\n\t\tcommand = append(command, \"-serverinfo\", serverInfoPath)\n\t}\n\n\tif test.numRenegotiations > 0 || test.sendKeyUpdate {\n\t\tfound := false\n\t\tfor _, flag := range command[1:] {\n\t\t\tif flag == \"-state\" {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\tpanic(\"-state flag missing to OpenSSL, you need this if testing renegotiation or KeyUpdate\")\n\t\t}\n\t}\n\n\tcmd := exec.Command(command[0], command[1:]...)\n\tstdin = opensslInput(make(chan opensslInputEvent))\n\tcmd.Stdin = stdin\n\tout := newOpensslOutputSink()\n\tcmd.Stdout = out\n\tcmd.Stderr = out\n\tif err := cmd.Start(); err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\t// OpenSSL does print an \"ACCEPT\" banner, but it does so *before*\n\t// opening the listening socket, so we can't use that to wait until it\n\t// has started listening. Thus we are forced to poll until we get a\n\t// connection.\n\tvar tcpConn net.Conn\n\tfor i := uint(0); i < 5; i++ {\n\t\ttcpConn, err = net.DialTCP(\"tcp\", nil, &net.TCPAddr{\n\t\t\tIP:   net.IPv4(127, 0, 0, 1),\n\t\t\tPort: serverPort,\n\t\t})\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep((1 << i) * 5 * time.Millisecond)\n\t}\n\tif err != nil {\n\t\tclose(stdin)\n\t\tcmd.Process.Kill()\n\t\terr = fmt.Errorf(\"error connecting to the OpenSSL server: %v (%v)\\n\\n%s\", err, cmd.Wait(), out)\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\trecord := &recordingConn{\n\t\tConn: tcpConn,\n\t}\n\n\treturn record, cmd, stdin, out, nil\n}\n\nfunc (test *clientTest) dataPath() string {\n\treturn filepath.Join(\"testdata\", \"Client-\"+test.name)\n}\n\nfunc (test *clientTest) loadData() (flows [][]byte, err error) {\n\tin, err := os.Open(test.dataPath())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer in.Close()\n\treturn parseTestData(in)\n}\n\nfunc (test *clientTest) run(t *testing.T, write bool) {\n\tvar clientConn, serverConn net.Conn\n\tvar recordingConn *recordingConn\n\tvar childProcess *exec.Cmd\n\tvar stdin opensslInput\n\tvar stdout *opensslOutputSink\n\n\tif write {\n\t\tvar err error\n\t\trecordingConn, childProcess, stdin, stdout, err = test.connFromCommand()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to start subcommand: %s\", err)\n\t\t}\n\t\tclientConn = recordingConn\n\t\tdefer func() {\n\t\t\tif t.Failed() {\n\t\t\t\tt.Logf(\"OpenSSL output:\\n\\n%s\", stdout.all)\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tclientConn, serverConn = localPipe(t)\n\t}\n\n\tdoneChan := make(chan bool)\n\tdefer func() {\n\t\tclientConn.Close()\n\t\t<-doneChan\n\t}()\n\tgo func() {\n\t\tdefer close(doneChan)\n\n\t\tconfig := test.config\n\t\tif config == nil {\n\t\t\tconfig = testConfig\n\t\t}\n\t\tclient := Client(clientConn, config)\n\t\tdefer client.Close()\n\n\t\tif _, err := client.Write([]byte(\"hello\\n\")); err != nil {\n\t\t\tt.Errorf(\"Client.Write failed: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 1; i <= test.numRenegotiations; i++ {\n\t\t\t// The initial handshake will generate a\n\t\t\t// handshakeComplete signal which needs to be quashed.\n\t\t\tif i == 1 && write {\n\t\t\t\t<-stdout.handshakeComplete\n\t\t\t}\n\n\t\t\t// OpenSSL will try to interleave application data and\n\t\t\t// a renegotiation if we send both concurrently.\n\t\t\t// Therefore: ask OpensSSL to start a renegotiation, run\n\t\t\t// a goroutine to call client.Read and thus process the\n\t\t\t// renegotiation request, watch for OpenSSL's stdout to\n\t\t\t// indicate that the handshake is complete and,\n\t\t\t// finally, have OpenSSL write something to cause\n\t\t\t// client.Read to complete.\n\t\t\tif write {\n\t\t\t\tstdin <- opensslRenegotiate\n\t\t\t}\n\n\t\t\tsignalChan := make(chan struct{})\n\n\t\t\tgo func() {\n\t\t\t\tdefer close(signalChan)\n\n\t\t\t\tbuf := make([]byte, 256)\n\t\t\t\tn, err := client.Read(buf)\n\n\t\t\t\tif test.checkRenegotiationError != nil {\n\t\t\t\t\tnewErr := test.checkRenegotiationError(i, err)\n\t\t\t\t\tif err != nil && newErr == nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\terr = newErr\n\t\t\t\t}\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Client.Read failed after renegotiation #%d: %s\", i, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tbuf = buf[:n]\n\t\t\t\tif !bytes.Equal([]byte(opensslSentinel), buf) {\n\t\t\t\t\tt.Errorf(\"Client.Read returned %q, but wanted %q\", string(buf), opensslSentinel)\n\t\t\t\t}\n\n\t\t\t\tif expected := i + 1; client.handshakes != expected {\n\t\t\t\t\tt.Errorf(\"client should have recorded %d handshakes, but believes that %d have occurred\", expected, client.handshakes)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif write && test.renegotiationExpectedToFail != i {\n\t\t\t\t<-stdout.handshakeComplete\n\t\t\t\tstdin <- opensslSendSentinel\n\t\t\t}\n\t\t\t<-signalChan\n\t\t}\n\n\t\tif test.sendKeyUpdate {\n\t\t\tif write {\n\t\t\t\t<-stdout.handshakeComplete\n\t\t\t\tstdin <- opensslKeyUpdate\n\t\t\t}\n\n\t\t\tdoneRead := make(chan struct{})\n\n\t\t\tgo func() {\n\t\t\t\tdefer close(doneRead)\n\n\t\t\t\tbuf := make([]byte, 256)\n\t\t\t\tn, err := client.Read(buf)\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Client.Read failed after KeyUpdate: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tbuf = buf[:n]\n\t\t\t\tif !bytes.Equal([]byte(opensslSentinel), buf) {\n\t\t\t\t\tt.Errorf(\"Client.Read returned %q, but wanted %q\", string(buf), opensslSentinel)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif write {\n\t\t\t\t// There's no real reason to wait for the client KeyUpdate to\n\t\t\t\t// send data with the new server keys, except that s_server\n\t\t\t\t// drops writes if they are sent at the wrong time.\n\t\t\t\t<-stdout.readKeyUpdate\n\t\t\t\tstdin <- opensslSendSentinel\n\t\t\t}\n\t\t\t<-doneRead\n\n\t\t\tif _, err := client.Write([]byte(\"hello again\\n\")); err != nil {\n\t\t\t\tt.Errorf(\"Client.Write failed: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif test.validate != nil {\n\t\t\tif err := test.validate(client.ConnectionState()); err != nil {\n\t\t\t\tt.Errorf(\"validate callback returned error: %s\", err)\n\t\t\t}\n\t\t}\n\n\t\t// If the server sent us an alert after our last flight, give it a\n\t\t// chance to arrive.\n\t\tif write && test.renegotiationExpectedToFail == 0 {\n\t\t\tif err := peekError(client); err != nil {\n\t\t\t\tt.Errorf(\"final Read returned an error: %s\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif !write {\n\t\tflows, err := test.loadData()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: failed to load data from %s: %v\", test.name, test.dataPath(), err)\n\t\t}\n\t\tfor i, b := range flows {\n\t\t\tif i%2 == 1 {\n\t\t\t\tif *fast {\n\t\t\t\t\tserverConn.SetWriteDeadline(time.Now().Add(1 * time.Second))\n\t\t\t\t} else {\n\t\t\t\t\tserverConn.SetWriteDeadline(time.Now().Add(1 * time.Minute))\n\t\t\t\t}\n\t\t\t\tserverConn.Write(b)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbb := make([]byte, len(b))\n\t\t\tif *fast {\n\t\t\t\tserverConn.SetReadDeadline(time.Now().Add(1 * time.Second))\n\t\t\t} else {\n\t\t\t\tserverConn.SetReadDeadline(time.Now().Add(1 * time.Minute))\n\t\t\t}\n\t\t\t_, err := io.ReadFull(serverConn, bb)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s, flow %d: %s\", test.name, i+1, err)\n\t\t\t}\n\t\t\tif !bytes.Equal(b, bb) {\n\t\t\t\tt.Fatalf(\"%s, flow %d: mismatch on read: got:%x want:%x\", test.name, i+1, bb, b)\n\t\t\t}\n\t\t}\n\t}\n\n\t<-doneChan\n\tif !write {\n\t\tserverConn.Close()\n\t}\n\n\tif write {\n\t\tpath := test.dataPath()\n\t\tout, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create output file: %s\", err)\n\t\t}\n\t\tdefer out.Close()\n\t\trecordingConn.Close()\n\t\tclose(stdin)\n\t\tchildProcess.Process.Kill()\n\t\tchildProcess.Wait()\n\t\tif len(recordingConn.flows) < 3 {\n\t\t\tt.Fatalf(\"Client connection didn't work\")\n\t\t}\n\t\trecordingConn.WriteTo(out)\n\t\tt.Logf(\"Wrote %s\\n\", path)\n\t}\n}\n\n// peekError does a read with a short timeout to check if the next read would\n// cause an error, for example if there is an alert waiting on the wire.\nfunc peekError(conn net.Conn) error {\n\tconn.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n\tif n, err := conn.Read(make([]byte, 1)); n != 0 {\n\t\treturn errors.New(\"unexpectedly read data\")\n\t} else if err != nil {\n\t\tif netErr, ok := err.(net.Error); !ok || !netErr.Timeout() {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc runClientTestForVersion(t *testing.T, template *clientTest, version, option string) {\n\t// Make a deep copy of the template before going parallel.\n\ttest := *template\n\tif template.config != nil {\n\t\ttest.config = template.config.Clone()\n\t}\n\ttest.name = version + \"-\" + test.name\n\ttest.args = append([]string{option}, test.args...)\n\n\trunTestAndUpdateIfNeeded(t, version, test.run, false)\n}\n\nfunc runClientTestTLS10(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv10\", \"-tls1\")\n}\n\nfunc runClientTestTLS11(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv11\", \"-tls1_1\")\n}\n\nfunc runClientTestTLS12(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv12\", \"-tls1_2\")\n}\n\nfunc runClientTestTLS13(t *testing.T, template *clientTest) {\n\trunClientTestForVersion(t, template, \"TLSv13\", \"-tls1_3\")\n}\n\nfunc TestHandshakeClientRSARC4(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"RSA-RC4\",\n\t\targs: []string{\"-cipher\", \"RC4-SHA\"},\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS11(t, test)\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientRSAAES128GCM(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES128-GCM-SHA256\",\n\t\targs: []string{\"-cipher\", \"AES128-GCM-SHA256\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientRSAAES256GCM(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES256-GCM-SHA384\",\n\t\targs: []string{\"-cipher\", \"AES256-GCM-SHA384\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHERSAAES(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-RSA-AES\",\n\t\targs: []string{\"-cipher\", \"ECDHE-RSA-AES128-SHA\"},\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS11(t, test)\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAAES(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS11(t, test)\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAAESGCM(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES-GCM\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES128-GCM-SHA256\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientAES256GCMSHA384(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES256-GCM-SHA384\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientAES128CBCSHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES128-SHA256\",\n\t\targs: []string{\"-cipher\", \"AES128-SHA256\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHERSAAES128CBCSHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-RSA-AES128-SHA256\",\n\t\targs: []string{\"-cipher\", \"ECDHE-RSA-AES128-SHA256\"},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAAES128CBCSHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDHE-ECDSA-AES128-SHA256\",\n\t\targs: []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA256\"},\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientX25519(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CurvePreferences = []CurveID{X25519}\n\n\ttest := &clientTest{\n\t\tname:   \"X25519-ECDHE\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\", \"-curves\", \"X25519\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientP256(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CurvePreferences = []CurveID{CurveP256}\n\n\ttest := &clientTest{\n\t\tname:   \"P256-ECDHE\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\", \"-curves\", \"P-256\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientHelloRetryRequest(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CurvePreferences = []CurveID{X25519, CurveP256}\n\n\ttest := &clientTest{\n\t\tname:   \"HelloRetryRequest\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\", \"-curves\", \"P-256\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientECDHERSAChaCha20(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305}\n\n\ttest := &clientTest{\n\t\tname:   \"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-CHACHA20-POLY1305\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientECDHEECDSAChaCha20(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.CipherSuites = []uint16{TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305}\n\n\ttest := &clientTest{\n\t\tname:   \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-ECDSA-CHACHA20-POLY1305\"},\n\t\tconfig: config,\n\t\tcert:   testECDSACertificate,\n\t\tkey:    testECDSAPrivateKey,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientAES128SHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES128-SHA256\",\n\t\targs: []string{\"-ciphersuites\", \"TLS_AES_128_GCM_SHA256\"},\n\t}\n\trunClientTestTLS13(t, test)\n}\nfunc TestHandshakeClientAES256SHA384(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"AES256-SHA384\",\n\t\targs: []string{\"-ciphersuites\", \"TLS_AES_256_GCM_SHA384\"},\n\t}\n\trunClientTestTLS13(t, test)\n}\nfunc TestHandshakeClientCHACHA20SHA256(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"CHACHA20-SHA256\",\n\t\targs: []string{\"-ciphersuites\", \"TLS_CHACHA20_POLY1305_SHA256\"},\n\t}\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientECDSATLS13(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"ECDSA\",\n\t\tcert: testECDSACertificate,\n\t\tkey:  testECDSAPrivateKey,\n\t}\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientEd25519(t *testing.T) {\n\ttest := &clientTest{\n\t\tname: \"Ed25519\",\n\t\tcert: testEd25519Certificate,\n\t\tkey:  testEd25519PrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientEd25519CertificatePEM), []byte(clientEd25519KeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-Ed25519\",\n\t\targs:   []string{\"-Verify\", \"1\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientCertRSA(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientCertificatePEM), []byte(clientKeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest := &clientTest{\n\t\tname:   \"ClientCert-RSA-RSA\",\n\t\targs:   []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-RSA-ECDSA\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t\tcert:   testECDSACertificate,\n\t\tkey:    testECDSAPrivateKey,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-RSA-AES256-GCM-SHA384\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-RSA-AES256-GCM-SHA384\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t\tcert:   testRSACertificate,\n\t\tkey:    testRSAPrivateKey,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientCertECDSA(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientECDSACertificatePEM), []byte(clientECDSAKeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest := &clientTest{\n\t\tname:   \"ClientCert-ECDSA-RSA\",\n\t\targs:   []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n\n\ttest = &clientTest{\n\t\tname:   \"ClientCert-ECDSA-ECDSA\",\n\t\targs:   []string{\"-cipher\", \"ECDHE-ECDSA-AES128-SHA\", \"-Verify\", \"1\"},\n\t\tconfig: config,\n\t\tcert:   testECDSACertificate,\n\t\tkey:    testECDSAPrivateKey,\n\t}\n\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n}\n\n// TestHandshakeClientCertRSAPSS tests rsa_pss_rsae_sha256 signatures from both\n// client and server certificates. It also serves from both sides a certificate\n// signed itself with RSA-PSS, mostly to check that crypto/x509 chain validation\n// works.\nfunc TestHandshakeClientCertRSAPSS(t *testing.T) {\n\tcert, err := x509.ParseCertificate(testRSAPSSCertificate)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trootCAs := x509.NewCertPool()\n\trootCAs.AddCert(cert)\n\n\tconfig := testConfig.Clone()\n\t// Use GetClientCertificate to bypass the client certificate selection logic.\n\tconfig.GetClientCertificate = func(*CertificateRequestInfo) (*Certificate, error) {\n\t\treturn &Certificate{\n\t\t\tCertificate: [][]byte{testRSAPSSCertificate},\n\t\t\tPrivateKey:  testRSAPrivateKey,\n\t\t}, nil\n\t}\n\tconfig.RootCAs = rootCAs\n\n\ttest := &clientTest{\n\t\tname: \"ClientCert-RSA-RSAPSS\",\n\t\targs: []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\", \"-client_sigalgs\",\n\t\t\t\"rsa_pss_rsae_sha256\", \"-sigalgs\", \"rsa_pss_rsae_sha256\"},\n\t\tconfig: config,\n\t\tcert:   testRSAPSSCertificate,\n\t\tkey:    testRSAPrivateKey,\n\t}\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestHandshakeClientCertRSAPKCS1v15(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tcert, _ := X509KeyPair([]byte(clientCertificatePEM), []byte(clientKeyPEM))\n\tconfig.Certificates = []Certificate{cert}\n\n\ttest := &clientTest{\n\t\tname: \"ClientCert-RSA-RSAPKCS1v15\",\n\t\targs: []string{\"-cipher\", \"AES128\", \"-Verify\", \"1\", \"-client_sigalgs\",\n\t\t\t\"rsa_pkcs1_sha256\", \"-sigalgs\", \"rsa_pkcs1_sha256\"},\n\t\tconfig: config,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestClientKeyUpdate(t *testing.T) {\n\ttest := &clientTest{\n\t\tname:          \"KeyUpdate\",\n\t\targs:          []string{\"-state\"},\n\t\tsendKeyUpdate: true,\n\t}\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestResumption(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testResumption(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testResumption(t, VersionTLS13) })\n}\n\nfunc testResumption(t *testing.T, version uint16) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping in -short mode\")\n\t}\n\tserverConfig := &Config{\n\t\tMaxVersion:   version,\n\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n\t\tCertificates: testConfig.Certificates,\n\t}\n\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\trootCAs := x509.NewCertPool()\n\trootCAs.AddCert(issuer)\n\n\tclientConfig := &Config{\n\t\tMaxVersion:         version,\n\t\tCipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n\t\tClientSessionCache: NewLRUClientSessionCache(32),\n\t\tRootCAs:            rootCAs,\n\t\tServerName:         \"example.golang\",\n\t}\n\n\ttestResumeState := func(test string, didResume bool) {\n\t\tt.Helper()\n\t\t_, hs, err := testHandshake(t, clientConfig, serverConfig)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: handshake failed: %s\", test, err)\n\t\t}\n\t\tif hs.DidResume != didResume {\n\t\t\tt.Fatalf(\"%s resumed: %v, expected: %v\", test, hs.DidResume, didResume)\n\t\t}\n\t\tif didResume && (hs.PeerCertificates == nil || hs.VerifiedChains == nil) {\n\t\t\tt.Fatalf(\"expected non-nil certificates after resumption. Got peerCertificates: %#v, verifiedCertificates: %#v\", hs.PeerCertificates, hs.VerifiedChains)\n\t\t}\n\t\tif got, want := hs.ServerName, clientConfig.ServerName; got != want {\n\t\t\tt.Errorf(\"%s: server name %s, want %s\", test, got, want)\n\t\t}\n\t}\n\n\tgetTicket := func() []byte {\n\t\treturn clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).state.ticket\n\t}\n\tdeleteTicket := func() {\n\t\tticketKey := clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).sessionKey\n\t\tclientConfig.ClientSessionCache.Put(ticketKey, nil)\n\t}\n\tcorruptTicket := func() {\n\t\tclientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).state.session.secret[0] ^= 0xff\n\t}\n\trandomKey := func() [32]byte {\n\t\tvar k [32]byte\n\t\tif _, err := io.ReadFull(serverConfig.rand(), k[:]); err != nil {\n\t\t\tt.Fatalf(\"Failed to read new SessionTicketKey: %s\", err)\n\t\t}\n\t\treturn k\n\t}\n\n\ttestResumeState(\"Handshake\", false)\n\tticket := getTicket()\n\ttestResumeState(\"Resume\", true)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"ticket didn't change after resumption\")\n\t}\n\n\t// An old session ticket is replaced with a ticket encrypted with a fresh key.\n\tticket = getTicket()\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*time.Hour + time.Minute) }\n\ttestResumeState(\"ResumeWithOldTicket\", true)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"old first ticket matches the fresh one\")\n\t}\n\n\t// Once the session master secret is expired, a full handshake should occur.\n\tticket = getTicket()\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*8*time.Hour + time.Minute) }\n\ttestResumeState(\"ResumeWithExpiredTicket\", false)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"expired first ticket matches the fresh one\")\n\t}\n\n\tserverConfig.Time = func() time.Time { return time.Now() } // reset the time back\n\tkey1 := randomKey()\n\tserverConfig.SetSessionTicketKeys([][32]byte{key1})\n\n\ttestResumeState(\"InvalidSessionTicketKey\", false)\n\ttestResumeState(\"ResumeAfterInvalidSessionTicketKey\", true)\n\n\tkey2 := randomKey()\n\tserverConfig.SetSessionTicketKeys([][32]byte{key2, key1})\n\tticket = getTicket()\n\ttestResumeState(\"KeyChange\", true)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"new ticket wasn't included while resuming\")\n\t}\n\ttestResumeState(\"KeyChangeFinish\", true)\n\n\t// Age the session ticket a bit, but not yet expired.\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*time.Hour + time.Minute) }\n\ttestResumeState(\"OldSessionTicket\", true)\n\tticket = getTicket()\n\t// Expire the session ticket, which would force a full handshake.\n\tserverConfig.Time = func() time.Time { return time.Now().Add(24*8*time.Hour + time.Minute) }\n\ttestResumeState(\"ExpiredSessionTicket\", false)\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"new ticket wasn't provided after old ticket expired\")\n\t}\n\n\t// Age the session ticket a bit at a time, but don't expire it.\n\td := 0 * time.Hour\n\tserverConfig.Time = func() time.Time { return time.Now().Add(d) }\n\tdeleteTicket()\n\ttestResumeState(\"GetFreshSessionTicket\", false)\n\tfor i := 0; i < 13; i++ {\n\t\td += 12 * time.Hour\n\t\ttestResumeState(\"OldSessionTicket\", true)\n\t}\n\t// Expire it (now a little more than 7 days) and make sure a full\n\t// handshake occurs for TLS 1.2. Resumption should still occur for\n\t// TLS 1.3 since the client should be using a fresh ticket sent over\n\t// by the server.\n\td += 12 * time.Hour\n\tif version == VersionTLS13 {\n\t\ttestResumeState(\"ExpiredSessionTicket\", true)\n\t} else {\n\t\ttestResumeState(\"ExpiredSessionTicket\", false)\n\t}\n\tif bytes.Equal(ticket, getTicket()) {\n\t\tt.Fatal(\"new ticket wasn't provided after old ticket expired\")\n\t}\n\n\t// Reset serverConfig to ensure that calling SetSessionTicketKeys\n\t// before the serverConfig is used works.\n\tserverConfig = &Config{\n\t\tMaxVersion:   version,\n\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n\t\tCertificates: testConfig.Certificates,\n\t}\n\tserverConfig.SetSessionTicketKeys([][32]byte{key2})\n\n\ttestResumeState(\"FreshConfig\", true)\n\n\t// In TLS 1.3, cross-cipher suite resumption is allowed as long as the KDF\n\t// hash matches. Also, Config.CipherSuites does not apply to TLS 1.3.\n\tif version != VersionTLS13 {\n\t\tclientConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}\n\t\ttestResumeState(\"DifferentCipherSuite\", false)\n\t\ttestResumeState(\"DifferentCipherSuiteRecovers\", true)\n\t}\n\n\tdeleteTicket()\n\ttestResumeState(\"WithoutSessionTicket\", false)\n\n\t// In TLS 1.3, HelloRetryRequest is sent after incorrect key share.\n\t// See https://www.rfc-editor.org/rfc/rfc8446#page-14.\n\tif version == VersionTLS13 {\n\t\tdeleteTicket()\n\t\tserverConfig = &Config{\n\t\t\t// Use a different curve than the client to force a HelloRetryRequest.\n\t\t\tCurvePreferences: []CurveID{CurveP521, CurveP384, CurveP256},\n\t\t\tMaxVersion:       version,\n\t\t\tCertificates:     testConfig.Certificates,\n\t\t}\n\t\ttestResumeState(\"InitialHandshake\", false)\n\t\ttestResumeState(\"WithHelloRetryRequest\", true)\n\n\t\t// Reset serverConfig back.\n\t\tserverConfig = &Config{\n\t\t\tMaxVersion:   version,\n\t\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n\t\t\tCertificates: testConfig.Certificates,\n\t\t}\n\t}\n\n\t// Session resumption should work when using client certificates\n\tdeleteTicket()\n\tserverConfig.ClientCAs = rootCAs\n\tserverConfig.ClientAuth = RequireAndVerifyClientCert\n\tclientConfig.Certificates = serverConfig.Certificates\n\ttestResumeState(\"InitialHandshake\", false)\n\ttestResumeState(\"WithClientCertificates\", true)\n\tserverConfig.ClientAuth = NoClientCert\n\n\t// Tickets should be removed from the session cache on TLS handshake\n\t// failure, and the client should recover from a corrupted PSK\n\ttestResumeState(\"FetchTicketToCorrupt\", false)\n\tcorruptTicket()\n\t_, _, err = testHandshake(t, clientConfig, serverConfig)\n\tif err == nil {\n\t\tt.Fatalf(\"handshake did not fail with a corrupted client secret\")\n\t}\n\ttestResumeState(\"AfterHandshakeFailure\", false)\n\n\tclientConfig.ClientSessionCache = nil\n\ttestResumeState(\"WithoutSessionCache\", false)\n\n\tclientConfig.ClientSessionCache = &serializingClientCache{t: t}\n\ttestResumeState(\"BeforeSerializingCache\", false)\n\ttestResumeState(\"WithSerializingCache\", true)\n}\n\ntype serializingClientCache struct {\n\tt *testing.T\n\n\tticket, state []byte\n}\n\nfunc (c *serializingClientCache) Get(sessionKey string) (session *ClientSessionState, ok bool) {\n\tif c.ticket == nil {\n\t\treturn nil, false\n\t}\n\tstate, err := ParseSessionState(c.state)\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn nil, false\n\t}\n\tcs, err := NewResumptionState(c.ticket, state)\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn nil, false\n\t}\n\treturn cs, true\n}\n\nfunc (c *serializingClientCache) Put(sessionKey string, cs *ClientSessionState) {\n\tticket, state, err := cs.ResumptionState()\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn\n\t}\n\tstateBytes, err := state.Bytes()\n\tif err != nil {\n\t\tc.t.Error(err)\n\t\treturn\n\t}\n\tc.ticket, c.state = ticket, stateBytes\n}\n\nfunc TestLRUClientSessionCache(t *testing.T) {\n\t// Initialize cache of capacity 4.\n\tcache := NewLRUClientSessionCache(4)\n\tcs := make([]ClientSessionState, 6)\n\tkeys := []string{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\"}\n\n\t// Add 4 entries to the cache and look them up.\n\tfor i := 0; i < 4; i++ {\n\t\tcache.Put(keys[i], &cs[i])\n\t}\n\tfor i := 0; i < 4; i++ {\n\t\tif s, ok := cache.Get(keys[i]); !ok || s != &cs[i] {\n\t\t\tt.Fatalf(\"session cache failed lookup for added key: %s\", keys[i])\n\t\t}\n\t}\n\n\t// Add 2 more entries to the cache. First 2 should be evicted.\n\tfor i := 4; i < 6; i++ {\n\t\tcache.Put(keys[i], &cs[i])\n\t}\n\tfor i := 0; i < 2; i++ {\n\t\tif s, ok := cache.Get(keys[i]); ok || s != nil {\n\t\t\tt.Fatalf(\"session cache should have evicted key: %s\", keys[i])\n\t\t}\n\t}\n\n\t// Touch entry 2. LRU should evict 3 next.\n\tcache.Get(keys[2])\n\tcache.Put(keys[0], &cs[0])\n\tif s, ok := cache.Get(keys[3]); ok || s != nil {\n\t\tt.Fatalf(\"session cache should have evicted key 3\")\n\t}\n\n\t// Update entry 0 in place.\n\tcache.Put(keys[0], &cs[3])\n\tif s, ok := cache.Get(keys[0]); !ok || s != &cs[3] {\n\t\tt.Fatalf(\"session cache failed update for key 0\")\n\t}\n\n\t// Calling Put with a nil entry deletes the key.\n\tcache.Put(keys[0], nil)\n\tif _, ok := cache.Get(keys[0]); ok {\n\t\tt.Fatalf(\"session cache failed to delete key 0\")\n\t}\n\n\t// Delete entry 2. LRU should keep 4 and 5\n\tcache.Put(keys[2], nil)\n\tif _, ok := cache.Get(keys[2]); ok {\n\t\tt.Fatalf(\"session cache failed to delete key 4\")\n\t}\n\tfor i := 4; i < 6; i++ {\n\t\tif s, ok := cache.Get(keys[i]); !ok || s != &cs[i] {\n\t\t\tt.Fatalf(\"session cache should not have deleted key: %s\", keys[i])\n\t\t}\n\t}\n}\n\nfunc TestKeyLogTLS12(t *testing.T) {\n\tvar serverBuf, clientBuf bytes.Buffer\n\n\tclientConfig := testConfig.Clone()\n\tclientConfig.KeyLogWriter = &clientBuf\n\tclientConfig.MaxVersion = VersionTLS12\n\n\tserverConfig := testConfig.Clone()\n\tserverConfig.KeyLogWriter = &serverBuf\n\tserverConfig.MaxVersion = VersionTLS12\n\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\tdefer close(done)\n\n\t\tif err := Server(s, serverConfig).Handshake(); err != nil {\n\t\t\tt.Errorf(\"server: %s\", err)\n\t\t\treturn\n\t\t}\n\t\ts.Close()\n\t}()\n\n\tif err := Client(c, clientConfig).Handshake(); err != nil {\n\t\tt.Fatalf(\"client: %s\", err)\n\t}\n\n\tc.Close()\n\t<-done\n\n\tcheckKeylogLine := func(side, loggedLine string) {\n\t\tif len(loggedLine) == 0 {\n\t\t\tt.Fatalf(\"%s: no keylog line was produced\", side)\n\t\t}\n\t\tconst expectedLen = 13 /* \"CLIENT_RANDOM\" */ +\n\t\t\t1 /* space */ +\n\t\t\t32*2 /* hex client nonce */ +\n\t\t\t1 /* space */ +\n\t\t\t48*2 /* hex master secret */ +\n\t\t\t1 /* new line */\n\t\tif len(loggedLine) != expectedLen {\n\t\t\tt.Fatalf(\"%s: keylog line has incorrect length (want %d, got %d): %q\", side, expectedLen, len(loggedLine), loggedLine)\n\t\t}\n\t\tif !strings.HasPrefix(loggedLine, \"CLIENT_RANDOM \"+strings.Repeat(\"0\", 64)+\" \") {\n\t\t\tt.Fatalf(\"%s: keylog line has incorrect structure or nonce: %q\", side, loggedLine)\n\t\t}\n\t}\n\n\tcheckKeylogLine(\"client\", clientBuf.String())\n\tcheckKeylogLine(\"server\", serverBuf.String())\n}\n\nfunc TestKeyLogTLS13(t *testing.T) {\n\tvar serverBuf, clientBuf bytes.Buffer\n\n\tclientConfig := testConfig.Clone()\n\tclientConfig.KeyLogWriter = &clientBuf\n\n\tserverConfig := testConfig.Clone()\n\tserverConfig.KeyLogWriter = &serverBuf\n\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\tdefer close(done)\n\n\t\tif err := Server(s, serverConfig).Handshake(); err != nil {\n\t\t\tt.Errorf(\"server: %s\", err)\n\t\t\treturn\n\t\t}\n\t\ts.Close()\n\t}()\n\n\tif err := Client(c, clientConfig).Handshake(); err != nil {\n\t\tt.Fatalf(\"client: %s\", err)\n\t}\n\n\tc.Close()\n\t<-done\n\n\tcheckKeylogLines := func(side, loggedLines string) {\n\t\tloggedLines = strings.TrimSpace(loggedLines)\n\t\tlines := strings.Split(loggedLines, \"\\n\")\n\t\tif len(lines) != 4 {\n\t\t\tt.Errorf(\"Expected the %s to log 4 lines, got %d\", side, len(lines))\n\t\t}\n\t}\n\n\tcheckKeylogLines(\"client\", clientBuf.String())\n\tcheckKeylogLines(\"server\", serverBuf.String())\n}\n\nfunc TestHandshakeClientALPNMatch(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.NextProtos = []string{\"proto2\", \"proto1\"}\n\n\ttest := &clientTest{\n\t\tname: \"ALPN\",\n\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n\t\t// version that supports the -alpn flag.\n\t\targs:   []string{\"-alpn\", \"proto1,proto2\"},\n\t\tconfig: config,\n\t\tvalidate: func(state ConnectionState) error {\n\t\t\t// The server's preferences should override the client.\n\t\t\tif state.NegotiatedProtocol != \"proto1\" {\n\t\t\t\treturn fmt.Errorf(\"Got protocol %q, wanted proto1\", state.NegotiatedProtocol)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nfunc TestServerSelectingUnconfiguredApplicationProtocol(t *testing.T) {\n\t// This checks that the server can't select an application protocol that the\n\t// client didn't offer.\n\n\tc, s := localPipe(t)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\tclient := Client(c, &Config{\n\t\t\tServerName:   \"foo\",\n\t\t\tCipherSuites: []uint16{TLS_RSA_WITH_AES_128_GCM_SHA256},\n\t\t\tNextProtos:   []string{\"http\", \"something-else\"},\n\t\t})\n\t\terrChan <- client.Handshake()\n\t}()\n\n\tvar header [5]byte\n\tif _, err := io.ReadFull(s, header[:]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\trecordLen := int(header[3])<<8 | int(header[4])\n\n\trecord := make([]byte, recordLen)\n\tif _, err := io.ReadFull(s, record); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tserverHello := &serverHelloMsg{\n\t\tvers:         VersionTLS12,\n\t\trandom:       make([]byte, 32),\n\t\tcipherSuite:  TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t\talpnProtocol: \"how-about-this\",\n\t}\n\tserverHelloBytes := mustMarshal(t, serverHello)\n\n\ts.Write([]byte{\n\t\tbyte(recordTypeHandshake),\n\t\tbyte(VersionTLS12 >> 8),\n\t\tbyte(VersionTLS12 & 0xff),\n\t\tbyte(len(serverHelloBytes) >> 8),\n\t\tbyte(len(serverHelloBytes)),\n\t})\n\ts.Write(serverHelloBytes)\n\ts.Close()\n\n\tif err := <-errChan; !strings.Contains(err.Error(), \"server selected unadvertised ALPN protocol\") {\n\t\tt.Fatalf(\"Expected error about unconfigured cipher suite but got %q\", err)\n\t}\n}\n\n// sctsBase64 contains data from `openssl s_client -serverinfo 18 -connect ritter.vg:443`\nconst sctsBase64 = \"ABIBaQFnAHUApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFHl5nuFgAABAMARjBEAiAcS4JdlW5nW9sElUv2zvQyPoZ6ejKrGGB03gjaBZFMLwIgc1Qbbn+hsH0RvObzhS+XZhr3iuQQJY8S9G85D9KeGPAAdgBo9pj4H2SCvjqM7rkoHUz8cVFdZ5PURNEKZ6y7T0/7xAAAAUeX4bVwAAAEAwBHMEUCIDIhFDgG2HIuADBkGuLobU5a4dlCHoJLliWJ1SYT05z6AiEAjxIoZFFPRNWMGGIjskOTMwXzQ1Wh2e7NxXE1kd1J0QsAdgDuS723dc5guuFCaR+r4Z5mow9+X7By2IMAxHuJeqj9ywAAAUhcZIqHAAAEAwBHMEUCICmJ1rBT09LpkbzxtUC+Hi7nXLR0J+2PmwLp+sJMuqK+AiEAr0NkUnEVKVhAkccIFpYDqHOlZaBsuEhWWrYpg2RtKp0=\"\n\nfunc TestHandshakClientSCTs(t *testing.T) {\n\tconfig := testConfig.Clone()\n\n\tscts, err := base64.StdEncoding.DecodeString(sctsBase64)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Note that this needs OpenSSL 1.0.2 because that is the first\n\t// version that supports the -serverinfo flag.\n\ttest := &clientTest{\n\t\tname:       \"SCT\",\n\t\tconfig:     config,\n\t\textensions: [][]byte{scts},\n\t\tvalidate: func(state ConnectionState) error {\n\t\t\texpectedSCTs := [][]byte{\n\t\t\t\tscts[8:125],\n\t\t\t\tscts[127:245],\n\t\t\t\tscts[247:],\n\t\t\t}\n\t\t\tif n := len(state.SignedCertificateTimestamps); n != len(expectedSCTs) {\n\t\t\t\treturn fmt.Errorf(\"Got %d scts, wanted %d\", n, len(expectedSCTs))\n\t\t\t}\n\t\t\tfor i, expected := range expectedSCTs {\n\t\t\t\tif sct := state.SignedCertificateTimestamps[i]; !bytes.Equal(sct, expected) {\n\t\t\t\t\treturn fmt.Errorf(\"SCT #%d contained %x, expected %x\", i, sct, expected)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS12(t, test)\n\n\t// TLS 1.3 moved SCTs to the Certificate extensions and -serverinfo only\n\t// supports ServerHello extensions.\n}\n\nfunc TestRenegotiationRejected(t *testing.T) {\n\tconfig := testConfig.Clone()\n\ttest := &clientTest{\n\t\tname:                        \"RenegotiationRejected\",\n\t\targs:                        []string{\"-state\"},\n\t\tconfig:                      config,\n\t\tnumRenegotiations:           1,\n\t\trenegotiationExpectedToFail: 1,\n\t\tcheckRenegotiationError: func(renegotiationNum int, err error) error {\n\t\t\tif err == nil {\n\t\t\t\treturn errors.New(\"expected error from renegotiation but got nil\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), \"no renegotiation\") {\n\t\t\t\treturn fmt.Errorf(\"expected renegotiation to be rejected but got %q\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestRenegotiateOnce(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.Renegotiation = RenegotiateOnceAsClient\n\n\ttest := &clientTest{\n\t\tname:              \"RenegotiateOnce\",\n\t\targs:              []string{\"-state\"},\n\t\tconfig:            config,\n\t\tnumRenegotiations: 1,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestRenegotiateTwice(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.Renegotiation = RenegotiateFreelyAsClient\n\n\ttest := &clientTest{\n\t\tname:              \"RenegotiateTwice\",\n\t\targs:              []string{\"-state\"},\n\t\tconfig:            config,\n\t\tnumRenegotiations: 2,\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestRenegotiateTwiceRejected(t *testing.T) {\n\tconfig := testConfig.Clone()\n\tconfig.Renegotiation = RenegotiateOnceAsClient\n\n\ttest := &clientTest{\n\t\tname:                        \"RenegotiateTwiceRejected\",\n\t\targs:                        []string{\"-state\"},\n\t\tconfig:                      config,\n\t\tnumRenegotiations:           2,\n\t\trenegotiationExpectedToFail: 2,\n\t\tcheckRenegotiationError: func(renegotiationNum int, err error) error {\n\t\t\tif renegotiationNum == 1 {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\treturn errors.New(\"expected error from renegotiation but got nil\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), \"no renegotiation\") {\n\t\t\t\treturn fmt.Errorf(\"expected renegotiation to be rejected but got %q\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\trunClientTestTLS12(t, test)\n}\n\nfunc TestHandshakeClientExportKeyingMaterial(t *testing.T) {\n\ttest := &clientTest{\n\t\tname:   \"ExportKeyingMaterial\",\n\t\tconfig: testConfig.Clone(),\n\t\tvalidate: func(state ConnectionState) error {\n\t\t\tif km, err := state.ExportKeyingMaterial(\"test\", nil, 42); err != nil {\n\t\t\t\treturn fmt.Errorf(\"ExportKeyingMaterial failed: %v\", err)\n\t\t\t} else if len(km) != 42 {\n\t\t\t\treturn fmt.Errorf(\"Got %d bytes from ExportKeyingMaterial, wanted %d\", len(km), 42)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\trunClientTestTLS10(t, test)\n\trunClientTestTLS12(t, test)\n\trunClientTestTLS13(t, test)\n}\n\nvar hostnameInSNITests = []struct {\n\tin, out string\n}{\n\t// Opaque string\n\t{\"\", \"\"},\n\t{\"localhost\", \"localhost\"},\n\t{\"foo, bar, baz and qux\", \"foo, bar, baz and qux\"},\n\n\t// DNS hostname\n\t{\"golang.org\", \"golang.org\"},\n\t{\"golang.org.\", \"golang.org\"},\n\n\t// Literal IPv4 address\n\t{\"1.2.3.4\", \"\"},\n\n\t// Literal IPv6 address\n\t{\"::1\", \"\"},\n\t{\"::1%lo0\", \"\"}, // with zone identifier\n\t{\"[::1]\", \"\"},   // as per RFC 5952 we allow the [] style as IPv6 literal\n\t{\"[::1%lo0]\", \"\"},\n}\n\nfunc TestHostnameInSNI(t *testing.T) {\n\tfor _, tt := range hostnameInSNITests {\n\t\tc, s := localPipe(t)\n\n\t\tgo func(host string) {\n\t\t\tClient(c, &Config{ServerName: host, InsecureSkipVerify: true}).Handshake()\n\t\t}(tt.in)\n\n\t\tvar header [5]byte\n\t\tif _, err := io.ReadFull(s, header[:]); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\trecordLen := int(header[3])<<8 | int(header[4])\n\n\t\trecord := make([]byte, recordLen)\n\t\tif _, err := io.ReadFull(s, record[:]); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tc.Close()\n\t\ts.Close()\n\n\t\tvar m clientHelloMsg\n\t\tif !m.unmarshal(record) {\n\t\t\tt.Errorf(\"unmarshaling ClientHello for %q failed\", tt.in)\n\t\t\tcontinue\n\t\t}\n\t\tif tt.in != tt.out && m.serverName == tt.in {\n\t\t\tt.Errorf(\"prohibited %q found in ClientHello: %x\", tt.in, record)\n\t\t}\n\t\tif m.serverName != tt.out {\n\t\t\tt.Errorf(\"expected %q not found in ClientHello: %x\", tt.out, record)\n\t\t}\n\t}\n}\n\nfunc TestServerSelectingUnconfiguredCipherSuite(t *testing.T) {\n\t// This checks that the server can't select a cipher suite that the\n\t// client didn't offer. See #13174.\n\n\tc, s := localPipe(t)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\tclient := Client(c, &Config{\n\t\t\tServerName:   \"foo\",\n\t\t\tCipherSuites: []uint16{TLS_RSA_WITH_AES_128_GCM_SHA256},\n\t\t})\n\t\terrChan <- client.Handshake()\n\t}()\n\n\tvar header [5]byte\n\tif _, err := io.ReadFull(s, header[:]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\trecordLen := int(header[3])<<8 | int(header[4])\n\n\trecord := make([]byte, recordLen)\n\tif _, err := io.ReadFull(s, record); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create a ServerHello that selects a different cipher suite than the\n\t// sole one that the client offered.\n\tserverHello := &serverHelloMsg{\n\t\tvers:        VersionTLS12,\n\t\trandom:      make([]byte, 32),\n\t\tcipherSuite: TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t}\n\tserverHelloBytes := mustMarshal(t, serverHello)\n\n\ts.Write([]byte{\n\t\tbyte(recordTypeHandshake),\n\t\tbyte(VersionTLS12 >> 8),\n\t\tbyte(VersionTLS12 & 0xff),\n\t\tbyte(len(serverHelloBytes) >> 8),\n\t\tbyte(len(serverHelloBytes)),\n\t})\n\ts.Write(serverHelloBytes)\n\ts.Close()\n\n\tif err := <-errChan; !strings.Contains(err.Error(), \"unconfigured cipher\") {\n\t\tt.Fatalf(\"Expected error about unconfigured cipher suite but got %q\", err)\n\t}\n}\n\nfunc TestVerifyConnection(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testVerifyConnection(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testVerifyConnection(t, VersionTLS13) })\n}\n\nfunc testVerifyConnection(t *testing.T, version uint16) {\n\tcheckFields := func(c ConnectionState, called *int, errorType string) error {\n\t\tif c.Version != version {\n\t\t\treturn fmt.Errorf(\"%s: got Version %v, want %v\", errorType, c.Version, version)\n\t\t}\n\t\tif c.HandshakeComplete {\n\t\t\treturn fmt.Errorf(\"%s: got HandshakeComplete, want false\", errorType)\n\t\t}\n\t\tif c.ServerName != \"example.golang\" {\n\t\t\treturn fmt.Errorf(\"%s: got ServerName %s, want %s\", errorType, c.ServerName, \"example.golang\")\n\t\t}\n\t\tif c.NegotiatedProtocol != \"protocol1\" {\n\t\t\treturn fmt.Errorf(\"%s: got NegotiatedProtocol %s, want %s\", errorType, c.NegotiatedProtocol, \"protocol1\")\n\t\t}\n\t\tif c.CipherSuite == 0 {\n\t\t\treturn fmt.Errorf(\"%s: got CipherSuite 0, want non-zero\", errorType)\n\t\t}\n\t\twantDidResume := false\n\t\tif *called == 2 { // if this is the second time, then it should be a resumption\n\t\t\twantDidResume = true\n\t\t}\n\t\tif c.DidResume != wantDidResume {\n\t\t\treturn fmt.Errorf(\"%s: got DidResume %t, want %t\", errorType, c.DidResume, wantDidResume)\n\t\t}\n\t\treturn nil\n\t}\n\n\ttests := []struct {\n\t\tname            string\n\t\tconfigureServer func(*Config, *int)\n\t\tconfigureClient func(*Config, *int)\n\t}{\n\t\t{\n\t\t\tname: \"RequireAndVerifyClientCert\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = RequireAndVerifyClientCert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.VerifiedChains) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.VerifiedChains) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif c.DidResume {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t// The SCTs and OCSP Response are dropped on resumption.\n\t\t\t\t\t\t// See http://golang.org/issue/39075.\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.OCSPResponse) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.SignedCertificateTimestamps) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(SignedCertificateTimestamps) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"InsecureSkipVerify\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = RequireAnyClientCert\n\t\t\t\tconfig.InsecureSkipVerify = true\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif c.VerifiedChains != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got Verified Chains %v, want nil\", c.VerifiedChains)\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.InsecureSkipVerify = true\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif c.VerifiedChains != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"server: got Verified Chains %v, want nil\", c.VerifiedChains)\n\t\t\t\t\t}\n\t\t\t\t\tif c.DidResume {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t// The SCTs and OCSP Response are dropped on resumption.\n\t\t\t\t\t\t// See http://golang.org/issue/39075.\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.OCSPResponse) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.SignedCertificateTimestamps) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(SignedCertificateTimestamps) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NoClientCert\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = NoClientCert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"RequestClientCert\",\n\t\t\tconfigureServer: func(config *Config, called *int) {\n\t\t\t\tconfig.ClientAuth = RequestClientCert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\treturn checkFields(c, called, \"server\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *int) {\n\t\t\t\tconfig.Certificates = nil // clear the client cert\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\t*called++\n\t\t\t\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.VerifiedChains) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif c.DidResume {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t// The SCTs and OCSP Response are dropped on resumption.\n\t\t\t\t\t\t// See http://golang.org/issue/39075.\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.OCSPResponse) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(c.SignedCertificateTimestamps) == 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"client: got len(SignedCertificateTimestamps) = 0, wanted non-zero\")\n\t\t\t\t\t}\n\t\t\t\t\treturn checkFields(c, called, \"client\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\trootCAs := x509.NewCertPool()\n\t\trootCAs.AddCert(issuer)\n\n\t\tvar serverCalled, clientCalled int\n\n\t\tserverConfig := &Config{\n\t\t\tMaxVersion:   version,\n\t\t\tCertificates: []Certificate{testConfig.Certificates[0]},\n\t\t\tClientCAs:    rootCAs,\n\t\t\tNextProtos:   []string{\"protocol1\"},\n\t\t}\n\t\tserverConfig.Certificates[0].SignedCertificateTimestamps = [][]byte{[]byte(\"dummy sct 1\"), []byte(\"dummy sct 2\")}\n\t\tserverConfig.Certificates[0].OCSPStaple = []byte(\"dummy ocsp\")\n\t\ttest.configureServer(serverConfig, &serverCalled)\n\n\t\tclientConfig := &Config{\n\t\t\tMaxVersion:         version,\n\t\t\tClientSessionCache: NewLRUClientSessionCache(32),\n\t\t\tRootCAs:            rootCAs,\n\t\t\tServerName:         \"example.golang\",\n\t\t\tCertificates:       []Certificate{testConfig.Certificates[0]},\n\t\t\tNextProtos:         []string{\"protocol1\"},\n\t\t}\n\t\ttest.configureClient(clientConfig, &clientCalled)\n\n\t\ttestHandshakeState := func(name string, didResume bool) {\n\t\t\t_, hs, err := testHandshake(t, clientConfig, serverConfig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s: handshake failed: %s\", name, err)\n\t\t\t}\n\t\t\tif hs.DidResume != didResume {\n\t\t\t\tt.Errorf(\"%s: resumed: %v, expected: %v\", name, hs.DidResume, didResume)\n\t\t\t}\n\t\t\twantCalled := 1\n\t\t\tif didResume {\n\t\t\t\twantCalled = 2 // resumption would mean this is the second time it was called in this test\n\t\t\t}\n\t\t\tif clientCalled != wantCalled {\n\t\t\t\tt.Errorf(\"%s: expected client VerifyConnection called %d times, did %d times\", name, wantCalled, clientCalled)\n\t\t\t}\n\t\t\tif serverCalled != wantCalled {\n\t\t\t\tt.Errorf(\"%s: expected server VerifyConnection called %d times, did %d times\", name, wantCalled, serverCalled)\n\t\t\t}\n\t\t}\n\t\ttestHandshakeState(fmt.Sprintf(\"%s-FullHandshake\", test.name), false)\n\t\ttestHandshakeState(fmt.Sprintf(\"%s-Resumption\", test.name), true)\n\t}\n}\n\nfunc TestVerifyPeerCertificate(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testVerifyPeerCertificate(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testVerifyPeerCertificate(t, VersionTLS13) })\n}\n\nfunc testVerifyPeerCertificate(t *testing.T, version uint16) {\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\trootCAs := x509.NewCertPool()\n\trootCAs.AddCert(issuer)\n\n\tnow := func() time.Time { return time.Unix(1476984729, 0) }\n\n\tsentinelErr := errors.New(\"TestVerifyPeerCertificate\")\n\n\tverifyPeerCertificateCallback := func(called *bool, rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\tif l := len(rawCerts); l != 1 {\n\t\t\treturn fmt.Errorf(\"got len(rawCerts) = %d, wanted 1\", l)\n\t\t}\n\t\tif len(validatedChains) == 0 {\n\t\t\treturn errors.New(\"got len(validatedChains) = 0, wanted non-zero\")\n\t\t}\n\t\t*called = true\n\t\treturn nil\n\t}\n\tverifyConnectionCallback := func(called *bool, isClient bool, c ConnectionState) error {\n\t\tif l := len(c.PeerCertificates); l != 1 {\n\t\t\treturn fmt.Errorf(\"got len(PeerCertificates) = %d, wanted 1\", l)\n\t\t}\n\t\tif len(c.VerifiedChains) == 0 {\n\t\t\treturn fmt.Errorf(\"got len(VerifiedChains) = 0, wanted non-zero\")\n\t\t}\n\t\tif isClient && len(c.OCSPResponse) == 0 {\n\t\t\treturn fmt.Errorf(\"got len(OCSPResponse) = 0, wanted non-zero\")\n\t\t}\n\t\t*called = true\n\t\treturn nil\n\t}\n\n\ttests := []struct {\n\t\tconfigureServer func(*Config, *bool)\n\t\tconfigureClient func(*Config, *bool)\n\t\tvalidate        func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error)\n\t}{\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif serverErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t\tif !serverCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: server did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.VerifyPeerCertificate = nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif serverErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got server error %v, wanted sentinelErr\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got client error %v, wanted sentinelErr\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = true\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\tif l := len(rawCerts); l != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"got len(rawCerts) = %d, wanted 1\", l)\n\t\t\t\t\t}\n\t\t\t\t\t// With InsecureSkipVerify set, this\n\t\t\t\t\t// callback should still be called but\n\t\t\t\t\t// validatedChains must be empty.\n\t\t\t\t\tif l := len(validatedChains); l != 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"got len(validatedChains) = %d, wanted zero\", l)\n\t\t\t\t\t}\n\t\t\t\t\t*called = true\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif serverErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn verifyConnectionCallback(called, false, c)\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn verifyConnectionCallback(called, true, c)\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif serverErr != nil {\n\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t\tif !serverCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: server did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif serverErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got server error %v, wanted sentinelErr\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got client error %v, wanted sentinelErr\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = nil\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif serverErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got server error %v, wanted sentinelErr\", testNo, serverErr)\n\t\t\t\t}\n\t\t\t\tif !serverCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: server did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tconfigureServer: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = nil\n\t\t\t\tconfig.VerifyConnection = nil\n\t\t\t},\n\t\t\tconfigureClient: func(config *Config, called *bool) {\n\t\t\t\tconfig.InsecureSkipVerify = false\n\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n\t\t\t\t\treturn verifyPeerCertificateCallback(called, rawCerts, validatedChains)\n\t\t\t\t}\n\t\t\t\tconfig.VerifyConnection = func(c ConnectionState) error {\n\t\t\t\t\treturn sentinelErr\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n\t\t\t\tif clientErr != sentinelErr {\n\t\t\t\t\tt.Errorf(\"#%d: got client error %v, wanted sentinelErr\", testNo, clientErr)\n\t\t\t\t}\n\t\t\t\tif !clientCalled {\n\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tc, s := localPipe(t)\n\t\tdone := make(chan error)\n\n\t\tvar clientCalled, serverCalled bool\n\n\t\tgo func() {\n\t\t\tconfig := testConfig.Clone()\n\t\t\tconfig.ServerName = \"example.golang\"\n\t\t\tconfig.ClientAuth = RequireAndVerifyClientCert\n\t\t\tconfig.ClientCAs = rootCAs\n\t\t\tconfig.Time = now\n\t\t\tconfig.MaxVersion = version\n\t\t\tconfig.Certificates = make([]Certificate, 1)\n\t\t\tconfig.Certificates[0].Certificate = [][]byte{testRSACertificate}\n\t\t\tconfig.Certificates[0].PrivateKey = testRSAPrivateKey\n\t\t\tconfig.Certificates[0].SignedCertificateTimestamps = [][]byte{[]byte(\"dummy sct 1\"), []byte(\"dummy sct 2\")}\n\t\t\tconfig.Certificates[0].OCSPStaple = []byte(\"dummy ocsp\")\n\t\t\ttest.configureServer(config, &serverCalled)\n\n\t\t\terr = Server(s, config).Handshake()\n\t\t\ts.Close()\n\t\t\tdone <- err\n\t\t}()\n\n\t\tconfig := testConfig.Clone()\n\t\tconfig.ServerName = \"example.golang\"\n\t\tconfig.RootCAs = rootCAs\n\t\tconfig.Time = now\n\t\tconfig.MaxVersion = version\n\t\ttest.configureClient(config, &clientCalled)\n\t\tclientErr := Client(c, config).Handshake()\n\t\tc.Close()\n\t\tserverErr := <-done\n\n\t\ttest.validate(t, i, clientCalled, serverCalled, clientErr, serverErr)\n\t}\n}\n\n// brokenConn wraps a net.Conn and causes all Writes after a certain number to\n// fail with brokenConnErr.\ntype brokenConn struct {\n\tnet.Conn\n\n\t// breakAfter is the number of successful writes that will be allowed\n\t// before all subsequent writes fail.\n\tbreakAfter int\n\n\t// numWrites is the number of writes that have been done.\n\tnumWrites int\n}\n\n// brokenConnErr is the error that brokenConn returns once exhausted.\nvar brokenConnErr = errors.New(\"too many writes to brokenConn\")\n\nfunc (b *brokenConn) Write(data []byte) (int, error) {\n\tif b.numWrites >= b.breakAfter {\n\t\treturn 0, brokenConnErr\n\t}\n\n\tb.numWrites++\n\treturn b.Conn.Write(data)\n}\n\nfunc TestFailedWrite(t *testing.T) {\n\t// Test that a write error during the handshake is returned.\n\tfor _, breakAfter := range []int{0, 1} {\n\t\tc, s := localPipe(t)\n\t\tdone := make(chan bool)\n\n\t\tgo func() {\n\t\t\tServer(s, testConfig).Handshake()\n\t\t\ts.Close()\n\t\t\tdone <- true\n\t\t}()\n\n\t\tbrokenC := &brokenConn{Conn: c, breakAfter: breakAfter}\n\t\terr := Client(brokenC, testConfig).Handshake()\n\t\tif err != brokenConnErr {\n\t\t\tt.Errorf(\"#%d: expected error from brokenConn but got %q\", breakAfter, err)\n\t\t}\n\t\tbrokenC.Close()\n\n\t\t<-done\n\t}\n}\n\n// writeCountingConn wraps a net.Conn and counts the number of Write calls.\ntype writeCountingConn struct {\n\tnet.Conn\n\n\t// numWrites is the number of writes that have been done.\n\tnumWrites int\n}\n\nfunc (wcc *writeCountingConn) Write(data []byte) (int, error) {\n\twcc.numWrites++\n\treturn wcc.Conn.Write(data)\n}\n\nfunc TestBuffering(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testBuffering(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testBuffering(t, VersionTLS13) })\n}\n\nfunc testBuffering(t *testing.T, version uint16) {\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tclientWCC := &writeCountingConn{Conn: c}\n\tserverWCC := &writeCountingConn{Conn: s}\n\n\tgo func() {\n\t\tconfig := testConfig.Clone()\n\t\tconfig.MaxVersion = version\n\t\tServer(serverWCC, config).Handshake()\n\t\tserverWCC.Close()\n\t\tdone <- true\n\t}()\n\n\terr := Client(clientWCC, testConfig).Handshake()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclientWCC.Close()\n\t<-done\n\n\tvar expectedClient, expectedServer int\n\tif version == VersionTLS13 {\n\t\texpectedClient = 2\n\t\texpectedServer = 1\n\t} else {\n\t\texpectedClient = 2\n\t\texpectedServer = 2\n\t}\n\n\tif n := clientWCC.numWrites; n != expectedClient {\n\t\tt.Errorf(\"expected client handshake to complete with %d writes, but saw %d\", expectedClient, n)\n\t}\n\n\tif n := serverWCC.numWrites; n != expectedServer {\n\t\tt.Errorf(\"expected server handshake to complete with %d writes, but saw %d\", expectedServer, n)\n\t}\n}\n\nfunc TestAlertFlushing(t *testing.T) {\n\tc, s := localPipe(t)\n\tdone := make(chan bool)\n\n\tclientWCC := &writeCountingConn{Conn: c}\n\tserverWCC := &writeCountingConn{Conn: s}\n\n\tserverConfig := testConfig.Clone()\n\n\t// Cause a signature-time error\n\tbrokenKey := rsa.PrivateKey{PublicKey: testRSAPrivateKey.PublicKey}\n\tbrokenKey.D = big.NewInt(42)\n\tserverConfig.Certificates = []Certificate{{\n\t\tCertificate: [][]byte{testRSACertificate},\n\t\tPrivateKey:  &brokenKey,\n\t}}\n\n\tgo func() {\n\t\tServer(serverWCC, serverConfig).Handshake()\n\t\tserverWCC.Close()\n\t\tdone <- true\n\t}()\n\n\terr := Client(clientWCC, testConfig).Handshake()\n\tif err == nil {\n\t\tt.Fatal(\"client unexpectedly returned no error\")\n\t}\n\n\tconst expectedError = \"remote error: tls: internal error\"\n\tif e := err.Error(); !strings.Contains(e, expectedError) {\n\t\tt.Fatalf(\"expected to find %q in error but error was %q\", expectedError, e)\n\t}\n\tclientWCC.Close()\n\t<-done\n\n\tif n := serverWCC.numWrites; n != 1 {\n\t\tt.Errorf(\"expected server handshake to complete with one write, but saw %d\", n)\n\t}\n}\n\nfunc TestHandshakeRace(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping in -short mode\")\n\t}\n\tt.Parallel()\n\t// This test races a Read and Write to try and complete a handshake in\n\t// order to provide some evidence that there are no races or deadlocks\n\t// in the handshake locking.\n\tfor i := 0; i < 32; i++ {\n\t\tc, s := localPipe(t)\n\n\t\tgo func() {\n\t\t\tserver := Server(s, testConfig)\n\t\t\tif err := server.Handshake(); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tvar request [1]byte\n\t\t\tif n, err := server.Read(request[:]); err != nil || n != 1 {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tserver.Write(request[:])\n\t\t\tserver.Close()\n\t\t}()\n\n\t\tstartWrite := make(chan struct{})\n\t\tstartRead := make(chan struct{})\n\t\treadDone := make(chan struct{}, 1)\n\n\t\tclient := Client(c, testConfig)\n\t\tgo func() {\n\t\t\t<-startWrite\n\t\t\tvar request [1]byte\n\t\t\tclient.Write(request[:])\n\t\t}()\n\n\t\tgo func() {\n\t\t\t<-startRead\n\t\t\tvar reply [1]byte\n\t\t\tif _, err := io.ReadFull(client, reply[:]); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treadDone <- struct{}{}\n\t\t}()\n\n\t\tif i&1 == 1 {\n\t\t\tstartWrite <- struct{}{}\n\t\t\tstartRead <- struct{}{}\n\t\t} else {\n\t\t\tstartRead <- struct{}{}\n\t\t\tstartWrite <- struct{}{}\n\t\t}\n\t\t<-readDone\n\t}\n}\n\nvar getClientCertificateTests = []struct {\n\tsetup               func(*Config, *Config)\n\texpectedClientError string\n\tverify              func(*testing.T, int, *ConnectionState)\n}{\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\t// Returning a Certificate with no certificate data\n\t\t\t// should result in an empty message being sent to the\n\t\t\t// server.\n\t\t\tserverConfig.ClientCAs = nil\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\tif len(cri.SignatureSchemes) == 0 {\n\t\t\t\t\tpanic(\"empty SignatureSchemes\")\n\t\t\t\t}\n\t\t\t\tif len(cri.AcceptableCAs) != 0 {\n\t\t\t\t\tpanic(\"AcceptableCAs should have been empty\")\n\t\t\t\t}\n\t\t\t\treturn new(Certificate), nil\n\t\t\t}\n\t\t},\n\t\t\"\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t\tif l := len(cs.PeerCertificates); l != 0 {\n\t\t\t\tt.Errorf(\"#%d: expected no certificates but got %d\", testNum, l)\n\t\t\t}\n\t\t},\n\t},\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\t// With TLS 1.1, the SignatureSchemes should be\n\t\t\t// synthesised from the supported certificate types.\n\t\t\tclientConfig.MaxVersion = VersionTLS11\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\tif len(cri.SignatureSchemes) == 0 {\n\t\t\t\t\tpanic(\"empty SignatureSchemes\")\n\t\t\t\t}\n\t\t\t\treturn new(Certificate), nil\n\t\t\t}\n\t\t},\n\t\t\"\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t\tif l := len(cs.PeerCertificates); l != 0 {\n\t\t\t\tt.Errorf(\"#%d: expected no certificates but got %d\", testNum, l)\n\t\t\t}\n\t\t},\n\t},\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\t// Returning an error should abort the handshake with\n\t\t\t// that error.\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\treturn nil, errors.New(\"GetClientCertificate\")\n\t\t\t}\n\t\t},\n\t\t\"GetClientCertificate\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t},\n\t},\n\t{\n\t\tfunc(clientConfig, serverConfig *Config) {\n\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n\t\t\t\tif len(cri.AcceptableCAs) == 0 {\n\t\t\t\t\tpanic(\"empty AcceptableCAs\")\n\t\t\t\t}\n\t\t\t\tcert := &Certificate{\n\t\t\t\t\tCertificate: [][]byte{testRSACertificate},\n\t\t\t\t\tPrivateKey:  testRSAPrivateKey,\n\t\t\t\t}\n\t\t\t\treturn cert, nil\n\t\t\t}\n\t\t},\n\t\t\"\",\n\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n\t\t\tif len(cs.VerifiedChains) == 0 {\n\t\t\t\tt.Errorf(\"#%d: expected some verified chains, but found none\", testNum)\n\t\t\t}\n\t\t},\n\t},\n}\n\nfunc TestGetClientCertificate(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testGetClientCertificate(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testGetClientCertificate(t, VersionTLS13) })\n}\n\nfunc testGetClientCertificate(t *testing.T, version uint16) {\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i, test := range getClientCertificateTests {\n\t\tserverConfig := testConfig.Clone()\n\t\tserverConfig.ClientAuth = VerifyClientCertIfGiven\n\t\tserverConfig.RootCAs = x509.NewCertPool()\n\t\tserverConfig.RootCAs.AddCert(issuer)\n\t\tserverConfig.ClientCAs = serverConfig.RootCAs\n\t\tserverConfig.Time = func() time.Time { return time.Unix(1476984729, 0) }\n\t\tserverConfig.MaxVersion = version\n\n\t\tclientConfig := testConfig.Clone()\n\t\tclientConfig.MaxVersion = version\n\n\t\ttest.setup(clientConfig, serverConfig)\n\n\t\ttype serverResult struct {\n\t\t\tcs  ConnectionState\n\t\t\terr error\n\t\t}\n\n\t\tc, s := localPipe(t)\n\t\tdone := make(chan serverResult)\n\n\t\tgo func() {\n\t\t\tdefer s.Close()\n\t\t\tserver := Server(s, serverConfig)\n\t\t\terr := server.Handshake()\n\n\t\t\tvar cs ConnectionState\n\t\t\tif err == nil {\n\t\t\t\tcs = server.ConnectionState()\n\t\t\t}\n\t\t\tdone <- serverResult{cs, err}\n\t\t}()\n\n\t\tclientErr := Client(c, clientConfig).Handshake()\n\t\tc.Close()\n\n\t\tresult := <-done\n\n\t\tif clientErr != nil {\n\t\t\tif len(test.expectedClientError) == 0 {\n\t\t\t\tt.Errorf(\"#%d: client error: %v\", i, clientErr)\n\t\t\t} else if got := clientErr.Error(); got != test.expectedClientError {\n\t\t\t\tt.Errorf(\"#%d: expected client error %q, but got %q\", i, test.expectedClientError, got)\n\t\t\t} else {\n\t\t\t\ttest.verify(t, i, &result.cs)\n\t\t\t}\n\t\t} else if len(test.expectedClientError) > 0 {\n\t\t\tt.Errorf(\"#%d: expected client error %q, but got no error\", i, test.expectedClientError)\n\t\t} else if err := result.err; err != nil {\n\t\t\tt.Errorf(\"#%d: server error: %v\", i, err)\n\t\t} else {\n\t\t\ttest.verify(t, i, &result.cs)\n\t\t}\n\t}\n}\n\nfunc TestRSAPSSKeyError(t *testing.T) {\n\t// crypto/tls does not support the rsa_pss_pss_* SignatureSchemes. If support for\n\t// public keys with OID RSASSA-PSS is added to crypto/x509, they will be misused with\n\t// the rsa_pss_rsae_* SignatureSchemes. Assert that RSASSA-PSS certificates don't\n\t// parse, or that they don't carry *rsa.PublicKey keys.\n\tb, _ := pem.Decode([]byte(`\n-----BEGIN CERTIFICATE-----\nMIIDZTCCAhygAwIBAgIUCF2x0FyTgZG0CC9QTDjGWkB5vgEwPgYJKoZIhvcNAQEK\nMDGgDTALBglghkgBZQMEAgGhGjAYBgkqhkiG9w0BAQgwCwYJYIZIAWUDBAIBogQC\nAgDeMBIxEDAOBgNVBAMMB1JTQS1QU1MwHhcNMTgwNjI3MjI0NDM2WhcNMTgwNzI3\nMjI0NDM2WjASMRAwDgYDVQQDDAdSU0EtUFNTMIIBIDALBgkqhkiG9w0BAQoDggEP\nADCCAQoCggEBANxDm0f76JdI06YzsjB3AmmjIYkwUEGxePlafmIASFjDZl/elD0Z\n/a7xLX468b0qGxLS5al7XCcEprSdsDR6DF5L520+pCbpfLyPOjuOvGmk9KzVX4x5\nb05YXYuXdsQ0Kjxcx2i3jjCday6scIhMJVgBZxTEyMj1thPQM14SHzKCd/m6HmCL\nQmswpH2yMAAcBRWzRpp/vdH5DeOJEB3aelq7094no731mrLUCHRiZ1htq8BDB3ou\nczwqgwspbqZ4dnMXl2MvfySQ5wJUxQwILbiuAKO2lVVPUbFXHE9pgtznNoPvKwQT\nJNcX8ee8WIZc2SEGzofjk3NpjR+2ADB2u3sCAwEAAaNTMFEwHQYDVR0OBBYEFNEz\nAdyJ2f+fU+vSCS6QzohnOnprMB8GA1UdIwQYMBaAFNEzAdyJ2f+fU+vSCS6Qzohn\nOnprMA8GA1UdEwEB/wQFMAMBAf8wPgYJKoZIhvcNAQEKMDGgDTALBglghkgBZQME\nAgGhGjAYBgkqhkiG9w0BAQgwCwYJYIZIAWUDBAIBogQCAgDeA4IBAQCjEdrR5aab\nsZmCwrMeKidXgfkmWvfuLDE+TCbaqDZp7BMWcMQXT9O0UoUT5kqgKj2ARm2pEW0Z\nH3Z1vj3bbds72qcDIJXp+l0fekyLGeCrX/CbgnMZXEP7+/+P416p34ChR1Wz4dU1\nKD3gdsUuTKKeMUog3plxlxQDhRQmiL25ygH1LmjLd6dtIt0GVRGr8lj3euVeprqZ\nbZ3Uq5eLfsn8oPgfC57gpO6yiN+UURRTlK3bgYvLh4VWB3XXk9UaQZ7Mq1tpXjoD\nHYFybkWzibkZp4WRo+Fa28rirH+/wHt0vfeN7UCceURZEx4JaxIIfe4ku7uDRhJi\nRwBA9Xk1KBNF\n-----END CERTIFICATE-----`))\n\tif b == nil {\n\t\tt.Fatal(\"Failed to decode certificate\")\n\t}\n\tcert, err := x509.ParseCertificate(b.Bytes)\n\tif err != nil {\n\t\treturn\n\t}\n\tif _, ok := cert.PublicKey.(*rsa.PublicKey); ok {\n\t\tt.Error(\"A RSASSA-PSS certificate was parsed like a PKCS#1 v1.5 one, and it will be mistakenly used with rsa_pss_rsae_* signature algorithms\")\n\t}\n}\n\nfunc TestCloseClientConnectionOnIdleServer(t *testing.T) {\n\tclientConn, serverConn := localPipe(t)\n\tclient := Client(clientConn, testConfig.Clone())\n\tgo func() {\n\t\tvar b [1]byte\n\t\tserverConn.Read(b[:])\n\t\tclient.Close()\n\t}()\n\tclient.SetWriteDeadline(time.Now().Add(time.Minute))\n\terr := client.Handshake()\n\tif err != nil {\n\t\tif err, ok := err.(net.Error); ok && err.Timeout() {\n\t\t\tt.Errorf(\"Expected a closed network connection error but got '%s'\", err.Error())\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Error expected, but no error returned\")\n\t}\n}\n\nfunc testDowngradeCanary(t *testing.T, clientVersion, serverVersion uint16) error {\n\tdefer func() { testingOnlyForceDowngradeCanary = false }()\n\ttestingOnlyForceDowngradeCanary = true\n\n\tclientConfig := testConfig.Clone()\n\tclientConfig.MaxVersion = clientVersion\n\tserverConfig := testConfig.Clone()\n\tserverConfig.MaxVersion = serverVersion\n\t_, _, err := testHandshake(t, clientConfig, serverConfig)\n\treturn err\n}\n\nfunc TestDowngradeCanary(t *testing.T) {\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS12); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.3 to TLS 1.2 was not detected\")\n\t}\n\tif testing.Short() {\n\t\tt.Skip(\"skipping the rest of the checks in short mode\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS11); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.3 to TLS 1.1 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS10); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.3 to TLS 1.0 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS12, VersionTLS11); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.2 to TLS 1.1 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS12, VersionTLS10); err == nil {\n\t\tt.Errorf(\"downgrade from TLS 1.2 to TLS 1.0 was not detected\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS13, VersionTLS13); err != nil {\n\t\tt.Errorf(\"server unexpectedly sent downgrade canary for TLS 1.3\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS12, VersionTLS12); err != nil {\n\t\tt.Errorf(\"client didn't ignore expected TLS 1.2 canary\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS11, VersionTLS11); err != nil {\n\t\tt.Errorf(\"client unexpectedly reacted to a canary in TLS 1.1\")\n\t}\n\tif err := testDowngradeCanary(t, VersionTLS10, VersionTLS10); err != nil {\n\t\tt.Errorf(\"client unexpectedly reacted to a canary in TLS 1.0\")\n\t}\n}\n\nfunc TestResumptionKeepsOCSPAndSCT(t *testing.T) {\n\tt.Run(\"TLSv12\", func(t *testing.T) { testResumptionKeepsOCSPAndSCT(t, VersionTLS12) })\n\tt.Run(\"TLSv13\", func(t *testing.T) { testResumptionKeepsOCSPAndSCT(t, VersionTLS13) })\n}\n\nfunc testResumptionKeepsOCSPAndSCT(t *testing.T, ver uint16) {\n\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse test issuer\")\n\t}\n\troots := x509.NewCertPool()\n\troots.AddCert(issuer)\n\tclientConfig := &Config{\n\t\tMaxVersion:         ver,\n\t\tClientSessionCache: NewLRUClientSessionCache(32),\n\t\tServerName:         \"example.golang\",\n\t\tRootCAs:            roots,\n\t}\n\tserverConfig := testConfig.Clone()\n\tserverConfig.MaxVersion = ver\n\tserverConfig.Certificates[0].OCSPStaple = []byte{1, 2, 3}\n\tserverConfig.Certificates[0].SignedCertificateTimestamps = [][]byte{{4, 5, 6}}\n\n\t_, ccs, err := testHandshake(t, clientConfig, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n\t// after a new session we expect to see OCSPResponse and\n\t// SignedCertificateTimestamps populated as usual\n\tif !bytes.Equal(ccs.OCSPResponse, serverConfig.Certificates[0].OCSPStaple) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected OCSPResponse: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].OCSPStaple, ccs.OCSPResponse)\n\t}\n\tif !reflect.DeepEqual(ccs.SignedCertificateTimestamps, serverConfig.Certificates[0].SignedCertificateTimestamps) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected SignedCertificateTimestamps: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].SignedCertificateTimestamps, ccs.SignedCertificateTimestamps)\n\t}\n\n\t// if the server doesn't send any SCTs, repopulate the old SCTs\n\toldSCTs := serverConfig.Certificates[0].SignedCertificateTimestamps\n\tserverConfig.Certificates[0].SignedCertificateTimestamps = nil\n\t_, ccs, err = testHandshake(t, clientConfig, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n\tif !ccs.DidResume {\n\t\tt.Fatalf(\"expected session to be resumed\")\n\t}\n\t// after a resumed session we also expect to see OCSPResponse\n\t// and SignedCertificateTimestamps populated\n\tif !bytes.Equal(ccs.OCSPResponse, serverConfig.Certificates[0].OCSPStaple) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected OCSPResponse after resumption: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].OCSPStaple, ccs.OCSPResponse)\n\t}\n\tif !reflect.DeepEqual(ccs.SignedCertificateTimestamps, oldSCTs) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected SignedCertificateTimestamps after resumption: wanted %v, got %v\",\n\t\t\toldSCTs, ccs.SignedCertificateTimestamps)\n\t}\n\n\t//  Only test overriding the SCTs for TLS 1.2, since in 1.3\n\t// the server won't send the message containing them\n\tif ver == VersionTLS13 {\n\t\treturn\n\t}\n\n\t// if the server changes the SCTs it sends, they should override the saved SCTs\n\tserverConfig.Certificates[0].SignedCertificateTimestamps = [][]byte{{7, 8, 9}}\n\t_, ccs, err = testHandshake(t, clientConfig, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n\tif !ccs.DidResume {\n\t\tt.Fatalf(\"expected session to be resumed\")\n\t}\n\tif !reflect.DeepEqual(ccs.SignedCertificateTimestamps, serverConfig.Certificates[0].SignedCertificateTimestamps) {\n\t\tt.Errorf(\"client ConnectionState contained unexpected SignedCertificateTimestamps after resumption: wanted %v, got %v\",\n\t\t\tserverConfig.Certificates[0].SignedCertificateTimestamps, ccs.SignedCertificateTimestamps)\n\t}\n}\n\n// TestClientHandshakeContextCancellation tests that canceling\n// the context given to the client side conn.HandshakeContext\n// interrupts the in-progress handshake.\nfunc TestClientHandshakeContextCancellation(t *testing.T) {\n\tc, s := localPipe(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tunblockServer := make(chan struct{})\n\tdefer close(unblockServer)\n\tgo func() {\n\t\tcancel()\n\t\t<-unblockServer\n\t\t_ = s.Close()\n\t}()\n\tcli := Client(c, testConfig)\n\t// Initiates client side handshake, which will block until the client hello is read\n\t// by the server, unless the cancellation works.\n\terr := cli.HandshakeContext(ctx)\n\tif err == nil {\n\t\tt.Fatal(\"Client handshake did not error when the context was canceled\")\n\t}\n\tif err != context.Canceled {\n\t\tt.Errorf(\"Unexpected client handshake error: %v\", err)\n\t}\n\tif runtime.GOARCH == \"wasm\" {\n\t\tt.Skip(\"conn.Close does not error as expected when called multiple times on WASM\")\n\t}\n\terr = cli.Close()\n\tif err == nil {\n\t\tt.Error(\"Client connection was not closed when the context was canceled\")\n\t}\n}\n\n// TestTLS13OnlyClientHelloCipherSuite tests that when a client states that\n// it only supports TLS 1.3, it correctly advertises only TLS 1.3 ciphers.\nfunc TestTLS13OnlyClientHelloCipherSuite(t *testing.T) {\n\ttls13Tests := []struct {\n\t\tname    string\n\t\tciphers []uint16\n\t}{\n\t\t{\n\t\t\tname:    \"nil\",\n\t\t\tciphers: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty\",\n\t\t\tciphers: []uint16{},\n\t\t},\n\t\t{\n\t\t\tname:    \"some TLS 1.2 cipher\",\n\t\t\tciphers: []uint16{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256},\n\t\t},\n\t\t{\n\t\t\tname:    \"some TLS 1.3 cipher\",\n\t\t\tciphers: []uint16{TLS_AES_128_GCM_SHA256},\n\t\t},\n\t\t{\n\t\t\tname:    \"some TLS 1.2 and 1.3 ciphers\",\n\t\t\tciphers: []uint16{TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_AES_256_GCM_SHA384},\n\t\t},\n\t}\n\tfor _, tt := range tls13Tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ttestTLS13OnlyClientHelloCipherSuite(t, tt.ciphers)\n\t\t})\n\t}\n}\n\nfunc testTLS13OnlyClientHelloCipherSuite(t *testing.T, ciphers []uint16) {\n\tserverConfig := &Config{\n\t\tCertificates: testConfig.Certificates,\n\t\tGetConfigForClient: func(chi *ClientHelloInfo) (*Config, error) {\n\t\t\tif len(chi.CipherSuites) != len(defaultCipherSuitesTLS13NoAES) {\n\t\t\t\tt.Errorf(\"only TLS 1.3 suites should be advertised, got=%x\", chi.CipherSuites)\n\t\t\t} else {\n\t\t\t\tfor i := range defaultCipherSuitesTLS13NoAES {\n\t\t\t\t\tif want, got := defaultCipherSuitesTLS13NoAES[i], chi.CipherSuites[i]; want != got {\n\t\t\t\t\t\tt.Errorf(\"cipher at index %d does not match, want=%x, got=%x\", i, want, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t},\n\t}\n\tclientConfig := &Config{\n\t\tMinVersion:         VersionTLS13, // client only supports TLS 1.3\n\t\tCipherSuites:       ciphers,\n\t\tInsecureSkipVerify: true,\n\t}\n\tif _, _, err := testHandshake(t, clientConfig, serverConfig); err != nil {\n\t\tt.Fatalf(\"handshake failed: %s\", err)\n\t}\n}\n\n// discardConn wraps a net.Conn but discards all writes, but reports that they happened.\ntype discardConn struct {\n\tnet.Conn\n}\n\nfunc (dc *discardConn) Write(data []byte) (int, error) {\n\treturn len(data), nil\n}\n\n// largeRSAKeyCertPEM contains a 8193 bit RSA key\nconst largeRSAKeyCertPEM = `-----BEGIN CERTIFICATE-----\nMIIInjCCBIWgAwIBAgIBAjANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDEwd0ZXN0\naW5nMB4XDTIzMDYwNzIxMjMzNloXDTIzMDYwNzIzMjMzNlowEjEQMA4GA1UEAxMH\ndGVzdGluZzCCBCIwDQYJKoZIhvcNAQEBBQADggQPADCCBAoCggQBAWdHsf6Rh2Ca\nn2SQwn4t4OQrOjbLLdGE1pM6TBKKrHUFy62uEL8atNjlcfXIsa4aEu3xNGiqxqur\nZectlkZbm0FkaaQ1Wr9oikDY3KfjuaXdPdO/XC/h8AKNxlDOylyXwUSK/CuYb+1j\ngy8yF5QFvVfwW/xwTlHmhUeSkVSQPosfQ6yXNNsmMzkd+ZPWLrfq4R+wiNtwYGu0\nWSBcI/M9o8/vrNLnIppoiBJJ13j9CR1ToEAzOFh9wwRWLY10oZhoh1ONN1KQURx4\nqedzvvP2DSjZbUccdvl2rBGvZpzfOiFdm1FCnxB0c72Cqx+GTHXBFf8bsa7KHky9\nsNO1GUanbq17WoDNgwbY6H51bfShqv0CErxatwWox3we4EcAmFHPVTCYL1oWVMGo\na3Eth91NZj+b/nGhF9lhHKGzXSv9brmLLkfvM1jA6XhNhA7BQ5Vz67lj2j3XfXdh\nt/BU5pBXbL4Ut4mIhT1YnKXAjX2/LF5RHQTE8Vwkx5JAEKZyUEGOReD/B+7GOrLp\nHduMT9vZAc5aR2k9I8qq1zBAzsL69lyQNAPaDYd1BIAjUety9gAYaSQffCgAgpRO\nGt+DYvxS+7AT/yEd5h74MU2AH7KrAkbXOtlwupiGwhMVTstncDJWXMJqbBhyHPF8\n3UmZH0hbL4PYmzSj9LDWQQXI2tv6vrCpfts3Cqhqxz9vRpgY7t1Wu6l/r+KxYYz3\n1pcGpPvRmPh0DJm7cPTiXqPnZcPt+ulSaSdlxmd19OnvG5awp0fXhxryZVwuiT8G\nVDkhyARrxYrdjlINsZJZbQjO0t8ketXAELJOnbFXXzeCOosyOHkLwsqOO96AVJA8\n45ZVL5m95ClGy0RSrjVIkXsxTAMVG6SPAqKwk6vmTdRGuSPS4rhgckPVDHmccmuq\ndfnT2YkX+wB2/M3oCgU+s30fAHGkbGZ0pCdNbFYFZLiH0iiMbTDl/0L/z7IdK0nH\nGLHVE7apPraKC6xl6rPWsD2iSfrmtIPQa0+rqbIVvKP5JdfJ8J4alI+OxFw/znQe\nV0/Rez0j22Fe119LZFFSXhRv+ZSvcq20xDwh00mzcumPWpYuCVPozA18yIhC9tNn\nALHndz0tDseIdy9vC71jQWy9iwri3ueN0DekMMF8JGzI1Z6BAFzgyAx3DkHtwHg7\nB7qD0jPG5hJ5+yt323fYgJsuEAYoZ8/jzZ01pkX8bt+UsVN0DGnSGsI2ktnIIk3J\nl+8krjmUy6EaW79nITwoOqaeHOIp8m3UkjEcoKOYrzHRKqRy+A09rY+m/cAQaafW\n4xp0Zv7qZPLwnu0jsqB4jD8Ll9yPB02ndsoV6U5PeHzTkVhPml19jKUAwFfs7TJg\nkXy+/xFhYVUCAwEAATANBgkqhkiG9w0BAQsFAAOCBAIAAQnZY77pMNeypfpba2WK\naDasT7dk2JqP0eukJCVPTN24Zca+xJNPdzuBATm/8SdZK9lddIbjSnWRsKvTnO2r\n/rYdlPf3jM5uuJtb8+Uwwe1s+gszelGS9G/lzzq+ehWicRIq2PFcs8o3iQMfENiv\nqILJ+xjcrvms5ZPDNahWkfRx3KCg8Q+/at2n5p7XYjMPYiLKHnDC+RE2b1qT20IZ\nFhuK/fTWLmKbfYFNNga6GC4qcaZJ7x0pbm4SDTYp0tkhzcHzwKhidfNB5J2vNz6l\nUr6wiYwamFTLqcOwWo7rdvI+sSn05WQBv0QZlzFX+OAu0l7WQ7yU+noOxBhjvHds\n14+r9qcQZg2q9kG+evopYZqYXRUNNlZKo9MRBXhfrISulFAc5lRFQIXMXnglvAu+\nIpz2gomEAOcOPNNVldhKAU94GAMJd/KfN0ZP7gX3YvPzuYU6XDhag5RTohXLm18w\n5AF+ES3DOQ6ixu3DTf0D+6qrDuK+prdX8ivcdTQVNOQ+MIZeGSc6NWWOTaMGJ3lg\naZIxJUGdo6E7GBGiC1YTjgFKFbHzek1LRTh/LX3vbSudxwaG0HQxwsU9T4DWiMqa\nFkf2KteLEUA6HrR+0XlAZrhwoqAmrJ+8lCFX3V0gE9lpENfVHlFXDGyx10DpTB28\nDdjnY3F7EPWNzwf9P3oNT69CKW3Bk6VVr3ROOJtDxVu1ioWo3TaXltQ0VOnap2Pu\nsa5wfrpfwBDuAS9JCDg4ttNp2nW3F7tgXC6xPqw5pvGwUppEw9XNrqV8TZrxduuv\nrQ3NyZ7KSzIpmFlD3UwV/fGfz3UQmHS6Ng1evrUID9DjfYNfRqSGIGjDfxGtYD+j\nZ1gLJZuhjJpNtwBkKRtlNtrCWCJK2hidK/foxwD7kwAPo2I9FjpltxCRywZUs07X\nKwXTfBR9v6ij1LV6K58hFS+8ezZyZ05CeVBFkMQdclTOSfuPxlMkQOtjp8QWDj+F\nj/MYziT5KBkHvcbrjdRtUJIAi4N7zCsPZtjik918AK1WBNRVqPbrgq/XSEXMfuvs\n6JbfK0B76vdBDRtJFC1JsvnIrGbUztxXzyQwFLaR/AjVJqpVlysLWzPKWVX6/+SJ\nu1NQOl2E8P6ycyBsuGnO89p0S4F8cMRcI2X1XQsZ7/q0NBrOMaEp5T3SrWo9GiQ3\no2SBdbs3Y6MBPBtTu977Z/0RO63J3M5i2tjUiDfrFy7+VRLKr7qQ7JibohyB8QaR\n9tedgjn2f+of7PnP/PEl1cCphUZeHM7QKUMPT8dbqwmKtlYY43EHXcvNOT5IBk3X\n9lwJoZk/B2i+ZMRNSP34ztAwtxmasPt6RAWGQpWCn9qmttAHAnMfDqe7F7jVR6rS\nu58=\n-----END CERTIFICATE-----`\n\nfunc TestHandshakeRSATooBig(t *testing.T) {\n\ttestCert, _ := pem.Decode([]byte(largeRSAKeyCertPEM))\n\n\tc := &Conn{conn: &discardConn{}, config: testConfig.Clone()}\n\n\texpectedErr := \"tls: server sent certificate containing RSA key larger than 8192 bits\"\n\terr := c.verifyServerCertificate([][]byte{testCert.Bytes})\n\tif err == nil || err.Error() != expectedErr {\n\t\tt.Errorf(\"Conn.verifyServerCertificate unexpected error: want %q, got %q\", expectedErr, err)\n\t}\n\n\texpectedErr = \"tls: client sent certificate containing RSA key larger than 8192 bits\"\n\terr = c.processCertsFromClient(Certificate{Certificate: [][]byte{testCert.Bytes}})\n\tif err == nil || err.Error() != expectedErr {\n\t\tt.Errorf(\"Conn.processCertsFromClient unexpected error: want %q, got %q\", expectedErr, err)\n\t}\n}\n", "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage tls\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"time\"\n)\n\n// serverHandshakeState contains details of a server handshake in progress.\n// It's discarded once the handshake has completed.\ntype serverHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tclientHello  *clientHelloMsg\n\thello        *serverHelloMsg\n\tsuite        *cipherSuite\n\tecdheOk      bool\n\tecSignOk     bool\n\trsaDecryptOk bool\n\trsaSignOk    bool\n\tsessionState *SessionState\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tcert         *Certificate\n}\n\n// serverHandshake performs a TLS handshake as a server.\nfunc (c *Conn) serverHandshake(ctx context.Context) error {\n\tclientHello, err := c.readClientHello(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.vers == VersionTLS13 {\n\t\ths := serverHandshakeStateTLS13{\n\t\t\tc:           c,\n\t\t\tctx:         ctx,\n\t\t\tclientHello: clientHello,\n\t\t}\n\t\treturn hs.handshake()\n\t}\n\n\ths := serverHandshakeState{\n\t\tc:           c,\n\t\tctx:         ctx,\n\t\tclientHello: clientHello,\n\t}\n\treturn hs.handshake()\n}\n\nfunc (hs *serverHandshakeState) handshake() error {\n\tc := hs.c\n\n\tif err := hs.processClientHello(); err != nil {\n\t\treturn err\n\t}\n\n\t// For an overview of TLS handshaking, see RFC 5246, Section 7.3.\n\tc.buffering = true\n\tif err := hs.checkForResumption(); err != nil {\n\t\treturn err\n\t}\n\tif hs.sessionState != nil {\n\t\t// The client has included a session ticket and so we do an abbreviated handshake.\n\t\tif err := hs.doResumeHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = false\n\t\tif err := hs.readFinished(nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// The client didn't include a session ticket, or it wasn't\n\t\t// valid so we do a full handshake.\n\t\tif err := hs.pickCipherSuite(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.doFullHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = true\n\t\tc.buffering = true\n\t\tif err := hs.sendSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tc.ekm = ekmFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random)\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\n// readClientHello reads a ClientHello message and selects the protocol version.\nfunc (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error) {\n\t// clientHelloMsg is included in the transcript, but we haven't initialized\n\t// it yet. The respective handshake functions will record it themselves.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclientHello, ok := msg.(*clientHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn nil, unexpectedMessageError(clientHello, msg)\n\t}\n\n\tvar configForClient *Config\n\toriginalConfig := c.config\n\tif c.config.GetConfigForClient != nil {\n\t\tchi := clientHelloInfo(ctx, c, clientHello)\n\t\tif configForClient, err = c.config.GetConfigForClient(chi); err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn nil, err\n\t\t} else if configForClient != nil {\n\t\t\tc.config = configForClient\n\t\t}\n\t}\n\tc.ticketKeys = originalConfig.ticketKeys(configForClient)\n\n\tclientVersions := clientHello.supportedVersions\n\tif len(clientHello.supportedVersions) == 0 {\n\t\tclientVersions = supportedVersionsFromMax(clientHello.vers)\n\t}\n\tc.vers, ok = c.config.mutualVersion(roleServer, clientVersions)\n\tif !ok {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn nil, fmt.Errorf(\"tls: client offered only unsupported versions: %x\", clientVersions)\n\t}\n\tc.haveVers = true\n\tc.in.version = c.vers\n\tc.out.version = c.vers\n\n\treturn clientHello, nil\n}\n\nfunc (hs *serverHandshakeState) processClientHello() error {\n\tc := hs.c\n\n\ths.hello = new(serverHelloMsg)\n\ths.hello.vers = c.vers\n\n\tfoundCompression := false\n\t// We only support null compression, so check that the client offered it.\n\tfor _, compression := range hs.clientHello.compressionMethods {\n\t\tif compression == compressionNone {\n\t\t\tfoundCompression = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !foundCompression {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: client does not support uncompressed connections\")\n\t}\n\n\ths.hello.random = make([]byte, 32)\n\tserverRandom := hs.hello.random\n\t// Downgrade protection canaries. See RFC 8446, Section 4.1.3.\n\tmaxVers := c.config.maxSupportedVersion(roleServer)\n\tif maxVers >= VersionTLS12 && c.vers < maxVers || testingOnlyForceDowngradeCanary {\n\t\tif c.vers == VersionTLS12 {\n\t\t\tcopy(serverRandom[24:], downgradeCanaryTLS12)\n\t\t} else {\n\t\t\tcopy(serverRandom[24:], downgradeCanaryTLS11)\n\t\t}\n\t\tserverRandom = serverRandom[:24]\n\t}\n\t_, err := io.ReadFull(c.config.rand(), serverRandom)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\tif len(hs.clientHello.secureRenegotiation) != 0 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n\t}\n\n\ths.hello.extendedMasterSecret = hs.clientHello.extendedMasterSecret\n\ths.hello.secureRenegotiationSupported = hs.clientHello.secureRenegotiationSupported\n\ths.hello.compressionMethod = compressionNone\n\tif len(hs.clientHello.serverName) > 0 {\n\t\tc.serverName = hs.clientHello.serverName\n\t}\n\n\tselectedProto, err := negotiateALPN(c.config.NextProtos, hs.clientHello.alpnProtocols, false)\n\tif err != nil {\n\t\tc.sendAlert(alertNoApplicationProtocol)\n\t\treturn err\n\t}\n\ths.hello.alpnProtocol = selectedProto\n\tc.clientProtocol = selectedProto\n\n\ths.cert, err = c.config.getCertificate(clientHelloInfo(hs.ctx, c, hs.clientHello))\n\tif err != nil {\n\t\tif err == errNoCertificates {\n\t\t\tc.sendAlert(alertUnrecognizedName)\n\t\t} else {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t}\n\t\treturn err\n\t}\n\tif hs.clientHello.scts {\n\t\ths.hello.scts = hs.cert.SignedCertificateTimestamps\n\t}\n\n\ths.ecdheOk = supportsECDHE(c.config, hs.clientHello.supportedCurves, hs.clientHello.supportedPoints)\n\n\tif hs.ecdheOk && len(hs.clientHello.supportedPoints) > 0 {\n\t\t// Although omitting the ec_point_formats extension is permitted, some\n\t\t// old OpenSSL version will refuse to handshake if not present.\n\t\t//\n\t\t// Per RFC 4492, section 5.1.2, implementations MUST support the\n\t\t// uncompressed point format. See golang.org/issue/31943.\n\t\ths.hello.supportedPoints = []uint8{pointFormatUncompressed}\n\t}\n\n\tif priv, ok := hs.cert.PrivateKey.(crypto.Signer); ok {\n\t\tswitch priv.Public().(type) {\n\t\tcase *ecdsa.PublicKey:\n\t\t\ths.ecSignOk = true\n\t\tcase ed25519.PublicKey:\n\t\t\ths.ecSignOk = true\n\t\tcase *rsa.PublicKey:\n\t\t\ths.rsaSignOk = true\n\t\tdefault:\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: unsupported signing key type (%T)\", priv.Public())\n\t\t}\n\t}\n\tif priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok {\n\t\tswitch priv.Public().(type) {\n\t\tcase *rsa.PublicKey:\n\t\t\ths.rsaDecryptOk = true\n\t\tdefault:\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: unsupported decryption key type (%T)\", priv.Public())\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// negotiateALPN picks a shared ALPN protocol that both sides support in server\n// preference order. If ALPN is not configured or the peer doesn't support it,\n// it returns \"\" and no error.\nfunc negotiateALPN(serverProtos, clientProtos []string, quic bool) (string, error) {\n\tif len(serverProtos) == 0 || len(clientProtos) == 0 {\n\t\tif quic && len(serverProtos) != 0 {\n\t\t\t// RFC 9001, Section 8.1\n\t\t\treturn \"\", fmt.Errorf(\"tls: client did not request an application protocol\")\n\t\t}\n\t\treturn \"\", nil\n\t}\n\tvar http11fallback bool\n\tfor _, s := range serverProtos {\n\t\tfor _, c := range clientProtos {\n\t\t\tif s == c {\n\t\t\t\treturn s, nil\n\t\t\t}\n\t\t\tif s == \"h2\" && c == \"http/1.1\" {\n\t\t\t\thttp11fallback = true\n\t\t\t}\n\t\t}\n\t}\n\t// As a special case, let http/1.1 clients connect to h2 servers as if they\n\t// didn't support ALPN. We used not to enforce protocol overlap, so over\n\t// time a number of HTTP servers were configured with only \"h2\", but\n\t// expected to accept connections from \"http/1.1\" clients. See Issue 46310.\n\tif http11fallback {\n\t\treturn \"\", nil\n\t}\n\treturn \"\", fmt.Errorf(\"tls: client requested unsupported application protocols (%s)\", clientProtos)\n}\n\n// supportsECDHE returns whether ECDHE key exchanges can be used with this\n// pre-TLS 1.3 client.\nfunc supportsECDHE(c *Config, supportedCurves []CurveID, supportedPoints []uint8) bool {\n\tsupportsCurve := false\n\tfor _, curve := range supportedCurves {\n\t\tif c.supportsCurve(curve) {\n\t\t\tsupportsCurve = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tsupportsPointFormat := false\n\tfor _, pointFormat := range supportedPoints {\n\t\tif pointFormat == pointFormatUncompressed {\n\t\t\tsupportsPointFormat = true\n\t\t\tbreak\n\t\t}\n\t}\n\t// Per RFC 8422, Section 5.1.2, if the Supported Point Formats extension is\n\t// missing, uncompressed points are supported. If supportedPoints is empty,\n\t// the extension must be missing, as an empty extension body is rejected by\n\t// the parser. See https://go.dev/issue/49126.\n\tif len(supportedPoints) == 0 {\n\t\tsupportsPointFormat = true\n\t}\n\n\treturn supportsCurve && supportsPointFormat\n}\n\nfunc (hs *serverHandshakeState) pickCipherSuite() error {\n\tc := hs.c\n\n\tpreferenceOrder := cipherSuitesPreferenceOrder\n\tif !hasAESGCMHardwareSupport || !aesgcmPreferred(hs.clientHello.cipherSuites) {\n\t\tpreferenceOrder = cipherSuitesPreferenceOrderNoAES\n\t}\n\n\tconfigCipherSuites := c.config.cipherSuites()\n\tpreferenceList := make([]uint16, 0, len(configCipherSuites))\n\tfor _, suiteID := range preferenceOrder {\n\t\tfor _, id := range configCipherSuites {\n\t\t\tif id == suiteID {\n\t\t\t\tpreferenceList = append(preferenceList, id)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\ths.suite = selectCipherSuite(preferenceList, hs.clientHello.cipherSuites, hs.cipherSuiteOk)\n\tif hs.suite == nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: no cipher suite supported by both client and server\")\n\t}\n\tc.cipherSuite = hs.suite.id\n\n\tfor _, id := range hs.clientHello.cipherSuites {\n\t\tif id == TLS_FALLBACK_SCSV {\n\t\t\t// The client is doing a fallback connection. See RFC 7507.\n\t\t\tif hs.clientHello.vers < c.config.maxSupportedVersion(roleServer) {\n\t\t\t\tc.sendAlert(alertInappropriateFallback)\n\t\t\t\treturn errors.New(\"tls: client using inappropriate protocol fallback\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) cipherSuiteOk(c *cipherSuite) bool {\n\tif c.flags&suiteECDHE != 0 {\n\t\tif !hs.ecdheOk {\n\t\t\treturn false\n\t\t}\n\t\tif c.flags&suiteECSign != 0 {\n\t\t\tif !hs.ecSignOk {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if !hs.rsaSignOk {\n\t\t\treturn false\n\t\t}\n\t} else if !hs.rsaDecryptOk {\n\t\treturn false\n\t}\n\tif hs.c.vers < VersionTLS12 && c.flags&suiteTLS12 != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// checkForResumption reports whether we should perform resumption on this connection.\nfunc (hs *serverHandshakeState) checkForResumption() error {\n\tc := hs.c\n\n\tif c.config.SessionTicketsDisabled {\n\t\treturn nil\n\t}\n\n\tvar sessionState *SessionState\n\tif c.config.UnwrapSession != nil {\n\t\tss, err := c.config.UnwrapSession(hs.clientHello.sessionTicket, c.connectionStateLocked())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif ss == nil {\n\t\t\treturn nil\n\t\t}\n\t\tsessionState = ss\n\t} else {\n\t\tplaintext := c.config.decryptTicket(hs.clientHello.sessionTicket, c.ticketKeys)\n\t\tif plaintext == nil {\n\t\t\treturn nil\n\t\t}\n\t\tss, err := ParseSessionState(plaintext)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tsessionState = ss\n\t}\n\n\t// TLS 1.2 tickets don't natively have a lifetime, but we want to avoid\n\t// re-wrapping the same master secret in different tickets over and over for\n\t// too long, weakening forward secrecy.\n\tcreatedAt := time.Unix(int64(sessionState.createdAt), 0)\n\tif c.config.time().Sub(createdAt) > maxSessionTicketLifetime {\n\t\treturn nil\n\t}\n\n\t// Never resume a session for a different TLS version.\n\tif c.vers != sessionState.version {\n\t\treturn nil\n\t}\n\n\tcipherSuiteOk := false\n\t// Check that the client is still offering the ciphersuite in the session.\n\tfor _, id := range hs.clientHello.cipherSuites {\n\t\tif id == sessionState.cipherSuite {\n\t\t\tcipherSuiteOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !cipherSuiteOk {\n\t\treturn nil\n\t}\n\n\t// Check that we also support the ciphersuite from the session.\n\tsuite := selectCipherSuite([]uint16{sessionState.cipherSuite},\n\t\tc.config.cipherSuites(), hs.cipherSuiteOk)\n\tif suite == nil {\n\t\treturn nil\n\t}\n\n\tsessionHasClientCerts := len(sessionState.peerCertificates) != 0\n\tneedClientCerts := requiresClientCert(c.config.ClientAuth)\n\tif needClientCerts && !sessionHasClientCerts {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.ClientAuth == NoClientCert {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.time().After(sessionState.peerCertificates[0].NotAfter) {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.ClientAuth >= VerifyClientCertIfGiven &&\n\t\tlen(sessionState.verifiedChains) == 0 {\n\t\treturn nil\n\t}\n\n\t// RFC 7627, Section 5.3\n\tif !sessionState.extMasterSecret && hs.clientHello.extendedMasterSecret {\n\t\treturn nil\n\t}\n\tif sessionState.extMasterSecret && !hs.clientHello.extendedMasterSecret {\n\t\t// Aborting is somewhat harsh, but it's a MUST and it would indicate a\n\t\t// weird downgrade in client capabilities.\n\t\treturn errors.New(\"tls: session supported extended_master_secret but client does not\")\n\t}\n\n\tc.peerCertificates = sessionState.peerCertificates\n\tc.ocspResponse = sessionState.ocspResponse\n\tc.scts = sessionState.scts\n\tc.verifiedChains = sessionState.verifiedChains\n\tc.extMasterSecret = sessionState.extMasterSecret\n\ths.sessionState = sessionState\n\ths.suite = suite\n\tc.didResume = true\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) doResumeHandshake() error {\n\tc := hs.c\n\n\ths.hello.cipherSuite = hs.suite.id\n\tc.cipherSuite = hs.suite.id\n\t// We echo the client's session ID in the ServerHello to let it know\n\t// that we're doing a resumption.\n\ths.hello.sessionId = hs.clientHello.sessionId\n\t// We always send a new session ticket, even if it wraps the same master\n\t// secret and it's potentially encrypted with the same key, to help the\n\t// client avoid cross-connection tracking from a network observer.\n\ths.hello.ticketSupported = true\n\ths.finishedHash = newFinishedHash(c.vers, hs.suite)\n\ths.finishedHash.discardHandshakeBuffer()\n\tif err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.masterSecret = hs.sessionState.secret\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) doFullHandshake() error {\n\tc := hs.c\n\n\tif hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 {\n\t\ths.hello.ocspStapling = true\n\t}\n\n\ths.hello.ticketSupported = hs.clientHello.ticketSupported && !c.config.SessionTicketsDisabled\n\ths.hello.cipherSuite = hs.suite.id\n\n\ths.finishedHash = newFinishedHash(hs.c.vers, hs.suite)\n\tif c.config.ClientAuth == NoClientCert {\n\t\t// No need to keep a full record of the handshake if client\n\t\t// certificates won't be used.\n\t\ths.finishedHash.discardHandshakeBuffer()\n\t}\n\tif err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcertMsg := new(certificateMsg)\n\tcertMsg.certificates = hs.cert.Certificate\n\tif _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif hs.hello.ocspStapling {\n\t\tcertStatus := new(certificateStatusMsg)\n\t\tcertStatus.response = hs.cert.OCSPStaple\n\t\tif _, err := hs.c.writeHandshakeRecord(certStatus, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tkeyAgreement := hs.suite.ka(c.vers)\n\tskx, err := keyAgreement.generateServerKeyExchange(c.config, hs.cert, hs.clientHello, hs.hello)\n\tif err != nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\tif skx != nil {\n\t\tif _, err := hs.c.writeHandshakeRecord(skx, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar certReq *certificateRequestMsg\n\tif c.config.ClientAuth >= RequestClientCert {\n\t\t// Request a client certificate\n\t\tcertReq = new(certificateRequestMsg)\n\t\tcertReq.certificateTypes = []byte{\n\t\t\tbyte(certTypeRSASign),\n\t\t\tbyte(certTypeECDSASign),\n\t\t}\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tcertReq.hasSignatureAlgorithm = true\n\t\t\tcertReq.supportedSignatureAlgorithms = supportedSignatureAlgorithms()\n\t\t}\n\n\t\t// An empty list of certificateAuthorities signals to\n\t\t// the client that it may send any certificate in response\n\t\t// to our request. When we know the CAs we trust, then\n\t\t// we can send them down, so that the client can choose\n\t\t// an appropriate certificate to give to us.\n\t\tif c.config.ClientCAs != nil {\n\t\t\tcertReq.certificateAuthorities = c.config.ClientCAs.Subjects()\n\t\t}\n\t\tif _, err := hs.c.writeHandshakeRecord(certReq, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\thelloDone := new(serverHelloDoneMsg)\n\tif _, err := hs.c.writeHandshakeRecord(helloDone, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := c.flush(); err != nil {\n\t\treturn err\n\t}\n\n\tvar pub crypto.PublicKey // public key for client auth, if any\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If we requested a client certificate, then the client must send a\n\t// certificate message, even if it's empty.\n\tif c.config.ClientAuth >= RequestClientCert {\n\t\tcertMsg, ok := msg.(*certificateMsg)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn unexpectedMessageError(certMsg, msg)\n\t\t}\n\n\t\tif err := c.processCertsFromClient(Certificate{\n\t\t\tCertificate: certMsg.certificates,\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(certMsg.certificates) != 0 {\n\t\t\tpub = c.peerCertificates[0].PublicKey\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Get client key exchange\n\tckx, ok := msg.(*clientKeyExchangeMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(ckx, msg)\n\t}\n\n\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(c.config, hs.cert, ckx, c.vers)\n\tif err != nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\tif hs.hello.extendedMasterSecret {\n\t\tc.extMasterSecret = true\n\t\ths.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.finishedHash.Sum())\n\t} else {\n\t\ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.clientHello.random, hs.hello.random)\n\t}\n\tif err := c.config.writeKeyLog(keyLogLabelTLS12, hs.clientHello.random, hs.masterSecret); err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\t// If we received a client cert in response to our certificate request message,\n\t// the client will send us a certificateVerifyMsg immediately after the\n\t// clientKeyExchangeMsg. This message is a digest of all preceding\n\t// handshake-layer messages that is signed using the private key corresponding\n\t// to the client's certificate. This allows us to verify that the client is in\n\t// possession of the private key of the certificate.\n\tif len(c.peerCertificates) > 0 {\n\t\t// certificateVerifyMsg is included in the transcript, but not until\n\t\t// after we verify the handshake signature, since the state before\n\t\t// this message was sent is used.\n\t\tmsg, err = c.readHandshake(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcertVerify, ok := msg.(*certificateVerifyMsg)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn unexpectedMessageError(certVerify, msg)\n\t\t}\n\n\t\tvar sigType uint8\n\t\tvar sigHash crypto.Hash\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tif !isSupportedSignatureAlgorithm(certVerify.signatureAlgorithm, certReq.supportedSignatureAlgorithms) {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn errors.New(\"tls: client certificate used with invalid signature algorithm\")\n\t\t\t}\n\t\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(certVerify.signatureAlgorithm)\n\t\t\tif err != nil {\n\t\t\t\treturn c.sendAlert(alertInternalError)\n\t\t\t}\n\t\t} else {\n\t\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(pub)\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tsigned := hs.finishedHash.hashForClientCertificate(sigType, sigHash)\n\t\tif err := verifyHandshakeSignature(sigType, pub, sigHash, signed, certVerify.signature); err != nil {\n\t\t\tc.sendAlert(alertDecryptError)\n\t\t\treturn errors.New(\"tls: invalid signature by the client certificate: \" + err.Error())\n\t\t}\n\n\t\tif err := transcriptMsg(certVerify, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.finishedHash.discardHandshakeBuffer()\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) establishKeys() error {\n\tc := hs.c\n\n\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n\t\tkeysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n\n\tvar clientCipher, serverCipher any\n\tvar clientHash, serverHash hash.Hash\n\n\tif hs.suite.aead == nil {\n\t\tclientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)\n\t\tclientHash = hs.suite.mac(clientMAC)\n\t\tserverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)\n\t\tserverHash = hs.suite.mac(serverMAC)\n\t} else {\n\t\tclientCipher = hs.suite.aead(clientKey, clientIV)\n\t\tserverCipher = hs.suite.aead(serverKey, serverIV)\n\t}\n\n\tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n\tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) readFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.readChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\n\t// finishedMsg is included in the transcript, but not until after we\n\t// check the client version, since the state before this message was\n\t// sent is used during verification.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tclientFinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(clientFinished, msg)\n\t}\n\n\tverify := hs.finishedHash.clientSum(hs.masterSecret)\n\tif len(verify) != len(clientFinished.verifyData) ||\n\t\tsubtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: client's Finished message is incorrect\")\n\t}\n\n\tif err := transcriptMsg(clientFinished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, verify)\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) sendSessionTicket() error {\n\tif !hs.hello.ticketSupported {\n\t\treturn nil\n\t}\n\n\tc := hs.c\n\tm := new(newSessionTicketMsg)\n\n\tstate, err := c.sessionState()\n\tif err != nil {\n\t\treturn err\n\t}\n\tstate.secret = hs.masterSecret\n\tif hs.sessionState != nil {\n\t\t// If this is re-wrapping an old key, then keep\n\t\t// the original time it was created.\n\t\tstate.createdAt = hs.sessionState.createdAt\n\t}\n\tif c.config.WrapSession != nil {\n\t\tm.ticket, err = c.config.WrapSession(c.connectionStateLocked(), state)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tstateBytes, err := state.Bytes()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.ticket, err = c.config.encryptTicket(stateBytes, c.ticketKeys)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(m, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) sendFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.writeChangeCipherRecord(); err != nil {\n\t\treturn err\n\t}\n\n\tfinished := new(finishedMsg)\n\tfinished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)\n\tif _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, finished.verifyData)\n\n\treturn nil\n}\n\n// processCertsFromClient takes a chain of client certificates either from a\n// Certificates message and verifies them.\nfunc (c *Conn) processCertsFromClient(certificate Certificate) error {\n\tcertificates := certificate.Certificate\n\tcerts := make([]*x509.Certificate, len(certificates))\n\tvar err error\n\tfor i, asn1Data := range certificates {\n\t\tif certs[i], err = x509.ParseCertificate(asn1Data); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: failed to parse client certificate: \" + err.Error())\n\t\t}\n\t\tif certs[i].PublicKeyAlgorithm == x509.RSA && certs[i].PublicKey.(*rsa.PublicKey).N.BitLen() > maxRSAKeySize {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn fmt.Errorf(\"tls: client sent certificate containing RSA key larger than %d bits\", maxRSAKeySize)\n\t\t}\n\t}\n\n\tif len(certs) == 0 && requiresClientCert(c.config.ClientAuth) {\n\t\tif c.vers == VersionTLS13 {\n\t\t\tc.sendAlert(alertCertificateRequired)\n\t\t} else {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t}\n\t\treturn errors.New(\"tls: client didn't provide a certificate\")\n\t}\n\n\tif c.config.ClientAuth >= VerifyClientCertIfGiven && len(certs) > 0 {\n\t\topts := x509.VerifyOptions{\n\t\t\tRoots:         c.config.ClientCAs,\n\t\t\tCurrentTime:   c.config.time(),\n\t\t\tIntermediates: x509.NewCertPool(),\n\t\t\tKeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},\n\t\t}\n\n\t\tfor _, cert := range certs[1:] {\n\t\t\topts.Intermediates.AddCert(cert)\n\t\t}\n\n\t\tchains, err := certs[0].Verify(opts)\n\t\tif err != nil {\n\t\t\tvar errCertificateInvalid x509.CertificateInvalidError\n\t\t\tif errors.As(err, &x509.UnknownAuthorityError{}) {\n\t\t\t\tc.sendAlert(alertUnknownCA)\n\t\t\t} else if errors.As(err, &errCertificateInvalid) && errCertificateInvalid.Reason == x509.Expired {\n\t\t\t\tc.sendAlert(alertCertificateExpired)\n\t\t\t} else {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t}\n\t\t\treturn &CertificateVerificationError{UnverifiedCertificates: certs, Err: err}\n\t\t}\n\n\t\tc.verifiedChains = chains\n\t}\n\n\tc.peerCertificates = certs\n\tc.ocspResponse = certificate.OCSPStaple\n\tc.scts = certificate.SignedCertificateTimestamps\n\n\tif len(certs) > 0 {\n\t\tswitch certs[0].PublicKey.(type) {\n\t\tcase *ecdsa.PublicKey, *rsa.PublicKey, ed25519.PublicKey:\n\t\tdefault:\n\t\t\tc.sendAlert(alertUnsupportedCertificate)\n\t\t\treturn fmt.Errorf(\"tls: client certificate contains an unsupported public key of type %T\", certs[0].PublicKey)\n\t\t}\n\t}\n\n\tif c.config.VerifyPeerCertificate != nil {\n\t\tif err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc clientHelloInfo(ctx context.Context, c *Conn, clientHello *clientHelloMsg) *ClientHelloInfo {\n\tsupportedVersions := clientHello.supportedVersions\n\tif len(clientHello.supportedVersions) == 0 {\n\t\tsupportedVersions = supportedVersionsFromMax(clientHello.vers)\n\t}\n\n\treturn &ClientHelloInfo{\n\t\tCipherSuites:      clientHello.cipherSuites,\n\t\tServerName:        clientHello.serverName,\n\t\tSupportedCurves:   clientHello.supportedCurves,\n\t\tSupportedPoints:   clientHello.supportedPoints,\n\t\tSignatureSchemes:  clientHello.supportedSignatureAlgorithms,\n\t\tSupportedProtos:   clientHello.alpnProtocols,\n\t\tSupportedVersions: supportedVersions,\n\t\tConn:              c.conn,\n\t\tconfig:            c.config,\n\t\tctx:               ctx,\n\t}\n}\n"], "filenames": ["src/crypto/tls/handshake_client.go", "src/crypto/tls/handshake_client_test.go", "src/crypto/tls/handshake_server.go"], "buggy_code_start_loc": [938, 2723, 866], "buggy_code_end_loc": [948, 2723, 866], "fixing_code_start_loc": [939, 2724, 867], "fixing_code_end_loc": [957, 2802, 871], "type": "CWE-770", "message": "go-libp2p is the Go implementation of the libp2p Networking Stack. Prior to versions 0.27.8, 0.28.2, and 0.29.1 malicious peer can use large RSA keys to run a resource exhaustion attack & force a node to spend time doing signature verification of the large key. This vulnerability is present in the core/crypto module of go-libp2p and can occur during the Noise handshake and the libp2p x509 extension verification step. To prevent this attack, go-libp2p versions 0.27.8, 0.28.2, and 0.29.1 restrict RSA keys to <= 8192 bits. To protect one's application, it is necessary to update to these patch releases and to use the updated Go compiler in 1.20.7 or 1.19.12. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-39533", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-08T19:15:10.657", "lastModified": "2023-10-31T19:08:26.883", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "go-libp2p is the Go implementation of the libp2p Networking Stack. Prior to versions 0.27.8, 0.28.2, and 0.29.1 malicious peer can use large RSA keys to run a resource exhaustion attack & force a node to spend time doing signature verification of the large key. This vulnerability is present in the core/crypto module of go-libp2p and can occur during the Noise handshake and the libp2p x509 extension verification step. To prevent this attack, go-libp2p versions 0.27.8, 0.28.2, and 0.29.1 restrict RSA keys to <= 8192 bits. To protect one's application, it is necessary to update to these patch releases and to use the updated Go compiler in 1.20.7 or 1.19.12. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libp2p:go-libp2p:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.27.8", "matchCriteriaId": "7E5E9196-C94D-4E08-93BA-AC1141ECE878"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libp2p:go-libp2p:*:*:*:*:*:go:*:*", "versionStartIncluding": "0.28.0", "versionEndExcluding": "0.28.2", "matchCriteriaId": "609AAD6A-5165-4995-B994-2F49D8751607"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libp2p:go-libp2p:0.29.0:*:*:*:*:go:*:*", "matchCriteriaId": "E7425EF5-C9F9-4834-B742-7F1117C974C1"}]}]}], "references": [{"url": "https://github.com/golang/go/commit/2350afd2e8ab054390e284c95d5b089c142db017", "source": "security-advisories@github.com", "tags": ["Not Applicable", "Patch"]}, {"url": "https://github.com/golang/go/issues/61460", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Not Applicable", "Vendor Advisory"]}, {"url": "https://github.com/libp2p/go-libp2p/commit/0cce607219f3710addc7e18672cffd1f1d912fbb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libp2p/go-libp2p/commit/445be526aea4ee0b1fa5388aa65d32b2816d3a00", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libp2p/go-libp2p/commit/e30fcf7dfd4715ed89a5e68d7a4f774d3b9aa92d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libp2p/go-libp2p/pull/2454", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/libp2p/go-libp2p/security/advisories/GHSA-876p-8259-xjgg", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/quic-go/quic-go/pull/4012", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/golang/go/commit/2350afd2e8ab054390e284c95d5b089c142db017"}}